[
  {
    "name": "AbstractUnivariateRealOptimizer.computeObjectiveValue",
    "class_name": "org.apache.commons.math.optimization.univariate.AbstractUnivariateRealOptimizer",
    "signature": "org.apache.commons.math.optimization.univariate.AbstractUnivariateRealOptimizer.computeObjectiveValue(double)",
    "snippet": "    protected double computeObjectiveValue(double point)\n        throws FunctionEvaluationException {\n        try {\n            evaluations.incrementCount();\n        } catch (MaxCountExceededException e) {\n            throw new TooManyEvaluationsException(e.getMax());\n        }\n        return function.value(point);\n    }",
    "comment": " Compute the objective function value.  @param point Point at which the objective function must be evaluated. @return the objective function value at specified point. @throws FunctionEvaluationException if the function cannot be evaluated. @throws TooManyEvaluationsException if the maximal number of evaluations is exceeded. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "AbstractUnivariateRealOptimizer.getConvergenceChecker",
    "class_name": "org.apache.commons.math.optimization.univariate.AbstractUnivariateRealOptimizer",
    "signature": "org.apache.commons.math.optimization.univariate.AbstractUnivariateRealOptimizer.getConvergenceChecker()",
    "snippet": "    public ConvergenceChecker<UnivariateRealPointValuePair> getConvergenceChecker() {\n        return checker;\n    }",
    "comment": " {@inheritDoc} ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "AbstractUnivariateRealOptimizer.getEvaluations",
    "class_name": "org.apache.commons.math.optimization.univariate.AbstractUnivariateRealOptimizer",
    "signature": "org.apache.commons.math.optimization.univariate.AbstractUnivariateRealOptimizer.getEvaluations()",
    "snippet": "    public int getEvaluations() {\n        return evaluations.getCount();\n    }",
    "comment": "{@inheritDoc} */",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "AbstractUnivariateRealOptimizer.getGoalType",
    "class_name": "org.apache.commons.math.optimization.univariate.AbstractUnivariateRealOptimizer",
    "signature": "org.apache.commons.math.optimization.univariate.AbstractUnivariateRealOptimizer.getGoalType()",
    "snippet": "    public GoalType getGoalType() {\n        return goal;\n    }",
    "comment": " @return the optimization type. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "AbstractUnivariateRealOptimizer.getMax",
    "class_name": "org.apache.commons.math.optimization.univariate.AbstractUnivariateRealOptimizer",
    "signature": "org.apache.commons.math.optimization.univariate.AbstractUnivariateRealOptimizer.getMax()",
    "snippet": "    public double getMax() {\n        return searchMax;\n    }",
    "comment": " @return the higher end of the search interval. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "AbstractUnivariateRealOptimizer.getMaxEvaluations",
    "class_name": "org.apache.commons.math.optimization.univariate.AbstractUnivariateRealOptimizer",
    "signature": "org.apache.commons.math.optimization.univariate.AbstractUnivariateRealOptimizer.getMaxEvaluations()",
    "snippet": "    public int getMaxEvaluations() {\n        return evaluations.getMaximalCount();\n    }",
    "comment": "{@inheritDoc} */",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "AbstractUnivariateRealOptimizer.getMin",
    "class_name": "org.apache.commons.math.optimization.univariate.AbstractUnivariateRealOptimizer",
    "signature": "org.apache.commons.math.optimization.univariate.AbstractUnivariateRealOptimizer.getMin()",
    "snippet": "    public double getMin() {\n        return searchMin;\n    }",
    "comment": " @return the lower end of the search interval. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "AbstractUnivariateRealOptimizer.getStartValue",
    "class_name": "org.apache.commons.math.optimization.univariate.AbstractUnivariateRealOptimizer",
    "signature": "org.apache.commons.math.optimization.univariate.AbstractUnivariateRealOptimizer.getStartValue()",
    "snippet": "    public double getStartValue() {\n        return searchStart;\n    }",
    "comment": " @return the initial guess. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "AbstractUnivariateRealOptimizer.optimize",
    "class_name": "org.apache.commons.math.optimization.univariate.AbstractUnivariateRealOptimizer",
    "signature": "org.apache.commons.math.optimization.univariate.AbstractUnivariateRealOptimizer.optimize(UnivariateRealFunction,GoalType,double,double)",
    "snippet": "    public UnivariateRealPointValuePair optimize(UnivariateRealFunction f,\n                                                 GoalType goalType,\n                                                 double min, double max)\n        throws FunctionEvaluationException {\n        return optimize(f, goalType, min, max, min + 0.5 * (max - min));\n    }",
    "comment": "{@inheritDoc} */",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "AbstractUnivariateRealOptimizer.optimize",
    "class_name": "org.apache.commons.math.optimization.univariate.AbstractUnivariateRealOptimizer",
    "signature": "org.apache.commons.math.optimization.univariate.AbstractUnivariateRealOptimizer.optimize(UnivariateRealFunction,GoalType,double,double,double)",
    "snippet": "    public UnivariateRealPointValuePair optimize(UnivariateRealFunction f,\n                                                 GoalType goalType,\n                                                 double min, double max,\n                                                 double startValue)\n        throws FunctionEvaluationException {\n        // Checks.\n        if (f == null) {\n            throw new NullArgumentException();\n        }\n        if (goalType == null) {\n            throw new NullArgumentException();\n        }\n\n        // Reset.\n        searchMin = min;\n        searchMax = max;\n        searchStart = startValue;\n        goal = goalType;\n        function = f;\n        evaluations.resetCount();\n\n        // Perform computation.\n        return doOptimize();\n    }",
    "comment": "{@inheritDoc} */",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "AbstractUnivariateRealOptimizer.setMaxEvaluations",
    "class_name": "org.apache.commons.math.optimization.univariate.AbstractUnivariateRealOptimizer",
    "signature": "org.apache.commons.math.optimization.univariate.AbstractUnivariateRealOptimizer.setMaxEvaluations(int)",
    "snippet": "    public void setMaxEvaluations(int maxEvaluations) {\n        evaluations.setMaximalCount(maxEvaluations);\n    }",
    "comment": "{@inheritDoc} */",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "BrentOptimizer.BrentOptimizer",
    "class_name": "org.apache.commons.math.optimization.univariate.BrentOptimizer",
    "signature": "org.apache.commons.math.optimization.univariate.BrentOptimizer.BrentOptimizer(double,double)",
    "snippet": "    public BrentOptimizer(double rel,\n                          double abs) {\n        if (rel < MIN_RELATIVE_TOLERANCE) {\n            throw new NumberIsTooSmallException(rel, MIN_RELATIVE_TOLERANCE, true);\n        }\n        if (abs <= 0) {\n            throw new NotStrictlyPositiveException(abs);\n        }\n        relativeThreshold = rel;\n        absoluteThreshold = abs;\n    }",
    "comment": " The arguments are used implement the original stopping criterion of Brent's algorithm. {@code abs} and {@code rel} define a tolerance {@code tol = rel |x| + abs}. {@code rel} should be no smaller than <em>2 macheps</em> and preferably not much less than <em>sqrt(macheps)</em>, where <em>macheps</em> is the relative machine precision. {@code abs} must be positive.  @param rel Relative threshold. @param abs Absolute threshold. @throws NotStrictlyPositiveException if {@code abs <= 0}. @throws NumberIsTooSmallException if {@code rel < 2 * Math.ulp(1d)}. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "BrentOptimizer.doOptimize",
    "class_name": "org.apache.commons.math.optimization.univariate.BrentOptimizer",
    "signature": "org.apache.commons.math.optimization.univariate.BrentOptimizer.doOptimize()",
    "snippet": "    protected UnivariateRealPointValuePair doOptimize()\n        throws FunctionEvaluationException {\n        final boolean isMinim = getGoalType() == GoalType.MINIMIZE;\n        final double lo = getMin();\n        final double mid = getStartValue();\n        final double hi = getMax();\n\n        // Optional additional convergence criteria.\n        final ConvergenceChecker<UnivariateRealPointValuePair> checker\n            = getConvergenceChecker();\n\n        double a;\n        double b;\n        if (lo < hi) {\n            a = lo;\n            b = hi;\n        } else {\n            a = hi;\n            b = lo;\n        }\n\n        double x = mid;\n        double v = x;\n        double w = x;\n        double d = 0;\n        double e = 0;\n        double fx = computeObjectiveValue(x);\n        if (!isMinim) {\n            fx = -fx;\n        }\n        double fv = fx;\n        double fw = fx;\n\n        UnivariateRealPointValuePair previous = null;\n        UnivariateRealPointValuePair current\n            = new UnivariateRealPointValuePair(x, isMinim ? fx : -fx);\n\n        int iter = 0;\n        while (true) {\n            final double m = 0.5 * (a + b);\n            final double tol1 = relativeThreshold * FastMath.abs(x) + absoluteThreshold;\n            final double tol2 = 2 * tol1;\n\n            // Default stopping criterion.\n            final boolean stop = FastMath.abs(x - m) <= tol2 - 0.5 * (b - a);\n            if (!stop) {\n                double p = 0;\n                double q = 0;\n                double r = 0;\n                double u = 0;\n\n                if (FastMath.abs(e) > tol1) { // Fit parabola.\n                    r = (x - w) * (fx - fv);\n                    q = (x - v) * (fx - fw);\n                    p = (x - v) * q - (x - w) * r;\n                    q = 2 * (q - r);\n\n                    if (q > 0) {\n                        p = -p;\n                    } else {\n                        q = -q;\n                    }\n\n                    r = e;\n                    e = d;\n\n                    if (p > q * (a - x) &&\n                        p < q * (b - x) &&\n                        FastMath.abs(p) < FastMath.abs(0.5 * q * r)) {\n                        // Parabolic interpolation step.\n                        d = p / q;\n                        u = x + d;\n\n                        // f must not be evaluated too close to a or b.\n                        if (u - a < tol2 || b - u < tol2) {\n                            if (x <= m) {\n                                d = tol1;\n                            } else {\n                                d = -tol1;\n                            }\n                        }\n                    } else {\n                        // Golden section step.\n                        if (x < m) {\n                            e = b - x;\n                        } else {\n                            e = a - x;\n                        }\n                        d = GOLDEN_SECTION * e;\n                    }\n                } else {\n                    // Golden section step.\n                    if (x < m) {\n                        e = b - x;\n                    } else {\n                        e = a - x;\n                    }\n                    d = GOLDEN_SECTION * e;\n                }\n\n                // Update by at least \"tol1\".\n                if (FastMath.abs(d) < tol1) {\n                    if (d >= 0) {\n                        u = x + tol1;\n                    } else {\n                        u = x - tol1;\n                    }\n                } else {\n                    u = x + d;\n                }\n\n                double fu = computeObjectiveValue(u);\n                if (!isMinim) {\n                    fu = -fu;\n                }\n\n                // Update a, b, v, w and x.\n                if (fu <= fx) {\n                    if (u < x) {\n                        b = x;\n                    } else {\n                        a = x;\n                    }\n                    v = w;\n                    fv = fw;\n                    w = x;\n                    fw = fx;\n                    x = u;\n                    fx = fu;\n                } else {\n                    if (u < x) {\n                        a = u;\n                    } else {\n                        b = u;\n                    }\n                    if (fu <= fw ||\n                        MathUtils.equals(w, x)) {\n                        v = w;\n                        fv = fw;\n                        w = u;\n                        fw = fu;\n                    } else if (fu <= fv ||\n                               MathUtils.equals(v, x) ||\n                               MathUtils.equals(v, w)) {\n                        v = u;\n                        fv = fu;\n                    }\n                }\n\n                previous = current;\n                current = new UnivariateRealPointValuePair(x, isMinim ? fx : -fx);\n\n                // User-defined convergence checker.\n                if (checker != null) {\n                    if (checker.converged(iter, previous, current)) {\n                        return current;\n                    }\n                }\n            } else { // Default termination (Brent's criterion).\n                return current;\n            }\n            ++iter;\n        }\n    }",
    "comment": "{@inheritDoc} */",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "MultiStartUnivariateRealOptimizer.MultiStartUnivariateRealOptimizer",
    "class_name": "org.apache.commons.math.optimization.univariate.MultiStartUnivariateRealOptimizer",
    "signature": "org.apache.commons.math.optimization.univariate.MultiStartUnivariateRealOptimizer.MultiStartUnivariateRealOptimizer(BaseUnivariateRealOptimizer,int,RandomGenerator)",
    "snippet": "    public MultiStartUnivariateRealOptimizer(final BaseUnivariateRealOptimizer<FUNC> optimizer,\n                                             final int starts,\n                                             final RandomGenerator generator) {\n        this.optimizer = optimizer;\n        this.starts = starts;\n        this.generator = generator;\n    }",
    "comment": " Create a multi-start optimizer from a single-start optimizer.  @param optimizer Single-start optimizer to wrap. @param starts Number of starts to perform (including the first one), multi-start is disabled if value is less than or equal to 1. @param generator Random generator to use for restarts. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "MultiStartUnivariateRealOptimizer.sortPairs",
    "class_name": "org.apache.commons.math.optimization.univariate.MultiStartUnivariateRealOptimizer",
    "signature": "org.apache.commons.math.optimization.univariate.MultiStartUnivariateRealOptimizer.sortPairs(GoalType)",
    "snippet": "    private void sortPairs(final GoalType goal) {\n        Arrays.sort(optima, new Comparator<UnivariateRealPointValuePair>() {\n                public int compare(final UnivariateRealPointValuePair o1,\n                                   final UnivariateRealPointValuePair o2) {\n                    if (o1 == null) {\n                        return (o2 == null) ? 0 : 1;\n                    } else if (o2 == null) {\n                        return -1;\n                    }\n                    final double v1 = o1.getValue();\n                    final double v2 = o2.getValue();\n                    return (goal == GoalType.MINIMIZE) ?\n                        Double.compare(v1, v2) : Double.compare(v2, v1);\n                }\n            });\n    }",
    "comment": " Sort the optima from best to worst, followed by {@code null} elements.  @param goal Goal type. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "UnivariateRealPointValuePair.UnivariateRealPointValuePair",
    "class_name": "org.apache.commons.math.optimization.univariate.UnivariateRealPointValuePair",
    "signature": "org.apache.commons.math.optimization.univariate.UnivariateRealPointValuePair.UnivariateRealPointValuePair(double,double)",
    "snippet": "    public UnivariateRealPointValuePair(final double point,\n                                        final double value) {\n        this.point = point;\n        this.value = value;\n    }",
    "comment": " Build a point/objective function value pair.  @param point Point. @param value Value of an objective function at the point ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "UnivariateRealPointValuePair.getPoint",
    "class_name": "org.apache.commons.math.optimization.univariate.UnivariateRealPointValuePair",
    "signature": "org.apache.commons.math.optimization.univariate.UnivariateRealPointValuePair.getPoint()",
    "snippet": "    public double getPoint() {\n        return point;\n    }",
    "comment": " Get the point.  @return the point. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "UnivariateRealPointValuePair.getValue",
    "class_name": "org.apache.commons.math.optimization.univariate.UnivariateRealPointValuePair",
    "signature": "org.apache.commons.math.optimization.univariate.UnivariateRealPointValuePair.getValue()",
    "snippet": "    public double getValue() {\n        return value;\n    }",
    "comment": " Get the value of the objective function.  @return the stored value of the objective function. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "FastMath.abs",
    "class_name": "org.apache.commons.math.util.FastMath",
    "signature": "org.apache.commons.math.util.FastMath.abs(double)",
    "snippet": "    public static double abs(double x) {\n        return (x < 0.0) ? -x : x;\n    }",
    "comment": " Absolute value. @param x number from which absolute value is requested @return abs(x) ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "FastMath.abs",
    "class_name": "org.apache.commons.math.util.FastMath",
    "signature": "org.apache.commons.math.util.FastMath.abs(long)",
    "snippet": "    public static long abs(final long x) {\n        return (x < 0l) ? -x : x;\n    }",
    "comment": " Absolute value. @param x number from which absolute value is requested @return abs(x) ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "FastMath.buildSinCosTables",
    "class_name": "org.apache.commons.math.util.FastMath",
    "signature": "org.apache.commons.math.util.FastMath.buildSinCosTables()",
    "snippet": "    private static void buildSinCosTables() {\n        final double result[] = new double[2];\n\n        /* Use taylor series for 0 <= x <= 6/8 */\n        for (int i = 0; i < 7; i++) {\n            double x = i / 8.0;\n\n            slowSin(x, result);\n            SINE_TABLE_A[i] = result[0];\n            SINE_TABLE_B[i] = result[1];\n\n            slowCos(x, result);\n            COSINE_TABLE_A[i] = result[0];\n            COSINE_TABLE_B[i] = result[1];\n        }\n\n        /* Use angle addition formula to complete table to 13/8, just beyond pi/2 */\n        for (int i = 7; i < 14; i++) {\n            double xs[] = new double[2];\n            double ys[] = new double[2];\n            double as[] = new double[2];\n            double bs[] = new double[2];\n            double temps[] = new double[2];\n\n            if ( (i & 1) == 0) {\n                // Even, use double angle\n                xs[0] = SINE_TABLE_A[i/2];\n                xs[1] = SINE_TABLE_B[i/2];\n                ys[0] = COSINE_TABLE_A[i/2];\n                ys[1] = COSINE_TABLE_B[i/2];\n\n                /* compute sine */\n                splitMult(xs, ys, result);\n                SINE_TABLE_A[i] = result[0] * 2.0;\n                SINE_TABLE_B[i] = result[1] * 2.0;\n\n                /* Compute cosine */\n                splitMult(ys, ys, as);\n                splitMult(xs, xs, temps);\n                temps[0] = -temps[0];\n                temps[1] = -temps[1];\n                splitAdd(as, temps, result);\n                COSINE_TABLE_A[i] = result[0];\n                COSINE_TABLE_B[i] = result[1];\n            } else {\n                xs[0] = SINE_TABLE_A[i/2];\n                xs[1] = SINE_TABLE_B[i/2];\n                ys[0] = COSINE_TABLE_A[i/2];\n                ys[1] = COSINE_TABLE_B[i/2];\n                as[0] = SINE_TABLE_A[i/2+1];\n                as[1] = SINE_TABLE_B[i/2+1];\n                bs[0] = COSINE_TABLE_A[i/2+1];\n                bs[1] = COSINE_TABLE_B[i/2+1];\n\n                /* compute sine */\n                splitMult(xs, bs, temps);\n                splitMult(ys, as, result);\n                splitAdd(result, temps, result);\n                SINE_TABLE_A[i] = result[0];\n                SINE_TABLE_B[i] = result[1];\n\n                /* Compute cosine */\n                splitMult(ys, bs, result);\n                splitMult(xs, as, temps);\n                temps[0] = -temps[0];\n                temps[1] = -temps[1];\n                splitAdd(result, temps, result);\n                COSINE_TABLE_A[i] = result[0];\n                COSINE_TABLE_B[i] = result[1];\n            }\n        }\n\n        /* Compute tangent = sine/cosine */\n        for (int i = 0; i < 14; i++) {\n            double xs[] = new double[2];\n            double ys[] = new double[2];\n            double as[] = new double[2];\n\n            as[0] = COSINE_TABLE_A[i];\n            as[1] = COSINE_TABLE_B[i];\n\n            splitReciprocal(as, ys);\n\n            xs[0] = SINE_TABLE_A[i];\n            xs[1] = SINE_TABLE_B[i];\n\n            splitMult(xs, ys, as);\n\n            TANGENT_TABLE_A[i] = as[0];\n            TANGENT_TABLE_B[i] = as[1];\n        }\n\n    }",
    "comment": "Build the sine and cosine tables. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "FastMath.expint",
    "class_name": "org.apache.commons.math.util.FastMath",
    "signature": "org.apache.commons.math.util.FastMath.expint(int,double[])",
    "snippet": "    private static double expint(int p, final double result[]) {\n        //double x = M_E;\n        final double xs[] = new double[2];\n        final double as[] = new double[2];\n        final double ys[] = new double[2];\n        //split(x, xs);\n        //xs[1] = (double)(2.7182818284590452353602874713526625L - xs[0]);\n        //xs[0] = 2.71827697753906250000;\n        //xs[1] = 4.85091998273542816811e-06;\n        //xs[0] = Double.longBitsToDouble(0x4005bf0800000000L);\n        //xs[1] = Double.longBitsToDouble(0x3ed458a2bb4a9b00L);\n\n        /* E */\n        xs[0] = 2.718281828459045;\n        xs[1] = 1.4456468917292502E-16;\n\n        split(1.0, ys);\n\n        while (p > 0) {\n            if ((p & 1) != 0) {\n                quadMult(ys, xs, as);\n                ys[0] = as[0]; ys[1] = as[1];\n            }\n\n            quadMult(xs, xs, as);\n            xs[0] = as[0]; xs[1] = as[1];\n\n            p >>= 1;\n        }\n\n        if (result != null) {\n            result[0] = ys[0];\n            result[1] = ys[1];\n\n            resplit(result);\n        }\n\n        return ys[0] + ys[1];\n    }",
    "comment": "Compute exp(p) for a integer p in extended precision. @param p integer whose exponential is requested @param result placeholder where to put the result in extended precision @return exp(p) in standard precision (equal to result[0] + result[1]) ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "FastMath.max",
    "class_name": "org.apache.commons.math.util.FastMath",
    "signature": "org.apache.commons.math.util.FastMath.max(double,double)",
    "snippet": "    public static double max(final double a, final double b) {\n        return (a <= b) ? b : (Double.isNaN(a + b) ? Double.NaN : a);\n    }",
    "comment": "Compute the maximum of two values @param a first value @param b second value @return b if a is lesser or equal to b, a otherwise ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "FastMath.min",
    "class_name": "org.apache.commons.math.util.FastMath",
    "signature": "org.apache.commons.math.util.FastMath.min(double,double)",
    "snippet": "    public static double min(final double a, final double b) {\n        return (a <= b) ? a : (Double.isNaN(a + b) ? Double.NaN : b);\n    }",
    "comment": "Compute the minimum of two values @param a first value @param b second value @return a if a is lesser or equal to b, b otherwise ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "FastMath.quadMult",
    "class_name": "org.apache.commons.math.util.FastMath",
    "signature": "org.apache.commons.math.util.FastMath.quadMult(double[],double[],double[])",
    "snippet": "    private static void quadMult(final double a[], final double b[], final double result[]) {\n        final double xs[] = new double[2];\n        final double ys[] = new double[2];\n        final double zs[] = new double[2];\n\n        /* a[0] * b[0] */\n        split(a[0], xs);\n        split(b[0], ys);\n        splitMult(xs, ys, zs);\n\n        result[0] = zs[0];\n        result[1] = zs[1];\n\n        /* a[0] * b[1] */\n        split(b[1], ys);\n        splitMult(xs, ys, zs);\n\n        double tmp = result[0] + zs[0];\n        result[1] = result[1] - (tmp - result[0] - zs[0]);\n        result[0] = tmp;\n        tmp = result[0] + zs[1];\n        result[1] = result[1] - (tmp - result[0] - zs[1]);\n        result[0] = tmp;\n\n        /* a[1] * b[0] */\n        split(a[1], xs);\n        split(b[0], ys);\n        splitMult(xs, ys, zs);\n\n        tmp = result[0] + zs[0];\n        result[1] = result[1] - (tmp - result[0] - zs[0]);\n        result[0] = tmp;\n        tmp = result[0] + zs[1];\n        result[1] = result[1] - (tmp - result[0] - zs[1]);\n        result[0] = tmp;\n\n        /* a[1] * b[0] */\n        split(a[1], xs);\n        split(b[1], ys);\n        splitMult(xs, ys, zs);\n\n        tmp = result[0] + zs[0];\n        result[1] = result[1] - (tmp - result[0] - zs[0]);\n        result[0] = tmp;\n        tmp = result[0] + zs[1];\n        result[1] = result[1] - (tmp - result[0] - zs[1]);\n        result[0] = tmp;\n    }",
    "comment": "Compute (a[0] + a[1]) * (b[0] + b[1]) in extended precision. @param a first term of the multiplication @param b second term of the multiplication @param result placeholder where to put the result ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "FastMath.resplit",
    "class_name": "org.apache.commons.math.util.FastMath",
    "signature": "org.apache.commons.math.util.FastMath.resplit(double[])",
    "snippet": "    private static void resplit(final double a[]) {\n        final double c = a[0] + a[1];\n        final double d = -(c - a[0] - a[1]);\n\n        if (c < 8e298 && c > -8e298) {\n            double z = c * 1073741824.0;\n            a[0] = (c + z) - z;\n            a[1] = c - a[0] + d;\n        } else {\n            double z = c * 9.31322574615478515625E-10;\n            a[0] = (c + z - c) * 1073741824.0;\n            a[1] = c - a[0] + d;\n        }\n    }",
    "comment": "Recompute a split. @param a input/out array containing the split, changed on output ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "FastMath.slowCos",
    "class_name": "org.apache.commons.math.util.FastMath",
    "signature": "org.apache.commons.math.util.FastMath.slowCos(double,double[])",
    "snippet": "    private static double slowCos(final double x, final double result[]) {\n\n        final double xs[] = new double[2];\n        final double ys[] = new double[2];\n        final double facts[] = new double[2];\n        final double as[] = new double[2];\n        split(x, xs);\n        ys[0] = ys[1] = 0.0;\n\n        for (int i = 19; i >= 0; i--) {\n            splitMult(xs, ys, as);\n            ys[0] = as[0]; ys[1] = as[1];\n\n            if ( (i & 1) != 0) {\n                continue;\n            }\n\n            split(FACT[i], as);\n            splitReciprocal(as, facts);\n\n            if ( (i & 2) != 0 ) {\n                facts[0] = -facts[0];\n                facts[1] = -facts[1];\n            }\n\n            splitAdd(ys, facts, as);\n            ys[0] = as[0]; ys[1] = as[1];\n        }\n\n        if (result != null) {\n            result[0] = ys[0];\n            result[1] = ys[1];\n        }\n\n        return ys[0] + ys[1];\n    }",
    "comment": " For x between 0 and pi/4 compute cosine @param x number from which cosine is requested @param result placeholder where to put the result in extended precision @return cos(x) ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "FastMath.slowLog",
    "class_name": "org.apache.commons.math.util.FastMath",
    "signature": "org.apache.commons.math.util.FastMath.slowLog(double)",
    "snippet": "    private static double[] slowLog(double xi) {\n        double x[] = new double[2];\n        double x2[] = new double[2];\n        double y[] = new double[2];\n        double a[] = new double[2];\n\n        split(xi, x);\n\n        /* Set X = (x-1)/(x+1) */\n        x[0] += 1.0;\n        resplit(x);\n        splitReciprocal(x, a);\n        x[0] -= 2.0;\n        resplit(x);\n        splitMult(x, a, y);\n        x[0] = y[0];\n        x[1] = y[1];\n\n        /* Square X -> X2*/\n        splitMult(x, x, x2);\n\n\n        //x[0] -= 1.0;\n        //resplit(x);\n\n        y[0] = LN_SPLIT_COEF[LN_SPLIT_COEF.length-1][0];\n        y[1] = LN_SPLIT_COEF[LN_SPLIT_COEF.length-1][1];\n\n        for (int i = LN_SPLIT_COEF.length-2; i >= 0; i--) {\n            splitMult(y, x2, a);\n            y[0] = a[0];\n            y[1] = a[1];\n            splitAdd(y, LN_SPLIT_COEF[i], a);\n            y[0] = a[0];\n            y[1] = a[1];\n        }\n\n        splitMult(y, x, a);\n        y[0] = a[0];\n        y[1] = a[1];\n\n        return y;\n    }",
    "comment": "xi in the range of [1, 2]. 3        5        7 x+1           /          x        x        x          \\ ln ----- =   2 *  |  x  +   ----  +  ----  +  ---- + ...  | 1-x           \\          3        5        7          /  So, compute a Remez approximation of the following function  ln ((sqrt(x)+1)/(1-sqrt(x)))  /  x  This will be an even function with only positive coefficents. x is in the range [0 - 1/3].  Transform xi for input to the above function by setting x = (xi-1)/(xi+1).   Input to the polynomial is x^2, then the result is multiplied by x. @param xi number from which log is requested @return log(xi) ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "FastMath.slowSin",
    "class_name": "org.apache.commons.math.util.FastMath",
    "signature": "org.apache.commons.math.util.FastMath.slowSin(double,double[])",
    "snippet": "    private static double slowSin(final double x, final double result[]) {\n        final double xs[] = new double[2];\n        final double ys[] = new double[2];\n        final double facts[] = new double[2];\n        final double as[] = new double[2];\n        split(x, xs);\n        ys[0] = ys[1] = 0.0;\n\n        for (int i = 19; i >= 0; i--) {\n            splitMult(xs, ys, as);\n            ys[0] = as[0]; ys[1] = as[1];\n\n            if ( (i & 1) == 0) {\n                continue;\n            }\n\n            split(FACT[i], as);\n            splitReciprocal(as, facts);\n\n            if ( (i & 2) != 0 ) {\n                facts[0] = -facts[0];\n                facts[1] = -facts[1];\n            }\n\n            splitAdd(ys, facts, as);\n            ys[0] = as[0]; ys[1] = as[1];\n        }\n\n        if (result != null) {\n            result[0] = ys[0];\n            result[1] = ys[1];\n        }\n\n        return ys[0] + ys[1];\n    }",
    "comment": " For x between 0 and pi/4 compute sine. @param x number from which sine is requested @param result placeholder where to put the result in extended precision @return sin(x) ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "FastMath.slowexp",
    "class_name": "org.apache.commons.math.util.FastMath",
    "signature": "org.apache.commons.math.util.FastMath.slowexp(double,double[])",
    "snippet": "    private static double slowexp(final double x, final double result[]) {\n        final double xs[] = new double[2];\n        final double ys[] = new double[2];\n        final double facts[] = new double[2];\n        final double as[] = new double[2];\n        split(x, xs);\n        ys[0] = ys[1] = 0.0;\n\n        for (int i = 19; i >= 0; i--) {\n            splitMult(xs, ys, as);\n            ys[0] = as[0];\n            ys[1] = as[1];\n\n            split(FACT[i], as);\n            splitReciprocal(as, facts);\n\n            splitAdd(ys, facts, as);\n            ys[0] = as[0];\n            ys[1] = as[1];\n        }\n\n        if (result != null) {\n            result[0] = ys[0];\n            result[1] = ys[1];\n        }\n\n        return ys[0] + ys[1];\n    }",
    "comment": " For x between 0 and 1, returns exp(x), uses extended precision @param x argument of exponential @param result placeholder where to place exp(x) split in two terms for extra precision (i.e. exp(x) = result[0] Â° result[1] @return exp(x) ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "FastMath.split",
    "class_name": "org.apache.commons.math.util.FastMath",
    "signature": "org.apache.commons.math.util.FastMath.split(double,double[])",
    "snippet": "    private static void split(final double d, final double split[]) {\n        if (d < 8e298 && d > -8e298) {\n            final double a = d * 1073741824.0;\n            split[0] = (d + a) - a;\n            split[1] = d - split[0];\n        } else {\n            final double a = d * 9.31322574615478515625E-10;\n            split[0] = (d + a - d) * 1073741824.0;\n            split[1] = d - split[0];\n        }\n    }",
    "comment": "Compute split[0], split[1] such that their sum is equal to d, and split[0] has its 30 least significant bits as zero. @param d number to split @param split placeholder where to place the result ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "FastMath.splitAdd",
    "class_name": "org.apache.commons.math.util.FastMath",
    "signature": "org.apache.commons.math.util.FastMath.splitAdd(double[],double[],double[])",
    "snippet": "    private static void splitAdd(final double a[], final double b[], final double ans[]) {\n        ans[0] = a[0] + b[0];\n        ans[1] = a[1] + b[1];\n\n        resplit(ans);\n    }",
    "comment": "Add two numbers in split form. @param a first term of addition @param b second term of addition @param ans placeholder where to put the result ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "FastMath.splitMult",
    "class_name": "org.apache.commons.math.util.FastMath",
    "signature": "org.apache.commons.math.util.FastMath.splitMult(double[],double[],double[])",
    "snippet": "    private static void splitMult(double a[], double b[], double ans[]) {\n        ans[0] = a[0] * b[0];\n        ans[1] = a[0] * b[1] + a[1] * b[0] + a[1] * b[1];\n\n        /* Resplit */\n        resplit(ans);\n    }",
    "comment": "Multiply two numbers in split form. @param a first term of multiplication @param b second term of multiplication @param ans placeholder where to put the result ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "FastMath.splitReciprocal",
    "class_name": "org.apache.commons.math.util.FastMath",
    "signature": "org.apache.commons.math.util.FastMath.splitReciprocal(double[],double[])",
    "snippet": "    private static void splitReciprocal(final double in[], final double result[]) {\n        final double b = 1.0/4194304.0;\n        final double a = 1.0 - b;\n\n        if (in[0] == 0.0) {\n            in[0] = in[1];\n            in[1] = 0.0;\n        }\n\n        result[0] = a / in[0];\n        result[1] = (b*in[0]-a*in[1]) / (in[0]*in[0] + in[0]*in[1]);\n\n        if (result[1] != result[1]) { // can happen if result[1] is NAN\n            result[1] = 0.0;\n        }\n\n        /* Resplit */\n        resplit(result);\n\n        for (int i = 0; i < 2; i++) {\n            /* this may be overkill, probably once is enough */\n            double err = 1.0 - result[0] * in[0] - result[0] * in[1] -\n            result[1] * in[0] - result[1] * in[1];\n            /*err = 1.0 - err; */\n            err = err * (result[0] + result[1]);\n            /*printf(\"err = %16e\\n\", err); */\n            result[1] += err;\n        }\n    }",
    "comment": "Compute the reciprocal of in.  Use the following algorithm. in = c + d. want to find x + y such that x+y = 1/(c+d) and x is much larger than y and x has several zero bits on the right.  Set b = 1/(2^22),  a = 1 - b.  Thus (a+b) = 1. Use following identity to compute (a+b)/(c+d)  (a+b)/(c+d)  =   a/c   +    (bc - ad) / (c^2 + cd) set x = a/c  and y = (bc - ad) / (c^2 + cd) This will be close to the right answer, but there will be some rounding in the calculation of X.  So by carefully computing 1 - (c+d)(x+y) we can compute an error and add that back in.   This is done carefully so that terms of similar size are subtracted first. @param in initial number, in split form @param result placeholder where to put the result ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "FastMath.sqrt",
    "class_name": "org.apache.commons.math.util.FastMath",
    "signature": "org.apache.commons.math.util.FastMath.sqrt(double)",
    "snippet": "    public static double sqrt(final double a) {\n        return Math.sqrt(a);\n    }",
    "comment": "Compute the square root of a number. @param a number on which evaluation is done @return square root of a ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "FastMath.ulp",
    "class_name": "org.apache.commons.math.util.FastMath",
    "signature": "org.apache.commons.math.util.FastMath.ulp(double)",
    "snippet": "    public static double ulp(double x) {\n        return abs(x - Double.longBitsToDouble(Double.doubleToLongBits(x) ^ 1));\n    }",
    "comment": " Compute least significant bit (Unit in Last Position) for a number. @param x number from which ulp is requested @return ulp(x) ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "Incrementor.getCount",
    "class_name": "org.apache.commons.math.util.Incrementor",
    "signature": "org.apache.commons.math.util.Incrementor.getCount()",
    "snippet": "    public int getCount() {\n        return count;\n    }",
    "comment": " Get the current count.  @return the current count. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "Incrementor.getMaximalCount",
    "class_name": "org.apache.commons.math.util.Incrementor",
    "signature": "org.apache.commons.math.util.Incrementor.getMaximalCount()",
    "snippet": "    public int getMaximalCount() {\n        return maximalCount;\n    }",
    "comment": " Get the upper limit of the counter.  @return the counter upper limit. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "Incrementor.incrementCount",
    "class_name": "org.apache.commons.math.util.Incrementor",
    "signature": "org.apache.commons.math.util.Incrementor.incrementCount()",
    "snippet": "    public void incrementCount() {\n        if (++count > maximalCount) {\n            throw new MaxCountExceededException(maximalCount);\n        }\n    }",
    "comment": " Add one to the current iteration count.  @throws MaxCountExceededException at counter exhaustion. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "Incrementor.resetCount",
    "class_name": "org.apache.commons.math.util.Incrementor",
    "signature": "org.apache.commons.math.util.Incrementor.resetCount()",
    "snippet": "    public void resetCount() {\n        count = 0;\n    }",
    "comment": " Reset the counter to 0. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "Incrementor.setMaximalCount",
    "class_name": "org.apache.commons.math.util.Incrementor",
    "signature": "org.apache.commons.math.util.Incrementor.setMaximalCount(int)",
    "snippet": "    public void setMaximalCount(int max) {\n        maximalCount = max;\n    }",
    "comment": " Set the upper limit for the counter.  @param max Upper limit of the counter. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "MathUtils.equals",
    "class_name": "org.apache.commons.math.util.MathUtils",
    "signature": "org.apache.commons.math.util.MathUtils.equals(double,double)",
    "snippet": "    public static boolean equals(double x, double y) {\n        return equals(x, y, 1);\n    }",
    "comment": " Returns true iff they are equal as defined by {@link #equals(double,double,int) equals(x, y, 1)}.  @param x first value @param y second value @return {@code true} if the values are equal. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "MathUtils.equals",
    "class_name": "org.apache.commons.math.util.MathUtils",
    "signature": "org.apache.commons.math.util.MathUtils.equals(double,double,int)",
    "snippet": "    public static boolean equals(double x, double y, int maxUlps) {\n        // Check that \"maxUlps\" is non-negative and small enough so that\n        // NaN won't compare as equal to anything (except another NaN).\n        assert maxUlps > 0 && maxUlps < NAN_GAP;\n\n        long xInt = Double.doubleToLongBits(x);\n        long yInt = Double.doubleToLongBits(y);\n\n        // Make lexicographically ordered as a two's-complement integer.\n        if (xInt < 0) {\n            xInt = SGN_MASK - xInt;\n        }\n        if (yInt < 0) {\n            yInt = SGN_MASK - yInt;\n        }\n\n        final boolean isEqual = FastMath.abs(xInt - yInt) <= maxUlps;\n\n        return isEqual && !Double.isNaN(x) && !Double.isNaN(y);\n    }",
    "comment": " Returns true if both arguments are equal or within the range of allowed error (inclusive). Two float numbers are considered equal if there are {@code (maxUlps - 1)} (or less) floating point numbers between them (i.e. two adjacent floating point numbers are considered equal. Adapted from <a href=\"http://www.cygnus-software.com/papers/comparingfloats/comparingfloats.htm\"> Bruce Dawson</a>  @param x first value @param y second value @param maxUlps {@code (maxUlps - 1)} is the number of floating point values between {@code x} and {@code y}. @return {@code true} if there are less than {@code maxUlps} floating point values between {@code x} and {@code y}. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  }
]