[
  {
    "name": "FastDateFormat.FastDateFormat",
    "class_name": "org.apache.commons.lang3.time.FastDateFormat",
    "signature": "org.apache.commons.lang3.time.FastDateFormat.FastDateFormat(String,TimeZone,Locale)",
    "snippet": "    protected FastDateFormat(String pattern, TimeZone timeZone, Locale locale) {\n        printer= new FastDatePrinter(pattern, timeZone, locale);\n        parser= new FastDateParser(pattern, timeZone, locale);\n    }",
    "comment": " <p>Constructs a new FastDateFormat.</p>  @param pattern  {@link java.text.SimpleDateFormat} compatible pattern @param timeZone  non-null time zone to use @param locale  non-null locale to use @throws NullPointerException if pattern, timeZone, or locale is null. ",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "FastDateFormat.getInstance",
    "class_name": "org.apache.commons.lang3.time.FastDateFormat",
    "signature": "org.apache.commons.lang3.time.FastDateFormat.getInstance(String,TimeZone,Locale)",
    "snippet": "    public static FastDateFormat getInstance(String pattern, TimeZone timeZone, Locale locale) {\n        return cache.getInstance(pattern, timeZone, locale);\n    }",
    "comment": " <p>Gets a formatter instance using the specified pattern, time zone and locale.</p>  @param pattern  {@link java.text.SimpleDateFormat} compatible pattern @param timeZone  optional time zone, overrides time zone of formatted date @param locale  optional locale, overrides system locale @return a pattern based date/time formatter @throws IllegalArgumentException if pattern is invalid or {@code null} ",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "FastDateFormat.parse",
    "class_name": "org.apache.commons.lang3.time.FastDateFormat",
    "signature": "org.apache.commons.lang3.time.FastDateFormat.parse(String)",
    "snippet": "    @Override\n    public Date parse(String source) throws ParseException {\n        return parser.parse(source);\n    }",
    "comment": "(non-Javadoc) @see DateParser#parse(java.lang.String) ",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "FastDateParser.FastDateParser",
    "class_name": "org.apache.commons.lang3.time.FastDateParser",
    "signature": "org.apache.commons.lang3.time.FastDateParser.FastDateParser(String,TimeZone,Locale)",
    "snippet": "    protected FastDateParser(String pattern, TimeZone timeZone, Locale locale) {\n        this.pattern = pattern;\n        this.timeZone = timeZone;\n        this.locale = locale;\n        init();\n    }",
    "comment": " <p>Constructs a new FastDateParser.</p>  @param pattern non-null {@link java.text.SimpleDateFormat} compatible pattern @param timeZone non-null time zone to use @param locale non-null locale ",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "FastDateParser.copy",
    "class_name": "org.apache.commons.lang3.time.FastDateParser",
    "signature": "org.apache.commons.lang3.time.FastDateParser.copy(KeyValue[],int,String[])",
    "snippet": "    private static int copy(KeyValue[] fieldKeyValues, int offset, String[] values) {\n        if(values!=null) {\n            for(int i= 0; i<values.length; ++i) {\n                String value= values[i];\n                if(value.length()>0) {\n                    fieldKeyValues[offset++]= new KeyValue(value, i);\n                }\n            }\n        }\n        return offset;\n    }",
    "comment": " Create key / value pairs from values @param fieldKeyValues The destination array @param offset The offset into the destination array @param values The values to use to create key / value pairs.  This parameter may be null. @return The offset into the destination array ",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "FastDateParser.count",
    "class_name": "org.apache.commons.lang3.time.FastDateParser",
    "signature": "org.apache.commons.lang3.time.FastDateParser.count(String[])",
    "snippet": "    private static int count(String[] values) {\n        int count= 0;\n        if(values!=null) {\n            for(String value : values) {\n                if(value.length()>0) {\n                    ++count;\n                }\n            }\n        }\n        return count;\n    }",
    "comment": " Get a count of valid values in array.  A valid value is of non-zero length. @param values The values to check.  This parameter may be null @return The number of valid values ",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "FastDateParser.createKeyValues",
    "class_name": "org.apache.commons.lang3.time.FastDateParser",
    "signature": "org.apache.commons.lang3.time.FastDateParser.createKeyValues(String[],String[])",
    "snippet": "    private static KeyValue[] createKeyValues(String[] longValues, String[] shortValues) {\n        KeyValue[] fieldKeyValues= new KeyValue[count(longValues)+count(shortValues)];\n        copy(fieldKeyValues, copy(fieldKeyValues, 0, longValues), shortValues);\n        Arrays.sort(fieldKeyValues, IGNORE_CASE_COMPARATOR);\n        return fieldKeyValues;\n    }",
    "comment": " Create key / value pairs from keys @param longValues The allowable long names for a field @param shortValues The optional allowable short names for a field @return The sorted name / value pairs for the field ",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "FastDateParser.escapeRegex",
    "class_name": "org.apache.commons.lang3.time.FastDateParser",
    "signature": "org.apache.commons.lang3.time.FastDateParser.escapeRegex(StringBuilder,String,boolean)",
    "snippet": "    private static StringBuilder escapeRegex(StringBuilder regex, String value, boolean unquote) {\n        boolean wasWhite= false;\n        for(int i= 0; i<value.length(); ++i) {\n            char c= value.charAt(i);\n            if(Character.isWhitespace(c)) {\n                if(!wasWhite) {\n                    wasWhite= true;\n                    regex.append(\"\\\\s*+\");\n                }\n                continue;\n            }\n            wasWhite= false;\n            switch(c) {\n            case '\\'':\n                if(unquote) {\n                    if(++i==value.length()) {\n                        return regex;\n                    }\n                    c= value.charAt(i);\n                }\n                break;\n            case '?':\n            case '[':\n            case ']':\n            case '(':\n            case ')':\n            case '{':\n            case '}':\n            case '\\\\':\n            case '|':\n            case '*':\n            case '+':\n            case '^':\n            case '$':\n            case '.':\n                regex.append('\\\\');\n            }\n            regex.append(c);\n        }\n        return regex;\n    }",
    "comment": " Escape constant fields into regular expression @param regex The destination regex @param value The source field @param unquote If true, replace two success quotes ('') with single quote (') @return The <code>StringBuilder</code> ",
    "is_bug": true,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "FastDateParser.getDisplayNames",
    "class_name": "org.apache.commons.lang3.time.FastDateParser",
    "signature": "org.apache.commons.lang3.time.FastDateParser.getDisplayNames(int)",
    "snippet": "    KeyValue[] getDisplayNames(int field) {\n        Integer fieldInt = Integer.valueOf(field);\n        KeyValue[] fieldKeyValues= nameValues.get(fieldInt);\n        if(fieldKeyValues==null) {\n            DateFormatSymbols symbols= DateFormatSymbols.getInstance(locale);\n            switch(field) {\n            case Calendar.ERA:\n                // DateFormatSymbols#getEras() only returns AD/BC or translations\n                // It does not work for the Thai Buddhist or Japanese Imperial calendars.\n                // see: https://issues.apache.org/jira/browse/TRINIDAD-2126\n                Calendar c = Calendar.getInstance(locale);\n                // N.B. Some calendars have different short and long symbols, e.g. ja_JP_JP\n                String[] shortEras = toArray(c.getDisplayNames(Calendar.ERA, Calendar.SHORT, locale));\n                String[] longEras = toArray(c.getDisplayNames(Calendar.ERA, Calendar.LONG, locale));\n                fieldKeyValues= createKeyValues(longEras, shortEras);\n                break;\n            case Calendar.DAY_OF_WEEK:\n                fieldKeyValues= createKeyValues(symbols.getWeekdays(), symbols.getShortWeekdays());\n                break;\n            case Calendar.AM_PM:\n                fieldKeyValues= createKeyValues(symbols.getAmPmStrings(), null);\n                break;\n            case Calendar.MONTH:\n                fieldKeyValues= createKeyValues(symbols.getMonths(), symbols.getShortMonths());\n                break;\n            default:\n                throw new IllegalArgumentException(\"Invalid field value \"+field);\n            }\n            KeyValue[] prior = nameValues.putIfAbsent(fieldInt, fieldKeyValues);\n            if(prior!=null) {\n                fieldKeyValues= prior;\n            }\n        }\n        return fieldKeyValues;\n    }",
    "comment": " Get the short and long values displayed for a field @param field The field of interest @return A sorted array of the field key / value pairs ",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "FastDateParser.getStrategy",
    "class_name": "org.apache.commons.lang3.time.FastDateParser",
    "signature": "org.apache.commons.lang3.time.FastDateParser.getStrategy(String)",
    "snippet": "    private Strategy getStrategy(String formatField) {\n        switch(formatField.charAt(0)) {\n        case '\\'':\n            if(formatField.length()>2) {\n                formatField= formatField.substring(1, formatField.length()-1);\n            }\n            //$FALL-THROUGH$\n        default:\n            return new CopyQuotedStrategy(formatField);\n        case 'D':\n            return DAY_OF_YEAR_STRATEGY;\n        case 'E':\n            return DAY_OF_WEEK_STRATEGY;\n        case 'F':\n            return DAY_OF_WEEK_IN_MONTH_STRATEGY;\n        case 'G':\n            return ERA_STRATEGY;\n        case 'H':\n            return MODULO_HOUR_OF_DAY_STRATEGY;\n        case 'K':\n            return HOUR_STRATEGY;\n        case 'M':\n            return formatField.length()>=3 ?TEXT_MONTH_STRATEGY :NUMBER_MONTH_STRATEGY;\n        case 'S':\n            return MILLISECOND_STRATEGY;\n        case 'W':\n            return WEEK_OF_MONTH_STRATEGY;\n        case 'Z':\n            break;\n        case 'a':\n            return AM_PM_STRATEGY;\n        case 'd':\n            return DAY_OF_MONTH_STRATEGY;\n        case 'h':\n            return MODULO_HOUR_STRATEGY;\n        case 'k':\n            return HOUR_OF_DAY_STRATEGY;\n        case 'm':\n            return MINUTE_STRATEGY;\n        case 's':\n            return SECOND_STRATEGY;\n        case 'w':\n            return WEEK_OF_YEAR_STRATEGY;\n        case 'y':\n            return formatField.length()>2 ?LITERAL_YEAR_STRATEGY :ABBREVIATED_YEAR_STRATEGY;\n        case 'z':\n            break;\n        }\n        TimeZoneStrategy tzs= tzsCache.get(locale);\n        if(tzs==null) {\n            tzs= new TimeZoneStrategy(locale);\n            TimeZoneStrategy inCache= tzsCache.putIfAbsent(locale, tzs);\n            if(inCache!=null) {\n                return inCache;\n            }\n        }\n        return tzs;\n    }",
    "comment": " Obtain a Strategy given a field from a SimpleDateFormat pattern @param formatField A sub-sequence of the SimpleDateFormat pattern @return The Strategy that will handle parsing for the field ",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "FastDateParser.init",
    "class_name": "org.apache.commons.lang3.time.FastDateParser",
    "signature": "org.apache.commons.lang3.time.FastDateParser.init()",
    "snippet": "    private void init() {\n        thisYear= Calendar.getInstance(timeZone, locale).get(Calendar.YEAR);\n\n        nameValues= new ConcurrentHashMap<Integer, KeyValue[]>();\n\n        StringBuilder regex= new StringBuilder();\n        List<Strategy> collector = new ArrayList<Strategy>();\n\n        Matcher patternMatcher= formatPattern.matcher(pattern);\n        if(!patternMatcher.lookingAt()) {\n            throw new IllegalArgumentException(\"Invalid pattern\");\n        }\n\n        currentFormatField= patternMatcher.group();\n        Strategy currentStrategy= getStrategy(currentFormatField);\n        for(;;) {\n            patternMatcher.region(patternMatcher.end(), patternMatcher.regionEnd());\n            if(!patternMatcher.lookingAt()) {\n                nextStrategy = null;\n                break;\n            }\n            String nextFormatField= patternMatcher.group();\n            nextStrategy = getStrategy(nextFormatField);\n            if(currentStrategy.addRegex(this, regex)) {\n                collector.add(currentStrategy);\n            }\n            currentFormatField= nextFormatField;\n            currentStrategy= nextStrategy;\n        }\n        if(currentStrategy.addRegex(this, regex)) {\n            collector.add(currentStrategy);\n        }\n        currentFormatField= null;\n        strategies= collector.toArray(new Strategy[collector.size()]);\n        parsePattern= Pattern.compile(regex.toString());\n    }",
    "comment": " Initialize derived fields from defining fields. This is called from constructor and from readObject (de-serialization) ",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "FastDateParser.isNextNumber",
    "class_name": "org.apache.commons.lang3.time.FastDateParser",
    "signature": "org.apache.commons.lang3.time.FastDateParser.isNextNumber()",
    "snippet": "    boolean isNextNumber() {\n        return nextStrategy!=null && nextStrategy.isNumber();\n    }",
    "comment": " Is the next field a number? @return true, if next field will be a number ",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "FastDateParser.parse",
    "class_name": "org.apache.commons.lang3.time.FastDateParser",
    "signature": "org.apache.commons.lang3.time.FastDateParser.parse(String)",
    "snippet": "    @Override\n    public Date parse(String source) throws ParseException {\n        Date date= parse(source, new ParsePosition(0));\n        if(date==null) {\n            // Add a note re supported date range\n            if (locale.equals(JAPANESE_IMPERIAL)) {\n                throw new ParseException(\n                        \"(The \" +locale + \" locale does not support dates before 1868 AD)\\n\" +\n                                \"Unparseable date: \\\"\"+source+\"\\\" does not match \"+parsePattern.pattern(), 0);\n            }\n            throw new ParseException(\"Unparseable date: \\\"\"+source+\"\\\" does not match \"+parsePattern.pattern(), 0);\n        }\n        return date;\n    }",
    "comment": "(non-Javadoc) @see org.apache.commons.lang3.time.DateParser#parse(java.lang.String) ",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "FastDateParser.parse",
    "class_name": "org.apache.commons.lang3.time.FastDateParser",
    "signature": "org.apache.commons.lang3.time.FastDateParser.parse(String,ParsePosition)",
    "snippet": "    @Override\n    public Date parse(String source, ParsePosition pos) {\n        int offset= pos.getIndex();\n        Matcher matcher= parsePattern.matcher(source.substring(offset));\n        if(!matcher.lookingAt()) {\n            return null;\n        }\n        // timing tests indicate getting new instance is 19% faster than cloning\n        Calendar cal= Calendar.getInstance(timeZone, locale);\n        cal.clear();\n\n        for(int i=0; i<strategies.length;) {\n            Strategy strategy= strategies[i++];\n            strategy.setCalendar(this, cal, matcher.group(i));\n        }\n        pos.setIndex(offset+matcher.end());\n        return cal.getTime();\n    }",
    "comment": "(non-Javadoc) @see org.apache.commons.lang3.time.DateParser#parse(java.lang.String, java.text.ParsePosition) ",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "CopyQuotedStrategy.addRegex",
    "class_name": "org.apache.commons.lang3.time.FastDateParser$CopyQuotedStrategy",
    "signature": "org.apache.commons.lang3.time.FastDateParser$CopyQuotedStrategy.addRegex(FastDateParser,StringBuilder)",
    "snippet": "        @Override\n        public boolean addRegex(FastDateParser parser, StringBuilder regex) {\n            escapeRegex(regex, formatField, true);\n            return false;\n        }",
    "comment": " {@inheritDoc} ",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "CopyQuotedStrategy.isNumber",
    "class_name": "org.apache.commons.lang3.time.FastDateParser$CopyQuotedStrategy",
    "signature": "org.apache.commons.lang3.time.FastDateParser$CopyQuotedStrategy.isNumber()",
    "snippet": "        @Override\n        public boolean isNumber() {\n            char c= formatField.charAt(0);\n            if(c=='\\'') {\n                c= formatField.charAt(1);\n            }\n            return Character.isDigit(c);\n        }",
    "comment": " {@inheritDoc} ",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "NumberStrategy.addRegex",
    "class_name": "org.apache.commons.lang3.time.FastDateParser$NumberStrategy",
    "signature": "org.apache.commons.lang3.time.FastDateParser$NumberStrategy.addRegex(FastDateParser,StringBuilder)",
    "snippet": "        @Override\n        public boolean addRegex(FastDateParser parser, StringBuilder regex) {\n            if(parser.isNextNumber()) {\n                regex.append(\"(\\\\p{IsNd}{\").append(parser.getFieldWidth()).append(\"}+)\");\n            }\n            else {\n                regex.append(\"(\\\\p{IsNd}++)\");\n            }\n            return true;\n        }",
    "comment": " {@inheritDoc} ",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "NumberStrategy.setCalendar",
    "class_name": "org.apache.commons.lang3.time.FastDateParser$NumberStrategy",
    "signature": "org.apache.commons.lang3.time.FastDateParser$NumberStrategy.setCalendar(FastDateParser,Calendar,String)",
    "snippet": "        @Override\n        public void setCalendar(FastDateParser parser, Calendar cal, String value) {\n            cal.set(field, modify(Integer.parseInt(value)));\n        }",
    "comment": " {@inheritDoc} ",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "TextStrategy.addRegex",
    "class_name": "org.apache.commons.lang3.time.FastDateParser$TextStrategy",
    "signature": "org.apache.commons.lang3.time.FastDateParser$TextStrategy.addRegex(FastDateParser,StringBuilder)",
    "snippet": "        @Override\n        public boolean addRegex(FastDateParser parser, StringBuilder regex) {\n            regex.append('(');\n            for(KeyValue textKeyValue : parser.getDisplayNames(field)) {\n                escapeRegex(regex, textKeyValue.key, false).append('|');\n            }\n            regex.setCharAt(regex.length()-1, ')');\n            return true;\n        }",
    "comment": " {@inheritDoc} ",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "TextStrategy.setCalendar",
    "class_name": "org.apache.commons.lang3.time.FastDateParser$TextStrategy",
    "signature": "org.apache.commons.lang3.time.FastDateParser$TextStrategy.setCalendar(FastDateParser,Calendar,String)",
    "snippet": "        @Override\n        public void setCalendar(FastDateParser parser, Calendar cal, String value) {\n            KeyValue[] textKeyValues= parser.getDisplayNames(field);\n            int idx= Arrays.binarySearch(textKeyValues, new KeyValue(value, -1), IGNORE_CASE_COMPARATOR);\n            if(idx<0) {\n                StringBuilder sb= new StringBuilder(value);\n                sb.append(\" not in (\");\n                for(KeyValue textKeyValue : textKeyValues) {\n                    sb.append(textKeyValue.key).append(' ');\n                }\n                sb.setCharAt(sb.length()-1, ')');\n                throw new IllegalArgumentException(sb.toString());\n            }\n            cal.set(field, textKeyValues[idx].value);\n        }",
    "comment": " {@inheritDoc} ",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "FastDatePrinter.FastDatePrinter",
    "class_name": "org.apache.commons.lang3.time.FastDatePrinter",
    "signature": "org.apache.commons.lang3.time.FastDatePrinter.FastDatePrinter(String,TimeZone,Locale)",
    "snippet": "    protected FastDatePrinter(String pattern, TimeZone timeZone, Locale locale) {\n        mPattern = pattern;\n        mTimeZone = timeZone;\n        mLocale = locale;\n\n        init();\n    }",
    "comment": " <p>Constructs a new FastDatePrinter.</p>  @param pattern  {@link java.text.SimpleDateFormat} compatible pattern @param timeZone  non-null time zone to use @param locale  non-null locale to use @throws NullPointerException if pattern, timeZone, or locale is null. ",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "FastDatePrinter.init",
    "class_name": "org.apache.commons.lang3.time.FastDatePrinter",
    "signature": "org.apache.commons.lang3.time.FastDatePrinter.init()",
    "snippet": "    private void init() {\n        List<Rule> rulesList = parsePattern();\n        mRules = rulesList.toArray(new Rule[rulesList.size()]);\n\n        int len = 0;\n        for (int i=mRules.length; --i >= 0; ) {\n            len += mRules[i].estimateLength();\n        }\n\n        mMaxLengthEstimate = len;\n    }",
    "comment": " <p>Initializes the instance for first use.</p> ",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "FastDatePrinter.parsePattern",
    "class_name": "org.apache.commons.lang3.time.FastDatePrinter",
    "signature": "org.apache.commons.lang3.time.FastDatePrinter.parsePattern()",
    "snippet": "    protected List<Rule> parsePattern() {\n        DateFormatSymbols symbols = new DateFormatSymbols(mLocale);\n        List<Rule> rules = new ArrayList<Rule>();\n\n        String[] ERAs = symbols.getEras();\n        String[] months = symbols.getMonths();\n        String[] shortMonths = symbols.getShortMonths();\n        String[] weekdays = symbols.getWeekdays();\n        String[] shortWeekdays = symbols.getShortWeekdays();\n        String[] AmPmStrings = symbols.getAmPmStrings();\n\n        int length = mPattern.length();\n        int[] indexRef = new int[1];\n\n        for (int i = 0; i < length; i++) {\n            indexRef[0] = i;\n            String token = parseToken(mPattern, indexRef);\n            i = indexRef[0];\n\n            int tokenLen = token.length();\n            if (tokenLen == 0) {\n                break;\n            }\n\n            Rule rule;\n            char c = token.charAt(0);\n\n            switch (c) {\n            case 'G': // era designator (text)\n                rule = new TextField(Calendar.ERA, ERAs);\n                break;\n            case 'y': // year (number)\n                if (tokenLen == 2) {\n                    rule = TwoDigitYearField.INSTANCE;\n                } else {\n                    rule = selectNumberRule(Calendar.YEAR, tokenLen < 4 ? 4 : tokenLen);\n                }\n                break;\n            case 'M': // month in year (text and number)\n                if (tokenLen >= 4) {\n                    rule = new TextField(Calendar.MONTH, months);\n                } else if (tokenLen == 3) {\n                    rule = new TextField(Calendar.MONTH, shortMonths);\n                } else if (tokenLen == 2) {\n                    rule = TwoDigitMonthField.INSTANCE;\n                } else {\n                    rule = UnpaddedMonthField.INSTANCE;\n                }\n                break;\n            case 'd': // day in month (number)\n                rule = selectNumberRule(Calendar.DAY_OF_MONTH, tokenLen);\n                break;\n            case 'h': // hour in am/pm (number, 1..12)\n                rule = new TwelveHourField(selectNumberRule(Calendar.HOUR, tokenLen));\n                break;\n            case 'H': // hour in day (number, 0..23)\n                rule = selectNumberRule(Calendar.HOUR_OF_DAY, tokenLen);\n                break;\n            case 'm': // minute in hour (number)\n                rule = selectNumberRule(Calendar.MINUTE, tokenLen);\n                break;\n            case 's': // second in minute (number)\n                rule = selectNumberRule(Calendar.SECOND, tokenLen);\n                break;\n            case 'S': // millisecond (number)\n                rule = selectNumberRule(Calendar.MILLISECOND, tokenLen);\n                break;\n            case 'E': // day in week (text)\n                rule = new TextField(Calendar.DAY_OF_WEEK, tokenLen < 4 ? shortWeekdays : weekdays);\n                break;\n            case 'D': // day in year (number)\n                rule = selectNumberRule(Calendar.DAY_OF_YEAR, tokenLen);\n                break;\n            case 'F': // day of week in month (number)\n                rule = selectNumberRule(Calendar.DAY_OF_WEEK_IN_MONTH, tokenLen);\n                break;\n            case 'w': // week in year (number)\n                rule = selectNumberRule(Calendar.WEEK_OF_YEAR, tokenLen);\n                break;\n            case 'W': // week in month (number)\n                rule = selectNumberRule(Calendar.WEEK_OF_MONTH, tokenLen);\n                break;\n            case 'a': // am/pm marker (text)\n                rule = new TextField(Calendar.AM_PM, AmPmStrings);\n                break;\n            case 'k': // hour in day (1..24)\n                rule = new TwentyFourHourField(selectNumberRule(Calendar.HOUR_OF_DAY, tokenLen));\n                break;\n            case 'K': // hour in am/pm (0..11)\n                rule = selectNumberRule(Calendar.HOUR, tokenLen);\n                break;\n            case 'z': // time zone (text)\n                if (tokenLen >= 4) {\n                    rule = new TimeZoneNameRule(mTimeZone, mLocale, TimeZone.LONG);\n                } else {\n                    rule = new TimeZoneNameRule(mTimeZone, mLocale, TimeZone.SHORT);\n                }\n                break;\n            case 'Z': // time zone (value)\n                if (tokenLen == 1) {\n                    rule = TimeZoneNumberRule.INSTANCE_NO_COLON;\n                } else {\n                    rule = TimeZoneNumberRule.INSTANCE_COLON;\n                }\n                break;\n            case '\\'': // literal text\n                String sub = token.substring(1);\n                if (sub.length() == 1) {\n                    rule = new CharacterLiteral(sub.charAt(0));\n                } else {\n                    rule = new StringLiteral(sub);\n                }\n                break;\n            default:\n                throw new IllegalArgumentException(\"Illegal pattern component: \" + token);\n            }\n\n            rules.add(rule);\n        }\n\n        return rules;\n    }",
    "comment": " <p>Returns a list of Rules given a pattern.</p>  @return a {@code List} of Rule objects @throws IllegalArgumentException if pattern is invalid ",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "FastDatePrinter.parseToken",
    "class_name": "org.apache.commons.lang3.time.FastDatePrinter",
    "signature": "org.apache.commons.lang3.time.FastDatePrinter.parseToken(String,int[])",
    "snippet": "    protected String parseToken(String pattern, int[] indexRef) {\n        StringBuilder buf = new StringBuilder();\n\n        int i = indexRef[0];\n        int length = pattern.length();\n\n        char c = pattern.charAt(i);\n        if (c >= 'A' && c <= 'Z' || c >= 'a' && c <= 'z') {\n            // Scan a run of the same character, which indicates a time\n            // pattern.\n            buf.append(c);\n\n            while (i + 1 < length) {\n                char peek = pattern.charAt(i + 1);\n                if (peek == c) {\n                    buf.append(c);\n                    i++;\n                } else {\n                    break;\n                }\n            }\n        } else {\n            // This will identify token as text.\n            buf.append('\\'');\n\n            boolean inLiteral = false;\n\n            for (; i < length; i++) {\n                c = pattern.charAt(i);\n\n                if (c == '\\'') {\n                    if (i + 1 < length && pattern.charAt(i + 1) == '\\'') {\n                        // '' is treated as escaped '\n                        i++;\n                        buf.append(c);\n                    } else {\n                        inLiteral = !inLiteral;\n                    }\n                } else if (!inLiteral &&\n                         (c >= 'A' && c <= 'Z' || c >= 'a' && c <= 'z')) {\n                    i--;\n                    break;\n                } else {\n                    buf.append(c);\n                }\n            }\n        }\n\n        indexRef[0] = i;\n        return buf.toString();\n    }",
    "comment": " <p>Performs the parsing of tokens.</p>  @param pattern  the pattern @param indexRef  index references @return parsed token ",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "CharacterLiteral.estimateLength",
    "class_name": "org.apache.commons.lang3.time.FastDatePrinter$CharacterLiteral",
    "signature": "org.apache.commons.lang3.time.FastDatePrinter$CharacterLiteral.estimateLength()",
    "snippet": "        @Override\n        public int estimateLength() {\n            return 1;\n        }",
    "comment": " {@inheritDoc} ",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "TextField.estimateLength",
    "class_name": "org.apache.commons.lang3.time.FastDatePrinter$TextField",
    "signature": "org.apache.commons.lang3.time.FastDatePrinter$TextField.estimateLength()",
    "snippet": "        @Override\n        public int estimateLength() {\n            int max = 0;\n            for (int i=mValues.length; --i >= 0; ) {\n                int len = mValues[i].length();\n                if (len > max) {\n                    max = len;\n                }\n            }\n            return max;\n        }",
    "comment": " {@inheritDoc} ",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "UnpaddedMonthField.estimateLength",
    "class_name": "org.apache.commons.lang3.time.FastDatePrinter$UnpaddedMonthField",
    "signature": "org.apache.commons.lang3.time.FastDatePrinter$UnpaddedMonthField.estimateLength()",
    "snippet": "        @Override\n        public int estimateLength() {\n            return 2;\n        }",
    "comment": " {@inheritDoc} ",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "FormatCache.getInstance",
    "class_name": "org.apache.commons.lang3.time.FormatCache",
    "signature": "org.apache.commons.lang3.time.FormatCache.getInstance(String,TimeZone,Locale)",
    "snippet": "    public F getInstance(String pattern, TimeZone timeZone, Locale locale) {\n        if (pattern == null) {\n            throw new NullPointerException(\"pattern must not be null\");\n        }\n        if (timeZone == null) {\n            timeZone = TimeZone.getDefault();\n        }\n        if (locale == null) {\n            locale = Locale.getDefault();\n        }\n        MultipartKey key = new MultipartKey(pattern, timeZone, locale);\n        F format = cInstanceCache.get(key);\n        if (format == null) {           \n            format = createInstance(pattern, timeZone, locale);\n            F previousValue= cInstanceCache.putIfAbsent(key, format);\n            if (previousValue != null) {\n                // another thread snuck in and did the same work\n                // we should return the instance that is in ConcurrentMap\n                format= previousValue;              \n            }\n        }\n        return format;\n    }",
    "comment": " <p>Gets a formatter instance using the specified pattern, time zone and locale.</p>  @param pattern  {@link java.text.SimpleDateFormat} compatible pattern @param timeZone  the non-null time zone @param locale  the non-null locale @return a pattern based date/time formatter @throws IllegalArgumentException if pattern is invalid or <code>null</code> ",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "MultipartKey.hashCode",
    "class_name": "org.apache.commons.lang3.time.FormatCache$MultipartKey",
    "signature": "org.apache.commons.lang3.time.FormatCache$MultipartKey.hashCode()",
    "snippet": "        @Override\n        public int hashCode() {\n            if(hashCode==0) {\n                int rc= 0;\n                for(Object key : keys) {\n                    if(key!=null) {\n                        rc= rc*7 + key.hashCode();\n                    }\n                }\n                hashCode= rc;\n            }\n            return hashCode;\n        }",
    "comment": " {@inheritDoc} ",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  }
]