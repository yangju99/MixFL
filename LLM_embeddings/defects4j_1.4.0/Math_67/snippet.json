[
  {
    "name": "ConvergingAlgorithmImpl.ConvergingAlgorithmImpl",
    "class_name": "org.apache.commons.math.ConvergingAlgorithmImpl",
    "signature": "org.apache.commons.math.ConvergingAlgorithmImpl.ConvergingAlgorithmImpl(int,double)",
    "snippet": "    protected ConvergingAlgorithmImpl(final int defaultMaximalIterationCount,\n                                      final double defaultAbsoluteAccuracy) {\n        this.defaultAbsoluteAccuracy = defaultAbsoluteAccuracy;\n        this.defaultRelativeAccuracy = 1.0e-14;\n        this.absoluteAccuracy = defaultAbsoluteAccuracy;\n        this.relativeAccuracy = defaultRelativeAccuracy;\n        this.defaultMaximalIterationCount = defaultMaximalIterationCount;\n        this.maximalIterationCount = defaultMaximalIterationCount;\n        this.iterationCount = 0;\n    }",
    "comment": " Construct an algorithm with given iteration count and accuracy.  @param defaultAbsoluteAccuracy maximum absolute error @param defaultMaximalIterationCount maximum number of iterations @throws IllegalArgumentException if f is null or the defaultAbsoluteAccuracy is not valid ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "ConvergingAlgorithmImpl.getAbsoluteAccuracy",
    "class_name": "org.apache.commons.math.ConvergingAlgorithmImpl",
    "signature": "org.apache.commons.math.ConvergingAlgorithmImpl.getAbsoluteAccuracy()",
    "snippet": "    public double getAbsoluteAccuracy() {\n        return absoluteAccuracy;\n    }",
    "comment": "{@inheritDoc} */",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "ConvergingAlgorithmImpl.getIterationCount",
    "class_name": "org.apache.commons.math.ConvergingAlgorithmImpl",
    "signature": "org.apache.commons.math.ConvergingAlgorithmImpl.getIterationCount()",
    "snippet": "    public int getIterationCount() {\n        return iterationCount;\n    }",
    "comment": "{@inheritDoc} */",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "ConvergingAlgorithmImpl.getRelativeAccuracy",
    "class_name": "org.apache.commons.math.ConvergingAlgorithmImpl",
    "signature": "org.apache.commons.math.ConvergingAlgorithmImpl.getRelativeAccuracy()",
    "snippet": "    public double getRelativeAccuracy() {\n        return relativeAccuracy;\n    }",
    "comment": "{@inheritDoc} */",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "ConvergingAlgorithmImpl.setAbsoluteAccuracy",
    "class_name": "org.apache.commons.math.ConvergingAlgorithmImpl",
    "signature": "org.apache.commons.math.ConvergingAlgorithmImpl.setAbsoluteAccuracy(double)",
    "snippet": "    public void setAbsoluteAccuracy(double accuracy) {\n        absoluteAccuracy = accuracy;\n    }",
    "comment": "{@inheritDoc} */",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "ConvergingAlgorithmImpl.setMaximalIterationCount",
    "class_name": "org.apache.commons.math.ConvergingAlgorithmImpl",
    "signature": "org.apache.commons.math.ConvergingAlgorithmImpl.setMaximalIterationCount(int)",
    "snippet": "    public void setMaximalIterationCount(int count) {\n        maximalIterationCount = count;\n    }",
    "comment": "{@inheritDoc} */",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "ConvergingAlgorithmImpl.setRelativeAccuracy",
    "class_name": "org.apache.commons.math.ConvergingAlgorithmImpl",
    "signature": "org.apache.commons.math.ConvergingAlgorithmImpl.setRelativeAccuracy(double)",
    "snippet": "    public void setRelativeAccuracy(double accuracy) {\n        relativeAccuracy = accuracy;\n    }",
    "comment": "{@inheritDoc} */",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "MathRuntimeException.createIllegalStateException",
    "class_name": "org.apache.commons.math.MathRuntimeException",
    "signature": "org.apache.commons.math.MathRuntimeException.createIllegalStateException(Localizable,Object[])",
    "snippet": "    public static IllegalStateException createIllegalStateException(final Localizable pattern,\n                                                                    final Object ... arguments) {\n        return new IllegalStateException() {\n\n            /** Serializable version identifier. */\n            private static final long serialVersionUID = 6880901520234515725L;\n\n            /** {@inheritDoc} */\n            @Override\n            public String getMessage() {\n                return buildMessage(Locale.US, pattern, arguments);\n            }\n\n            /** {@inheritDoc} */\n            @Override\n            public String getLocalizedMessage() {\n                return buildMessage(Locale.getDefault(), pattern, arguments);\n            }\n\n        };\n    }",
    "comment": " Constructs a new <code>IllegalStateException</code> with specified formatted detail message. Message formatting is delegated to {@link java.text.MessageFormat}. @param pattern format specifier @param arguments format arguments @return built exception @since 2.2 ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "MultiStartUnivariateRealOptimizer.MultiStartUnivariateRealOptimizer",
    "class_name": "org.apache.commons.math.optimization.MultiStartUnivariateRealOptimizer",
    "signature": "org.apache.commons.math.optimization.MultiStartUnivariateRealOptimizer.MultiStartUnivariateRealOptimizer(UnivariateRealOptimizer,int,RandomGenerator)",
    "snippet": "    public MultiStartUnivariateRealOptimizer(final UnivariateRealOptimizer optimizer,\n                                             final int starts,\n                                             final RandomGenerator generator) {\n        this.optimizer        = optimizer;\n        this.totalIterations  = 0;\n        this.starts           = starts;\n        this.generator        = generator;\n        this.optima           = null;\n        setMaximalIterationCount(Integer.MAX_VALUE);\n        setMaxEvaluations(Integer.MAX_VALUE);\n    }",
    "comment": " Create a multi-start optimizer from a single-start optimizer @param optimizer single-start optimizer to wrap @param starts number of starts to perform (including the first one), multi-start is disabled if value is less than or equal to 1 @param generator random generator to use for restarts ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "MultiStartUnivariateRealOptimizer.getAbsoluteAccuracy",
    "class_name": "org.apache.commons.math.optimization.MultiStartUnivariateRealOptimizer",
    "signature": "org.apache.commons.math.optimization.MultiStartUnivariateRealOptimizer.getAbsoluteAccuracy()",
    "snippet": "    public double getAbsoluteAccuracy() {\n        return optimizer.getAbsoluteAccuracy();\n    }",
    "comment": "{@inheritDoc} */",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "MultiStartUnivariateRealOptimizer.getOptima",
    "class_name": "org.apache.commons.math.optimization.MultiStartUnivariateRealOptimizer",
    "signature": "org.apache.commons.math.optimization.MultiStartUnivariateRealOptimizer.getOptima()",
    "snippet": "    public double[] getOptima() throws IllegalStateException {\n        if (optima == null) {\n            throw MathRuntimeException.createIllegalStateException(LocalizedFormats.NO_OPTIMUM_COMPUTED_YET);\n        }\n        return optima.clone();\n    }",
    "comment": "Get all the optima found during the last call to {@link #optimize(UnivariateRealFunction, GoalType, double, double) optimize}. <p>The optimizer stores all the optima found during a set of restarts. The {@link #optimize(UnivariateRealFunction, GoalType, double, double) optimize} method returns the best point only. This method returns all the points found at the end of each starts, including the best one already returned by the {@link #optimize(UnivariateRealFunction, GoalType, double, double) optimize} method. </p> <p> The returned array as one element for each start as specified in the constructor. It is ordered with the results from the runs that did converge first, sorted from best to worst objective value (i.e in ascending order if minimizing and in descending order if maximizing), followed by Double.NaN elements corresponding to the runs that did not converge. This means all elements will be NaN if the {@link #optimize(UnivariateRealFunction, GoalType, double, double) optimize} method did throw a {@link ConvergenceException ConvergenceException}). This also means that if the first element is not NaN, it is the best point found across all starts.</p> @return array containing the optima @exception IllegalStateException if {@link #optimize(UnivariateRealFunction, GoalType, double, double) optimize} has not been called @see #getOptimaValues() ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "MultiStartUnivariateRealOptimizer.getOptimaValues",
    "class_name": "org.apache.commons.math.optimization.MultiStartUnivariateRealOptimizer",
    "signature": "org.apache.commons.math.optimization.MultiStartUnivariateRealOptimizer.getOptimaValues()",
    "snippet": "    public double[] getOptimaValues() throws IllegalStateException {\n        if (optimaValues == null) {\n            throw MathRuntimeException.createIllegalStateException(LocalizedFormats.NO_OPTIMUM_COMPUTED_YET);\n        }\n        return optimaValues.clone();\n    }",
    "comment": "Get all the function values at optima found during the last call to {@link #optimize(UnivariateRealFunction, GoalType, double, double) optimize}. <p> The returned array as one element for each start as specified in the constructor. It is ordered with the results from the runs that did converge first, sorted from best to worst objective value (i.e in ascending order if minimizing and in descending order if maximizing), followed by Double.NaN elements corresponding to the runs that did not converge. This means all elements will be NaN if the {@link #optimize(UnivariateRealFunction, GoalType, double, double) optimize} method did throw a {@link ConvergenceException ConvergenceException}). This also means that if the first element is not NaN, it is the best point found across all starts.</p> @return array containing the optima @exception IllegalStateException if {@link #optimize(UnivariateRealFunction, GoalType, double, double) optimize} has not been called @see #getOptima() ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "MultiStartUnivariateRealOptimizer.getRelativeAccuracy",
    "class_name": "org.apache.commons.math.optimization.MultiStartUnivariateRealOptimizer",
    "signature": "org.apache.commons.math.optimization.MultiStartUnivariateRealOptimizer.getRelativeAccuracy()",
    "snippet": "    public double getRelativeAccuracy() {\n        return optimizer.getRelativeAccuracy();\n    }",
    "comment": "{@inheritDoc} */",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "MultiStartUnivariateRealOptimizer.getResult",
    "class_name": "org.apache.commons.math.optimization.MultiStartUnivariateRealOptimizer",
    "signature": "org.apache.commons.math.optimization.MultiStartUnivariateRealOptimizer.getResult()",
    "snippet": "    public double getResult() {\n        return optimizer.getResult();\n    }",
    "comment": "{@inheritDoc} */",
    "is_bug": true,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "MultiStartUnivariateRealOptimizer.optimize",
    "class_name": "org.apache.commons.math.optimization.MultiStartUnivariateRealOptimizer",
    "signature": "org.apache.commons.math.optimization.MultiStartUnivariateRealOptimizer.optimize(UnivariateRealFunction,GoalType,double,double)",
    "snippet": "    public double optimize(final UnivariateRealFunction f, final GoalType goalType,\n                           final double min, final double max)\n        throws ConvergenceException,\n            FunctionEvaluationException {\n\n        optima           = new double[starts];\n        optimaValues     = new double[starts];\n        totalIterations  = 0;\n        totalEvaluations = 0;\n\n        // multi-start loop\n        for (int i = 0; i < starts; ++i) {\n\n            try {\n                optimizer.setMaximalIterationCount(maxIterations - totalIterations);\n                optimizer.setMaxEvaluations(maxEvaluations - totalEvaluations);\n                final double bound1 = (i == 0) ? min : min + generator.nextDouble() * (max - min);\n                final double bound2 = (i == 0) ? max : min + generator.nextDouble() * (max - min);\n                optima[i]       = optimizer.optimize(f, goalType,\n                                                     Math.min(bound1, bound2),\n                                                     Math.max(bound1, bound2));\n                optimaValues[i] = optimizer.getFunctionValue();\n            } catch (FunctionEvaluationException fee) {\n                optima[i]       = Double.NaN;\n                optimaValues[i] = Double.NaN;\n            } catch (ConvergenceException ce) {\n                optima[i]       = Double.NaN;\n                optimaValues[i] = Double.NaN;\n            }\n\n            totalIterations  += optimizer.getIterationCount();\n            totalEvaluations += optimizer.getEvaluations();\n\n        }\n\n        // sort the optima from best to worst, followed by NaN elements\n        int lastNaN = optima.length;\n        for (int i = 0; i < lastNaN; ++i) {\n            if (Double.isNaN(optima[i])) {\n                optima[i] = optima[--lastNaN];\n                optima[lastNaN + 1] = Double.NaN;\n                optimaValues[i] = optimaValues[--lastNaN];\n                optimaValues[lastNaN + 1] = Double.NaN;\n            }\n        }\n\n        double currX = optima[0];\n        double currY = optimaValues[0];\n        for (int j = 1; j < lastNaN; ++j) {\n            final double prevY = currY;\n            currX = optima[j];\n            currY = optimaValues[j];\n            if ((goalType == GoalType.MAXIMIZE) ^ (currY < prevY)) {\n                // the current element should be inserted closer to the beginning\n                int i = j - 1;\n                double mIX = optima[i];\n                double mIY = optimaValues[i];\n                while ((i >= 0) && ((goalType == GoalType.MAXIMIZE) ^ (currY < mIY))) {\n                    optima[i + 1]       = mIX;\n                    optimaValues[i + 1] = mIY;\n                    if (i-- != 0) {\n                        mIX = optima[i];\n                        mIY = optimaValues[i];\n                    } else {\n                        mIX = Double.NaN;\n                        mIY = Double.NaN;\n                    }\n                }\n                optima[i + 1]       = currX;\n                optimaValues[i + 1] = currY;\n                currX = optima[j];\n                currY = optimaValues[j];\n            }\n        }\n\n        if (Double.isNaN(optima[0])) {\n            throw new OptimizationException(\n                    LocalizedFormats.NO_CONVERGENCE_WITH_ANY_START_POINT,\n                    starts);\n        }\n\n        // return the found point given the best objective function value\n        return optima[0];\n\n    }",
    "comment": "{@inheritDoc} */",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "MultiStartUnivariateRealOptimizer.setAbsoluteAccuracy",
    "class_name": "org.apache.commons.math.optimization.MultiStartUnivariateRealOptimizer",
    "signature": "org.apache.commons.math.optimization.MultiStartUnivariateRealOptimizer.setAbsoluteAccuracy(double)",
    "snippet": "    public void setAbsoluteAccuracy(double accuracy) {\n        optimizer.setAbsoluteAccuracy(accuracy);\n    }",
    "comment": "{@inheritDoc} */",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "MultiStartUnivariateRealOptimizer.setMaxEvaluations",
    "class_name": "org.apache.commons.math.optimization.MultiStartUnivariateRealOptimizer",
    "signature": "org.apache.commons.math.optimization.MultiStartUnivariateRealOptimizer.setMaxEvaluations(int)",
    "snippet": "    public void setMaxEvaluations(int maxEvaluations) {\n        this.maxEvaluations = maxEvaluations;\n    }",
    "comment": "{@inheritDoc} */",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "MultiStartUnivariateRealOptimizer.setMaximalIterationCount",
    "class_name": "org.apache.commons.math.optimization.MultiStartUnivariateRealOptimizer",
    "signature": "org.apache.commons.math.optimization.MultiStartUnivariateRealOptimizer.setMaximalIterationCount(int)",
    "snippet": "    public void setMaximalIterationCount(int count) {\n        this.maxIterations = count;\n    }",
    "comment": "{@inheritDoc} */",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "MultiStartUnivariateRealOptimizer.setRelativeAccuracy",
    "class_name": "org.apache.commons.math.optimization.MultiStartUnivariateRealOptimizer",
    "signature": "org.apache.commons.math.optimization.MultiStartUnivariateRealOptimizer.setRelativeAccuracy(double)",
    "snippet": "    public void setRelativeAccuracy(double accuracy) {\n        optimizer.setRelativeAccuracy(accuracy);\n    }",
    "comment": "{@inheritDoc} */",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "AbstractUnivariateRealOptimizer.AbstractUnivariateRealOptimizer",
    "class_name": "org.apache.commons.math.optimization.univariate.AbstractUnivariateRealOptimizer",
    "signature": "org.apache.commons.math.optimization.univariate.AbstractUnivariateRealOptimizer.AbstractUnivariateRealOptimizer(int,double)",
    "snippet": "    protected AbstractUnivariateRealOptimizer(final int defaultMaximalIterationCount,\n                                              final double defaultAbsoluteAccuracy) {\n        super(defaultMaximalIterationCount, defaultAbsoluteAccuracy);\n        resultComputed = false;\n        setMaxEvaluations(Integer.MAX_VALUE);\n    }",
    "comment": " Construct a solver with given iteration count and accuracy. FunctionEvaluationExceptionFunctionEvaluationException @param defaultAbsoluteAccuracy maximum absolute error @param defaultMaximalIterationCount maximum number of iterations @throws IllegalArgumentException if f is null or the defaultAbsoluteAccuracy is not valid ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "AbstractUnivariateRealOptimizer.checkResultComputed",
    "class_name": "org.apache.commons.math.optimization.univariate.AbstractUnivariateRealOptimizer",
    "signature": "org.apache.commons.math.optimization.univariate.AbstractUnivariateRealOptimizer.checkResultComputed()",
    "snippet": "    protected void checkResultComputed() throws IllegalStateException {\n        if (!resultComputed) {\n            throw MathRuntimeException.createIllegalStateException(LocalizedFormats.NO_RESULT_AVAILABLE);\n        }\n    }",
    "comment": "Check if a result has been computed. @exception IllegalStateException if no result has been computed ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "AbstractUnivariateRealOptimizer.clearResult",
    "class_name": "org.apache.commons.math.optimization.univariate.AbstractUnivariateRealOptimizer",
    "signature": "org.apache.commons.math.optimization.univariate.AbstractUnivariateRealOptimizer.clearResult()",
    "snippet": "    protected final void clearResult() {\n        this.resultComputed = false;\n    }",
    "comment": " Convenience function for implementations. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "AbstractUnivariateRealOptimizer.computeObjectiveValue",
    "class_name": "org.apache.commons.math.optimization.univariate.AbstractUnivariateRealOptimizer",
    "signature": "org.apache.commons.math.optimization.univariate.AbstractUnivariateRealOptimizer.computeObjectiveValue(UnivariateRealFunction,double)",
    "snippet": "    protected double computeObjectiveValue(final UnivariateRealFunction f,\n                                           final double point)\n        throws FunctionEvaluationException {\n        if (++evaluations > maxEvaluations) {\n            throw new FunctionEvaluationException(new MaxEvaluationsExceededException(maxEvaluations),\n                                                  point);\n        }\n        return f.value(point);\n    }",
    "comment": " Compute the objective function value. @param f objective function @param point point at which the objective function must be evaluated @return objective function value at specified point @exception FunctionEvaluationException if the function cannot be evaluated or the maximal number of iterations is exceeded ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "AbstractUnivariateRealOptimizer.getEvaluations",
    "class_name": "org.apache.commons.math.optimization.univariate.AbstractUnivariateRealOptimizer",
    "signature": "org.apache.commons.math.optimization.univariate.AbstractUnivariateRealOptimizer.getEvaluations()",
    "snippet": "    public int getEvaluations() {\n        return evaluations;\n    }",
    "comment": "{@inheritDoc} */",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "AbstractUnivariateRealOptimizer.getFunctionValue",
    "class_name": "org.apache.commons.math.optimization.univariate.AbstractUnivariateRealOptimizer",
    "signature": "org.apache.commons.math.optimization.univariate.AbstractUnivariateRealOptimizer.getFunctionValue()",
    "snippet": "    public double getFunctionValue() {\n        checkResultComputed();\n        return functionValue;\n    }",
    "comment": "{@inheritDoc} */",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "AbstractUnivariateRealOptimizer.getResult",
    "class_name": "org.apache.commons.math.optimization.univariate.AbstractUnivariateRealOptimizer",
    "signature": "org.apache.commons.math.optimization.univariate.AbstractUnivariateRealOptimizer.getResult()",
    "snippet": "    public double getResult() {\n        checkResultComputed();\n        return result;\n    }",
    "comment": "{@inheritDoc} */",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "AbstractUnivariateRealOptimizer.setMaxEvaluations",
    "class_name": "org.apache.commons.math.optimization.univariate.AbstractUnivariateRealOptimizer",
    "signature": "org.apache.commons.math.optimization.univariate.AbstractUnivariateRealOptimizer.setMaxEvaluations(int)",
    "snippet": "    public void setMaxEvaluations(int maxEvaluations) {\n        this.maxEvaluations = maxEvaluations;\n    }",
    "comment": "{@inheritDoc} */",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "AbstractUnivariateRealOptimizer.setResult",
    "class_name": "org.apache.commons.math.optimization.univariate.AbstractUnivariateRealOptimizer",
    "signature": "org.apache.commons.math.optimization.univariate.AbstractUnivariateRealOptimizer.setResult(double,double,int)",
    "snippet": "    protected final void setResult(final double x, final double fx,\n                                   final int iterationCount) {\n        this.result         = x;\n        this.functionValue  = fx;\n        this.iterationCount = iterationCount;\n        this.resultComputed = true;\n    }",
    "comment": " Convenience function for implementations.  @param x the result to set @param fx the result to set @param iterationCount the iteration count to set ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "BrentOptimizer.BrentOptimizer",
    "class_name": "org.apache.commons.math.optimization.univariate.BrentOptimizer",
    "signature": "org.apache.commons.math.optimization.univariate.BrentOptimizer.BrentOptimizer()",
    "snippet": "    public BrentOptimizer() {\n        super(100, 1E-10);\n    }",
    "comment": " Construct a solver. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "BrentOptimizer.localMin",
    "class_name": "org.apache.commons.math.optimization.univariate.BrentOptimizer",
    "signature": "org.apache.commons.math.optimization.univariate.BrentOptimizer.localMin(UnivariateRealFunction,GoalType,double,double,double,double)",
    "snippet": "    private double localMin(final UnivariateRealFunction f, final GoalType goalType,\n                            double a, double b, final double eps, final double t)\n        throws MaxIterationsExceededException, FunctionEvaluationException {\n        double x = a + GOLDEN_SECTION * (b - a);\n        double v = x;\n        double w = x;\n        double e = 0;\n        double fx = computeObjectiveValue(f, x);\n        if (goalType == GoalType.MAXIMIZE) {\n            fx = -fx;\n        }\n        double fv = fx;\n        double fw = fx;\n\n        int count = 0;\n        while (count < maximalIterationCount) {\n            double m = 0.5 * (a + b);\n            double tol = eps * Math.abs(x) + t;\n            double t2 = 2 * tol;\n\n            // Check stopping criterion.\n            if (Math.abs(x - m) > t2 - 0.5 * (b - a)) {\n                double p = 0;\n                double q = 0;\n                double r = 0;\n                double d = 0;\n                double u = 0;\n\n                if (Math.abs(e) > tol) { // Fit parabola.\n                    r = (x - w) * (fx - fv);\n                    q = (x - v) * (fx - fw);\n                    p = (x - v) * q - (x - w) * r;\n                    q = 2 * (q - r);\n\n                    if (q > 0) {\n                        p = -p;\n                    } else {\n                        q = -q;\n                    }\n\n                    r = e;\n                    e = d;\n                }\n\n                if (Math.abs(p) < Math.abs(0.5 * q * r) &&\n                    (p < q * (a - x)) && (p < q * (b - x))) { // Parabolic interpolation step.\n                    d = p / q;\n                    u = x + d;\n\n                    // f must not be evaluated too close to a or b.\n                    if (((u - a) < t2) || ((b - u) < t2)) {\n                        d = (x < m) ? tol : -tol;\n                    }\n                } else { // Golden section step.\n                    e = ((x < m) ? b : a) - x;\n                    d = GOLDEN_SECTION * e;\n                }\n\n                // f must not be evaluated too close to a or b.\n                u = x + ((Math.abs(d) > tol) ? d : ((d > 0) ? tol : -tol));\n                double fu = computeObjectiveValue(f, u);\n                if (goalType == GoalType.MAXIMIZE) {\n                    fu = -fu;\n                }\n\n                // Update a, b, v, w and x.\n                if (fu <= fx) {\n                    if (u < x) {\n                        b = x;\n                    } else {\n                        a = x;\n                    }\n                    v = w;\n                    fv = fw;\n                    w = x;\n                    fw = fx;\n                    x = u;\n                    fx = fu;\n                } else {\n                    if (u < x) {\n                        a = u;\n                    } else {\n                        b = u;\n                    }\n                    if ((fu <= fw) || (w == x)) {\n                        v = w;\n                        fv = fw;\n                        w = u;\n                        fw = fu;\n                    } else if ((fu <= fv) || (v == x) || (v == w)) {\n                        v = u;\n                        fv = fu;\n                    }\n                }\n            } else { // termination\n                setResult(x, (goalType == GoalType.MAXIMIZE) ? -fx : fx, count);\n                return x;\n            }\n\n            ++count;\n        }\n\n        throw new MaxIterationsExceededException(maximalIterationCount);\n\n    }",
    "comment": " Find the minimum of the function {@code f} within the interval {@code (a, b)}.  If the function {@code f} is defined on the interval {@code (a, b)}, then this method finds an approximation {@code x} to the point at which {@code f} attains its minimum.<br/> {@code t} and {@code eps} define a tolerance {@code tol = eps |x| + t} and {@code f} is never evaluated at two points closer together than {@code tol}. {@code eps} should be no smaller than <em>2 macheps</em> and preferable not much less than <em>sqrt(macheps)</em>, where <em>macheps</em> is the relative machine precision. {@code t} should be positive. @param f the function to solve @param goalType type of optimization goal: either {@link GoalType#MAXIMIZE} or {@link GoalType#MINIMIZE} @param a Lower bound of the interval @param b Higher bound of the interval @param eps Relative accuracy @param t Absolute accuracy @return the point at which the function is minimal. @throws MaxIterationsExceededException if the maximum iteration count is exceeded. @throws FunctionEvaluationException if an error occurs evaluating the function. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "BrentOptimizer.optimize",
    "class_name": "org.apache.commons.math.optimization.univariate.BrentOptimizer",
    "signature": "org.apache.commons.math.optimization.univariate.BrentOptimizer.optimize(UnivariateRealFunction,GoalType,double,double)",
    "snippet": "    public double optimize(final UnivariateRealFunction f, final GoalType goalType,\n                           final double min, final double max)\n        throws MaxIterationsExceededException, FunctionEvaluationException {\n        clearResult();\n        return localMin(f, goalType, min, max, relativeAccuracy, absoluteAccuracy);\n    }",
    "comment": "{@inheritDoc} */",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  }
]