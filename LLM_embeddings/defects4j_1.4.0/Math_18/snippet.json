[
  {
    "name": "AbstractRealMatrix.AbstractRealMatrix",
    "class_name": "org.apache.commons.math3.linear.AbstractRealMatrix",
    "signature": "org.apache.commons.math3.linear.AbstractRealMatrix.AbstractRealMatrix()",
    "snippet": "    protected AbstractRealMatrix() {}",
    "comment": " Creates a matrix with no data ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 3
  },
  {
    "name": "AbstractRealMatrix.AbstractRealMatrix",
    "class_name": "org.apache.commons.math3.linear.AbstractRealMatrix",
    "signature": "org.apache.commons.math3.linear.AbstractRealMatrix.AbstractRealMatrix(int,int)",
    "snippet": "    protected AbstractRealMatrix(final int rowDimension,\n        final int columnDimension)\n        throws NotStrictlyPositiveException {\n        if (rowDimension < 1) {\n            throw new NotStrictlyPositiveException(rowDimension);\n        }\n        if (columnDimension < 1) {\n            throw new NotStrictlyPositiveException(columnDimension);\n        }\n    }",
    "comment": " Create a new RealMatrix with the supplied row and column dimensions.  @param rowDimension  the number of rows in the new matrix @param columnDimension  the number of columns in the new matrix @throws NotStrictlyPositiveException if row or column dimension is not positive ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 3
  },
  {
    "name": "AbstractRealMatrix.add",
    "class_name": "org.apache.commons.math3.linear.AbstractRealMatrix",
    "signature": "org.apache.commons.math3.linear.AbstractRealMatrix.add(RealMatrix)",
    "snippet": "    public RealMatrix add(RealMatrix m)\n        throws MatrixDimensionMismatchException {\n        MatrixUtils.checkAdditionCompatible(this, m);\n\n        final int rowCount    = getRowDimension();\n        final int columnCount = getColumnDimension();\n        final RealMatrix out = createMatrix(rowCount, columnCount);\n        for (int row = 0; row < rowCount; ++row) {\n            for (int col = 0; col < columnCount; ++col) {\n                out.setEntry(row, col, getEntry(row, col) + m.getEntry(row, col));\n            }\n        }\n\n        return out;\n    }",
    "comment": "{@inheritDoc} */",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 3
  },
  {
    "name": "AbstractRealMatrix.getColumn",
    "class_name": "org.apache.commons.math3.linear.AbstractRealMatrix",
    "signature": "org.apache.commons.math3.linear.AbstractRealMatrix.getColumn(int)",
    "snippet": "    public double[] getColumn(final int column) throws OutOfRangeException {\n        MatrixUtils.checkColumnIndex(this, column);\n        final int nRows = getRowDimension();\n        final double[] out = new double[nRows];\n        for (int i = 0; i < nRows; ++i) {\n            out[i] = getEntry(i, column);\n        }\n\n        return out;\n    }",
    "comment": "{@inheritDoc} */",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 3
  },
  {
    "name": "AbstractRealMatrix.getColumnMatrix",
    "class_name": "org.apache.commons.math3.linear.AbstractRealMatrix",
    "signature": "org.apache.commons.math3.linear.AbstractRealMatrix.getColumnMatrix(int)",
    "snippet": "    public RealMatrix getColumnMatrix(final int column)\n        throws OutOfRangeException {\n        MatrixUtils.checkColumnIndex(this, column);\n        final int nRows = getRowDimension();\n        final RealMatrix out = createMatrix(nRows, 1);\n        for (int i = 0; i < nRows; ++i) {\n            out.setEntry(i, 0, getEntry(i, column));\n        }\n\n        return out;\n    }",
    "comment": "{@inheritDoc} */",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 3
  },
  {
    "name": "AbstractRealMatrix.getFrobeniusNorm",
    "class_name": "org.apache.commons.math3.linear.AbstractRealMatrix",
    "signature": "org.apache.commons.math3.linear.AbstractRealMatrix.getFrobeniusNorm()",
    "snippet": "    public double getFrobeniusNorm() {\n        return walkInOptimizedOrder(new RealMatrixPreservingVisitor() {\n\n            /** Sum of squared entries. */\n            private double sum;\n\n            /** {@inheritDoc} */\n            public void start(final int rows, final int columns,\n                              final int startRow, final int endRow,\n                              final int startColumn, final int endColumn) {\n                sum = 0;\n            }\n\n            /** {@inheritDoc} */\n            public void visit(final int row, final int column, final double value) {\n                sum += value * value;\n            }\n\n            /** {@inheritDoc} */\n            public double end() {\n                return FastMath.sqrt(sum);\n            }\n        });\n    }",
    "comment": "{@inheritDoc} */",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 3
  },
  {
    "name": "AbstractRealMatrix.getRow",
    "class_name": "org.apache.commons.math3.linear.AbstractRealMatrix",
    "signature": "org.apache.commons.math3.linear.AbstractRealMatrix.getRow(int)",
    "snippet": "    public double[] getRow(final int row) throws OutOfRangeException {\n        MatrixUtils.checkRowIndex(this, row);\n        final int nCols = getColumnDimension();\n        final double[] out = new double[nCols];\n        for (int i = 0; i < nCols; ++i) {\n            out[i] = getEntry(row, i);\n        }\n\n        return out;\n    }",
    "comment": "{@inheritDoc} */",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 3
  },
  {
    "name": "AbstractRealMatrix.isSquare",
    "class_name": "org.apache.commons.math3.linear.AbstractRealMatrix",
    "signature": "org.apache.commons.math3.linear.AbstractRealMatrix.isSquare()",
    "snippet": "    public boolean isSquare() {\n        return getColumnDimension() == getRowDimension();\n    }",
    "comment": "{@inheritDoc} */",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 3
  },
  {
    "name": "AbstractRealMatrix.multiply",
    "class_name": "org.apache.commons.math3.linear.AbstractRealMatrix",
    "signature": "org.apache.commons.math3.linear.AbstractRealMatrix.multiply(RealMatrix)",
    "snippet": "    public RealMatrix multiply(final RealMatrix m)\n        throws DimensionMismatchException {\n        MatrixUtils.checkMultiplicationCompatible(this, m);\n\n        final int nRows = getRowDimension();\n        final int nCols = m.getColumnDimension();\n        final int nSum  = getColumnDimension();\n        final RealMatrix out = createMatrix(nRows, nCols);\n        for (int row = 0; row < nRows; ++row) {\n            for (int col = 0; col < nCols; ++col) {\n                double sum = 0;\n                for (int i = 0; i < nSum; ++i) {\n                    sum += getEntry(row, i) * m.getEntry(i, col);\n                }\n                out.setEntry(row, col, sum);\n            }\n        }\n\n        return out;\n    }",
    "comment": "{@inheritDoc} */",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 3
  },
  {
    "name": "AbstractRealMatrix.scalarAdd",
    "class_name": "org.apache.commons.math3.linear.AbstractRealMatrix",
    "signature": "org.apache.commons.math3.linear.AbstractRealMatrix.scalarAdd(double)",
    "snippet": "    public RealMatrix scalarAdd(final double d) {\n        final int rowCount    = getRowDimension();\n        final int columnCount = getColumnDimension();\n        final RealMatrix out = createMatrix(rowCount, columnCount);\n        for (int row = 0; row < rowCount; ++row) {\n            for (int col = 0; col < columnCount; ++col) {\n                out.setEntry(row, col, getEntry(row, col) + d);\n            }\n        }\n\n        return out;\n    }",
    "comment": "{@inheritDoc} */",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 3
  },
  {
    "name": "AbstractRealMatrix.scalarMultiply",
    "class_name": "org.apache.commons.math3.linear.AbstractRealMatrix",
    "signature": "org.apache.commons.math3.linear.AbstractRealMatrix.scalarMultiply(double)",
    "snippet": "    public RealMatrix scalarMultiply(final double d) {\n        final int rowCount    = getRowDimension();\n        final int columnCount = getColumnDimension();\n        final RealMatrix out = createMatrix(rowCount, columnCount);\n        for (int row = 0; row < rowCount; ++row) {\n            for (int col = 0; col < columnCount; ++col) {\n                out.setEntry(row, col, getEntry(row, col) * d);\n            }\n        }\n\n        return out;\n    }",
    "comment": "{@inheritDoc} */",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 3
  },
  {
    "name": "AbstractRealMatrix.setColumnVector",
    "class_name": "org.apache.commons.math3.linear.AbstractRealMatrix",
    "signature": "org.apache.commons.math3.linear.AbstractRealMatrix.setColumnVector(int,RealVector)",
    "snippet": "    public void setColumnVector(final int column, final RealVector vector)\n        throws OutOfRangeException, MatrixDimensionMismatchException {\n        MatrixUtils.checkColumnIndex(this, column);\n        final int nRows = getRowDimension();\n        if (vector.getDimension() != nRows) {\n            throw new MatrixDimensionMismatchException(vector.getDimension(), 1,\n                                                       nRows, 1);\n        }\n        for (int i = 0; i < nRows; ++i) {\n            setEntry(i, column, vector.getEntry(i));\n        }\n    }",
    "comment": "{@inheritDoc} */",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 3
  },
  {
    "name": "AbstractRealMatrix.subtract",
    "class_name": "org.apache.commons.math3.linear.AbstractRealMatrix",
    "signature": "org.apache.commons.math3.linear.AbstractRealMatrix.subtract(RealMatrix)",
    "snippet": "    public RealMatrix subtract(final RealMatrix m)\n        throws MatrixDimensionMismatchException {\n        MatrixUtils.checkSubtractionCompatible(this, m);\n\n        final int rowCount    = getRowDimension();\n        final int columnCount = getColumnDimension();\n        final RealMatrix out = createMatrix(rowCount, columnCount);\n        for (int row = 0; row < rowCount; ++row) {\n            for (int col = 0; col < columnCount; ++col) {\n                out.setEntry(row, col, getEntry(row, col) - m.getEntry(row, col));\n            }\n        }\n\n        return out;\n    }",
    "comment": "{@inheritDoc} */",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 3
  },
  {
    "name": "AbstractRealMatrix.transpose",
    "class_name": "org.apache.commons.math3.linear.AbstractRealMatrix",
    "signature": "org.apache.commons.math3.linear.AbstractRealMatrix.transpose()",
    "snippet": "    public RealMatrix transpose() {\n        final int nRows = getRowDimension();\n        final int nCols = getColumnDimension();\n        final RealMatrix out = createMatrix(nCols, nRows);\n        walkInOptimizedOrder(new DefaultRealMatrixPreservingVisitor() {\n\n            /** {@inheritDoc} */\n            @Override\n            public void visit(final int row, final int column, final double value) {\n                out.setEntry(column, row, value);\n            }\n\n        });\n\n        return out;\n    }",
    "comment": "{@inheritDoc} */",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 3
  },
  {
    "name": "AbstractRealMatrix.walkInOptimizedOrder",
    "class_name": "org.apache.commons.math3.linear.AbstractRealMatrix",
    "signature": "org.apache.commons.math3.linear.AbstractRealMatrix.walkInOptimizedOrder(RealMatrixPreservingVisitor)",
    "snippet": "    public double walkInOptimizedOrder(final RealMatrixPreservingVisitor visitor) {\n        return walkInRowOrder(visitor);\n    }",
    "comment": "{@inheritDoc} */",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 3
  },
  {
    "name": "Array2DRowRealMatrix.Array2DRowRealMatrix",
    "class_name": "org.apache.commons.math3.linear.Array2DRowRealMatrix",
    "signature": "org.apache.commons.math3.linear.Array2DRowRealMatrix.Array2DRowRealMatrix(double[][])",
    "snippet": "    public Array2DRowRealMatrix(final double[][] d)\n        throws DimensionMismatchException, NoDataException, NullArgumentException {\n        copyIn(d);\n    }",
    "comment": " Create a new {@code RealMatrix} using the input array as the underlying data array. <p>The input array is copied, not referenced. This constructor has the same effect as calling {@link #Array2DRowRealMatrix(double[][], boolean)} with the second argument set to {@code true}.</p>  @param d Data for the new matrix. @throws DimensionMismatchException if {@code d} is not rectangular. @throws NoDataException if {@code d} row or colum dimension is zero. @throws NullArgumentException if {@code d} is {@code null}. @see #Array2DRowRealMatrix(double[][], boolean) ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 3
  },
  {
    "name": "Array2DRowRealMatrix.Array2DRowRealMatrix",
    "class_name": "org.apache.commons.math3.linear.Array2DRowRealMatrix",
    "signature": "org.apache.commons.math3.linear.Array2DRowRealMatrix.Array2DRowRealMatrix(double[][],boolean)",
    "snippet": "    public Array2DRowRealMatrix(final double[][] d, final boolean copyArray)\n        throws DimensionMismatchException, NoDataException,\n        NullArgumentException {\n        if (copyArray) {\n            copyIn(d);\n        } else {\n            if (d == null) {\n                throw new NullArgumentException();\n            }\n            final int nRows = d.length;\n            if (nRows == 0) {\n                throw new NoDataException(LocalizedFormats.AT_LEAST_ONE_ROW);\n            }\n            final int nCols = d[0].length;\n            if (nCols == 0) {\n                throw new NoDataException(LocalizedFormats.AT_LEAST_ONE_COLUMN);\n            }\n            for (int r = 1; r < nRows; r++) {\n                if (d[r].length != nCols) {\n                    throw new DimensionMismatchException(d[r].length, nCols);\n                }\n            }\n            data = d;\n        }\n    }",
    "comment": " Create a new RealMatrix using the input array as the underlying data array. If an array is built specially in order to be embedded in a RealMatrix and not used directly, the {@code copyArray} may be set to {@code false}. This will prevent the copying and improve performance as no new array will be built and no data will be copied.  @param d Data for new matrix. @param copyArray if {@code true}, the input array will be copied, otherwise it will be referenced. @throws DimensionMismatchException if {@code d} is not rectangular. @throws NoDataException if {@code d} row or colum dimension is zero. @throws NullArgumentException if {@code d} is {@code null}. @see #Array2DRowRealMatrix(double[][]) ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 3
  },
  {
    "name": "Array2DRowRealMatrix.Array2DRowRealMatrix",
    "class_name": "org.apache.commons.math3.linear.Array2DRowRealMatrix",
    "signature": "org.apache.commons.math3.linear.Array2DRowRealMatrix.Array2DRowRealMatrix(int,int)",
    "snippet": "    public Array2DRowRealMatrix(final int rowDimension,\n                                final int columnDimension)\n        throws NotStrictlyPositiveException {\n        super(rowDimension, columnDimension);\n        data = new double[rowDimension][columnDimension];\n    }",
    "comment": " Create a new RealMatrix with the supplied row and column dimensions.  @param rowDimension Number of rows in the new matrix. @param columnDimension Number of columns in the new matrix. @throws NotStrictlyPositiveException if the row or column dimension is not positive. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 3
  },
  {
    "name": "Array2DRowRealMatrix.copyIn",
    "class_name": "org.apache.commons.math3.linear.Array2DRowRealMatrix",
    "signature": "org.apache.commons.math3.linear.Array2DRowRealMatrix.copyIn(double[][])",
    "snippet": "    private void copyIn(final double[][] in)\n        throws DimensionMismatchException, NoDataException, NullArgumentException {\n        setSubMatrix(in, 0, 0);\n    }",
    "comment": " Replace data with a fresh copy of the input array.  @param in Data to copy. @throws NoDataException if the input array is empty. @throws DimensionMismatchException if the input array is not rectangular. @throws NullArgumentException if the input array is {@code null}. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 3
  },
  {
    "name": "Array2DRowRealMatrix.copyOut",
    "class_name": "org.apache.commons.math3.linear.Array2DRowRealMatrix",
    "signature": "org.apache.commons.math3.linear.Array2DRowRealMatrix.copyOut()",
    "snippet": "    private double[][] copyOut() {\n        final int nRows = this.getRowDimension();\n        final double[][] out = new double[nRows][this.getColumnDimension()];\n        // can't copy 2-d array in one shot, otherwise get row references\n        for (int i = 0; i < nRows; i++) {\n            System.arraycopy(data[i], 0, out[i], 0, data[i].length);\n        }\n        return out;\n    }",
    "comment": " Get a fresh copy of the underlying data array.  @return a copy of the underlying data array. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 3
  },
  {
    "name": "Array2DRowRealMatrix.createMatrix",
    "class_name": "org.apache.commons.math3.linear.Array2DRowRealMatrix",
    "signature": "org.apache.commons.math3.linear.Array2DRowRealMatrix.createMatrix(int,int)",
    "snippet": "    @Override\n    public RealMatrix createMatrix(final int rowDimension,\n                                   final int columnDimension)\n        throws NotStrictlyPositiveException {\n        return new Array2DRowRealMatrix(rowDimension, columnDimension);\n    }",
    "comment": "{@inheritDoc} */",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 3
  },
  {
    "name": "Array2DRowRealMatrix.getColumnDimension",
    "class_name": "org.apache.commons.math3.linear.Array2DRowRealMatrix",
    "signature": "org.apache.commons.math3.linear.Array2DRowRealMatrix.getColumnDimension()",
    "snippet": "    @Override\n    public int getColumnDimension() {\n        return ((data == null) || (data[0] == null)) ? 0 : data[0].length;\n    }",
    "comment": "{@inheritDoc} */",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 3
  },
  {
    "name": "Array2DRowRealMatrix.getData",
    "class_name": "org.apache.commons.math3.linear.Array2DRowRealMatrix",
    "signature": "org.apache.commons.math3.linear.Array2DRowRealMatrix.getData()",
    "snippet": "    @Override\n    public double[][] getData() {\n        return copyOut();\n    }",
    "comment": "{@inheritDoc} */",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 3
  },
  {
    "name": "Array2DRowRealMatrix.getEntry",
    "class_name": "org.apache.commons.math3.linear.Array2DRowRealMatrix",
    "signature": "org.apache.commons.math3.linear.Array2DRowRealMatrix.getEntry(int,int)",
    "snippet": "    @Override\n    public double getEntry(final int row, final int column)\n        throws OutOfRangeException {\n        MatrixUtils.checkMatrixIndex(this, row, column);\n        return data[row][column];\n    }",
    "comment": "{@inheritDoc} */",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 3
  },
  {
    "name": "Array2DRowRealMatrix.getRowDimension",
    "class_name": "org.apache.commons.math3.linear.Array2DRowRealMatrix",
    "signature": "org.apache.commons.math3.linear.Array2DRowRealMatrix.getRowDimension()",
    "snippet": "    @Override\n    public int getRowDimension() {\n        return (data == null) ? 0 : data.length;\n    }",
    "comment": "{@inheritDoc} */",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 3
  },
  {
    "name": "Array2DRowRealMatrix.setEntry",
    "class_name": "org.apache.commons.math3.linear.Array2DRowRealMatrix",
    "signature": "org.apache.commons.math3.linear.Array2DRowRealMatrix.setEntry(int,int,double)",
    "snippet": "    @Override\n    public void setEntry(final int row, final int column, final double value)\n        throws OutOfRangeException {\n        MatrixUtils.checkMatrixIndex(this, row, column);\n        data[row][column] = value;\n    }",
    "comment": "{@inheritDoc} */",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 3
  },
  {
    "name": "Array2DRowRealMatrix.setSubMatrix",
    "class_name": "org.apache.commons.math3.linear.Array2DRowRealMatrix",
    "signature": "org.apache.commons.math3.linear.Array2DRowRealMatrix.setSubMatrix(double[][],int,int)",
    "snippet": "    @Override\n    public void setSubMatrix(final double[][] subMatrix, final int row,\n                             final int column)\n        throws NoDataException, OutOfRangeException,\n        DimensionMismatchException, NullArgumentException {\n        if (data == null) {\n            if (row > 0) {\n                throw new MathIllegalStateException(LocalizedFormats.FIRST_ROWS_NOT_INITIALIZED_YET, row);\n            }\n            if (column > 0) {\n                throw new MathIllegalStateException(LocalizedFormats.FIRST_COLUMNS_NOT_INITIALIZED_YET, column);\n            }\n            MathUtils.checkNotNull(subMatrix);\n            final int nRows = subMatrix.length;\n            if (nRows == 0) {\n                throw new NoDataException(LocalizedFormats.AT_LEAST_ONE_ROW);\n            }\n\n            final int nCols = subMatrix[0].length;\n            if (nCols == 0) {\n                throw new NoDataException(LocalizedFormats.AT_LEAST_ONE_COLUMN);\n            }\n            data = new double[subMatrix.length][nCols];\n            for (int i = 0; i < data.length; ++i) {\n                if (subMatrix[i].length != nCols) {\n                    throw new DimensionMismatchException(subMatrix[i].length, nCols);\n                }\n                System.arraycopy(subMatrix[i], 0, data[i + row], column, nCols);\n            }\n        } else {\n            super.setSubMatrix(subMatrix, row, column);\n        }\n\n    }",
    "comment": "{@inheritDoc} */",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 3
  },
  {
    "name": "Array2DRowRealMatrix.walkInRowOrder",
    "class_name": "org.apache.commons.math3.linear.Array2DRowRealMatrix",
    "signature": "org.apache.commons.math3.linear.Array2DRowRealMatrix.walkInRowOrder(RealMatrixPreservingVisitor)",
    "snippet": "    @Override\n    public double walkInRowOrder(final RealMatrixPreservingVisitor visitor) {\n        final int rows    = getRowDimension();\n        final int columns = getColumnDimension();\n        visitor.start(rows, columns, 0, rows - 1, 0, columns - 1);\n        for (int i = 0; i < rows; ++i) {\n            final double[] rowI = data[i];\n            for (int j = 0; j < columns; ++j) {\n                visitor.visit(i, j, rowI[j]);\n            }\n        }\n        return visitor.end();\n    }",
    "comment": "{@inheritDoc} */",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 3
  },
  {
    "name": "ArrayRealVector.ArrayRealVector",
    "class_name": "org.apache.commons.math3.linear.ArrayRealVector",
    "signature": "org.apache.commons.math3.linear.ArrayRealVector.ArrayRealVector(double[])",
    "snippet": "    public ArrayRealVector(double[] d) {\n        data = d.clone();\n    }",
    "comment": " Construct a vector from an array, copying the input array.  @param d Array. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 3
  },
  {
    "name": "ArrayRealVector.getDimension",
    "class_name": "org.apache.commons.math3.linear.ArrayRealVector",
    "signature": "org.apache.commons.math3.linear.ArrayRealVector.getDimension()",
    "snippet": "    @Override\n    public int getDimension() {\n        return data.length;\n    }",
    "comment": "{@inheritDoc} */",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 3
  },
  {
    "name": "ArrayRealVector.getEntry",
    "class_name": "org.apache.commons.math3.linear.ArrayRealVector",
    "signature": "org.apache.commons.math3.linear.ArrayRealVector.getEntry(int)",
    "snippet": "    @Override\n    public double getEntry(int index) throws OutOfRangeException {\n        try {\n            return data[index];\n        } catch (IndexOutOfBoundsException e) {\n            throw new OutOfRangeException(LocalizedFormats.INDEX, index, 0,\n                getDimension() - 1);\n        }\n    }",
    "comment": "{@inheritDoc} */",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 3
  },
  {
    "name": "DefaultRealMatrixPreservingVisitor.end",
    "class_name": "org.apache.commons.math3.linear.DefaultRealMatrixPreservingVisitor",
    "signature": "org.apache.commons.math3.linear.DefaultRealMatrixPreservingVisitor.end()",
    "snippet": "    public double end() {\n        return 0;\n    }",
    "comment": "{@inheritDoc} */",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 3
  },
  {
    "name": "DefaultRealMatrixPreservingVisitor.start",
    "class_name": "org.apache.commons.math3.linear.DefaultRealMatrixPreservingVisitor",
    "signature": "org.apache.commons.math3.linear.DefaultRealMatrixPreservingVisitor.start(int,int,int,int,int,int)",
    "snippet": "    public void start(int rows, int columns,\n                      int startRow, int endRow, int startColumn, int endColumn) {\n    }",
    "comment": "{@inheritDoc} */",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 3
  },
  {
    "name": "EigenDecomposition.EigenDecomposition",
    "class_name": "org.apache.commons.math3.linear.EigenDecomposition",
    "signature": "org.apache.commons.math3.linear.EigenDecomposition.EigenDecomposition(RealMatrix)",
    "snippet": "    public EigenDecomposition(final RealMatrix matrix)\n        throws MathArithmeticException {\n        if (isSymmetric(matrix, false)) {\n            transformToTridiagonal(matrix);\n            findEigenVectors(transformer.getQ().getData());\n        } else {\n            final SchurTransformer t = transformToSchur(matrix);\n            findEigenVectorsFromSchur(t);\n        }\n    }",
    "comment": " Calculates the eigen decomposition of the given real matrix. <p> Supports decomposition of a general matrix since 3.1.  @param matrix Matrix to decompose. @throws MaxCountExceededException if the algorithm fails to converge. @throws MathArithmeticException if the decomposition of a general matrix results in a matrix with zero norm ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 3
  },
  {
    "name": "EigenDecomposition.findEigenVectors",
    "class_name": "org.apache.commons.math3.linear.EigenDecomposition",
    "signature": "org.apache.commons.math3.linear.EigenDecomposition.findEigenVectors(double[][])",
    "snippet": "    private void findEigenVectors(final double[][] householderMatrix) {\n        final double[][]z = householderMatrix.clone();\n        final int n = main.length;\n        realEigenvalues = new double[n];\n        imagEigenvalues = new double[n];\n        final double[] e = new double[n];\n        for (int i = 0; i < n - 1; i++) {\n            realEigenvalues[i] = main[i];\n            e[i] = secondary[i];\n        }\n        realEigenvalues[n - 1] = main[n - 1];\n        e[n - 1] = 0;\n\n        // Determine the largest main and secondary value in absolute term.\n        double maxAbsoluteValue = 0;\n        for (int i = 0; i < n; i++) {\n            if (FastMath.abs(realEigenvalues[i]) > maxAbsoluteValue) {\n                maxAbsoluteValue = FastMath.abs(realEigenvalues[i]);\n            }\n            if (FastMath.abs(e[i]) > maxAbsoluteValue) {\n                maxAbsoluteValue = FastMath.abs(e[i]);\n            }\n        }\n        // Make null any main and secondary value too small to be significant\n        if (maxAbsoluteValue != 0) {\n            for (int i=0; i < n; i++) {\n                if (FastMath.abs(realEigenvalues[i]) <= Precision.EPSILON * maxAbsoluteValue) {\n                    realEigenvalues[i] = 0;\n                }\n                if (FastMath.abs(e[i]) <= Precision.EPSILON * maxAbsoluteValue) {\n                    e[i]=0;\n                }\n            }\n        }\n\n        for (int j = 0; j < n; j++) {\n            int its = 0;\n            int m;\n            do {\n                for (m = j; m < n - 1; m++) {\n                    double delta = FastMath.abs(realEigenvalues[m]) +\n                        FastMath.abs(realEigenvalues[m + 1]);\n                    if (FastMath.abs(e[m]) + delta == delta) {\n                        break;\n                    }\n                }\n                if (m != j) {\n                    if (its == maxIter) {\n                        throw new MaxCountExceededException(LocalizedFormats.CONVERGENCE_FAILED,\n                                                            maxIter);\n                    }\n                    its++;\n                    double q = (realEigenvalues[j + 1] - realEigenvalues[j]) / (2 * e[j]);\n                    double t = FastMath.sqrt(1 + q * q);\n                    if (q < 0.0) {\n                        q = realEigenvalues[m] - realEigenvalues[j] + e[j] / (q - t);\n                    } else {\n                        q = realEigenvalues[m] - realEigenvalues[j] + e[j] / (q + t);\n                    }\n                    double u = 0.0;\n                    double s = 1.0;\n                    double c = 1.0;\n                    int i;\n                    for (i = m - 1; i >= j; i--) {\n                        double p = s * e[i];\n                        double h = c * e[i];\n                        if (FastMath.abs(p) >= FastMath.abs(q)) {\n                            c = q / p;\n                            t = FastMath.sqrt(c * c + 1.0);\n                            e[i + 1] = p * t;\n                            s = 1.0 / t;\n                            c = c * s;\n                        } else {\n                            s = p / q;\n                            t = FastMath.sqrt(s * s + 1.0);\n                            e[i + 1] = q * t;\n                            c = 1.0 / t;\n                            s = s * c;\n                        }\n                        if (e[i + 1] == 0.0) {\n                            realEigenvalues[i + 1] -= u;\n                            e[m] = 0.0;\n                            break;\n                        }\n                        q = realEigenvalues[i + 1] - u;\n                        t = (realEigenvalues[i] - q) * s + 2.0 * c * h;\n                        u = s * t;\n                        realEigenvalues[i + 1] = q + u;\n                        q = c * t - h;\n                        for (int ia = 0; ia < n; ia++) {\n                            p = z[ia][i + 1];\n                            z[ia][i + 1] = s * z[ia][i] + c * p;\n                            z[ia][i] = c * z[ia][i] - s * p;\n                        }\n                    }\n                    if (t == 0.0 && i >= j) {\n                        continue;\n                    }\n                    realEigenvalues[j] -= u;\n                    e[j] = q;\n                    e[m] = 0.0;\n                }\n            } while (m != j);\n        }\n\n        //Sort the eigen values (and vectors) in increase order\n        for (int i = 0; i < n; i++) {\n            int k = i;\n            double p = realEigenvalues[i];\n            for (int j = i + 1; j < n; j++) {\n                if (realEigenvalues[j] > p) {\n                    k = j;\n                    p = realEigenvalues[j];\n                }\n            }\n            if (k != i) {\n                realEigenvalues[k] = realEigenvalues[i];\n                realEigenvalues[i] = p;\n                for (int j = 0; j < n; j++) {\n                    p = z[j][i];\n                    z[j][i] = z[j][k];\n                    z[j][k] = p;\n                }\n            }\n        }\n\n        // Determine the largest eigen value in absolute term.\n        maxAbsoluteValue = 0;\n        for (int i = 0; i < n; i++) {\n            if (FastMath.abs(realEigenvalues[i]) > maxAbsoluteValue) {\n                maxAbsoluteValue=FastMath.abs(realEigenvalues[i]);\n            }\n        }\n        // Make null any eigen value too small to be significant\n        if (maxAbsoluteValue != 0.0) {\n            for (int i=0; i < n; i++) {\n                if (FastMath.abs(realEigenvalues[i]) < Precision.EPSILON * maxAbsoluteValue) {\n                    realEigenvalues[i] = 0;\n                }\n            }\n        }\n        eigenvectors = new ArrayRealVector[n];\n        final double[] tmp = new double[n];\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < n; j++) {\n                tmp[j] = z[j][i];\n            }\n            eigenvectors[i] = new ArrayRealVector(tmp);\n        }\n    }",
    "comment": " Find eigenvalues and eigenvectors (Dubrulle et al., 1971)  @param householderMatrix Householder matrix of the transformation to tridiagonal form. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 3
  },
  {
    "name": "EigenDecomposition.getD",
    "class_name": "org.apache.commons.math3.linear.EigenDecomposition",
    "signature": "org.apache.commons.math3.linear.EigenDecomposition.getD()",
    "snippet": "    public RealMatrix getD() {\n\n        if (cachedD == null) {\n            // cache the matrix for subsequent calls\n            cachedD = MatrixUtils.createRealDiagonalMatrix(realEigenvalues);\n\n            for (int i = 0; i < imagEigenvalues.length; i++) {\n                if (Precision.compareTo(imagEigenvalues[i], 0.0, EPSILON) > 0) {\n                    cachedD.setEntry(i, i+1, imagEigenvalues[i]);\n                } else if (Precision.compareTo(imagEigenvalues[i], 0.0, EPSILON) < 0) {\n                    cachedD.setEntry(i, i-1, imagEigenvalues[i]);\n                }\n            }\n        }\n        return cachedD;\n    }",
    "comment": " Gets the block diagonal matrix D of the decomposition. D is a block diagonal matrix. Real eigenvalues are on the diagonal while complex values are on 2x2 blocks { {real +imaginary}, {-imaginary, real} }.  @return the D matrix.  @see #getRealEigenvalues() @see #getImagEigenvalues() ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 3
  },
  {
    "name": "EigenDecomposition.getV",
    "class_name": "org.apache.commons.math3.linear.EigenDecomposition",
    "signature": "org.apache.commons.math3.linear.EigenDecomposition.getV()",
    "snippet": "    public RealMatrix getV() {\n\n        if (cachedV == null) {\n            final int m = eigenvectors.length;\n            cachedV = MatrixUtils.createRealMatrix(m, m);\n            for (int k = 0; k < m; ++k) {\n                cachedV.setColumnVector(k, eigenvectors[k]);\n            }\n        }\n        // return the cached matrix\n        return cachedV;\n    }",
    "comment": " Gets the matrix V of the decomposition. V is an orthogonal matrix, i.e. its transpose is also its inverse. The columns of V are the eigenvectors of the original matrix. No assumption is made about the orientation of the system axes formed by the columns of V (e.g. in a 3-dimension space, V can form a left- or right-handed system).  @return the V matrix. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 3
  },
  {
    "name": "EigenDecomposition.isSymmetric",
    "class_name": "org.apache.commons.math3.linear.EigenDecomposition",
    "signature": "org.apache.commons.math3.linear.EigenDecomposition.isSymmetric(RealMatrix,boolean)",
    "snippet": "    private boolean isSymmetric(final RealMatrix matrix,\n                                boolean raiseException) {\n        final int rows = matrix.getRowDimension();\n        final int columns = matrix.getColumnDimension();\n        final double eps = 10 * rows * columns * Precision.EPSILON;\n        for (int i = 0; i < rows; ++i) {\n            for (int j = i + 1; j < columns; ++j) {\n                final double mij = matrix.getEntry(i, j);\n                final double mji = matrix.getEntry(j, i);\n                if (FastMath.abs(mij - mji) >\n                    (FastMath.max(FastMath.abs(mij), FastMath.abs(mji)) * eps)) {\n                    if (raiseException) {\n                        throw new NonSymmetricMatrixException(i, j, eps);\n                    }\n                    return false;\n                }\n            }\n        }\n        return true;\n    }",
    "comment": " Check if a matrix is symmetric.  @param matrix Matrix to check. @param raiseException If {@code true}, the method will throw an exception if {@code matrix} is not symmetric. @return {@code true} if {@code matrix} is symmetric. @throws NonSymmetricMatrixException if the matrix is not symmetric and {@code raiseException} is {@code true}. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 3
  },
  {
    "name": "EigenDecomposition.transformToTridiagonal",
    "class_name": "org.apache.commons.math3.linear.EigenDecomposition",
    "signature": "org.apache.commons.math3.linear.EigenDecomposition.transformToTridiagonal(RealMatrix)",
    "snippet": "    private void transformToTridiagonal(final RealMatrix matrix) {\n        // transform the matrix to tridiagonal\n        transformer = new TriDiagonalTransformer(matrix);\n        main = transformer.getMainDiagonalRef();\n        secondary = transformer.getSecondaryDiagonalRef();\n    }",
    "comment": " Transforms the matrix to tridiagonal form.  @param matrix Matrix to transform. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 3
  },
  {
    "name": "MatrixUtils.checkAdditionCompatible",
    "class_name": "org.apache.commons.math3.linear.MatrixUtils",
    "signature": "org.apache.commons.math3.linear.MatrixUtils.checkAdditionCompatible(AnyMatrix,AnyMatrix)",
    "snippet": "    public static void checkAdditionCompatible(final AnyMatrix left, final AnyMatrix right)\n        throws MatrixDimensionMismatchException {\n        if ((left.getRowDimension()    != right.getRowDimension()) ||\n            (left.getColumnDimension() != right.getColumnDimension())) {\n            throw new MatrixDimensionMismatchException(left.getRowDimension(), left.getColumnDimension(),\n                                                       right.getRowDimension(), right.getColumnDimension());\n        }\n    }",
    "comment": " Check if matrices are addition compatible.  @param left Left hand side matrix. @param right Right hand side matrix. @throws MatrixDimensionMismatchException if the matrices are not addition compatible. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 3
  },
  {
    "name": "MatrixUtils.checkColumnIndex",
    "class_name": "org.apache.commons.math3.linear.MatrixUtils",
    "signature": "org.apache.commons.math3.linear.MatrixUtils.checkColumnIndex(AnyMatrix,int)",
    "snippet": "    public static void checkColumnIndex(final AnyMatrix m, final int column)\n        throws OutOfRangeException {\n        if (column < 0 || column >= m.getColumnDimension()) {\n            throw new OutOfRangeException(LocalizedFormats.COLUMN_INDEX,\n                                           column, 0, m.getColumnDimension() - 1);\n        }\n    }",
    "comment": " Check if a column index is valid.  @param m Matrix. @param column Column index to check. @throws OutOfRangeException if {@code column} is not a valid index. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 3
  },
  {
    "name": "MatrixUtils.checkMatrixIndex",
    "class_name": "org.apache.commons.math3.linear.MatrixUtils",
    "signature": "org.apache.commons.math3.linear.MatrixUtils.checkMatrixIndex(AnyMatrix,int,int)",
    "snippet": "    public static void checkMatrixIndex(final AnyMatrix m,\n                                        final int row, final int column)\n        throws OutOfRangeException {\n        checkRowIndex(m, row);\n        checkColumnIndex(m, column);\n    }",
    "comment": " Check if matrix indices are valid.  @param m Matrix. @param row Row index to check. @param column Column index to check. @throws OutOfRangeException if {@code row} or {@code column} is not a valid index. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 3
  },
  {
    "name": "MatrixUtils.checkMultiplicationCompatible",
    "class_name": "org.apache.commons.math3.linear.MatrixUtils",
    "signature": "org.apache.commons.math3.linear.MatrixUtils.checkMultiplicationCompatible(AnyMatrix,AnyMatrix)",
    "snippet": "    public static void checkMultiplicationCompatible(final AnyMatrix left, final AnyMatrix right)\n        throws DimensionMismatchException {\n\n        if (left.getColumnDimension() != right.getRowDimension()) {\n            throw new DimensionMismatchException(left.getColumnDimension(),\n                                                 right.getRowDimension());\n        }\n    }",
    "comment": " Check if matrices are multiplication compatible  @param left Left hand side matrix. @param right Right hand side matrix. @throws DimensionMismatchException if matrices are not multiplication compatible. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 3
  },
  {
    "name": "MatrixUtils.checkRowIndex",
    "class_name": "org.apache.commons.math3.linear.MatrixUtils",
    "signature": "org.apache.commons.math3.linear.MatrixUtils.checkRowIndex(AnyMatrix,int)",
    "snippet": "    public static void checkRowIndex(final AnyMatrix m, final int row)\n        throws OutOfRangeException {\n        if (row < 0 ||\n            row >= m.getRowDimension()) {\n            throw new OutOfRangeException(LocalizedFormats.ROW_INDEX,\n                                          row, 0, m.getRowDimension() - 1);\n        }\n    }",
    "comment": " Check if a row index is valid.  @param m Matrix. @param row Row index to check. @throws OutOfRangeException if {@code row} is not a valid index. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 3
  },
  {
    "name": "MatrixUtils.checkSubtractionCompatible",
    "class_name": "org.apache.commons.math3.linear.MatrixUtils",
    "signature": "org.apache.commons.math3.linear.MatrixUtils.checkSubtractionCompatible(AnyMatrix,AnyMatrix)",
    "snippet": "    public static void checkSubtractionCompatible(final AnyMatrix left, final AnyMatrix right)\n        throws MatrixDimensionMismatchException {\n        if ((left.getRowDimension()    != right.getRowDimension()) ||\n            (left.getColumnDimension() != right.getColumnDimension())) {\n            throw new MatrixDimensionMismatchException(left.getRowDimension(), left.getColumnDimension(),\n                                                       right.getRowDimension(), right.getColumnDimension());\n        }\n    }",
    "comment": " Check if matrices are subtraction compatible  @param left Left hand side matrix. @param right Right hand side matrix. @throws MatrixDimensionMismatchException if the matrices are not addition compatible. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 3
  },
  {
    "name": "MatrixUtils.createColumnRealMatrix",
    "class_name": "org.apache.commons.math3.linear.MatrixUtils",
    "signature": "org.apache.commons.math3.linear.MatrixUtils.createColumnRealMatrix(double[])",
    "snippet": "    public static RealMatrix createColumnRealMatrix(double[] columnData)\n        throws NoDataException, NullArgumentException {\n        if (columnData == null) {\n            throw new NullArgumentException();\n        }\n        final int nRows = columnData.length;\n        final RealMatrix m = createRealMatrix(nRows, 1);\n        for (int i = 0; i < nRows; ++i) {\n            m.setEntry(i, 0, columnData[i]);\n        }\n        return m;\n    }",
    "comment": " Creates a column {@link RealMatrix} using the data from the input array.  @param columnData  the input column data @return a columnData x 1 RealMatrix @throws NoDataException if {@code columnData} is empty. @throws NullArgumentException if {@code columnData} is {@code null}. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 3
  },
  {
    "name": "MatrixUtils.createRealDiagonalMatrix",
    "class_name": "org.apache.commons.math3.linear.MatrixUtils",
    "signature": "org.apache.commons.math3.linear.MatrixUtils.createRealDiagonalMatrix(double[])",
    "snippet": "    public static RealMatrix createRealDiagonalMatrix(final double[] diagonal) {\n        final RealMatrix m = createRealMatrix(diagonal.length, diagonal.length);\n        for (int i = 0; i < diagonal.length; ++i) {\n            m.setEntry(i, i, diagonal[i]);\n        }\n        return m;\n    }",
    "comment": " Returns a diagonal matrix with specified elements.  @param diagonal diagonal elements of the matrix (the array elements will be copied) @return diagonal matrix @since 2.0 ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 3
  },
  {
    "name": "MatrixUtils.createRealMatrix",
    "class_name": "org.apache.commons.math3.linear.MatrixUtils",
    "signature": "org.apache.commons.math3.linear.MatrixUtils.createRealMatrix(double[][])",
    "snippet": "    public static RealMatrix createRealMatrix(double[][] data)\n        throws NullArgumentException, DimensionMismatchException,\n        NoDataException {\n        if (data == null ||\n            data[0] == null) {\n            throw new NullArgumentException();\n        }\n        return (data.length * data[0].length <= 4096) ?\n                new Array2DRowRealMatrix(data) : new BlockRealMatrix(data);\n    }",
    "comment": " Returns a {@link RealMatrix} whose entries are the the values in the the input array. <p>The type of matrix returned depends on the dimension. Below 2<sup>12</sup> elements (i.e. 4096 elements or 64&times;64 for a square matrix) which can be stored in a 32kB array, a {@link Array2DRowRealMatrix} instance is built. Above this threshold a {@link BlockRealMatrix} instance is built.</p> <p>The input array is copied, not referenced.</p>  @param data input array @return  RealMatrix containing the values of the array @throws org.apache.commons.math3.exception.DimensionMismatchException if {@code data} is not rectangular (not all rows have the same length). @throws NoDataException if a row or column is empty. @throws NullArgumentException if either {@code data} or {@code data[0]} is {@code null}. @throws DimensionMismatchException if {@code data} is not rectangular. @see #createRealMatrix(int, int) ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 3
  },
  {
    "name": "MatrixUtils.createRealMatrix",
    "class_name": "org.apache.commons.math3.linear.MatrixUtils",
    "signature": "org.apache.commons.math3.linear.MatrixUtils.createRealMatrix(int,int)",
    "snippet": "    public static RealMatrix createRealMatrix(final int rows, final int columns) {\n        return (rows * columns <= 4096) ?\n                new Array2DRowRealMatrix(rows, columns) : new BlockRealMatrix(rows, columns);\n    }",
    "comment": " Returns a {@link RealMatrix} with specified dimensions. <p>The type of matrix returned depends on the dimension. Below 2<sup>12</sup> elements (i.e. 4096 elements or 64&times;64 for a square matrix) which can be stored in a 32kB array, a {@link Array2DRowRealMatrix} instance is built. Above this threshold a {@link BlockRealMatrix} instance is built.</p> <p>The matrix elements are all set to 0.0.</p> @param rows number of rows of the matrix @param columns number of columns of the matrix @return  RealMatrix with specified dimensions @see #createRealMatrix(double[][]) ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 3
  },
  {
    "name": "RealMatrixFormat.RealMatrixFormat",
    "class_name": "org.apache.commons.math3.linear.RealMatrixFormat",
    "signature": "org.apache.commons.math3.linear.RealMatrixFormat.RealMatrixFormat(NumberFormat)",
    "snippet": "    public RealMatrixFormat(final NumberFormat format) {\n        this(DEFAULT_PREFIX, DEFAULT_SUFFIX, DEFAULT_ROW_PREFIX, DEFAULT_ROW_SUFFIX,\n                DEFAULT_ROW_SEPARATOR, DEFAULT_COLUMN_SEPARATOR, format);\n    }",
    "comment": " Create an instance with a custom number format for components. @param format the custom format for components. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 3
  },
  {
    "name": "RealMatrixFormat.RealMatrixFormat",
    "class_name": "org.apache.commons.math3.linear.RealMatrixFormat",
    "signature": "org.apache.commons.math3.linear.RealMatrixFormat.RealMatrixFormat(String,String,String,String,String,String)",
    "snippet": "    public RealMatrixFormat(final String prefix, final String suffix,\n                            final String rowPrefix, final String rowSuffix,\n                            final String rowSeparator, final String columnSeparator) {\n        this(prefix, suffix, rowPrefix, rowSuffix, rowSeparator, columnSeparator,\n                CompositeFormat.getDefaultNumberFormat());\n    }",
    "comment": " Create an instance with custom prefix, suffix and separator. @param prefix prefix to use instead of the default \"{\" @param suffix suffix to use instead of the default \"}\" @param rowPrefix row prefix to use instead of the default \"{\" @param rowSuffix row suffix to use instead of the default \"}\" @param rowSeparator tow separator to use instead of the default \";\" @param columnSeparator column separator to use instead of the default \", \" ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 3
  },
  {
    "name": "RealMatrixFormat.RealMatrixFormat",
    "class_name": "org.apache.commons.math3.linear.RealMatrixFormat",
    "signature": "org.apache.commons.math3.linear.RealMatrixFormat.RealMatrixFormat(String,String,String,String,String,String,NumberFormat)",
    "snippet": "    public RealMatrixFormat(final String prefix, final String suffix,\n                            final String rowPrefix, final String rowSuffix,\n                            final String rowSeparator, final String columnSeparator,\n                            final NumberFormat format) {\n        this.prefix            = prefix;\n        this.suffix            = suffix;\n        this.rowPrefix         = rowPrefix;\n        this.rowSuffix         = rowSuffix;\n        this.rowSeparator      = rowSeparator;\n        this.columnSeparator   = columnSeparator;\n        this.format            = format;\n        // disable grouping to prevent parsing problems\n        this.format.setGroupingUsed(false);\n    }",
    "comment": " Create an instance with custom prefix, suffix, separator and format for components. @param prefix prefix to use instead of the default \"{\" @param suffix suffix to use instead of the default \"}\" @param rowPrefix row prefix to use instead of the default \"{\" @param rowSuffix row suffix to use instead of the default \"}\" @param rowSeparator tow separator to use instead of the default \";\" @param columnSeparator column separator to use instead of the default \", \" @param format the custom format for components. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 3
  },
  {
    "name": "RealMatrixFormat.getFormat",
    "class_name": "org.apache.commons.math3.linear.RealMatrixFormat",
    "signature": "org.apache.commons.math3.linear.RealMatrixFormat.getFormat()",
    "snippet": "    public NumberFormat getFormat() {\n        return format;\n    }",
    "comment": " Get the components format. @return components format. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 3
  },
  {
    "name": "RealMatrixFormat.getInstance",
    "class_name": "org.apache.commons.math3.linear.RealMatrixFormat",
    "signature": "org.apache.commons.math3.linear.RealMatrixFormat.getInstance()",
    "snippet": "    public static RealMatrixFormat getInstance() {\n        return getInstance(Locale.getDefault());\n    }",
    "comment": " Returns the default real vector format for the current locale. @return the default real vector format. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 3
  },
  {
    "name": "RealMatrixFormat.getInstance",
    "class_name": "org.apache.commons.math3.linear.RealMatrixFormat",
    "signature": "org.apache.commons.math3.linear.RealMatrixFormat.getInstance(Locale)",
    "snippet": "    public static RealMatrixFormat getInstance(final Locale locale) {\n        return new RealMatrixFormat(CompositeFormat.getDefaultNumberFormat(locale));\n    }",
    "comment": " Returns the default real vector format for the given locale. @param locale the specific locale used by the format. @return the real vector format specific to the given locale. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 3
  },
  {
    "name": "RealVectorFormat.RealVectorFormat",
    "class_name": "org.apache.commons.math3.linear.RealVectorFormat",
    "signature": "org.apache.commons.math3.linear.RealVectorFormat.RealVectorFormat(NumberFormat)",
    "snippet": "    public RealVectorFormat(final NumberFormat format) {\n        this(DEFAULT_PREFIX, DEFAULT_SUFFIX, DEFAULT_SEPARATOR, format);\n    }",
    "comment": " Create an instance with a custom number format for components. @param format the custom format for components. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 3
  },
  {
    "name": "RealVectorFormat.RealVectorFormat",
    "class_name": "org.apache.commons.math3.linear.RealVectorFormat",
    "signature": "org.apache.commons.math3.linear.RealVectorFormat.RealVectorFormat(String,String,String,NumberFormat)",
    "snippet": "    public RealVectorFormat(final String prefix, final String suffix,\n                            final String separator, final NumberFormat format) {\n        this.prefix      = prefix;\n        this.suffix      = suffix;\n        this.separator   = separator;\n        trimmedPrefix    = prefix.trim();\n        trimmedSuffix    = suffix.trim();\n        trimmedSeparator = separator.trim();\n        this.format      = format;\n    }",
    "comment": " Create an instance with custom prefix, suffix, separator and format for components. @param prefix prefix to use instead of the default \"{\" @param suffix suffix to use instead of the default \"}\" @param separator separator to use instead of the default \"; \" @param format the custom format for components. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 3
  },
  {
    "name": "RealVectorFormat.getInstance",
    "class_name": "org.apache.commons.math3.linear.RealVectorFormat",
    "signature": "org.apache.commons.math3.linear.RealVectorFormat.getInstance()",
    "snippet": "    public static RealVectorFormat getInstance() {\n        return getInstance(Locale.getDefault());\n    }",
    "comment": " Returns the default real vector format for the current locale. @return the default real vector format. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 3
  },
  {
    "name": "RealVectorFormat.getInstance",
    "class_name": "org.apache.commons.math3.linear.RealVectorFormat",
    "signature": "org.apache.commons.math3.linear.RealVectorFormat.getInstance(Locale)",
    "snippet": "    public static RealVectorFormat getInstance(final Locale locale) {\n        return new RealVectorFormat(CompositeFormat.getDefaultNumberFormat(locale));\n    }",
    "comment": " Returns the default real vector format for the given locale. @param locale the specific locale used by the format. @return the real vector format specific to the given locale. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 3
  },
  {
    "name": "TriDiagonalTransformer.TriDiagonalTransformer",
    "class_name": "org.apache.commons.math3.linear.TriDiagonalTransformer",
    "signature": "org.apache.commons.math3.linear.TriDiagonalTransformer.TriDiagonalTransformer(RealMatrix)",
    "snippet": "    public TriDiagonalTransformer(RealMatrix matrix) {\n        if (!matrix.isSquare()) {\n            throw new NonSquareMatrixException(matrix.getRowDimension(),\n                                               matrix.getColumnDimension());\n        }\n\n        final int m = matrix.getRowDimension();\n        householderVectors = matrix.getData();\n        main      = new double[m];\n        secondary = new double[m - 1];\n        cachedQ   = null;\n        cachedQt  = null;\n        cachedT   = null;\n\n        // transform matrix\n        transform();\n    }",
    "comment": " Build the transformation to tridiagonal shape of a symmetrical matrix. <p>The specified matrix is assumed to be symmetrical without any check. Only the upper triangular part of the matrix is used.</p>  @param matrix Symmetrical matrix to transform. @throws NonSquareMatrixException if the matrix is not square. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 3
  },
  {
    "name": "TriDiagonalTransformer.getMainDiagonalRef",
    "class_name": "org.apache.commons.math3.linear.TriDiagonalTransformer",
    "signature": "org.apache.commons.math3.linear.TriDiagonalTransformer.getMainDiagonalRef()",
    "snippet": "    double[] getMainDiagonalRef() {\n        return main;\n    }",
    "comment": " Get the main diagonal elements of the matrix T of the transform. <p>Note that since this class is only intended for internal use, it returns directly a reference to its internal arrays, not a copy.</p> @return the main diagonal elements of the T matrix ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 3
  },
  {
    "name": "TriDiagonalTransformer.getQ",
    "class_name": "org.apache.commons.math3.linear.TriDiagonalTransformer",
    "signature": "org.apache.commons.math3.linear.TriDiagonalTransformer.getQ()",
    "snippet": "    public RealMatrix getQ() {\n        if (cachedQ == null) {\n            cachedQ = getQT().transpose();\n        }\n        return cachedQ;\n    }",
    "comment": " Returns the matrix Q of the transform. <p>Q is an orthogonal matrix, i.e. its transpose is also its inverse.</p> @return the Q matrix ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 3
  },
  {
    "name": "TriDiagonalTransformer.getQT",
    "class_name": "org.apache.commons.math3.linear.TriDiagonalTransformer",
    "signature": "org.apache.commons.math3.linear.TriDiagonalTransformer.getQT()",
    "snippet": "    public RealMatrix getQT() {\n        if (cachedQt == null) {\n            final int m = householderVectors.length;\n            double[][] qta = new double[m][m];\n\n            // build up first part of the matrix by applying Householder transforms\n            for (int k = m - 1; k >= 1; --k) {\n                final double[] hK = householderVectors[k - 1];\n                qta[k][k] = 1;\n                if (hK[k] != 0.0) {\n                    final double inv = 1.0 / (secondary[k - 1] * hK[k]);\n                    double beta = 1.0 / secondary[k - 1];\n                    qta[k][k] = 1 + beta * hK[k];\n                    for (int i = k + 1; i < m; ++i) {\n                        qta[k][i] = beta * hK[i];\n                    }\n                    for (int j = k + 1; j < m; ++j) {\n                        beta = 0;\n                        for (int i = k + 1; i < m; ++i) {\n                            beta += qta[j][i] * hK[i];\n                        }\n                        beta *= inv;\n                        qta[j][k] = beta * hK[k];\n                        for (int i = k + 1; i < m; ++i) {\n                            qta[j][i] += beta * hK[i];\n                        }\n                    }\n                }\n            }\n            qta[0][0] = 1;\n            cachedQt = MatrixUtils.createRealMatrix(qta);\n        }\n\n        // return the cached matrix\n        return cachedQt;\n    }",
    "comment": " Returns the transpose of the matrix Q of the transform. <p>Q is an orthogonal matrix, i.e. its transpose is also its inverse.</p> @return the Q matrix ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 3
  },
  {
    "name": "TriDiagonalTransformer.getSecondaryDiagonalRef",
    "class_name": "org.apache.commons.math3.linear.TriDiagonalTransformer",
    "signature": "org.apache.commons.math3.linear.TriDiagonalTransformer.getSecondaryDiagonalRef()",
    "snippet": "    double[] getSecondaryDiagonalRef() {\n        return secondary;\n    }",
    "comment": " Get the secondary diagonal elements of the matrix T of the transform. <p>Note that since this class is only intended for internal use, it returns directly a reference to its internal arrays, not a copy.</p> @return the secondary diagonal elements of the T matrix ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 3
  },
  {
    "name": "TriDiagonalTransformer.transform",
    "class_name": "org.apache.commons.math3.linear.TriDiagonalTransformer",
    "signature": "org.apache.commons.math3.linear.TriDiagonalTransformer.transform()",
    "snippet": "    private void transform() {\n        final int m = householderVectors.length;\n        final double[] z = new double[m];\n        for (int k = 0; k < m - 1; k++) {\n\n            //zero-out a row and a column simultaneously\n            final double[] hK = householderVectors[k];\n            main[k] = hK[k];\n            double xNormSqr = 0;\n            for (int j = k + 1; j < m; ++j) {\n                final double c = hK[j];\n                xNormSqr += c * c;\n            }\n            final double a = (hK[k + 1] > 0) ? -FastMath.sqrt(xNormSqr) : FastMath.sqrt(xNormSqr);\n            secondary[k] = a;\n            if (a != 0.0) {\n                // apply Householder transform from left and right simultaneously\n\n                hK[k + 1] -= a;\n                final double beta = -1 / (a * hK[k + 1]);\n\n                // compute a = beta A v, where v is the Householder vector\n                // this loop is written in such a way\n                //   1) only the upper triangular part of the matrix is accessed\n                //   2) access is cache-friendly for a matrix stored in rows\n                Arrays.fill(z, k + 1, m, 0);\n                for (int i = k + 1; i < m; ++i) {\n                    final double[] hI = householderVectors[i];\n                    final double hKI = hK[i];\n                    double zI = hI[i] * hKI;\n                    for (int j = i + 1; j < m; ++j) {\n                        final double hIJ = hI[j];\n                        zI   += hIJ * hK[j];\n                        z[j] += hIJ * hKI;\n                    }\n                    z[i] = beta * (z[i] + zI);\n                }\n\n                // compute gamma = beta vT z / 2\n                double gamma = 0;\n                for (int i = k + 1; i < m; ++i) {\n                    gamma += z[i] * hK[i];\n                }\n                gamma *= beta / 2;\n\n                // compute z = z - gamma v\n                for (int i = k + 1; i < m; ++i) {\n                    z[i] -= gamma * hK[i];\n                }\n\n                // update matrix: A = A - v zT - z vT\n                // only the upper triangular part of the matrix is updated\n                for (int i = k + 1; i < m; ++i) {\n                    final double[] hI = householderVectors[i];\n                    for (int j = i; j < m; ++j) {\n                        hI[j] -= hK[i] * z[j] + z[i] * hK[j];\n                    }\n                }\n            }\n        }\n        main[m - 1] = householderVectors[m - 1][m - 1];\n    }",
    "comment": " Transform original matrix to tridiagonal form. <p>Transformation is done using Householder transforms.</p> ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 3
  },
  {
    "name": "AbstractConvergenceChecker.AbstractConvergenceChecker",
    "class_name": "org.apache.commons.math3.optimization.AbstractConvergenceChecker",
    "signature": "org.apache.commons.math3.optimization.AbstractConvergenceChecker.AbstractConvergenceChecker()",
    "snippet": "    @Deprecated\n    public AbstractConvergenceChecker() {\n        this.relativeThreshold = DEFAULT_RELATIVE_THRESHOLD;\n        this.absoluteThreshold = DEFAULT_ABSOLUTE_THRESHOLD;\n    }",
    "comment": " Build an instance with default thresholds. @deprecated in 3.1 (to be removed in 4.0). Convergence thresholds are problem-dependent. As this class is intended for users who want to set their own convergence criterion instead of relying on an algorithm's default procedure, they should also set the thresholds appropriately (cf. MATH-798). ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 3
  },
  {
    "name": "AbstractConvergenceChecker.getAbsoluteThreshold",
    "class_name": "org.apache.commons.math3.optimization.AbstractConvergenceChecker",
    "signature": "org.apache.commons.math3.optimization.AbstractConvergenceChecker.getAbsoluteThreshold()",
    "snippet": "    public double getAbsoluteThreshold() {\n        return absoluteThreshold;\n    }",
    "comment": " @return the absolute threshold. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 3
  },
  {
    "name": "AbstractConvergenceChecker.getRelativeThreshold",
    "class_name": "org.apache.commons.math3.optimization.AbstractConvergenceChecker",
    "signature": "org.apache.commons.math3.optimization.AbstractConvergenceChecker.getRelativeThreshold()",
    "snippet": "    public double getRelativeThreshold() {\n        return relativeThreshold;\n    }",
    "comment": " @return the relative threshold. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 3
  },
  {
    "name": "PointValuePair.PointValuePair",
    "class_name": "org.apache.commons.math3.optimization.PointValuePair",
    "signature": "org.apache.commons.math3.optimization.PointValuePair.PointValuePair(double[],double)",
    "snippet": "    public PointValuePair(final double[] point,\n                          final double value) {\n        this(point, value, true);\n    }",
    "comment": " Builds a point/objective function value pair.  @param point Point coordinates. This instance will store a copy of the array, not the array passed as argument. @param value Value of the objective function at the point. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 3
  },
  {
    "name": "PointValuePair.PointValuePair",
    "class_name": "org.apache.commons.math3.optimization.PointValuePair",
    "signature": "org.apache.commons.math3.optimization.PointValuePair.PointValuePair(double[],double,boolean)",
    "snippet": "    public PointValuePair(final double[] point,\n                          final double value,\n                          final boolean copyArray) {\n        super(copyArray ? ((point == null) ? null :\n                           point.clone()) :\n              point,\n              value);\n    }",
    "comment": " Builds a point/objective function value pair.  @param point Point coordinates. @param value Value of the objective function at the point. @param copyArray if {@code true}, the input array will be copied, otherwise it will be referenced. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 3
  },
  {
    "name": "PointValuePair.getPoint",
    "class_name": "org.apache.commons.math3.optimization.PointValuePair",
    "signature": "org.apache.commons.math3.optimization.PointValuePair.getPoint()",
    "snippet": "    public double[] getPoint() {\n        final double[] p = getKey();\n        return p == null ? null : p.clone();\n    }",
    "comment": " Gets the point.  @return a copy of the stored point. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 3
  },
  {
    "name": "SimpleValueChecker.SimpleValueChecker",
    "class_name": "org.apache.commons.math3.optimization.SimpleValueChecker",
    "signature": "org.apache.commons.math3.optimization.SimpleValueChecker.SimpleValueChecker()",
    "snippet": "    @Deprecated\n    public SimpleValueChecker() {}",
    "comment": " Build an instance with default thresholds. @deprecated See {@link AbstractConvergenceChecker#AbstractConvergenceChecker()} ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 3
  },
  {
    "name": "SimpleValueChecker.converged",
    "class_name": "org.apache.commons.math3.optimization.SimpleValueChecker",
    "signature": "org.apache.commons.math3.optimization.SimpleValueChecker.converged(int,PointValuePair,PointValuePair)",
    "snippet": "    @Override\n    public boolean converged(final int iteration,\n                             final PointValuePair previous,\n                             final PointValuePair current) {\n        final double p = previous.getValue();\n        final double c = current.getValue();\n        final double difference = FastMath.abs(p - c);\n        final double size = FastMath.max(FastMath.abs(p), FastMath.abs(c));\n        return difference <= size * getRelativeThreshold() ||\n            difference <= getAbsoluteThreshold();\n    }",
    "comment": " Check if the optimization algorithm has converged considering the last two points. This method may be called several time from the same algorithm iteration with different points. This can be detected by checking the iteration number at each call if needed. Each time this method is called, the previous and current point correspond to points with the same role at each iteration, so they can be compared. As an example, simplex-based algorithms call this method for all points of the simplex, not only for the best or worst ones.  @param iteration Index of current iteration @param previous Best point in the previous iteration. @param current Best point in the current iteration. @return {@code true} if the algorithm has converged. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 3
  },
  {
    "name": "BaseAbstractMultivariateOptimizer.BaseAbstractMultivariateOptimizer",
    "class_name": "org.apache.commons.math3.optimization.direct.BaseAbstractMultivariateOptimizer",
    "signature": "org.apache.commons.math3.optimization.direct.BaseAbstractMultivariateOptimizer.BaseAbstractMultivariateOptimizer(ConvergenceChecker)",
    "snippet": "    protected BaseAbstractMultivariateOptimizer(ConvergenceChecker<PointValuePair> checker) {\n        this.checker = checker;\n    }",
    "comment": " @param checker Convergence checker. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 3
  },
  {
    "name": "BaseAbstractMultivariateOptimizer.computeObjectiveValue",
    "class_name": "org.apache.commons.math3.optimization.direct.BaseAbstractMultivariateOptimizer",
    "signature": "org.apache.commons.math3.optimization.direct.BaseAbstractMultivariateOptimizer.computeObjectiveValue(double[])",
    "snippet": "    protected double computeObjectiveValue(double[] point) {\n        try {\n            evaluations.incrementCount();\n        } catch (MaxCountExceededException e) {\n            throw new TooManyEvaluationsException(e.getMax());\n        }\n        return function.value(point);\n    }",
    "comment": " Compute the objective function value.  @param point Point at which the objective function must be evaluated. @return the objective function value at the specified point. @throws TooManyEvaluationsException if the maximal number of evaluations is exceeded. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 3
  },
  {
    "name": "BaseAbstractMultivariateOptimizer.getConvergenceChecker",
    "class_name": "org.apache.commons.math3.optimization.direct.BaseAbstractMultivariateOptimizer",
    "signature": "org.apache.commons.math3.optimization.direct.BaseAbstractMultivariateOptimizer.getConvergenceChecker()",
    "snippet": "    public ConvergenceChecker<PointValuePair> getConvergenceChecker() {\n        return checker;\n    }",
    "comment": "{@inheritDoc} */",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 3
  },
  {
    "name": "BaseAbstractMultivariateOptimizer.getGoalType",
    "class_name": "org.apache.commons.math3.optimization.direct.BaseAbstractMultivariateOptimizer",
    "signature": "org.apache.commons.math3.optimization.direct.BaseAbstractMultivariateOptimizer.getGoalType()",
    "snippet": "    public GoalType getGoalType() {\n        return goal;\n    }",
    "comment": " @return the optimization type. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 3
  },
  {
    "name": "BaseAbstractMultivariateOptimizer.getMaxEvaluations",
    "class_name": "org.apache.commons.math3.optimization.direct.BaseAbstractMultivariateOptimizer",
    "signature": "org.apache.commons.math3.optimization.direct.BaseAbstractMultivariateOptimizer.getMaxEvaluations()",
    "snippet": "    public int getMaxEvaluations() {\n        return evaluations.getMaximalCount();\n    }",
    "comment": "{@inheritDoc} */",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 3
  },
  {
    "name": "BaseAbstractMultivariateOptimizer.getStartPoint",
    "class_name": "org.apache.commons.math3.optimization.direct.BaseAbstractMultivariateOptimizer",
    "signature": "org.apache.commons.math3.optimization.direct.BaseAbstractMultivariateOptimizer.getStartPoint()",
    "snippet": "    public double[] getStartPoint() {\n        return start.clone();\n    }",
    "comment": " @return the initial guess. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 3
  },
  {
    "name": "BaseAbstractMultivariateOptimizer.optimizeInternal",
    "class_name": "org.apache.commons.math3.optimization.direct.BaseAbstractMultivariateOptimizer",
    "signature": "org.apache.commons.math3.optimization.direct.BaseAbstractMultivariateOptimizer.optimizeInternal(int,MultivariateFunction,GoalType,double[])",
    "snippet": "    protected PointValuePair optimizeInternal(int maxEval, MultivariateFunction f, GoalType goalType,\n                                              double[] startPoint) {\n        // Checks.\n        if (f == null) {\n            throw new NullArgumentException();\n        }\n        if (goalType == null) {\n            throw new NullArgumentException();\n        }\n        if (startPoint == null) {\n            throw new NullArgumentException();\n        }\n\n        // Reset.\n        evaluations.setMaximalCount(maxEval);\n        evaluations.resetCount();\n\n        // Store optimization problem characteristics.\n        function = f;\n        goal = goalType;\n        start = startPoint.clone();\n\n        // Perform computation.\n        return doOptimize();\n    }",
    "comment": " Optimize an objective function.  @param f Objective function. @param goalType Type of optimization goal: either {@link GoalType#MAXIMIZE} or {@link GoalType#MINIMIZE}. @param startPoint Start point for optimization. @param maxEval Maximum number of function evaluations. @return the point/value pair giving the optimal value for objective function. @throws org.apache.commons.math3.exception.DimensionMismatchException if the start point dimension is wrong. @throws org.apache.commons.math3.exception.TooManyEvaluationsException if the maximal number of evaluations is exceeded. @throws org.apache.commons.math3.exception.NullArgumentException if any argument is {@code null}. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 3
  },
  {
    "name": "BaseAbstractMultivariateSimpleBoundsOptimizer.BaseAbstractMultivariateSimpleBoundsOptimizer",
    "class_name": "org.apache.commons.math3.optimization.direct.BaseAbstractMultivariateSimpleBoundsOptimizer",
    "signature": "org.apache.commons.math3.optimization.direct.BaseAbstractMultivariateSimpleBoundsOptimizer.BaseAbstractMultivariateSimpleBoundsOptimizer(ConvergenceChecker)",
    "snippet": "    protected BaseAbstractMultivariateSimpleBoundsOptimizer(ConvergenceChecker<PointValuePair> checker) {\n        super(checker);\n    }",
    "comment": " @param checker Convergence checker. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 3
  },
  {
    "name": "BaseAbstractMultivariateSimpleBoundsOptimizer.getLowerBound",
    "class_name": "org.apache.commons.math3.optimization.direct.BaseAbstractMultivariateSimpleBoundsOptimizer",
    "signature": "org.apache.commons.math3.optimization.direct.BaseAbstractMultivariateSimpleBoundsOptimizer.getLowerBound()",
    "snippet": "    public double[] getLowerBound() {\n        return lowerBound.clone();\n    }",
    "comment": " @return the lower bounds. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 3
  },
  {
    "name": "BaseAbstractMultivariateSimpleBoundsOptimizer.getUpperBound",
    "class_name": "org.apache.commons.math3.optimization.direct.BaseAbstractMultivariateSimpleBoundsOptimizer",
    "signature": "org.apache.commons.math3.optimization.direct.BaseAbstractMultivariateSimpleBoundsOptimizer.getUpperBound()",
    "snippet": "    public double[] getUpperBound() {\n        return upperBound.clone();\n    }",
    "comment": " @return the upper bounds. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 3
  },
  {
    "name": "CMAESOptimizer.CMAESOptimizer",
    "class_name": "org.apache.commons.math3.optimization.direct.CMAESOptimizer",
    "signature": "org.apache.commons.math3.optimization.direct.CMAESOptimizer.CMAESOptimizer()",
    "snippet": "    public CMAESOptimizer() {\n        this(0);\n    }",
    "comment": " Default constructor, uses default parameters ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 3
  },
  {
    "name": "CMAESOptimizer.CMAESOptimizer",
    "class_name": "org.apache.commons.math3.optimization.direct.CMAESOptimizer",
    "signature": "org.apache.commons.math3.optimization.direct.CMAESOptimizer.CMAESOptimizer(int)",
    "snippet": "    public CMAESOptimizer(int lambda) {\n        this(lambda, null, DEFAULT_MAXITERATIONS, DEFAULT_STOPFITNESS,\n             DEFAULT_ISACTIVECMA, DEFAULT_DIAGONALONLY,\n             DEFAULT_CHECKFEASABLECOUNT, DEFAULT_RANDOMGENERATOR, false);\n    }",
    "comment": " @param lambda Population size. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 3
  },
  {
    "name": "CMAESOptimizer.CMAESOptimizer",
    "class_name": "org.apache.commons.math3.optimization.direct.CMAESOptimizer",
    "signature": "org.apache.commons.math3.optimization.direct.CMAESOptimizer.CMAESOptimizer(int,double[],int,double,boolean,int,int,RandomGenerator,boolean)",
    "snippet": "    @Deprecated\n    public CMAESOptimizer(int lambda, double[] inputSigma,\n                          int maxIterations, double stopFitness,\n                          boolean isActiveCMA, int diagonalOnly, int checkFeasableCount,\n                          RandomGenerator random, boolean generateStatistics) {\n        this(lambda, inputSigma, maxIterations, stopFitness, isActiveCMA,\n             diagonalOnly, checkFeasableCount, random, generateStatistics,\n             new SimpleValueChecker());\n    }",
    "comment": " @param lambda Population size. @param inputSigma Initial search volume; sigma of offspring objective variables. @param maxIterations Maximal number of iterations. @param stopFitness Whether to stop if objective function value is smaller than {@code stopFitness}. @param isActiveCMA Chooses the covariance matrix update method. @param diagonalOnly Number of initial iterations, where the covariance matrix remains diagonal. @param checkFeasableCount Determines how often new random objective variables are generated in case they are out of bounds. @param random Random generator. @param generateStatistics Whether statistic data is collected. @deprecated See {@link SimpleValueChecker#SimpleValueChecker()} ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 3
  },
  {
    "name": "CMAESOptimizer.CMAESOptimizer",
    "class_name": "org.apache.commons.math3.optimization.direct.CMAESOptimizer",
    "signature": "org.apache.commons.math3.optimization.direct.CMAESOptimizer.CMAESOptimizer(int,double[],int,double,boolean,int,int,RandomGenerator,boolean,ConvergenceChecker)",
    "snippet": "    public CMAESOptimizer(int lambda, double[] inputSigma,\n                          int maxIterations, double stopFitness,\n                          boolean isActiveCMA, int diagonalOnly, int checkFeasableCount,\n                          RandomGenerator random, boolean generateStatistics,\n                          ConvergenceChecker<PointValuePair> checker) {\n        super(checker);\n        this.lambda = lambda;\n        this.inputSigma = inputSigma == null ? null : (double[]) inputSigma.clone();\n        this.maxIterations = maxIterations;\n        this.stopFitness = stopFitness;\n        this.isActiveCMA = isActiveCMA;\n        this.diagonalOnly = diagonalOnly;\n        this.checkFeasableCount = checkFeasableCount;\n        this.random = random;\n        this.generateStatistics = generateStatistics;\n    }",
    "comment": " @param lambda Population size. @param inputSigma Initial search volume; sigma of offspring objective variables. @param maxIterations Maximal number of iterations. @param stopFitness Whether to stop if objective function value is smaller than {@code stopFitness}. @param isActiveCMA Chooses the covariance matrix update method. @param diagonalOnly Number of initial iterations, where the covariance matrix remains diagonal. @param checkFeasableCount Determines how often new random objective variables are generated in case they are out of bounds. @param random Random generator. @param generateStatistics Whether statistic data is collected. @param checker Convergence checker. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 3
  },
  {
    "name": "CMAESOptimizer.checkParameters",
    "class_name": "org.apache.commons.math3.optimization.direct.CMAESOptimizer",
    "signature": "org.apache.commons.math3.optimization.direct.CMAESOptimizer.checkParameters()",
    "snippet": "    private void checkParameters() {\n        final double[] init = getStartPoint();\n        final double[] lB = getLowerBound();\n        final double[] uB = getUpperBound();\n\n        // Checks whether there is at least one finite bound value.\n        boolean hasFiniteBounds = false;\n        for (int i = 0; i < lB.length; i++) {\n            if (!Double.isInfinite(lB[i]) ||\n                !Double.isInfinite(uB[i])) {\n                hasFiniteBounds = true;\n                break;\n            }\n        }\n        // Checks whether there is at least one infinite bound value.\n        boolean hasInfiniteBounds = false;\n        if (hasFiniteBounds) {\n            for (int i = 0; i < lB.length; i++) {\n                if (Double.isInfinite(lB[i]) ||\n                    Double.isInfinite(uB[i])) {\n                    hasInfiniteBounds = true;\n                    break;\n                }\n            }\n\n            if (hasInfiniteBounds) {\n                // If there is at least one finite bound, none can be infinite,\n                // because mixed cases are not supported by the current code.\n                throw new MathUnsupportedOperationException();\n            } else {\n                // Convert API to internal handling of boundaries.\n                boundaries = new double[2][];\n                boundaries[0] = lB;\n                boundaries[1] = uB;\n\n                // Abort early if the normalization will overflow (cf. \"encode\" method).\n                for (int i = 0; i < lB.length; i++) {\n                    if (Double.isInfinite(boundaries[1][i] - boundaries[0][i])) {\n                        final double max = Double.MAX_VALUE + boundaries[0][i];\n                        final NumberIsTooLargeException e\n                            = new NumberIsTooLargeException(boundaries[1][i],\n                                                            max,\n                                                            true);\n                        e.getContext().addMessage(LocalizedFormats.OVERFLOW);\n                        e.getContext().addMessage(LocalizedFormats.INDEX, i);\n\n                        throw e;\n                    }\n                }\n            }\n        } else {\n            // Convert API to internal handling of boundaries.\n            boundaries = null;\n        }\n\n        if (inputSigma != null) {\n            if (inputSigma.length != init.length) {\n                throw new DimensionMismatchException(inputSigma.length, init.length);\n            }\n            for (int i = 0; i < init.length; i++) {\n                if (inputSigma[i] < 0) {\n                    throw new NotPositiveException(inputSigma[i]);\n                }\n                if (boundaries != null) {\n                    if (inputSigma[i] > boundaries[1][i] - boundaries[0][i]) {\n                        throw new OutOfRangeException(inputSigma[i], 0, boundaries[1][i] - boundaries[0][i]);\n                    }\n                }\n            }\n        }\n    }",
    "comment": " Checks dimensions and values of boundaries and inputSigma if defined. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 3
  },
  {
    "name": "CMAESOptimizer.copyColumn",
    "class_name": "org.apache.commons.math3.optimization.direct.CMAESOptimizer",
    "signature": "org.apache.commons.math3.optimization.direct.CMAESOptimizer.copyColumn(RealMatrix,int,RealMatrix,int)",
    "snippet": "    private static void copyColumn(final RealMatrix m1, int col1, RealMatrix m2, int col2) {\n        for (int i = 0; i < m1.getRowDimension(); i++) {\n            m2.setEntry(i, col2, m1.getEntry(i, col1));\n        }\n    }",
    "comment": " Copies a column from m1 to m2.  @param m1 Source matrix 1. @param col1 Source column. @param m2 Target matrix. @param col2 Target column. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 3
  },
  {
    "name": "CMAESOptimizer.diag",
    "class_name": "org.apache.commons.math3.optimization.direct.CMAESOptimizer",
    "signature": "org.apache.commons.math3.optimization.direct.CMAESOptimizer.diag(RealMatrix)",
    "snippet": "    private static RealMatrix diag(final RealMatrix m) {\n        if (m.getColumnDimension() == 1) {\n            double[][] d = new double[m.getRowDimension()][m.getRowDimension()];\n            for (int i = 0; i < m.getRowDimension(); i++) {\n                d[i][i] = m.getEntry(i, 0);\n            }\n            return new Array2DRowRealMatrix(d, false);\n        } else {\n            double[][] d = new double[m.getRowDimension()][1];\n            for (int i = 0; i < m.getColumnDimension(); i++) {\n                d[i][0] = m.getEntry(i, i);\n            }\n            return new Array2DRowRealMatrix(d, false);\n        }\n    }",
    "comment": " @param m Input matrix. @return the diagonal n-by-n matrix if m is a column matrix or the column matrix representing the diagonal if m is a n-by-n matrix. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 3
  },
  {
    "name": "CMAESOptimizer.divide",
    "class_name": "org.apache.commons.math3.optimization.direct.CMAESOptimizer",
    "signature": "org.apache.commons.math3.optimization.direct.CMAESOptimizer.divide(RealMatrix,RealMatrix)",
    "snippet": "    private static RealMatrix divide(final RealMatrix m, final RealMatrix n) {\n        double[][] d = new double[m.getRowDimension()][m.getColumnDimension()];\n        for (int r = 0; r < m.getRowDimension(); r++) {\n            for (int c = 0; c < m.getColumnDimension(); c++) {\n                d[r][c] = m.getEntry(r, c) / n.getEntry(r, c);\n            }\n        }\n        return new Array2DRowRealMatrix(d, false);\n    }",
    "comment": " @param m Input matrix 1. @param n Input matrix 2. @return Matrix where the elements of m and n are element-wise divided. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 3
  },
  {
    "name": "CMAESOptimizer.doOptimize",
    "class_name": "org.apache.commons.math3.optimization.direct.CMAESOptimizer",
    "signature": "org.apache.commons.math3.optimization.direct.CMAESOptimizer.doOptimize()",
    "snippet": "    @Override\n    protected PointValuePair doOptimize() {\n        checkParameters();\n         // -------------------- Initialization --------------------------------\n        isMinimize = getGoalType().equals(GoalType.MINIMIZE);\n        final FitnessFunction fitfun = new FitnessFunction();\n        final double[] guess = fitfun.encode(getStartPoint());\n        // number of objective variables/problem dimension\n        dimension = guess.length;\n        initializeCMA(guess);\n        iterations = 0;\n        double bestValue = fitfun.value(guess);\n        push(fitnessHistory, bestValue);\n        PointValuePair optimum = new PointValuePair(getStartPoint(),\n                isMinimize ? bestValue : -bestValue);\n        PointValuePair lastResult = null;\n\n        // -------------------- Generation Loop --------------------------------\n\n        generationLoop:\n            for (iterations = 1; iterations <= maxIterations; iterations++) {\n                // Generate and evaluate lambda offspring\n                RealMatrix arz = randn1(dimension, lambda);\n                RealMatrix arx = zeros(dimension, lambda);\n                double[] fitness = new double[lambda];\n                // generate random offspring\n                for (int k = 0; k < lambda; k++) {\n                    RealMatrix arxk = null;\n                    for (int i = 0; i < checkFeasableCount+1; i++) {\n                        if (diagonalOnly <= 0) {\n                            arxk = xmean.add(BD.multiply(arz.getColumnMatrix(k))\n                                    .scalarMultiply(sigma)); // m + sig * Normal(0,C)\n                        } else {\n                            arxk = xmean.add(times(diagD,arz.getColumnMatrix(k))\n                                    .scalarMultiply(sigma));\n                        }\n                        if (i >= checkFeasableCount || fitfun.isFeasible(arxk.getColumn(0))) {\n                            break;\n                        }\n                        // regenerate random arguments for row\n                        arz.setColumn(k, randn(dimension));\n                    }\n                    copyColumn(arxk, 0, arx, k);\n                    try {\n                        fitness[k] = fitfun.value(arx.getColumn(k)); // compute fitness\n                    } catch (TooManyEvaluationsException e) {\n                        break generationLoop;\n                    }\n                }\n                // Sort by fitness and compute weighted mean into xmean\n                int[] arindex = sortedIndices(fitness);\n                // Calculate new xmean, this is selection and recombination\n                RealMatrix xold = xmean; // for speed up of Eq. (2) and (3)\n                RealMatrix bestArx = selectColumns(arx, MathArrays.copyOf(arindex, mu));\n                xmean = bestArx.multiply(weights);\n                RealMatrix bestArz = selectColumns(arz, MathArrays.copyOf(arindex, mu));\n                RealMatrix zmean = bestArz.multiply(weights);\n                boolean hsig = updateEvolutionPaths(zmean, xold);\n                if (diagonalOnly <= 0) {\n                    updateCovariance(hsig, bestArx, arz, arindex, xold);\n                } else {\n                    updateCovarianceDiagonalOnly(hsig, bestArz, xold);\n                }\n                // Adapt step size sigma - Eq. (5)\n                sigma *= Math.exp(Math.min(1.0,(normps/chiN - 1.)*cs/damps));\n                double bestFitness = fitness[arindex[0]];\n                double worstFitness = fitness[arindex[arindex.length-1]];\n                if (bestValue > bestFitness) {\n                    bestValue = bestFitness;\n                    lastResult = optimum;\n                    optimum = new PointValuePair(\n                            fitfun.repairAndDecode(bestArx.getColumn(0)),\n                            isMinimize ? bestFitness : -bestFitness);\n                    if (getConvergenceChecker() != null && lastResult != null) {\n                        if (getConvergenceChecker().converged(iterations, optimum, lastResult)) {\n                            break generationLoop;\n                        }\n                    }\n                }\n                // handle termination criteria\n                // Break, if fitness is good enough\n                if (stopFitness != 0) { // only if stopFitness is defined\n                    if (bestFitness < (isMinimize ? stopFitness : -stopFitness)) {\n                        break generationLoop;\n                    }\n                }\n                double[] sqrtDiagC = sqrt(diagC).getColumn(0);\n                double[] pcCol = pc.getColumn(0);\n                for (int i = 0; i < dimension; i++) {\n                    if (sigma*(Math.max(Math.abs(pcCol[i]), sqrtDiagC[i])) > stopTolX) {\n                        break;\n                    }\n                    if (i >= dimension-1) {\n                        break generationLoop;\n                    }\n                }\n                for (int i = 0; i < dimension; i++) {\n                    if (sigma*sqrtDiagC[i] > stopTolUpX) {\n                        break generationLoop;\n                    }\n                }\n                double historyBest = min(fitnessHistory);\n                double historyWorst = max(fitnessHistory);\n                if (iterations > 2 && Math.max(historyWorst, worstFitness) -\n                        Math.min(historyBest, bestFitness) < stopTolFun) {\n                    break generationLoop;\n                }\n                if (iterations > fitnessHistory.length &&\n                        historyWorst-historyBest < stopTolHistFun) {\n                    break generationLoop;\n                }\n                // condition number of the covariance matrix exceeds 1e14\n                if (max(diagD)/min(diagD) > 1e7) {\n                    break generationLoop;\n                }\n                // user defined termination\n                if (getConvergenceChecker() != null) {\n                    PointValuePair current =\n                        new PointValuePair(bestArx.getColumn(0),\n                                isMinimize ? bestFitness : -bestFitness);\n                    if (lastResult != null &&\n                        getConvergenceChecker().converged(iterations, current, lastResult)) {\n                        break generationLoop;\n                    }\n                    lastResult = current;\n                }\n                // Adjust step size in case of equal function values (flat fitness)\n                if (bestValue == fitness[arindex[(int)(0.1+lambda/4.)]]) {\n                    sigma = sigma * Math.exp(0.2+cs/damps);\n                }\n                if (iterations > 2 && Math.max(historyWorst, bestFitness) -\n                        Math.min(historyBest, bestFitness) == 0) {\n                    sigma = sigma * Math.exp(0.2+cs/damps);\n                }\n                // store best in history\n                push(fitnessHistory,bestFitness);\n                fitfun.setValueRange(worstFitness-bestFitness);\n                if (generateStatistics) {\n                    statisticsSigmaHistory.add(sigma);\n                    statisticsFitnessHistory.add(bestFitness);\n                    statisticsMeanHistory.add(xmean.transpose());\n                    statisticsDHistory.add(diagD.transpose().scalarMultiply(1E5));\n                }\n            }\n        return optimum;\n    }",
    "comment": "{@inheritDoc} */",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 3
  },
  {
    "name": "CMAESOptimizer.eye",
    "class_name": "org.apache.commons.math3.optimization.direct.CMAESOptimizer",
    "signature": "org.apache.commons.math3.optimization.direct.CMAESOptimizer.eye(int,int)",
    "snippet": "    private static RealMatrix eye(int n, int m) {\n        double[][] d = new double[n][m];\n        for (int r = 0; r < n; r++) {\n            if (r < m) {\n                d[r][r] = 1;\n            }\n        }\n        return new Array2DRowRealMatrix(d, false);\n    }",
    "comment": " @param n Number of rows. @param m Number of columns. @return n-by-m matrix of 0.0-values, diagonal has values 1.0. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 3
  },
  {
    "name": "CMAESOptimizer.initializeCMA",
    "class_name": "org.apache.commons.math3.optimization.direct.CMAESOptimizer",
    "signature": "org.apache.commons.math3.optimization.direct.CMAESOptimizer.initializeCMA(double[])",
    "snippet": "    private void initializeCMA(double[] guess) {\n        if (lambda <= 0) {\n            lambda = 4 + (int) (3. * Math.log(dimension));\n        }\n        // initialize sigma\n        double[][] sigmaArray = new double[guess.length][1];\n        for (int i = 0; i < guess.length; i++) {\n            final double range = (boundaries == null) ? 1.0 : boundaries[1][i] - boundaries[0][i];\n            sigmaArray[i][0] = ((inputSigma == null) ? 0.3 : inputSigma[i]) / range;\n        }\n        RealMatrix insigma = new Array2DRowRealMatrix(sigmaArray, false);\n        sigma = max(insigma); // overall standard deviation\n\n        // initialize termination criteria\n        stopTolUpX = 1e3 * max(insigma);\n        stopTolX = 1e-11 * max(insigma);\n        stopTolFun = 1e-12;\n        stopTolHistFun = 1e-13;\n\n        // initialize selection strategy parameters\n        mu = lambda / 2; // number of parents/points for recombination\n        logMu2 = Math.log(mu + 0.5);\n        weights = log(sequence(1, mu, 1)).scalarMultiply(-1.).scalarAdd(logMu2);\n        double sumw = 0;\n        double sumwq = 0;\n        for (int i = 0; i < mu; i++) {\n            double w = weights.getEntry(i, 0);\n            sumw += w;\n            sumwq += w * w;\n        }\n        weights = weights.scalarMultiply(1. / sumw);\n        mueff = sumw * sumw / sumwq; // variance-effectiveness of sum w_i x_i\n\n        // initialize dynamic strategy parameters and constants\n        cc = (4. + mueff / dimension) /\n                (dimension + 4. + 2. * mueff / dimension);\n        cs = (mueff + 2.) / (dimension + mueff + 3.);\n        damps = (1. + 2. * Math.max(0, Math.sqrt((mueff - 1.) /\n                (dimension + 1.)) - 1.)) *\n                Math.max(0.3, 1. - dimension /\n                        (1e-6 + Math.min(maxIterations, getMaxEvaluations() /\n                                lambda))) + cs; // minor increment\n        ccov1 = 2. / ((dimension + 1.3) * (dimension + 1.3) + mueff);\n        ccovmu = Math.min(1 - ccov1, 2. * (mueff - 2. + 1. / mueff) /\n                ((dimension + 2.) * (dimension + 2.) + mueff));\n        ccov1Sep = Math.min(1, ccov1 * (dimension + 1.5) / 3.);\n        ccovmuSep = Math.min(1 - ccov1, ccovmu * (dimension + 1.5) / 3.);\n        chiN = Math.sqrt(dimension) *\n                (1. - 1. / (4. * dimension) + 1 / (21. * dimension * dimension));\n        // intialize CMA internal values - updated each generation\n        xmean = MatrixUtils.createColumnRealMatrix(guess); // objective\n                                                           // variables\n        diagD = insigma.scalarMultiply(1. / sigma);\n        diagC = square(diagD);\n        pc = zeros(dimension, 1); // evolution paths for C and sigma\n        ps = zeros(dimension, 1); // B defines the coordinate system\n        normps = ps.getFrobeniusNorm();\n\n        B = eye(dimension, dimension);\n        D = ones(dimension, 1); // diagonal D defines the scaling\n        BD = times(B, repmat(diagD.transpose(), dimension, 1));\n        C = B.multiply(diag(square(D)).multiply(B.transpose())); // covariance\n        historySize = 10 + (int) (3. * 10. * dimension / lambda);\n        fitnessHistory = new double[historySize]; // history of fitness values\n        for (int i = 0; i < historySize; i++) {\n            fitnessHistory[i] = Double.MAX_VALUE;\n        }\n    }",
    "comment": " Initialization of the dynamic search parameters  @param guess Initial guess for the arguments of the fitness function. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 3
  },
  {
    "name": "CMAESOptimizer.inverse",
    "class_name": "org.apache.commons.math3.optimization.direct.CMAESOptimizer",
    "signature": "org.apache.commons.math3.optimization.direct.CMAESOptimizer.inverse(int[])",
    "snippet": "    private static int[] inverse(final int[] indices) {\n        int[] inverse = new int[indices.length];\n        for (int i = 0; i < indices.length; i++) {\n            inverse[indices[i]] = i;\n        }\n        return inverse;\n    }",
    "comment": " @param indices Input index array. @return the inverse of the mapping defined by indices. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 3
  },
  {
    "name": "CMAESOptimizer.log",
    "class_name": "org.apache.commons.math3.optimization.direct.CMAESOptimizer",
    "signature": "org.apache.commons.math3.optimization.direct.CMAESOptimizer.log(RealMatrix)",
    "snippet": "    private static RealMatrix log(final RealMatrix m) {\n        double[][] d = new double[m.getRowDimension()][m.getColumnDimension()];\n        for (int r = 0; r < m.getRowDimension(); r++) {\n            for (int c = 0; c < m.getColumnDimension(); c++) {\n                d[r][c] = Math.log(m.getEntry(r, c));\n            }\n        }\n        return new Array2DRowRealMatrix(d, false);\n    }",
    "comment": " @param m Input matrix @return Matrix representing the element-wise logarithm of m. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 3
  },
  {
    "name": "CMAESOptimizer.max",
    "class_name": "org.apache.commons.math3.optimization.direct.CMAESOptimizer",
    "signature": "org.apache.commons.math3.optimization.direct.CMAESOptimizer.max(RealMatrix)",
    "snippet": "    private static double max(final RealMatrix m) {\n        double max = -Double.MAX_VALUE;\n        for (int r = 0; r < m.getRowDimension(); r++) {\n            for (int c = 0; c < m.getColumnDimension(); c++) {\n                double e = m.getEntry(r, c);\n                if (max < e) {\n                    max = e;\n                }\n            }\n        }\n        return max;\n    }",
    "comment": " @param m Input matrix. @return the maximum of the matrix element values. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 3
  },
  {
    "name": "CMAESOptimizer.max",
    "class_name": "org.apache.commons.math3.optimization.direct.CMAESOptimizer",
    "signature": "org.apache.commons.math3.optimization.direct.CMAESOptimizer.max(double[])",
    "snippet": "    private static double max(final double[] m) {\n        double max = -Double.MAX_VALUE;\n        for (int r = 0; r < m.length; r++) {\n            if (max < m[r]) {\n                max = m[r];\n            }\n        }\n        return max;\n    }",
    "comment": " @param m Input array. @return the maximum of the array values. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 3
  },
  {
    "name": "CMAESOptimizer.min",
    "class_name": "org.apache.commons.math3.optimization.direct.CMAESOptimizer",
    "signature": "org.apache.commons.math3.optimization.direct.CMAESOptimizer.min(RealMatrix)",
    "snippet": "    private static double min(final RealMatrix m) {\n        double min = Double.MAX_VALUE;\n        for (int r = 0; r < m.getRowDimension(); r++) {\n            for (int c = 0; c < m.getColumnDimension(); c++) {\n                double e = m.getEntry(r, c);\n                if (min > e) {\n                    min = e;\n                }\n            }\n        }\n        return min;\n    }",
    "comment": " @param m Input matrix. @return the minimum of the matrix element values. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 3
  },
  {
    "name": "CMAESOptimizer.min",
    "class_name": "org.apache.commons.math3.optimization.direct.CMAESOptimizer",
    "signature": "org.apache.commons.math3.optimization.direct.CMAESOptimizer.min(double[])",
    "snippet": "    private static double min(final double[] m) {\n        double min = Double.MAX_VALUE;\n        for (int r = 0; r < m.length; r++) {\n            if (min > m[r]) {\n                min = m[r];\n            }\n        }\n        return min;\n    }",
    "comment": " @param m Input array. @return the minimum of the array values. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 3
  },
  {
    "name": "CMAESOptimizer.ones",
    "class_name": "org.apache.commons.math3.optimization.direct.CMAESOptimizer",
    "signature": "org.apache.commons.math3.optimization.direct.CMAESOptimizer.ones(int,int)",
    "snippet": "    private static RealMatrix ones(int n, int m) {\n        double[][] d = new double[n][m];\n        for (int r = 0; r < n; r++) {\n            Arrays.fill(d[r], 1.0);\n        }\n        return new Array2DRowRealMatrix(d, false);\n    }",
    "comment": " @param n Number of rows. @param m Number of columns. @return n-by-m matrix filled with 1. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 3
  },
  {
    "name": "CMAESOptimizer.push",
    "class_name": "org.apache.commons.math3.optimization.direct.CMAESOptimizer",
    "signature": "org.apache.commons.math3.optimization.direct.CMAESOptimizer.push(double[],double)",
    "snippet": "    private static void push(double[] vals, double val) {\n        for (int i = vals.length-1; i > 0; i--) {\n            vals[i] = vals[i-1];\n        }\n        vals[0] = val;\n    }",
    "comment": " Pushes the current best fitness value in a history queue.  @param vals History queue. @param val Current best fitness value. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 3
  },
  {
    "name": "CMAESOptimizer.randn1",
    "class_name": "org.apache.commons.math3.optimization.direct.CMAESOptimizer",
    "signature": "org.apache.commons.math3.optimization.direct.CMAESOptimizer.randn1(int,int)",
    "snippet": "    private RealMatrix randn1(int size, int popSize) {\n        double[][] d = new double[size][popSize];\n        for (int r = 0; r < size; r++) {\n            for (int c = 0; c < popSize; c++) {\n                d[r][c] = random.nextGaussian();\n            }\n        }\n        return new Array2DRowRealMatrix(d, false);\n    }",
    "comment": " @param size Number of rows. @param popSize Population size. @return a 2-dimensional matrix of Gaussian random numbers. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 3
  },
  {
    "name": "CMAESOptimizer.repmat",
    "class_name": "org.apache.commons.math3.optimization.direct.CMAESOptimizer",
    "signature": "org.apache.commons.math3.optimization.direct.CMAESOptimizer.repmat(RealMatrix,int,int)",
    "snippet": "    private static RealMatrix repmat(final RealMatrix mat, int n, int m) {\n        int rd = mat.getRowDimension();\n        int cd = mat.getColumnDimension();\n        double[][] d = new double[n * rd][m * cd];\n        for (int r = 0; r < n * rd; r++) {\n            for (int c = 0; c < m * cd; c++) {\n                d[r][c] = mat.getEntry(r % rd, c % cd);\n            }\n        }\n        return new Array2DRowRealMatrix(d, false);\n    }",
    "comment": " @param mat Input matrix. @param n Number of row replicates. @param m Number of column replicates. @return a matrix which replicates the input matrix in both directions. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 3
  },
  {
    "name": "CMAESOptimizer.reverse",
    "class_name": "org.apache.commons.math3.optimization.direct.CMAESOptimizer",
    "signature": "org.apache.commons.math3.optimization.direct.CMAESOptimizer.reverse(int[])",
    "snippet": "    private static int[] reverse(final int[] indices) {\n        int[] reverse = new int[indices.length];\n        for (int i = 0; i < indices.length; i++) {\n            reverse[i] = indices[indices.length - i - 1];\n        }\n        return reverse;\n    }",
    "comment": " @param indices Input index array. @return the indices in inverse order (last is first). ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 3
  },
  {
    "name": "CMAESOptimizer.selectColumns",
    "class_name": "org.apache.commons.math3.optimization.direct.CMAESOptimizer",
    "signature": "org.apache.commons.math3.optimization.direct.CMAESOptimizer.selectColumns(RealMatrix,int[])",
    "snippet": "    private static RealMatrix selectColumns(final RealMatrix m, final int[] cols) {\n        double[][] d = new double[m.getRowDimension()][cols.length];\n        for (int r = 0; r < m.getRowDimension(); r++) {\n            for (int c = 0; c < cols.length; c++) {\n                d[r][c] = m.getEntry(r, cols[c]);\n            }\n        }\n        return new Array2DRowRealMatrix(d, false);\n    }",
    "comment": " @param m Input matrix. @param cols Columns to select. @return Matrix representing the selected columns. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 3
  },
  {
    "name": "CMAESOptimizer.sequence",
    "class_name": "org.apache.commons.math3.optimization.direct.CMAESOptimizer",
    "signature": "org.apache.commons.math3.optimization.direct.CMAESOptimizer.sequence(double,double,double)",
    "snippet": "    private static RealMatrix sequence(double start, double end, double step) {\n        int size = (int) ((end - start) / step + 1);\n        double[][] d = new double[size][1];\n        double value = start;\n        for (int r = 0; r < size; r++) {\n            d[r][0] = value;\n            value += step;\n        }\n        return new Array2DRowRealMatrix(d, false);\n    }",
    "comment": " @param start Start value. @param end End value. @param step Step size. @return a sequence as column matrix. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 3
  },
  {
    "name": "CMAESOptimizer.sortedIndices",
    "class_name": "org.apache.commons.math3.optimization.direct.CMAESOptimizer",
    "signature": "org.apache.commons.math3.optimization.direct.CMAESOptimizer.sortedIndices(double[])",
    "snippet": "    private int[] sortedIndices(final double[] doubles) {\n        DoubleIndex[] dis = new DoubleIndex[doubles.length];\n        for (int i = 0; i < doubles.length; i++) {\n            dis[i] = new DoubleIndex(doubles[i], i);\n        }\n        Arrays.sort(dis);\n        int[] indices = new int[doubles.length];\n        for (int i = 0; i < doubles.length; i++) {\n            indices[i] = dis[i].index;\n        }\n        return indices;\n    }",
    "comment": " Sorts fitness values.  @param doubles Array of values to be sorted. @return a sorted array of indices pointing into doubles. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 3
  },
  {
    "name": "CMAESOptimizer.sqrt",
    "class_name": "org.apache.commons.math3.optimization.direct.CMAESOptimizer",
    "signature": "org.apache.commons.math3.optimization.direct.CMAESOptimizer.sqrt(RealMatrix)",
    "snippet": "    private static RealMatrix sqrt(final RealMatrix m) {\n        double[][] d = new double[m.getRowDimension()][m.getColumnDimension()];\n        for (int r = 0; r < m.getRowDimension(); r++) {\n            for (int c = 0; c < m.getColumnDimension(); c++) {\n                d[r][c] = Math.sqrt(m.getEntry(r, c));\n            }\n        }\n        return new Array2DRowRealMatrix(d, false);\n    }",
    "comment": " @param m Input matrix @return Matrix representing the element-wise square root of m. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 3
  },
  {
    "name": "CMAESOptimizer.square",
    "class_name": "org.apache.commons.math3.optimization.direct.CMAESOptimizer",
    "signature": "org.apache.commons.math3.optimization.direct.CMAESOptimizer.square(RealMatrix)",
    "snippet": "    private static RealMatrix square(final RealMatrix m) {\n        double[][] d = new double[m.getRowDimension()][m.getColumnDimension()];\n        for (int r = 0; r < m.getRowDimension(); r++) {\n            for (int c = 0; c < m.getColumnDimension(); c++) {\n                double e = m.getEntry(r, c);\n                d[r][c] = e * e;\n            }\n        }\n        return new Array2DRowRealMatrix(d, false);\n    }",
    "comment": " @param m Input matrix @return Matrix representing the element-wise square (^2) of m. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 3
  },
  {
    "name": "CMAESOptimizer.sumRows",
    "class_name": "org.apache.commons.math3.optimization.direct.CMAESOptimizer",
    "signature": "org.apache.commons.math3.optimization.direct.CMAESOptimizer.sumRows(RealMatrix)",
    "snippet": "    private static RealMatrix sumRows(final RealMatrix m) {\n        double[][] d = new double[1][m.getColumnDimension()];\n        for (int c = 0; c < m.getColumnDimension(); c++) {\n            double sum = 0;\n            for (int r = 0; r < m.getRowDimension(); r++) {\n                sum += m.getEntry(r, c);\n            }\n            d[0][c] = sum;\n        }\n        return new Array2DRowRealMatrix(d, false);\n    }",
    "comment": " @param m Input matrix. @return Row matrix representing the sums of the rows. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 3
  },
  {
    "name": "CMAESOptimizer.times",
    "class_name": "org.apache.commons.math3.optimization.direct.CMAESOptimizer",
    "signature": "org.apache.commons.math3.optimization.direct.CMAESOptimizer.times(RealMatrix,RealMatrix)",
    "snippet": "    private static RealMatrix times(final RealMatrix m, final RealMatrix n) {\n        double[][] d = new double[m.getRowDimension()][m.getColumnDimension()];\n        for (int r = 0; r < m.getRowDimension(); r++) {\n            for (int c = 0; c < m.getColumnDimension(); c++) {\n                d[r][c] = m.getEntry(r, c) * n.getEntry(r, c);\n            }\n        }\n        return new Array2DRowRealMatrix(d, false);\n    }",
    "comment": " @param m Input matrix 1. @param n Input matrix 2. @return the matrix where the elements of m and n are element-wise multiplied. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 3
  },
  {
    "name": "CMAESOptimizer.triu",
    "class_name": "org.apache.commons.math3.optimization.direct.CMAESOptimizer",
    "signature": "org.apache.commons.math3.optimization.direct.CMAESOptimizer.triu(RealMatrix,int)",
    "snippet": "    private static RealMatrix triu(final RealMatrix m, int k) {\n        double[][] d = new double[m.getRowDimension()][m.getColumnDimension()];\n        for (int r = 0; r < m.getRowDimension(); r++) {\n            for (int c = 0; c < m.getColumnDimension(); c++) {\n                d[r][c] = r <= c - k ? m.getEntry(r, c) : 0;\n            }\n        }\n        return new Array2DRowRealMatrix(d, false);\n    }",
    "comment": " @param m Input matrix. @param k Diagonal position. @return Upper triangular part of matrix. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 3
  },
  {
    "name": "CMAESOptimizer.updateBD",
    "class_name": "org.apache.commons.math3.optimization.direct.CMAESOptimizer",
    "signature": "org.apache.commons.math3.optimization.direct.CMAESOptimizer.updateBD(double)",
    "snippet": "    private void updateBD(double negccov) {\n        if (ccov1 + ccovmu + negccov > 0 &&\n                (iterations % 1. / (ccov1 + ccovmu + negccov) / dimension / 10.) < 1.) {\n            // to achieve O(N^2)\n            C = triu(C, 0).add(triu(C, 1).transpose());\n            // enforce symmetry to prevent complex numbers\n            EigenDecomposition eig = new EigenDecomposition(C);\n            B = eig.getV(); // eigen decomposition, B==normalized eigenvectors\n            D = eig.getD();\n            diagD = diag(D);\n            if (min(diagD) <= 0) {\n                for (int i = 0; i < dimension; i++) {\n                    if (diagD.getEntry(i, 0) < 0) {\n                        diagD.setEntry(i, 0, 0.);\n                    }\n                }\n                double tfac = max(diagD) / 1e14;\n                C = C.add(eye(dimension, dimension).scalarMultiply(tfac));\n                diagD = diagD.add(ones(dimension, 1).scalarMultiply(tfac));\n            }\n            if (max(diagD) > 1e14 * min(diagD)) {\n                double tfac = max(diagD) / 1e14 - min(diagD);\n                C = C.add(eye(dimension, dimension).scalarMultiply(tfac));\n                diagD = diagD.add(ones(dimension, 1).scalarMultiply(tfac));\n            }\n            diagC = diag(C);\n            diagD = sqrt(diagD); // D contains standard deviations now\n            BD = times(B, repmat(diagD.transpose(), dimension, 1)); // O(n^2)\n        }\n    }",
    "comment": " Update B and D from C.  @param negccov Negative covariance factor. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 3
  },
  {
    "name": "CMAESOptimizer.updateCovariance",
    "class_name": "org.apache.commons.math3.optimization.direct.CMAESOptimizer",
    "signature": "org.apache.commons.math3.optimization.direct.CMAESOptimizer.updateCovariance(boolean,RealMatrix,RealMatrix,int[],RealMatrix)",
    "snippet": "    private void updateCovariance(boolean hsig, final RealMatrix bestArx,\n            final RealMatrix arz, final int[] arindex, final RealMatrix xold) {\n        double negccov = 0;\n        if (ccov1 + ccovmu > 0) {\n            RealMatrix arpos = bestArx.subtract(repmat(xold, 1, mu))\n                    .scalarMultiply(1. / sigma); // mu difference vectors\n            RealMatrix roneu = pc.multiply(pc.transpose())\n                    .scalarMultiply(ccov1); // rank one update\n            // minor correction if hsig==false\n            double oldFac = hsig ? 0 : ccov1 * cc * (2. - cc);\n            oldFac += 1. - ccov1 - ccovmu;\n            if (isActiveCMA) {\n                // Adapt covariance matrix C active CMA\n                negccov = (1. - ccovmu) * 0.25 * mueff /\n                (Math.pow(dimension + 2., 1.5) + 2. * mueff);\n                double negminresidualvariance = 0.66;\n                // keep at least 0.66 in all directions, small popsize are most\n                // critical\n                double negalphaold = 0.5; // where to make up for the variance\n                                          // loss,\n                // prepare vectors, compute negative updating matrix Cneg\n                int[] arReverseIndex = reverse(arindex);\n                RealMatrix arzneg\n                    = selectColumns(arz, MathArrays.copyOf(arReverseIndex, mu));\n                RealMatrix arnorms = sqrt(sumRows(square(arzneg)));\n                int[] idxnorms = sortedIndices(arnorms.getRow(0));\n                RealMatrix arnormsSorted = selectColumns(arnorms, idxnorms);\n                int[] idxReverse = reverse(idxnorms);\n                RealMatrix arnormsReverse = selectColumns(arnorms, idxReverse);\n                arnorms = divide(arnormsReverse, arnormsSorted);\n                int[] idxInv = inverse(idxnorms);\n                RealMatrix arnormsInv = selectColumns(arnorms, idxInv);\n                // check and set learning rate negccov\n                double negcovMax = (1. - negminresidualvariance) /\n                        square(arnormsInv).multiply(weights).getEntry(0, 0);\n                if (negccov > negcovMax) {\n                    negccov = negcovMax;\n                }\n                arzneg = times(arzneg, repmat(arnormsInv, dimension, 1));\n                RealMatrix artmp = BD.multiply(arzneg);\n                RealMatrix Cneg = artmp.multiply(diag(weights)).multiply(\n                        artmp.transpose());\n                oldFac += negalphaold * negccov;\n                C = C.scalarMultiply(oldFac)\n                        // regard old matrix\n                        .add(roneu)\n                        // plus rank one update\n                        .add(arpos.scalarMultiply(\n                                // plus rank mu update\n                                ccovmu + (1. - negalphaold) * negccov)\n                                .multiply(\n                                        times(repmat(weights, 1, dimension),\n                                                arpos.transpose())))\n                        .subtract(Cneg.scalarMultiply(negccov));\n            } else {\n                // Adapt covariance matrix C - nonactive\n                C = C.scalarMultiply(oldFac) // regard old matrix\n                        .add(roneu)\n                        // plus rank one update\n                        .add(arpos.scalarMultiply(ccovmu) // plus rank mu update\n                                .multiply(\n                                        times(repmat(weights, 1, dimension),\n                                                arpos.transpose())));\n            }\n        }\n        updateBD(negccov);\n    }",
    "comment": " Update of the covariance matrix C.  @param hsig Flag indicating a small correction. @param bestArx Fitness-sorted matrix of the argument vectors producing the current offspring. @param arz Unsorted matrix containing the gaussian random values of the current offspring. @param arindex Indices indicating the fitness-order of the current offspring. @param xold xmean matrix of the previous generation. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 3
  },
  {
    "name": "CMAESOptimizer.updateEvolutionPaths",
    "class_name": "org.apache.commons.math3.optimization.direct.CMAESOptimizer",
    "signature": "org.apache.commons.math3.optimization.direct.CMAESOptimizer.updateEvolutionPaths(RealMatrix,RealMatrix)",
    "snippet": "    private boolean updateEvolutionPaths(RealMatrix zmean, RealMatrix xold) {\n        ps = ps.scalarMultiply(1. - cs).add(\n                B.multiply(zmean).scalarMultiply(\n                        Math.sqrt(cs * (2. - cs) * mueff)));\n        normps = ps.getFrobeniusNorm();\n        boolean hsig = normps /\n            Math.sqrt(1. - Math.pow(1. - cs, 2. * iterations)) /\n                chiN < 1.4 + 2. / (dimension + 1.);\n        pc = pc.scalarMultiply(1. - cc);\n        if (hsig) {\n            pc = pc.add(xmean.subtract(xold).scalarMultiply(\n                    Math.sqrt(cc * (2. - cc) * mueff) / sigma));\n        }\n        return hsig;\n    }",
    "comment": " Update of the evolution paths ps and pc.  @param zmean Weighted row matrix of the gaussian random numbers generating the current offspring. @param xold xmean matrix of the previous generation. @return hsig flag indicating a small correction. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 3
  },
  {
    "name": "CMAESOptimizer.zeros",
    "class_name": "org.apache.commons.math3.optimization.direct.CMAESOptimizer",
    "signature": "org.apache.commons.math3.optimization.direct.CMAESOptimizer.zeros(int,int)",
    "snippet": "    private static RealMatrix zeros(int n, int m) {\n        return new Array2DRowRealMatrix(n, m);\n    }",
    "comment": " @param n Number of rows. @param m Number of columns. @return n-by-m matrix of 0.0-values. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 3
  },
  {
    "name": "DoubleIndex.compareTo",
    "class_name": "org.apache.commons.math3.optimization.direct.CMAESOptimizer$DoubleIndex",
    "signature": "org.apache.commons.math3.optimization.direct.CMAESOptimizer$DoubleIndex.compareTo(DoubleIndex)",
    "snippet": "        public int compareTo(DoubleIndex o) {\n            return Double.compare(value, o.value);\n        }",
    "comment": "{@inheritDoc} */",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 3
  },
  {
    "name": "FitnessFunction.decode",
    "class_name": "org.apache.commons.math3.optimization.direct.CMAESOptimizer$FitnessFunction",
    "signature": "org.apache.commons.math3.optimization.direct.CMAESOptimizer$FitnessFunction.decode(double[])",
    "snippet": "        public double[] decode(final double[] x) {\n            if (boundaries == null) {\n                return x;\n            }\n            double[] res = new double[x.length];\n            for (int i = 0; i < x.length; i++) {\n                double diff = boundaries[1][i] - boundaries[0][i];\n                res[i] = diff * x[i] + boundaries[0][i];\n            }\n            return res;\n        }",
    "comment": " @param x Normalized objective variables. @return the original objective variables. ",
    "is_bug": true,
    "failing_test_cases": 1,
    "buggy_methods": 3
  },
  {
    "name": "FitnessFunction.encode",
    "class_name": "org.apache.commons.math3.optimization.direct.CMAESOptimizer$FitnessFunction",
    "signature": "org.apache.commons.math3.optimization.direct.CMAESOptimizer$FitnessFunction.encode(double[])",
    "snippet": "        public double[] encode(final double[] x) {\n            if (boundaries == null) {\n                return x;\n            }\n            double[] res = new double[x.length];\n            for (int i = 0; i < x.length; i++) {\n                double diff = boundaries[1][i] - boundaries[0][i];\n                res[i] = (x[i] - boundaries[0][i]) / diff;\n            }\n            return res;\n        }",
    "comment": " @param x Original objective variables. @return the normalized objective variables. ",
    "is_bug": true,
    "failing_test_cases": 1,
    "buggy_methods": 3
  },
  {
    "name": "FitnessFunction.penalty",
    "class_name": "org.apache.commons.math3.optimization.direct.CMAESOptimizer$FitnessFunction",
    "signature": "org.apache.commons.math3.optimization.direct.CMAESOptimizer$FitnessFunction.penalty(double[],double[])",
    "snippet": "        private double penalty(final double[] x, final double[] repaired) {\n            double penalty = 0;\n            for (int i = 0; i < x.length; i++) {\n                double diff = Math.abs(x[i] - repaired[i]);\n                penalty += diff * valueRange;\n            }\n            return isMinimize ? penalty : -penalty;\n        }",
    "comment": " @param x Normalized objective variables. @param repaired Repaired objective variables. @return Penalty value according to the violation of the bounds. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 3
  },
  {
    "name": "FitnessFunction.repair",
    "class_name": "org.apache.commons.math3.optimization.direct.CMAESOptimizer$FitnessFunction",
    "signature": "org.apache.commons.math3.optimization.direct.CMAESOptimizer$FitnessFunction.repair(double[])",
    "snippet": "        private double[] repair(final double[] x) {\n            double[] repaired = new double[x.length];\n            for (int i = 0; i < x.length; i++) {\n                if (x[i] < 0) {\n                    repaired[i] = 0;\n                } else if (x[i] > 1.0) {\n                    repaired[i] = 1.0;\n                } else {\n                    repaired[i] = x[i];\n                }\n            }\n            return repaired;\n        }",
    "comment": " @param x Normalized objective variables. @return the repaired objective variables - all in bounds. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 3
  },
  {
    "name": "FitnessFunction.repairAndDecode",
    "class_name": "org.apache.commons.math3.optimization.direct.CMAESOptimizer$FitnessFunction",
    "signature": "org.apache.commons.math3.optimization.direct.CMAESOptimizer$FitnessFunction.repairAndDecode(double[])",
    "snippet": "        public double[] repairAndDecode(final double[] x) {\n            return boundaries != null && isRepairMode ?\n                decode(repair(x)) :\n                decode(x);\n        }",
    "comment": " @param x Normalized objective variables. @return the original objective variables, possibly repaired. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 3
  },
  {
    "name": "FitnessFunction.setValueRange",
    "class_name": "org.apache.commons.math3.optimization.direct.CMAESOptimizer$FitnessFunction",
    "signature": "org.apache.commons.math3.optimization.direct.CMAESOptimizer$FitnessFunction.setValueRange(double)",
    "snippet": "        public void setValueRange(double valueRange) {\n            this.valueRange = valueRange;\n        }",
    "comment": " @param valueRange Adjusts the penalty computation. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 3
  },
  {
    "name": "FitnessFunction.value",
    "class_name": "org.apache.commons.math3.optimization.direct.CMAESOptimizer$FitnessFunction",
    "signature": "org.apache.commons.math3.optimization.direct.CMAESOptimizer$FitnessFunction.value(double[])",
    "snippet": "        public double value(final double[] point) {\n            double value;\n            if (boundaries != null && isRepairMode) {\n                double[] repaired = repair(point);\n                value = CMAESOptimizer.this\n                        .computeObjectiveValue(decode(repaired)) +\n                        penalty(point, repaired);\n            } else {\n                value = CMAESOptimizer.this\n                        .computeObjectiveValue(decode(point));\n            }\n            return isMinimize ? value : -value;\n        }",
    "comment": " @param point Normalized objective variables. @return the objective value + penalty for violated bounds. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 3
  },
  {
    "name": "BitsStreamGenerator.BitsStreamGenerator",
    "class_name": "org.apache.commons.math3.random.BitsStreamGenerator",
    "signature": "org.apache.commons.math3.random.BitsStreamGenerator.BitsStreamGenerator()",
    "snippet": "    public BitsStreamGenerator() {\n        nextGaussian = Double.NaN;\n    }",
    "comment": "Creates a new random number generator. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 3
  },
  {
    "name": "BitsStreamGenerator.clear",
    "class_name": "org.apache.commons.math3.random.BitsStreamGenerator",
    "signature": "org.apache.commons.math3.random.BitsStreamGenerator.clear()",
    "snippet": "    public void clear() {\n        nextGaussian = Double.NaN;\n    }",
    "comment": " Clears the cache used by the default implementation of {@link #nextGaussian}. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 3
  },
  {
    "name": "BitsStreamGenerator.nextDouble",
    "class_name": "org.apache.commons.math3.random.BitsStreamGenerator",
    "signature": "org.apache.commons.math3.random.BitsStreamGenerator.nextDouble()",
    "snippet": "    public double nextDouble() {\n        final long high = ((long) next(26)) << 26;\n        final int  low  = next(26);\n        return (high | low) * 0x1.0p-52d;\n    }",
    "comment": "{@inheritDoc} */",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 3
  },
  {
    "name": "BitsStreamGenerator.nextGaussian",
    "class_name": "org.apache.commons.math3.random.BitsStreamGenerator",
    "signature": "org.apache.commons.math3.random.BitsStreamGenerator.nextGaussian()",
    "snippet": "    public double nextGaussian() {\n\n        final double random;\n        if (Double.isNaN(nextGaussian)) {\n            // generate a new pair of gaussian numbers\n            final double x = nextDouble();\n            final double y = nextDouble();\n            final double alpha = 2 * FastMath.PI * x;\n            final double r      = FastMath.sqrt(-2 * FastMath.log(y));\n            random       = r * FastMath.cos(alpha);\n            nextGaussian = r * FastMath.sin(alpha);\n        } else {\n            // use the second element of the pair already generated\n            random = nextGaussian;\n            nextGaussian = Double.NaN;\n        }\n\n        return random;\n\n    }",
    "comment": "{@inheritDoc} */",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 3
  },
  {
    "name": "MersenneTwister.MersenneTwister",
    "class_name": "org.apache.commons.math3.random.MersenneTwister",
    "signature": "org.apache.commons.math3.random.MersenneTwister.MersenneTwister()",
    "snippet": "    public MersenneTwister() {\n        mt = new int[N];\n        setSeed(System.currentTimeMillis() + System.identityHashCode(this));\n    }",
    "comment": "Creates a new random number generator. <p>The instance is initialized using the current time plus the system identity hash code of this instance as the seed.</p> ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 3
  },
  {
    "name": "MersenneTwister.next",
    "class_name": "org.apache.commons.math3.random.MersenneTwister",
    "signature": "org.apache.commons.math3.random.MersenneTwister.next(int)",
    "snippet": "    @Override\n    protected int next(int bits) {\n\n        int y;\n\n        if (mti >= N) { // generate N words at one time\n            int mtNext = mt[0];\n            for (int k = 0; k < N - M; ++k) {\n                int mtCurr = mtNext;\n                mtNext = mt[k + 1];\n                y = (mtCurr & 0x80000000) | (mtNext & 0x7fffffff);\n                mt[k] = mt[k + M] ^ (y >>> 1) ^ MAG01[y & 0x1];\n            }\n            for (int k = N - M; k < N - 1; ++k) {\n                int mtCurr = mtNext;\n                mtNext = mt[k + 1];\n                y = (mtCurr & 0x80000000) | (mtNext & 0x7fffffff);\n                mt[k] = mt[k + (M - N)] ^ (y >>> 1) ^ MAG01[y & 0x1];\n            }\n            y = (mtNext & 0x80000000) | (mt[0] & 0x7fffffff);\n            mt[N - 1] = mt[M - 1] ^ (y >>> 1) ^ MAG01[y & 0x1];\n\n            mti = 0;\n        }\n\n        y = mt[mti++];\n\n        // tempering\n        y ^=  y >>> 11;\n        y ^= (y <<   7) & 0x9d2c5680;\n        y ^= (y <<  15) & 0xefc60000;\n        y ^=  y >>> 18;\n\n        return y >>> (32 - bits);\n\n    }",
    "comment": "Generate next pseudorandom number. <p>This method is the core generation algorithm. It is used by all the public generation methods for the various primitive types {@link #nextBoolean()}, {@link #nextBytes(byte[])}, {@link #nextDouble()}, {@link #nextFloat()}, {@link #nextGaussian()}, {@link #nextInt()}, {@link #next(int)} and {@link #nextLong()}.</p> @param bits number of random bits to produce @return random bits generated ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 3
  },
  {
    "name": "MersenneTwister.setSeed",
    "class_name": "org.apache.commons.math3.random.MersenneTwister",
    "signature": "org.apache.commons.math3.random.MersenneTwister.setSeed(int)",
    "snippet": "    @Override\n    public void setSeed(int seed) {\n        // we use a long masked by 0xffffffffL as a poor man unsigned int\n        long longMT = seed;\n        // NB: unlike original C code, we are working with java longs, the cast below makes masking unnecessary\n        mt[0]= (int) longMT;\n        for (mti = 1; mti < N; ++mti) {\n            // See Knuth TAOCP Vol2. 3rd Ed. P.106 for multiplier.\n            // initializer from the 2002-01-09 C version by Makoto Matsumoto\n            longMT = (1812433253l * (longMT ^ (longMT >> 30)) + mti) & 0xffffffffL;\n            mt[mti]= (int) longMT;\n        }\n\n        clear(); // Clear normal deviate cache\n    }",
    "comment": "Reinitialize the generator as if just built with the given int seed. <p>The state of the generator is exactly the same as a new generator built with the same seed.</p> @param seed the initial seed (32 bits integer) ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 3
  },
  {
    "name": "MersenneTwister.setSeed",
    "class_name": "org.apache.commons.math3.random.MersenneTwister",
    "signature": "org.apache.commons.math3.random.MersenneTwister.setSeed(int[])",
    "snippet": "    @Override\n    public void setSeed(int[] seed) {\n\n        if (seed == null) {\n            setSeed(System.currentTimeMillis() + System.identityHashCode(this));\n            return;\n        }\n\n        setSeed(19650218);\n        int i = 1;\n        int j = 0;\n\n        for (int k = FastMath.max(N, seed.length); k != 0; k--) {\n            long l0 = (mt[i] & 0x7fffffffl)   | ((mt[i]   < 0) ? 0x80000000l : 0x0l);\n            long l1 = (mt[i-1] & 0x7fffffffl) | ((mt[i-1] < 0) ? 0x80000000l : 0x0l);\n            long l  = (l0 ^ ((l1 ^ (l1 >> 30)) * 1664525l)) + seed[j] + j; // non linear\n            mt[i]   = (int) (l & 0xffffffffl);\n            i++; j++;\n            if (i >= N) {\n                mt[0] = mt[N - 1];\n                i = 1;\n            }\n            if (j >= seed.length) {\n                j = 0;\n            }\n        }\n\n        for (int k = N - 1; k != 0; k--) {\n            long l0 = (mt[i] & 0x7fffffffl)   | ((mt[i]   < 0) ? 0x80000000l : 0x0l);\n            long l1 = (mt[i-1] & 0x7fffffffl) | ((mt[i-1] < 0) ? 0x80000000l : 0x0l);\n            long l  = (l0 ^ ((l1 ^ (l1 >> 30)) * 1566083941l)) - i; // non linear\n            mt[i]   = (int) (l & 0xffffffffL);\n            i++;\n            if (i >= N) {\n                mt[0] = mt[N - 1];\n                i = 1;\n            }\n        }\n\n        mt[0] = 0x80000000; // MSB is 1; assuring non-zero initial array\n\n        clear(); // Clear normal deviate cache\n\n    }",
    "comment": "Reinitialize the generator as if just built with the given int array seed. <p>The state of the generator is exactly the same as a new generator built with the same seed.</p> @param seed the initial seed (32 bits integers array), if null the seed of the generator will be the current system time plus the system identity hash code of this instance ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 3
  },
  {
    "name": "MersenneTwister.setSeed",
    "class_name": "org.apache.commons.math3.random.MersenneTwister",
    "signature": "org.apache.commons.math3.random.MersenneTwister.setSeed(long)",
    "snippet": "    @Override\n    public void setSeed(long seed) {\n        setSeed(new int[] { (int) (seed >>> 32), (int) (seed & 0xffffffffl) });\n    }",
    "comment": "Reinitialize the generator as if just built with the given long seed. <p>The state of the generator is exactly the same as a new generator built with the same seed.</p> @param seed the initial seed (64 bits integer) ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 3
  },
  {
    "name": "CompositeFormat.getDefaultNumberFormat",
    "class_name": "org.apache.commons.math3.util.CompositeFormat",
    "signature": "org.apache.commons.math3.util.CompositeFormat.getDefaultNumberFormat()",
    "snippet": "    public static NumberFormat getDefaultNumberFormat() {\n        return getDefaultNumberFormat(Locale.getDefault());\n    }",
    "comment": " Create a default number format.  The default number format is based on {@link NumberFormat#getInstance()} with the only customizing that the maximum number of fraction digits is set to 10. @return the default number format. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 3
  },
  {
    "name": "CompositeFormat.getDefaultNumberFormat",
    "class_name": "org.apache.commons.math3.util.CompositeFormat",
    "signature": "org.apache.commons.math3.util.CompositeFormat.getDefaultNumberFormat(Locale)",
    "snippet": "    public static NumberFormat getDefaultNumberFormat(final Locale locale) {\n        final NumberFormat nf = NumberFormat.getInstance(locale);\n        nf.setMaximumFractionDigits(10);\n        return nf;\n    }",
    "comment": " Create a default number format.  The default number format is based on {@link NumberFormat#getInstance(java.util.Locale)} with the only customizing that the maximum number of fraction digits is set to 10. @param locale the specific locale used by the format. @return the default number format specific to the given locale. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 3
  },
  {
    "name": "FastMath.abs",
    "class_name": "org.apache.commons.math3.util.FastMath",
    "signature": "org.apache.commons.math3.util.FastMath.abs(double)",
    "snippet": "    public static double abs(double x) {\n        return (x < 0.0) ? -x : (x == 0.0) ? 0.0 : x; // -0.0 => +0.0\n    }",
    "comment": " Absolute value. @param x number from which absolute value is requested @return abs(x) ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 3
  },
  {
    "name": "FastMath.abs",
    "class_name": "org.apache.commons.math3.util.FastMath",
    "signature": "org.apache.commons.math3.util.FastMath.abs(long)",
    "snippet": "    public static long abs(final long x) {\n        return (x < 0l) ? -x : x;\n    }",
    "comment": " Absolute value. @param x number from which absolute value is requested @return abs(x) ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 3
  },
  {
    "name": "FastMath.cos",
    "class_name": "org.apache.commons.math3.util.FastMath",
    "signature": "org.apache.commons.math3.util.FastMath.cos(double)",
    "snippet": "    public static double cos(double x) {\n        int quadrant = 0;\n\n        /* Take absolute value of the input */\n        double xa = x;\n        if (x < 0) {\n            xa = -xa;\n        }\n\n        if (xa != xa || xa == Double.POSITIVE_INFINITY) {\n            return Double.NaN;\n        }\n\n        /* Perform any argument reduction */\n        double xb = 0;\n        if (xa > 3294198.0) {\n            // PI * (2**20)\n            // Argument too big for CodyWaite reduction.  Must use\n            // PayneHanek.\n            double reduceResults[] = new double[3];\n            reducePayneHanek(xa, reduceResults);\n            quadrant = ((int) reduceResults[0]) & 3;\n            xa = reduceResults[1];\n            xb = reduceResults[2];\n        } else if (xa > 1.5707963267948966) {\n            final CodyWaite cw = new CodyWaite(xa, xb);\n            quadrant = cw.getK() & 3;\n            xa = cw.getRemA();\n            xb = cw.getRemB();\n        }\n\n        //if (negative)\n        //  quadrant = (quadrant + 2) % 4;\n\n        switch (quadrant) {\n            case 0:\n                return cosQ(xa, xb);\n            case 1:\n                return -sinQ(xa, xb);\n            case 2:\n                return -cosQ(xa, xb);\n            case 3:\n                return sinQ(xa, xb);\n            default:\n                return Double.NaN;\n        }\n    }",
    "comment": " Cosine function.  @param x Argument. @return cos(x) ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 3
  },
  {
    "name": "FastMath.cosQ",
    "class_name": "org.apache.commons.math3.util.FastMath",
    "signature": "org.apache.commons.math3.util.FastMath.cosQ(double,double)",
    "snippet": "    private static double cosQ(double xa, double xb) {\n        final double pi2a = 1.5707963267948966;\n        final double pi2b = 6.123233995736766E-17;\n\n        final double a = pi2a - xa;\n        double b = -(a - pi2a + xa);\n        b += pi2b - xb;\n\n        return sinQ(a, b);\n    }",
    "comment": " Compute cosine in the first quadrant by subtracting input from PI/2 and then calling sinQ.  This is more accurate as the input approaches PI/2. @param xa number from which cosine is requested @param xb extra bits for x (may be 0.0) @return cos(xa + xb) ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 3
  },
  {
    "name": "FastMath.log",
    "class_name": "org.apache.commons.math3.util.FastMath",
    "signature": "org.apache.commons.math3.util.FastMath.log(double)",
    "snippet": "    public static double log(final double x) {\n        return log(x, null);\n    }",
    "comment": " Natural logarithm.  @param x   a double @return log(x) ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 3
  },
  {
    "name": "FastMath.log",
    "class_name": "org.apache.commons.math3.util.FastMath",
    "signature": "org.apache.commons.math3.util.FastMath.log(double,double[])",
    "snippet": "    private static double log(final double x, final double[] hiPrec) {\n        if (x==0) { // Handle special case of +0/-0\n            return Double.NEGATIVE_INFINITY;\n        }\n        long bits = Double.doubleToLongBits(x);\n\n        /* Handle special cases of negative input, and NaN */\n        if ((bits & 0x8000000000000000L) != 0 || x != x) {\n            if (x != 0.0) {\n                if (hiPrec != null) {\n                    hiPrec[0] = Double.NaN;\n                }\n\n                return Double.NaN;\n            }\n        }\n\n        /* Handle special cases of Positive infinity. */\n        if (x == Double.POSITIVE_INFINITY) {\n            if (hiPrec != null) {\n                hiPrec[0] = Double.POSITIVE_INFINITY;\n            }\n\n            return Double.POSITIVE_INFINITY;\n        }\n\n        /* Extract the exponent */\n        int exp = (int)(bits >> 52)-1023;\n\n        if ((bits & 0x7ff0000000000000L) == 0) {\n            // Subnormal!\n            if (x == 0) {\n                // Zero\n                if (hiPrec != null) {\n                    hiPrec[0] = Double.NEGATIVE_INFINITY;\n                }\n\n                return Double.NEGATIVE_INFINITY;\n            }\n\n            /* Normalize the subnormal number. */\n            bits <<= 1;\n            while ( (bits & 0x0010000000000000L) == 0) {\n                --exp;\n                bits <<= 1;\n            }\n        }\n\n\n        if (exp == -1 || exp == 0) {\n            if (x < 1.01 && x > 0.99 && hiPrec == null) {\n                /* The normal method doesn't work well in the range [0.99, 1.01], so call do a straight\n           polynomial expansion in higer precision. */\n\n               /* Compute x - 1.0 and split it */\n                double xa = x - 1.0;\n                double xb = xa - x + 1.0;\n                double tmp = xa * HEX_40000000;\n                double aa = xa + tmp - tmp;\n                double ab = xa - aa;\n                xa = aa;\n                xb = ab;\n\n                final double[] lnCoef_last = LN_QUICK_COEF[LN_QUICK_COEF.length - 1];\n                double ya = lnCoef_last[0];\n                double yb = lnCoef_last[1];\n\n                for (int i = LN_QUICK_COEF.length - 2; i >= 0; i--) {\n                    /* Multiply a = y * x */\n                    aa = ya * xa;\n                    ab = ya * xb + yb * xa + yb * xb;\n                    /* split, so now y = a */\n                    tmp = aa * HEX_40000000;\n                    ya = aa + tmp - tmp;\n                    yb = aa - ya + ab;\n\n                    /* Add  a = y + lnQuickCoef */\n                    final double[] lnCoef_i = LN_QUICK_COEF[i];\n                    aa = ya + lnCoef_i[0];\n                    ab = yb + lnCoef_i[1];\n                    /* Split y = a */\n                    tmp = aa * HEX_40000000;\n                    ya = aa + tmp - tmp;\n                    yb = aa - ya + ab;\n                }\n\n                /* Multiply a = y * x */\n                aa = ya * xa;\n                ab = ya * xb + yb * xa + yb * xb;\n                /* split, so now y = a */\n                tmp = aa * HEX_40000000;\n                ya = aa + tmp - tmp;\n                yb = aa - ya + ab;\n\n                return ya + yb;\n            }\n        }\n\n        // lnm is a log of a number in the range of 1.0 - 2.0, so 0 <= lnm < ln(2)\n        final double[] lnm = lnMant.LN_MANT[(int)((bits & 0x000ffc0000000000L) >> 42)];\n\n        /*\n    double epsilon = x / Double.longBitsToDouble(bits & 0xfffffc0000000000L);\n\n    epsilon -= 1.0;\n         */\n\n        // y is the most significant 10 bits of the mantissa\n        //double y = Double.longBitsToDouble(bits & 0xfffffc0000000000L);\n        //double epsilon = (x - y) / y;\n        final double epsilon = (bits & 0x3ffffffffffL) / (TWO_POWER_52 + (bits & 0x000ffc0000000000L));\n\n        double lnza = 0.0;\n        double lnzb = 0.0;\n\n        if (hiPrec != null) {\n            /* split epsilon -> x */\n            double tmp = epsilon * HEX_40000000;\n            double aa = epsilon + tmp - tmp;\n            double ab = epsilon - aa;\n            double xa = aa;\n            double xb = ab;\n\n            /* Need a more accurate epsilon, so adjust the division. */\n            final double numer = bits & 0x3ffffffffffL;\n            final double denom = TWO_POWER_52 + (bits & 0x000ffc0000000000L);\n            aa = numer - xa*denom - xb * denom;\n            xb += aa / denom;\n\n            /* Remez polynomial evaluation */\n            final double[] lnCoef_last = LN_HI_PREC_COEF[LN_HI_PREC_COEF.length-1];\n            double ya = lnCoef_last[0];\n            double yb = lnCoef_last[1];\n\n            for (int i = LN_HI_PREC_COEF.length - 2; i >= 0; i--) {\n                /* Multiply a = y * x */\n                aa = ya * xa;\n                ab = ya * xb + yb * xa + yb * xb;\n                /* split, so now y = a */\n                tmp = aa * HEX_40000000;\n                ya = aa + tmp - tmp;\n                yb = aa - ya + ab;\n\n                /* Add  a = y + lnHiPrecCoef */\n                final double[] lnCoef_i = LN_HI_PREC_COEF[i];\n                aa = ya + lnCoef_i[0];\n                ab = yb + lnCoef_i[1];\n                /* Split y = a */\n                tmp = aa * HEX_40000000;\n                ya = aa + tmp - tmp;\n                yb = aa - ya + ab;\n            }\n\n            /* Multiply a = y * x */\n            aa = ya * xa;\n            ab = ya * xb + yb * xa + yb * xb;\n\n            /* split, so now lnz = a */\n            /*\n      tmp = aa * 1073741824.0;\n      lnza = aa + tmp - tmp;\n      lnzb = aa - lnza + ab;\n             */\n            lnza = aa + ab;\n            lnzb = -(lnza - aa - ab);\n        } else {\n            /* High precision not required.  Eval Remez polynomial\n         using standard double precision */\n            lnza = -0.16624882440418567;\n            lnza = lnza * epsilon + 0.19999954120254515;\n            lnza = lnza * epsilon + -0.2499999997677497;\n            lnza = lnza * epsilon + 0.3333333333332802;\n            lnza = lnza * epsilon + -0.5;\n            lnza = lnza * epsilon + 1.0;\n            lnza = lnza * epsilon;\n        }\n\n        /* Relative sizes:\n         * lnzb     [0, 2.33E-10]\n         * lnm[1]   [0, 1.17E-7]\n         * ln2B*exp [0, 1.12E-4]\n         * lnza      [0, 9.7E-4]\n         * lnm[0]   [0, 0.692]\n         * ln2A*exp [0, 709]\n         */\n\n        /* Compute the following sum:\n         * lnzb + lnm[1] + ln2B*exp + lnza + lnm[0] + ln2A*exp;\n         */\n\n        //return lnzb + lnm[1] + ln2B*exp + lnza + lnm[0] + ln2A*exp;\n        double a = LN_2_A*exp;\n        double b = 0.0;\n        double c = a+lnm[0];\n        double d = -(c-a-lnm[0]);\n        a = c;\n        b = b + d;\n\n        c = a + lnza;\n        d = -(c - a - lnza);\n        a = c;\n        b = b + d;\n\n        c = a + LN_2_B*exp;\n        d = -(c - a - LN_2_B*exp);\n        a = c;\n        b = b + d;\n\n        c = a + lnm[1];\n        d = -(c - a - lnm[1]);\n        a = c;\n        b = b + d;\n\n        c = a + lnzb;\n        d = -(c - a - lnzb);\n        a = c;\n        b = b + d;\n\n        if (hiPrec != null) {\n            hiPrec[0] = a;\n            hiPrec[1] = b;\n        }\n\n        return a + b;\n    }",
    "comment": " Internal helper method for natural logarithm function. @param x original argument of the natural logarithm function @param hiPrec extra bits of precision on output (To Be Confirmed) @return log(x) ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 3
  },
  {
    "name": "FastMath.max",
    "class_name": "org.apache.commons.math3.util.FastMath",
    "signature": "org.apache.commons.math3.util.FastMath.max(double,double)",
    "snippet": "    public static double max(final double a, final double b) {\n        if (a > b) {\n            return a;\n        }\n        if (a < b) {\n            return b;\n        }\n        /* if either arg is NaN, return NaN */\n        if (a != b) {\n            return Double.NaN;\n        }\n        /* min(+0.0,-0.0) == -0.0 */\n        /* 0x8000000000000000L == Double.doubleToRawLongBits(-0.0d) */\n        long bits = Double.doubleToRawLongBits(a);\n        if (bits == 0x8000000000000000L) {\n            return b;\n        }\n        return a;\n    }",
    "comment": "Compute the maximum of two values @param a first value @param b second value @return b if a is lesser or equal to b, a otherwise ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 3
  },
  {
    "name": "FastMath.max",
    "class_name": "org.apache.commons.math3.util.FastMath",
    "signature": "org.apache.commons.math3.util.FastMath.max(int,int)",
    "snippet": "    public static int max(final int a, final int b) {\n        return (a <= b) ? b : a;\n    }",
    "comment": "Compute the maximum of two values @param a first value @param b second value @return b if a is lesser or equal to b, a otherwise ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 3
  },
  {
    "name": "FastMath.min",
    "class_name": "org.apache.commons.math3.util.FastMath",
    "signature": "org.apache.commons.math3.util.FastMath.min(int,int)",
    "snippet": "    public static int min(final int a, final int b) {\n        return (a <= b) ? a : b;\n    }",
    "comment": "Compute the minimum of two values @param a first value @param b second value @return a if a is lesser or equal to b, b otherwise ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 3
  },
  {
    "name": "FastMath.polyCosine",
    "class_name": "org.apache.commons.math3.util.FastMath",
    "signature": "org.apache.commons.math3.util.FastMath.polyCosine(double)",
    "snippet": "    private static double polyCosine(double x) {\n        double x2 = x*x;\n\n        double p = 2.479773539153719E-5;\n        p = p * x2 + -0.0013888888689039883;\n        p = p * x2 + 0.041666666666621166;\n        p = p * x2 + -0.49999999999999994;\n        p *= x2;\n\n        return p;\n    }",
    "comment": " Computes cos(x) - 1, where |x| < 1/16. Use a Remez polynomial approximation. @param x a number smaller than 1/16 @return cos(x) - 1 ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 3
  },
  {
    "name": "FastMath.polySine",
    "class_name": "org.apache.commons.math3.util.FastMath",
    "signature": "org.apache.commons.math3.util.FastMath.polySine(double)",
    "snippet": "    private static double polySine(final double x)\n    {\n        double x2 = x*x;\n\n        double p = 2.7553817452272217E-6;\n        p = p * x2 + -1.9841269659586505E-4;\n        p = p * x2 + 0.008333333333329196;\n        p = p * x2 + -0.16666666666666666;\n        //p *= x2;\n        //p *= x;\n        p = p * x2 * x;\n\n        return p;\n    }",
    "comment": " Computes sin(x) - x, where |x| < 1/16. Use a Remez polynomial approximation. @param x a number smaller than 1/16 @return sin(x) - x ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 3
  },
  {
    "name": "FastMath.sin",
    "class_name": "org.apache.commons.math3.util.FastMath",
    "signature": "org.apache.commons.math3.util.FastMath.sin(double)",
    "snippet": "    public static double sin(double x) {\n        boolean negative = false;\n        int quadrant = 0;\n        double xa;\n        double xb = 0.0;\n\n        /* Take absolute value of the input */\n        xa = x;\n        if (x < 0) {\n            negative = true;\n            xa = -xa;\n        }\n\n        /* Check for zero and negative zero */\n        if (xa == 0.0) {\n            long bits = Double.doubleToLongBits(x);\n            if (bits < 0) {\n                return -0.0;\n            }\n            return 0.0;\n        }\n\n        if (xa != xa || xa == Double.POSITIVE_INFINITY) {\n            return Double.NaN;\n        }\n\n        /* Perform any argument reduction */\n        if (xa > 3294198.0) {\n            // PI * (2**20)\n            // Argument too big for CodyWaite reduction.  Must use\n            // PayneHanek.\n            double reduceResults[] = new double[3];\n            reducePayneHanek(xa, reduceResults);\n            quadrant = ((int) reduceResults[0]) & 3;\n            xa = reduceResults[1];\n            xb = reduceResults[2];\n        } else if (xa > 1.5707963267948966) {\n            final CodyWaite cw = new CodyWaite(xa, xb);\n            quadrant = cw.getK() & 3;\n            xa = cw.getRemA();\n            xb = cw.getRemB();\n        }\n\n        if (negative) {\n            quadrant ^= 2;  // Flip bit 1\n        }\n\n        switch (quadrant) {\n            case 0:\n                return sinQ(xa, xb);\n            case 1:\n                return cosQ(xa, xb);\n            case 2:\n                return -sinQ(xa, xb);\n            case 3:\n                return -cosQ(xa, xb);\n            default:\n                return Double.NaN;\n        }\n    }",
    "comment": " Sine function.  @param x Argument. @return sin(x) ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 3
  },
  {
    "name": "FastMath.sinQ",
    "class_name": "org.apache.commons.math3.util.FastMath",
    "signature": "org.apache.commons.math3.util.FastMath.sinQ(double,double)",
    "snippet": "    private static double sinQ(double xa, double xb) {\n        int idx = (int) ((xa * 8.0) + 0.5);\n        final double epsilon = xa - EIGHTHS[idx]; //idx*0.125;\n\n        // Table lookups\n        final double sintA = SINE_TABLE_A[idx];\n        final double sintB = SINE_TABLE_B[idx];\n        final double costA = COSINE_TABLE_A[idx];\n        final double costB = COSINE_TABLE_B[idx];\n\n        // Polynomial eval of sin(epsilon), cos(epsilon)\n        double sinEpsA = epsilon;\n        double sinEpsB = polySine(epsilon);\n        final double cosEpsA = 1.0;\n        final double cosEpsB = polyCosine(epsilon);\n\n        // Split epsilon   xa + xb = x\n        final double temp = sinEpsA * HEX_40000000;\n        double temp2 = (sinEpsA + temp) - temp;\n        sinEpsB +=  sinEpsA - temp2;\n        sinEpsA = temp2;\n\n        /* Compute sin(x) by angle addition formula */\n        double result;\n\n        /* Compute the following sum:\n         *\n         * result = sintA + costA*sinEpsA + sintA*cosEpsB + costA*sinEpsB +\n         *          sintB + costB*sinEpsA + sintB*cosEpsB + costB*sinEpsB;\n         *\n         * Ranges of elements\n         *\n         * xxxtA   0            PI/2\n         * xxxtB   -1.5e-9      1.5e-9\n         * sinEpsA -0.0625      0.0625\n         * sinEpsB -6e-11       6e-11\n         * cosEpsA  1.0\n         * cosEpsB  0           -0.0625\n         *\n         */\n\n        //result = sintA + costA*sinEpsA + sintA*cosEpsB + costA*sinEpsB +\n        //          sintB + costB*sinEpsA + sintB*cosEpsB + costB*sinEpsB;\n\n        //result = sintA + sintA*cosEpsB + sintB + sintB * cosEpsB;\n        //result += costA*sinEpsA + costA*sinEpsB + costB*sinEpsA + costB * sinEpsB;\n        double a = 0;\n        double b = 0;\n\n        double t = sintA;\n        double c = a + t;\n        double d = -(c - a - t);\n        a = c;\n        b = b + d;\n\n        t = costA * sinEpsA;\n        c = a + t;\n        d = -(c - a - t);\n        a = c;\n        b = b + d;\n\n        b = b + sintA * cosEpsB + costA * sinEpsB;\n        /*\n    t = sintA*cosEpsB;\n    c = a + t;\n    d = -(c - a - t);\n    a = c;\n    b = b + d;\n\n    t = costA*sinEpsB;\n    c = a + t;\n    d = -(c - a - t);\n    a = c;\n    b = b + d;\n         */\n\n        b = b + sintB + costB * sinEpsA + sintB * cosEpsB + costB * sinEpsB;\n        /*\n    t = sintB;\n    c = a + t;\n    d = -(c - a - t);\n    a = c;\n    b = b + d;\n\n    t = costB*sinEpsA;\n    c = a + t;\n    d = -(c - a - t);\n    a = c;\n    b = b + d;\n\n    t = sintB*cosEpsB;\n    c = a + t;\n    d = -(c - a - t);\n    a = c;\n    b = b + d;\n\n    t = costB*sinEpsB;\n    c = a + t;\n    d = -(c - a - t);\n    a = c;\n    b = b + d;\n         */\n\n        if (xb != 0.0) {\n            t = ((costA + costB) * (cosEpsA + cosEpsB) -\n                 (sintA + sintB) * (sinEpsA + sinEpsB)) * xb;  // approximate cosine*xb\n            c = a + t;\n            d = -(c - a - t);\n            a = c;\n            b = b + d;\n        }\n\n        result = a + b;\n\n        return result;\n    }",
    "comment": " Compute sine over the first quadrant (0 < x < pi/2). Use combination of table lookup and rational polynomial expansion. @param xa number from which sine is requested @param xb extra bits for x (may be 0.0) @return sin(xa + xb) ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 3
  },
  {
    "name": "FastMath.sqrt",
    "class_name": "org.apache.commons.math3.util.FastMath",
    "signature": "org.apache.commons.math3.util.FastMath.sqrt(double)",
    "snippet": "    public static double sqrt(final double a) {\n        return Math.sqrt(a);\n    }",
    "comment": "Compute the square root of a number. <p><b>Note:</b> this implementation currently delegates to {@link Math#sqrt} @param a number on which evaluation is done @return square root of a ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 3
  },
  {
    "name": "CodyWaite.getK",
    "class_name": "org.apache.commons.math3.util.FastMath$CodyWaite",
    "signature": "org.apache.commons.math3.util.FastMath$CodyWaite.getK()",
    "snippet": "        int getK() {\n            return finalK;\n        }",
    "comment": " @return k ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 3
  },
  {
    "name": "CodyWaite.getRemA",
    "class_name": "org.apache.commons.math3.util.FastMath$CodyWaite",
    "signature": "org.apache.commons.math3.util.FastMath$CodyWaite.getRemA()",
    "snippet": "        double getRemA() {\n            return finalRemA;\n        }",
    "comment": " @return remA ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 3
  },
  {
    "name": "CodyWaite.getRemB",
    "class_name": "org.apache.commons.math3.util.FastMath$CodyWaite",
    "signature": "org.apache.commons.math3.util.FastMath$CodyWaite.getRemB()",
    "snippet": "        double getRemB() {\n            return finalRemB;\n        }",
    "comment": " @return remB ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 3
  },
  {
    "name": "FastMathLiteralArrays.loadLnMant",
    "class_name": "org.apache.commons.math3.util.FastMathLiteralArrays",
    "signature": "org.apache.commons.math3.util.FastMathLiteralArrays.loadLnMant()",
    "snippet": "    static double[][] loadLnMant() {\n        return LN_MANT.clone();\n    }",
    "comment": " Load \"LN_MANT\".  @return a clone of the data array. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 3
  },
  {
    "name": "Incrementor.Incrementor",
    "class_name": "org.apache.commons.math3.util.Incrementor",
    "signature": "org.apache.commons.math3.util.Incrementor.Incrementor()",
    "snippet": "    public Incrementor() {\n        this(0);\n    }",
    "comment": " Default constructor. For the new instance to be useful, the maximal count must be set by calling {@link #setMaximalCount(int) setMaximalCount}. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 3
  },
  {
    "name": "Incrementor.Incrementor",
    "class_name": "org.apache.commons.math3.util.Incrementor",
    "signature": "org.apache.commons.math3.util.Incrementor.Incrementor(int)",
    "snippet": "    public Incrementor(int max) {\n        this(max,\n             new MaxCountExceededCallback() {\n                 /** {@inheritDoc} */\n                 public void trigger(int max) {\n                     throw new MaxCountExceededException(max);\n                 }\n             });\n    }",
    "comment": " Defines a maximal count.  @param max Maximal count. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 3
  },
  {
    "name": "Incrementor.Incrementor",
    "class_name": "org.apache.commons.math3.util.Incrementor",
    "signature": "org.apache.commons.math3.util.Incrementor.Incrementor(int,MaxCountExceededCallback)",
    "snippet": "    public Incrementor(int max,\n                       MaxCountExceededCallback cb) {\n        if (cb == null){\n            throw new NullArgumentException();\n        }\n        maximalCount = max;\n        maxCountCallback = cb;\n    }",
    "comment": " Defines a maximal count and a callback method to be triggered at counter exhaustion.  @param max Maximal count. @param cb Function to be called when the maximal count has been reached. @throws NullArgumentException if {@code cb} is {@code null} ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 3
  },
  {
    "name": "Incrementor.getMaximalCount",
    "class_name": "org.apache.commons.math3.util.Incrementor",
    "signature": "org.apache.commons.math3.util.Incrementor.getMaximalCount()",
    "snippet": "    public int getMaximalCount() {\n        return maximalCount;\n    }",
    "comment": " Gets the upper limit of the counter.  @return the counter upper limit. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 3
  },
  {
    "name": "Incrementor.incrementCount",
    "class_name": "org.apache.commons.math3.util.Incrementor",
    "signature": "org.apache.commons.math3.util.Incrementor.incrementCount()",
    "snippet": "    public void incrementCount() {\n        if (++count > maximalCount) {\n            maxCountCallback.trigger(maximalCount);\n        }\n    }",
    "comment": " Adds one to the current iteration count. At counter exhaustion, this method will call the {@link MaxCountExceededCallback#trigger(int) trigger} method of the callback object passed to the {@link #Incrementor(int,MaxCountExceededCallback) constructor}. If not explictly set, a default callback is used that will throw a {@code MaxCountExceededException}.  @throws MaxCountExceededException at counter exhaustion, unless a custom {@link MaxCountExceededCallback callback} has been set at construction. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 3
  },
  {
    "name": "Incrementor.resetCount",
    "class_name": "org.apache.commons.math3.util.Incrementor",
    "signature": "org.apache.commons.math3.util.Incrementor.resetCount()",
    "snippet": "    public void resetCount() {\n        count = 0;\n    }",
    "comment": " Resets the counter to 0. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 3
  },
  {
    "name": "Incrementor.setMaximalCount",
    "class_name": "org.apache.commons.math3.util.Incrementor",
    "signature": "org.apache.commons.math3.util.Incrementor.setMaximalCount(int)",
    "snippet": "    public void setMaximalCount(int max) {\n        maximalCount = max;\n    }",
    "comment": " Sets the upper limit for the counter. This does not automatically reset the current count to zero (see {@link #resetCount()}).  @param max Upper limit of the counter. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 3
  },
  {
    "name": "MathArrays.copyOf",
    "class_name": "org.apache.commons.math3.util.MathArrays",
    "signature": "org.apache.commons.math3.util.MathArrays.copyOf(int[],int)",
    "snippet": "    public static int[] copyOf(int[] source, int len) {\n         final int[] output = new int[len];\n         System.arraycopy(source, 0, output, 0, FastMath.min(len, source.length));\n         return output;\n     }",
    "comment": " Creates a copy of the {@code source} array.  @param source Array to be copied. @param len Number of entries to copy. If smaller then the source length, the copy will be truncated, if larger it will padded with zeroes. @return the copied array. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 3
  },
  {
    "name": "MathUtils.checkNotNull",
    "class_name": "org.apache.commons.math3.util.MathUtils",
    "signature": "org.apache.commons.math3.util.MathUtils.checkNotNull(Object)",
    "snippet": "    public static void checkNotNull(Object o)\n        throws NullArgumentException {\n        if (o == null) {\n            throw new NullArgumentException();\n        }\n    }",
    "comment": " Checks that an object is not null.  @param o Object to be checked. @throws NullArgumentException if {@code o} is {@code null}. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 3
  },
  {
    "name": "Pair.Pair",
    "class_name": "org.apache.commons.math3.util.Pair",
    "signature": "org.apache.commons.math3.util.Pair.Pair(K,V)",
    "snippet": "    public Pair(K k, V v) {\n        key = k;\n        value = v;\n    }",
    "comment": " Create an entry representing a mapping from the specified key to the specified value.  @param k Key (first element of the pair). @param v Value (second element of the pair). ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 3
  },
  {
    "name": "Pair.getKey",
    "class_name": "org.apache.commons.math3.util.Pair",
    "signature": "org.apache.commons.math3.util.Pair.getKey()",
    "snippet": "    public K getKey() {\n        return key;\n    }",
    "comment": " Get the key.  @return the key (first element of the pair). ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 3
  },
  {
    "name": "Pair.getValue",
    "class_name": "org.apache.commons.math3.util.Pair",
    "signature": "org.apache.commons.math3.util.Pair.getValue()",
    "snippet": "    public V getValue() {\n        return value;\n    }",
    "comment": " Get the value.  @return the value (second element of the pair). ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 3
  },
  {
    "name": "Precision.compareTo",
    "class_name": "org.apache.commons.math3.util.Precision",
    "signature": "org.apache.commons.math3.util.Precision.compareTo(double,double,double)",
    "snippet": "    public static int compareTo(double x, double y, double eps) {\n        if (equals(x, y, eps)) {\n            return 0;\n        } else if (x < y) {\n            return -1;\n        }\n        return 1;\n    }",
    "comment": " Compares two numbers given some amount of allowed error.  @param x the first number @param y the second number @param eps the amount of error to allow when checking for equality @return <ul><li>0 if  {@link #equals(double, double, double) equals(x, y, eps)}</li> <li>&lt; 0 if !{@link #equals(double, double, double) equals(x, y, eps)} &amp;&amp; x &lt; y</li> <li>> 0 if !{@link #equals(double, double, double) equals(x, y, eps)} &amp;&amp; x > y</li></ul> ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 3
  },
  {
    "name": "Precision.equals",
    "class_name": "org.apache.commons.math3.util.Precision",
    "signature": "org.apache.commons.math3.util.Precision.equals(double,double,double)",
    "snippet": "    public static boolean equals(double x, double y, double eps) {\n        return equals(x, y, 1) || FastMath.abs(y - x) <= eps;\n    }",
    "comment": " Returns {@code true} if there is no double value strictly between the arguments or the difference between them is within the range of allowed error (inclusive).  @param x First value. @param y Second value. @param eps Amount of allowed absolute error. @return {@code true} if the values are two adjacent floating point numbers or they are within range of each other. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 3
  },
  {
    "name": "Precision.equals",
    "class_name": "org.apache.commons.math3.util.Precision",
    "signature": "org.apache.commons.math3.util.Precision.equals(double,double,int)",
    "snippet": "    public static boolean equals(double x, double y, int maxUlps) {\n        long xInt = Double.doubleToLongBits(x);\n        long yInt = Double.doubleToLongBits(y);\n\n        // Make lexicographically ordered as a two's-complement integer.\n        if (xInt < 0) {\n            xInt = SGN_MASK - xInt;\n        }\n        if (yInt < 0) {\n            yInt = SGN_MASK - yInt;\n        }\n\n        final boolean isEqual = FastMath.abs(xInt - yInt) <= maxUlps;\n\n        return isEqual && !Double.isNaN(x) && !Double.isNaN(y);\n    }",
    "comment": " Returns true if both arguments are equal or within the range of allowed error (inclusive). Two float numbers are considered equal if there are {@code (maxUlps - 1)} (or fewer) floating point numbers between them, i.e. two adjacent floating point numbers are considered equal. Adapted from <a href=\"http://www.cygnus-software.com/papers/comparingfloats/comparingfloats.htm\"> Bruce Dawson</a>  @param x first value @param y second value @param maxUlps {@code (maxUlps - 1)} is the number of floating point values between {@code x} and {@code y}. @return {@code true} if there are fewer than {@code maxUlps} floating point values between {@code x} and {@code y}. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 3
  }
]