[
  {
    "name": "Matchers.anyObject",
    "class_name": "org.mockito.Matchers",
    "signature": "org.mockito.Matchers.anyObject()",
    "snippet": "    public static <T> T anyObject() {\n        return (T) reportMatcher(Any.ANY).returnNull();\n    }",
    "comment": " any Object or null. <p> See examples in javadoc for {@link Matchers} class  @return <code>null</code>. ",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "Matchers.reportMatcher",
    "class_name": "org.mockito.Matchers",
    "signature": "org.mockito.Matchers.reportMatcher(Matcher)",
    "snippet": "    private static HandyReturnValues reportMatcher(Matcher<?> matcher) {\n        return mockingProgress.getArgumentMatcherStorage().reportMatcher(matcher);\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "Mockito.mock",
    "class_name": "org.mockito.Mockito",
    "signature": "org.mockito.Mockito.mock(Class)",
    "snippet": "    public static <T> T mock(Class<T> classToMock) {\n        return mock(classToMock, withSettings().defaultAnswer(RETURNS_DEFAULTS));\n    }",
    "comment": " Creates mock object of given class or interface. <p> See examples in javadoc for {@link Mockito} class  @param classToMock class or interface to mock @return mock object ",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "Mockito.mock",
    "class_name": "org.mockito.Mockito",
    "signature": "org.mockito.Mockito.mock(Class,MockSettings)",
    "snippet": "    public static <T> T mock(Class<T> classToMock, MockSettings mockSettings) {\n        return MOCKITO_CORE.mock(classToMock, mockSettings);\n    }",
    "comment": " Creates a mock with some non-standard settings. <p> The number of configuration points for a mock grows  so we need a fluent way to introduce new configuration without adding more and more overloaded Mockito.mock() methods.  Hence {@link MockSettings}. <pre> Listener mock = mock(Listener.class, withSettings() .name(\"firstListner\").defaultBehavior(RETURNS_SMART_NULLS)); );   </pre> <b>Use it carefully and occasionally</b>. What might be reason your test needs non-standard mocks?  Is the code under test so complicated that it requires non-standard mocks?  Wouldn't you prefer to refactor the code under test so it is testable in a simple way? <p> See also {@link Mockito#withSettings()} <p> See examples in javadoc for {@link Mockito} class  @param classToMock class or interface to mock @param mockSettings additional mock settings @return mock object ",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "Mockito.times",
    "class_name": "org.mockito.Mockito",
    "signature": "org.mockito.Mockito.times(int)",
    "snippet": "    public static VerificationMode times(int wantedNumberOfInvocations) {\n        return VerificationModeFactory.times(wantedNumberOfInvocations);\n    }",
    "comment": " Allows verifying exact number of invocations. E.g: <pre> verify(mock, times(2)).someMethod(\"some arg\"); </pre>  See examples in javadoc for {@link Mockito} class  @param wantedNumberOfInvocations wanted number of invocations   @return verification mode ",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "Mockito.verify",
    "class_name": "org.mockito.Mockito",
    "signature": "org.mockito.Mockito.verify(T)",
    "snippet": "    public static <T> T verify(T mock) {\n        return MOCKITO_CORE.verify(mock, times(1));\n    }",
    "comment": " Verifies certain behavior <b>happened once</b>  <p> Alias to <code>verify(mock, times(1))</code> E.g: <pre> verify(mock).someMethod(\"some arg\"); </pre> Above is equivalent to: <pre> verify(mock, times(1)).someMethod(\"some arg\"); </pre>  <p> Although it is possible to verify a stubbed invocation, usually <b>it's just redundant</b>. Let's say you've stubbed foo.bar().  If your code cares what foo.bar() returns then something else breaks(often before even verify() gets executed). If your code doesn't care what get(0) returns then it should not be stubbed.  Not convinced? See <a href=\"http://monkeyisland.pl/2008/04/26/asking-and-telling\">here</a>.  <p> See examples in javadoc for {@link Mockito} class  @param mock to be verified @return mock object itself ",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "Mockito.when",
    "class_name": "org.mockito.Mockito",
    "signature": "org.mockito.Mockito.when(T)",
    "snippet": "    public static <T> OngoingStubbing<T> when(T methodCall) {\n        return MOCKITO_CORE.when(methodCall);\n    }",
    "comment": " Enables stubbing methods. Use it when you want the mock to return particular value when particular method is called.  <p> Simply put: \"<b>When</b> the x method is called <b>then</b> return y\". <p> <b>when() is a successor of deprecated {@link Mockito#stub(Object)}</b> <p> Examples:  <pre> <b>when</b>(mock.someMethod()).<b>thenReturn</b>(10);  you can use flexible argument matchers, e.g: when(mock.someMethod(<b>anyString()</b>)).thenReturn(10);  setting exception to be thrown: when(mock.someMethod(\"some arg\")).thenThrow(new RuntimeException());  you can set different behavior for consecutive method calls. Last stubbing (e.g: thenReturn(\"foo\")) determines the behavior of further consecutive calls. when(mock.someMethod(\"some arg\")) .thenThrow(new RuntimeException()) .thenReturn(\"foo\");  Alternative, shorter version for consecutive stubbing: when(mock.someMethod(\"some arg\")) .thenReturn(\"one\", \"two\"); is the same as: when(mock.someMethod(\"some arg\")) .thenReturn(\"one\") .thenReturn(\"two\");  shorter version for consecutive method calls throwing exceptions: when(mock.someMethod(\"some arg\")) .thenThrow(new RuntimeException(), new NullPointerException();  </pre>  For stubbing void methods with throwables see: {@link Mockito#doThrow(Throwable)} <p> Stubbing can be overridden: for example common stubbing can go to fixture setup but the test methods can override it. <p> Once stubbed, the method will always return stubbed value regardless of how many times it is called. <p> Last stubbing is more important - when you stubbed the same method with the same arguments many times. <p> Although it is possible to verify a stubbed invocation, usually <b>it's just redundant</b>. Let's say you've stubbed foo.bar().  If your code cares what foo.bar() returns then something else breaks(often before even verify() gets executed). If your code doesn't care what get(0) returns then it should not be stubbed.  Not convinced? See <a href=\"http://monkeyisland.pl/2008/04/26/asking-and-telling\">here</a>.  <p> See examples in javadoc for {@link Mockito} class @param methodCall method to be stubbed ",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "Mockito.withSettings",
    "class_name": "org.mockito.Mockito",
    "signature": "org.mockito.Mockito.withSettings()",
    "snippet": "    public static MockSettings withSettings() {\n        return new MockSettingsImpl().defaultAnswer(RETURNS_DEFAULTS);\n    }",
    "comment": " Allows mock creation with additional mock settings.  <p> Don't use it too often.  Consider writing simple tests that use simple mocks.  Repeat after me: simple tests push simple, KISSy, readable & maintainable code. If you cannot write a test in a simple way - refactor the code under test. <p> Examples of mock settings: <pre> Creates mock with different default answer & name Foo mock = mock(Foo.class, withSettings() .defaultAnswer(RETURNS_SMART_NULLS) .name(\"cool mockie\"));  Creates mock with different default answer, descriptive name and extra interfaces Foo mock = mock(Foo.class, withSettings() .defaultAnswer(RETURNS_SMART_NULLS) .name(\"cool mockie\") .extraInterfaces(Bar.class));     </pre> {@link MockSettings} has been introduced for two reasons.  Firstly, to make it easy to add another mock settings when the demand comes. Secondly, to enable combining different mock settings without introducing zillions of overloaded mock() methods. <p> See javadoc for {@link MockSettings} to learn about possible mock settings. <p>  @return mock settings instance with defaults. ",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "MockitoAnnotations.initMocks",
    "class_name": "org.mockito.MockitoAnnotations",
    "signature": "org.mockito.MockitoAnnotations.initMocks(Object)",
    "snippet": "    public static void initMocks(Object testClass) {\n        if (testClass == null) {\n            throw new MockitoException(\"testClass cannot be null. For info how to use @Mock annotations see examples in javadoc for MockitoAnnotations class\");\n        }\n        \n        Class<?> clazz = testClass.getClass();\n        while (clazz != Object.class) {\n            scan(testClass, clazz);\n            clazz = clazz.getSuperclass();\n        }\n    }",
    "comment": " Initializes objects annotated with &#064;Mock for given testClass. <p> See examples in javadoc for {@link MockitoAnnotations} class. ",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "MockitoAnnotations.scan",
    "class_name": "org.mockito.MockitoAnnotations",
    "signature": "org.mockito.MockitoAnnotations.scan(Object,Class)",
    "snippet": "    private static void scan(Object testClass, Class<?> clazz) {\n        AnnotationEngine annotationEngine = new GlobalConfiguration().getAnnotationEngine();\n        Field[] fields = clazz.getDeclaredFields();\n        for (Field field : fields) {\n            for(Annotation annotation : field.getAnnotations()) {\n                Object mock = annotationEngine.createMockFor(annotation, field);\n                if (mock != null) {\n                    boolean wasAccessible = field.isAccessible();\n                    field.setAccessible(true);\n                    try {\n                        field.set(testClass, mock);\n                    } catch (IllegalAccessException e) {\n                        throw new MockitoException(\"Problems initiating mocks annotated with \" + annotation, e);\n                    } finally {\n                        field.setAccessible(wasAccessible);\n                    }    \n                }\n            }\n        }\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "MockHandler.MockHandler",
    "class_name": "org.mockito.internal.MockHandler",
    "signature": "org.mockito.internal.MockHandler.MockHandler(MockName,MockingProgress,MatchersBinder,MockSettingsImpl)",
    "snippet": "    public MockHandler(MockName mockName, MockingProgress mockingProgress, MatchersBinder matchersBinder, MockSettingsImpl mockSettings) {\n        this.mockName = mockName;\n        this.mockingProgress = mockingProgress;\n        this.matchersBinder = matchersBinder;\n        this.mockSettings = mockSettings;\n        this.mockitoStubber = new MockitoStubber(mockingProgress);\n        this.registeredInvocations = new RegisteredInvocations();\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "MockHandler.intercept",
    "class_name": "org.mockito.internal.MockHandler",
    "signature": "org.mockito.internal.MockHandler.intercept(Object,Method,Object[],MethodProxy)",
    "snippet": "    public Object intercept(Object proxy, Method method, Object[] args, MethodProxy methodProxy) throws Throwable {\n        if (mockitoStubber.hasAnswersForStubbing()) {\n            //stubbing voids with stubVoid() or doAnswer() style\n            Invocation invocation = new Invocation(proxy, method, args, SequenceNumber.next(), new FilteredCGLIBProxyRealMethod(methodProxy));\n            InvocationMatcher invocationMatcher = matchersBinder.bindMatchers(mockingProgress.getArgumentMatcherStorage(), invocation);\n            mockitoStubber.setMethodForStubbing(invocationMatcher);\n            return null;\n        }\n        VerificationMode verificationMode = mockingProgress.pullVerificationMode();\n\n        Invocation invocation = new Invocation(proxy, method, args, SequenceNumber.next(), new FilteredCGLIBProxyRealMethod(methodProxy));\n        InvocationMatcher invocationMatcher = matchersBinder.bindMatchers(mockingProgress.getArgumentMatcherStorage(), invocation);\n        \n        mockingProgress.validateState();\n\n        if (verificationMode != null) {\n            VerificationDataImpl data = new VerificationDataImpl(registeredInvocations.getAll(), invocationMatcher);\n            verificationMode.verify(data);\n            return null;\n        }\n\n        registeredInvocations.add(invocationMatcher.getInvocation());\n        mockitoStubber.setInvocationForPotentialStubbing(invocationMatcher);\n        OngoingStubbingImpl<T> ongoingStubbing = new OngoingStubbingImpl<T>(mockitoStubber, registeredInvocations);\n        mockingProgress.reportOngoingStubbing(ongoingStubbing);\n\n        Answer<?> stubbedAnswer = mockitoStubber.findAnswerFor(invocation);\n        if (!invocation.isVoid() && stubbedAnswer == null) {\n            //it is a return-value interaction but not stubbed. This *might* be a problem\n            mockingProgress.getDebuggingInfo().addPotentiallyUnstubbed(invocationMatcher);\n        }\n        \n        if (stubbedAnswer != null) {\n            mockingProgress.getDebuggingInfo().reportUsedStub(invocationMatcher);\n            return stubbedAnswer.answer(invocation);\n        } else {\n            Object ret = mockSettings.getDefaultAnswer().answer(invocation);\n            \n            //redo setting invocation for potential stubbing in case of partial mocks / spies.\n            //Without it, the real method inside 'when' might have delegated \n            //to other self method and overwrite the intended stubbed method with a different one.\n            mockitoStubber.setInvocationForPotentialStubbing(invocationMatcher);\n            return ret;\n        }\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "MockitoCore.mock",
    "class_name": "org.mockito.internal.MockitoCore",
    "signature": "org.mockito.internal.MockitoCore.mock(Class,MockSettings)",
    "snippet": "    public <T> T mock(Class<T> classToMock, MockSettings mockSettings) {\n        mockingProgress.validateState();\n        mockingProgress.resetOngoingStubbing();\n        return mockUtil.createMock(classToMock, mockingProgress, (MockSettingsImpl) mockSettings);\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "MockitoCore.stub",
    "class_name": "org.mockito.internal.MockitoCore",
    "signature": "org.mockito.internal.MockitoCore.stub()",
    "snippet": "    public IOngoingStubbing stub() {\n        IOngoingStubbing stubbing = mockingProgress.pullOngoingStubbing();\n        if (stubbing == null) {\n            mockingProgress.reset();\n            reporter.missingMethodInvocation();\n        }\n        return stubbing;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "MockitoCore.verify",
    "class_name": "org.mockito.internal.MockitoCore",
    "signature": "org.mockito.internal.MockitoCore.verify(T,VerificationMode)",
    "snippet": "    public <T> T verify(T mock, VerificationMode mode) {\n        if (mock == null) {\n            reporter.nullPassedToVerify();\n        } else if (!mockUtil.isMock(mock)) {\n            reporter.notAMockPassedToVerify();\n        }\n        mockingProgress.verificationStarted(mode);\n        return mock;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "MockitoCore.when",
    "class_name": "org.mockito.internal.MockitoCore",
    "signature": "org.mockito.internal.MockitoCore.when(T)",
    "snippet": "    public <T> OngoingStubbing<T> when(T methodCall) {\n        mockingProgress.stubbingStarted();\n        return (OngoingStubbing) stub();\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "ClassPathLoader.loadConfiguration",
    "class_name": "org.mockito.internal.configuration.ClassPathLoader",
    "signature": "org.mockito.internal.configuration.ClassPathLoader.loadConfiguration()",
    "snippet": "    @SuppressWarnings({\"unchecked\"})\n    public IMockitoConfiguration loadConfiguration() {\n        //Trying to get config from classpath\n        Class configClass = null;\n        try {\n            configClass = (Class) Class.forName(\"org.mockito.configuration.MockitoConfiguration\");\n        } catch (ClassNotFoundException e) {\n            //that's ok, it means there is no global config, using default one. \n            return null;\n        }\n        \n        try {\n            return (IMockitoConfiguration) configClass.newInstance();\n        } catch (ClassCastException e) {\n            throw new MockitoConfigurationException(\"\\n\" +\n                    \"MockitoConfiguration class must implement org.mockito.configuration.IMockitoConfiguration interface.\", e);\n        } catch (Exception e) {\n            throw new MockitoConfigurationException(\"\\n\" +\n                    \"Unable to instantianate org.mockito.configuration.MockitoConfiguration class. Does it have a safe, no-arg constructor?\", e);\n        }\n    }",
    "comment": " @return configuration loaded from classpath or null ",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "GlobalConfiguration.GlobalConfiguration",
    "class_name": "org.mockito.internal.configuration.GlobalConfiguration",
    "signature": "org.mockito.internal.configuration.GlobalConfiguration.GlobalConfiguration()",
    "snippet": "    public GlobalConfiguration() {\n        //Configuration should be loaded only once but I cannot really test it\n        if (globalConfiguration.get() == null) {\n            globalConfiguration.set(createConfig());\n        }\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "GlobalConfiguration.createConfig",
    "class_name": "org.mockito.internal.configuration.GlobalConfiguration",
    "signature": "org.mockito.internal.configuration.GlobalConfiguration.createConfig()",
    "snippet": "    @SuppressWarnings(\"deprecation\")\n    private IMockitoConfiguration createConfig() {\n        IMockitoConfiguration defaultConfiguration = new DefaultMockitoConfiguration();\n        IMockitoConfiguration config = new ClassPathLoader().loadConfiguration();\n        if (config != null) {\n            return config;\n        } else {\n            return defaultConfiguration;\n        }\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "GlobalConfiguration.getAnnotationEngine",
    "class_name": "org.mockito.internal.configuration.GlobalConfiguration",
    "signature": "org.mockito.internal.configuration.GlobalConfiguration.getAnnotationEngine()",
    "snippet": "    public AnnotationEngine getAnnotationEngine() {\n        return globalConfiguration.get().getAnnotationEngine();\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "GlobalConfiguration.getIt",
    "class_name": "org.mockito.internal.configuration.GlobalConfiguration",
    "signature": "org.mockito.internal.configuration.GlobalConfiguration.getIt()",
    "snippet": "    IMockitoConfiguration getIt() {\n        return globalConfiguration.get();\n    }",
    "comment": "back door for testing",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "GlobalConfiguration.validate",
    "class_name": "org.mockito.internal.configuration.GlobalConfiguration",
    "signature": "org.mockito.internal.configuration.GlobalConfiguration.validate()",
    "snippet": "    public static void validate() {\n        new GlobalConfiguration();\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "MethodInterceptorFilter.intercept",
    "class_name": "org.mockito.internal.creation.MethodInterceptorFilter",
    "signature": "org.mockito.internal.creation.MethodInterceptorFilter.intercept(Object,Method,Object[],MethodProxy)",
    "snippet": "    public Object intercept(Object proxy, Method method, Object[] args, MethodProxy methodProxy)\n            throws Throwable {\n        if (equalsMethod.equals(method)) {\n            return Boolean.valueOf(proxy == args[0]);\n        } else if (hashCodeMethod.equals(method)) {\n            return hashCodeForMock(proxy);\n        }\n        \n        new CGLIBHacker().setMockitoNamingPolicy(methodProxy);\n        \n        return delegate.intercept(proxy, method, args, methodProxy);\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "MockSettingsImpl.defaultAnswer",
    "class_name": "org.mockito.internal.creation.MockSettingsImpl",
    "signature": "org.mockito.internal.creation.MockSettingsImpl.defaultAnswer(Answer)",
    "snippet": "    @SuppressWarnings(\"unchecked\")\n    public MockSettings defaultAnswer(Answer defaultAnswer) {\n        this.defaultAnswer = defaultAnswer;\n        return this;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "MockSettingsImpl.getDefaultAnswer",
    "class_name": "org.mockito.internal.creation.MockSettingsImpl",
    "signature": "org.mockito.internal.creation.MockSettingsImpl.getDefaultAnswer()",
    "snippet": "    public Answer<Object> getDefaultAnswer() {\n        return defaultAnswer;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "MockSettingsImpl.getExtraInterfaces",
    "class_name": "org.mockito.internal.creation.MockSettingsImpl",
    "signature": "org.mockito.internal.creation.MockSettingsImpl.getExtraInterfaces()",
    "snippet": "    public Class<?>[] getExtraInterfaces() {\n        return extraInterfaces;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "MockSettingsImpl.getMockName",
    "class_name": "org.mockito.internal.creation.MockSettingsImpl",
    "signature": "org.mockito.internal.creation.MockSettingsImpl.getMockName()",
    "snippet": "    public String getMockName() {\n        return name;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "MockSettingsImpl.getSpiedInstance",
    "class_name": "org.mockito.internal.creation.MockSettingsImpl",
    "signature": "org.mockito.internal.creation.MockSettingsImpl.getSpiedInstance()",
    "snippet": "    public Object getSpiedInstance() {\n        return spiedInstance;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "CGLIBHacker.reflectOnCreateInfo",
    "class_name": "org.mockito.internal.creation.cglib.CGLIBHacker",
    "signature": "org.mockito.internal.creation.cglib.CGLIBHacker.reflectOnCreateInfo(MethodProxy)",
    "snippet": "    @SuppressWarnings(\"unchecked\")\n    private Field reflectOnCreateInfo(MethodProxy methodProxy) throws NoSuchFieldException {\n        Class cglibMethodProxyClass = methodProxy.getClass();\n        //in case methodProxy was extended by user, let's traverse the object graph to find the cglib methodProxy \n        //with all the fields we would like to change \n        while (cglibMethodProxyClass != MethodProxy.class) {\n            cglibMethodProxyClass = methodProxy.getClass().getSuperclass();\n        }\n        return cglibMethodProxyClass.getDeclaredField(\"createInfo\");\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "CGLIBHacker.setMockitoNamingPolicy",
    "class_name": "org.mockito.internal.creation.cglib.CGLIBHacker",
    "signature": "org.mockito.internal.creation.cglib.CGLIBHacker.setMockitoNamingPolicy(MethodProxy)",
    "snippet": "    public void setMockitoNamingPolicy(MethodProxy methodProxy) {\n        try {\n            Field createInfoField = reflectOnCreateInfo(methodProxy);\n            createInfoField.setAccessible(true);\n            Object createInfo = createInfoField.get(methodProxy);\n            Field namingPolicyField = createInfo.getClass().getDeclaredField(\"namingPolicy\");\n            namingPolicyField.setAccessible(true);\n            if (namingPolicyField.get(createInfo) == null) {\n                namingPolicyField.set(createInfo, MockitoNamingPolicy.INSTANCE);\n            }\n        } catch (Exception e) {\n            throw new RuntimeException(\"Unable to set MockitoNamingPolicy on cglib generator which creates FastClasses\", e);\n        }\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "MockitoNamingPolicy.getTag",
    "class_name": "org.mockito.internal.creation.cglib.MockitoNamingPolicy",
    "signature": "org.mockito.internal.creation.cglib.MockitoNamingPolicy.getTag()",
    "snippet": "    @Override\n    protected String getTag() {\n        return \"ByMockitoWithCGLIB\";\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "ClassImposterizer.canImposterise",
    "class_name": "org.mockito.internal.creation.jmock.ClassImposterizer",
    "signature": "org.mockito.internal.creation.jmock.ClassImposterizer.canImposterise(Class)",
    "snippet": "    public boolean canImposterise(Class<?> type) {\n        return !type.isPrimitive() && !Modifier.isFinal(type.getModifiers()) && !type.isAnonymousClass();\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "ClassImposterizer.createProxy",
    "class_name": "org.mockito.internal.creation.jmock.ClassImposterizer",
    "signature": "org.mockito.internal.creation.jmock.ClassImposterizer.createProxy(Class,MethodInterceptor)",
    "snippet": "    private Object createProxy(Class<?> proxyClass, final MethodInterceptor interceptor) {\n        Factory proxy = (Factory) objenesis.newInstance(proxyClass);\n        proxy.setCallbacks(new Callback[] {interceptor, NoOp.INSTANCE});\n        return proxy;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "ClassImposterizer.setConstructorsAccessible",
    "class_name": "org.mockito.internal.creation.jmock.ClassImposterizer",
    "signature": "org.mockito.internal.creation.jmock.ClassImposterizer.setConstructorsAccessible(Class,boolean)",
    "snippet": "    private void setConstructorsAccessible(Class<?> mockedType, boolean accessible) {\n        for (Constructor<?> constructor : mockedType.getDeclaredConstructors()) {\n            constructor.setAccessible(accessible);\n        }\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "SearchingClassLoader.addIfNewElement",
    "class_name": "org.mockito.internal.creation.jmock.SearchingClassLoader",
    "signature": "org.mockito.internal.creation.jmock.SearchingClassLoader.addIfNewElement(List,ClassLoader)",
    "snippet": "    private static void addIfNewElement(List<ClassLoader> loaders, ClassLoader c) {\n        if (c != null && !loaders.contains(c)) {\n            loaders.add(c);\n        }\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "SearchingClassLoader.combine",
    "class_name": "org.mockito.internal.creation.jmock.SearchingClassLoader",
    "signature": "org.mockito.internal.creation.jmock.SearchingClassLoader.combine(List)",
    "snippet": "    private static ClassLoader combine(List<ClassLoader> parentLoaders) {\n        ClassLoader loader = parentLoaders.get(parentLoaders.size()-1);\n        \n        for (int i = parentLoaders.size()-2; i >= 0; i--) {\n            loader = new SearchingClassLoader(parentLoaders.get(i), loader);\n        }\n        \n        return loader;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "Localized.Localized",
    "class_name": "org.mockito.internal.debugging.Localized",
    "signature": "org.mockito.internal.debugging.Localized.Localized(T)",
    "snippet": "    public Localized(T object) {\n        this.object = object;\n        location = new Location();\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "Localized.getObject",
    "class_name": "org.mockito.internal.debugging.Localized",
    "signature": "org.mockito.internal.debugging.Localized.getObject()",
    "snippet": "    public T getObject() {\n        return object;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "Location.Location",
    "class_name": "org.mockito.internal.debugging.Location",
    "signature": "org.mockito.internal.debugging.Location.Location()",
    "snippet": "    public Location() {\n        StackTraceElement[] stackTrace = Thread.currentThread().getStackTrace();\n        StackTraceFilter filter = new StackTraceFilter();\n        this.firstTraceElement = filter.filter(stackTrace, false)[0];\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "StackTraceFilter.filter",
    "class_name": "org.mockito.internal.exceptions.base.StackTraceFilter",
    "signature": "org.mockito.internal.exceptions.base.StackTraceFilter.filter(StackTraceElement[],boolean)",
    "snippet": "    public StackTraceElement[] filter(StackTraceElement[] target, boolean keepTop) {\n        //TODO: after 1.8 profile\n        List<StackTraceElement> unfilteredStackTrace = Arrays.asList(target);\n        \n        int lastBad = -1;\n        int firstBad = -1;\n        for (int i = 0; i < unfilteredStackTrace.size(); i++) {\n            if (!this.isBad(unfilteredStackTrace.get(i))) {\n                continue;\n            }\n            lastBad = i;\n            if (firstBad == -1) {\n                firstBad = i;\n            }\n        }\n        \n        List<StackTraceElement> top;\n        if (keepTop && firstBad != -1) {\n            top = unfilteredStackTrace.subList(0, firstBad);\n        } else {\n            top = new LinkedList<StackTraceElement>();\n        }\n        \n        List<StackTraceElement> bottom = unfilteredStackTrace.subList(lastBad + 1, unfilteredStackTrace.size());\n        List<StackTraceElement> filtered = new ArrayList<StackTraceElement>(top);\n        filtered.addAll(bottom);\n        return filtered.toArray(new StackTraceElement[]{});\n    }",
    "comment": " Example how the filter works (+/- means good/bad): [a+, b+, c-, d+, e+, f-, g+] -> [a+, b+, g+] Basically removes all bad from the middle. If any good are in the middle of bad those are also removed.  ",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "StackTraceFilter.isBad",
    "class_name": "org.mockito.internal.exceptions.base.StackTraceFilter",
    "signature": "org.mockito.internal.exceptions.base.StackTraceFilter.isBad(StackTraceElement)",
    "snippet": "    public boolean isBad(StackTraceElement e) {\n        boolean fromMockObject = e.getClassName().contains(\"$$EnhancerByMockitoWithCGLIB$$\");\n        boolean fromOrgMockito = e.getClassName().startsWith(\"org.mockito.\");\n        boolean isRunner = e.getClassName().startsWith(\"org.mockito.runners.\");\n        boolean isInternalRunner = e.getClassName().startsWith(\"org.mockito.internal.runners.\");\n        return (fromMockObject || fromOrgMockito) && !isRunner && !isInternalRunner;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "Invocation.Invocation",
    "class_name": "org.mockito.internal.invocation.Invocation",
    "signature": "org.mockito.internal.invocation.Invocation.Invocation(Object,Method,Object[],int,RealMethod)",
    "snippet": "    public Invocation(Object mock, Method method, Object[] args, int sequenceNumber, RealMethod realMethod) {\n        this.mock = mock;\n        this.method = method;\n        this.realMethod = realMethod;\n        this.arguments = expandVarArgs(method.isVarArgs(), args);\n        this.rawArguments = args;\n        this.sequenceNumber = sequenceNumber;\n        this.location = new Location();\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "Invocation.argumentsToMatchers",
    "class_name": "org.mockito.internal.invocation.Invocation",
    "signature": "org.mockito.internal.invocation.Invocation.argumentsToMatchers()",
    "snippet": "    protected List<Matcher> argumentsToMatchers() {\n        List<Matcher> matchers = new ArrayList<Matcher>(arguments.length);\n        for (Object arg : arguments) {\n            if (arg != null && arg.getClass().isArray()) {\n                matchers.add(new ArrayEquals(arg));\n            } else {\n                matchers.add(new Equals(arg));\n            }\n        }\n        return matchers;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "Invocation.expandVarArgs",
    "class_name": "org.mockito.internal.invocation.Invocation",
    "signature": "org.mockito.internal.invocation.Invocation.expandVarArgs(boolean,Object[])",
    "snippet": "    private static Object[] expandVarArgs(final boolean isVarArgs, final Object[] args) {\n        if (!isVarArgs || isVarArgs && args[args.length - 1] != null && !args[args.length - 1].getClass().isArray()) {\n            return args == null ? new Object[0] : args;\n        }\n\n        final int nonVarArgsCount = args.length - 1;\n        Object[] varArgs;\n        if (args[nonVarArgsCount] == null) {\n            // in case someone deliberately passed null varArg array\n            varArgs = new Object[] { null };\n        } else {\n            varArgs = ArrayEquals.createObjectArray(args[nonVarArgsCount]);\n        }\n        final int varArgsCount = varArgs.length;\n        Object[] newArgs = new Object[nonVarArgsCount + varArgsCount];\n        System.arraycopy(args, 0, newArgs, 0, nonVarArgsCount);\n        System.arraycopy(varArgs, 0, newArgs, nonVarArgsCount, varArgsCount);\n        return newArgs;\n    }",
    "comment": "varArgs (1, a, b);",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "Invocation.getArguments",
    "class_name": "org.mockito.internal.invocation.Invocation",
    "signature": "org.mockito.internal.invocation.Invocation.getArguments()",
    "snippet": "    public Object[] getArguments() {\n        return arguments;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "Invocation.getArgumentsCount",
    "class_name": "org.mockito.internal.invocation.Invocation",
    "signature": "org.mockito.internal.invocation.Invocation.getArgumentsCount()",
    "snippet": "    public int getArgumentsCount() {\n        return arguments.length;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "Invocation.getMethod",
    "class_name": "org.mockito.internal.invocation.Invocation",
    "signature": "org.mockito.internal.invocation.Invocation.getMethod()",
    "snippet": "    public Method getMethod() {\n        return method;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "Invocation.getMock",
    "class_name": "org.mockito.internal.invocation.Invocation",
    "signature": "org.mockito.internal.invocation.Invocation.getMock()",
    "snippet": "    public Object getMock() {\n        return mock;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "Invocation.isToString",
    "class_name": "org.mockito.internal.invocation.Invocation",
    "signature": "org.mockito.internal.invocation.Invocation.isToString(InvocationOnMock)",
    "snippet": "    public static boolean isToString(InvocationOnMock invocation) {\n        return isToString(invocation.getMethod());\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "Invocation.isToString",
    "class_name": "org.mockito.internal.invocation.Invocation",
    "signature": "org.mockito.internal.invocation.Invocation.isToString(Method)",
    "snippet": "    public static boolean isToString(Method method) {\n        return method.getReturnType() == String.class && method.getParameterTypes().length == 0\n                && method.getName().equals(\"toString\");\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "Invocation.isValidReturnType",
    "class_name": "org.mockito.internal.invocation.Invocation",
    "signature": "org.mockito.internal.invocation.Invocation.isValidReturnType(Class)",
    "snippet": "    public boolean isValidReturnType(Class clazz) {\n        if (method.getReturnType().isPrimitive()) {\n            return Primitives.primitiveTypeOf(clazz) == method.getReturnType();\n        } else {\n            return method.getReturnType().isAssignableFrom(clazz);\n        }\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "Invocation.isVerified",
    "class_name": "org.mockito.internal.invocation.Invocation",
    "signature": "org.mockito.internal.invocation.Invocation.isVerified()",
    "snippet": "    public boolean isVerified() {\n        return verified;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "Invocation.isVoid",
    "class_name": "org.mockito.internal.invocation.Invocation",
    "signature": "org.mockito.internal.invocation.Invocation.isVoid()",
    "snippet": "    public boolean isVoid() {\n        return this.method.getReturnType() == Void.TYPE;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "InvocationMatcher.InvocationMatcher",
    "class_name": "org.mockito.internal.invocation.InvocationMatcher",
    "signature": "org.mockito.internal.invocation.InvocationMatcher.InvocationMatcher(Invocation,List)",
    "snippet": "    public InvocationMatcher(Invocation invocation, List<Matcher> matchers) {\n        this.invocation = invocation;\n        if (matchers.isEmpty()) {\n            this.matchers = invocation.argumentsToMatchers();\n        } else {\n            this.matchers = matchers;\n        }\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "InvocationMatcher.argumentsMatch",
    "class_name": "org.mockito.internal.invocation.InvocationMatcher",
    "signature": "org.mockito.internal.invocation.InvocationMatcher.argumentsMatch(Object[])",
    "snippet": "    private boolean argumentsMatch(Object[] actualArgs) {\n        if (actualArgs.length != matchers.size()) {\n            return false;\n        }\n        for (int i = 0; i < actualArgs.length; i++) {\n            if (!matchers.get(i).matches(actualArgs[i])) {\n                return false;\n            }\n        }\n        return true;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "InvocationMatcher.getInvocation",
    "class_name": "org.mockito.internal.invocation.InvocationMatcher",
    "signature": "org.mockito.internal.invocation.InvocationMatcher.getInvocation()",
    "snippet": "    public Invocation getInvocation() {\n        return this.invocation;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "InvocationMatcher.getMatchers",
    "class_name": "org.mockito.internal.invocation.InvocationMatcher",
    "signature": "org.mockito.internal.invocation.InvocationMatcher.getMatchers()",
    "snippet": "    public List<Matcher> getMatchers() {\n        return this.matchers;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "InvocationMatcher.getMethod",
    "class_name": "org.mockito.internal.invocation.InvocationMatcher",
    "signature": "org.mockito.internal.invocation.InvocationMatcher.getMethod()",
    "snippet": "    public Method getMethod() {\n        return invocation.getMethod();\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "InvocationMatcher.hasSameMethod",
    "class_name": "org.mockito.internal.invocation.InvocationMatcher",
    "signature": "org.mockito.internal.invocation.InvocationMatcher.hasSameMethod(Invocation)",
    "snippet": "    public boolean hasSameMethod(Invocation candidate) {\n        return invocation.getMethod().equals(candidate.getMethod());\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "InvocationMatcher.hasSimilarMethod",
    "class_name": "org.mockito.internal.invocation.InvocationMatcher",
    "signature": "org.mockito.internal.invocation.InvocationMatcher.hasSimilarMethod(Invocation)",
    "snippet": "    public boolean hasSimilarMethod(Invocation candidate) {\n        String wantedMethodName = getMethod().getName();\n        String currentMethodName = candidate.getMethod().getName();\n        \n        final boolean methodNameEquals = wantedMethodName.equals(currentMethodName);\n        final boolean isUnverified = !candidate.isVerified();\n        final boolean mockIsTheSame = getInvocation().getMock() == candidate.getMock();\n        final boolean methodEquals = hasSameMethod(candidate);\n        final boolean overloadedButSameArgs = !methodEquals && safelyArgumentsMatch(candidate.getArguments());        \n        \n        if (methodNameEquals && isUnverified && mockIsTheSame && !overloadedButSameArgs) {\n            return true;\n        }\n        \n        return false;\n    }",
    "comment": " similar means the same method name, same mock, unverified  and: if arguments are the same cannot be overloaded ",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "InvocationMatcher.matches",
    "class_name": "org.mockito.internal.invocation.InvocationMatcher",
    "signature": "org.mockito.internal.invocation.InvocationMatcher.matches(Invocation)",
    "snippet": "    public boolean matches(Invocation actual) {\n        return invocation.getMock().equals(actual.getMock())\n                && hasSameMethod(actual)\n                && (argumentsMatch(actual.getArguments()));\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "InvocationsFinder.findInvocations",
    "class_name": "org.mockito.internal.invocation.InvocationsFinder",
    "signature": "org.mockito.internal.invocation.InvocationsFinder.findInvocations(List,InvocationMatcher)",
    "snippet": "    public List<Invocation> findInvocations(List<Invocation> invocations, InvocationMatcher wanted) {\n        return ListUtil.filter(invocations, new RemoveNotMatching(wanted));\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "InvocationsFinder.findSimilarInvocation",
    "class_name": "org.mockito.internal.invocation.InvocationsFinder",
    "signature": "org.mockito.internal.invocation.InvocationsFinder.findSimilarInvocation(List,InvocationMatcher)",
    "snippet": "    public Invocation findSimilarInvocation(List<Invocation> invocations, InvocationMatcher wanted) {\n        Invocation firstSimilar = null;\n        for (Invocation invocation : invocations) {\n            if (!wanted.hasSimilarMethod(invocation)) {\n                continue;\n            }\n            if (firstSimilar == null) {\n                firstSimilar = invocation;\n            }\n            if (wanted.hasSameMethod(invocation)) {\n                return invocation;\n            }\n        }\n        \n        return firstSimilar;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "RemoveNotMatching.isOut",
    "class_name": "org.mockito.internal.invocation.InvocationsFinder$RemoveNotMatching",
    "signature": "org.mockito.internal.invocation.InvocationsFinder$RemoveNotMatching.isOut(Invocation)",
    "snippet": "        public boolean isOut(Invocation invocation) {\n            return !wanted.matches(invocation);\n        }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "MatchersBinder.bindMatchers",
    "class_name": "org.mockito.internal.invocation.MatchersBinder",
    "signature": "org.mockito.internal.invocation.MatchersBinder.bindMatchers(ArgumentMatcherStorage,Invocation)",
    "snippet": "    public InvocationMatcher bindMatchers(ArgumentMatcherStorage argumentMatcherStorage, Invocation invocation) {\n        List<Matcher> lastMatchers = argumentMatcherStorage.pullMatchers();\n        validateMatchers(invocation, lastMatchers);\n\n        InvocationMatcher invocationWithMatchers = new InvocationMatcher(invocation, lastMatchers);\n        return invocationWithMatchers;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "MatchersBinder.validateMatchers",
    "class_name": "org.mockito.internal.invocation.MatchersBinder",
    "signature": "org.mockito.internal.invocation.MatchersBinder.validateMatchers(Invocation,List)",
    "snippet": "    private void validateMatchers(Invocation invocation, List<Matcher> matchers) {\n        if (!matchers.isEmpty()) {\n            int recordedMatchersSize = matchers.size();\n            int expectedMatchersSize = invocation.getArgumentsCount();\n            if (expectedMatchersSize != recordedMatchersSize) {\n                new Reporter().invalidUseOfMatchers(expectedMatchersSize, recordedMatchersSize);\n            }\n        }\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "CGLIBProxyRealMethod.CGLIBProxyRealMethod",
    "class_name": "org.mockito.internal.invocation.realmethod.CGLIBProxyRealMethod",
    "signature": "org.mockito.internal.invocation.realmethod.CGLIBProxyRealMethod.CGLIBProxyRealMethod(MethodProxy)",
    "snippet": "    public CGLIBProxyRealMethod(MethodProxy methodProxy) {\n        this.methodProxy = methodProxy;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "FilteredCGLIBProxyRealMethod.FilteredCGLIBProxyRealMethod",
    "class_name": "org.mockito.internal.invocation.realmethod.FilteredCGLIBProxyRealMethod",
    "signature": "org.mockito.internal.invocation.realmethod.FilteredCGLIBProxyRealMethod.FilteredCGLIBProxyRealMethod(MethodProxy)",
    "snippet": "    public FilteredCGLIBProxyRealMethod(MethodProxy methodProxy) {\n        this(new CGLIBProxyRealMethod(methodProxy));\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "FilteredCGLIBProxyRealMethod.FilteredCGLIBProxyRealMethod",
    "class_name": "org.mockito.internal.invocation.realmethod.FilteredCGLIBProxyRealMethod",
    "signature": "org.mockito.internal.invocation.realmethod.FilteredCGLIBProxyRealMethod.FilteredCGLIBProxyRealMethod(RealMethod)",
    "snippet": "    public FilteredCGLIBProxyRealMethod(RealMethod realMethod) {\n        this.realMethod = realMethod;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "Any.matches",
    "class_name": "org.mockito.internal.matchers.Any",
    "signature": "org.mockito.internal.matchers.Any.matches(Object)",
    "snippet": "    public boolean matches(Object actual) {\n        return true;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "Equals.Equals",
    "class_name": "org.mockito.internal.matchers.Equals",
    "signature": "org.mockito.internal.matchers.Equals.Equals(Object)",
    "snippet": "    public Equals(Object wanted) {\n        this.wanted = wanted;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "Equals.describe",
    "class_name": "org.mockito.internal.matchers.Equals",
    "signature": "org.mockito.internal.matchers.Equals.describe(Object)",
    "snippet": "    public String describe(Object object) {\n        String text = quoting();\n        if (object == null) {\n            text+=\"null\";\n        } else {\n            text+=object.toString();\n        }\n        text+= quoting();\n        return text;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "Equals.describeTo",
    "class_name": "org.mockito.internal.matchers.Equals",
    "signature": "org.mockito.internal.matchers.Equals.describeTo(Description)",
    "snippet": "    public void describeTo(Description description) {\n        description.appendText(describe(wanted));\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "Equals.matches",
    "class_name": "org.mockito.internal.matchers.Equals",
    "signature": "org.mockito.internal.matchers.Equals.matches(Object)",
    "snippet": "    public boolean matches(Object actual) {\n        if (this.wanted == null) {\n            return actual == null;\n        }\n        return wanted.equals(actual);\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "Equals.quoting",
    "class_name": "org.mockito.internal.matchers.Equals",
    "signature": "org.mockito.internal.matchers.Equals.quoting()",
    "snippet": "    private String quoting() {\n        if (wanted instanceof String) {\n            return \"\\\"\";\n        } else if (wanted instanceof Character) {\n            return \"'\";\n        } else {\n            return \"\";\n        }\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "LocalizedMatcher.LocalizedMatcher",
    "class_name": "org.mockito.internal.matchers.LocalizedMatcher",
    "signature": "org.mockito.internal.matchers.LocalizedMatcher.LocalizedMatcher(Matcher)",
    "snippet": "    public LocalizedMatcher(Matcher actualMatcher) {\n        this.actualMatcher = actualMatcher;\n        this.location = new Location();\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "LocalizedMatcher.matches",
    "class_name": "org.mockito.internal.matchers.LocalizedMatcher",
    "signature": "org.mockito.internal.matchers.LocalizedMatcher.matches(Object)",
    "snippet": "    public boolean matches(Object item) {\n        return actualMatcher.matches(item);\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "ArgumentMatcherStorageImpl.validateState",
    "class_name": "org.mockito.internal.progress.ArgumentMatcherStorageImpl",
    "signature": "org.mockito.internal.progress.ArgumentMatcherStorageImpl.validateState()",
    "snippet": "    public void validateState() {\n        if (!matcherStack.isEmpty()) {\n            LocalizedMatcher lastMatcher = matcherStack.lastElement();\n            matcherStack.clear();\n            new Reporter().misplacedArgumentMatcher(lastMatcher.getLocation());\n        }\n    }",
    "comment": "(non-Javadoc) @see org.mockito.internal.progress.ArgumentMatcherStorage#validateState() ",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "HandyReturnValues.returnNull",
    "class_name": "org.mockito.internal.progress.HandyReturnValues",
    "signature": "org.mockito.internal.progress.HandyReturnValues.returnNull()",
    "snippet": "    public <T> T returnNull() {\n        return null;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "MockingProgressImpl.getArgumentMatcherStorage",
    "class_name": "org.mockito.internal.progress.MockingProgressImpl",
    "signature": "org.mockito.internal.progress.MockingProgressImpl.getArgumentMatcherStorage()",
    "snippet": "    public ArgumentMatcherStorage getArgumentMatcherStorage() {\n        return argumentMatcherStorage;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "MockingProgressImpl.validateState",
    "class_name": "org.mockito.internal.progress.MockingProgressImpl",
    "signature": "org.mockito.internal.progress.MockingProgressImpl.validateState()",
    "snippet": "    public void validateState() {\n        //State is cool when GlobalConfiguration is already loaded\n        //this cannot really be tested functionally because I cannot dynamically mess up org.mockito.configuration.MockitoConfiguration class \n        GlobalConfiguration.validate();\n        \n        if (verificationMode != null) {\n            Location location = verificationMode.getLocation();\n            verificationMode = null;\n            reporter.unfinishedVerificationException(location);\n        }\n        \n        if (stubbingInProgress != null) {\n            Location temp = stubbingInProgress;\n            stubbingInProgress = null;\n            reporter.unfinishedStubbing(temp);\n        }\n      \n        getArgumentMatcherStorage().validateState();\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "SequenceNumber.next",
    "class_name": "org.mockito.internal.progress.SequenceNumber",
    "signature": "org.mockito.internal.progress.SequenceNumber.next()",
    "snippet": "    public static synchronized int next() {\n        return sequenceNumber++;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "ThreadSafeMockingProgress.threadSafely",
    "class_name": "org.mockito.internal.progress.ThreadSafeMockingProgress",
    "signature": "org.mockito.internal.progress.ThreadSafeMockingProgress.threadSafely()",
    "snippet": "    static MockingProgress threadSafely() {\n        if (mockingProgress.get() == null) {\n            mockingProgress.set(new MockingProgressImpl());\n        }\n        return mockingProgress.get();\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "ThreadSafeMockingProgress.validateState",
    "class_name": "org.mockito.internal.progress.ThreadSafeMockingProgress",
    "signature": "org.mockito.internal.progress.ThreadSafeMockingProgress.validateState()",
    "snippet": "    public void validateState() {\n        threadSafely().validateState();\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "BaseStubbing.thenReturn",
    "class_name": "org.mockito.internal.stubbing.BaseStubbing",
    "signature": "org.mockito.internal.stubbing.BaseStubbing.thenReturn(T)",
    "snippet": "    public OngoingStubbing<T> thenReturn(T value) {\n        return thenAnswer(new Returns(value));\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "ConsecutiveStubbing.ConsecutiveStubbing",
    "class_name": "org.mockito.internal.stubbing.ConsecutiveStubbing",
    "signature": "org.mockito.internal.stubbing.ConsecutiveStubbing.ConsecutiveStubbing(MockitoStubber)",
    "snippet": "    public ConsecutiveStubbing(MockitoStubber mockitoStubber) {\n        this.mockitoStubber = mockitoStubber;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "MockitoStubber.MockitoStubber",
    "class_name": "org.mockito.internal.stubbing.MockitoStubber",
    "signature": "org.mockito.internal.stubbing.MockitoStubber.MockitoStubber(MockingProgress)",
    "snippet": "    public MockitoStubber(MockingProgress mockingProgress) {\n        this.mockingProgress = mockingProgress;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "MockitoStubber.addAnswer",
    "class_name": "org.mockito.internal.stubbing.MockitoStubber",
    "signature": "org.mockito.internal.stubbing.MockitoStubber.addAnswer(Answer)",
    "snippet": "    public void addAnswer(Answer answer) {\n        addAnswer(answer, false);\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "MockitoStubber.addAnswer",
    "class_name": "org.mockito.internal.stubbing.MockitoStubber",
    "signature": "org.mockito.internal.stubbing.MockitoStubber.addAnswer(Answer,boolean)",
    "snippet": "    private void addAnswer(Answer answer, boolean isConsecutive) {\n        Invocation invocation = invocationForStubbing.getInvocation();\n        mockingProgress.stubbingCompleted(invocation);\n        AnswersValidator answersValidator = new AnswersValidator();\n        answersValidator.validate(answer, invocation);\n        \n        if (isConsecutive) {\n            stubbed.getFirst().addAnswer(answer);\n        } else {\n            stubbed.addFirst(new StubbedInvocationMatcher(invocationForStubbing, answer));\n        }\n    } ",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "MockitoStubber.findAnswerFor",
    "class_name": "org.mockito.internal.stubbing.MockitoStubber",
    "signature": "org.mockito.internal.stubbing.MockitoStubber.findAnswerFor(Invocation)",
    "snippet": "    public Answer<?> findAnswerFor(Invocation invocation) {\n        for (StubbedInvocationMatcher s : stubbed) {\n            if (s.matches(invocation)) {\n                return s;\n            }\n        }\n        \n        return null;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "MockitoStubber.hasAnswersForStubbing",
    "class_name": "org.mockito.internal.stubbing.MockitoStubber",
    "signature": "org.mockito.internal.stubbing.MockitoStubber.hasAnswersForStubbing()",
    "snippet": "    public boolean hasAnswersForStubbing() {\n        return !answersForStubbing.isEmpty();\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "MockitoStubber.setInvocationForPotentialStubbing",
    "class_name": "org.mockito.internal.stubbing.MockitoStubber",
    "signature": "org.mockito.internal.stubbing.MockitoStubber.setInvocationForPotentialStubbing(InvocationMatcher)",
    "snippet": "    public void setInvocationForPotentialStubbing(InvocationMatcher invocation) {\n        this.invocationForStubbing = invocation;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "OngoingStubbingImpl.OngoingStubbingImpl",
    "class_name": "org.mockito.internal.stubbing.OngoingStubbingImpl",
    "signature": "org.mockito.internal.stubbing.OngoingStubbingImpl.OngoingStubbingImpl(MockitoStubber,RegisteredInvocations)",
    "snippet": "    public OngoingStubbingImpl(MockitoStubber mockitoStubber,\n            RegisteredInvocations registeredInvocations) {\n        this.mockitoStubber = mockitoStubber;\n        this.registeredInvocations = registeredInvocations;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "OngoingStubbingImpl.thenAnswer",
    "class_name": "org.mockito.internal.stubbing.OngoingStubbingImpl",
    "signature": "org.mockito.internal.stubbing.OngoingStubbingImpl.thenAnswer(Answer)",
    "snippet": "    public OngoingStubbing<T> thenAnswer(Answer<?> answer) {\n        registeredInvocations.removeLast();\n        mockitoStubber.addAnswer(answer);\n        return new ConsecutiveStubbing<T>(mockitoStubber);\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "StubbedInvocationMatcher.StubbedInvocationMatcher",
    "class_name": "org.mockito.internal.stubbing.StubbedInvocationMatcher",
    "signature": "org.mockito.internal.stubbing.StubbedInvocationMatcher.StubbedInvocationMatcher(InvocationMatcher,Answer)",
    "snippet": "    public StubbedInvocationMatcher(InvocationMatcher invocation, Answer answer) {\n        super(invocation.getInvocation(), invocation.getMatchers());\n        this.answers.add(answer);\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "StubbedInvocationMatcher.answer",
    "class_name": "org.mockito.internal.stubbing.StubbedInvocationMatcher",
    "signature": "org.mockito.internal.stubbing.StubbedInvocationMatcher.answer(InvocationOnMock)",
    "snippet": "    public Object answer(InvocationOnMock invocation) throws Throwable {\n        //see ThreadsShareGenerouslyStubbedMockTest\n        synchronized(answers) {\n            return answers.size() == 1 ? answers.peek().answer(invocation) : answers.poll().answer(invocation);\n        }\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "AnswersValidator.validate",
    "class_name": "org.mockito.internal.stubbing.answers.AnswersValidator",
    "signature": "org.mockito.internal.stubbing.answers.AnswersValidator.validate(Answer,Invocation)",
    "snippet": "    public void validate(Answer<?> answer, Invocation invocation) {\n        if (answer instanceof ThrowsException) {\n            validateException((ThrowsException) answer, invocation);\n        }\n        \n        if (answer instanceof Returns) {\n            validateReturnValue((Returns) answer, invocation);\n        }\n        \n        if (answer instanceof DoesNothing) {\n            validateDoNothing((DoesNothing) answer, invocation);\n        }\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "AnswersValidator.validateReturnValue",
    "class_name": "org.mockito.internal.stubbing.answers.AnswersValidator",
    "signature": "org.mockito.internal.stubbing.answers.AnswersValidator.validateReturnValue(Returns,Invocation)",
    "snippet": "    private void validateReturnValue(Returns answer, Invocation invocation) {\n        if (invocation.isVoid()) {\n            reporter.cannotStubVoidMethodWithAReturnValue();\n        }\n        \n        if (answer.returnsNull() && invocation.returnsPrimitive()) {\n            reporter.wrongTypeOfReturnValue(invocation.printMethodReturnType(), \"null\", invocation.getMethodName());\n        } \n\n        if (!answer.returnsNull() && !invocation.isValidReturnType(answer.getReturnType())) {\n            reporter.wrongTypeOfReturnValue(invocation.printMethodReturnType(), answer.printReturnType(), invocation.getMethodName());\n        }\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "Returns.Returns",
    "class_name": "org.mockito.internal.stubbing.answers.Returns",
    "signature": "org.mockito.internal.stubbing.answers.Returns.Returns(Object)",
    "snippet": "    public Returns(Object value) {\n        this.value = value;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "Returns.answer",
    "class_name": "org.mockito.internal.stubbing.answers.Returns",
    "signature": "org.mockito.internal.stubbing.answers.Returns.answer(InvocationOnMock)",
    "snippet": "    public Object answer(InvocationOnMock invocation) throws Throwable {\n        return value;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "Returns.getReturnType",
    "class_name": "org.mockito.internal.stubbing.answers.Returns",
    "signature": "org.mockito.internal.stubbing.answers.Returns.getReturnType()",
    "snippet": "    public Class<?> getReturnType() {\n        return value.getClass();\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "Returns.returnsNull",
    "class_name": "org.mockito.internal.stubbing.answers.Returns",
    "signature": "org.mockito.internal.stubbing.answers.Returns.returnsNull()",
    "snippet": "    public boolean returnsNull() {\n        return value == null;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "GloballyConfiguredAnswer.answer",
    "class_name": "org.mockito.internal.stubbing.defaultanswers.GloballyConfiguredAnswer",
    "signature": "org.mockito.internal.stubbing.defaultanswers.GloballyConfiguredAnswer.answer(InvocationOnMock)",
    "snippet": "    public Object answer(InvocationOnMock invocation) throws Throwable {\n        return new GlobalConfiguration().getDefaultAnswer().answer(invocation);\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "ReturnsEmptyValues.answer",
    "class_name": "org.mockito.internal.stubbing.defaultanswers.ReturnsEmptyValues",
    "signature": "org.mockito.internal.stubbing.defaultanswers.ReturnsEmptyValues.answer(InvocationOnMock)",
    "snippet": "    public Object answer(InvocationOnMock invocation) {\n        if (Invocation.isToString(invocation)) {\n            Object mock = invocation.getMock();\n            MockName name = new MockUtil().getMockName(mock);\n            if (name.isSurrogate()) {\n                return \"Mock for \" + ClassNameFinder.classNameForMock(mock) + \", hashCode: \" + mock.hashCode();\n            } else {\n                return name.toString();\n            }\n        }\n        \n        Class<?> returnType = invocation.getMethod().getReturnType();\n        return returnValueFor(returnType);\n    }",
    "comment": "(non-Javadoc) @see org.mockito.stubbing.Answer#answer(org.mockito.invocation.InvocationOnMock) ",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "ReturnsEmptyValues.returnValueFor",
    "class_name": "org.mockito.internal.stubbing.defaultanswers.ReturnsEmptyValues",
    "signature": "org.mockito.internal.stubbing.defaultanswers.ReturnsEmptyValues.returnValueFor(Class)",
    "snippet": "    Object returnValueFor(Class<?> type) {\n        if (type.isPrimitive()) {\n            return primitiveOf(type);\n        } else if (Primitives.isPrimitiveWrapper(type)) {\n            return Primitives.primitiveWrapperOf(type);\n        //new instances are used instead of Collections.emptyList(), etc.\n        //to avoid UnsupportedOperationException if code under test modifies returned collection\n        } else if (type == Collection.class) {\n            return new LinkedList<Object>();\n        } else if (type == Set.class) {\n            return new HashSet<Object>();\n        } else if (type == HashSet.class) {\n            return new HashSet<Object>();\n        } else if (type == SortedSet.class) {\n            return new TreeSet<Object>();\n        } else if (type == TreeSet.class) {\n            return new TreeSet<Object>();\n        } else if (type == LinkedHashSet.class) {\n            return new LinkedHashSet<Object>();\n        } else if (type == List.class) {\n            return new LinkedList<Object>();\n        } else if (type == LinkedList.class) {\n            return new LinkedList<Object>();\n        } else if (type == ArrayList.class) {\n            return new ArrayList<Object>();\n        } else if (type == Map.class) {\n            return new HashMap<Object, Object>();\n        } else if (type == HashMap.class) {\n            return new HashMap<Object, Object>();\n        } else if (type == SortedMap.class) {\n            return new TreeMap<Object, Object>();\n        } else if (type == TreeMap.class) {\n            return new TreeMap<Object, Object>();\n        } else if (type == LinkedHashMap.class) {\n            return new LinkedHashMap<Object, Object>();\n        }       \n        //Let's not care about the rest of collections.\n        return null;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "CreationValidator.validateExtraInterfaces",
    "class_name": "org.mockito.internal.util.CreationValidator",
    "signature": "org.mockito.internal.util.CreationValidator.validateExtraInterfaces(Class,Class[])",
    "snippet": "    public void validateExtraInterfaces(Class classToMock, Class ... extraInterfaces) {\n        if (extraInterfaces == null) {\n            return;\n        }\n        \n        for (Class i : extraInterfaces) {\n            if (classToMock == i) {\n                new Reporter().extraInterfacesCannotContainMockedType(classToMock);\n            }\n        }\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "CreationValidator.validateType",
    "class_name": "org.mockito.internal.util.CreationValidator",
    "signature": "org.mockito.internal.util.CreationValidator.validateType(Class)",
    "snippet": "    public void validateType(Class classToMock) {\n        if (!ClassImposterizer.INSTANCE.canImposterise(classToMock)) {\n            new Reporter().cannotMockFinalClass(classToMock);\n        }\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "ListUtil.filter",
    "class_name": "org.mockito.internal.util.ListUtil",
    "signature": "org.mockito.internal.util.ListUtil.filter(Collection,Filter)",
    "snippet": "    public static <T> LinkedList<T> filter(Collection<T> collection, Filter<T> filter) {\n        LinkedList<T> filtered = new LinkedList<T>();\n        for (T t : collection) {\n            if (!filter.isOut(t)) {\n                filtered.add(t);\n            }\n        }\n        return filtered;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "MockName.MockName",
    "class_name": "org.mockito.internal.util.MockName",
    "signature": "org.mockito.internal.util.MockName.MockName(String,Class)",
    "snippet": "    @SuppressWarnings(\"unchecked\")\n    public MockName(String mockName, Class classToMock) {\n        if (mockName == null) {\n            this.mockName = toInstanceName(classToMock);\n            this.surrogate = true;\n        } else {\n            this.mockName = mockName;\n        }\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "MockName.toInstanceName",
    "class_name": "org.mockito.internal.util.MockName",
    "signature": "org.mockito.internal.util.MockName.toInstanceName(Class)",
    "snippet": "    private static String toInstanceName(Class<?> clazz) {\n        String className = clazz.getSimpleName();\n        //lower case first letter\n        return className.substring(0, 1).toLowerCase() + className.substring(1);\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "MockUtil.MockUtil",
    "class_name": "org.mockito.internal.util.MockUtil",
    "signature": "org.mockito.internal.util.MockUtil.MockUtil()",
    "snippet": "    public MockUtil() {\n        this(new CreationValidator());\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "MockUtil.MockUtil",
    "class_name": "org.mockito.internal.util.MockUtil",
    "signature": "org.mockito.internal.util.MockUtil.MockUtil(CreationValidator)",
    "snippet": "    public MockUtil(CreationValidator creationValidator) {\n        this.creationValidator = creationValidator;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "MockUtil.createMock",
    "class_name": "org.mockito.internal.util.MockUtil",
    "signature": "org.mockito.internal.util.MockUtil.createMock(Class,MockingProgress,MockSettingsImpl)",
    "snippet": "    public <T> T createMock(Class<T> classToMock, MockingProgress progress, MockSettingsImpl settings) {\n        creationValidator.validateType(classToMock);\n        creationValidator.validateExtraInterfaces(classToMock, settings.getExtraInterfaces());\n        \n        MockName mockName = new MockName(settings.getMockName(), classToMock);\n        MockHandler<T> mockHandler = new MockHandler<T>(mockName, progress, new MatchersBinder(), settings);\n        MethodInterceptorFilter<MockHandler<T>> filter = new MethodInterceptorFilter<MockHandler<T>>(classToMock, mockHandler);\n        Class<?>[] interfaces = settings.getExtraInterfaces();\n        Class<?>[] ancillaryTypes = interfaces == null ? new Class<?>[0] : interfaces;\n        Object spiedInstance = settings.getSpiedInstance();\n        \n        T mock = ClassImposterizer.INSTANCE.imposterise(filter, classToMock, ancillaryTypes);\n        \n        if (spiedInstance != null) {\n            new LenientCopyTool().copyToMock(spiedInstance, mock);\n        }\n        \n        return mock;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "MockUtil.getInterceptor",
    "class_name": "org.mockito.internal.util.MockUtil",
    "signature": "org.mockito.internal.util.MockUtil.getInterceptor(T)",
    "snippet": "    @SuppressWarnings(\"unchecked\")\n    private <T> MethodInterceptorFilter<MockHandler<T>> getInterceptor(T mock) {\n        Factory factory = (Factory) mock;\n        Callback callback = factory.getCallback(0);\n        if (callback instanceof MethodInterceptorFilter) {\n            return (MethodInterceptorFilter<MockHandler<T>>) callback;\n        }\n        return null;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "MockUtil.isMock",
    "class_name": "org.mockito.internal.util.MockUtil",
    "signature": "org.mockito.internal.util.MockUtil.isMock(Object)",
    "snippet": "    public boolean isMock(Object mock) {\n        return mock != null && isMockitoMock(mock);\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "MockUtil.isMockitoMock",
    "class_name": "org.mockito.internal.util.MockUtil",
    "signature": "org.mockito.internal.util.MockUtil.isMockitoMock(T)",
    "snippet": "    private <T> boolean isMockitoMock(T mock) {\n        return Enhancer.isEnhanced(mock.getClass()) && getInterceptor(mock) != null;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "Primitives.isPrimitiveWrapper",
    "class_name": "org.mockito.internal.util.Primitives",
    "signature": "org.mockito.internal.util.Primitives.isPrimitiveWrapper(Class)",
    "snippet": "    public static boolean isPrimitiveWrapper(Class<?> type) {\n        return wrapperReturnValues.containsKey(type);\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "RegisteredInvocations.add",
    "class_name": "org.mockito.internal.verification.RegisteredInvocations",
    "signature": "org.mockito.internal.verification.RegisteredInvocations.add(Invocation)",
    "snippet": "    public void add(Invocation invocation) {\n        invocations.add(invocation);\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "RegisteredInvocations.getAll",
    "class_name": "org.mockito.internal.verification.RegisteredInvocations",
    "signature": "org.mockito.internal.verification.RegisteredInvocations.getAll()",
    "snippet": "    public List<Invocation> getAll() {\n        return ListUtil.filter(new LinkedList<Invocation>(invocations), new RemoveToString());\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "RegisteredInvocations.removeLast",
    "class_name": "org.mockito.internal.verification.RegisteredInvocations",
    "signature": "org.mockito.internal.verification.RegisteredInvocations.removeLast()",
    "snippet": "    public void removeLast() {\n        invocations.remove(invocations.size()-1);\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "RemoveToString.isOut",
    "class_name": "org.mockito.internal.verification.RegisteredInvocations$RemoveToString",
    "signature": "org.mockito.internal.verification.RegisteredInvocations$RemoveToString.isOut(Invocation)",
    "snippet": "        public boolean isOut(Invocation invocation) {\n            return Invocation.isToString(invocation);\n        }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "Times.Times",
    "class_name": "org.mockito.internal.verification.Times",
    "signature": "org.mockito.internal.verification.Times.Times(int)",
    "snippet": "    public Times(int wantedNumberOfInvocations) {\n        if (wantedNumberOfInvocations < 0) {\n            throw new MockitoException(\"Negative value is not allowed here\");\n        }\n        this.wantedCount = wantedNumberOfInvocations;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "Times.verify",
    "class_name": "org.mockito.internal.verification.Times",
    "signature": "org.mockito.internal.verification.Times.verify(VerificationData)",
    "snippet": "    public void verify(VerificationData data) {\n        if (wantedCount > 0) {\n            MissingInvocationChecker missingInvocation = new MissingInvocationChecker();\n            missingInvocation.check(data.getAllInvocations(), data.getWanted());\n        }\n        NumberOfInvocationsChecker numberOfInvocations = new NumberOfInvocationsChecker();\n        numberOfInvocations.check(data.getAllInvocations(), data.getWanted(), wantedCount);\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "VerificationDataImpl.VerificationDataImpl",
    "class_name": "org.mockito.internal.verification.VerificationDataImpl",
    "signature": "org.mockito.internal.verification.VerificationDataImpl.VerificationDataImpl(List,InvocationMatcher)",
    "snippet": "    public VerificationDataImpl(List<Invocation> allInvocations, InvocationMatcher wanted) {\n        this.allInvocations = allInvocations;\n        this.wanted = wanted;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "VerificationDataImpl.getAllInvocations",
    "class_name": "org.mockito.internal.verification.VerificationDataImpl",
    "signature": "org.mockito.internal.verification.VerificationDataImpl.getAllInvocations()",
    "snippet": "    public List<Invocation> getAllInvocations() {\n        return allInvocations;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "VerificationDataImpl.getWanted",
    "class_name": "org.mockito.internal.verification.VerificationDataImpl",
    "signature": "org.mockito.internal.verification.VerificationDataImpl.getWanted()",
    "snippet": "    public InvocationMatcher getWanted() {\n        return wanted;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "VerificationModeFactory.times",
    "class_name": "org.mockito.internal.verification.VerificationModeFactory",
    "signature": "org.mockito.internal.verification.VerificationModeFactory.times(int)",
    "snippet": "    public static Times times(int wantedNumberOfInvocations) {\n        return new Times(wantedNumberOfInvocations);\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "ArgumentMatchingTool.getSuspiciouslyNotMatchingArgsIndexes",
    "class_name": "org.mockito.internal.verification.argumentmatching.ArgumentMatchingTool",
    "signature": "org.mockito.internal.verification.argumentmatching.ArgumentMatchingTool.getSuspiciouslyNotMatchingArgsIndexes(List,Object[])",
    "snippet": "    public Integer[] getSuspiciouslyNotMatchingArgsIndexes(List<Matcher> matchers, Object[] arguments) {\n        if (matchers.size() != arguments.length) {\n            return new Integer[0];\n        }\n        \n        List<Integer> suspicious = new LinkedList<Integer>();\n        int i = 0;\n        for (Matcher m : matchers) {\n            if (m instanceof ContainsExtraTypeInformation \n                    && !safelyMatches(m, arguments[i]) \n                    && toStringEquals(m, arguments[i])\n                    && !((ContainsExtraTypeInformation) m).typeMatches(arguments[i])) {\n                suspicious.add(i);\n            }\n            i++;\n        }\n        return suspicious.toArray(new Integer[0]);\n    }",
    "comment": " Suspiciously not matching arguments are those that don't much, the toString() representation is the same but types are different. ",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "ArgumentMatchingTool.safelyMatches",
    "class_name": "org.mockito.internal.verification.argumentmatching.ArgumentMatchingTool",
    "signature": "org.mockito.internal.verification.argumentmatching.ArgumentMatchingTool.safelyMatches(Matcher,Object)",
    "snippet": "    private boolean safelyMatches(Matcher m, Object arg) {\n        try {\n            return m.matches(arg);\n        } catch (Throwable t) {\n            return false;\n        }\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "ArgumentMatchingTool.toStringEquals",
    "class_name": "org.mockito.internal.verification.argumentmatching.ArgumentMatchingTool",
    "signature": "org.mockito.internal.verification.argumentmatching.ArgumentMatchingTool.toStringEquals(Matcher,Object)",
    "snippet": "    private boolean toStringEquals(Matcher m, Object arg) {\n        return StringDescription.toString(m).equals(arg.toString());\n    }",
    "comment": "",
    "is_bug": true,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "MissingInvocationChecker.MissingInvocationChecker",
    "class_name": "org.mockito.internal.verification.checkers.MissingInvocationChecker",
    "signature": "org.mockito.internal.verification.checkers.MissingInvocationChecker.MissingInvocationChecker()",
    "snippet": "    public MissingInvocationChecker() {\n        this(new InvocationsFinder(), new Reporter());\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "MissingInvocationChecker.MissingInvocationChecker",
    "class_name": "org.mockito.internal.verification.checkers.MissingInvocationChecker",
    "signature": "org.mockito.internal.verification.checkers.MissingInvocationChecker.MissingInvocationChecker(InvocationsFinder,Reporter)",
    "snippet": "    MissingInvocationChecker(InvocationsFinder finder, Reporter reporter) {\n        this.finder = finder;\n        this.reporter = reporter;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "MissingInvocationChecker.check",
    "class_name": "org.mockito.internal.verification.checkers.MissingInvocationChecker",
    "signature": "org.mockito.internal.verification.checkers.MissingInvocationChecker.check(List,InvocationMatcher)",
    "snippet": "    public void check(List<Invocation> invocations, InvocationMatcher wanted) {\n        List<Invocation> actualInvocations = finder.findInvocations(invocations, wanted);\n        \n        if (actualInvocations.isEmpty()) {\n            Invocation similar = finder.findSimilarInvocation(invocations, wanted);\n            if (similar != null) {\n                ArgumentMatchingTool argumentMatchingTool = new ArgumentMatchingTool();\n                Integer[] indexesOfSuspiciousArgs = argumentMatchingTool.getSuspiciouslyNotMatchingArgsIndexes(wanted.getMatchers(), similar.getArguments());\n                SmartPrinter smartPrinter = new SmartPrinter(wanted, similar, indexesOfSuspiciousArgs);\n                reporter.argumentsAreDifferent(smartPrinter.getWanted(), smartPrinter.getActual(), similar.getLocation());\n            } else {\n                reporter.wantedButNotInvoked(wanted, invocations);\n            }\n        }\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  }
]