[
  {
    "name": "AbstractCommandLineRunner.AbstractCommandLineRunner",
    "class_name": "com.google.javascript.jscomp.AbstractCommandLineRunner",
    "signature": "com.google.javascript.jscomp.AbstractCommandLineRunner.AbstractCommandLineRunner(PrintStream,PrintStream)",
    "snippet": "  AbstractCommandLineRunner(PrintStream out, PrintStream err) {\n    this.config = new CommandLineConfig();\n    this.jsOutput = Preconditions.checkNotNull(out);\n    this.err = Preconditions.checkNotNull(err);\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "AbstractCommandLineRunner.createDefineOrTweakReplacements",
    "class_name": "com.google.javascript.jscomp.AbstractCommandLineRunner",
    "signature": "com.google.javascript.jscomp.AbstractCommandLineRunner.createDefineOrTweakReplacements(List,CompilerOptions,boolean)",
    "snippet": "  @VisibleForTesting\n  static void createDefineOrTweakReplacements(List<String> definitions,\n      CompilerOptions options, boolean tweaks) {\n    // Parse the definitions\n    for (String override : definitions) {\n      String[] assignment = override.split(\"=\", 2);\n      String defName = assignment[0];\n\n      if (defName.length() > 0) {\n        String defValue = assignment.length == 1 ? \"true\" : assignment[1];\n\n        boolean isTrue = defValue.equals(\"true\");\n        boolean isFalse = defValue.equals(\"false\");\n        if (isTrue || isFalse) {\n          if (tweaks) {\n            options.setTweakToBooleanLiteral(defName, isTrue);\n          } else {\n            options.setDefineToBooleanLiteral(defName, isTrue);\n          }\n          continue;\n        } else if (defValue.length() > 1\n            && ((defValue.charAt(0) == '\\'' &&\n                defValue.charAt(defValue.length() - 1) == '\\'')\n                || (defValue.charAt(0) == '\\\"' &&\n                    defValue.charAt(defValue.length() - 1) == '\\\"'))) {\n          // If the value starts and ends with a single quote,\n          // we assume that it's a string.\n          String maybeStringVal =\n              defValue.substring(1, defValue.length() - 1);\n          if (maybeStringVal.indexOf(defValue.charAt(0)) == -1) {\n            if (tweaks) {\n              options.setTweakToStringLiteral(defName, maybeStringVal);\n            } else {\n              options.setDefineToStringLiteral(defName, maybeStringVal);\n            }\n            continue;\n          }\n        } else {\n          try {\n            double value = Double.parseDouble(defValue);\n            if (tweaks) {\n              options.setTweakToDoubleLiteral(defName, value);\n            } else {\n              options.setDefineToDoubleLiteral(defName, value);\n            }\n            continue;\n          } catch (NumberFormatException e) {\n            // do nothing, it will be caught at the end\n          }\n        }\n      }\n\n      if (tweaks) {\n        throw new RuntimeException(\n            \"--tweak flag syntax invalid: \" + override);\n      }\n      throw new RuntimeException(\n          \"--define flag syntax invalid: \" + override);\n    }\n  }",
    "comment": " Create a map of constant names to constant values from a textual description of the map.  @param definitions A list of overriding definitions for defines in the form <name>[=<val>], where <val> is a number, boolean, or single-quoted string without single quotes. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "AbstractCommandLineRunner.createExterns",
    "class_name": "com.google.javascript.jscomp.AbstractCommandLineRunner",
    "signature": "com.google.javascript.jscomp.AbstractCommandLineRunner.createExterns()",
    "snippet": "  protected List<JSSourceFile> createExterns() throws FlagUsageException,\n      IOException {\n    return isInTestMode() ? externsSupplierForTesting.get() :\n        createExternInputs(config.externs);\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "AbstractCommandLineRunner.createSourceInputs",
    "class_name": "com.google.javascript.jscomp.AbstractCommandLineRunner",
    "signature": "com.google.javascript.jscomp.AbstractCommandLineRunner.createSourceInputs(List)",
    "snippet": "  private List<JSSourceFile> createSourceInputs(List<String> files)\n      throws FlagUsageException, IOException {\n    if (isInTestMode()) {\n      return inputsSupplierForTesting.get();\n    }\n    if (files.isEmpty()) {\n      files = Collections.singletonList(\"-\");\n    }\n    try {\n      return createInputs(files, true);\n    } catch (FlagUsageException e) {\n      throw new FlagUsageException(\"Bad --js flag. \" + e.getMessage());\n    }\n  }",
    "comment": " Creates js source code inputs from a list of files. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "AbstractCommandLineRunner.doRun",
    "class_name": "com.google.javascript.jscomp.AbstractCommandLineRunner",
    "signature": "com.google.javascript.jscomp.AbstractCommandLineRunner.doRun()",
    "snippet": "  protected int doRun() throws FlagUsageException, IOException {\n    Compiler.setLoggingLevel(Level.parse(config.loggingLevel));\n\n    List<JSSourceFile> externs = createExterns();\n\n    compiler = createCompiler();\n    B options = createOptions();\n\n    List<JSModule> modules = null;\n    Result result = null;\n\n    setRunOptions(options);\n\n    boolean writeOutputToFile = !options.jsOutputFile.isEmpty();\n    if (writeOutputToFile) {\n      jsOutput = fileNameToOutputWriter(options.jsOutputFile);\n    } else if (jsOutput instanceof OutputStream) {\n      jsOutput = streamToOutputWriter((OutputStream) jsOutput);\n    }\n\n    List<String> jsFiles = config.js;\n    List<String> moduleSpecs = config.module;\n    if (!moduleSpecs.isEmpty()) {\n      modules = createJsModules(moduleSpecs, jsFiles);\n      if (config.skipNormalOutputs) {\n        compiler.initModules(externs, modules, options);\n      } else {\n        result = compiler.compileModules(externs, modules, options);\n      }\n    } else {\n      List<JSSourceFile> inputs = createSourceInputs(jsFiles);\n      if (config.skipNormalOutputs) {\n        compiler.init(externs, inputs, options);\n      } else {\n        result = compiler.compile(externs, inputs, options);\n      }\n    }\n\n    int errCode = processResults(result, modules, options);\n    // Flush the output if we are writing to a file.\n    // We can't close yet, because we may need to write phase ordering\n    // info to it later.\n    if (jsOutput instanceof Flushable) {\n      ((Flushable) jsOutput).flush();\n    }\n    return errCode;\n  }",
    "comment": " Parses command-line arguments and runs the compiler.  @return system exit status ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "AbstractCommandLineRunner.enableTestMode",
    "class_name": "com.google.javascript.jscomp.AbstractCommandLineRunner",
    "signature": "com.google.javascript.jscomp.AbstractCommandLineRunner.enableTestMode(Supplier,Supplier,Supplier,Function)",
    "snippet": "  @VisibleForTesting\n  void enableTestMode(\n      Supplier<List<JSSourceFile>> externsSupplier,\n      Supplier<List<JSSourceFile>> inputsSupplier,\n      Supplier<List<JSModule>> modulesSupplier,\n      Function<Integer, Boolean> exitCodeReceiver) {\n    Preconditions.checkArgument(\n        inputsSupplier == null ^ modulesSupplier == null);\n    testMode = true;\n    this.externsSupplierForTesting = externsSupplier;\n    this.inputsSupplierForTesting = inputsSupplier;\n    this.modulesSupplierForTesting = modulesSupplier;\n    this.exitCodeReceiverForTesting = exitCodeReceiver;\n  }",
    "comment": " Put the command line runner into test mode. In test mode, all outputs will be blackholed. @param externsSupplier A provider for externs. @param inputsSupplier A provider for source inputs. @param modulesSupplier A provider for modules. Only one of inputsSupplier and modulesSupplier may be non-null. @param exitCodeReceiver A receiver for the status code that would have been passed to System.exit in non-test mode. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "AbstractCommandLineRunner.getCommandLineConfig",
    "class_name": "com.google.javascript.jscomp.AbstractCommandLineRunner",
    "signature": "com.google.javascript.jscomp.AbstractCommandLineRunner.getCommandLineConfig()",
    "snippet": "  protected CommandLineConfig getCommandLineConfig() {\n    return config;\n  }",
    "comment": " Get the command line config, so that it can be initialized. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "AbstractCommandLineRunner.getCompiler",
    "class_name": "com.google.javascript.jscomp.AbstractCommandLineRunner",
    "signature": "com.google.javascript.jscomp.AbstractCommandLineRunner.getCompiler()",
    "snippet": "  final protected A getCompiler() {\n    return compiler;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "AbstractCommandLineRunner.getDiagnosticGroups",
    "class_name": "com.google.javascript.jscomp.AbstractCommandLineRunner",
    "signature": "com.google.javascript.jscomp.AbstractCommandLineRunner.getDiagnosticGroups()",
    "snippet": "  protected DiagnosticGroups getDiagnosticGroups() {\n    if (compiler == null) {\n      return new DiagnosticGroups();\n    }\n    return compiler.getDiagnosticGroups();\n  }",
    "comment": " The warning classes that are available from the command-line. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "AbstractCommandLineRunner.getErrorPrintStream",
    "class_name": "com.google.javascript.jscomp.AbstractCommandLineRunner",
    "signature": "com.google.javascript.jscomp.AbstractCommandLineRunner.getErrorPrintStream()",
    "snippet": "  protected PrintStream getErrorPrintStream() {\n    return err;\n  }",
    "comment": " Returns the PrintStream for writing errors associated with this AbstractCommandLineRunner. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "AbstractCommandLineRunner.getInputCharset",
    "class_name": "com.google.javascript.jscomp.AbstractCommandLineRunner",
    "signature": "com.google.javascript.jscomp.AbstractCommandLineRunner.getInputCharset()",
    "snippet": "  private Charset getInputCharset() throws FlagUsageException {\n    if (!config.charset.isEmpty()) {\n      if (!Charset.isSupported(config.charset)) {\n        throw new FlagUsageException(config.charset +\n            \" is not a valid charset name.\");\n      }\n      return Charset.forName(config.charset);\n    }\n    return Charsets.UTF_8;\n  }",
    "comment": " Query the flag for the input charset, and return a Charset object representing the selection.  @return Charset to use when reading inputs @throws FlagUsageException if flag is not a valid Charset name. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "AbstractCommandLineRunner.getOutputCharset",
    "class_name": "com.google.javascript.jscomp.AbstractCommandLineRunner",
    "signature": "com.google.javascript.jscomp.AbstractCommandLineRunner.getOutputCharset()",
    "snippet": "  private String getOutputCharset() throws FlagUsageException {\n    if (!config.charset.isEmpty()) {\n      if (!Charset.isSupported(config.charset)) {\n        throw new FlagUsageException(config.charset +\n            \" is not a valid charset name.\");\n      }\n      return config.charset;\n    }\n    return \"US-ASCII\";\n  }",
    "comment": " Query the flag for the output charset.  Let the outputCharset be the same as the input charset... except if we're reading in UTF-8 by default.  By tradition, we've always output ASCII to avoid various hiccups with different browsers, proxies and firewalls.  @return Name of the charset to use when writing outputs. Guaranteed to be a supported charset. @throws FlagUsageException if flag is not a valid Charset name. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "AbstractCommandLineRunner.isInTestMode",
    "class_name": "com.google.javascript.jscomp.AbstractCommandLineRunner",
    "signature": "com.google.javascript.jscomp.AbstractCommandLineRunner.isInTestMode()",
    "snippet": "  protected boolean isInTestMode() {\n    return testMode;\n  }",
    "comment": " Returns whether we're in test mode. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "AbstractCommandLineRunner.outputBundle",
    "class_name": "com.google.javascript.jscomp.AbstractCommandLineRunner",
    "signature": "com.google.javascript.jscomp.AbstractCommandLineRunner.outputBundle()",
    "snippet": "  private void outputBundle() throws IOException {\n    outputManifestOrBundle(config.outputBundles, false);\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "AbstractCommandLineRunner.outputManifest",
    "class_name": "com.google.javascript.jscomp.AbstractCommandLineRunner",
    "signature": "com.google.javascript.jscomp.AbstractCommandLineRunner.outputManifest()",
    "snippet": "  private void outputManifest() throws IOException {\n    outputManifestOrBundle(config.outputManifests, true);\n  }",
    "comment": " Writes the manifest or bundle of all compiler input files that survived manage_closure_dependencies, if requested. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "AbstractCommandLineRunner.outputManifestOrBundle",
    "class_name": "com.google.javascript.jscomp.AbstractCommandLineRunner",
    "signature": "com.google.javascript.jscomp.AbstractCommandLineRunner.outputManifestOrBundle(List,boolean)",
    "snippet": "  private void outputManifestOrBundle(List<String> outputFiles,\n      boolean isManifest) throws IOException {\n    if (outputFiles.isEmpty()) {\n      return;\n    }\n\n    for (String output : outputFiles) {\n      if (output.isEmpty()) {\n        continue;\n      }\n\n      JSModuleGraph graph = compiler.getModuleGraph();\n      if (shouldGenerateOutputPerModule(output)) {\n        // Generate per-module manifests or bundles\n        Iterable<JSModule> modules = graph.getAllModules();\n        for (JSModule module : modules) {\n          Writer out = fileNameToOutputWriter(\n              expandCommandLinePath(output, module));\n          if (isManifest) {\n            printManifestTo(module.getInputs(), out);\n          } else {\n            printBundleTo(module.getInputs(), out);\n          }\n          out.close();\n        }\n      } else {\n        // Generate a single file manifest or bundle.\n        Writer out = fileNameToOutputWriter(\n            expandCommandLinePath(output, null));\n        if (graph == null) {\n          if (isManifest) {\n            printManifestTo(compiler.getInputsInOrder(), out);\n          } else {\n            printBundleTo(compiler.getInputsInOrder(), out);\n          }\n        } else {\n          printModuleGraphManifestOrBundleTo(graph, out, isManifest);\n        }\n        out.close();\n      }\n    }\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "AbstractCommandLineRunner.run",
    "class_name": "com.google.javascript.jscomp.AbstractCommandLineRunner",
    "signature": "com.google.javascript.jscomp.AbstractCommandLineRunner.run()",
    "snippet": "  final public void run() {\n    int result = 0;\n    int runs = 1;\n    if (config.computePhaseOrdering) {\n      runs = NUM_RUNS_TO_DETERMINE_OPTIMAL_ORDER;\n      PhaseOptimizer.randomizeLoops();\n    }\n    try {\n      for (int i = 0; i < runs && result == 0; i++) {\n        runTimeStats.recordStartRun();\n        result = doRun();\n        runTimeStats.recordEndRun();\n      }\n    } catch (AbstractCommandLineRunner.FlagUsageException e) {\n      System.err.println(e.getMessage());\n      result = -1;\n    } catch (Throwable t) {\n      t.printStackTrace();\n      result = -2;\n    }\n\n    if (config.computePhaseOrdering) {\n      runTimeStats.outputBestPhaseOrdering();\n    }\n\n    try {\n      if (jsOutput instanceof Closeable) {\n        ((Closeable) jsOutput).close();\n      }\n    } catch (IOException e) {\n      throw Throwables.propagate(e);\n    }\n\n    if (testMode) {\n      exitCodeReceiverForTesting.apply(result);\n    } else {\n      System.exit(result);\n    }\n  }",
    "comment": " Runs the Compiler and calls System.exit() with the exit status of the compiler. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "AbstractCommandLineRunner.setRunOptions",
    "class_name": "com.google.javascript.jscomp.AbstractCommandLineRunner",
    "signature": "com.google.javascript.jscomp.AbstractCommandLineRunner.setRunOptions(CompilerOptions)",
    "snippet": "  protected void setRunOptions(CompilerOptions options)\n      throws FlagUsageException, IOException {\n    DiagnosticGroups diagnosticGroups = getDiagnosticGroups();\n\n    if (config.warningGuards != null) {\n      for (WarningGuardSpec.Entry entry : config.warningGuards.entries) {\n        diagnosticGroups.setWarningLevel(options, entry.groupName, entry.level);\n      }\n    }\n\n    createDefineOrTweakReplacements(config.define, options, false);\n\n    options.setTweakProcessing(config.tweakProcessing);\n    createDefineOrTweakReplacements(config.tweak, options, true);\n\n    options.manageClosureDependencies = config.manageClosureDependencies;\n    if (config.closureEntryPoints.size() > 0) {\n      options.setManageClosureDependencies(config.closureEntryPoints);\n    }\n    options.devMode = config.jscompDevMode;\n    options.setCodingConvention(config.codingConvention);\n    options.setSummaryDetailLevel(config.summaryDetailLevel);\n\n    outputCharset = options.outputCharset = getOutputCharset();\n    inputCharset = getInputCharset();\n\n    if (config.jsOutputFile.length() > 0) {\n      if (config.skipNormalOutputs) {\n        throw new FlagUsageException(\"skip_normal_outputs and js_output_file\"\n            + \" cannot be used together.\");\n      } else {\n        options.jsOutputFile = config.jsOutputFile;\n      }\n    }\n\n    if (config.skipNormalOutputs && config.printAst) {\n      throw new FlagUsageException(\"skip_normal_outputs and print_ast cannot\"\n          + \" be used together.\");\n    }\n\n    if (config.skipNormalOutputs && config.printTree) {\n      throw new FlagUsageException(\"skip_normal_outputs and print_tree cannot\"\n          + \" be used together.\");\n    }\n\n    if (config.createSourceMap.length() > 0) {\n      options.sourceMapOutputPath = config.createSourceMap;\n    }\n    options.sourceMapDetailLevel = config.sourceMapDetailLevel;\n    options.sourceMapFormat = config.sourceMapFormat;\n\n    if (!config.variableMapInputFile.equals(\"\")) {\n      options.inputVariableMapSerialized =\n          VariableMap.load(config.variableMapInputFile).toBytes();\n    }\n\n    if (!config.propertyMapInputFile.equals(\"\")) {\n      options.inputPropertyMapSerialized =\n          VariableMap.load(config.propertyMapInputFile).toBytes();\n    }\n\n    if (config.languageIn.length() > 0) {\n      if (config.languageIn.equals(\"ECMASCRIPT5_STRICT\") ||\n          config.languageIn.equals(\"ES5_STRICT\")) {\n        options.setLanguageIn(CompilerOptions.LanguageMode.ECMASCRIPT5_STRICT);\n      } else if (config.languageIn.equals(\"ECMASCRIPT5\") ||\n          config.languageIn.equals(\"ES5\")) {\n        options.setLanguageIn(CompilerOptions.LanguageMode.ECMASCRIPT5);\n      } else if (config.languageIn.equals(\"ECMASCRIPT3\") ||\n                 config.languageIn.equals(\"ES3\")) {\n        options.setLanguageIn(CompilerOptions.LanguageMode.ECMASCRIPT3);\n      } else {\n        throw new FlagUsageException(\"Unknown language `\" + config.languageIn +\n                                     \"' specified.\");\n      }\n    }\n\n    options.acceptConstKeyword = config.acceptConstKeyword;\n  }",
    "comment": " Sets options based on the configurations set flags API. Called during the run() run() method. If you want to ignore the flags API, or intepret flags your own way, then you should override this method. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "AbstractCommandLineRunner.streamToOutputWriter",
    "class_name": "com.google.javascript.jscomp.AbstractCommandLineRunner",
    "signature": "com.google.javascript.jscomp.AbstractCommandLineRunner.streamToOutputWriter(OutputStream)",
    "snippet": "  private Writer streamToOutputWriter(OutputStream stream)\n      throws IOException {\n    if (outputCharset == null) {\n      return new BufferedWriter(\n          new OutputStreamWriter(stream));\n    } else {\n      return new BufferedWriter(\n          new OutputStreamWriter(stream, outputCharset));\n    }\n  }",
    "comment": " Create a writer. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "AbstractCommandLineRunner.writeOutput",
    "class_name": "com.google.javascript.jscomp.AbstractCommandLineRunner",
    "signature": "com.google.javascript.jscomp.AbstractCommandLineRunner.writeOutput(Appendable,Compiler,String,String,String)",
    "snippet": "  static void writeOutput(Appendable out, Compiler compiler, String code,\n      String wrapper, String codePlaceholder) throws IOException {\n    int pos = wrapper.indexOf(codePlaceholder);\n    if (pos != -1) {\n      String prefix = \"\";\n\n      if (pos > 0) {\n        prefix = wrapper.substring(0, pos);\n        out.append(prefix);\n      }\n\n      out.append(code);\n\n      int suffixStart = pos + codePlaceholder.length();\n      if (suffixStart != wrapper.length()) {\n        // Something after placeholder?\n        out.append(wrapper.substring(suffixStart));\n      }\n      // Make sure we always end output with a line feed.\n      out.append('\\n');\n\n      // If we have a source map, adjust its offsets to match\n      // the code WITHIN the wrapper.\n      if (compiler != null && compiler.getSourceMap() != null) {\n        compiler.getSourceMap().setWrapperPrefix(prefix);\n      }\n\n    } else {\n      out.append(code);\n      out.append('\\n');\n    }\n  }",
    "comment": " Writes code to an output stream, optionally wrapping it in an arbitrary wrapper that contains a placeholder where the code should be inserted. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "CommandLineConfig.setAcceptConstKeyword",
    "class_name": "com.google.javascript.jscomp.AbstractCommandLineRunner$CommandLineConfig",
    "signature": "com.google.javascript.jscomp.AbstractCommandLineRunner$CommandLineConfig.setAcceptConstKeyword(boolean)",
    "snippet": "    CommandLineConfig setAcceptConstKeyword(boolean acceptConstKeyword) {\n      this.acceptConstKeyword = acceptConstKeyword;\n      return this;\n    }",
    "comment": " Sets whether to accept usage of 'const' keyword. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "CommandLineConfig.setCharset",
    "class_name": "com.google.javascript.jscomp.AbstractCommandLineRunner$CommandLineConfig",
    "signature": "com.google.javascript.jscomp.AbstractCommandLineRunner$CommandLineConfig.setCharset(String)",
    "snippet": "    CommandLineConfig setCharset(String charset) {\n      this.charset = charset;\n      return this;\n    }",
    "comment": " Input charset for all files. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "CommandLineConfig.setClosureEntryPoints",
    "class_name": "com.google.javascript.jscomp.AbstractCommandLineRunner$CommandLineConfig",
    "signature": "com.google.javascript.jscomp.AbstractCommandLineRunner$CommandLineConfig.setClosureEntryPoints(List)",
    "snippet": "    CommandLineConfig setClosureEntryPoints(List<String> entryPoints) {\n      Preconditions.checkNotNull(entryPoints);\n      this.closureEntryPoints = entryPoints;\n      return this;\n    }",
    "comment": " Set closure entry points, which makes the compiler only include those files and sort them in dependency order. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "CommandLineConfig.setCodingConvention",
    "class_name": "com.google.javascript.jscomp.AbstractCommandLineRunner$CommandLineConfig",
    "signature": "com.google.javascript.jscomp.AbstractCommandLineRunner$CommandLineConfig.setCodingConvention(CodingConvention)",
    "snippet": "    CommandLineConfig setCodingConvention(CodingConvention codingConvention) {\n      this.codingConvention = codingConvention;\n      return this;\n    }",
    "comment": " Sets rules and conventions to enforce. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "CommandLineConfig.setCreateNameMapFiles",
    "class_name": "com.google.javascript.jscomp.AbstractCommandLineRunner$CommandLineConfig",
    "signature": "com.google.javascript.jscomp.AbstractCommandLineRunner$CommandLineConfig.setCreateNameMapFiles(boolean)",
    "snippet": "    CommandLineConfig setCreateNameMapFiles(boolean createNameMapFiles) {\n      this.createNameMapFiles = createNameMapFiles;\n      return this;\n    }",
    "comment": " If true, variable renaming and property renaming map files will be produced as {binary name}_vars_map.out and {binary name}_props_map.out. Note that this flag cannot be used in conjunction with either variable_map_output_file or property_map_output_file ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "CommandLineConfig.setCreateSourceMap",
    "class_name": "com.google.javascript.jscomp.AbstractCommandLineRunner$CommandLineConfig",
    "signature": "com.google.javascript.jscomp.AbstractCommandLineRunner$CommandLineConfig.setCreateSourceMap(String)",
    "snippet": "    CommandLineConfig setCreateSourceMap(String createSourceMap) {\n      this.createSourceMap = createSourceMap;\n      return this;\n    }",
    "comment": " If specified, a source map file mapping the generated source files back to the original source file will be output to the specified path. The %outname% placeholder will expand to the name of the output file that the source map corresponds to. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "CommandLineConfig.setDefine",
    "class_name": "com.google.javascript.jscomp.AbstractCommandLineRunner$CommandLineConfig",
    "signature": "com.google.javascript.jscomp.AbstractCommandLineRunner$CommandLineConfig.setDefine(List)",
    "snippet": "    CommandLineConfig setDefine(List<String> define) {\n      this.define.clear();\n      this.define.addAll(define);\n      return this;\n    }",
    "comment": " Override the value of a variable annotated @define. The format is <name>[=<val>], where <name> is the name of a @define variable and <val> is a boolean, number, or a single-quoted string that contains no single quotes. If [=<val>] is omitted, the variable is marked true ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "CommandLineConfig.setExterns",
    "class_name": "com.google.javascript.jscomp.AbstractCommandLineRunner$CommandLineConfig",
    "signature": "com.google.javascript.jscomp.AbstractCommandLineRunner$CommandLineConfig.setExterns(List)",
    "snippet": "    CommandLineConfig setExterns(List<String> externs) {\n      this.externs.clear();\n      this.externs.addAll(externs);\n      return this;\n    }",
    "comment": " The file containing javascript externs. You may specify multiple. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "CommandLineConfig.setJs",
    "class_name": "com.google.javascript.jscomp.AbstractCommandLineRunner$CommandLineConfig",
    "signature": "com.google.javascript.jscomp.AbstractCommandLineRunner$CommandLineConfig.setJs(List)",
    "snippet": "    CommandLineConfig setJs(List<String> js) {\n      this.js.clear();\n      this.js.addAll(js);\n      return this;\n    }",
    "comment": " The javascript filename. You may specify multiple. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "CommandLineConfig.setJsOutputFile",
    "class_name": "com.google.javascript.jscomp.AbstractCommandLineRunner$CommandLineConfig",
    "signature": "com.google.javascript.jscomp.AbstractCommandLineRunner$CommandLineConfig.setJsOutputFile(String)",
    "snippet": "    CommandLineConfig setJsOutputFile(String jsOutputFile) {\n      this.jsOutputFile = jsOutputFile;\n      return this;\n    }",
    "comment": " Primary output filename. If not specified, output is written to stdout ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "CommandLineConfig.setJscompDevMode",
    "class_name": "com.google.javascript.jscomp.AbstractCommandLineRunner$CommandLineConfig",
    "signature": "com.google.javascript.jscomp.AbstractCommandLineRunner$CommandLineConfig.setJscompDevMode(DevMode)",
    "snippet": "    CommandLineConfig setJscompDevMode(CompilerOptions.DevMode jscompDevMode) {\n      this.jscompDevMode = jscompDevMode;\n      return this;\n    }",
    "comment": "Turns on extra sanity checks */",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "CommandLineConfig.setLanguageIn",
    "class_name": "com.google.javascript.jscomp.AbstractCommandLineRunner$CommandLineConfig",
    "signature": "com.google.javascript.jscomp.AbstractCommandLineRunner$CommandLineConfig.setLanguageIn(String)",
    "snippet": "    CommandLineConfig setLanguageIn(String languageIn) {\n      this.languageIn = languageIn;\n      return this;\n    }",
    "comment": " Sets whether to accept input files as ECMAScript5 compliant. Otherwise input files are treated as ECMAScript3 compliant. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "CommandLineConfig.setLoggingLevel",
    "class_name": "com.google.javascript.jscomp.AbstractCommandLineRunner$CommandLineConfig",
    "signature": "com.google.javascript.jscomp.AbstractCommandLineRunner$CommandLineConfig.setLoggingLevel(String)",
    "snippet": "    CommandLineConfig setLoggingLevel(String loggingLevel) {\n      this.loggingLevel = loggingLevel;\n      return this;\n    }",
    "comment": " The logging level (standard java.util.logging.Level values) for Compiler progress. Does not control errors or warnings for the JavaScript code under compilation ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "CommandLineConfig.setManageClosureDependencies",
    "class_name": "com.google.javascript.jscomp.AbstractCommandLineRunner$CommandLineConfig",
    "signature": "com.google.javascript.jscomp.AbstractCommandLineRunner$CommandLineConfig.setManageClosureDependencies(boolean)",
    "snippet": "    CommandLineConfig setManageClosureDependencies(boolean newVal) {\n      this.manageClosureDependencies = newVal;\n      return this;\n    }",
    "comment": " Sets whether to sort files by their goog.provide/require deps, and prune inputs that are not required. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "CommandLineConfig.setModule",
    "class_name": "com.google.javascript.jscomp.AbstractCommandLineRunner$CommandLineConfig",
    "signature": "com.google.javascript.jscomp.AbstractCommandLineRunner$CommandLineConfig.setModule(List)",
    "snippet": "    CommandLineConfig setModule(List<String> module) {\n      this.module.clear();\n      this.module.addAll(module);\n      return this;\n    }",
    "comment": " A javascript module specification. The format is <name>:<num-js-files>[:[<dep>,...][:]]]. Module names must be unique. Each dep is the name of a module that this module depends on. Modules must be listed in dependency order, and js source files must be listed in the corresponding order. Where --module flags occur in relation to --js flags is unimportant ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "CommandLineConfig.setModuleOutputPathPrefix",
    "class_name": "com.google.javascript.jscomp.AbstractCommandLineRunner$CommandLineConfig",
    "signature": "com.google.javascript.jscomp.AbstractCommandLineRunner$CommandLineConfig.setModuleOutputPathPrefix(String)",
    "snippet": "    CommandLineConfig setModuleOutputPathPrefix(String moduleOutputPathPrefix) {\n      this.moduleOutputPathPrefix = moduleOutputPathPrefix;\n      return this;\n    }",
    "comment": " Prefix for filenames of compiled js modules. <module-name>.js will be appended to this prefix. Directories will be created as needed. Use with --module ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "CommandLineConfig.setModuleWrapper",
    "class_name": "com.google.javascript.jscomp.AbstractCommandLineRunner$CommandLineConfig",
    "signature": "com.google.javascript.jscomp.AbstractCommandLineRunner$CommandLineConfig.setModuleWrapper(List)",
    "snippet": "    CommandLineConfig setModuleWrapper(List<String> moduleWrapper) {\n      this.moduleWrapper.clear();\n      this.moduleWrapper.addAll(moduleWrapper);\n      return this;\n    }",
    "comment": " An output wrapper for a javascript module (optional). The format is <name>:<wrapper>. The module name must correspond with a module specified using --module. The wrapper must contain %s as the code placeholder ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "CommandLineConfig.setOutputManifest",
    "class_name": "com.google.javascript.jscomp.AbstractCommandLineRunner$CommandLineConfig",
    "signature": "com.google.javascript.jscomp.AbstractCommandLineRunner$CommandLineConfig.setOutputManifest(List)",
    "snippet": "    CommandLineConfig setOutputManifest(List<String> outputManifests) {\n      this.outputManifests = outputManifests;\n      return this;\n    }",
    "comment": " Sets whether to print output manifest files. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "CommandLineConfig.setOutputWrapper",
    "class_name": "com.google.javascript.jscomp.AbstractCommandLineRunner$CommandLineConfig",
    "signature": "com.google.javascript.jscomp.AbstractCommandLineRunner$CommandLineConfig.setOutputWrapper(String)",
    "snippet": "    CommandLineConfig setOutputWrapper(String outputWrapper) {\n      this.outputWrapper = outputWrapper;\n      return this;\n    }",
    "comment": " Interpolate output into this string at the place denoted by the marker token %output%. See --output_wrapper_marker ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "CommandLineConfig.setPrintAst",
    "class_name": "com.google.javascript.jscomp.AbstractCommandLineRunner$CommandLineConfig",
    "signature": "com.google.javascript.jscomp.AbstractCommandLineRunner$CommandLineConfig.setPrintAst(boolean)",
    "snippet": "    CommandLineConfig setPrintAst(boolean printAst) {\n      this.printAst = printAst;\n      return this;\n    }",
    "comment": " Prints a dot file describing the internal abstract syntax tree and exits ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "CommandLineConfig.setPrintPassGraph",
    "class_name": "com.google.javascript.jscomp.AbstractCommandLineRunner$CommandLineConfig",
    "signature": "com.google.javascript.jscomp.AbstractCommandLineRunner$CommandLineConfig.setPrintPassGraph(boolean)",
    "snippet": "    CommandLineConfig setPrintPassGraph(boolean printPassGraph) {\n      this.printPassGraph = printPassGraph;\n      return this;\n    }",
    "comment": "Prints a dot file describing the passes that will get run and exits */",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "CommandLineConfig.setPrintTree",
    "class_name": "com.google.javascript.jscomp.AbstractCommandLineRunner$CommandLineConfig",
    "signature": "com.google.javascript.jscomp.AbstractCommandLineRunner$CommandLineConfig.setPrintTree(boolean)",
    "snippet": "    CommandLineConfig setPrintTree(boolean printTree) {\n      this.printTree = printTree;\n      return this;\n    }",
    "comment": "Prints out the parse tree and exits */",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "CommandLineConfig.setPropertyMapInputFile",
    "class_name": "com.google.javascript.jscomp.AbstractCommandLineRunner$CommandLineConfig",
    "signature": "com.google.javascript.jscomp.AbstractCommandLineRunner$CommandLineConfig.setPropertyMapInputFile(String)",
    "snippet": "    CommandLineConfig setPropertyMapInputFile(String propertyMapInputFile) {\n      this.propertyMapInputFile = propertyMapInputFile;\n      return this;\n    }",
    "comment": " File containing the serialized version of the property renaming map produced by a previous compilation ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "CommandLineConfig.setPropertyMapOutputFile",
    "class_name": "com.google.javascript.jscomp.AbstractCommandLineRunner$CommandLineConfig",
    "signature": "com.google.javascript.jscomp.AbstractCommandLineRunner$CommandLineConfig.setPropertyMapOutputFile(String)",
    "snippet": "    CommandLineConfig setPropertyMapOutputFile(String propertyMapOutputFile) {\n      this.propertyMapOutputFile = propertyMapOutputFile;\n      return this;\n    }",
    "comment": " File where the serialized version of the property renaming map produced should be saved ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "CommandLineConfig.setSourceMapFormat",
    "class_name": "com.google.javascript.jscomp.AbstractCommandLineRunner$CommandLineConfig",
    "signature": "com.google.javascript.jscomp.AbstractCommandLineRunner$CommandLineConfig.setSourceMapFormat(Format)",
    "snippet": "    CommandLineConfig setSourceMapFormat(SourceMap.Format format) {\n      this.sourceMapFormat = format;\n      return this;\n    }",
    "comment": " The detail supplied in the source map file, if generated. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "CommandLineConfig.setSummaryDetailLevel",
    "class_name": "com.google.javascript.jscomp.AbstractCommandLineRunner$CommandLineConfig",
    "signature": "com.google.javascript.jscomp.AbstractCommandLineRunner$CommandLineConfig.setSummaryDetailLevel(int)",
    "snippet": "    CommandLineConfig setSummaryDetailLevel(int summaryDetailLevel) {\n      this.summaryDetailLevel = summaryDetailLevel;\n      return this;\n    }",
    "comment": " Controls how detailed the compilation summary is. Values: 0 (never print summary), 1 (print summary only if there are errors or warnings), 2 (print summary if type checking is on, see --check_types), 3 (always print summary). The default level is 1 ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "CommandLineConfig.setVariableMapInputFile",
    "class_name": "com.google.javascript.jscomp.AbstractCommandLineRunner$CommandLineConfig",
    "signature": "com.google.javascript.jscomp.AbstractCommandLineRunner$CommandLineConfig.setVariableMapInputFile(String)",
    "snippet": "    CommandLineConfig setVariableMapInputFile(String variableMapInputFile) {\n      this.variableMapInputFile = variableMapInputFile;\n      return this;\n    }",
    "comment": " File containing the serialized version of the variable renaming map produced by a previous compilation ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "CommandLineConfig.setVariableMapOutputFile",
    "class_name": "com.google.javascript.jscomp.AbstractCommandLineRunner$CommandLineConfig",
    "signature": "com.google.javascript.jscomp.AbstractCommandLineRunner$CommandLineConfig.setVariableMapOutputFile(String)",
    "snippet": "    CommandLineConfig setVariableMapOutputFile(String variableMapOutputFile) {\n      this.variableMapOutputFile = variableMapOutputFile;\n      return this;\n    }",
    "comment": " File where the serialized version of the variable renaming map produced should be saved ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "CommandLineConfig.setWarningGuardSpec",
    "class_name": "com.google.javascript.jscomp.AbstractCommandLineRunner$CommandLineConfig",
    "signature": "com.google.javascript.jscomp.AbstractCommandLineRunner$CommandLineConfig.setWarningGuardSpec(WarningGuardSpec)",
    "snippet": "    CommandLineConfig setWarningGuardSpec(WarningGuardSpec spec) {\n      this.warningGuards = spec;\n      return this;\n    }",
    "comment": " Add warning guards. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "RunTimeStats.recordEndRun",
    "class_name": "com.google.javascript.jscomp.AbstractCommandLineRunner$RunTimeStats",
    "signature": "com.google.javascript.jscomp.AbstractCommandLineRunner$RunTimeStats.recordEndRun()",
    "snippet": "    private void recordEndRun() {\n      long endTime = System.currentTimeMillis();\n      long length = endTime - lastStartTime;\n      worstRunTime = Math.max(length, worstRunTime);\n      if (length < bestRunTime) {\n        loopedPassesInBestRun = PhaseOptimizer.getLoopsRun();\n        bestRunTime = length;\n      }\n    }",
    "comment": " Record the end of a run. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "RunTimeStats.recordStartRun",
    "class_name": "com.google.javascript.jscomp.AbstractCommandLineRunner$RunTimeStats",
    "signature": "com.google.javascript.jscomp.AbstractCommandLineRunner$RunTimeStats.recordStartRun()",
    "snippet": "    private void recordStartRun() {\n      lastStartTime = System.currentTimeMillis();\n      PhaseOptimizer.clearLoopsRun();\n    }",
    "comment": " Record the start of a run. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "WarningGuardSpec.add",
    "class_name": "com.google.javascript.jscomp.AbstractCommandLineRunner$WarningGuardSpec",
    "signature": "com.google.javascript.jscomp.AbstractCommandLineRunner$WarningGuardSpec.add(CheckLevel,String)",
    "snippet": "    protected void add(CheckLevel level, String groupName) {\n      entries.add(new Entry(level, groupName));\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "WarningGuardSpec.clear",
    "class_name": "com.google.javascript.jscomp.AbstractCommandLineRunner$WarningGuardSpec",
    "signature": "com.google.javascript.jscomp.AbstractCommandLineRunner$WarningGuardSpec.clear()",
    "snippet": "    protected void clear() {\n      entries.clear();\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "AbstractCompiler.getLifeCycleStage",
    "class_name": "com.google.javascript.jscomp.AbstractCompiler",
    "signature": "com.google.javascript.jscomp.AbstractCompiler.getLifeCycleStage()",
    "snippet": "  LifeCycleStage getLifeCycleStage() {\n    return stage;\n  }",
    "comment": " @return The current life-cycle stage of the AST we're working on. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "AbstractCompiler.setLifeCycleStage",
    "class_name": "com.google.javascript.jscomp.AbstractCompiler",
    "signature": "com.google.javascript.jscomp.AbstractCompiler.setLifeCycleStage(LifeCycleStage)",
    "snippet": "  void setLifeCycleStage(LifeCycleStage stage) {\n    this.stage = stage;\n  }",
    "comment": " Set the current life-cycle state. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "LifeCycleStage.isNormalized",
    "class_name": "com.google.javascript.jscomp.AbstractCompiler$LifeCycleStage",
    "signature": "com.google.javascript.jscomp.AbstractCompiler$LifeCycleStage.isNormalized()",
    "snippet": "    boolean isNormalized() {\n      return this == NORMALIZED || this == NORMALIZED_OBFUSCATED;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "LifeCycleStage.isNormalizedObfuscated",
    "class_name": "com.google.javascript.jscomp.AbstractCompiler$LifeCycleStage",
    "signature": "com.google.javascript.jscomp.AbstractCompiler$LifeCycleStage.isNormalizedObfuscated()",
    "snippet": "    boolean isNormalizedObfuscated() {\n      return this == NORMALIZED_OBFUSCATED;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "AbstractMessageFormatter.AbstractMessageFormatter",
    "class_name": "com.google.javascript.jscomp.AbstractMessageFormatter",
    "signature": "com.google.javascript.jscomp.AbstractMessageFormatter.AbstractMessageFormatter(SourceExcerptProvider)",
    "snippet": "  public AbstractMessageFormatter(SourceExcerptProvider source) {\n    this.source = source;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "AbstractMessageFormatter.getLevelName",
    "class_name": "com.google.javascript.jscomp.AbstractMessageFormatter",
    "signature": "com.google.javascript.jscomp.AbstractMessageFormatter.getLevelName(CheckLevel)",
    "snippet": "  String getLevelName(CheckLevel level) {\n    switch (level) {\n      case ERROR: return maybeColorize(\"ERROR\", Color.ERROR);\n      case WARNING: return maybeColorize(\"WARNING\", Color.WARNING);\n      default: return level.toString();\n    }\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "AbstractMessageFormatter.getSource",
    "class_name": "com.google.javascript.jscomp.AbstractMessageFormatter",
    "signature": "com.google.javascript.jscomp.AbstractMessageFormatter.getSource()",
    "snippet": "  protected final SourceExcerptProvider getSource() {\n    return source;\n  }",
    "comment": " Get the source excerpt provider. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "AbstractMessageFormatter.maybeColorize",
    "class_name": "com.google.javascript.jscomp.AbstractMessageFormatter",
    "signature": "com.google.javascript.jscomp.AbstractMessageFormatter.maybeColorize(String,Color)",
    "snippet": "  private String maybeColorize(String text, Color color) {\n    if (!colorize) return text;\n\n    return color.getControlCharacter() +\n        text + Color.RESET.getControlCharacter();\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "AbstractMessageFormatter.setColorize",
    "class_name": "com.google.javascript.jscomp.AbstractMessageFormatter",
    "signature": "com.google.javascript.jscomp.AbstractMessageFormatter.setColorize(boolean)",
    "snippet": "  public void setColorize(boolean colorize) {\n    this.colorize = colorize;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "AbstractPeepholeOptimization.beginTraversal",
    "class_name": "com.google.javascript.jscomp.AbstractPeepholeOptimization",
    "signature": "com.google.javascript.jscomp.AbstractPeepholeOptimization.beginTraversal(NodeTraversal)",
    "snippet": "  void beginTraversal(NodeTraversal traversal) {\n    currentTraversal = traversal;\n  }",
    "comment": " Informs the optimization that a traversal will begin. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "AbstractPeepholeOptimization.endTraversal",
    "class_name": "com.google.javascript.jscomp.AbstractPeepholeOptimization",
    "signature": "com.google.javascript.jscomp.AbstractPeepholeOptimization.endTraversal(NodeTraversal)",
    "snippet": "  void endTraversal(NodeTraversal traversal) {\n    currentTraversal = null;\n  }",
    "comment": " Informs the optimization that a traversal has completed. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "AbstractPeepholeOptimization.isASTNormalized",
    "class_name": "com.google.javascript.jscomp.AbstractPeepholeOptimization",
    "signature": "com.google.javascript.jscomp.AbstractPeepholeOptimization.isASTNormalized()",
    "snippet": "  protected boolean isASTNormalized() {\n    Preconditions.checkNotNull(currentTraversal);\n    Preconditions.checkNotNull(currentTraversal.getCompiler());\n\n    return currentTraversal.getCompiler().getLifeCycleStage().isNormalized();\n  }",
    "comment": " Is the current AST normalized? (e.g. has the Normalize pass been run and has the Denormalize pass not yet been run?) ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "AbstractPeepholeOptimization.mayHaveSideEffects",
    "class_name": "com.google.javascript.jscomp.AbstractPeepholeOptimization",
    "signature": "com.google.javascript.jscomp.AbstractPeepholeOptimization.mayHaveSideEffects(Node)",
    "snippet": "  boolean mayHaveSideEffects(Node n) {\n    return NodeUtil.mayHaveSideEffects(n, currentTraversal.getCompiler());\n  }",
    "comment": " @return Whether the node may have side effects when executed. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "AnonymousFunctionNamingPolicy.getReservedCharacters",
    "class_name": "com.google.javascript.jscomp.AnonymousFunctionNamingPolicy",
    "signature": "com.google.javascript.jscomp.AnonymousFunctionNamingPolicy.getReservedCharacters()",
    "snippet": "  public char[] getReservedCharacters() {\n    // TODO(user) - for MAPPED, only the first character is reserved which\n    // can be used to further optimize\n    return reservedCharacters;\n  }",
    "comment": " Gets characters that are reserved for use in anonymous function names and can't be used in variable or property names. @return reserved characters or null if no characters are reserved ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "AstValidator.AstValidator",
    "class_name": "com.google.javascript.jscomp.AstValidator",
    "signature": "com.google.javascript.jscomp.AstValidator.AstValidator()",
    "snippet": "  public AstValidator() {\n    this.violationHandler = new ViolationHandler() {\n      @Override\n      public void handleViolation(String message, Node n) {\n        throw new IllegalStateException(\n            message + \" Reference node \" + n.toString());\n      }\n    };\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "AstValidator.process",
    "class_name": "com.google.javascript.jscomp.AstValidator",
    "signature": "com.google.javascript.jscomp.AstValidator.process(Node,Node)",
    "snippet": "  @Override\n  public void process(Node externs, Node root) {\n    if (externs != null) {\n      validateCodeRoot(externs);\n    }\n    if (root != null) {\n      validateCodeRoot(root);\n    }\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "AstValidator.validateAssignmentExpression",
    "class_name": "com.google.javascript.jscomp.AstValidator",
    "signature": "com.google.javascript.jscomp.AstValidator.validateAssignmentExpression(Node)",
    "snippet": "  private void validateAssignmentExpression(Node n) {\n    validateChildCount(n, 2);\n    validateAssignmentTarget(n.getFirstChild());\n    validateExpression(n.getLastChild());\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "AstValidator.validateAssignmentTarget",
    "class_name": "com.google.javascript.jscomp.AstValidator",
    "signature": "com.google.javascript.jscomp.AstValidator.validateAssignmentTarget(Node)",
    "snippet": "  private void validateAssignmentTarget(Node n) {\n    switch (n.getType()) {\n      case Token.NAME:\n      case Token.GETELEM:\n      case Token.GETPROP:\n        validateExpression(n);\n        return;\n      default:\n        violation(\"Expected assignment target expression but was \"\n            + Node.tokenToName(n.getType()), n);\n    }\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "AstValidator.validateBlock",
    "class_name": "com.google.javascript.jscomp.AstValidator",
    "signature": "com.google.javascript.jscomp.AstValidator.validateBlock(Node)",
    "snippet": "  private void validateBlock(Node n) {\n    validateNodeType(Token.BLOCK, n);\n    for (Node c = n.getFirstChild(); c != null; c = c.getNext()) {\n      validateStatement(c);\n    }\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "AstValidator.validateChildCount",
    "class_name": "com.google.javascript.jscomp.AstValidator",
    "signature": "com.google.javascript.jscomp.AstValidator.validateChildCount(Node,int)",
    "snippet": "  private void validateChildCount(Node n, int i) {\n    boolean valid = false;\n    if (i == 0) {\n      valid = !n.hasChildren();\n    } else if (i == 1) {\n      valid = n.hasOneChild();\n    } else {\n      valid = (n.getChildCount() == i);\n    }\n    if (!valid) {\n      violation(\n          \"Expected \" + i + \" children, but was \"\n              + n.getChildCount(), n);\n    }\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "AstValidator.validateChildless",
    "class_name": "com.google.javascript.jscomp.AstValidator",
    "signature": "com.google.javascript.jscomp.AstValidator.validateChildless(Node)",
    "snippet": "  private void validateChildless(Node n) {\n    validateChildCount(n, 0);\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "AstValidator.validateCodeRoot",
    "class_name": "com.google.javascript.jscomp.AstValidator",
    "signature": "com.google.javascript.jscomp.AstValidator.validateCodeRoot(Node)",
    "snippet": "  public void validateCodeRoot(Node n) {\n    validateNodeType(Token.BLOCK, n);\n    validateIsSynthetic(n);\n    for (Node c = n.getFirstChild(); c != null; c = c.getNext()) {\n      validateScript(c);\n    }\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "AstValidator.validateExprStmt",
    "class_name": "com.google.javascript.jscomp.AstValidator",
    "signature": "com.google.javascript.jscomp.AstValidator.validateExprStmt(Node)",
    "snippet": "  private void validateExprStmt(Node n) {\n    validateNodeType(Token.EXPR_RESULT, n);\n    validateChildCount(n, 1);\n    validateExpression(n.getFirstChild());\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "AstValidator.validateExpression",
    "class_name": "com.google.javascript.jscomp.AstValidator",
    "signature": "com.google.javascript.jscomp.AstValidator.validateExpression(Node)",
    "snippet": "  public void validateExpression(Node n) {\n    switch (n.getType()) {\n      // Childless expressions\n      case Token.FALSE:\n      case Token.NULL:\n      case Token.THIS:\n      case Token.TRUE:\n        validateChildless(n);\n        return;\n\n      // General uniary ops\n      case Token.DELPROP:\n      case Token.POS:\n      case Token.NEG:\n      case Token.NOT:\n      case Token.INC:\n      case Token.DEC:\n      case Token.TYPEOF:\n      case Token.VOID:\n      case Token.BITNOT:\n        validateUnaryOp(n);\n        return;\n\n      // General binary ops\n      case Token.COMMA:\n      case Token.OR:\n      case Token.AND:\n      case Token.BITOR:\n      case Token.BITXOR:\n      case Token.BITAND:\n      case Token.EQ:\n      case Token.NE:\n      case Token.SHEQ:\n      case Token.SHNE:\n      case Token.LT:\n      case Token.GT:\n      case Token.LE:\n      case Token.GE:\n      case Token.INSTANCEOF:\n      case Token.IN:\n      case Token.LSH:\n      case Token.RSH:\n      case Token.URSH:\n      case Token.SUB:\n      case Token.ADD:\n      case Token.MUL:\n      case Token.MOD:\n      case Token.DIV:\n        validateBinaryOp(n);\n        return;\n\n      // Assignments\n      case Token.ASSIGN:\n      case Token.ASSIGN_BITOR:\n      case Token.ASSIGN_BITXOR:\n      case Token.ASSIGN_BITAND:\n      case Token.ASSIGN_LSH:\n      case Token.ASSIGN_RSH:\n      case Token.ASSIGN_URSH:\n      case Token.ASSIGN_ADD:\n      case Token.ASSIGN_SUB:\n      case Token.ASSIGN_MUL:\n      case Token.ASSIGN_DIV:\n      case Token.ASSIGN_MOD:\n        validateAssignmentExpression(n);\n        return;\n\n      case Token.HOOK:\n        validateTrinaryOp(n);\n        return;\n\n      // Node types that require special handling\n      case Token.STRING:\n        validateString(n);\n        return;\n\n      case Token.NUMBER:\n        validateNumber(n);\n        return;\n\n      case Token.NAME:\n        validateName(n);\n        return;\n\n      case Token.GETELEM:\n        validateBinaryOp(n);\n        return;\n\n      case Token.GETPROP:\n        validateGetProp(n);\n        return;\n\n      case Token.ARRAYLIT:\n        validateArrayLit(n);\n        return;\n\n      case Token.OBJECTLIT:\n        validateObjectLit(n);\n        return;\n\n      case Token.REGEXP:\n        validateRegExpLit(n);\n        return;\n\n      case Token.CALL:\n        validateCall(n);\n        return;\n\n      case Token.NEW:\n        validateNew(n);\n        return;\n\n      case Token.FUNCTION:\n        validateFunctionExpression(n);\n        return;\n\n      default:\n        violation(\"Expected expression but was \"\n            + Node.tokenToName(n.getType()), n);\n    }\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "AstValidator.validateFunctionExpression",
    "class_name": "com.google.javascript.jscomp.AstValidator",
    "signature": "com.google.javascript.jscomp.AstValidator.validateFunctionExpression(Node)",
    "snippet": "  private void validateFunctionExpression(Node n) {\n    validateNodeType(Token.FUNCTION, n);\n    validateChildCount(n, 3);\n    validateOptionalName(n.getFirstChild());\n    validateParameters(n.getChildAtIndex(1));\n    validateBlock(n.getLastChild());\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "AstValidator.validateFunctionStatement",
    "class_name": "com.google.javascript.jscomp.AstValidator",
    "signature": "com.google.javascript.jscomp.AstValidator.validateFunctionStatement(Node)",
    "snippet": "  private void validateFunctionStatement(Node n) {\n    validateNodeType(Token.FUNCTION, n);\n    validateChildCount(n, 3);\n    validateName(n.getFirstChild());\n    validateParameters(n.getChildAtIndex(1));\n    validateBlock(n.getLastChild());\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "AstValidator.validateGetProp",
    "class_name": "com.google.javascript.jscomp.AstValidator",
    "signature": "com.google.javascript.jscomp.AstValidator.validateGetProp(Node)",
    "snippet": "  private void validateGetProp(Node n) {\n    validateNodeType(Token.GETPROP, n);\n    validateChildCount(n, 2);\n    validateExpression(n.getFirstChild());\n    Node prop = n.getLastChild();\n    validateNodeType(Token.STRING, prop);\n    validateNonEmptyString(prop);\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "AstValidator.validateHasSourceName",
    "class_name": "com.google.javascript.jscomp.AstValidator",
    "signature": "com.google.javascript.jscomp.AstValidator.validateHasSourceName(Node)",
    "snippet": "  private void validateHasSourceName(Node n) {\n    String sourceName = n.getSourceFileName();\n    if (sourceName == null || sourceName.isEmpty()) {\n      violation(\"Missing 'source name' annotation.\", n);\n    }\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "AstValidator.validateIsSynthetic",
    "class_name": "com.google.javascript.jscomp.AstValidator",
    "signature": "com.google.javascript.jscomp.AstValidator.validateIsSynthetic(Node)",
    "snippet": "  private void validateIsSynthetic(Node n) {\n    if (!n.getBooleanProp(Node.SYNTHETIC_BLOCK_PROP)) {\n      violation(\"Missing 'synthetic block' annotation.\", n);\n    }\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "AstValidator.validateMaximumChildCount",
    "class_name": "com.google.javascript.jscomp.AstValidator",
    "signature": "com.google.javascript.jscomp.AstValidator.validateMaximumChildCount(Node,int)",
    "snippet": "  private void validateMaximumChildCount(Node n, int i) {\n    boolean valid = false;\n    if (i == 1) {\n      valid = !n.hasMoreThanOneChild();\n    } else {\n      valid = n.getChildCount() <= i;\n    }\n    if (!valid) {\n      violation(\n          \"Expected no more than \" + i + \" children, but was \"\n              + n.getChildCount(), n);\n    }\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "AstValidator.validateMinimumChildCount",
    "class_name": "com.google.javascript.jscomp.AstValidator",
    "signature": "com.google.javascript.jscomp.AstValidator.validateMinimumChildCount(Node,int)",
    "snippet": "  private void validateMinimumChildCount(Node n, int i) {\n    boolean valid = false;\n    if (i == 1) {\n      valid = n.hasChildren();\n    } else if (i == 2) {\n      valid = n.hasMoreThanOneChild();\n    } else {\n      valid = n.getChildCount() >= i;\n    }\n\n    if (!valid) {\n      violation(\n          \"Expected at least \" + i + \" children, but was \"\n              + n.getChildCount(), n);\n    }\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "AstValidator.validateName",
    "class_name": "com.google.javascript.jscomp.AstValidator",
    "signature": "com.google.javascript.jscomp.AstValidator.validateName(Node)",
    "snippet": "  private void validateName(Node n) {\n    validateNodeType(Token.NAME, n);\n    validateNonEmptyString(n);\n    validateChildCount(n, 0);\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "AstValidator.validateNodeType",
    "class_name": "com.google.javascript.jscomp.AstValidator",
    "signature": "com.google.javascript.jscomp.AstValidator.validateNodeType(int,Node)",
    "snippet": "  private void validateNodeType(int type, Node n) {\n    if (n.getType() != type) {\n      violation(\n          \"Expected \" + Node.tokenToName(type) + \" but was \"\n              + Node.tokenToName(n.getType()), n);\n    }\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "AstValidator.validateNonEmptyString",
    "class_name": "com.google.javascript.jscomp.AstValidator",
    "signature": "com.google.javascript.jscomp.AstValidator.validateNonEmptyString(Node)",
    "snippet": "  private void validateNonEmptyString(Node n) {\n    validateNonNullString(n);\n    if (n.getString().isEmpty()) {\n      violation(\"Expected non-empty string.\", n);\n    }\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "AstValidator.validateNonNullString",
    "class_name": "com.google.javascript.jscomp.AstValidator",
    "signature": "com.google.javascript.jscomp.AstValidator.validateNonNullString(Node)",
    "snippet": "  private void validateNonNullString(Node n) {\n    if (n.getString() == null) {\n      violation(\"Expected non-null string.\", n);\n    }\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "AstValidator.validateNumber",
    "class_name": "com.google.javascript.jscomp.AstValidator",
    "signature": "com.google.javascript.jscomp.AstValidator.validateNumber(Node)",
    "snippet": "  private void validateNumber(Node n) {\n    validateNodeType(Token.NUMBER, n);\n    validateChildCount(n, 0);\n    try {\n      // Validate that getDouble doesn't throw\n      n.getDouble();\n    } catch (UnsupportedOperationException e) {\n      violation(\"Invalid NUMBER node.\", n);\n    }\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "AstValidator.validateOptionalName",
    "class_name": "com.google.javascript.jscomp.AstValidator",
    "signature": "com.google.javascript.jscomp.AstValidator.validateOptionalName(Node)",
    "snippet": "  private void validateOptionalName(Node n) {\n    validateNodeType(Token.NAME, n);\n    validateNonNullString(n);\n    validateChildCount(n, 0);\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "AstValidator.validateParameters",
    "class_name": "com.google.javascript.jscomp.AstValidator",
    "signature": "com.google.javascript.jscomp.AstValidator.validateParameters(Node)",
    "snippet": "  private void validateParameters(Node n) {\n    validateNodeType(Token.LP, n);\n    for (Node c = n.getFirstChild(); c != null; c = c.getNext()) {\n      validateName(c);\n    }\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "AstValidator.validateScript",
    "class_name": "com.google.javascript.jscomp.AstValidator",
    "signature": "com.google.javascript.jscomp.AstValidator.validateScript(Node)",
    "snippet": "  public void validateScript(Node n) {\n    validateNodeType(Token.SCRIPT, n);\n    validateIsSynthetic(n);\n    validateHasSourceName(n);\n    for (Node c = n.getFirstChild(); c != null; c = c.getNext()) {\n      validateStatement(c);\n    }\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "AstValidator.validateStatement",
    "class_name": "com.google.javascript.jscomp.AstValidator",
    "signature": "com.google.javascript.jscomp.AstValidator.validateStatement(Node)",
    "snippet": "  public void validateStatement(Node n) {\n    switch (n.getType()) {\n      case Token.LABEL:\n        validateLabel(n);\n        return;\n      case Token.BLOCK:\n        validateBlock(n);\n        return;\n      case Token.FUNCTION:\n        validateFunctionStatement(n);\n        return;\n      case Token.WITH:\n        validateWith(n);\n        return;\n      case Token.FOR:\n        validateFor(n);\n        return;\n      case Token.WHILE:\n        validateWhile(n);\n        return;\n      case Token.DO:\n        validateDo(n);\n        return;\n      case Token.SWITCH:\n        validateSwitch(n);\n        return;\n      case Token.IF:\n        validateIf(n);\n        return;\n      case Token.VAR:\n        validateVar(n);\n        return;\n      case Token.EXPR_RESULT:\n        validateExprStmt(n);\n        return;\n      case Token.RETURN:\n        validateReturn(n);\n        return;\n      case Token.THROW:\n        validateThrow(n);\n        return;\n      case Token.TRY:\n        validateTry(n);\n        return;\n      case Token.BREAK:\n        validateBreak(n);\n        return;\n      case Token.CONTINUE:\n        validateContinue(n);\n        return;\n      case Token.EMPTY:\n        validateChildless(n);\n        return;\n      case Token.DEBUGGER:\n        validateChildless(n);\n        return;\n      default:\n        violation(\"Expected statement but was \"\n            + Node.tokenToName(n.getType()) + \".\", n);\n    }\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "AstValidator.validateVar",
    "class_name": "com.google.javascript.jscomp.AstValidator",
    "signature": "com.google.javascript.jscomp.AstValidator.validateVar(Node)",
    "snippet": "  private void validateVar(Node n) {\n    validateNodeType(Token.VAR, n);\n    this.validateMinimumChildCount(n, 1);\n    for (Node c = n.getFirstChild(); c != null; c = c.getNext()) {\n      // Don't use the validateName here as the NAME is allowed to have\n      // a child.\n      validateNodeType(Token.NAME, c);\n      validateNonEmptyString(c);\n      validateMaximumChildCount(c, 1);\n      if (c.hasChildren()) {\n        validateExpression(c.getFirstChild());\n      }\n    }\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "BasicErrorManager.generateReport",
    "class_name": "com.google.javascript.jscomp.BasicErrorManager",
    "signature": "com.google.javascript.jscomp.BasicErrorManager.generateReport()",
    "snippet": "  public void generateReport() {\n    for (ErrorWithLevel message : messages) {\n      println(message.level, message.error);\n    }\n    printSummary();\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "BasicErrorManager.getErrorCount",
    "class_name": "com.google.javascript.jscomp.BasicErrorManager",
    "signature": "com.google.javascript.jscomp.BasicErrorManager.getErrorCount()",
    "snippet": "  public int getErrorCount() {\n    return errorCount;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "BasicErrorManager.getErrors",
    "class_name": "com.google.javascript.jscomp.BasicErrorManager",
    "signature": "com.google.javascript.jscomp.BasicErrorManager.getErrors()",
    "snippet": "  public JSError[] getErrors() {\n    return toArray(CheckLevel.ERROR);\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "BasicErrorManager.getTypedPercent",
    "class_name": "com.google.javascript.jscomp.BasicErrorManager",
    "signature": "com.google.javascript.jscomp.BasicErrorManager.getTypedPercent()",
    "snippet": "  public double getTypedPercent() {\n    return typedPercent;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "BasicErrorManager.getWarningCount",
    "class_name": "com.google.javascript.jscomp.BasicErrorManager",
    "signature": "com.google.javascript.jscomp.BasicErrorManager.getWarningCount()",
    "snippet": "  public int getWarningCount() {\n    return warningCount;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "BasicErrorManager.getWarnings",
    "class_name": "com.google.javascript.jscomp.BasicErrorManager",
    "signature": "com.google.javascript.jscomp.BasicErrorManager.getWarnings()",
    "snippet": "  public JSError[] getWarnings() {\n    return toArray(CheckLevel.WARNING);\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "BasicErrorManager.report",
    "class_name": "com.google.javascript.jscomp.BasicErrorManager",
    "signature": "com.google.javascript.jscomp.BasicErrorManager.report(CheckLevel,JSError)",
    "snippet": "  public void report(CheckLevel level, JSError error) {\n    if (messages.add(new ErrorWithLevel(error, level))) {\n      if (level == CheckLevel.ERROR) {\n        errorCount++;\n      } else if (level == CheckLevel.WARNING) {\n        warningCount++;\n      }\n    }\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "BasicErrorManager.setTypedPercent",
    "class_name": "com.google.javascript.jscomp.BasicErrorManager",
    "signature": "com.google.javascript.jscomp.BasicErrorManager.setTypedPercent(double)",
    "snippet": "  public void setTypedPercent(double typedPercent) {\n    this.typedPercent = typedPercent;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "BasicErrorManager.toArray",
    "class_name": "com.google.javascript.jscomp.BasicErrorManager",
    "signature": "com.google.javascript.jscomp.BasicErrorManager.toArray(CheckLevel)",
    "snippet": "  private JSError[] toArray(CheckLevel level) {\n    List<JSError> errors = new ArrayList<JSError>(messages.size());\n    for (ErrorWithLevel p : messages) {\n      if (p.level == level) {\n        errors.add(p.error);\n      }\n    }\n    return errors.toArray(new JSError[errors.size()]);\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "LeveledJSErrorComparator.compare",
    "class_name": "com.google.javascript.jscomp.BasicErrorManager$LeveledJSErrorComparator",
    "signature": "com.google.javascript.jscomp.BasicErrorManager$LeveledJSErrorComparator.compare(ErrorWithLevel,ErrorWithLevel)",
    "snippet": "    public int compare(ErrorWithLevel p1, ErrorWithLevel p2) {\n      // null is the smallest value\n      if (p2 == null) {\n        if (p1 == null) {\n          return 0;\n        } else {\n          return P1_GT_P2;\n        }\n      }\n\n      // check level\n      if (p1.level != p2.level) {\n        return p2.level.compareTo(p1.level);\n      }\n\n      // sourceName comparison\n      String source1 = p1.error.sourceName;\n      String source2 = p2.error.sourceName;\n      if (source1 != null && source2 != null) {\n        int sourceCompare = source1.compareTo(source2);\n        if (sourceCompare != 0) {\n          return sourceCompare;\n        }\n      } else if (source1 == null && source2 != null) {\n        return P1_LT_P2;\n      } else if (source1 != null && source2 == null) {\n        return P1_GT_P2;\n      }\n      // lineno comparison\n      int lineno1 = p1.error.lineNumber;\n      int lineno2 = p2.error.lineNumber;\n      if (lineno1 != lineno2) {\n        return lineno1 - lineno2;\n      } else if (lineno1 < 0 && 0 <= lineno2) {\n        return P1_LT_P2;\n      } else if (0 <= lineno1 && lineno2 < 0) {\n        return P1_GT_P2;\n      }\n      // charno comparison\n      int charno1 = p1.error.getCharno();\n      int charno2 = p2.error.getCharno();\n      if (charno1 != charno2) {\n        return charno1 - charno2;\n      } else if (charno1 < 0 && 0 <= charno2) {\n        return P1_LT_P2;\n      } else if (0 <= charno1 && charno2 < 0) {\n        return P1_GT_P2;\n      }\n      // description\n      return p1.error.description.compareTo(p2.error.description);\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "ChainableReverseAbstractInterpreter.ChainableReverseAbstractInterpreter",
    "class_name": "com.google.javascript.jscomp.ChainableReverseAbstractInterpreter",
    "signature": "com.google.javascript.jscomp.ChainableReverseAbstractInterpreter.ChainableReverseAbstractInterpreter(CodingConvention,JSTypeRegistry)",
    "snippet": "  ChainableReverseAbstractInterpreter(CodingConvention convention,\n      JSTypeRegistry typeRegistry) {\n    Preconditions.checkNotNull(convention);\n    this.convention = convention;\n    this.typeRegistry = typeRegistry;\n    firstLink = this;\n    nextLink = null;\n  }",
    "comment": " Constructs an interpreter, which is the only link in a chain. Interpreters can be appended using {@link #append}. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "ChainableReverseAbstractInterpreter.append",
    "class_name": "com.google.javascript.jscomp.ChainableReverseAbstractInterpreter",
    "signature": "com.google.javascript.jscomp.ChainableReverseAbstractInterpreter.append(ChainableReverseAbstractInterpreter)",
    "snippet": "  ChainableReverseAbstractInterpreter append(\n      ChainableReverseAbstractInterpreter lastLink) {\n    Preconditions.checkArgument(lastLink.nextLink == null);\n    this.nextLink = lastLink;\n    lastLink.firstLink = this.firstLink;\n    return lastLink;\n  }",
    "comment": " Appends a link to {@code this}, returning the updated last link. <p> The pattern {@code new X().append(new Y())...append(new Z())} forms a chain starting with X, then Y, then ... Z. @param lastLink a chainable interpreter, with no next link @return the updated last link ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "ChainableReverseAbstractInterpreter.getFirst",
    "class_name": "com.google.javascript.jscomp.ChainableReverseAbstractInterpreter",
    "signature": "com.google.javascript.jscomp.ChainableReverseAbstractInterpreter.getFirst()",
    "snippet": "  ChainableReverseAbstractInterpreter getFirst() {\n    return firstLink;\n  }",
    "comment": " Gets the first link of this chain. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "CheckAccessControls.CheckAccessControls",
    "class_name": "com.google.javascript.jscomp.CheckAccessControls",
    "signature": "com.google.javascript.jscomp.CheckAccessControls.CheckAccessControls(AbstractCompiler)",
    "snippet": "  CheckAccessControls(AbstractCompiler compiler) {\n    this.compiler = compiler;\n    this.validator = compiler.getTypeValidator();\n    this.initializedConstantProperties = HashMultimap.create();\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "CheckAccessControls.checkConstantProperty",
    "class_name": "com.google.javascript.jscomp.CheckAccessControls",
    "signature": "com.google.javascript.jscomp.CheckAccessControls.checkConstantProperty(NodeTraversal,Node)",
    "snippet": "  private void checkConstantProperty(NodeTraversal t,\n      Node getprop) {\n    // Check whether the property is modified\n    Node parent = getprop.getParent();\n    boolean isDelete = parent.getType() == Token.DELPROP;\n    if (!(NodeUtil.isAssignmentOp(parent) && parent.getFirstChild() == getprop)\n        && (parent.getType() != Token.INC) && (parent.getType() != Token.DEC)\n        && !isDelete) {\n      return;\n    }\n\n    ObjectType objectType =\n      ObjectType.cast(dereference(getprop.getFirstChild().getJSType()));\n    String propertyName = getprop.getLastChild().getString();\n\n    boolean isConstant = isPropertyDeclaredConstant(objectType, propertyName);\n\n    // Check whether constant properties are reassigned\n    if (isConstant) {\n      if (isDelete) {\n        compiler.report(\n            t.makeError(getprop, CONST_PROPERTY_DELETED, propertyName));\n        return;\n      }\n\n      ObjectType oType = objectType;\n      while (oType != null) {\n        if (oType.hasReferenceName()) {\n          if (initializedConstantProperties.containsEntry(\n                  oType.getReferenceName(), propertyName)) {\n            compiler.report(\n                t.makeError(getprop, CONST_PROPERTY_REASSIGNED_VALUE,\n                    propertyName));\n            break;\n          }\n        }\n        oType = oType.getImplicitPrototype();\n      }\n\n      Preconditions.checkState(objectType.hasReferenceName());\n      initializedConstantProperties.put(objectType.getReferenceName(),\n          propertyName);\n\n      // Add the prototype when we're looking at an instance object\n      if (objectType.isInstanceType()) {\n        ObjectType prototype = objectType.getImplicitPrototype();\n        if (prototype != null) {\n          if (prototype.hasProperty(propertyName)\n              && prototype.hasReferenceName()) {\n            initializedConstantProperties.put(prototype.getReferenceName(),\n                propertyName);\n          }\n        }\n      }\n    }\n  }",
    "comment": " Determines whether the given property with @const tag got reassigned @param t The current traversal. @param getprop The getprop node. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "CheckAccessControls.checkNameDeprecation",
    "class_name": "com.google.javascript.jscomp.CheckAccessControls",
    "signature": "com.google.javascript.jscomp.CheckAccessControls.checkNameDeprecation(NodeTraversal,Node,Node)",
    "snippet": "  private void checkNameDeprecation(NodeTraversal t, Node n, Node parent) {\n    // Don't bother checking definitions or constructors.\n    if (parent.getType() == Token.FUNCTION || parent.getType() == Token.VAR ||\n        parent.getType() == Token.NEW) {\n      return;\n    }\n\n    Scope.Var var = t.getScope().getVar(n.getString());\n    JSDocInfo docInfo = var == null ? null : var.getJSDocInfo();\n\n    if (docInfo != null && docInfo.isDeprecated() &&\n        shouldEmitDeprecationWarning(t, n, parent)) {\n\n      if (docInfo.getDeprecationReason() != null) {\n        compiler.report(\n            t.makeError(n, DEPRECATED_NAME_REASON, n.getString(),\n                docInfo.getDeprecationReason()));\n      } else {\n        compiler.report(\n            t.makeError(n, DEPRECATED_NAME, n.getString()));\n      }\n    }\n  }",
    "comment": " Checks the given NAME node to ensure that access restrictions are obeyed. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "CheckAccessControls.checkNameVisibility",
    "class_name": "com.google.javascript.jscomp.CheckAccessControls",
    "signature": "com.google.javascript.jscomp.CheckAccessControls.checkNameVisibility(NodeTraversal,Node,Node)",
    "snippet": "  private void checkNameVisibility(NodeTraversal t, Node name, Node parent) {\n    Var var = t.getScope().getVar(name.getString());\n    if (var != null) {\n      JSDocInfo docInfo = var.getJSDocInfo();\n      if (docInfo != null) {\n        // If a name is private, make sure that we're in the same file.\n        Visibility visibility = docInfo.getVisibility();\n        if (visibility == Visibility.PRIVATE &&\n            !t.getInput().getName().equals(docInfo.getSourceName())) {\n          if (docInfo.isConstructor() &&\n              isValidPrivateConstructorAccess(parent)) {\n            return;\n          }\n\n          compiler.report(\n              t.makeError(name, BAD_PRIVATE_GLOBAL_ACCESS,\n                  name.getString(), docInfo.getSourceName()));\n        }\n      }\n    }\n  }",
    "comment": " Determines whether the given name is visible in the current context. @param t The current traversal. @param name The name node. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "CheckAccessControls.checkPropertyDeprecation",
    "class_name": "com.google.javascript.jscomp.CheckAccessControls",
    "signature": "com.google.javascript.jscomp.CheckAccessControls.checkPropertyDeprecation(NodeTraversal,Node,Node)",
    "snippet": "  private void checkPropertyDeprecation(NodeTraversal t, Node n, Node parent) {\n    // Don't bother checking constructors.\n    if (parent.getType() == Token.NEW) {\n      return;\n    }\n\n    ObjectType objectType =\n        ObjectType.cast(dereference(n.getFirstChild().getJSType()));\n    String propertyName = n.getLastChild().getString();\n\n    if (objectType != null) {\n      String deprecationInfo\n          = getPropertyDeprecationInfo(objectType, propertyName);\n\n      if (deprecationInfo != null &&\n          shouldEmitDeprecationWarning(t, n, parent)) {\n\n        if (!deprecationInfo.isEmpty()) {\n          compiler.report(\n              t.makeError(n, DEPRECATED_PROP_REASON, propertyName,\n                  validator.getReadableJSTypeName(n.getFirstChild(), true),\n                  deprecationInfo));\n        } else {\n          compiler.report(\n              t.makeError(n, DEPRECATED_PROP, propertyName,\n                  validator.getReadableJSTypeName(n.getFirstChild(), true)));\n        }\n      }\n    }\n  }",
    "comment": " Checks the given GETPROP node to ensure that access restrictions are obeyed. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "CheckAccessControls.checkPropertyVisibility",
    "class_name": "com.google.javascript.jscomp.CheckAccessControls",
    "signature": "com.google.javascript.jscomp.CheckAccessControls.checkPropertyVisibility(NodeTraversal,Node,Node)",
    "snippet": "  private void checkPropertyVisibility(NodeTraversal t,\n      Node getprop, Node parent) {\n    ObjectType objectType =\n        ObjectType.cast(dereference(getprop.getFirstChild().getJSType()));\n    String propertyName = getprop.getLastChild().getString();\n\n    if (objectType != null) {\n      // Is this a normal property access, or are we trying to override\n      // an existing property?\n      boolean isOverride = parent.getJSDocInfo() != null &&\n          parent.getType() == Token.ASSIGN &&\n          parent.getFirstChild() == getprop;\n\n      // Find the lowest property defined on a class with visibility\n      // information.\n      if (isOverride) {\n        objectType = objectType.getImplicitPrototype();\n      }\n      JSDocInfo docInfo = null;\n      for (; objectType != null;\n           objectType = objectType.getImplicitPrototype()) {\n        docInfo = objectType.getOwnPropertyJSDocInfo(propertyName);\n        if (docInfo != null &&\n            docInfo.getVisibility() != Visibility.INHERITED) {\n          break;\n        }\n      }\n\n      if (objectType == null) {\n        // We couldn't find a visibility modifier; assume it's public.\n        return;\n      }\n\n      boolean sameInput =\n          t.getInput().getName().equals(docInfo.getSourceName());\n      Visibility visibility = docInfo.getVisibility();\n      JSType ownerType = normalizeClassType(objectType);\n      if (isOverride) {\n        // Check an ASSIGN statement that's trying to override a property\n        // on a superclass.\n        JSDocInfo overridingInfo = parent.getJSDocInfo();\n        Visibility overridingVisibility = overridingInfo == null ?\n            Visibility.INHERITED : overridingInfo.getVisibility();\n\n        // Check that (a) the property *can* be overridden, and\n        // (b) that the visibility of the override is the same as the\n        // visibility of the original property.\n        if (visibility == Visibility.PRIVATE && !sameInput) {\n          compiler.report(\n              t.makeError(getprop, PRIVATE_OVERRIDE,\n                  objectType.toString()));\n        } else if (overridingVisibility != Visibility.INHERITED &&\n            overridingVisibility != visibility) {\n          compiler.report(\n              t.makeError(getprop, VISIBILITY_MISMATCH,\n                  visibility.name(), objectType.toString(),\n                  overridingVisibility.name()));\n        }\n      } else {\n        if (sameInput) {\n          // private access is always allowed in the same file.\n          return;\n        } else if (visibility == Visibility.PRIVATE &&\n            (currentClass == null || ownerType.differsFrom(currentClass))) {\n          if (docInfo.isConstructor() &&\n              isValidPrivateConstructorAccess(parent)) {\n            return;\n          }\n\n          // private access is not allowed outside the file from a different\n          // enclosing class.\n          compiler.report(\n              t.makeError(getprop,\n                  BAD_PRIVATE_PROPERTY_ACCESS,\n                  propertyName,\n                  validator.getReadableJSTypeName(\n                      getprop.getFirstChild(), true)));\n        } else if (visibility == Visibility.PROTECTED) {\n          // There are 3 types of legal accesses of a protected property:\n          // 1) Accesses in the same file\n          // 2) Overriding the property in a subclass\n          // 3) Accessing the property from inside a subclass\n          // The first two have already been checked for.\n          if (currentClass == null || !currentClass.isSubtype(ownerType)) {\n            compiler.report(\n                t.makeError(getprop,  BAD_PROTECTED_PROPERTY_ACCESS,\n                    propertyName,\n                    validator.getReadableJSTypeName(\n                        getprop.getFirstChild(), true)));\n          }\n        }\n      }\n    }\n  }",
    "comment": " Determines whether the given property is visible in the current context. @param t The current traversal. @param getprop The getprop node. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "CheckAccessControls.dereference",
    "class_name": "com.google.javascript.jscomp.CheckAccessControls",
    "signature": "com.google.javascript.jscomp.CheckAccessControls.dereference(JSType)",
    "snippet": "  private static JSType dereference(JSType type) {\n    return type == null ? null : type.dereference();\n  }",
    "comment": " Dereference a type, autoboxing it and filtering out null. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "CheckAccessControls.enterScope",
    "class_name": "com.google.javascript.jscomp.CheckAccessControls",
    "signature": "com.google.javascript.jscomp.CheckAccessControls.enterScope(NodeTraversal)",
    "snippet": "  public void enterScope(NodeTraversal t) {\n    if (!t.inGlobalScope()) {\n      Node n = t.getScopeRoot();\n      Node parent = n.getParent();\n      if (isDeprecatedFunction(n, parent)) {\n        deprecatedDepth++;\n      }\n\n      if (methodDepth == 0) {\n        currentClass = getClassOfMethod(n, parent);\n      }\n      methodDepth++;\n    }\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "CheckAccessControls.exitScope",
    "class_name": "com.google.javascript.jscomp.CheckAccessControls",
    "signature": "com.google.javascript.jscomp.CheckAccessControls.exitScope(NodeTraversal)",
    "snippet": "  public void exitScope(NodeTraversal t) {\n    if (!t.inGlobalScope()) {\n      Node n = t.getScopeRoot();\n      Node parent = n.getParent();\n      if (isDeprecatedFunction(n, parent)) {\n        deprecatedDepth--;\n      }\n\n      methodDepth--;\n      if (methodDepth == 0) {\n        currentClass = null;\n      }\n    }\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "CheckAccessControls.getClassOfMethod",
    "class_name": "com.google.javascript.jscomp.CheckAccessControls",
    "signature": "com.google.javascript.jscomp.CheckAccessControls.getClassOfMethod(Node,Node)",
    "snippet": "  private JSType getClassOfMethod(Node n, Node parent) {\n    if (parent.getType() == Token.ASSIGN) {\n      Node lValue = parent.getFirstChild();\n      if (lValue.isQualifiedName()) {\n        if (lValue.getType() == Token.GETPROP) {\n          // We have an assignment of the form \"a.b = ...\".\n          JSType lValueType = lValue.getJSType();\n          if (lValueType != null && lValueType.isConstructor()) {\n            // If a.b is a constructor, then everything in this function\n            // belongs to the \"a.b\" type.\n            return ((FunctionType) lValueType).getInstanceType();\n          } else {\n            // If a.b is not a constructor, then treat this as a method\n            // of whatever type is on \"a\".\n            return normalizeClassType(lValue.getFirstChild().getJSType());\n          }\n        } else {\n          // We have an assignment of the form \"a = ...\", so pull the\n          // type off the \"a\".\n          return normalizeClassType(lValue.getJSType());\n        }\n      }\n    } else if (NodeUtil.isFunctionDeclaration(n) ||\n               parent.getType() == Token.NAME) {\n      return normalizeClassType(n.getJSType());\n    }\n\n    return null;\n  }",
    "comment": " Gets the type of the class that \"owns\" a method, or null if we know that its un-owned. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "CheckAccessControls.getPropertyDeprecationInfo",
    "class_name": "com.google.javascript.jscomp.CheckAccessControls",
    "signature": "com.google.javascript.jscomp.CheckAccessControls.getPropertyDeprecationInfo(ObjectType,String)",
    "snippet": "  private static String getPropertyDeprecationInfo(ObjectType type,\n                                                   String prop) {\n    JSDocInfo info = type.getOwnPropertyJSDocInfo(prop);\n    if (info != null && info.isDeprecated()) {\n      if (info.getDeprecationReason() != null) {\n        return info.getDeprecationReason();\n      }\n\n      return \"\";\n    }\n    ObjectType implicitProto = type.getImplicitPrototype();\n    if (implicitProto != null) {\n      return getPropertyDeprecationInfo(implicitProto, prop);\n    }\n    return null;\n  }",
    "comment": " Returns the deprecation reason for the property if it is marked as being deprecated. Returns empty string if the property is deprecated but no reason was given. Returns null if the property is not deprecated. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "CheckAccessControls.getTypeDeprecationInfo",
    "class_name": "com.google.javascript.jscomp.CheckAccessControls",
    "signature": "com.google.javascript.jscomp.CheckAccessControls.getTypeDeprecationInfo(JSType)",
    "snippet": "  private static String getTypeDeprecationInfo(JSType type) {\n    if (type == null) {\n      return null;\n    }\n\n    JSDocInfo info = type.getJSDocInfo();\n    if (info != null && info.isDeprecated()) {\n      if (info.getDeprecationReason() != null) {\n        return info.getDeprecationReason();\n      }\n      return \"\";\n    }\n    ObjectType objType = ObjectType.cast(type);\n    if (objType != null) {\n      ObjectType implicitProto = objType.getImplicitPrototype();\n      if (implicitProto != null) {\n        return getTypeDeprecationInfo(implicitProto);\n      }\n    }\n    return null;\n  }",
    "comment": " Returns the deprecation reason for the type if it is marked as being deprecated. Returns empty string if the type is deprecated but no reason was given. Returns null if the type is not deprecated. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "CheckAccessControls.isDeprecatedFunction",
    "class_name": "com.google.javascript.jscomp.CheckAccessControls",
    "signature": "com.google.javascript.jscomp.CheckAccessControls.isDeprecatedFunction(Node,Node)",
    "snippet": "  private static boolean isDeprecatedFunction(Node n, Node parent) {\n    if (n.getType() == Token.FUNCTION) {\n      JSType type = n.getJSType();\n      if (type != null) {\n        return getTypeDeprecationInfo(type) != null;\n      }\n    }\n\n    return false;\n  }",
    "comment": " Returns whether this is a function node annotated as deprecated. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "CheckAccessControls.isPropertyDeclaredConstant",
    "class_name": "com.google.javascript.jscomp.CheckAccessControls",
    "signature": "com.google.javascript.jscomp.CheckAccessControls.isPropertyDeclaredConstant(ObjectType,String)",
    "snippet": "  private static boolean isPropertyDeclaredConstant(\n      ObjectType objectType, String prop) {\n    for (;\n         // Only objects with reference names can have constant properties.\n         objectType != null && objectType.hasReferenceName();\n\n         objectType = objectType.getImplicitPrototype()) {\n      JSDocInfo docInfo = objectType.getOwnPropertyJSDocInfo(prop);\n      if (docInfo != null && docInfo.isConstant()) {\n        return true;\n      }\n    }\n    return false;\n  }",
    "comment": " Returns if a property is declared constant. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "CheckAccessControls.normalizeClassType",
    "class_name": "com.google.javascript.jscomp.CheckAccessControls",
    "signature": "com.google.javascript.jscomp.CheckAccessControls.normalizeClassType(JSType)",
    "snippet": "  private JSType normalizeClassType(JSType type) {\n    if (type == null || type.isUnknownType()) {\n      return type;\n    } else if (type.isConstructor()) {\n      return ((FunctionType) type).getInstanceType();\n    } else if (type.isFunctionPrototypeType()) {\n      FunctionType owner = ((FunctionPrototypeType) type).getOwnerFunction();\n      if (owner.isConstructor()) {\n        return owner.getInstanceType();\n      }\n    }\n    return type;\n  }",
    "comment": " Normalize the type of a constructor, its instance, and its prototype all down to the same type (the instance type). ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "CheckAccessControls.process",
    "class_name": "com.google.javascript.jscomp.CheckAccessControls",
    "signature": "com.google.javascript.jscomp.CheckAccessControls.process(Node,Node)",
    "snippet": "  @Override\n  public void process(Node externs, Node root) {\n    NodeTraversal.traverse(compiler, root, this);\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "CheckAccessControls.shouldTraverse",
    "class_name": "com.google.javascript.jscomp.CheckAccessControls",
    "signature": "com.google.javascript.jscomp.CheckAccessControls.shouldTraverse(NodeTraversal,Node,Node)",
    "snippet": "  public boolean shouldTraverse(NodeTraversal t, Node n, Node parent) {\n    return true;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "CheckAccessControls.visit",
    "class_name": "com.google.javascript.jscomp.CheckAccessControls",
    "signature": "com.google.javascript.jscomp.CheckAccessControls.visit(NodeTraversal,Node,Node)",
    "snippet": "  public void visit(NodeTraversal t, Node n, Node parent) {\n    switch (n.getType()) {\n      case Token.NAME:\n        checkNameDeprecation(t, n, parent);\n        checkNameVisibility(t, n, parent);\n        break;\n      case Token.GETPROP:\n        checkPropertyDeprecation(t, n, parent);\n        checkPropertyVisibility(t, n, parent);\n        checkConstantProperty(t, n);\n        break;\n      case Token.NEW:\n        checkConstructorDeprecation(t, n, parent);\n        break;\n    }\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "CheckAccidentalSemicolon.CheckAccidentalSemicolon",
    "class_name": "com.google.javascript.jscomp.CheckAccidentalSemicolon",
    "signature": "com.google.javascript.jscomp.CheckAccidentalSemicolon.CheckAccidentalSemicolon(CheckLevel)",
    "snippet": "  CheckAccidentalSemicolon(CheckLevel level) {\n    this.level = level;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "CheckAccidentalSemicolon.visit",
    "class_name": "com.google.javascript.jscomp.CheckAccidentalSemicolon",
    "signature": "com.google.javascript.jscomp.CheckAccidentalSemicolon.visit(NodeTraversal,Node,Node)",
    "snippet": "  public void visit(NodeTraversal t, Node n, Node parent) {\n    Node child;\n    switch (n.getType()) {\n      case Token.IF:\n        child = n.getFirstChild().getNext();  // skip the condition child\n        break;\n\n      case Token.WHILE:\n      case Token.FOR:\n        child = NodeUtil.getLoopCodeBlock(n);\n        break;\n\n      default:\n        return;  // don't check other types\n    }\n\n    // semicolons cause VOID children. Empty blocks are allowed because\n    // that's usually intentional, especially with loops.\n    for (; child != null; child = child.getNext()) {\n      if ((child.getType() == Token.BLOCK) && (!child.hasChildren())) {\n        // Only warn on empty blocks that replaced EMPTY nodes.  BLOCKs with no\n        // children are considered OK.\n        if (child.wasEmptyNode()) {\n          t.getCompiler().report(\n              t.makeError(n, level, SUSPICIOUS_SEMICOLON));\n        }\n      }\n    }\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "CheckGlobalNames.CheckGlobalNames",
    "class_name": "com.google.javascript.jscomp.CheckGlobalNames",
    "signature": "com.google.javascript.jscomp.CheckGlobalNames.CheckGlobalNames(AbstractCompiler,CheckLevel)",
    "snippet": "  CheckGlobalNames(AbstractCompiler compiler, CheckLevel level) {\n    this.compiler = compiler;\n    this.level = level;\n  }",
    "comment": " Creates a pass to check global name references at the given warning level. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "CheckGlobalNames.checkDescendantNames",
    "class_name": "com.google.javascript.jscomp.CheckGlobalNames",
    "signature": "com.google.javascript.jscomp.CheckGlobalNames.checkDescendantNames(Name,boolean)",
    "snippet": "  private void checkDescendantNames(Name name, boolean nameIsDefined) {\n    if (name.props != null) {\n      for (Name prop : name.props) {\n        // if the ancestor of a property is not defined, then we should emit\n        // warnings for all references to the property.\n        boolean propIsDefined = false;\n        if (nameIsDefined) {\n          // if the ancestor of a property is defined, then let's check that\n          // the property is also explicitly defined if it needs to be.\n          propIsDefined = (!propertyMustBeInitializedByFullName(prop) ||\n              prop.globalSets + prop.localSets > 0);\n        }\n\n        validateName(prop, propIsDefined);\n        checkDescendantNames(prop, propIsDefined);\n      }\n    }\n  }",
    "comment": " Checks to make sure all the descendants of a name are defined if they are referenced.  @param name A global name. @param nameIsDefined If true, {@code name} is defined. Otherwise, it's undefined, and any references to descendant names should emit warnings. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "CheckGlobalNames.injectNamespace",
    "class_name": "com.google.javascript.jscomp.CheckGlobalNames",
    "signature": "com.google.javascript.jscomp.CheckGlobalNames.injectNamespace(GlobalNamespace)",
    "snippet": "  CheckGlobalNames injectNamespace(GlobalNamespace namespace) {\n    this.namespace = namespace;\n    return this;\n  }",
    "comment": " Injects a pre-computed global namespace, so that the same namespace can be re-used for multiple check passes. Returns this for easy chaining. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "CheckGlobalNames.process",
    "class_name": "com.google.javascript.jscomp.CheckGlobalNames",
    "signature": "com.google.javascript.jscomp.CheckGlobalNames.process(Node,Node)",
    "snippet": "  public void process(Node externs, Node root) {\n    // TODO(nicksantos): Let CollapseProperties and CheckGlobalNames\n    // share a namespace.\n    if (namespace == null) {\n      namespace = new GlobalNamespace(compiler, root);\n    }\n\n    for (Name name : namespace.getNameForest()) {\n      checkDescendantNames(name, name.globalSets + name.localSets > 0);\n    }\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "CheckGlobalThis.CheckGlobalThis",
    "class_name": "com.google.javascript.jscomp.CheckGlobalThis",
    "signature": "com.google.javascript.jscomp.CheckGlobalThis.CheckGlobalThis(AbstractCompiler)",
    "snippet": "  CheckGlobalThis(AbstractCompiler compiler) {\n    this.compiler = compiler;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "CheckGlobalThis.getFunctionJsDocInfo",
    "class_name": "com.google.javascript.jscomp.CheckGlobalThis",
    "signature": "com.google.javascript.jscomp.CheckGlobalThis.getFunctionJsDocInfo(Node)",
    "snippet": "  private JSDocInfo getFunctionJsDocInfo(Node n) {\n    JSDocInfo jsDoc = n.getJSDocInfo();\n    Node parent = n.getParent();\n    if (jsDoc == null) {\n      int parentType = parent.getType();\n      if (parentType == Token.NAME || parentType == Token.ASSIGN) {\n        jsDoc = parent.getJSDocInfo();\n        if (jsDoc == null && parentType == Token.NAME) {\n          Node gramps = parent.getParent();\n          if (gramps.getType() == Token.VAR) {\n            jsDoc = gramps.getJSDocInfo();\n          }\n        }\n      }\n    }\n    return jsDoc;\n  }",
    "comment": " Gets a function's JSDoc information, if it has any. Checks for a few patterns (ellipses show where JSDoc would be): <pre> ... function() {} ... x = function() {}; var ... x = function() {}; ... var x = function() {}; </pre> ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "CheckGlobalThis.shouldReportThis",
    "class_name": "com.google.javascript.jscomp.CheckGlobalThis",
    "signature": "com.google.javascript.jscomp.CheckGlobalThis.shouldReportThis(Node,Node)",
    "snippet": "  private boolean shouldReportThis(Node n, Node parent) {\n    if (assignLhsChild != null) {\n      // Always report a THIS on the left side of an assign.\n      return true;\n    }\n\n    // Also report a THIS with a property access.\n    return parent != null && NodeUtil.isGet(parent);\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "CheckGlobalThis.shouldTraverse",
    "class_name": "com.google.javascript.jscomp.CheckGlobalThis",
    "signature": "com.google.javascript.jscomp.CheckGlobalThis.shouldTraverse(NodeTraversal,Node,Node)",
    "snippet": "  public boolean shouldTraverse(NodeTraversal t, Node n, Node parent) {\n\n    if (n.getType() == Token.FUNCTION) {\n      // Don't traverse functions that are constructors or have the @this\n      // or @override annotation.\n      JSDocInfo jsDoc = getFunctionJsDocInfo(n);\n      if (jsDoc != null &&\n          (jsDoc.isConstructor() ||\n           jsDoc.isInterface() ||\n           jsDoc.hasThisType() ||\n           jsDoc.isOverride())) {\n        return false;\n      }\n\n      // Don't traverse functions unless they would normally\n      // be able to have a @this annotation associated with them. e.g.,\n      // var a = function() { }; // or\n      // function a() {} // or\n      // a.x = function() {}; // or\n      // var a = {x: function() {}};\n      int pType = parent.getType();\n      if (!(pType == Token.BLOCK ||\n            pType == Token.SCRIPT ||\n            pType == Token.NAME ||\n            pType == Token.ASSIGN ||\n\n            // object literal keys\n            pType == Token.STRING)) {\n        return false;\n      }\n\n      // Don't traverse functions that are getting lent to a prototype.\n      Node gramps = parent.getParent();\n      if (NodeUtil.isObjectLitKey(parent, gramps)) {\n        JSDocInfo maybeLends = gramps.getJSDocInfo();\n        if (maybeLends != null &&\n            maybeLends.getLendsName() != null &&\n            maybeLends.getLendsName().endsWith(\".prototype\")) {\n          return false;\n        }\n      }\n    }\n\n    if (parent != null && parent.getType() == Token.ASSIGN) {\n      Node lhs = parent.getFirstChild();\n      Node rhs = lhs.getNext();\n\n      if (n == lhs) {\n        // Always traverse the left side of the assignment. To handle\n        // nested assignments properly (e.g., (a = this).property = c;),\n        // assignLhsChild should not be overridden.\n        if (assignLhsChild == null) {\n          assignLhsChild = lhs;\n        }\n      } else {\n        // Only traverse the right side if it's not an assignment to a prototype\n        // property or subproperty.\n        if (NodeUtil.isGet(lhs)) {\n          if (lhs.getType() == Token.GETPROP &&\n              lhs.getLastChild().getString().equals(\"prototype\")) {\n            return false;\n          }\n          Node llhs = lhs.getFirstChild();\n          if (llhs.getType() == Token.GETPROP &&\n              llhs.getLastChild().getString().equals(\"prototype\")) {\n            return false;\n          }\n        }\n      }\n    }\n\n    return true;\n  }",
    "comment": " Since this pass reports errors only when a global {@code this} keyword is encountered, there is no reason to traverse non global contexts. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "CheckGlobalThis.visit",
    "class_name": "com.google.javascript.jscomp.CheckGlobalThis",
    "signature": "com.google.javascript.jscomp.CheckGlobalThis.visit(NodeTraversal,Node,Node)",
    "snippet": "  public void visit(NodeTraversal t, Node n, Node parent) {\n    if (n.getType() == Token.THIS && shouldReportThis(n, parent)) {\n      compiler.report(t.makeError(n, GLOBAL_THIS));\n    }\n    if (n == assignLhsChild) {\n      assignLhsChild = null;\n    }\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "CheckLevel.isOn",
    "class_name": "com.google.javascript.jscomp.CheckLevel",
    "signature": "com.google.javascript.jscomp.CheckLevel.isOn()",
    "snippet": "  boolean isOn() {\n    return this != OFF;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "CheckMissingReturn.CheckMissingReturn",
    "class_name": "com.google.javascript.jscomp.CheckMissingReturn",
    "signature": "com.google.javascript.jscomp.CheckMissingReturn.CheckMissingReturn(AbstractCompiler,CheckLevel)",
    "snippet": "  CheckMissingReturn(AbstractCompiler compiler, CheckLevel level) {\n    this.compiler = compiler;\n    this.level = level;\n  }",
    "comment": " @param level level of severity to report when a missing return statement is discovered ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "CheckMissingReturn.enterScope",
    "class_name": "com.google.javascript.jscomp.CheckMissingReturn",
    "signature": "com.google.javascript.jscomp.CheckMissingReturn.enterScope(NodeTraversal)",
    "snippet": "  @Override\n  public void enterScope(NodeTraversal t) {\n    JSType returnType = explicitReturnExpected(t.getScopeRoot());\n    if (returnType == null) {\n      return;\n    }\n\n    if (fastAllPathsReturnCheck(t.getControlFlowGraph())) {\n      return;\n    }\n\n    CheckPathsBetweenNodes<Node, ControlFlowGraph.Branch> test =\n        new CheckPathsBetweenNodes<Node, ControlFlowGraph.Branch>(\n            t.getControlFlowGraph(),\n            t.getControlFlowGraph().getEntry(),\n            t.getControlFlowGraph().getImplicitReturn(),\n            IS_RETURN, GOES_THROUGH_TRUE_CONDITION_PREDICATE);\n\n    if (!test.allPathsSatisfyPredicate()) {\n      compiler.report(\n          t.makeError(t.getScopeRoot(), level,\n              MISSING_RETURN_STATEMENT, returnType.toString()));\n    }\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "CheckMissingReturn.exitScope",
    "class_name": "com.google.javascript.jscomp.CheckMissingReturn",
    "signature": "com.google.javascript.jscomp.CheckMissingReturn.exitScope(NodeTraversal)",
    "snippet": "  @Override\n  public void exitScope(NodeTraversal t) {\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "CheckMissingReturn.explicitReturnExpected",
    "class_name": "com.google.javascript.jscomp.CheckMissingReturn",
    "signature": "com.google.javascript.jscomp.CheckMissingReturn.explicitReturnExpected(Node)",
    "snippet": "  private JSType explicitReturnExpected(Node scope) {\n    JSType scopeType = scope.getJSType();\n\n    if (!(scopeType instanceof FunctionType)) {\n      return null;\n    }\n\n    if (isEmptyFunction(scope)) {\n      return null;\n    }\n\n    JSType returnType = ((FunctionType) scopeType).getReturnType();\n\n    if (returnType == null) {\n      return null;\n    }\n\n    if (!isVoidOrUnknown(returnType)) {\n      return returnType;\n    }\n\n    return null;\n  }",
    "comment": " Determines if the given scope should explicitly return. All functions with non-void or non-unknown return types must have explicit returns. @return If a return type is expected, returns it. Otherwise returns null. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "CheckMissingReturn.isEmptyFunction",
    "class_name": "com.google.javascript.jscomp.CheckMissingReturn",
    "signature": "com.google.javascript.jscomp.CheckMissingReturn.isEmptyFunction(Node)",
    "snippet": "  private static boolean isEmptyFunction(Node function) {\n    return function.getChildCount() == 3 &&\n           !function.getFirstChild().getNext().getNext().hasChildren();\n  }",
    "comment": " @return {@code true} if function represents a JavaScript function with an empty body ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "CheckMissingReturn.isVoidOrUnknown",
    "class_name": "com.google.javascript.jscomp.CheckMissingReturn",
    "signature": "com.google.javascript.jscomp.CheckMissingReturn.isVoidOrUnknown(JSType)",
    "snippet": "  private boolean isVoidOrUnknown(JSType returnType) {\n    final JSType voidType =\n        compiler.getTypeRegistry().getNativeType(JSTypeNative.VOID_TYPE);\n    return voidType.isSubtype(returnType);\n  }",
    "comment": " @return {@code true} if returnType is void, unknown, or a union containing void or unknown ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "CheckMissingReturn.shouldTraverse",
    "class_name": "com.google.javascript.jscomp.CheckMissingReturn",
    "signature": "com.google.javascript.jscomp.CheckMissingReturn.shouldTraverse(NodeTraversal,Node,Node)",
    "snippet": "  @Override\n  public boolean shouldTraverse(\n      NodeTraversal nodeTraversal, Node n, Node parent) {\n    return true;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "CheckMissingReturn.visit",
    "class_name": "com.google.javascript.jscomp.CheckMissingReturn",
    "signature": "com.google.javascript.jscomp.CheckMissingReturn.visit(NodeTraversal,Node,Node)",
    "snippet": "  @Override\n  public void visit(NodeTraversal t, Node n, Node parent) {\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "CheckSideEffects.CheckSideEffects",
    "class_name": "com.google.javascript.jscomp.CheckSideEffects",
    "signature": "com.google.javascript.jscomp.CheckSideEffects.CheckSideEffects(CheckLevel)",
    "snippet": "  CheckSideEffects(CheckLevel level) {\n    this.level = level;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "CheckSideEffects.visit",
    "class_name": "com.google.javascript.jscomp.CheckSideEffects",
    "signature": "com.google.javascript.jscomp.CheckSideEffects.visit(NodeTraversal,Node,Node)",
    "snippet": "  public void visit(NodeTraversal t, Node n, Node parent) {\n    // VOID nodes appear when there are extra semicolons at the BLOCK level.\n    // I've been unable to think of any cases where this indicates a bug,\n    // and apparently some people like keeping these semicolons around,\n    // so we'll allow it.\n    if (n.getType() == Token.EMPTY ||\n        n.getType() == Token.COMMA) {\n      return;\n    }\n\n    if (parent == null)\n      return;\n\n    int pt = parent.getType();\n    if (pt == Token.COMMA) {\n      Node gramps = parent.getParent();\n      if (gramps.getType() == Token.CALL &&\n          parent == gramps.getFirstChild()) {\n        // Semantically, a direct call to eval is different from an indirect\n        // call to an eval. See Ecma-262 S15.1.2.1. So it's ok for the first\n        // expression to a comma to be a no-op if it's used to indirect\n        // an eval.\n        if (n == parent.getFirstChild() &&\n            parent.getChildCount() == 2 &&\n            n.getNext().getType() == Token.NAME &&\n            \"eval\".equals(n.getNext().getString())) {\n          return;\n        }\n      }\n\n      if (n == parent.getLastChild()) {\n        for (Node an : parent.getAncestors()) {\n          int ancestorType = an.getType();\n          if (ancestorType == Token.COMMA)\n            continue;\n          if (ancestorType != Token.EXPR_RESULT &&\n              ancestorType != Token.BLOCK)\n            return;\n          else\n            break;\n        }\n      }\n    } else if (pt != Token.EXPR_RESULT && pt != Token.BLOCK) {\n      if (pt == Token.FOR && parent.getChildCount() == 4 &&\n          (n == parent.getFirstChild() ||\n           n == parent.getFirstChild().getNext().getNext())) {\n        // Fall through and look for warnings for the 1st and 3rd child\n        // of a for.\n      } else {\n        return;  // it might be ok to not have a side-effect\n      }\n    }\n\n    boolean isSimpleOp = NodeUtil.isSimpleOperatorType(n.getType());\n    if (isSimpleOp ||\n        !NodeUtil.mayHaveSideEffects(n, t.getCompiler())) {\n      if (n.isQualifiedName() && n.getJSDocInfo() != null) {\n        // This no-op statement was there so that JSDoc information could\n        // be attached to the name. This check should not complain about it.\n        return;\n      } else if (NodeUtil.isExpressionNode(n)) {\n        // we already reported the problem when we visited the child.\n        return;\n      }\n\n      String msg = \"This code lacks side-effects. Is there a bug?\";\n      if (n.getType() == Token.STRING) {\n        msg = \"Is there a missing '+' on the previous line?\";\n      } else if (isSimpleOp) {\n        msg = \"The result of the '\" + Node.tokenToName(n.getType()) +\n            \"' operator is not being used.\";\n      }\n\n      t.getCompiler().report(\n          t.makeError(n, level, USELESS_CODE_ERROR, msg));\n    }\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "CheckUnreachableCode.CheckUnreachableCode",
    "class_name": "com.google.javascript.jscomp.CheckUnreachableCode",
    "signature": "com.google.javascript.jscomp.CheckUnreachableCode.CheckUnreachableCode(AbstractCompiler,CheckLevel)",
    "snippet": "  CheckUnreachableCode(AbstractCompiler compiler, CheckLevel level) {\n    this.compiler = compiler;\n    this.level = level;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "CheckUnreachableCode.enterScope",
    "class_name": "com.google.javascript.jscomp.CheckUnreachableCode",
    "signature": "com.google.javascript.jscomp.CheckUnreachableCode.enterScope(NodeTraversal)",
    "snippet": "  @Override\n  public void enterScope(NodeTraversal t) {\n    initScope(t.getControlFlowGraph());\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "CheckUnreachableCode.exitScope",
    "class_name": "com.google.javascript.jscomp.CheckUnreachableCode",
    "signature": "com.google.javascript.jscomp.CheckUnreachableCode.exitScope(NodeTraversal)",
    "snippet": "  @Override\n  public void exitScope(NodeTraversal t) {\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "CheckUnreachableCode.initScope",
    "class_name": "com.google.javascript.jscomp.CheckUnreachableCode",
    "signature": "com.google.javascript.jscomp.CheckUnreachableCode.initScope(ControlFlowGraph)",
    "snippet": "  private void initScope(ControlFlowGraph<Node> controlFlowGraph) {\n    new GraphReachability<Node, ControlFlowGraph.Branch>(\n        controlFlowGraph, new ReachablePredicate()).compute(\n            controlFlowGraph.getEntry().getValue());\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "CheckUnreachableCode.shouldTraverse",
    "class_name": "com.google.javascript.jscomp.CheckUnreachableCode",
    "signature": "com.google.javascript.jscomp.CheckUnreachableCode.shouldTraverse(NodeTraversal,Node,Node)",
    "snippet": "  @Override\n  public boolean shouldTraverse(NodeTraversal t, Node n, Node parent) {\n    GraphNode<Node, Branch> gNode = t.getControlFlowGraph().getNode(n);\n    if (gNode != null && gNode.getAnnotation() != GraphReachability.REACHABLE) {\n\n      // Only report error when there are some line number informations.\n      // There are synthetic nodes with no line number informations, nodes\n      // introduce by other passes (although not likely since this pass should\n      // be executed early) or some rhino bug.\n      if (n.getLineno() != -1 &&\n          // Allow spurious semi-colons and spurious breaks.\n          n.getType() != Token.EMPTY && n.getType() != Token.BREAK) {\n        compiler.report(t.makeError(n, level, UNREACHABLE_CODE));\n        // From now on, we are going to assume the user fixed the error and not\n        // give more warning related to code section reachable from this node.\n        new GraphReachability<Node, ControlFlowGraph.Branch>(\n            t.getControlFlowGraph()).recompute(n);\n\n        // Saves time by not traversing children.\n        return false;\n      }\n    }\n    return true;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "CheckUnreachableCode.visit",
    "class_name": "com.google.javascript.jscomp.CheckUnreachableCode",
    "signature": "com.google.javascript.jscomp.CheckUnreachableCode.visit(NodeTraversal,Node,Node)",
    "snippet": "  @Override\n  public void visit(NodeTraversal t, Node n, Node parent) {\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "ReachablePredicate.apply",
    "class_name": "com.google.javascript.jscomp.CheckUnreachableCode$ReachablePredicate",
    "signature": "com.google.javascript.jscomp.CheckUnreachableCode$ReachablePredicate.apply(EdgeTuple)",
    "snippet": "    @Override\n    public boolean apply(EdgeTuple<Node, Branch> input) {\n      Branch branch = input.edge;\n      if (!branch.isConditional()) {\n        return true;\n      }\n      Node predecessor = input.sourceNode;\n      Node condition = NodeUtil.getConditionExpression(predecessor);\n\n      // TODO(user): Handle more complicated expression like true == true,\n      // etc....\n      if (condition != null) {\n        TernaryValue val = NodeUtil.getImpureBooleanValue(condition);\n        if (val != TernaryValue.UNKNOWN) {\n          return val.toBoolean(true) == (branch == Branch.ON_TRUE);\n        }\n      }\n      return true;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "ClosureCodeRemoval.ClosureCodeRemoval",
    "class_name": "com.google.javascript.jscomp.ClosureCodeRemoval",
    "signature": "com.google.javascript.jscomp.ClosureCodeRemoval.ClosureCodeRemoval(AbstractCompiler,boolean,boolean)",
    "snippet": "  ClosureCodeRemoval(AbstractCompiler compiler, boolean removeAbstractMethods,\n                     boolean removeAssertionCalls) {\n    this.compiler = compiler;\n    this.removeAbstractMethods = removeAbstractMethods;\n    this.removeAssertionCalls = removeAssertionCalls;\n  }",
    "comment": " Creates a Closure code remover.  @param compiler The AbstractCompiler @param removeAbstractMethods Remove declarations of abstract methods. @param removeAssertionCalls Remove calls to goog.assert functions. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "ClosureCodeRemoval.process",
    "class_name": "com.google.javascript.jscomp.ClosureCodeRemoval",
    "signature": "com.google.javascript.jscomp.ClosureCodeRemoval.process(Node,Node)",
    "snippet": "  @Override\n  public void process(Node externs, Node root) {\n    List<Callback> passes = Lists.newArrayList();\n    if (removeAbstractMethods) {\n      passes.add(new FindAbstractMethods());\n    }\n    if (removeAssertionCalls) {\n      passes.add(new FindAssertionCalls());\n    }\n    CombinedCompilerPass.traverse(compiler, root, passes);\n\n    for (RemovableAssignment assignment : abstractMethodAssignmentNodes) {\n      assignment.remove();\n    }\n\n    for (Node call : assertionCalls) {\n      // If the assertion is an expression, just strip the whole thing.\n      Node parent = call.getParent();\n      if (NodeUtil.isExpressionNode(parent)) {\n        parent.getParent().removeChild(parent);\n      } else {\n        // Otherwise, replace the assertion with its first argument,\n        // which is the return value of the assertion.\n        Node firstArg = call.getFirstChild().getNext();\n        if (firstArg == null) {\n          parent.replaceChild(call, NodeUtil.newUndefinedNode(call));\n        } else {\n          parent.replaceChild(call, firstArg.detachFromParent());\n        }\n      }\n      compiler.reportCodeChange();\n    }\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "FindAbstractMethods.visit",
    "class_name": "com.google.javascript.jscomp.ClosureCodeRemoval$FindAbstractMethods",
    "signature": "com.google.javascript.jscomp.ClosureCodeRemoval$FindAbstractMethods.visit(NodeTraversal,Node,Node)",
    "snippet": "    @Override\n    public void visit(NodeTraversal t, Node n, Node parent) {\n      if (n.getType() == Token.ASSIGN) {\n        Node nameNode = n.getFirstChild();\n        Node valueNode = n.getLastChild();\n\n        if (nameNode.isQualifiedName() &&\n            valueNode.isQualifiedName() &&\n            ABSTRACT_METHOD_NAME.equals(valueNode.getQualifiedName())) {\n          abstractMethodAssignmentNodes.add(new RemovableAssignment(\n              n.getFirstChild(), n, t));\n        }\n      }\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "ClosureCodingConvention.getAssertionFunctions",
    "class_name": "com.google.javascript.jscomp.ClosureCodingConvention",
    "signature": "com.google.javascript.jscomp.ClosureCodingConvention.getAssertionFunctions()",
    "snippet": "  @Override\n  public Collection<AssertionFunctionSpec> getAssertionFunctions() {\n    return ImmutableList.<AssertionFunctionSpec>of(\n        new AssertionFunctionSpec(\"goog.asserts.assert\"),\n        new AssertionFunctionSpec(\"goog.asserts.assertNumber\",\n            JSTypeNative.NUMBER_TYPE),\n        new AssertionFunctionSpec(\"goog.asserts.assertString\",\n            JSTypeNative.STRING_TYPE),\n        new AssertionFunctionSpec(\"goog.asserts.assertFunction\",\n            JSTypeNative.FUNCTION_INSTANCE_TYPE),\n        new AssertionFunctionSpec(\"goog.asserts.assertObject\",\n            JSTypeNative.OBJECT_TYPE),\n        new AssertionFunctionSpec(\"goog.asserts.assertArray\",\n            JSTypeNative.ARRAY_TYPE),\n        // TODO(agrieve): It would be better if this could make the first\n        // parameter the type of the second parameter.\n        new AssertionFunctionSpec(\"goog.asserts.assertInstanceof\",\n            JSTypeNative.OBJECT_TYPE)\n    );\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "ClosureCodingConvention.isOptionalParameter",
    "class_name": "com.google.javascript.jscomp.ClosureCodingConvention",
    "signature": "com.google.javascript.jscomp.ClosureCodingConvention.isOptionalParameter(Node)",
    "snippet": "  @Override\n  public boolean isOptionalParameter(Node parameter) {\n    return false;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "ClosureCodingConvention.isVarArgsParameter",
    "class_name": "com.google.javascript.jscomp.ClosureCodingConvention",
    "signature": "com.google.javascript.jscomp.ClosureCodingConvention.isVarArgsParameter(Node)",
    "snippet": "  @Override\n  public boolean isVarArgsParameter(Node parameter) {\n    return false;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "ClosureOptimizePrimitives.ClosureOptimizePrimitives",
    "class_name": "com.google.javascript.jscomp.ClosureOptimizePrimitives",
    "signature": "com.google.javascript.jscomp.ClosureOptimizePrimitives.ClosureOptimizePrimitives(AbstractCompiler)",
    "snippet": "  ClosureOptimizePrimitives(AbstractCompiler compiler) {\n    this.compiler = compiler;\n  }",
    "comment": " @param compiler The AbstractCompiler ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "ClosureOptimizePrimitives.process",
    "class_name": "com.google.javascript.jscomp.ClosureOptimizePrimitives",
    "signature": "com.google.javascript.jscomp.ClosureOptimizePrimitives.process(Node,Node)",
    "snippet": "  @Override\n  public void process(Node externs, Node root) {\n    FindObjectCreateCalls pass = new FindObjectCreateCalls();\n    NodeTraversal.traverse(compiler, root, pass);\n    processObjectCreateCalls(pass.callNodes);\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "ClosureOptimizePrimitives.processObjectCreateCalls",
    "class_name": "com.google.javascript.jscomp.ClosureOptimizePrimitives",
    "signature": "com.google.javascript.jscomp.ClosureOptimizePrimitives.processObjectCreateCalls(List)",
    "snippet": "  private void processObjectCreateCalls(List<Node> callNodes) {\n    for (Node callNode : callNodes) {\n      Node curParam = callNode.getFirstChild().getNext();\n      if (canOptimizeObjectCreate(curParam)) {\n        Node objNode = new Node(Token.OBJECTLIT)\n            .copyInformationFrom(callNode);\n        while (curParam != null) {\n          Node keyNode = curParam;\n          Node valueNode = curParam.getNext();\n          curParam = valueNode.getNext();\n\n          callNode.removeChild(keyNode);\n          callNode.removeChild(valueNode);\n\n          if (keyNode.getType() != Token.STRING) {\n            keyNode = Node.newString(NodeUtil.getStringValue(keyNode))\n                .copyInformationFrom(keyNode);\n          }\n          keyNode.setQuotedString();\n          keyNode.addChildToBack(valueNode);\n          objNode.addChildToBack(keyNode);\n        }\n        callNode.getParent().replaceChild(callNode, objNode);\n        compiler.reportCodeChange();\n      }\n    }\n  }",
    "comment": " Converts all of the given call nodes to object literals that are safe to do so. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "FindObjectCreateCalls.visit",
    "class_name": "com.google.javascript.jscomp.ClosureOptimizePrimitives$FindObjectCreateCalls",
    "signature": "com.google.javascript.jscomp.ClosureOptimizePrimitives$FindObjectCreateCalls.visit(NodeTraversal,Node,Node)",
    "snippet": "    @Override\n    public void visit(NodeTraversal t, Node n, Node parent) {\n      if (n.getType() == Token.CALL) {\n        String fnName = n.getFirstChild().getQualifiedName();\n        if (\"goog$object$create\".equals(fnName) ||\n            \"goog.object.create\".equals(fnName)) {\n          callNodes.add(n);\n        }\n      }\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "ClosureReverseAbstractInterpreter.ClosureReverseAbstractInterpreter",
    "class_name": "com.google.javascript.jscomp.ClosureReverseAbstractInterpreter",
    "signature": "com.google.javascript.jscomp.ClosureReverseAbstractInterpreter.ClosureReverseAbstractInterpreter(CodingConvention,JSTypeRegistry)",
    "snippet": "  ClosureReverseAbstractInterpreter(CodingConvention convention,\n      final JSTypeRegistry typeRegistry) {\n    super(convention, typeRegistry);\n    this.restricters =\n      new ImmutableMap.Builder<String, Function<TypeRestriction, JSType>>()\n      .put(\"isDef\", new Function<TypeRestriction, JSType>() {\n        public JSType apply(TypeRestriction p) {\n          if (p.outcome) {\n            return getRestrictedWithoutUndefined(p.type);\n          } else {\n            return null;\n          }\n         }\n      })\n      .put(\"isNull\", new Function<TypeRestriction, JSType>() {\n        public JSType apply(TypeRestriction p) {\n          if (p.outcome) {\n            return getNativeType(NULL_TYPE);\n          } else {\n            return getRestrictedWithoutNull(p.type);\n          }\n        }\n      })\n      .put(\"isDefAndNotNull\", new Function<TypeRestriction, JSType>() {\n        public JSType apply(TypeRestriction p) {\n          if (p.outcome) {\n            return getRestrictedWithoutUndefined(\n                getRestrictedWithoutNull(p.type));\n          } else {\n            return null;\n          }\n        }\n      })\n      .put(\"isString\", new Function<TypeRestriction, JSType>() {\n        public JSType apply(TypeRestriction p) {\n          return getRestrictedByTypeOfResult(p.type, \"string\", p.outcome);\n        }\n      })\n      .put(\"isBoolean\", new Function<TypeRestriction, JSType>() {\n        public JSType apply(TypeRestriction p) {\n          return getRestrictedByTypeOfResult(p.type, \"boolean\", p.outcome);\n        }\n      })\n      .put(\"isNumber\", new Function<TypeRestriction, JSType>() {\n        public JSType apply(TypeRestriction p) {\n          return getRestrictedByTypeOfResult(p.type, \"number\", p.outcome);\n        }\n      })\n      .put(\"isFunction\", new Function<TypeRestriction, JSType>() {\n        public JSType apply(TypeRestriction p) {\n          return getRestrictedByTypeOfResult(p.type, \"function\", p.outcome);\n        }\n      })\n      .put(\"isArray\", new Function<TypeRestriction, JSType>() {\n        public JSType apply(TypeRestriction p) {\n          if (p.type == null) {\n            return p.outcome ? getNativeType(ARRAY_TYPE) : null;\n          }\n\n          Visitor<JSType> visitor = p.outcome ? restrictToArrayVisitor :\n              restrictToNotArrayVisitor;\n          return p.type.visit(visitor);\n        }\n      })\n      .put(\"isObject\", new Function<TypeRestriction, JSType>() {\n        public JSType apply(TypeRestriction p) {\n          if (p.type == null) {\n            return p.outcome ? getNativeType(OBJECT_TYPE) : null;\n          }\n\n          Visitor<JSType> visitor = p.outcome ? restrictToObjectVisitor :\n              restrictToNotObjectVisitor;\n          return p.type.visit(visitor);\n        }\n      })\n      .build();\n  }",
    "comment": " Creates a {@link ClosureReverseAbstractInterpreter}. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "CoalesceVariableNames.CoalesceVariableNames",
    "class_name": "com.google.javascript.jscomp.CoalesceVariableNames",
    "signature": "com.google.javascript.jscomp.CoalesceVariableNames.CoalesceVariableNames(AbstractCompiler,boolean)",
    "snippet": "  CoalesceVariableNames(AbstractCompiler compiler, boolean usePseudoNames) {\n    Preconditions.checkState(!compiler.getLifeCycleStage().isNormalized());\n\n    this.compiler = compiler;\n    colorings = Lists.newLinkedList();\n    this.usePseudoNames = usePseudoNames;\n  }",
    "comment": " @param usePseudoNames For debug purposes, when merging variable foo and bar to foo, rename both variable to foo_bar. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "CoalesceVariableNames.computeVariableNamesInterferenceGraph",
    "class_name": "com.google.javascript.jscomp.CoalesceVariableNames",
    "signature": "com.google.javascript.jscomp.CoalesceVariableNames.computeVariableNamesInterferenceGraph(NodeTraversal,ControlFlowGraph,Set)",
    "snippet": "  private UndiGraph<Var, Void> computeVariableNamesInterferenceGraph(\n      NodeTraversal t, ControlFlowGraph<Node> cfg, Set<Var> escaped) {\n    UndiGraph<Var, Void> interferenceGraph =\n        LinkedUndirectedGraph.create();\n    Scope scope = t.getScope();\n\n    // First create a node for each non-escaped variable.\n    for (Iterator<Var> i = scope.getVars(); i.hasNext();) {\n      Var v = i.next();\n      if (!escaped.contains(v)) {\n\n        // TODO(user): In theory, we CAN coalesce function names just like\n        // any variables. Our Liveness analysis captures this just like it as\n        // described in the specification. However, we saw some zipped and\n        // and unzipped size increase after this. We are not totally sure why\n        // that is but, for now, we will respect the dead functions and not play\n        // around with it.\n        if (!NodeUtil.isFunction(v.getParentNode())) {\n          interferenceGraph.createNode(v);\n        }\n      }\n    }\n\n    // Go through each variable and try to connect them.\n    for (Iterator<Var> i1 = scope.getVars(); i1.hasNext();) {\n      Var v1 = i1.next();\n\n      NEXT_VAR_PAIR:\n      for (Iterator<Var> i2 = scope.getVars(); i2.hasNext();) {\n        Var v2 = i2.next();\n\n        // Skip duplicate pairs.\n        if (v1.index >= v2.index) {\n          continue;\n        }\n\n        if (!interferenceGraph.hasNode(v1) ||\n            !interferenceGraph.hasNode(v2)) {\n          // Skip nodes that were not added. They are globals and escaped\n          // locals. Also avoid merging a variable with itself.\n          continue NEXT_VAR_PAIR;\n        }\n\n        if (v1.getParentNode().getType() == Token.LP &&\n            v2.getParentNode().getType() == Token.LP) {\n          interferenceGraph.connectIfNotFound(v1, null, v2);\n          continue NEXT_VAR_PAIR;\n        }\n\n        // Go through every CFG node in the program and look at\n        // this variable pair. If they are both live at the same\n        // time, add an edge between them and continue to the next pair.\n        NEXT_CROSS_CFG_NODE:\n        for (DiGraphNode<Node, Branch> cfgNode : cfg.getDirectedGraphNodes()) {\n          if (cfg.isImplicitReturn(cfgNode)) {\n            continue NEXT_CROSS_CFG_NODE;\n          }\n\n          FlowState<LiveVariableLattice> state = cfgNode.getAnnotation();\n          // Check the live states and add edge when possible.\n          if ((state.getIn().isLive(v1) && state.getIn().isLive(v2)) ||\n              (state.getOut().isLive(v1) && state.getOut().isLive(v2))) {\n            interferenceGraph.connectIfNotFound(v1, null, v2);\n            continue NEXT_VAR_PAIR;\n          }\n        }\n\n        // v1 and v2 might not have an edge between them! woohoo. there's\n        // one last sanity check that we have to do: we have to check\n        // if there's a collision *within* the cfg node.\n        NEXT_INTRA_CFG_NODE:\n        for (DiGraphNode<Node, Branch> cfgNode : cfg.getDirectedGraphNodes()) {\n          if (cfg.isImplicitReturn(cfgNode)) {\n            continue NEXT_INTRA_CFG_NODE;\n          }\n\n          FlowState<LiveVariableLattice> state = cfgNode.getAnnotation();\n          boolean v1OutLive = state.getOut().isLive(v1);\n          boolean v2OutLive = state.getOut().isLive(v2);\n          CombinedLiveRangeChecker checker = new CombinedLiveRangeChecker(\n              new LiveRangeChecker(v1, v2OutLive ? null : v2),\n              new LiveRangeChecker(v2, v1OutLive ? null : v1));\n          NodeTraversal.traverse(\n              compiler,\n              cfgNode.getValue(),\n              checker);\n          if (checker.connectIfCrossed(interferenceGraph)) {\n            continue NEXT_VAR_PAIR;\n          }\n        }\n      }\n    }\n    return interferenceGraph;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "CoalesceVariableNames.enterScope",
    "class_name": "com.google.javascript.jscomp.CoalesceVariableNames",
    "signature": "com.google.javascript.jscomp.CoalesceVariableNames.enterScope(NodeTraversal)",
    "snippet": "  @Override\n  public void enterScope(NodeTraversal t) {\n    // TODO(user): We CAN do this in the global scope, just need to be\n    // careful when something is exported. Liveness uses bit-vector for live\n    // sets so I don't see compilation time will be a problem for running this\n    // pass in the global scope.\n    if (t.inGlobalScope()) {\n      return;\n    }\n    Scope scope = t.getScope();\n    ControlFlowGraph<Node> cfg = t.getControlFlowGraph();\n\n    LiveVariablesAnalysis liveness =\n        new LiveVariablesAnalysis(cfg, scope, compiler);\n    // If the function has exactly 2 params, mark them as escaped. This is\n    // a work-around for an IE bug where it throws an exception if you\n    // write to the parameters of the callback in a sort(). See:\n    // http://code.google.com/p/closure-compiler/issues/detail?id=58\n    if (scope.getRootNode().getFirstChild().getNext().getChildCount() == 2) {\n      liveness.markAllParametersEscaped();\n    }\n    liveness.analyze();\n\n    UndiGraph<Var, Void> interferenceGraph =\n        computeVariableNamesInterferenceGraph(\n            t, cfg, liveness.getEscapedLocals());\n\n    GraphColoring<Var, Void> coloring =\n        new GreedyGraphColoring<Var, Void>(interferenceGraph,\n            coloringTieBreaker);\n\n    coloring.color();\n    colorings.push(coloring);\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "CoalesceVariableNames.exitScope",
    "class_name": "com.google.javascript.jscomp.CoalesceVariableNames",
    "signature": "com.google.javascript.jscomp.CoalesceVariableNames.exitScope(NodeTraversal)",
    "snippet": "  @Override\n  public void exitScope(NodeTraversal t) {\n    if (t.inGlobalScope()) {\n      return;\n    }\n    colorings.pop();\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "CoalesceVariableNames.process",
    "class_name": "com.google.javascript.jscomp.CoalesceVariableNames",
    "signature": "com.google.javascript.jscomp.CoalesceVariableNames.process(Node,Node)",
    "snippet": "  @Override\n  public void process(Node externs, Node root) {\n    NodeTraversal.traverse(compiler, root, this);\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "CoalesceVariableNames.visit",
    "class_name": "com.google.javascript.jscomp.CoalesceVariableNames",
    "signature": "com.google.javascript.jscomp.CoalesceVariableNames.visit(NodeTraversal,Node,Node)",
    "snippet": "  @Override\n  public void visit(NodeTraversal t, Node n, Node parent) {\n    if (colorings.isEmpty() || !NodeUtil.isName(n) ||\n        NodeUtil.isFunction(parent)) {\n      // Don't rename named functions.\n      return;\n    }\n    Var var = t.getScope().getVar(n.getString());\n    GraphNode<Var, ?> vNode = colorings.peek().getGraph().getNode(var);\n    if (vNode == null) {\n      // This is not a local.\n      return;\n    }\n    Var coalescedVar = colorings.peek().getPartitionSuperNode(var);\n\n    if (!usePseudoNames) {\n      if (vNode.getValue().equals(coalescedVar)) {\n        // The coalesced name is itself, nothing to do.\n        return;\n      }\n\n      // Rename.\n      n.setString(coalescedVar.name);\n      compiler.reportCodeChange();\n\n      if (NodeUtil.isVar(parent)) {\n        removeVarDeclaration(n);\n      }\n    } else {\n      // This code block is slow but since usePseudoName is for debugging,\n      // we should not sacrifice performance for non-debugging compilation to\n      // make this fast.\n      String pseudoName = null;\n      Set<String> allMergedNames = Sets.newTreeSet();\n      for (Iterator<Var> i = t.getScope().getVars(); i.hasNext();) {\n        Var iVar = i.next();\n\n        // Look for all the variables that can be merged (in the graph by now)\n        // and it is merged with the current coalscedVar.\n        if (colorings.peek().getGraph().getNode(iVar) != null &&\n            coalescedVar.equals(colorings.peek().getPartitionSuperNode(iVar))) {\n          allMergedNames.add(iVar.name);\n        }\n      }\n\n      // Keep its original name.\n      if (allMergedNames.size() == 1) {\n        return;\n      }\n\n      pseudoName = Joiner.on(\"_\").join(allMergedNames);\n\n      while (t.getScope().isDeclared(pseudoName, true)) {\n        pseudoName += \"$\";\n      }\n\n      n.setString(pseudoName);\n      compiler.reportCodeChange();\n\n      if (!vNode.getValue().equals(coalescedVar) && NodeUtil.isVar(parent)) {\n        removeVarDeclaration(n);\n      }\n    }\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "RecentChange.hasCodeChanged",
    "class_name": "com.google.javascript.jscomp.CodeChangeHandler$RecentChange",
    "signature": "com.google.javascript.jscomp.CodeChangeHandler$RecentChange.hasCodeChanged()",
    "snippet": "    boolean hasCodeChanged() {\n      return hasChanged;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "RecentChange.reportChange",
    "class_name": "com.google.javascript.jscomp.CodeChangeHandler$RecentChange",
    "signature": "com.google.javascript.jscomp.CodeChangeHandler$RecentChange.reportChange()",
    "snippet": "    public void reportChange() {\n      hasChanged = true;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "RecentChange.reset",
    "class_name": "com.google.javascript.jscomp.CodeChangeHandler$RecentChange",
    "signature": "com.google.javascript.jscomp.CodeChangeHandler$RecentChange.reset()",
    "snippet": "    void reset() {\n      hasChanged = false;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "CodeConsumer.add",
    "class_name": "com.google.javascript.jscomp.CodeConsumer",
    "signature": "com.google.javascript.jscomp.CodeConsumer.add(String)",
    "snippet": "  void add(String newcode) {\n    maybeEndStatement();\n\n    if (newcode.length() == 0) {\n      return;\n    }\n\n    char c = newcode.charAt(0);\n    if ((isWordChar(c) || c == '\\\\') &&\n        isWordChar(getLastChar())) {\n      // need space to separate. This is not pretty printing.\n      // For example: \"return foo;\"\n      append(\" \");\n    }\n\n    append(newcode);\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "CodeConsumer.addIdentifier",
    "class_name": "com.google.javascript.jscomp.CodeConsumer",
    "signature": "com.google.javascript.jscomp.CodeConsumer.addIdentifier(String)",
    "snippet": "  void addIdentifier(String identifier) {\n    add(identifier);\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "CodeConsumer.addNumber",
    "class_name": "com.google.javascript.jscomp.CodeConsumer",
    "signature": "com.google.javascript.jscomp.CodeConsumer.addNumber(double)",
    "snippet": "  void addNumber(double x) {\n    // This is not pretty printing. This is to prevent misparsing of x- -4 as\n    // x--4 (which is a syntax error).\n    char prev = getLastChar();\n    if (x < 0 && prev == '-') {\n      add(\" \");\n    }\n\n    if ((long) x == x) {\n      long value = (long) x;\n      long mantissa = value;\n      int exp = 0;\n      if (Math.abs(x) >= 100) {\n        while (mantissa / 10 * Math.pow(10, exp + 1) == value) {\n          mantissa /= 10;\n          exp++;\n        }\n      }\n      if (exp > 2) {\n        add(Long.toString(mantissa) + \"E\" + Integer.toString(exp));\n      } else {\n        add(Long.toString(value));\n      }\n    } else {\n      add(String.valueOf(x));\n    }\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "CodeConsumer.addOp",
    "class_name": "com.google.javascript.jscomp.CodeConsumer",
    "signature": "com.google.javascript.jscomp.CodeConsumer.addOp(String,boolean)",
    "snippet": "  void addOp(String op, boolean binOp) {\n    maybeEndStatement();\n\n    char first = op.charAt(0);\n    char prev = getLastChar();\n\n    if ((first == '+' || first == '-') && prev == first) {\n      // This is not pretty printing. This is to prevent misparsing of\n      // things like \"x + ++y\" or \"x++ + ++y\"\n      append(\" \");\n    } else if (Character.isLetter(first) &&\n               isWordChar(prev)) {\n      // Make sure there is a space after e.g. instanceof , typeof\n      append(\" \");\n    } else if (prev == '-' && first == '>') {\n      // Make sure that we don't emit -->\n      append(\" \");\n    }\n\n    // Allow formating around the operator.\n    appendOp(op, binOp);\n\n    // Line breaking after an operator is always safe. Line breaking before an\n    // operator on the other hand is not. We only line break after a bin op\n    // because it looks strange.\n    if (binOp) {\n      maybeCutLine();\n    }\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "CodeConsumer.appendBlockEnd",
    "class_name": "com.google.javascript.jscomp.CodeConsumer",
    "signature": "com.google.javascript.jscomp.CodeConsumer.appendBlockEnd()",
    "snippet": "  void appendBlockEnd() {\n    append(\"}\");\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "CodeConsumer.appendBlockStart",
    "class_name": "com.google.javascript.jscomp.CodeConsumer",
    "signature": "com.google.javascript.jscomp.CodeConsumer.appendBlockStart()",
    "snippet": "  void appendBlockStart() {\n    append(\"{\");\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "CodeConsumer.appendOp",
    "class_name": "com.google.javascript.jscomp.CodeConsumer",
    "signature": "com.google.javascript.jscomp.CodeConsumer.appendOp(String,boolean)",
    "snippet": "  void appendOp(String op, boolean binOp) {\n    append(op);\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "CodeConsumer.beginBlock",
    "class_name": "com.google.javascript.jscomp.CodeConsumer",
    "signature": "com.google.javascript.jscomp.CodeConsumer.beginBlock()",
    "snippet": "  void beginBlock() {\n    if (statementNeedsEnded) {\n      append(\";\");\n      maybeLineBreak();\n    }\n    appendBlockStart();\n\n    endLine();\n    statementNeedsEnded = false;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "CodeConsumer.breakAfterBlockFor",
    "class_name": "com.google.javascript.jscomp.CodeConsumer",
    "signature": "com.google.javascript.jscomp.CodeConsumer.breakAfterBlockFor(Node,boolean)",
    "snippet": "  boolean breakAfterBlockFor(Node n, boolean statementContext) {\n    return statementContext;\n  }",
    "comment": " @return Whether the a line break can be added after the specified BLOCK. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "CodeConsumer.continueProcessing",
    "class_name": "com.google.javascript.jscomp.CodeConsumer",
    "signature": "com.google.javascript.jscomp.CodeConsumer.continueProcessing()",
    "snippet": "  boolean continueProcessing() {\n    return true;\n  }",
    "comment": " Provides a means of interrupting the CodeGenerator. Derived classes should return false to stop further processing. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "CodeConsumer.endBlock",
    "class_name": "com.google.javascript.jscomp.CodeConsumer",
    "signature": "com.google.javascript.jscomp.CodeConsumer.endBlock(boolean)",
    "snippet": "  void endBlock(boolean shouldEndLine) {\n    appendBlockEnd();\n    if (shouldEndLine) {\n      endLine();\n    }\n    statementNeedsEnded = false;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "CodeConsumer.endFile",
    "class_name": "com.google.javascript.jscomp.CodeConsumer",
    "signature": "com.google.javascript.jscomp.CodeConsumer.endFile()",
    "snippet": "  void endFile() {}",
    "comment": "Called when we're at the end of a file. */",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "CodeConsumer.endFunction",
    "class_name": "com.google.javascript.jscomp.CodeConsumer",
    "signature": "com.google.javascript.jscomp.CodeConsumer.endFunction(boolean)",
    "snippet": "  void endFunction(boolean statementContext) {\n    sawFunction = true;\n    if (statementContext) {\n      endLine();\n    }\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "CodeConsumer.endLine",
    "class_name": "com.google.javascript.jscomp.CodeConsumer",
    "signature": "com.google.javascript.jscomp.CodeConsumer.endLine()",
    "snippet": "  void endLine() {\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "CodeConsumer.endStatement",
    "class_name": "com.google.javascript.jscomp.CodeConsumer",
    "signature": "com.google.javascript.jscomp.CodeConsumer.endStatement()",
    "snippet": "  void endStatement() {\n    endStatement(false);\n  }",
    "comment": " Indicates the end of a statement and a ';' may need to be added. But we don't add it now, in case we're at the end of a block (in which case we don't have to add the ';'). See maybeEndStatement() ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "CodeConsumer.endStatement",
    "class_name": "com.google.javascript.jscomp.CodeConsumer",
    "signature": "com.google.javascript.jscomp.CodeConsumer.endStatement(boolean)",
    "snippet": "  void endStatement(boolean needSemiColon) {\n    if (needSemiColon) {\n      append(\";\");\n      maybeLineBreak();\n      statementNeedsEnded = false;\n    } else if (statementStarted) {\n      statementNeedsEnded = true;\n    }\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "CodeConsumer.isWordChar",
    "class_name": "com.google.javascript.jscomp.CodeConsumer",
    "signature": "com.google.javascript.jscomp.CodeConsumer.isWordChar(char)",
    "snippet": "  static boolean isWordChar(char ch) {\n    return (ch == '_' ||\n            ch == '$' ||\n            Character.isLetterOrDigit(ch));\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "CodeConsumer.maybeEndStatement",
    "class_name": "com.google.javascript.jscomp.CodeConsumer",
    "signature": "com.google.javascript.jscomp.CodeConsumer.maybeEndStatement()",
    "snippet": "  void maybeEndStatement() {\n    // Add a ';' if we need to.\n    if (statementNeedsEnded) {\n      append(\";\");\n      maybeLineBreak();\n      endLine();\n      statementNeedsEnded = false;\n    }\n    statementStarted = true;\n  }",
    "comment": " This is to be called when we're in a statement. If the prev statement needs to be ended, add a ';'. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "CodeGenerator.CodeGenerator",
    "class_name": "com.google.javascript.jscomp.CodeGenerator",
    "signature": "com.google.javascript.jscomp.CodeGenerator.CodeGenerator(CodeConsumer,Charset)",
    "snippet": "  CodeGenerator(\n      CodeConsumer consumer, Charset outputCharset) {\n    cc = consumer;\n    if (outputCharset == null || outputCharset == Charsets.US_ASCII) {\n      // If we want our default (pretending to be UTF-8, but escaping anything\n      // outside of straight ASCII), then don't use the encoder, but\n      // just special-case the code.  This keeps the normal path through\n      // the code identical to how it's been for years.\n      this.outputCharsetEncoder = null;\n    } else {\n      this.outputCharsetEncoder = outputCharset.newEncoder();\n    }\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "CodeGenerator.add",
    "class_name": "com.google.javascript.jscomp.CodeGenerator",
    "signature": "com.google.javascript.jscomp.CodeGenerator.add(Node)",
    "snippet": "  void add(Node n) {\n    add(n, Context.OTHER);\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "CodeGenerator.add",
    "class_name": "com.google.javascript.jscomp.CodeGenerator",
    "signature": "com.google.javascript.jscomp.CodeGenerator.add(Node,Context)",
    "snippet": "  void add(Node n, Context context) {\n    if (!cc.continueProcessing()) {\n      return;\n    }\n\n    int type = n.getType();\n    String opstr = NodeUtil.opToStr(type);\n    int childCount = n.getChildCount();\n    Node first = n.getFirstChild();\n    Node last = n.getLastChild();\n\n    // Handle all binary operators\n    if (opstr != null && first != last) {\n      Preconditions.checkState(\n          childCount == 2,\n          \"Bad binary operator \\\"%s\\\": expected 2 arguments but got %s\",\n          opstr, childCount);\n      int p = NodeUtil.precedence(type);\n      addLeftExpr(first, p, context);\n      cc.addOp(opstr, true);\n\n      // For right-hand-side of operations, only pass context if it's\n      // the IN_FOR_INIT_CLAUSE one.\n      Context rhsContext = getContextForNoInOperator(context);\n\n      // Handle associativity.\n      // e.g. if the parse tree is a * (b * c),\n      // we can simply generate a * b * c.\n      if (last.getType() == type &&\n          NodeUtil.isAssociative(type)) {\n        addExpr(last, p, rhsContext);\n      } else if (NodeUtil.isAssignmentOp(n) && NodeUtil.isAssignmentOp(last)) {\n        // Assignments are the only right-associative binary operators\n        addExpr(last, p, rhsContext);\n      } else {\n        addExpr(last, p + 1, rhsContext);\n      }\n      return;\n    }\n\n    cc.startSourceMapping(n);\n\n    switch (type) {\n      case Token.TRY: {\n        Preconditions.checkState(first.getNext().getType() == Token.BLOCK &&\n                !first.getNext().hasMoreThanOneChild());\n        Preconditions.checkState(childCount >= 2 && childCount <= 3);\n\n        add(\"try\");\n        add(first, Context.PRESERVE_BLOCK);\n\n        // second child contains the catch block, or nothing if there\n        // isn't a catch block\n        Node catchblock = first.getNext().getFirstChild();\n        if (catchblock != null) {\n          add(catchblock);\n        }\n\n        if (childCount == 3) {\n          add(\"finally\");\n          add(last, Context.PRESERVE_BLOCK);\n        }\n        break;\n      }\n\n      case Token.CATCH:\n        Preconditions.checkState(childCount == 2);\n        add(\"catch(\");\n        add(first);\n        add(\")\");\n        add(last, Context.PRESERVE_BLOCK);\n        break;\n\n      case Token.THROW:\n        Preconditions.checkState(childCount == 1);\n        add(\"throw\");\n        add(first);\n\n        // Must have a ';' after a throw statement, otherwise safari can't\n        // parse this.\n        cc.endStatement(true);\n        break;\n\n      case Token.RETURN:\n        add(\"return\");\n        if (childCount == 1) {\n          add(first);\n        } else {\n          Preconditions.checkState(childCount == 0);\n        }\n        cc.endStatement();\n        break;\n\n      case Token.VAR:\n        if (first != null) {\n          add(\"var \");\n          addList(first, false, getContextForNoInOperator(context));\n        }\n        break;\n\n      case Token.LABEL_NAME:\n        Preconditions.checkState(!n.getString().isEmpty());\n        addIdentifier(n.getString());\n        break;\n\n      case Token.NAME:\n        if (first == null || first.getType() == Token.EMPTY) {\n          addIdentifier(n.getString());\n        } else {\n          Preconditions.checkState(childCount == 1);\n          addIdentifier(n.getString());\n          cc.addOp(\"=\", true);\n          if (first.getType() == Token.COMMA) {\n            addExpr(first, NodeUtil.precedence(Token.ASSIGN));\n          } else {\n            // Add expression, consider nearby code at lowest level of\n            // precedence.\n            addExpr(first, 0, getContextForNoInOperator(context));\n          }\n        }\n        break;\n\n      case Token.ARRAYLIT:\n        add(\"[\");\n        addArrayList(first);\n        add(\"]\");\n        break;\n\n      case Token.LP:\n        add(\"(\");\n        addList(first);\n        add(\")\");\n        break;\n\n      case Token.COMMA:\n        Preconditions.checkState(childCount == 2);\n        addList(first, false, context);\n        break;\n\n      case Token.NUMBER:\n        Preconditions.checkState(childCount == 0);\n        cc.addNumber(n.getDouble());\n        break;\n\n      case Token.TYPEOF:\n      case Token.VOID:\n      case Token.NOT:\n      case Token.BITNOT:\n      case Token.POS: {\n        // All of these unary operators are right-associative\n        Preconditions.checkState(childCount == 1);\n        cc.addOp(NodeUtil.opToStrNoFail(type), false);\n        addExpr(first, NodeUtil.precedence(type));\n        break;\n      }\n\n      case Token.NEG: {\n        Preconditions.checkState(childCount == 1);\n\n        // It's important to our sanity checker that the code\n        // we print produces the same AST as the code we parse back.\n        // NEG is a weird case because Rhino parses \"- -2\" as \"2\".\n        if (n.getFirstChild().getType() == Token.NUMBER) {\n          cc.addNumber(-n.getFirstChild().getDouble());\n        } else {\n          cc.addOp(NodeUtil.opToStrNoFail(type), false);\n          addExpr(first, NodeUtil.precedence(type));\n        }\n\n        break;\n      }\n\n      case Token.HOOK: {\n        Preconditions.checkState(childCount == 3);\n        int p = NodeUtil.precedence(type);\n        addLeftExpr(first, p + 1, context);\n        cc.addOp(\"?\", true);\n        addExpr(first.getNext(), 1);\n        cc.addOp(\":\", true);\n        addExpr(last, 1);\n        break;\n      }\n\n      case Token.REGEXP:\n        if (first.getType() != Token.STRING ||\n            last.getType() != Token.STRING) {\n          throw new Error(\"Expected children to be strings\");\n        }\n\n        String regexp = regexpEscape(first.getString(), outputCharsetEncoder);\n\n        // I only use one .add because whitespace matters\n        if (childCount == 2) {\n          add(regexp + last.getString());\n        } else {\n          Preconditions.checkState(childCount == 1);\n          add(regexp);\n        }\n        break;\n\n      case Token.GET_REF:\n        add(first);\n        break;\n\n      case Token.REF_SPECIAL:\n        Preconditions.checkState(childCount == 1);\n        add(first);\n        add(\".\");\n        add((String) n.getProp(Node.NAME_PROP));\n        break;\n\n      case Token.FUNCTION:\n        if (n.getClass() != Node.class) {\n          throw new Error(\"Unexpected Node subclass.\");\n        }\n        Preconditions.checkState(childCount == 3);\n        boolean funcNeedsParens = (context == Context.START_OF_EXPR);\n        if (funcNeedsParens) {\n          add(\"(\");\n        }\n\n        add(\"function\");\n        add(first);\n\n        add(first.getNext());\n        add(last, Context.PRESERVE_BLOCK);\n        cc.endFunction(context == Context.STATEMENT);\n\n        if (funcNeedsParens) {\n          add(\")\");\n        }\n        break;\n\n      case Token.GET:\n      case Token.SET:\n        Preconditions.checkState(n.getParent().getType() == Token.OBJECTLIT);\n        Preconditions.checkState(childCount == 1);\n        Preconditions.checkState(first.getType() == Token.FUNCTION);\n\n        // Get methods are unnamed\n        Preconditions.checkState(first.getFirstChild().getString().isEmpty());\n        if (type == Token.GET) {\n          // Get methods have no parameters.\n          Preconditions.checkState(!first.getChildAtIndex(1).hasChildren());\n          add(\"get \");\n        } else {\n          // Set methods have one parameter.\n          Preconditions.checkState(first.getChildAtIndex(1).hasOneChild());\n          add(\"set \");\n        }\n\n        // The name is on the GET or SET node.\n        String name = n.getString();\n        Node fn = first;\n        Node parameters = fn.getChildAtIndex(1);\n        Node body = fn.getLastChild();\n\n        // Add the property name.\n        if (!n.isQuotedString() &&\n            TokenStream.isJSIdentifier(name) &&\n            // do not encode literally any non-literal characters that were\n            // unicode escaped.\n            NodeUtil.isLatin(name)) {\n          add(name);\n        } else {\n          // Determine if the string is a simple number.\n          double d = getSimpleNumber(name);\n          if (!Double.isNaN(d)) {\n            cc.addNumber(d);\n          } else {\n            addJsString(n.getString());\n          }\n        }\n\n        add(parameters);\n        add(body, Context.PRESERVE_BLOCK);\n        break;\n\n      case Token.SCRIPT:\n      case Token.BLOCK: {\n        if (n.getClass() != Node.class) {\n          throw new Error(\"Unexpected Node subclass.\");\n        }\n        boolean preserveBlock = context == Context.PRESERVE_BLOCK;\n        if (preserveBlock) {\n          cc.beginBlock();\n        }\n\n        boolean preferLineBreaks =\n            type == Token.SCRIPT ||\n            (type == Token.BLOCK &&\n                !preserveBlock &&\n                n.getParent() != null &&\n                n.getParent().getType() == Token.SCRIPT);\n        for (Node c = first; c != null; c = c.getNext()) {\n          add(c, Context.STATEMENT);\n\n          // VAR doesn't include ';' since it gets used in expressions\n          if (c.getType() == Token.VAR) {\n            cc.endStatement();\n          }\n\n          if (c.getType() == Token.FUNCTION) {\n            cc.maybeLineBreak();\n          }\n\n          // Prefer to break lines in between top-level statements\n          // because top level statements are more homogeneous.\n          if (preferLineBreaks) {\n            cc.notePreferredLineBreak();\n          }\n        }\n        if (preserveBlock) {\n          cc.endBlock(cc.breakAfterBlockFor(n, context == Context.STATEMENT));\n        }\n        break;\n      }\n\n      case Token.FOR:\n        if (childCount == 4) {\n          add(\"for(\");\n          if (first.getType() == Token.VAR) {\n            add(first, Context.IN_FOR_INIT_CLAUSE);\n          } else {\n            addExpr(first, 0, Context.IN_FOR_INIT_CLAUSE);\n          }\n          add(\";\");\n          add(first.getNext());\n          add(\";\");\n          add(first.getNext().getNext());\n          add(\")\");\n          addNonEmptyStatement(\n              last, getContextForNonEmptyExpression(context), false);\n        } else {\n          Preconditions.checkState(childCount == 3);\n          add(\"for(\");\n          add(first);\n          add(\"in\");\n          add(first.getNext());\n          add(\")\");\n          addNonEmptyStatement(\n              last, getContextForNonEmptyExpression(context), false);\n        }\n        break;\n\n      case Token.DO:\n        Preconditions.checkState(childCount == 2);\n        add(\"do\");\n        addNonEmptyStatement(first, Context.OTHER, false);\n        add(\"while(\");\n        add(last);\n        add(\")\");\n        cc.endStatement();\n        break;\n\n      case Token.WHILE:\n        Preconditions.checkState(childCount == 2);\n        add(\"while(\");\n        add(first);\n        add(\")\");\n        addNonEmptyStatement(\n            last, getContextForNonEmptyExpression(context), false);\n        break;\n\n      case Token.EMPTY:\n        Preconditions.checkState(childCount == 0);\n        break;\n\n      case Token.GETPROP: {\n        Preconditions.checkState(\n            childCount == 2,\n            \"Bad GETPROP: expected 2 children, but got %s\", childCount);\n        Preconditions.checkState(\n            last.getType() == Token.STRING,\n            \"Bad GETPROP: RHS should be STRING\");\n        boolean needsParens = (first.getType() == Token.NUMBER);\n        if (needsParens) {\n          add(\"(\");\n        }\n        addLeftExpr(first, NodeUtil.precedence(type), context);\n        if (needsParens) {\n          add(\")\");\n        }\n        add(\".\");\n        addIdentifier(last.getString());\n        break;\n      }\n\n      case Token.GETELEM:\n        Preconditions.checkState(\n            childCount == 2,\n            \"Bad GETELEM: expected 2 children but got %s\", childCount);\n        addLeftExpr(first, NodeUtil.precedence(type), context);\n        add(\"[\");\n        add(first.getNext());\n        add(\"]\");\n        break;\n\n      case Token.WITH:\n        Preconditions.checkState(childCount == 2);\n        add(\"with(\");\n        add(first);\n        add(\")\");\n        addNonEmptyStatement(\n            last, getContextForNonEmptyExpression(context), false);\n        break;\n\n      case Token.INC:\n      case Token.DEC: {\n        Preconditions.checkState(childCount == 1);\n        String o = type == Token.INC ? \"++\" : \"--\";\n        int postProp = n.getIntProp(Node.INCRDECR_PROP);\n        // A non-zero post-prop value indicates a post inc/dec, default of zero\n        // is a pre-inc/dec.\n        if (postProp != 0) {\n          addLeftExpr(first, NodeUtil.precedence(type), context);\n          cc.addOp(o, false);\n        } else {\n          cc.addOp(o, false);\n          add(first);\n        }\n        break;\n      }\n\n      case Token.CALL:\n        // We have two special cases here:\n        // 1) If the left hand side of the call is a direct reference to eval,\n        // then it must have a DIRECT_EVAL annotation. If it does not, then\n        // that means it was originally an indirect call to eval, and that\n        // indirectness must be preserved.\n        // 2) If the left hand side of the call is a property reference,\n        // then the call must not a FREE_CALL annotation. If it does, then\n        // that means it was originally an call without an explicit this and\n        // that must be preserved.\n        if (isIndirectEval(first)\n            || n.getBooleanProp(Node.FREE_CALL) && NodeUtil.isGet(first)) {\n          add(\"(0,\");\n          addExpr(first, NodeUtil.precedence(Token.COMMA));\n          add(\")\");\n        } else {\n          addLeftExpr(first, NodeUtil.precedence(type), context);\n        }\n        add(\"(\");\n        addList(first.getNext());\n        add(\")\");\n        break;\n\n      case Token.IF:\n        boolean hasElse = childCount == 3;\n        boolean ambiguousElseClause =\n            context == Context.BEFORE_DANGLING_ELSE && !hasElse;\n        if (ambiguousElseClause) {\n          cc.beginBlock();\n        }\n\n        add(\"if(\");\n        add(first);\n        add(\")\");\n\n        if (hasElse) {\n          addNonEmptyStatement(\n              first.getNext(), Context.BEFORE_DANGLING_ELSE, false);\n          add(\"else\");\n          addNonEmptyStatement(\n              last, getContextForNonEmptyExpression(context), false);\n        } else {\n          addNonEmptyStatement(first.getNext(), Context.OTHER, false);\n          Preconditions.checkState(childCount == 2);\n        }\n\n        if (ambiguousElseClause) {\n          cc.endBlock();\n        }\n        break;\n\n      case Token.NULL:\n      case Token.THIS:\n      case Token.FALSE:\n      case Token.TRUE:\n        Preconditions.checkState(childCount == 0);\n        add(Node.tokenToName(type));\n        break;\n\n      case Token.CONTINUE:\n        Preconditions.checkState(childCount <= 1);\n        add(\"continue\");\n        if (childCount == 1) {\n          if (first.getType() != Token.LABEL_NAME) {\n            throw new Error(\"Unexpected token type. Should be LABEL_NAME.\");\n          }\n          add(\" \");\n          add(first);\n        }\n        cc.endStatement();\n        break;\n\n      case Token.DEBUGGER:\n        Preconditions.checkState(childCount == 0);\n        add(\"debugger\");\n        cc.endStatement();\n        break;\n\n      case Token.BREAK:\n        Preconditions.checkState(childCount <= 1);\n        add(\"break\");\n        if (childCount == 1) {\n          if (first.getType() != Token.LABEL_NAME) {\n            throw new Error(\"Unexpected token type. Should be LABEL_NAME.\");\n          }\n          add(\" \");\n          add(first);\n        }\n        cc.endStatement();\n        break;\n\n      case Token.EXPR_VOID:\n        throw new Error(\"Unexpected EXPR_VOID. Should be EXPR_RESULT.\");\n\n      case Token.EXPR_RESULT:\n        Preconditions.checkState(childCount == 1);\n        add(first, Context.START_OF_EXPR);\n        cc.endStatement();\n        break;\n\n      case Token.NEW:\n        add(\"new \");\n        int precedence = NodeUtil.precedence(type);\n\n        // If the first child contains a CALL, then claim higher precedence\n        // to force parentheses. Otherwise, when parsed, NEW will bind to the\n        // first viable parentheses (don't traverse into functions).\n        if (NodeUtil.containsType(first, Token.CALL, new MatchNotFunction())) {\n          precedence = NodeUtil.precedence(first.getType()) + 1;\n        }\n        addExpr(first, precedence);\n\n        // '()' is optional when no arguments are present\n        Node next = first.getNext();\n        if (next != null) {\n          add(\"(\");\n          addList(next);\n          add(\")\");\n        }\n        break;\n\n      case Token.STRING:\n        if (childCount !=\n            ((n.getParent() != null &&\n              n.getParent().getType() == Token.OBJECTLIT) ? 1 : 0)) {\n          throw new IllegalStateException(\n              \"Unexpected String children: \" + n.getParent().toStringTree());\n        }\n        addJsString(n.getString());\n        break;\n\n      case Token.DELPROP:\n        Preconditions.checkState(childCount == 1);\n        add(\"delete \");\n        add(first);\n        break;\n\n      case Token.OBJECTLIT: {\n        boolean needsParens = (context == Context.START_OF_EXPR);\n        if (needsParens) {\n          add(\"(\");\n        }\n        add(\"{\");\n        for (Node c = first; c != null; c = c.getNext()) {\n          if (c != first) {\n            cc.listSeparator();\n          }\n\n          if (c.getType() == Token.GET || c.getType() == Token.SET) {\n            add(c);\n          } else {\n            Preconditions.checkState(c.getType() == Token.STRING);\n            String key = c.getString();\n            // Object literal property names don't have to be quoted if they\n            // are not JavaScript keywords\n            if (!c.isQuotedString() &&\n                !TokenStream.isKeyword(key) &&\n                TokenStream.isJSIdentifier(key) &&\n                // do not encode literally any non-literal characters that\n                // were unicode escaped.\n                NodeUtil.isLatin(key)) {\n              add(key);\n            } else {\n              // Determine if the string is a simple number.\n              double d = getSimpleNumber(key);\n              if (!Double.isNaN(d)) {\n                cc.addNumber(d);\n              } else {\n                addExpr(c, 1);\n              }\n            }\n            add(\":\");\n            addExpr(c.getFirstChild(), 1);\n          }\n        }\n        add(\"}\");\n        if (needsParens) {\n          add(\")\");\n        }\n        break;\n      }\n\n      case Token.SWITCH:\n        add(\"switch(\");\n        add(first);\n        add(\")\");\n        cc.beginBlock();\n        addAllSiblings(first.getNext());\n        cc.endBlock(context == Context.STATEMENT);\n        break;\n\n      case Token.CASE:\n        Preconditions.checkState(childCount == 2);\n        add(\"case \");\n        add(first);\n        addCaseBody(last);\n        break;\n\n      case Token.DEFAULT:\n        Preconditions.checkState(childCount == 1);\n        add(\"default\");\n        addCaseBody(first);\n        break;\n\n      case Token.LABEL:\n        Preconditions.checkState(childCount == 2);\n        if (first.getType() != Token.LABEL_NAME) {\n          throw new Error(\"Unexpected token type. Should be LABEL_NAME.\");\n        }\n        add(first);\n        add(\":\");\n        addNonEmptyStatement(\n            last, getContextForNonEmptyExpression(context), true);\n        break;\n\n      // This node is auto generated in anonymous functions and should just get\n      // ignored for our purposes.\n      case Token.SETNAME:\n        break;\n\n      default:\n        throw new Error(\"Unknown type \" + type + \"\\n\" + n.toStringTree());\n    }\n\n    cc.endSourceMapping(n);\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "CodeGenerator.add",
    "class_name": "com.google.javascript.jscomp.CodeGenerator",
    "signature": "com.google.javascript.jscomp.CodeGenerator.add(String)",
    "snippet": "  void add(String str) {\n    cc.add(str);\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "CodeGenerator.addExpr",
    "class_name": "com.google.javascript.jscomp.CodeGenerator",
    "signature": "com.google.javascript.jscomp.CodeGenerator.addExpr(Node,int,Context)",
    "snippet": "  private void addExpr(Node n, int minPrecedence, Context context) {\n    if ((NodeUtil.precedence(n.getType()) < minPrecedence) ||\n        ((context == Context.IN_FOR_INIT_CLAUSE) &&\n        (n.getType() == Token.IN))){\n      add(\"(\");\n      add(n, clearContextForNoInOperator(context));\n      add(\")\");\n    } else {\n      add(n, context);\n    }\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "CodeGenerator.addIdentifier",
    "class_name": "com.google.javascript.jscomp.CodeGenerator",
    "signature": "com.google.javascript.jscomp.CodeGenerator.addIdentifier(String)",
    "snippet": "  private void addIdentifier(String identifier) {\n    cc.addIdentifier(identifierEscape(identifier));\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "CodeGenerator.addLeftExpr",
    "class_name": "com.google.javascript.jscomp.CodeGenerator",
    "signature": "com.google.javascript.jscomp.CodeGenerator.addLeftExpr(Node,int,Context)",
    "snippet": "  void addLeftExpr(Node n, int minPrecedence, Context context) {\n    addExpr(n, minPrecedence, context);\n  }",
    "comment": " Adds a node at the left-hand side of an expression. Unlike {@link #addExpr(Node,int)}, this preserves information about the context.  The left side of an expression is special because in the JavaScript grammar, certain tokens may be parsed differently when they are at the beginning of a statement. For example, \"{}\" is parsed as a block, but \"{'x': 'y'}\" is parsed as an object literal. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "CodeGenerator.addList",
    "class_name": "com.google.javascript.jscomp.CodeGenerator",
    "signature": "com.google.javascript.jscomp.CodeGenerator.addList(Node)",
    "snippet": "  void addList(Node firstInList) {\n    addList(firstInList, true, Context.OTHER);\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "CodeGenerator.addList",
    "class_name": "com.google.javascript.jscomp.CodeGenerator",
    "signature": "com.google.javascript.jscomp.CodeGenerator.addList(Node,boolean,Context)",
    "snippet": "  void addList(Node firstInList, boolean isArrayOrFunctionArgument,\n               Context lhsContext) {\n    for (Node n = firstInList; n != null; n = n.getNext()) {\n      boolean isFirst = n == firstInList;\n      if (isFirst) {\n        addLeftExpr(n, isArrayOrFunctionArgument ? 1 : 0, lhsContext);\n      } else {\n        cc.listSeparator();\n        addExpr(n, isArrayOrFunctionArgument ? 1 : 0);\n      }\n    }\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "CodeGenerator.getContextForNoInOperator",
    "class_name": "com.google.javascript.jscomp.CodeGenerator",
    "signature": "com.google.javascript.jscomp.CodeGenerator.getContextForNoInOperator(Context)",
    "snippet": "  private  Context getContextForNoInOperator(Context context) {\n    return (context == Context.IN_FOR_INIT_CLAUSE\n        ? Context.IN_FOR_INIT_CLAUSE : Context.OTHER);\n  }",
    "comment": " If we're in a IN_FOR_INIT_CLAUSE, we can't permit in operators in the expression.  Pass on the IN_FOR_INIT_CLAUSE flag through subexpressions. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "CodeGenerator.identifierEscape",
    "class_name": "com.google.javascript.jscomp.CodeGenerator",
    "signature": "com.google.javascript.jscomp.CodeGenerator.identifierEscape(String)",
    "snippet": "  static String identifierEscape(String s) {\n    // First check if escaping is needed at all -- in most cases it isn't.\n    if (NodeUtil.isLatin(s)) {\n      return s;\n    }\n\n    // Now going through the string to escape non-latin characters if needed.\n    StringBuilder sb = new StringBuilder();\n    for (int i = 0; i < s.length(); i++) {\n      char c = s.charAt(i);\n      // Identifiers should always go to Latin1/ ASCII characters because\n      // different browser's rules for valid identifier characters are\n      // crazy.\n      if (c > 0x1F && c < 0x7F) {\n        sb.append(c);\n      } else {\n        appendHexJavaScriptRepresentation(sb, c);\n      }\n    }\n    return sb.toString();\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "CodePrinter.toSource",
    "class_name": "com.google.javascript.jscomp.CodePrinter",
    "signature": "com.google.javascript.jscomp.CodePrinter.toSource(Node,Format,boolean,int,SourceMap,DetailLevel,Charset,boolean)",
    "snippet": "  private static String toSource(Node root, Format outputFormat,\n                                 boolean lineBreak,  int lineLengthThreshold,\n                                 SourceMap sourceMap,\n                                 SourceMap.DetailLevel sourceMapDetailLevel,\n                                 Charset outputCharset,\n                                 boolean tagAsStrict) {\n    Preconditions.checkState(sourceMapDetailLevel != null);\n\n    boolean createSourceMap = (sourceMap != null);\n    MappedCodePrinter mcp =\n        outputFormat == Format.COMPACT\n        ? new CompactCodePrinter(\n            lineBreak, lineLengthThreshold,\n            createSourceMap, sourceMapDetailLevel)\n        : new PrettyCodePrinter(\n            lineLengthThreshold, createSourceMap, sourceMapDetailLevel);\n    CodeGenerator cg =\n        outputFormat == Format.TYPED\n        ? new TypedCodeGenerator(mcp, outputCharset)\n        : new CodeGenerator(mcp, outputCharset);\n\n    if (tagAsStrict) {\n      cg.tagAsStrict();\n    }\n\n    cg.add(root);\n    mcp.endFile();\n\n    String code = mcp.getCode();\n\n    if (createSourceMap) {\n      mcp.generateSourceMap(sourceMap);\n    }\n\n    return code;\n  }",
    "comment": " Converts a tree to js code ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "Builder.build",
    "class_name": "com.google.javascript.jscomp.CodePrinter$Builder",
    "signature": "com.google.javascript.jscomp.CodePrinter$Builder.build()",
    "snippet": "    String build() {\n      if (root == null) {\n        throw new IllegalStateException(\n            \"Cannot build without root node being specified\");\n      }\n\n      Format outputFormat = outputTypes\n          ? Format.TYPED\n          : prettyPrint\n              ? Format.PRETTY\n              : Format.COMPACT;\n\n      return toSource(root, outputFormat, lineBreak, lineLengthThreshold,\n          sourceMap, sourceMapDetailLevel, outputCharset, tagAsStrict);\n    }",
    "comment": " Generates the source code and returns it. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "Builder.setLineBreak",
    "class_name": "com.google.javascript.jscomp.CodePrinter$Builder",
    "signature": "com.google.javascript.jscomp.CodePrinter$Builder.setLineBreak(boolean)",
    "snippet": "    Builder setLineBreak(boolean lineBreak) {\n      this.lineBreak = lineBreak;\n      return this;\n    }",
    "comment": " Sets whether line breaking should be done automatically. @param lineBreak If true, line breaking is done automatically. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "Builder.setLineLengthThreshold",
    "class_name": "com.google.javascript.jscomp.CodePrinter$Builder",
    "signature": "com.google.javascript.jscomp.CodePrinter$Builder.setLineLengthThreshold(int)",
    "snippet": "    Builder setLineLengthThreshold(int threshold) {\n      this.lineLengthThreshold = threshold;\n      return this;\n    }",
    "comment": " Sets the line length threshold that will be used to determine when to break lines, if line breaking is on.  @param threshold The line length threshold. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "Builder.setOutputCharset",
    "class_name": "com.google.javascript.jscomp.CodePrinter$Builder",
    "signature": "com.google.javascript.jscomp.CodePrinter$Builder.setOutputCharset(Charset)",
    "snippet": "    Builder setOutputCharset(Charset outCharset) {\n      this.outputCharset = outCharset;\n      return this;\n    }",
    "comment": " Set the charset to use when determining what characters need to be escaped in the output. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "Builder.setPrettyPrint",
    "class_name": "com.google.javascript.jscomp.CodePrinter$Builder",
    "signature": "com.google.javascript.jscomp.CodePrinter$Builder.setPrettyPrint(boolean)",
    "snippet": "    Builder setPrettyPrint(boolean prettyPrint) {\n      this.prettyPrint = prettyPrint;\n      return this;\n    }",
    "comment": " Sets whether pretty printing should be used. @param prettyPrint If true, pretty printing will be used. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "Builder.setSourceMap",
    "class_name": "com.google.javascript.jscomp.CodePrinter$Builder",
    "signature": "com.google.javascript.jscomp.CodePrinter$Builder.setSourceMap(SourceMap)",
    "snippet": "    Builder setSourceMap(SourceMap sourceMap) {\n      this.sourceMap = sourceMap;\n      return this;\n    }",
    "comment": " Sets the source map to which to write the metadata about the generated source code.  @param sourceMap The source map. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "Builder.setSourceMapDetailLevel",
    "class_name": "com.google.javascript.jscomp.CodePrinter$Builder",
    "signature": "com.google.javascript.jscomp.CodePrinter$Builder.setSourceMapDetailLevel(DetailLevel)",
    "snippet": "    Builder setSourceMapDetailLevel(SourceMap.DetailLevel level) {\n      Preconditions.checkState(level != null);\n      this.sourceMapDetailLevel = level;\n      return this;\n    }",
    "comment": " @param level The detail level to use. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "Builder.setTagAsStrict",
    "class_name": "com.google.javascript.jscomp.CodePrinter$Builder",
    "signature": "com.google.javascript.jscomp.CodePrinter$Builder.setTagAsStrict(boolean)",
    "snippet": "    Builder setTagAsStrict(boolean tagAsStrict) {\n      this.tagAsStrict = tagAsStrict;\n      return this;\n    }",
    "comment": " Set whether the output should be tags as ECMASCRIPT 5 Strict. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "CompactCodePrinter.append",
    "class_name": "com.google.javascript.jscomp.CodePrinter$CompactCodePrinter",
    "signature": "com.google.javascript.jscomp.CodePrinter$CompactCodePrinter.append(String)",
    "snippet": "    @Override\n    void append(String str) {\n      code.append(str);\n      lineLength += str.length();\n    }",
    "comment": " Appends a string to the code, keeping track of the current line length. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "CompactCodePrinter.maybeCutLine",
    "class_name": "com.google.javascript.jscomp.CodePrinter$CompactCodePrinter",
    "signature": "com.google.javascript.jscomp.CodePrinter$CompactCodePrinter.maybeCutLine()",
    "snippet": "    @Override\n    void maybeCutLine() {\n      if (lineLength > lineLengthThreshold) {\n        // Use the preferred position provided it will break the line.\n        if (preferredBreakPosition > lineStartPosition &&\n            preferredBreakPosition < lineStartPosition + lineLength) {\n          int position = preferredBreakPosition;\n          code.insert(position, '\\n');\n          reportLineCut(lineIndex, position - lineStartPosition);\n          lineIndex++;\n          lineLength -= (position - lineStartPosition);\n          lineStartPosition = position + 1;\n        } else {\n          startNewLine();\n        }\n      }\n    }",
    "comment": " This may start a new line if the current line is longer than the line length threshold. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "CompactCodePrinter.maybeLineBreak",
    "class_name": "com.google.javascript.jscomp.CodePrinter$CompactCodePrinter",
    "signature": "com.google.javascript.jscomp.CodePrinter$CompactCodePrinter.maybeLineBreak()",
    "snippet": "    @Override\n    void maybeLineBreak() {\n      if (lineBreak) {\n        if (sawFunction) {\n          startNewLine();\n          sawFunction = false;\n        }\n      }\n\n      // Since we are at a legal line break, can we upgrade the\n      // preferred break position?  We prefer to break after a\n      // semicolon rather than before it.\n      int len = code.length();\n      if (preferredBreakPosition == len - 1) {\n        char ch = code.charAt(len - 1);\n        if (ch == ';') {\n          preferredBreakPosition = len;\n        }\n      }\n      maybeCutLine();\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "CompactCodePrinter.notePreferredLineBreak",
    "class_name": "com.google.javascript.jscomp.CodePrinter$CompactCodePrinter",
    "signature": "com.google.javascript.jscomp.CodePrinter$CompactCodePrinter.notePreferredLineBreak()",
    "snippet": "    @Override\n    void notePreferredLineBreak() {\n      preferredBreakPosition = code.length();\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "MappedCodePrinter.endSourceMapping",
    "class_name": "com.google.javascript.jscomp.CodePrinter$MappedCodePrinter",
    "signature": "com.google.javascript.jscomp.CodePrinter$MappedCodePrinter.endSourceMapping(Node)",
    "snippet": "    @Override\n    void endSourceMapping(Node node) {\n      if (createSrcMap && !mappings.isEmpty() && mappings.peek().node == node) {\n        Mapping mapping = mappings.pop();\n        int line = getCurrentLineIndex();\n        int index = getCurrentCharIndex();\n        Preconditions.checkState(line >= 0);\n        mapping.end = new FilePosition(line, index);\n      }\n    }",
    "comment": " Finishes the source mapping for the given node at the current position. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "MappedCodePrinter.getCode",
    "class_name": "com.google.javascript.jscomp.CodePrinter$MappedCodePrinter",
    "signature": "com.google.javascript.jscomp.CodePrinter$MappedCodePrinter.getCode()",
    "snippet": "    public String getCode() {\n      return code.toString();\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "MappedCodePrinter.getLastChar",
    "class_name": "com.google.javascript.jscomp.CodePrinter$MappedCodePrinter",
    "signature": "com.google.javascript.jscomp.CodePrinter$MappedCodePrinter.getLastChar()",
    "snippet": "    @Override\n    char getLastChar() {\n      return (code.length() > 0) ? code.charAt(code.length() - 1) : '\\0';\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "MappedCodePrinter.startSourceMapping",
    "class_name": "com.google.javascript.jscomp.CodePrinter$MappedCodePrinter",
    "signature": "com.google.javascript.jscomp.CodePrinter$MappedCodePrinter.startSourceMapping(Node)",
    "snippet": "    @Override\n    void startSourceMapping(Node node) {\n      Preconditions.checkState(sourceMapDetailLevel != null);\n      Preconditions.checkState(node != null);\n      if (createSrcMap\n          && node.getSourceFileName() != null\n          && node.getLineno() > 0\n          && sourceMapDetailLevel.apply(node)) {\n        int line = getCurrentLineIndex();\n        int index = getCurrentCharIndex();\n        Preconditions.checkState(line >= 0);\n        Mapping mapping = new Mapping();\n        mapping.node = node;\n        mapping.start = new FilePosition(line, index);\n        mappings.push(mapping);\n        allMappings.add(mapping);\n      }\n    }",
    "comment": " Starts the source mapping for the given node at the current position. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "AssertionFunctionSpec.getFunctionName",
    "class_name": "com.google.javascript.jscomp.CodingConvention$AssertionFunctionSpec",
    "signature": "com.google.javascript.jscomp.CodingConvention$AssertionFunctionSpec.getFunctionName()",
    "snippet": "    public String getFunctionName() {\n      return functionName;\n    }",
    "comment": "Returns the name of the function. */",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "CollapseVariableDeclarations.CollapseVariableDeclarations",
    "class_name": "com.google.javascript.jscomp.CollapseVariableDeclarations",
    "signature": "com.google.javascript.jscomp.CollapseVariableDeclarations.CollapseVariableDeclarations(AbstractCompiler)",
    "snippet": "  CollapseVariableDeclarations(AbstractCompiler compiler) {\n    Preconditions.checkState(!compiler.getLifeCycleStage().isNormalized());\n    this.compiler = compiler;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "CollapseVariableDeclarations.process",
    "class_name": "com.google.javascript.jscomp.CollapseVariableDeclarations",
    "signature": "com.google.javascript.jscomp.CollapseVariableDeclarations.process(Node,Node)",
    "snippet": "  public void process(Node externs, Node root) {\n    collapses.clear();\n    nodesToCollapse.clear();\n\n    NodeTraversal.traverse(compiler, root, new GatherCollapses());\n\n    if (!collapses.isEmpty()) {\n      applyCollapses();\n      compiler.reportCodeChange();\n    }\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "GatherCollapses.canBeRedeclared",
    "class_name": "com.google.javascript.jscomp.CollapseVariableDeclarations$GatherCollapses",
    "signature": "com.google.javascript.jscomp.CollapseVariableDeclarations$GatherCollapses.canBeRedeclared(Node,Scope)",
    "snippet": "    private boolean canBeRedeclared(Node n, Scope s) {\n      if (!NodeUtil.isExprAssign(n)) {\n        return false;\n      }\n      Node assign = n.getFirstChild();\n      Node lhs = assign.getFirstChild();\n\n      if (!NodeUtil.isName(lhs)) {\n        return false;\n      }\n\n      Var var = s.getVar(lhs.getString());\n      return var != null &&\n          var.getScope() == s && !blacklistedVars.contains(var);\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "GatherCollapses.visit",
    "class_name": "com.google.javascript.jscomp.CollapseVariableDeclarations$GatherCollapses",
    "signature": "com.google.javascript.jscomp.CollapseVariableDeclarations$GatherCollapses.visit(NodeTraversal,Node,Node)",
    "snippet": "    public void visit(NodeTraversal t, Node n, Node parent) {\n      if (n.getType() == Token.VAR) {\n        blacklistStubVars(t, n);\n      }\n\n      // Only care about var nodes\n      if (n.getType() != Token.VAR && !canBeRedeclared(n, t.getScope())) return;\n\n      // If we've already looked at this node, skip it\n      if (nodesToCollapse.contains(n)) return;\n\n      // Adjacent VAR children of an IF node are the if and else parts and can't\n      // be collapsed\n      if (parent.getType() == Token.IF) return;\n\n      Node varNode = n;\n\n      boolean hasVar = n.getType() == Token.VAR;\n\n      // Find variable declarations that follow this one (if any)\n      n = n.getNext();\n\n      boolean hasNodesToCollapse = false;\n\n      while (n != null &&\n          (n.getType() == Token.VAR || canBeRedeclared(n, t.getScope()))) {\n\n        if (NodeUtil.isVar(n)) {\n          blacklistStubVars(t, n);\n          hasVar = true;\n        }\n\n        nodesToCollapse.add(n);\n        hasNodesToCollapse = true;\n\n        n = n.getNext();\n      }\n\n      if (hasNodesToCollapse && hasVar) {\n        nodesToCollapse.add(varNode);\n        collapses.add(new Collapse(varNode, n, parent));\n      }\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "CombinedCompilerPass.CombinedCompilerPass",
    "class_name": "com.google.javascript.jscomp.CombinedCompilerPass",
    "signature": "com.google.javascript.jscomp.CombinedCompilerPass.CombinedCompilerPass(AbstractCompiler,Callback[])",
    "snippet": "  CombinedCompilerPass(\n      AbstractCompiler compiler, Callback... callbacks) {\n    this(compiler, Lists.<Callback>newArrayList(callbacks));\n  }",
    "comment": " Creates a combined compiler pass. @param compiler the compiler ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "CombinedCompilerPass.CombinedCompilerPass",
    "class_name": "com.google.javascript.jscomp.CombinedCompilerPass",
    "signature": "com.google.javascript.jscomp.CombinedCompilerPass.CombinedCompilerPass(AbstractCompiler,List)",
    "snippet": "  CombinedCompilerPass(\n      AbstractCompiler compiler, List<Callback> callbacks) {\n    this.compiler = compiler;\n    this.callbacks = new CallbackWrapper[callbacks.size()];\n    for (int i = 0; i < callbacks.size(); i++) {\n      this.callbacks[i] = new CallbackWrapper(callbacks.get(i));\n    }\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "CombinedCompilerPass.enterScope",
    "class_name": "com.google.javascript.jscomp.CombinedCompilerPass",
    "signature": "com.google.javascript.jscomp.CombinedCompilerPass.enterScope(NodeTraversal)",
    "snippet": "  @Override\n  public void enterScope(NodeTraversal t) {\n    for (CallbackWrapper callback : callbacks) {\n      callback.enterScopeIfActive(t);\n    }\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "CombinedCompilerPass.exitScope",
    "class_name": "com.google.javascript.jscomp.CombinedCompilerPass",
    "signature": "com.google.javascript.jscomp.CombinedCompilerPass.exitScope(NodeTraversal)",
    "snippet": "  @Override\n  public void exitScope(NodeTraversal t) {\n    for (CallbackWrapper callback : callbacks) {\n      callback.exitScopeIfActive(t);\n    }\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "CombinedCompilerPass.process",
    "class_name": "com.google.javascript.jscomp.CombinedCompilerPass",
    "signature": "com.google.javascript.jscomp.CombinedCompilerPass.process(Node,Node)",
    "snippet": "  @Override\n  public final void process(Node externs, Node root) {\n    NodeTraversal.traverse(compiler, root, this);\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "CombinedCompilerPass.shouldTraverse",
    "class_name": "com.google.javascript.jscomp.CombinedCompilerPass",
    "signature": "com.google.javascript.jscomp.CombinedCompilerPass.shouldTraverse(NodeTraversal,Node,Node)",
    "snippet": "  @Override\n  public boolean shouldTraverse(NodeTraversal t, Node n, Node parent) {\n    for (CallbackWrapper callback : callbacks) {\n      callback.shouldTraverseIfActive(t, n, parent);\n    }\n    // Note that this method could return false if all callbacks are inactive.\n    // This apparent optimization would make this method more expensive\n    // in the typical case where not all nodes are inactive. It is\n    // very unlikely that many all callbacks would be inactive at the same\n    // time (indeed, there are several checking passes that never return false).\n    return true;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "CombinedCompilerPass.traverse",
    "class_name": "com.google.javascript.jscomp.CombinedCompilerPass",
    "signature": "com.google.javascript.jscomp.CombinedCompilerPass.traverse(AbstractCompiler,Node,List)",
    "snippet": "  static void traverse(AbstractCompiler compiler, Node root,\n      List<Callback> callbacks) {\n    if (callbacks.size() == 1) {\n      NodeTraversal.traverse(compiler, root, callbacks.get(0));\n    } else {\n      (new CombinedCompilerPass(compiler, callbacks)).process(null, root);\n    }\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "CombinedCompilerPass.visit",
    "class_name": "com.google.javascript.jscomp.CombinedCompilerPass",
    "signature": "com.google.javascript.jscomp.CombinedCompilerPass.visit(NodeTraversal,Node,Node)",
    "snippet": "  @Override\n  public void visit(NodeTraversal t, Node n, Node parent) {\n    for (CallbackWrapper callback : callbacks) {\n      callback.visitOrMaybeActivate(t, n, parent);\n    }\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "CallbackWrapper.enterScopeIfActive",
    "class_name": "com.google.javascript.jscomp.CombinedCompilerPass$CallbackWrapper",
    "signature": "com.google.javascript.jscomp.CombinedCompilerPass$CallbackWrapper.enterScopeIfActive(NodeTraversal)",
    "snippet": "    void enterScopeIfActive(NodeTraversal t) {\n      if (isActive() && scopedCallback != null) {\n        scopedCallback.enterScope(t);\n      }\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "CallbackWrapper.exitScopeIfActive",
    "class_name": "com.google.javascript.jscomp.CombinedCompilerPass$CallbackWrapper",
    "signature": "com.google.javascript.jscomp.CombinedCompilerPass$CallbackWrapper.exitScopeIfActive(NodeTraversal)",
    "snippet": "    void exitScopeIfActive(NodeTraversal t) {\n      if (isActive() && scopedCallback != null) {\n        scopedCallback.exitScope(t);\n      }\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "CallbackWrapper.isActive",
    "class_name": "com.google.javascript.jscomp.CombinedCompilerPass$CallbackWrapper",
    "signature": "com.google.javascript.jscomp.CombinedCompilerPass$CallbackWrapper.isActive()",
    "snippet": "    boolean isActive() {\n      return waiting == null;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "CallbackWrapper.shouldTraverseIfActive",
    "class_name": "com.google.javascript.jscomp.CombinedCompilerPass$CallbackWrapper",
    "signature": "com.google.javascript.jscomp.CombinedCompilerPass$CallbackWrapper.shouldTraverseIfActive(NodeTraversal,Node,Node)",
    "snippet": "    void shouldTraverseIfActive(NodeTraversal t, Node n, Node parent) {\n      if (isActive() && !callback.shouldTraverse(t, n, parent)) {\n        waiting = n;\n      }\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "CallbackWrapper.visitOrMaybeActivate",
    "class_name": "com.google.javascript.jscomp.CombinedCompilerPass$CallbackWrapper",
    "signature": "com.google.javascript.jscomp.CombinedCompilerPass$CallbackWrapper.visitOrMaybeActivate(NodeTraversal,Node,Node)",
    "snippet": "    void visitOrMaybeActivate(NodeTraversal t, Node n, Node parent) {\n      if (isActive()) {\n        callback.visit(t, n, parent);\n      } else if (waiting == n) {\n        waiting = null;\n      }\n    }",
    "comment": " Visits the node unless the wrapped callback is inactive. Activates the callback if appropriate. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "CommandLineRunner.CommandLineRunner",
    "class_name": "com.google.javascript.jscomp.CommandLineRunner",
    "signature": "com.google.javascript.jscomp.CommandLineRunner.CommandLineRunner(String[],PrintStream,PrintStream)",
    "snippet": "  protected CommandLineRunner(String[] args, PrintStream out, PrintStream err) {\n    super(out, err);\n    initConfigFromFlags(args, err);\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "CommandLineRunner.createCompiler",
    "class_name": "com.google.javascript.jscomp.CommandLineRunner",
    "signature": "com.google.javascript.jscomp.CommandLineRunner.createCompiler()",
    "snippet": "  @Override\n  protected Compiler createCompiler() {\n    return new Compiler(getErrorPrintStream());\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "CommandLineRunner.createExterns",
    "class_name": "com.google.javascript.jscomp.CommandLineRunner",
    "signature": "com.google.javascript.jscomp.CommandLineRunner.createExterns()",
    "snippet": "  @Override\n  protected List<JSSourceFile> createExterns() throws FlagUsageException,\n      IOException {\n    List<JSSourceFile> externs = super.createExterns();\n    if (flags.use_only_custom_externs || isInTestMode()) {\n      return externs;\n    } else {\n      List<JSSourceFile> defaultExterns = getDefaultExterns();\n      defaultExterns.addAll(externs);\n      return defaultExterns;\n    }\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "CommandLineRunner.createOptions",
    "class_name": "com.google.javascript.jscomp.CommandLineRunner",
    "signature": "com.google.javascript.jscomp.CommandLineRunner.createOptions()",
    "snippet": "  @Override\n  protected CompilerOptions createOptions() {\n    CompilerOptions options = new CompilerOptions();\n    options.setCodingConvention(new ClosureCodingConvention());\n    CompilationLevel level = flags.compilation_level;\n    level.setOptionsForCompilationLevel(options);\n    if (flags.debug) {\n      level.setDebugOptionsForCompilationLevel(options);\n    }\n\n    if(flags.generate_exports) {\n      options.setGenerateExports(flags.generate_exports);\n    }\n\n    WarningLevel wLevel = flags.warning_level;\n    wLevel.setOptionsForWarningLevel(options);\n    for (FormattingOption formattingOption : flags.formatting) {\n      formattingOption.applyToOptions(options);\n    }\n\n    options.closurePass = flags.process_closure_primitives;\n    return options;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "CommandLineRunner.initConfigFromFlags",
    "class_name": "com.google.javascript.jscomp.CommandLineRunner",
    "signature": "com.google.javascript.jscomp.CommandLineRunner.initConfigFromFlags(String[],PrintStream)",
    "snippet": "  private void initConfigFromFlags(String[] args, PrintStream err) {\n\n    List<String> processedArgs = processArgs(args);\n\n    CmdLineParser parser = new CmdLineParser(flags);\n    Flags.warningGuardSpec.clear();\n    isConfigValid = true;\n    try {\n      parser.parseArgument(processedArgs.toArray(new String[] {}));\n      // For contains --flagfile flag\n      if (!flags.flag_file.equals(\"\")) {\n        processFlagFile(err);\n      }\n    } catch (CmdLineException e) {\n      err.println(e.getMessage());\n      isConfigValid = false;\n    } catch (IOException ioErr) {\n      err.println(\"ERROR - \" + flags.flag_file + \" read error.\");\n      isConfigValid = false;\n    }\n\n    if (flags.version) {\n      ResourceBundle config = ResourceBundle.getBundle(configResource);\n      err.println(\n          \"Closure Compiler (http://code.google.com/closure/compiler)\\n\" +\n          \"Version: \" + config.getString(\"compiler.version\") + \"\\n\" +\n          \"Built on: \" + config.getString(\"compiler.date\"));\n      err.flush();\n    }\n\n    if (!isConfigValid || flags.display_help) {\n      isConfigValid = false;\n      parser.printUsage(err);\n    } else {\n      getCommandLineConfig()\n          .setPrintTree(flags.print_tree)\n          .setPrintAst(flags.print_ast)\n          .setPrintPassGraph(flags.print_pass_graph)\n          .setJscompDevMode(flags.jscomp_dev_mode)\n          .setLoggingLevel(flags.logging_level)\n          .setExterns(flags.externs)\n          .setJs(flags.js)\n          .setJsOutputFile(flags.js_output_file)\n          .setModule(flags.module)\n          .setVariableMapInputFile(flags.variable_map_input_file)\n          .setPropertyMapInputFile(flags.property_map_input_file)\n          .setVariableMapOutputFile(flags.variable_map_output_file)\n          .setCreateNameMapFiles(flags.create_name_map_files)\n          .setPropertyMapOutputFile(flags.property_map_output_file)\n          .setCodingConvention(flags.third_party ?\n               new DefaultCodingConvention() :\n               new ClosureCodingConvention())\n          .setSummaryDetailLevel(flags.summary_detail_level)\n          .setOutputWrapper(flags.output_wrapper)\n          .setModuleWrapper(flags.module_wrapper)\n          .setModuleOutputPathPrefix(flags.module_output_path_prefix)\n          .setCreateSourceMap(flags.create_source_map)\n          .setSourceMapFormat(flags.source_map_format)\n          .setWarningGuardSpec(Flags.warningGuardSpec)\n          .setDefine(flags.define)\n          .setCharset(flags.charset)\n          .setManageClosureDependencies(flags.manage_closure_dependencies)\n          .setClosureEntryPoints(flags.closure_entry_point)\n          .setOutputManifest(ImmutableList.of(flags.output_manifest))\n          .setAcceptConstKeyword(flags.accept_const_keyword)\n          .setLanguageIn(flags.language_in);\n    }\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "CommandLineRunner.processArgs",
    "class_name": "com.google.javascript.jscomp.CommandLineRunner",
    "signature": "com.google.javascript.jscomp.CommandLineRunner.processArgs(String[])",
    "snippet": "  private List<String> processArgs(String[] args) {\n    // Args4j has a different format that the old command-line parser.\n    // So we use some voodoo to get the args into the format that args4j\n    // expects.\n    Pattern argPattern = Pattern.compile(\"(--[a-zA-Z_]+)=(.*)\");\n    Pattern quotesPattern = Pattern.compile(\"^['\\\"](.*)['\\\"]$\");\n    List<String> processedArgs = Lists.newArrayList();\n\n    for (String arg : args) {\n      Matcher matcher = argPattern.matcher(arg);\n      if (matcher.matches()) {\n        processedArgs.add(matcher.group(1));\n\n        String value = matcher.group(2);\n        Matcher quotesMatcher = quotesPattern.matcher(value);\n        if (quotesMatcher.matches()) {\n          processedArgs.add(quotesMatcher.group(1));\n        } else {\n          processedArgs.add(value);\n        }\n      } else {\n        processedArgs.add(arg);\n      }\n    }\n\n    return processedArgs;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "CommandLineRunner.shouldRunCompiler",
    "class_name": "com.google.javascript.jscomp.CommandLineRunner",
    "signature": "com.google.javascript.jscomp.CommandLineRunner.shouldRunCompiler()",
    "snippet": "  public boolean shouldRunCompiler() {\n    return this.isConfigValid;\n  }",
    "comment": " @return Whether the configuration is valid. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "WarningGuardSetter.addValue",
    "class_name": "com.google.javascript.jscomp.CommandLineRunner$Flags$WarningGuardSetter",
    "signature": "com.google.javascript.jscomp.CommandLineRunner$Flags$WarningGuardSetter.addValue(Object)",
    "snippet": "      @Override public void addValue(Object value) throws CmdLineException {\n        proxy.addValue((String) value);\n        warningGuardSpec.add(level, (String) value);\n      }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "CompilationLevel.applySafeCompilationOptions",
    "class_name": "com.google.javascript.jscomp.CompilationLevel",
    "signature": "com.google.javascript.jscomp.CompilationLevel.applySafeCompilationOptions(CompilerOptions)",
    "snippet": "  private static void applySafeCompilationOptions(CompilerOptions options) {\n    // Does not call applyBasicCompilationOptions(options) because the call to\n    // skipAllCompilerPasses() cannot be easily undone.\n    options.closurePass = true;\n    options.variableRenaming = VariableRenamingPolicy.LOCAL;\n    options.shadowVariables = true;\n    options.inlineLocalVariables = true;\n    options.flowSensitiveInlineVariables = true;\n    options.inlineLocalFunctions = true;\n    options.checkGlobalThisLevel = CheckLevel.OFF;\n    options.foldConstants = true;\n    options.coalesceVariableNames = true;\n    options.deadAssignmentElimination = true;\n    options.collapseVariableDeclarations = true;\n    options.convertToDottedProperties = true;\n    options.labelRenaming = true;\n    options.removeDeadCode = true;\n    options.optimizeArgumentsArray = true;\n    options.removeUnusedVars = false;\n    options.removeUnusedLocalVars = true;\n    options.collapseObjectLiterals = true;\n\n    // Allows annotations that are not standard.\n    options.setWarningLevel(DiagnosticGroups.NON_STANDARD_JSDOC,\n        CheckLevel.OFF);\n  }",
    "comment": " Add options that are safe. Safe means options that won't break the JavaScript code even if no symbols are exported and no coding convention is used. @param options The CompilerOptions object to set the options on. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "CompilationLevel.setOptionsForCompilationLevel",
    "class_name": "com.google.javascript.jscomp.CompilationLevel",
    "signature": "com.google.javascript.jscomp.CompilationLevel.setOptionsForCompilationLevel(CompilerOptions)",
    "snippet": "  public void setOptionsForCompilationLevel(CompilerOptions options) {\n    switch (this) {\n      case WHITESPACE_ONLY:\n        applyBasicCompilationOptions(options);\n        break;\n      case SIMPLE_OPTIMIZATIONS:\n        applySafeCompilationOptions(options);\n        break;\n      case ADVANCED_OPTIMIZATIONS:\n        applyFullCompilationOptions(options);\n        break;\n      default:\n        throw new RuntimeException(\"Unknown compilation level.\");\n    }\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "Compiler.Compiler",
    "class_name": "com.google.javascript.jscomp.Compiler",
    "signature": "com.google.javascript.jscomp.Compiler.Compiler(PrintStream)",
    "snippet": "  public Compiler(PrintStream stream) {\n    addChangeHandler(recentChange);\n    outStream = stream;\n  }",
    "comment": " Creates n Compiler that reports errors and warnings to an output stream. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "Compiler.acceptConstKeyword",
    "class_name": "com.google.javascript.jscomp.Compiler",
    "signature": "com.google.javascript.jscomp.Compiler.acceptConstKeyword()",
    "snippet": "  @Override\n  public boolean acceptConstKeyword() {\n    return options.acceptConstKeyword;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "Compiler.addChangeHandler",
    "class_name": "com.google.javascript.jscomp.Compiler",
    "signature": "com.google.javascript.jscomp.Compiler.addChangeHandler(CodeChangeHandler)",
    "snippet": "  @Override\n  void addChangeHandler(CodeChangeHandler handler) {\n    codeChangeHandlers.add(handler);\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "Compiler.addToDebugLog",
    "class_name": "com.google.javascript.jscomp.Compiler",
    "signature": "com.google.javascript.jscomp.Compiler.addToDebugLog(String)",
    "snippet": "  @Override\n  void addToDebugLog(String str) {\n    debugLog.append(str);\n    debugLog.append('\\n');\n    logger.fine(str);\n  }",
    "comment": "Called from the compiler passes, adds debug info */",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "Compiler.check",
    "class_name": "com.google.javascript.jscomp.Compiler",
    "signature": "com.google.javascript.jscomp.Compiler.check()",
    "snippet": "  public void check() {\n    runCustomPasses(CustomPassExecutionTime.BEFORE_CHECKS);\n\n    PhaseOptimizer phaseOptimizer = new PhaseOptimizer(this, tracker);\n    if (options.devMode == DevMode.EVERY_PASS) {\n      phaseOptimizer.setSanityCheck(sanityCheck);\n    }\n    phaseOptimizer.consume(getPassConfig().getChecks());\n    phaseOptimizer.process(externsRoot, jsRoot);\n    if (hasErrors()) {\n      return;\n    }\n\n    // TODO(nicksantos): clean this up. The flow here is too hard to follow.\n    if (options.nameAnonymousFunctionsOnly) {\n      return;\n    }\n\n    if (options.removeTryCatchFinally) {\n      removeTryCatchFinally();\n    }\n\n    if (options.getTweakProcessing().shouldStrip() ||\n        !options.stripTypes.isEmpty() ||\n        !options.stripNameSuffixes.isEmpty() ||\n        !options.stripTypePrefixes.isEmpty() ||\n        !options.stripNamePrefixes.isEmpty()) {\n      stripCode(options.stripTypes, options.stripNameSuffixes,\n          options.stripTypePrefixes, options.stripNamePrefixes);\n    }\n\n    runCustomPasses(CustomPassExecutionTime.BEFORE_OPTIMIZATIONS);\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "Compiler.checkFirstModule",
    "class_name": "com.google.javascript.jscomp.Compiler",
    "signature": "com.google.javascript.jscomp.Compiler.checkFirstModule(List)",
    "snippet": "  private void checkFirstModule(List<JSModule> modules) {\n    if (modules.isEmpty()) {\n      report(JSError.make(EMPTY_MODULE_LIST_ERROR));\n    } else if (modules.get(0).getInputs().isEmpty() && modules.size() > 1) {\n      // The root module may only be empty if there is exactly 1 module.\n      report(JSError.make(EMPTY_ROOT_MODULE_ERROR,\n          modules.get(0).getName()));\n    }\n  }",
    "comment": " Verifies that at least one module has been provided and that the first one has at least one source code input. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "Compiler.compile",
    "class_name": "com.google.javascript.jscomp.Compiler",
    "signature": "com.google.javascript.jscomp.Compiler.compile()",
    "snippet": "  private Result compile() {\n    return runInCompilerThread(new Callable<Result>() {\n      public Result call() throws Exception {\n        compileInternal();\n        return getResult();\n      }\n    });\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "Compiler.compile",
    "class_name": "com.google.javascript.jscomp.Compiler",
    "signature": "com.google.javascript.jscomp.Compiler.compile(List,List,CompilerOptions)",
    "snippet": "  public Result compile(List<JSSourceFile> externs,\n      List<JSSourceFile> inputs, CompilerOptions options) {\n    // The compile method should only be called once.\n    Preconditions.checkState(jsRoot == null);\n\n    try {\n      init(externs, inputs, options);\n      if (hasErrors()) {\n        return getResult();\n      }\n      return compile();\n    } finally {\n      Tracer t = newTracer(\"generateReport\");\n      errorManager.generateReport();\n      stopTracer(t, \"generateReport\");\n    }\n  }",
    "comment": " Compiles a list of inputs. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "Compiler.compileInternal",
    "class_name": "com.google.javascript.jscomp.Compiler",
    "signature": "com.google.javascript.jscomp.Compiler.compileInternal()",
    "snippet": "  private void compileInternal() {\n    parse();\n    if (hasErrors()) {\n      return;\n    }\n\n    if (!precheck()) {\n      return;\n    }\n\n    if (options.nameAnonymousFunctionsOnly) {\n      // TODO(nicksantos): Move this into an instrument() phase maybe?\n      check();\n      return;\n    }\n\n    if (!options.skipAllPasses) {\n      check();\n      if (hasErrors()) {\n        return;\n      }\n\n      if (options.isExternExportsEnabled()\n          || options.externExportsPath != null) {\n        externExports();\n      }\n\n      // IDE-mode is defined to stop here, before the heavy rewriting begins.\n      if (!options.ideMode) {\n        optimize();\n      }\n    }\n\n    if (options.recordFunctionInformation) {\n      recordFunctionInformation();\n    }\n\n    if (options.devMode == DevMode.START_AND_END) {\n      runSanityCheck();\n    }\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "Compiler.createMessageFormatter",
    "class_name": "com.google.javascript.jscomp.Compiler",
    "signature": "com.google.javascript.jscomp.Compiler.createMessageFormatter()",
    "snippet": "  private MessageFormatter createMessageFormatter() {\n    boolean colorize = options.shouldColorizeErrorOutput();\n    return options.errorFormat.toFormatter(this, colorize);\n  }",
    "comment": " Creates a message formatter instance corresponding to the value of {@link CompilerOptions}. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "Compiler.createPassConfigInternal",
    "class_name": "com.google.javascript.jscomp.Compiler",
    "signature": "com.google.javascript.jscomp.Compiler.createPassConfigInternal()",
    "snippet": "  PassConfig createPassConfigInternal() {\n    return new DefaultPassConfig(options);\n  }",
    "comment": " Create the passes object. Clients should use setPassConfig instead of overriding this. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "Compiler.endPass",
    "class_name": "com.google.javascript.jscomp.Compiler",
    "signature": "com.google.javascript.jscomp.Compiler.endPass()",
    "snippet": "  void endPass() {\n    Preconditions.checkState(currentTracer != null,\n        \"Tracer should not be null at the end of a pass.\");\n    stopTracer(currentTracer, currentPassName);\n    String passToCheck = currentPassName;\n    currentPassName = null;\n    currentTracer = null;\n\n    maybeSanityCheck();\n  }",
    "comment": " Marks the end of a pass. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "Compiler.fillEmptyModules",
    "class_name": "com.google.javascript.jscomp.Compiler",
    "signature": "com.google.javascript.jscomp.Compiler.fillEmptyModules(List)",
    "snippet": "  private static void fillEmptyModules(List<JSModule> modules) {\n    for (JSModule module : modules) {\n      if (module.getInputs().isEmpty()) {\n        module.add(JSSourceFile.fromCode(\"[\" + module.getName() + \"]\", \"\"));\n      }\n    }\n  }",
    "comment": " Fill any empty modules with a place holder file. It makes any cross module motion easier. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "Compiler.getAllInputsFromModules",
    "class_name": "com.google.javascript.jscomp.Compiler",
    "signature": "com.google.javascript.jscomp.Compiler.getAllInputsFromModules(List)",
    "snippet": "  private static List<CompilerInput> getAllInputsFromModules(\n      List<JSModule> modules) {\n    List<CompilerInput> inputs = Lists.newArrayList();\n    Map<String, JSModule> inputMap = Maps.newHashMap();\n    for (JSModule module : modules) {\n      for (CompilerInput input : module.getInputs()) {\n        String inputName = input.getName();\n\n        // NOTE(nicksantos): If an input is in more than one module,\n        // it will show up twice in the inputs list, and then we\n        // will get an error down the line.\n        inputs.add(input);\n        inputMap.put(inputName, module);\n      }\n    }\n    return inputs;\n  }",
    "comment": " Builds a single list of all module inputs. Verifies that it contains no duplicates. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "Compiler.getCodingConvention",
    "class_name": "com.google.javascript.jscomp.Compiler",
    "signature": "com.google.javascript.jscomp.Compiler.getCodingConvention()",
    "snippet": "  @Override\n  public CodingConvention getCodingConvention() {\n    CodingConvention convention = options.getCodingConvention();\n    convention = convention != null ? convention : defaultCodingConvention;\n    return convention;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "Compiler.getCssRenamingMap",
    "class_name": "com.google.javascript.jscomp.Compiler",
    "signature": "com.google.javascript.jscomp.Compiler.getCssRenamingMap()",
    "snippet": "  @Override\n  CssRenamingMap getCssRenamingMap() {\n    return options.cssRenamingMap;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "Compiler.getDefaultErrorReporter",
    "class_name": "com.google.javascript.jscomp.Compiler",
    "signature": "com.google.javascript.jscomp.Compiler.getDefaultErrorReporter()",
    "snippet": "  @Override\n  ErrorReporter getDefaultErrorReporter() {\n    return defaultErrorReporter;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "Compiler.getDiagnosticGroups",
    "class_name": "com.google.javascript.jscomp.Compiler",
    "signature": "com.google.javascript.jscomp.Compiler.getDiagnosticGroups()",
    "snippet": "  protected DiagnosticGroups getDiagnosticGroups() {\n    return new DiagnosticGroups();\n  }",
    "comment": " The warning classes that are available from the command-line, and are suppressable by the {@code @suppress} annotation. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "Compiler.getErrorCount",
    "class_name": "com.google.javascript.jscomp.Compiler",
    "signature": "com.google.javascript.jscomp.Compiler.getErrorCount()",
    "snippet": "  public int getErrorCount() {\n    return errorManager.getErrorCount();\n  }",
    "comment": " Gets the number of errors. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "Compiler.getErrorLevel",
    "class_name": "com.google.javascript.jscomp.Compiler",
    "signature": "com.google.javascript.jscomp.Compiler.getErrorLevel(JSError)",
    "snippet": "  @Override\n  public CheckLevel getErrorLevel(JSError error) {\n    Preconditions.checkNotNull(options);\n    return warningsGuard.level(error);\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "Compiler.getErrorManager",
    "class_name": "com.google.javascript.jscomp.Compiler",
    "signature": "com.google.javascript.jscomp.Compiler.getErrorManager()",
    "snippet": "  @Override\n  public ErrorManager getErrorManager() {\n    if (options == null) {\n      initOptions(new CompilerOptions());\n    }\n    return errorManager;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "Compiler.getErrors",
    "class_name": "com.google.javascript.jscomp.Compiler",
    "signature": "com.google.javascript.jscomp.Compiler.getErrors()",
    "snippet": "  public JSError[] getErrors() {\n    return errorManager.getErrors();\n  }",
    "comment": " Returns the array of errors (never null). ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "Compiler.getExternsInOrder",
    "class_name": "com.google.javascript.jscomp.Compiler",
    "signature": "com.google.javascript.jscomp.Compiler.getExternsInOrder()",
    "snippet": "  List<CompilerInput> getExternsInOrder() {\n    return Collections.<CompilerInput>unmodifiableList(externs);\n  }",
    "comment": " Gets the externs in the order in which they are being processed. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "Compiler.getGlobalVarReferences",
    "class_name": "com.google.javascript.jscomp.Compiler",
    "signature": "com.google.javascript.jscomp.Compiler.getGlobalVarReferences()",
    "snippet": "  @Override\n  ReferenceMap getGlobalVarReferences() {\n    return globalRefMap;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "Compiler.getInput",
    "class_name": "com.google.javascript.jscomp.Compiler",
    "signature": "com.google.javascript.jscomp.Compiler.getInput(String)",
    "snippet": "  @Override\n  public CompilerInput getInput(String name) {\n    return inputsByName.get(name);\n  }",
    "comment": "interface, and which ones should always be injected.",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "Compiler.getInputsInOrder",
    "class_name": "com.google.javascript.jscomp.Compiler",
    "signature": "com.google.javascript.jscomp.Compiler.getInputsInOrder()",
    "snippet": "  @Override\n  List<CompilerInput> getInputsInOrder() {\n    return Collections.<CompilerInput>unmodifiableList(inputs);\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "Compiler.getModuleGraph",
    "class_name": "com.google.javascript.jscomp.Compiler",
    "signature": "com.google.javascript.jscomp.Compiler.getModuleGraph()",
    "snippet": "  @Override\n  JSModuleGraph getModuleGraph() {\n    return moduleGraph;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "Compiler.getParserConfig",
    "class_name": "com.google.javascript.jscomp.Compiler",
    "signature": "com.google.javascript.jscomp.Compiler.getParserConfig()",
    "snippet": "  @Override\n  Config getParserConfig() {\n    if (parserConfig == null) {\n      Config.LanguageMode mode;\n      switch (options.getLanguageIn()) {\n        case ECMASCRIPT3:\n          mode = Config.LanguageMode.ECMASCRIPT3;\n          break;\n        case ECMASCRIPT5:\n          mode = Config.LanguageMode.ECMASCRIPT5;\n          break;\n        case ECMASCRIPT5_STRICT:\n          mode = Config.LanguageMode.ECMASCRIPT5_STRICT;\n          break;\n        default:\n          throw new IllegalStateException(\"unexpected language mode\");\n      }\n\n      parserConfig = ParserRunner.createConfig(\n        isIdeMode(),\n        mode,\n        acceptConstKeyword(),\n        options.extraAnnotationNames);\n    }\n    return parserConfig;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "Compiler.getPassConfig",
    "class_name": "com.google.javascript.jscomp.Compiler",
    "signature": "com.google.javascript.jscomp.Compiler.getPassConfig()",
    "snippet": "  PassConfig getPassConfig() {\n    if (passes == null) {\n      passes = createPassConfigInternal();\n    }\n    return passes;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "Compiler.getResult",
    "class_name": "com.google.javascript.jscomp.Compiler",
    "signature": "com.google.javascript.jscomp.Compiler.getResult()",
    "snippet": "  public Result getResult() {\n    PassConfig.State state = getPassConfig().getIntermediateState();\n    return new Result(getErrors(), getWarnings(), debugLog.toString(),\n        state.variableMap, state.propertyMap,\n        state.anonymousFunctionNameMap, state.stringMap, functionInformationMap,\n        sourceMap, externExports, state.cssNames, state.idGeneratorMap);\n  }",
    "comment": " Returns the result of the compilation. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "Compiler.getReverseAbstractInterpreter",
    "class_name": "com.google.javascript.jscomp.Compiler",
    "signature": "com.google.javascript.jscomp.Compiler.getReverseAbstractInterpreter()",
    "snippet": "  @Override\n  public ReverseAbstractInterpreter getReverseAbstractInterpreter() {\n    if (abstractInterpreter == null) {\n      ChainableReverseAbstractInterpreter interpreter =\n          new SemanticReverseAbstractInterpreter(\n              getCodingConvention(), getTypeRegistry());\n      if (options.closurePass) {\n        interpreter = new ClosureReverseAbstractInterpreter(\n            getCodingConvention(), getTypeRegistry())\n            .append(interpreter).getFirst();\n      }\n      abstractInterpreter = interpreter;\n    }\n    return abstractInterpreter;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "Compiler.getSourceFileByName",
    "class_name": "com.google.javascript.jscomp.Compiler",
    "signature": "com.google.javascript.jscomp.Compiler.getSourceFileByName(String)",
    "snippet": "  private SourceFile getSourceFileByName(String sourceName) {\n    if (inputsByName.containsKey(sourceName)) {\n      return inputsByName.get(sourceName).getSourceFile();\n    }\n    return null;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "Compiler.getSourceLine",
    "class_name": "com.google.javascript.jscomp.Compiler",
    "signature": "com.google.javascript.jscomp.Compiler.getSourceLine(String,int)",
    "snippet": "  public String getSourceLine(String sourceName, int lineNumber) {\n    if (lineNumber < 1) {\n      return null;\n    }\n    SourceFile input = getSourceFileByName(sourceName);\n    if (input != null) {\n      return input.getLine(lineNumber);\n    }\n    return null;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "Compiler.getTypeRegistry",
    "class_name": "com.google.javascript.jscomp.Compiler",
    "signature": "com.google.javascript.jscomp.Compiler.getTypeRegistry()",
    "snippet": "  @Override\n  public JSTypeRegistry getTypeRegistry() {\n    if (typeRegistry == null) {\n      typeRegistry = new JSTypeRegistry(oldErrorReporter, options.looseTypes);\n    }\n    return typeRegistry;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "Compiler.getTypeValidator",
    "class_name": "com.google.javascript.jscomp.Compiler",
    "signature": "com.google.javascript.jscomp.Compiler.getTypeValidator()",
    "snippet": "  @Override\n  TypeValidator getTypeValidator() {\n    if (typeValidator == null) {\n      typeValidator = new TypeValidator(this);\n    }\n    return typeValidator;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "Compiler.getUniqueNameIdSupplier",
    "class_name": "com.google.javascript.jscomp.Compiler",
    "signature": "com.google.javascript.jscomp.Compiler.getUniqueNameIdSupplier()",
    "snippet": "  @Override\n  Supplier<String> getUniqueNameIdSupplier() {\n    final Compiler self = this;\n    return new Supplier<String>() {\n      public String get() {\n        return String.valueOf(self.nextUniqueNameId());\n      }\n    };\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "Compiler.getWarnings",
    "class_name": "com.google.javascript.jscomp.Compiler",
    "signature": "com.google.javascript.jscomp.Compiler.getWarnings()",
    "snippet": "  public JSError[] getWarnings() {\n    return errorManager.getWarnings();\n  }",
    "comment": " Returns the array of warnings (never null). ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "Compiler.hasErrors",
    "class_name": "com.google.javascript.jscomp.Compiler",
    "signature": "com.google.javascript.jscomp.Compiler.hasErrors()",
    "snippet": "  public boolean hasErrors() {\n    return hasHaltingErrors();\n  }",
    "comment": " Consults the {@link ErrorManager} to see if we've encountered errors that should halt compilation. <p>  If {@link CompilerOptions#ideMode} is {@code true}, this function always returns {@code false} without consulting the error manager. The error manager will continue to be told about new errors and warnings, but the compiler will complete compilation of all inputs.<p> ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "Compiler.hasHaltingErrors",
    "class_name": "com.google.javascript.jscomp.Compiler",
    "signature": "com.google.javascript.jscomp.Compiler.hasHaltingErrors()",
    "snippet": "  @Override\n  boolean hasHaltingErrors() {\n    return !isIdeMode() && getErrorCount() > 0;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "Compiler.init",
    "class_name": "com.google.javascript.jscomp.Compiler",
    "signature": "com.google.javascript.jscomp.Compiler.init(List,List,CompilerOptions)",
    "snippet": "  public void init(List<JSSourceFile> externs, List<JSSourceFile> inputs,\n      CompilerOptions options) {\n    JSModule module = new JSModule(\"[singleton]\");\n    for (JSSourceFile input : inputs) {\n      module.add(input);\n    }\n\n    initModules(externs, Lists.newArrayList(module), options);\n  }",
    "comment": " Initializes the instance state needed for a compile job. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "Compiler.initBasedOnOptions",
    "class_name": "com.google.javascript.jscomp.Compiler",
    "signature": "com.google.javascript.jscomp.Compiler.initBasedOnOptions()",
    "snippet": "  private void initBasedOnOptions() {\n    // Create the source map if necessary.\n    if (options.sourceMapOutputPath != null) {\n      sourceMap = options.sourceMapFormat.getInstance();\n      sourceMap.setPrefixMappings(options.sourceMapLocationMappings);\n    }\n  }",
    "comment": " Do any initialization that is dependent on the compiler options. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "Compiler.initInputsByNameMap",
    "class_name": "com.google.javascript.jscomp.Compiler",
    "signature": "com.google.javascript.jscomp.Compiler.initInputsByNameMap()",
    "snippet": "  void initInputsByNameMap() {\n    inputsByName = new HashMap<String, CompilerInput>();\n    for (CompilerInput input : externs) {\n      String name = input.getName();\n      if (!inputsByName.containsKey(name)) {\n        inputsByName.put(name, input);\n      } else {\n        report(JSError.make(DUPLICATE_EXTERN_INPUT, name));\n      }\n    }\n    for (CompilerInput input : inputs) {\n      String name = input.getName();\n      if (!inputsByName.containsKey(name)) {\n        inputsByName.put(name, input);\n      } else {\n        report(JSError.make(DUPLICATE_INPUT, name));\n      }\n    }\n  }",
    "comment": " Creates a map to make looking up an input by name fast. Also checks for duplicate inputs. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "Compiler.initModules",
    "class_name": "com.google.javascript.jscomp.Compiler",
    "signature": "com.google.javascript.jscomp.Compiler.initModules(List,List,CompilerOptions)",
    "snippet": "  public void initModules(\n      List<JSSourceFile> externs, List<JSModule> modules,\n      CompilerOptions options) {\n    initOptions(options);\n\n    checkFirstModule(modules);\n    fillEmptyModules(modules);\n\n    this.externs = makeCompilerInput(externs, true);\n\n    // Generate the module graph, and report any errors in the module\n    // specification as errors.\n    this.modules = modules;\n    if (modules.size() > 1) {\n      try {\n        this.moduleGraph = new JSModuleGraph(modules);\n      } catch (JSModuleGraph.ModuleDependenceException e) {\n        // problems with the module format.  Report as an error.  The\n        // message gives all details.\n        report(JSError.make(MODULE_DEPENDENCY_ERROR,\n                e.getModule().getName(), e.getDependentModule().getName()));\n        return;\n      }\n    } else {\n      this.moduleGraph = null;\n    }\n\n    this.inputs = getAllInputsFromModules(modules);\n    initBasedOnOptions();\n\n    initInputsByNameMap();\n  }",
    "comment": " Initializes the instance state needed for a compile job if the sources are in modules. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "Compiler.initOptions",
    "class_name": "com.google.javascript.jscomp.Compiler",
    "signature": "com.google.javascript.jscomp.Compiler.initOptions(CompilerOptions)",
    "snippet": "  public void initOptions(CompilerOptions options) {\n    this.options = options;\n    if (errorManager == null) {\n      if (outStream == null) {\n        setErrorManager(\n            new LoggerErrorManager(createMessageFormatter(), logger));\n      } else {\n        PrintStreamErrorManager printer =\n            new PrintStreamErrorManager(createMessageFormatter(), outStream);\n        printer.setSummaryDetailLevel(options.summaryDetailLevel);\n        setErrorManager(printer);\n      }\n    }\n\n    // DiagnosticGroups override the plain checkTypes option.\n    if (options.enables(DiagnosticGroups.CHECK_TYPES)) {\n      options.checkTypes = true;\n    } else if (options.disables(DiagnosticGroups.CHECK_TYPES)) {\n      options.checkTypes = false;\n    } else if (!options.checkTypes) {\n      // If DiagnosticGroups did not override the plain checkTypes\n      // option, and checkTypes is enabled, then turn off the\n      // parser type warnings.\n      options.setWarningLevel(\n          DiagnosticGroup.forType(\n              RhinoErrorReporter.TYPE_PARSE_ERROR),\n          CheckLevel.OFF);\n    }\n\n    if (options.checkGlobalThisLevel.isOn()) {\n      options.setWarningLevel(\n          DiagnosticGroups.GLOBAL_THIS,\n          options.checkGlobalThisLevel);\n    }\n\n    if (options.getLanguageIn() == LanguageMode.ECMASCRIPT5_STRICT) {\n      options.setWarningLevel(\n          DiagnosticGroups.ES5_STRICT,\n          CheckLevel.ERROR);\n    }\n\n    // Initialize the warnings guard.\n    List<WarningsGuard> guards = Lists.newArrayList();\n    guards.add(\n        new SuppressDocWarningsGuard(\n            getDiagnosticGroups().getRegisteredGroups()));\n    guards.add(options.getWarningsGuard());\n\n    ComposeWarningsGuard composedGuards = new ComposeWarningsGuard(guards);\n\n    // All passes must run the variable check. This synthesizes\n    // variables later so that the compiler doesn't crash. It also\n    // checks the externs file for validity. If you don't want to warn\n    // about missing variable declarations, we shut that specific\n    // error off.\n    if (!options.checkSymbols &&\n        !composedGuards.enables(DiagnosticGroups.CHECK_VARIABLES)) {\n      composedGuards.addGuard(new DiagnosticGroupWarningsGuard(\n          DiagnosticGroups.CHECK_VARIABLES, CheckLevel.OFF));\n    }\n\n    this.warningsGuard = composedGuards;\n  }",
    "comment": " Initialize the compiler options. Only necessary if you're not doing a normal compile() job. ",
    "is_bug": true,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "Compiler.isIdeMode",
    "class_name": "com.google.javascript.jscomp.Compiler",
    "signature": "com.google.javascript.jscomp.Compiler.isIdeMode()",
    "snippet": "  @Override\n  public boolean isIdeMode() {\n    return options.ideMode;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "Compiler.makeCompilerInput",
    "class_name": "com.google.javascript.jscomp.Compiler",
    "signature": "com.google.javascript.jscomp.Compiler.makeCompilerInput(List,boolean)",
    "snippet": "  private List<CompilerInput> makeCompilerInput(\n      List<JSSourceFile> files, boolean isExtern) {\n    List<CompilerInput> inputs = Lists.newArrayList();\n    for (JSSourceFile file : files) {\n      inputs.add(new CompilerInput(file, isExtern));\n    }\n    return inputs;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "Compiler.maybeSanityCheck",
    "class_name": "com.google.javascript.jscomp.Compiler",
    "signature": "com.google.javascript.jscomp.Compiler.maybeSanityCheck()",
    "snippet": "  private void maybeSanityCheck() {\n    if (options.devMode == DevMode.EVERY_PASS) {\n      runSanityCheck();\n    }\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "Compiler.newTracer",
    "class_name": "com.google.javascript.jscomp.Compiler",
    "signature": "com.google.javascript.jscomp.Compiler.newTracer(String)",
    "snippet": "  Tracer newTracer(String passName) {\n    String comment = passName\n        + (recentChange.hasCodeChanged() ? \" on recently changed AST\" : \"\");\n    if (options.tracer.isOn()) {\n      tracker.recordPassStart(passName);\n    }\n    return new Tracer(\"Compiler\", comment);\n  }",
    "comment": " Returns a new tracer for the given pass name. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "Compiler.normalize",
    "class_name": "com.google.javascript.jscomp.Compiler",
    "signature": "com.google.javascript.jscomp.Compiler.normalize()",
    "snippet": "  public void normalize() {\n    logger.info(\"Normalizing\");\n    startPass(\"normalize\");\n    process(new Normalize(this, false));\n    endPass();\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "Compiler.optimize",
    "class_name": "com.google.javascript.jscomp.Compiler",
    "signature": "com.google.javascript.jscomp.Compiler.optimize()",
    "snippet": "  public void optimize() {\n    // Ideally, this pass should be the first pass run, however:\n    // 1) VariableReferenceCheck reports unexpected warnings if Normalize\n    // is done first.\n    // 2) ReplaceMessages, stripCode, and potentially custom passes rely on\n    // unmodified local names.\n    normalize();\n\n    PhaseOptimizer phaseOptimizer = new PhaseOptimizer(this, tracker);\n    if (options.devMode == DevMode.EVERY_PASS) {\n      phaseOptimizer.setSanityCheck(sanityCheck);\n    }\n    phaseOptimizer.consume(getPassConfig().getOptimizations());\n    phaseOptimizer.process(externsRoot, jsRoot);\n    if (hasErrors()) {\n      return;\n    }\n  }",
    "comment": "------------------------------------------------------------------------",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "Compiler.parse",
    "class_name": "com.google.javascript.jscomp.Compiler",
    "signature": "com.google.javascript.jscomp.Compiler.parse()",
    "snippet": "  public void parse() {\n    parseInputs();\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "Compiler.parseInputs",
    "class_name": "com.google.javascript.jscomp.Compiler",
    "signature": "com.google.javascript.jscomp.Compiler.parseInputs()",
    "snippet": "  Node parseInputs() {\n    boolean devMode = options.devMode != DevMode.OFF;\n\n    // If old roots exist (we are parsing a second time), detach each of the\n    // individual file parse trees.\n    if (externsRoot != null) {\n      externsRoot.detachChildren();\n    }\n    if (jsRoot != null) {\n      jsRoot.detachChildren();\n    }\n\n    // Parse main js sources.\n    jsRoot = new Node(Token.BLOCK);\n    jsRoot.setIsSyntheticBlock(true);\n\n    externsRoot = new Node(Token.BLOCK);\n    externsRoot.setIsSyntheticBlock(true);\n\n    externAndJsRoot = new Node(Token.BLOCK, externsRoot, jsRoot);\n    externAndJsRoot.setIsSyntheticBlock(true);\n\n    if (options.tracer.isOn()) {\n      tracker = new PerformanceTracker(jsRoot,\n          options.tracer == TracerMode.ALL);\n      addChangeHandler(tracker.getCodeChangeHandler());\n    }\n\n    Tracer tracer = newTracer(\"parseInputs\");\n\n    try {\n      // Parse externs sources.\n      for (CompilerInput input : externs) {\n        Node n = input.getAstRoot(this);\n        if (hasErrors()) {\n          return null;\n        }\n        externsRoot.addChildToBack(n);\n      }\n\n      // Check if the sources need to be re-ordered.\n      if (options.manageClosureDependencies) {\n        for (CompilerInput input : inputs) {\n          input.setCompiler(this);\n\n          // Forward-declare all the provided types, so that they\n          // are not flagged even if they are dropped from the process.\n          for (String provide : input.getProvides()) {\n            getTypeRegistry().forwardDeclareType(provide);\n          }\n        }\n\n        try {\n          inputs =\n              (moduleGraph == null ? new JSModuleGraph(modules) : moduleGraph)\n              .manageDependencies(\n                  options.manageClosureDependenciesEntryPoints, inputs);\n        } catch (CircularDependencyException e) {\n          report(JSError.make(\n              JSModule.CIRCULAR_DEPENDENCY_ERROR, e.getMessage()));\n          return null;\n        } catch (MissingProvideException e) {\n          report(JSError.make(\n              MISSING_ENTRY_ERROR, e.getMessage()));\n          return null;\n        }\n      }\n\n      // Check if inputs need to be rebuilt from modules.\n      boolean staleInputs = false;\n      for (CompilerInput input : inputs) {\n        Node n = input.getAstRoot(this);\n\n        // Inputs can have a null AST during initial parse.\n        if (n == null) {\n          continue;\n        }\n\n        if (n.getJSDocInfo() != null) {\n          JSDocInfo info = n.getJSDocInfo();\n          if (info.isExterns()) {\n            // If the input file is explicitly marked as an externs file, then\n            // assume the programmer made a mistake and throw it into\n            // the externs pile anyways.\n            externsRoot.addChildToBack(n);\n            input.setIsExtern(true);\n\n            input.getModule().remove(input);\n\n            externs.add(input);\n            staleInputs = true;\n          } else if (info.isNoCompile()) {\n            input.getModule().remove(input);\n            staleInputs = true;\n          }\n        }\n      }\n\n      if (staleInputs) {\n        fillEmptyModules(modules);\n        rebuildInputsFromModules();\n      }\n\n      // Build the AST.\n      for (CompilerInput input : inputs) {\n        Node n = input.getAstRoot(this);\n        if (n == null) {\n          continue;\n        }\n\n        if (devMode) {\n          runSanityCheck();\n          if (hasErrors()) {\n            return null;\n          }\n        }\n\n        if (options.sourceMapOutputPath != null ||\n            options.nameReferenceReportPath != null) {\n\n          // Annotate the nodes in the tree with information from the\n          // input file. This information is used to construct the SourceMap.\n          SourceInformationAnnotator sia =\n              new SourceInformationAnnotator(\n                  input.getName(), options.devMode != DevMode.OFF);\n          NodeTraversal.traverse(this, n, sia);\n        }\n\n        jsRoot.addChildToBack(n);\n      }\n\n      if (hasErrors()) {\n        return null;\n      }\n      return externAndJsRoot;\n    } finally {\n      stopTracer(tracer, \"parseInputs\");\n    }\n  }",
    "comment": " Parses the externs and main inputs.  @return A synthetic root node whose two children are the externs root and the main root ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "Compiler.precheck",
    "class_name": "com.google.javascript.jscomp.Compiler",
    "signature": "com.google.javascript.jscomp.Compiler.precheck()",
    "snippet": "  boolean precheck() {\n    return true;\n  }",
    "comment": " Carry out any special checks or procedures that need to be done before proceeding with rest of the compilation process.  @return true, to continue with compilation ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "Compiler.prepareAst",
    "class_name": "com.google.javascript.jscomp.Compiler",
    "signature": "com.google.javascript.jscomp.Compiler.prepareAst(Node)",
    "snippet": "  @Override\n  void prepareAst(Node root) {\n    Tracer tracer = newTracer(\"prepareAst\");\n    CompilerPass pass = new PrepareAst(this);\n    pass.process(null, root);\n    stopTracer(tracer, \"prepareAst\");\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "Compiler.process",
    "class_name": "com.google.javascript.jscomp.Compiler",
    "signature": "com.google.javascript.jscomp.Compiler.process(CompilerPass)",
    "snippet": "  @Override\n  void process(CompilerPass p) {\n    p.process(externsRoot, jsRoot);\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "Compiler.report",
    "class_name": "com.google.javascript.jscomp.Compiler",
    "signature": "com.google.javascript.jscomp.Compiler.report(JSError)",
    "snippet": "  @Override\n  public void report(JSError error) {\n    CheckLevel level = error.level;\n    if (warningsGuard != null) {\n      CheckLevel newLevel = warningsGuard.level(error);\n      if (newLevel != null) {\n        level = newLevel;\n      }\n    }\n\n    if (level.isOn()) {\n      errorManager.report(level, error);\n    }\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "Compiler.reportCodeChange",
    "class_name": "com.google.javascript.jscomp.Compiler",
    "signature": "com.google.javascript.jscomp.Compiler.reportCodeChange()",
    "snippet": "  @Override\n  public void reportCodeChange() {\n    for (CodeChangeHandler handler : codeChangeHandlers) {\n      handler.reportChange();\n    }\n  }",
    "comment": " All passes should call reportCodeChange() when they alter the JS tree structure. This is verified by CompilerTestCase. This allows us to optimize to a fixed point. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "Compiler.runCallable",
    "class_name": "com.google.javascript.jscomp.Compiler",
    "signature": "com.google.javascript.jscomp.Compiler.runCallable(Callable,boolean,boolean)",
    "snippet": "  @SuppressWarnings(\"unchecked\")\n  static <T> T runCallable(\n      final Callable<T> callable, boolean useLargeStackThread, boolean trace) {\n\n    // Under JRE 1.6, the jscompiler overflows the stack when running on some\n    // large or complex js code. Here we start a new thread with a larger\n    // stack in order to let the compiler do its thing, without having to\n    // increase the stack size for *every* thread (which is what -Xss does).\n    // Might want to add thread pool support for clients that compile a lot.\n\n    final boolean dumpTraceReport = trace;\n    final Object[] result = new Object[1];\n    final Throwable[] exception = new Throwable[1];\n    Runnable runnable = new Runnable() {\n      public void run() {\n        try {\n          if (dumpTraceReport) {\n            Tracer.initCurrentThreadTrace();\n          }\n          result[0] = callable.call();\n        } catch (Throwable e) {\n          exception[0] = e;\n        } finally {\n          if (dumpTraceReport) {\n            Tracer.logAndClearCurrentThreadTrace();\n          }\n        }\n      }\n    };\n\n    if (useLargeStackThread) {\n      Thread th = new Thread(null, runnable, \"jscompiler\", COMPILER_STACK_SIZE);\n      th.start();\n      while (true) {\n        try {\n          th.join();\n          break;\n        } catch (InterruptedException ignore) {\n          // ignore\n        }\n      }\n    } else {\n      runnable.run();\n    }\n\n    // Pass on any exception caught by the runnable object.\n    if (exception[0] != null) {\n      throw new RuntimeException(exception[0]);\n    }\n\n    return (T) result[0];\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "Compiler.runCustomPasses",
    "class_name": "com.google.javascript.jscomp.Compiler",
    "signature": "com.google.javascript.jscomp.Compiler.runCustomPasses(CustomPassExecutionTime)",
    "snippet": "  private void runCustomPasses(CustomPassExecutionTime executionTime) {\n    if (options.customPasses != null) {\n      Tracer t = newTracer(\"runCustomPasses\");\n      try {\n        for (CompilerPass p : options.customPasses.get(executionTime)) {\n          process(p);\n        }\n      } finally {\n        stopTracer(t, \"runCustomPasses\");\n      }\n    }\n  }",
    "comment": " Runs custom passes that are designated to run at a particular time. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "Compiler.runInCompilerThread",
    "class_name": "com.google.javascript.jscomp.Compiler",
    "signature": "com.google.javascript.jscomp.Compiler.runInCompilerThread(Callable)",
    "snippet": "  private <T> T runInCompilerThread(final Callable<T> callable) {\n    return runCallable(callable, useThreads, options.tracer.isOn());\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "Compiler.setErrorManager",
    "class_name": "com.google.javascript.jscomp.Compiler",
    "signature": "com.google.javascript.jscomp.Compiler.setErrorManager(ErrorManager)",
    "snippet": "  public void setErrorManager(ErrorManager errorManager) {\n    Preconditions.checkNotNull(\n        errorManager, \"the error manager cannot be null\");\n    this.errorManager = errorManager;\n  }",
    "comment": " Sets the error manager.  @param errorManager the error manager, it cannot be {@code null} ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "Compiler.setLoggingLevel",
    "class_name": "com.google.javascript.jscomp.Compiler",
    "signature": "com.google.javascript.jscomp.Compiler.setLoggingLevel(Level)",
    "snippet": "  public static void setLoggingLevel(Level level) {\n    logger.setLevel(level);\n  }",
    "comment": " Sets the logging level for the com.google.javascript.jscomp package. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "Compiler.startPass",
    "class_name": "com.google.javascript.jscomp.Compiler",
    "signature": "com.google.javascript.jscomp.Compiler.startPass(String)",
    "snippet": "  void startPass(String passName) {\n    Preconditions.checkState(currentTracer == null);\n    currentPassName = passName;\n    currentTracer = newTracer(passName);\n  }",
    "comment": " Marks the beginning of a pass. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "Compiler.stopTracer",
    "class_name": "com.google.javascript.jscomp.Compiler",
    "signature": "com.google.javascript.jscomp.Compiler.stopTracer(Tracer,String)",
    "snippet": "  void stopTracer(Tracer t, String passName) {\n    long result = t.stop();\n    if (options.tracer.isOn()) {\n      tracker.recordPassStop(passName, result);\n    }\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "Compiler.toSource",
    "class_name": "com.google.javascript.jscomp.Compiler",
    "signature": "com.google.javascript.jscomp.Compiler.toSource()",
    "snippet": "  public String toSource() {\n    return runInCompilerThread(new Callable<String>() {\n      public String call() throws Exception {\n        Tracer tracer = newTracer(\"toSource\");\n        try {\n          CodeBuilder cb = new CodeBuilder();\n          if (jsRoot != null) {\n            int i = 0;\n            for (Node scriptNode = jsRoot.getFirstChild();\n                 scriptNode != null;\n                 scriptNode = scriptNode.getNext()) {\n              toSource(cb, i++, scriptNode);\n            }\n          }\n          return cb.toString();\n        } finally {\n          stopTracer(tracer, \"toSource\");\n        }\n      }\n    });\n  }",
    "comment": " Converts the main parse tree back to js code. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "Compiler.toSource",
    "class_name": "com.google.javascript.jscomp.Compiler",
    "signature": "com.google.javascript.jscomp.Compiler.toSource(CodeBuilder,int,Node)",
    "snippet": "  public void toSource(final CodeBuilder cb,\n                       final int inputSeqNum,\n                       final Node root) {\n    runInCompilerThread(new Callable<Void>() {\n      public Void call() throws Exception {\n        if (options.printInputDelimiter) {\n          if ((cb.getLength() > 0) && !cb.endsWith(\"\\n\")) {\n            cb.append(\"\\n\");  // Make sure that the label starts on a new line\n          }\n          Preconditions.checkState(root.getType() == Token.SCRIPT);\n\n          String delimiter = options.inputDelimiter;\n\n          String sourceName = root.getSourceFileName();\n          Preconditions.checkState(sourceName != null);\n          Preconditions.checkState(!sourceName.isEmpty());\n\n          delimiter = delimiter.replaceAll(\"%name%\", sourceName)\n            .replaceAll(\"%num%\", String.valueOf(inputSeqNum));\n\n          cb.append(delimiter)\n            .append(\"\\n\");\n        }\n        if (root.getJSDocInfo() != null &&\n            root.getJSDocInfo().getLicense() != null) {\n          cb.append(\"/*\\n\")\n            .append(root.getJSDocInfo().getLicense())\n            .append(\"*/\\n\");\n        }\n\n        // If there is a valid source map, then indicate to it that the current\n        // root node's mappings are offset by the given string builder buffer.\n        if (options.sourceMapOutputPath != null) {\n          sourceMap.setStartingPosition(\n              cb.getLineIndex(), cb.getColumnIndex());\n        }\n\n        // if LanguageMode is ECMASCRIPT5_STRICT, only print 'use strict'\n        // for the first input file\n        String code = toSource(root, sourceMap, inputSeqNum == 0);\n        if (!code.isEmpty()) {\n          cb.append(code);\n\n          // In order to avoid parse ambiguity when files are concatenated\n          // together, all files should end in a semi-colon. Do a quick\n          // heuristic check if there's an obvious semi-colon already there.\n          int length = code.length();\n          char lastChar = code.charAt(length - 1);\n          char secondLastChar = length >= 2 ?\n              code.charAt(length - 2) : '\\0';\n          boolean hasSemiColon = lastChar == ';' ||\n              (lastChar == '\\n' && secondLastChar == ';');\n          if (!hasSemiColon) {\n            cb.append(\";\");\n          }\n        }\n        return null;\n      }\n    });\n  }",
    "comment": " Writes out js code from a root node. If printing input delimiters, this method will attach a comment to the start of the text indicating which input the output derived from. If there were any preserve annotations within the root's source, they will also be printed in a block comment at the beginning of the output. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "Compiler.toSource",
    "class_name": "com.google.javascript.jscomp.Compiler",
    "signature": "com.google.javascript.jscomp.Compiler.toSource(Node,SourceMap,boolean)",
    "snippet": "  private String toSource(Node n, SourceMap sourceMap, boolean firstOutput) {\n    CodePrinter.Builder builder = new CodePrinter.Builder(n);\n    builder.setPrettyPrint(options.prettyPrint);\n    builder.setLineBreak(options.lineBreak);\n    builder.setSourceMap(sourceMap);\n    builder.setSourceMapDetailLevel(options.sourceMapDetailLevel);\n    builder.setTagAsStrict(firstOutput &&\n        options.getLanguageOut() == LanguageMode.ECMASCRIPT5_STRICT);\n    builder.setLineLengthThreshold(options.lineLengthThreshold);\n\n    Charset charset = options.outputCharset != null ?\n        Charset.forName(options.outputCharset) : null;\n    builder.setOutputCharset(charset);\n\n    return builder.build();\n  }",
    "comment": " Generates JavaScript source code for an AST. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "Compiler.updateGlobalVarReferences",
    "class_name": "com.google.javascript.jscomp.Compiler",
    "signature": "com.google.javascript.jscomp.Compiler.updateGlobalVarReferences(Map,Node)",
    "snippet": "  @Override\n  void updateGlobalVarReferences(Map<Var, ReferenceCollection> refMapPatch,\n      Node collectionRoot) {\n    Preconditions.checkState(collectionRoot.getType() == Token.SCRIPT\n        || collectionRoot.getType() == Token.BLOCK);\n    if (globalRefMap == null) {\n      globalRefMap = new GlobalVarReferenceMap(getInputsInOrder(),\n          getExternsInOrder());\n    }\n    globalRefMap.updateGlobalVarReferences(refMapPatch, collectionRoot);\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "CodeBuilder.append",
    "class_name": "com.google.javascript.jscomp.Compiler$CodeBuilder",
    "signature": "com.google.javascript.jscomp.Compiler$CodeBuilder.append(String)",
    "snippet": "    CodeBuilder append(String str) {\n      sb.append(str);\n\n      // Adjust the line and column information for the new text.\n      int index = -1;\n      int lastIndex = index;\n      while ((index = str.indexOf('\\n', index + 1)) >= 0) {\n        ++lineCount;\n        lastIndex = index;\n      }\n\n      if (lastIndex == -1) {\n        // No new lines, append the new characters added.\n        colCount += str.length();\n      } else {\n        colCount = str.length() - (lastIndex + 1);\n      }\n\n      return this;\n    }",
    "comment": "Appends the given string to the text buffer. */",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "CodeBuilder.toString",
    "class_name": "com.google.javascript.jscomp.Compiler$CodeBuilder",
    "signature": "com.google.javascript.jscomp.Compiler$CodeBuilder.toString()",
    "snippet": "    @Override\n    public String toString() {\n      return sb.toString();\n    }",
    "comment": "Returns all text in the text buffer. */",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "CompilerInput.CompilerInput",
    "class_name": "com.google.javascript.jscomp.CompilerInput",
    "signature": "com.google.javascript.jscomp.CompilerInput.CompilerInput(JSSourceFile)",
    "snippet": "  public CompilerInput(JSSourceFile file) {\n    this(file, false);\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "CompilerInput.CompilerInput",
    "class_name": "com.google.javascript.jscomp.CompilerInput",
    "signature": "com.google.javascript.jscomp.CompilerInput.CompilerInput(JSSourceFile,boolean)",
    "snippet": "  public CompilerInput(JSSourceFile file, boolean isExtern) {\n    this(new JsAst(file), file.getName(), isExtern);\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "CompilerInput.CompilerInput",
    "class_name": "com.google.javascript.jscomp.CompilerInput",
    "signature": "com.google.javascript.jscomp.CompilerInput.CompilerInput(SourceAst,String,boolean)",
    "snippet": "  public CompilerInput(SourceAst ast, String inputName, boolean isExtern) {\n    this.ast = ast;\n    this.name = inputName;\n\n    // TODO(nicksantos): Add a precondition check here. People are passing\n    // in null, but they should not be.\n    if (ast != null && ast.getSourceFile() != null) {\n      ast.getSourceFile().setIsExtern(isExtern);\n    }\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "CompilerInput.getAstRoot",
    "class_name": "com.google.javascript.jscomp.CompilerInput",
    "signature": "com.google.javascript.jscomp.CompilerInput.getAstRoot(AbstractCompiler)",
    "snippet": "  @Override\n  public Node getAstRoot(AbstractCompiler compiler) {\n    return ast.getAstRoot(compiler);\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "CompilerInput.getName",
    "class_name": "com.google.javascript.jscomp.CompilerInput",
    "signature": "com.google.javascript.jscomp.CompilerInput.getName()",
    "snippet": "  @Override\n  public String getName() {\n    return name;\n  }",
    "comment": "Returns a name for this input. Must be unique across all inputs. */",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "CompilerInput.getSourceFile",
    "class_name": "com.google.javascript.jscomp.CompilerInput",
    "signature": "com.google.javascript.jscomp.CompilerInput.getSourceFile()",
    "snippet": "  @Override\n  public SourceFile getSourceFile() {\n    return ast.getSourceFile();\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "CompilerInput.isExtern",
    "class_name": "com.google.javascript.jscomp.CompilerInput",
    "signature": "com.google.javascript.jscomp.CompilerInput.isExtern()",
    "snippet": "  @Override\n  public boolean isExtern() {\n    if (ast == null || ast.getSourceFile() == null) {\n      return false;\n    }\n    return ast.getSourceFile().isExtern();\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "CompilerInput.setModule",
    "class_name": "com.google.javascript.jscomp.CompilerInput",
    "signature": "com.google.javascript.jscomp.CompilerInput.setModule(JSModule)",
    "snippet": "  public void setModule(JSModule module) {\n    // An input may only belong to one module.\n    Preconditions.checkArgument(\n        module == null || this.module == null || this.module == module);\n    this.module = module;\n  }",
    "comment": "Sets the module to which the input belongs. */",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "CompilerOptions.CompilerOptions",
    "class_name": "com.google.javascript.jscomp.CompilerOptions",
    "signature": "com.google.javascript.jscomp.CompilerOptions.CompilerOptions()",
    "snippet": "  public CompilerOptions() {\n    // Accepted language\n    languageIn = LanguageMode.ECMASCRIPT3;\n\n    // Language variation\n    acceptConstKeyword = false;\n\n    // Checks\n    skipAllPasses = false;\n    nameAnonymousFunctionsOnly = false;\n    devMode = DevMode.OFF;\n    checkSymbols = false;\n    checkShadowVars = CheckLevel.OFF;\n    aggressiveVarCheck = CheckLevel.OFF;\n    checkFunctions = CheckLevel.OFF;\n    checkMethods = CheckLevel.OFF;\n    checkDuplicateMessages = false;\n    allowLegacyJsMessages = false;\n    strictMessageReplacement = false;\n    checkSuspiciousCode = false;\n    checkControlStructures = false;\n    checkTypes = false;\n    tightenTypes = false;\n    inferTypesInGlobalScope = false;\n    checkTypedPropertyCalls = false;\n    reportMissingOverride = CheckLevel.OFF;\n    reportUnknownTypes = CheckLevel.OFF;\n    checkRequires = CheckLevel.OFF;\n    checkProvides = CheckLevel.OFF;\n    checkGlobalNamesLevel = CheckLevel.OFF;\n    brokenClosureRequiresLevel = CheckLevel.ERROR;\n    checkGlobalThisLevel = CheckLevel.OFF;\n    checkUnreachableCode = CheckLevel.OFF;\n    checkMissingReturn = CheckLevel.OFF;\n    checkMissingGetCssNameLevel = CheckLevel.OFF;\n    checkMissingGetCssNameBlacklist = null;\n    checkCaja = false;\n    computeFunctionSideEffects = false;\n    chainCalls = false;\n    extraAnnotationNames = null;\n\n    // Optimizations\n    foldConstants = false;\n    coalesceVariableNames = false;\n    deadAssignmentElimination = false;\n    inlineConstantVars = false;\n    inlineFunctions = false;\n    inlineLocalFunctions = false;\n    assumeStrictThis = false;\n    crossModuleCodeMotion = false;\n    crossModuleMethodMotion = false;\n    inlineGetters = false;\n    inlineVariables = false;\n    inlineLocalVariables = false;\n    smartNameRemoval = false;\n    removeDeadCode = false;\n    extractPrototypeMemberDeclarations = false;\n    removeUnusedPrototypeProperties = false;\n    removeUnusedPrototypePropertiesInExterns = false;\n    removeUnusedVars = false;\n    removeUnusedLocalVars = false;\n    aliasExternals = false;\n    collapseVariableDeclarations = false;\n    groupVariableDeclarations = false;\n    collapseAnonymousFunctions = false;\n    aliasableStrings = Collections.emptySet();\n    aliasStringsBlacklist = \"\";\n    aliasAllStrings = false;\n    outputJsStringUsage = false;\n    convertToDottedProperties = false;\n    rewriteFunctionExpressions = false;\n    optimizeParameters = false;\n    optimizeReturns = false;\n\n    // Renaming\n    variableRenaming = VariableRenamingPolicy.OFF;\n    propertyRenaming = PropertyRenamingPolicy.OFF;\n    propertyAffinity = false;\n    labelRenaming = false;\n    generatePseudoNames = false;\n    shadowVariables = false;\n    renamePrefix = null;\n    aliasKeywords = false;\n    collapseProperties = false;\n    collapsePropertiesOnExternTypes = false;\n    collapseObjectLiterals = false;\n    devirtualizePrototypeMethods = false;\n    disambiguateProperties = false;\n    ambiguateProperties = false;\n    anonymousFunctionNaming = AnonymousFunctionNamingPolicy.OFF;\n    exportTestFunctions = false;\n\n    // Alterations\n    runtimeTypeCheck = false;\n    runtimeTypeCheckLogFunction = null;\n    instrumentForCoverage = false;\n    instrumentForCoverageOnly = false;\n    ignoreCajaProperties = false;\n    syntheticBlockStartMarker = null;\n    syntheticBlockEndMarker = null;\n    locale = null;\n    markAsCompiled = false;\n    removeTryCatchFinally = false;\n    closurePass = false;\n    rewriteNewDateGoogNow = true;\n    removeAbstractMethods = true;\n    removeClosureAsserts = false;\n    stripTypes = Collections.emptySet();\n    stripNameSuffixes = Collections.emptySet();\n    stripNamePrefixes = Collections.emptySet();\n    stripTypePrefixes = Collections.emptySet();\n    customPasses = null;\n    markNoSideEffectCalls = false;\n    defineReplacements = Maps.newHashMap();\n    tweakProcessing = TweakProcessing.OFF;\n    tweakReplacements = Maps.newHashMap();\n    moveFunctionDeclarations = false;\n    instrumentationTemplate = null;\n    appNameStr = \"\";\n    recordFunctionInformation = false;\n    generateExports = false;\n    cssRenamingMap = null;\n    processObjectPropertyString = false;\n    idGenerators = Collections.emptySet();\n    replaceStringsFunctionDescriptions = Collections.emptyList();\n    replaceStringsPlaceholderToken = \"\";\n    replaceStringsReservedStrings = Collections.emptySet();\n\n    // Output\n    printInputDelimiter = false;\n    prettyPrint = false;\n    lineBreak = false;\n    reportPath = null;\n    tracer = TracerMode.OFF;\n    colorizeErrorOutput = false;\n    errorFormat = ErrorFormat.SINGLELINE;\n    debugFunctionSideEffectsPath = null;\n    jsOutputFile = \"\";\n    externExports = false;\n    nameReferenceReportPath = null;\n    nameReferenceGraphPath = null;\n\n    // Debugging\n    aliasHandler = NULL_ALIAS_TRANSFORMATION_HANDLER;\n\n    operaCompoundAssignFix = true;\n  }",
    "comment": " Initializes compiler options. All options are disabled by default.  Command-line frontends to the compiler should set these properties like a builder. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "CompilerOptions.addWarningsGuard",
    "class_name": "com.google.javascript.jscomp.CompilerOptions",
    "signature": "com.google.javascript.jscomp.CompilerOptions.addWarningsGuard(WarningsGuard)",
    "snippet": "  public void addWarningsGuard(WarningsGuard guard) {\n    warningsGuard.addGuard(guard);\n  }",
    "comment": " Add a guard to the set of warnings guards. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "CompilerOptions.enables",
    "class_name": "com.google.javascript.jscomp.CompilerOptions",
    "signature": "com.google.javascript.jscomp.CompilerOptions.enables(DiagnosticGroup)",
    "snippet": "  boolean enables(DiagnosticGroup type) {\n    return warningsGuard.enables(type);\n  }",
    "comment": " Whether the warnings guard in this Options object enables the given group of warnings. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "CompilerOptions.getAliasTransformationHandler",
    "class_name": "com.google.javascript.jscomp.CompilerOptions",
    "signature": "com.google.javascript.jscomp.CompilerOptions.getAliasTransformationHandler()",
    "snippet": "  public AliasTransformationHandler getAliasTransformationHandler() {\n    return this.aliasHandler;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "CompilerOptions.getCodingConvention",
    "class_name": "com.google.javascript.jscomp.CompilerOptions",
    "signature": "com.google.javascript.jscomp.CompilerOptions.getCodingConvention()",
    "snippet": "  public CodingConvention getCodingConvention() {\n    return codingConvention;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "CompilerOptions.getDefineReplacements",
    "class_name": "com.google.javascript.jscomp.CompilerOptions",
    "signature": "com.google.javascript.jscomp.CompilerOptions.getDefineReplacements()",
    "snippet": "  public Map<String, Node> getDefineReplacements() {\n    return getReplacementsHelper(defineReplacements);\n  }",
    "comment": " Returns the map of define replacements. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "CompilerOptions.getLanguageIn",
    "class_name": "com.google.javascript.jscomp.CompilerOptions",
    "signature": "com.google.javascript.jscomp.CompilerOptions.getLanguageIn()",
    "snippet": "  public LanguageMode getLanguageIn() {\n    return languageIn;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "CompilerOptions.getLanguageOut",
    "class_name": "com.google.javascript.jscomp.CompilerOptions",
    "signature": "com.google.javascript.jscomp.CompilerOptions.getLanguageOut()",
    "snippet": "  public LanguageMode getLanguageOut() {\n    return languageOut;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "CompilerOptions.getReplacementsHelper",
    "class_name": "com.google.javascript.jscomp.CompilerOptions",
    "signature": "com.google.javascript.jscomp.CompilerOptions.getReplacementsHelper(Map)",
    "snippet": "  private static Map<String, Node> getReplacementsHelper(\n      Map<String, Object> source) {\n    Map<String, Node> map = Maps.newHashMap();\n    for (Map.Entry<String, Object> entry : source.entrySet()) {\n      String name = entry.getKey();\n      Object value = entry.getValue();\n      if (value instanceof Boolean) {\n        map.put(name, ((Boolean) value).booleanValue() ?\n            new Node(Token.TRUE) : new Node(Token.FALSE));\n      } else if (value instanceof Integer) {\n        map.put(name, Node.newNumber(((Integer) value).intValue()));\n      } else if (value instanceof Double) {\n        map.put(name, Node.newNumber(((Double) value).doubleValue()));\n      } else {\n        Preconditions.checkState(value instanceof String);\n        map.put(name, Node.newString((String) value));\n      }\n    }\n    return map;\n  }",
    "comment": " Creates a map of String->Node from a map of String->Number/String/Boolean. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "CompilerOptions.getTweakProcessing",
    "class_name": "com.google.javascript.jscomp.CompilerOptions",
    "signature": "com.google.javascript.jscomp.CompilerOptions.getTweakProcessing()",
    "snippet": "  public TweakProcessing getTweakProcessing() {\n    return tweakProcessing;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "CompilerOptions.getWarningsGuard",
    "class_name": "com.google.javascript.jscomp.CompilerOptions",
    "signature": "com.google.javascript.jscomp.CompilerOptions.getWarningsGuard()",
    "snippet": "  WarningsGuard getWarningsGuard() {\n    return warningsGuard;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "CompilerOptions.isAssumeStrictThis",
    "class_name": "com.google.javascript.jscomp.CompilerOptions",
    "signature": "com.google.javascript.jscomp.CompilerOptions.isAssumeStrictThis()",
    "snippet": "  public boolean isAssumeStrictThis() {\n    return assumeStrictThis;\n  }",
    "comment": " @return Whether assumeStrictThis is set. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "CompilerOptions.isExternExportsEnabled",
    "class_name": "com.google.javascript.jscomp.CompilerOptions",
    "signature": "com.google.javascript.jscomp.CompilerOptions.isExternExportsEnabled()",
    "snippet": "  public boolean isExternExportsEnabled() {\n    return externExports;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "CompilerOptions.setCodingConvention",
    "class_name": "com.google.javascript.jscomp.CompilerOptions",
    "signature": "com.google.javascript.jscomp.CompilerOptions.setCodingConvention(CodingConvention)",
    "snippet": "  public void setCodingConvention(CodingConvention codingConvention) {\n    this.codingConvention = codingConvention;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "CompilerOptions.setLanguageIn",
    "class_name": "com.google.javascript.jscomp.CompilerOptions",
    "signature": "com.google.javascript.jscomp.CompilerOptions.setLanguageIn(LanguageMode)",
    "snippet": "  public void setLanguageIn(LanguageMode languageIn) {\n    this.languageIn = languageIn;\n    this.languageOut = languageIn;\n  }",
    "comment": " Sets how goog.tweak calls are processed. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "CompilerOptions.setSummaryDetailLevel",
    "class_name": "com.google.javascript.jscomp.CompilerOptions",
    "signature": "com.google.javascript.jscomp.CompilerOptions.setSummaryDetailLevel(int)",
    "snippet": "  public void setSummaryDetailLevel(int summaryDetailLevel) {\n    this.summaryDetailLevel = summaryDetailLevel;\n  }",
    "comment": " Controls how detailed the compilation summary is. Values: 0 (never print summary), 1 (print summary only if there are errors or warnings), 2 (print summary if type checking is on, see --check_types), 3 (always print summary). The default level is 1 ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "CompilerOptions.setTweakProcessing",
    "class_name": "com.google.javascript.jscomp.CompilerOptions",
    "signature": "com.google.javascript.jscomp.CompilerOptions.setTweakProcessing(TweakProcessing)",
    "snippet": "  public void setTweakProcessing(TweakProcessing tweakProcessing) {\n    this.tweakProcessing = tweakProcessing;\n  }",
    "comment": " Sets how goog.tweak calls are processed. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "CompilerOptions.setWarningLevel",
    "class_name": "com.google.javascript.jscomp.CompilerOptions",
    "signature": "com.google.javascript.jscomp.CompilerOptions.setWarningLevel(DiagnosticGroup,CheckLevel)",
    "snippet": "  public void setWarningLevel(DiagnosticGroup type, CheckLevel level) {\n    addWarningsGuard(new DiagnosticGroupWarningsGuard(type, level));\n  }",
    "comment": " Configure the given type of warning to the given level. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "CompilerOptions.shouldColorizeErrorOutput",
    "class_name": "com.google.javascript.jscomp.CompilerOptions",
    "signature": "com.google.javascript.jscomp.CompilerOptions.shouldColorizeErrorOutput()",
    "snippet": "  public boolean shouldColorizeErrorOutput() {\n    return colorizeErrorOutput;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "TracerMode.isOn",
    "class_name": "com.google.javascript.jscomp.CompilerOptions$TracerMode",
    "signature": "com.google.javascript.jscomp.CompilerOptions$TracerMode.isOn()",
    "snippet": "    boolean isOn() {\n      return this != OFF;\n    }",
    "comment": "Collect no timing and size metrics.",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "TweakProcessing.isOn",
    "class_name": "com.google.javascript.jscomp.CompilerOptions$TweakProcessing",
    "signature": "com.google.javascript.jscomp.CompilerOptions$TweakProcessing.isOn()",
    "snippet": "    public boolean isOn() {\n      return this != OFF;\n    }",
    "comment": "Strip out all calls to goog.tweak.*.",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "TweakProcessing.shouldStrip",
    "class_name": "com.google.javascript.jscomp.CompilerOptions$TweakProcessing",
    "signature": "com.google.javascript.jscomp.CompilerOptions$TweakProcessing.shouldStrip()",
    "snippet": "    public boolean shouldStrip() {\n      return this == STRIP;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "ComposeWarningsGuard.ComposeWarningsGuard",
    "class_name": "com.google.javascript.jscomp.ComposeWarningsGuard",
    "signature": "com.google.javascript.jscomp.ComposeWarningsGuard.ComposeWarningsGuard(List)",
    "snippet": "  public ComposeWarningsGuard(List<WarningsGuard> guards) {\n    addGuards(guards);\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "ComposeWarningsGuard.ComposeWarningsGuard",
    "class_name": "com.google.javascript.jscomp.ComposeWarningsGuard",
    "signature": "com.google.javascript.jscomp.ComposeWarningsGuard.ComposeWarningsGuard(WarningsGuard[])",
    "snippet": "  public ComposeWarningsGuard(WarningsGuard... guards) {\n    this(Lists.newArrayList(guards));\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "ComposeWarningsGuard.addGuard",
    "class_name": "com.google.javascript.jscomp.ComposeWarningsGuard",
    "signature": "com.google.javascript.jscomp.ComposeWarningsGuard.addGuard(WarningsGuard)",
    "snippet": "  void addGuard(WarningsGuard guard) {\n    if (guard instanceof ComposeWarningsGuard) {\n      // Reverse the guards, so that they have the same order in the result.\n      addGuards(((ComposeWarningsGuard) guard).guards.descendingSet());\n    } else {\n      numberOfAdds++;\n      orderOfAddition.put(guard, numberOfAdds);\n      guards.remove(guard);\n      guards.add(guard);\n    }\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "ComposeWarningsGuard.addGuards",
    "class_name": "com.google.javascript.jscomp.ComposeWarningsGuard",
    "signature": "com.google.javascript.jscomp.ComposeWarningsGuard.addGuards(Iterable)",
    "snippet": "  private void addGuards(Iterable<WarningsGuard> guards) {\n    for (WarningsGuard guard : guards) {\n      addGuard(guard);\n    }\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "ComposeWarningsGuard.enables",
    "class_name": "com.google.javascript.jscomp.ComposeWarningsGuard",
    "signature": "com.google.javascript.jscomp.ComposeWarningsGuard.enables(DiagnosticGroup)",
    "snippet": "  @Override\n  public boolean enables(DiagnosticGroup group) {\n    for (WarningsGuard guard : guards) {\n      if (guard.enables(group)) {\n        return true;\n      } else if (guard.disables(group)) {\n        return false;\n      }\n    }\n\n    return false;\n  }",
    "comment": " Determines whether this guard will \"elevate\" the status of any disabled diagnostic type in the group to a warning or an error. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "ComposeWarningsGuard.level",
    "class_name": "com.google.javascript.jscomp.ComposeWarningsGuard",
    "signature": "com.google.javascript.jscomp.ComposeWarningsGuard.level(JSError)",
    "snippet": "  @Override\n  public CheckLevel level(JSError error) {\n    for (WarningsGuard guard : guards) {\n      CheckLevel newLevel = guard.level(error);\n      if (newLevel != null) {\n        return newLevel;\n      }\n    }\n    return null;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "GuardComparator.compare",
    "class_name": "com.google.javascript.jscomp.ComposeWarningsGuard$GuardComparator",
    "signature": "com.google.javascript.jscomp.ComposeWarningsGuard$GuardComparator.compare(WarningsGuard,WarningsGuard)",
    "snippet": "    @Override\n    public int compare(WarningsGuard a, WarningsGuard b) {\n      int priorityDiff = a.getPriority() - b.getPriority();\n      if (priorityDiff != 0) {\n        return priorityDiff;\n      }\n\n      // If the warnings guards have the same priority, the one that\n      // was added last wins.\n      return orderOfAddition.get(b).intValue() -\n          orderOfAddition.get(a).intValue();\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "ControlFlowAnalysis.ControlFlowAnalysis",
    "class_name": "com.google.javascript.jscomp.ControlFlowAnalysis",
    "signature": "com.google.javascript.jscomp.ControlFlowAnalysis.ControlFlowAnalysis(AbstractCompiler,boolean,boolean)",
    "snippet": "  ControlFlowAnalysis(AbstractCompiler compiler,\n      boolean shouldTraverseFunctions, boolean edgeAnnotations) {\n    this.compiler = compiler;\n    this.shouldTraverseFunctions = shouldTraverseFunctions;\n    this.edgeAnnotations = edgeAnnotations;\n  }",
    "comment": " Constructor.  @param compiler Compiler instance. @param shouldTraverseFunctions Whether functions should be traversed (true by default). @param edgeAnnotations Whether to allow edge annotations. By default, only node annotations are allowed. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "ControlFlowAnalysis.computeFallThrough",
    "class_name": "com.google.javascript.jscomp.ControlFlowAnalysis",
    "signature": "com.google.javascript.jscomp.ControlFlowAnalysis.computeFallThrough(Node)",
    "snippet": "  static Node computeFallThrough(Node n) {\n    switch (n.getType()) {\n      case Token.DO:\n        return computeFallThrough(n.getFirstChild());\n      case Token.FOR:\n        if (NodeUtil.isForIn(n)) {\n          return n;\n        }\n        return computeFallThrough(n.getFirstChild());\n      case Token.LABEL:\n        return computeFallThrough(n.getLastChild());\n      default:\n        return n;\n    }\n  }",
    "comment": " Computes the destination node of n when we want to fallthough into the subtree of n. We don't always create a CFG edge into n itself because of DOs and FORs. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "ControlFlowAnalysis.computeFollowNode",
    "class_name": "com.google.javascript.jscomp.ControlFlowAnalysis",
    "signature": "com.google.javascript.jscomp.ControlFlowAnalysis.computeFollowNode(Node,ControlFlowAnalysis)",
    "snippet": "  static Node computeFollowNode(Node node, ControlFlowAnalysis cfa) {\n    return computeFollowNode(node, node, cfa);\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "ControlFlowAnalysis.computeFollowNode",
    "class_name": "com.google.javascript.jscomp.ControlFlowAnalysis",
    "signature": "com.google.javascript.jscomp.ControlFlowAnalysis.computeFollowNode(Node,Node,ControlFlowAnalysis)",
    "snippet": "  private static Node computeFollowNode(\n      Node fromNode, Node node, ControlFlowAnalysis cfa) {\n    /*\n     * This is the case where:\n     *\n     * 1. Parent is null implies that we are transferring control to the end of\n     * the script.\n     *\n     * 2. Parent is a function implies that we are transferring control back to\n     * the caller of the function.\n     *\n     * 3. If the node is a return statement, we should also transfer control\n     * back to the caller of the function.\n     *\n     * 4. If the node is root then we have reached the end of what we have been\n     * asked to traverse.\n     *\n     * In all cases we should transfer control to a \"symbolic return\" node.\n     * This will make life easier for DFAs.\n     */\n    Node parent = node.getParent();\n    if (parent == null || parent.getType() == Token.FUNCTION ||\n        (cfa != null && node == cfa.root)) {\n      return null;\n    }\n\n    // If we are just before a IF/WHILE/DO/FOR:\n    switch (parent.getType()) {\n      // The follow() of any of the path from IF would be what follows IF.\n      case Token.IF:\n        return computeFollowNode(fromNode, parent, cfa);\n      case Token.CASE:\n      case Token.DEFAULT:\n        // After the body of a CASE, the control goes to the body of the next\n        // case, without having to go to the case condition.\n        if (parent.getNext() != null) {\n          if (parent.getNext().getType() == Token.CASE) {\n            return parent.getNext().getFirstChild().getNext();\n          } else if (parent.getNext().getType() == Token.DEFAULT) {\n            return parent.getNext().getFirstChild();\n          } else {\n            Preconditions.checkState(false, \"Not reachable\");\n          }\n        } else {\n          return computeFollowNode(fromNode, parent, cfa);\n        }\n        break;\n      case Token.FOR:\n        if (NodeUtil.isForIn(parent)) {\n          return parent;\n        } else {\n          return parent.getFirstChild().getNext().getNext();\n        }\n      case Token.WHILE:\n      case Token.DO:\n        return parent;\n      case Token.TRY:\n        // If we are coming out of the TRY block...\n        if (parent.getFirstChild() == node) {\n          if (NodeUtil.hasFinally(parent)) { // and have FINALLY block.\n            return computeFallThrough(parent.getLastChild());\n          } else { // and have no FINALLY.\n            return computeFollowNode(fromNode, parent, cfa);\n          }\n        // CATCH block.\n        } else if (NodeUtil.getCatchBlock(parent) == node){\n          if (NodeUtil.hasFinally(parent)) { // and have FINALLY block.\n            return computeFallThrough(node.getNext());\n          } else {\n            return computeFollowNode(fromNode, parent, cfa);\n          }\n        // If we are coming out of the FINALLY block...\n        } else if (parent.getLastChild() == node){\n          if (cfa != null) {\n            for (Node finallyNode : cfa.finallyMap.get(parent)) {\n              cfa.createEdge(fromNode, Branch.UNCOND, finallyNode);\n            }\n          }\n          return computeFollowNode(fromNode, parent, cfa);\n        }\n    }\n\n    // Now that we are done with the special cases follow should be its\n    // immediate sibling, unless its sibling is a function\n    Node nextSibling = node.getNext();\n\n    // Skip function declarations because control doesn't get pass into it.\n    while (nextSibling != null && nextSibling.getType() == Token.FUNCTION) {\n      nextSibling = nextSibling.getNext();\n    }\n\n    if (nextSibling != null) {\n      return computeFallThrough(nextSibling);\n    } else {\n      // If there are no more siblings, control is transfered up the AST.\n      return computeFollowNode(fromNode, parent, cfa);\n    }\n  }",
    "comment": " Computes the follow() node of a given node and its parent. There is a side effect when calling this function. If this function computed an edge that exists a FINALLY, it'll attempt to connect the fromNode to the outer FINALLY according to the finallyMap.  @param fromNode The original source node since {@code node} is changed during recursion. @param node The node that follow() should compute. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "ControlFlowAnalysis.connectToPossibleExceptionHandler",
    "class_name": "com.google.javascript.jscomp.ControlFlowAnalysis",
    "signature": "com.google.javascript.jscomp.ControlFlowAnalysis.connectToPossibleExceptionHandler(Node,Node)",
    "snippet": "  private void connectToPossibleExceptionHandler(Node cfgNode, Node target) {\n    if (mayThrowException(target) && !exceptionHandler.isEmpty()) {\n      Node lastJump = cfgNode;\n      for (Node handler : exceptionHandler) {\n        if (NodeUtil.isFunction(handler)) {\n          return;\n        }\n        Preconditions.checkState(handler.getType() == Token.TRY);\n        Node catchBlock = NodeUtil.getCatchBlock(handler);\n\n        if (!NodeUtil.hasCatchHandler(catchBlock)) { // No catch but a FINALLY.\n          if (lastJump == cfgNode) {\n            createEdge(cfgNode, Branch.ON_EX, handler.getLastChild());\n          } else {\n            finallyMap.put(lastJump, handler.getLastChild());\n          }\n        } else { // Has a catch.\n          if (lastJump == cfgNode) {\n            createEdge(cfgNode, Branch.ON_EX, catchBlock);\n            return;\n          } else {\n            finallyMap.put(lastJump, catchBlock);\n          }\n        }\n        lastJump = handler;\n      }\n    }\n  }",
    "comment": " Connects cfgNode to the proper CATCH block if target subtree might throw an exception. If there are FINALLY blocks reached before a CATCH, it will make the corresponding entry in finallyMap. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "ControlFlowAnalysis.createEdge",
    "class_name": "com.google.javascript.jscomp.ControlFlowAnalysis",
    "signature": "com.google.javascript.jscomp.ControlFlowAnalysis.createEdge(Node,Branch,Node)",
    "snippet": "  private void createEdge(Node fromNode, ControlFlowGraph.Branch branch,\n      Node toNode) {\n    cfg.createNode(fromNode);\n    cfg.createNode(toNode);\n    cfg.connectIfNotFound(fromNode, branch, toNode);\n  }",
    "comment": " Connects the two nodes in the control flow graph.  @param fromNode Source. @param toNode Destination. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "ControlFlowAnalysis.getCfg",
    "class_name": "com.google.javascript.jscomp.ControlFlowAnalysis",
    "signature": "com.google.javascript.jscomp.ControlFlowAnalysis.getCfg()",
    "snippet": "  ControlFlowGraph<Node> getCfg() {\n    return cfg;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "ControlFlowAnalysis.handleExpr",
    "class_name": "com.google.javascript.jscomp.ControlFlowAnalysis",
    "signature": "com.google.javascript.jscomp.ControlFlowAnalysis.handleExpr(Node)",
    "snippet": "  private void handleExpr(Node node) {\n    createEdge(node, Branch.UNCOND, computeFollowNode(node, this));\n    connectToPossibleExceptionHandler(node, node);\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "ControlFlowAnalysis.handleFunction",
    "class_name": "com.google.javascript.jscomp.ControlFlowAnalysis",
    "signature": "com.google.javascript.jscomp.ControlFlowAnalysis.handleFunction(Node)",
    "snippet": "  private void handleFunction(Node node) {\n    // A block transfer control to its first child if it is not empty.\n    Preconditions.checkState(node.getChildCount() >= 3);\n    createEdge(node, Branch.UNCOND,\n        computeFallThrough(node.getFirstChild().getNext().getNext()));\n    Preconditions.checkState(exceptionHandler.peek() == node);\n    exceptionHandler.pop();\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "ControlFlowAnalysis.handleStmt",
    "class_name": "com.google.javascript.jscomp.ControlFlowAnalysis",
    "signature": "com.google.javascript.jscomp.ControlFlowAnalysis.handleStmt(Node)",
    "snippet": "  private void handleStmt(Node node) {\n    // Simply transfer to the next line.\n    createEdge(node, Branch.UNCOND, computeFollowNode(node, this));\n    connectToPossibleExceptionHandler(node, node);\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "ControlFlowAnalysis.handleStmtList",
    "class_name": "com.google.javascript.jscomp.ControlFlowAnalysis",
    "signature": "com.google.javascript.jscomp.ControlFlowAnalysis.handleStmtList(Node)",
    "snippet": "  private void handleStmtList(Node node) {\n    Node parent = node.getParent();\n    // Special case, don't add a block of empty CATCH block to the graph.\n    if (node.getType() == Token.BLOCK && parent != null &&\n        parent.getType() == Token.TRY &&\n        NodeUtil.getCatchBlock(parent) == node &&\n        !NodeUtil.hasCatchHandler(node)) {\n      return;\n    }\n\n    // A block transfer control to its first child if it is not empty.\n    Node child = node.getFirstChild();\n\n    // Function declarations are skipped since control doesn't go into that\n    // function (unless it is called)\n    while (child != null && child.getType() == Token.FUNCTION) {\n      child = child.getNext();\n    }\n\n    if (child != null) {\n      createEdge(node, Branch.UNCOND, computeFallThrough(child));\n    } else {\n      createEdge(node, Branch.UNCOND, computeFollowNode(node, this));\n    }\n\n    // Synthetic blocks\n    if (parent != null) {\n      switch (parent.getType()) {\n        case Token.DEFAULT:\n        case Token.CASE:\n        case Token.TRY:\n          break;\n        default:\n          if (node.getType() == Token.BLOCK && node.isSyntheticBlock()) {\n            createEdge(node, Branch.SYN_BLOCK, computeFollowNode(node, this));\n          }\n          break;\n      }\n    }\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "ControlFlowAnalysis.mayThrowException",
    "class_name": "com.google.javascript.jscomp.ControlFlowAnalysis",
    "signature": "com.google.javascript.jscomp.ControlFlowAnalysis.mayThrowException(Node)",
    "snippet": "  public static boolean mayThrowException(Node n) {\n    switch (n.getType()) {\n      case Token.CALL:\n      case Token.GETPROP:\n      case Token.GETELEM:\n      case Token.THROW:\n      case Token.NEW:\n      case Token.ASSIGN:\n      case Token.INC:\n      case Token.DEC:\n      case Token.INSTANCEOF:\n        return true;\n      case Token.FUNCTION:\n        return false;\n    }\n    for (Node c = n.getFirstChild(); c != null; c = c.getNext()) {\n      if (!ControlFlowGraph.isEnteringNewCfgNode(c) && mayThrowException(c)) {\n        return true;\n      }\n    }\n    return false;\n  }",
    "comment": " Determines if the subtree might throw an exception. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "ControlFlowAnalysis.prioritizeFromEntryNode",
    "class_name": "com.google.javascript.jscomp.ControlFlowAnalysis",
    "signature": "com.google.javascript.jscomp.ControlFlowAnalysis.prioritizeFromEntryNode(DiGraphNode)",
    "snippet": "  private void prioritizeFromEntryNode(DiGraphNode<Node, Branch> entry) {\n    PriorityQueue<DiGraphNode<Node, Branch>> worklist =\n        new PriorityQueue<DiGraphNode<Node, Branch>>(10, priorityComparator);\n    worklist.add(entry);\n\n    while (!worklist.isEmpty()) {\n      DiGraphNode<Node, Branch> current = worklist.remove();\n      if (nodePriorities.containsKey(current)) {\n        continue;\n      }\n\n      nodePriorities.put(current, ++priorityCounter);\n\n      List<DiGraphNode<Node, Branch>> successors =\n          cfg.getDirectedSuccNodes(current);\n      for (DiGraphNode<Node, Branch> candidate : successors) {\n        worklist.add(candidate);\n      }\n    }\n  }",
    "comment": " Given an entry node, find all the nodes reachable from that node and prioritize them. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "ControlFlowAnalysis.process",
    "class_name": "com.google.javascript.jscomp.ControlFlowAnalysis",
    "signature": "com.google.javascript.jscomp.ControlFlowAnalysis.process(Node,Node)",
    "snippet": "  @Override\n  public void process(Node externs, Node root) {\n    this.root = root;\n    astPositionCounter = 0;\n    astPosition = Maps.newHashMap();\n    nodePriorities = Maps.newHashMap();\n    cfg = new AstControlFlowGraph(computeFallThrough(root), nodePriorities,\n                                  edgeAnnotations);\n    NodeTraversal.traverse(compiler, root, this);\n    astPosition.put(null, ++astPositionCounter); // the implicit return is last.\n\n    // Now, generate the priority of nodes by doing a depth-first\n    // search on the CFG.\n    priorityCounter = 0;\n    DiGraphNode<Node, Branch> entry = cfg.getEntry();\n    prioritizeFromEntryNode(entry);\n\n    if (shouldTraverseFunctions) {\n      // If we're traversing inner functions, we need to rank the\n      // priority of them too.\n      for (DiGraphNode<Node, Branch> candidate : cfg.getDirectedGraphNodes()) {\n        Node value = candidate.getValue();\n        if (value != null && value.getType() == Token.FUNCTION) {\n          Preconditions.checkState(\n              !nodePriorities.containsKey(candidate) || candidate == entry);\n          prioritizeFromEntryNode(candidate);\n        }\n      }\n    }\n\n    // At this point, all reachable nodes have been given a priority, but\n    // unreachable nodes have not been given a priority. Put them last.\n    // Presumably, it doesn't really matter what priority they get, since\n    // this shouldn't happen in real code.\n    for (DiGraphNode<Node, Branch> candidate : cfg.getDirectedGraphNodes()) {\n      if (!nodePriorities.containsKey(candidate)) {\n        nodePriorities.put(candidate, ++priorityCounter);\n      }\n    }\n\n    // Again, the implicit return node is always last.\n    nodePriorities.put(cfg.getImplicitReturn(), ++priorityCounter);\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "ControlFlowAnalysis.shouldTraverse",
    "class_name": "com.google.javascript.jscomp.ControlFlowAnalysis",
    "signature": "com.google.javascript.jscomp.ControlFlowAnalysis.shouldTraverse(NodeTraversal,Node,Node)",
    "snippet": "  @Override\n  public boolean shouldTraverse(\n      NodeTraversal nodeTraversal, Node n, Node parent) {\n    astPosition.put(n, astPositionCounter++);\n\n    switch (n.getType()) {\n      case Token.FUNCTION:\n        if (shouldTraverseFunctions || n == cfg.getEntry().getValue()) {\n          exceptionHandler.push(n);\n          return true;\n        }\n        return false;\n      case Token.TRY:\n        exceptionHandler.push(n);\n        return true;\n    }\n\n    /*\n     * We are going to stop the traversal depending on what the node's parent\n     * is.\n     *\n     * We are only interested in adding edges between nodes that change control\n     * flow. The most obvious ones are loops and IF-ELSE's. A statement\n     * transfers control to its next sibling.\n     *\n     * In case of an expression tree, there is no control flow within the tree\n     * even when there are short circuited operators and conditionals. When we\n     * are doing data flow analysis, we will simply synthesize lattices up the\n     * expression tree by finding the meet at each expression node.\n     *\n     * For example: within a Token.SWITCH, the expression in question does not\n     * change the control flow and need not to be considered.\n     */\n    if (parent != null) {\n      switch (parent.getType()) {\n        case Token.FOR:\n          // Only traverse the body of the for loop.\n          return n == parent.getLastChild();\n\n        // Skip the conditions.\n        case Token.IF:\n        case Token.WHILE:\n        case Token.WITH:\n          return n != parent.getFirstChild();\n        case Token.DO:\n          return n != parent.getFirstChild().getNext();\n        // Only traverse the body of the cases\n        case Token.SWITCH:\n        case Token.CASE:\n        case Token.CATCH:\n        case Token.LABEL:\n          return n != parent.getFirstChild();\n        case Token.FUNCTION:\n          return n == parent.getFirstChild().getNext().getNext();\n        case Token.CONTINUE:\n        case Token.BREAK:\n        case Token.EXPR_RESULT:\n        case Token.VAR:\n        case Token.RETURN:\n        case Token.THROW:\n          return false;\n        case Token.TRY:\n          /* Just before we are about to visit the second child of the TRY node,\n           * we know that we will be visiting either the CATCH or the FINALLY.\n           * In other words, we know that the post order traversal of the TRY\n           * block has been finished, no more exceptions can be caught by the\n           * handler at this TRY block and should be taken out of the stack.\n           */\n          if (n == parent.getFirstChild().getNext()) {\n            Preconditions.checkState(exceptionHandler.peek() == parent);\n            exceptionHandler.pop();\n          }\n      }\n    }\n    return true;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "ControlFlowAnalysis.visit",
    "class_name": "com.google.javascript.jscomp.ControlFlowAnalysis",
    "signature": "com.google.javascript.jscomp.ControlFlowAnalysis.visit(NodeTraversal,Node,Node)",
    "snippet": "  @Override\n  public void visit(NodeTraversal t, Node n, Node parent) {\n    switch (n.getType()) {\n      case Token.IF:\n        handleIf(n);\n        return;\n      case Token.WHILE:\n        handleWhile(n);\n        return;\n      case Token.DO:\n        handleDo(n);\n        return;\n      case Token.FOR:\n        handleFor(n);\n        return;\n      case Token.SWITCH:\n        handleSwitch(n);\n        return;\n      case Token.CASE:\n        handleCase(n);\n        return;\n      case Token.DEFAULT:\n        handleDefault(n);\n        return;\n      case Token.BLOCK:\n      case Token.SCRIPT:\n        handleStmtList(n);\n        return;\n      case Token.FUNCTION:\n        handleFunction(n);\n        return;\n      case Token.EXPR_RESULT:\n        handleExpr(n);\n        return;\n      case Token.THROW:\n        handleThrow(n);\n        return;\n      case Token.TRY:\n        handleTry(n);\n        return;\n      case Token.CATCH:\n        handleCatch(n);\n        return;\n      case Token.BREAK:\n        handleBreak(n);\n        return;\n      case Token.CONTINUE:\n        handleContinue(n);\n        return;\n      case Token.RETURN:\n        handleReturn(n);\n        return;\n      case Token.WITH:\n        handleWith(n);\n        return;\n      case Token.LABEL:\n        return;\n      default:\n        handleStmt(n);\n        return;\n    }\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "AstControlFlowGraph.getOptionalNodeComparator",
    "class_name": "com.google.javascript.jscomp.ControlFlowAnalysis$AstControlFlowGraph",
    "signature": "com.google.javascript.jscomp.ControlFlowAnalysis$AstControlFlowGraph.getOptionalNodeComparator(boolean)",
    "snippet": "    @Override\n    /**\n     * Returns a node comparator based on the pre-order traversal of the AST.\n     * @param isForward x 'before' y in the pre-order traversal implies\n     * x 'less than' y (if true) and x 'greater than' y (if false).\n     */\n    public Comparator<DiGraphNode<Node, Branch>> getOptionalNodeComparator(\n        boolean isForward) {\n      if (isForward) {\n        return new Comparator<DiGraphNode<Node, Branch>>() {\n          @Override\n          public int compare(\n              DiGraphNode<Node, Branch> n1, DiGraphNode<Node, Branch> n2) {\n            return getPosition(n1) - getPosition(n2);\n          }\n        };\n      } else {\n        return new Comparator<DiGraphNode<Node, Branch>>() {\n          @Override\n          public int compare(\n              DiGraphNode<Node, Branch> n1, DiGraphNode<Node, Branch> n2) {\n            return getPosition(n2) - getPosition(n1);\n          }\n        };\n      }\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "AstControlFlowGraph.getPosition",
    "class_name": "com.google.javascript.jscomp.ControlFlowAnalysis$AstControlFlowGraph",
    "signature": "com.google.javascript.jscomp.ControlFlowAnalysis$AstControlFlowGraph.getPosition(DiGraphNode)",
    "snippet": "    private int getPosition(DiGraphNode<Node, Branch> n) {\n      Integer priority = priorities.get(n);\n      Preconditions.checkNotNull(priority);\n      return priority;\n    }",
    "comment": " Gets the pre-order traversal position of the given node. @return An arbitrary counter used for comparing positions. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "ControlFlowGraph.ControlFlowGraph",
    "class_name": "com.google.javascript.jscomp.ControlFlowGraph",
    "signature": "com.google.javascript.jscomp.ControlFlowGraph.ControlFlowGraph(N,boolean,boolean)",
    "snippet": "  ControlFlowGraph(\n      N entry, boolean nodeAnnotations, boolean edgeAnnotations) {\n    super(nodeAnnotations, edgeAnnotations);\n    implicitReturn = createDirectedGraphNode(null);\n    this.entry = createDirectedGraphNode(entry);\n  }",
    "comment": " Constructor. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "ControlFlowGraph.getEntry",
    "class_name": "com.google.javascript.jscomp.ControlFlowGraph",
    "signature": "com.google.javascript.jscomp.ControlFlowGraph.getEntry()",
    "snippet": "  public DiGraphNode<N, ControlFlowGraph.Branch> getEntry() {\n    return entry;\n  }",
    "comment": " Gets the entry point of the control flow graph. In general, this should be the beginning of the global script or beginning of a function.  @return The entry point. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "ControlFlowGraph.getImplicitReturn",
    "class_name": "com.google.javascript.jscomp.ControlFlowGraph",
    "signature": "com.google.javascript.jscomp.ControlFlowGraph.getImplicitReturn()",
    "snippet": "  public DiGraphNode<N, ControlFlowGraph.Branch> getImplicitReturn() {\n    return implicitReturn;\n  }",
    "comment": " Gets the implicit return node.  @return Return node. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "ControlFlowGraph.isEnteringNewCfgNode",
    "class_name": "com.google.javascript.jscomp.ControlFlowGraph",
    "signature": "com.google.javascript.jscomp.ControlFlowGraph.isEnteringNewCfgNode(Node)",
    "snippet": "  public static boolean isEnteringNewCfgNode(Node n) {\n    Node parent = n.getParent();\n    switch (parent.getType()) {\n      case Token.BLOCK:\n      case Token.SCRIPT:\n      case Token.TRY:\n      case Token.FINALLY:\n        return true;\n      case Token.FUNCTION:\n        // A function node represents the start of a function where the name\n        // is bleed into the local scope and parameters has been assigned\n        // to the formal argument names. The node includes the name of the\n        // function and the LP list since we assume the whole set up process\n        // is atomic without change in control flow. The next change of\n        // control is going into the function's body represent by the second\n        // child.\n        return n != parent.getFirstChild().getNext();\n      case Token.WHILE:\n      case Token.DO:\n      case Token.IF:\n        // Theses control structure is represented by its node that holds the\n        // condition. Each of them is a branch node based on its condition.\n        return NodeUtil.getConditionExpression(parent) != n;\n\n      case Token.FOR:\n        // The FOR(;;) node differs from other control structure in that\n        // it has a initialization and a increment statement. Those\n        // two statements have its corresponding CFG nodes to represent them.\n        // The FOR node represents the condition check for each iteration.\n        // That way the following:\n        // for(var x = 0; x < 10; x++) { } has a graph that is isomorphic to\n        // var x = 0; while(x<10) {  x++; }\n        if (NodeUtil.isForIn(parent)) {\n          return n == parent.getLastChild();\n        } else {\n          return NodeUtil.getConditionExpression(parent) != n;\n        }\n      case Token.SWITCH:\n      case Token.CASE:\n      case Token.CATCH:\n      case Token.WITH:\n        return n != parent.getFirstChild();\n      default:\n        return false;\n    }\n  }",
    "comment": " @return True if n should be represented by a new CFG node in the control flow graph. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "AbstractCfgNodeTraversalCallback.shouldTraverse",
    "class_name": "com.google.javascript.jscomp.ControlFlowGraph$AbstractCfgNodeTraversalCallback",
    "signature": "com.google.javascript.jscomp.ControlFlowGraph$AbstractCfgNodeTraversalCallback.shouldTraverse(NodeTraversal,Node,Node)",
    "snippet": "    public final boolean shouldTraverse(NodeTraversal nodeTraversal, Node n,\n        Node parent) {\n      if (parent == null) {\n        return true;\n      }\n      return !isEnteringNewCfgNode(n);\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "Branch.isConditional",
    "class_name": "com.google.javascript.jscomp.ControlFlowGraph$Branch",
    "signature": "com.google.javascript.jscomp.ControlFlowGraph$Branch.isConditional()",
    "snippet": "    public boolean isConditional() {\n      return this == ON_TRUE || this == ON_FALSE;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "ControlStructureCheck.ControlStructureCheck",
    "class_name": "com.google.javascript.jscomp.ControlStructureCheck",
    "signature": "com.google.javascript.jscomp.ControlStructureCheck.ControlStructureCheck(AbstractCompiler)",
    "snippet": "  ControlStructureCheck(AbstractCompiler compiler) {\n    this.compiler = compiler;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "ControlStructureCheck.check",
    "class_name": "com.google.javascript.jscomp.ControlStructureCheck",
    "signature": "com.google.javascript.jscomp.ControlStructureCheck.check(Node)",
    "snippet": "  private void check(Node node) {\n    switch (node.getType()) {\n      case Token.WITH:\n        JSDocInfo info = node.getJSDocInfo();\n        boolean allowWith =\n            info != null && info.getSuppressions().contains(\"with\");\n        if (!allowWith) {\n          report(node, USE_OF_WITH);\n        }\n        break;\n    }\n\n    for (Node bChild = node.getFirstChild(); bChild != null;) {\n      Node next = bChild.getNext();\n      check(bChild);\n      bChild = next;\n    }\n  }",
    "comment": " Reports errors for any invalid use of control structures.  @param node Current node to check. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "ControlStructureCheck.process",
    "class_name": "com.google.javascript.jscomp.ControlStructureCheck",
    "signature": "com.google.javascript.jscomp.ControlStructureCheck.process(Node,Node)",
    "snippet": "  @Override\n  public void process(Node externs, Node root) {\n    check(root);\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "ConvertToDottedProperties.ConvertToDottedProperties",
    "class_name": "com.google.javascript.jscomp.ConvertToDottedProperties",
    "signature": "com.google.javascript.jscomp.ConvertToDottedProperties.ConvertToDottedProperties(AbstractCompiler)",
    "snippet": "  ConvertToDottedProperties(AbstractCompiler compiler) {\n    this.compiler = compiler;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "ConvertToDottedProperties.process",
    "class_name": "com.google.javascript.jscomp.ConvertToDottedProperties",
    "signature": "com.google.javascript.jscomp.ConvertToDottedProperties.process(Node,Node)",
    "snippet": "  @Override\n  public void process(Node externs, Node root) {\n    NodeTraversal.traverse(compiler, root, this);\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "ConvertToDottedProperties.visit",
    "class_name": "com.google.javascript.jscomp.ConvertToDottedProperties",
    "signature": "com.google.javascript.jscomp.ConvertToDottedProperties.visit(NodeTraversal,Node,Node)",
    "snippet": "  @Override\n  public void visit(NodeTraversal t, Node n, Node parent) {\n    switch (n.getType()) {\n      case Token.GET:\n      case Token.SET:\n      case Token.STRING:\n        if (NodeUtil.isObjectLitKey(n, parent) &&\n            NodeUtil.isValidPropertyName(n.getString())) {\n          n.putBooleanProp(Node.QUOTED_PROP, false);\n        }\n        break;\n\n      case Token.GETELEM:\n        Node left = n.getFirstChild();\n        Node right = left.getNext();\n        if (right.getType() == Token.STRING &&\n            NodeUtil.isValidPropertyName(right.getString())) {\n          n.removeChild(left);\n          n.removeChild(right);\n          parent.replaceChild(n, new Node(Token.GETPROP, left, right));\n          compiler.reportCodeChange();\n        }\n        break;\n    }\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "DataFlowAnalysis.DataFlowAnalysis",
    "class_name": "com.google.javascript.jscomp.DataFlowAnalysis",
    "signature": "com.google.javascript.jscomp.DataFlowAnalysis.DataFlowAnalysis(ControlFlowGraph,JoinOp)",
    "snippet": "  DataFlowAnalysis(ControlFlowGraph<N> targetCfg, JoinOp<L> joinOp) {\n    this.cfg = targetCfg;\n    this.joinOp = joinOp;\n    Comparator<DiGraphNode<N, Branch>> nodeComparator =\n      cfg.getOptionalNodeComparator(isForward());\n    if (nodeComparator != null) {\n      this.orderedWorkSet = Sets.newTreeSet(nodeComparator);\n    } else {\n      this.orderedWorkSet = Sets.newLinkedHashSet();\n    }\n  }",
    "comment": " Constructs a data flow analysis.  <p>Typical usage <pre> DataFlowAnalysis dfa = ... dfa.analyze(); </pre>  {@link #analyze()} annotates the result to the control flow graph by means of {@link DiGraphNode#setAnnotation} without any modification of the graph itself. Additional calls to {@link #analyze()} recomputes the analysis which can be useful if the control flow graph has been modified.  @param targetCfg The control flow graph object that this object performs on. Modification of the graph requires a separate call to {@link #analyze()}.  @see #analyze() ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "DataFlowAnalysis.analyze",
    "class_name": "com.google.javascript.jscomp.DataFlowAnalysis",
    "signature": "com.google.javascript.jscomp.DataFlowAnalysis.analyze()",
    "snippet": "  final void analyze() {\n    analyze(MAX_STEPS);\n  }",
    "comment": " Finds a fixed-point solution using at most {@link #MAX_STEPS} iterations.  @see #analyze(int) ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "DataFlowAnalysis.analyze",
    "class_name": "com.google.javascript.jscomp.DataFlowAnalysis",
    "signature": "com.google.javascript.jscomp.DataFlowAnalysis.analyze(int)",
    "snippet": "  final void analyze(int maxSteps) {\n    initialize();\n    int step = 0;\n    while (!orderedWorkSet.isEmpty()) {\n      if (step > maxSteps) {\n        throw new MaxIterationsExceededException(\n          \"Analysis did not terminate after \" + maxSteps + \" iterations\");\n      }\n      DiGraphNode<N, Branch> curNode = orderedWorkSet.iterator().next();\n      orderedWorkSet.remove(curNode);\n      joinInputs(curNode);\n      if (flow(curNode)) {\n        // If there is a change in the current node, we want to grab the list\n        // of nodes that this node affects.\n        List<DiGraphNode<N, Branch>> nextNodes = isForward() ?\n            cfg.getDirectedSuccNodes(curNode) :\n            cfg.getDirectedPredNodes(curNode);\n        for (DiGraphNode<N, Branch> nextNode : nextNodes) {\n          if (nextNode != cfg.getImplicitReturn()) {\n            orderedWorkSet.add(nextNode);\n          }\n        }\n      }\n      step++;\n    }\n    if (isForward()) {\n      joinInputs(getCfg().getImplicitReturn());\n    }\n  }",
    "comment": " Finds a fixed-point solution. The function has the side effect of replacing the existing node annotations with the computed solutions using {@link com.google.javascript.jscomp.graph.GraphNode#setAnnotation(Annotation)}.  <p>Initially, each node's input and output flow state contains the value given by {@link #createInitialEstimateLattice()} (with the exception of the entry node of the graph which takes on the {@link #createEntryLattice()} value. Each node will use the output state of its predecessor and compute a output state according to the instruction. At that time, any nodes that depends on the node's newly modified output value will need to recompute their output state again. Each step will perform a computation at one node until no extra computation will modify any existing output state anymore.  @param maxSteps Max number of iterations before the method stops and throw a {@link MaxIterationsExceededException}. This will prevent the analysis from going into a infinite loop. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "DataFlowAnalysis.computeEscaped",
    "class_name": "com.google.javascript.jscomp.DataFlowAnalysis",
    "signature": "com.google.javascript.jscomp.DataFlowAnalysis.computeEscaped(Scope,Set,AbstractCompiler)",
    "snippet": "  static void computeEscaped(final Scope jsScope, final Set<Var> escaped,\n      AbstractCompiler compiler) {\n    // TODO(user): Very good place to store this information somewhere.\n    AbstractPostOrderCallback finder = new AbstractPostOrderCallback() {\n      @Override\n      public void visit(NodeTraversal t, Node n, Node parent) {\n        if (jsScope == t.getScope() || !NodeUtil.isName(n)\n            || NodeUtil.isFunction(parent)) {\n          return;\n        }\n        String name = n.getString();\n        Var var = t.getScope().getVar(name);\n        if (var != null && var.scope == jsScope) {\n          escaped.add(jsScope.getVar(name));\n        }\n      }\n    };\n\n    NodeTraversal t = new NodeTraversal(compiler, finder);\n    t.traverseAtScope(jsScope);\n\n    // 1: Remove the exception name in CATCH which technically isn't local to\n    //    begin with.\n    for (Iterator<Var> i = jsScope.getVars(); i.hasNext();) {\n      Var var = i.next();\n      if (var.getParentNode().getType() == Token.CATCH ||\n          compiler.getCodingConvention().isExported(var.getName())) {\n        escaped.add(var);\n      }\n    }\n  }",
    "comment": " Compute set of escaped variables. When a variable is escaped in a dataflow analysis, it can be reference outside of the code that we are analyzing. A variable is escaped if any of the following is true:  <p><ol> <li>It is defined as the exception name in CATCH clause so it became a variable local not to our definition of scope.</li> <li>Exported variables as they can be needed after the script terminates. </li> <li>Names of named functions because in javascript, <i>function foo(){}</i> does not kill <i>foo</i> in the dataflow.</li> ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "DataFlowAnalysis.flow",
    "class_name": "com.google.javascript.jscomp.DataFlowAnalysis",
    "signature": "com.google.javascript.jscomp.DataFlowAnalysis.flow(DiGraphNode)",
    "snippet": "  protected boolean flow(DiGraphNode<N, Branch> node) {\n    FlowState<L> state = node.getAnnotation();\n    if (isForward()) {\n      L outBefore = state.out;\n      state.out = flowThrough(node.getValue(), state.in);\n      return !outBefore.equals(state.out);\n    } else {\n      L inBefore = state.in;\n      state.in = flowThrough(node.getValue(), state.out);\n      return !inBefore.equals(state.in);\n    }\n  }",
    "comment": " Performs a single flow through a node.  @return {@code true} if the flow state differs from the previous state. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "DataFlowAnalysis.getCfg",
    "class_name": "com.google.javascript.jscomp.DataFlowAnalysis",
    "signature": "com.google.javascript.jscomp.DataFlowAnalysis.getCfg()",
    "snippet": "  final ControlFlowGraph<N> getCfg() {\n    return cfg;\n  }",
    "comment": " Returns the control flow graph that this analysis was performed on. Modifications can be done on this graph, however, the only time that the annotations are correct is after {@link #analyze()} is called and before the graph has been modified. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "DataFlowAnalysis.initialize",
    "class_name": "com.google.javascript.jscomp.DataFlowAnalysis",
    "signature": "com.google.javascript.jscomp.DataFlowAnalysis.initialize()",
    "snippet": "  protected void initialize() {\n    // TODO(user): Calling clear doesn't deallocate the memory in a\n    // LinkedHashSet. Consider creating a new work set if we plan to repeatedly\n    // call analyze.\n    orderedWorkSet.clear();\n    for (DiGraphNode<N, Branch> node : cfg.getDirectedGraphNodes()) {\n      node.setAnnotation(new FlowState<L>(createInitialEstimateLattice(),\n          createInitialEstimateLattice()));\n      if (node != cfg.getImplicitReturn()) {\n        orderedWorkSet.add(node);\n      }\n    }\n  }",
    "comment": " Initializes the work list and the control flow graph. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "DataFlowAnalysis.joinInputs",
    "class_name": "com.google.javascript.jscomp.DataFlowAnalysis",
    "signature": "com.google.javascript.jscomp.DataFlowAnalysis.joinInputs(DiGraphNode)",
    "snippet": "  protected void joinInputs(DiGraphNode<N, Branch> node) {\n    FlowState<L> state = node.getAnnotation();\n    if (isForward()) {\n      if (cfg.getEntry() == node) {\n        state.setIn(createEntryLattice());\n      } else {\n        List<DiGraphNode<N, Branch>> inNodes = cfg.getDirectedPredNodes(node);\n        if (inNodes.size() == 1) {\n          FlowState<L> inNodeState = inNodes.get(0).getAnnotation();\n          state.setIn(inNodeState.getOut());\n        } else if (inNodes.size() > 1) {\n          List<L> values = new ArrayList<L>(inNodes.size());\n          for (DiGraphNode<N, Branch> currentNode : inNodes) {\n            FlowState<L> currentNodeState = currentNode.getAnnotation();\n            values.add(currentNodeState.getOut());\n          }\n          state.setIn(joinOp.apply(values));\n        }\n      }\n    } else {\n      List<DiGraphNode<N, Branch>> inNodes = cfg.getDirectedSuccNodes(node);\n      if (inNodes.size() == 1) {\n        DiGraphNode<N, Branch> inNode = inNodes.get(0);\n        if (inNode == cfg.getImplicitReturn()) {\n          state.setOut(createEntryLattice());\n        } else {\n          FlowState<L> inNodeState = inNode.getAnnotation();\n          state.setOut(inNodeState.getIn());\n        }\n      } else if (inNodes.size() > 1) {\n        List<L> values = new ArrayList<L>(inNodes.size());\n        for (DiGraphNode<N, Branch> currentNode : inNodes) {\n          FlowState<L> currentNodeState = currentNode.getAnnotation();\n          values.add(currentNodeState.getIn());\n        }\n        state.setOut(joinOp.apply(values));\n      }\n    }\n  }",
    "comment": " Computes the new flow state at a given node's entry by merging the output (input) lattice of the node's predecessor (successor).  @param node Node to compute new join. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "BranchedFlowState.setIn",
    "class_name": "com.google.javascript.jscomp.DataFlowAnalysis$BranchedFlowState",
    "signature": "com.google.javascript.jscomp.DataFlowAnalysis$BranchedFlowState.setIn(L)",
    "snippet": "    void setIn(L in) {\n      Preconditions.checkNotNull(in);\n      this.in = in;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "BranchedForwardDataFlowAnalysis.flow",
    "class_name": "com.google.javascript.jscomp.DataFlowAnalysis$BranchedForwardDataFlowAnalysis",
    "signature": "com.google.javascript.jscomp.DataFlowAnalysis$BranchedForwardDataFlowAnalysis.flow(DiGraphNode)",
    "snippet": "    @Override\n    protected final boolean flow(DiGraphNode<N, Branch> node) {\n      BranchedFlowState<L> state = node.getAnnotation();\n      List<L> outBefore = state.out;\n      state.out = branchedFlowThrough(node.getValue(), state.in);\n      Preconditions.checkState(outBefore.size() == state.out.size());\n      for (int i = 0; i < outBefore.size(); i++) {\n        if (!outBefore.get(i).equals(state.out.get(i))) {\n          return true;\n        }\n      }\n      return false;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "BranchedForwardDataFlowAnalysis.initialize",
    "class_name": "com.google.javascript.jscomp.DataFlowAnalysis$BranchedForwardDataFlowAnalysis",
    "signature": "com.google.javascript.jscomp.DataFlowAnalysis$BranchedForwardDataFlowAnalysis.initialize()",
    "snippet": "    @Override\n    protected void initialize() {\n      orderedWorkSet.clear();\n      for (DiGraphNode<N, Branch> node : getCfg().getDirectedGraphNodes()) {\n        int outEdgeCount = getCfg().getOutEdges(node.getValue()).size();\n        List<L> outLattices = Lists.newArrayList();\n        for (int i = 0; i < outEdgeCount; i++) {\n          outLattices.add(createInitialEstimateLattice());\n        }\n        node.setAnnotation(new BranchedFlowState<L>(\n            createInitialEstimateLattice(), outLattices));\n        if (node != getCfg().getImplicitReturn()) {\n          orderedWorkSet.add(node);\n        }\n      }\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "BranchedForwardDataFlowAnalysis.isForward",
    "class_name": "com.google.javascript.jscomp.DataFlowAnalysis$BranchedForwardDataFlowAnalysis",
    "signature": "com.google.javascript.jscomp.DataFlowAnalysis$BranchedForwardDataFlowAnalysis.isForward()",
    "snippet": "    @Override\n    final boolean isForward() {\n      return true;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "BranchedForwardDataFlowAnalysis.joinInputs",
    "class_name": "com.google.javascript.jscomp.DataFlowAnalysis$BranchedForwardDataFlowAnalysis",
    "signature": "com.google.javascript.jscomp.DataFlowAnalysis$BranchedForwardDataFlowAnalysis.joinInputs(DiGraphNode)",
    "snippet": "    @Override\n    protected void joinInputs(DiGraphNode<N, Branch> node) {\n      BranchedFlowState<L> state = node.getAnnotation();\n      List<DiGraphNode<N, Branch>> predNodes =\n          getCfg().getDirectedPredNodes(node);\n      List<L> values = new ArrayList<L>(predNodes.size());\n\n      for (DiGraphNode<N, Branch> predNode : predNodes) {\n        BranchedFlowState<L> predNodeState = predNode.getAnnotation();\n\n        L in = predNodeState.out.get(\n            getCfg().getDirectedSuccNodes(predNode).indexOf(node));\n\n        values.add(in);\n      }\n      if (getCfg().getEntry() == node) {\n        state.setIn(createEntryLattice());\n      } else if (!values.isEmpty()) {\n        state.setIn(joinOp.apply(values));\n      }\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "FlowState.getIn",
    "class_name": "com.google.javascript.jscomp.DataFlowAnalysis$FlowState",
    "signature": "com.google.javascript.jscomp.DataFlowAnalysis$FlowState.getIn()",
    "snippet": "    L getIn() {\n      return in;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "FlowState.getOut",
    "class_name": "com.google.javascript.jscomp.DataFlowAnalysis$FlowState",
    "signature": "com.google.javascript.jscomp.DataFlowAnalysis$FlowState.getOut()",
    "snippet": "    L getOut() {\n      return out;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "FlowState.setIn",
    "class_name": "com.google.javascript.jscomp.DataFlowAnalysis$FlowState",
    "signature": "com.google.javascript.jscomp.DataFlowAnalysis$FlowState.setIn(L)",
    "snippet": "    void setIn(L in) {\n      Preconditions.checkNotNull(in);\n      this.in = in;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "FlowState.setOut",
    "class_name": "com.google.javascript.jscomp.DataFlowAnalysis$FlowState",
    "signature": "com.google.javascript.jscomp.DataFlowAnalysis$FlowState.setOut(L)",
    "snippet": "    void setOut(L out) {\n      Preconditions.checkNotNull(out);\n      this.out = out;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "DeadAssignmentsElimination.DeadAssignmentsElimination",
    "class_name": "com.google.javascript.jscomp.DeadAssignmentsElimination",
    "signature": "com.google.javascript.jscomp.DeadAssignmentsElimination.DeadAssignmentsElimination(AbstractCompiler)",
    "snippet": "  public DeadAssignmentsElimination(AbstractCompiler compiler) {\n    this.compiler = compiler;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "DeadAssignmentsElimination.enterScope",
    "class_name": "com.google.javascript.jscomp.DeadAssignmentsElimination",
    "signature": "com.google.javascript.jscomp.DeadAssignmentsElimination.enterScope(NodeTraversal)",
    "snippet": "  @Override\n  public void enterScope(NodeTraversal t) {\n    Scope scope = t.getScope();\n    // Global scope _SHOULD_ work, however, liveness won't finish without\n    // -Xmx1024 in closure. We might have to look at coding conventions for\n    // exported variables as well.\n    if (scope.isGlobal()) {\n      return;\n    }\n\n    // We are not going to do any dead assignment elimination in when there is\n    // at least one inner function because in most browsers, when there is a\n    // closure, ALL the variables are saved (escaped).\n    Node fnBlock = t.getScopeRoot().getLastChild();\n    if (NodeUtil.containsFunction(fnBlock)) {\n      return;\n    }\n\n    // We don't do any dead assignment elimination if there are no assigns\n    // to eliminate. :)\n    if (!NodeUtil.has(fnBlock, matchRemovableAssigns,\n            Predicates.<Node>alwaysTrue())) {\n      return;\n    }\n\n    // Computes liveness information first.\n    ControlFlowGraph<Node> cfg = t.getControlFlowGraph();\n    liveness = new LiveVariablesAnalysis(cfg, scope, compiler);\n    liveness.analyze();\n    tryRemoveDeadAssignments(t, cfg);\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "DeadAssignmentsElimination.exitScope",
    "class_name": "com.google.javascript.jscomp.DeadAssignmentsElimination",
    "signature": "com.google.javascript.jscomp.DeadAssignmentsElimination.exitScope(NodeTraversal)",
    "snippet": "  @Override\n  public void exitScope(NodeTraversal t) {\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "DeadAssignmentsElimination.process",
    "class_name": "com.google.javascript.jscomp.DeadAssignmentsElimination",
    "signature": "com.google.javascript.jscomp.DeadAssignmentsElimination.process(Node,Node)",
    "snippet": "  @Override\n  public void process(Node externs, Node root) {\n    Preconditions.checkNotNull(externs);\n    Preconditions.checkNotNull(root);\n    NodeTraversal.traverse(compiler, root, this);\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "DeadAssignmentsElimination.visit",
    "class_name": "com.google.javascript.jscomp.DeadAssignmentsElimination",
    "signature": "com.google.javascript.jscomp.DeadAssignmentsElimination.visit(NodeTraversal,Node,Node)",
    "snippet": "  @Override\n  public void visit(NodeTraversal t, Node n, Node parent) {\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "DefaultCodingConvention.defineDelegateProxyPrototypeProperties",
    "class_name": "com.google.javascript.jscomp.DefaultCodingConvention",
    "signature": "com.google.javascript.jscomp.DefaultCodingConvention.defineDelegateProxyPrototypeProperties(JSTypeRegistry,Scope,List)",
    "snippet": "  @Override\n  public void defineDelegateProxyPrototypeProperties(\n      JSTypeRegistry registry, Scope scope,\n      List<ObjectType> delegateProxyPrototypes) {\n    // do nothing.\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "DefaultCodingConvention.isConstant",
    "class_name": "com.google.javascript.jscomp.DefaultCodingConvention",
    "signature": "com.google.javascript.jscomp.DefaultCodingConvention.isConstant(String)",
    "snippet": "  @Override\n  public boolean isConstant(String variableName) {\n    return false;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "DefaultCodingConvention.isConstantKey",
    "class_name": "com.google.javascript.jscomp.DefaultCodingConvention",
    "signature": "com.google.javascript.jscomp.DefaultCodingConvention.isConstantKey(String)",
    "snippet": "  @Override\n  public boolean isConstantKey(String variableName) {\n    return false;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "DefaultCodingConvention.isExported",
    "class_name": "com.google.javascript.jscomp.DefaultCodingConvention",
    "signature": "com.google.javascript.jscomp.DefaultCodingConvention.isExported(String,boolean)",
    "snippet": "  @Override\n  public boolean isExported(String name, boolean local) {\n    return local && name.startsWith(\"$super\");\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "DefaultPassConfig.DefaultPassConfig",
    "class_name": "com.google.javascript.jscomp.DefaultPassConfig",
    "signature": "com.google.javascript.jscomp.DefaultPassConfig.DefaultPassConfig(CompilerOptions)",
    "snippet": "  public DefaultPassConfig(CompilerOptions options) {\n    super(options);\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "DefaultPassConfig.assertAllLoopablePasses",
    "class_name": "com.google.javascript.jscomp.DefaultPassConfig",
    "signature": "com.google.javascript.jscomp.DefaultPassConfig.assertAllLoopablePasses(List)",
    "snippet": "  private void assertAllLoopablePasses(List<PassFactory> passes) {\n    for (PassFactory pass : passes) {\n      Preconditions.checkState(!pass.isOneTimePass());\n    }\n  }",
    "comment": "Verify that all the passes are multi-run passes. */",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "DefaultPassConfig.assertAllOneTimePasses",
    "class_name": "com.google.javascript.jscomp.DefaultPassConfig",
    "signature": "com.google.javascript.jscomp.DefaultPassConfig.assertAllOneTimePasses(List)",
    "snippet": "  private void assertAllOneTimePasses(List<PassFactory> passes) {\n    for (PassFactory pass : passes) {\n      Preconditions.checkState(pass.isOneTimePass());\n    }\n  }",
    "comment": "Verify that all the passes are one-time passes. */",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "DefaultPassConfig.combineChecks",
    "class_name": "com.google.javascript.jscomp.DefaultPassConfig",
    "signature": "com.google.javascript.jscomp.DefaultPassConfig.combineChecks(AbstractCompiler,List)",
    "snippet": "  private static HotSwapCompilerPass combineChecks(AbstractCompiler compiler,\n      List<Callback> callbacks) {\n    Preconditions.checkArgument(callbacks.size() > 0);\n    Callback[] array = callbacks.toArray(new Callback[callbacks.size()]);\n    return new CombinedCompilerPass(compiler, array);\n  }",
    "comment": "Executes the given callbacks with a {@link CombinedCompilerPass}. */",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "DefaultPassConfig.createEmptyPass",
    "class_name": "com.google.javascript.jscomp.DefaultPassConfig",
    "signature": "com.google.javascript.jscomp.DefaultPassConfig.createEmptyPass(String)",
    "snippet": "  private static PassFactory createEmptyPass(String name) {\n    return new PassFactory(name, true) {\n      @Override\n      protected CompilerPass createInternal(final AbstractCompiler compiler) {\n        return runInSerial();\n      }\n    };\n  }",
    "comment": " Create a no-op pass that can only run once. Used to break up loops. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "DefaultPassConfig.getAdditionalReplacements",
    "class_name": "com.google.javascript.jscomp.DefaultPassConfig",
    "signature": "com.google.javascript.jscomp.DefaultPassConfig.getAdditionalReplacements(CompilerOptions)",
    "snippet": "  @VisibleForTesting\n  static Map<String, Node> getAdditionalReplacements(\n      CompilerOptions options) {\n    Map<String, Node> additionalReplacements = Maps.newHashMap();\n\n    if (options.markAsCompiled || options.closurePass) {\n      additionalReplacements.put(COMPILED_CONSTANT_NAME, new Node(Token.TRUE));\n    }\n\n    if (options.closurePass && options.locale != null) {\n      additionalReplacements.put(CLOSURE_LOCALE_CONSTANT_NAME,\n          Node.newString(options.locale));\n    }\n\n    return additionalReplacements;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "DefaultPassConfig.getChecks",
    "class_name": "com.google.javascript.jscomp.DefaultPassConfig",
    "signature": "com.google.javascript.jscomp.DefaultPassConfig.getChecks()",
    "snippet": "  @Override\n  protected List<PassFactory> getChecks() {\n    List<PassFactory> checks = Lists.newArrayList();\n\n    if (options.closurePass) {\n      checks.add(closureGoogScopeAliases);\n    }\n\n    if (options.nameAnonymousFunctionsOnly) {\n      if (options.anonymousFunctionNaming ==\n          AnonymousFunctionNamingPolicy.MAPPED) {\n        checks.add(nameMappedAnonymousFunctions);\n      } else if (options.anonymousFunctionNaming ==\n          AnonymousFunctionNamingPolicy.UNMAPPED) {\n        checks.add(nameUnmappedAnonymousFunctions);\n      }\n      return checks;\n    }\n\n    if (options.checkSuspiciousCode ||\n        options.enables(DiagnosticGroups.GLOBAL_THIS)) {\n      checks.add(suspiciousCode);\n    }\n\n    if (options.checkControlStructures)  {\n      checks.add(checkControlStructures);\n    }\n\n    if (options.checkRequires.isOn()) {\n      checks.add(checkRequires);\n    }\n\n    if (options.checkProvides.isOn()) {\n      checks.add(checkProvides);\n    }\n\n    // The following passes are more like \"preprocessor\" passes.\n    // It's important that they run before most checking passes.\n    // Perhaps this method should be renamed?\n    if (options.generateExports) {\n      checks.add(generateExports);\n    }\n\n    if (options.exportTestFunctions) {\n      checks.add(exportTestFunctions);\n    }\n\n    if (options.closurePass) {\n      checks.add(closurePrimitives.makeOneTimePass());\n    }\n\n    if (options.closurePass && options.checkMissingGetCssNameLevel.isOn()) {\n      checks.add(closureCheckGetCssName);\n    }\n\n    if (options.syntheticBlockStartMarker != null) {\n      // This pass must run before the first fold constants pass.\n      checks.add(createSyntheticBlocks);\n    }\n\n    checks.add(checkVars);\n    if (options.computeFunctionSideEffects) {\n      checks.add(checkRegExp);\n    }\n\n    if (options.checkShadowVars.isOn()) {\n      checks.add(checkShadowVars);\n    }\n\n    if (options.aggressiveVarCheck.isOn()) {\n      checks.add(checkVariableReferences);\n    }\n\n    // This pass should run before types are assigned.\n    if (options.processObjectPropertyString) {\n      checks.add(objectPropertyStringPreprocess);\n    }\n\n    if (options.checkTypes || options.inferTypes) {\n      checks.add(resolveTypes.makeOneTimePass());\n      checks.add(inferTypes.makeOneTimePass());\n      if (options.checkTypes) {\n        checks.add(checkTypes.makeOneTimePass());\n      } else {\n        checks.add(inferJsDocInfo.makeOneTimePass());\n      }\n    }\n\n    if (options.checkUnreachableCode.isOn() ||\n        (options.checkTypes && options.checkMissingReturn.isOn())) {\n      checks.add(checkControlFlow);\n    }\n\n    // CheckAccessControls only works if check types is on.\n    if (options.checkTypes &&\n        (options.enables(DiagnosticGroups.ACCESS_CONTROLS)\n         || options.enables(DiagnosticGroups.CONSTANT_PROPERTY))) {\n      checks.add(checkAccessControls);\n    }\n\n    if (options.checkGlobalNamesLevel.isOn()) {\n      checks.add(checkGlobalNames);\n    }\n\n    checks.add(checkStrictMode);\n\n    // Replace 'goog.getCssName' before processing defines but after the\n    // other checks have been done.\n    if (options.closurePass) {\n      checks.add(closureReplaceGetCssName);\n    }\n\n    // i18n\n    // If you want to customize the compiler to use a different i18n pass,\n    // you can create a PassConfig that calls replacePassFactory\n    // to replace this.\n    checks.add(options.messageBundle != null ?\n        replaceMessages : createEmptyPass(\"replaceMessages\"));\n\n    if (options.getTweakProcessing().isOn()) {\n      checks.add(processTweaks);\n    }\n\n    // Defines in code always need to be processed.\n    checks.add(processDefines);\n\n    if (options.instrumentationTemplate != null ||\n        options.recordFunctionInformation) {\n      checks.add(computeFunctionNames);\n    }\n\n    if (options.nameReferenceGraphPath != null &&\n        !options.nameReferenceGraphPath.isEmpty()) {\n      checks.add(printNameReferenceGraph);\n    }\n\n    if (options.nameReferenceReportPath != null &&\n        !options.nameReferenceReportPath.isEmpty()) {\n      checks.add(printNameReferenceReport);\n    }\n\n    assertAllOneTimePasses(checks);\n    return checks;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "DefaultPassConfig.getCodeRemovingPasses",
    "class_name": "com.google.javascript.jscomp.DefaultPassConfig",
    "signature": "com.google.javascript.jscomp.DefaultPassConfig.getCodeRemovingPasses()",
    "snippet": "  private List<PassFactory> getCodeRemovingPasses() {\n    List<PassFactory> passes = Lists.newArrayList();\n    if (options.collapseObjectLiterals && !isInliningForbidden()) {\n      passes.add(collapseObjectLiterals);\n    }\n\n    if (options.inlineVariables || options.inlineLocalVariables) {\n      passes.add(inlineVariables);\n    } else if (options.inlineConstantVars) {\n      passes.add(inlineConstants);\n    }\n\n    if (options.foldConstants) {\n      // These used to be one pass.\n      passes.add(minimizeExitPoints);\n      passes.add(peepholeOptimizations);\n    }\n\n    if (options.removeDeadCode) {\n      passes.add(removeUnreachableCode);\n    }\n\n    if (options.removeUnusedPrototypeProperties) {\n      passes.add(removeUnusedPrototypeProperties);\n    }\n\n    assertAllLoopablePasses(passes);\n    return passes;\n  }",
    "comment": "Creates several passes aimed at removing code. */",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "DefaultPassConfig.getIntermediateState",
    "class_name": "com.google.javascript.jscomp.DefaultPassConfig",
    "signature": "com.google.javascript.jscomp.DefaultPassConfig.getIntermediateState()",
    "snippet": "  @Override\n  State getIntermediateState() {\n    return new State(\n        cssNames == null ? null : Maps.newHashMap(cssNames),\n        exportedNames == null ? null :\n            Collections.unmodifiableSet(exportedNames),\n        crossModuleIdGenerator, variableMap, propertyMap,\n        anonymousFunctionNameMap, stringMap, functionNames, idGeneratorMap);\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "DefaultPassConfig.getMainOptimizationLoop",
    "class_name": "com.google.javascript.jscomp.DefaultPassConfig",
    "signature": "com.google.javascript.jscomp.DefaultPassConfig.getMainOptimizationLoop()",
    "snippet": "  private List<PassFactory> getMainOptimizationLoop() {\n    List<PassFactory> passes = Lists.newArrayList();\n    if (options.inlineGetters) {\n      passes.add(inlineSimpleMethods);\n    }\n\n    passes.addAll(getCodeRemovingPasses());\n\n    if (options.inlineFunctions || options.inlineLocalFunctions) {\n      passes.add(inlineFunctions);\n    }\n\n    boolean runOptimizeCalls = options.optimizeCalls\n        || options.optimizeParameters\n        || options.optimizeReturns;\n\n    if (options.removeUnusedVars || options.removeUnusedLocalVars) {\n      if (options.deadAssignmentElimination) {\n        passes.add(deadAssignmentsElimination);\n      }\n      if (!runOptimizeCalls) {\n        passes.add(removeUnusedVars);\n      }\n    }\n    if (runOptimizeCalls) {\n      passes.add(optimizeCallsAndRemoveUnusedVars);\n    }\n    assertAllLoopablePasses(passes);\n    return passes;\n  }",
    "comment": "Creates the passes for the main optimization loop. */",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "DefaultPassConfig.getOptimizations",
    "class_name": "com.google.javascript.jscomp.DefaultPassConfig",
    "signature": "com.google.javascript.jscomp.DefaultPassConfig.getOptimizations()",
    "snippet": "  @Override\n  protected List<PassFactory> getOptimizations() {\n    List<PassFactory> passes = Lists.newArrayList();\n    passes.add(garbageCollectChecks);\n\n    // TODO(nicksantos): The order of these passes makes no sense, and needs\n    // to be re-arranged.\n\n    if (options.runtimeTypeCheck) {\n      passes.add(runtimeTypeCheck);\n    }\n\n    passes.add(createEmptyPass(\"beforeStandardOptimizations\"));\n\n    if (!options.idGenerators.isEmpty()) {\n      passes.add(replaceIdGenerators);\n    }\n\n    // Optimizes references to the arguments variable.\n    if (options.optimizeArgumentsArray) {\n      passes.add(optimizeArgumentsArray);\n    }\n\n    // Abstract method removal works best on minimally modified code, and also\n    // only needs to run once.\n    if (options.closurePass &&\n        (options.removeAbstractMethods || options.removeClosureAsserts)) {\n      passes.add(closureCodeRemoval);\n    }\n\n    // Collapsing properties can undo constant inlining, so we do this before\n    // the main optimization loop.\n    if (options.collapseProperties) {\n      passes.add(collapseProperties);\n    }\n\n    // ReplaceStrings runs after CollapseProperties in order to simplify\n    // pulling in values of constants defined in enums structures.\n    if (!options.replaceStringsFunctionDescriptions.isEmpty()) {\n      passes.add(replaceStrings);\n    }\n\n    // Tighten types based on actual usage.\n    if (options.tightenTypes) {\n      passes.add(tightenTypesBuilder);\n    }\n\n    // Property disambiguation should only run once and needs to be done\n    // soon after type checking, both so that it can make use of type\n    // information and so that other passes can take advantage of the renamed\n    // properties.\n    if (options.disambiguateProperties) {\n      passes.add(disambiguateProperties);\n    }\n\n    if (options.computeFunctionSideEffects) {\n      passes.add(markPureFunctions);\n    } else if (options.markNoSideEffectCalls) {\n      // TODO(user) The properties that this pass adds to CALL and NEW\n      // AST nodes increase the AST's in-memory size.  Given that we are\n      // already running close to our memory limits, we could run into\n      // trouble if we end up using the @nosideeffects annotation a lot\n      // or compute @nosideeffects annotations by looking at function\n      // bodies.  It should be easy to propagate @nosideeffects\n      // annotations as part of passes that depend on this property and\n      // store the result outside the AST (which would allow garbage\n      // collection once the pass is done).\n      passes.add(markNoSideEffectCalls);\n    }\n\n    if (options.chainCalls) {\n      passes.add(chainCalls);\n    }\n\n    // Constant checking must be done after property collapsing because\n    // property collapsing can introduce new constants (e.g. enum values).\n    if (options.inlineConstantVars) {\n      passes.add(checkConsts);\n    }\n\n    // The Caja library adds properties to Object.prototype, which breaks\n    // most for-in loops.  This adds a check to each loop that skips\n    // any property matching /___$/.\n    if (options.ignoreCajaProperties) {\n      passes.add(ignoreCajaProperties);\n    }\n\n    assertAllOneTimePasses(passes);\n\n    if (options.smartNameRemoval || options.reportPath != null) {\n      passes.addAll(getCodeRemovingPasses());\n      passes.add(smartNamePass);\n    }\n\n    // This needs to come after the inline constants pass, which is run within\n    // the code removing passes.\n    if (options.closurePass) {\n      passes.add(closureOptimizePrimitives);\n    }\n\n    // TODO(user): This forces a first crack at crossModuleCodeMotion\n    // before devirtualization. Once certain functions are devirtualized,\n    // it confuses crossModuleCodeMotion ability to recognized that\n    // it is recursive.\n\n    // TODO(user): This is meant for a temporary quick win.\n    // In the future, we might want to improve our analysis in\n    // CrossModuleCodeMotion so we don't need to do this.\n    if (options.crossModuleCodeMotion) {\n      passes.add(crossModuleCodeMotion);\n    }\n\n    // Method devirtualization benefits from property disambiguiation so\n    // it should run after that pass but before passes that do\n    // optimizations based on global names (like cross module code motion\n    // and inline functions).  Smart Name Removal does better if run before\n    // this pass.\n    if (options.devirtualizePrototypeMethods) {\n      passes.add(devirtualizePrototypeMethods);\n    }\n\n    if (options.customPasses != null) {\n      passes.add(getCustomPasses(\n          CustomPassExecutionTime.BEFORE_OPTIMIZATION_LOOP));\n    }\n\n    passes.add(createEmptyPass(\"beforeMainOptimizations\"));\n\n    if (options.specializeInitialModule) {\n      // When specializing the initial module, we want our fixups to be\n      // as lean as possible, so we run the entire optimization loop to a\n      // fixed point before specializing, then specialize, and then run the\n      // main optimization loop again.\n\n      passes.addAll(getMainOptimizationLoop());\n\n      if (options.crossModuleCodeMotion) {\n        passes.add(crossModuleCodeMotion);\n      }\n\n      if (options.crossModuleMethodMotion) {\n        passes.add(crossModuleMethodMotion);\n      }\n\n      passes.add(specializeInitialModule.makeOneTimePass());\n    }\n\n    passes.addAll(getMainOptimizationLoop());\n\n    passes.add(createEmptyPass(\"beforeModuleMotion\"));\n\n    if (options.crossModuleCodeMotion) {\n      passes.add(crossModuleCodeMotion);\n    }\n\n    if (options.crossModuleMethodMotion) {\n      passes.add(crossModuleMethodMotion);\n    }\n\n    passes.add(createEmptyPass(\"afterModuleMotion\"));\n\n    // Some optimizations belong outside the loop because running them more\n    // than once would either have no benefit or be incorrect.\n    if (options.customPasses != null) {\n      passes.add(getCustomPasses(\n          CustomPassExecutionTime.AFTER_OPTIMIZATION_LOOP));\n    }\n\n    if (options.flowSensitiveInlineVariables) {\n      passes.add(flowSensitiveInlineVariables);\n\n      // After inlining some of the variable uses, some variables are unused.\n      // Re-run remove unused vars to clean it up.\n      if (options.removeUnusedVars) {\n        passes.add(removeUnusedVars);\n      }\n    }\n\n    // Running this pass again is required to have goog.events compile down to\n    // nothing when compiled on its own.\n    if (options.smartNameRemoval) {\n      passes.add(smartNamePass2);\n    }\n\n    if (options.collapseAnonymousFunctions) {\n      passes.add(collapseAnonymousFunctions);\n    }\n\n    // Move functions before extracting prototype member declarations.\n    if (options.moveFunctionDeclarations) {\n      passes.add(moveFunctionDeclarations);\n    }\n\n    if (options.anonymousFunctionNaming ==\n        AnonymousFunctionNamingPolicy.MAPPED) {\n      passes.add(nameMappedAnonymousFunctions);\n    }\n\n    // The mapped name anonymous function pass makes use of information that\n    // the extract prototype member declarations pass removes so the former\n    // happens before the latter.\n    //\n    // Extracting prototype properties screws up the heuristic renaming\n    // policies, so never run it when those policies are requested.\n    if (options.extractPrototypeMemberDeclarations &&\n        (options.propertyRenaming != PropertyRenamingPolicy.HEURISTIC &&\n         options.propertyRenaming !=\n            PropertyRenamingPolicy.AGGRESSIVE_HEURISTIC)) {\n      passes.add(extractPrototypeMemberDeclarations);\n    }\n\n    if (options.ambiguateProperties &&\n        (options.propertyRenaming == PropertyRenamingPolicy.ALL_UNQUOTED)) {\n      passes.add(ambiguateProperties);\n    }\n\n    if (options.propertyRenaming != PropertyRenamingPolicy.OFF) {\n      passes.add(renameProperties);\n    }\n\n    // Reserve global names added to the \"windows\" object.\n    if (options.reserveRawExports) {\n      passes.add(gatherRawExports);\n    }\n\n    // This comes after property renaming because quoted property names must\n    // not be renamed.\n    if (options.convertToDottedProperties) {\n      passes.add(convertToDottedProperties);\n    }\n\n    // Property renaming must happen before this pass runs since this\n    // pass may convert dotted properties into quoted properties.  It\n    // is beneficial to run before alias strings, alias keywords and\n    // variable renaming.\n    if (options.rewriteFunctionExpressions) {\n      passes.add(rewriteFunctionExpressions);\n    }\n\n    // This comes after converting quoted property accesses to dotted property\n    // accesses in order to avoid aliasing property names.\n    if (!options.aliasableStrings.isEmpty() || options.aliasAllStrings) {\n      passes.add(aliasStrings);\n    }\n\n    if (options.aliasExternals) {\n      passes.add(aliasExternals);\n    }\n\n    if (options.aliasKeywords) {\n      passes.add(aliasKeywords);\n    }\n\n    // Passes after this point can no longer depend on normalized AST\n    // assumptions.\n    passes.add(markUnnormalized);\n\n    if (options.coalesceVariableNames) {\n      passes.add(coalesceVariableNames);\n\n      // coalesceVariables creates identity assignments and more redundant code\n      // that can be removed, rerun the peephole optimizations to clean them\n      // up.\n      if (options.foldConstants) {\n        passes.add(peepholeOptimizations);\n      }\n    }\n\n    if (options.collapseVariableDeclarations) {\n      passes.add(exploitAssign);\n      passes.add(collapseVariableDeclarations);\n    }\n\n    // This pass works best after collapseVariableDeclarations.\n    passes.add(denormalize);\n\n    if (options.instrumentationTemplate != null) {\n      passes.add(instrumentFunctions);\n    }\n\n    if (options.variableRenaming != VariableRenamingPolicy.ALL) {\n      // If we're leaving some (or all) variables with their old names,\n      // then we need to undo any of the markers we added for distinguishing\n      // local variables (\"$$1\").\n      passes.add(invertContextualRenaming);\n    }\n\n    if (options.variableRenaming != VariableRenamingPolicy.OFF) {\n      passes.add(renameVars);\n    }\n\n    if (options.groupVariableDeclarations) {\n      passes.add(groupVariableDeclarations);\n    }\n\n    // This pass should run after names stop changing.\n    if (options.processObjectPropertyString) {\n      passes.add(objectPropertyStringPostprocess);\n    }\n\n    if (options.labelRenaming) {\n      passes.add(renameLabels);\n    }\n\n    if (options.foldConstants) {\n      passes.add(latePeepholeOptimizations);\n    }\n\n    if (options.anonymousFunctionNaming ==\n        AnonymousFunctionNamingPolicy.UNMAPPED) {\n      passes.add(nameUnmappedAnonymousFunctions);\n    }\n\n    if (options.operaCompoundAssignFix) {\n      passes.add(operaCompoundAssignFix);\n    }\n\n    // Safety checks\n    passes.add(sanityCheckAst);\n    passes.add(sanityCheckVars);\n\n    return passes;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "DefaultPassConfig.isInliningForbidden",
    "class_name": "com.google.javascript.jscomp.DefaultPassConfig",
    "signature": "com.google.javascript.jscomp.DefaultPassConfig.isInliningForbidden()",
    "snippet": "  private boolean isInliningForbidden() {\n    return options.propertyRenaming == PropertyRenamingPolicy.HEURISTIC ||\n        options.propertyRenaming ==\n            PropertyRenamingPolicy.AGGRESSIVE_HEURISTIC;\n  }",
    "comment": " All inlining is forbidden in heuristic renaming mode, because inlining will ruin the invariants that it depends on. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "DefaultPassConfig.runInSerial",
    "class_name": "com.google.javascript.jscomp.DefaultPassConfig",
    "signature": "com.google.javascript.jscomp.DefaultPassConfig.runInSerial(Collection)",
    "snippet": "  private static CompilerPass runInSerial(\n      final Collection<CompilerPass> passes) {\n    return new CompilerPass() {\n      @Override public void process(Node externs, Node root) {\n        for (CompilerPass pass : passes) {\n          pass.process(externs, root);\n        }\n      }\n    };\n  }",
    "comment": "Create a compiler pass that runs the given passes in serial. */",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "DefaultPassConfig.runInSerial",
    "class_name": "com.google.javascript.jscomp.DefaultPassConfig",
    "signature": "com.google.javascript.jscomp.DefaultPassConfig.runInSerial(CompilerPass[])",
    "snippet": "  private static CompilerPass runInSerial(final CompilerPass ... passes) {\n    return runInSerial(Lists.newArrayList(passes));\n  }",
    "comment": "Create a compiler pass that runs the given passes in serial. */",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "DefaultPassConfig.runVariableRenaming",
    "class_name": "com.google.javascript.jscomp.DefaultPassConfig",
    "signature": "com.google.javascript.jscomp.DefaultPassConfig.runVariableRenaming(AbstractCompiler,VariableMap,Node,Node)",
    "snippet": "  private VariableMap runVariableRenaming(\n      AbstractCompiler compiler, VariableMap prevVariableMap,\n      Node externs, Node root) {\n    char[] reservedChars =\n        options.anonymousFunctionNaming.getReservedCharacters();\n    boolean preserveAnonymousFunctionNames =\n        options.anonymousFunctionNaming != AnonymousFunctionNamingPolicy.OFF;\n    RenameVars rn = new RenameVars(\n        compiler,\n        options.renamePrefix,\n        options.variableRenaming == VariableRenamingPolicy.LOCAL,\n        preserveAnonymousFunctionNames,\n        options.generatePseudoNames,\n        options.shadowVariables,\n        prevVariableMap,\n        reservedChars,\n        exportedNames);\n    rn.process(externs, root);\n    return rn.getVariableMap();\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "GlobalTypeResolver.process",
    "class_name": "com.google.javascript.jscomp.DefaultPassConfig$GlobalTypeResolver",
    "signature": "com.google.javascript.jscomp.DefaultPassConfig$GlobalTypeResolver.process(Node,Node)",
    "snippet": "    @Override\n    public void process(Node externs, Node root) {\n      if (topScope == null) {\n        regenerateGlobalTypedScope(compiler, root.getParent());\n      } else {\n        compiler.getTypeRegistry().resolveTypesInScope(topScope);\n      }\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "Denormalize.Denormalize",
    "class_name": "com.google.javascript.jscomp.Denormalize",
    "signature": "com.google.javascript.jscomp.Denormalize.Denormalize(AbstractCompiler)",
    "snippet": "  Denormalize(AbstractCompiler compiler) {\n    this.compiler = compiler;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "Denormalize.maybeCollapseIntoForStatements",
    "class_name": "com.google.javascript.jscomp.Denormalize",
    "signature": "com.google.javascript.jscomp.Denormalize.maybeCollapseIntoForStatements(Node,Node)",
    "snippet": "  private void maybeCollapseIntoForStatements(Node n, Node parent) {\n    // Only SCRIPT, BLOCK, and LABELs can have FORs that can be collapsed into.\n    // LABELs are not supported here.\n    if (parent == null || !NodeUtil.isStatementBlock(parent)) {\n      return;\n    }\n\n    // Is the current node something that can be in a for loop initializer?\n    if (!NodeUtil.isExpressionNode(n) && !NodeUtil.isVar(n)) {\n      return;\n    }\n\n    // Is the next statement a valid FOR?\n    Node nextSibling = n.getNext();\n    if (nextSibling == null) {\n      return;\n    } else if (NodeUtil.isForIn(nextSibling)) {\n      Node forNode = nextSibling;\n      Node forVar = forNode.getFirstChild();\n      if (NodeUtil.isName(forVar)\n          && NodeUtil.isVar(n) && n.hasOneChild()) {\n        Node name = n.getFirstChild();\n        if (!name.hasChildren()\n            && forVar.getString().equals(name.getString())) {\n          // Ok, the names match, and the var declaration does not have an\n          // initializer. Move it into the loop.\n          parent.removeChild(n);\n          forNode.replaceChild(forVar, n);\n          compiler.reportCodeChange();\n        }\n      }\n    } else if (nextSibling.getType() == Token.FOR\n        && nextSibling.getFirstChild().getType() == Token.EMPTY) {\n\n      // Does the current node contain an in operator?  If so, embedding\n      // the expression in a for loop can cause some Javascript parsers (such\n      // as the Playstation 3's browser based on Access's NetFront\n      // browser) to fail to parse the code.\n      // See bug 1778863 for details.\n      if (NodeUtil.containsType(n, Token.IN)) {\n        return;\n      }\n\n      // Move the current node into the FOR loop initializer.\n      Node forNode = nextSibling;\n      Node oldInitializer = forNode.getFirstChild();\n      parent.removeChild(n);\n\n      Node newInitializer;\n      if (NodeUtil.isVar(n)) {\n        newInitializer = n;\n      } else {\n        // Extract the expression from EXPR_RESULT node.\n        Preconditions.checkState(n.hasOneChild());\n        newInitializer = n.getFirstChild();\n        n.removeChild(newInitializer);\n      }\n\n      forNode.replaceChild(oldInitializer, newInitializer);\n\n      compiler.reportCodeChange();\n    }\n  }",
    "comment": " Collapse VARs and EXPR_RESULT node into FOR loop initializers where possible. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "Denormalize.process",
    "class_name": "com.google.javascript.jscomp.Denormalize",
    "signature": "com.google.javascript.jscomp.Denormalize.process(Node,Node)",
    "snippet": "  @Override\n  public void process(Node externs, Node root) {\n    NodeTraversal.traverse(compiler, root, this);\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "Denormalize.shouldTraverse",
    "class_name": "com.google.javascript.jscomp.Denormalize",
    "signature": "com.google.javascript.jscomp.Denormalize.shouldTraverse(NodeTraversal,Node,Node)",
    "snippet": "  @Override\n  public boolean shouldTraverse(NodeTraversal t, Node n, Node parent) {\n    return true;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "Denormalize.visit",
    "class_name": "com.google.javascript.jscomp.Denormalize",
    "signature": "com.google.javascript.jscomp.Denormalize.visit(NodeTraversal,Node,Node)",
    "snippet": "  @Override\n  public void visit(NodeTraversal t, Node n, Node parent) {\n    maybeCollapseIntoForStatements(n, parent);\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "DiagnosticGroup.DiagnosticGroup",
    "class_name": "com.google.javascript.jscomp.DiagnosticGroup",
    "signature": "com.google.javascript.jscomp.DiagnosticGroup.DiagnosticGroup(DiagnosticType[])",
    "snippet": "  public DiagnosticGroup(DiagnosticType ...types) {\n    this(null, types);\n  }",
    "comment": " Create a group that matches all errors of the given types. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "DiagnosticGroup.DiagnosticGroup",
    "class_name": "com.google.javascript.jscomp.DiagnosticGroup",
    "signature": "com.google.javascript.jscomp.DiagnosticGroup.DiagnosticGroup(String,DiagnosticGroup[])",
    "snippet": "  public DiagnosticGroup(String name, DiagnosticGroup ...groups) {\n    Set<DiagnosticType> set = Sets.newHashSet();\n\n    for (DiagnosticGroup group : groups) {\n      set.addAll(group.types);\n    }\n\n    this.name = name;\n    this.types = ImmutableSet.copyOf(set);\n  }",
    "comment": " Create a composite group. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "DiagnosticGroup.DiagnosticGroup",
    "class_name": "com.google.javascript.jscomp.DiagnosticGroup",
    "signature": "com.google.javascript.jscomp.DiagnosticGroup.DiagnosticGroup(String,DiagnosticType[])",
    "snippet": "  DiagnosticGroup(String name, DiagnosticType ...types) {\n    this.name = name;\n    this.types = ImmutableSet.copyOf(Arrays.asList(types));\n  }",
    "comment": " Create a group that matches all errors of the given types. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "DiagnosticGroup.forType",
    "class_name": "com.google.javascript.jscomp.DiagnosticGroup",
    "signature": "com.google.javascript.jscomp.DiagnosticGroup.forType(DiagnosticType)",
    "snippet": "  static DiagnosticGroup forType(DiagnosticType type) {\n    if (!singletons.containsKey(type)) {\n      singletons.put(type, new DiagnosticGroup(type));\n    }\n    return singletons.get(type);\n  }",
    "comment": "Create a diagnostic group that matches only the given type. */",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "DiagnosticGroup.getTypes",
    "class_name": "com.google.javascript.jscomp.DiagnosticGroup",
    "signature": "com.google.javascript.jscomp.DiagnosticGroup.getTypes()",
    "snippet": "  Collection<DiagnosticType> getTypes() {\n    return types;\n  }",
    "comment": " Returns an iterator over all the types in this group. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "DiagnosticGroup.isSubGroup",
    "class_name": "com.google.javascript.jscomp.DiagnosticGroup",
    "signature": "com.google.javascript.jscomp.DiagnosticGroup.isSubGroup(DiagnosticGroup)",
    "snippet": "  boolean isSubGroup(DiagnosticGroup group) {\n    for (DiagnosticType type : group.types) {\n      if (!matches(type)) {\n        return false;\n      }\n    }\n    return true;\n  }",
    "comment": " Returns whether all of the types in the given group are in this group. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "DiagnosticGroup.matches",
    "class_name": "com.google.javascript.jscomp.DiagnosticGroup",
    "signature": "com.google.javascript.jscomp.DiagnosticGroup.matches(DiagnosticType)",
    "snippet": "  public boolean matches(DiagnosticType type) {\n    return types.contains(type);\n  }",
    "comment": " Returns whether the given type matches a type in this group. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "DiagnosticGroup.matches",
    "class_name": "com.google.javascript.jscomp.DiagnosticGroup",
    "signature": "com.google.javascript.jscomp.DiagnosticGroup.matches(JSError)",
    "snippet": "  public boolean matches(JSError error) {\n    return matches(error.getType());\n  }",
    "comment": " Returns whether the given error's type matches a type in this group. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "DiagnosticGroupWarningsGuard.DiagnosticGroupWarningsGuard",
    "class_name": "com.google.javascript.jscomp.DiagnosticGroupWarningsGuard",
    "signature": "com.google.javascript.jscomp.DiagnosticGroupWarningsGuard.DiagnosticGroupWarningsGuard(DiagnosticGroup,CheckLevel)",
    "snippet": "  public DiagnosticGroupWarningsGuard(\n      DiagnosticGroup group, CheckLevel level) {\n    this.group = group;\n    this.level = level;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "DiagnosticGroupWarningsGuard.disables",
    "class_name": "com.google.javascript.jscomp.DiagnosticGroupWarningsGuard",
    "signature": "com.google.javascript.jscomp.DiagnosticGroupWarningsGuard.disables(DiagnosticGroup)",
    "snippet": "  @Override\n  public boolean disables(DiagnosticGroup otherGroup) {\n    return !level.isOn() && group.isSubGroup(otherGroup);\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "DiagnosticGroupWarningsGuard.enables",
    "class_name": "com.google.javascript.jscomp.DiagnosticGroupWarningsGuard",
    "signature": "com.google.javascript.jscomp.DiagnosticGroupWarningsGuard.enables(DiagnosticGroup)",
    "snippet": "  @Override\n  public boolean enables(DiagnosticGroup otherGroup) {\n    if (level.isOn()) {\n      for (DiagnosticType type : otherGroup.getTypes()) {\n        if (group.matches(type)) {\n          return true;\n        }\n      }\n    }\n\n    return false;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "DiagnosticGroupWarningsGuard.level",
    "class_name": "com.google.javascript.jscomp.DiagnosticGroupWarningsGuard",
    "signature": "com.google.javascript.jscomp.DiagnosticGroupWarningsGuard.level(JSError)",
    "snippet": "  @Override\n  public CheckLevel level(JSError error) {\n    return group.matches(error) ? level : null;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "DiagnosticGroups.DiagnosticGroups",
    "class_name": "com.google.javascript.jscomp.DiagnosticGroups",
    "signature": "com.google.javascript.jscomp.DiagnosticGroups.DiagnosticGroups()",
    "snippet": "  public DiagnosticGroups() {}",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "DiagnosticGroups.forName",
    "class_name": "com.google.javascript.jscomp.DiagnosticGroups",
    "signature": "com.google.javascript.jscomp.DiagnosticGroups.forName(String)",
    "snippet": "  protected DiagnosticGroup forName(String name) {\n    return groupsByName.get(name);\n  }",
    "comment": "Find the diagnostic group registered under the given name. */",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "DiagnosticGroups.getRegisteredGroups",
    "class_name": "com.google.javascript.jscomp.DiagnosticGroups",
    "signature": "com.google.javascript.jscomp.DiagnosticGroups.getRegisteredGroups()",
    "snippet": "  protected Map<String, DiagnosticGroup> getRegisteredGroups() {\n    return ImmutableMap.copyOf(groupsByName);\n  }",
    "comment": "Get the registered diagnostic groups, indexed by name. */",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "DiagnosticGroups.registerGroup",
    "class_name": "com.google.javascript.jscomp.DiagnosticGroups",
    "signature": "com.google.javascript.jscomp.DiagnosticGroups.registerGroup(String,DiagnosticGroup[])",
    "snippet": "  static DiagnosticGroup registerGroup(String name,\n      DiagnosticGroup ... groups) {\n    DiagnosticGroup group = new DiagnosticGroup(name, groups);\n    groupsByName.put(name, group);\n    return group;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "DiagnosticGroups.registerGroup",
    "class_name": "com.google.javascript.jscomp.DiagnosticGroups",
    "signature": "com.google.javascript.jscomp.DiagnosticGroups.registerGroup(String,DiagnosticType[])",
    "snippet": "  static DiagnosticGroup registerGroup(String name,\n      DiagnosticType ... types) {\n    DiagnosticGroup group = new DiagnosticGroup(name, types);\n    groupsByName.put(name, group);\n    return group;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "DiagnosticGroups.setWarningLevel",
    "class_name": "com.google.javascript.jscomp.DiagnosticGroups",
    "signature": "com.google.javascript.jscomp.DiagnosticGroups.setWarningLevel(CompilerOptions,String,CheckLevel)",
    "snippet": "  void setWarningLevel(CompilerOptions options,\n      String name, CheckLevel level) {\n    DiagnosticGroup group = forName(name);\n    Preconditions.checkNotNull(group, \"No warning class for name: \" + name);\n    options.setWarningLevel(group, level);\n  }",
    "comment": " Adds warning levels by name. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "DiagnosticType.disabled",
    "class_name": "com.google.javascript.jscomp.DiagnosticType",
    "signature": "com.google.javascript.jscomp.DiagnosticType.disabled(String,String)",
    "snippet": "  public static DiagnosticType disabled(String name,\n      String descriptionFormat) {\n    return make(name, CheckLevel.OFF, descriptionFormat);\n  }",
    "comment": " Create a DiagnosticType at level CheckLevel.OFF  @param name An identifier @param descriptionFormat A format string @return A new DiagnosticType ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "DiagnosticType.equals",
    "class_name": "com.google.javascript.jscomp.DiagnosticType",
    "signature": "com.google.javascript.jscomp.DiagnosticType.equals(Object)",
    "snippet": "  @Override\n  public boolean equals(Object type) {\n    return type instanceof DiagnosticType &&\n        ((DiagnosticType) type).key.equals(key);\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "DiagnosticType.error",
    "class_name": "com.google.javascript.jscomp.DiagnosticType",
    "signature": "com.google.javascript.jscomp.DiagnosticType.error(String,String)",
    "snippet": "  public static DiagnosticType error(String name, String descriptionFormat) {\n    return make(name, CheckLevel.ERROR, descriptionFormat);\n  }",
    "comment": " Create a DiagnosticType at level CheckLevel.ERROR  @param name An identifier @param descriptionFormat A format string @return A new DiagnosticType ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "DiagnosticType.hashCode",
    "class_name": "com.google.javascript.jscomp.DiagnosticType",
    "signature": "com.google.javascript.jscomp.DiagnosticType.hashCode()",
    "snippet": "  @Override\n  public int hashCode() {\n    return key.hashCode();\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "DiagnosticType.make",
    "class_name": "com.google.javascript.jscomp.DiagnosticType",
    "signature": "com.google.javascript.jscomp.DiagnosticType.make(String,CheckLevel,String)",
    "snippet": "  public static DiagnosticType make(String name, CheckLevel level,\n                                    String descriptionFormat) {\n    return\n        new DiagnosticType(name, level, new MessageFormat(descriptionFormat));\n  }",
    "comment": " Create a DiagnosticType at a given CheckLevel.  @param name An identifier @param level Either CheckLevel.ERROR or CheckLevel.WARNING @param descriptionFormat A format string @return A new DiagnosticType ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "DiagnosticType.warning",
    "class_name": "com.google.javascript.jscomp.DiagnosticType",
    "signature": "com.google.javascript.jscomp.DiagnosticType.warning(String,String)",
    "snippet": "  public static DiagnosticType warning(String name, String descriptionFormat) {\n    return make(name, CheckLevel.WARNING, descriptionFormat);\n  }",
    "comment": " Create a DiagnosticType at level CheckLevel.WARNING  @param name An identifier @param descriptionFormat A format string @return A new DiagnosticType ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "ExploitAssigns.collapseAssign",
    "class_name": "com.google.javascript.jscomp.ExploitAssigns",
    "signature": "com.google.javascript.jscomp.ExploitAssigns.collapseAssign(Node,Node,Node)",
    "snippet": "  private void collapseAssign(Node assign, Node expr,\n      Node exprParent) {\n    Node leftValue = assign.getFirstChild();\n    Node rightValue = leftValue.getNext();\n    if (isCollapsibleValue(leftValue, true) &&\n        collapseAssignEqualTo(expr, exprParent, leftValue)) {\n      reportCodeChange();\n    } else if (isCollapsibleValue(rightValue, false) &&\n        collapseAssignEqualTo(expr, exprParent, rightValue)) {\n      reportCodeChange();\n    } else if (rightValue.getType() == Token.ASSIGN) {\n      // Recursively deal with nested assigns.\n      collapseAssign(rightValue, expr, exprParent);\n    }\n  }",
    "comment": " Try to collapse the given assign into subsequent expressions. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "ExploitAssigns.collapseAssignEqualTo",
    "class_name": "com.google.javascript.jscomp.ExploitAssigns",
    "signature": "com.google.javascript.jscomp.ExploitAssigns.collapseAssignEqualTo(Node,Node,Node)",
    "snippet": "  private boolean collapseAssignEqualTo(Node expr, Node exprParent,\n      Node value) {\n    Node assign = expr.getFirstChild();\n    Node parent = exprParent;\n    Node next = expr.getNext();\n    while (next != null) {\n      switch (next.getType()) {\n        case Token.AND:\n        case Token.OR:\n        case Token.HOOK:\n        case Token.IF:\n        case Token.RETURN:\n        case Token.EXPR_RESULT:\n          // Dive down the left side\n          parent = next;\n          next = next.getFirstChild();\n          break;\n\n        case Token.VAR:\n          if (next.getFirstChild().hasChildren()) {\n            parent = next.getFirstChild();\n            next = parent.getFirstChild();\n            break;\n          }\n          return false;\n\n        case Token.GETPROP:\n        case Token.NAME:\n          if (next.isQualifiedName()) {\n            String nextName = next.getQualifiedName();\n            if (value.isQualifiedName() &&\n                nextName.equals(value.getQualifiedName())) {\n              // If the previous expression evaluates to value of a\n              // qualified name, and that qualified name is used again\n              // shortly, then we can exploit the assign here.\n\n              // Verify the assignment doesn't change its own value.\n              if (!isSafeReplacement(next, assign)) {\n                return false;\n              }\n\n              exprParent.removeChild(expr);\n              expr.removeChild(assign);\n              parent.replaceChild(next, assign);\n              return true;\n            }\n          }\n          return false;\n\n        case Token.ASSIGN:\n          // Assigns are really tricky. In lots of cases, we want to inline\n          // into the right side of the assign. But the left side of the\n          // assign is evaluated first, and it may have convoluted logic:\n          //   a = null;\n          //   (a = b).c = null;\n          // We don't want to exploit the first assign. Similarly:\n          //   a.b = null;\n          //   a.b.c = null;\n          // We don't want to exploit the first assign either.\n          //\n          // To protect against this, we simply only inline when the left side\n          // is guaranteed to evaluate to the same L-value no matter what.\n          Node leftSide = next.getFirstChild();\n          if (leftSide.getType() == Token.NAME ||\n              leftSide.getType() == Token.GETPROP &&\n              leftSide.getFirstChild().getType() == Token.THIS) {\n            // Dive down the right side of the assign.\n            parent = next;\n            next = leftSide.getNext();\n            break;\n          } else {\n            return false;\n          }\n\n        default:\n          if (NodeUtil.isImmutableValue(next)\n              && next.isEquivalentTo(value)) {\n            // If the r-value of the expr assign is an immutable value,\n            // and the value is used again shortly, then we can exploit\n            // the assign here.\n            exprParent.removeChild(expr);\n            expr.removeChild(assign);\n            parent.replaceChild(next, assign);\n            return true;\n          }\n          // Return without inlining a thing\n          return false;\n      }\n    }\n\n    return false;\n  }",
    "comment": " Collapse the given assign expression into the expression directly following it, if possible.  @param expr The expression that may be moved. @param exprParent The parent of {@code expr}. @param value The value of this expression, expressed as a node. Each expression may have multiple values, so this function may be called multiple times for the same expression. For example, <code> a = true; </code> is equal to the name \"a\" and the boolean \"true\". @return Whether the expression was collapsed succesfully. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "ExploitAssigns.isCollapsibleValue",
    "class_name": "com.google.javascript.jscomp.ExploitAssigns",
    "signature": "com.google.javascript.jscomp.ExploitAssigns.isCollapsibleValue(Node,boolean)",
    "snippet": "  private boolean isCollapsibleValue(Node value, boolean isLValue) {\n    switch (value.getType()) {\n      case Token.GETPROP:\n        // Do not collapse GETPROPs on arbitrary objects, because\n        // they may be implemented  setter functions, and oftentimes\n        // setter functions fail on native objects. This is ok for \"THIS\"\n        // objects, because we assume that they are non-native.\n        return !isLValue || value.getFirstChild().getType() == Token.THIS;\n\n      case Token.NAME:\n        return true;\n\n      default:\n        return NodeUtil.isImmutableValue(value);\n    }\n  }",
    "comment": " Determines whether we know enough about the given value to be able to collapse it into subsequent expressions.  For example, we can collapse booleans and variable names: <code> x = 3; y = x; // y = x = 3; a = true; b = true; // b = a = true; <code> But we won't try to collapse complex expressions.  @param value The value node. @param isLValue Whether it's on the left-hand side of an expr. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "ExploitAssigns.optimizeSubtree",
    "class_name": "com.google.javascript.jscomp.ExploitAssigns",
    "signature": "com.google.javascript.jscomp.ExploitAssigns.optimizeSubtree(Node)",
    "snippet": "  @Override\n  Node optimizeSubtree(Node subtree) {\n    for (Node child = subtree.getFirstChild(); child != null;) {\n      Node next = child.getNext();\n      if (NodeUtil.isExprAssign(child)) {\n        collapseAssign(child.getFirstChild(), child, subtree);\n      }\n      child = next;\n    }\n    return subtree;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "FlowSensitiveInlineVariables.FlowSensitiveInlineVariables",
    "class_name": "com.google.javascript.jscomp.FlowSensitiveInlineVariables",
    "signature": "com.google.javascript.jscomp.FlowSensitiveInlineVariables.FlowSensitiveInlineVariables(AbstractCompiler)",
    "snippet": "  public FlowSensitiveInlineVariables(AbstractCompiler compiler) {\n    this.compiler = compiler;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "FlowSensitiveInlineVariables.enterScope",
    "class_name": "com.google.javascript.jscomp.FlowSensitiveInlineVariables",
    "signature": "com.google.javascript.jscomp.FlowSensitiveInlineVariables.enterScope(NodeTraversal)",
    "snippet": "  @Override\n  public void enterScope(NodeTraversal t) {\n\n    if (t.inGlobalScope()) {\n      return; // Don't even brother. All global variables are likely escaped.\n    }\n\n    // Compute the forward reaching definition.\n    ControlFlowAnalysis cfa = new ControlFlowAnalysis(compiler, false, true);\n    // Process the body of the function.\n    Preconditions.checkState(NodeUtil.isFunction(t.getScopeRoot()));\n    cfa.process(null, t.getScopeRoot().getLastChild());\n    cfg = cfa.getCfg();\n    reachingDef = new MustBeReachingVariableDef(cfg, t.getScope(), compiler);\n    reachingDef.analyze();\n    candidates = Lists.newLinkedList();\n\n    // Using the forward reaching definition search to find all the inline\n    // candiates\n    new NodeTraversal(compiler, new GatherCandiates()).traverse(\n        t.getScopeRoot().getLastChild());\n\n    // Compute the backward reaching use. The CFG can be reused.\n    reachingUses = new MaybeReachingVariableUse(cfg, t.getScope(), compiler);\n    reachingUses.analyze();\n    for (Candidate c : candidates) {\n      if (c.canInline()) {\n        c.inlineVariable();\n      }\n    }\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "FlowSensitiveInlineVariables.exitScope",
    "class_name": "com.google.javascript.jscomp.FlowSensitiveInlineVariables",
    "signature": "com.google.javascript.jscomp.FlowSensitiveInlineVariables.exitScope(NodeTraversal)",
    "snippet": "  @Override\n  public void exitScope(NodeTraversal t) {}",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "FlowSensitiveInlineVariables.process",
    "class_name": "com.google.javascript.jscomp.FlowSensitiveInlineVariables",
    "signature": "com.google.javascript.jscomp.FlowSensitiveInlineVariables.process(Node,Node)",
    "snippet": "  @Override\n  public void process(Node externs, Node root) {\n    (new NodeTraversal(compiler, this)).traverse(root);\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "FlowSensitiveInlineVariables.visit",
    "class_name": "com.google.javascript.jscomp.FlowSensitiveInlineVariables",
    "signature": "com.google.javascript.jscomp.FlowSensitiveInlineVariables.visit(NodeTraversal,Node,Node)",
    "snippet": "  @Override\n  public void visit(NodeTraversal t, Node n, Node parent) {\n    // TODO(user): While the helpers do a subtree traversal on the AST, the\n    // compiler pass itself only traverse the AST to look for function\n    // declarations to perform dataflow analysis on. We could combine\n    // the traversal in DataFlowAnalysis's computeEscaped later to save some\n    // time.\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "GatherCandiates.visit",
    "class_name": "com.google.javascript.jscomp.FlowSensitiveInlineVariables$GatherCandiates",
    "signature": "com.google.javascript.jscomp.FlowSensitiveInlineVariables$GatherCandiates.visit(NodeTraversal,Node,Node)",
    "snippet": "    @Override\n    public void visit(NodeTraversal t, Node n, Node parent) {\n      DiGraphNode<Node, Branch> graphNode = cfg.getDirectedGraphNode(n);\n      if (graphNode == null) {\n        // Not a CFG node.\n        return;\n      }\n      FlowState<MustDef> state = graphNode.getAnnotation();\n      final MustDef defs = state.getIn();\n      final Node cfgNode = n;\n      AbstractCfgNodeTraversalCallback gatherCb =\n          new AbstractCfgNodeTraversalCallback() {\n\n        @Override\n        public void visit(NodeTraversal t, Node n, Node parent) {\n          if (NodeUtil.isName(n)) {\n\n            // Make sure that the name node is purely a read.\n            if ((NodeUtil.isAssignmentOp(parent) && parent.getFirstChild() == n)\n                || NodeUtil.isVar(parent) || parent.getType() == Token.INC ||\n                parent.getType() == Token.DEC || parent.getType() == Token.LP ||\n                parent.getType() == Token.CATCH) {\n              return;\n            }\n\n            String name = n.getString();\n            if (compiler.getCodingConvention().isExported(name)) {\n              return;\n            }\n\n            Node defNode = reachingDef.getDef(name, cfgNode);\n            if (defNode != null &&\n                !reachingDef.dependsOnOuterScopeVars(name, cfgNode)) {\n              candidates.add(new Candidate(name, defNode, n, cfgNode));\n            }\n          }\n        }\n      };\n\n      NodeTraversal.traverse(compiler, cfgNode, gatherCb);\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "FunctionInjector.FunctionInjector",
    "class_name": "com.google.javascript.jscomp.FunctionInjector",
    "signature": "com.google.javascript.jscomp.FunctionInjector.FunctionInjector(AbstractCompiler,Supplier,boolean,boolean)",
    "snippet": "  public FunctionInjector(\n      AbstractCompiler compiler,\n      Supplier<String> safeNameIdSupplier,\n      boolean allowDecomposition,\n      boolean assumeStrictThis) {\n    Preconditions.checkNotNull(compiler);\n    Preconditions.checkNotNull(safeNameIdSupplier);\n    this.compiler = compiler;\n    this.safeNameIdSupplier = safeNameIdSupplier;\n    this.allowDecomposition = allowDecomposition;\n    this.assumeStrictThis = assumeStrictThis;\n  }",
    "comment": " @param allowDecomposition Whether an effort should be made to break down expressions into simpler expressions to allow functions to be injected where they would otherwise be disallowed. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "FunctionTypeBuilder.FunctionTypeBuilder",
    "class_name": "com.google.javascript.jscomp.FunctionTypeBuilder",
    "signature": "com.google.javascript.jscomp.FunctionTypeBuilder.FunctionTypeBuilder(String,AbstractCompiler,Node,String,Scope)",
    "snippet": "  FunctionTypeBuilder(String fnName, AbstractCompiler compiler,\n      Node errorRoot, String sourceName, Scope scope) {\n    Preconditions.checkNotNull(errorRoot);\n\n    this.fnName = fnName == null ? \"\" : fnName;\n    this.codingConvention = compiler.getCodingConvention();\n    this.typeRegistry = compiler.getTypeRegistry();\n    this.errorRoot = errorRoot;\n    this.sourceName = sourceName;\n    this.compiler = compiler;\n    this.scope = scope;\n  }",
    "comment": " @param fnName The function name. @param compiler The compiler. @param errorRoot The node to associate with any warning generated by this builder. @param sourceName A source name for associating any warnings that we have to emit. @param scope The syntactic scope. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "FunctionTypeBuilder.addParameter",
    "class_name": "com.google.javascript.jscomp.FunctionTypeBuilder",
    "signature": "com.google.javascript.jscomp.FunctionTypeBuilder.addParameter(FunctionParamBuilder,JSType,boolean,boolean,boolean)",
    "snippet": "  private boolean addParameter(FunctionParamBuilder builder,\n      JSType paramType, boolean warnedAboutArgList,\n      boolean isOptional, boolean isVarArgs) {\n    boolean emittedWarning = false;\n    if (isOptional) {\n      // Remembering that an optional parameter has been encountered\n      // so that if a non optional param is encountered later, an\n      // error can be reported.\n      if (!builder.addOptionalParams(paramType) && !warnedAboutArgList) {\n        reportWarning(VAR_ARGS_MUST_BE_LAST);\n        emittedWarning = true;\n      }\n    } else if (isVarArgs) {\n      if (!builder.addVarArgs(paramType) && !warnedAboutArgList) {\n        reportWarning(VAR_ARGS_MUST_BE_LAST);\n        emittedWarning = true;\n      }\n    } else {\n      if (!builder.addRequiredParams(paramType) && !warnedAboutArgList) {\n        // An optional parameter was seen and this argument is not an optional\n        // or var arg so it is an error.\n        if (builder.hasVarArgs()) {\n          reportWarning(VAR_ARGS_MUST_BE_LAST);\n        } else {\n          reportWarning(OPTIONAL_ARG_AT_END);\n        }\n        emittedWarning = true;\n      }\n    }\n    return emittedWarning;\n  }",
    "comment": " Add a parameter to the param list. @param builder A builder. @param paramType The parameter type. @param warnedAboutArgList Whether we've already warned about arg ordering issues (like if optional args appeared before required ones). @param isOptional Is this an optional parameter? @param isVarArgs Is this a var args parameter? @return Whether a warning was emitted. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "FunctionTypeBuilder.buildAndRegister",
    "class_name": "com.google.javascript.jscomp.FunctionTypeBuilder",
    "signature": "com.google.javascript.jscomp.FunctionTypeBuilder.buildAndRegister()",
    "snippet": "  FunctionType buildAndRegister() {\n    if (returnType == null) {\n      returnType = typeRegistry.getNativeType(UNKNOWN_TYPE);\n    }\n\n    if (parametersNode == null) {\n      throw new IllegalStateException(\n          \"All Function types must have params and a return type\");\n    }\n\n    FunctionType fnType;\n    if (isConstructor) {\n      fnType = getOrCreateConstructor();\n    } else if (isInterface) {\n      fnType = typeRegistry.createInterfaceType(fnName, sourceNode);\n      if (getScopeDeclaredIn().isGlobal() && !fnName.isEmpty()) {\n        typeRegistry.declareType(fnName, fnType.getInstanceType());\n      }\n      maybeSetBaseType(fnType);\n    } else {\n      fnType = new FunctionBuilder(typeRegistry)\n          .withName(fnName)\n          .withSourceNode(sourceNode)\n          .withParamsNode(parametersNode)\n          .withReturnType(returnType, returnTypeInferred)\n          .withTypeOfThis(thisType)\n          .withTemplateName(templateTypeName)\n          .build();\n      maybeSetBaseType(fnType);\n    }\n\n    if (implementedInterfaces != null) {\n      fnType.setImplementedInterfaces(implementedInterfaces);\n    }\n\n    if (extendedInterfaces != null) {\n      fnType.setExtendedInterfaces(extendedInterfaces);\n    }\n\n    typeRegistry.clearTemplateTypeName();\n\n    return fnType;\n  }",
    "comment": " Builds the function type, and puts it in the registry. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "FunctionTypeBuilder.getOrCreateConstructor",
    "class_name": "com.google.javascript.jscomp.FunctionTypeBuilder",
    "signature": "com.google.javascript.jscomp.FunctionTypeBuilder.getOrCreateConstructor()",
    "snippet": "  private FunctionType getOrCreateConstructor() {\n    FunctionType fnType = typeRegistry.createConstructorType(\n        fnName, sourceNode, parametersNode, returnType);\n    JSType existingType = typeRegistry.getType(fnName);\n\n    if (existingType != null) {\n      boolean isInstanceObject = existingType instanceof InstanceObjectType;\n      if (isInstanceObject || fnName.equals(\"Function\")) {\n        FunctionType existingFn =\n            isInstanceObject ?\n            ((InstanceObjectType) existingType).getConstructor() :\n            typeRegistry.getNativeFunctionType(FUNCTION_FUNCTION_TYPE);\n\n        if (existingFn.getSource() == null) {\n          existingFn.setSource(sourceNode);\n        }\n\n        if (!existingFn.hasEqualCallType(fnType)) {\n          reportWarning(TYPE_REDEFINITION, fnName,\n              fnType.toString(), existingFn.toString());\n        }\n\n        return existingFn;\n      } else {\n        // We fall through and return the created type, even though it will fail\n        // to register. We have no choice as we have to return a function. We\n        // issue an error elsewhere though, so the user should fix it.\n      }\n    }\n\n    maybeSetBaseType(fnType);\n\n    if (getScopeDeclaredIn().isGlobal() && !fnName.isEmpty()) {\n      typeRegistry.declareType(fnName, fnType.getInstanceType());\n    }\n    return fnType;\n  }",
    "comment": " Returns a constructor function either by returning it from the registry if it exists or creating and registering a new type. If there is already a type, then warn if the existing type is different than the one we are creating, though still return the existing function if possible.  The primary purpose of this is that registering a constructor will fail for all built-in types that are initialized in {@link JSTypeRegistry}.  We a) want to make sure that the type information specified in the externs file matches what is in the registry and b) annotate the externs with the {@link JSType} from the registry so that there are not two separate JSType objects for one type. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "FunctionTypeBuilder.getScopeDeclaredIn",
    "class_name": "com.google.javascript.jscomp.FunctionTypeBuilder",
    "signature": "com.google.javascript.jscomp.FunctionTypeBuilder.getScopeDeclaredIn()",
    "snippet": "  private Scope getScopeDeclaredIn() {\n    int dotIndex = fnName.indexOf(\".\");\n    if (dotIndex != -1) {\n      String rootVarName = fnName.substring(0, dotIndex);\n      Var rootVar = scope.getVar(rootVarName);\n      if (rootVar != null) {\n        return rootVar.getScope();\n      }\n    }\n    return scope;\n  }",
    "comment": " The scope that we should declare this function in, if it needs to be declared in a scope. Notice that TypedScopeCreator takes care of most scope-declaring. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "FunctionTypeBuilder.inferFromOverriddenFunction",
    "class_name": "com.google.javascript.jscomp.FunctionTypeBuilder",
    "signature": "com.google.javascript.jscomp.FunctionTypeBuilder.inferFromOverriddenFunction(FunctionType,Node)",
    "snippet": "  FunctionTypeBuilder inferFromOverriddenFunction(\n      @Nullable FunctionType oldType, @Nullable Node paramsParent) {\n    if (oldType == null) {\n      return this;\n    }\n\n    returnType = oldType.getReturnType();\n    returnTypeInferred = oldType.isReturnTypeInferred();\n    if (paramsParent == null) {\n      // Not a function literal.\n      parametersNode = oldType.getParametersNode();\n      if (parametersNode == null) {\n        parametersNode = new FunctionParamBuilder(typeRegistry).build();\n      }\n    } else {\n      // We're overriding with a function literal. Apply type information\n      // to each parameter of the literal.\n      FunctionParamBuilder paramBuilder =\n          new FunctionParamBuilder(typeRegistry);\n      Iterator<Node> oldParams = oldType.getParameters().iterator();\n      boolean warnedAboutArgList = false;\n      boolean oldParamsListHitOptArgs = false;\n      for (Node currentParam = paramsParent.getFirstChild();\n           currentParam != null; currentParam = currentParam.getNext()) {\n        if (oldParams.hasNext()) {\n          Node oldParam = oldParams.next();\n          Node newParam = paramBuilder.newParameterFromNode(oldParam);\n\n          oldParamsListHitOptArgs = oldParamsListHitOptArgs ||\n              oldParam.isVarArgs() ||\n              oldParam.isOptionalArg();\n\n          // The subclass method might right its var_args as individual\n          // arguments.\n          if (currentParam.getNext() != null && newParam.isVarArgs()) {\n            newParam.setVarArgs(false);\n            newParam.setOptionalArg(true);\n          }\n        } else {\n          warnedAboutArgList |= addParameter(\n              paramBuilder,\n              typeRegistry.getNativeType(UNKNOWN_TYPE),\n              warnedAboutArgList,\n              codingConvention.isOptionalParameter(currentParam) ||\n                  oldParamsListHitOptArgs,\n              codingConvention.isVarArgsParameter(currentParam));\n        }\n      }\n      parametersNode = paramBuilder.build();\n    }\n    return this;\n  }",
    "comment": " Infer the parameter and return types of a function from the parameter and return types of the function it is overriding.  @param oldType The function being overridden. Does nothing if this is null. @param paramsParent The LP node of the function that we're assigning to. If null, that just means we're not initializing this to a function literal. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "FunctionTypeBuilder.inferInheritance",
    "class_name": "com.google.javascript.jscomp.FunctionTypeBuilder",
    "signature": "com.google.javascript.jscomp.FunctionTypeBuilder.inferInheritance(JSDocInfo)",
    "snippet": "  FunctionTypeBuilder inferInheritance(@Nullable JSDocInfo info) {\n    if (info != null) {\n      isConstructor = info.isConstructor();\n      isInterface = info.isInterface();\n\n      // base type\n      if (info.hasBaseType()) {\n        if (isConstructor) {\n          JSType maybeBaseType =\n              info.getBaseType().evaluate(scope, typeRegistry);\n          if (maybeBaseType != null &&\n              maybeBaseType.setValidator(new ExtendedTypeValidator())) {\n            baseType = (ObjectType) maybeBaseType;\n          }\n        } else {\n          reportWarning(EXTENDS_WITHOUT_TYPEDEF, fnName);\n        }\n      }\n\n      // implemented interfaces\n      if (isConstructor || isInterface) {\n        implementedInterfaces = Lists.newArrayList();\n        for (JSTypeExpression t : info.getImplementedInterfaces()) {\n          JSType maybeInterType = t.evaluate(scope, typeRegistry);\n          if (maybeInterType != null &&\n              maybeInterType.setValidator(new ImplementedTypeValidator())) {\n            implementedInterfaces.add((ObjectType) maybeInterType);\n          }\n        }\n      } else if (info.getImplementedInterfaceCount() > 0) {\n        reportWarning(IMPLEMENTS_WITHOUT_CONSTRUCTOR, fnName);\n      }\n\n      // extended interfaces (for interface only)\n      if (isInterface) {\n        extendedInterfaces = Lists.newArrayList();\n        for (JSTypeExpression t : info.getExtendedInterfaces()) {\n          JSType maybeInterfaceType = t.evaluate(scope, typeRegistry);\n          if (maybeInterfaceType != null &&\n              maybeInterfaceType.setValidator(new ExtendedTypeValidator())) {\n            extendedInterfaces.add((ObjectType) maybeInterfaceType);\n          }\n        }\n      }\n    }\n\n    return this;\n  }",
    "comment": " Infer the role of the function (whether it's a constructor or interface) and what it inherits from in JSDocInfo. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "FunctionTypeBuilder.inferParameterTypes",
    "class_name": "com.google.javascript.jscomp.FunctionTypeBuilder",
    "signature": "com.google.javascript.jscomp.FunctionTypeBuilder.inferParameterTypes(Node,JSDocInfo)",
    "snippet": "  FunctionTypeBuilder inferParameterTypes(@Nullable Node argsParent,\n      @Nullable JSDocInfo info) {\n    if (argsParent == null) {\n      if (info == null) {\n        return this;\n      } else {\n        return inferParameterTypes(info);\n      }\n    }\n\n    // arguments\n    Node oldParameterType = null;\n    if (parametersNode != null) {\n      oldParameterType = parametersNode.getFirstChild();\n    }\n\n    FunctionParamBuilder builder = new FunctionParamBuilder(typeRegistry);\n    boolean warnedAboutArgList = false;\n    Set<String> allJsDocParams = (info == null) ?\n        Sets.<String>newHashSet() :\n        Sets.newHashSet(info.getParameterNames());\n    boolean foundTemplateType = false;\n    for (Node arg : argsParent.children()) {\n      String argumentName = arg.getString();\n      allJsDocParams.remove(argumentName);\n\n      // type from JSDocInfo\n      JSType parameterType = null;\n      boolean isOptionalParam = isOptionalParameter(arg, info);\n      boolean isVarArgs = isVarArgsParameter(arg, info);\n      if (info != null && info.hasParameterType(argumentName)) {\n        parameterType =\n            info.getParameterType(argumentName).evaluate(scope, typeRegistry);\n      } else if (oldParameterType != null &&\n          oldParameterType.getJSType() != null) {\n        parameterType = oldParameterType.getJSType();\n        isOptionalParam = oldParameterType.isOptionalArg();\n        isVarArgs = oldParameterType.isVarArgs();\n      } else {\n        parameterType = typeRegistry.getNativeType(UNKNOWN_TYPE);\n      }\n\n      if (templateTypeName != null &&\n          parameterType.restrictByNotNullOrUndefined().isTemplateType()) {\n        if (foundTemplateType) {\n          reportError(TEMPLATE_TYPE_DUPLICATED, fnName);\n        }\n        foundTemplateType = true;\n      }\n      warnedAboutArgList |= addParameter(\n          builder, parameterType, warnedAboutArgList,\n          isOptionalParam,\n          isVarArgs);\n\n      if (oldParameterType != null) {\n        oldParameterType = oldParameterType.getNext();\n      }\n    }\n\n    if (templateTypeName != null && !foundTemplateType) {\n      reportError(TEMPLATE_TYPE_EXPECTED, fnName);\n    }\n\n    for (String inexistentName : allJsDocParams) {\n      reportWarning(INEXISTANT_PARAM, inexistentName, fnName);\n    }\n\n    parametersNode = builder.build();\n    return this;\n  }",
    "comment": " Infer the parameter types from the list of argument names and the doc info. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "FunctionTypeBuilder.inferReturnStatementsAsLastResort",
    "class_name": "com.google.javascript.jscomp.FunctionTypeBuilder",
    "signature": "com.google.javascript.jscomp.FunctionTypeBuilder.inferReturnStatementsAsLastResort(Node)",
    "snippet": "  FunctionTypeBuilder inferReturnStatementsAsLastResort(\n      @Nullable Node functionBlock) {\n    if (functionBlock == null || compiler.getInput(sourceName).isExtern()) {\n      return this;\n    }\n    Preconditions.checkArgument(functionBlock.getType() == Token.BLOCK);\n    if (returnType == null) {\n      boolean hasNonEmptyReturns = false;\n      List<Node> worklist = Lists.newArrayList(functionBlock);\n      while (!worklist.isEmpty()) {\n        Node current = worklist.remove(worklist.size() - 1);\n        int cType = current.getType();\n        if (cType == Token.RETURN && current.getFirstChild() != null) {\n          hasNonEmptyReturns = true;\n          break;\n        } else if (NodeUtil.isStatementBlock(current) ||\n            NodeUtil.isControlStructure(current)) {\n          for (Node child = current.getFirstChild();\n               child != null; child = child.getNext()) {\n            worklist.add(child);\n          }\n        }\n      }\n\n      if (!hasNonEmptyReturns) {\n        returnType = typeRegistry.getNativeType(VOID_TYPE);\n        returnTypeInferred = true;\n      }\n    }\n    return this;\n  }",
    "comment": " If we haven't found a return value yet, try to look at the \"return\" statements in the function. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "FunctionTypeBuilder.inferReturnType",
    "class_name": "com.google.javascript.jscomp.FunctionTypeBuilder",
    "signature": "com.google.javascript.jscomp.FunctionTypeBuilder.inferReturnType(JSDocInfo)",
    "snippet": "  FunctionTypeBuilder inferReturnType(@Nullable JSDocInfo info) {\n    if (info != null && info.hasReturnType()) {\n      returnType = info.getReturnType().evaluate(scope, typeRegistry);\n      returnTypeInferred = false;\n    }\n\n    if (templateTypeName != null &&\n        returnType != null &&\n        returnType.restrictByNotNullOrUndefined().isTemplateType()) {\n      reportError(TEMPLATE_TYPE_EXPECTED, fnName);\n    }\n    return this;\n  }",
    "comment": " Infer the return type from JSDocInfo. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "FunctionTypeBuilder.inferTemplateTypeName",
    "class_name": "com.google.javascript.jscomp.FunctionTypeBuilder",
    "signature": "com.google.javascript.jscomp.FunctionTypeBuilder.inferTemplateTypeName(JSDocInfo)",
    "snippet": "  FunctionTypeBuilder inferTemplateTypeName(@Nullable JSDocInfo info) {\n    if (info != null) {\n      templateTypeName = info.getTemplateTypeName();\n      typeRegistry.setTemplateTypeName(templateTypeName);\n    }\n    return this;\n  }",
    "comment": " Infer the template type from the doc info. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "FunctionTypeBuilder.inferThisType",
    "class_name": "com.google.javascript.jscomp.FunctionTypeBuilder",
    "signature": "com.google.javascript.jscomp.FunctionTypeBuilder.inferThisType(JSDocInfo,Node)",
    "snippet": "  FunctionTypeBuilder inferThisType(JSDocInfo info,\n      @Nullable Node owner) {\n    ObjectType maybeThisType = null;\n    if (info != null && info.hasThisType()) {\n      maybeThisType = ObjectType.cast(\n          info.getThisType().evaluate(scope, typeRegistry));\n    }\n    if (maybeThisType != null) {\n      thisType = maybeThisType;\n      thisType.setValidator(new ThisTypeValidator());\n    } else if (owner != null &&\n               (info == null || !info.hasType())) {\n      // If the function is of the form:\n      // x.prototype.y = function() {}\n      // then we can assume \"x\" is the @this type. On the other hand,\n      // if it's of the form:\n      // /** @type {Function} */ x.prototype.y;\n      // then we should not give it a @this type.\n      String ownerTypeName = owner.getQualifiedName();\n      Var ownerVar = scope.getVar(ownerTypeName);\n      JSType ownerType = ownerVar == null ? null : ownerVar.getType();\n      FunctionType ownerFnType = ownerType instanceof FunctionType ?\n          (FunctionType) ownerType : null;\n      ObjectType instType =\n          ownerFnType == null || ownerFnType.isOrdinaryFunction() ?\n          null : ownerFnType.getInstanceType();\n      if (instType != null) {\n        thisType = instType;\n      }\n    }\n\n    return this;\n  }",
    "comment": " Infers the type of {@code this}. @param info The JSDocInfo for this function. @param owner The node for the object whose prototype \"owns\" this function. For example, {@code A} in the expression {@code A.prototype.foo}. May be null to indicate that this is not a prototype property. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "FunctionTypeBuilder.isFunctionTypeDeclaration",
    "class_name": "com.google.javascript.jscomp.FunctionTypeBuilder",
    "signature": "com.google.javascript.jscomp.FunctionTypeBuilder.isFunctionTypeDeclaration(JSDocInfo)",
    "snippet": "  static boolean isFunctionTypeDeclaration(JSDocInfo info) {\n    return info.getParameterCount() > 0 ||\n        info.hasReturnType() ||\n        info.hasThisType() ||\n        info.isConstructor() ||\n        info.isInterface();\n  }",
    "comment": " Determines whether the given jsdoc info declares a function type. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "FunctionTypeBuilder.isOptionalParameter",
    "class_name": "com.google.javascript.jscomp.FunctionTypeBuilder",
    "signature": "com.google.javascript.jscomp.FunctionTypeBuilder.isOptionalParameter(Node,JSDocInfo)",
    "snippet": "  private boolean isOptionalParameter(\n      Node param, @Nullable JSDocInfo info) {\n    if (codingConvention.isOptionalParameter(param)) {\n      return true;\n    }\n\n    String paramName = param.getString();\n    return info != null && info.hasParameterType(paramName) &&\n        info.getParameterType(paramName).isOptionalArg();\n  }",
    "comment": " @return Whether the given param is an optional param. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "FunctionTypeBuilder.isVarArgsParameter",
    "class_name": "com.google.javascript.jscomp.FunctionTypeBuilder",
    "signature": "com.google.javascript.jscomp.FunctionTypeBuilder.isVarArgsParameter(Node,JSDocInfo)",
    "snippet": "  private boolean isVarArgsParameter(\n      Node param, @Nullable JSDocInfo info) {\n    if (codingConvention.isVarArgsParameter(param)) {\n      return true;\n    }\n\n    String paramName = param.getString();\n    return info != null && info.hasParameterType(paramName) &&\n        info.getParameterType(paramName).isVarArgs();\n  }",
    "comment": " Determine whether this is a var args parameter. @return Whether the given param is a var args param. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "FunctionTypeBuilder.maybeSetBaseType",
    "class_name": "com.google.javascript.jscomp.FunctionTypeBuilder",
    "signature": "com.google.javascript.jscomp.FunctionTypeBuilder.maybeSetBaseType(FunctionType)",
    "snippet": "  private void maybeSetBaseType(FunctionType fnType) {\n    if (!fnType.isInterface() && baseType != null) {\n      fnType.setPrototypeBasedOn(baseType);\n    }\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "FunctionTypeBuilder.setSourceNode",
    "class_name": "com.google.javascript.jscomp.FunctionTypeBuilder",
    "signature": "com.google.javascript.jscomp.FunctionTypeBuilder.setSourceNode(Node)",
    "snippet": "  FunctionTypeBuilder setSourceNode(@Nullable Node sourceNode) {\n    this.sourceNode = sourceNode;\n    return this;\n  }",
    "comment": " Sets the FUNCTION node of this function. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "ThisTypeValidator.apply",
    "class_name": "com.google.javascript.jscomp.FunctionTypeBuilder$ThisTypeValidator",
    "signature": "com.google.javascript.jscomp.FunctionTypeBuilder$ThisTypeValidator.apply(JSType)",
    "snippet": "    @Override\n    public boolean apply(JSType type) {\n      // TODO(user): Doing an instanceof check here is too\n      // restrictive as (Date,Error) is, for instance, an object type\n      // even though its implementation is a UnionType. Would need to\n      // create interfaces JSType, ObjectType, FunctionType etc and have\n      // separate implementation instead of the class hierarchy, so that\n      // union types can also be object types, etc.\n      if (!type.restrictByNotNullOrUndefined().isSubtype(\n              typeRegistry.getNativeType(OBJECT_TYPE))) {\n        reportWarning(THIS_TYPE_NON_OBJECT, type.toString());\n        return false;\n      }\n      return true;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "GlobalNamespace.GlobalNamespace",
    "class_name": "com.google.javascript.jscomp.GlobalNamespace",
    "signature": "com.google.javascript.jscomp.GlobalNamespace.GlobalNamespace(AbstractCompiler,Node)",
    "snippet": "  GlobalNamespace(AbstractCompiler compiler, Node root) {\n    this(compiler, null, root);\n  }",
    "comment": " Creates an instance that may emit warnings when building the namespace.  @param compiler The AbstractCompiler, for reporting code changes @param root The root of the rest of the code to build a namespace for. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "GlobalNamespace.GlobalNamespace",
    "class_name": "com.google.javascript.jscomp.GlobalNamespace",
    "signature": "com.google.javascript.jscomp.GlobalNamespace.GlobalNamespace(AbstractCompiler,Node,Node)",
    "snippet": "  GlobalNamespace(AbstractCompiler compiler, Node externsRoot, Node root) {\n    this.compiler = compiler;\n    this.externsRoot = externsRoot;\n    this.root = root;\n  }",
    "comment": " Creates an instance that may emit warnings when building the namespace.  @param compiler The AbstractCompiler, for reporting code changes @param externsRoot The root of the externs to build a namespace for. If this is null, externs and properties defined on extern types will not be included in the global namespace.  If non-null, it allows user-defined function on extern types to be included in the global namespace.  E.g. String.foo. @param root The root of the rest of the code to build a namespace for. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "GlobalNamespace.ensureGenerated",
    "class_name": "com.google.javascript.jscomp.GlobalNamespace",
    "signature": "com.google.javascript.jscomp.GlobalNamespace.ensureGenerated()",
    "snippet": "  private void ensureGenerated() {\n    if (!generated) {\n      process();\n    }\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "GlobalNamespace.getNameForest",
    "class_name": "com.google.javascript.jscomp.GlobalNamespace",
    "signature": "com.google.javascript.jscomp.GlobalNamespace.getNameForest()",
    "snippet": "  List<Name> getNameForest() {\n    ensureGenerated();\n    return globalNames;\n  }",
    "comment": " Gets a list of the roots of the forest of the global names, where the roots are the top-level names. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "GlobalNamespace.getNameIndex",
    "class_name": "com.google.javascript.jscomp.GlobalNamespace",
    "signature": "com.google.javascript.jscomp.GlobalNamespace.getNameIndex()",
    "snippet": "  Map<String, Name> getNameIndex() {\n    ensureGenerated();\n    return nameMap;\n  }",
    "comment": " Gets an index of all the global names, indexed by full qualified name (as in \"a\", \"a.b.c\", etc.). ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "GlobalNamespace.getTopVarName",
    "class_name": "com.google.javascript.jscomp.GlobalNamespace",
    "signature": "com.google.javascript.jscomp.GlobalNamespace.getTopVarName(String)",
    "snippet": "  private String getTopVarName(String name) {\n    int firstDotIndex = name.indexOf('.');\n    return firstDotIndex == -1 ? name : name.substring(0, firstDotIndex);\n  }",
    "comment": " Gets the top variable name from a possibly namespaced name.  @param name A variable or qualified property name (e.g. \"a\" or \"a.b.c.d\") @return The top variable name (e.g. \"a\") ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "GlobalNamespace.isGlobalNameReference",
    "class_name": "com.google.javascript.jscomp.GlobalNamespace",
    "signature": "com.google.javascript.jscomp.GlobalNamespace.isGlobalNameReference(String,Scope)",
    "snippet": "  private boolean isGlobalNameReference(String name, Scope s) {\n    String topVarName = getTopVarName(name);\n    return isGlobalVarReference(topVarName, s);\n  }",
    "comment": " Determines whether a name reference in a particular scope is a global name reference.  @param name A variable or property name (e.g. \"a\" or \"a.b.c.d\") @param s The scope in which the name is referenced @return Whether the name reference is a global name reference ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "GlobalNamespace.isGlobalScope",
    "class_name": "com.google.javascript.jscomp.GlobalNamespace",
    "signature": "com.google.javascript.jscomp.GlobalNamespace.isGlobalScope(Scope)",
    "snippet": "  private boolean isGlobalScope(Scope s) {\n    return s.getParent() == null;\n  }",
    "comment": " Gets whether a scope is the global scope.  @param s A scope @return Whether the scope is the global scope ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "GlobalNamespace.isGlobalVarReference",
    "class_name": "com.google.javascript.jscomp.GlobalNamespace",
    "signature": "com.google.javascript.jscomp.GlobalNamespace.isGlobalVarReference(String,Scope)",
    "snippet": "  private boolean isGlobalVarReference(String name, Scope s) {\n    Scope.Var v = s.getVar(name);\n    if (v == null && externsScope != null) {\n      v = externsScope.getVar(name);\n    }\n    return v != null && !v.isLocal();\n  }",
    "comment": " Determines whether a variable name reference in a particular scope is a global variable reference.  @param name A variable name (e.g. \"a\") @param s The scope in which the name is referenced @return Whether the name reference is a global variable reference ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "GlobalNamespace.process",
    "class_name": "com.google.javascript.jscomp.GlobalNamespace",
    "signature": "com.google.javascript.jscomp.GlobalNamespace.process()",
    "snippet": "  private void process() {\n    if (externsRoot != null) {\n      inExterns = true;\n      NodeTraversal.traverse(compiler, externsRoot, new BuildGlobalNamespace());\n    }\n    inExterns = false;\n\n    NodeTraversal.traverse(compiler, root, new BuildGlobalNamespace());\n    generated = true;\n  }",
    "comment": " Builds the namespace lazily. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "BuildGlobalNamespace.collect",
    "class_name": "com.google.javascript.jscomp.GlobalNamespace$BuildGlobalNamespace",
    "signature": "com.google.javascript.jscomp.GlobalNamespace$BuildGlobalNamespace.collect(NodeTraversal,Node,Node)",
    "snippet": "    public void collect(NodeTraversal t, Node n, Node parent) {\n      if (nodeFilter != null && !nodeFilter.apply(n)) {\n        return;\n      }\n\n      // If we are traversing the externs, then we save a pointer to the scope\n      // generated by them, so that we can do lookups in it later.\n      if (externsRoot != null && n == externsRoot) {\n        externsScope = t.getScope();\n      }\n\n      String name;\n      boolean isSet = false;\n      Name.Type type = Name.Type.OTHER;\n      boolean isPropAssign = false;\n\n      switch (n.getType()) {\n        case Token.GET:\n        case Token.SET:\n        case Token.STRING:\n          // This may be a key in an object literal declaration.\n          name = null;\n          if (parent != null && parent.getType() == Token.OBJECTLIT) {\n            name = getNameForObjLitKey(n);\n          }\n          if (name == null) return;\n          isSet = true;\n          switch (n.getType()) {\n            case Token.STRING:\n              type = getValueType(n.getFirstChild());\n              break;\n            case Token.GET:\n              type = Name.Type.GET;\n              break;\n            case Token.SET:\n              type = Name.Type.SET;\n              break;\n            default:\n              throw new IllegalStateException(\"unexpected:\" + n);\n          }\n          break;\n        case Token.NAME:\n          // This may be a variable get or set.\n          if (parent != null) {\n            switch (parent.getType()) {\n              case Token.VAR:\n                isSet = true;\n                Node rvalue = n.getFirstChild();\n                type = rvalue == null ? Name.Type.OTHER : getValueType(rvalue);\n                break;\n              case Token.ASSIGN:\n                if (parent.getFirstChild() == n) {\n                  isSet = true;\n                  type = getValueType(n.getNext());\n                }\n                break;\n              case Token.GETPROP:\n                return;\n              case Token.FUNCTION:\n                Node gramps = parent.getParent();\n                if (gramps == null ||\n                    NodeUtil.isFunctionExpression(parent)) return;\n                isSet = true;\n                type = Name.Type.FUNCTION;\n                break;\n              case Token.INC:\n              case Token.DEC:\n                isSet = true;\n                type = Name.Type.OTHER;\n                break;\n              default:\n                if (NodeUtil.isAssignmentOp(parent) &&\n                    parent.getFirstChild() == n) {\n                  isSet = true;\n                  type = Name.Type.OTHER;\n                }\n            }\n          }\n          name = n.getString();\n          break;\n        case Token.GETPROP:\n          // This may be a namespaced name get or set.\n          if (parent != null) {\n            switch (parent.getType()) {\n              case Token.ASSIGN:\n                if (parent.getFirstChild() == n) {\n                  isSet = true;\n                  type = getValueType(n.getNext());\n                  isPropAssign = true;\n                }\n                break;\n              case Token.INC:\n              case Token.DEC:\n                isSet = true;\n                type = Name.Type.OTHER;\n                break;\n              case Token.GETPROP:\n                return;\n              default:\n                if (NodeUtil.isAssignmentOp(parent) &&\n                    parent.getFirstChild() == n) {\n                  isSet = true;\n                  type = Name.Type.OTHER;\n                }\n            }\n          }\n          name = n.getQualifiedName();\n          if (name == null) return;\n          break;\n        default:\n          return;\n      }\n\n      // We are only interested in global names.\n      Scope scope = t.getScope();\n      if (!isGlobalNameReference(name, scope)) {\n        return;\n      }\n\n      if (isSet) {\n        if (isGlobalScope(scope)) {\n          handleSetFromGlobal(t, n, parent, name, isPropAssign, type);\n        } else {\n          handleSetFromLocal(t, n, parent, name);\n        }\n      } else {\n        handleGet(t, n, parent, name);\n      }\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "BuildGlobalNamespace.getOrCreateName",
    "class_name": "com.google.javascript.jscomp.GlobalNamespace$BuildGlobalNamespace",
    "signature": "com.google.javascript.jscomp.GlobalNamespace$BuildGlobalNamespace.getOrCreateName(String)",
    "snippet": "    Name getOrCreateName(String name) {\n      Name node = nameMap.get(name);\n      if (node == null) {\n        int i = name.lastIndexOf('.');\n        if (i >= 0) {\n          String parentName = name.substring(0, i);\n          Name parent = getOrCreateName(parentName);\n          node = parent.addProperty(name.substring(i + 1), inExterns);\n        } else {\n          node = new Name(name, null, inExterns);\n          globalNames.add(node);\n        }\n        nameMap.put(name, node);\n      }\n      return node;\n    }",
    "comment": " Gets a {@link Name} instance for a global name. Creates it if necessary, as well as instances for any of its prefixes that are not yet defined.  @param name A global name (e.g. \"a\", \"a.b.c.d\") @return The {@link Name} instance for {@code name} ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "BuildGlobalNamespace.getValueType",
    "class_name": "com.google.javascript.jscomp.GlobalNamespace$BuildGlobalNamespace",
    "signature": "com.google.javascript.jscomp.GlobalNamespace$BuildGlobalNamespace.getValueType(Node)",
    "snippet": "    Name.Type getValueType(Node n) {\n      switch (n.getType()) {\n        case Token.OBJECTLIT:\n          return Name.Type.OBJECTLIT;\n        case Token.FUNCTION:\n          return Name.Type.FUNCTION;\n        case Token.OR:\n          // Recurse on the second value. If the first value were an object\n          // literal or function, then the OR would be meaningless and the\n          // second value would be dead code. Assume that if the second value\n          // is an object literal or function, then the first value will also\n          // evaluate to one when it doesn't evaluate to false.\n          return getValueType(n.getLastChild());\n        case Token.HOOK:\n          // The same line of reasoning used for the OR case applies here.\n          Node second = n.getFirstChild().getNext();\n          Name.Type t = getValueType(second);\n          if (t != Name.Type.OTHER) return t;\n          Node third = second.getNext();\n          return getValueType(third);\n      }\n      return Name.Type.OTHER;\n    }",
    "comment": " Gets the type of a value or simple expression.  @param n An rvalue in an assignment or variable declaration (not null) @return A {@link Name.Type} ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "BuildGlobalNamespace.handleSetFromGlobal",
    "class_name": "com.google.javascript.jscomp.GlobalNamespace$BuildGlobalNamespace",
    "signature": "com.google.javascript.jscomp.GlobalNamespace$BuildGlobalNamespace.handleSetFromGlobal(NodeTraversal,Node,Node,String,boolean,Type)",
    "snippet": "    void handleSetFromGlobal(NodeTraversal t, Node n, Node parent, String name,\n                             boolean isPropAssign, Name.Type type) {\n      if (maybeHandlePrototypePrefix(t, n, parent, name)) return;\n\n      Name nameObj = getOrCreateName(name);\n      nameObj.type = type;\n\n      Ref set = new Ref(t, n, nameObj, Ref.Type.SET_FROM_GLOBAL,\n          currentPreOrderIndex++);\n      nameObj.addRef(set);\n\n      if (isNestedAssign(parent)) {\n        // This assignment is both a set and a get that creates an alias.\n        Ref get = new Ref(t, n, nameObj, Ref.Type.ALIASING_GET,\n            currentPreOrderIndex++);\n        nameObj.addRef(get);\n        Ref.markTwins(set, get);\n      } else if (isConstructorOrEnumDeclaration(n, parent)) {\n        // Names with a @constructor or @enum annotation are always collapsed\n        nameObj.setIsClassOrEnum();\n      }\n    }",
    "comment": " Updates our respresentation of the global namespace to reflect an assignment to a global name in global scope.  @param t The traversal @param n The node currently being visited @param parent {@code n}'s parent @param name The global name (e.g. \"a\" or \"a.b.c.d\") @param isPropAssign Whether this set corresponds to a property assignment of the form <code>a.b.c = ...;</code> @param type The type of the value that the name is being assigned ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "BuildGlobalNamespace.isConstructorOrEnumDeclaration",
    "class_name": "com.google.javascript.jscomp.GlobalNamespace$BuildGlobalNamespace",
    "signature": "com.google.javascript.jscomp.GlobalNamespace$BuildGlobalNamespace.isConstructorOrEnumDeclaration(Node,Node)",
    "snippet": "    private boolean isConstructorOrEnumDeclaration(Node n, Node parent) {\n      JSDocInfo info;\n      int valueNodeType;\n      switch (parent.getType()) {\n        case Token.ASSIGN:\n          info = parent.getJSDocInfo();\n          valueNodeType = n.getNext().getType();\n          break;\n        case Token.VAR:\n          info = n.getJSDocInfo();\n          if (info == null) {\n            info = parent.getJSDocInfo();\n          }\n          Node valueNode = n.getFirstChild();\n          valueNodeType = valueNode != null ? valueNode.getType() : Token.VOID;\n          break;\n        default:\n          if (NodeUtil.isFunctionDeclaration(parent)) {\n            info = parent.getJSDocInfo();\n            valueNodeType = Token.FUNCTION;\n            break;\n          }\n          return false;\n      }\n      // Heed the annotations only if they're sensibly used.\n      return info != null &&\n             (info.isConstructor() && valueNodeType == Token.FUNCTION ||\n              info.hasEnumParameterType() && valueNodeType == Token.OBJECTLIT);\n    }",
    "comment": " Determines whether a set operation is a constructor or enumeration declaration. The set operation may either be an assignment to a name, a variable declaration, or an object literal key mapping.  @param n The node that represents the name being set @param parent Parent node of {@code n} (an ASSIGN, VAR, or OBJLIT node) @return Whether the set operation is either a constructor or enum declaration ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "BuildGlobalNamespace.isNestedAssign",
    "class_name": "com.google.javascript.jscomp.GlobalNamespace$BuildGlobalNamespace",
    "signature": "com.google.javascript.jscomp.GlobalNamespace$BuildGlobalNamespace.isNestedAssign(Node)",
    "snippet": "    boolean isNestedAssign(Node parent) {\n      return parent.getType() == Token.ASSIGN &&\n             !NodeUtil.isExpressionNode(parent.getParent());\n    }",
    "comment": " Determines whether an assignment is nested (i.e. whether its return value is used).  @param parent The parent of the current traversal node (not null) @return Whether it appears that the return value of the assignment is used ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "BuildGlobalNamespace.maybeHandlePrototypePrefix",
    "class_name": "com.google.javascript.jscomp.GlobalNamespace$BuildGlobalNamespace",
    "signature": "com.google.javascript.jscomp.GlobalNamespace$BuildGlobalNamespace.maybeHandlePrototypePrefix(NodeTraversal,Node,Node,String)",
    "snippet": "    boolean maybeHandlePrototypePrefix(NodeTraversal t, Node n, Node parent,\n        String name) {\n      // We use a string-based approach instead of inspecting the parse tree\n      // to avoid complexities with object literals, possibly nested, beneath\n      // assignments.\n\n      int numLevelsToRemove;\n      String prefix;\n      if (name.endsWith(\".prototype\")) {\n        numLevelsToRemove = 1;\n        prefix = name.substring(0, name.length() - 10);\n      } else {\n        int i = name.indexOf(\".prototype.\");\n        if (i == -1) {\n          return false;\n        }\n        prefix = name.substring(0, i);\n        numLevelsToRemove = 2;\n        i = name.indexOf('.', i + 11);\n        while (i >= 0) {\n          numLevelsToRemove++;\n          i = name.indexOf('.', i + 1);\n        }\n      }\n\n      if (parent != null && NodeUtil.isObjectLitKey(n, parent)) {\n        // Object literal keys have no prefix that's referenced directly per\n        // key, so we're done.\n        return true;\n      }\n\n      for (int i = 0; i < numLevelsToRemove; i++) {\n        parent = n;\n        n = n.getFirstChild();\n      }\n\n      handleGet(t, n, parent, prefix, Ref.Type.PROTOTYPE_GET);\n      return true;\n    }",
    "comment": " Updates our respresentation of the global namespace to reflect a read of a global name's longest prefix before the \"prototype\" property if the name includes the \"prototype\" property. Does nothing otherwise.  @param t The current node traversal @param n The node currently being visited @param parent {@code n}'s parent @param name The global name (e.g. \"a\" or \"a.b.c.d\") @return Whether the name was handled ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "BuildGlobalNamespace.shouldTraverse",
    "class_name": "com.google.javascript.jscomp.GlobalNamespace$BuildGlobalNamespace",
    "signature": "com.google.javascript.jscomp.GlobalNamespace$BuildGlobalNamespace.shouldTraverse(NodeTraversal,Node,Node)",
    "snippet": "    @Override\n    public boolean shouldTraverse(NodeTraversal t, Node n, Node parent) {\n      collect(t, n, parent);\n      return true;\n    }",
    "comment": "Collect the references in pre-order. */",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "BuildGlobalNamespace.visit",
    "class_name": "com.google.javascript.jscomp.GlobalNamespace$BuildGlobalNamespace",
    "signature": "com.google.javascript.jscomp.GlobalNamespace$BuildGlobalNamespace.visit(NodeTraversal,Node,Node)",
    "snippet": "    @Override\n    public void visit(NodeTraversal t, Node n, Node parent) {}",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "Name.addRef",
    "class_name": "com.google.javascript.jscomp.GlobalNamespace$Name",
    "signature": "com.google.javascript.jscomp.GlobalNamespace$Name.addRef(Ref)",
    "snippet": "    void addRef(Ref ref) {\n      addRefInternal(ref);\n      switch (ref.type) {\n        case SET_FROM_GLOBAL:\n          if (declaration == null) {\n            declaration = ref;\n            docInfo = getDocInfoForDeclaration(ref);\n          }\n          globalSets++;\n          break;\n        case SET_FROM_LOCAL:\n          localSets++;\n          break;\n        case PROTOTYPE_GET:\n        case DIRECT_GET:\n          totalGets++;\n          break;\n        case ALIASING_GET:\n          aliasingGets++;\n          totalGets++;\n          break;\n        case CALL_GET:\n          callGets++;\n          totalGets++;\n          break;\n        case DELETE_PROP:\n          deleteProps++;\n          break;\n        default:\n          throw new IllegalStateException();\n      }\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "Name.addRefInternal",
    "class_name": "com.google.javascript.jscomp.GlobalNamespace$Name",
    "signature": "com.google.javascript.jscomp.GlobalNamespace$Name.addRefInternal(Ref)",
    "snippet": "    void addRefInternal(Ref ref) {\n      if (refs == null) {\n        refs = Lists.newArrayList();\n      }\n      refs.add(ref);\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "Name.getDeclaration",
    "class_name": "com.google.javascript.jscomp.GlobalNamespace$Name",
    "signature": "com.google.javascript.jscomp.GlobalNamespace$Name.getDeclaration()",
    "snippet": "    @Override\n    public Ref getDeclaration() {\n      return declaration;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "Name.getDocInfoForDeclaration",
    "class_name": "com.google.javascript.jscomp.GlobalNamespace$Name",
    "signature": "com.google.javascript.jscomp.GlobalNamespace$Name.getDocInfoForDeclaration(Ref)",
    "snippet": "    private static JSDocInfo getDocInfoForDeclaration(Ref ref) {\n      if (ref.node != null) {\n        Node refParent = ref.node.getParent();\n        switch (refParent.getType()) {\n          case Token.FUNCTION:\n          case Token.ASSIGN:\n            return refParent.getJSDocInfo();\n          case Token.VAR:\n            return ref.node == refParent.getFirstChild() ?\n                refParent.getJSDocInfo() : ref.node.getJSDocInfo();\n        }\n      }\n\n      return null;\n    }",
    "comment": " Tries to get the doc info for a given declaration ref. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "Name.getRefs",
    "class_name": "com.google.javascript.jscomp.GlobalNamespace$Name",
    "signature": "com.google.javascript.jscomp.GlobalNamespace$Name.getRefs()",
    "snippet": "    List<Ref> getRefs() {\n      return refs == null ? ImmutableList.<Ref>of() : refs;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "GlobalVarReferenceMap.GlobalVarReferenceMap",
    "class_name": "com.google.javascript.jscomp.GlobalVarReferenceMap",
    "signature": "com.google.javascript.jscomp.GlobalVarReferenceMap.GlobalVarReferenceMap(List,List)",
    "snippet": "  GlobalVarReferenceMap(List<CompilerInput> inputs,\n      List<CompilerInput> externs) {\n    inputOrder = Maps.newHashMap();\n    int ind = 0;\n    for (CompilerInput extern : externs) {\n      inputOrder.put(extern.getName(), ind);\n      ind++;\n    }\n    for (CompilerInput input : inputs) {\n      inputOrder.put(input.getName(), ind);\n      ind++;\n    }\n  }",
    "comment": " @param inputs The ordered list of all inputs for the compiler. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "GlobalVarReferenceMap.getReferences",
    "class_name": "com.google.javascript.jscomp.GlobalVarReferenceMap",
    "signature": "com.google.javascript.jscomp.GlobalVarReferenceMap.getReferences(Var)",
    "snippet": "  @Override\n  public ReferenceCollection getReferences(Var var) {\n    if (!var.isGlobal()) {\n      return null;\n    }\n    return refMap.get(var.getName());\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "GlobalVarReferenceMap.resetGlobalVarReferences",
    "class_name": "com.google.javascript.jscomp.GlobalVarReferenceMap",
    "signature": "com.google.javascript.jscomp.GlobalVarReferenceMap.resetGlobalVarReferences(Map)",
    "snippet": "  private void resetGlobalVarReferences(\n      Map<Var, ReferenceCollection> globalRefMap) {\n    refMap = Maps.newHashMap();\n    for (Entry<Var, ReferenceCollection> entry : globalRefMap.entrySet()) {\n      Var var = entry.getKey();\n      if (var.isGlobal()) {\n        refMap.put(var.getName(), entry.getValue());\n      }\n    }\n  }",
    "comment": " Resets global var reference map with the new provide map.  @param globalRefMap The reference map result of a {@link ReferenceCollectingCallback} pass collected from the whole AST. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "GlobalVarReferenceMap.updateGlobalVarReferences",
    "class_name": "com.google.javascript.jscomp.GlobalVarReferenceMap",
    "signature": "com.google.javascript.jscomp.GlobalVarReferenceMap.updateGlobalVarReferences(Map,Node)",
    "snippet": "  void updateGlobalVarReferences(Map<Var, ReferenceCollection>\n      refMapPatch, Node root) {\n    if (refMap == null || root.getType() != Token.SCRIPT) {\n      resetGlobalVarReferences(refMapPatch);\n      return;\n    }\n    String sourceName = NodeUtil.getSourceName(root);\n    Preconditions.checkNotNull(sourceName);\n    // Note there are two assumptions here (i) the order of compiler inputs\n    // has not changed and (ii) all references are in the order they appear\n    // in AST (this is enforced in ReferenceCollectionCallback).\n    removeScriptReferences(sourceName);\n    for (Entry<Var, ReferenceCollection> entry : refMapPatch.entrySet()) {\n      Var var = entry.getKey();\n      if (var.isGlobal()) {\n        replaceReferences(var.getName(), sourceName, entry.getValue());\n      }\n    }\n  }",
    "comment": " Updates the internal reference map based on the provided parameters. If {@code scriptRoot} is not SCRIPT, it basically replaces the internal map with the new one, otherwise it replaces all the information associated to the given script.  @param refMapPatch The reference map result of a {@link ReferenceCollectingCallback} pass which might be collected from the whole AST or just a sub-tree associated to a SCRIPT node. @param root AST sub-tree root on which reference collection was done. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "InferJSDocInfo.InferJSDocInfo",
    "class_name": "com.google.javascript.jscomp.InferJSDocInfo",
    "signature": "com.google.javascript.jscomp.InferJSDocInfo.InferJSDocInfo(AbstractCompiler)",
    "snippet": "  InferJSDocInfo(AbstractCompiler compiler) {\n    this.compiler = compiler;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "InferJSDocInfo.attachJSDocInfoToNominalTypeOrShape",
    "class_name": "com.google.javascript.jscomp.InferJSDocInfo",
    "signature": "com.google.javascript.jscomp.InferJSDocInfo.attachJSDocInfoToNominalTypeOrShape(ObjectType,JSDocInfo,String)",
    "snippet": "  private void attachJSDocInfoToNominalTypeOrShape(\n      ObjectType objType, JSDocInfo docInfo, @Nullable String qName) {\n    if (objType.isConstructor() ||\n        objType.isEnumType() ||\n        objType.isInterface()) {\n      // Named types.\n      if (objType.hasReferenceName() &&\n          objType.getReferenceName().equals(qName)) {\n        objType.setJSDocInfo(docInfo);\n\n        if (objType.isConstructor() || objType.isInterface()) {\n          ((FunctionType) objType).getInstanceType().setJSDocInfo(\n              docInfo);\n        } else if (objType instanceof EnumType) {\n          ((EnumType) objType).getElementsType().setJSDocInfo(docInfo);\n        }\n      }\n    } else if (!objType.isNativeObjectType() &&\n        objType.isFunctionType()) {\n      // Structural functions.\n      objType.setJSDocInfo(docInfo);\n    }\n  }",
    "comment": " Handle cases #1 and #3 in the class doc. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "InferJSDocInfo.dereferenceToObject",
    "class_name": "com.google.javascript.jscomp.InferJSDocInfo",
    "signature": "com.google.javascript.jscomp.InferJSDocInfo.dereferenceToObject(JSType)",
    "snippet": "  private ObjectType dereferenceToObject(JSType type) {\n    return ObjectType.cast(type == null ? null : type.dereference());\n  }",
    "comment": " Dereferences the given type to an object, or returns null. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "InferJSDocInfo.process",
    "class_name": "com.google.javascript.jscomp.InferJSDocInfo",
    "signature": "com.google.javascript.jscomp.InferJSDocInfo.process(Node,Node)",
    "snippet": "  @Override\n  public void process(Node externs, Node root) {\n    if (externs != null) {\n      inExterns = true;\n      NodeTraversal.traverse(compiler, externs, this);\n    }\n    if (root != null) {\n      inExterns = false;\n      NodeTraversal.traverse(compiler, root, this);\n    }\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "InferJSDocInfo.visit",
    "class_name": "com.google.javascript.jscomp.InferJSDocInfo",
    "signature": "com.google.javascript.jscomp.InferJSDocInfo.visit(NodeTraversal,Node,Node)",
    "snippet": "  public void visit(NodeTraversal t, Node n, Node parent) {\n    JSDocInfo docInfo;\n\n    switch (n.getType()) {\n      // Infer JSDocInfo on types of all type declarations on variables.\n      case Token.NAME:\n        if (parent == null) {\n          return;\n        }\n\n        // Only allow JSDoc on VARs, function declarations, and assigns.\n        if (parent.getType() != Token.VAR &&\n            !NodeUtil.isFunctionDeclaration(parent) &&\n            !(parent.getType() == Token.ASSIGN &&\n              n == parent.getFirstChild())) {\n          return;\n        }\n\n        // There are four places the doc info could live.\n        // 1) A FUNCTION node.\n        // /** ... */ function f() { ... }\n        // 2) An ASSIGN parent.\n        // /** ... */ x = function () { ... }\n        // 3) A NAME parent.\n        // var x, /** ... */ y = function() { ... }\n        // 4) A VAR gramps.\n        // /** ... */ var x = function() { ... }\n        docInfo = n.getJSDocInfo();\n        if (docInfo == null &&\n            !(parent.getType() == Token.VAR &&\n                !parent.hasOneChild())) {\n          docInfo = parent.getJSDocInfo();\n        }\n\n        // Try to find the type of the NAME.\n        JSType varType = n.getJSType();\n        if (varType == null && parent.getType() == Token.FUNCTION) {\n          varType = parent.getJSType();\n        }\n\n        // If we have no type to attach JSDocInfo to, then there's nothing\n        // we can do.\n        if (varType == null || docInfo == null) {\n          return;\n        }\n\n        // Dereference the type. If the result is not an object, or already\n        // has docs attached, then do nothing.\n        ObjectType objType = dereferenceToObject(varType);\n        if (objType == null || objType.getJSDocInfo() != null) {\n          return;\n        }\n\n        attachJSDocInfoToNominalTypeOrShape(objType, docInfo, n.getString());\n        break;\n\n      case Token.GETPROP:\n        // Infer JSDocInfo on properties.\n        // There are two ways to write doc comments on a property.\n        //\n        // 1)\n        // /** @deprecated */\n        // obj.prop = ...\n        //\n        // 2)\n        // /** @deprecated */\n        // obj.prop;\n        if (NodeUtil.isExpressionNode(parent) ||\n            (parent.getType() == Token.ASSIGN &&\n             parent.getFirstChild() == n)) {\n          docInfo = n.getJSDocInfo();\n          if (docInfo == null) {\n            docInfo = parent.getJSDocInfo();\n          }\n          if (docInfo != null) {\n            ObjectType lhsType =\n                dereferenceToObject(n.getFirstChild().getJSType());\n            if (lhsType != null) {\n              // Put the JSDoc in the property slot, if there is one.\n              String propName = n.getLastChild().getString();\n              if (lhsType.hasOwnProperty(propName)) {\n                lhsType.setPropertyJSDocInfo(propName, docInfo);\n              }\n\n              // Put the JSDoc in any constructors or function shapes as well.\n              ObjectType propType =\n                  dereferenceToObject(lhsType.getPropertyType(propName));\n              if (propType != null) {\n                attachJSDocInfoToNominalTypeOrShape(\n                    propType, docInfo, n.getQualifiedName());\n              }\n            }\n          }\n        }\n        break;\n    }\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "InlineFunctions.InlineFunctions",
    "class_name": "com.google.javascript.jscomp.InlineFunctions",
    "signature": "com.google.javascript.jscomp.InlineFunctions.InlineFunctions(AbstractCompiler,Supplier,boolean,boolean,boolean,boolean)",
    "snippet": "  InlineFunctions(AbstractCompiler compiler,\n      Supplier<String> safeNameIdSupplier,\n      boolean inlineGlobalFunctions,\n      boolean inlineLocalFunctions,\n      boolean blockFunctionInliningEnabled,\n      boolean assumeStrictThis) {\n    Preconditions.checkArgument(compiler != null);\n    Preconditions.checkArgument(safeNameIdSupplier != null);\n    this.compiler = compiler;\n\n    this.inlineGlobalFunctions = inlineGlobalFunctions;\n    this.inlineLocalFunctions = inlineLocalFunctions;\n    this.blockFunctionInliningEnabled = blockFunctionInliningEnabled;\n\n    this.injector = new FunctionInjector(\n        compiler, safeNameIdSupplier, true, assumeStrictThis);\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "InlineFunctions.process",
    "class_name": "com.google.javascript.jscomp.InlineFunctions",
    "signature": "com.google.javascript.jscomp.InlineFunctions.process(Node,Node)",
    "snippet": "  @Override\n  public void process(Node externs, Node root) {\n    Preconditions.checkState(compiler.getLifeCycleStage().isNormalized());\n\n    NodeTraversal.traverse(compiler, root, new FindCandidateFunctions());\n    if (fns.isEmpty()) {\n      return;  // Nothing left to do.\n    }\n    NodeTraversal.traverse(compiler, root,\n       new FindCandidatesReferences(fns, anonFns));\n    trimCanidatesNotMeetingMinimumRequirements();\n    if (fns.isEmpty()) {\n      return;  // Nothing left to do.\n    }\n\n    // Store the set of function names eligible for inlining and use this to\n    // prevent function names from being moved into temporaries during\n    // expression decomposition. If this movement were allowed it would prevent\n    // the Inline callback from finding the function calls.\n    //\n    // This pass already assumes these are constants, so this is safe for anyone\n    // using function inlining.\n    //\n    Set<String> fnNames = Sets.newHashSet(fns.keySet());\n    injector.setKnownConstants(fnNames);\n\n    trimCanidatesUsingOnCost();\n    if (fns.isEmpty()) {\n      return;  // Nothing left to do.\n    }\n    resolveInlineConflicts();\n    decomposeExpressions(fnNames);\n    NodeTraversal.traverse(compiler, root,\n        new CallVisitor(\n            fns, anonFns, new Inline(injector, specializationState)));\n\n    removeInlinedFunctions();\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "FindCandidateFunctions.findFunctionExpressions",
    "class_name": "com.google.javascript.jscomp.InlineFunctions$FindCandidateFunctions",
    "signature": "com.google.javascript.jscomp.InlineFunctions$FindCandidateFunctions.findFunctionExpressions(NodeTraversal,Node)",
    "snippet": "    public void findFunctionExpressions(NodeTraversal t, Node n) {\n      switch (n.getType()) {\n        // Functions expressions in the form of:\n        //   (function(){})();\n        case Token.CALL:\n          Node fnNode = null;\n          if (n.getFirstChild().getType() == Token.FUNCTION) {\n            fnNode = n.getFirstChild();\n          } else if (NodeUtil.isFunctionObjectCall(n)) {\n            Node fnIdentifingNode = n.getFirstChild().getFirstChild();\n            if (fnIdentifingNode.getType() == Token.FUNCTION) {\n              fnNode = fnIdentifingNode;\n            }\n          }\n\n          // If a interesting function was discovered, add it.\n          if (fnNode != null) {\n            Function fn = new FunctionExpression(fnNode, callsSeen++);\n            maybeAddFunction(fn, t.getModule());\n            anonFns.put(fnNode, fn.getName());\n          }\n          break;\n      }\n    }",
    "comment": " Find function expressions that are called directly in the form of (function(a,b,...){...})(a,b,...) or (function(a,b,...){...}).call(this,a,b, ...) ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "FindCandidateFunctions.findNamedFunctions",
    "class_name": "com.google.javascript.jscomp.InlineFunctions$FindCandidateFunctions",
    "signature": "com.google.javascript.jscomp.InlineFunctions$FindCandidateFunctions.findNamedFunctions(NodeTraversal,Node,Node)",
    "snippet": "    public void findNamedFunctions(NodeTraversal t, Node n, Node parent) {\n      if (!NodeUtil.isStatement(n)) {\n        // There aren't any interesting functions here.\n        return;\n      }\n\n      switch (n.getType()) {\n        // Functions expressions in the form of:\n        //   var fooFn = function(x) { return ... }\n        case Token.VAR:\n          Preconditions.checkState(n.hasOneChild());\n          Node nameNode = n.getFirstChild();\n          if (nameNode.getType() == Token.NAME && nameNode.hasChildren()\n              && nameNode.getFirstChild().getType() == Token.FUNCTION) {\n            maybeAddFunction(new FunctionVar(n), t.getModule());\n          }\n          break;\n\n        // Named functions\n        // function Foo(x) { return ... }\n        case Token.FUNCTION:\n          Preconditions.checkState(NodeUtil.isStatementBlock(parent)\n              || parent.getType() == Token.LABEL);\n          if (!NodeUtil.isFunctionExpression(n)) {\n            Function fn = new NamedFunction(n);\n            maybeAddFunction(fn, t.getModule());\n          }\n          break;\n      }\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "FindCandidateFunctions.shouldTraverse",
    "class_name": "com.google.javascript.jscomp.InlineFunctions$FindCandidateFunctions",
    "signature": "com.google.javascript.jscomp.InlineFunctions$FindCandidateFunctions.shouldTraverse(NodeTraversal,Node,Node)",
    "snippet": "    @Override\n    public boolean shouldTraverse(\n        NodeTraversal nodeTraversal, Node n, Node parent) {\n      // Don't traverse into function bodies\n      // if we aren't inlining local functions.\n      return inlineLocalFunctions || nodeTraversal.inGlobalScope();\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "FindCandidateFunctions.visit",
    "class_name": "com.google.javascript.jscomp.InlineFunctions$FindCandidateFunctions",
    "signature": "com.google.javascript.jscomp.InlineFunctions$FindCandidateFunctions.visit(NodeTraversal,Node,Node)",
    "snippet": "    public void visit(NodeTraversal t, Node n, Node parent) {\n      if ((t.inGlobalScope() && inlineGlobalFunctions)\n          || (!t.inGlobalScope() && inlineLocalFunctions)) {\n        findNamedFunctions(t, n, parent);\n\n        findFunctionExpressions(t, n);\n      }\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "InlineObjectLiterals.InlineObjectLiterals",
    "class_name": "com.google.javascript.jscomp.InlineObjectLiterals",
    "signature": "com.google.javascript.jscomp.InlineObjectLiterals.InlineObjectLiterals(AbstractCompiler,Supplier)",
    "snippet": "  InlineObjectLiterals(\n      AbstractCompiler compiler,\n      Supplier<String> safeNameIdSupplier) {\n    this.compiler = compiler;\n    this.safeNameIdSupplier = safeNameIdSupplier;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "InlineObjectLiterals.process",
    "class_name": "com.google.javascript.jscomp.InlineObjectLiterals",
    "signature": "com.google.javascript.jscomp.InlineObjectLiterals.process(Node,Node)",
    "snippet": "  @Override\n  public void process(Node externs, Node root) {\n    ReferenceCollectingCallback callback = new ReferenceCollectingCallback(\n        compiler, new InliningBehavior());\n    callback.process(externs, root);\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "InliningBehavior.afterExitScope",
    "class_name": "com.google.javascript.jscomp.InlineObjectLiterals$InliningBehavior",
    "signature": "com.google.javascript.jscomp.InlineObjectLiterals$InliningBehavior.afterExitScope(NodeTraversal,ReferenceMap)",
    "snippet": "    @Override\n    public void afterExitScope(NodeTraversal t, ReferenceMap referenceMap) {\n      for (Iterator<Var> it = t.getScope().getVars(); it.hasNext();) {\n        Var v = it.next();\n\n        if (isVarInlineForbidden(v)) {\n            continue;\n        }\n\n        ReferenceCollection referenceInfo = referenceMap.getReferences(v);\n\n        if (isInlinableObject(referenceInfo.references)) {\n            // Blacklist the object itself, as well as any other values\n            // that it refers to, since they will have been moved around.\n            staleVars.add(v);\n\n            Reference declaration = referenceInfo.references.get(0);\n            Reference init = referenceInfo.getInitializingReference();\n\n            // Split up the object into individual variables if the object\n            // is never referenced directly in full.\n            splitObject(v, declaration, init, referenceInfo);\n        }\n      }\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "InliningBehavior.isVarInlineForbidden",
    "class_name": "com.google.javascript.jscomp.InlineObjectLiterals$InliningBehavior",
    "signature": "com.google.javascript.jscomp.InlineObjectLiterals$InliningBehavior.isVarInlineForbidden(Var)",
    "snippet": "    private boolean isVarInlineForbidden(Var var) {\n      // A variable may not be inlined if:\n      // 1) The variable is defined in the externs\n      // 2) The variable is exported,\n      // 3) Don't inline the special RENAME_PROPERTY_FUNCTION_NAME\n      // 4) A reference to the variable has been inlined. We're downstream\n      //    of the mechanism that creates variable references, so we don't\n      //    have a good way to update the reference. Just punt on it.\n\n      // Additionally, exclude global variables for now.\n\n      return var.isGlobal()\n          || var.isExtern()\n          || compiler.getCodingConvention().isExported(var.name)\n          || RenameProperties.RENAME_PROPERTY_FUNCTION_NAME.equals(var.name)\n          || staleVars.contains(var);\n    }",
    "comment": " Whether the given variable is forbidden from being inlined. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "InlineVariables.InlineVariables",
    "class_name": "com.google.javascript.jscomp.InlineVariables",
    "signature": "com.google.javascript.jscomp.InlineVariables.InlineVariables(AbstractCompiler,Mode,boolean)",
    "snippet": "  InlineVariables(\n      AbstractCompiler compiler,\n      Mode mode,\n      boolean inlineAllStrings) {\n    this.compiler = compiler;\n    this.mode = mode;\n    this.inlineAllStrings = inlineAllStrings;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "InlineVariables.getFilterForMode",
    "class_name": "com.google.javascript.jscomp.InlineVariables",
    "signature": "com.google.javascript.jscomp.InlineVariables.getFilterForMode()",
    "snippet": "  private Predicate<Var> getFilterForMode() {\n    switch (mode) {\n      case ALL:\n        return Predicates.<Var>alwaysTrue();\n      case LOCALS_ONLY:\n        return new IdentifyLocals();\n      case CONSTANTS_ONLY:\n        return new IdentifyConstants();\n      default:\n        throw new IllegalStateException();\n    }\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "InlineVariables.process",
    "class_name": "com.google.javascript.jscomp.InlineVariables",
    "signature": "com.google.javascript.jscomp.InlineVariables.process(Node,Node)",
    "snippet": "  @Override\n  public void process(Node externs, Node root) {\n    ReferenceCollectingCallback callback = new ReferenceCollectingCallback(\n        compiler, new InliningBehavior(), getFilterForMode());\n    callback.process(externs, root);\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "IdentifyLocals.apply",
    "class_name": "com.google.javascript.jscomp.InlineVariables$IdentifyLocals",
    "signature": "com.google.javascript.jscomp.InlineVariables$IdentifyLocals.apply(Var)",
    "snippet": "    @Override\n    public boolean apply(Var var) {\n      return var.scope.isLocal();\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "InliningBehavior.afterExitScope",
    "class_name": "com.google.javascript.jscomp.InlineVariables$InliningBehavior",
    "signature": "com.google.javascript.jscomp.InlineVariables$InliningBehavior.afterExitScope(NodeTraversal,ReferenceMap)",
    "snippet": "    @Override\n    public void afterExitScope(NodeTraversal t, ReferenceMap referenceMap) {\n      collectAliasCandidates(t, referenceMap);\n      doInlinesForScope(t, referenceMap);\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "InliningBehavior.collectAliasCandidates",
    "class_name": "com.google.javascript.jscomp.InlineVariables$InliningBehavior",
    "signature": "com.google.javascript.jscomp.InlineVariables$InliningBehavior.collectAliasCandidates(NodeTraversal,ReferenceMap)",
    "snippet": "    private void collectAliasCandidates(NodeTraversal t,\n        ReferenceMap referenceMap) {\n      if (mode != Mode.CONSTANTS_ONLY) {\n        for (Iterator<Var> it = t.getScope().getVars(); it.hasNext();) {\n          Var v = it.next();\n          ReferenceCollection referenceInfo = referenceMap.getReferences(v);\n\n          // NOTE(nicksantos): Don't handle variables that are never used.\n          // The tests are much easier to write if you don't, and there's\n          // another pass that handles unused variables much more elegantly.\n          if (referenceInfo != null && referenceInfo.references.size() >= 2 &&\n              referenceInfo.isWellDefined() &&\n              referenceInfo.isAssignedOnceInLifetime()) {\n            Reference init = referenceInfo.getInitializingReference();\n            Node value = init.getAssignedValue();\n            if (value != null && value.getType() == Token.NAME) {\n              aliasCandidates.put(value, new AliasCandidate(v, referenceInfo));\n            }\n          }\n        }\n      }\n    }",
    "comment": " If any of the variables are well-defined and alias other variables, mark them as aliasing candidates. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "InliningBehavior.doInlinesForScope",
    "class_name": "com.google.javascript.jscomp.InlineVariables$InliningBehavior",
    "signature": "com.google.javascript.jscomp.InlineVariables$InliningBehavior.doInlinesForScope(NodeTraversal,ReferenceMap)",
    "snippet": "    private void doInlinesForScope(NodeTraversal t, ReferenceMap referenceMap) {\n\n      boolean maybeModifiedArguments =\n          maybeEscapedOrModifiedArguments(t.getScope(), referenceMap);\n      for (Iterator<Var> it = t.getScope().getVars(); it.hasNext();) {\n        Var v = it.next();\n\n        ReferenceCollection referenceInfo = referenceMap.getReferences(v);\n\n        // referenceInfo will be null if we're in constants-only mode\n        // and the variable is not a constant.\n        if (referenceInfo == null || isVarInlineForbidden(v)) {\n          // Never try to inline exported variables or variables that\n          // were not collected or variables that have already been inlined.\n          continue;\n        } else if (isInlineableDeclaredConstant(v, referenceInfo)) {\n          Reference init = referenceInfo.getInitializingReferenceForConstants();\n          Node value = init.getAssignedValue();\n          inlineDeclaredConstant(v, value, referenceInfo.references);\n          staleVars.add(v);\n        } else if (mode == Mode.CONSTANTS_ONLY) {\n          // If we're in constants-only mode, don't run more aggressive\n          // inlining heuristics. See InlineConstantsTest.\n          continue;\n        } else {\n          inlineNonConstants(v, referenceInfo, maybeModifiedArguments);\n        }\n      }\n    }",
    "comment": " For all variables in this scope, see if they are only used once. If it looks safe to do so, inline them. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "InliningBehavior.isVarInlineForbidden",
    "class_name": "com.google.javascript.jscomp.InlineVariables$InliningBehavior",
    "signature": "com.google.javascript.jscomp.InlineVariables$InliningBehavior.isVarInlineForbidden(Var)",
    "snippet": "    private boolean isVarInlineForbidden(Var var) {\n      // A variable may not be inlined if:\n      // 1) The variable is exported,\n      // 2) A reference to the variable has been inlined. We're downstream\n      //    of the mechanism that creates variable references, so we don't\n      //    have a good way to update the reference. Just punt on it.\n      // 3) Don't inline the special RENAME_PROPERTY_FUNCTION_NAME\n      return var.isExtern()\n          || compiler.getCodingConvention().isExported(var.name)\n          || RenameProperties.RENAME_PROPERTY_FUNCTION_NAME.equals(var.name)\n          || staleVars.contains(var);\n    }",
    "comment": " Whether the given variable is forbidden from being inlined. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "InliningBehavior.maybeEscapedOrModifiedArguments",
    "class_name": "com.google.javascript.jscomp.InlineVariables$InliningBehavior",
    "signature": "com.google.javascript.jscomp.InlineVariables$InliningBehavior.maybeEscapedOrModifiedArguments(Scope,ReferenceMap)",
    "snippet": "    private boolean maybeEscapedOrModifiedArguments(\n        Scope scope, ReferenceMap referenceMap) {\n      if (scope.isLocal()) {\n        Var arguments = scope.getArgumentsVar();\n        ReferenceCollection refs = referenceMap.getReferences(arguments);\n        if (refs != null && !refs.references.isEmpty()) {\n          for (Reference ref : refs.references) {\n            Node refNode = ref.getNode();\n            Node refParent = ref.getParent();\n            // Any reference that is not a read of the arguments property\n            // consider a escape of the arguments object.\n            if (!(NodeUtil.isGet(refParent)\n                && refNode == ref.getParent().getFirstChild()\n                && !isLValue(refParent))) {\n              return true;\n            }\n          }\n        }\n      }\n      return false;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "JSError.format",
    "class_name": "com.google.javascript.jscomp.JSError",
    "signature": "com.google.javascript.jscomp.JSError.format(CheckLevel,MessageFormatter)",
    "snippet": "  public String format(CheckLevel level, MessageFormatter formatter) {\n    switch (level) {\n      case ERROR:\n        return formatter.formatError(this);\n\n      case WARNING:\n        return formatter.formatWarning(this);\n\n      default:\n        return null;\n    }\n  }",
    "comment": " Format a message at the given level.  @return the formatted message or {@code null} ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "JSError.getCharno",
    "class_name": "com.google.javascript.jscomp.JSError",
    "signature": "com.google.javascript.jscomp.JSError.getCharno()",
    "snippet": "  public int getCharno() {\n    return charno;\n  }",
    "comment": " Get the character number. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "JSError.getType",
    "class_name": "com.google.javascript.jscomp.JSError",
    "signature": "com.google.javascript.jscomp.JSError.getType()",
    "snippet": "  public DiagnosticType getType() {\n    return type;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "JSError.make",
    "class_name": "com.google.javascript.jscomp.JSError",
    "signature": "com.google.javascript.jscomp.JSError.make(String,Node,DiagnosticType,String[])",
    "snippet": "  public static JSError make(String sourceName, Node n,\n                             DiagnosticType type, String... arguments) {\n    return new JSError(sourceName, n, type, arguments);\n  }",
    "comment": " Creates a JSError from a file and Node position.  @param sourceName The source file name @param n Determines the line and char position within the source file name @param type The DiagnosticType @param arguments Arguments to be incorporated into the message ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "JSError.make",
    "class_name": "com.google.javascript.jscomp.JSError",
    "signature": "com.google.javascript.jscomp.JSError.make(String,int,int,DiagnosticType,String[])",
    "snippet": "  public static JSError make(String sourceName, int lineno, int charno,\n                             DiagnosticType type, String... arguments) {\n    return new JSError(sourceName, null, lineno, charno, type, null, arguments);\n  }",
    "comment": " Creates a JSError at a given source location  @param sourceName The source file name @param lineno Line number with source file, or -1 if unknown @param charno Column number within line, or -1 for whole line. @param type The DiagnosticType @param arguments Arguments to be incorporated into the message ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "JSError.toString",
    "class_name": "com.google.javascript.jscomp.JSError",
    "signature": "com.google.javascript.jscomp.JSError.toString()",
    "snippet": "  @Override\n  public String toString() {\n    // TODO(user): remove custom toString.\n    return type.key + \". \" + description + \" at \" +\n      (sourceName != null && sourceName.length() > 0 ?\n       sourceName : \"(unknown source)\") + \" line \" +\n      (lineNumber != -1 ? String.valueOf(lineNumber) : \"(unknown line)\") +\n      \" : \" + (charno != -1 ? String.valueOf(charno) : \"(unknown column)\");\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "JSModule.JSModule",
    "class_name": "com.google.javascript.jscomp.JSModule",
    "signature": "com.google.javascript.jscomp.JSModule.JSModule(String)",
    "snippet": "  public JSModule(String name) {\n    this.name = name;\n    this.depth = -1;\n  }",
    "comment": " Creates an instance.  @param name A unique name for the module ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "JSModule.add",
    "class_name": "com.google.javascript.jscomp.JSModule",
    "signature": "com.google.javascript.jscomp.JSModule.add(CompilerInput)",
    "snippet": "  public void add(CompilerInput input) {\n    inputs.add(input);\n    input.setModule(this);\n  }",
    "comment": "Adds a source code input to this module. */",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "JSModule.add",
    "class_name": "com.google.javascript.jscomp.JSModule",
    "signature": "com.google.javascript.jscomp.JSModule.add(JSSourceFile)",
    "snippet": "  public void add(JSSourceFile file) {\n    add(new CompilerInput(file));\n  }",
    "comment": "Adds a source file input to this module. */",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "JSModule.getInputs",
    "class_name": "com.google.javascript.jscomp.JSModule",
    "signature": "com.google.javascript.jscomp.JSModule.getInputs()",
    "snippet": "  public List<CompilerInput> getInputs() {\n    return inputs;\n  }",
    "comment": " Gets this module's list of source code inputs.  @return A list that may be empty but not null ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "JSSourceFile.fromCode",
    "class_name": "com.google.javascript.jscomp.JSSourceFile",
    "signature": "com.google.javascript.jscomp.JSSourceFile.fromCode(String,String)",
    "snippet": "  public static JSSourceFile fromCode(String fileName, String code) {\n    return new JSSourceFile(SourceFile.fromCode(fileName, code));\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "JSSourceFile.getCode",
    "class_name": "com.google.javascript.jscomp.JSSourceFile",
    "signature": "com.google.javascript.jscomp.JSSourceFile.getCode()",
    "snippet": "  @Override\n  public String getCode() throws IOException {\n    return referenced.getCode();\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "BinaryJoinOp.apply",
    "class_name": "com.google.javascript.jscomp.JoinOp$BinaryJoinOp",
    "signature": "com.google.javascript.jscomp.JoinOp$BinaryJoinOp.apply(L,L)",
    "snippet": "    abstract L apply(L latticeA, L latticeB);",
    "comment": " Creates a new lattice that will be the join of two input lattices.  @return The join of {@code latticeA} and {@code latticeB}. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "BinaryJoinOp.apply",
    "class_name": "com.google.javascript.jscomp.JoinOp$BinaryJoinOp",
    "signature": "com.google.javascript.jscomp.JoinOp$BinaryJoinOp.apply(List)",
    "snippet": "    @Override\n    public final L apply(List<L> values) {\n      Preconditions.checkArgument(!values.isEmpty());\n      int size = values.size();\n      if (size == 1) {\n        return values.get(0);\n      } else if (size == 2) {\n        return apply(values.get(0), values.get(1));\n      } else {\n        int mid = computeMidPoint(size);\n        return apply(\n            apply(values.subList(0, mid)),\n            apply(values.subList(mid, size)));\n      }\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "JsAst.JsAst",
    "class_name": "com.google.javascript.jscomp.JsAst",
    "signature": "com.google.javascript.jscomp.JsAst.JsAst(SourceFile)",
    "snippet": "  public JsAst(SourceFile sourceFile) {\n    this.sourceFile = sourceFile;\n    this.fileName = sourceFile.getName();\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "JsAst.getAstRoot",
    "class_name": "com.google.javascript.jscomp.JsAst",
    "signature": "com.google.javascript.jscomp.JsAst.getAstRoot(AbstractCompiler)",
    "snippet": "  @Override\n  public Node getAstRoot(AbstractCompiler compiler) {\n    if (root == null) {\n      parse(compiler);\n    }\n    return root;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "JsAst.getSourceFile",
    "class_name": "com.google.javascript.jscomp.JsAst",
    "signature": "com.google.javascript.jscomp.JsAst.getSourceFile()",
    "snippet": "  @Override\n  public SourceFile getSourceFile() {\n    return sourceFile;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "JsAst.parse",
    "class_name": "com.google.javascript.jscomp.JsAst",
    "signature": "com.google.javascript.jscomp.JsAst.parse(AbstractCompiler)",
    "snippet": "  private void parse(AbstractCompiler compiler) {\n    try {\n      logger_.fine(\"Parsing: \" + sourceFile.getName());\n      root = ParserRunner.parse(sourceFile, sourceFile.getCode(),\n          compiler.getParserConfig(),\n          compiler.getDefaultErrorReporter(),\n          logger_);\n    } catch (IOException e) {\n      compiler.report(\n          JSError.make(AbstractCompiler.READ_ERROR, sourceFile.getName()));\n    }\n\n    if (root == null || compiler.hasHaltingErrors()) {\n      // There was a parse error or IOException, so use a dummy block.\n      root = new Node(Token.BLOCK);\n    } else {\n      compiler.prepareAst(root);\n    }\n\n    // Set the source name so that the compiler passes can track\n    // the source file and module.\n    root.setStaticSourceFile(sourceFile);\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "LightweightMessageFormatter.LightweightMessageFormatter",
    "class_name": "com.google.javascript.jscomp.LightweightMessageFormatter",
    "signature": "com.google.javascript.jscomp.LightweightMessageFormatter.LightweightMessageFormatter(SourceExcerptProvider)",
    "snippet": "  public LightweightMessageFormatter(SourceExcerptProvider source) {\n    this(source, LINE);\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "LightweightMessageFormatter.LightweightMessageFormatter",
    "class_name": "com.google.javascript.jscomp.LightweightMessageFormatter",
    "signature": "com.google.javascript.jscomp.LightweightMessageFormatter.LightweightMessageFormatter(SourceExcerptProvider,SourceExcerpt)",
    "snippet": "  public LightweightMessageFormatter(SourceExcerptProvider source,\n      SourceExcerpt excerpt) {\n    super(source);\n    Preconditions.checkNotNull(source);\n    this.excerpt = excerpt;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "LightweightMessageFormatter.format",
    "class_name": "com.google.javascript.jscomp.LightweightMessageFormatter",
    "signature": "com.google.javascript.jscomp.LightweightMessageFormatter.format(JSError,boolean)",
    "snippet": "  private String format(JSError error, boolean warning) {\n    // extract source excerpt\n    SourceExcerptProvider source = getSource();\n    String sourceExcerpt = source == null ? null :\n        excerpt.get(\n            source, error.sourceName, error.lineNumber, excerptFormatter);\n\n    // formatting the message\n    StringBuilder b = new StringBuilder();\n    if (error.sourceName != null) {\n      b.append(error.sourceName);\n      if (error.lineNumber > 0) {\n        b.append(':');\n        b.append(error.lineNumber);\n      }\n      b.append(\": \");\n    }\n\n    b.append(getLevelName(warning ? CheckLevel.WARNING : CheckLevel.ERROR));\n    b.append(\" - \");\n\n    b.append(error.description);\n    b.append('\\n');\n    if (sourceExcerpt != null) {\n      b.append(sourceExcerpt);\n      b.append('\\n');\n      int charno = error.getCharno();\n\n      // padding equal to the excerpt and arrow at the end\n      // charno == sourceExpert.length() means something is missing\n      // at the end of the line\n      if (excerpt.equals(LINE)\n          && 0 <= charno && charno <= sourceExcerpt.length()) {\n        for (int i = 0; i < charno; i++) {\n          char c = sourceExcerpt.charAt(i);\n          if (Character.isWhitespace(c)) {\n            b.append(c);\n          } else {\n            b.append(' ');\n          }\n        }\n        b.append(\"^\\n\");\n      }\n    }\n    return b.toString();\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "LightweightMessageFormatter.formatWarning",
    "class_name": "com.google.javascript.jscomp.LightweightMessageFormatter",
    "signature": "com.google.javascript.jscomp.LightweightMessageFormatter.formatWarning(JSError)",
    "snippet": "  public String formatWarning(JSError warning) {\n    return format(warning, true);\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "LineNumberingFormatter.formatLine",
    "class_name": "com.google.javascript.jscomp.LightweightMessageFormatter$LineNumberingFormatter",
    "signature": "com.google.javascript.jscomp.LightweightMessageFormatter$LineNumberingFormatter.formatLine(String,int)",
    "snippet": "    public String formatLine(String line, int lineNumber) {\n      return line;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "LinkedFlowScope.LinkedFlowScope",
    "class_name": "com.google.javascript.jscomp.LinkedFlowScope",
    "signature": "com.google.javascript.jscomp.LinkedFlowScope.LinkedFlowScope(FlatFlowScopeCache)",
    "snippet": "  LinkedFlowScope(FlatFlowScopeCache cache) {\n    this(cache, null);\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "LinkedFlowScope.LinkedFlowScope",
    "class_name": "com.google.javascript.jscomp.LinkedFlowScope",
    "signature": "com.google.javascript.jscomp.LinkedFlowScope.LinkedFlowScope(LinkedFlowScope)",
    "snippet": "  LinkedFlowScope(LinkedFlowScope directParent) {\n    this(directParent.cache, directParent);\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "LinkedFlowScope.createChildFlowScope",
    "class_name": "com.google.javascript.jscomp.LinkedFlowScope",
    "signature": "com.google.javascript.jscomp.LinkedFlowScope.createChildFlowScope()",
    "snippet": "  @Override\n  public FlowScope createChildFlowScope() {\n    frozen = true;\n\n    if (depth > MAX_DEPTH) {\n      if (flattened == null) {\n        flattened = new FlatFlowScopeCache(this);\n      }\n      return new LinkedFlowScope(flattened);\n    }\n\n    return new LinkedFlowScope(this);\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "LinkedFlowScope.createEntryLattice",
    "class_name": "com.google.javascript.jscomp.LinkedFlowScope",
    "signature": "com.google.javascript.jscomp.LinkedFlowScope.createEntryLattice(Scope)",
    "snippet": "  public static LinkedFlowScope createEntryLattice(Scope scope) {\n    return new LinkedFlowScope(new FlatFlowScopeCache(scope));\n  }",
    "comment": " Creates an entry lattice for the flow. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "LinkedFlowScope.equals",
    "class_name": "com.google.javascript.jscomp.LinkedFlowScope",
    "signature": "com.google.javascript.jscomp.LinkedFlowScope.equals(Object)",
    "snippet": "  @Override\n  public boolean equals(Object other) {\n    if (other instanceof LinkedFlowScope) {\n      LinkedFlowScope that = (LinkedFlowScope) other;\n      if (this.optimize() == that.optimize()) {\n        return true;\n      }\n\n      // If two flow scopes are in the same function, then they could have\n      // two possible function scopes: the real one and the BOTTOM scope.\n      // If they have different function scopes, we *should* iterate thru all\n      // the variables in each scope and compare. However, 99.9% of the time,\n      // they're not equal. And the other .1% of the time, we can pretend\n      // they're equal--this just means that data flow analysis will have\n      // to propagate the entry lattice a little bit further than it\n      // really needs to. Everything will still come out ok.\n      if (this.getFunctionScope() != that.getFunctionScope()) {\n        return false;\n      }\n\n      if (cache == that.cache) {\n        // If the two flow scopes have the same cache, then we can check\n        // equality a lot faster: by just looking at the \"dirty\" elements\n        // in the cache, and comparing them in both scopes.\n        for (String name : cache.dirtySymbols) {\n          if (diffSlots(getSlot(name), that.getSlot(name))) {\n            return false;\n          }\n        }\n\n        return true;\n      }\n\n      Map<String, StaticSlot<JSType>> myFlowSlots = allFlowSlots();\n      Map<String, StaticSlot<JSType>> otherFlowSlots = that.allFlowSlots();\n\n      for (StaticSlot<JSType> slot : myFlowSlots.values()) {\n        if (diffSlots(slot, otherFlowSlots.get(slot.getName()))) {\n          return false;\n        }\n        otherFlowSlots.remove(slot.getName());\n      }\n      for (StaticSlot<JSType> slot : otherFlowSlots.values()) {\n        if (diffSlots(slot, myFlowSlots.get(slot.getName()))) {\n          return false;\n        }\n      }\n      return true;\n    }\n    return false;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "LinkedFlowScope.getFunctionScope",
    "class_name": "com.google.javascript.jscomp.LinkedFlowScope",
    "signature": "com.google.javascript.jscomp.LinkedFlowScope.getFunctionScope()",
    "snippet": "  private Scope getFunctionScope() {\n    return cache.functionScope;\n  }",
    "comment": "Gets the function scope for this flow scope. */",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "LinkedFlowScope.getSlot",
    "class_name": "com.google.javascript.jscomp.LinkedFlowScope",
    "signature": "com.google.javascript.jscomp.LinkedFlowScope.getSlot(String)",
    "snippet": "  public StaticSlot<JSType> getSlot(String name) {\n    if (cache.dirtySymbols.contains(name)) {\n      for (LinkedFlowSlot slot = lastSlot;\n           slot != null; slot = slot.parent) {\n        if (slot.getName().equals(name)) {\n          return slot;\n        }\n      }\n    }\n    return cache.getSlot(name);\n  }",
    "comment": " Get the slot for the given symbol. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "LinkedFlowScope.getTypeOfThis",
    "class_name": "com.google.javascript.jscomp.LinkedFlowScope",
    "signature": "com.google.javascript.jscomp.LinkedFlowScope.getTypeOfThis()",
    "snippet": "  @Override\n  public JSType getTypeOfThis() {\n    return cache.functionScope.getTypeOfThis();\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "LinkedFlowScope.inferQualifiedSlot",
    "class_name": "com.google.javascript.jscomp.LinkedFlowScope",
    "signature": "com.google.javascript.jscomp.LinkedFlowScope.inferQualifiedSlot(String,JSType,JSType)",
    "snippet": "  @Override\n  public void inferQualifiedSlot(String symbol, JSType bottomType,\n      JSType inferredType) {\n    Scope functionScope = getFunctionScope();\n    if (functionScope.isLocal()) {\n      if (functionScope.getVar(symbol) == null && !functionScope.isBottom()) {\n        // When we enter a local scope, many qualified names are\n        // already defined even if they haven't been declared in the Scope\n        // object. If the name has not yet been defined in this scope, we\n        // need to define it now before we refine it.\n        functionScope.declare(symbol, null, bottomType, null);\n      }\n\n      inferSlotType(symbol, inferredType);\n    }\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "LinkedFlowScope.inferSlotType",
    "class_name": "com.google.javascript.jscomp.LinkedFlowScope",
    "signature": "com.google.javascript.jscomp.LinkedFlowScope.inferSlotType(String,JSType)",
    "snippet": "  @Override\n  public void inferSlotType(String symbol, JSType type) {\n    Preconditions.checkState(!frozen);\n    lastSlot = new LinkedFlowSlot(symbol, type, lastSlot);\n    depth++;\n    cache.dirtySymbols.add(symbol);\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "LinkedFlowScope.optimize",
    "class_name": "com.google.javascript.jscomp.LinkedFlowScope",
    "signature": "com.google.javascript.jscomp.LinkedFlowScope.optimize()",
    "snippet": "  @Override\n  public LinkedFlowScope optimize() {\n    LinkedFlowScope current;\n    for (current = this;\n         current.parent != null &&\n             current.lastSlot == current.parent.lastSlot;\n         current = current.parent) {}\n    return current;\n  }",
    "comment": "a findUniqueRefinedSlot on it.",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "FlatFlowScopeCache.getSlot",
    "class_name": "com.google.javascript.jscomp.LinkedFlowScope$FlatFlowScopeCache",
    "signature": "com.google.javascript.jscomp.LinkedFlowScope$FlatFlowScopeCache.getSlot(String)",
    "snippet": "    public StaticSlot<JSType> getSlot(String name) {\n      if (symbols.containsKey(name)) {\n        return symbols.get(name);\n      } else {\n        return functionScope.getSlot(name);\n      }\n    }",
    "comment": " Get the slot for the given symbol. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "FlowScopeJoinOp.apply",
    "class_name": "com.google.javascript.jscomp.LinkedFlowScope$FlowScopeJoinOp",
    "signature": "com.google.javascript.jscomp.LinkedFlowScope$FlowScopeJoinOp.apply(FlowScope,FlowScope)",
    "snippet": "    @SuppressWarnings(\"unchecked\")\n    @Override\n    public FlowScope apply(FlowScope a, FlowScope b) {\n      // To join the two scopes, we have to\n      LinkedFlowScope linkedA = (LinkedFlowScope) a;\n      LinkedFlowScope linkedB = (LinkedFlowScope) b;\n      linkedA.frozen = true;\n      linkedB.frozen = true;\n      if (linkedA.optimize() == linkedB.optimize()) {\n        return linkedA.createChildFlowScope();\n      }\n      return new LinkedFlowScope(new FlatFlowScopeCache(linkedA, linkedB));\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "LiveVariablesAnalysis.LiveVariablesAnalysis",
    "class_name": "com.google.javascript.jscomp.LiveVariablesAnalysis",
    "signature": "com.google.javascript.jscomp.LiveVariablesAnalysis.LiveVariablesAnalysis(ControlFlowGraph,Scope,AbstractCompiler)",
    "snippet": "  LiveVariablesAnalysis(ControlFlowGraph<Node> cfg, Scope jsScope,\n      AbstractCompiler compiler) {\n    super(cfg, new LiveVariableJoinOp());\n    this.jsScope = jsScope;\n    this.escaped = Sets.newHashSet();\n    computeEscaped(jsScope, escaped, compiler);\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "LiveVariablesAnalysis.computeGenKill",
    "class_name": "com.google.javascript.jscomp.LiveVariablesAnalysis",
    "signature": "com.google.javascript.jscomp.LiveVariablesAnalysis.computeGenKill(Node,BitSet,BitSet,boolean)",
    "snippet": "  private void computeGenKill(Node n, BitSet gen, BitSet kill,\n      boolean conditional) {\n\n    switch (n.getType()) {\n      case Token.SCRIPT:\n      case Token.BLOCK:\n      case Token.FUNCTION:\n        return;\n\n      case Token.WHILE:\n      case Token.DO:\n      case Token.IF:\n        computeGenKill(NodeUtil.getConditionExpression(n), gen, kill,\n            conditional);\n        return;\n\n      case Token.FOR:\n        if (!NodeUtil.isForIn(n)) {\n          computeGenKill(NodeUtil.getConditionExpression(n), gen, kill,\n              conditional);\n        } else {\n          // for(x in y) {...}\n          Node lhs = n.getFirstChild();\n          Node rhs = lhs.getNext();\n          if (NodeUtil.isVar(lhs)) {\n            // for(var x in y) {...}\n            lhs = lhs.getLastChild();\n          }\n          addToSetIfLocal(lhs, kill);\n          addToSetIfLocal(lhs, gen);\n          computeGenKill(rhs, gen, kill, conditional);\n        }\n        return;\n\n      case Token.VAR:\n        for (Node c = n.getFirstChild(); c != null; c = c.getNext()) {\n          if (c.hasChildren()) {\n            computeGenKill(c.getFirstChild(), gen, kill, conditional);\n            if (!conditional) {\n              addToSetIfLocal(c, kill);\n            }\n          }\n        }\n        return;\n\n      case Token.AND:\n      case Token.OR:\n        computeGenKill(n.getFirstChild(), gen, kill, conditional);\n        // May short circuit.\n        computeGenKill(n.getLastChild(), gen, kill, true);\n        return;\n\n      case Token.HOOK:\n        computeGenKill(n.getFirstChild(), gen, kill, conditional);\n        // Assume both sides are conditional.\n        computeGenKill(n.getFirstChild().getNext(), gen, kill, true);\n        computeGenKill(n.getLastChild(), gen, kill, true);\n        return;\n\n      case Token.NAME:\n        if (isArgumentsName(n)) {\n          markAllParametersEscaped();\n        } else {\n          addToSetIfLocal(n, gen);\n        }\n        return;\n\n      default:\n        if (NodeUtil.isAssignmentOp(n) && NodeUtil.isName(n.getFirstChild())) {\n          Node lhs = n.getFirstChild();\n          if (!conditional) {\n            addToSetIfLocal(lhs, kill);\n          }\n          if (!NodeUtil.isAssign(n)) {\n            // assignments such as a += 1 reads a.\n            addToSetIfLocal(lhs, gen);\n          }\n          computeGenKill(lhs.getNext(), gen, kill, conditional);\n        } else {\n          for (Node c = n.getFirstChild(); c != null; c = c.getNext()) {\n            computeGenKill(c, gen, kill, conditional);\n          }\n        }\n        return;\n    }\n  }",
    "comment": " Computes the GEN and KILL set.  @param n Root node. @param gen Local variables that are live because of the instruction at {@code n} will be added to this set. @param kill Local variables that are killed because of the instruction at {@code n} will be added to this set. @param conditional {@code true} if any assignments encountered are conditionally executed. These assignments might not kill a variable. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "LiveVariablesAnalysis.createEntryLattice",
    "class_name": "com.google.javascript.jscomp.LiveVariablesAnalysis",
    "signature": "com.google.javascript.jscomp.LiveVariablesAnalysis.createEntryLattice()",
    "snippet": "  @Override\n  LiveVariableLattice createEntryLattice() {\n    return new LiveVariableLattice(jsScope.getVarCount());\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "LiveVariablesAnalysis.createInitialEstimateLattice",
    "class_name": "com.google.javascript.jscomp.LiveVariablesAnalysis",
    "signature": "com.google.javascript.jscomp.LiveVariablesAnalysis.createInitialEstimateLattice()",
    "snippet": "  @Override\n  LiveVariableLattice createInitialEstimateLattice() {\n    return new LiveVariableLattice(jsScope.getVarCount());\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "LiveVariablesAnalysis.flowThrough",
    "class_name": "com.google.javascript.jscomp.LiveVariablesAnalysis",
    "signature": "com.google.javascript.jscomp.LiveVariablesAnalysis.flowThrough(Node,LiveVariableLattice)",
    "snippet": "  @Override\n  LiveVariableLattice flowThrough(Node node, LiveVariableLattice input) {\n    final BitSet gen = new BitSet(input.liveSet.size());\n    final BitSet kill = new BitSet(input.liveSet.size());\n\n    // Make kills conditional if the node can end abruptly by an exception.\n    boolean conditional = false;\n    List<DiGraphEdge<Node, Branch>> edgeList = getCfg().getOutEdges(node);\n    for (DiGraphEdge<Node, Branch> edge : edgeList) {\n      if (Branch.ON_EX.equals(edge.getValue())) {\n        conditional = true;\n      }\n    }\n    computeGenKill(node, gen, kill, conditional);\n    LiveVariableLattice result = new LiveVariableLattice(input);\n    // L_in = L_out - Kill + Gen\n    result.liveSet.andNot(kill);\n    result.liveSet.or(gen);\n    return result;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "LiveVariablesAnalysis.getEscapedLocals",
    "class_name": "com.google.javascript.jscomp.LiveVariablesAnalysis",
    "signature": "com.google.javascript.jscomp.LiveVariablesAnalysis.getEscapedLocals()",
    "snippet": "  public Set<Var> getEscapedLocals() {\n    return escaped;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "LiveVariablesAnalysis.isForward",
    "class_name": "com.google.javascript.jscomp.LiveVariablesAnalysis",
    "signature": "com.google.javascript.jscomp.LiveVariablesAnalysis.isForward()",
    "snippet": "  @Override\n  boolean isForward() {\n    return false;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "LiveVariableLattice.equals",
    "class_name": "com.google.javascript.jscomp.LiveVariablesAnalysis$LiveVariableLattice",
    "signature": "com.google.javascript.jscomp.LiveVariablesAnalysis$LiveVariableLattice.equals(Object)",
    "snippet": "    @Override\n    public boolean equals(Object other) {\n      Preconditions.checkNotNull(other);\n      return (other instanceof LiveVariableLattice) &&\n          this.liveSet.equals(((LiveVariableLattice) other).liveSet);\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "MakeDeclaredNamesUnique.MakeDeclaredNamesUnique",
    "class_name": "com.google.javascript.jscomp.MakeDeclaredNamesUnique",
    "signature": "com.google.javascript.jscomp.MakeDeclaredNamesUnique.MakeDeclaredNamesUnique()",
    "snippet": "  MakeDeclaredNamesUnique() {\n    this(new ContextualRenamer());\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "MakeDeclaredNamesUnique.MakeDeclaredNamesUnique",
    "class_name": "com.google.javascript.jscomp.MakeDeclaredNamesUnique",
    "signature": "com.google.javascript.jscomp.MakeDeclaredNamesUnique.MakeDeclaredNamesUnique(Renamer)",
    "snippet": "  MakeDeclaredNamesUnique(Renamer renamer) {\n    this.rootRenamer = renamer;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "MakeDeclaredNamesUnique.enterScope",
    "class_name": "com.google.javascript.jscomp.MakeDeclaredNamesUnique",
    "signature": "com.google.javascript.jscomp.MakeDeclaredNamesUnique.enterScope(NodeTraversal)",
    "snippet": "  @Override\n  public void enterScope(NodeTraversal t) {\n    Node declarationRoot = t.getScopeRoot();\n    Renamer renamer;\n    if (nameStack.isEmpty()) {\n      // If the contextual renamer is being used the starting context can not\n      // be a function.\n      Preconditions.checkState(\n          declarationRoot.getType() != Token.FUNCTION ||\n          !(rootRenamer instanceof ContextualRenamer));\n      Preconditions.checkState(t.inGlobalScope());\n      renamer = rootRenamer;\n    } else {\n      renamer = nameStack.peek().forChildScope();\n    }\n\n    if (declarationRoot.getType() == Token.FUNCTION) {\n      // Add the function parameters\n      Node fnParams = declarationRoot.getFirstChild().getNext();\n      for (Node c = fnParams.getFirstChild(); c != null; c = c.getNext()) {\n        String name = c.getString();\n        renamer.addDeclaredName(name);\n      }\n\n      // Add the function body declarations\n      Node functionBody = declarationRoot.getLastChild();\n      findDeclaredNames(functionBody, null, renamer);\n    } else {\n      // Add the block declarations\n      findDeclaredNames(declarationRoot, null, renamer);\n    }\n    nameStack.push(renamer);\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "MakeDeclaredNamesUnique.exitScope",
    "class_name": "com.google.javascript.jscomp.MakeDeclaredNamesUnique",
    "signature": "com.google.javascript.jscomp.MakeDeclaredNamesUnique.exitScope(NodeTraversal)",
    "snippet": "  @Override\n  public void exitScope(NodeTraversal t) {\n    if (!t.inGlobalScope()) {\n      nameStack.pop();\n    }\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "MakeDeclaredNamesUnique.findDeclaredNames",
    "class_name": "com.google.javascript.jscomp.MakeDeclaredNamesUnique",
    "signature": "com.google.javascript.jscomp.MakeDeclaredNamesUnique.findDeclaredNames(Node,Node,Renamer)",
    "snippet": "  private void findDeclaredNames(Node n, Node parent, Renamer renamer) {\n    // Do a shallow traversal, so don't traverse into function declarations,\n    // except for the name of the function itself.\n    if (parent == null\n        || parent.getType() != Token.FUNCTION\n        || n == parent.getFirstChild()) {\n      if (NodeUtil.isVarDeclaration(n)) {\n        renamer.addDeclaredName(n.getString());\n      } else if (NodeUtil.isFunctionDeclaration(n)) {\n        Node nameNode = n.getFirstChild();\n        renamer.addDeclaredName(nameNode.getString());\n      }\n\n      for (Node c = n.getFirstChild(); c != null; c = c.getNext()) {\n        findDeclaredNames(c, n, renamer);\n      }\n    }\n  }",
    "comment": " Traverses the current scope and collects declared names.  Does not decent into functions or add CATCH exceptions. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "MakeDeclaredNamesUnique.getContextualRenameInverter",
    "class_name": "com.google.javascript.jscomp.MakeDeclaredNamesUnique",
    "signature": "com.google.javascript.jscomp.MakeDeclaredNamesUnique.getContextualRenameInverter(AbstractCompiler)",
    "snippet": "  static CompilerPass getContextualRenameInverter(AbstractCompiler compiler) {\n    return new ContextualRenameInverter(compiler);\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "MakeDeclaredNamesUnique.getReplacementName",
    "class_name": "com.google.javascript.jscomp.MakeDeclaredNamesUnique",
    "signature": "com.google.javascript.jscomp.MakeDeclaredNamesUnique.getReplacementName(String)",
    "snippet": "  private String getReplacementName(String oldName) {\n    for (Renamer names : nameStack) {\n      String newName = names.getReplacementName(oldName);\n      if (newName != null) {\n        return newName;\n      }\n    }\n    return null;\n  }",
    "comment": " Walks the stack of name maps and finds the replacement name for the current scope. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "MakeDeclaredNamesUnique.shouldTraverse",
    "class_name": "com.google.javascript.jscomp.MakeDeclaredNamesUnique",
    "signature": "com.google.javascript.jscomp.MakeDeclaredNamesUnique.shouldTraverse(NodeTraversal,Node,Node)",
    "snippet": "  @Override\n  public boolean shouldTraverse(NodeTraversal t, Node n, Node parent) {\n\n    switch (n.getType()) {\n      case Token.FUNCTION:\n        {\n          // Add recursive function name, if needed.\n          // NOTE: \"enterScope\" is called after we need to pick up this name.\n          Renamer renamer = nameStack.peek().forChildScope();\n\n          // If needed, add the function recursive name.\n          String name = n.getFirstChild().getString();\n          if (name != null && !name.isEmpty() && parent != null\n              && !NodeUtil.isFunctionDeclaration(n)) {\n            renamer.addDeclaredName(name);\n          }\n\n          nameStack.push(renamer);\n        }\n        break;\n\n      case Token.CATCH:\n        {\n          Renamer renamer = nameStack.peek().forChildScope();\n\n          String name = n.getFirstChild().getString();\n          renamer.addDeclaredName(name);\n\n          nameStack.push(renamer);\n        }\n        break;\n    }\n\n    return true;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "MakeDeclaredNamesUnique.visit",
    "class_name": "com.google.javascript.jscomp.MakeDeclaredNamesUnique",
    "signature": "com.google.javascript.jscomp.MakeDeclaredNamesUnique.visit(NodeTraversal,Node,Node)",
    "snippet": "  @Override\n  public void visit(NodeTraversal t, Node n, Node parent) {\n    switch (n.getType()) {\n      case Token.NAME:\n        String newName = getReplacementName(n.getString());\n        if (newName != null) {\n          Renamer renamer = nameStack.peek();\n          if (renamer.stripConstIfReplaced()) {\n            // TODO(johnlenz): Do we need to do anything about the javadoc?\n            n.removeProp(Node.IS_CONSTANT_NAME);\n          }\n          n.setString(newName);\n          t.getCompiler().reportCodeChange();\n        }\n        break;\n\n      case Token.FUNCTION:\n        // Remove function recursive name (if any).\n        nameStack.pop();\n        break;\n\n      case Token.CATCH:\n        // Remove catch except name from the stack of names.\n        nameStack.pop();\n        break;\n    }\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "ContextualRenameInverter.enterScope",
    "class_name": "com.google.javascript.jscomp.MakeDeclaredNamesUnique$ContextualRenameInverter",
    "signature": "com.google.javascript.jscomp.MakeDeclaredNamesUnique$ContextualRenameInverter.enterScope(NodeTraversal)",
    "snippet": "    public void enterScope(NodeTraversal t) {\n      if (t.inGlobalScope()) {\n        return;\n      }\n\n      referenceStack.push(referencedNames);\n      referencedNames = Sets.newHashSet();\n    }",
    "comment": " Prepare a set for the new scope. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "ContextualRenameInverter.exitScope",
    "class_name": "com.google.javascript.jscomp.MakeDeclaredNamesUnique$ContextualRenameInverter",
    "signature": "com.google.javascript.jscomp.MakeDeclaredNamesUnique$ContextualRenameInverter.exitScope(NodeTraversal)",
    "snippet": "    public void exitScope(NodeTraversal t) {\n      if (t.inGlobalScope()) {\n        return;\n      }\n\n      for (Iterator<Var> it = t.getScope().getVars(); it.hasNext();) {\n        Var v = it.next();\n        handleScopeVar(v);\n      }\n\n      // Merge any names that were referenced but not declared in the current\n      // scope.\n      Set<String> current = referencedNames;\n      referencedNames = referenceStack.pop();\n      // If there isn't anything left in the stack we will be going into the\n      // global scope: don't try to build a set of referenced names for the\n      // global scope.\n      if (!referenceStack.isEmpty()) {\n        referencedNames.addAll(current);\n      }\n    }",
    "comment": " Rename vars for the current scope, and merge any referenced names into the parent scope reference set. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "ContextualRenameInverter.process",
    "class_name": "com.google.javascript.jscomp.MakeDeclaredNamesUnique$ContextualRenameInverter",
    "signature": "com.google.javascript.jscomp.MakeDeclaredNamesUnique$ContextualRenameInverter.process(Node,Node)",
    "snippet": "    public void process(Node externs, Node js) {\n      NodeTraversal.traverse(compiler, js, this);\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "ContextualRenameInverter.shouldTraverse",
    "class_name": "com.google.javascript.jscomp.MakeDeclaredNamesUnique$ContextualRenameInverter",
    "signature": "com.google.javascript.jscomp.MakeDeclaredNamesUnique$ContextualRenameInverter.shouldTraverse(NodeTraversal,Node,Node)",
    "snippet": "    @Override\n    public boolean shouldTraverse(NodeTraversal t, Node n, Node parent) {\n      return true;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "ContextualRenameInverter.visit",
    "class_name": "com.google.javascript.jscomp.MakeDeclaredNamesUnique$ContextualRenameInverter",
    "signature": "com.google.javascript.jscomp.MakeDeclaredNamesUnique$ContextualRenameInverter.visit(NodeTraversal,Node,Node)",
    "snippet": "    @Override\n    public void visit(NodeTraversal t, Node node, Node parent) {\n      if (t.inGlobalScope()) {\n        return;\n      }\n\n      if (NodeUtil.isReferenceName(node)) {\n        String name = node.getString();\n        // Add all referenced names to the set so it is possible to check for\n        // conflicts.\n        referencedNames.add(name);\n        // Store only references to candidate names in the node map.\n        if (containsSeparator(name)) {\n          addCandidateNameReference(name, node);\n        }\n      }\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "ContextualRenamer.addDeclaredName",
    "class_name": "com.google.javascript.jscomp.MakeDeclaredNamesUnique$ContextualRenamer",
    "signature": "com.google.javascript.jscomp.MakeDeclaredNamesUnique$ContextualRenamer.addDeclaredName(String)",
    "snippet": "    @Override\n    public void addDeclaredName(String name) {\n      if (!name.equals(ARGUMENTS)) {\n        if (global) {\n          reserveName(name);\n        } else {\n          // It hasn't been declared locally yet, so increment the count.\n          if (!declarations.containsKey(name)) {\n            int id = incrementNameCount(name);\n            String newName = null;\n            if (id != 0) {\n              newName = getUniqueName(name, id);\n            }\n            declarations.put(name, newName);\n          }\n        }\n      }\n    }",
    "comment": " Adds a name to the map of names declared in this scope. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "ContextualRenamer.forChildScope",
    "class_name": "com.google.javascript.jscomp.MakeDeclaredNamesUnique$ContextualRenamer",
    "signature": "com.google.javascript.jscomp.MakeDeclaredNamesUnique$ContextualRenamer.forChildScope()",
    "snippet": "    @Override\n    public Renamer forChildScope() {\n      return new ContextualRenamer(nameUsage);\n    }",
    "comment": " Create a ContextualRenamer ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "ContextualRenamer.getReplacementName",
    "class_name": "com.google.javascript.jscomp.MakeDeclaredNamesUnique$ContextualRenamer",
    "signature": "com.google.javascript.jscomp.MakeDeclaredNamesUnique$ContextualRenamer.getReplacementName(String)",
    "snippet": "    @Override\n    public String getReplacementName(String oldName) {\n      return declarations.get(oldName);\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "ContextualRenamer.getUniqueName",
    "class_name": "com.google.javascript.jscomp.MakeDeclaredNamesUnique$ContextualRenamer",
    "signature": "com.google.javascript.jscomp.MakeDeclaredNamesUnique$ContextualRenamer.getUniqueName(String,int)",
    "snippet": "    private String getUniqueName(String name, int id) {\n      return name + UNIQUE_ID_SEPARATOR + id;\n    }",
    "comment": " Given a name and the associated id, create a new unique name. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "ContextualRenamer.incrementNameCount",
    "class_name": "com.google.javascript.jscomp.MakeDeclaredNamesUnique$ContextualRenamer",
    "signature": "com.google.javascript.jscomp.MakeDeclaredNamesUnique$ContextualRenamer.incrementNameCount(String)",
    "snippet": "    private int incrementNameCount(String name) {\n      return nameUsage.add(name, 1);\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "ContextualRenamer.reserveName",
    "class_name": "com.google.javascript.jscomp.MakeDeclaredNamesUnique$ContextualRenamer",
    "signature": "com.google.javascript.jscomp.MakeDeclaredNamesUnique$ContextualRenamer.reserveName(String)",
    "snippet": "    private void reserveName(String name) {\n      nameUsage.setCount(name, 0, 1);\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "ContextualRenamer.stripConstIfReplaced",
    "class_name": "com.google.javascript.jscomp.MakeDeclaredNamesUnique$ContextualRenamer",
    "signature": "com.google.javascript.jscomp.MakeDeclaredNamesUnique$ContextualRenamer.stripConstIfReplaced()",
    "snippet": "    @Override\n    public boolean stripConstIfReplaced() {\n      return false;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "MaybeReachingVariableUse.MaybeReachingVariableUse",
    "class_name": "com.google.javascript.jscomp.MaybeReachingVariableUse",
    "signature": "com.google.javascript.jscomp.MaybeReachingVariableUse.MaybeReachingVariableUse(ControlFlowGraph,Scope,AbstractCompiler)",
    "snippet": "  MaybeReachingVariableUse(\n      ControlFlowGraph<Node> cfg, Scope jsScope, AbstractCompiler compiler) {\n    super(cfg, new ReachingUsesJoinOp());\n    this.jsScope = jsScope;\n    this.escaped = Sets.newHashSet();\n\n    // TODO(user): May be comute it somewhere else and re-use the escape\n    // local set here.\n    computeEscaped(jsScope, escaped, compiler);\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "MaybeReachingVariableUse.computeMayUse",
    "class_name": "com.google.javascript.jscomp.MaybeReachingVariableUse",
    "signature": "com.google.javascript.jscomp.MaybeReachingVariableUse.computeMayUse(Node,Node,ReachingUses,boolean)",
    "snippet": "  private void computeMayUse(\n      Node n, Node cfgNode, ReachingUses output, boolean conditional) {\n    switch (n.getType()) {\n\n      case Token.BLOCK:\n      case Token.FUNCTION:\n        return;\n\n      case Token.NAME:\n        addToUseIfLocal(n.getString(), cfgNode, output);\n        return;\n\n      case Token.WHILE:\n      case Token.DO:\n      case Token.IF:\n        computeMayUse(\n            NodeUtil.getConditionExpression(n), cfgNode, output, conditional);\n        return;\n\n      case Token.FOR:\n        if (!NodeUtil.isForIn(n)) {\n          computeMayUse(\n              NodeUtil.getConditionExpression(n), cfgNode, output, conditional);\n        } else {\n          // for(x in y) {...}\n          Node lhs = n.getFirstChild();\n          Node rhs = lhs.getNext();\n          if (NodeUtil.isVar(lhs)) {\n            lhs = lhs.getLastChild(); // for(var x in y) {...}\n          }\n          if (NodeUtil.isName(lhs) && !conditional) {\n            removeFromUseIfLocal(lhs.getString(), output);\n          }\n          computeMayUse(rhs, cfgNode, output, conditional);\n        }\n        return;\n\n      case Token.AND:\n      case Token.OR:\n        computeMayUse(n.getLastChild(), cfgNode, output, true);\n        computeMayUse(n.getFirstChild(), cfgNode, output, conditional);\n        return;\n\n      case Token.HOOK:\n        computeMayUse(n.getLastChild(), cfgNode, output, true);\n        computeMayUse(n.getFirstChild().getNext(), cfgNode, output, true);\n        computeMayUse(n.getFirstChild(), cfgNode, output, conditional);\n        return;\n\n      case Token.VAR:\n        Node varName = n.getFirstChild();\n        Preconditions.checkState(n.hasChildren(), \"AST should be normalized\");\n\n        if (varName.hasChildren()) {\n          computeMayUse(varName.getFirstChild(), cfgNode, output, conditional);\n          if (!conditional) {\n            removeFromUseIfLocal(varName.getString(), output);\n          }\n        }\n        return;\n\n      default:\n        if (NodeUtil.isAssignmentOp(n) && NodeUtil.isName(n.getFirstChild())) {\n          Node name = n.getFirstChild();\n          if (!conditional) {\n            removeFromUseIfLocal(name.getString(), output);\n          }\n\n          // In case of a += \"Hello\". There is a read of a.\n          if (!NodeUtil.isAssign(n)) {\n            addToUseIfLocal(name.getString(), cfgNode, output);\n          }\n\n          computeMayUse(name.getNext(), cfgNode, output, conditional);\n        } else {\n          /*\n           * We want to traverse in reverse order because we want the LAST\n           * definition in the sub-tree....\n           * But we have no better way to traverse in reverse other :'(\n           */\n          for (Node c = n.getLastChild(); c != null; c = n.getChildBefore(c)) {\n            computeMayUse(c, cfgNode, output, conditional);\n          }\n        }\n    }\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "MaybeReachingVariableUse.createEntryLattice",
    "class_name": "com.google.javascript.jscomp.MaybeReachingVariableUse",
    "signature": "com.google.javascript.jscomp.MaybeReachingVariableUse.createEntryLattice()",
    "snippet": "  @Override\n  ReachingUses createEntryLattice() {\n    return new ReachingUses();\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "MaybeReachingVariableUse.createInitialEstimateLattice",
    "class_name": "com.google.javascript.jscomp.MaybeReachingVariableUse",
    "signature": "com.google.javascript.jscomp.MaybeReachingVariableUse.createInitialEstimateLattice()",
    "snippet": "  @Override\n  ReachingUses createInitialEstimateLattice() {\n    return new ReachingUses();\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "MaybeReachingVariableUse.flowThrough",
    "class_name": "com.google.javascript.jscomp.MaybeReachingVariableUse",
    "signature": "com.google.javascript.jscomp.MaybeReachingVariableUse.flowThrough(Node,ReachingUses)",
    "snippet": "  @Override\n  ReachingUses flowThrough(Node n, ReachingUses input) {\n    ReachingUses output = new ReachingUses(input);\n    computeMayUse(n, n, output, false);\n    return output;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "MaybeReachingVariableUse.isForward",
    "class_name": "com.google.javascript.jscomp.MaybeReachingVariableUse",
    "signature": "com.google.javascript.jscomp.MaybeReachingVariableUse.isForward()",
    "snippet": "  @Override\n  boolean isForward() {\n    return false;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "ReachingUses.equals",
    "class_name": "com.google.javascript.jscomp.MaybeReachingVariableUse$ReachingUses",
    "signature": "com.google.javascript.jscomp.MaybeReachingVariableUse$ReachingUses.equals(Object)",
    "snippet": "    @Override\n    public boolean equals(Object other) {\n      return (other instanceof ReachingUses) &&\n          ((ReachingUses) other).mayUseMap.equals(this.mayUseMap);\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "MemoizedScopeCreator.MemoizedScopeCreator",
    "class_name": "com.google.javascript.jscomp.MemoizedScopeCreator",
    "signature": "com.google.javascript.jscomp.MemoizedScopeCreator.MemoizedScopeCreator(ScopeCreator)",
    "snippet": "  MemoizedScopeCreator(ScopeCreator delegate) {\n    this.delegate = delegate;\n  }",
    "comment": " @param delegate The real source of Scope objects. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "MemoizedScopeCreator.createScope",
    "class_name": "com.google.javascript.jscomp.MemoizedScopeCreator",
    "signature": "com.google.javascript.jscomp.MemoizedScopeCreator.createScope(Node,Scope)",
    "snippet": "  @Override\n  public Scope createScope(Node n, Scope parent) {\n    Scope scope = scopes.get(n);\n    if (scope == null) {\n      scope = delegate.createScope(n, parent);\n      scopes.put(n, scope);\n    } else {\n      Preconditions.checkState(parent == scope.getParent());\n    }\n    return scope;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "MinimizeExitPoints.MinimizeExitPoints",
    "class_name": "com.google.javascript.jscomp.MinimizeExitPoints",
    "signature": "com.google.javascript.jscomp.MinimizeExitPoints.MinimizeExitPoints(AbstractCompiler)",
    "snippet": "  MinimizeExitPoints(AbstractCompiler compiler) {\n    this.compiler = compiler;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "MinimizeExitPoints.matchingExitNode",
    "class_name": "com.google.javascript.jscomp.MinimizeExitPoints",
    "signature": "com.google.javascript.jscomp.MinimizeExitPoints.matchingExitNode(Node,int,String)",
    "snippet": "  static private boolean matchingExitNode(Node n, int type, String labelName) {\n    if (n.getType() == type) {\n      if (type == Token.RETURN) {\n        // only returns without expressions.\n        return !n.hasChildren();\n      } else {\n        if (labelName == null) {\n          return !n.hasChildren();\n        } else {\n          return n.hasChildren()\n            && labelName.equals(n.getFirstChild().getString());\n        }\n      }\n    }\n    return false;\n  }",
    "comment": " Determines if n matches the type and name for the following types of \"exits\": - return without values - continues and breaks with or without names. @param n The node to inspect. @param type The Token type to look for. @param labelName The name that must be associated with the exit type. @nullable labelName non-null only for breaks associated with labels. @return Whether the node matches the specified block-exit type. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "MinimizeExitPoints.process",
    "class_name": "com.google.javascript.jscomp.MinimizeExitPoints",
    "signature": "com.google.javascript.jscomp.MinimizeExitPoints.process(Node,Node)",
    "snippet": "  @Override\n  public void process(Node externs, Node root) {\n    NodeTraversal.traverse(compiler, root, this);\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "MinimizeExitPoints.tryMinimizeExits",
    "class_name": "com.google.javascript.jscomp.MinimizeExitPoints",
    "signature": "com.google.javascript.jscomp.MinimizeExitPoints.tryMinimizeExits(Node,int,String)",
    "snippet": "  void tryMinimizeExits(Node n, int exitType, String labelName) {\n\n    // Just an 'exit'.\n    if (matchingExitNode(n, exitType, labelName)) {\n      NodeUtil.removeChild(n.getParent(), n);\n      compiler.reportCodeChange();\n      return;\n    }\n\n    // Just an 'if'.\n    if (n.getType() == Token.IF) {\n      Node ifBlock = n.getFirstChild().getNext();\n      tryMinimizeExits(ifBlock, exitType, labelName);\n      Node elseBlock = ifBlock.getNext();\n      if (elseBlock != null) {\n        tryMinimizeExits(elseBlock, exitType, labelName);\n      }\n      return;\n    }\n\n    // Just a 'try/catch/finally'.\n    if (n.getType() == Token.TRY) {\n      Node tryBlock = n.getFirstChild();\n      tryMinimizeExits(tryBlock, exitType, labelName);\n      Node allCatchNodes = NodeUtil.getCatchBlock(n);\n      if (NodeUtil.hasCatchHandler(allCatchNodes)) {\n        Preconditions.checkState(allCatchNodes.hasOneChild());\n        Node catchNode = allCatchNodes.getFirstChild();\n        Node catchCodeBlock = catchNode.getLastChild();\n        tryMinimizeExits(catchCodeBlock, exitType, labelName);\n      }\n      if (NodeUtil.hasFinally(n)) {\n        Node finallyBlock = n.getLastChild();\n        tryMinimizeExits(finallyBlock, exitType, labelName);\n      }\n    }\n\n    // Just a 'label'.\n    if (n.getType() == Token.LABEL) {\n      Node labelBlock = n.getLastChild();\n      tryMinimizeExits(labelBlock, exitType, labelName);\n    }\n\n    // TODO(johnlenz): The last case of SWITCH statement?\n\n    // The rest assumes a block with at least one child, bail on anything else.\n    if (n.getType() != Token.BLOCK || n.getLastChild() == null) {\n      return;\n    }\n\n    // Multiple if-exits can be converted in a single pass.\n    // Convert \"if (blah) break;  if (blah2) break; other_stmt;\" to\n    // become \"if (blah); else { if (blah2); else { other_stmt; } }\"\n    // which will get converted to \"if (!blah && !blah2) { other_stmt; }\".\n    for (Node c : n.children()) {\n\n      // An 'if' block to process below.\n      if (c.getType() == Token.IF) {\n        Node ifTree = c;\n        Node trueBlock, falseBlock;\n\n        // First, the true condition block.\n        trueBlock = ifTree.getFirstChild().getNext();\n        falseBlock = trueBlock.getNext();\n        tryMinimizeIfBlockExits(trueBlock, falseBlock,\n            ifTree, exitType, labelName);\n\n        // Now the else block.\n        // The if blocks may have changed, get them again.\n        trueBlock = ifTree.getFirstChild().getNext();\n        falseBlock = trueBlock.getNext();\n        if (falseBlock != null) {\n          tryMinimizeIfBlockExits(falseBlock, trueBlock,\n              ifTree, exitType, labelName);\n        }\n      }\n\n      if (c == n.getLastChild()) {\n        break;\n      }\n    }\n\n    // Now try to minimize the exits of the last child, if it is removed\n    // look at what has become the last child.\n    for (Node c = n.getLastChild(); c != null; c = n.getLastChild()) {\n      tryMinimizeExits(c, exitType, labelName);\n      // If the node is still the last child, we are done.\n      if (c == n.getLastChild()) {\n        break;\n      }\n    }\n  }",
    "comment": " Attempts to minimize the number of explicit exit points in a control structure to take advantage of the implied exit at the end of the structure.  This is accomplished by removing redundant statements, and moving statements following a qualifying IF node into that node. For example:  function () { if (x) return; else blah(); foo(); }  becomes:  function () { if (x) ; else { blah(); foo(); }  @param n The execution node of a parent to inspect. @param exitType The type of exit to look for. @param labelName If parent is a label the name of the label to look for, null otherwise. @nullable labelName non-null only for breaks within labels. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "MinimizeExitPoints.visit",
    "class_name": "com.google.javascript.jscomp.MinimizeExitPoints",
    "signature": "com.google.javascript.jscomp.MinimizeExitPoints.visit(NodeTraversal,Node,Node)",
    "snippet": "  @Override\n  public void visit(NodeTraversal t, Node n, Node parent) {\n    switch (n.getType()) {\n      case Token.LABEL:\n        tryMinimizeExits(\n            n.getLastChild(), Token.BREAK, n.getFirstChild().getString());\n        break;\n\n      case Token.FOR:\n      case Token.WHILE:\n        tryMinimizeExits(\n            NodeUtil.getLoopCodeBlock(n), Token.CONTINUE, null);\n        break;\n\n      case Token.DO:\n        tryMinimizeExits(\n            NodeUtil.getLoopCodeBlock(n), Token.CONTINUE, null);\n\n        Node cond = NodeUtil.getConditionExpression(n);\n        if (NodeUtil.getImpureBooleanValue(cond) == TernaryValue.FALSE) {\n          // Normally, we wouldn't be able to optimize BREAKs inside a loop\n          // but as we know the condition will always false, we can treat them\n          // as we would a CONTINUE.\n          tryMinimizeExits(\n              n.getFirstChild(), Token.BREAK, null);\n        }\n        break;\n\n      case Token.FUNCTION:\n        tryMinimizeExits(\n            n.getLastChild(), Token.RETURN, null);\n        break;\n    }\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "MustBeReachingVariableDef.MustBeReachingVariableDef",
    "class_name": "com.google.javascript.jscomp.MustBeReachingVariableDef",
    "signature": "com.google.javascript.jscomp.MustBeReachingVariableDef.MustBeReachingVariableDef(ControlFlowGraph,Scope,AbstractCompiler)",
    "snippet": "  MustBeReachingVariableDef(\n      ControlFlowGraph<Node> cfg, Scope jsScope, AbstractCompiler compiler) {\n    super(cfg, new MustDefJoin());\n    this.jsScope = jsScope;\n    this.compiler = compiler;\n    this.escaped = Sets.newHashSet();\n    computeEscaped(jsScope, escaped, compiler);\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "MustBeReachingVariableDef.computeMustDef",
    "class_name": "com.google.javascript.jscomp.MustBeReachingVariableDef",
    "signature": "com.google.javascript.jscomp.MustBeReachingVariableDef.computeMustDef(Node,Node,MustDef,boolean)",
    "snippet": "  private void computeMustDef(\n      Node n, Node cfgNode, MustDef output, boolean conditional) {\n    switch (n.getType()) {\n\n      case Token.BLOCK:\n      case Token.FUNCTION:\n        return;\n\n      case Token.WHILE:\n      case Token.DO:\n      case Token.IF:\n        computeMustDef(\n            NodeUtil.getConditionExpression(n), cfgNode, output, conditional);\n        return;\n\n      case Token.FOR:\n        if (!NodeUtil.isForIn(n)) {\n          computeMustDef(\n              NodeUtil.getConditionExpression(n), cfgNode, output, conditional);\n        } else {\n          // for(x in y) {...}\n          Node lhs = n.getFirstChild();\n          Node rhs = lhs.getNext();\n          if (NodeUtil.isVar(lhs)) {\n            lhs = lhs.getLastChild(); // for(var x in y) {...}\n          }\n          if (NodeUtil.isName(lhs)) {\n            addToDefIfLocal(lhs.getString(), cfgNode, rhs, output);\n          }\n        }\n        return;\n\n      case Token.AND:\n      case Token.OR:\n        computeMustDef(n.getFirstChild(), cfgNode, output, conditional);\n        computeMustDef(n.getLastChild(), cfgNode, output, true);\n        return;\n\n      case Token.HOOK:\n        computeMustDef(n.getFirstChild(), cfgNode, output, conditional);\n        computeMustDef(n.getFirstChild().getNext(), cfgNode, output, true);\n        computeMustDef(n.getLastChild(), cfgNode, output, true);\n        return;\n\n      case Token.VAR:\n        for (Node c = n.getFirstChild(); c != null; c = c.getNext()) {\n          if (c.hasChildren()) {\n            computeMustDef(c.getFirstChild(), cfgNode, output, conditional);\n            addToDefIfLocal(c.getString(), conditional ? null : cfgNode,\n                c.getFirstChild(), output);\n          }\n        }\n        return;\n\n      default:\n        if (NodeUtil.isAssignmentOp(n)) {\n          if (NodeUtil.isName(n.getFirstChild())) {\n            Node name = n.getFirstChild();\n            computeMustDef(name.getNext(), cfgNode, output, conditional);\n            addToDefIfLocal(name.getString(), conditional ? null : cfgNode,\n              n.getLastChild(), output);\n            return;\n          } else if (NodeUtil.isGet(n.getFirstChild())) {\n            // Treat all assignments to arguments as redefining the\n            // parameters itself.\n            Node obj = n.getFirstChild().getFirstChild();\n            if (NodeUtil.isName(obj) && \"arguments\".equals(obj.getString())) {\n              // TODO(user): More accuracy can be introduced\n              // ie: We know exactly what arguments[x] is if x is a constant\n              // number.\n              escapeParameters(output);\n            }\n          }\n        }\n\n        if (NodeUtil.isName(n) && \"arguments\".equals(n.getString())) {\n          escapeParameters(output);\n        }\n\n        // DEC and INC actually defines the variable.\n        if (n.getType() == Token.DEC || n.getType() == Token.INC) {\n          Node target = n.getFirstChild();\n          if (NodeUtil.isName(target)) {\n            addToDefIfLocal(target.getString(),\n                conditional ? null : cfgNode, null, output);\n            return;\n          }\n        }\n\n        for (Node c = n.getFirstChild(); c != null; c = c.getNext()) {\n          computeMustDef(c, cfgNode, output, conditional);\n        }\n    }\n  }",
    "comment": " @param n The node in question. @param cfgNode The node to add @param conditional true if the definition is not always executed. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "MustBeReachingVariableDef.createEntryLattice",
    "class_name": "com.google.javascript.jscomp.MustBeReachingVariableDef",
    "signature": "com.google.javascript.jscomp.MustBeReachingVariableDef.createEntryLattice()",
    "snippet": "  @Override\n  MustDef createEntryLattice() {\n    return new MustDef(jsScope.getVars());\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "MustBeReachingVariableDef.createInitialEstimateLattice",
    "class_name": "com.google.javascript.jscomp.MustBeReachingVariableDef",
    "signature": "com.google.javascript.jscomp.MustBeReachingVariableDef.createInitialEstimateLattice()",
    "snippet": "  @Override\n  MustDef createInitialEstimateLattice() {\n    return new MustDef();\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "MustBeReachingVariableDef.flowThrough",
    "class_name": "com.google.javascript.jscomp.MustBeReachingVariableDef",
    "signature": "com.google.javascript.jscomp.MustBeReachingVariableDef.flowThrough(Node,MustDef)",
    "snippet": "  @Override\n  MustDef flowThrough(Node n, MustDef input) {\n    // TODO(user): We are doing a straight copy from input to output. There\n    // might be some opportunities to cut down overhead.\n    MustDef output = new MustDef(input);\n    // TODO(user): This must know about ON_EX edges but it should handle\n    // it better than what we did in liveness. Because we are in a forward mode,\n    // we can used the branched forward analysis.\n    computeMustDef(n, n, output, false);\n    return output;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "MustBeReachingVariableDef.isForward",
    "class_name": "com.google.javascript.jscomp.MustBeReachingVariableDef",
    "signature": "com.google.javascript.jscomp.MustBeReachingVariableDef.isForward()",
    "snippet": "  @Override\n  boolean isForward() {\n    return true;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "MustDef.equals",
    "class_name": "com.google.javascript.jscomp.MustBeReachingVariableDef$MustDef",
    "signature": "com.google.javascript.jscomp.MustBeReachingVariableDef$MustDef.equals(Object)",
    "snippet": "    @Override\n    public boolean equals(Object other) {\n      return (other instanceof MustDef) &&\n          ((MustDef) other).reachingDef.equals(this.reachingDef);\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "NameGenerator.NameGenerator",
    "class_name": "com.google.javascript.jscomp.NameGenerator",
    "signature": "com.google.javascript.jscomp.NameGenerator.NameGenerator(Set,String,char[])",
    "snippet": "  NameGenerator(Set<String> reservedNames, String prefix,\n      @Nullable char[] reservedCharacters) {\n    this.reservedNames = reservedNames;\n    this.prefix = prefix;\n\n    // build the character arrays to use\n    this.firstChars = reserveCharacters(FIRST_CHAR, reservedCharacters);\n    this.nonFirstChars = reserveCharacters(NONFIRST_CHAR, reservedCharacters);\n\n    checkPrefix(prefix);\n  }",
    "comment": " Creates a NameGenerator.  @param reservedNames set of names that are reserved; generated names will not include these names. This set is referenced rather than copied, so changes to the set will be reflected in how names are generated. @param prefix all generated names begin with this prefix. @param reservedCharacters If specified these characters won't be used in generated names ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "NameGenerator.checkPrefix",
    "class_name": "com.google.javascript.jscomp.NameGenerator",
    "signature": "com.google.javascript.jscomp.NameGenerator.checkPrefix(String)",
    "snippet": "  private void checkPrefix(String prefix) {\n    if (prefix.length() > 0) {\n      // Make sure that prefix starts with a legal character.\n      if (!contains(firstChars, prefix.charAt(0))) {\n        throw new IllegalArgumentException(\"prefix must start with one of: \" +\n                                           Arrays.toString(firstChars));\n      }\n      for (int pos = 1; pos < prefix.length(); ++pos) {\n        if (!contains(nonFirstChars, prefix.charAt(pos))) {\n          throw new IllegalArgumentException(\"prefix has invalid characters, \" +\n                                             \"must be one of: \" +\n                                             Arrays.toString(nonFirstChars));\n        }\n      }\n    }\n  }",
    "comment": "Validates a name prefix. */",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "NameGenerator.reserveCharacters",
    "class_name": "com.google.javascript.jscomp.NameGenerator",
    "signature": "com.google.javascript.jscomp.NameGenerator.reserveCharacters(char[],char[])",
    "snippet": "  static char[] reserveCharacters(char[] chars, char[] reservedCharacters) {\n    if (reservedCharacters == null || reservedCharacters.length == 0) {\n      return chars;\n    }\n    Set<Character> charSet = Sets.newLinkedHashSet(Chars.asList(chars));\n    for (char reservedCharacter : reservedCharacters) {\n      charSet.remove(reservedCharacter);\n    }\n    return Chars.toArray(charSet);\n  }",
    "comment": " Provides the array of available characters based on the specified arrays. @param chars The list of characters that are legal @param reservedCharacters The characters that should not be used @return An array of characters to use. Will return the chars array if reservedCharacters is null or empty, otherwise creates a new array. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "NodeTraversal.NodeTraversal",
    "class_name": "com.google.javascript.jscomp.NodeTraversal",
    "signature": "com.google.javascript.jscomp.NodeTraversal.NodeTraversal(AbstractCompiler,Callback)",
    "snippet": "  public NodeTraversal(AbstractCompiler compiler, Callback cb) {\n    this(compiler, cb, new SyntacticScopeCreator(compiler));\n  }",
    "comment": " Creates a node traversal using the specified callback interface. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "NodeTraversal.NodeTraversal",
    "class_name": "com.google.javascript.jscomp.NodeTraversal",
    "signature": "com.google.javascript.jscomp.NodeTraversal.NodeTraversal(AbstractCompiler,Callback,ScopeCreator)",
    "snippet": "  public NodeTraversal(AbstractCompiler compiler, Callback cb,\n      ScopeCreator scopeCreator) {\n    this.callback = cb;\n    if (cb instanceof ScopedCallback) {\n      this.scopeCallback = (ScopedCallback) cb;\n    }\n    this.compiler = compiler;\n    this.sourceName = \"\";\n    this.scopeCreator = scopeCreator;\n  }",
    "comment": " Creates a node traversal using the specified callback interface and the scope creator. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "NodeTraversal.getCompiler",
    "class_name": "com.google.javascript.jscomp.NodeTraversal",
    "signature": "com.google.javascript.jscomp.NodeTraversal.getCompiler()",
    "snippet": "  public Compiler getCompiler() {\n    // TODO(nicksantos): Remove this type cast. This is just temporary\n    // while refactoring.\n    return (Compiler) compiler;\n  }",
    "comment": " Gets the compiler. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "NodeTraversal.getControlFlowGraph",
    "class_name": "com.google.javascript.jscomp.NodeTraversal",
    "signature": "com.google.javascript.jscomp.NodeTraversal.getControlFlowGraph()",
    "snippet": "  public ControlFlowGraph<Node> getControlFlowGraph() {\n    if (cfgs.peek() == null) {\n      ControlFlowAnalysis cfa = new ControlFlowAnalysis(compiler, false, true);\n      cfa.process(null, getScopeRoot());\n      cfgs.pop();\n      cfgs.push(cfa.getCfg());\n    }\n    return cfgs.peek();\n  }",
    "comment": "Gets the control flow graph for the current JS scope. */",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "NodeTraversal.getCurrentNode",
    "class_name": "com.google.javascript.jscomp.NodeTraversal",
    "signature": "com.google.javascript.jscomp.NodeTraversal.getCurrentNode()",
    "snippet": "  public Node getCurrentNode() {\n    return curNode;\n  }",
    "comment": "Returns the node currently being traversed. */",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "NodeTraversal.getInput",
    "class_name": "com.google.javascript.jscomp.NodeTraversal",
    "signature": "com.google.javascript.jscomp.NodeTraversal.getInput()",
    "snippet": "  public CompilerInput getInput() {\n    return compiler.getInput(sourceName);\n  }",
    "comment": " Gets the current input source. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "NodeTraversal.getScope",
    "class_name": "com.google.javascript.jscomp.NodeTraversal",
    "signature": "com.google.javascript.jscomp.NodeTraversal.getScope()",
    "snippet": "  public Scope getScope() {\n    Scope scope = scopes.isEmpty() ? null : scopes.peek();\n    if (scopeRoots.isEmpty()) {\n      return scope;\n    }\n\n    Iterator<Node> it = scopeRoots.descendingIterator();\n    while (it.hasNext()) {\n      scope = scopeCreator.createScope(it.next(), scope);\n      scopes.push(scope);\n    }\n    scopeRoots.clear();\n\n    return scope;\n  }",
    "comment": "Gets the current scope. */",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "NodeTraversal.getScopeDepth",
    "class_name": "com.google.javascript.jscomp.NodeTraversal",
    "signature": "com.google.javascript.jscomp.NodeTraversal.getScopeDepth()",
    "snippet": "  int getScopeDepth() {\n    return scopes.size() + scopeRoots.size();\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "NodeTraversal.getScopeRoot",
    "class_name": "com.google.javascript.jscomp.NodeTraversal",
    "signature": "com.google.javascript.jscomp.NodeTraversal.getScopeRoot()",
    "snippet": "  public Node getScopeRoot() {\n    if (scopeRoots.isEmpty()) {\n      return scopes.peek().getRootNode();\n    } else {\n      return scopeRoots.peek();\n    }\n  }",
    "comment": "Returns the current scope's root. */",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "NodeTraversal.getSourceName",
    "class_name": "com.google.javascript.jscomp.NodeTraversal",
    "signature": "com.google.javascript.jscomp.NodeTraversal.getSourceName()",
    "snippet": "  public String getSourceName() {\n    return sourceName;\n  }",
    "comment": " Gets the current input source name.  @return A string that may be empty, but not null ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "NodeTraversal.getSourceName",
    "class_name": "com.google.javascript.jscomp.NodeTraversal",
    "signature": "com.google.javascript.jscomp.NodeTraversal.getSourceName(Node)",
    "snippet": "  private static String getSourceName(Node n) {\n    String name = n.getSourceFileName();\n    return name == null ? \"\" : name;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "NodeTraversal.inGlobalScope",
    "class_name": "com.google.javascript.jscomp.NodeTraversal",
    "signature": "com.google.javascript.jscomp.NodeTraversal.inGlobalScope()",
    "snippet": "  boolean inGlobalScope() {\n    return getScopeDepth() <= 1;\n  }",
    "comment": " Determines whether the traversal is currently in the global scope. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "NodeTraversal.makeError",
    "class_name": "com.google.javascript.jscomp.NodeTraversal",
    "signature": "com.google.javascript.jscomp.NodeTraversal.makeError(Node,DiagnosticType,String[])",
    "snippet": "  public JSError makeError(Node n, DiagnosticType type, String... arguments) {\n    return JSError.make(getSourceName(), n, type, arguments);\n  }",
    "comment": " Creates a JSError during NodeTraversal.  @param n Determines the line and char position within the source file name @param type The DiagnosticType @param arguments Arguments to be incorporated into the message ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "NodeTraversal.popScope",
    "class_name": "com.google.javascript.jscomp.NodeTraversal",
    "signature": "com.google.javascript.jscomp.NodeTraversal.popScope()",
    "snippet": "  private void popScope() {\n    if (scopeCallback != null) {\n      scopeCallback.exitScope(this);\n    }\n    if (scopeRoots.isEmpty()) {\n      scopes.pop();\n    } else {\n      scopeRoots.pop();\n    }\n    cfgs.pop();\n  }",
    "comment": "Pops back to the previous scope (e.g. when leaving a function). */",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "NodeTraversal.pushScope",
    "class_name": "com.google.javascript.jscomp.NodeTraversal",
    "signature": "com.google.javascript.jscomp.NodeTraversal.pushScope(Node)",
    "snippet": "  private void pushScope(Node node) {\n    Preconditions.checkState(curNode != null);\n    scopeRoots.push(node);\n    cfgs.push(null);\n    if (scopeCallback != null) {\n      scopeCallback.enterScope(this);\n    }\n  }",
    "comment": "Creates a new scope (e.g. when entering a function). */",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "NodeTraversal.pushScope",
    "class_name": "com.google.javascript.jscomp.NodeTraversal",
    "signature": "com.google.javascript.jscomp.NodeTraversal.pushScope(Scope)",
    "snippet": "  private void pushScope(Scope s) {\n    Preconditions.checkState(curNode != null);\n    scopes.push(s);\n    cfgs.push(null);\n    if (scopeCallback != null) {\n      scopeCallback.enterScope(this);\n    }\n  }",
    "comment": "Creates a new scope (e.g. when entering a function). */",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "NodeTraversal.traverse",
    "class_name": "com.google.javascript.jscomp.NodeTraversal",
    "signature": "com.google.javascript.jscomp.NodeTraversal.traverse(AbstractCompiler,Node,Callback)",
    "snippet": "  public static void traverse(\n      AbstractCompiler compiler, Node root, Callback cb) {\n    NodeTraversal t = new NodeTraversal(compiler, cb);\n    t.traverse(root);\n  }",
    "comment": " Traverses a node recursively. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "NodeTraversal.traverse",
    "class_name": "com.google.javascript.jscomp.NodeTraversal",
    "signature": "com.google.javascript.jscomp.NodeTraversal.traverse(Node)",
    "snippet": "  public void traverse(Node root) {\n    try {\n      sourceName = \"\";\n      curNode = root;\n      pushScope(root);\n      traverseBranch(root, null);\n      popScope();\n    } catch (Exception unexpectedException) {\n      throwUnexpectedException(unexpectedException);\n    }\n  }",
    "comment": " Traverses a parse tree recursively. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "NodeTraversal.traverseAtScope",
    "class_name": "com.google.javascript.jscomp.NodeTraversal",
    "signature": "com.google.javascript.jscomp.NodeTraversal.traverseAtScope(Scope)",
    "snippet": "  void traverseAtScope(Scope s) {\n    Node n = s.getRootNode();\n    if (n.getType() == Token.FUNCTION) {\n      // We need to do some extra magic to make sure that the scope doesn't\n      // get re-created when we dive into the function.\n      sourceName = getSourceName(n);\n      curNode = n;\n      pushScope(s);\n\n      Node args = n.getFirstChild().getNext();\n      Node body = args.getNext();\n      traverseBranch(args, n);\n      traverseBranch(body, n);\n\n      popScope();\n    } else {\n      traverseWithScope(n, s);\n    }\n  }",
    "comment": " Traverses a parse tree recursively with a scope, starting at that scope's root. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "NodeTraversal.traverseBranch",
    "class_name": "com.google.javascript.jscomp.NodeTraversal",
    "signature": "com.google.javascript.jscomp.NodeTraversal.traverseBranch(Node,Node)",
    "snippet": "  @SuppressWarnings(\"fallthrough\")\n  private void traverseBranch(Node n, Node parent) {\n    int type = n.getType();\n    if (type == Token.SCRIPT) {\n      sourceName = getSourceName(n);\n    }\n\n    curNode = n;\n    if (!callback.shouldTraverse(this, n, parent)) return;\n\n    switch (type) {\n      case Token.FUNCTION:\n        traverseFunction(n, parent);\n        break;\n\n      default:\n        for (Node child = n.getFirstChild(); child != null; ) {\n          // child could be replaced, in which case our child node\n          // would no longer point to the true next\n          Node next = child.getNext();\n          traverseBranch(child, n);\n          child = next;\n        }\n        break;\n    }\n\n    curNode = n;\n    callback.visit(this, n, parent);\n  }",
    "comment": " Traverses a branch. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "NodeTraversal.traverseFunction",
    "class_name": "com.google.javascript.jscomp.NodeTraversal",
    "signature": "com.google.javascript.jscomp.NodeTraversal.traverseFunction(Node,Node)",
    "snippet": "  private void traverseFunction(Node n, Node parent) {\n    Preconditions.checkState(n.getChildCount() == 3);\n    Preconditions.checkState(n.getType() == Token.FUNCTION);\n\n    final Node fnName = n.getFirstChild();\n\n    boolean isFunctionExpression = (parent != null)\n        && NodeUtil.isFunctionExpression(n);\n\n    if (!isFunctionExpression) {\n      // Functions declarations are in the scope containing the declaration.\n      traverseBranch(fnName, n);\n    }\n\n    curNode = n;\n    pushScope(n);\n\n    if (isFunctionExpression) {\n      // Function expression names are only accessible within the function\n      // scope.\n      traverseBranch(fnName, n);\n    }\n\n    final Node args = fnName.getNext();\n    final Node body = args.getNext();\n\n    // Args\n    traverseBranch(args, n);\n\n    // Body\n    Preconditions.checkState(body.getNext() == null &&\n            body.getType() == Token.BLOCK);\n    traverseBranch(body, n);\n\n    popScope();\n  }",
    "comment": " Traverses a function. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "NodeTraversal.traverseRoots",
    "class_name": "com.google.javascript.jscomp.NodeTraversal",
    "signature": "com.google.javascript.jscomp.NodeTraversal.traverseRoots(AbstractCompiler,List,Callback)",
    "snippet": "  public static void traverseRoots(\n      AbstractCompiler compiler, List<Node> roots, Callback cb) {\n    NodeTraversal t = new NodeTraversal(compiler, cb);\n    t.traverseRoots(roots);\n  }",
    "comment": " Traverses a list of node trees. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "NodeTraversal.traverseRoots",
    "class_name": "com.google.javascript.jscomp.NodeTraversal",
    "signature": "com.google.javascript.jscomp.NodeTraversal.traverseRoots(List)",
    "snippet": "  public void traverseRoots(List<Node> roots) {\n    if (roots.isEmpty()) {\n      return;\n    }\n\n    try {\n      Node scopeRoot = roots.get(0).getParent();\n      Preconditions.checkState(scopeRoot != null);\n\n      sourceName = \"\";\n      curNode = scopeRoot;\n      pushScope(scopeRoot);\n\n      for (Node root : roots) {\n        Preconditions.checkState(root.getParent() == scopeRoot);\n        traverseBranch(root, scopeRoot);\n      }\n\n      popScope();\n    } catch (Exception unexpectedException) {\n      throwUnexpectedException(unexpectedException);\n    }\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "NodeTraversal.traverseRoots",
    "class_name": "com.google.javascript.jscomp.NodeTraversal",
    "signature": "com.google.javascript.jscomp.NodeTraversal.traverseRoots(Node[])",
    "snippet": "  public void traverseRoots(Node ... roots) {\n    traverseRoots(Lists.newArrayList(roots));\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "NodeTraversal.traverseWithScope",
    "class_name": "com.google.javascript.jscomp.NodeTraversal",
    "signature": "com.google.javascript.jscomp.NodeTraversal.traverseWithScope(Node,Scope)",
    "snippet": "  void traverseWithScope(Node root, Scope s) {\n    Preconditions.checkState(s.isGlobal());\n\n    sourceName = \"\";\n    curNode = root;\n    pushScope(s);\n    traverseBranch(root, null);\n    popScope();\n  }",
    "comment": " Traverses a parse tree recursively with a scope, starting with the given root. This should only be used in the global scope. Otherwise, use {@link #traverseAtScope}. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "AbstractPostOrderCallback.shouldTraverse",
    "class_name": "com.google.javascript.jscomp.NodeTraversal$AbstractPostOrderCallback",
    "signature": "com.google.javascript.jscomp.NodeTraversal$AbstractPostOrderCallback.shouldTraverse(NodeTraversal,Node,Node)",
    "snippet": "    public final boolean shouldTraverse(NodeTraversal nodeTraversal, Node n,\n        Node parent) {\n      return true;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "AbstractShallowCallback.shouldTraverse",
    "class_name": "com.google.javascript.jscomp.NodeTraversal$AbstractShallowCallback",
    "signature": "com.google.javascript.jscomp.NodeTraversal$AbstractShallowCallback.shouldTraverse(NodeTraversal,Node,Node)",
    "snippet": "    public final boolean shouldTraverse(NodeTraversal nodeTraversal, Node n,\n        Node parent) {\n      // We do want to traverse the name of a named function, but we don't\n      // want to traverse the arguments or body.\n      return parent == null || parent.getType() != Token.FUNCTION ||\n          n == parent.getFirstChild();\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "AbstractShallowStatementCallback.shouldTraverse",
    "class_name": "com.google.javascript.jscomp.NodeTraversal$AbstractShallowStatementCallback",
    "signature": "com.google.javascript.jscomp.NodeTraversal$AbstractShallowStatementCallback.shouldTraverse(NodeTraversal,Node,Node)",
    "snippet": "    public final boolean shouldTraverse(NodeTraversal nodeTraversal, Node n,\n        Node parent) {\n      return parent == null || NodeUtil.isControlStructure(parent)\n         || NodeUtil.isStatementBlock(parent);\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "NodeUtil.checkForStateChangeHelper",
    "class_name": "com.google.javascript.jscomp.NodeUtil",
    "signature": "com.google.javascript.jscomp.NodeUtil.checkForStateChangeHelper(Node,boolean,AbstractCompiler)",
    "snippet": "  private static boolean checkForStateChangeHelper(\n      Node n, boolean checkForNewObjects, AbstractCompiler compiler) {\n    // Rather than id which ops may have side effects, id the ones\n    // that we know to be safe\n    switch (n.getType()) {\n      // other side-effect free statements and expressions\n      case Token.AND:\n      case Token.BLOCK:\n      case Token.EXPR_RESULT:\n      case Token.HOOK:\n      case Token.IF:\n      case Token.IN:\n      case Token.LP:\n      case Token.NUMBER:\n      case Token.OR:\n      case Token.THIS:\n      case Token.TRUE:\n      case Token.FALSE:\n      case Token.NULL:\n      case Token.STRING:\n      case Token.SWITCH:\n      case Token.TRY:\n      case Token.EMPTY:\n        break;\n\n      // Throws are by definition side effects\n      case Token.THROW:\n        return true;\n\n      case Token.OBJECTLIT:\n        if (checkForNewObjects) {\n          return true;\n        }\n        for (Node c = n.getFirstChild(); c != null; c = c.getNext()) {\n          if (checkForStateChangeHelper(\n                  c.getFirstChild(), checkForNewObjects, compiler)) {\n            return true;\n          }\n        }\n        return false;\n\n      case Token.ARRAYLIT:\n      case Token.REGEXP:\n        if (checkForNewObjects) {\n          return true;\n        }\n        break;\n\n      case Token.VAR:    // empty var statement (no declaration)\n      case Token.NAME:   // variable by itself\n        if (n.getFirstChild() != null) {\n          return true;\n        }\n        break;\n\n      case Token.FUNCTION:\n        // Function expressions don't have side-effects, but function\n        // declarations change the namespace. Either way, we don't need to\n        // check the children, since they aren't executed at declaration time.\n        return checkForNewObjects || !isFunctionExpression(n);\n\n      case Token.NEW:\n        if (checkForNewObjects) {\n          return true;\n        }\n\n        if (!constructorCallHasSideEffects(n)) {\n          // loop below will see if the constructor parameters have\n          // side-effects\n          break;\n        }\n        return true;\n\n      case Token.CALL:\n        // calls to functions that have no side effects have the no\n        // side effect property set.\n        if (!functionCallHasSideEffects(n, compiler)) {\n          // loop below will see if the function parameters have\n          // side-effects\n          break;\n        }\n        return true;\n\n      default:\n        if (isSimpleOperatorType(n.getType())) {\n          break;\n        }\n\n        if (isAssignmentOp(n)) {\n          Node assignTarget = n.getFirstChild();\n          if (isName(assignTarget)) {\n            return true;\n          }\n\n          // Assignments will have side effects if\n          // a) The RHS has side effects, or\n          // b) The LHS has side effects, or\n          // c) A name on the LHS will exist beyond the life of this statement.\n          if (checkForStateChangeHelper(\n                  n.getFirstChild(), checkForNewObjects, compiler) ||\n              checkForStateChangeHelper(\n                  n.getLastChild(), checkForNewObjects, compiler)) {\n            return true;\n          }\n\n          if (isGet(assignTarget)) {\n            // If the object being assigned to is a local object, don't\n            // consider this a side-effect as it can't be referenced\n            // elsewhere.  Don't do this recursively as the property might\n            // be an alias of another object, unlike a literal below.\n            Node current = assignTarget.getFirstChild();\n            if (evaluatesToLocalValue(current)) {\n              return false;\n            }\n\n            // A literal value as defined by \"isLiteralValue\" is guaranteed\n            // not to be an alias, or any components which are aliases of\n            // other objects.\n            // If the root object is a literal don't consider this a\n            // side-effect.\n            while (isGet(current)) {\n              current = current.getFirstChild();\n            }\n\n            return !isLiteralValue(current, true);\n          } else {\n            // TODO(johnlenz): remove this code and make this an exception. This\n            // is here only for legacy reasons, the AST is not valid but\n            // preserve existing behavior.\n            return !isLiteralValue(assignTarget, true);\n          }\n        }\n\n        return true;\n    }\n\n    for (Node c = n.getFirstChild(); c != null; c = c.getNext()) {\n      if (checkForStateChangeHelper(c, checkForNewObjects, compiler)) {\n        return true;\n      }\n    }\n\n    return false;\n  }",
    "comment": " Returns true if some node in n's subtree changes application state. If {@code checkForNewObjects} is true, we assume that newly created mutable objects (like object literals) change state. Otherwise, we assume that they have no side effects. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "NodeUtil.containsFunction",
    "class_name": "com.google.javascript.jscomp.NodeUtil",
    "signature": "com.google.javascript.jscomp.NodeUtil.containsFunction(Node)",
    "snippet": "  static boolean containsFunction(Node n) {\n    return containsType(n, Token.FUNCTION);\n  }",
    "comment": " Determines if the given node contains a function statement or function expression. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "NodeUtil.containsType",
    "class_name": "com.google.javascript.jscomp.NodeUtil",
    "signature": "com.google.javascript.jscomp.NodeUtil.containsType(Node,int)",
    "snippet": "  static boolean containsType(Node node, int type) {\n    return containsType(node, type, Predicates.<Node>alwaysTrue());\n  }",
    "comment": " @return true if n or any of its children are of the specified type ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "NodeUtil.containsType",
    "class_name": "com.google.javascript.jscomp.NodeUtil",
    "signature": "com.google.javascript.jscomp.NodeUtil.containsType(Node,int,Predicate)",
    "snippet": "  static boolean containsType(Node node,\n                              int type,\n                              Predicate<Node> traverseChildrenPred) {\n    return has(node, new MatchNodeType(type), traverseChildrenPred);\n  }",
    "comment": " @return true if n or any of its children are of the specified type ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "NodeUtil.evaluatesToLocalValue",
    "class_name": "com.google.javascript.jscomp.NodeUtil",
    "signature": "com.google.javascript.jscomp.NodeUtil.evaluatesToLocalValue(Node)",
    "snippet": "  static boolean evaluatesToLocalValue(Node value) {\n    return evaluatesToLocalValue(value, Predicates.<Node>alwaysFalse());\n  }",
    "comment": " @return Whether the node is known to be a value that is not referenced elsewhere. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "NodeUtil.evaluatesToLocalValue",
    "class_name": "com.google.javascript.jscomp.NodeUtil",
    "signature": "com.google.javascript.jscomp.NodeUtil.evaluatesToLocalValue(Node,Predicate)",
    "snippet": "  static boolean evaluatesToLocalValue(Node value, Predicate<Node> locals) {\n    switch (value.getType()) {\n      case Token.ASSIGN:\n        // A result that is aliased by a non-local name, is the effectively the\n        // same as returning a non-local name, but this doesn't matter if the\n        // value is immutable.\n        return NodeUtil.isImmutableValue(value.getLastChild())\n            || (locals.apply(value)\n                && evaluatesToLocalValue(value.getLastChild(), locals));\n      case Token.COMMA:\n        return evaluatesToLocalValue(value.getLastChild(), locals);\n      case Token.AND:\n      case Token.OR:\n        return evaluatesToLocalValue(value.getFirstChild(), locals)\n           && evaluatesToLocalValue(value.getLastChild(), locals);\n      case Token.HOOK:\n        return evaluatesToLocalValue(value.getFirstChild().getNext(), locals)\n           && evaluatesToLocalValue(value.getLastChild(), locals);\n      case Token.INC:\n      case Token.DEC:\n        if (value.getBooleanProp(Node.INCRDECR_PROP)) {\n          return evaluatesToLocalValue(value.getFirstChild(), locals);\n        } else {\n          return true;\n        }\n      case Token.THIS:\n        return locals.apply(value);\n      case Token.NAME:\n        return isImmutableValue(value) || locals.apply(value);\n      case Token.GETELEM:\n      case Token.GETPROP:\n        // There is no information about the locality of object properties.\n        return locals.apply(value);\n      case Token.CALL:\n        return callHasLocalResult(value)\n            || isToStringMethodCall(value)\n            || locals.apply(value);\n      case Token.NEW:\n        return newHasLocalResult(value)\n               || locals.apply(value);\n      case Token.FUNCTION:\n      case Token.REGEXP:\n      case Token.ARRAYLIT:\n      case Token.OBJECTLIT:\n        // Literals objects with non-literal children are allowed.\n        return true;\n      case Token.DELPROP:\n      case Token.IN:\n        // TODO(johnlenz): should IN operator be included in #isSimpleOperator?\n        return true;\n      default:\n        // Other op force a local value:\n        //  x = '' + g (x is now an local string)\n        //  x -= g (x is now an local number)\n        if (isAssignmentOp(value)\n            || isSimpleOperator(value)\n            || isImmutableValue(value)) {\n          return true;\n        }\n\n        throw new IllegalStateException(\n            \"Unexpected expression node\" + value +\n            \"\\n parent:\" + value.getParent());\n    }\n  }",
    "comment": " @param locals A predicate to apply to unknown local values. @return Whether the node is known to be a value that is not a reference outside the expression scope. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "NodeUtil.getFunctionJSDocInfo",
    "class_name": "com.google.javascript.jscomp.NodeUtil",
    "signature": "com.google.javascript.jscomp.NodeUtil.getFunctionJSDocInfo(Node)",
    "snippet": "  public static JSDocInfo getFunctionJSDocInfo(Node n) {\n    Preconditions.checkState(n.getType() == Token.FUNCTION);\n    JSDocInfo fnInfo = n.getJSDocInfo();\n    if (fnInfo == null && NodeUtil.isFunctionExpression(n)) {\n      // Look for the info on other nodes.\n      Node parent = n.getParent();\n      if (parent.getType() == Token.ASSIGN) {\n        // on ASSIGNs\n        fnInfo = parent.getJSDocInfo();\n      } else if (parent.getType() == Token.NAME) {\n        // on var NAME = function() { ... };\n        fnInfo = parent.getParent().getJSDocInfo();\n      }\n    }\n    return fnInfo;\n  }",
    "comment": " Get the JSDocInfo for a function. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "NodeUtil.getInfoForNameNode",
    "class_name": "com.google.javascript.jscomp.NodeUtil",
    "signature": "com.google.javascript.jscomp.NodeUtil.getInfoForNameNode(Node)",
    "snippet": "  static JSDocInfo getInfoForNameNode(Node nameNode) {\n    JSDocInfo info = null;\n    Node parent = null;\n    if (nameNode != null) {\n      info = nameNode.getJSDocInfo();\n      parent = nameNode.getParent();\n    }\n\n    if (info == null && parent != null &&\n        ((parent.getType() == Token.VAR && parent.hasOneChild()) ||\n          parent.getType() == Token.FUNCTION)) {\n      info = parent.getJSDocInfo();\n    }\n    return info;\n  }",
    "comment": " @param nameNode A name node @return The JSDocInfo for the name node ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "NodeUtil.getPureBooleanValue",
    "class_name": "com.google.javascript.jscomp.NodeUtil",
    "signature": "com.google.javascript.jscomp.NodeUtil.getPureBooleanValue(Node)",
    "snippet": "  static TernaryValue getPureBooleanValue(Node n) {\n    switch (n.getType()) {\n      case Token.STRING:\n        return TernaryValue.forBoolean(n.getString().length() > 0);\n\n      case Token.NUMBER:\n        return TernaryValue.forBoolean(n.getDouble() != 0);\n\n      case Token.NOT:\n        return getPureBooleanValue(n.getLastChild()).not();\n\n      case Token.NULL:\n      case Token.FALSE:\n        return TernaryValue.FALSE;\n\n      case Token.VOID:\n        if (!mayHaveSideEffects(n.getFirstChild())) {\n          return TernaryValue.FALSE;\n        }\n        break;\n\n      case Token.NAME:\n        String name = n.getString();\n        if (\"undefined\".equals(name)\n            || \"NaN\".equals(name)) {\n          // We assume here that programs don't change the value of the keyword\n          // undefined to something other than the value undefined.\n          return TernaryValue.FALSE;\n        } else if (\"Infinity\".equals(name)) {\n          return TernaryValue.TRUE;\n        }\n        break;\n\n      case Token.TRUE:\n      case Token.REGEXP:\n        return TernaryValue.TRUE;\n\n      case Token.ARRAYLIT:\n      case Token.OBJECTLIT:\n        if (!mayHaveSideEffects(n)) {\n          return TernaryValue.TRUE;\n        }\n        break;\n    }\n\n    return TernaryValue.UNKNOWN;\n  }",
    "comment": " Gets the boolean value of a node that represents a literal. This method effectively emulates the <code>Boolean()</code> JavaScript cast function except it return UNKNOWN for known values with side-effects, use getExpressionBooleanValue if you don't care about side-effects. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "NodeUtil.getSourceName",
    "class_name": "com.google.javascript.jscomp.NodeUtil",
    "signature": "com.google.javascript.jscomp.NodeUtil.getSourceName(Node)",
    "snippet": "  public static String getSourceName(Node n) {\n    String sourceName = null;\n    while (sourceName == null && n != null) {\n      sourceName = n.getSourceFileName();\n      n = n.getParent();\n    }\n    return sourceName;\n  }",
    "comment": " @param n The node. @return The source name property on the node or its ancestors. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "NodeUtil.getStringValue",
    "class_name": "com.google.javascript.jscomp.NodeUtil",
    "signature": "com.google.javascript.jscomp.NodeUtil.getStringValue(Node)",
    "snippet": "  static String getStringValue(Node n) {\n    // TODO(user): regex literals as well.\n    switch (n.getType()) {\n      case Token.STRING:\n        return n.getString();\n\n      case Token.NAME:\n        String name = n.getString();\n        if (\"undefined\".equals(name)\n            || \"Infinity\".equals(name)\n            || \"NaN\".equals(name)) {\n          return name;\n        }\n        break;\n\n      case Token.NUMBER:\n        return getStringValue(n.getDouble());\n\n      case Token.FALSE:\n      case Token.TRUE:\n      case Token.NULL:\n        return Node.tokenToName(n.getType());\n\n      case Token.VOID:\n        return \"undefined\";\n\n      case Token.NOT:\n        TernaryValue child = getPureBooleanValue(n.getFirstChild());\n        if (child != TernaryValue.UNKNOWN) {\n          return child.toBoolean(true) ? \"false\" : \"true\"; // reversed.\n        }\n        break;\n\n      case Token.ARRAYLIT:\n        return arrayToString(n);\n\n      case Token.OBJECTLIT:\n        return \"[object Object]\";\n    }\n    return null;\n  }",
    "comment": " Gets the value of a node as a String, or null if it cannot be converted. When it returns a non-null String, this method effectively emulates the <code>String()</code> JavaScript cast function. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "NodeUtil.has",
    "class_name": "com.google.javascript.jscomp.NodeUtil",
    "signature": "com.google.javascript.jscomp.NodeUtil.has(Node,Predicate,Predicate)",
    "snippet": "  static boolean has(Node node,\n                     Predicate<Node> pred,\n                     Predicate<Node> traverseChildrenPred) {\n    if (pred.apply(node)) {\n      return true;\n    }\n\n    if (!traverseChildrenPred.apply(node)) {\n      return false;\n    }\n\n    for (Node c = node.getFirstChild(); c != null; c = c.getNext()) {\n      if (has(c, pred, traverseChildrenPred)) {\n        return true;\n      }\n    }\n\n    return false;\n  }",
    "comment": " @return Whether the predicate is true for the node or any of its children. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "NodeUtil.isAssign",
    "class_name": "com.google.javascript.jscomp.NodeUtil",
    "signature": "com.google.javascript.jscomp.NodeUtil.isAssign(Node)",
    "snippet": "  static boolean isAssign(Node n) {\n    return n.getType() == Token.ASSIGN;\n  }",
    "comment": " Is this an ASSIGN node? ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "NodeUtil.isAssignmentOp",
    "class_name": "com.google.javascript.jscomp.NodeUtil",
    "signature": "com.google.javascript.jscomp.NodeUtil.isAssignmentOp(Node)",
    "snippet": "  static boolean isAssignmentOp(Node n) {\n    switch (n.getType()){\n      case Token.ASSIGN:\n      case Token.ASSIGN_BITOR:\n      case Token.ASSIGN_BITXOR:\n      case Token.ASSIGN_BITAND:\n      case Token.ASSIGN_LSH:\n      case Token.ASSIGN_RSH:\n      case Token.ASSIGN_URSH:\n      case Token.ASSIGN_ADD:\n      case Token.ASSIGN_SUB:\n      case Token.ASSIGN_MUL:\n      case Token.ASSIGN_DIV:\n      case Token.ASSIGN_MOD:\n        return true;\n    }\n    return false;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "NodeUtil.isCall",
    "class_name": "com.google.javascript.jscomp.NodeUtil",
    "signature": "com.google.javascript.jscomp.NodeUtil.isCall(Node)",
    "snippet": "  static boolean isCall(Node n) {\n    return n.getType() == Token.CALL;\n  }",
    "comment": " Is this a CALL node? ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "NodeUtil.isConstantByConvention",
    "class_name": "com.google.javascript.jscomp.NodeUtil",
    "signature": "com.google.javascript.jscomp.NodeUtil.isConstantByConvention(CodingConvention,Node,Node)",
    "snippet": "  static boolean isConstantByConvention(\n      CodingConvention convention, Node node, Node parent) {\n    String name = node.getString();\n    if (parent.getType() == Token.GETPROP &&\n        node == parent.getLastChild()) {\n      return convention.isConstantKey(name);\n    } else if (isObjectLitKey(node, parent)) {\n      return convention.isConstantKey(name);\n    } else {\n      return convention.isConstant(name);\n    }\n  }",
    "comment": "Whether the given name is constant by coding convention. */",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "NodeUtil.isControlStructure",
    "class_name": "com.google.javascript.jscomp.NodeUtil",
    "signature": "com.google.javascript.jscomp.NodeUtil.isControlStructure(Node)",
    "snippet": "  static boolean isControlStructure(Node n) {\n    switch (n.getType()) {\n      case Token.FOR:\n      case Token.DO:\n      case Token.WHILE:\n      case Token.WITH:\n      case Token.IF:\n      case Token.LABEL:\n      case Token.TRY:\n      case Token.CATCH:\n      case Token.SWITCH:\n      case Token.CASE:\n      case Token.DEFAULT:\n        return true;\n      default:\n        return false;\n    }\n  }",
    "comment": " Determines whether the given node is a FOR, DO, WHILE, WITH, or IF node. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "NodeUtil.isExprAssign",
    "class_name": "com.google.javascript.jscomp.NodeUtil",
    "signature": "com.google.javascript.jscomp.NodeUtil.isExprAssign(Node)",
    "snippet": "  static boolean isExprAssign(Node n) {\n    return n.getType() == Token.EXPR_RESULT\n        && n.getFirstChild().getType() == Token.ASSIGN;\n  }",
    "comment": " Is this node an assignment expression statement?  @param n The node @return True if {@code n} is EXPR_RESULT and {@code n}'s first child is ASSIGN ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "NodeUtil.isExpressionNode",
    "class_name": "com.google.javascript.jscomp.NodeUtil",
    "signature": "com.google.javascript.jscomp.NodeUtil.isExpressionNode(Node)",
    "snippet": "  static boolean isExpressionNode(Node n) {\n    return n.getType() == Token.EXPR_RESULT;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "NodeUtil.isFunction",
    "class_name": "com.google.javascript.jscomp.NodeUtil",
    "signature": "com.google.javascript.jscomp.NodeUtil.isFunction(Node)",
    "snippet": "  static boolean isFunction(Node n) {\n    return n.getType() == Token.FUNCTION;\n  }",
    "comment": " Is this a FUNCTION node? ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "NodeUtil.isFunctionDeclaration",
    "class_name": "com.google.javascript.jscomp.NodeUtil",
    "signature": "com.google.javascript.jscomp.NodeUtil.isFunctionDeclaration(Node)",
    "snippet": "  static boolean isFunctionDeclaration(Node n) {\n    return n.getType() == Token.FUNCTION && isStatement(n);\n  }",
    "comment": " Is this node a function declaration? A function declaration is a function that has a name that is added to the current scope (i.e. a function that is not part of a expression; see {@link #isFunctionExpression}). ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "NodeUtil.isFunctionExpression",
    "class_name": "com.google.javascript.jscomp.NodeUtil",
    "signature": "com.google.javascript.jscomp.NodeUtil.isFunctionExpression(Node)",
    "snippet": "  static boolean isFunctionExpression(Node n) {\n    return n.getType() == Token.FUNCTION && !isStatement(n);\n  }",
    "comment": " Is a FUNCTION node an function expression? An function expression is one that has either no name or a name that is not added to the current scope.  <p>Some examples of function expressions: <pre> (function () {}) (function f() {})() [ function f() {} ] var f = function f() {}; for (function f() {};;) {} </pre>  <p>Some examples of functions that are <em>not</em> expressions: <pre> function f() {} if (x); else function f() {} for (;;) { function f() {} } </pre>  @param n A node @return Whether n is an function used within an expression. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "NodeUtil.isGet",
    "class_name": "com.google.javascript.jscomp.NodeUtil",
    "signature": "com.google.javascript.jscomp.NodeUtil.isGet(Node)",
    "snippet": "  static boolean isGet(Node n) {\n    return n.getType() == Token.GETPROP\n        || n.getType() == Token.GETELEM;\n  }",
    "comment": " Is this a GETPROP or GETELEM node? ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "NodeUtil.isGetOrSetKey",
    "class_name": "com.google.javascript.jscomp.NodeUtil",
    "signature": "com.google.javascript.jscomp.NodeUtil.isGetOrSetKey(Node)",
    "snippet": "  static boolean isGetOrSetKey(Node node) {\n    switch (node.getType()) {\n      case Token.GET:\n      case Token.SET:\n        return true;\n    }\n    return false;\n  }",
    "comment": " Determines whether a node represents an object literal get or set key (e.g. key1 in {get key1() {}, set key2(a){}).  @param node A node ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "NodeUtil.isHoistedFunctionDeclaration",
    "class_name": "com.google.javascript.jscomp.NodeUtil",
    "signature": "com.google.javascript.jscomp.NodeUtil.isHoistedFunctionDeclaration(Node)",
    "snippet": "  static boolean isHoistedFunctionDeclaration(Node n) {\n    return isFunctionDeclaration(n)\n        && (n.getParent().getType() == Token.SCRIPT\n            || n.getParent().getParent().getType() == Token.FUNCTION);\n  }",
    "comment": " Is this node a hoisted function declaration? A function declaration in the scope root is hoisted to the top of the scope. See {@link #isFunctionDeclaration}). ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "NodeUtil.isImmutableValue",
    "class_name": "com.google.javascript.jscomp.NodeUtil",
    "signature": "com.google.javascript.jscomp.NodeUtil.isImmutableValue(Node)",
    "snippet": "  static boolean isImmutableValue(Node n) {\n    switch (n.getType()) {\n      case Token.STRING:\n      case Token.NUMBER:\n      case Token.NULL:\n      case Token.TRUE:\n      case Token.FALSE:\n        return true;\n      case Token.NOT:\n        return isImmutableValue(n.getFirstChild());\n      case Token.VOID:\n      case Token.NEG:\n        return isImmutableValue(n.getFirstChild());\n      case Token.NAME:\n        String name = n.getString();\n        // We assume here that programs don't change the value of the keyword\n        // undefined to something other than the value undefined.\n        return \"undefined\".equals(name)\n            || \"Infinity\".equals(name)\n            || \"NaN\".equals(name);\n    }\n\n    return false;\n  }",
    "comment": " Returns true if this is an immutable value. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "NodeUtil.isLatin",
    "class_name": "com.google.javascript.jscomp.NodeUtil",
    "signature": "com.google.javascript.jscomp.NodeUtil.isLatin(String)",
    "snippet": "  static boolean isLatin(String s) {\n    char LARGEST_BASIC_LATIN = 0x7f;\n    int len = s.length();\n    for (int index = 0; index < len; index++) {\n      char c = s.charAt(index);\n      if (c > LARGEST_BASIC_LATIN) {\n        return false;\n      }\n    }\n    return true;\n  }",
    "comment": "Test if all characters in the string are in the Basic Latin (aka ASCII) character set - that they have UTF-16 values equal to or below 0x7f. This check can find which identifiers with Unicode characters need to be escaped in order to allow resulting files to be processed by non-Unicode aware UNIX tools and editors.  See http://en.wikipedia.org/wiki/Latin_characters_in_Unicode for more on Basic Latin.  @param s The string to be checked for ASCII-goodness.  @return True if all characters in the string are in Basic Latin set. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "NodeUtil.isLiteralValue",
    "class_name": "com.google.javascript.jscomp.NodeUtil",
    "signature": "com.google.javascript.jscomp.NodeUtil.isLiteralValue(Node,boolean)",
    "snippet": "  static boolean isLiteralValue(Node n, boolean includeFunctions) {\n    switch (n.getType()) {\n      case Token.ARRAYLIT:\n        for (Node child = n.getFirstChild(); child != null;\n             child = child.getNext()) {\n          if (child.getType() != Token.EMPTY\n              && !isLiteralValue(child, includeFunctions)) {\n            return false;\n          }\n        }\n        return true;\n\n      case Token.REGEXP:\n        // Return true only if all children are const.\n        for (Node child = n.getFirstChild(); child != null;\n             child = child.getNext()) {\n          if (!isLiteralValue(child, includeFunctions)) {\n            return false;\n          }\n        }\n        return true;\n\n      case Token.OBJECTLIT:\n        // Return true only if all values are const.\n        for (Node child = n.getFirstChild(); child != null;\n             child = child.getNext()) {\n          if (!isLiteralValue(child.getFirstChild(), includeFunctions)) {\n            return false;\n          }\n        }\n        return true;\n\n      case Token.FUNCTION:\n        return includeFunctions && !NodeUtil.isFunctionDeclaration(n);\n\n      default:\n        return isImmutableValue(n);\n    }\n  }",
    "comment": " Returns true if this is a literal value. We define a literal value as any node that evaluates to the same thing regardless of when or where it is evaluated. So /xyz/ and [3, 5] are literals, but the name a is not.  Function literals do not meet this definition, because they lexically capture variables. For example, if you have <code> function() { return a; } </code> If it is evaluated in a different scope, then it captures a different variable. Even if the function did not read any captured vairables directly, it would still fail this definition, because it affects the lifecycle of variables in the enclosing scope.  However, a function literal with respect to a particular scope is a literal.  @param includeFunctions If true, all function expressions will be treated as literals. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "NodeUtil.isName",
    "class_name": "com.google.javascript.jscomp.NodeUtil",
    "signature": "com.google.javascript.jscomp.NodeUtil.isName(Node)",
    "snippet": "  static boolean isName(Node n) {\n    return n.getType() == Token.NAME;\n  }",
    "comment": " Is this a NAME node? ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "NodeUtil.isObjectLitKey",
    "class_name": "com.google.javascript.jscomp.NodeUtil",
    "signature": "com.google.javascript.jscomp.NodeUtil.isObjectLitKey(Node,Node)",
    "snippet": "  static boolean isObjectLitKey(Node node, Node parent) {\n    switch (node.getType()) {\n      case Token.STRING:\n        return parent.getType() == Token.OBJECTLIT;\n      case Token.GET:\n      case Token.SET:\n        return true;\n    }\n    return false;\n  }",
    "comment": " Determines whether a node represents an object literal key (e.g. key1 in {key1: value1, key2: value2}).  @param node A node @param parent The node's parent ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "NodeUtil.isReferenceName",
    "class_name": "com.google.javascript.jscomp.NodeUtil",
    "signature": "com.google.javascript.jscomp.NodeUtil.isReferenceName(Node)",
    "snippet": "  static boolean isReferenceName(Node n) {\n    return isName(n) && !n.getString().isEmpty();\n  }",
    "comment": " @return Whether the name is a reference to a variable, function or function parameter (not a label or a empty function expression name). ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "NodeUtil.isSimpleOperatorType",
    "class_name": "com.google.javascript.jscomp.NodeUtil",
    "signature": "com.google.javascript.jscomp.NodeUtil.isSimpleOperatorType(int)",
    "snippet": "  static boolean isSimpleOperatorType(int type) {\n    switch (type) {\n      case Token.ADD:\n      case Token.BITAND:\n      case Token.BITNOT:\n      case Token.BITOR:\n      case Token.BITXOR:\n      case Token.COMMA:\n      case Token.DIV:\n      case Token.EQ:\n      case Token.GE:\n      case Token.GETELEM:\n      case Token.GETPROP:\n      case Token.GT:\n      case Token.INSTANCEOF:\n      case Token.LE:\n      case Token.LSH:\n      case Token.LT:\n      case Token.MOD:\n      case Token.MUL:\n      case Token.NE:\n      case Token.NOT:\n      case Token.RSH:\n      case Token.SHEQ:\n      case Token.SHNE:\n      case Token.SUB:\n      case Token.TYPEOF:\n      case Token.VOID:\n      case Token.POS:\n      case Token.NEG:\n      case Token.URSH:\n        return true;\n\n      default:\n        return false;\n    }\n  }",
    "comment": " A \"simple\" operator is one whose children are expressions, has no direct side-effects (unlike '+='), and has no conditional aspects (unlike '||'). ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "NodeUtil.isStatement",
    "class_name": "com.google.javascript.jscomp.NodeUtil",
    "signature": "com.google.javascript.jscomp.NodeUtil.isStatement(Node)",
    "snippet": "  static boolean isStatement(Node n) {\n    return isStatementParent(n.getParent());\n  }",
    "comment": " @return Whether the node is used as a statement. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "NodeUtil.isStatementBlock",
    "class_name": "com.google.javascript.jscomp.NodeUtil",
    "signature": "com.google.javascript.jscomp.NodeUtil.isStatementBlock(Node)",
    "snippet": "  static boolean isStatementBlock(Node n) {\n    return n.getType() == Token.SCRIPT || n.getType() == Token.BLOCK;\n  }",
    "comment": " @return Whether the node is of a type that contain other statements. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "NodeUtil.isStatementParent",
    "class_name": "com.google.javascript.jscomp.NodeUtil",
    "signature": "com.google.javascript.jscomp.NodeUtil.isStatementParent(Node)",
    "snippet": "  static boolean isStatementParent(Node parent) {\n    // It is not possible to determine definitely if a node is a statement\n    // or not if it is not part of the AST.  A FUNCTION node can be\n    // either part of an expression or a statement.\n    Preconditions.checkState(parent != null);\n    switch (parent.getType()) {\n      case Token.SCRIPT:\n      case Token.BLOCK:\n      case Token.LABEL:\n        return true;\n      default:\n        return false;\n    }\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "NodeUtil.isUndefined",
    "class_name": "com.google.javascript.jscomp.NodeUtil",
    "signature": "com.google.javascript.jscomp.NodeUtil.isUndefined(Node)",
    "snippet": "  static boolean isUndefined(Node n) {\n    switch (n.getType()) {\n      case Token.VOID:\n        return true;\n      case Token.NAME:\n        return n.getString().equals(\"undefined\");\n    }\n    return false;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "NodeUtil.isVar",
    "class_name": "com.google.javascript.jscomp.NodeUtil",
    "signature": "com.google.javascript.jscomp.NodeUtil.isVar(Node)",
    "snippet": "  static boolean isVar(Node n) {\n    return n.getType() == Token.VAR;\n  }",
    "comment": " Is this a VAR node? ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "NodeUtil.isVarDeclaration",
    "class_name": "com.google.javascript.jscomp.NodeUtil",
    "signature": "com.google.javascript.jscomp.NodeUtil.isVarDeclaration(Node)",
    "snippet": "  static boolean isVarDeclaration(Node n) {\n    // There is no need to verify that parent != null because a NAME node\n    // always has a parent in a valid parse tree.\n    return n.getType() == Token.NAME && n.getParent().getType() == Token.VAR;\n  }",
    "comment": " Is this node the name of a variable being declared?  @param n The node @return True if {@code n} is NAME and {@code parent} is VAR ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "NodeUtil.mayHaveSideEffects",
    "class_name": "com.google.javascript.jscomp.NodeUtil",
    "signature": "com.google.javascript.jscomp.NodeUtil.mayHaveSideEffects(Node)",
    "snippet": "  static boolean mayHaveSideEffects(Node n) {\n    return mayHaveSideEffects(n, null);\n  }",
    "comment": " Returns true if the node which may have side effects when executed. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "NodeUtil.mayHaveSideEffects",
    "class_name": "com.google.javascript.jscomp.NodeUtil",
    "signature": "com.google.javascript.jscomp.NodeUtil.mayHaveSideEffects(Node,AbstractCompiler)",
    "snippet": "  static boolean mayHaveSideEffects(Node n, AbstractCompiler compiler) {\n    return checkForStateChangeHelper(n, false, compiler);\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "NodeUtil.nodeTypeMayHaveSideEffects",
    "class_name": "com.google.javascript.jscomp.NodeUtil",
    "signature": "com.google.javascript.jscomp.NodeUtil.nodeTypeMayHaveSideEffects(Node)",
    "snippet": "  static boolean nodeTypeMayHaveSideEffects(Node n) {\n    return nodeTypeMayHaveSideEffects(n, null);\n  }",
    "comment": " Returns true if the current node's type implies side effects.  This is a non-recursive version of the may have side effects check; used to check wherever the current node's type is one of the reason's why a subtree has side effects. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "NodeUtil.nodeTypeMayHaveSideEffects",
    "class_name": "com.google.javascript.jscomp.NodeUtil",
    "signature": "com.google.javascript.jscomp.NodeUtil.nodeTypeMayHaveSideEffects(Node,AbstractCompiler)",
    "snippet": "  static boolean nodeTypeMayHaveSideEffects(Node n, AbstractCompiler compiler) {\n    if (isAssignmentOp(n)) {\n      return true;\n    }\n\n    switch(n.getType()) {\n      case Token.DELPROP:\n      case Token.DEC:\n      case Token.INC:\n      case Token.THROW:\n        return true;\n      case Token.CALL:\n        return NodeUtil.functionCallHasSideEffects(n, compiler);\n      case Token.NEW:\n        return NodeUtil.constructorCallHasSideEffects(n, compiler);\n      case Token.NAME:\n        // A variable definition.\n        return n.hasChildren();\n      default:\n        return false;\n    }\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "NodeUtil.opToStr",
    "class_name": "com.google.javascript.jscomp.NodeUtil",
    "signature": "com.google.javascript.jscomp.NodeUtil.opToStr(int)",
    "snippet": "  static String opToStr(int operator) {\n    switch (operator) {\n      case Token.BITOR: return \"|\";\n      case Token.OR: return \"||\";\n      case Token.BITXOR: return \"^\";\n      case Token.AND: return \"&&\";\n      case Token.BITAND: return \"&\";\n      case Token.SHEQ: return \"===\";\n      case Token.EQ: return \"==\";\n      case Token.NOT: return \"!\";\n      case Token.NE: return \"!=\";\n      case Token.SHNE: return \"!==\";\n      case Token.LSH: return \"<<\";\n      case Token.IN: return \"in\";\n      case Token.LE: return \"<=\";\n      case Token.LT: return \"<\";\n      case Token.URSH: return \">>>\";\n      case Token.RSH: return \">>\";\n      case Token.GE: return \">=\";\n      case Token.GT: return \">\";\n      case Token.MUL: return \"*\";\n      case Token.DIV: return \"/\";\n      case Token.MOD: return \"%\";\n      case Token.BITNOT: return \"~\";\n      case Token.ADD: return \"+\";\n      case Token.SUB: return \"-\";\n      case Token.POS: return \"+\";\n      case Token.NEG: return \"-\";\n      case Token.ASSIGN: return \"=\";\n      case Token.ASSIGN_BITOR: return \"|=\";\n      case Token.ASSIGN_BITXOR: return \"^=\";\n      case Token.ASSIGN_BITAND: return \"&=\";\n      case Token.ASSIGN_LSH: return \"<<=\";\n      case Token.ASSIGN_RSH: return \">>=\";\n      case Token.ASSIGN_URSH: return \">>>=\";\n      case Token.ASSIGN_ADD: return \"+=\";\n      case Token.ASSIGN_SUB: return \"-=\";\n      case Token.ASSIGN_MUL: return \"*=\";\n      case Token.ASSIGN_DIV: return \"/=\";\n      case Token.ASSIGN_MOD: return \"%=\";\n      case Token.VOID: return \"void\";\n      case Token.TYPEOF: return \"typeof\";\n      case Token.INSTANCEOF: return \"instanceof\";\n      default: return null;\n    }\n  }",
    "comment": " Converts an operator's token value (see {@link Token}) to a string representation.  @param operator the operator's token value to convert @return the string representation or {@code null} if the token value is not an operator ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "NodeUtil.precedence",
    "class_name": "com.google.javascript.jscomp.NodeUtil",
    "signature": "com.google.javascript.jscomp.NodeUtil.precedence(int)",
    "snippet": "  static int precedence(int type) {\n    switch (type) {\n      case Token.COMMA:  return 0;\n      case Token.ASSIGN_BITOR:\n      case Token.ASSIGN_BITXOR:\n      case Token.ASSIGN_BITAND:\n      case Token.ASSIGN_LSH:\n      case Token.ASSIGN_RSH:\n      case Token.ASSIGN_URSH:\n      case Token.ASSIGN_ADD:\n      case Token.ASSIGN_SUB:\n      case Token.ASSIGN_MUL:\n      case Token.ASSIGN_DIV:\n      case Token.ASSIGN_MOD:\n      case Token.ASSIGN: return 1;\n      case Token.HOOK:   return 2;  // ?: operator\n      case Token.OR:     return 3;\n      case Token.AND:    return 4;\n      case Token.BITOR:  return 5;\n      case Token.BITXOR: return 6;\n      case Token.BITAND: return 7;\n      case Token.EQ:\n      case Token.NE:\n      case Token.SHEQ:\n      case Token.SHNE:   return 8;\n      case Token.LT:\n      case Token.GT:\n      case Token.LE:\n      case Token.GE:\n      case Token.INSTANCEOF:\n      case Token.IN:     return 9;\n      case Token.LSH:\n      case Token.RSH:\n      case Token.URSH:   return 10;\n      case Token.SUB:\n      case Token.ADD:    return 11;\n      case Token.MUL:\n      case Token.MOD:\n      case Token.DIV:    return 12;\n      case Token.INC:\n      case Token.DEC:\n      case Token.NEW:\n      case Token.DELPROP:\n      case Token.TYPEOF:\n      case Token.VOID:\n      case Token.NOT:\n      case Token.BITNOT:\n      case Token.POS:\n      case Token.NEG:    return 13;\n\n      case Token.CALL:\n      case Token.GETELEM:\n      case Token.GETPROP:\n      // Data values\n      case Token.ARRAYLIT:\n      case Token.EMPTY:  // TODO(johnlenz): remove this.\n      case Token.FALSE:\n      case Token.FUNCTION:\n      case Token.NAME:\n      case Token.NULL:\n      case Token.NUMBER:\n      case Token.OBJECTLIT:\n      case Token.REGEXP:\n      case Token.STRING:\n      case Token.THIS:\n      case Token.TRUE:\n        return 15;\n\n      default: throw new Error(\"Unknown precedence for \" +\n                               Node.tokenToName(type) +\n                               \" (type \" + type + \")\");\n    }\n  }",
    "comment": " 0 comma , 1 assignment = += -= *= /= %= <<= >>= >>>= &= ^= |= 2 conditional ?: 3 logical-or || 4 logical-and && 5 bitwise-or | 6 bitwise-xor ^ 7 bitwise-and & 8 equality == != 9 relational < <= > >= 10 bitwise shift << >> >>> 11 addition/subtraction + - 12 multiply/divide * / % 13 negation/increment ! ~ - ++ -- 14 call, member () [] . ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "NodeUtil.tryMergeBlock",
    "class_name": "com.google.javascript.jscomp.NodeUtil",
    "signature": "com.google.javascript.jscomp.NodeUtil.tryMergeBlock(Node)",
    "snippet": "  static boolean tryMergeBlock(Node block) {\n    Preconditions.checkState(block.getType() == Token.BLOCK);\n    Node parent = block.getParent();\n    // Try to remove the block if its parent is a block/script or if its\n    // parent is label and it has exactly one child.\n    if (isStatementBlock(parent)) {\n      Node previous = block;\n      while (block.hasChildren()) {\n        Node child = block.removeFirstChild();\n        parent.addChildAfter(child, previous);\n        previous = child;\n      }\n      parent.removeChild(block);\n      return true;\n    } else {\n      return false;\n    }\n  }",
    "comment": " Merge a block with its parent block. @return Whether the block was removed. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "MatchNodeType.apply",
    "class_name": "com.google.javascript.jscomp.NodeUtil$MatchNodeType",
    "signature": "com.google.javascript.jscomp.NodeUtil$MatchNodeType.apply(Node)",
    "snippet": "    public boolean apply(Node n) {\n      return n.getType() == type;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "Normalize.Normalize",
    "class_name": "com.google.javascript.jscomp.Normalize",
    "signature": "com.google.javascript.jscomp.Normalize.Normalize(AbstractCompiler,boolean)",
    "snippet": "  Normalize(AbstractCompiler compiler, boolean assertOnChange) {\n    this.compiler = compiler;\n    this.assertOnChange = assertOnChange;\n\n    // TODO(nicksantos): assertOnChange should only be true if the tree\n    // is normalized.\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "Normalize.process",
    "class_name": "com.google.javascript.jscomp.Normalize",
    "signature": "com.google.javascript.jscomp.Normalize.process(Node,Node)",
    "snippet": "  @Override\n  public void process(Node externs, Node root) {\n    new NodeTraversal(\n        compiler, new NormalizeStatements(compiler, assertOnChange))\n        .traverseRoots(externs, root);\n    if (MAKE_LOCAL_NAMES_UNIQUE) {\n      MakeDeclaredNamesUnique renamer = new MakeDeclaredNamesUnique();\n      NodeTraversal t = new NodeTraversal(compiler, renamer);\n      t.traverseRoots(externs, root);\n    }\n    // It is important that removeDuplicateDeclarations runs after\n    // MakeDeclaredNamesUnique in order for catch block exception names to be\n    // handled properly. Specifically, catch block exception names are\n    // only valid within the catch block, but our currect Scope logic\n    // has no concept of this and includes it in the containing function\n    // (or global scope). MakeDeclaredNamesUnique makes the catch exception\n    // names unique so that removeDuplicateDeclarations() will properly handle\n    // cases where a function scope variable conflict with a exception name:\n    //   function f() {\n    //      try {throw 0;} catch(e) {e; /* catch scope 'e'*/}\n    //      var e = 1; // f scope 'e'\n    //   }\n    // otherwise 'var e = 1' would be rewritten as 'e = 1'.\n    // TODO(johnlenz): Introduce a seperate scope for catch nodes.\n    removeDuplicateDeclarations(externs, root);\n    new PropagateConstantAnnotationsOverVars(compiler, assertOnChange)\n        .process(externs, root);\n\n    if (!compiler.getLifeCycleStage().isNormalized()) {\n      compiler.setLifeCycleStage(LifeCycleStage.NORMALIZED);\n    }\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "Normalize.removeDuplicateDeclarations",
    "class_name": "com.google.javascript.jscomp.Normalize",
    "signature": "com.google.javascript.jscomp.Normalize.removeDuplicateDeclarations(Node,Node)",
    "snippet": "  private void removeDuplicateDeclarations(Node externs, Node root) {\n    Callback tickler = new ScopeTicklingCallback();\n    ScopeCreator scopeCreator =  new SyntacticScopeCreator(\n        compiler, new DuplicateDeclarationHandler());\n    NodeTraversal t = new NodeTraversal(compiler, tickler, scopeCreator);\n    t.traverseRoots(externs, root);\n  }",
    "comment": " Remove duplicate VAR declarations. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "NormalizeStatements.annotateConstantsByConvention",
    "class_name": "com.google.javascript.jscomp.Normalize$NormalizeStatements",
    "signature": "com.google.javascript.jscomp.Normalize$NormalizeStatements.annotateConstantsByConvention(Node,Node)",
    "snippet": "    private void annotateConstantsByConvention(Node n, Node parent) {\n      Preconditions.checkState(\n          n.getType() == Token.NAME\n          || n.getType() == Token.STRING\n          || n.getType() == Token.GET\n          || n.getType() == Token.SET);\n\n      // There are only two cases where a string token\n      // may be a variable reference: The right side of a GETPROP\n      // or an OBJECTLIT key.\n      boolean isObjLitKey = NodeUtil.isObjectLitKey(n, parent);\n      boolean isProperty = isObjLitKey ||\n          (parent.getType() == Token.GETPROP &&\n           parent.getLastChild() == n);\n      if (n.getType() == Token.NAME || isProperty) {\n        boolean isMarkedConstant = n.getBooleanProp(Node.IS_CONSTANT_NAME);\n        if (!isMarkedConstant &&\n            NodeUtil.isConstantByConvention(\n                compiler.getCodingConvention(), n, parent)) {\n          if (assertOnChange) {\n            String name = n.getString();\n            throw new IllegalStateException(\n                \"Unexpected const change.\\n\" +\n                \"  name: \"+ name + \"\\n\" +\n                \"  parent:\" + n.getParent().toStringTree());\n          }\n          n.putBooleanProp(Node.IS_CONSTANT_NAME, true);\n        }\n      }\n    }",
    "comment": " Mark names and properties that are constants by convention. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "NormalizeStatements.doStatementNormalizations",
    "class_name": "com.google.javascript.jscomp.Normalize$NormalizeStatements",
    "signature": "com.google.javascript.jscomp.Normalize$NormalizeStatements.doStatementNormalizations(NodeTraversal,Node,Node)",
    "snippet": "    private void doStatementNormalizations(\n        NodeTraversal t, Node n, Node parent) {\n      if (n.getType() == Token.LABEL) {\n        normalizeLabels(n);\n      }\n\n      // Only inspect the children of SCRIPTs, BLOCKs and LABELs, as all these\n      // are the only legal place for VARs and FOR statements.\n      if (NodeUtil.isStatementBlock(n) || n.getType() == Token.LABEL) {\n        extractForInitializer(n, null, null);\n      }\n\n      // Only inspect the children of SCRIPTs, BLOCKs, as all these\n      // are the only legal place for VARs.\n      if (NodeUtil.isStatementBlock(n)) {\n        splitVarDeclarations(n);\n      }\n\n      if (n.getType() == Token.FUNCTION) {\n        moveNamedFunctions(n.getLastChild());\n      }\n    }",
    "comment": " Do normalizations that introduce new siblings or parents. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "NormalizeStatements.extractForInitializer",
    "class_name": "com.google.javascript.jscomp.Normalize$NormalizeStatements",
    "signature": "com.google.javascript.jscomp.Normalize$NormalizeStatements.extractForInitializer(Node,Node,Node)",
    "snippet": "    private void extractForInitializer(\n        Node n, Node before, Node beforeParent) {\n\n      for (Node next, c = n.getFirstChild(); c != null; c = next) {\n        next = c.getNext();\n        Node insertBefore = (before == null) ? c : before;\n        Node insertBeforeParent = (before == null) ? n : beforeParent;\n        switch (c.getType()) {\n          case Token.LABEL:\n            extractForInitializer(c, insertBefore, insertBeforeParent);\n            break;\n          case Token.FOR:\n            if (NodeUtil.isForIn(c)) {\n              Node first = c.getFirstChild();\n              if (first.getType() == Token.VAR) {\n                // Transform:\n                //    for (var a = 1 in b) {}\n                // to:\n                //    var a = 1; for (a in b) {};\n                Node newStatement = first;\n                // Clone just the node, to remove any initialization.\n                Node name = newStatement.getFirstChild().cloneNode();\n                first.getParent().replaceChild(first, name);\n                insertBeforeParent.addChildBefore(newStatement, insertBefore);\n                reportCodeChange(\"FOR-IN var declaration\");\n              }\n            } else if (c.getFirstChild().getType() != Token.EMPTY) {\n              Node init = c.getFirstChild();\n              Node empty = new Node(Token.EMPTY);\n              empty.copyInformationFrom(c);\n              c.replaceChild(init, empty);\n\n              Node newStatement;\n              // Only VAR statements, and expressions are allowed,\n              // but are handled differently.\n              if (init.getType() == Token.VAR) {\n                newStatement = init;\n              } else {\n                newStatement = NodeUtil.newExpr(init);\n              }\n\n              insertBeforeParent.addChildBefore(newStatement, insertBefore);\n              reportCodeChange(\"FOR initializer\");\n            }\n            break;\n        }\n      }\n    }",
    "comment": " Bring the initializers out of FOR loops.  These need to be placed before any associated LABEL nodes. This needs to be done from the top level label first so this is called as a pre-order callback (from shouldTraverse).  @param n The node to inspect. @param before The node to insert the initializer before. @param beforeParent The parent of the node before which the initializer will be inserted. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "NormalizeStatements.moveNamedFunctions",
    "class_name": "com.google.javascript.jscomp.Normalize$NormalizeStatements",
    "signature": "com.google.javascript.jscomp.Normalize$NormalizeStatements.moveNamedFunctions(Node)",
    "snippet": "    private void moveNamedFunctions(Node functionBody) {\n      Preconditions.checkState(\n          functionBody.getParent().getType() == Token.FUNCTION);\n      Node previous = null;\n      Node current = functionBody.getFirstChild();\n      // Skip any declarations at the beginning of the function body, they\n      // are already in the right place.\n      while (current != null && NodeUtil.isFunctionDeclaration(current)) {\n        previous = current;\n        current = current.getNext();\n      }\n\n      // Find any remaining declarations and move them.\n      Node insertAfter = previous;\n      while (current != null) {\n        // Save off the next node as the current node maybe removed.\n        Node next = current.getNext();\n        if (NodeUtil.isFunctionDeclaration(current)) {\n          // Remove the declaration from the body.\n          Preconditions.checkNotNull(previous);\n          functionBody.removeChildAfter(previous);\n\n          // Readd the function at the top of the function body (after any\n          // previous declarations).\n          insertAfter = addToFront(functionBody, current, insertAfter);\n          reportCodeChange(\"Move function declaration not at top of function\");\n        } else {\n          // Update the previous only if the current node hasn't been moved.\n          previous = current;\n        }\n        current = next;\n      }\n    }",
    "comment": " Move all the functions that are valid at the execution of the first statement of the function to the beginning of the function definition. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "NormalizeStatements.normalizeFunctionDeclaration",
    "class_name": "com.google.javascript.jscomp.Normalize$NormalizeStatements",
    "signature": "com.google.javascript.jscomp.Normalize$NormalizeStatements.normalizeFunctionDeclaration(Node)",
    "snippet": "    private void normalizeFunctionDeclaration(Node n) {\n      Preconditions.checkState(n.getType() == Token.FUNCTION);\n      if (!NodeUtil.isFunctionExpression(n)\n          && !NodeUtil.isHoistedFunctionDeclaration(n)) {\n        rewriteFunctionDeclaration(n);\n      }\n    }",
    "comment": " Rewrite named unhoisted functions declarations to a known consistent behavior so we don't to different logic paths for the same code. From: function f() {} to: var f = function () {}; ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "NormalizeStatements.shouldTraverse",
    "class_name": "com.google.javascript.jscomp.Normalize$NormalizeStatements",
    "signature": "com.google.javascript.jscomp.Normalize$NormalizeStatements.shouldTraverse(NodeTraversal,Node,Node)",
    "snippet": "    @Override\n    public boolean shouldTraverse(NodeTraversal t, Node n, Node parent) {\n      doStatementNormalizations(t, n, parent);\n\n      return true;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "NormalizeStatements.splitVarDeclarations",
    "class_name": "com.google.javascript.jscomp.Normalize$NormalizeStatements",
    "signature": "com.google.javascript.jscomp.Normalize$NormalizeStatements.splitVarDeclarations(Node)",
    "snippet": "    private void splitVarDeclarations(Node n) {\n      for (Node next, c = n.getFirstChild(); c != null; c = next) {\n        next = c.getNext();\n        if (c.getType() == Token.VAR) {\n          if (assertOnChange && !c.hasChildren()) {\n            throw new IllegalStateException(\"Empty VAR node.\");\n          }\n\n          while (c.getFirstChild() != c.getLastChild()) {\n            Node name = c.getFirstChild();\n            c.removeChild(name);\n            Node newVar = new Node(\n                Token.VAR, name, n.getLineno(), n.getCharno());\n            n.addChildBefore(newVar, c);\n            reportCodeChange(\"VAR with multiple children\");\n          }\n        }\n      }\n    }",
    "comment": " Split a var node such as: var a, b; into individual statements: var a; var b; @param n The whose children we should inspect. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "NormalizeStatements.visit",
    "class_name": "com.google.javascript.jscomp.Normalize$NormalizeStatements",
    "signature": "com.google.javascript.jscomp.Normalize$NormalizeStatements.visit(NodeTraversal,Node,Node)",
    "snippet": "    @Override\n    public void visit(NodeTraversal t, Node n, Node parent) {\n      switch (n.getType()) {\n        case Token.WHILE:\n          if (CONVERT_WHILE_TO_FOR) {\n            Node expr = n.getFirstChild();\n            n.setType(Token.FOR);\n            Node empty = new Node(Token.EMPTY);\n            empty.copyInformationFrom(n);\n            n.addChildBefore(empty, expr);\n            n.addChildAfter(empty.cloneNode(), expr);\n            reportCodeChange(\"WHILE node\");\n          }\n          break;\n\n        case Token.FUNCTION:\n          normalizeFunctionDeclaration(n);\n          break;\n\n        case Token.NAME:\n        case Token.STRING:\n        case Token.GET:\n        case Token.SET:\n          if (!compiler.getLifeCycleStage().isNormalizedObfuscated()) {\n            annotateConstantsByConvention(n, parent);\n          }\n          break;\n      }\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "PropagateConstantAnnotationsOverVars.process",
    "class_name": "com.google.javascript.jscomp.Normalize$PropagateConstantAnnotationsOverVars",
    "signature": "com.google.javascript.jscomp.Normalize$PropagateConstantAnnotationsOverVars.process(Node,Node)",
    "snippet": "    @Override\n    public void process(Node externs, Node root) {\n      new NodeTraversal(compiler, this).traverseRoots(externs, root);\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "PropagateConstantAnnotationsOverVars.visit",
    "class_name": "com.google.javascript.jscomp.Normalize$PropagateConstantAnnotationsOverVars",
    "signature": "com.google.javascript.jscomp.Normalize$PropagateConstantAnnotationsOverVars.visit(NodeTraversal,Node,Node)",
    "snippet": "    @Override\n    public void visit(NodeTraversal t, Node n, Node parent) {\n      // Note: Constant properties annotations are not propagated.\n      if (n.getType() == Token.NAME) {\n        if (n.getString().isEmpty()) {\n          return;\n        }\n\n        JSDocInfo info = null;\n        // Find the JSDocInfo for a top level variable.\n        Var var = t.getScope().getVar(n.getString());\n        if (var != null) {\n          info = var.getJSDocInfo();\n        }\n\n        boolean shouldBeConstant =\n            (info != null && info.isConstant()) ||\n            NodeUtil.isConstantByConvention(\n                compiler.getCodingConvention(), n, parent);\n        boolean isMarkedConstant = n.getBooleanProp(Node.IS_CONSTANT_NAME);\n        if (shouldBeConstant && !isMarkedConstant) {\n          if (assertOnChange) {\n            String name = n.getString();\n            throw new IllegalStateException(\n                \"Unexpected const change.\\n\" +\n                \"  name: \"+ name + \"\\n\" +\n                \"  parent:\" + n.getParent().toStringTree());\n          }\n          n.putBooleanProp(Node.IS_CONSTANT_NAME, true);\n        }\n      }\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "ScopeTicklingCallback.enterScope",
    "class_name": "com.google.javascript.jscomp.Normalize$ScopeTicklingCallback",
    "signature": "com.google.javascript.jscomp.Normalize$ScopeTicklingCallback.enterScope(NodeTraversal)",
    "snippet": "    @Override\n    public void enterScope(NodeTraversal t) {\n      // Cause the scope to be created, which will cause duplicate\n      // to be found.\n      t.getScope();\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "ScopeTicklingCallback.exitScope",
    "class_name": "com.google.javascript.jscomp.Normalize$ScopeTicklingCallback",
    "signature": "com.google.javascript.jscomp.Normalize$ScopeTicklingCallback.exitScope(NodeTraversal)",
    "snippet": "    @Override\n    public void exitScope(NodeTraversal t) {\n      // Nothing to do.\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "ScopeTicklingCallback.shouldTraverse",
    "class_name": "com.google.javascript.jscomp.Normalize$ScopeTicklingCallback",
    "signature": "com.google.javascript.jscomp.Normalize$ScopeTicklingCallback.shouldTraverse(NodeTraversal,Node,Node)",
    "snippet": "    @Override\n    public boolean shouldTraverse(\n        NodeTraversal nodeTraversal, Node n, Node parent) {\n      return true;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "ScopeTicklingCallback.visit",
    "class_name": "com.google.javascript.jscomp.Normalize$ScopeTicklingCallback",
    "signature": "com.google.javascript.jscomp.Normalize$ScopeTicklingCallback.visit(NodeTraversal,Node,Node)",
    "snippet": "    @Override\n    public void visit(NodeTraversal t, Node n, Node parent) {\n      // Nothing to do.\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "OperaCompoundAssignFix.OperaCompoundAssignFix",
    "class_name": "com.google.javascript.jscomp.OperaCompoundAssignFix",
    "signature": "com.google.javascript.jscomp.OperaCompoundAssignFix.OperaCompoundAssignFix(AbstractCompiler)",
    "snippet": "  OperaCompoundAssignFix(AbstractCompiler compiler) {\n    this.compiler = compiler;\n    names = Lists.newLinkedList();\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "OperaCompoundAssignFix.enterScope",
    "class_name": "com.google.javascript.jscomp.OperaCompoundAssignFix",
    "signature": "com.google.javascript.jscomp.OperaCompoundAssignFix.enterScope(NodeTraversal)",
    "snippet": "  @Override\n  public void enterScope(NodeTraversal t) {\n    names.push(new VariableNameGenerator(t.getScope()));\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "OperaCompoundAssignFix.exitScope",
    "class_name": "com.google.javascript.jscomp.OperaCompoundAssignFix",
    "signature": "com.google.javascript.jscomp.OperaCompoundAssignFix.exitScope(NodeTraversal)",
    "snippet": "  @Override\n  public void exitScope(NodeTraversal t) {\n    names.pop();\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "OperaCompoundAssignFix.process",
    "class_name": "com.google.javascript.jscomp.OperaCompoundAssignFix",
    "signature": "com.google.javascript.jscomp.OperaCompoundAssignFix.process(Node,Node)",
    "snippet": "  @Override\n  public void process(Node externs, Node root) {\n    List<Node> code = Lists.newArrayList(externs, root);\n    NodeTraversal.traverseRoots(compiler, code, this);\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "OperaCompoundAssignFix.visit",
    "class_name": "com.google.javascript.jscomp.OperaCompoundAssignFix",
    "signature": "com.google.javascript.jscomp.OperaCompoundAssignFix.visit(NodeTraversal,Node,Node)",
    "snippet": "  @Override\n  public void visit(NodeTraversal t, Node n, Node parent) {\n    if (!NodeUtil.isName(n)) {\n      return;\n    }\n\n    if (!NodeUtil.isGet(parent)) {\n      return;\n    }\n\n    boolean nested = false;\n    boolean reassign = false;\n    Node lastAssign = null;\n    Node prevParent = n;\n\n    while (!(NodeUtil.isExpressionNode(parent) ||\n             NodeUtil.isStatementBlock(parent))) {\n      if (NodeUtil.isAssign(parent) &&\n          NodeUtil.isName(parent.getFirstChild()) &&\n          parent.getFirstChild().getString().equals(n.getString()) &&\n          nested) {\n        reassign = true;\n        break;\n      } else if (NodeUtil.isAssignmentOp(parent) &&\n          parent.getLastChild() == prevParent) {\n        if (lastAssign == null) {\n          nested = true;\n        }\n        lastAssign = parent;\n      }\n      prevParent = parent;\n      parent = parent.getParent();\n    }\n\n    if (!(reassign && nested)) {\n      return;\n    }\n\n    applyWorkAround(parent, t);\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "OptimizeArgumentsArray.OptimizeArgumentsArray",
    "class_name": "com.google.javascript.jscomp.OptimizeArgumentsArray",
    "signature": "com.google.javascript.jscomp.OptimizeArgumentsArray.OptimizeArgumentsArray(AbstractCompiler)",
    "snippet": "  OptimizeArgumentsArray(AbstractCompiler compiler) {\n    this(compiler, PARAMETER_PREFIX);\n  }",
    "comment": " Construct this pass and use {@link #PARAMETER_PREFIX} as the prefix for all parameter names that it introduces. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "OptimizeArgumentsArray.OptimizeArgumentsArray",
    "class_name": "com.google.javascript.jscomp.OptimizeArgumentsArray",
    "signature": "com.google.javascript.jscomp.OptimizeArgumentsArray.OptimizeArgumentsArray(AbstractCompiler,String)",
    "snippet": "  OptimizeArgumentsArray(AbstractCompiler compiler, String paramPrefix) {\n    this.compiler = Preconditions.checkNotNull(compiler);\n    this.paramPredix = Preconditions.checkNotNull(paramPrefix);\n  }",
    "comment": " @param paramPrefix the prefix to use for all parameter names that this pass introduces ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "OptimizeArgumentsArray.enterScope",
    "class_name": "com.google.javascript.jscomp.OptimizeArgumentsArray",
    "signature": "com.google.javascript.jscomp.OptimizeArgumentsArray.enterScope(NodeTraversal)",
    "snippet": "  @Override\n  public void enterScope(NodeTraversal traversal) {\n    Preconditions.checkNotNull(traversal);\n\n    // This optimization is valid only within a function so we are going to\n    // skip over the initial entry to the global scope.\n    Node function = traversal.getScopeRoot();\n    if (!NodeUtil.isFunction(function)) {\n      return;\n    }\n\n    // Introduces a new access list and stores the access list of the outer\n    // scope in the stack if necessary.\n    if (currentArgumentsAccess != null) {\n      argumentsAccessStack.push(currentArgumentsAccess);\n    }\n    currentArgumentsAccess = Lists.newLinkedList();\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "OptimizeArgumentsArray.exitScope",
    "class_name": "com.google.javascript.jscomp.OptimizeArgumentsArray",
    "signature": "com.google.javascript.jscomp.OptimizeArgumentsArray.exitScope(NodeTraversal)",
    "snippet": "  @Override\n  public void exitScope(NodeTraversal traversal) {\n    Preconditions.checkNotNull(traversal);\n\n    // This is the case when we are exiting the global scope where we had never\n    // collected argument access list. Since we do not perform this optimization\n    // for the global scope, we will skip this exit point.\n    if (currentArgumentsAccess == null) {\n      return;\n    }\n\n    // Attempt to replace the argument access and if the AST has been change,\n    // report back to the compiler.\n    if (tryReplaceArguments(traversal.getScope())) {\n      traversal.getCompiler().reportCodeChange();\n    }\n\n    // After the attempt to replace the arguments. The currentArgumentsAccess\n    // is stale and as we exit the Scope, no longer holds all the access to the\n    // current scope anymore. We'll pop the access list from the outer scope\n    // and set it as currentArgumentsAcess if the outer scope is not the global\n    // scope.\n    if (!argumentsAccessStack.isEmpty()) {\n      currentArgumentsAccess = argumentsAccessStack.pop();\n    } else {\n      currentArgumentsAccess = null;\n    }\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "OptimizeArgumentsArray.process",
    "class_name": "com.google.javascript.jscomp.OptimizeArgumentsArray",
    "signature": "com.google.javascript.jscomp.OptimizeArgumentsArray.process(Node,Node)",
    "snippet": "  @Override\n  public void process(Node externs, Node root) {\n    NodeTraversal.traverse(compiler, Preconditions.checkNotNull(root), this);\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "OptimizeArgumentsArray.shouldTraverse",
    "class_name": "com.google.javascript.jscomp.OptimizeArgumentsArray",
    "signature": "com.google.javascript.jscomp.OptimizeArgumentsArray.shouldTraverse(NodeTraversal,Node,Node)",
    "snippet": "  @Override\n  public boolean shouldTraverse(\n      NodeTraversal nodeTraversal, Node node, Node parent) {\n    // We will continuously recurse down the AST regardless of the node types.\n    return true;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "OptimizeArgumentsArray.tryReplaceArguments",
    "class_name": "com.google.javascript.jscomp.OptimizeArgumentsArray",
    "signature": "com.google.javascript.jscomp.OptimizeArgumentsArray.tryReplaceArguments(Scope)",
    "snippet": "  private boolean tryReplaceArguments(Scope scope) {\n\n    Node parametersList = scope.getRootNode().getFirstChild().getNext();\n    Preconditions.checkState(parametersList.getType() == Token.LP);\n\n    // Keep track of rather this function modified the AST and needs to be\n    // reported back to the compiler later.\n    boolean changed = false;\n\n    // Number of parameter that can be accessed without using the arguments\n    // array.\n    int numNamedParameter = parametersList.getChildCount();\n\n    // We want to guess what the highest index that has been access from the\n    // arguments array. We will guess that it does not use anything index higher\n    // than the named parameter list first until we see other wise.\n    int highestIndex = numNamedParameter - 1;\n\n    // Iterate through all the references to arguments array in the function to\n    // determine the real highestIndex.\n    for (Node ref : currentArgumentsAccess) {\n\n      Node getElem = ref.getParent();\n\n      // Bail on anything but argument[c] access where c is a constant.\n      // TODO(user): We might not need to bail out all the time, there might\n      // be more cases that we can cover.\n      if (getElem.getType() != Token.GETELEM) {\n        return false;\n      }\n\n      Node index = ref.getNext();\n\n      // We have something like arguments[x] where x is not a constant. That\n      // means at least one of the access is not known.\n      if (index.getType() != Token.NUMBER) {\n        // TODO(user): Its possible not to give up just yet. The type\n        // inference did a 'semi value propagation'. If we know that string\n        // is never a subclass of the type of the index. We'd know that\n        // it is never 'callee'.\n        return false; // Give up.\n      }\n\n      Node getElemParent = getElem.getParent();\n      // When we have argument[0](), replacing it with a() is semantically\n      // different if argument[0] is a function call that refers to 'this'\n      if (NodeUtil.isCall(getElemParent) &&\n          getElemParent.getFirstChild() == getElem) {\n        // TODO(user): We can consider using .call() if aliasing that\n        // argument allows shorter alias for other arguments.\n        return false;\n      }\n\n      // Replace the highest index if we see an access that has a higher index\n      // than all the one we saw before.\n      int value = (int) index.getDouble();\n      if (value > highestIndex) {\n        highestIndex = value;\n      }\n    }\n\n    // Number of extra arguments we need.\n    // For example: function() { arguments[3] } access index 3 so\n    // it will need 4 extra named arguments to changed into:\n    // function(a,b,c,d) { d }.\n    int numExtraArgs = highestIndex - numNamedParameter + 1;\n\n    // Temporary holds the new names as string for quick access later.\n    String[] argNames = new String[numExtraArgs];\n\n    // Insert the formal parameter to the method's signature.\n    // Example: function() --> function(r0, r1, r2)\n    for (int i = 0; i < numExtraArgs; i++) {\n      String name = getNewName();\n      argNames[i] = name;\n      parametersList.addChildrenToBack(Node.newString(Token.NAME, name));\n      changed = true;\n    }\n\n    // This loop performs the replacement of arguments[x] -> a if x is known.\n    for (Node ref : currentArgumentsAccess) {\n      Node index = ref.getNext();\n\n      // Skip if it is unknown.\n      if (index.getType() != Token.NUMBER) {\n        continue;\n      }\n      int value = (int) index.getDouble();\n\n      // Unnamed parameter.\n      if (value >= numNamedParameter) {\n        ref.getParent().getParent().replaceChild(ref.getParent(),\n            Node.newString(Token.NAME, argNames[value - numNamedParameter]));\n      } else {\n\n        // Here, for no apparent reason, the user is accessing a named parameter\n        // with arguments[idx]. We can replace it with the actual name for them.\n        Node name = parametersList.getFirstChild();\n\n        // This is a linear search for the actual name from the signature.\n        // It is not necessary to make this fast because chances are the user\n        // will not deliberately write code like this.\n        for (int i = 0; i < value; i++) {\n          name = name.getNext();\n        }\n        ref.getParent().getParent().replaceChild(ref.getParent(),\n            Node.newString(Token.NAME, name.getString()));\n      }\n      changed = true;\n    }\n\n    return changed;\n  }",
    "comment": " Tries to optimize all the arguments array access in this scope by assigning a name to each element.  @param scope scope of the function @return true if any modification has been done to the AST ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "OptimizeArgumentsArray.visit",
    "class_name": "com.google.javascript.jscomp.OptimizeArgumentsArray",
    "signature": "com.google.javascript.jscomp.OptimizeArgumentsArray.visit(NodeTraversal,Node,Node)",
    "snippet": "  @Override\n  public void visit(NodeTraversal traversal, Node node, Node parent) {\n    Preconditions.checkNotNull(traversal);\n    Preconditions.checkNotNull(node);\n\n\n    // Searches for all the references to the arguments array.\n\n    // We don't have an arguments list set up for this scope. This implies we\n    // are currently in the global scope so we will not record any arguments\n    // array access.\n    if (currentArgumentsAccess == null) {\n      return;\n    }\n\n    // Otherwise, we are in a function scope and we should record if the current\n    // name is referring to the implicit arguments array.\n    if (NodeUtil.isName(node) && ARGUMENTS.equals(node.getString())) {\n      currentArgumentsAccess.add(node);\n    }\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "PassConfig.PassConfig",
    "class_name": "com.google.javascript.jscomp.PassConfig",
    "signature": "com.google.javascript.jscomp.PassConfig.PassConfig(CompilerOptions)",
    "snippet": "  public PassConfig(CompilerOptions options) {\n    this.options = options;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "PassConfig.getTypedScopeCreator",
    "class_name": "com.google.javascript.jscomp.PassConfig",
    "signature": "com.google.javascript.jscomp.PassConfig.getTypedScopeCreator()",
    "snippet": "  MemoizedScopeCreator getTypedScopeCreator() {\n    return typedScopeCreator;\n  }",
    "comment": " Gets the scope creator for typed scopes. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "PassConfig.makeTypeCheck",
    "class_name": "com.google.javascript.jscomp.PassConfig",
    "signature": "com.google.javascript.jscomp.PassConfig.makeTypeCheck(AbstractCompiler)",
    "snippet": "  final TypeCheck makeTypeCheck(AbstractCompiler compiler) {\n    return new TypeCheck(\n        compiler,\n        compiler.getReverseAbstractInterpreter(),\n        compiler.getTypeRegistry(),\n        topScope,\n        typedScopeCreator,\n        options.reportMissingOverride,\n        options.reportUnknownTypes)\n        .reportMissingProperties(options.enables(\n            DiagnosticGroup.forType(TypeCheck.INEXISTENT_PROPERTY)));\n  }",
    "comment": " Create a type-checking pass. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "PassConfig.makeTypeInference",
    "class_name": "com.google.javascript.jscomp.PassConfig",
    "signature": "com.google.javascript.jscomp.PassConfig.makeTypeInference(AbstractCompiler)",
    "snippet": "  final TypeInferencePass makeTypeInference(AbstractCompiler compiler) {\n    return new TypeInferencePass(\n        compiler, compiler.getReverseAbstractInterpreter(),\n        topScope, typedScopeCreator);\n  }",
    "comment": " Create a type inference pass. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "PassConfig.regenerateGlobalTypedScope",
    "class_name": "com.google.javascript.jscomp.PassConfig",
    "signature": "com.google.javascript.jscomp.PassConfig.regenerateGlobalTypedScope(AbstractCompiler,Node)",
    "snippet": "  void regenerateGlobalTypedScope(AbstractCompiler compiler, Node root) {\n    internalScopeCreator = new TypedScopeCreator(compiler);\n    typedScopeCreator = new MemoizedScopeCreator(internalScopeCreator);\n    topScope = typedScopeCreator.createScope(root, null);\n  }",
    "comment": " Regenerates the top scope from scratch.  @param compiler The compiler for which the global scope is regenerated. @param root The root of the AST. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "PassFactory.PassFactory",
    "class_name": "com.google.javascript.jscomp.PassFactory",
    "signature": "com.google.javascript.jscomp.PassFactory.PassFactory(String,boolean)",
    "snippet": "  protected PassFactory(String name, boolean isOneTimePass) {\n    this.name = name;\n    this.isOneTimePass = isOneTimePass;\n  }",
    "comment": " @param name The name of the pass that this factory creates. @param isOneTimePass If true, the pass produced by this factory can only be run once. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "PassFactory.create",
    "class_name": "com.google.javascript.jscomp.PassFactory",
    "signature": "com.google.javascript.jscomp.PassFactory.create(AbstractCompiler)",
    "snippet": "  final CompilerPass create(AbstractCompiler compiler) {\n    Preconditions.checkState(!isCreated || !isOneTimePass,\n        \"One-time passes cannot be run multiple times: \" + name);\n    isCreated = true;\n    return createInternal(compiler);\n  }",
    "comment": " Creates a new compiler pass to be run. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "PassFactory.getName",
    "class_name": "com.google.javascript.jscomp.PassFactory",
    "signature": "com.google.javascript.jscomp.PassFactory.getName()",
    "snippet": "  String getName() {\n    return name;\n  }",
    "comment": " @return The name of this pass. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "PassFactory.isOneTimePass",
    "class_name": "com.google.javascript.jscomp.PassFactory",
    "signature": "com.google.javascript.jscomp.PassFactory.isOneTimePass()",
    "snippet": "  boolean isOneTimePass() {\n    return isOneTimePass;\n  }",
    "comment": " @return Whether the pass produced by this factory can only be run once. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "PassFactory.makeOneTimePass",
    "class_name": "com.google.javascript.jscomp.PassFactory",
    "signature": "com.google.javascript.jscomp.PassFactory.makeOneTimePass()",
    "snippet": "  PassFactory makeOneTimePass() {\n    if (isOneTimePass()) {\n      return this;\n    }\n\n    final PassFactory self = this;\n    return new PassFactory(name, true /* one time pass */) {\n      @Override\n      protected CompilerPass createInternal(AbstractCompiler compiler) {\n        return self.createInternal(compiler);\n      }\n      @Override\n      HotSwapCompilerPass getHotSwapPass(AbstractCompiler compiler) {\n        return self.getHotSwapPass(compiler);\n      }\n    };\n  }",
    "comment": " Make a new pass factory that only creates one-time passes. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "PeepholeCollectPropertyAssignments.isPropertyAssignmentToName",
    "class_name": "com.google.javascript.jscomp.PeepholeCollectPropertyAssignments",
    "signature": "com.google.javascript.jscomp.PeepholeCollectPropertyAssignments.isPropertyAssignmentToName(Node)",
    "snippet": "  private boolean isPropertyAssignmentToName(Node propertyCandidate) {\n    if (propertyCandidate == null) { return false; }\n    // Must be an assignment...\n    if (!NodeUtil.isExprAssign(propertyCandidate)) {\n      return false;\n    }\n\n    Node expr = propertyCandidate.getFirstChild();\n\n    // to a property...\n    Node lhs = expr.getFirstChild();\n    if (lhs.getType() != Token.GETELEM && lhs.getType() != Token.GETPROP) {\n      return false;\n    }\n\n    // of a variable.\n    Node obj = lhs.getFirstChild();\n    if (obj.getType() != Token.NAME) {\n      return false;\n    }\n\n    return true;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "PeepholeCollectPropertyAssignments.optimizeSubtree",
    "class_name": "com.google.javascript.jscomp.PeepholeCollectPropertyAssignments",
    "signature": "com.google.javascript.jscomp.PeepholeCollectPropertyAssignments.optimizeSubtree(Node)",
    "snippet": "  @Override\n  Node optimizeSubtree(Node subtree) {\n    if (subtree.getType() != Token.SCRIPT\n        && subtree.getType() != Token.BLOCK) {\n      return subtree;\n    }\n\n    boolean codeChanged = false;\n\n    // Look for variable declarations or simple assignments\n    // and start processing there.\n    for (Node child = subtree.getFirstChild();\n         child != null; child = child.getNext()) {\n      if (child.getType() != Token.VAR && !NodeUtil.isExprAssign(child)) {\n        continue;\n      }\n      if (!isPropertyAssignmentToName(child.getNext())) {\n        // Quick check to see if there's anything to collapse.\n        continue;\n      }\n\n      Preconditions.checkState(child.hasOneChild());\n      Node name = getName(child);\n      if (name.getType() != Token.NAME) {\n        // The assignment target is not a simple name.\n        continue;\n      }\n      Node value = getValue(child);\n      if (value == null || !isInterestingValue(value)) {\n        // No initializer or not an Object or Array literal.\n        continue;\n      }\n\n      Node propertyCandidate;\n      while ((propertyCandidate = child.getNext()) != null) {\n        // This does not infinitely loop because collectProperty always\n        // removes propertyCandidate from its parent when it returns true.\n        if (!collectProperty(propertyCandidate, name.getString(), value)) {\n          break;\n        }\n        codeChanged = true;\n      }\n    }\n\n    if (codeChanged) {\n      reportCodeChange();\n    }\n    return subtree;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "PeepholeFoldConstants.optimizeSubtree",
    "class_name": "com.google.javascript.jscomp.PeepholeFoldConstants",
    "signature": "com.google.javascript.jscomp.PeepholeFoldConstants.optimizeSubtree(Node)",
    "snippet": "  @Override\n  Node optimizeSubtree(Node subtree) {\n    switch(subtree.getType()) {\n      case Token.NEW:\n        return tryFoldCtorCall(subtree);\n\n      case Token.TYPEOF:\n        return tryFoldTypeof(subtree);\n\n      case Token.NOT:\n      case Token.POS:\n      case Token.NEG:\n      case Token.BITNOT:\n        tryReduceOperandsForOp(subtree);\n        return tryFoldUnaryOperator(subtree);\n\n      case Token.VOID:\n        return tryReduceVoid(subtree);\n\n      default:\n        tryReduceOperandsForOp(subtree);\n        return tryFoldBinaryOperator(subtree);\n    }\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "PeepholeFoldConstants.tryFoldAssign",
    "class_name": "com.google.javascript.jscomp.PeepholeFoldConstants",
    "signature": "com.google.javascript.jscomp.PeepholeFoldConstants.tryFoldAssign(Node,Node,Node)",
    "snippet": "  private Node tryFoldAssign(Node n, Node left, Node right) {\n    Preconditions.checkArgument(n.getType() == Token.ASSIGN);\n\n    // Tries to convert x = x + y -> x += y;\n    if (!right.hasChildren() ||\n        right.getFirstChild().getNext() != right.getLastChild()) {\n      // RHS must have two children.\n      return n;\n    }\n\n    if (mayHaveSideEffects(left)) {\n      return n;\n    }\n\n    Node newRight;\n    if (areNodesEqualForInlining(left, right.getFirstChild())) {\n      newRight = right.getLastChild();\n    } else if (NodeUtil.isCommutative(right.getType()) &&\n          areNodesEqualForInlining(left, right.getLastChild())) {\n      newRight = right.getFirstChild();\n    } else {\n      return n;\n    }\n\n    int newType = -1;\n    switch (right.getType()) {\n      case Token.ADD:\n        newType = Token.ASSIGN_ADD;\n        break;\n      case Token.BITAND:\n        newType = Token.ASSIGN_BITAND;\n        break;\n      case Token.BITOR:\n        newType = Token.ASSIGN_BITOR;\n        break;\n      case Token.BITXOR:\n        newType = Token.ASSIGN_BITXOR;\n        break;\n      case Token.DIV:\n        newType = Token.ASSIGN_DIV;\n        break;\n      case Token.LSH:\n        newType = Token.ASSIGN_LSH;\n        break;\n      case Token.MOD:\n        newType = Token.ASSIGN_MOD;\n        break;\n      case Token.MUL:\n        newType = Token.ASSIGN_MUL;\n        break;\n      case Token.RSH:\n        newType = Token.ASSIGN_RSH;\n        break;\n      case Token.SUB:\n        newType = Token.ASSIGN_SUB;\n        break;\n      case Token.URSH:\n        newType = Token.ASSIGN_URSH;\n        break;\n      default:\n        return n;\n    }\n\n    Node newNode = new Node(newType,\n        left.detachFromParent(), newRight.detachFromParent());\n    n.getParent().replaceChild(n, newNode);\n\n    reportCodeChange();\n\n    return newNode;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "PeepholeFoldConstants.tryFoldBinaryOperator",
    "class_name": "com.google.javascript.jscomp.PeepholeFoldConstants",
    "signature": "com.google.javascript.jscomp.PeepholeFoldConstants.tryFoldBinaryOperator(Node)",
    "snippet": "  private Node tryFoldBinaryOperator(Node subtree) {\n    Node left = subtree.getFirstChild();\n\n    if (left == null) {\n      return subtree;\n    }\n\n    Node right = left.getNext();\n\n    if (right == null) {\n      return subtree;\n    }\n\n    // If we've reached here, node is truly a binary operator.\n    switch(subtree.getType()) {\n      case Token.GETPROP:\n        return tryFoldGetProp(subtree, left, right);\n\n      case Token.GETELEM:\n        return tryFoldGetElem(subtree, left, right);\n\n      case Token.INSTANCEOF:\n        return tryFoldInstanceof(subtree, left, right);\n\n      case Token.AND:\n      case Token.OR:\n        return tryFoldAndOr(subtree, left, right);\n\n      case Token.LSH:\n      case Token.RSH:\n      case Token.URSH:\n        return tryFoldShift(subtree, left, right);\n\n      case Token.ASSIGN:\n        return tryFoldAssign(subtree, left, right);\n\n      case Token.ADD:\n        return tryFoldAdd(subtree, left, right);\n\n      case Token.SUB:\n      case Token.DIV:\n      case Token.MOD:\n        return tryFoldArithmeticOp(subtree, left, right);\n\n      case Token.MUL:\n      case Token.BITAND:\n      case Token.BITOR:\n      case Token.BITXOR:\n        Node result = tryFoldArithmeticOp(subtree, left, right);\n        if (result != subtree) {\n          return result;\n        }\n        return tryFoldLeftChildOp(subtree, left, right);\n\n      case Token.LT:\n      case Token.GT:\n      case Token.LE:\n      case Token.GE:\n      case Token.EQ:\n      case Token.NE:\n      case Token.SHEQ:\n      case Token.SHNE:\n        return tryFoldComparison(subtree, left, right);\n\n      default:\n        return subtree;\n    }\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "PeepholeFoldConstants.tryFoldGetProp",
    "class_name": "com.google.javascript.jscomp.PeepholeFoldConstants",
    "signature": "com.google.javascript.jscomp.PeepholeFoldConstants.tryFoldGetProp(Node,Node,Node)",
    "snippet": "  private Node tryFoldGetProp(Node n, Node left, Node right) {\n    Preconditions.checkArgument(n.getType() == Token.GETPROP);\n\n    if (left.getType() == Token.OBJECTLIT) {\n      return tryFoldObjectPropAccess(n, left, right);\n    }\n\n    if (right.getType() == Token.STRING &&\n        right.getString().equals(\"length\")) {\n      int knownLength = -1;\n      switch (left.getType()) {\n        case Token.ARRAYLIT:\n          if (mayHaveSideEffects(left)) {\n            // Nope, can't fold this, without handling the side-effects.\n            return n;\n          }\n          knownLength = left.getChildCount();\n          break;\n        case Token.STRING:\n          knownLength = left.getString().length();\n          break;\n        default:\n          // Not a foldable case, forget it.\n          return n;\n      }\n\n      Preconditions.checkState(knownLength != -1);\n      Node lengthNode = Node.newNumber(knownLength);\n      n.getParent().replaceChild(n, lengthNode);\n      reportCodeChange();\n\n      return lengthNode;\n    }\n\n    return n;\n  }",
    "comment": " Try to fold array-length. e.g [1, 2, 3].length ==> 3, [x, y].length ==> 2 ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "PeepholeFoldConstants.tryReduceOperandsForOp",
    "class_name": "com.google.javascript.jscomp.PeepholeFoldConstants",
    "signature": "com.google.javascript.jscomp.PeepholeFoldConstants.tryReduceOperandsForOp(Node)",
    "snippet": "  private void tryReduceOperandsForOp(Node n) {\n    switch (n.getType()) {\n      case Token.ADD:\n        Node left = n.getFirstChild();\n        Node right = n.getLastChild();\n        if (!NodeUtil.mayBeString(left) && !NodeUtil.mayBeString(right)) {\n          tryConvertOperandsToNumber(n);\n        }\n        break;\n      case Token.ASSIGN_BITOR:\n      case Token.ASSIGN_BITXOR:\n      case Token.ASSIGN_BITAND:\n        // TODO(johnlenz): convert these to integers.\n      case Token.ASSIGN_LSH:\n      case Token.ASSIGN_RSH:\n      case Token.ASSIGN_URSH:\n      case Token.ASSIGN_SUB:\n      case Token.ASSIGN_MUL:\n      case Token.ASSIGN_MOD:\n      case Token.ASSIGN_DIV:\n        tryConvertToNumber(n.getLastChild());\n        break;\n      case Token.BITNOT:\n      case Token.BITOR:\n      case Token.BITXOR:\n      case Token.BITAND:\n      case Token.LSH:\n      case Token.RSH:\n      case Token.URSH:\n      case Token.SUB:\n      case Token.MUL:\n      case Token.MOD:\n      case Token.DIV:\n      case Token.POS:\n      case Token.NEG:\n        tryConvertOperandsToNumber(n);\n        break;\n    }\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "PeepholeOptimizationsPass.PeepholeOptimizationsPass",
    "class_name": "com.google.javascript.jscomp.PeepholeOptimizationsPass",
    "signature": "com.google.javascript.jscomp.PeepholeOptimizationsPass.PeepholeOptimizationsPass(AbstractCompiler,AbstractPeepholeOptimization[])",
    "snippet": "  PeepholeOptimizationsPass(AbstractCompiler compiler,\n      AbstractPeepholeOptimization... optimizations) {\n    this.compiler = compiler;\n    this.peepholeOptimizations = optimizations;\n  }",
    "comment": " Creates a peephole optimization pass that runs the given optimizations. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "PeepholeOptimizationsPass.beginTraversal",
    "class_name": "com.google.javascript.jscomp.PeepholeOptimizationsPass",
    "signature": "com.google.javascript.jscomp.PeepholeOptimizationsPass.beginTraversal(NodeTraversal)",
    "snippet": "  private void beginTraversal(NodeTraversal t) {\n    for (AbstractPeepholeOptimization optimization : peepholeOptimizations) {\n      optimization.beginTraversal(t);\n    }\n  }",
    "comment": " Make sure that all the optimizations have the current traversal so they can report errors. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "PeepholeOptimizationsPass.endTraversal",
    "class_name": "com.google.javascript.jscomp.PeepholeOptimizationsPass",
    "signature": "com.google.javascript.jscomp.PeepholeOptimizationsPass.endTraversal(NodeTraversal)",
    "snippet": "  private void endTraversal(NodeTraversal t) {\n    for (AbstractPeepholeOptimization optimization : peepholeOptimizations) {\n      optimization.endTraversal(t);\n    }\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "PeepholeOptimizationsPass.process",
    "class_name": "com.google.javascript.jscomp.PeepholeOptimizationsPass",
    "signature": "com.google.javascript.jscomp.PeepholeOptimizationsPass.process(Node,Node)",
    "snippet": "  @Override\n  public void process(Node externs, Node root) {\n    NodeTraversal t = new NodeTraversal(compiler, this);\n\n    beginTraversal(t);\n    t.traverse(root);\n    endTraversal(t);\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "PeepholeOptimizationsPass.visit",
    "class_name": "com.google.javascript.jscomp.PeepholeOptimizationsPass",
    "signature": "com.google.javascript.jscomp.PeepholeOptimizationsPass.visit(NodeTraversal,Node,Node)",
    "snippet": "  @Override\n  public void visit(NodeTraversal t, Node n, Node parent) {\n    Node currentVersionOfNode = n;\n    boolean somethingChanged = false;\n\n    do {\n      somethingChanged = false;\n      for (AbstractPeepholeOptimization optimization : peepholeOptimizations) {\n        Node newVersionOfNode =\n            optimization.optimizeSubtree(currentVersionOfNode);\n\n        if (newVersionOfNode != currentVersionOfNode) {\n          somethingChanged = true;\n\n          currentVersionOfNode = newVersionOfNode;\n        }\n\n        if (currentVersionOfNode == null) {\n          return;\n        }\n      }\n    } while(somethingChanged);\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "PeepholeRemoveDeadCode.isSimpleAssignment",
    "class_name": "com.google.javascript.jscomp.PeepholeRemoveDeadCode",
    "signature": "com.google.javascript.jscomp.PeepholeRemoveDeadCode.isSimpleAssignment(Node)",
    "snippet": "  private boolean isSimpleAssignment(Node n) {\n    // For our purposes we define a simple assignment to be a assignment\n    // to a NAME node, or a VAR declaration with one child and a initializer.\n    if (NodeUtil.isExprAssign(n)\n        && NodeUtil.isName(n.getFirstChild().getFirstChild())) {\n      return true;\n    } else if (n.getType() == Token.VAR && n.hasOneChild() &&\n        n.getFirstChild().getFirstChild() != null) {\n      return true;\n    }\n\n    return false;\n  }",
    "comment": " @return whether the node is a assignment to a simple name, or simple var declaration with initialization. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "PeepholeRemoveDeadCode.optimizeSubtree",
    "class_name": "com.google.javascript.jscomp.PeepholeRemoveDeadCode",
    "signature": "com.google.javascript.jscomp.PeepholeRemoveDeadCode.optimizeSubtree(Node)",
    "snippet": "  @Override\n  Node optimizeSubtree(Node subtree) {\n    switch(subtree.getType()) {\n      case Token.ASSIGN:\n        return tryFoldAssignment(subtree);\n      case Token.COMMA:\n        return tryFoldComma(subtree);\n      case Token.SCRIPT:\n      case Token.BLOCK:\n        return tryOptimizeBlock(subtree);\n      case Token.EXPR_RESULT:\n        subtree = tryFoldExpr(subtree);\n        return subtree;\n      case Token.HOOK:\n        return tryFoldHook(subtree);\n      case Token.SWITCH:\n        return tryOptimizeSwitch(subtree);\n      case Token.IF:\n        return tryFoldIf(subtree);\n      case Token.WHILE:\n        return tryFoldWhile(subtree);\n       case Token.FOR: {\n          Node condition = NodeUtil.getConditionExpression(subtree);\n          if (condition != null) {\n            tryFoldForCondition(condition);\n          }\n        }\n        return tryFoldFor(subtree);\n      case Token.DO:\n        return tryFoldDo(subtree);\n      case Token.TRY:\n        return tryFoldTry(subtree);\n      default:\n          return subtree;\n    }\n  }",
    "comment": "could be changed to use code from CheckUnreachableCode to do this.",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "PeepholeRemoveDeadCode.tryFoldAssignment",
    "class_name": "com.google.javascript.jscomp.PeepholeRemoveDeadCode",
    "signature": "com.google.javascript.jscomp.PeepholeRemoveDeadCode.tryFoldAssignment(Node)",
    "snippet": "  private Node tryFoldAssignment(Node subtree) {\n    Preconditions.checkState(subtree.getType() == Token.ASSIGN);\n    Node left = subtree.getFirstChild();\n    Node right = subtree.getLastChild();\n    // Only names\n    if (left.getType() == Token.NAME\n        && right.getType() == Token.NAME\n        && left.getString().equals(right.getString())) {\n      subtree.getParent().replaceChild(subtree, right.detachFromParent());\n      reportCodeChange();\n      return right;\n    }\n    return subtree;\n  }",
    "comment": " Try removing identity assignments @return the replacement node, if changed, or the original if not ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "PeepholeRemoveDeadCode.tryFoldExpr",
    "class_name": "com.google.javascript.jscomp.PeepholeRemoveDeadCode",
    "signature": "com.google.javascript.jscomp.PeepholeRemoveDeadCode.tryFoldExpr(Node)",
    "snippet": "  private Node tryFoldExpr(Node subtree) {\n    Node result = trySimplifyUnusedResult(subtree.getFirstChild());\n    if (result == null) {\n      Node parent = subtree.getParent();\n      // If the EXPR_RESULT no longer has any children, remove it as well.\n      if (parent.getType() == Token.LABEL) {\n        Node replacement = new Node(Token.BLOCK).copyInformationFrom(subtree);\n        parent.replaceChild(subtree, replacement);\n        subtree = replacement;\n      } else {\n        subtree.detachFromParent();\n        subtree = null;\n      }\n    }\n    return subtree;\n  }",
    "comment": " Try folding EXPR_RESULT nodes by removing useless Ops and expressions. @return the replacement node, if changed, or the original if not ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "PeepholeRemoveDeadCode.tryOptimizeBlock",
    "class_name": "com.google.javascript.jscomp.PeepholeRemoveDeadCode",
    "signature": "com.google.javascript.jscomp.PeepholeRemoveDeadCode.tryOptimizeBlock(Node)",
    "snippet": "  Node tryOptimizeBlock(Node n) {\n    // Remove any useless children\n    for (Node c = n.getFirstChild(); c != null; ) {\n      Node next = c.getNext();  // save c.next, since 'c' may be removed\n      if (!mayHaveSideEffects(c) && !c.isSyntheticBlock()) {\n        // TODO(johnlenz): determine what this is actually removing. Candidates\n        //    include: EMPTY nodes, control structures without children\n        //    (removing infinite loops), empty try blocks.  What else?\n        n.removeChild(c);  // lazy kids\n        reportCodeChange();\n      } else {\n        tryOptimizeConditionalAfterAssign(c);\n      }\n      c = next;\n    }\n\n    if (n.isSyntheticBlock() ||  n.getParent() == null) {\n      return n;\n    }\n\n    // Try to remove the block.\n    if (NodeUtil.tryMergeBlock(n)) {\n      reportCodeChange();\n      return null;\n    }\n\n    return n;\n  }",
    "comment": " Try removing unneeded block nodes and their useless children ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "PeepholeRemoveDeadCode.tryOptimizeConditionalAfterAssign",
    "class_name": "com.google.javascript.jscomp.PeepholeRemoveDeadCode",
    "signature": "com.google.javascript.jscomp.PeepholeRemoveDeadCode.tryOptimizeConditionalAfterAssign(Node)",
    "snippet": "  private void tryOptimizeConditionalAfterAssign(Node n) {\n    Node next = n.getNext();\n\n    // Look for patterns like the following and replace the if-condition with\n    // a constant value so it can later be folded:\n    //   var a = /a/;\n    //   if (a) {foo(a)}\n    // or\n    //   a = 0;\n    //   a ? foo(a) : c;\n    // or\n    //   a = 0;\n    //   a || foo(a);\n    // or\n    //   a = 0;\n    //   a && foo(a)\n    //\n    // TODO(johnlenz): This would be better handled by control-flow sensitive\n    // constant propagation. As the other case that I want to handle is:\n    //   i=0; for(;i<0;i++){}\n    // as right now nothing facilitates removing a loop like that.\n    // This is here simply to remove the cruft left behind goog.userAgent and\n    // similar cases.\n\n    if (isSimpleAssignment(n) && isConditionalStatement(next)) {\n      Node lhsAssign = getSimpleAssignmentName(n);\n\n      Node condition = getConditionalStatementCondition(next);\n      if (NodeUtil.isName(lhsAssign) && NodeUtil.isName(condition)\n          && lhsAssign.getString().equals(condition.getString())) {\n        Node rhsAssign = getSimpleAssignmentValue(n);\n        TernaryValue value = NodeUtil.getImpureBooleanValue(rhsAssign);\n        if (value != TernaryValue.UNKNOWN) {\n          int replacementConditionNodeType =\n            (value.toBoolean(true)) ? Token.TRUE : Token.FALSE;\n          condition.getParent().replaceChild(condition,\n              new Node(replacementConditionNodeType));\n          reportCodeChange();\n        }\n      }\n    }\n  }",
    "comment": " Attempt to replace the condition of if or hook immediately that is a reference to a name that is assigned immediately before. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "PeepholeRemoveDeadCode.trySimplifyUnusedResult",
    "class_name": "com.google.javascript.jscomp.PeepholeRemoveDeadCode",
    "signature": "com.google.javascript.jscomp.PeepholeRemoveDeadCode.trySimplifyUnusedResult(Node)",
    "snippet": "  private Node trySimplifyUnusedResult(Node n) {\n    return trySimplifyUnusedResult(n, true);\n  }",
    "comment": " General cascading unused operation node removal. @param n The root of the expression to simplify. @return The replacement node, or null if the node was is not useful. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "PeepholeRemoveDeadCode.trySimplifyUnusedResult",
    "class_name": "com.google.javascript.jscomp.PeepholeRemoveDeadCode",
    "signature": "com.google.javascript.jscomp.PeepholeRemoveDeadCode.trySimplifyUnusedResult(Node,boolean)",
    "snippet": "  private Node trySimplifyUnusedResult(Node n, boolean removeUnused) {\n    Node result = n;\n\n    // Simplify the results of conditional expressions\n    switch (n.getType()) {\n      case Token.HOOK:\n        Node trueNode = trySimplifyUnusedResult(n.getFirstChild().getNext());\n        Node falseNode = trySimplifyUnusedResult(n.getLastChild());\n        // If one or more of the conditional children were removed,\n        // transform the HOOK to an equivalent operation:\n        //    x() ? foo() : 1 --> x() && foo()\n        //    x() ? 1 : foo() --> x() || foo()\n        //    x() ? 1 : 1 --> x()\n        //    x ? 1 : 1 --> null\n        if (trueNode == null && falseNode != null) {\n          n.setType(Token.OR);\n          Preconditions.checkState(n.getChildCount() == 2);\n        } else if (trueNode != null && falseNode == null) {\n          n.setType(Token.AND);\n          Preconditions.checkState(n.getChildCount() == 2);\n        } else if (trueNode == null && falseNode == null) {\n          result = trySimplifyUnusedResult(n.getFirstChild());\n        } else {\n          // The structure didn't change.\n          result = n;\n        }\n        break;\n      case Token.AND:\n      case Token.OR:\n        // Try to remove the second operand from a AND or OR operations:\n        //    x() || f --> x()\n        //    x() && f --> x()\n        Node conditionalResultNode = trySimplifyUnusedResult(\n            n.getLastChild());\n        if (conditionalResultNode == null) {\n          Preconditions.checkState(n.hasOneChild());\n          // The conditionally executed code was removed, so\n          // replace the AND/OR with its LHS or remove it if it isn't useful.\n          result = trySimplifyUnusedResult(n.getFirstChild());\n        }\n        break;\n      case Token.FUNCTION:\n        // A function expression isn't useful if it isn't used, remove it and\n        // don't bother to look at its children.\n        result = null;\n        break;\n      case Token.COMMA:\n        // We rewrite other operations as COMMA expressions (which will later\n        // get split into individual EXPR_RESULT statement, if possible), so\n        // we special case COMMA (we don't want to rewrite COMMAs as new COMMAs\n        // nodes.\n        Node left = trySimplifyUnusedResult(n.getFirstChild());\n        Node right = trySimplifyUnusedResult(n.getLastChild());\n        if (left == null && right == null) {\n          result = null;\n        } else if (left == null) {\n          result = right;\n        } else if (right == null){\n          result = left;\n        } else {\n          // The structure didn't change.\n          result = n;\n        }\n        break;\n      default:\n        if (!NodeUtil.nodeTypeMayHaveSideEffects(n)) {\n          // This is the meat of this function. The node itself doesn't generate\n          // any side-effects but preserve any side-effects in the children.\n          Node resultList = null;\n          for (Node next, c = n.getFirstChild(); c != null; c = next) {\n            next = c.getNext();\n            c = trySimplifyUnusedResult(c);\n            if (c != null) {\n              c.detachFromParent();\n              if (resultList == null)  {\n                // The first side-effect can be used stand-alone.\n                resultList = c;\n              } else {\n                // Leave the side-effects in-place, simplifying it to a COMMA\n                // expression.\n                resultList = new Node(Token.COMMA, resultList, c)\n                    .copyInformationFrom(c);\n              }\n            }\n          }\n          result = resultList;\n        }\n    }\n\n    // Fix up the AST, replace or remove the an unused node (if requested).\n    if (n != result) {\n      Node parent = n.getParent();\n      if (result == null) {\n        if (removeUnused) {\n          parent.removeChild(n);\n        } else {\n          result = new Node(Token.EMPTY).copyInformationFrom(n);\n          parent.replaceChild(n, result);\n        }\n      } else {\n        // A new COMMA expression may not have an existing parent.\n        if (result.getParent() != null) {\n          result.detachFromParent();\n        }\n        n.getParent().replaceChild(n, result);\n      }\n      reportCodeChange();\n    }\n\n    return result;\n  }",
    "comment": " General cascading unused operation node removal. @param n The root of the expression to simplify. @param removeUnused If true, the node is removed from the AST if it is not useful, otherwise it replaced with an EMPTY node. @return The replacement node, or null if the node was is not useful. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "PeepholeReplaceKnownMethods.optimizeSubtree",
    "class_name": "com.google.javascript.jscomp.PeepholeReplaceKnownMethods",
    "signature": "com.google.javascript.jscomp.PeepholeReplaceKnownMethods.optimizeSubtree(Node)",
    "snippet": "  @Override\n  Node optimizeSubtree(Node subtree) {\n    if (NodeUtil.isCall(subtree) ){\n      return tryFoldKnownMethods(subtree);\n    }\n    return subtree;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "PeepholeSubstituteAlternateSyntax.PeepholeSubstituteAlternateSyntax",
    "class_name": "com.google.javascript.jscomp.PeepholeSubstituteAlternateSyntax",
    "signature": "com.google.javascript.jscomp.PeepholeSubstituteAlternateSyntax.PeepholeSubstituteAlternateSyntax(boolean)",
    "snippet": "  PeepholeSubstituteAlternateSyntax(boolean late) {\n    this.late = late;\n  }",
    "comment": " @param late When late is false, this mean we are currently running before most of the other optimizations. In this case we would avoid optimizations that would make the code harder to analyze (such as using string spliting, merging statements with commans, etc). When this is true, we would do anything to minimize for size. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "PeepholeSubstituteAlternateSyntax.optimizeSubtree",
    "class_name": "com.google.javascript.jscomp.PeepholeSubstituteAlternateSyntax",
    "signature": "com.google.javascript.jscomp.PeepholeSubstituteAlternateSyntax.optimizeSubtree(Node)",
    "snippet": "  @Override\n  @SuppressWarnings(\"fallthrough\")\n  public Node optimizeSubtree(Node node) {\n    switch(node.getType()) {\n      case Token.RETURN: {\n        Node result = tryRemoveRedundantExit(node);\n        if (result != node) {\n          return result;\n        }\n        result = tryReplaceExitWithBreak(node);\n        if (result != node) {\n          return result;\n        }\n        return tryReduceReturn(node);\n      }\n\n      case Token.THROW: {\n        Node result = tryRemoveRedundantExit(node);\n        if (result != node) {\n          return result;\n        }\n        return tryReplaceExitWithBreak(node);\n      }\n\n      // TODO(johnlenz): Maybe remove redundant BREAK and CONTINUE. Overlaps\n      // with MinimizeExitPoints.\n\n      case Token.NOT:\n        tryMinimizeCondition(node.getFirstChild());\n        return tryMinimizeNot(node);\n\n      case Token.IF:\n        tryMinimizeCondition(node.getFirstChild());\n        return tryMinimizeIf(node);\n\n      case Token.EXPR_RESULT:\n        tryMinimizeCondition(node.getFirstChild());\n        return node;\n\n      case Token.HOOK:\n        tryMinimizeCondition(node.getFirstChild());\n        return node;\n\n      case Token.WHILE:\n      case Token.DO:\n        tryMinimizeCondition(NodeUtil.getConditionExpression(node));\n        return node;\n\n      case Token.FOR:\n        if (!NodeUtil.isForIn(node)) {\n          tryMinimizeCondition(NodeUtil.getConditionExpression(node));\n        }\n        return node;\n\n\n      case Token.TRUE:\n      case Token.FALSE:\n        return reduceTrueFalse(node);\n\n      case Token.NEW:\n        node = tryFoldStandardConstructors(node);\n        if (node.getType() != Token.CALL) {\n          return node;\n        }\n        // Fall through on purpose because tryFoldStandardConstructors() may\n        // convert a NEW node into a CALL node\n      case Token.CALL:\n        Node result =  tryFoldLiteralConstructor(node);\n        if (result == node) {\n          result = tryFoldImmediateCallToBoundFunction(node);\n        }\n        return result;\n\n      case Token.COMMA:\n        return tryFoldComma(node);\n\n      case Token.NAME:\n        return tryReplaceUndefined(node);\n\n      case Token.BLOCK:\n        return tryReplaceIf(node);\n\n      case Token.ARRAYLIT:\n        return tryMinimizeArrayLiteral(node);\n\n      default:\n        return node; //Nothing changed\n    }\n  }",
    "comment": " Tries apply our various peephole minimizations on the passed in node. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "PeepholeSubstituteAlternateSyntax.tryMinimizeCondition",
    "class_name": "com.google.javascript.jscomp.PeepholeSubstituteAlternateSyntax",
    "signature": "com.google.javascript.jscomp.PeepholeSubstituteAlternateSyntax.tryMinimizeCondition(Node)",
    "snippet": "  private Node tryMinimizeCondition(Node n) {\n    Node parent = n.getParent();\n\n    switch (n.getType()) {\n      case Token.NOT:\n        Node first = n.getFirstChild();\n        switch (first.getType()) {\n          case Token.NOT: {\n              Node newRoot = first.removeFirstChild();\n              parent.replaceChild(n, newRoot);\n              reportCodeChange();\n              // No need to traverse, tryMinimizeCondition is called on the\n              // NOT children are handled below.\n              return newRoot;\n            }\n          case Token.AND:\n          case Token.OR: {\n              // !(!x && !y) --> x || y\n              // !(!x || !y) --> x && y\n              // !(!x && y) --> x || !y\n              // !(!x || y) --> x && !y\n              // !(x && !y) --> !x || y\n              // !(x || !y) --> !x && y\n              // !(x && y) --> !x || !y\n              // !(x || y) --> !x && !y\n              Node leftParent = first.getFirstChild();\n              Node rightParent = first.getLastChild();\n              Node left, right;\n\n              // Check special case when such transformation cannot reduce\n              // due to the added ()\n              // It only occurs when both of expressions are not NOT expressions\n              if (leftParent.getType() != Token.NOT\n                  && rightParent.getType() != Token.NOT) {\n                // If an expression has higher precendence than && or ||,\n                // but lower precedence than NOT, an additional () is needed\n                // Thus we do not preceed\n                int op_precedence = NodeUtil.precedence(first.getType());\n                if ((isLowerPrecedence(leftParent, NOT_PRECEDENCE)\n                    && isHigherPrecedence(leftParent, op_precedence))\n                    || (isLowerPrecedence(rightParent, NOT_PRECEDENCE)\n                    && isHigherPrecedence(rightParent, op_precedence))) {\n                  return n;\n                }\n              }\n\n              if (leftParent.getType() == Token.NOT) {\n                left = leftParent.removeFirstChild();\n              } else {\n                leftParent.detachFromParent();\n                left = new Node(Token.NOT, leftParent)\n                  .copyInformationFrom(leftParent);\n              }\n              if (rightParent.getType() == Token.NOT) {\n                right = rightParent.removeFirstChild();\n              } else {\n                rightParent.detachFromParent();\n                right = new Node(Token.NOT, rightParent)\n                  .copyInformationFrom(rightParent);\n              }\n\n              int newOp = (first.getType() == Token.AND) ? Token.OR : Token.AND;\n              Node newRoot = new Node(newOp, left, right);\n              parent.replaceChild(n, newRoot);\n              reportCodeChange();\n              // No need to traverse, tryMinimizeCondition is called on the\n              // AND and OR children below.\n              return newRoot;\n            }\n\n           default:\n             TernaryValue nVal = NodeUtil.getPureBooleanValue(first);\n             if (nVal != TernaryValue.UNKNOWN) {\n               boolean result = nVal.not().toBoolean(true);\n               int equivalentResult = result ? 1 : 0;\n               return maybeReplaceChildWithNumber(n, parent, equivalentResult);\n             }\n        }\n        // No need to traverse, tryMinimizeCondition is called on the NOT\n        // children in the general case in the main post-order traversal.\n        return n;\n\n      case Token.OR:\n      case Token.AND: {\n        Node left = n.getFirstChild();\n        Node right = n.getLastChild();\n\n        // Because the expression is in a boolean context minimize\n        // the children, this can't be done in the general case.\n        left = tryMinimizeCondition(left);\n        right = tryMinimizeCondition(right);\n\n        // Remove useless conditionals\n        // Handle four cases:\n        //   x || false --> x\n        //   x || true  --> true\n        //   x && true --> x\n        //   x && false  --> false\n        TernaryValue rightVal = NodeUtil.getPureBooleanValue(right);\n        if (NodeUtil.getPureBooleanValue(right) != TernaryValue.UNKNOWN) {\n          int type = n.getType();\n          Node replacement = null;\n          boolean rval = rightVal.toBoolean(true);\n\n          // (x || FALSE) => x\n          // (x && TRUE) => x\n          if (type == Token.OR && !rval ||\n              type == Token.AND && rval) {\n            replacement = left;\n          } else if (!mayHaveSideEffects(left)) {\n            replacement = right;\n          }\n\n          if (replacement != null) {\n            n.detachChildren();\n            parent.replaceChild(n, replacement);\n            reportCodeChange();\n            return replacement;\n          }\n        }\n        return n;\n      }\n\n      case Token.HOOK: {\n        Node condition = n.getFirstChild();\n        Node trueNode = n.getFirstChild().getNext();\n        Node falseNode = n.getLastChild();\n\n        // Because the expression is in a boolean context minimize\n        // the result children, this can't be done in the general case.\n        // The condition is handled in the general case in #optimizeSubtree\n        trueNode = tryMinimizeCondition(trueNode);\n        falseNode = tryMinimizeCondition(falseNode);\n\n        // Handle four cases:\n        //   x ? true : false --> x\n        //   x ? false : true --> !x\n        //   x ? true : y     --> x || y\n        //   x ? y : false    --> x && y\n        Node replacement = null;\n        TernaryValue trueNodeVal = NodeUtil.getPureBooleanValue(trueNode);\n        TernaryValue falseNodeVal = NodeUtil.getPureBooleanValue(falseNode);\n        if (trueNodeVal == TernaryValue.TRUE\n            && falseNodeVal == TernaryValue.FALSE) {\n          // Remove useless conditionals, keep the condition\n          condition.detachFromParent();\n          replacement = condition;\n        } else if (trueNodeVal == TernaryValue.FALSE\n            && falseNodeVal == TernaryValue.TRUE) {\n          // Remove useless conditionals, keep the condition\n          condition.detachFromParent();\n          replacement = new Node(Token.NOT, condition);\n        } else if (trueNodeVal == TernaryValue.TRUE) {\n          // Remove useless true case.\n          n.detachChildren();\n          replacement = new Node(Token.OR, condition, falseNode);\n        } else if (falseNodeVal == TernaryValue.FALSE) {\n          // Remove useless false case\n          n.detachChildren();\n          replacement = new Node(Token.AND, condition, trueNode);\n        }\n\n        if (replacement != null) {\n          parent.replaceChild(n, replacement);\n          n = replacement;\n          reportCodeChange();\n        }\n\n        return n;\n      }\n\n      default:\n        // while(true) --> while(1)\n        TernaryValue nVal = NodeUtil.getPureBooleanValue(n);\n        if (nVal != TernaryValue.UNKNOWN) {\n          boolean result = nVal.toBoolean(true);\n          int equivalentResult = result ? 1 : 0;\n          return maybeReplaceChildWithNumber(n, parent, equivalentResult);\n        }\n        // We can't do anything else currently.\n        return n;\n    }\n  }",
    "comment": " Try to minimize conditions expressions, as there are additional assumptions that can be made when it is known that the final result is a boolean.  The following transformations are done recursively: !(x||y) --> !x&&!y !(x&&y) --> !x||!y !!x     --> x Thus: !(x&&!y) --> !x||!!y --> !x||y  Returns the replacement for n, or the original if no change was made ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "PeepholeSubstituteAlternateSyntax.tryReplaceIf",
    "class_name": "com.google.javascript.jscomp.PeepholeSubstituteAlternateSyntax",
    "signature": "com.google.javascript.jscomp.PeepholeSubstituteAlternateSyntax.tryReplaceIf(Node)",
    "snippet": "  private Node tryReplaceIf(Node n) {\n\n    for (Node child = n.getFirstChild();\n         child != null; child = child.getNext()){\n      if (child.getType() == Token.IF){\n\n        Node cond = child.getFirstChild();\n        Node thenBranch = cond.getNext();\n        Node elseBranch = thenBranch.getNext();\n        Node nextNode = child.getNext();\n\n        if (nextNode != null && elseBranch == null &&\n            isReturnBlock(thenBranch) && isReturnExpression(nextNode)) {\n          Node thenExpr = null;\n          // if(x)return; return 1 -> return x?void 0:1\n          if (isReturnExpressBlock(thenBranch)) {\n            thenExpr = getBlockReturnExpression(thenBranch);\n            thenExpr.detachFromParent();\n          } else {\n            thenExpr = NodeUtil.newUndefinedNode(child);\n          }\n\n          Node elseExpr = nextNode.getFirstChild();\n\n          cond.detachFromParent();\n          elseExpr.detachFromParent();\n\n          Node hookNode = new Node(Token.HOOK, cond, thenExpr, elseExpr)\n                              .copyInformationFrom(child);\n          Node returnNode = new Node(Token.RETURN, hookNode);\n          n.replaceChild(child, returnNode);\n          n.removeChild(nextNode);\n          reportCodeChange();\n        }\n      }\n    }\n    return n;\n  }",
    "comment": " Use \"return x?1:2;\" in place of \"if(x)return 1;return 2;\" ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "PeepholeSubstituteAlternateSyntax.tryReplaceUndefined",
    "class_name": "com.google.javascript.jscomp.PeepholeSubstituteAlternateSyntax",
    "signature": "com.google.javascript.jscomp.PeepholeSubstituteAlternateSyntax.tryReplaceUndefined(Node)",
    "snippet": "  private Node tryReplaceUndefined(Node n) {\n    // TODO(johnlenz): consider doing this as a normalization.\n    if (isASTNormalized()\n        && NodeUtil.isUndefined(n)\n        && !NodeUtil.isLValue(n)) {\n      Node replacement = NodeUtil.newUndefinedNode(n);\n      n.getParent().replaceChild(n, replacement);\n      reportCodeChange();\n      return replacement;\n    }\n    return n;\n  }",
    "comment": " Use \"void 0\" in place of \"undefined\" ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "PhaseOptimizer.PhaseOptimizer",
    "class_name": "com.google.javascript.jscomp.PhaseOptimizer",
    "signature": "com.google.javascript.jscomp.PhaseOptimizer.PhaseOptimizer(AbstractCompiler,PerformanceTracker)",
    "snippet": "  PhaseOptimizer(AbstractCompiler compiler, PerformanceTracker tracker) {\n    this.compiler = compiler;\n    this.tracker = tracker;\n    compiler.addChangeHandler(recentChange);\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "PhaseOptimizer.addOneTimePass",
    "class_name": "com.google.javascript.jscomp.PhaseOptimizer",
    "signature": "com.google.javascript.jscomp.PhaseOptimizer.addOneTimePass(PassFactory)",
    "snippet": "  void addOneTimePass(PassFactory factory) {\n    passes.add(new PassFactoryDelegate(compiler, factory));\n  }",
    "comment": " Add the pass generated by the given factory to the compile sequence. This pass will be run once. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "PhaseOptimizer.clearLoopsRun",
    "class_name": "com.google.javascript.jscomp.PhaseOptimizer",
    "signature": "com.google.javascript.jscomp.PhaseOptimizer.clearLoopsRun()",
    "snippet": "  static void clearLoopsRun() {\n    loopsRun.clear();\n  }",
    "comment": " Clears the phase ordering of loops during this run. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "PhaseOptimizer.consume",
    "class_name": "com.google.javascript.jscomp.PhaseOptimizer",
    "signature": "com.google.javascript.jscomp.PhaseOptimizer.consume(List)",
    "snippet": "  void consume(List<PassFactory> factories) {\n    Loop currentLoop = new LoopInternal();\n    boolean isCurrentLoopPopulated = false;\n    for (PassFactory factory : factories) {\n      if (factory.isOneTimePass()) {\n        if (isCurrentLoopPopulated) {\n          passes.add(currentLoop);\n\n          currentLoop = new LoopInternal();\n          isCurrentLoopPopulated = false;\n        }\n        addOneTimePass(factory);\n      } else {\n        currentLoop.addLoopedPass(factory);\n        isCurrentLoopPopulated = true;\n      }\n    }\n\n    if (isCurrentLoopPopulated) {\n      passes.add(currentLoop);\n    }\n  }",
    "comment": " Add the passes generated by the given factories to the compile sequence.  Automatically pulls multi-run passes into fixed point loops. If there are 2 or more multi-run passes in a row, they will run together in the same fixed point loop. If A and B are in the same fixed point loop, the loop will continue to run both A and B until both are finished making changes.  Other than that, the PhaseOptimizer is free to tweak the order and frequency of multi-run passes in a fixed-point loop. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "PhaseOptimizer.endPass",
    "class_name": "com.google.javascript.jscomp.PhaseOptimizer",
    "signature": "com.google.javascript.jscomp.PhaseOptimizer.endPass(Node,Node)",
    "snippet": "  private void endPass(Node externs, Node root) {\n    Preconditions.checkState(currentTracer != null && currentPassName != null);\n\n    String passToCheck = currentPassName;\n    try {\n      stopTracer(currentTracer, currentPassName);\n      currentPassName = null;\n      currentTracer = null;\n\n      maybeSanityCheck(externs, root);\n    } catch (Exception e) {\n      // TODO(johnlenz): Remove this once the normalization checks report\n      // errors instead of exceptions.\n      throw new RuntimeException(\"Sanity check failed for \" + passToCheck, e);\n    }\n  }",
    "comment": " Marks the end of a pass. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "PhaseOptimizer.getLoopsRun",
    "class_name": "com.google.javascript.jscomp.PhaseOptimizer",
    "signature": "com.google.javascript.jscomp.PhaseOptimizer.getLoopsRun()",
    "snippet": "  static List<List<String>> getLoopsRun() {\n    return loopsRun;\n  }",
    "comment": " Get the phase ordering of loops during this run. Returns an empty list when the loops are not randomized. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "PhaseOptimizer.hasHaltingErrors",
    "class_name": "com.google.javascript.jscomp.PhaseOptimizer",
    "signature": "com.google.javascript.jscomp.PhaseOptimizer.hasHaltingErrors()",
    "snippet": "  private boolean hasHaltingErrors() {\n    return compiler.hasHaltingErrors();\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "PhaseOptimizer.maybeSanityCheck",
    "class_name": "com.google.javascript.jscomp.PhaseOptimizer",
    "signature": "com.google.javascript.jscomp.PhaseOptimizer.maybeSanityCheck(Node,Node)",
    "snippet": "  void maybeSanityCheck(Node externs, Node root) {\n    if (sanityCheck != null) {\n      sanityCheck.create(compiler).process(externs, root);\n    }\n  }",
    "comment": " Runs the sanity check if it is available. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "PhaseOptimizer.newTracer",
    "class_name": "com.google.javascript.jscomp.PhaseOptimizer",
    "signature": "com.google.javascript.jscomp.PhaseOptimizer.newTracer(String)",
    "snippet": "  private Tracer newTracer(String passName) {\n    String comment = passName +\n        (recentChange.hasCodeChanged() ? \" on recently changed AST\" : \"\");\n    if (tracker != null) {\n      tracker.recordPassStart(passName);\n    }\n    return new Tracer(\"JSCompiler\", comment);\n  }",
    "comment": " Returns a new tracer for the given pass name. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "PhaseOptimizer.process",
    "class_name": "com.google.javascript.jscomp.PhaseOptimizer",
    "signature": "com.google.javascript.jscomp.PhaseOptimizer.process(Node,Node)",
    "snippet": "  public void process(Node externs, Node root) {\n    for (CompilerPass pass : passes) {\n      pass.process(externs, root);\n      if (hasHaltingErrors()) {\n        return;\n      }\n    }\n  }",
    "comment": " Run all the passes in the optimizer. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "PhaseOptimizer.startPass",
    "class_name": "com.google.javascript.jscomp.PhaseOptimizer",
    "signature": "com.google.javascript.jscomp.PhaseOptimizer.startPass(String)",
    "snippet": "  private void startPass(String passName) {\n    Preconditions.checkState(currentTracer == null && currentPassName == null);\n    currentPassName = passName;\n    currentTracer = newTracer(passName);\n  }",
    "comment": " Marks the beginning of a pass. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "PhaseOptimizer.stopTracer",
    "class_name": "com.google.javascript.jscomp.PhaseOptimizer",
    "signature": "com.google.javascript.jscomp.PhaseOptimizer.stopTracer(Tracer,String)",
    "snippet": "  private void stopTracer(Tracer t, String passName) {\n    long result = t.stop();\n    if (tracker != null) {\n      tracker.recordPassStop(passName, result);\n    }\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "LoopInternal.addLoopedPass",
    "class_name": "com.google.javascript.jscomp.PhaseOptimizer$LoopInternal",
    "signature": "com.google.javascript.jscomp.PhaseOptimizer$LoopInternal.addLoopedPass(PassFactory)",
    "snippet": "    @Override\n    void addLoopedPass(PassFactory factory) {\n      String name = factory.getName();\n      Preconditions.checkArgument(\n          !myNames.contains(name),\n          \"Already a pass with name '\" + name + \"' in this loop\");\n      myNames.add(factory.getName());\n      myPasses.add(new PassFactoryDelegate(compiler, factory));\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "LoopInternal.optimizePasses",
    "class_name": "com.google.javascript.jscomp.PhaseOptimizer$LoopInternal",
    "signature": "com.google.javascript.jscomp.PhaseOptimizer$LoopInternal.optimizePasses()",
    "snippet": "    private void optimizePasses() {\n      // It's important that this ordering is deterministic, so that\n      // multiple compiles with the same input produce exactly the same\n      // results.\n      //\n      // To do this, grab any passes we recognize, and move them to the end\n      // in an \"optimal\" order.\n      List<NamedPass> optimalPasses = Lists.newArrayList();\n      for (String passName : OPTIMAL_ORDER) {\n        for (NamedPass pass : myPasses) {\n          if (pass.name.equals(passName)) {\n            optimalPasses.add(pass);\n            break;\n          }\n        }\n      }\n\n      myPasses.removeAll(optimalPasses);\n      myPasses.addAll(optimalPasses);\n    }",
    "comment": "Re-arrange the passes in an optimal order. */",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "LoopInternal.process",
    "class_name": "com.google.javascript.jscomp.PhaseOptimizer$LoopInternal",
    "signature": "com.google.javascript.jscomp.PhaseOptimizer$LoopInternal.process(Node,Node)",
    "snippet": "    public void process(Node externs, Node root) {\n      Preconditions.checkState(!loopMutex, \"Nested loops are forbidden\");\n      loopMutex = true;\n      if (randomizeLoops) {\n        randomizePasses();\n      } else {\n        optimizePasses();\n      }\n\n      try {\n        // TODO(nicksantos): Use a smarter algorithm that dynamically adjusts\n        // the order that passes are run in.\n        int count = 0;\n        out: do {\n          if (count++ > MAX_LOOPS) {\n            compiler.throwInternalError(OPTIMIZE_LOOP_ERROR, null);\n          }\n\n          recentChange.reset();  // reset before this round of optimizations\n\n          for (CompilerPass pass : myPasses) {\n            pass.process(externs, root);\n            if (hasHaltingErrors()) {\n              break out;\n            }\n          }\n\n        } while (recentChange.hasCodeChanged() && !hasHaltingErrors());\n\n        if (randomizeLoops) {\n          loopsRun.add(getPassOrder());\n        }\n      } finally {\n        loopMutex = false;\n      }\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "NamedPass.process",
    "class_name": "com.google.javascript.jscomp.PhaseOptimizer$NamedPass",
    "signature": "com.google.javascript.jscomp.PhaseOptimizer$NamedPass.process(Node,Node)",
    "snippet": "    public void process(Node externs, Node root) {\n      logger.info(name);\n      startPass(name);\n      processInternal(externs, root);\n      endPass(externs, root);\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "PassFactoryDelegate.processInternal",
    "class_name": "com.google.javascript.jscomp.PhaseOptimizer$PassFactoryDelegate",
    "signature": "com.google.javascript.jscomp.PhaseOptimizer$PassFactoryDelegate.processInternal(Node,Node)",
    "snippet": "    @Override\n    void processInternal(Node externs, Node root) {\n      factory.create(myCompiler).process(externs, root);\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "PrepareAst.PrepareAst",
    "class_name": "com.google.javascript.jscomp.PrepareAst",
    "signature": "com.google.javascript.jscomp.PrepareAst.PrepareAst(AbstractCompiler)",
    "snippet": "  PrepareAst(AbstractCompiler compiler) {\n    this(compiler, false);\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "PrepareAst.PrepareAst",
    "class_name": "com.google.javascript.jscomp.PrepareAst",
    "signature": "com.google.javascript.jscomp.PrepareAst.PrepareAst(AbstractCompiler,boolean)",
    "snippet": "  PrepareAst(AbstractCompiler compiler, boolean checkOnly) {\n    this.compiler = compiler;\n    this.checkOnly = checkOnly;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "PrepareAst.process",
    "class_name": "com.google.javascript.jscomp.PrepareAst",
    "signature": "com.google.javascript.jscomp.PrepareAst.process(Node,Node)",
    "snippet": "  @Override\n  public void process(Node externs, Node root) {\n    if (checkOnly) {\n      normalizeNodeTypes(root);\n    } else {\n      // Don't perform \"PrepareAnnotations\" when doing checks as\n      // they currently aren't valid during sanity checks.  In particular,\n      // they DIRECT_EVAL shouldn't be applied after inlining has been\n      // performed.\n      if (externs != null) {\n        NodeTraversal.traverse(\n            compiler, externs, new PrepareAnnotations(compiler));\n      }\n      if (root != null) {\n        NodeTraversal.traverse(\n            compiler, root, new PrepareAnnotations(compiler));\n      }\n    }\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "PrepareAnnotations.annotateDispatchers",
    "class_name": "com.google.javascript.jscomp.PrepareAst$PrepareAnnotations",
    "signature": "com.google.javascript.jscomp.PrepareAst$PrepareAnnotations.annotateDispatchers(Node,Node)",
    "snippet": "    private void annotateDispatchers(Node n, Node parent) {\n      Preconditions.checkState(n.getType() == Token.FUNCTION);\n      if (parent.getJSDocInfo() != null\n          && parent.getJSDocInfo().isJavaDispatch()) {\n        if (parent.getType() == Token.ASSIGN) {\n          Preconditions.checkState(parent.getLastChild() == n);\n          n.putBooleanProp(Node.IS_DISPATCHER, true);\n        }\n      }\n    }",
    "comment": " Translate dispatcher info into the property expected node. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "PrepareAnnotations.annotateFunctions",
    "class_name": "com.google.javascript.jscomp.PrepareAst$PrepareAnnotations",
    "signature": "com.google.javascript.jscomp.PrepareAst$PrepareAnnotations.annotateFunctions(Node,Node)",
    "snippet": "    private void annotateFunctions(Node n, Node parent) {\n      JSDocInfo fnInfo = NodeUtil.getFunctionJSDocInfo(n);\n\n      // Compute which function parameters are optional and\n      // which are var_args.\n      Node args = n.getFirstChild().getNext();\n      for (Node arg = args.getFirstChild();\n           arg != null;\n           arg = arg.getNext()) {\n        String argName = arg.getString();\n        JSTypeExpression typeExpr = fnInfo == null ?\n            null : fnInfo.getParameterType(argName);\n\n        if (convention.isOptionalParameter(arg) ||\n            typeExpr != null && typeExpr.isOptionalArg()) {\n          arg.putBooleanProp(Node.IS_OPTIONAL_PARAM, true);\n        }\n        if (convention.isVarArgsParameter(arg) ||\n            typeExpr != null && typeExpr.isVarArgs()) {\n          arg.putBooleanProp(Node.IS_VAR_ARGS_PARAM, true);\n        }\n      }\n    }",
    "comment": " Annotate optional and var_arg function parameters. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "PrepareAnnotations.shouldTraverse",
    "class_name": "com.google.javascript.jscomp.PrepareAst$PrepareAnnotations",
    "signature": "com.google.javascript.jscomp.PrepareAst$PrepareAnnotations.shouldTraverse(NodeTraversal,Node,Node)",
    "snippet": "    @Override\n    public boolean shouldTraverse(NodeTraversal t, Node n, Node parent) {\n      if (n.getType() == Token.OBJECTLIT) {\n        normalizeObjectLiteralAnnotations(n);\n      }\n      return true;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "PrepareAnnotations.visit",
    "class_name": "com.google.javascript.jscomp.PrepareAst$PrepareAnnotations",
    "signature": "com.google.javascript.jscomp.PrepareAst$PrepareAnnotations.visit(NodeTraversal,Node,Node)",
    "snippet": "    @Override\n    public void visit(NodeTraversal t, Node n, Node parent) {\n      switch (n.getType()) {\n        case Token.CALL:\n          annotateCalls(n);\n          break;\n\n        case Token.FUNCTION:\n          annotateFunctions(n, parent);\n          annotateDispatchers(n, parent);\n          break;\n      }\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "PrintStreamErrorManager.PrintStreamErrorManager",
    "class_name": "com.google.javascript.jscomp.PrintStreamErrorManager",
    "signature": "com.google.javascript.jscomp.PrintStreamErrorManager.PrintStreamErrorManager(MessageFormatter,PrintStream)",
    "snippet": "  public PrintStreamErrorManager(MessageFormatter formatter,\n                                 PrintStream stream) {\n    this.formatter = formatter;\n    this.stream = stream;\n  }",
    "comment": " Creates an error manager. @param formatter the message formatter used to format the messages @param stream the stream on which the errors and warnings should be printed. This class does not close the stream ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "PrintStreamErrorManager.printSummary",
    "class_name": "com.google.javascript.jscomp.PrintStreamErrorManager",
    "signature": "com.google.javascript.jscomp.PrintStreamErrorManager.printSummary()",
    "snippet": "  @Override\n  public void printSummary() {\n    if (summaryDetailLevel >= 3 ||\n        (summaryDetailLevel >= 1 && getErrorCount() + getWarningCount() > 0) ||\n        (summaryDetailLevel >= 2 && getTypedPercent() > 0.0)) {\n      if (getTypedPercent() > 0.0) {\n        stream.format(\"%d error(s), %d warning(s), %.1f%% typed%n\",\n            getErrorCount(), getWarningCount(), getTypedPercent());\n      } else {\n        stream.format(\"%d error(s), %d warning(s)%n\", getErrorCount(),\n            getWarningCount());\n      }\n    }\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "PrintStreamErrorManager.println",
    "class_name": "com.google.javascript.jscomp.PrintStreamErrorManager",
    "signature": "com.google.javascript.jscomp.PrintStreamErrorManager.println(CheckLevel,JSError)",
    "snippet": "  @Override\n  public void println(CheckLevel level, JSError error) {\n    stream.println(error.format(level, formatter));\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "PrintStreamErrorManager.setSummaryDetailLevel",
    "class_name": "com.google.javascript.jscomp.PrintStreamErrorManager",
    "signature": "com.google.javascript.jscomp.PrintStreamErrorManager.setSummaryDetailLevel(int)",
    "snippet": "  public void setSummaryDetailLevel(int summaryDetailLevel) {\n    this.summaryDetailLevel = summaryDetailLevel;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "ProcessClosurePrimitives.ProcessClosurePrimitives",
    "class_name": "com.google.javascript.jscomp.ProcessClosurePrimitives",
    "signature": "com.google.javascript.jscomp.ProcessClosurePrimitives.ProcessClosurePrimitives(AbstractCompiler,CheckLevel,boolean)",
    "snippet": "  ProcessClosurePrimitives(AbstractCompiler compiler,\n                           CheckLevel requiresLevel,\n                           boolean rewriteNewDateGoogNow) {\n    this.compiler = compiler;\n    this.moduleGraph = compiler.getModuleGraph();\n    this.requiresLevel = requiresLevel;\n    this.rewriteNewDateGoogNow = rewriteNewDateGoogNow;\n\n    // goog is special-cased because it is provided in Closure's base library.\n    providedNames.put(GOOG,\n        new ProvidedName(GOOG, null, null, false /* implicit */));\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "ProcessClosurePrimitives.getExportedVariableNames",
    "class_name": "com.google.javascript.jscomp.ProcessClosurePrimitives",
    "signature": "com.google.javascript.jscomp.ProcessClosurePrimitives.getExportedVariableNames()",
    "snippet": "  Set<String> getExportedVariableNames() {\n    return exportedVariables;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "ProcessClosurePrimitives.handleCandidateProvideDefinition",
    "class_name": "com.google.javascript.jscomp.ProcessClosurePrimitives",
    "signature": "com.google.javascript.jscomp.ProcessClosurePrimitives.handleCandidateProvideDefinition(NodeTraversal,Node,Node)",
    "snippet": "  private void handleCandidateProvideDefinition(\n      NodeTraversal t, Node n, Node parent) {\n    if (t.inGlobalScope()) {\n      String name = null;\n      if (n.getType() == Token.NAME && parent.getType() == Token.VAR) {\n        name = n.getString();\n      } else if (n.getType() == Token.ASSIGN &&\n          parent.getType() == Token.EXPR_RESULT) {\n        name = n.getFirstChild().getQualifiedName();\n      }\n\n      if (name != null) {\n        if (parent.getBooleanProp(Node.IS_NAMESPACE)) {\n          processProvideFromPreviousPass(t, name, parent);\n        } else {\n          ProvidedName pn = providedNames.get(name);\n          if (pn != null) {\n            pn.addDefinition(parent, t.getModule());\n          }\n        }\n      }\n    }\n  }",
    "comment": " Handles a candidate definition for a goog.provided name. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "ProcessClosurePrimitives.handleTypedefDefinition",
    "class_name": "com.google.javascript.jscomp.ProcessClosurePrimitives",
    "signature": "com.google.javascript.jscomp.ProcessClosurePrimitives.handleTypedefDefinition(NodeTraversal,Node,Node)",
    "snippet": "  private void handleTypedefDefinition(\n      NodeTraversal t, Node n, Node parent) {\n    JSDocInfo info = n.getFirstChild().getJSDocInfo();\n    if (t.inGlobalScope() && info != null && info.hasTypedefType()) {\n      String name = n.getFirstChild().getQualifiedName();\n      if (name != null) {\n        ProvidedName pn = providedNames.get(name);\n        if (pn != null) {\n          pn.addDefinition(n, t.getModule());\n        }\n      }\n    }\n  }",
    "comment": " Handles a typedef definition for a goog.provided name. @param n EXPR_RESULT node. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "ProcessClosurePrimitives.process",
    "class_name": "com.google.javascript.jscomp.ProcessClosurePrimitives",
    "signature": "com.google.javascript.jscomp.ProcessClosurePrimitives.process(Node,Node)",
    "snippet": "  @Override\n  public void process(Node externs, Node root) {\n    new NodeTraversal(compiler, this).traverse(root);\n\n    for (ProvidedName pn : providedNames.values()) {\n      pn.replace();\n    }\n\n    if (requiresLevel.isOn()) {\n      for (UnrecognizedRequire r : unrecognizedRequires) {\n        DiagnosticType error;\n        ProvidedName expectedName = providedNames.get(r.namespace);\n        if (expectedName != null && expectedName.firstNode != null) {\n          // The namespace ended up getting provided after it was required.\n          error = LATE_PROVIDE_ERROR;\n        } else {\n          error = MISSING_PROVIDE_ERROR;\n        }\n\n        compiler.report(JSError.make(\n            r.inputName, r.requireNode, requiresLevel, error, r.namespace));\n      }\n    }\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "ProcessClosurePrimitives.visit",
    "class_name": "com.google.javascript.jscomp.ProcessClosurePrimitives",
    "signature": "com.google.javascript.jscomp.ProcessClosurePrimitives.visit(NodeTraversal,Node,Node)",
    "snippet": "  @Override\n  public void visit(NodeTraversal t, Node n, Node parent) {\n    switch (n.getType()) {\n      case Token.CALL:\n        boolean isExpr = parent.getType() == Token.EXPR_RESULT;\n        Node left = n.getFirstChild();\n        if (left.getType() == Token.GETPROP) {\n          Node name = left.getFirstChild();\n          if (name.getType() == Token.NAME &&\n              GOOG.equals(name.getString())) {\n            // For the sake of simplicity, we report code changes\n            // when we see a provides/requires, and don't worry about\n            // reporting the change when we actually do the replacement.\n            String methodName = name.getNext().getString();\n            if (\"base\".equals(methodName)) {\n              processBaseClassCall(t, n);\n            } else if (!isExpr) {\n              // All other methods must be called in an EXPR.\n              break;\n            } else if (\"require\".equals(methodName)) {\n              processRequireCall(t, n, parent);\n            } else if (\"provide\".equals(methodName)) {\n              processProvideCall(t, n, parent);\n            } else if (\"exportSymbol\".equals(methodName)) {\n              Node arg = left.getNext();\n              if (arg.getType() == Token.STRING) {\n                int dot = arg.getString().indexOf('.');\n                if (dot == -1) {\n                  exportedVariables.add(arg.getString());\n                } else {\n                  exportedVariables.add(arg.getString().substring(0, dot));\n                }\n              }\n            } else if (\"addDependency\".equals(methodName)) {\n              CodingConvention convention = compiler.getCodingConvention();\n              List<String> typeDecls =\n                  convention.identifyTypeDeclarationCall(n);\n              if (typeDecls != null) {\n                for (String typeDecl : typeDecls) {\n                  compiler.getTypeRegistry().forwardDeclareType(typeDecl);\n                }\n              }\n\n              // We can't modify parent, so just create a node that will\n              // get compiled out.\n              parent.replaceChild(n, Node.newNumber(0));\n              compiler.reportCodeChange();\n            } else if (\"setCssNameMapping\".equals(methodName)) {\n              processSetCssNameMapping(t, n, parent);\n            }\n          }\n        }\n        break;\n\n      case Token.ASSIGN:\n      case Token.NAME:\n        // If this is an assignment to a provided name, remove the provided\n        // object.\n        handleCandidateProvideDefinition(t, n, parent);\n        break;\n\n      case Token.EXPR_RESULT:\n        handleTypedefDefinition(t, n, parent);\n        break;\n\n      case Token.FUNCTION:\n        // If this is a declaration of a provided named function, this is an\n        // error. Hosited functions will explode if the're provided.\n        if (t.inGlobalScope() &&\n            !NodeUtil.isFunctionExpression(n)) {\n          String name = n.getFirstChild().getString();\n          ProvidedName pn = providedNames.get(name);\n          if (pn != null) {\n            compiler.report(t.makeError(n, FUNCTION_NAMESPACE_ERROR, name));\n          }\n        }\n        break;\n\n      case Token.NEW:\n        trySimplifyNewDate(t, n, parent);\n        break;\n\n      case Token.GETPROP:\n        if (n.getFirstChild().getType() == Token.NAME &&\n            parent.getType() != Token.CALL &&\n            parent.getType() != Token.ASSIGN &&\n            \"goog.base\".equals(n.getQualifiedName())) {\n          reportBadBaseClassUse(t, n, \"May only be called directly.\");\n        }\n        break;\n    }\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "ProvidedName.addProvide",
    "class_name": "com.google.javascript.jscomp.ProcessClosurePrimitives$ProvidedName",
    "signature": "com.google.javascript.jscomp.ProcessClosurePrimitives$ProvidedName.addProvide(Node,JSModule,boolean)",
    "snippet": "    void addProvide(Node node, JSModule module, boolean explicit) {\n      if (explicit) {\n        Preconditions.checkState(explicitNode == null);\n        Preconditions.checkArgument(NodeUtil.isExpressionNode(node));\n        explicitNode = node;\n        explicitModule = module;\n      }\n      updateMinimumModule(module);\n    }",
    "comment": " Add an implicit or explicit provide. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "ProvidedName.replace",
    "class_name": "com.google.javascript.jscomp.ProcessClosurePrimitives$ProvidedName",
    "signature": "com.google.javascript.jscomp.ProcessClosurePrimitives$ProvidedName.replace()",
    "snippet": "    void replace() {\n      if (firstNode == null) {\n        // Don't touch the base case ('goog').\n        replacementNode = candidateDefinition;\n        return;\n      }\n\n      // Handle the case where there is a duplicate definition for an explicitly\n      // provided symbol.\n      if (candidateDefinition != null && explicitNode != null) {\n        explicitNode.detachFromParent();\n        compiler.reportCodeChange();\n\n        // Does this need a VAR keyword?\n        replacementNode = candidateDefinition;\n        if (NodeUtil.isExpressionNode(candidateDefinition) &&\n            !candidateDefinition.getFirstChild().isQualifiedName()) {\n          candidateDefinition.putBooleanProp(Node.IS_NAMESPACE, true);\n          Node assignNode = candidateDefinition.getFirstChild();\n          Node nameNode = assignNode.getFirstChild();\n          if (nameNode.getType() == Token.NAME) {\n            // Need to convert this assign to a var declaration.\n            Node valueNode = nameNode.getNext();\n            assignNode.removeChild(nameNode);\n            assignNode.removeChild(valueNode);\n            nameNode.addChildToFront(valueNode);\n            Node varNode = new Node(Token.VAR, nameNode);\n            varNode.copyInformationFrom(candidateDefinition);\n            candidateDefinition.getParent().replaceChild(\n                candidateDefinition, varNode);\n            nameNode.setJSDocInfo(assignNode.getJSDocInfo());\n            compiler.reportCodeChange();\n            replacementNode = varNode;\n          }\n        }\n      } else {\n        // Handle the case where there's not a duplicate definition.\n        replacementNode = createDeclarationNode();\n        if (firstModule == minimumModule) {\n          firstNode.getParent().addChildBefore(replacementNode, firstNode);\n        } else {\n          // In this case, the name was implicitly provided by two independent\n          // modules. We need to move this code up to a common module.\n          int indexOfDot = namespace.lastIndexOf('.');\n          if (indexOfDot == -1) {\n            // Any old place is fine.\n            compiler.getNodeForCodeInsertion(minimumModule)\n                .addChildToBack(replacementNode);\n          } else {\n            // Add it after the parent namespace.\n            ProvidedName parentName =\n                providedNames.get(namespace.substring(0, indexOfDot));\n            Preconditions.checkNotNull(parentName);\n            Preconditions.checkNotNull(parentName.replacementNode);\n            parentName.replacementNode.getParent().addChildAfter(\n                replacementNode, parentName.replacementNode);\n          }\n        }\n        if (explicitNode != null) {\n          explicitNode.detachFromParent();\n        }\n        compiler.reportCodeChange();\n      }\n    }",
    "comment": " Replace the provide statement.  If we're providing a name with no definition, then create one. If we're providing a name with a duplicate definition, then make sure that definition becomes a declaration. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "ProvidedName.updateMinimumModule",
    "class_name": "com.google.javascript.jscomp.ProcessClosurePrimitives$ProvidedName",
    "signature": "com.google.javascript.jscomp.ProcessClosurePrimitives$ProvidedName.updateMinimumModule(JSModule)",
    "snippet": "    private void updateMinimumModule(JSModule newModule) {\n      if (minimumModule == null) {\n        minimumModule = newModule;\n      } else if (moduleGraph != null) {\n        minimumModule = moduleGraph.getDeepestCommonDependencyInclusive(\n            minimumModule, newModule);\n      } else {\n        // If there is no module graph, then there must be exactly one\n        // module in the program.\n        Preconditions.checkState(newModule == minimumModule,\n                                 \"Missing module graph\");\n      }\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "ProcessDefines.ProcessDefines",
    "class_name": "com.google.javascript.jscomp.ProcessDefines",
    "signature": "com.google.javascript.jscomp.ProcessDefines.ProcessDefines(AbstractCompiler,Map)",
    "snippet": "  ProcessDefines(AbstractCompiler compiler, Map<String, Node> replacements) {\n    this.compiler = compiler;\n    dominantReplacements = replacements;\n  }",
    "comment": " Create a pass that overrides define constants.  TODO(nicksantos): Write a builder to help JSCompiler induce {@code replacements} from command-line flags  @param replacements A hash table of names of defines to their replacements. All replacements <b>must</b> be literals. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "ProcessDefines.collectDefines",
    "class_name": "com.google.javascript.jscomp.ProcessDefines",
    "signature": "com.google.javascript.jscomp.ProcessDefines.collectDefines(Node,GlobalNamespace)",
    "snippet": "  private Map<String, DefineInfo> collectDefines(Node root,\n      GlobalNamespace namespace) {\n    // Find all the global names with a @define annotation\n    List<Name> allDefines = Lists.newArrayList();\n    for (Name name : namespace.getNameIndex().values()) {\n      Ref decl = name.getDeclaration();\n      if (name.docInfo != null && name.docInfo.isDefine()) {\n        // Process defines should not depend on check types being enabled,\n        // so we look for the JSDoc instead of the inferred type.\n        if (isValidDefineType(name.docInfo.getType())) {\n          allDefines.add(name);\n        } else {\n          JSError error = JSError.make(\n              decl.getSourceName(),\n              decl.node, INVALID_DEFINE_TYPE_ERROR);\n          compiler.report(error);\n        }\n      } else {\n        for (Ref ref : name.getRefs()) {\n          if (ref == decl) {\n            // Declarations were handled above.\n            continue;\n          }\n\n          Node n = ref.node;\n          Node parent = ref.node.getParent();\n          JSDocInfo info = n.getJSDocInfo();\n          if (info == null &&\n              parent.getType() == Token.VAR && parent.hasOneChild()) {\n            info = parent.getJSDocInfo();\n          }\n\n          if (info != null && info.isDefine()) {\n            allDefines.add(name);\n            break;\n          }\n        }\n      }\n    }\n\n    CollectDefines pass = new CollectDefines(compiler, allDefines);\n    NodeTraversal.traverse(compiler, root, pass);\n    return pass.getAllDefines();\n  }",
    "comment": " Finds all defines, and creates a {@link DefineInfo} data structure for each one. @return A map of {@link DefineInfo} structures, keyed by name. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "ProcessDefines.injectNamespace",
    "class_name": "com.google.javascript.jscomp.ProcessDefines",
    "signature": "com.google.javascript.jscomp.ProcessDefines.injectNamespace(GlobalNamespace)",
    "snippet": "  ProcessDefines injectNamespace(GlobalNamespace namespace) {\n    this.namespace = namespace;\n    return this;\n  }",
    "comment": " Injects a pre-computed global namespace, so that the same namespace can be re-used for multiple check passes. Returns {@code this} for easy chaining. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "ProcessDefines.overrideDefines",
    "class_name": "com.google.javascript.jscomp.ProcessDefines",
    "signature": "com.google.javascript.jscomp.ProcessDefines.overrideDefines(Map)",
    "snippet": "  private void overrideDefines(Map<String, DefineInfo> allDefines) {\n    boolean changed = false;\n    for (Map.Entry<String, DefineInfo> def : allDefines.entrySet()) {\n      String defineName = def.getKey();\n      DefineInfo info = def.getValue();\n      Node inputValue = dominantReplacements.get(defineName);\n      Node finalValue = inputValue != null ?\n          inputValue : info.getLastValue();\n      if (finalValue != info.initialValue) {\n        info.initialValueParent.replaceChild(\n            info.initialValue, finalValue.cloneTree());\n        compiler.addToDebugLog(\"Overriding @define variable \" + defineName);\n        changed = changed ||\n            finalValue.getType() != info.initialValue.getType() ||\n            !finalValue.isEquivalentTo(info.initialValue);\n      }\n    }\n\n    if (changed) {\n      compiler.reportCodeChange();\n    }\n\n    Set<String> unusedReplacements = dominantReplacements.keySet();\n    unusedReplacements.removeAll(allDefines.keySet());\n    unusedReplacements.removeAll(KNOWN_DEFINES);\n    for (String unknownDefine : unusedReplacements) {\n      compiler.report(JSError.make(UNKNOWN_DEFINE_WARNING, unknownDefine));\n    }\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "ProcessDefines.process",
    "class_name": "com.google.javascript.jscomp.ProcessDefines",
    "signature": "com.google.javascript.jscomp.ProcessDefines.process(Node,Node)",
    "snippet": "  public void process(Node externs, Node root) {\n    if (namespace == null) {\n      namespace = new GlobalNamespace(compiler, root);\n    }\n    overrideDefines(collectDefines(root, namespace));\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "CollectDefines.getAllDefines",
    "class_name": "com.google.javascript.jscomp.ProcessDefines$CollectDefines",
    "signature": "com.google.javascript.jscomp.ProcessDefines$CollectDefines.getAllDefines()",
    "snippet": "    Map<String, DefineInfo> getAllDefines() {\n      return allDefines;\n    }",
    "comment": " Get a map of {@link DefineInfo} structures, keyed by the name of the define. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "CollectDefines.shouldTraverse",
    "class_name": "com.google.javascript.jscomp.ProcessDefines$CollectDefines",
    "signature": "com.google.javascript.jscomp.ProcessDefines$CollectDefines.shouldTraverse(NodeTraversal,Node,Node)",
    "snippet": "    public boolean shouldTraverse(NodeTraversal nodeTraversal, Node n,\n        Node parent) {\n      updateAssignAllowedStack(n, true);\n      return true;\n    }",
    "comment": " Keeps track of whether the traversal is in a conditional branch. We traverse all nodes of the parse tree. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "CollectDefines.updateAssignAllowedStack",
    "class_name": "com.google.javascript.jscomp.ProcessDefines$CollectDefines",
    "signature": "com.google.javascript.jscomp.ProcessDefines$CollectDefines.updateAssignAllowedStack(Node,boolean)",
    "snippet": "    private void updateAssignAllowedStack(Node n, boolean entering) {\n      switch (n.getType()) {\n        case Token.CASE:\n        case Token.FOR:\n        case Token.FUNCTION:\n        case Token.HOOK:\n        case Token.IF:\n        case Token.SWITCH:\n        case Token.WHILE:\n          if (entering) {\n            assignAllowed.push(0);\n          } else {\n            assignAllowed.remove();\n          }\n          break;\n      }\n    }",
    "comment": " Determines whether assignment to a define should be allowed in the subtree of the given node, and if not, records that fact.  @param n The node whose subtree we're about to enter or exit. @param entering True if we're entering the subtree, false otherwise. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "CollectDefines.visit",
    "class_name": "com.google.javascript.jscomp.ProcessDefines$CollectDefines",
    "signature": "com.google.javascript.jscomp.ProcessDefines$CollectDefines.visit(NodeTraversal,Node,Node)",
    "snippet": "    public  void visit(NodeTraversal t, Node n, Node parent) {\n      RefInfo refInfo = allRefInfo.get(n);\n      if (refInfo != null) {\n        Ref ref = refInfo.ref;\n        Name name = refInfo.name;\n        String fullName = name.fullName();\n        switch (ref.type) {\n          case SET_FROM_GLOBAL:\n          case SET_FROM_LOCAL:\n            Node valParent = getValueParent(ref);\n            Node val = valParent.getLastChild();\n            if (valParent.getType() == Token.ASSIGN && name.isSimpleName() &&\n                name.getDeclaration() == ref) {\n              // For defines, it's an error if a simple name is assigned\n              // before it's declared\n              compiler.report(\n                  t.makeError(val, INVALID_DEFINE_INIT_ERROR, fullName));\n            } else if (processDefineAssignment(t, fullName, val, valParent)) {\n              // remove the assignment so that the variable is still declared,\n              // but no longer assigned to a value, e.g.,\n              // DEF_FOO = 5; // becomes \"5;\"\n\n              // We can't remove the ASSIGN/VAR when we're still visiting its\n              // children, so we'll have to come back later to remove it.\n              refInfo.name.removeRef(ref);\n              lvalueToRemoveLater = valParent;\n            }\n            break;\n          default:\n            if (t.inGlobalScope()) {\n              // Treat this as a reference to a define in the global scope.\n              // After this point, the define must not be reassigned,\n              // or it's an error.\n              DefineInfo info = assignableDefines.get(fullName);\n              if (info != null) {\n                setDefineInfoNotAssignable(info, t);\n                assignableDefines.remove(fullName);\n              }\n            }\n            break;\n        }\n      }\n\n      if (!t.inGlobalScope() &&\n          n.getJSDocInfo() != null && n.getJSDocInfo().isDefine()) {\n        // warn about @define annotations in local scopes\n        compiler.report(\n            t.makeError(n, NON_GLOBAL_DEFINE_INIT_ERROR, \"\"));\n      }\n\n      if (lvalueToRemoveLater == n) {\n        lvalueToRemoveLater = null;\n        if (n.getType() == Token.ASSIGN) {\n          Node last = n.getLastChild();\n          n.removeChild(last);\n          parent.replaceChild(n, last);\n        } else {\n          Preconditions.checkState(n.getType() == Token.NAME);\n          n.removeChild(n.getFirstChild());\n        }\n        compiler.reportCodeChange();\n      }\n\n      if (n.getType() == Token.CALL) {\n        if (t.inGlobalScope()) {\n          // If there's a function call in the global scope,\n          // we just say it's unsafe and freeze all the defines.\n          //\n          // NOTE(nicksantos): We could be a lot smarter here. For example,\n          // ReplaceOverriddenVars keeps a call graph of all functions and\n          // which functions/variables that they reference, and tries\n          // to statically determine which functions are \"safe\" and which\n          // are not. But this would be overkill, expecially because\n          // the intended use of defines is with config_files, where\n          // all the defines are at the top of the bundle.\n          for (DefineInfo info : assignableDefines.values()) {\n            setDefineInfoNotAssignable(info, t);\n          }\n\n          assignableDefines.clear();\n        }\n      }\n\n      updateAssignAllowedStack(n, false);\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "TweakFunction.getName",
    "class_name": "com.google.javascript.jscomp.ProcessTweaks$TweakFunction",
    "signature": "com.google.javascript.jscomp.ProcessTweaks$TweakFunction.getName()",
    "snippet": "    String getName() {\n      return name;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "ReferenceCollectingCallback.ReferenceCollectingCallback",
    "class_name": "com.google.javascript.jscomp.ReferenceCollectingCallback",
    "signature": "com.google.javascript.jscomp.ReferenceCollectingCallback.ReferenceCollectingCallback(AbstractCompiler,Behavior)",
    "snippet": "  ReferenceCollectingCallback(AbstractCompiler compiler, Behavior behavior) {\n    this(compiler, behavior, Predicates.<Var>alwaysTrue());\n  }",
    "comment": " Constructor initializes block stack. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "ReferenceCollectingCallback.ReferenceCollectingCallback",
    "class_name": "com.google.javascript.jscomp.ReferenceCollectingCallback",
    "signature": "com.google.javascript.jscomp.ReferenceCollectingCallback.ReferenceCollectingCallback(AbstractCompiler,Behavior,Predicate)",
    "snippet": "  ReferenceCollectingCallback(AbstractCompiler compiler, Behavior behavior,\n      Predicate<Var> varFilter) {\n    this.compiler = compiler;\n    this.behavior = behavior;\n    this.varFilter = varFilter;\n  }",
    "comment": " Constructor only collects references that match the given variable.  The test for Var equality uses reference equality, so it's necessary to inject a scope when you traverse. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "ReferenceCollectingCallback.addReference",
    "class_name": "com.google.javascript.jscomp.ReferenceCollectingCallback",
    "signature": "com.google.javascript.jscomp.ReferenceCollectingCallback.addReference(NodeTraversal,Var,Reference)",
    "snippet": "  private void addReference(NodeTraversal t, Var v, Reference reference) {\n    // Create collection if none already\n    ReferenceCollection referenceInfo = referenceMap.get(v);\n    if (referenceInfo == null) {\n      referenceInfo = new ReferenceCollection();\n      referenceMap.put(v, referenceInfo);\n    }\n\n    // Add this particular reference\n    referenceInfo.add(reference, t, v);\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "ReferenceCollectingCallback.enterScope",
    "class_name": "com.google.javascript.jscomp.ReferenceCollectingCallback",
    "signature": "com.google.javascript.jscomp.ReferenceCollectingCallback.enterScope(NodeTraversal)",
    "snippet": "  public void enterScope(NodeTraversal t) {\n    Node n = t.getScope().getRootNode();\n    BasicBlock parent = blockStack.isEmpty() ? null : blockStack.peek();\n    blockStack.push(new BasicBlock(parent, n));\n  }",
    "comment": " Updates block stack and invokes any additional behavior. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "ReferenceCollectingCallback.exitScope",
    "class_name": "com.google.javascript.jscomp.ReferenceCollectingCallback",
    "signature": "com.google.javascript.jscomp.ReferenceCollectingCallback.exitScope(NodeTraversal)",
    "snippet": "  public void exitScope(NodeTraversal t) {\n    blockStack.pop();\n    if (t.getScope().isGlobal()) {\n      // Update global scope reference lists when we are done with it.\n      compiler.updateGlobalVarReferences(referenceMap, t.getScopeRoot());\n      behavior.afterExitScope(t, compiler.getGlobalVarReferences());\n    } else {\n      behavior.afterExitScope(t, new ReferenceMapWrapper(referenceMap));\n    }\n  }",
    "comment": " Updates block statck and invokes any additional behavior. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "ReferenceCollectingCallback.isBlockBoundary",
    "class_name": "com.google.javascript.jscomp.ReferenceCollectingCallback",
    "signature": "com.google.javascript.jscomp.ReferenceCollectingCallback.isBlockBoundary(Node,Node)",
    "snippet": "  private static boolean isBlockBoundary(Node n, Node parent) {\n    if (parent != null) {\n      switch (parent.getType()) {\n        case Token.DO:\n        case Token.FOR:\n        case Token.TRY:\n        case Token.WHILE:\n        case Token.WITH:\n          // NOTE: TRY has up to 3 child blocks:\n          // TRY\n          //   BLOCK\n          //   BLOCK\n          //     CATCH\n          //   BLOCK\n          // Note that there is an explcit CATCH token but no explicit\n          // FINALLY token. For simplicity, we consider each BLOCK\n          // a separate basic BLOCK.\n          return true;\n        case Token.AND:\n        case Token.HOOK:\n        case Token.IF:\n        case Token.OR:\n          // The first child of a conditional is not a boundary,\n          // but all the rest of the children are.\n          return n != parent.getFirstChild();\n\n      }\n    }\n\n    return n.getType() == Token.CASE;\n  }",
    "comment": " @return true if this node marks the start of a new basic block ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "ReferenceCollectingCallback.process",
    "class_name": "com.google.javascript.jscomp.ReferenceCollectingCallback",
    "signature": "com.google.javascript.jscomp.ReferenceCollectingCallback.process(Node,Node)",
    "snippet": "  @Override\n  public void process(Node externs, Node root) {\n    NodeTraversal.traverseRoots(\n        compiler, Lists.newArrayList(externs, root), this);\n  }",
    "comment": " Convenience method for running this pass over a tree with this class as a callback. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "ReferenceCollectingCallback.shouldTraverse",
    "class_name": "com.google.javascript.jscomp.ReferenceCollectingCallback",
    "signature": "com.google.javascript.jscomp.ReferenceCollectingCallback.shouldTraverse(NodeTraversal,Node,Node)",
    "snippet": "  public boolean shouldTraverse(NodeTraversal nodeTraversal, Node n,\n      Node parent) {\n    // If node is a new basic block, put on basic block stack\n    if (isBlockBoundary(n, parent)) {\n      blockStack.push(new BasicBlock(blockStack.peek(), n));\n    }\n    return true;\n  }",
    "comment": " Updates block stack. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "ReferenceCollectingCallback.visit",
    "class_name": "com.google.javascript.jscomp.ReferenceCollectingCallback",
    "signature": "com.google.javascript.jscomp.ReferenceCollectingCallback.visit(NodeTraversal,Node,Node)",
    "snippet": "  public void visit(NodeTraversal t, Node n, Node parent) {\n    if (n.getType() == Token.NAME) {\n      Var v;\n      if (n.getString().equals(\"arguments\")) {\n        v = t.getScope().getArgumentsVar();\n      } else {\n        v = t.getScope().getVar(n.getString());\n      }\n      if (v != null && varFilter.apply(v)) {\n        addReference(t, v, new Reference(n, t, blockStack.peek()));\n      }\n    }\n\n    if (isBlockBoundary(n, parent)) {\n      blockStack.pop();\n    }\n  }",
    "comment": " For each node, update the block stack and reference collection as appropriate. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "Reference.getBasicBlock",
    "class_name": "com.google.javascript.jscomp.ReferenceCollectingCallback$Reference",
    "signature": "com.google.javascript.jscomp.ReferenceCollectingCallback$Reference.getBasicBlock()",
    "snippet": "    BasicBlock getBasicBlock() {\n      return basicBlock;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "Reference.getNode",
    "class_name": "com.google.javascript.jscomp.ReferenceCollectingCallback$Reference",
    "signature": "com.google.javascript.jscomp.ReferenceCollectingCallback$Reference.getNode()",
    "snippet": "    @Override\n    public Node getNode() {\n      return nameNode;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "Reference.getParent",
    "class_name": "com.google.javascript.jscomp.ReferenceCollectingCallback$Reference",
    "signature": "com.google.javascript.jscomp.ReferenceCollectingCallback$Reference.getParent()",
    "snippet": "    Node getParent() {\n      return getNode().getParent();\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "Reference.isDeclaration",
    "class_name": "com.google.javascript.jscomp.ReferenceCollectingCallback$Reference",
    "signature": "com.google.javascript.jscomp.ReferenceCollectingCallback$Reference.isDeclaration()",
    "snippet": "    boolean isDeclaration() {\n      Node parent = getParent();\n      Node grandparent = parent.getParent();\n      return DECLARATION_PARENTS.contains(parent.getType()) ||\n          parent.getType() == Token.LP &&\n          grandparent.getType() == Token.FUNCTION;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "Reference.isHoistedFunction",
    "class_name": "com.google.javascript.jscomp.ReferenceCollectingCallback$Reference",
    "signature": "com.google.javascript.jscomp.ReferenceCollectingCallback$Reference.isHoistedFunction()",
    "snippet": "    boolean isHoistedFunction() {\n      return NodeUtil.isHoistedFunctionDeclaration(getParent());\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "ReferenceCollection.add",
    "class_name": "com.google.javascript.jscomp.ReferenceCollectingCallback$ReferenceCollection",
    "signature": "com.google.javascript.jscomp.ReferenceCollectingCallback$ReferenceCollection.add(Reference,NodeTraversal,Var)",
    "snippet": "    void add(Reference reference, NodeTraversal t, Var v) {\n      references.add(reference);\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "ReferenceMapWrapper.getReferences",
    "class_name": "com.google.javascript.jscomp.ReferenceCollectingCallback$ReferenceMapWrapper",
    "signature": "com.google.javascript.jscomp.ReferenceCollectingCallback$ReferenceMapWrapper.getReferences(Var)",
    "snippet": "    @Override\n    public ReferenceCollection getReferences(Var var) {\n      return referenceMap.get(var);\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "RemoveUnusedVars.RemoveUnusedVars",
    "class_name": "com.google.javascript.jscomp.RemoveUnusedVars",
    "signature": "com.google.javascript.jscomp.RemoveUnusedVars.RemoveUnusedVars(AbstractCompiler,boolean,boolean,boolean)",
    "snippet": "  RemoveUnusedVars(\n      AbstractCompiler compiler,\n      boolean removeGlobals,\n      boolean preserveFunctionExpressionNames,\n      boolean modifyCallSites) {\n    this.compiler = compiler;\n    this.codingConvention = compiler.getCodingConvention();\n    this.removeGlobals = removeGlobals;\n    this.preserveFunctionExpressionNames = preserveFunctionExpressionNames;\n    this.modifyCallSites = modifyCallSites;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "RemoveUnusedVars.collectMaybeUnreferencedVars",
    "class_name": "com.google.javascript.jscomp.RemoveUnusedVars",
    "signature": "com.google.javascript.jscomp.RemoveUnusedVars.collectMaybeUnreferencedVars(Scope)",
    "snippet": "  private void collectMaybeUnreferencedVars(Scope scope) {\n    for (Iterator<Var> it = scope.getVars(); it.hasNext(); ) {\n      Var var = it.next();\n      if (isRemovableVar(var)) {\n        maybeUnreferenced.add(var);\n      }\n    }\n  }",
    "comment": " For each variable in this scope that we haven't found a reference for yet, add it to the list of variables to check later. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "RemoveUnusedVars.getFunctionArgList",
    "class_name": "com.google.javascript.jscomp.RemoveUnusedVars",
    "signature": "com.google.javascript.jscomp.RemoveUnusedVars.getFunctionArgList(Node)",
    "snippet": "  private static Node getFunctionArgList(Node function) {\n    return function.getFirstChild().getNext();\n  }",
    "comment": " @return the LP node containing the function parameters. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "RemoveUnusedVars.interpretAssigns",
    "class_name": "com.google.javascript.jscomp.RemoveUnusedVars",
    "signature": "com.google.javascript.jscomp.RemoveUnusedVars.interpretAssigns()",
    "snippet": "  private void interpretAssigns() {\n    boolean changes = false;\n    do {\n      changes = false;\n\n      // We can't use traditional iterators and iterables for this list,\n      // because our lazily-evaluated continuations will modify it while\n      // we traverse it.\n      for (int current = 0; current < maybeUnreferenced.size(); current++) {\n        Var var = maybeUnreferenced.get(current);\n        if (referenced.contains(var)) {\n          maybeUnreferenced.remove(current);\n          current--;\n        } else {\n          boolean assignedToUnknownValue = false;\n          boolean hasPropertyAssign = false;\n\n          if (var.getParentNode().getType() == Token.VAR &&\n              !NodeUtil.isForIn(var.getParentNode().getParent())) {\n            Node value = var.getInitialValue();\n            assignedToUnknownValue = value != null &&\n                !NodeUtil.isLiteralValue(value, true);\n          } else {\n            // This was initialized to a function arg or a catch param\n            // or a for...in variable.\n            assignedToUnknownValue = true;\n          }\n\n          for (Assign assign : assignsByVar.get(var)) {\n            if (assign.isPropertyAssign) {\n              hasPropertyAssign = true;\n            } else if (!NodeUtil.isLiteralValue(\n                assign.assignNode.getLastChild(), true)) {\n              assignedToUnknownValue = true;\n            }\n          }\n\n          if (assignedToUnknownValue && hasPropertyAssign) {\n            changes = markReferencedVar(var) || changes;\n            maybeUnreferenced.remove(current);\n            current--;\n          }\n        }\n      }\n    } while (changes);\n  }",
    "comment": " Look at all the property assigns to all variables. These may or may not count as references. For example,  <code> var x = {}; x.foo = 3; // not a reference. var y = foo(); y.foo = 3; // is a reference. </code>  Interpreting assigments could mark a variable as referenced that wasn't referenced before, in order to keep it alive. Because we find references by lazily traversing subtrees, marking a variable as referenced could trigger new traversals of new subtrees, which could find new references.  Therefore, this interpretation needs to be run to a fixed point. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "RemoveUnusedVars.isRemovableVar",
    "class_name": "com.google.javascript.jscomp.RemoveUnusedVars",
    "signature": "com.google.javascript.jscomp.RemoveUnusedVars.isRemovableVar(Var)",
    "snippet": "  private boolean isRemovableVar(Var var) {\n    // Global variables are off-limits if the user might be using them.\n    if (!removeGlobals && var.isGlobal()) {\n      return false;\n    }\n\n    // Referenced variables are off-limits.\n    if (referenced.contains(var)) {\n      return false;\n    }\n\n    // Exported variables are off-limits.\n    if (codingConvention.isExported(var.getName())) {\n      return false;\n    }\n\n    return true;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "RemoveUnusedVars.process",
    "class_name": "com.google.javascript.jscomp.RemoveUnusedVars",
    "signature": "com.google.javascript.jscomp.RemoveUnusedVars.process(Node,Node)",
    "snippet": "  public void process(Node externs, Node root) {\n    Preconditions.checkState(compiler.getLifeCycleStage().isNormalized());\n    SimpleDefinitionFinder defFinder = null;\n\n    if (modifyCallSites) {\n      // For testing, allow the SimpleDefinitionFinder to be build now.\n      defFinder = new SimpleDefinitionFinder(compiler);\n      defFinder.process(externs, root);\n    }\n    process(externs, root, defFinder);\n  }",
    "comment": " Traverses the root, removing all unused variables. Multiple traversals may occur to ensure all unused variables are removed. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "RemoveUnusedVars.process",
    "class_name": "com.google.javascript.jscomp.RemoveUnusedVars",
    "signature": "com.google.javascript.jscomp.RemoveUnusedVars.process(Node,Node,SimpleDefinitionFinder)",
    "snippet": "  @Override\n  public void process(\n      Node externs, Node root, SimpleDefinitionFinder defFinder) {\n    if (modifyCallSites) {\n      Preconditions.checkNotNull(defFinder);\n      callSiteOptimizer = new CallSiteOptimizer(compiler, defFinder);\n    }\n    traverseAndRemoveUnusedReferences(root);\n    if (callSiteOptimizer != null) {\n      callSiteOptimizer.applyChanges();\n    }\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "RemoveUnusedVars.removeUnreferencedFunctionArgs",
    "class_name": "com.google.javascript.jscomp.RemoveUnusedVars",
    "signature": "com.google.javascript.jscomp.RemoveUnusedVars.removeUnreferencedFunctionArgs(Scope)",
    "snippet": "  private void removeUnreferencedFunctionArgs(Scope fnScope) {\n    // TODO(johnlenz): Update type registry for function signature changes.\n\n    Node function = fnScope.getRootNode();\n\n    Preconditions.checkState(function.getType() == Token.FUNCTION);\n    if (NodeUtil.isGetOrSetKey(function.getParent())) {\n      // The parameters object literal setters can not be removed.\n      return;\n    }\n\n    Node argList = getFunctionArgList(function);\n    boolean modifyCallers = modifyCallSites\n        && callSiteOptimizer.canModifyCallers(function);\n    if (!modifyCallers) {\n      // Strip unreferenced args off the end of the function declaration.\n      Node lastArg;\n      while ((lastArg = argList.getLastChild()) != null) {\n        Var var = fnScope.getVar(lastArg.getString());\n        if (!referenced.contains(var)) {\n          Preconditions.checkNotNull(var == null);\n          argList.removeChild(lastArg);\n          compiler.reportCodeChange();\n        } else {\n          break;\n        }\n      }\n    } else {\n      callSiteOptimizer.optimize(fnScope, referenced);\n    }\n  }",
    "comment": " Removes unreferenced arguments from a function declaration and when possible the function's callSites.  @param fnScope The scope inside the function ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "RemoveUnusedVars.removeUnreferencedVars",
    "class_name": "com.google.javascript.jscomp.RemoveUnusedVars",
    "signature": "com.google.javascript.jscomp.RemoveUnusedVars.removeUnreferencedVars()",
    "snippet": "  private void removeUnreferencedVars() {\n    CodingConvention convention = codingConvention;\n\n    for (Iterator<Var> it = maybeUnreferenced.iterator(); it.hasNext(); ) {\n      Var var = it.next();\n\n      // Remove calls to inheritance-defining functions where the unreferenced\n      // class is the subclass.\n      for (Node exprCallNode : inheritsCalls.get(var)) {\n        NodeUtil.removeChild(exprCallNode.getParent(), exprCallNode);\n        compiler.reportCodeChange();\n      }\n\n      // Regardless of what happens to the original declaration,\n      // we need to remove all assigns, because they may contain references\n      // to other unreferenced variables.\n      removeAllAssigns(var);\n\n      compiler.addToDebugLog(\"Unreferenced var: \" + var.name);\n      Node nameNode = var.nameNode;\n      Node toRemove = nameNode.getParent();\n      Node parent = toRemove.getParent();\n\n      Preconditions.checkState(\n          toRemove.getType() == Token.VAR ||\n          toRemove.getType() == Token.FUNCTION ||\n          toRemove.getType() == Token.LP &&\n          parent.getType() == Token.FUNCTION,\n          \"We should only declare vars and functions and function args\");\n\n      if (toRemove.getType() == Token.LP &&\n          parent.getType() == Token.FUNCTION) {\n        // Don't remove function arguments here. That's a special case\n        // that's taken care of in removeUnreferencedFunctionArgs.\n      } else if (NodeUtil.isFunctionExpression(toRemove)) {\n        if (!preserveFunctionExpressionNames) {\n          toRemove.getFirstChild().setString(\"\");\n          compiler.reportCodeChange();\n        }\n        // Don't remove bleeding functions.\n      } else if (parent != null &&\n          parent.getType() == Token.FOR &&\n          parent.getChildCount() < 4) {\n        // foreach iterations have 3 children. Leave them alone.\n      } else if (toRemove.getType() == Token.VAR &&\n          nameNode.hasChildren() &&\n          NodeUtil.mayHaveSideEffects(nameNode.getFirstChild())) {\n        // If this is a single var declaration, we can at least remove the\n        // declaration itself and just leave the value, e.g.,\n        // var a = foo(); => foo();\n        if (toRemove.getChildCount() == 1) {\n          parent.replaceChild(toRemove,\n              new Node(Token.EXPR_RESULT, nameNode.removeFirstChild()));\n          compiler.reportCodeChange();\n        }\n      } else if (toRemove.getType() == Token.VAR &&\n          toRemove.getChildCount() > 1) {\n        // For var declarations with multiple names (i.e. var a, b, c),\n        // only remove the unreferenced name\n        toRemove.removeChild(nameNode);\n        compiler.reportCodeChange();\n      } else if (parent != null) {\n        NodeUtil.removeChild(parent, toRemove);\n        compiler.reportCodeChange();\n      }\n    }\n  }",
    "comment": " Removes any vars in the scope that were not referenced. Removes any assignments to those variables as well. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "RemoveUnusedVars.traverseAndRemoveUnusedReferences",
    "class_name": "com.google.javascript.jscomp.RemoveUnusedVars",
    "signature": "com.google.javascript.jscomp.RemoveUnusedVars.traverseAndRemoveUnusedReferences(Node)",
    "snippet": "  private void traverseAndRemoveUnusedReferences(Node root) {\n    Scope scope = new SyntacticScopeCreator(compiler).createScope(root, null);\n    traverseNode(root, null, scope);\n\n    if (removeGlobals) {\n      collectMaybeUnreferencedVars(scope);\n    }\n\n    interpretAssigns();\n    removeUnreferencedVars();\n    for (Scope fnScope : allFunctionScopes) {\n      removeUnreferencedFunctionArgs(fnScope);\n    }\n  }",
    "comment": " Traverses a node recursively. Call this once per pass. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "RemoveUnusedVars.traverseFunction",
    "class_name": "com.google.javascript.jscomp.RemoveUnusedVars",
    "signature": "com.google.javascript.jscomp.RemoveUnusedVars.traverseFunction(Node,Scope)",
    "snippet": "  private void traverseFunction(Node n, Scope parentScope) {\n    Preconditions.checkState(n.getChildCount() == 3);\n    Preconditions.checkState(n.getType() == Token.FUNCTION);\n\n    final Node body = n.getLastChild();\n    Preconditions.checkState(body.getNext() == null &&\n            body.getType() == Token.BLOCK);\n\n    Scope fnScope =\n        new SyntacticScopeCreator(compiler).createScope(n, parentScope);\n    traverseNode(body, n, fnScope);\n\n    collectMaybeUnreferencedVars(fnScope);\n    allFunctionScopes.add(fnScope);\n  }",
    "comment": " Traverses a function, which creates a new scope in javascript.  Note that CATCH blocks also create a new scope, but only for the catch variable. Declarations within the block actually belong to the enclosing scope. Because we don't remove catch variables, there's no need to treat CATCH blocks differently like we do functions. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "RemoveUnusedVars.traverseNode",
    "class_name": "com.google.javascript.jscomp.RemoveUnusedVars",
    "signature": "com.google.javascript.jscomp.RemoveUnusedVars.traverseNode(Node,Node,Scope)",
    "snippet": "  private void traverseNode(Node n, Node parent, Scope scope) {\n    int type = n.getType();\n    Var var = null;\n    switch (type) {\n      case Token.FUNCTION:\n        // If this function is a removable var, then create a continuation\n        // for it instead of traversing immediately.\n        if (NodeUtil.isFunctionDeclaration(n)) {\n          var = scope.getVar(n.getFirstChild().getString());\n        }\n\n        if (var != null && isRemovableVar(var)) {\n          continuations.put(var, new Continuation(n, scope));\n        } else {\n          traverseFunction(n, scope);\n        }\n        return;\n\n      case Token.ASSIGN:\n        Assign maybeAssign = Assign.maybeCreateAssign(n);\n        if (maybeAssign != null) {\n          // Put this in the assign map. It might count as a reference,\n          // but we won't know that until we have an index of all assigns.\n          var = scope.getVar(maybeAssign.nameNode.getString());\n          if (var != null) {\n            assignsByVar.put(var, maybeAssign);\n            assignsByNode.put(maybeAssign.nameNode, maybeAssign);\n\n            if (isRemovableVar(var) &&\n                !maybeAssign.mayHaveSecondarySideEffects) {\n              // If the var is unreferenced and performing this assign has\n              // no secondary side effects, then we can create a continuation\n              // for it instead of traversing immediately.\n              continuations.put(var, new Continuation(n, scope));\n              return;\n            }\n          }\n        }\n        break;\n\n      case Token.CALL:\n        // Look for calls to inheritance-defining calls (such as goog.inherits).\n        SubclassRelationship subclassRelationship =\n            codingConvention.getClassesDefinedByCall(n);\n        if (subclassRelationship != null) {\n          Var subclassVar = scope.getVar(subclassRelationship.subclassName);\n          // Don't try to track the inheritance calls for non-globals. It would\n          // be more correct to only not track when the subclass does not\n          // reference a constructor, but checking that it is a global is\n          // easier and mostly the same.\n          if (subclassVar != null && subclassVar.isGlobal()\n              && !referenced.contains(subclassVar)) {\n            // Save a reference to the EXPR node.\n            inheritsCalls.put(subclassVar, parent);\n            continuations.put(subclassVar, new Continuation(n, scope));\n            return;\n          }\n        }\n        break;\n\n      case Token.NAME:\n        var = scope.getVar(n.getString());\n        if (parent.getType() == Token.VAR) {\n          Node value = n.getFirstChild();\n          if (value != null && var != null && isRemovableVar(var) &&\n              !NodeUtil.mayHaveSideEffects(value)) {\n            // If the var is unreferenced and creating its value has no side\n            // effects, then we can create a continuation for it instead\n            // of traversing immediately.\n            continuations.put(var, new Continuation(n, scope));\n            return;\n          }\n        } else {\n\n          // If arguments is escaped, we just assume the worst and continue\n          // on all the parameters.\n          if (\"arguments\".equals(n.getString()) && scope.isLocal()) {\n            Node lp = scope.getRootNode().getFirstChild().getNext();\n            for (Node a = lp.getFirstChild(); a != null; a = a.getNext()) {\n              markReferencedVar(scope.getVar(a.getString()));\n            }\n          }\n\n          // All name references that aren't declarations or assigns\n          // are references to other vars.\n          if (var != null) {\n            // If that var hasn't already been marked referenced, then\n            // start tracking it.  If this is an assign, do nothing\n            // for now.\n            if (isRemovableVar(var)) {\n              if (!assignsByNode.containsKey(n)) {\n                markReferencedVar(var);\n              }\n            } else {\n              markReferencedVar(var);\n            }\n          }\n        }\n        break;\n    }\n\n    for (Node c = n.getFirstChild(); c != null; c = c.getNext()) {\n      traverseNode(c, n, scope);\n    }\n  }",
    "comment": " Traverses everything in the current scope and marks variables that are referenced.  During traversal, we identify subtrees that will only be referenced if their enclosing variables are referenced. Instead of traversing those subtrees, we create a continuation for them, and traverse them lazily. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "Assign.maybeCreateAssign",
    "class_name": "com.google.javascript.jscomp.RemoveUnusedVars$Assign",
    "signature": "com.google.javascript.jscomp.RemoveUnusedVars$Assign.maybeCreateAssign(Node)",
    "snippet": "    static Assign maybeCreateAssign(Node assignNode) {\n      Preconditions.checkState(NodeUtil.isAssignmentOp(assignNode));\n\n      // Skip one level of GETPROPs or GETELEMs.\n      //\n      // Don't skip more than one level, because then we get into\n      // situations where assigns to properties of properties will always\n      // trigger side-effects, and the variable they're on cannot be removed.\n      boolean isPropAssign = false;\n      Node current = assignNode.getFirstChild();\n      if (NodeUtil.isGet(current)) {\n        current = current.getFirstChild();\n        isPropAssign = true;\n\n        if (current.getType() == Token.GETPROP &&\n            current.getLastChild().getString().equals(\"prototype\")) {\n          // Prototype properties sets should be considered like normal\n          // property sets.\n          current = current.getFirstChild();\n        }\n      }\n\n      if (current.getType() == Token.NAME) {\n        return new Assign(assignNode, current, isPropAssign);\n      }\n      return null;\n    }",
    "comment": " If this is an assign to a variable or its property, return it. Otherwise, return null. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "RenameLabels.RenameLabels",
    "class_name": "com.google.javascript.jscomp.RenameLabels",
    "signature": "com.google.javascript.jscomp.RenameLabels.RenameLabels(AbstractCompiler)",
    "snippet": "  RenameLabels(AbstractCompiler compiler) {\n    this(compiler, new DefaultNameSupplier(), true);\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "RenameLabels.RenameLabels",
    "class_name": "com.google.javascript.jscomp.RenameLabels",
    "signature": "com.google.javascript.jscomp.RenameLabels.RenameLabels(AbstractCompiler,Supplier,boolean)",
    "snippet": "  RenameLabels(\n      AbstractCompiler compiler,\n      Supplier<String> supplier,\n      boolean removeUnused) {\n    this.compiler = compiler;\n    this.nameSupplier = supplier;\n    this.removeUnused = removeUnused;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "RenameLabels.process",
    "class_name": "com.google.javascript.jscomp.RenameLabels",
    "signature": "com.google.javascript.jscomp.RenameLabels.process(Node,Node)",
    "snippet": "  @Override\n  public void process(Node externs, Node root) {\n    // Do variable reference counting.\n    NodeTraversal.traverse(compiler, root, new ProcessLabels());\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "ProcessLabels.enterScope",
    "class_name": "com.google.javascript.jscomp.RenameLabels$ProcessLabels",
    "signature": "com.google.javascript.jscomp.RenameLabels$ProcessLabels.enterScope(NodeTraversal)",
    "snippet": "    @Override\n    public void enterScope(NodeTraversal nodeTraversal) {\n      // Start a new namespace for label names.\n      namespaceStack.push(new LabelNamespace());\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "ProcessLabels.exitScope",
    "class_name": "com.google.javascript.jscomp.RenameLabels$ProcessLabels",
    "signature": "com.google.javascript.jscomp.RenameLabels$ProcessLabels.exitScope(NodeTraversal)",
    "snippet": "    @Override\n    public void exitScope(NodeTraversal nodeTraversal) {\n      namespaceStack.pop();\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "ProcessLabels.shouldTraverse",
    "class_name": "com.google.javascript.jscomp.RenameLabels$ProcessLabels",
    "signature": "com.google.javascript.jscomp.RenameLabels$ProcessLabels.shouldTraverse(NodeTraversal,Node,Node)",
    "snippet": "    public boolean shouldTraverse(NodeTraversal nodeTraversal, Node node,\n        Node parent) {\n      if (node.getType() == Token.LABEL) {\n        // Determine the new name for this label.\n        LabelNamespace current = namespaceStack.peek();\n        int currentDepth = current.renameMap.size() + 1;\n        String name = node.getFirstChild().getString();\n\n        // Store the context for this label name.\n        LabelInfo li = new LabelInfo(currentDepth);\n        Preconditions.checkState(!current.renameMap.containsKey(name));\n        current.renameMap.put(name, li);\n\n        // Create a new name, if needed, for this depth.\n        if (names.size() < currentDepth) {\n          names.add(nameSupplier.get());\n        }\n\n        String newName = getNameForId(currentDepth);\n        compiler.addToDebugLog(\"label renamed: \" + name + \" => \" + newName);\n      }\n\n      return true;\n    }",
    "comment": " shouldTraverse is call when descending into the Node tree, so it is used here to build the context for label renames.  {@inheritDoc} ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "ProcessLabels.visit",
    "class_name": "com.google.javascript.jscomp.RenameLabels$ProcessLabels",
    "signature": "com.google.javascript.jscomp.RenameLabels$ProcessLabels.visit(NodeTraversal,Node,Node)",
    "snippet": "    public void visit(NodeTraversal nodeTraversal, Node node, Node parent) {\n      switch (node.getType()) {\n        case Token.LABEL:\n          visitLabel(node, parent);\n          break;\n\n        case Token.BREAK:\n        case Token.CONTINUE:\n          visitBreakOrContinue(node);\n          break;\n      }\n    }",
    "comment": " Delegate the actual processing of the node to visitLabel and visitBreakOrContinue.  {@inheritDoc} ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "RenameVars.RenameVars",
    "class_name": "com.google.javascript.jscomp.RenameVars",
    "signature": "com.google.javascript.jscomp.RenameVars.RenameVars(AbstractCompiler,String,boolean,boolean,boolean,boolean,VariableMap,char[],Set)",
    "snippet": "  RenameVars(AbstractCompiler compiler, String prefix,\n      boolean localRenamingOnly, boolean preserveFunctionExpressionNames,\n      boolean generatePseudoNames, boolean shouldShadow,\n      VariableMap prevUsedRenameMap,\n      @Nullable char[] reservedCharacters,\n      @Nullable Set<String> reservedNames) {\n    this.compiler = compiler;\n    this.prefix = prefix == null ? \"\" : prefix;\n    this.localRenamingOnly = localRenamingOnly;\n    this.preserveFunctionExpressionNames = preserveFunctionExpressionNames;\n    if (generatePseudoNames) {\n      this.pseudoNameMap = Maps.newHashMap();\n    } else {\n      this.pseudoNameMap = null;\n    }\n    this.prevUsedRenameMap = prevUsedRenameMap;\n    this.reservedCharacters = reservedCharacters;\n    this.shouldShadow = shouldShadow;\n    if (reservedNames == null) {\n      this.reservedNames = Sets.newHashSet();\n    } else {\n      this.reservedNames = Sets.newHashSet(reservedNames);\n    }\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "RenameVars.assignNames",
    "class_name": "com.google.javascript.jscomp.RenameVars",
    "signature": "com.google.javascript.jscomp.RenameVars.assignNames(Set)",
    "snippet": "  private void assignNames(Set<Assignment> varsToRename) {\n    NameGenerator globalNameGenerator =\n        new NameGenerator(reservedNames, prefix, reservedCharacters);\n\n    // Local variables never need a prefix.\n    NameGenerator localNameGenerator =\n        prefix.isEmpty() ? globalNameGenerator : new NameGenerator(\n            reservedNames, \"\", reservedCharacters);\n\n    // Generated names and the assignments for non-local vars.\n    List<Assignment> pendingAssignments = new ArrayList<Assignment>();\n    List<String> generatedNamesForAssignments = new ArrayList<String>();\n\n    for (Assignment a : varsToRename) {\n      if (a.newName != null) {\n        continue;\n      }\n\n      if (externNames.contains(a.oldName)) {\n        continue;\n      }\n\n      String newName;\n      if (a.oldName.startsWith(LOCAL_VAR_PREFIX)) {\n        // For local variable, we make the assignment right away.\n        newName = localNameGenerator.generateNextName();\n        finalizeNameAssignment(a, newName);\n      } else {\n        // For non-local variable, delay finalizing the name assignment\n        // until we know how many new names we'll have of length 2, 3, etc.\n        newName = globalNameGenerator.generateNextName();\n        pendingAssignments.add(a);\n        generatedNamesForAssignments.add(newName);\n      }\n      reservedNames.add(newName);\n    }\n\n    // Now that we have a list of generated names, and a list of variable\n    // Assignment objects, we assign the generated names to the vars as\n    // follows:\n    // 1) The most frequent vars get the shorter names.\n    // 2) If N number of vars are going to be assigned names of the same\n    //    length, we assign the N names based on the order at which the vars\n    //    first appear in the source. This makes the output somewhat less\n    //    random, because symbols declared close together are assigned names\n    //    that are quite similar. With this heuristic, the output is more\n    //    compressible.\n    //    For instance, the output may look like:\n    //    var da = \"..\", ea = \"..\";\n    //    function fa() { .. } function ga() { .. }\n\n    int numPendingAssignments = generatedNamesForAssignments.size();\n    for (int i = 0; i < numPendingAssignments;) {\n      SortedSet<Assignment> varsByOrderOfOccurrence =\n          new TreeSet<Assignment>(ORDER_OF_OCCURRENCE_COMPARATOR);\n\n      // Add k number of Assignment to the set, where k is the number of\n      // generated names of the same length.\n      int len = generatedNamesForAssignments.get(i).length();\n      for (int j = i; j < numPendingAssignments\n          && generatedNamesForAssignments.get(j).length() == len; j++) {\n        varsByOrderOfOccurrence.add(pendingAssignments.get(j));\n      }\n\n      // Now, make the assignments\n      for (Assignment a : varsByOrderOfOccurrence) {\n        finalizeNameAssignment(a, generatedNamesForAssignments.get(i));\n        ++i;\n      }\n    }\n  }",
    "comment": " Determines which new names to substitute for the original names. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "RenameVars.getVariableMap",
    "class_name": "com.google.javascript.jscomp.RenameVars",
    "signature": "com.google.javascript.jscomp.RenameVars.getVariableMap()",
    "snippet": "  VariableMap getVariableMap() {\n    return new VariableMap(renameMap);\n  }",
    "comment": " Gets the variable map. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "RenameVars.okToRenameVar",
    "class_name": "com.google.javascript.jscomp.RenameVars",
    "signature": "com.google.javascript.jscomp.RenameVars.okToRenameVar(String,boolean)",
    "snippet": "  private boolean okToRenameVar(String name, boolean isLocal) {\n    return !compiler.getCodingConvention().isExported(name, isLocal);\n  }",
    "comment": " Determines whether a variable name is okay to rename. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "RenameVars.process",
    "class_name": "com.google.javascript.jscomp.RenameVars",
    "signature": "com.google.javascript.jscomp.RenameVars.process(Node,Node)",
    "snippet": "  @Override\n  public void process(Node externs, Node root) {\n    assignmentLog = new StringBuilder();\n\n    // Do variable reference counting.\n    NodeTraversal.traverse(compiler, externs, new ProcessVars(true));\n    NodeTraversal.traverse(compiler, root, new ProcessVars(false));\n\n    // Make sure that new names don't overlap with extern names.\n    reservedNames.addAll(externNames);\n\n    // Rename vars, sorted by frequency of occurrence to minimize code size.\n    SortedSet<Assignment> varsByFrequency =\n        new TreeSet<Assignment>(FREQUENCY_COMPARATOR);\n    varsByFrequency.addAll(assignments.values());\n\n    if (shouldShadow) {\n      new ShadowVariables(\n          compiler, assignments, varsByFrequency, pseudoNameMap).process(\n              externs, root);\n    }\n\n    // First try to reuse names from an earlier compilation.\n    if (prevUsedRenameMap != null) {\n      reusePreviouslyUsedVariableMap();\n    }\n\n    // Assign names, sorted by descending frequency to minimize code size.\n    assignNames(varsByFrequency);\n\n    boolean changed = false;\n\n    // Rename the globals!\n    for (Node n : globalNameNodes) {\n      String newName = getNewGlobalName(n);\n      // Note: if newName is null, then oldName is an extern.\n      if (newName != null) {\n        n.setString(newName);\n        changed = true;\n      }\n    }\n\n    // Rename the locals!\n    int count = 0;\n    for (Node n : localNameNodes) {\n      String newName = getNewLocalName(n);\n      if (newName != null) {\n        n.setString(newName);\n        changed = true;\n      }\n      count++;\n    }\n\n    if (changed) {\n      compiler.reportCodeChange();\n    }\n\n    // Lastly, write the name assignments to the debug log.\n    compiler.addToDebugLog(\"JS var assignments:\\n\" + assignmentLog);\n    assignmentLog = null;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "ProcessVars.enterScope",
    "class_name": "com.google.javascript.jscomp.RenameVars$ProcessVars",
    "signature": "com.google.javascript.jscomp.RenameVars$ProcessVars.enterScope(NodeTraversal)",
    "snippet": "    @Override\n    public void enterScope(NodeTraversal t) {\n      if (t.inGlobalScope()) return;\n\n      Iterator<Var> it = t.getScope().getVars();\n      while (it.hasNext()) {\n        Var current = it.next();\n        if (current.isBleedingFunction()) {\n          localBleedingFunctions.add(current);\n          localBleedingFunctionsPerScope.put(\n              t.getScope().getParent(), current);\n        }\n      }\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "ProcessVars.exitScope",
    "class_name": "com.google.javascript.jscomp.RenameVars$ProcessVars",
    "signature": "com.google.javascript.jscomp.RenameVars$ProcessVars.exitScope(NodeTraversal)",
    "snippet": "    @Override\n    public void exitScope(NodeTraversal t) {}",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "ProcessVars.visit",
    "class_name": "com.google.javascript.jscomp.RenameVars$ProcessVars",
    "signature": "com.google.javascript.jscomp.RenameVars$ProcessVars.visit(NodeTraversal,Node,Node)",
    "snippet": "    @Override\n    public void visit(NodeTraversal t, Node n, Node parent) {\n      if (n.getType() != Token.NAME) {\n        return;\n      }\n\n      String name = n.getString();\n\n      // Ignore anonymous functions\n      if (name.length() == 0) {\n        return;\n      }\n\n      // Is this local or Global?\n      // Bleeding functions should be treated as part of their outer\n      // scope, because IE has bugs in how it handles bleeding\n      // functions.\n      Scope.Var var = t.getScope().getVar(name);\n      boolean local = (var != null) && var.isLocal() &&\n          (!var.scope.getParent().isGlobal() ||\n           !var.isBleedingFunction());\n\n      // Are we renaming global variables?\n      if (!local && localRenamingOnly) {\n        reservedNames.add(name);\n        return;\n      }\n\n      // Are we renaming function expression names?\n      if (preserveFunctionExpressionNames && var != null\n          && NodeUtil.isFunctionExpression(var.getParentNode())) {\n        reservedNames.add(name);\n        return;\n      }\n\n      // Check if we can rename this.\n      if (!okToRenameVar(name, local)) {\n        if (local) {\n          // Blindly de-uniquify for the Prototype library for issue 103.\n          String newName = MakeDeclaredNamesUnique.ContextualRenameInverter\n              .getOrginalName(name);\n          if (!newName.equals(name)) {\n            n.setString(newName);\n          }\n        }\n        return;\n      }\n\n      if (isExternsPass_) {\n        // Keep track of extern globals.\n        if (!local) {\n          externNames.add(name);\n        }\n        return;\n      }\n\n      if (pseudoNameMap != null) {\n        recordPseudoName(n);\n      }\n\n      if (local) {\n        // Local var: assign a new name\n        String tempName = LOCAL_VAR_PREFIX + getLocalVarIndex(var);\n        incCount(tempName);\n        localNameNodes.add(n);\n        n.setString(tempName);\n      } else if (var != null) { // Not an extern\n        // If it's global, increment global count\n        incCount(name);\n        globalNameNodes.add(n);\n      }\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "ReplaceCssNames.ReplaceCssNames",
    "class_name": "com.google.javascript.jscomp.ReplaceCssNames",
    "signature": "com.google.javascript.jscomp.ReplaceCssNames.ReplaceCssNames(AbstractCompiler,Map)",
    "snippet": "  ReplaceCssNames(AbstractCompiler compiler,\n      @Nullable Map<String, Integer> cssNames) {\n    this.compiler = compiler;\n    this.cssNames = cssNames;\n    this.nativeStringType =  compiler.getTypeRegistry()\n        .getNativeType(STRING_TYPE);\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "ReplaceCssNames.getCssRenamingMap",
    "class_name": "com.google.javascript.jscomp.ReplaceCssNames",
    "signature": "com.google.javascript.jscomp.ReplaceCssNames.getCssRenamingMap()",
    "snippet": "  @VisibleForTesting\n  protected CssRenamingMap getCssRenamingMap() {\n    return compiler.getCssRenamingMap();\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "ReplaceCssNames.process",
    "class_name": "com.google.javascript.jscomp.ReplaceCssNames",
    "signature": "com.google.javascript.jscomp.ReplaceCssNames.process(Node,Node)",
    "snippet": "  @Override\n  public void process(Node externs, Node root) {\n    // The CssRenamingMap may not have been available from the compiler when\n    // this ReplaceCssNames pass was constructed, so getCssRenamingMap() should\n    // only be called before this pass is actually run.\n    symbolMap = getCssRenamingMap();\n\n    NodeTraversal.traverse(compiler, root, new Traversal());\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "Traversal.visit",
    "class_name": "com.google.javascript.jscomp.ReplaceCssNames$Traversal",
    "signature": "com.google.javascript.jscomp.ReplaceCssNames$Traversal.visit(NodeTraversal,Node,Node)",
    "snippet": "    @Override\n    public void visit(NodeTraversal t, Node n, Node parent) {\n      if (n.getType() == Token.CALL &&\n          GET_CSS_NAME_FUNCTION.equals(n.getFirstChild().getQualifiedName())) {\n        int count = n.getChildCount();\n        Node first = n.getFirstChild().getNext();\n        switch (count) {\n          case 2:\n            // Replace the function call with the processed argument.\n            if (first.getType() == Token.STRING) {\n              processStringNode(t, first);\n              n.removeChild(first);\n              parent.replaceChild(n, first);\n              compiler.reportCodeChange();\n            } else {\n              compiler.report(t.makeError(n, STRING_LITERAL_EXPECTED_ERROR,\n                  Token.name(first.getType())));\n            }\n            break;\n\n          case 3:\n            // Replace function call with concatenation of two args.  It's\n            // assumed the first arg has already been processed.\n\n            Node second = first.getNext();\n\n            if (first.getType() == Token.STRING) {\n              compiler.report(t.makeError(\n                  n, UNEXPECTED_STRING_LITERAL_ERROR,\n                  first.getString(), second.getString()));\n\n            } else if (second.getType() == Token.STRING) {\n              processStringNode(t, second);\n              n.removeChild(first);\n              Node replacement = new Node(Token.ADD, first,\n                  Node.newString(\"-\" + second.getString())\n                      .copyInformationFrom(second))\n                  .copyInformationFrom(n);\n              replacement.setJSType(nativeStringType);\n              parent.replaceChild(n, replacement);\n              compiler.reportCodeChange();\n\n            } else {\n              compiler.report(t.makeError(n, STRING_LITERAL_EXPECTED_ERROR,\n                  Token.name(second.getType())));\n            }\n            break;\n\n          default:\n            compiler.report(t.makeError(\n                n, INVALID_NUM_ARGUMENTS_ERROR, String.valueOf(count)));\n        }\n      }\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "Result.Result",
    "class_name": "com.google.javascript.jscomp.Result",
    "signature": "com.google.javascript.jscomp.Result.Result(JSError[],JSError[],String,VariableMap,VariableMap,VariableMap,VariableMap,FunctionInformationMap,SourceMap,String,Map,String)",
    "snippet": "  Result(JSError[] errors, JSError[] warnings, String debugLog,\n         VariableMap variableMap, VariableMap propertyMap,\n         VariableMap namedAnonFunctionMap,\n         VariableMap stringMap,\n         FunctionInformationMap functionInformationMap,\n         SourceMap sourceMap, String externExport,\n         Map<String, Integer> cssNames, String idGeneratorMap) {\n    this.success = errors.length == 0;\n    this.errors = errors;\n    this.warnings = warnings;\n    this.debugLog = debugLog;\n    this.variableMap = variableMap;\n    this.propertyMap = propertyMap;\n    this.namedAnonFunctionMap = namedAnonFunctionMap;\n    this.stringMap = stringMap;\n    this.functionInformationMap = functionInformationMap;\n    this.sourceMap = sourceMap;\n    this.externExport = externExport;\n    this.cssNames = cssNames;\n    this.idGeneratorMap = idGeneratorMap;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "RhinoErrorReporter.forNewRhino",
    "class_name": "com.google.javascript.jscomp.RhinoErrorReporter",
    "signature": "com.google.javascript.jscomp.RhinoErrorReporter.forNewRhino(AbstractCompiler)",
    "snippet": "  public static com.google.javascript.jscomp.mozilla.rhino.ErrorReporter\n      forNewRhino(AbstractCompiler compiler) {\n    return new NewRhinoErrorReporter(compiler);\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "RhinoErrorReporter.forOldRhino",
    "class_name": "com.google.javascript.jscomp.RhinoErrorReporter",
    "signature": "com.google.javascript.jscomp.RhinoErrorReporter.forOldRhino(AbstractCompiler)",
    "snippet": "  public static ErrorReporter forOldRhino(AbstractCompiler compiler) {\n    return new OldRhinoErrorReporter(compiler);\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "RhinoErrorReporter.replacePlaceHolders",
    "class_name": "com.google.javascript.jscomp.RhinoErrorReporter",
    "signature": "com.google.javascript.jscomp.RhinoErrorReporter.replacePlaceHolders(String)",
    "snippet": "  private Pattern replacePlaceHolders(String s) {\n    s = Pattern.quote(s);\n    return Pattern.compile(s.replaceAll(\"\\\\{\\\\d+\\\\}\", \"\\\\\\\\E.*\\\\\\\\Q\"));\n  }",
    "comment": " For each message such as \"Not a good use of {0}\", replace the place holder {0} with a wild card that matches all possible strings. Also put the any non-place-holder in quotes for regex matching later. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "Scope.Scope",
    "class_name": "com.google.javascript.jscomp.Scope",
    "signature": "com.google.javascript.jscomp.Scope.Scope(Node,AbstractCompiler)",
    "snippet": "  Scope(Node rootNode, AbstractCompiler compiler) {\n    this.parent = null;\n    this.rootNode = rootNode;\n    thisType = compiler.getTypeRegistry().getNativeObjectType(GLOBAL_THIS);\n    this.isBottom = false;\n    this.depth = 0;\n  }",
    "comment": " Creates a global Scope. @param rootNode  Typically the global BLOCK node. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "Scope.Scope",
    "class_name": "com.google.javascript.jscomp.Scope",
    "signature": "com.google.javascript.jscomp.Scope.Scope(Node,ObjectType)",
    "snippet": "  Scope(Node rootNode, ObjectType thisType) {\n    this.parent = null;\n    this.rootNode = rootNode;\n    this.thisType = thisType;\n    this.isBottom = true;\n    this.depth = 0;\n  }",
    "comment": " Creates a empty Scope (bottom of the lattice). @param rootNode Typically a FUNCTION node or the global BLOCK node. @param thisType the type of {@code this} in this scope ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "Scope.Scope",
    "class_name": "com.google.javascript.jscomp.Scope",
    "signature": "com.google.javascript.jscomp.Scope.Scope(Scope,Node)",
    "snippet": "  Scope(Scope parent, Node rootNode) {\n    Preconditions.checkNotNull(parent);\n    Preconditions.checkArgument(rootNode != parent.rootNode);\n\n    this.parent = parent;\n    this.rootNode = rootNode;\n    JSType nodeType = rootNode.getJSType();\n    if (nodeType != null && nodeType instanceof FunctionType) {\n      thisType = ((FunctionType) nodeType).getTypeOfThis();\n    } else {\n      thisType = parent.thisType;\n    }\n    this.isBottom = false;\n    this.depth = parent.depth + 1;\n  }",
    "comment": " Creates a Scope given the parent Scope and the root node of the scope. @param parent  The parent Scope. Cannot be null. @param rootNode  Typically the FUNCTION node. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "Scope.declare",
    "class_name": "com.google.javascript.jscomp.Scope",
    "signature": "com.google.javascript.jscomp.Scope.declare(String,Node,JSType,CompilerInput)",
    "snippet": "  Var declare(String name, Node nameNode, JSType type, CompilerInput input) {\n    return declare(name, nameNode, type, input, true);\n  }",
    "comment": " Declares a variable whose type is inferred.  @param name name of the variable @param nameNode the NAME node declaring the variable @param type the variable's type @param input the input in which this variable is defined. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "Scope.declare",
    "class_name": "com.google.javascript.jscomp.Scope",
    "signature": "com.google.javascript.jscomp.Scope.declare(String,Node,JSType,CompilerInput,boolean)",
    "snippet": "  Var declare(String name, Node nameNode,\n      JSType type, CompilerInput input, boolean inferred) {\n    Preconditions.checkState(name != null && name.length() > 0);\n\n    // Make sure that it's declared only once\n    Preconditions.checkState(vars.get(name) == null);\n\n    // native variables do not have a name node.\n    // TODO(user): make Var abstract and have NativeVar, NormalVar.\n    JSDocInfo info = NodeUtil.getInfoForNameNode(nameNode);\n\n    Var var = new Var(inferred, name, nameNode, type, this, vars.size(), input,\n        info != null && info.isDefine(), info);\n\n    vars.put(name, var);\n    return var;\n  }",
    "comment": " Declares a variable.  @param name name of the variable @param nameNode the NAME node declaring the variable @param type the variable's type @param input the input in which this variable is defined. @param inferred Whether this variable's type is inferred (as opposed to declared). ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "Scope.getArgumentsVar",
    "class_name": "com.google.javascript.jscomp.Scope",
    "signature": "com.google.javascript.jscomp.Scope.getArgumentsVar()",
    "snippet": "  public Var getArgumentsVar() {\n    if (arguments == null) {\n      arguments = new Arguments(this);\n    }\n    return arguments;\n  }",
    "comment": " Get a unique VAR object to represents \"arguments\" within this scope ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "Scope.getDeclarativelyUnboundVarsWithoutTypes",
    "class_name": "com.google.javascript.jscomp.Scope",
    "signature": "com.google.javascript.jscomp.Scope.getDeclarativelyUnboundVarsWithoutTypes()",
    "snippet": "  public Iterator<Var> getDeclarativelyUnboundVarsWithoutTypes() {\n    return Iterators.filter(\n        getVars(), DECLARATIVELY_UNBOUND_VARS_WITHOUT_TYPES);\n  }",
    "comment": " Gets all variables declared with \"var\" but without declared types attached. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "Scope.getParent",
    "class_name": "com.google.javascript.jscomp.Scope",
    "signature": "com.google.javascript.jscomp.Scope.getParent()",
    "snippet": "  public Scope getParent() {\n    return parent;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "Scope.getParentScope",
    "class_name": "com.google.javascript.jscomp.Scope",
    "signature": "com.google.javascript.jscomp.Scope.getParentScope()",
    "snippet": "  @Override\n  public StaticScope<JSType> getParentScope() {\n    return parent;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "Scope.getRootNode",
    "class_name": "com.google.javascript.jscomp.Scope",
    "signature": "com.google.javascript.jscomp.Scope.getRootNode()",
    "snippet": "  @Override\n  public Node getRootNode() {\n    return rootNode;\n  }",
    "comment": " Gets the container node of the scope. This is typically the FUNCTION node or the global BLOCK/SCRIPT node. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "Scope.getSlot",
    "class_name": "com.google.javascript.jscomp.Scope",
    "signature": "com.google.javascript.jscomp.Scope.getSlot(String)",
    "snippet": "  public StaticSlot<JSType> getSlot(String name) {\n    return getVar(name);\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "Scope.getTypeOfThis",
    "class_name": "com.google.javascript.jscomp.Scope",
    "signature": "com.google.javascript.jscomp.Scope.getTypeOfThis()",
    "snippet": "  public ObjectType getTypeOfThis() {\n    return thisType;\n  }",
    "comment": " Gets the type of {@code this} in the current scope. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "Scope.getVar",
    "class_name": "com.google.javascript.jscomp.Scope",
    "signature": "com.google.javascript.jscomp.Scope.getVar(String)",
    "snippet": "  public Var getVar(String name) {\n    Var var = vars.get(name);\n    if (var != null) {\n      return var;\n    } else if (parent != null) { // Recurse up the parent Scope\n      return parent.getVar(name);\n    } else {\n      return null;\n    }\n  }",
    "comment": " Returns the variable, may be null ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "Scope.getVarCount",
    "class_name": "com.google.javascript.jscomp.Scope",
    "signature": "com.google.javascript.jscomp.Scope.getVarCount()",
    "snippet": "  public int getVarCount() {\n    return vars.size();\n  }",
    "comment": " Returns number of variables in this scope ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "Scope.getVars",
    "class_name": "com.google.javascript.jscomp.Scope",
    "signature": "com.google.javascript.jscomp.Scope.getVars()",
    "snippet": "  public Iterator<Var> getVars() {\n    return vars.values().iterator();\n  }",
    "comment": " Return an iterator over all of the variables declared in this scope. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "Scope.isBottom",
    "class_name": "com.google.javascript.jscomp.Scope",
    "signature": "com.google.javascript.jscomp.Scope.isBottom()",
    "snippet": "  boolean isBottom() {\n    return isBottom;\n  }",
    "comment": "Whether this is the bottom of the lattice. */",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "Scope.isDeclared",
    "class_name": "com.google.javascript.jscomp.Scope",
    "signature": "com.google.javascript.jscomp.Scope.isDeclared(String,boolean)",
    "snippet": "  public boolean isDeclared(String name, boolean recurse) {\n    Scope scope = this;\n    if (scope.vars.containsKey(name))\n      return true;\n\n    if (scope.parent != null && recurse) {\n      return scope.parent.isDeclared(name, recurse);\n    }\n    return false;\n  }",
    "comment": " Returns true if a variable is declared. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "Scope.isGlobal",
    "class_name": "com.google.javascript.jscomp.Scope",
    "signature": "com.google.javascript.jscomp.Scope.isGlobal()",
    "snippet": "  public boolean isGlobal() {\n    return parent == null;\n  }",
    "comment": " Returns whether this is the global scope. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "Scope.isLocal",
    "class_name": "com.google.javascript.jscomp.Scope",
    "signature": "com.google.javascript.jscomp.Scope.isLocal()",
    "snippet": "  public boolean isLocal() {\n    return !isGlobal();\n  }",
    "comment": " Returns whether this is a local scope (i.e. not the global scope). ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "Arguments.hashCode",
    "class_name": "com.google.javascript.jscomp.Scope$Arguments",
    "signature": "com.google.javascript.jscomp.Scope$Arguments.hashCode()",
    "snippet": "    @Override public int hashCode() {\n      return System.identityHashCode(this);\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "Var.getInitialValue",
    "class_name": "com.google.javascript.jscomp.Scope$Var",
    "signature": "com.google.javascript.jscomp.Scope$Var.getInitialValue()",
    "snippet": "    public Node getInitialValue() {\n      Node parent = getParentNode();\n      int pType = parent.getType();\n      if (pType == Token.FUNCTION) {\n        return parent;\n      } else if (pType == Token.ASSIGN) {\n        return parent.getLastChild();\n      } else if (pType == Token.VAR) {\n        return nameNode.getFirstChild();\n      } else {\n        return null;\n      }\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "Var.getJSDocInfo",
    "class_name": "com.google.javascript.jscomp.Scope$Var",
    "signature": "com.google.javascript.jscomp.Scope$Var.getJSDocInfo()",
    "snippet": "    public JSDocInfo getJSDocInfo() {\n      return info;\n    }",
    "comment": " Gets the JSDocInfo for the variable. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "Var.getName",
    "class_name": "com.google.javascript.jscomp.Scope$Var",
    "signature": "com.google.javascript.jscomp.Scope$Var.getName()",
    "snippet": "    public String getName() {\n      return name;\n    }",
    "comment": " Gets the name of the variable. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "Var.getNameNode",
    "class_name": "com.google.javascript.jscomp.Scope$Var",
    "signature": "com.google.javascript.jscomp.Scope$Var.getNameNode()",
    "snippet": "    public Node getNameNode() {\n      return nameNode;\n    }",
    "comment": " Returns the name node that produced this variable. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "Var.getParentNode",
    "class_name": "com.google.javascript.jscomp.Scope$Var",
    "signature": "com.google.javascript.jscomp.Scope$Var.getParentNode()",
    "snippet": "    public Node getParentNode() {\n      return nameNode == null ? null : nameNode.getParent();\n    }",
    "comment": " Gets the parent of the name node. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "Var.getType",
    "class_name": "com.google.javascript.jscomp.Scope$Var",
    "signature": "com.google.javascript.jscomp.Scope$Var.getType()",
    "snippet": "    public JSType getType() {\n      return type;\n    }",
    "comment": " Gets this variable's type. To know whether this type has been inferred, see {@code #isTypeInferred()}. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "Var.hashCode",
    "class_name": "com.google.javascript.jscomp.Scope$Var",
    "signature": "com.google.javascript.jscomp.Scope$Var.hashCode()",
    "snippet": "    @Override public int hashCode() {\n      return nameNode.hashCode();\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "Var.isBleedingFunction",
    "class_name": "com.google.javascript.jscomp.Scope$Var",
    "signature": "com.google.javascript.jscomp.Scope$Var.isBleedingFunction()",
    "snippet": "    public boolean isBleedingFunction() {\n      return NodeUtil.isFunctionExpression(getParentNode());\n    }",
    "comment": " Whether this is a bleeding function (an anonymous named function that bleeds into the inner scope. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "Var.isExtern",
    "class_name": "com.google.javascript.jscomp.Scope$Var",
    "signature": "com.google.javascript.jscomp.Scope$Var.isExtern()",
    "snippet": "    boolean isExtern() {\n      return input == null || input.isExtern();\n    }",
    "comment": " Returns whether this is defined in an extern file. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "Var.isGlobal",
    "class_name": "com.google.javascript.jscomp.Scope$Var",
    "signature": "com.google.javascript.jscomp.Scope$Var.isGlobal()",
    "snippet": "    public boolean isGlobal() {\n      return scope.isGlobal();\n    }",
    "comment": " Returns whether this is a global variable. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "Var.isLocal",
    "class_name": "com.google.javascript.jscomp.Scope$Var",
    "signature": "com.google.javascript.jscomp.Scope$Var.isLocal()",
    "snippet": "    public boolean isLocal() {\n      return scope.isLocal();\n    }",
    "comment": " Returns whether this is a local variable. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "Var.isTypeInferred",
    "class_name": "com.google.javascript.jscomp.Scope$Var",
    "signature": "com.google.javascript.jscomp.Scope$Var.isTypeInferred()",
    "snippet": "    public boolean isTypeInferred() {\n      return typeInferred;\n    }",
    "comment": " Returns whether this variable's type is inferred. To get the variable's type, see {@link #getType()}. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "Var.resolveType",
    "class_name": "com.google.javascript.jscomp.Scope$Var",
    "signature": "com.google.javascript.jscomp.Scope$Var.resolveType(ErrorReporter)",
    "snippet": "    void resolveType(ErrorReporter errorReporter) {\n      if (type != null) {\n        type = type.resolve(errorReporter, scope);\n      }\n    }",
    "comment": " Resolve this variable's type. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "ScopedAliases.ScopedAliases",
    "class_name": "com.google.javascript.jscomp.ScopedAliases",
    "signature": "com.google.javascript.jscomp.ScopedAliases.ScopedAliases(AbstractCompiler,AliasTransformationHandler)",
    "snippet": "  ScopedAliases(AbstractCompiler compiler,\n      AliasTransformationHandler transformationHandler) {\n    this.compiler = compiler;\n    this.transformationHandler = transformationHandler;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "ScopedAliases.hotSwapScript",
    "class_name": "com.google.javascript.jscomp.ScopedAliases",
    "signature": "com.google.javascript.jscomp.ScopedAliases.hotSwapScript(Node)",
    "snippet": "  @Override\n  public void hotSwapScript(Node root) {\n    Traversal traversal = new Traversal();\n    NodeTraversal.traverse(compiler, root, traversal);\n\n    if (!traversal.hasErrors()) {\n\n      // Apply the aliases.\n      for (AliasUsage aliasUsage : traversal.getAliasUsages()) {\n        aliasUsage.applyAlias();\n      }\n\n      // Remove the alias definitions.\n      for (Node aliasDefinition : traversal.getAliasDefinitions()) {\n        if (aliasDefinition.getParent().getType() == Token.VAR &&\n            aliasDefinition.getParent().hasOneChild()) {\n          aliasDefinition.getParent().detachFromParent();\n        } else {\n          aliasDefinition.detachFromParent();\n        }\n      }\n\n      // Collapse the scopes.\n      for (Node scopeCall : traversal.getScopeCalls()) {\n        Node expressionWithScopeCall = scopeCall.getParent();\n        Node scopeClosureBlock = scopeCall.getLastChild().getLastChild();\n        scopeClosureBlock.detachFromParent();\n        expressionWithScopeCall.getParent().replaceChild(\n            expressionWithScopeCall,\n            scopeClosureBlock);\n        NodeUtil.tryMergeBlock(scopeClosureBlock);\n      }\n\n      if (traversal.getAliasUsages().size() > 0 ||\n          traversal.getAliasDefinitions().size() > 0 ||\n          traversal.getScopeCalls().size() > 0) {\n        compiler.reportCodeChange();\n      }\n    }\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "ScopedAliases.process",
    "class_name": "com.google.javascript.jscomp.ScopedAliases",
    "signature": "com.google.javascript.jscomp.ScopedAliases.process(Node,Node)",
    "snippet": "  @Override\n  public void process(Node externs, Node root) {\n    hotSwapScript(root);\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "Traversal.enterScope",
    "class_name": "com.google.javascript.jscomp.ScopedAliases$Traversal",
    "signature": "com.google.javascript.jscomp.ScopedAliases$Traversal.enterScope(NodeTraversal)",
    "snippet": "    @Override\n    public void enterScope(NodeTraversal t) {\n      Node n = t.getCurrentNode().getParent();\n      if (n != null && isCallToScopeMethod(n)) {\n        transformation = transformationHandler.logAliasTransformation(\n            n.getSourceFileName(), getSourceRegion(n));\n      }\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "Traversal.exitScope",
    "class_name": "com.google.javascript.jscomp.ScopedAliases$Traversal",
    "signature": "com.google.javascript.jscomp.ScopedAliases$Traversal.exitScope(NodeTraversal)",
    "snippet": "    @Override\n    public void exitScope(NodeTraversal t) {\n      if (t.getScopeDepth() == 2) {\n        aliases.clear();\n        transformation = null;\n      }\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "Traversal.getAliasDefinitions",
    "class_name": "com.google.javascript.jscomp.ScopedAliases$Traversal",
    "signature": "com.google.javascript.jscomp.ScopedAliases$Traversal.getAliasDefinitions()",
    "snippet": "    List<Node> getAliasDefinitions() {\n      return aliasDefinitions;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "Traversal.getAliasUsages",
    "class_name": "com.google.javascript.jscomp.ScopedAliases$Traversal",
    "signature": "com.google.javascript.jscomp.ScopedAliases$Traversal.getAliasUsages()",
    "snippet": "    private List<AliasUsage> getAliasUsages() {\n      return aliasUsages;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "Traversal.getScopeCalls",
    "class_name": "com.google.javascript.jscomp.ScopedAliases$Traversal",
    "signature": "com.google.javascript.jscomp.ScopedAliases$Traversal.getScopeCalls()",
    "snippet": "    List<Node> getScopeCalls() {\n      return scopeCalls;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "Traversal.hasErrors",
    "class_name": "com.google.javascript.jscomp.ScopedAliases$Traversal",
    "signature": "com.google.javascript.jscomp.ScopedAliases$Traversal.hasErrors()",
    "snippet": "    boolean hasErrors() {\n      return hasErrors;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "Traversal.isCallToScopeMethod",
    "class_name": "com.google.javascript.jscomp.ScopedAliases$Traversal",
    "signature": "com.google.javascript.jscomp.ScopedAliases$Traversal.isCallToScopeMethod(Node)",
    "snippet": "    private boolean isCallToScopeMethod(Node n) {\n      return n.getType() == Token.CALL &&\n          SCOPING_METHOD_NAME.equals(n.getFirstChild().getQualifiedName());\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "Traversal.shouldTraverse",
    "class_name": "com.google.javascript.jscomp.ScopedAliases$Traversal",
    "signature": "com.google.javascript.jscomp.ScopedAliases$Traversal.shouldTraverse(NodeTraversal,Node,Node)",
    "snippet": "    @Override\n    public final boolean shouldTraverse(NodeTraversal t, Node n, Node parent) {\n      if (n.getType() == Token.FUNCTION && t.inGlobalScope()) {\n        // Do not traverse in to functions except for goog.scope functions.\n        if (parent == null || !isCallToScopeMethod(parent)) {\n          return false;\n        }\n      }\n      return true;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "Traversal.visit",
    "class_name": "com.google.javascript.jscomp.ScopedAliases$Traversal",
    "signature": "com.google.javascript.jscomp.ScopedAliases$Traversal.visit(NodeTraversal,Node,Node)",
    "snippet": "    @Override\n    public void visit(NodeTraversal t, Node n, Node parent) {\n      if (isCallToScopeMethod(n)) {\n        if (!NodeUtil.isExpressionNode(parent)) {\n          report(t, n, GOOG_SCOPE_USED_IMPROPERLY);\n        }\n        if (n.getChildCount() != 2) {\n          // The goog.scope call should have exactly 1 parameter.  The first\n          // child is the \"goog.scope\" and the second should be the parameter.\n          report(t, n, GOOG_SCOPE_HAS_BAD_PARAMETERS);\n        } else {\n          Node anonymousFnNode = n.getChildAtIndex(1);\n          if (!NodeUtil.isFunction(anonymousFnNode) ||\n              NodeUtil.getFunctionName(anonymousFnNode) != null ||\n              NodeUtil.getFunctionParameters(anonymousFnNode).hasChildren()) {\n            report(t, anonymousFnNode, GOOG_SCOPE_HAS_BAD_PARAMETERS);\n          } else {\n            scopeCalls.add(n);\n          }\n        }\n      }\n\n\n      if (t.getScopeDepth() == 2) {\n        int type = n.getType();\n        if (type == Token.NAME && parent.getType() == Token.VAR) {\n          if (n.hasChildren() && n.getFirstChild().isQualifiedName()) {\n            String name = n.getString();\n            Var aliasVar = t.getScope().getVar(name);\n            aliases.put(name, aliasVar);\n            aliasDefinitions.add(n);\n            String qualifiedName =\n                aliasVar.getInitialValue().getQualifiedName();\n            transformation.addAlias(name, qualifiedName);\n            return;\n          } else {\n            // TODO(robbyw): Support using locals for private variables.\n            report(t, n, GOOG_SCOPE_NON_ALIAS_LOCAL, n.getString());\n          }\n        }\n\n        if (type == Token.NAME && NodeUtil.isAssignmentOp(parent) &&\n            n == parent.getFirstChild()) {\n          report(t, n, GOOG_SCOPE_ALIAS_REDEFINED, n.getString());\n        }\n\n        if (type == Token.RETURN) {\n          report(t, n, GOOG_SCOPE_USES_RETURN);\n        } else if (type == Token.THIS) {\n          report(t, n, GOOG_SCOPE_REFERENCES_THIS);\n        } else if (type == Token.THROW) {\n          report(t, n, GOOG_SCOPE_USES_THROW);\n        }\n      }\n\n      if (t.getScopeDepth() >= 2) {\n        if (n.getType() == Token.NAME) {\n          String name = n.getString();\n          Var aliasVar = aliases.get(name);\n\n          // Check if this name points to an alias.\n          if (aliasVar != null &&\n              t.getScope().getVar(name) == aliasVar) {\n            // Note, to support the transitive case, it's important we don't\n            // clone aliasedNode here.  For example,\n            // var g = goog; var d = g.dom; d.createElement('DIV');\n            // The node in aliasedNode (which is \"g\") will be replaced in the\n            // changes pass above with \"goog\".  If we cloned here, we'd end up\n            // with <code>g.dom.createElement('DIV')</code>.\n            Node aliasedNode = aliasVar.getInitialValue();\n            aliasUsages.add(new AliasedNode(n, aliasedNode));\n          }\n        }\n\n        JSDocInfo info = n.getJSDocInfo();\n        if (info != null) {\n          for (Node node : info.getTypeNodes()) {\n            fixTypeNode(node);\n          }\n        }\n\n        // TODO(robbyw): Error for goog.scope not at root.\n      }\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "SemanticReverseAbstractInterpreter.SemanticReverseAbstractInterpreter",
    "class_name": "com.google.javascript.jscomp.SemanticReverseAbstractInterpreter",
    "signature": "com.google.javascript.jscomp.SemanticReverseAbstractInterpreter.SemanticReverseAbstractInterpreter(CodingConvention,JSTypeRegistry)",
    "snippet": "  SemanticReverseAbstractInterpreter(CodingConvention convention,\n      JSTypeRegistry typeRegistry) {\n    super(convention, typeRegistry);\n  }",
    "comment": " Creates a semantic reverse abstract interpreter. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "ShadowVariables.ShadowVariables",
    "class_name": "com.google.javascript.jscomp.ShadowVariables",
    "signature": "com.google.javascript.jscomp.ShadowVariables.ShadowVariables(AbstractCompiler,SortedMap,SortedSet,Map)",
    "snippet": "  ShadowVariables(\n      AbstractCompiler compiler,\n      SortedMap<String, Assignment> assignments,\n      SortedSet<Assignment> varsByFrequency,\n      Map<Node, String> pseudoNameMap) {\n    this.compiler = compiler;\n    this.assignments = assignments;\n    this.varsByFrequency = varsByFrequency;\n    this.oldPseudoNameMap = pseudoNameMap;\n    this.deltaPseudoNameMap = Maps.newLinkedHashMap();\n  }",
    "comment": " @param assignments Map of old variable names to its assignment Objects. @param varsByFrequency Sorted variable assignments by Frequency. @param pseudoNameMap The current psedo name map so this pass can update it accordingly. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "ShadowVariables.process",
    "class_name": "com.google.javascript.jscomp.ShadowVariables",
    "signature": "com.google.javascript.jscomp.ShadowVariables.process(Node,Node)",
    "snippet": "  @Override\n  public void process(Node externs, Node root) {\n\n    // The algorithm is divided into two stages:\n    //\n    // 1. Information gathering (variable usage, upward referencing)\n    //\n    // 2. Tries to find shadows for each variables, updates the\n    //    variable usage frequency map.\n    //\n    // 3. Updates the pseudo naming map if needed.\n    NodeTraversal.traverse(compiler, root, new GatherReferenceInfo());\n    NodeTraversal.traverse(compiler, root, new DoShadowVariables());\n\n    if (oldPseudoNameMap != null) {\n      oldPseudoNameMap.putAll(deltaPseudoNameMap);\n    }\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "DoShadowVariables.enterScope",
    "class_name": "com.google.javascript.jscomp.ShadowVariables$DoShadowVariables",
    "signature": "com.google.javascript.jscomp.ShadowVariables$DoShadowVariables.enterScope(NodeTraversal)",
    "snippet": "    @Override\n    public void enterScope(NodeTraversal t) {\n      Scope s = t.getScope();\n      if (!s.isLocal()) {\n        return;\n      }\n\n      // Since we don't shadow global, there is nothing to be done in the\n      // first immediate local scope as well.\n      if (s.getParent().isGlobal()) {\n        return;\n      }\n\n      for (Iterator<Var> vars = s.getVars(); vars.hasNext();) {\n        Var var = vars.next();\n\n        // Don't shadow variables that is bleed-out to fix an IE bug.\n        if (var.isBleedingFunction()) {\n          continue;\n        }\n\n        // Don't shadow an exported local.\n        if (compiler.getCodingConvention().isExported(var.name, s.isLocal())) {\n          continue;\n        }\n\n        // Try to look for the best shadow for the current candidate.\n        Assignment bestShadow = findBestShadow(s, var);\n        if (bestShadow == null) {\n          continue;\n        }\n\n        // The name assignment being shadowed.\n        Assignment localAssignment = assignments.get(var.getName());\n\n        // Only shadow if this increases the number of occurrences of the\n        // shadowed variable.\n        if (bestShadow.count < localAssignment.count) {\n          continue; // Hope the next local variable would have a smaller count.\n        }\n\n        doShadow(localAssignment, bestShadow, var);\n\n        if (oldPseudoNameMap != null) {\n          String targetPseudoName =\n            oldPseudoNameMap.get(s.getVar(bestShadow.oldName).nameNode);\n          for (Node use : varToNameUsage.get(var)) {\n            deltaPseudoNameMap.put(use, targetPseudoName);\n          }\n        }\n      }\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "DoShadowVariables.exitScope",
    "class_name": "com.google.javascript.jscomp.ShadowVariables$DoShadowVariables",
    "signature": "com.google.javascript.jscomp.ShadowVariables$DoShadowVariables.exitScope(NodeTraversal)",
    "snippet": "    @Override\n    public void exitScope(NodeTraversal t) {}",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "DoShadowVariables.visit",
    "class_name": "com.google.javascript.jscomp.ShadowVariables$DoShadowVariables",
    "signature": "com.google.javascript.jscomp.ShadowVariables$DoShadowVariables.visit(NodeTraversal,Node,Node)",
    "snippet": "    @Override\n    public void visit(NodeTraversal t, Node n, Node parent) {}",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "GatherReferenceInfo.visit",
    "class_name": "com.google.javascript.jscomp.ShadowVariables$GatherReferenceInfo",
    "signature": "com.google.javascript.jscomp.ShadowVariables$GatherReferenceInfo.visit(NodeTraversal,Node,Node)",
    "snippet": "    @Override\n    public void visit(NodeTraversal t, Node n, Node parent) {\n      // Skipping over non-name nodes and empty function names.\n      if (!NodeUtil.isReferenceName(n)) {\n        return;\n      }\n\n      // We focus on shadowing local variables as their name occurs much more\n      // than global names.\n      // TODO(user): Alternatively, we could experiment with using a local\n      // name to shadow a global variable.\n      if (t.inGlobalScope()) {\n        return;\n      }\n\n      Var var = t.getScope().getVar(n.getString());\n      if (var == null) {\n        // extern name or undefined name.\n        return;\n      }\n\n      if (var.getScope().isGlobal()) {\n        // We will not shadow a global variable name.\n        return;\n      }\n\n      // Using the definition of upward referencing, fill in the map.\n      if (var.getScope() != t.getScope()) {\n        for (Scope s = t.getScope();\n            s != var.getScope() && s.isLocal(); s = s.getParent()) {\n          scopeUpRefMap.put(s.getRootNode(), var.name);\n        }\n      }\n\n      if (var.getScope() == t.getScope()) {\n        scopeUpRefMap.put(t.getScopeRoot(), var.name);\n      }\n\n      // Find in the usage map that tracks a var and all of its usage.\n      varToNameUsage.put(var, n);\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "SourceFile.SourceFile",
    "class_name": "com.google.javascript.jscomp.SourceFile",
    "signature": "com.google.javascript.jscomp.SourceFile.SourceFile(String)",
    "snippet": "  public SourceFile(String fileName) {\n    if (fileName == null || fileName.isEmpty()) {\n      throw new IllegalArgumentException(\"a source must have a name\");\n    }\n    this.fileName = fileName;\n    // Starting point: offset 0 is at line 1.\n    this.lastOffset = 0;\n    this.lastLine = 1;\n  }",
    "comment": " Construct a new abstract source file.  @param fileName The file name of the source file. It does not necessarily need to correspond to a real path. But it should be unique. Will appear in warning messages emitted by the compiler. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "SourceFile.fromCode",
    "class_name": "com.google.javascript.jscomp.SourceFile",
    "signature": "com.google.javascript.jscomp.SourceFile.fromCode(String,String)",
    "snippet": "  public static SourceFile fromCode(String fileName, String code) {\n    return new Preloaded(fileName, code);\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "SourceFile.getCode",
    "class_name": "com.google.javascript.jscomp.SourceFile",
    "signature": "com.google.javascript.jscomp.SourceFile.getCode()",
    "snippet": "  public String getCode() throws IOException {\n    return code;\n  }",
    "comment": " Gets all the code in this source file. @throws IOException ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "SourceFile.getLine",
    "class_name": "com.google.javascript.jscomp.SourceFile",
    "signature": "com.google.javascript.jscomp.SourceFile.getLine(int)",
    "snippet": "  public String getLine(int lineNumber) {\n    String js = \"\";\n    try {\n      // NOTE(nicksantos): Right now, this is optimized for few warnings.\n      // This is probably the right trade-off, but will be slow if there\n      // are lots of warnings in one file.\n      js = getCode();\n    } catch (IOException e) {\n      return null;\n    }\n\n    int pos = 0;\n    int startLine = 1;\n\n    // If we've saved a previous offset and it's for a line less than the\n    // one we're searching for, then start at that point.\n    if (lineNumber >= lastLine) {\n      pos = lastOffset;\n      startLine = lastLine;\n    }\n\n    for (int n = startLine; n < lineNumber; n++) {\n      int nextpos = js.indexOf('\\n', pos);\n      if (nextpos == -1) {\n        return null;\n      }\n      pos = nextpos + 1;\n    }\n\n    // Remember this offset for the next search we do.\n    lastOffset = pos;\n    lastLine = lineNumber;\n\n    return (js.indexOf('\\n', pos) == -1) ? null :\n        js.substring(pos, js.indexOf('\\n', pos));\n  }",
    "comment": " Gets the source line for the indicated line number.  @param lineNumber the line number, 1 being the first line of the file. @return The line indicated. Does not include the newline at the end of the file. Returns {@code null} if it does not exist, or if there was an IO exception. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "SourceFile.getName",
    "class_name": "com.google.javascript.jscomp.SourceFile",
    "signature": "com.google.javascript.jscomp.SourceFile.getName()",
    "snippet": "  @Override\n  public String getName() {\n    return fileName;\n  }",
    "comment": "Returns a unique name for the source file. */",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "SourceFile.isExtern",
    "class_name": "com.google.javascript.jscomp.SourceFile",
    "signature": "com.google.javascript.jscomp.SourceFile.isExtern()",
    "snippet": "  @Override\n  public boolean isExtern() {\n    return isExternFile;\n  }",
    "comment": "Returns whether this is an extern. */",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "SourceFile.setCode",
    "class_name": "com.google.javascript.jscomp.SourceFile",
    "signature": "com.google.javascript.jscomp.SourceFile.setCode(String)",
    "snippet": "  private void setCode(String sourceCode) {\n    code = sourceCode;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "SourceFile.setIsExtern",
    "class_name": "com.google.javascript.jscomp.SourceFile",
    "signature": "com.google.javascript.jscomp.SourceFile.setIsExtern(boolean)",
    "snippet": "  void setIsExtern(boolean newVal) {\n    isExternFile = newVal;\n  }",
    "comment": "Sets that this is an extern. */",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "SourceFile.setOriginalPath",
    "class_name": "com.google.javascript.jscomp.SourceFile",
    "signature": "com.google.javascript.jscomp.SourceFile.setOriginalPath(String)",
    "snippet": "  public void setOriginalPath(String originalPath) {\n    this.originalPath = originalPath;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "StatementFusion.canFuseIntoOneStatement",
    "class_name": "com.google.javascript.jscomp.StatementFusion",
    "signature": "com.google.javascript.jscomp.StatementFusion.canFuseIntoOneStatement(Node)",
    "snippet": "  private static boolean canFuseIntoOneStatement(Node block) {\n    // Fold only statement block. NOT scripts block.\n    if (block.getType() != Token.BLOCK) {\n      return false;\n    }\n\n    // Nothing to do here.\n    if (!block.hasChildren() || block.hasOneChild()) {\n      return false;\n    }\n\n    Node last = block.getLastChild();\n\n    for (Node c = block.getFirstChild(); c != null; c = c.getNext()) {\n      if (!NodeUtil.isExpressionNode(c) && c != last) {\n        return false;\n      }\n    }\n\n    // TODO(user): Support more control statement for fusion.\n    // FOR\n    switch(last.getType()) {\n      case Token.IF:\n      case Token.THROW:\n      case Token.SWITCH:\n      case Token.EXPR_RESULT:\n        return true;\n      case Token.RETURN:\n        // We don't want to add a new return value.\n        return last.hasChildren();\n      case Token.FOR:\n        return NodeUtil.isForIn(last) &&\n            // Avoid cases where we have for(var x = foo() in a) { ....\n            !NodeUtil.mayHaveSideEffects(last.getFirstChild());\n    }\n\n    return false;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "StatementFusion.optimizeSubtree",
    "class_name": "com.google.javascript.jscomp.StatementFusion",
    "signature": "com.google.javascript.jscomp.StatementFusion.optimizeSubtree(Node)",
    "snippet": "  @Override\n  Node optimizeSubtree(Node n) {\n    // The block of a function body always need { }.\n    if (!NodeUtil.isFunction(n.getParent()) && canFuseIntoOneStatement(n)) {\n      fuseIntoOneStatement(n);\n      reportCodeChange();\n    }\n    return n;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "StrictModeCheck.StrictModeCheck",
    "class_name": "com.google.javascript.jscomp.StrictModeCheck",
    "signature": "com.google.javascript.jscomp.StrictModeCheck.StrictModeCheck(AbstractCompiler,boolean,boolean)",
    "snippet": "  StrictModeCheck(\n      AbstractCompiler compiler, boolean noVarCheck, boolean noCajaChecks) {\n    this.compiler = compiler;\n    this.noVarCheck = noVarCheck;\n    this.noCajaChecks = noCajaChecks;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "StrictModeCheck.checkAssignment",
    "class_name": "com.google.javascript.jscomp.StrictModeCheck",
    "signature": "com.google.javascript.jscomp.StrictModeCheck.checkAssignment(NodeTraversal,Node)",
    "snippet": "  private void checkAssignment(NodeTraversal t, Node n) {\n    if (n.getFirstChild().getType() == Token.NAME) {\n      if (\"arguments\".equals(n.getFirstChild().getString())) {\n        t.report(n, ARGUMENTS_ASSIGNMENT);\n      } else if (\"eval\".equals(n.getFirstChild().getString())) {\n        // Note that assignment to eval is already illegal because any use of\n        // that name is illegal.\n        if (noCajaChecks) {\n          t.report(n, EVAL_ASSIGNMENT);\n        }\n      }\n    }\n  }",
    "comment": "Checks that an assignment is not to the \"arguments\" object. */",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "StrictModeCheck.checkNameUse",
    "class_name": "com.google.javascript.jscomp.StrictModeCheck",
    "signature": "com.google.javascript.jscomp.StrictModeCheck.checkNameUse(NodeTraversal,Node)",
    "snippet": "  private void checkNameUse(NodeTraversal t, Node n) {\n    Var v = t.getScope().getVar(n.getString());\n    if (v == null) {\n      // In particular, this prevents creating a global variable by assigning\n      // to it without a declaration.\n      if (!noVarCheck) {\n        t.report(n, UNKNOWN_VARIABLE, n.getString());\n      }\n    }\n\n    if (!noCajaChecks) {\n      if (\"eval\".equals(n.getString())) {\n        t.report(n, EVAL_USE);\n      } else if (n.getString().endsWith(\"__\")) {\n        t.report(n, ILLEGAL_NAME);\n      }\n    }\n  }",
    "comment": "Checks that the given name is used legally. */",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "StrictModeCheck.isDeclaration",
    "class_name": "com.google.javascript.jscomp.StrictModeCheck",
    "signature": "com.google.javascript.jscomp.StrictModeCheck.isDeclaration(Node)",
    "snippet": "  private static boolean isDeclaration(Node n) {\n    switch (n.getParent().getType()) {\n      case Token.VAR:\n      case Token.FUNCTION:\n      case Token.CATCH:\n        return true;\n\n      case Token.LP:\n        return n.getParent().getParent().getType() == Token.FUNCTION;\n\n      default:\n        return false;\n    }\n  }",
    "comment": " Determines if the given name is a declaration, which can be a declaration of a variable, function, or argument. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "StrictModeCheck.process",
    "class_name": "com.google.javascript.jscomp.StrictModeCheck",
    "signature": "com.google.javascript.jscomp.StrictModeCheck.process(Node,Node)",
    "snippet": "  @Override public void process(Node externs, Node root) {\n    NodeTraversal.traverseRoots(\n        compiler, Lists.newArrayList(externs, root), this);\n    NodeTraversal.traverse(compiler, root, new NonExternChecks());\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "StrictModeCheck.visit",
    "class_name": "com.google.javascript.jscomp.StrictModeCheck",
    "signature": "com.google.javascript.jscomp.StrictModeCheck.visit(NodeTraversal,Node,Node)",
    "snippet": "  @Override public void visit(NodeTraversal t, Node n, Node parent) {\n    if (n.getType() == Token.WITH) {\n      t.report(n, WITH_DISALLOWED);\n    } else if (n.getType() == Token.NAME) {\n      if (!isDeclaration(n)) {\n        checkNameUse(t, n);\n      }\n    } else if (n.getType() == Token.ASSIGN) {\n      checkAssignment(t, n);\n    } else if (n.getType() == Token.DELPROP) {\n      checkDelete(t, n);\n    } else if (n.getType() == Token.OBJECTLIT) {\n      checkObjectLiteral(t, n);\n    } else if (n.getType() == Token.LABEL) {\n      checkLabel(t, n);\n    }\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "NonExternChecks.checkDeclaration",
    "class_name": "com.google.javascript.jscomp.StrictModeCheck$NonExternChecks",
    "signature": "com.google.javascript.jscomp.StrictModeCheck$NonExternChecks.checkDeclaration(NodeTraversal,Node)",
    "snippet": "    private void checkDeclaration(NodeTraversal t, Node n) {\n      if (\"eval\".equals(n.getString())) {\n        t.report(n, EVAL_DECLARATION);\n      } else if (\"arguments\".equals(n.getString())) {\n        t.report(n, ARGUMENTS_DECLARATION);\n      } else if (n.getString().endsWith(\"__\")) {\n        if (!noCajaChecks) {\n          t.report(n, ILLEGAL_NAME);\n        }\n      }\n    }",
    "comment": "Checks for illegal declarations. */",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "NonExternChecks.checkProperty",
    "class_name": "com.google.javascript.jscomp.StrictModeCheck$NonExternChecks",
    "signature": "com.google.javascript.jscomp.StrictModeCheck$NonExternChecks.checkProperty(NodeTraversal,Node)",
    "snippet": "    private void checkProperty(NodeTraversal t, Node n) {\n      if (n.getLastChild().getString().endsWith(\"__\")) {\n        if (!noCajaChecks) {\n          t.report(n.getLastChild(), ILLEGAL_NAME);\n        }\n      }\n    }",
    "comment": "Checks for illegal property accesses. */",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "NonExternChecks.visit",
    "class_name": "com.google.javascript.jscomp.StrictModeCheck$NonExternChecks",
    "signature": "com.google.javascript.jscomp.StrictModeCheck$NonExternChecks.visit(NodeTraversal,Node,Node)",
    "snippet": "    @Override public void visit(NodeTraversal t, Node n, Node parent) {\n      if ((n.getType() == Token.NAME) && isDeclaration(n)) {\n        checkDeclaration(t, n);\n      } else if (n.getType() == Token.GETPROP) {\n        checkProperty(t, n);\n      }\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "Strings.isEmpty",
    "class_name": "com.google.javascript.jscomp.Strings",
    "signature": "com.google.javascript.jscomp.Strings.isEmpty(String)",
    "snippet": "  static boolean isEmpty(@Nullable String string) {\n    return string == null || string.isEmpty();\n  }",
    "comment": " Returns {@code true} if the given string is either null or the empty string (\"\").  @param string the string reference to check @return {@code true} if {@code string} is either null or the empty string ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "SuppressDocWarningsGuard.SuppressDocWarningsGuard",
    "class_name": "com.google.javascript.jscomp.SuppressDocWarningsGuard",
    "signature": "com.google.javascript.jscomp.SuppressDocWarningsGuard.SuppressDocWarningsGuard(Map)",
    "snippet": "  SuppressDocWarningsGuard(Map<String, DiagnosticGroup> suppressableGroups) {\n    for (Map.Entry<String, DiagnosticGroup> entry :\n             suppressableGroups.entrySet()) {\n      suppressors.put(\n          entry.getKey(),\n          new DiagnosticGroupWarningsGuard(\n              entry.getValue(),\n              CheckLevel.OFF));\n    }\n  }",
    "comment": " The suppressable groups, indexed by name. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "SuppressDocWarningsGuard.getPriority",
    "class_name": "com.google.javascript.jscomp.SuppressDocWarningsGuard",
    "signature": "com.google.javascript.jscomp.SuppressDocWarningsGuard.getPriority()",
    "snippet": "  @Override\n  public int getPriority() {\n    // Happens after path-based filtering, but before other times\n    // of filtering.\n    return WarningsGuard.Priority.SUPPRESS_DOC.value;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "SuppressDocWarningsGuard.level",
    "class_name": "com.google.javascript.jscomp.SuppressDocWarningsGuard",
    "signature": "com.google.javascript.jscomp.SuppressDocWarningsGuard.level(JSError)",
    "snippet": "  @Override\n  public CheckLevel level(JSError error) {\n    Node node = error.node;\n    if (node != null) {\n      for (Node current = node;\n           current != null;\n           current = current.getParent()) {\n        int type = current.getType();\n        JSDocInfo info = null;\n\n        // We only care about function annotations at the FUNCTION and SCRIPT\n        // level. Otherwise, the @suppress annotation has an implicit\n        // dependency on the exact structure of our AST, and that seems like\n        // a bad idea.\n        if (type == Token.FUNCTION) {\n          info = NodeUtil.getFunctionJSDocInfo(current);\n        } else if (type == Token.SCRIPT) {\n          info = current.getJSDocInfo();\n        }\n\n        if (info != null) {\n          for (String suppressor : info.getSuppressions()) {\n            WarningsGuard guard = suppressors.get(suppressor);\n\n            // Some @suppress tags are for other tools, and\n            // may not have a warnings guard.\n            if (guard != null) {\n              CheckLevel newLevel = guard.level(error);\n              if (newLevel != null) {\n                return newLevel;\n              }\n            }\n          }\n        }\n      }\n    }\n    return null;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "SyntacticScopeCreator.SyntacticScopeCreator",
    "class_name": "com.google.javascript.jscomp.SyntacticScopeCreator",
    "signature": "com.google.javascript.jscomp.SyntacticScopeCreator.SyntacticScopeCreator(AbstractCompiler)",
    "snippet": "  SyntacticScopeCreator(AbstractCompiler compiler) {\n    this.compiler = compiler;\n    this.redeclarationHandler = new DefaultRedeclarationHandler();\n  }",
    "comment": " Creates a ScopeCreator. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "SyntacticScopeCreator.SyntacticScopeCreator",
    "class_name": "com.google.javascript.jscomp.SyntacticScopeCreator",
    "signature": "com.google.javascript.jscomp.SyntacticScopeCreator.SyntacticScopeCreator(AbstractCompiler,RedeclarationHandler)",
    "snippet": "  SyntacticScopeCreator(\n      AbstractCompiler compiler, RedeclarationHandler redeclarationHandler) {\n    this.compiler = compiler;\n    this.redeclarationHandler = redeclarationHandler;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "SyntacticScopeCreator.createScope",
    "class_name": "com.google.javascript.jscomp.SyntacticScopeCreator",
    "signature": "com.google.javascript.jscomp.SyntacticScopeCreator.createScope(Node,Scope)",
    "snippet": "  public Scope createScope(Node n, Scope parent) {\n    sourceName = null;\n    if (parent == null) {\n      scope = new Scope(n, compiler);\n    } else {\n      scope = new Scope(parent, n);\n    }\n\n    scanRoot(n, parent);\n\n    sourceName = null;\n    Scope returnedScope = scope;\n    scope = null;\n    return returnedScope;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "SyntacticScopeCreator.declareVar",
    "class_name": "com.google.javascript.jscomp.SyntacticScopeCreator",
    "signature": "com.google.javascript.jscomp.SyntacticScopeCreator.declareVar(Node)",
    "snippet": "  private void declareVar(Node n) {\n    Preconditions.checkState(n.getType() == Token.NAME);\n\n    CompilerInput input = compiler.getInput(sourceName);\n    String name = n.getString();\n    if (scope.isDeclared(name, false)\n        || (scope.isLocal() && name.equals(ARGUMENTS))) {\n      redeclarationHandler.onRedeclaration(\n          scope, name, n, input);\n    } else {\n      scope.declare(name, n, null, input);\n    }\n  }",
    "comment": " Declares a variable.  @param n The node corresponding to the variable name. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "SyntacticScopeCreator.hasDuplicateDeclarationSuppression",
    "class_name": "com.google.javascript.jscomp.SyntacticScopeCreator",
    "signature": "com.google.javascript.jscomp.SyntacticScopeCreator.hasDuplicateDeclarationSuppression(Node,Var)",
    "snippet": "  static boolean hasDuplicateDeclarationSuppression(Node n, Scope.Var origVar) {\n    Preconditions.checkState(n.getType() == Token.NAME);\n    Node parent = n.getParent();\n    Node origParent = origVar.getParentNode();\n\n    JSDocInfo info = n.getJSDocInfo();\n    if (info == null) {\n      info = parent.getJSDocInfo();\n    }\n    if (info != null && info.getSuppressions().contains(\"duplicate\")) {\n      return true;\n    }\n\n    info = origVar.nameNode.getJSDocInfo();\n    if (info == null) {\n      info = origParent.getJSDocInfo();\n    }\n    return (info != null && info.getSuppressions().contains(\"duplicate\"));\n  }",
    "comment": " @param n The name node to check. @param origVar The associated Var. @return Whether duplicated declarations warnings should be suppressed for the given node. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "SyntacticScopeCreator.scanRoot",
    "class_name": "com.google.javascript.jscomp.SyntacticScopeCreator",
    "signature": "com.google.javascript.jscomp.SyntacticScopeCreator.scanRoot(Node,Scope)",
    "snippet": "  private void scanRoot(Node n, Scope parent) {\n    if (n.getType() == Token.FUNCTION) {\n      sourceName = n.getSourceFileName();\n\n      final Node fnNameNode = n.getFirstChild();\n      final Node args = fnNameNode.getNext();\n      final Node body = args.getNext();\n\n      // Bleed the function name into the scope, if it hasn't\n      // been declared in the outer scope.\n      String fnName = fnNameNode.getString();\n      if (!fnName.isEmpty() && NodeUtil.isFunctionExpression(n)) {\n        declareVar(fnNameNode);\n      }\n\n      // Args: Declare function variables\n      Preconditions.checkState(args.getType() == Token.LP);\n      for (Node a = args.getFirstChild(); a != null;\n           a = a.getNext()) {\n        Preconditions.checkState(a.getType() == Token.NAME);\n        declareVar(a);\n      }\n\n      // Body\n      scanVars(body, n);\n    } else {\n      // It's the global block\n      Preconditions.checkState(scope.getParent() == null);\n      scanVars(n, null);\n    }\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "SyntacticScopeCreator.scanVars",
    "class_name": "com.google.javascript.jscomp.SyntacticScopeCreator",
    "signature": "com.google.javascript.jscomp.SyntacticScopeCreator.scanVars(Node,Node)",
    "snippet": "  private void scanVars(Node n, Node parent) {\n    switch (n.getType()) {\n      case Token.VAR:\n        // Declare all variables. e.g. var x = 1, y, z;\n        for (Node child = n.getFirstChild();\n             child != null;) {\n          Node next = child.getNext();\n          declareVar(child);\n          child = next;\n        }\n        return;\n\n      case Token.FUNCTION:\n        if (NodeUtil.isFunctionExpression(n)) {\n          return;\n        }\n\n        String fnName = n.getFirstChild().getString();\n        if (fnName.isEmpty()) {\n          // This is invalid, but allow it so the checks can catch it.\n          return;\n        }\n        declareVar(n.getFirstChild());\n        return;   // should not examine function's children\n\n      case Token.CATCH:\n        Preconditions.checkState(n.getChildCount() == 2);\n        Preconditions.checkState(n.getFirstChild().getType() == Token.NAME);\n        // the first child is the catch var and the third child\n        // is the code block\n\n        final Node var = n.getFirstChild();\n        final Node block = var.getNext();\n\n        declareVar(var);\n        scanVars(block, n);\n        return;  // only one child to scan\n\n      case Token.SCRIPT:\n        sourceName = n.getSourceFileName();\n        break;\n    }\n\n    // Variables can only occur in statement-level nodes, so\n    // we only need to traverse children in a couple special cases.\n    if (NodeUtil.isControlStructure(n) || NodeUtil.isStatementBlock(n)) {\n      for (Node child = n.getFirstChild();\n           child != null;) {\n        Node next = child.getNext();\n        scanVars(child, n);\n        child = next;\n      }\n    }\n  }",
    "comment": " Scans and gather variables declarations under a Node ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "Tracer.Tracer",
    "class_name": "com.google.javascript.jscomp.Tracer",
    "signature": "com.google.javascript.jscomp.Tracer.Tracer(String,String)",
    "snippet": "  Tracer(@Nullable String type, @Nullable String comment) {\n    this.type = type;\n    this.comment = comment == null ? \"\" : comment;\n    startTimeMs = clock.currentTimeMillis();\n    startThread = Thread.currentThread();\n    if (!extraTracingStatistics.isEmpty()) {\n      int size = extraTracingStatistics.size();\n      extraTracingValues = new long[size];\n      int i = 0;\n      for (TracingStatistic tracingStatistic : extraTracingStatistics) {\n        extraTracingValues[i] = tracingStatistic.start(startThread);\n        i++;\n      }\n    }\n\n    ThreadTrace trace = getThreadTrace();\n\n    // Do nothing if the current thread trace wasn't initialized.\n    if (!trace.isInitialized()) {\n      return;\n    }\n\n    // Check if we are creating too many Tracers.\n    if (trace.events.size() >= MAX_TRACE_SIZE) {\n      logger.log(Level.WARNING,\n                  \"Giant thread trace. Too many Tracers created. \"\n                    + \"Clearing to avoid memory leak.\",\n                  new Throwable(trace.toString()));\n      trace.truncateEvents();\n    }\n\n    // Check if we forgot to close the Tracers.\n    if (trace.outstandingEvents.size() >= MAX_TRACE_SIZE) {\n      logger.log(Level.WARNING,\n                  \"Too many outstanding Tracers. Tracer.stop() is missing \"\n                    + \"or Tracer.stop() is not wrapped in a \"\n                    + \"try/finally block. \"\n                    + \"Clearing to avoid memory leak.\",\n                  new Throwable(trace.toString()));\n      trace.truncateOutstandingEvents();\n    }\n\n    trace.startEvent(this);\n  }",
    "comment": " Create and start a tracer. Both type and comment may be null. See class comment for usage.  @param type The type for totalling @param comment Comment about this tracer ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "Tracer.getThreadTrace",
    "class_name": "com.google.javascript.jscomp.Tracer",
    "signature": "com.google.javascript.jscomp.Tracer.getThreadTrace()",
    "snippet": "  static ThreadTrace getThreadTrace() {\n    ThreadTrace t = traces.get();\n    if (t == null) {\n      t = new ThreadTrace();\n      t.prettyPrint = defaultPrettyPrint;\n      traces.set(t);\n    }\n    return t;\n  }",
    "comment": " Get the ThreadTrace for the current thread, creating one if necessary. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "Tracer.stop",
    "class_name": "com.google.javascript.jscomp.Tracer",
    "signature": "com.google.javascript.jscomp.Tracer.stop()",
    "snippet": "  long stop() {\n    return stop(-1);\n  }",
    "comment": "Stop the trace using the default silence_threshold  @return  The time that this trace actually ran. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "Tracer.stop",
    "class_name": "com.google.javascript.jscomp.Tracer",
    "signature": "com.google.javascript.jscomp.Tracer.stop(int)",
    "snippet": "  long stop(int silence_threshold) {\n    Preconditions.checkState(Thread.currentThread() == startThread);\n\n    ThreadTrace trace = getThreadTrace();\n    // Do nothing if the thread trace was not initialized.\n    if (!trace.isInitialized()) {\n      return 0;\n    }\n\n    stopTimeMs = clock.currentTimeMillis();\n    if (extraTracingValues != null) {\n      // We use extraTracingValues.length rather than\n      // extraTracingStatistics.size() because a new statistic may\n      // have been added\n      for (int i = 0; i < extraTracingValues.length; i++) {\n        long value = extraTracingStatistics.get(i).stop(startThread);\n        extraTracingValues[i] = value - extraTracingValues[i];\n      }\n    }\n\n    // Do nothing if the thread trace was not initialized.\n    if (!trace.isInitialized()) {\n      return 0;\n    }\n\n    trace.endEvent(this, silence_threshold);\n    return stopTimeMs - startTimeMs;\n  }",
    "comment": " Stop the trace. This may only be done once and must be done from the same thread that started it. @param silence_threshold Traces for time less than silence_threshold ms will be left out of the trace report. A value of -1 indicates that the current ThreadTrace silence_threshold should be used. @return The time that this trace actually ran ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "ThreadTrace.isInitialized",
    "class_name": "com.google.javascript.jscomp.Tracer$ThreadTrace",
    "signature": "com.google.javascript.jscomp.Tracer$ThreadTrace.isInitialized()",
    "snippet": "    boolean isInitialized() {\n      return isInitialized;\n    }",
    "comment": "Is initialized? */",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "TypeCheck.TypeCheck",
    "class_name": "com.google.javascript.jscomp.TypeCheck",
    "signature": "com.google.javascript.jscomp.TypeCheck.TypeCheck(AbstractCompiler,ReverseAbstractInterpreter,JSTypeRegistry,Scope,ScopeCreator,CheckLevel,CheckLevel)",
    "snippet": "  public TypeCheck(AbstractCompiler compiler,\n      ReverseAbstractInterpreter reverseInterpreter,\n      JSTypeRegistry typeRegistry,\n      Scope topScope,\n      ScopeCreator scopeCreator,\n      CheckLevel reportMissingOverride,\n      CheckLevel reportUnknownTypes) {\n    this.compiler = compiler;\n    this.validator = compiler.getTypeValidator();\n    this.reverseInterpreter = reverseInterpreter;\n    this.typeRegistry = typeRegistry;\n    this.topScope = topScope;\n    this.scopeCreator = scopeCreator;\n    this.reportMissingOverride = reportMissingOverride;\n    this.reportUnknownTypes = reportUnknownTypes;\n    this.inferJSDocInfo = new InferJSDocInfo(compiler);\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "TypeCheck.check",
    "class_name": "com.google.javascript.jscomp.TypeCheck",
    "signature": "com.google.javascript.jscomp.TypeCheck.check(Node,boolean)",
    "snippet": "  public void check(Node node, boolean externs) {\n    Preconditions.checkNotNull(node);\n\n    NodeTraversal t = new NodeTraversal(compiler, this, scopeCreator);\n    inExterns = externs;\n    t.traverseWithScope(node, topScope);\n    if (externs) {\n      inferJSDocInfo.process(node, null);\n    } else {\n      inferJSDocInfo.process(null, node);\n    }\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "TypeCheck.checkDeclaredPropertyInheritance",
    "class_name": "com.google.javascript.jscomp.TypeCheck",
    "signature": "com.google.javascript.jscomp.TypeCheck.checkDeclaredPropertyInheritance(NodeTraversal,Node,FunctionType,String,JSDocInfo,JSType)",
    "snippet": "  private void checkDeclaredPropertyInheritance(\n      NodeTraversal t, Node n, FunctionType ctorType, String propertyName,\n      JSDocInfo info, JSType propertyType) {\n    // If the supertype doesn't resolve correctly, we've warned about this\n    // already.\n    if (hasUnknownOrEmptySupertype(ctorType)) {\n      return;\n    }\n\n    FunctionType superClass = ctorType.getSuperClassConstructor();\n    boolean superClassHasProperty = superClass != null &&\n        superClass.getPrototype().hasProperty(propertyName);\n    // For interface\n    boolean superInterfacesHasProperty = false;\n    if (ctorType.isInterface()) {\n      for (ObjectType interfaceType : ctorType.getExtendedInterfaces()) {\n        superInterfacesHasProperty =\n          superInterfacesHasProperty || interfaceType.hasProperty(propertyName);\n      }\n    }\n    boolean declaredOverride = info != null && info.isOverride();\n\n    boolean foundInterfaceProperty = false;\n    if (ctorType.isConstructor()) {\n      for (JSType implementedInterface :\n          ctorType.getAllImplementedInterfaces()) {\n        if (implementedInterface.isUnknownType() ||\n            implementedInterface.isEmptyType()) {\n          continue;\n        }\n        FunctionType interfaceType =\n            implementedInterface.toObjectType().getConstructor();\n        Preconditions.checkNotNull(interfaceType);\n        boolean interfaceHasProperty =\n            interfaceType.getPrototype().hasProperty(propertyName);\n        foundInterfaceProperty = foundInterfaceProperty || interfaceHasProperty;\n        if (reportMissingOverride.isOn() && !declaredOverride &&\n            interfaceHasProperty) {\n          // @override not present, but the property does override an interface\n          // property\n          compiler.report(t.makeError(n, reportMissingOverride,\n              HIDDEN_INTERFACE_PROPERTY, propertyName,\n              interfaceType.getTopMostDefiningType(propertyName).toString()));\n        }\n      }\n    }\n\n    if (!declaredOverride && !superClassHasProperty\n        && !superInterfacesHasProperty) {\n      // nothing to do here, it's just a plain new property\n      return;\n    }\n\n    JSType topInstanceType = superClassHasProperty ?\n        superClass.getTopMostDefiningType(propertyName) : null;\n    if (reportMissingOverride.isOn() && ctorType.isConstructor() &&\n        !declaredOverride && superClassHasProperty) {\n      // @override not present, but the property does override a superclass\n      // property\n      compiler.report(t.makeError(n, reportMissingOverride,\n          HIDDEN_SUPERCLASS_PROPERTY, propertyName,\n          topInstanceType.toString()));\n    }\n    if (!declaredOverride) {\n      // there's no @override to check\n      return;\n    }\n    // @override is present and we have to check that it is ok\n    if (superClassHasProperty) {\n      // there is a superclass implementation\n      JSType superClassPropType =\n          superClass.getPrototype().getPropertyType(propertyName);\n      if (!propertyType.canAssignTo(superClassPropType)) {\n        compiler.report(\n            t.makeError(n, HIDDEN_SUPERCLASS_PROPERTY_MISMATCH,\n                propertyName, topInstanceType.toString(),\n                superClassPropType.toString(), propertyType.toString()));\n      }\n    } else if (superInterfacesHasProperty) {\n      // there is an super interface property\n      for (ObjectType interfaceType : ctorType.getExtendedInterfaces()) {\n        if (interfaceType.hasProperty(propertyName)) {\n          JSType superPropertyType =\n            interfaceType.getPropertyType(propertyName);\n          if (!propertyType.canAssignTo(superPropertyType)) {\n            topInstanceType = interfaceType.getConstructor().\n                getTopMostDefiningType(propertyName);\n            compiler.report(\n                t.makeError(n, HIDDEN_SUPERCLASS_PROPERTY_MISMATCH,\n                    propertyName, topInstanceType.toString(),\n                    superPropertyType.toString(),\n                    propertyType.toString()));\n          }\n        }\n      }\n    } else if (!foundInterfaceProperty) {\n      // there is no superclass nor interface implementation\n      compiler.report(\n          t.makeError(n, UNKNOWN_OVERRIDE,\n              propertyName, ctorType.getInstanceType().toString()));\n    }\n  }",
    "comment": " Given a constructor type and a property name, check that the property has the JSDoc annotation @override iff the property is declared on a superclass. Several checks regarding inheritance correctness are also performed. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "TypeCheck.checkNoTypeCheckSection",
    "class_name": "com.google.javascript.jscomp.TypeCheck",
    "signature": "com.google.javascript.jscomp.TypeCheck.checkNoTypeCheckSection(Node,boolean)",
    "snippet": "  private void checkNoTypeCheckSection(Node n, boolean enterSection) {\n    switch (n.getType()) {\n      case Token.SCRIPT:\n      case Token.BLOCK:\n      case Token.VAR:\n      case Token.FUNCTION:\n      case Token.ASSIGN:\n        JSDocInfo info = n.getJSDocInfo();\n        if (info != null && info.isNoTypeCheck()) {\n          if (enterSection) {\n            noTypeCheckSection++;\n          } else {\n            noTypeCheckSection--;\n          }\n        }\n        validator.setShouldReport(noTypeCheckSection == 0);\n        break;\n    }\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "TypeCheck.checkPropertyAccess",
    "class_name": "com.google.javascript.jscomp.TypeCheck",
    "signature": "com.google.javascript.jscomp.TypeCheck.checkPropertyAccess(JSType,String,NodeTraversal,Node)",
    "snippet": "  private void checkPropertyAccess(JSType childType, String propName,\n      NodeTraversal t, Node n) {\n    ObjectType objectType = childType.dereference();\n    if (objectType != null) {\n      JSType propType = getJSType(n);\n      if ((!objectType.hasProperty(propName) ||\n           objectType.equals(typeRegistry.getNativeType(UNKNOWN_TYPE))) &&\n          propType.equals(typeRegistry.getNativeType(UNKNOWN_TYPE))) {\n        if (objectType instanceof EnumType) {\n          report(t, n, INEXISTENT_ENUM_ELEMENT, propName);\n        } else if (!objectType.isEmptyType() &&\n            reportMissingProperties && !isPropertyTest(n)) {\n          if (!typeRegistry.canPropertyBeDefined(objectType, propName)) {\n            report(t, n, INEXISTENT_PROPERTY, propName,\n                validator.getReadableJSTypeName(n.getFirstChild(), true));\n          }\n        }\n      }\n    } else {\n      // TODO(nicksantos): might want to flag the access on a non object when\n      // it's impossible to get a property from this type.\n    }\n  }",
    "comment": " Make sure that the access of this property is ok. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "TypeCheck.doPercentTypedAccounting",
    "class_name": "com.google.javascript.jscomp.TypeCheck",
    "signature": "com.google.javascript.jscomp.TypeCheck.doPercentTypedAccounting(NodeTraversal,Node)",
    "snippet": "  private void doPercentTypedAccounting(NodeTraversal t, Node n) {\n    JSType type = n.getJSType();\n    if (type == null) {\n      nullCount++;\n    } else if (type.isUnknownType()) {\n      if (reportUnknownTypes.isOn()) {\n        compiler.report(\n            t.makeError(n, reportUnknownTypes, UNKNOWN_EXPR_TYPE));\n      }\n      unknownCount++;\n    } else {\n      typedCount++;\n    }\n  }",
    "comment": " Counts the given node in the typed statistics. @param n a node that should be typed ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "TypeCheck.ensureTyped",
    "class_name": "com.google.javascript.jscomp.TypeCheck",
    "signature": "com.google.javascript.jscomp.TypeCheck.ensureTyped(NodeTraversal,Node)",
    "snippet": "  private void ensureTyped(NodeTraversal t, Node n) {\n    ensureTyped(t, n, getNativeType(UNKNOWN_TYPE));\n  }",
    "comment": " Ensure that the given node has a type. If it does not have one, attach the UNKNOWN_TYPE. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "TypeCheck.ensureTyped",
    "class_name": "com.google.javascript.jscomp.TypeCheck",
    "signature": "com.google.javascript.jscomp.TypeCheck.ensureTyped(NodeTraversal,Node,JSType)",
    "snippet": "  private void ensureTyped(NodeTraversal t, Node n, JSType type) {\n    // Make sure FUNCTION nodes always get function type.\n    Preconditions.checkState(n.getType() != Token.FUNCTION ||\n            type instanceof FunctionType ||\n            type.isUnknownType());\n    JSDocInfo info = n.getJSDocInfo();\n    if (info != null) {\n      if (info.hasType()) {\n        JSType infoType = info.getType().evaluate(t.getScope(), typeRegistry);\n        validator.expectCanCast(t, n, infoType, type);\n        type = infoType;\n      }\n\n      if (info.isImplicitCast() && !inExterns) {\n        String propName = n.getType() == Token.GETPROP ?\n            n.getLastChild().getString() : \"(missing)\";\n        compiler.report(\n            t.makeError(n, ILLEGAL_IMPLICIT_CAST, propName));\n      }\n    }\n\n    if (n.getJSType() == null) {\n      n.setJSType(type);\n    }\n  }",
    "comment": " Enforces type casts, and ensures the node is typed.  A cast in the way that we use it in JSDoc annotations never alters the generated code and therefore never can induce any runtime operation. What this means is that a 'cast' is really just a compile time constraint on the underlying value. In the future, we may add support for run-time casts for compiled tests.  To ensure some shred of sanity, we enforce the notion that the type you are casting to may only meaningfully be a narrower type than the underlying declared type. We also invalidate optimizations on bad type casts.  @param t The traversal object needed to report errors. @param n The node getting a type assigned to it. @param type The type to be assigned. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "TypeCheck.ensureTyped",
    "class_name": "com.google.javascript.jscomp.TypeCheck",
    "signature": "com.google.javascript.jscomp.TypeCheck.ensureTyped(NodeTraversal,Node,JSTypeNative)",
    "snippet": "  private void ensureTyped(NodeTraversal t, Node n, JSTypeNative type) {\n    ensureTyped(t, n, getNativeType(type));\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "TypeCheck.getJSType",
    "class_name": "com.google.javascript.jscomp.TypeCheck",
    "signature": "com.google.javascript.jscomp.TypeCheck.getJSType(Node)",
    "snippet": "  private JSType getJSType(Node n) {\n    JSType jsType = n.getJSType();\n    if (jsType == null) {\n      // TODO(nicksantos): This branch indicates a compiler bug, not worthy of\n      // halting the compilation but we should log this and analyze to track\n      // down why it happens. This is not critical and will be resolved over\n      // time as the type checker is extended.\n      return getNativeType(UNKNOWN_TYPE);\n    } else {\n      return jsType;\n    }\n  }",
    "comment": " This method gets the JSType from the Node argument and verifies that it is present. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "TypeCheck.getNativeType",
    "class_name": "com.google.javascript.jscomp.TypeCheck",
    "signature": "com.google.javascript.jscomp.TypeCheck.getNativeType(JSTypeNative)",
    "snippet": "  private JSType getNativeType(JSTypeNative typeId) {\n    return typeRegistry.getNativeType(typeId);\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "TypeCheck.getTypedPercent",
    "class_name": "com.google.javascript.jscomp.TypeCheck",
    "signature": "com.google.javascript.jscomp.TypeCheck.getTypedPercent()",
    "snippet": "  double getTypedPercent() {\n    int total = nullCount + unknownCount + typedCount;\n    if (total == 0) {\n      return 0.0;\n    } else {\n      return (100.0 * typedCount) / total;\n    }\n  }",
    "comment": " Returns the percentage of nodes typed by the type checker. @return a number between 0.0 and 100.0 ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "TypeCheck.hasUnknownOrEmptySupertype",
    "class_name": "com.google.javascript.jscomp.TypeCheck",
    "signature": "com.google.javascript.jscomp.TypeCheck.hasUnknownOrEmptySupertype(FunctionType)",
    "snippet": "  private static boolean hasUnknownOrEmptySupertype(FunctionType ctor) {\n    Preconditions.checkArgument(ctor.isConstructor() || ctor.isInterface());\n    Preconditions.checkArgument(!ctor.isUnknownType());\n\n    // The type system should notice inheritance cycles on its own\n    // and break the cycle.\n    while (true) {\n      ObjectType maybeSuperInstanceType =\n          ctor.getPrototype().getImplicitPrototype();\n      if (maybeSuperInstanceType == null) {\n        return false;\n      }\n      if (maybeSuperInstanceType.isUnknownType() ||\n          maybeSuperInstanceType.isEmptyType()) {\n        return true;\n      }\n      ctor = maybeSuperInstanceType.getConstructor();\n      if (ctor == null) {\n        return false;\n      }\n      Preconditions.checkState(ctor.isConstructor() || ctor.isInterface());\n    }\n  }",
    "comment": " Given a constructor or an interface type, find out whether the unknown type is a supertype of the current type. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "TypeCheck.process",
    "class_name": "com.google.javascript.jscomp.TypeCheck",
    "signature": "com.google.javascript.jscomp.TypeCheck.process(Node,Node)",
    "snippet": "  public void process(Node externsRoot, Node jsRoot) {\n    Preconditions.checkNotNull(scopeCreator);\n    Preconditions.checkNotNull(topScope);\n\n    Node externsAndJs = jsRoot.getParent();\n    Preconditions.checkState(externsAndJs != null);\n    Preconditions.checkState(\n        externsRoot == null || externsAndJs.hasChild(externsRoot));\n\n    if (externsRoot != null) {\n      check(externsRoot, true);\n    }\n    check(jsRoot, false);\n  }",
    "comment": " Main entry point for this phase of processing. This follows the pattern for JSCompiler phases.  @param externsRoot The root of the externs parse tree. @param jsRoot The root of the input parse tree to be checked. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "TypeCheck.propertyIsImplicitCast",
    "class_name": "com.google.javascript.jscomp.TypeCheck",
    "signature": "com.google.javascript.jscomp.TypeCheck.propertyIsImplicitCast(ObjectType,String)",
    "snippet": "  private boolean propertyIsImplicitCast(ObjectType type, String prop) {\n    for (; type != null; type = type.getImplicitPrototype()) {\n      JSDocInfo docInfo = type.getOwnPropertyJSDocInfo(prop);\n      if (docInfo != null && docInfo.isImplicitCast()) {\n        return true;\n      }\n    }\n    return false;\n  }",
    "comment": " Returns true if any type in the chain has an implictCast annotation for the given property. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "TypeCheck.reportMissingProperties",
    "class_name": "com.google.javascript.jscomp.TypeCheck",
    "signature": "com.google.javascript.jscomp.TypeCheck.reportMissingProperties(boolean)",
    "snippet": "  TypeCheck reportMissingProperties(boolean report) {\n    reportMissingProperties = report;\n    return this;\n  }",
    "comment": "Turn on the missing property check. Returns this for easy chaining. */",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "TypeCheck.shouldTraverse",
    "class_name": "com.google.javascript.jscomp.TypeCheck",
    "signature": "com.google.javascript.jscomp.TypeCheck.shouldTraverse(NodeTraversal,Node,Node)",
    "snippet": "  public boolean shouldTraverse(\n      NodeTraversal t, Node n, Node parent) {\n    checkNoTypeCheckSection(n, true);\n    switch (n.getType()) {\n      case Token.FUNCTION:\n        // normal type checking\n        final TypeCheck outerThis = this;\n        final Scope outerScope = t.getScope();\n        final FunctionType functionType = (FunctionType) n.getJSType();\n        final String functionPrivateName = n.getFirstChild().getString();\n        if (functionPrivateName != null && functionPrivateName.length() > 0 &&\n            outerScope.isDeclared(functionPrivateName, false) &&\n            // Ideally, we would want to check whether the type in the scope\n            // differs from the type being defined, but then the extern\n            // redeclarations of built-in types generates spurious warnings.\n            !(outerScope.getVar(\n                functionPrivateName).getType() instanceof FunctionType)) {\n          report(t, n, FUNCTION_MASKS_VARIABLE, functionPrivateName);\n        }\n\n        // TODO(user): Only traverse the function's body. The function's\n        // name and arguments are traversed by the scope creator, and ideally\n        // should not be traversed by the type checker.\n        break;\n    }\n    return true;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "TypeCheck.visit",
    "class_name": "com.google.javascript.jscomp.TypeCheck",
    "signature": "com.google.javascript.jscomp.TypeCheck.visit(NodeTraversal,Node,Node)",
    "snippet": "  public void visit(NodeTraversal t, Node n, Node parent) {\n    JSType childType;\n    JSType leftType, rightType;\n    Node left, right;\n    // To be explicitly set to false if the node is not typeable.\n    boolean typeable = true;\n\n    switch (n.getType()) {\n      case Token.NAME:\n        typeable = visitName(t, n, parent);\n        break;\n\n      case Token.LP:\n        // If this is under a FUNCTION node, it is a parameter list and can be\n        // ignored here.\n        if (parent.getType() != Token.FUNCTION) {\n          ensureTyped(t, n, getJSType(n.getFirstChild()));\n        } else {\n          typeable = false;\n        }\n        break;\n\n      case Token.COMMA:\n        ensureTyped(t, n, getJSType(n.getLastChild()));\n        break;\n\n      case Token.TRUE:\n      case Token.FALSE:\n        ensureTyped(t, n, BOOLEAN_TYPE);\n        break;\n\n      case Token.THIS:\n        ensureTyped(t, n, t.getScope().getTypeOfThis());\n        break;\n\n      case Token.REF_SPECIAL:\n        ensureTyped(t, n);\n        break;\n\n      case Token.GET_REF:\n        ensureTyped(t, n, getJSType(n.getFirstChild()));\n        break;\n\n      case Token.NULL:\n        ensureTyped(t, n, NULL_TYPE);\n        break;\n\n      case Token.NUMBER:\n        ensureTyped(t, n, NUMBER_TYPE);\n        break;\n\n      case Token.STRING:\n        // Object literal keys are handled with OBJECTLIT\n        if (!NodeUtil.isObjectLitKey(n, n.getParent())) {\n          ensureTyped(t, n, STRING_TYPE);\n        } else {\n          // Object literal keys are not typeable\n          typeable = false;\n        }\n        break;\n\n      case Token.GET:\n      case Token.SET:\n        // Object literal keys are handled with OBJECTLIT\n        break;\n\n      case Token.ARRAYLIT:\n        ensureTyped(t, n, ARRAY_TYPE);\n        break;\n\n      case Token.REGEXP:\n        ensureTyped(t, n, REGEXP_TYPE);\n        break;\n\n      case Token.GETPROP:\n        visitGetProp(t, n, parent);\n        typeable = !(parent.getType() == Token.ASSIGN &&\n                     parent.getFirstChild() == n);\n        break;\n\n      case Token.GETELEM:\n        visitGetElem(t, n);\n        // The type of GETELEM is always unknown, so no point counting that.\n        // If that unknown leaks elsewhere (say by an assignment to another\n        // variable), then it will be counted.\n        typeable = false;\n        break;\n\n      case Token.VAR:\n        visitVar(t, n);\n        typeable = false;\n        break;\n\n      case Token.NEW:\n        visitNew(t, n);\n        typeable = true;\n        break;\n\n      case Token.CALL:\n        visitCall(t, n);\n        typeable = !NodeUtil.isExpressionNode(parent);\n        break;\n\n      case Token.RETURN:\n        visitReturn(t, n);\n        typeable = false;\n        break;\n\n      case Token.DEC:\n      case Token.INC:\n        left = n.getFirstChild();\n        validator.expectNumber(\n            t, left, getJSType(left), \"increment/decrement\");\n        ensureTyped(t, n, NUMBER_TYPE);\n        break;\n\n      case Token.NOT:\n        ensureTyped(t, n, BOOLEAN_TYPE);\n        break;\n\n      case Token.VOID:\n        ensureTyped(t, n, VOID_TYPE);\n        break;\n\n      case Token.TYPEOF:\n        ensureTyped(t, n, STRING_TYPE);\n        break;\n\n      case Token.BITNOT:\n        childType = getJSType(n.getFirstChild());\n        if (!childType.matchesInt32Context()) {\n          report(t, n, BIT_OPERATION, NodeUtil.opToStr(n.getType()),\n              childType.toString());\n        }\n        ensureTyped(t, n, NUMBER_TYPE);\n        break;\n\n      case Token.POS:\n      case Token.NEG:\n        left = n.getFirstChild();\n        validator.expectNumber(t, left, getJSType(left), \"sign operator\");\n        ensureTyped(t, n, NUMBER_TYPE);\n        break;\n\n      case Token.EQ:\n      case Token.NE: {\n        leftType = getJSType(n.getFirstChild());\n        rightType = getJSType(n.getLastChild());\n\n        JSType leftTypeRestricted = leftType.restrictByNotNullOrUndefined();\n        JSType rightTypeRestricted = rightType.restrictByNotNullOrUndefined();\n        TernaryValue result =\n            leftTypeRestricted.testForEquality(rightTypeRestricted);\n        if (result != TernaryValue.UNKNOWN) {\n          if (n.getType() == Token.NE) {\n            result = result.not();\n          }\n          report(t, n, DETERMINISTIC_TEST, leftType.toString(),\n              rightType.toString(), result.toString());\n        }\n        ensureTyped(t, n, BOOLEAN_TYPE);\n        break;\n      }\n\n      case Token.SHEQ:\n      case Token.SHNE: {\n        leftType = getJSType(n.getFirstChild());\n        rightType = getJSType(n.getLastChild());\n\n        JSType leftTypeRestricted = leftType.restrictByNotNullOrUndefined();\n        JSType rightTypeRestricted = rightType.restrictByNotNullOrUndefined();\n        if (!leftTypeRestricted.canTestForShallowEqualityWith(\n                rightTypeRestricted)) {\n          report(t, n, DETERMINISTIC_TEST_NO_RESULT, leftType.toString(),\n              rightType.toString());\n        }\n        ensureTyped(t, n, BOOLEAN_TYPE);\n        break;\n      }\n\n      case Token.LT:\n      case Token.LE:\n      case Token.GT:\n      case Token.GE:\n        leftType = getJSType(n.getFirstChild());\n        rightType = getJSType(n.getLastChild());\n        if (rightType.isNumber()) {\n          validator.expectNumber(\n              t, n, leftType, \"left side of numeric comparison\");\n        } else if (leftType.isNumber()) {\n          validator.expectNumber(\n              t, n, rightType, \"right side of numeric comparison\");\n        } else if (leftType.matchesNumberContext() &&\n                   rightType.matchesNumberContext()) {\n          // OK.\n        } else {\n          // Whether the comparison is numeric will be determined at runtime\n          // each time the expression is evaluated. Regardless, both operands\n          // should match a string context.\n          String message = \"left side of comparison\";\n          validator.expectString(t, n, leftType, message);\n          validator.expectNotNullOrUndefined(\n              t, n, leftType, message, getNativeType(STRING_TYPE));\n          message = \"right side of comparison\";\n          validator.expectString(t, n, rightType, message);\n          validator.expectNotNullOrUndefined(\n              t, n, rightType, message, getNativeType(STRING_TYPE));\n        }\n        ensureTyped(t, n, BOOLEAN_TYPE);\n        break;\n\n      case Token.IN:\n        left = n.getFirstChild();\n        right = n.getLastChild();\n        leftType = getJSType(left);\n        rightType = getJSType(right);\n        validator.expectObject(t, n, rightType, \"'in' requires an object\");\n        validator.expectString(t, left, leftType, \"left side of 'in'\");\n        ensureTyped(t, n, BOOLEAN_TYPE);\n        break;\n\n      case Token.INSTANCEOF:\n        left = n.getFirstChild();\n        right = n.getLastChild();\n        leftType = getJSType(left);\n        rightType = getJSType(right).restrictByNotNullOrUndefined();\n\n        validator.expectAnyObject(\n            t, left, leftType, \"deterministic instanceof yields false\");\n        validator.expectActualObject(\n            t, right, rightType, \"instanceof requires an object\");\n        ensureTyped(t, n, BOOLEAN_TYPE);\n        break;\n\n      case Token.ASSIGN:\n        visitAssign(t, n);\n        typeable = false;\n        break;\n\n      case Token.ASSIGN_LSH:\n      case Token.ASSIGN_RSH:\n      case Token.ASSIGN_URSH:\n      case Token.ASSIGN_DIV:\n      case Token.ASSIGN_MOD:\n      case Token.ASSIGN_BITOR:\n      case Token.ASSIGN_BITXOR:\n      case Token.ASSIGN_BITAND:\n      case Token.ASSIGN_SUB:\n      case Token.ASSIGN_ADD:\n      case Token.ASSIGN_MUL:\n      case Token.LSH:\n      case Token.RSH:\n      case Token.URSH:\n      case Token.DIV:\n      case Token.MOD:\n      case Token.BITOR:\n      case Token.BITXOR:\n      case Token.BITAND:\n      case Token.SUB:\n      case Token.ADD:\n      case Token.MUL:\n        visitBinaryOperator(n.getType(), t, n);\n        break;\n\n      case Token.DELPROP:\n        ensureTyped(t, n, BOOLEAN_TYPE);\n        break;\n\n      case Token.CASE:\n        JSType switchType = getJSType(parent.getFirstChild());\n        JSType caseType = getJSType(n.getFirstChild());\n        validator.expectSwitchMatchesCase(t, n, switchType, caseType);\n        typeable = false;\n        break;\n\n      case Token.WITH: {\n        Node child = n.getFirstChild();\n        childType = getJSType(child);\n        validator.expectObject(\n            t, child, childType, \"with requires an object\");\n        typeable = false;\n        break;\n      }\n\n      case Token.FUNCTION:\n        visitFunction(t, n);\n        break;\n\n      // These nodes have no interesting type behavior.\n      case Token.LABEL:\n      case Token.LABEL_NAME:\n      case Token.SWITCH:\n      case Token.BREAK:\n      case Token.CATCH:\n      case Token.TRY:\n      case Token.SCRIPT:\n      case Token.EXPR_RESULT:\n      case Token.BLOCK:\n      case Token.EMPTY:\n      case Token.DEFAULT:\n      case Token.CONTINUE:\n      case Token.DEBUGGER:\n      case Token.THROW:\n        typeable = false;\n        break;\n\n      // These nodes require data flow analysis.\n      case Token.DO:\n      case Token.FOR:\n      case Token.IF:\n      case Token.WHILE:\n        typeable = false;\n        break;\n\n      // These nodes are typed during the type inference.\n      case Token.AND:\n      case Token.HOOK:\n      case Token.OBJECTLIT:\n      case Token.OR:\n        if (n.getJSType() != null) { // If we didn't run type inference.\n          ensureTyped(t, n);\n        } else {\n          // If this is an enum, then give that type to the objectlit as well.\n          if ((n.getType() == Token.OBJECTLIT)\n              && (parent.getJSType() instanceof EnumType)) {\n            ensureTyped(t, n, parent.getJSType());\n          } else {\n            ensureTyped(t, n);\n          }\n        }\n        if (n.getType() == Token.OBJECTLIT) {\n          for (Node key : n.children()) {\n            visitObjLitKey(t, key, n);\n          }\n        }\n        break;\n\n      default:\n        report(t, n, UNEXPECTED_TOKEN, Token.name(n.getType()));\n        ensureTyped(t, n);\n        break;\n    }\n\n    // Don't count externs since the user's code may not even use that part.\n    typeable = typeable && !inExterns;\n\n    if (typeable) {\n      doPercentTypedAccounting(t, n);\n    }\n\n    checkNoTypeCheckSection(n, false);\n  }",
    "comment": " This is the meat of the type checking.  It is basically one big switch, with each case representing one type of parse tree node.  The individual cases are usually pretty straightforward.  @param t The node traversal object that supplies context, such as the scope chain to use in name lookups as well as error reporting. @param n The node being visited. @param parent The parent of the node n. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "TypeCheck.visitAssign",
    "class_name": "com.google.javascript.jscomp.TypeCheck",
    "signature": "com.google.javascript.jscomp.TypeCheck.visitAssign(NodeTraversal,Node)",
    "snippet": "  private void visitAssign(NodeTraversal t, Node assign) {\n    JSDocInfo info = assign.getJSDocInfo();\n    Node lvalue = assign.getFirstChild();\n    Node rvalue = assign.getLastChild();\n\n    if (lvalue.getType() == Token.GETPROP) {\n      Node object = lvalue.getFirstChild();\n      JSType objectJsType = getJSType(object);\n      String property = lvalue.getLastChild().getString();\n\n      // the first name in this getprop refers to an interface\n      // we perform checks in addition to the ones below\n      if (object.getType() == Token.GETPROP) {\n        JSType jsType = getJSType(object.getFirstChild());\n        if (jsType.isInterface() &&\n            object.getLastChild().getString().equals(\"prototype\")) {\n          visitInterfaceGetprop(t, assign, object, property, lvalue, rvalue);\n        }\n      }\n\n      // /** @type ... */object.name = ...;\n      if (info != null && info.hasType()) {\n        visitAnnotatedAssignGetprop(t, assign,\n            info.getType().evaluate(t.getScope(), typeRegistry), object,\n            property, rvalue);\n        return;\n      }\n\n      // /** @enum ... */object.name = ...;\n      if (info != null && info.hasEnumParameterType()) {\n        checkEnumInitializer(\n            t, rvalue, info.getEnumParameterType().evaluate(\n                t.getScope(), typeRegistry));\n        return;\n      }\n\n      // object.prototype = ...;\n      if (property.equals(\"prototype\")) {\n        if (objectJsType instanceof FunctionType) {\n          FunctionType functionType = (FunctionType) objectJsType;\n          if (functionType.isConstructor()) {\n            JSType rvalueType = rvalue.getJSType();\n            validator.expectObject(t, rvalue, rvalueType,\n                OVERRIDING_PROTOTYPE_WITH_NON_OBJECT);\n          }\n        } else {\n          // TODO(user): might want to flag that\n        }\n        return;\n      }\n\n      // object.prototype.property = ...;\n      if (object.getType() == Token.GETPROP) {\n        Node object2 = object.getFirstChild();\n        String property2 = NodeUtil.getStringValue(object.getLastChild());\n\n        if (\"prototype\".equals(property2)) {\n          JSType jsType = object2.getJSType();\n          if (jsType instanceof FunctionType) {\n            FunctionType functionType = (FunctionType) jsType;\n            if (functionType.isConstructor() || functionType.isInterface()) {\n              checkDeclaredPropertyInheritance(\n                  t, assign, functionType, property, info, getJSType(rvalue));\n            }\n          } else {\n            // TODO(user): might want to flag that\n          }\n          return;\n        }\n      }\n\n      // object.property = ...;\n      ObjectType type = ObjectType.cast(\n          objectJsType.restrictByNotNullOrUndefined());\n      if (type != null) {\n        if (type.hasProperty(property) &&\n            !type.isPropertyTypeInferred(property) &&\n            !propertyIsImplicitCast(type, property)) {\n          validator.expectCanAssignToPropertyOf(\n              t, assign, getJSType(rvalue),\n              type.getPropertyType(property), object, property);\n        }\n        return;\n      }\n    } else if (lvalue.getType() == Token.NAME) {\n      // variable with inferred type case\n      JSType rvalueType = getJSType(assign.getLastChild());\n      Var var = t.getScope().getVar(lvalue.getString());\n      if (var != null) {\n        if (var.isTypeInferred()) {\n          return;\n        }\n      }\n    }\n\n    // fall through case\n    JSType leftType = getJSType(lvalue);\n    Node rightChild = assign.getLastChild();\n    JSType rightType = getJSType(rightChild);\n    if (validator.expectCanAssignTo(\n            t, assign, rightType, leftType, \"assignment\")) {\n      ensureTyped(t, assign, rightType);\n    } else {\n      ensureTyped(t, assign);\n    }\n  }",
    "comment": " Visits an assignment <code>lvalue = rvalue</code>. If the <code>lvalue</code> is a prototype modification, we change the schema of the object type it is referring to. @param t the traversal @param assign the assign node (<code>assign.getType() == Token.ASSIGN</code> is an implicit invariant) ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "TypeCheck.visitFunction",
    "class_name": "com.google.javascript.jscomp.TypeCheck",
    "signature": "com.google.javascript.jscomp.TypeCheck.visitFunction(NodeTraversal,Node)",
    "snippet": "  private void visitFunction(NodeTraversal t, Node n) {\n    FunctionType functionType = (FunctionType) n.getJSType();\n    String functionPrivateName = n.getFirstChild().getString();\n    if (functionType.isConstructor()) {\n      FunctionType baseConstructor = functionType.\n          getPrototype().getImplicitPrototype().getConstructor();\n      if (baseConstructor != null &&\n          baseConstructor != getNativeType(OBJECT_FUNCTION_TYPE) &&\n          (baseConstructor.isInterface() && functionType.isConstructor())) {\n        compiler.report(\n            t.makeError(n, CONFLICTING_EXTENDED_TYPE, functionPrivateName));\n      } else {\n        // All interfaces are properly implemented by a class\n        for (JSType baseInterface : functionType.getImplementedInterfaces()) {\n          boolean badImplementedType = false;\n          ObjectType baseInterfaceObj = ObjectType.cast(baseInterface);\n          if (baseInterfaceObj != null) {\n            FunctionType interfaceConstructor =\n              baseInterfaceObj.getConstructor();\n            if (interfaceConstructor != null &&\n                !interfaceConstructor.isInterface()) {\n              badImplementedType = true;\n            }\n          } else {\n            badImplementedType = true;\n          }\n          if (badImplementedType) {\n            report(t, n, BAD_IMPLEMENTED_TYPE, functionPrivateName);\n          }\n        }\n        // check properties\n        validator.expectAllInterfaceProperties(t, n, functionType);\n      }\n    } else if (functionType.isInterface()) {\n      // Interface must extend only interfaces\n      for (ObjectType extInterface : functionType.getExtendedInterfaces()) {\n        if (extInterface.getConstructor() != null\n            && !extInterface.getConstructor().isInterface()) {\n          compiler.report(\n              t.makeError(n, CONFLICTING_EXTENDED_TYPE, functionPrivateName));\n        }\n      }\n      // Interface cannot implement any interfaces\n      if (functionType.hasImplementedInterfaces()) {\n        compiler.report(t.makeError(n,\n            CONFLICTING_IMPLEMENTED_TYPE, functionPrivateName));\n      }\n      // Check whether the extended interfaces have any conflicts\n      if (functionType.getExtendedInterfacesCount() > 1) {\n        // Only check when extending more than one interfaces\n        HashMap<String, ObjectType> properties\n            = new HashMap<String, ObjectType>();\n        HashMap<String, ObjectType> currentProperties\n            = new HashMap<String, ObjectType>();\n        for (ObjectType interfaceType : functionType.getExtendedInterfaces()) {\n          currentProperties.clear();\n          checkInterfaceConflictProperties(t, n, functionPrivateName,\n              properties, currentProperties, interfaceType);\n          properties.putAll(currentProperties);\n        }\n      }\n    }\n  }",
    "comment": " Visits a {@link Token#FUNCTION} node.  @param t The node traversal object that supplies context, such as the scope chain to use in name lookups as well as error reporting. @param n The node being visited. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "TypeCheck.visitGetProp",
    "class_name": "com.google.javascript.jscomp.TypeCheck",
    "signature": "com.google.javascript.jscomp.TypeCheck.visitGetProp(NodeTraversal,Node,Node)",
    "snippet": "  private void visitGetProp(NodeTraversal t, Node n, Node parent) {\n    // GETPROP nodes have an assigned type on their node by the scope creator\n    // if this is an enum declaration. The only namespaced enum declarations\n    // that we allow are of the form object.name = ...;\n    if (n.getJSType() != null && parent.getType() == Token.ASSIGN) {\n      return;\n    }\n\n    // obj.prop or obj.method()\n    // Lots of types can appear on the left, a call to a void function can\n    // never be on the left. getPropertyType will decide what is acceptable\n    // and what isn't.\n    Node property = n.getLastChild();\n    Node objNode = n.getFirstChild();\n    JSType childType = getJSType(objNode);\n\n    // TODO(user): remove in favor of flagging every property access on\n    // non-object.\n    if (!validator.expectNotNullOrUndefined(t, n, childType,\n            childType + \" has no properties\", getNativeType(OBJECT_TYPE))) {\n      ensureTyped(t, n);\n      return;\n    }\n\n    checkPropertyAccess(childType, property.getString(), t, n);\n    ensureTyped(t, n);\n  }",
    "comment": " Visits a GETPROP node.  @param t The node traversal object that supplies context, such as the scope chain to use in name lookups as well as error reporting. @param n The node being visited. @param parent The parent of <code>n</code> ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "TypeCheck.visitName",
    "class_name": "com.google.javascript.jscomp.TypeCheck",
    "signature": "com.google.javascript.jscomp.TypeCheck.visitName(NodeTraversal,Node,Node)",
    "snippet": "  boolean visitName(NodeTraversal t, Node n, Node parent) {\n    // At this stage, we need to determine whether this is a leaf\n    // node in an expression (which therefore needs to have a type\n    // assigned for it) versus some other decorative node that we\n    // can safely ignore.  Function names, arguments (children of LP nodes) and\n    // variable declarations are ignored.\n    // TODO(user): remove this short-circuiting in favor of a\n    // pre order traversal of the FUNCTION, CATCH, LP and VAR nodes.\n    int parentNodeType = parent.getType();\n    if (parentNodeType == Token.FUNCTION ||\n        parentNodeType == Token.CATCH ||\n        parentNodeType == Token.LP ||\n        parentNodeType == Token.VAR) {\n      return false;\n    }\n\n    JSType type = n.getJSType();\n    if (type == null) {\n      type = getNativeType(UNKNOWN_TYPE);\n      Var var = t.getScope().getVar(n.getString());\n      if (var != null) {\n        JSType varType = var.getType();\n        if (varType != null) {\n          type = varType;\n        }\n      }\n    }\n    ensureTyped(t, n, type);\n    return true;\n  }",
    "comment": " Visits a NAME node.  @param t The node traversal object that supplies context, such as the scope chain to use in name lookups as well as error reporting. @param n The node being visited. @param parent The parent of the node n. @return whether the node is typeable or not ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "TypeCheck.visitVar",
    "class_name": "com.google.javascript.jscomp.TypeCheck",
    "signature": "com.google.javascript.jscomp.TypeCheck.visitVar(NodeTraversal,Node)",
    "snippet": "  private void visitVar(NodeTraversal t, Node n) {\n    // TODO(nicksantos): Fix this so that the doc info always shows up\n    // on the NAME node. We probably want to wait for the parser\n    // merge to fix this.\n    JSDocInfo varInfo = n.hasOneChild() ? n.getJSDocInfo() : null;\n    for (Node name : n.children()) {\n      Node value = name.getFirstChild();\n      // A null var would indicate a bug in the scope creation logic.\n      Var var = t.getScope().getVar(name.getString());\n\n      if (value != null) {\n        JSType valueType = getJSType(value);\n        JSType nameType = var.getType();\n        nameType = (nameType == null) ? getNativeType(UNKNOWN_TYPE) : nameType;\n\n        JSDocInfo info = name.getJSDocInfo();\n        if (info == null) {\n          info = varInfo;\n        }\n        if (info != null && info.hasEnumParameterType()) {\n          // var.getType() can never be null, this would indicate a bug in the\n          // scope creation logic.\n          checkEnumInitializer(\n              t, value,\n              info.getEnumParameterType().evaluate(t.getScope(), typeRegistry));\n        } else if (var.isTypeInferred()) {\n          ensureTyped(t, name, valueType);\n        } else {\n          validator.expectCanAssignTo(\n              t, value, valueType, nameType, \"initializing variable\");\n        }\n      }\n    }\n  }",
    "comment": " Visits a VAR node.  @param t The node traversal object that supplies context, such as the scope chain to use in name lookups as well as error reporting. @param n The node being visited. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "TypeInference.TypeInference",
    "class_name": "com.google.javascript.jscomp.TypeInference",
    "signature": "com.google.javascript.jscomp.TypeInference.TypeInference(AbstractCompiler,ControlFlowGraph,ReverseAbstractInterpreter,Scope,Map,Collection)",
    "snippet": "  TypeInference(AbstractCompiler compiler, ControlFlowGraph<Node> cfg,\n                ReverseAbstractInterpreter reverseInterpreter,\n                Scope functionScope,\n                Map<String, AssertionFunctionSpec> assertionFunctionsMap,\n                Collection<Var> unflowableVars) {\n    super(cfg, new LinkedFlowScope.FlowScopeJoinOp());\n    this.compiler = compiler;\n    this.registry = compiler.getTypeRegistry();\n    this.reverseInterpreter = reverseInterpreter;\n    this.syntacticScope = functionScope;\n    this.functionScope = LinkedFlowScope.createEntryLattice(functionScope);\n    this.assertionFunctionsMap = assertionFunctionsMap;\n\n    for (Var unflowableVar : unflowableVars) {\n      String name = unflowableVar.getName();\n      if (functionScope.getVar(name) == unflowableVar) {\n        this.unflowableVarNames.add(name);\n      }\n    }\n\n    // For each local variable declared with the VAR keyword, the entry\n    // type is VOID.\n    Iterator<Var> varIt =\n        functionScope.getDeclarativelyUnboundVarsWithoutTypes();\n    while (varIt.hasNext()) {\n      Var var = varIt.next();\n      if (this.unflowableVarNames.contains(var.getName())) {\n        continue;\n      }\n\n      this.functionScope.inferSlotType(\n          var.getName(), getNativeType(VOID_TYPE));\n    }\n\n    this.bottomScope = LinkedFlowScope.createEntryLattice(\n        new Scope(functionScope.getRootNode(), functionScope.getTypeOfThis()));\n  }",
    "comment": "TODO(nicksantos): Create a builder for this class.",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "TypeInference.branchedFlowThrough",
    "class_name": "com.google.javascript.jscomp.TypeInference",
    "signature": "com.google.javascript.jscomp.TypeInference.branchedFlowThrough(Node,FlowScope)",
    "snippet": "  @Override\n  @SuppressWarnings(\"fallthrough\")\n  List<FlowScope> branchedFlowThrough(Node source, FlowScope input) {\n    // NOTE(nicksantos): Right now, we just treat ON_EX edges like UNCOND\n    // edges. If we wanted to be perfect, we'd actually JOIN all the out\n    // lattices of this flow with the in lattice, and then make that the out\n    // lattice for the ON_EX edge. But it's probably to expensive to be\n    // worthwhile.\n    FlowScope output = flowThrough(source, input);\n    Node condition = null;\n    FlowScope conditionFlowScope = null;\n    BooleanOutcomePair conditionOutcomes = null;\n\n    List<DiGraphEdge<Node, Branch>> branchEdges = getCfg().getOutEdges(source);\n    List<FlowScope> result = Lists.newArrayListWithCapacity(branchEdges.size());\n    for (DiGraphEdge<Node, Branch> branchEdge : branchEdges) {\n      Branch branch = branchEdge.getValue();\n      FlowScope newScope = output;\n\n      switch (branch) {\n        case ON_TRUE:\n          if (NodeUtil.isForIn(source)) {\n            // item is assigned a property name, so its type should be string.\n            Node item = source.getFirstChild();\n            Node obj = item.getNext();\n\n            FlowScope informed = traverse(obj, output.createChildFlowScope());\n\n            if (item.getType() == Token.VAR) {\n              item = item.getFirstChild();\n            }\n            if (item.getType() == Token.NAME) {\n              JSType iterKeyType = getNativeType(STRING_TYPE);\n              ObjectType objType = getJSType(obj).dereference();\n              JSType objIndexType = objType == null ?\n                  null : objType.getIndexType();\n              if (objIndexType != null && !objIndexType.isUnknownType()) {\n                JSType narrowedKeyType =\n                    iterKeyType.getGreatestSubtype(objIndexType);\n                if (!narrowedKeyType.isEmptyType()) {\n                  iterKeyType = narrowedKeyType;\n                }\n              }\n              redeclareSimpleVar(informed, item, iterKeyType);\n            }\n            newScope = informed;\n            break;\n          }\n\n          // FALL THROUGH\n\n        case ON_FALSE:\n          if (condition == null) {\n            condition = NodeUtil.getConditionExpression(source);\n            if (condition == null && source.getType() == Token.CASE) {\n              condition = source;\n\n              // conditionFlowScope is cached from previous iterations\n              // of the loop.\n              if (conditionFlowScope == null) {\n                conditionFlowScope = traverse(\n                    condition.getFirstChild(), output.createChildFlowScope());\n              }\n            }\n          }\n\n          if (condition != null) {\n            if (condition.getType() == Token.AND ||\n                condition.getType() == Token.OR) {\n              // When handling the short-circuiting binary operators,\n              // the outcome scope on true can be different than the outcome\n              // scope on false.\n              //\n              // TODO(nicksantos): The \"right\" way to do this is to\n              // carry the known outcome all the way through the\n              // recursive traversal, so that we can construct a\n              // different flow scope based on the outcome. However,\n              // this would require a bunch of code and a bunch of\n              // extra computation for an edge case. This seems to be\n              // a \"good enough\" approximation.\n\n              // conditionOutcomes is cached from previous iterations\n              // of the loop.\n              if (conditionOutcomes == null) {\n                conditionOutcomes = condition.getType() == Token.AND ?\n                    traverseAnd(condition, output.createChildFlowScope()) :\n                    traverseOr(condition, output.createChildFlowScope());\n              }\n              newScope =\n                  reverseInterpreter.getPreciserScopeKnowingConditionOutcome(\n                      condition,\n                      conditionOutcomes.getOutcomeFlowScope(\n                          condition.getType(), branch == Branch.ON_TRUE),\n                      branch == Branch.ON_TRUE);\n            } else {\n              // conditionFlowScope is cached from previous iterations\n              // of the loop.\n              if (conditionFlowScope == null) {\n                conditionFlowScope =\n                    traverse(condition, output.createChildFlowScope());\n              }\n              newScope =\n                  reverseInterpreter.getPreciserScopeKnowingConditionOutcome(\n                      condition, conditionFlowScope, branch == Branch.ON_TRUE);\n            }\n          }\n          break;\n      }\n\n      result.add(newScope.optimize());\n    }\n    return result;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "TypeInference.createEntryLattice",
    "class_name": "com.google.javascript.jscomp.TypeInference",
    "signature": "com.google.javascript.jscomp.TypeInference.createEntryLattice()",
    "snippet": "  @Override\n  FlowScope createEntryLattice() {\n    return functionScope;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "TypeInference.createInitialEstimateLattice",
    "class_name": "com.google.javascript.jscomp.TypeInference",
    "signature": "com.google.javascript.jscomp.TypeInference.createInitialEstimateLattice()",
    "snippet": "  @Override\n  FlowScope createInitialEstimateLattice() {\n    return bottomScope;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "TypeInference.dereferencePointer",
    "class_name": "com.google.javascript.jscomp.TypeInference",
    "signature": "com.google.javascript.jscomp.TypeInference.dereferencePointer(Node,FlowScope)",
    "snippet": "  private FlowScope dereferencePointer(Node n, FlowScope scope) {\n    if (n.isQualifiedName()) {\n      JSType type = getJSType(n);\n      JSType narrowed = type.restrictByNotNullOrUndefined();\n      if (type != narrowed) {\n        scope = narrowScope(scope, n, narrowed);\n      }\n    }\n    return scope;\n  }",
    "comment": " If we access a property of a symbol, then that symbol is not null or undefined. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "TypeInference.ensurePropertyDeclared",
    "class_name": "com.google.javascript.jscomp.TypeInference",
    "signature": "com.google.javascript.jscomp.TypeInference.ensurePropertyDeclared(Node)",
    "snippet": "  private void ensurePropertyDeclared(Node getprop) {\n    ObjectType ownerType = ObjectType.cast(\n        getJSType(getprop.getFirstChild()).restrictByNotNullOrUndefined());\n    if (ownerType != null) {\n      ensurePropertyDeclaredHelper(getprop, ownerType);\n    }\n  }",
    "comment": " Defines a declared property if it has not been defined yet.  This handles the case where a property is declared on an object where the object type is inferred, and so the object type will not be known in {@code TypedScopeCreator}. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "TypeInference.ensurePropertyDeclaredHelper",
    "class_name": "com.google.javascript.jscomp.TypeInference",
    "signature": "com.google.javascript.jscomp.TypeInference.ensurePropertyDeclaredHelper(Node,ObjectType)",
    "snippet": "  private boolean ensurePropertyDeclaredHelper(\n      Node getprop, ObjectType objectType) {\n    String propName = getprop.getLastChild().getString();\n    String qName = getprop.getQualifiedName();\n    if (qName != null) {\n      Var var = syntacticScope.getVar(qName);\n      if (var != null && !var.isTypeInferred()) {\n        // Handle normal declarations that could not be addressed earlier.\n        if (propName.equals(\"prototype\") ||\n        // Handle prototype declarations that could not be addressed earlier.\n            (!objectType.hasOwnProperty(propName) &&\n             (!objectType.isInstanceType() ||\n                 (var.isExtern() && !objectType.isNativeObjectType())))) {\n          return objectType.defineDeclaredProperty(\n              propName, var.getType(), getprop);\n        }\n      }\n    }\n    return false;\n  }",
    "comment": " Declares a property on its owner, if necessary. @return True if a property was declared. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "TypeInference.ensurePropertyDefined",
    "class_name": "com.google.javascript.jscomp.TypeInference",
    "signature": "com.google.javascript.jscomp.TypeInference.ensurePropertyDefined(Node,JSType)",
    "snippet": "  private void ensurePropertyDefined(Node getprop, JSType rightType) {\n    String propName = getprop.getLastChild().getString();\n    JSType nodeType = getJSType(getprop.getFirstChild());\n    ObjectType objectType = ObjectType.cast(\n        nodeType.restrictByNotNullOrUndefined());\n    if (objectType == null) {\n      registry.registerPropertyOnType(propName, nodeType);\n    } else {\n      if (ensurePropertyDeclaredHelper(getprop, objectType)) {\n        return;\n      }\n\n      if (!objectType.isPropertyTypeDeclared(propName)) {\n        // We do not want a \"stray\" assign to define an inferred property\n        // for every object of this type in the program. So we use a heuristic\n        // approach to determine whether to infer the propery.\n        //\n        // 1) If the property is already defined, join it with the previously\n        //    inferred type.\n        // 2) If this isn't an instance object, define it.\n        // 3) If the property of an object is being assigned in the constructor,\n        //    define it.\n        // 4) If this is a stub, define it.\n        // 5) Otherwise, do not define the type, but declare it in the registry\n        //    so that we can use it for missing property checks.\n        if (objectType.hasProperty(propName) ||\n            !objectType.isInstanceType()) {\n          if (\"prototype\".equals(propName)) {\n            objectType.defineDeclaredProperty(\n                propName, rightType, getprop);\n          } else {\n            objectType.defineInferredProperty(\n                propName, rightType, getprop);\n          }\n        } else {\n          if (getprop.getFirstChild().getType() == Token.THIS &&\n              getJSType(syntacticScope.getRootNode()).isConstructor()) {\n            objectType.defineInferredProperty(\n                propName, rightType, getprop);\n          } else {\n            registry.registerPropertyOnType(propName, objectType);\n          }\n        }\n      }\n    }\n  }",
    "comment": " Defines a property if the property has not been defined yet. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "TypeInference.flowThrough",
    "class_name": "com.google.javascript.jscomp.TypeInference",
    "signature": "com.google.javascript.jscomp.TypeInference.flowThrough(Node,FlowScope)",
    "snippet": "  @Override\n  FlowScope flowThrough(Node n, FlowScope input) {\n    // If we have not walked a path from <entry> to <n>, then we don't\n    // want to infer anything about this scope.\n    if (input == bottomScope) {\n      return input;\n    }\n\n    FlowScope output = input.createChildFlowScope();\n    output = traverse(n, output);\n    return output;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "TypeInference.getAssignedOuterLocalVars",
    "class_name": "com.google.javascript.jscomp.TypeInference",
    "signature": "com.google.javascript.jscomp.TypeInference.getAssignedOuterLocalVars()",
    "snippet": "  Multimap<Scope, Var> getAssignedOuterLocalVars() {\n    return assignedOuterLocalVars;\n  }",
    "comment": " @return Local variables assigned in this scope, but which are declared in a scope outside of it. Hashed by the scope they're declared in. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "TypeInference.getJSType",
    "class_name": "com.google.javascript.jscomp.TypeInference",
    "signature": "com.google.javascript.jscomp.TypeInference.getJSType(Node)",
    "snippet": "  private JSType getJSType(Node n) {\n    JSType jsType = n.getJSType();\n    if (jsType == null) {\n      // TODO(nicksantos): This branch indicates a compiler bug, not worthy of\n      // halting the compilation but we should log this and analyze to track\n      // down why it happens. This is not critical and will be resolved over\n      // time as the type checker is extended.\n      return getNativeType(UNKNOWN_TYPE);\n    } else {\n      return jsType;\n    }\n  }",
    "comment": " This method gets the JSType from the Node argument and verifies that it is present. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "TypeInference.getNativeType",
    "class_name": "com.google.javascript.jscomp.TypeInference",
    "signature": "com.google.javascript.jscomp.TypeInference.getNativeType(JSTypeNative)",
    "snippet": "  private JSType getNativeType(JSTypeNative typeId) {\n    return registry.getNativeType(typeId);\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "TypeInference.getPropertyType",
    "class_name": "com.google.javascript.jscomp.TypeInference",
    "signature": "com.google.javascript.jscomp.TypeInference.getPropertyType(JSType,String,Node,FlowScope)",
    "snippet": "  private JSType getPropertyType(JSType objType, String propName,\n      Node n, FlowScope scope) {\n    // Scopes sometimes contain inferred type info about qualified names.\n    String qualifiedName = n.getQualifiedName();\n    StaticSlot<JSType> var = scope.getSlot(qualifiedName);\n    if (var != null) {\n      JSType varType = var.getType();\n      if (varType != null) {\n        if (varType.equals(getNativeType(UNKNOWN_TYPE)) &&\n            var != syntacticScope.getSlot(qualifiedName)) {\n          // If the type of this qualified name has been checked in this scope,\n          // then use CHECKED_UNKNOWN_TYPE instead to indicate that.\n          return getNativeType(CHECKED_UNKNOWN_TYPE);\n        } else {\n          return varType;\n        }\n      }\n    }\n\n    JSType propertyType = null;\n    if (objType != null) {\n      propertyType = objType.findPropertyType(propName);\n    }\n\n    if ((propertyType == null || propertyType.isUnknownType()) &&\n        qualifiedName != null) {\n      // If we find this node in the registry, then we can infer its type.\n      ObjectType regType = ObjectType.cast(registry.getType(qualifiedName));\n      if (regType != null) {\n        propertyType = regType.getConstructor();\n      }\n    }\n\n    return propertyType;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "TypeInference.traverse",
    "class_name": "com.google.javascript.jscomp.TypeInference",
    "signature": "com.google.javascript.jscomp.TypeInference.traverse(Node,FlowScope)",
    "snippet": "  private FlowScope traverse(Node n, FlowScope scope) {\n    switch (n.getType()) {\n      case Token.ASSIGN:\n        scope = traverseAssign(n, scope);\n        break;\n\n      case Token.NAME:\n        scope = traverseName(n, scope);\n        break;\n\n      case Token.GETPROP:\n        scope = traverseGetProp(n, scope);\n        break;\n\n      case Token.AND:\n        scope = traverseAnd(n, scope).getJoinedFlowScope()\n            .createChildFlowScope();\n        break;\n\n      case Token.OR:\n        scope = traverseOr(n, scope).getJoinedFlowScope()\n            .createChildFlowScope();\n        break;\n\n      case Token.HOOK:\n        scope = traverseHook(n, scope);\n        break;\n\n      case Token.OBJECTLIT:\n        scope = traverseObjectLiteral(n, scope);\n        break;\n\n      case Token.CALL:\n        scope = traverseCall(n, scope);\n        break;\n\n      case Token.NEW:\n        scope = traverseNew(n, scope);\n        break;\n\n      case Token.ASSIGN_ADD:\n      case Token.ADD:\n        scope = traverseAdd(n, scope);\n        break;\n\n      case Token.POS:\n      case Token.NEG:\n        scope = traverse(n.getFirstChild(), scope);  // Find types.\n        n.setJSType(getNativeType(NUMBER_TYPE));\n        break;\n\n      case Token.ARRAYLIT:\n        scope = traverseArrayLiteral(n, scope);\n        break;\n\n      case Token.THIS:\n        n.setJSType(scope.getTypeOfThis());\n        break;\n\n      case Token.ASSIGN_LSH:\n      case Token.ASSIGN_RSH:\n      case Token.LSH:\n      case Token.RSH:\n      case Token.ASSIGN_URSH:\n      case Token.URSH:\n      case Token.ASSIGN_DIV:\n      case Token.ASSIGN_MOD:\n      case Token.ASSIGN_BITAND:\n      case Token.ASSIGN_BITXOR:\n      case Token.ASSIGN_BITOR:\n      case Token.ASSIGN_MUL:\n      case Token.ASSIGN_SUB:\n      case Token.DIV:\n      case Token.MOD:\n      case Token.BITAND:\n      case Token.BITXOR:\n      case Token.BITOR:\n      case Token.MUL:\n      case Token.SUB:\n      case Token.DEC:\n      case Token.INC:\n      case Token.BITNOT:\n        scope = traverseChildren(n, scope);\n        n.setJSType(getNativeType(NUMBER_TYPE));\n        break;\n\n      case Token.LP:\n      case Token.GET_REF:\n        scope = traverse(n.getFirstChild(), scope);\n        n.setJSType(getJSType(n.getFirstChild()));\n        break;\n\n      case Token.COMMA:\n        scope = traverseChildren(n, scope);\n        n.setJSType(getJSType(n.getLastChild()));\n        break;\n\n      case Token.TYPEOF:\n        scope = traverseChildren(n, scope);\n        n.setJSType(getNativeType(STRING_TYPE));\n        break;\n\n      case Token.DELPROP:\n      case Token.LT:\n      case Token.LE:\n      case Token.GT:\n      case Token.GE:\n      case Token.NOT:\n      case Token.EQ:\n      case Token.NE:\n      case Token.SHEQ:\n      case Token.SHNE:\n      case Token.INSTANCEOF:\n      case Token.IN:\n        scope = traverseChildren(n, scope);\n        n.setJSType(getNativeType(BOOLEAN_TYPE));\n        break;\n\n      case Token.GETELEM:\n        scope = traverseGetElem(n, scope);\n        break;\n\n      case Token.EXPR_RESULT:\n        scope = traverseChildren(n, scope);\n        if (n.getFirstChild().getType() == Token.GETPROP) {\n          ensurePropertyDeclared(n.getFirstChild());\n        }\n        break;\n\n      case Token.SWITCH:\n        scope = traverse(n.getFirstChild(), scope);\n        break;\n\n      case Token.VAR:\n      case Token.RETURN:\n      case Token.THROW:\n        scope = traverseChildren(n, scope);\n        break;\n\n      case Token.CATCH:\n        scope = traverseCatch(n, scope);\n        break;\n    }\n    if (n.getType() != Token.FUNCTION) {\n      JSDocInfo info = n.getJSDocInfo();\n      if (info != null && info.hasType()) {\n        JSType castType = info.getType().evaluate(syntacticScope, registry);\n\n        // A stubbed type cast on a qualified name should take\n        // effect for all subsequent accesses of that name,\n        // so treat it the same as an assign to that name.\n        if (n.isQualifiedName() &&\n            n.getParent().getType() == Token.EXPR_RESULT) {\n          updateScopeForTypeChange(scope, n, n.getJSType(), castType);\n        }\n\n        n.setJSType(castType);\n      }\n    }\n\n    return scope;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "TypeInference.traverseAssign",
    "class_name": "com.google.javascript.jscomp.TypeInference",
    "signature": "com.google.javascript.jscomp.TypeInference.traverseAssign(Node,FlowScope)",
    "snippet": "  private FlowScope traverseAssign(Node n, FlowScope scope) {\n    Node left = n.getFirstChild();\n    Node right = n.getLastChild();\n    scope = traverseChildren(n, scope);\n\n    JSType leftType = left.getJSType();\n    JSType rightType = getJSType(right);\n    n.setJSType(rightType);\n\n    updateScopeForTypeChange(scope, left, leftType, rightType);\n    return scope;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "TypeInference.traverseChildren",
    "class_name": "com.google.javascript.jscomp.TypeInference",
    "signature": "com.google.javascript.jscomp.TypeInference.traverseChildren(Node,FlowScope)",
    "snippet": "  private FlowScope traverseChildren(Node n, FlowScope scope) {\n    for (Node el = n.getFirstChild(); el != null; el = el.getNext()) {\n      scope = traverse(el, scope);\n    }\n    return scope;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "TypeInference.traverseGetProp",
    "class_name": "com.google.javascript.jscomp.TypeInference",
    "signature": "com.google.javascript.jscomp.TypeInference.traverseGetProp(Node,FlowScope)",
    "snippet": "  private FlowScope traverseGetProp(Node n, FlowScope scope) {\n    Node objNode = n.getFirstChild();\n    Node property = n.getLastChild();\n    scope = traverseChildren(n, scope);\n    n.setJSType(\n        getPropertyType(\n            objNode.getJSType(), property.getString(), n, scope));\n    return dereferencePointer(n.getFirstChild(), scope);\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "TypeInference.traverseName",
    "class_name": "com.google.javascript.jscomp.TypeInference",
    "signature": "com.google.javascript.jscomp.TypeInference.traverseName(Node,FlowScope)",
    "snippet": "  private FlowScope traverseName(Node n, FlowScope scope) {\n    String varName = n.getString();\n    Node value = n.getFirstChild();\n    JSType type = n.getJSType();\n    if (value != null) {\n      scope = traverse(value, scope);\n      updateScopeForTypeChange(scope, n, n.getJSType() /* could be null */,\n          getJSType(value));\n      return scope;\n    } else {\n      StaticSlot<JSType> var = scope.getSlot(varName);\n      if (var != null) {\n        // There are two situations where we don't want to use type information\n        // from the scope, even if we have it.\n\n        // 1) The var is escaped in a weird way, e.g.,\n        // function f() { var x = 3; function g() { x = null } (x); }\n        boolean isInferred = var.isTypeInferred();\n        boolean unflowable =\n            isInferred && unflowableVarNames.contains(varName);\n\n        // 2) We're reading type information from another scope for an\n        // inferred variable.\n        // var t = null; function f() { (t); }\n        boolean nonLocalInferredSlot =\n            isInferred &&\n            syntacticScope.getParent() != null &&\n            var == syntacticScope.getParent().getSlot(varName);\n\n        if (!unflowable && !nonLocalInferredSlot) {\n          type = var.getType();\n          if (type == null) {\n            type = getNativeType(UNKNOWN_TYPE);\n          }\n        }\n      }\n    }\n    n.setJSType(type);\n    return scope;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "TypeInference.updateScopeForTypeChange",
    "class_name": "com.google.javascript.jscomp.TypeInference",
    "signature": "com.google.javascript.jscomp.TypeInference.updateScopeForTypeChange(FlowScope,Node,JSType,JSType)",
    "snippet": "  private void updateScopeForTypeChange(\n      FlowScope scope, Node left, JSType leftType, JSType resultType) {\n    Preconditions.checkNotNull(resultType);\n    switch (left.getType()) {\n      case Token.NAME:\n        String varName = left.getString();\n        Var var = syntacticScope.getVar(varName);\n        if (var != null && var.isLocal() && var.getScope() != syntacticScope) {\n          assignedOuterLocalVars.put(var.getScope(), var);\n        }\n\n        // When looking at VAR initializers for declared VARs, we trust\n        // the declared type over the type it's being initialized to.\n        // This has two purposes:\n        // 1) We avoid re-declaring declared variables so that built-in\n        //    types defined in externs are not redeclared.\n        // 2) When there's a lexical closure like\n        //    /** @type {?string} */ var x = null;\n        //    function f() { x = 'xyz'; }\n        //    the inference will ignore the lexical closure,\n        //    which is just wrong. This bug needs to be fixed eventually.\n        boolean isVarDeclaration = left.hasChildren();\n        if (!isVarDeclaration || var == null || var.isTypeInferred()) {\n          redeclareSimpleVar(scope, left, resultType);\n        }\n        left.setJSType(isVarDeclaration || leftType == null ?\n            resultType : null);\n\n        if (var != null && var.isTypeInferred()) {\n          JSType oldType = var.getType();\n          var.setType(oldType == null ?\n              resultType : oldType.getLeastSupertype(resultType));\n        }\n        break;\n      case Token.GETPROP:\n        String qualifiedName = left.getQualifiedName();\n        if (qualifiedName != null) {\n          scope.inferQualifiedSlot(qualifiedName,\n              leftType == null ? getNativeType(UNKNOWN_TYPE) : leftType,\n              resultType);\n        }\n\n        left.setJSType(resultType);\n        ensurePropertyDefined(left, resultType);\n        break;\n    }\n  }",
    "comment": " Updates the scope according to the result of a type change, like an assignment or a type cast. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "TypeInferencePass.TypeInferencePass",
    "class_name": "com.google.javascript.jscomp.TypeInferencePass",
    "signature": "com.google.javascript.jscomp.TypeInferencePass.TypeInferencePass(AbstractCompiler,ReverseAbstractInterpreter,Scope,ScopeCreator)",
    "snippet": "  TypeInferencePass(AbstractCompiler compiler,\n      ReverseAbstractInterpreter reverseInterpreter,\n      Scope topScope, ScopeCreator scopeCreator) {\n    this.compiler = compiler;\n    this.reverseInterpreter = reverseInterpreter;\n    this.topScope = topScope;\n    this.scopeCreator = scopeCreator;\n\n    assertionFunctionsMap = Maps.newHashMap();\n    for (AssertionFunctionSpec assertionFucntion :\n        compiler.getCodingConvention().getAssertionFunctions()) {\n      assertionFunctionsMap.put(assertionFucntion.getFunctionName(),\n          assertionFucntion);\n    }\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "TypeInferencePass.computeCfg",
    "class_name": "com.google.javascript.jscomp.TypeInferencePass",
    "signature": "com.google.javascript.jscomp.TypeInferencePass.computeCfg(Node)",
    "snippet": "  private ControlFlowGraph<Node> computeCfg(Node n) {\n    ControlFlowAnalysis cfa = new ControlFlowAnalysis(compiler, false, false);\n    cfa.process(null, n);\n    return cfa.getCfg();\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "TypeInferencePass.getUnflowableVars",
    "class_name": "com.google.javascript.jscomp.TypeInferencePass",
    "signature": "com.google.javascript.jscomp.TypeInferencePass.getUnflowableVars(Scope)",
    "snippet": "  private Collection<Var> getUnflowableVars(Scope scope) {\n    List<Var> vars = Lists.newArrayList();\n    for (Scope current = scope;\n         current.isLocal(); current = current.getParent()) {\n      vars.addAll(escapedLocalVars.get(current));\n    }\n    return vars;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "TypeInferencePass.inferTypes",
    "class_name": "com.google.javascript.jscomp.TypeInferencePass",
    "signature": "com.google.javascript.jscomp.TypeInferencePass.inferTypes(Node)",
    "snippet": "  void inferTypes(Node node) {\n    NodeTraversal inferTypes = new NodeTraversal(\n        compiler, new TypeInferringCallback(), scopeCreator);\n    inferTypes.traverseWithScope(node, topScope);\n  }",
    "comment": "Entry point for type inference when running over part of the tree. */",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "TypeInferencePass.inferTypes",
    "class_name": "com.google.javascript.jscomp.TypeInferencePass",
    "signature": "com.google.javascript.jscomp.TypeInferencePass.inferTypes(NodeTraversal,Node,Scope)",
    "snippet": "  void inferTypes(NodeTraversal t, Node n, Scope scope) {\n    TypeInference typeInference =\n        new TypeInference(\n            compiler, computeCfg(n), reverseInterpreter, scope,\n            assertionFunctionsMap, getUnflowableVars(scope));\n    try {\n      typeInference.analyze();\n      escapedLocalVars.putAll(typeInference.getAssignedOuterLocalVars());\n\n      // Resolve any new type names found during the inference.\n      compiler.getTypeRegistry().resolveTypesInScope(scope);\n\n    } catch (DataFlowAnalysis.MaxIterationsExceededException e) {\n      compiler.report(t.makeError(n, DATAFLOW_ERROR));\n    }\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "TypeInferencePass.process",
    "class_name": "com.google.javascript.jscomp.TypeInferencePass",
    "signature": "com.google.javascript.jscomp.TypeInferencePass.process(Node,Node)",
    "snippet": "  public void process(Node externsRoot, Node jsRoot) {\n    Node externsAndJs = jsRoot.getParent();\n    Preconditions.checkState(externsAndJs != null);\n    Preconditions.checkState(\n        externsRoot == null || externsAndJs.hasChild(externsRoot));\n\n    inferTypes(externsAndJs);\n  }",
    "comment": " Main entry point for type inference when running over the whole tree.  @param externsRoot The root of the externs parse tree. @param jsRoot The root of the input parse tree to be checked. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "TypeInferringCallback.enterScope",
    "class_name": "com.google.javascript.jscomp.TypeInferencePass$TypeInferringCallback",
    "signature": "com.google.javascript.jscomp.TypeInferencePass$TypeInferringCallback.enterScope(NodeTraversal)",
    "snippet": "    public void enterScope(NodeTraversal t) {\n      Scope scope = t.getScope();\n      Node node = t.getCurrentNode();\n      if (scope.isGlobal()) {\n        inferTypes(t, node, scope);\n      }\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "TypeInferringCallback.exitScope",
    "class_name": "com.google.javascript.jscomp.TypeInferencePass$TypeInferringCallback",
    "signature": "com.google.javascript.jscomp.TypeInferencePass$TypeInferringCallback.exitScope(NodeTraversal)",
    "snippet": "    public void exitScope(NodeTraversal t) {\n      Scope scope = t.getScope();\n      Node node = t.getCurrentNode();\n      if (scope.isLocal()) {\n        inferTypes(t, node, scope);\n      }\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "TypeInferringCallback.shouldTraverse",
    "class_name": "com.google.javascript.jscomp.TypeInferencePass$TypeInferringCallback",
    "signature": "com.google.javascript.jscomp.TypeInferencePass$TypeInferringCallback.shouldTraverse(NodeTraversal,Node,Node)",
    "snippet": "    public boolean shouldTraverse(NodeTraversal t, Node n, Node parent) {\n      return true;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "TypeInferringCallback.visit",
    "class_name": "com.google.javascript.jscomp.TypeInferencePass$TypeInferringCallback",
    "signature": "com.google.javascript.jscomp.TypeInferencePass$TypeInferringCallback.visit(NodeTraversal,Node,Node)",
    "snippet": "    public void visit(NodeTraversal t, Node n, Node parent) {\n      // Do nothing\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "TypeValidator.TypeValidator",
    "class_name": "com.google.javascript.jscomp.TypeValidator",
    "signature": "com.google.javascript.jscomp.TypeValidator.TypeValidator(AbstractCompiler)",
    "snippet": "  TypeValidator(AbstractCompiler compiler) {\n    this.compiler = compiler;\n    this.typeRegistry = compiler.getTypeRegistry();\n    this.allValueTypes = typeRegistry.createUnionType(\n        STRING_TYPE, NUMBER_TYPE, BOOLEAN_TYPE, NULL_TYPE, VOID_TYPE);\n    this.nullOrUndefined = typeRegistry.createUnionType(\n        NULL_TYPE, VOID_TYPE);\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "TypeValidator.expectAllInterfaceProperties",
    "class_name": "com.google.javascript.jscomp.TypeValidator",
    "signature": "com.google.javascript.jscomp.TypeValidator.expectAllInterfaceProperties(NodeTraversal,Node,FunctionType)",
    "snippet": "  void expectAllInterfaceProperties(NodeTraversal t, Node n,\n      FunctionType type) {\n    ObjectType instance = type.getInstanceType();\n    for (ObjectType implemented : type.getAllImplementedInterfaces()) {\n      if (implemented.getImplicitPrototype() != null) {\n        for (String prop :\n            implemented.getImplicitPrototype().getOwnPropertyNames()) {\n          expectInterfaceProperty(t, n, instance, implemented, prop);\n        }\n      }\n    }\n  }",
    "comment": " Expect that all properties on interfaces that this type implements are implemented and correctly typed. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "TypeValidator.expectCanAssignToPropertyOf",
    "class_name": "com.google.javascript.jscomp.TypeValidator",
    "signature": "com.google.javascript.jscomp.TypeValidator.expectCanAssignToPropertyOf(NodeTraversal,Node,JSType,JSType,Node,String)",
    "snippet": "  boolean expectCanAssignToPropertyOf(NodeTraversal t, Node n, JSType rightType,\n      JSType leftType, Node owner, String propName) {\n    // The NoType check is a hack to make typedefs work ok.\n    if (!leftType.isNoType() && !rightType.canAssignTo(leftType)) {\n      if (bothIntrinsics(rightType, leftType)) {\n        // We have a superior warning for this mistake, which gives you\n        // the line numbers of both types.\n        registerMismatch(rightType, leftType);\n      } else {\n        mismatch(t, n,\n            \"assignment to property \" + propName + \" of \" +\n            getReadableJSTypeName(owner, true),\n            rightType, leftType);\n      }\n      return false;\n    }\n    return true;\n  }",
    "comment": " Expect that the first type can be assigned to a symbol of the second type.  @param t The node traversal. @param n The node to issue warnings on. @param rightType The type on the RHS of the assign. @param leftType The type of the symbol on the LHS of the assign. @param owner The owner of the property being assigned to. @param propName The name of the property being assigned to. @return True if the types matched, false otherwise. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "TypeValidator.expectCanCast",
    "class_name": "com.google.javascript.jscomp.TypeValidator",
    "signature": "com.google.javascript.jscomp.TypeValidator.expectCanCast(NodeTraversal,Node,JSType,JSType)",
    "snippet": "  void expectCanCast(NodeTraversal t, Node n, JSType type, JSType castType) {\n    castType = castType.restrictByNotNullOrUndefined();\n    type = type.restrictByNotNullOrUndefined();\n\n    if (!type.canAssignTo(castType) && !castType.canAssignTo(type)) {\n      if (shouldReport) {\n        compiler.report(\n            t.makeError(n, INVALID_CAST,\n                castType.toString(), type.toString()));\n      }\n      registerMismatch(type, castType);\n    }\n  }",
    "comment": " Expect that the first type can be cast to the second type. The first type should be either a subtype or supertype of the second.  @param t The node traversal. @param n The node where warnings should point. @param type The type being cast from. @param castType The type being cast to. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "TypeValidator.expectNotNullOrUndefined",
    "class_name": "com.google.javascript.jscomp.TypeValidator",
    "signature": "com.google.javascript.jscomp.TypeValidator.expectNotNullOrUndefined(NodeTraversal,Node,JSType,String,JSType)",
    "snippet": "  boolean expectNotNullOrUndefined(\n      NodeTraversal t, Node n, JSType type, String msg, JSType expectedType) {\n    if (!type.isNoType() && !type.isUnknownType() &&\n        type.isSubtype(nullOrUndefined) &&\n        !containsForwardDeclaredUnresolvedName(type)) {\n\n      // There's one edge case right now that we don't handle well, and\n      // that we don't want to warn about.\n      // if (this.x == null) {\n      //   this.initializeX();\n      //   this.x.foo();\n      // }\n      // In this case, we incorrectly type x because of how we\n      // infer properties locally. See issue 109.\n      // http://code.google.com/p/closure-compiler/issues/detail?id=109\n      //\n      // We do not do this inference globally.\n      if (n.getType() == Token.GETPROP &&\n          !t.inGlobalScope() && type.isNullType()) {\n        return true;\n      }\n\n      mismatch(t, n, msg, type, expectedType);\n      return false;\n    }\n    return true;\n  }",
    "comment": " Expect the type to be anything but the null or void type. If the expectation is not met, issue a warning at the provided node's source code position. Note that a union type that includes the void type and at least one other type meets the expectation. @return Whether the expectation was met. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "TypeValidator.expectUndeclaredVariable",
    "class_name": "com.google.javascript.jscomp.TypeValidator",
    "signature": "com.google.javascript.jscomp.TypeValidator.expectUndeclaredVariable(String,Node,Node,Var,String,JSType)",
    "snippet": "  void expectUndeclaredVariable(String sourceName, Node n, Node parent, Var var,\n      String variableName, JSType newType) {\n    boolean allowDupe = false;\n    if (n.getType() == Token.GETPROP ||\n        NodeUtil.isObjectLitKey(n, parent)) {\n      JSDocInfo info = n.getJSDocInfo();\n      if (info == null) {\n        info = parent.getJSDocInfo();\n      }\n      allowDupe =\n          info != null && info.getSuppressions().contains(\"duplicate\");\n    }\n\n    JSType varType = var.getType();\n\n    // Only report duplicate declarations that have types. Other duplicates\n    // will be reported by the syntactic scope creator later in the\n    // compilation process.\n    if (varType != null &&\n        varType != typeRegistry.getNativeType(UNKNOWN_TYPE) &&\n        newType != null &&\n        newType != typeRegistry.getNativeType(UNKNOWN_TYPE)) {\n      // If there are two typed declarations of the same variable, that\n      // is an error and the second declaration is ignored, except in the\n      // case of native types. A null input type means that the declaration\n      // was made in TypedScopeCreator#createInitialScope and is a\n      // native type.\n      if (var.input == null) {\n        n.setJSType(varType);\n        if (parent.getType() == Token.VAR) {\n          if (n.getFirstChild() != null) {\n            n.getFirstChild().setJSType(varType);\n          }\n        } else {\n          Preconditions.checkState(parent.getType() == Token.FUNCTION);\n          parent.setJSType(varType);\n        }\n      } else {\n        // Always warn about duplicates if the overridden type does not\n        // match the original type.\n        //\n        // If the types match, suppress the warning iff there was a @suppress\n        // tag, or if the original declaration was a stub.\n        if (!(allowDupe ||\n              var.getParentNode().getType() == Token.EXPR_RESULT) ||\n            !newType.equals(varType)) {\n          if (shouldReport) {\n            compiler.report(\n                JSError.make(sourceName, n, DUP_VAR_DECLARATION,\n                    variableName, newType.toString(), var.getInputName(),\n                    String.valueOf(var.nameNode.getLineno()),\n                    varType.toString()));\n          }\n        }\n      }\n    }\n  }",
    "comment": " Expect that the given variable has not been declared with a type.  @param sourceName The name of the source file we're in. @param n The node where warnings should point to. @param parent The parent of {@code n}. @param var The variable that we're checking. @param variableName The name of the variable. @param newType The type being applied to the variable. Mostly just here for the benefit of the warning. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "TypeValidator.setShouldReport",
    "class_name": "com.google.javascript.jscomp.TypeValidator",
    "signature": "com.google.javascript.jscomp.TypeValidator.setShouldReport(boolean)",
    "snippet": "  void setShouldReport(boolean report) {\n    this.shouldReport = report;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "TypedScopeCreator.TypedScopeCreator",
    "class_name": "com.google.javascript.jscomp.TypedScopeCreator",
    "signature": "com.google.javascript.jscomp.TypedScopeCreator.TypedScopeCreator(AbstractCompiler)",
    "snippet": "  TypedScopeCreator(AbstractCompiler compiler) {\n    this(compiler, compiler.getCodingConvention());\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "TypedScopeCreator.TypedScopeCreator",
    "class_name": "com.google.javascript.jscomp.TypedScopeCreator",
    "signature": "com.google.javascript.jscomp.TypedScopeCreator.TypedScopeCreator(AbstractCompiler,CodingConvention)",
    "snippet": "  TypedScopeCreator(AbstractCompiler compiler,\n      CodingConvention codingConvention) {\n    this.compiler = compiler;\n    this.validator = compiler.getTypeValidator();\n    this.codingConvention = codingConvention;\n    this.typeRegistry = compiler.getTypeRegistry();\n    this.typeParsingErrorReporter = typeRegistry.getErrorReporter();\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "TypedScopeCreator.createInitialScope",
    "class_name": "com.google.javascript.jscomp.TypedScopeCreator",
    "signature": "com.google.javascript.jscomp.TypedScopeCreator.createInitialScope(Node)",
    "snippet": "  @VisibleForTesting\n  Scope createInitialScope(Node root) {\n\n    NodeTraversal.traverse(\n        compiler, root, new DiscoverEnumsAndTypedefs(typeRegistry));\n\n    Scope s = new Scope(root, compiler);\n    declareNativeFunctionType(s, ARRAY_FUNCTION_TYPE);\n    declareNativeFunctionType(s, BOOLEAN_OBJECT_FUNCTION_TYPE);\n    declareNativeFunctionType(s, DATE_FUNCTION_TYPE);\n    declareNativeFunctionType(s, ERROR_FUNCTION_TYPE);\n    declareNativeFunctionType(s, EVAL_ERROR_FUNCTION_TYPE);\n    declareNativeFunctionType(s, FUNCTION_FUNCTION_TYPE);\n    declareNativeFunctionType(s, NUMBER_OBJECT_FUNCTION_TYPE);\n    declareNativeFunctionType(s, OBJECT_FUNCTION_TYPE);\n    declareNativeFunctionType(s, RANGE_ERROR_FUNCTION_TYPE);\n    declareNativeFunctionType(s, REFERENCE_ERROR_FUNCTION_TYPE);\n    declareNativeFunctionType(s, REGEXP_FUNCTION_TYPE);\n    declareNativeFunctionType(s, STRING_OBJECT_FUNCTION_TYPE);\n    declareNativeFunctionType(s, SYNTAX_ERROR_FUNCTION_TYPE);\n    declareNativeFunctionType(s, TYPE_ERROR_FUNCTION_TYPE);\n    declareNativeFunctionType(s, URI_ERROR_FUNCTION_TYPE);\n    declareNativeValueType(s, \"undefined\", VOID_TYPE);\n\n    // ActiveXObject is unqiuely special, because it can be used to construct\n    // any type (the type that it creates is related to the arguments you\n    // pass to it).\n    declareNativeValueType(s, \"ActiveXObject\", NO_OBJECT_TYPE);\n\n    return s;\n  }",
    "comment": " Create the outermost scope. This scope contains native binding such as {@code Object}, {@code Date}, etc. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "TypedScopeCreator.createScope",
    "class_name": "com.google.javascript.jscomp.TypedScopeCreator",
    "signature": "com.google.javascript.jscomp.TypedScopeCreator.createScope(Node,Scope)",
    "snippet": "  @Override\n  public Scope createScope(Node root, Scope parent) {\n    // Constructing the global scope is very different than constructing\n    // inner scopes, because only global scopes can contain named classes that\n    // show up in the type registry.\n    Scope newScope = null;\n    AbstractScopeBuilder scopeBuilder = null;\n    if (parent == null) {\n      // Find all the classes in the global scope.\n      newScope = createInitialScope(root);\n\n      GlobalScopeBuilder globalScopeBuilder = new GlobalScopeBuilder(newScope);\n      scopeBuilder = globalScopeBuilder;\n      NodeTraversal.traverse(compiler, root, scopeBuilder);\n    } else {\n      newScope = new Scope(parent, root);\n      LocalScopeBuilder localScopeBuilder = new LocalScopeBuilder(newScope);\n      scopeBuilder = localScopeBuilder;\n      localScopeBuilder.build();\n    }\n\n    scopeBuilder.resolveStubDeclarations();\n    scopeBuilder.resolveTypes();\n\n    // Gather the properties in each function that we found in the\n    // global scope, if that function has a @this type that we can\n    // build properties on.\n    for (Node functionNode : scopeBuilder.nonExternFunctions) {\n      JSType type = functionNode.getJSType();\n      if (type != null && type instanceof FunctionType) {\n        FunctionType fnType = (FunctionType) type;\n        ObjectType fnThisType = fnType.getTypeOfThis();\n        if (!fnThisType.isUnknownType()) {\n          NodeTraversal.traverse(compiler, functionNode.getLastChild(),\n              scopeBuilder.new CollectProperties(fnThisType));\n        }\n      }\n    }\n\n    if (parent == null) {\n      codingConvention.defineDelegateProxyPrototypeProperties(\n          typeRegistry, newScope, delegateProxyPrototypes);\n    }\n    return newScope;\n  }",
    "comment": " Creates a scope with all types declared. Declares newly discovered types and type properties in the type registry. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "TypedScopeCreator.declareNativeFunctionType",
    "class_name": "com.google.javascript.jscomp.TypedScopeCreator",
    "signature": "com.google.javascript.jscomp.TypedScopeCreator.declareNativeFunctionType(Scope,JSTypeNative)",
    "snippet": "  private void declareNativeFunctionType(Scope scope, JSTypeNative tId) {\n    FunctionType t = typeRegistry.getNativeFunctionType(tId);\n    declareNativeType(scope, t.getInstanceType().getReferenceName(), t);\n    declareNativeType(\n        scope, t.getPrototype().getReferenceName(), t.getPrototype());\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "TypedScopeCreator.declareNativeType",
    "class_name": "com.google.javascript.jscomp.TypedScopeCreator",
    "signature": "com.google.javascript.jscomp.TypedScopeCreator.declareNativeType(Scope,String,JSType)",
    "snippet": "  private void declareNativeType(Scope scope, String name, JSType t) {\n    scope.declare(name, null, t, null, false);\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "TypedScopeCreator.declareNativeValueType",
    "class_name": "com.google.javascript.jscomp.TypedScopeCreator",
    "signature": "com.google.javascript.jscomp.TypedScopeCreator.declareNativeValueType(Scope,String,JSTypeNative)",
    "snippet": "  private void declareNativeValueType(Scope scope, String name,\n      JSTypeNative tId) {\n    declareNativeType(scope, name, typeRegistry.getNativeType(tId));\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "TypedScopeCreator.getBestJSDocInfo",
    "class_name": "com.google.javascript.jscomp.TypedScopeCreator",
    "signature": "com.google.javascript.jscomp.TypedScopeCreator.getBestJSDocInfo(Node)",
    "snippet": "  static JSDocInfo getBestJSDocInfo(Node n) {\n    JSDocInfo info = n.getJSDocInfo();\n    if (info == null) {\n      Node parent = n.getParent();\n      int parentType = parent.getType();\n      if (parentType == Token.NAME) {\n        info = parent.getJSDocInfo();\n        if (info == null && parent.getParent().hasOneChild()) {\n          info = parent.getParent().getJSDocInfo();\n        }\n      } else if (parentType == Token.ASSIGN) {\n        info = parent.getJSDocInfo();\n      } else if (NodeUtil.isObjectLitKey(parent, parent.getParent())) {\n        info = parent.getJSDocInfo();\n      }\n    }\n    return info;\n  }",
    "comment": "Find the best JSDoc for the given node. */",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "TypedScopeCreator.getBestLValue",
    "class_name": "com.google.javascript.jscomp.TypedScopeCreator",
    "signature": "com.google.javascript.jscomp.TypedScopeCreator.getBestLValue(Node)",
    "snippet": "  private static Node getBestLValue(Node n) {\n    Node parent = n.getParent();\n    int parentType = parent.getType();\n    boolean isFunctionDeclaration = NodeUtil.isFunctionDeclaration(n);\n    if (isFunctionDeclaration) {\n      return n.getFirstChild();\n    } else if (parentType == Token.NAME) {\n      return parent;\n    } else if (parentType == Token.ASSIGN) {\n      return parent.getFirstChild();\n    } else if (NodeUtil.isObjectLitKey(parent, parent.getParent())) {\n      return parent;\n    }\n    return null;\n  }",
    "comment": "Find the l-value that the given r-value is being assigned to. */",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "TypedScopeCreator.getBestLValueName",
    "class_name": "com.google.javascript.jscomp.TypedScopeCreator",
    "signature": "com.google.javascript.jscomp.TypedScopeCreator.getBestLValueName(Node)",
    "snippet": "  private static String getBestLValueName(@Nullable Node lValue) {\n    if (lValue == null || lValue.getParent() == null) {\n      return null;\n    }\n    if (NodeUtil.isObjectLitKey(lValue, lValue.getParent())) {\n      Node owner = getBestLValue(lValue.getParent());\n      if (owner != null) {\n        String ownerName = getBestLValueName(owner);\n        if (ownerName != null) {\n          return ownerName + \".\" + NodeUtil.getObjectLitKeyName(lValue);\n        }\n      }\n      return null;\n    }\n    return lValue.getQualifiedName();\n  }",
    "comment": "Get the name of the given l-value node. */",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "TypedScopeCreator.getNativeType",
    "class_name": "com.google.javascript.jscomp.TypedScopeCreator",
    "signature": "com.google.javascript.jscomp.TypedScopeCreator.getNativeType(JSTypeNative)",
    "snippet": "  private JSType getNativeType(JSTypeNative nativeType) {\n    return typeRegistry.getNativeType(nativeType);\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "AbstractScopeBuilder.assertDefinitionNode",
    "class_name": "com.google.javascript.jscomp.TypedScopeCreator$AbstractScopeBuilder",
    "signature": "com.google.javascript.jscomp.TypedScopeCreator$AbstractScopeBuilder.assertDefinitionNode(Node,int)",
    "snippet": "    void assertDefinitionNode(Node n, int type) {\n      Preconditions.checkState(sourceName != null);\n      Preconditions.checkState(n.getType() == type);\n    }",
    "comment": " Asserts that it's ok to define this node's name. The node should have a source name and be of the specified type. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "AbstractScopeBuilder.attachLiteralTypes",
    "class_name": "com.google.javascript.jscomp.TypedScopeCreator$AbstractScopeBuilder",
    "signature": "com.google.javascript.jscomp.TypedScopeCreator$AbstractScopeBuilder.attachLiteralTypes(NodeTraversal,Node)",
    "snippet": "    private void attachLiteralTypes(NodeTraversal t, Node n) {\n      switch (n.getType()) {\n        case Token.NULL:\n          n.setJSType(getNativeType(NULL_TYPE));\n          break;\n\n        case Token.VOID:\n          n.setJSType(getNativeType(VOID_TYPE));\n          break;\n\n        case Token.STRING:\n          // Defer keys to the Token.OBJECTLIT case\n          if (!NodeUtil.isObjectLitKey(n, n.getParent())) {\n            n.setJSType(getNativeType(STRING_TYPE));\n          }\n          break;\n\n        case Token.NUMBER:\n          n.setJSType(getNativeType(NUMBER_TYPE));\n          break;\n\n        case Token.TRUE:\n        case Token.FALSE:\n          n.setJSType(getNativeType(BOOLEAN_TYPE));\n          break;\n\n        case Token.REGEXP:\n          n.setJSType(getNativeType(REGEXP_TYPE));\n          break;\n\n        case Token.REF_SPECIAL:\n          n.setJSType(getNativeType(UNKNOWN_TYPE));\n          break;\n\n        case Token.OBJECTLIT:\n          defineObjectLiteral(t, n);\n          break;\n\n          // NOTE(nicksantos): If we ever support Array tuples,\n          // we will need to put ARRAYLIT here as well.\n      }\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "AbstractScopeBuilder.createFunctionTypeFromNodes",
    "class_name": "com.google.javascript.jscomp.TypedScopeCreator$AbstractScopeBuilder",
    "signature": "com.google.javascript.jscomp.TypedScopeCreator$AbstractScopeBuilder.createFunctionTypeFromNodes(Node,String,JSDocInfo,Node)",
    "snippet": "    private FunctionType createFunctionTypeFromNodes(\n        @Nullable Node rValue,\n        @Nullable String name,\n        @Nullable JSDocInfo info,\n        @Nullable Node lvalueNode) {\n\n      FunctionType functionType = null;\n\n      // Global ctor aliases should be registered with the type registry.\n      if (rValue != null && rValue.isQualifiedName() && scope.isGlobal()) {\n        Var var = scope.getVar(rValue.getQualifiedName());\n        if (var != null && var.getType() instanceof FunctionType) {\n          FunctionType aliasedType  = (FunctionType) var.getType();\n          if ((aliasedType.isConstructor() || aliasedType.isInterface()) &&\n              !aliasedType.isNativeObjectType()) {\n            functionType = aliasedType;\n\n            if (name != null && scope.isGlobal()) {\n              typeRegistry.declareType(name, functionType.getInstanceType());\n            }\n          }\n        }\n      }\n\n      if (functionType == null) {\n        Node errorRoot = rValue == null ? lvalueNode : rValue;\n        boolean isFnLiteral =\n            rValue != null && rValue.getType() == Token.FUNCTION;\n        Node fnRoot = isFnLiteral ? rValue : null;\n        Node parametersNode = isFnLiteral ?\n            rValue.getFirstChild().getNext() : null;\n        Node fnBlock = isFnLiteral ? parametersNode.getNext() : null;\n\n        if (info != null && info.hasType()) {\n          JSType type = info.getType().evaluate(scope, typeRegistry);\n\n          // Known to be not null since we have the FUNCTION token there.\n          type = type.restrictByNotNullOrUndefined();\n          if (type.isFunctionType()) {\n            functionType = (FunctionType) type;\n            functionType.setJSDocInfo(info);\n          }\n        }\n\n        if (functionType == null) {\n          // Find the type of any overridden function.\n          FunctionType overriddenPropType = null;\n          if (lvalueNode != null &&\n              lvalueNode.getType() == Token.GETPROP &&\n              lvalueNode.isQualifiedName()) {\n            Var var = scope.getVar(\n                lvalueNode.getFirstChild().getQualifiedName());\n            if (var != null) {\n              ObjectType ownerType = ObjectType.cast(var.getType());\n              if (ownerType != null) {\n                String propName = lvalueNode.getLastChild().getString();\n                overriddenPropType =\n                    findOverriddenFunction(ownerType, propName);\n              }\n            }\n          }\n\n          FunctionTypeBuilder builder =\n              new FunctionTypeBuilder(name, compiler, errorRoot, sourceName,\n                  scope)\n              .setSourceNode(fnRoot)\n              .inferFromOverriddenFunction(overriddenPropType, parametersNode)\n              .inferTemplateTypeName(info)\n              .inferReturnType(info)\n              .inferInheritance(info);\n\n          // Infer the context type.\n          boolean searchedForThisType = false;\n          if (lvalueNode != null &&\n              lvalueNode.getType() == Token.GETPROP) {\n            Node objNode = lvalueNode.getFirstChild();\n            if (objNode.getType() == Token.GETPROP &&\n                objNode.getLastChild().getString().equals(\"prototype\")) {\n              builder.inferThisType(info, objNode.getFirstChild());\n              searchedForThisType = true;\n            } else if (objNode.getType() == Token.THIS) {\n              builder.inferThisType(info, objNode.getJSType());\n              searchedForThisType = true;\n            }\n          }\n\n          if (!searchedForThisType) {\n            builder.inferThisType(info, (Node) null);\n          }\n\n          functionType = builder\n              .inferParameterTypes(parametersNode, info)\n              .inferReturnStatementsAsLastResort(fnBlock)\n              .buildAndRegister();\n        }\n      }\n\n      // all done\n      return functionType;\n    }",
    "comment": " Creates a new function type, based on the given nodes.  This handles two cases that are semantically very different, but are not mutually exclusive: - A function literal that needs a type attached to it. - An assignment expression with function-type info in the jsdoc.  All parameters are optional, and we will do the best we can to create a function type.  This function will always create a function type, so only call it if you're sure that's what you want.  @param rValue The function node. @param name the function's name @param info the {@link JSDocInfo} attached to the function definition @param lvalueNode The node where this function is being assigned. For example, {@code A.prototype.foo = ...} would be used to determine that this function is a method of A.prototype. May be null to indicate that this is not being assigned to a qualified name. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "AbstractScopeBuilder.defineFunctionLiteral",
    "class_name": "com.google.javascript.jscomp.TypedScopeCreator$AbstractScopeBuilder",
    "signature": "com.google.javascript.jscomp.TypedScopeCreator$AbstractScopeBuilder.defineFunctionLiteral(Node,Node)",
    "snippet": "    void defineFunctionLiteral(Node n, Node parent) {\n      assertDefinitionNode(n, Token.FUNCTION);\n\n      // Determine the name and JSDocInfo and lvalue for the function.\n      // Any of these may be null.\n      Node lValue = getBestLValue(n);\n      JSDocInfo info = getBestJSDocInfo(n);\n      String functionName = getBestLValueName(lValue);\n      FunctionType functionType =\n          createFunctionTypeFromNodes(n, functionName, info, lValue);\n\n      // Assigning the function type to the function node\n      setDeferredType(n, functionType);\n\n      // Declare this symbol in the current scope iff it's a function\n      // declaration. Otherwise, the declaration will happen in other\n      // code paths.\n      if (NodeUtil.isFunctionDeclaration(n)) {\n        defineSlot(n.getFirstChild(), n, functionType);\n      }\n    }",
    "comment": " Defines a function literal. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "AbstractScopeBuilder.defineName",
    "class_name": "com.google.javascript.jscomp.TypedScopeCreator$AbstractScopeBuilder",
    "signature": "com.google.javascript.jscomp.TypedScopeCreator$AbstractScopeBuilder.defineName(Node,Node,Node,JSDocInfo)",
    "snippet": "    private void defineName(Node name, Node var, Node parent, JSDocInfo info) {\n      Node value = name.getFirstChild();\n\n      // variable's type\n      JSType type = getDeclaredType(sourceName, info, name, value);\n      if (type == null) {\n        // The variable's type will be inferred.\n        CompilerInput input = compiler.getInput(sourceName);\n        Preconditions.checkNotNull(input, sourceName);\n        type = input.isExtern() ?\n            getNativeType(UNKNOWN_TYPE) : null;\n      }\n      defineSlot(name, var, type);\n    }",
    "comment": " Defines a variable based on the {@link Token#NAME} node passed. @param name The {@link Token#NAME} node. @param var The parent of the {@code name} node, which must be a {@link Token#VAR} node. @param parent {@code var}'s parent. @param info the {@link JSDocInfo} information relating to this {@code name} node. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "AbstractScopeBuilder.defineSlot",
    "class_name": "com.google.javascript.jscomp.TypedScopeCreator$AbstractScopeBuilder",
    "signature": "com.google.javascript.jscomp.TypedScopeCreator$AbstractScopeBuilder.defineSlot(Node,Node,JSType)",
    "snippet": "    private void defineSlot(Node name, Node parent, JSType type) {\n      defineSlot(name, parent, type, type == null);\n    }",
    "comment": " Defines a typed variable. The defining node will be annotated with the variable's type or {@code null} if its type is inferred. @param name the defining node. It must be a {@link Token#NAME}. @param parent the {@code name}'s parent. @param type the variable's type. It may be {@code null}, in which case the variable's type will be inferred. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "AbstractScopeBuilder.defineSlot",
    "class_name": "com.google.javascript.jscomp.TypedScopeCreator$AbstractScopeBuilder",
    "signature": "com.google.javascript.jscomp.TypedScopeCreator$AbstractScopeBuilder.defineSlot(Node,Node,JSType,boolean)",
    "snippet": "    void defineSlot(Node n, Node parent, JSType type, boolean inferred) {\n      Preconditions.checkArgument(inferred || type != null);\n\n      // Only allow declarations of NAMEs and qualfied names.\n      // Object literal keys will have to compute their names themselves.\n      if (n.getType() == Token.NAME) {\n        Preconditions.checkArgument(\n            parent.getType() == Token.FUNCTION ||\n            parent.getType() == Token.VAR ||\n            parent.getType() == Token.LP ||\n            parent.getType() == Token.CATCH);\n      } else {\n        Preconditions.checkArgument(\n            n.getType() == Token.GETPROP &&\n            (parent.getType() == Token.ASSIGN ||\n             parent.getType() == Token.EXPR_RESULT));\n      }\n      defineSlot(n, parent, n.getQualifiedName(), type, inferred);\n    }",
    "comment": " Defines a typed variable. The defining node will be annotated with the variable's type of {@link JSTypeNative#UNKNOWN_TYPE} if its type is inferred.  Slots may be any variable or any qualified name in the global scope.  @param n the defining NAME or GETPROP node. @param parent the {@code n}'s parent. @param type the variable's type. It may be {@code null} if {@code inferred} is {@code true}. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "AbstractScopeBuilder.defineSlot",
    "class_name": "com.google.javascript.jscomp.TypedScopeCreator$AbstractScopeBuilder",
    "signature": "com.google.javascript.jscomp.TypedScopeCreator$AbstractScopeBuilder.defineSlot(Node,Node,String,JSType,boolean)",
    "snippet": "    void defineSlot(Node n, Node parent, String variableName,\n        JSType type, boolean inferred) {\n      Preconditions.checkArgument(!variableName.isEmpty());\n\n      boolean isGlobalVar = n.getType() == Token.NAME && scope.isGlobal();\n      boolean shouldDeclareOnGlobalThis =\n          isGlobalVar &&\n          (parent.getType() == Token.VAR ||\n           parent.getType() == Token.FUNCTION);\n\n      // If n is a property, then we should really declare it in the\n      // scope where the root object appears. This helps out people\n      // who declare \"global\" names in an anonymous namespace.\n      Scope scopeToDeclareIn = scope;\n      if (n.getType() == Token.GETPROP && !scope.isGlobal() &&\n          isQnameRootedInGlobalScope(n)) {\n        Scope globalScope = scope.getGlobalScope();\n\n        // don't try to declare in the global scope if there's\n        // already a symbol there with this name.\n        if (!globalScope.isDeclared(variableName, false)) {\n          scopeToDeclareIn = scope.getGlobalScope();\n        }\n      }\n\n      // declared in closest scope?\n      if (scopeToDeclareIn.isDeclared(variableName, false)) {\n        Var oldVar = scopeToDeclareIn.getVar(variableName);\n        validator.expectUndeclaredVariable(\n            sourceName, n, parent, oldVar, variableName, type);\n      } else {\n        if (!inferred) {\n          setDeferredType(n, type);\n        }\n        CompilerInput input = compiler.getInput(sourceName);\n        boolean isExtern = input.isExtern();\n        Var newVar =\n            scopeToDeclareIn.declare(variableName, n, type, input, inferred);\n\n        if (shouldDeclareOnGlobalThis) {\n          ObjectType globalThis =\n              typeRegistry.getNativeObjectType(GLOBAL_THIS);\n          if (inferred) {\n            globalThis.defineInferredProperty(variableName,\n                type == null ?\n                    getNativeType(JSTypeNative.NO_TYPE) :\n                    type,\n                 n);\n          } else {\n            globalThis.defineDeclaredProperty(variableName, type, n);\n          }\n        }\n\n        if (type instanceof EnumType) {\n          Node initialValue = newVar.getInitialValue();\n          boolean isValidValue = initialValue != null &&\n              (initialValue.getType() == Token.OBJECTLIT ||\n               initialValue.isQualifiedName());\n          if (!isValidValue) {\n            compiler.report(JSError.make(sourceName, n, ENUM_INITIALIZER));\n          }\n        }\n\n        // We need to do some additional work for constructors and interfaces.\n        if (type instanceof FunctionType &&\n            // We don't want to look at empty function types.\n            !type.isEmptyType()) {\n          FunctionType fnType = (FunctionType) type;\n          if ((fnType.isConstructor() || fnType.isInterface()) &&\n              !fnType.equals(getNativeType(U2U_CONSTRUCTOR_TYPE))) {\n            // Declare var.prototype in the scope chain.\n            FunctionType superClassCtor = fnType.getSuperClassConstructor();\n            scopeToDeclareIn.declare(variableName + \".prototype\", n,\n                fnType.getPrototype(), input,\n                /* declared iff there's an explicit supertype */\n                superClassCtor == null ||\n                superClassCtor.getInstanceType().equals(\n                    getNativeType(OBJECT_TYPE)));\n\n            // Make sure the variable is initialized to something if\n            // it constructs itself.\n            if (newVar.getInitialValue() == null &&\n                !isExtern &&\n                // We want to make sure that when we declare a new instance\n                // type (with @constructor) that there's actually a ctor for it.\n                // This doesn't apply to structural constructors\n                // (like function(new:Array). Checking the constructed\n                // type against the variable name is a sufficient check for\n                // this.\n                variableName.equals(\n                    fnType.getInstanceType().getReferenceName())) {\n              compiler.report(\n                  JSError.make(sourceName, n,\n                      fnType.isConstructor() ?\n                          CTOR_INITIALIZER : IFACE_INITIALIZER,\n                      variableName));\n            }\n          }\n        }\n      }\n\n      if (isGlobalVar && \"Window\".equals(variableName)\n          && type instanceof FunctionType\n          && type.isConstructor()) {\n        FunctionType globalThisCtor =\n            typeRegistry.getNativeObjectType(GLOBAL_THIS).getConstructor();\n        globalThisCtor.getInstanceType().clearCachedValues();\n        globalThisCtor.getPrototype().clearCachedValues();\n        globalThisCtor\n            .setPrototypeBasedOn(((FunctionType) type).getInstanceType());\n      }\n    }",
    "comment": " Defines a symbol in the current scope.  @param n the defining NAME or GETPROP or object literal key node. @param parent the {@code n}'s parent. @param variableName The name that this should be known by. @param type the variable's type. It may be {@code null} if {@code inferred} is {@code true}. @param inferred Whether the type is inferred or declared. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "AbstractScopeBuilder.defineVar",
    "class_name": "com.google.javascript.jscomp.TypedScopeCreator$AbstractScopeBuilder",
    "signature": "com.google.javascript.jscomp.TypedScopeCreator$AbstractScopeBuilder.defineVar(Node,Node)",
    "snippet": "    void defineVar(Node n, Node parent) {\n      assertDefinitionNode(n, Token.VAR);\n      JSDocInfo info = n.getJSDocInfo();\n      if (n.hasMoreThanOneChild()) {\n        if (info != null) {\n          // multiple children\n          compiler.report(JSError.make(sourceName, n, MULTIPLE_VAR_DEF));\n        }\n        for (Node name : n.children()) {\n          defineName(name, n, parent, name.getJSDocInfo());\n        }\n      } else {\n        Node name = n.getFirstChild();\n        defineName(name, n, parent,\n            (info != null) ? info : name.getJSDocInfo());\n      }\n    }",
    "comment": " Defines a VAR initialization. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "AbstractScopeBuilder.findOverriddenFunction",
    "class_name": "com.google.javascript.jscomp.TypedScopeCreator$AbstractScopeBuilder",
    "signature": "com.google.javascript.jscomp.TypedScopeCreator$AbstractScopeBuilder.findOverriddenFunction(ObjectType,String)",
    "snippet": "    private FunctionType findOverriddenFunction(\n        ObjectType ownerType, String propName) {\n      // First, check to see if the property is implemented\n      // on a superclass.\n      JSType propType = ownerType.getPropertyType(propName);\n      if (propType instanceof FunctionType) {\n        return (FunctionType) propType;\n      } else {\n        // If it's not, then check to see if it's implemented\n        // on an implemented interface.\n        for (ObjectType iface :\n                 ownerType.getCtorImplementedInterfaces()) {\n          propType = iface.getPropertyType(propName);\n          if (propType instanceof FunctionType) {\n            return (FunctionType) propType;\n          }\n        }\n      }\n\n      return null;\n    }",
    "comment": " Find the function that's being overridden on this type, if any. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "AbstractScopeBuilder.getDeclaredType",
    "class_name": "com.google.javascript.jscomp.TypedScopeCreator$AbstractScopeBuilder",
    "signature": "com.google.javascript.jscomp.TypedScopeCreator$AbstractScopeBuilder.getDeclaredType(String,JSDocInfo,Node,Node)",
    "snippet": "    private JSType getDeclaredType(String sourceName, JSDocInfo info,\n        Node lValue, @Nullable Node rValue) {\n      if (info != null && info.hasType()) {\n        return getDeclaredTypeInAnnotation(sourceName, lValue, info);\n      } else if (rValue != null && rValue.getType() == Token.FUNCTION &&\n          shouldUseFunctionLiteralType(\n              (FunctionType) rValue.getJSType(), info, lValue)) {\n        return rValue.getJSType();\n      } else if (info != null) {\n        if (info.hasEnumParameterType()) {\n          if (rValue != null && rValue.getType() == Token.OBJECTLIT) {\n            return rValue.getJSType();\n          } else {\n            return createEnumTypeFromNodes(\n                rValue, lValue.getQualifiedName(), info, lValue);\n          }\n        } else if (info.isConstructor() || info.isInterface()) {\n          return createFunctionTypeFromNodes(\n              rValue, lValue.getQualifiedName(), info, lValue);\n        } else {\n          // Check if this is constant, and if it has a known type.\n          if (info.isConstant()) {\n            JSType knownType = null;\n            if (rValue != null) {\n              if (rValue.getJSType() != null\n                  && !rValue.getJSType().isUnknownType()) {\n                return rValue.getJSType();\n              } else if (rValue.getType() == Token.OR) {\n                // Check for a very specific JS idiom:\n                // var x = x || TYPE;\n                // This is used by Closure's base namespace for esoteric\n                // reasons.\n                Node firstClause = rValue.getFirstChild();\n                Node secondClause = firstClause.getNext();\n                boolean namesMatch = firstClause.getType() == Token.NAME\n                    && lValue.getType() == Token.NAME\n                    && firstClause.getString().equals(lValue.getString());\n                if (namesMatch && secondClause.getJSType() != null\n                    && !secondClause.getJSType().isUnknownType()) {\n                  return secondClause.getJSType();\n                }\n              }\n            }\n          }\n        }\n      }\n\n      return getDeclaredTypeInAnnotation(sourceName, lValue, info);\n    }",
    "comment": " Look for a type declaration on a property assignment (in an ASSIGN or an object literal key).  @param info The doc info for this property. @param lValue The l-value node. @param rValue The node that {@code n} is being initialized to, or {@code null} if this is a stub declaration. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "AbstractScopeBuilder.getDeclaredTypeInAnnotation",
    "class_name": "com.google.javascript.jscomp.TypedScopeCreator$AbstractScopeBuilder",
    "signature": "com.google.javascript.jscomp.TypedScopeCreator$AbstractScopeBuilder.getDeclaredTypeInAnnotation(String,Node,JSDocInfo)",
    "snippet": "    private JSType getDeclaredTypeInAnnotation(String sourceName,\n        Node node, JSDocInfo info) {\n      JSType jsType = null;\n      Node objNode =\n          node.getType() == Token.GETPROP ? node.getFirstChild() :\n          NodeUtil.isObjectLitKey(node, node.getParent()) ? node.getParent() :\n          null;\n      if (info != null) {\n        if (info.hasType()) {\n          jsType = info.getType().evaluate(scope, typeRegistry);\n        } else if (FunctionTypeBuilder.isFunctionTypeDeclaration(info)) {\n          String fnName = node.getQualifiedName();\n          jsType = createFunctionTypeFromNodes(\n              null, fnName, info, node);\n        }\n      }\n      return jsType;\n    }",
    "comment": " Returns the type specified in a JSDoc annotation near a GETPROP or NAME.  Extracts type information from either the {@code @type} tag or from the {@code @return} and {@code @param} tags. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "AbstractScopeBuilder.getObjectSlot",
    "class_name": "com.google.javascript.jscomp.TypedScopeCreator$AbstractScopeBuilder",
    "signature": "com.google.javascript.jscomp.TypedScopeCreator$AbstractScopeBuilder.getObjectSlot(String)",
    "snippet": "    private ObjectType getObjectSlot(String slotName) {\n      Var ownerVar = scope.getVar(slotName);\n      if (ownerVar != null) {\n        JSType ownerVarType = ownerVar.getType();\n        return ObjectType.cast(ownerVarType == null ?\n            null : ownerVarType.restrictByNotNullOrUndefined());\n      }\n      return null;\n    }",
    "comment": " Find the ObjectType associated with the given slot. @param slotName The name of the slot to find the type in. @return An object type, or null if this slot does not contain an object. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "AbstractScopeBuilder.maybeDeclareQualifiedName",
    "class_name": "com.google.javascript.jscomp.TypedScopeCreator$AbstractScopeBuilder",
    "signature": "com.google.javascript.jscomp.TypedScopeCreator$AbstractScopeBuilder.maybeDeclareQualifiedName(NodeTraversal,JSDocInfo,Node,Node,Node)",
    "snippet": "    void maybeDeclareQualifiedName(NodeTraversal t, JSDocInfo info,\n        Node n, Node parent, Node rhsValue) {\n      Node ownerNode = n.getFirstChild();\n      String ownerName = ownerNode.getQualifiedName();\n      String qName = n.getQualifiedName();\n      String propName = n.getLastChild().getString();\n      Preconditions.checkArgument(qName != null && ownerName != null);\n\n      // Function prototypes are special.\n      // It's a common JS idiom to do:\n      // F.prototype = { ... };\n      // So if F does not have an explicitly declared super type,\n      // allow F.prototype to be redefined arbitrarily.\n      if (\"prototype\".equals(propName)) {\n        Var qVar = scope.getVar(qName);\n        if (qVar != null) {\n          if (!qVar.isTypeInferred()) {\n            // Just ignore assigns to declared prototypes.\n            return;\n          }\n          if (qVar.getScope() == scope) {\n            scope.undeclare(qVar);\n          }\n        }\n      }\n\n      // Precedence of type information on GETPROPs:\n      // 1) @type annnotation / @enum annotation\n      // 2) ASSIGN to FUNCTION literal\n      // 3) @param/@return annotation (with no function literal)\n      // 4) ASSIGN to something marked @const\n      // 5) ASSIGN to anything else\n      //\n      // 1, 3, and 4 are declarations, 5 is inferred, and 2 is a declaration iff\n      // the function has jsdoc or has not been declared before.\n      //\n      // FUNCTION literals are special because TypedScopeCreator is very smart\n      // about getting as much type information as possible for them.\n\n      // Determining type for #1 + #2 + #3 + #4\n      JSType valueType = getDeclaredType(t.getSourceName(), info, n, rhsValue);\n      if (valueType == null && rhsValue != null) {\n        // Determining type for #5\n        valueType = rhsValue.getJSType();\n      }\n\n      if (valueType == null) {\n        if (parent.getType() == Token.EXPR_RESULT) {\n          stubDeclarations.add(new StubDeclaration(\n              n,\n              t.getInput() != null && t.getInput().isExtern(),\n              ownerName));\n        }\n\n        return;\n      }\n\n      boolean inferred = true;\n      if (info != null) {\n        // Determining declaration for #1 + #3 + #4\n        inferred = !(info.hasType()\n            || info.hasEnumParameterType()\n            || (info.isConstant() && valueType != null\n                && !valueType.isUnknownType())\n            || FunctionTypeBuilder.isFunctionTypeDeclaration(info));\n      }\n\n      if (inferred) {\n        // Determining declaration for #2\n        inferred = !(rhsValue != null &&\n            rhsValue.getType() == Token.FUNCTION &&\n            (info != null || !scope.isDeclared(qName, false)));\n      }\n\n      if (!inferred) {\n        ObjectType ownerType = getObjectSlot(ownerName);\n        if (ownerType != null) {\n          // Only declare this as an official property if it has not been\n          // declared yet.\n          boolean isExtern = t.getInput() != null && t.getInput().isExtern();\n          if ((!ownerType.hasOwnProperty(propName) ||\n               ownerType.isPropertyTypeInferred(propName)) &&\n              ((isExtern && !ownerType.isNativeObjectType()) ||\n               !ownerType.isInstanceType())) {\n            // If the property is undeclared or inferred, declare it now.\n            ownerType.defineDeclaredProperty(propName, valueType, n);\n          }\n        }\n\n        // If the property is already declared, the error will be\n        // caught when we try to declare it in the current scope.\n        defineSlot(n, parent, valueType, inferred);\n      } else if (rhsValue != null &&\n          rhsValue.getType() == Token.TRUE) {\n        // We declare these for delegate proxy method properties.\n        ObjectType ownerType = getObjectSlot(ownerName);\n        if (ownerType instanceof FunctionType) {\n          JSType ownerTypeOfThis = ((FunctionType) ownerType).getTypeOfThis();\n          String delegateName = codingConvention.getDelegateSuperclassName();\n          JSType delegateType = delegateName == null ?\n              null : typeRegistry.getType(delegateName);\n          if (delegateType != null &&\n              ownerTypeOfThis.isSubtype(delegateType)) {\n            defineSlot(n, parent, getNativeType(BOOLEAN_TYPE),\n                true);\n          }\n        }\n      }\n    }",
    "comment": " Declare the symbol for a qualified name in the global scope.  @param info The doc info for this property. @param n A top-level GETPROP node (it should not be contained inside another GETPROP). @param parent The parent of {@code n}. @param rhsValue The node that {@code n} is being initialized to, or {@code null} if this is a stub declaration. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "AbstractScopeBuilder.resolveStubDeclarations",
    "class_name": "com.google.javascript.jscomp.TypedScopeCreator$AbstractScopeBuilder",
    "signature": "com.google.javascript.jscomp.TypedScopeCreator$AbstractScopeBuilder.resolveStubDeclarations()",
    "snippet": "    void resolveStubDeclarations() {\n      for (StubDeclaration stub : stubDeclarations) {\n        Node n = stub.node;\n        Node parent = n.getParent();\n        String qName = n.getQualifiedName();\n        String propName = n.getLastChild().getString();\n        String ownerName = stub.ownerName;\n        boolean isExtern = stub.isExtern;\n\n        if (scope.isDeclared(qName, false)) {\n          continue;\n        }\n\n        // If we see a stub property, make sure to register this property\n        // in the type registry.\n        ObjectType ownerType = getObjectSlot(ownerName);\n        ObjectType unknownType = typeRegistry.getNativeObjectType(UNKNOWN_TYPE);\n        defineSlot(n, parent, unknownType, true);\n\n        if (ownerType != null &&\n            (isExtern || ownerType.isFunctionPrototypeType())) {\n          // If this is a stub for a prototype, just declare it\n          // as an unknown type. These are seen often in externs.\n          ownerType.defineInferredProperty(\n              propName, unknownType, n);\n        } else {\n          typeRegistry.registerPropertyOnType(\n              propName, ownerType == null ? unknownType : ownerType);\n        }\n      }\n    }",
    "comment": " Resolve any stub delcarations to unknown types if we could not find types for them during traversal. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "AbstractScopeBuilder.resolveTypes",
    "class_name": "com.google.javascript.jscomp.TypedScopeCreator$AbstractScopeBuilder",
    "signature": "com.google.javascript.jscomp.TypedScopeCreator$AbstractScopeBuilder.resolveTypes()",
    "snippet": "    void resolveTypes() {\n      // Resolve types and attach them to nodes.\n      for (DeferredSetType deferred : deferredSetTypes) {\n        deferred.resolve(scope);\n      }\n\n      // Resolve types and attach them to scope slots.\n      Iterator<Var> vars = scope.getVars();\n      while (vars.hasNext()) {\n        vars.next().resolveType(typeParsingErrorReporter);\n      }\n\n      // Tell the type registry that any remaining types\n      // are unknown.\n      typeRegistry.resolveTypesInScope(scope);\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "AbstractScopeBuilder.setDeferredType",
    "class_name": "com.google.javascript.jscomp.TypedScopeCreator$AbstractScopeBuilder",
    "signature": "com.google.javascript.jscomp.TypedScopeCreator$AbstractScopeBuilder.setDeferredType(Node,JSType)",
    "snippet": "    void setDeferredType(Node node, JSType type) {\n      deferredSetTypes.add(new DeferredSetType(node, type));\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "AbstractScopeBuilder.shouldTraverse",
    "class_name": "com.google.javascript.jscomp.TypedScopeCreator$AbstractScopeBuilder",
    "signature": "com.google.javascript.jscomp.TypedScopeCreator$AbstractScopeBuilder.shouldTraverse(NodeTraversal,Node,Node)",
    "snippet": "    @Override\n    public final boolean shouldTraverse(NodeTraversal nodeTraversal, Node n,\n        Node parent) {\n      if (n.getType() == Token.FUNCTION ||\n          n.getType() == Token.SCRIPT) {\n        sourceName = NodeUtil.getSourceName(n);\n      }\n\n      // We do want to traverse the name of a named function, but we don't\n      // want to traverse the arguments or body.\n      boolean descend = parent == null || parent.getType() != Token.FUNCTION ||\n          n == parent.getFirstChild() || parent == scope.getRootNode();\n\n      if (descend) {\n        // Handle hoisted functions on pre-order traversal, so that they\n        // get hit before other things in the scope.\n        if (NodeUtil.isStatementParent(n)) {\n          for (Node child = n.getFirstChild();\n               child != null;\n               child = child.getNext()) {\n            if (NodeUtil.isHoistedFunctionDeclaration(child)) {\n              defineFunctionLiteral(child, n);\n            }\n          }\n        }\n      }\n\n      return descend;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "AbstractScopeBuilder.shouldUseFunctionLiteralType",
    "class_name": "com.google.javascript.jscomp.TypedScopeCreator$AbstractScopeBuilder",
    "signature": "com.google.javascript.jscomp.TypedScopeCreator$AbstractScopeBuilder.shouldUseFunctionLiteralType(FunctionType,JSDocInfo,Node)",
    "snippet": "    private boolean shouldUseFunctionLiteralType(\n        FunctionType type, JSDocInfo info, Node lValue) {\n      if (info != null) {\n        return true;\n      }\n      if (lValue != null &&\n          NodeUtil.isObjectLitKey(lValue, lValue.getParent())) {\n        return false;\n      }\n      return scope.isGlobal() || !type.isReturnTypeInferred();\n    }",
    "comment": " If a variable is assigned a function literal in the global scope, make that a declared type (even if there's no doc info). There's only one exception to this rule: if the return type is inferred, and we're in a local scope, we should assume the whole function is inferred. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "AbstractScopeBuilder.visit",
    "class_name": "com.google.javascript.jscomp.TypedScopeCreator$AbstractScopeBuilder",
    "signature": "com.google.javascript.jscomp.TypedScopeCreator$AbstractScopeBuilder.visit(NodeTraversal,Node,Node)",
    "snippet": "    @Override\n    public void visit(NodeTraversal t, Node n, Node parent) {\n      attachLiteralTypes(t, n);\n\n      switch (n.getType()) {\n        case Token.CALL:\n          checkForClassDefiningCalls(t, n, parent);\n          break;\n\n        case Token.FUNCTION:\n          if (t.getInput() == null || !t.getInput().isExtern()) {\n            nonExternFunctions.add(n);\n          }\n\n          // Hoisted functions are handled during pre-traversal.\n          if (!NodeUtil.isHoistedFunctionDeclaration(n)) {\n            defineFunctionLiteral(n, parent);\n          }\n          break;\n\n        case Token.ASSIGN:\n          // Handle initialization of properties.\n          Node firstChild = n.getFirstChild();\n          if (firstChild.getType() == Token.GETPROP &&\n              firstChild.isQualifiedName()) {\n            maybeDeclareQualifiedName(t, n.getJSDocInfo(),\n                firstChild, n, firstChild.getNext());\n          }\n          break;\n\n        case Token.CATCH:\n          defineCatch(n, parent);\n          break;\n\n        case Token.VAR:\n          defineVar(n, parent);\n          break;\n\n        case Token.GETPROP:\n          // Handle stubbed properties.\n          if (parent.getType() == Token.EXPR_RESULT &&\n              n.isQualifiedName()) {\n            maybeDeclareQualifiedName(t, n.getJSDocInfo(), n, parent, null);\n          }\n          break;\n      }\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "DeferredSetType.resolve",
    "class_name": "com.google.javascript.jscomp.TypedScopeCreator$DeferredSetType",
    "signature": "com.google.javascript.jscomp.TypedScopeCreator$DeferredSetType.resolve(Scope)",
    "snippet": "    void resolve(Scope scope) {\n      node.setJSType(type.resolve(typeParsingErrorReporter, scope));\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "DiscoverEnumsAndTypedefs.identifyNameNode",
    "class_name": "com.google.javascript.jscomp.TypedScopeCreator$DiscoverEnumsAndTypedefs",
    "signature": "com.google.javascript.jscomp.TypedScopeCreator$DiscoverEnumsAndTypedefs.identifyNameNode(Node,Node,JSDocInfo)",
    "snippet": "    private void identifyNameNode(\n        Node nameNode, Node valueNode, JSDocInfo info) {\n      if (nameNode.isQualifiedName()) {\n        if (info != null) {\n          if (info.hasEnumParameterType()) {\n            registry.identifyNonNullableName(nameNode.getQualifiedName());\n          } else if (info.hasTypedefType()) {\n            registry.identifyNonNullableName(nameNode.getQualifiedName());\n          }\n        }\n      }\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "DiscoverEnumsAndTypedefs.visit",
    "class_name": "com.google.javascript.jscomp.TypedScopeCreator$DiscoverEnumsAndTypedefs",
    "signature": "com.google.javascript.jscomp.TypedScopeCreator$DiscoverEnumsAndTypedefs.visit(NodeTraversal,Node,Node)",
    "snippet": "    @Override\n    public void visit(NodeTraversal t, Node node, Node parent) {\n      Node nameNode = null;\n      switch (node.getType()) {\n        case Token.VAR:\n          for (Node child = node.getFirstChild();\n               child != null; child = child.getNext()) {\n            identifyNameNode(\n                child, child.getFirstChild(),\n                NodeUtil.getInfoForNameNode(child));\n          }\n          break;\n        case Token.EXPR_RESULT:\n          Node firstChild = node.getFirstChild();\n          if (firstChild.getType() == Token.ASSIGN) {\n            identifyNameNode(\n                firstChild.getFirstChild(), firstChild.getLastChild(),\n                firstChild.getJSDocInfo());\n          } else {\n            identifyNameNode(\n                firstChild, null, firstChild.getJSDocInfo());\n          }\n          break;\n      }\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "GlobalScopeBuilder.checkForTypedef",
    "class_name": "com.google.javascript.jscomp.TypedScopeCreator$GlobalScopeBuilder",
    "signature": "com.google.javascript.jscomp.TypedScopeCreator$GlobalScopeBuilder.checkForTypedef(NodeTraversal,Node,JSDocInfo)",
    "snippet": "    private void checkForTypedef(\n        NodeTraversal t, Node candidate, JSDocInfo info) {\n      if (info == null || !info.hasTypedefType()) {\n        return;\n      }\n\n      String typedef = candidate.getQualifiedName();\n      if (typedef == null) {\n        return;\n      }\n\n      // TODO(nicksantos|user): This is a terrible, terrible hack\n      // to bail out on recusive typedefs. We'll eventually need\n      // to handle these properly.\n      typeRegistry.declareType(typedef, getNativeType(UNKNOWN_TYPE));\n\n      JSType realType = info.getTypedefType().evaluate(scope, typeRegistry);\n      if (realType == null) {\n        compiler.report(\n            JSError.make(\n                t.getSourceName(), candidate, MALFORMED_TYPEDEF, typedef));\n      }\n\n      typeRegistry.overwriteDeclaredType(typedef, realType);\n      if (candidate.getType() == Token.GETPROP) {\n        defineSlot(candidate, candidate.getParent(),\n            getNativeType(NO_TYPE), false);\n      }\n    }",
    "comment": " Handle typedefs. @param t The current traversal. @param candidate A qualified name node. @param info JSDoc comments. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "GlobalScopeBuilder.maybeDeclareQualifiedName",
    "class_name": "com.google.javascript.jscomp.TypedScopeCreator$GlobalScopeBuilder",
    "signature": "com.google.javascript.jscomp.TypedScopeCreator$GlobalScopeBuilder.maybeDeclareQualifiedName(NodeTraversal,JSDocInfo,Node,Node,Node)",
    "snippet": "    @Override\n    void maybeDeclareQualifiedName(\n        NodeTraversal t, JSDocInfo info,\n        Node n, Node parent, Node rhsValue) {\n      checkForTypedef(t, n, info);\n      super.maybeDeclareQualifiedName(t, info, n, parent, rhsValue);\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "GlobalScopeBuilder.visit",
    "class_name": "com.google.javascript.jscomp.TypedScopeCreator$GlobalScopeBuilder",
    "signature": "com.google.javascript.jscomp.TypedScopeCreator$GlobalScopeBuilder.visit(NodeTraversal,Node,Node)",
    "snippet": "    @Override public void visit(NodeTraversal t, Node n, Node parent) {\n      super.visit(t, n, parent);\n\n      switch (n.getType()) {\n\n        case Token.VAR:\n          // Handle typedefs.\n          if (n.hasOneChild()) {\n            checkForTypedef(t, n.getFirstChild(), n.getJSDocInfo());\n          }\n          break;\n      }\n    }",
    "comment": " Visit a node in the global scope, and add anything it declares to the global symbol table.  @param t The current traversal. @param n The node being visited. @param parent The parent of n ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "LocalScopeBuilder.build",
    "class_name": "com.google.javascript.jscomp.TypedScopeCreator$LocalScopeBuilder",
    "signature": "com.google.javascript.jscomp.TypedScopeCreator$LocalScopeBuilder.build()",
    "snippet": "    void build() {\n      NodeTraversal.traverse(compiler, scope.getRootNode(), this);\n    }",
    "comment": " Traverse the scope root and build it. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "LocalScopeBuilder.declareArguments",
    "class_name": "com.google.javascript.jscomp.TypedScopeCreator$LocalScopeBuilder",
    "signature": "com.google.javascript.jscomp.TypedScopeCreator$LocalScopeBuilder.declareArguments(Node)",
    "snippet": "    private void declareArguments(Node functionNode) {\n      Node astParameters = functionNode.getFirstChild().getNext();\n      Node body = astParameters.getNext();\n      FunctionType functionType = (FunctionType) functionNode.getJSType();\n      if (functionType != null) {\n        Node jsDocParameters = functionType.getParametersNode();\n        if (jsDocParameters != null) {\n          Node jsDocParameter = jsDocParameters.getFirstChild();\n          for (Node astParameter : astParameters.children()) {\n            if (jsDocParameter != null) {\n              defineSlot(astParameter, functionNode,\n                  jsDocParameter.getJSType(), false);\n              jsDocParameter = jsDocParameter.getNext();\n            } else {\n              defineSlot(astParameter, functionNode, null, true);\n            }\n          }\n        }\n      }\n    } // end declareArguments",
    "comment": " Declares all of a function's arguments. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "LocalScopeBuilder.handleFunctionInputs",
    "class_name": "com.google.javascript.jscomp.TypedScopeCreator$LocalScopeBuilder",
    "signature": "com.google.javascript.jscomp.TypedScopeCreator$LocalScopeBuilder.handleFunctionInputs(Node)",
    "snippet": "    private void handleFunctionInputs(Node fnNode) {\n      // Handle bleeding functions.\n      Node fnNameNode = fnNode.getFirstChild();\n      String fnName = fnNameNode.getString();\n      if (!fnName.isEmpty()) {\n        Scope.Var fnVar = scope.getVar(fnName);\n        if (fnVar == null ||\n            // Make sure we're not touching a native function. Native\n            // functions aren't bleeding, but may not have a declaration\n            // node.\n            (fnVar.getNameNode() != null &&\n                // Make sure that the function is actually bleeding by checking\n                // if has already been declared.\n                fnVar.getInitialValue() != fnNode)) {\n          defineSlot(fnNameNode, fnNode, fnNode.getJSType(), false);\n        }\n      }\n\n      declareArguments(fnNode);\n    }",
    "comment": "Handle bleeding functions and function parameters. */",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "LocalScopeBuilder.visit",
    "class_name": "com.google.javascript.jscomp.TypedScopeCreator$LocalScopeBuilder",
    "signature": "com.google.javascript.jscomp.TypedScopeCreator$LocalScopeBuilder.visit(NodeTraversal,Node,Node)",
    "snippet": "    @Override public void visit(NodeTraversal t, Node n, Node parent) {\n      if (n == scope.getRootNode()) return;\n\n      if (n.getType() == Token.LP && parent == scope.getRootNode()) {\n        handleFunctionInputs(parent);\n        return;\n      }\n\n      super.visit(t, n, parent);\n    }",
    "comment": " Visit a node in a local scope, and add any local variables or catch parameters into the local symbol table.  @param t The node traversal. @param n The node being visited. @param parent The parent of n ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "UnreachableCodeElimination.UnreachableCodeElimination",
    "class_name": "com.google.javascript.jscomp.UnreachableCodeElimination",
    "signature": "com.google.javascript.jscomp.UnreachableCodeElimination.UnreachableCodeElimination(AbstractCompiler,boolean)",
    "snippet": "  UnreachableCodeElimination(AbstractCompiler compiler,\n      boolean removeNoOpStatements) {\n    this.compiler = compiler;\n    this.removeNoOpStatements = removeNoOpStatements;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "UnreachableCodeElimination.enterScope",
    "class_name": "com.google.javascript.jscomp.UnreachableCodeElimination",
    "signature": "com.google.javascript.jscomp.UnreachableCodeElimination.enterScope(NodeTraversal)",
    "snippet": "  @Override\n  public void enterScope(NodeTraversal t) {\n    Scope scope = t.getScope();\n\n    // Computes the control flow graph.\n    ControlFlowAnalysis cfa = new ControlFlowAnalysis(compiler, false, false);\n    cfa.process(null, scope.getRootNode());\n    cfgStack.push(curCfg);\n    curCfg = cfa.getCfg();\n\n    new GraphReachability<Node, ControlFlowGraph.Branch>(curCfg)\n        .compute(curCfg.getEntry().getValue());\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "UnreachableCodeElimination.exitScope",
    "class_name": "com.google.javascript.jscomp.UnreachableCodeElimination",
    "signature": "com.google.javascript.jscomp.UnreachableCodeElimination.exitScope(NodeTraversal)",
    "snippet": "  @Override\n  public void exitScope(NodeTraversal t) {\n    curCfg = cfgStack.pop();\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "UnreachableCodeElimination.process",
    "class_name": "com.google.javascript.jscomp.UnreachableCodeElimination",
    "signature": "com.google.javascript.jscomp.UnreachableCodeElimination.process(Node,Node)",
    "snippet": "  @Override\n  public void process(Node externs, Node root) {\n    NodeTraversal.traverse(compiler, root, this);\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "UnreachableCodeElimination.tryRemoveUnconditionalBranching",
    "class_name": "com.google.javascript.jscomp.UnreachableCodeElimination",
    "signature": "com.google.javascript.jscomp.UnreachableCodeElimination.tryRemoveUnconditionalBranching(Node)",
    "snippet": "  @SuppressWarnings(\"fallthrough\")\n  private Node tryRemoveUnconditionalBranching(Node n) {\n    /*\n     * For each of the unconditional branching control flow node, check to see\n     * if the ControlFlowAnalysis.computeFollowNode of that node is same as\n     * the branching target. If it is, the branch node is safe to be removed.\n     *\n     * This is not as clever as MinimizeExitPoints because it doesn't do any\n     * if-else conversion but it handles more complicated switch statements\n     * much nicer.\n     */\n\n    // If n is null the target is the end of the function, nothing to do.\n    if (n == null) {\n       return n;\n    }\n\n    DiGraphNode<Node, Branch> gNode = curCfg.getDirectedGraphNode(n);\n\n    if (gNode == null) {\n      return n;\n    }\n\n    switch (n.getType()) {\n      case Token.RETURN:\n        if (n.hasChildren()) {\n          break;\n        }\n      case Token.BREAK:\n      case Token.CONTINUE:\n\n        // We are looking for a control flow changing statement that always\n        // branches to the same node. If removing it the control flow still\n        // branches to that same node. It is safe to remove it.\n        List<DiGraphEdge<Node,Branch>> outEdges = gNode.getOutEdges();\n        if (outEdges.size() == 1 &&\n            // If there is a next node, there is no chance this jump is useless.\n            (n.getNext() == null || n.getNext().getType() == Token.FUNCTION)) {\n\n          Preconditions.checkState(outEdges.get(0).getValue() == Branch.UNCOND);\n          Node fallThrough = computeFollowing(n);\n          Node nextCfgNode = outEdges.get(0).getDestination().getValue();\n          if (nextCfgNode == fallThrough) {\n            removeDeadExprStatementSafely(n);\n            return fallThrough;\n          }\n        }\n    }\n    return n;\n  }",
    "comment": " Tries to remove n if an unconditional branch node (break, continue or return) if the target of n is the same as the the follow of n. That is, if we remove n, the control flow remains the same. Also if n targets to another unconditional branch, this function will recursively try to remove the target branch as well. The reason why we want to cascade this removal is because we only run this pass once. If we have code such as  break -> break -> break  where all 3 break's are useless. The order of removal matters. When we first look at the first break, we see that it branches to the 2nd break. However, if we remove the last break, the 2nd break becomes useless and finally the first break becomes useless as well.  @return The target of this jump. If the target is also useless jump, the target of that useless jump recursively. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "UnreachableCodeElimination.visit",
    "class_name": "com.google.javascript.jscomp.UnreachableCodeElimination",
    "signature": "com.google.javascript.jscomp.UnreachableCodeElimination.visit(NodeTraversal,Node,Node)",
    "snippet": "  @Override\n  public void visit(NodeTraversal t, Node n, Node parent) {\n    if (parent == null) {\n      return;\n    }\n    if (n.getType() == Token.FUNCTION || n.getType() == Token.SCRIPT) {\n      return;\n    }\n\n    DiGraphNode<Node, Branch> gNode = curCfg.getDirectedGraphNode(n);\n    if (gNode == null) { // Not in CFG.\n      return;\n    }\n    if (gNode.getAnnotation() != GraphReachability.REACHABLE ||\n        (removeNoOpStatements && !NodeUtil.mayHaveSideEffects(n))) {\n      removeDeadExprStatementSafely(n);\n      return;\n    }\n\n    tryRemoveUnconditionalBranching(n);\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "VarCheck.VarCheck",
    "class_name": "com.google.javascript.jscomp.VarCheck",
    "signature": "com.google.javascript.jscomp.VarCheck.VarCheck(AbstractCompiler)",
    "snippet": "  VarCheck(AbstractCompiler compiler) {\n    this(compiler, false);\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "VarCheck.VarCheck",
    "class_name": "com.google.javascript.jscomp.VarCheck",
    "signature": "com.google.javascript.jscomp.VarCheck.VarCheck(AbstractCompiler,boolean)",
    "snippet": "  VarCheck(AbstractCompiler compiler, boolean sanityCheck) {\n    this.compiler = compiler;\n    this.strictExternCheck = compiler.getErrorLevel(\n        JSError.make(\"\", 0, 0, UNDEFINED_EXTERN_VAR_ERROR)) == CheckLevel.ERROR;\n    this.sanityCheck = sanityCheck;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "VarCheck.process",
    "class_name": "com.google.javascript.jscomp.VarCheck",
    "signature": "com.google.javascript.jscomp.VarCheck.process(Node,Node)",
    "snippet": "  @Override\n  public void process(Node externs, Node root) {\n    // Don't run externs-checking in sanity check mode. Normalization will\n    // remove duplicate VAR declarations, which will make\n    // externs look like they have assigns.\n    if (!sanityCheck) {\n      NodeTraversal.traverse(compiler, externs, new NameRefInExternsCheck());\n    }\n\n    NodeTraversal.traverseRoots(\n        compiler, Lists.newArrayList(externs, root), this);\n    for (String varName : varsToDeclareInExterns) {\n      createSynthesizedExternVar(varName);\n    }\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "VarCheck.visit",
    "class_name": "com.google.javascript.jscomp.VarCheck",
    "signature": "com.google.javascript.jscomp.VarCheck.visit(NodeTraversal,Node,Node)",
    "snippet": "  @Override\n  public void visit(NodeTraversal t, Node n, Node parent) {\n    if (n.getType() != Token.NAME) {\n      return;\n    }\n\n    String varName = n.getString();\n\n    // Only a function can have an empty name.\n    if (varName.isEmpty()) {\n      Preconditions.checkState(NodeUtil.isFunction(parent));\n\n      // A function declaration with an empty name passes Rhino,\n      // but is supposed to be a syntax error according to the spec.\n      if (!NodeUtil.isFunctionExpression(parent)) {\n        t.report(n, INVALID_FUNCTION_DECL);\n      }\n      return;\n    }\n\n    // Check if this is a declaration for a var that has been declared\n    // elsewhere. If so, mark it as a duplicate.\n    if ((parent.getType() == Token.VAR ||\n         NodeUtil.isFunctionDeclaration(parent)) &&\n        varsToDeclareInExterns.contains(varName)) {\n      createSynthesizedExternVar(varName);\n\n      n.addSuppression(\"duplicate\");\n    }\n\n    // Check that the var has been declared.\n    Scope scope = t.getScope();\n    Scope.Var var = scope.getVar(varName);\n    if (var == null) {\n      if (NodeUtil.isFunctionExpression(parent)) {\n        // e.g. [ function foo() {} ], it's okay if \"foo\" isn't defined in the\n        // current scope.\n      } else {\n        // The extern checks are stricter, don't report a second error.\n        if (!strictExternCheck || !t.getInput().isExtern()) {\n          t.report(n, UNDEFINED_VAR_ERROR, varName);\n        }\n\n        if (sanityCheck) {\n          throw new IllegalStateException(\"Unexpected variable \" + varName);\n        } else {\n          createSynthesizedExternVar(varName);\n          scope.getGlobalScope().declare(varName, n,\n              null, getSynthesizedExternsInput());\n        }\n      }\n      return;\n    }\n\n    CompilerInput currInput = t.getInput();\n    CompilerInput varInput = var.input;\n    if (currInput == varInput || currInput == null || varInput == null) {\n      // The variable was defined in the same file. This is fine.\n      return;\n    }\n\n    // Check module dependencies.\n    JSModule currModule = currInput.getModule();\n    JSModule varModule = varInput.getModule();\n    JSModuleGraph moduleGraph = compiler.getModuleGraph();\n    if (varModule != currModule && varModule != null && currModule != null) {\n      if (moduleGraph.dependsOn(currModule, varModule)) {\n        // The module dependency was properly declared.\n      } else {\n        if (!sanityCheck && scope.isGlobal()) {\n          if (moduleGraph.dependsOn(varModule, currModule)) {\n            // The variable reference violates a declared module dependency.\n            t.report(n, VIOLATED_MODULE_DEP_ERROR,\n                     currModule.getName(), varModule.getName(), varName);\n          } else {\n            // The variable reference is between two modules that have no\n            // dependency relationship. This should probably be considered an\n            // error, but just issue a warning for now.\n            t.report(n, MISSING_MODULE_DEP_ERROR,\n                     currModule.getName(), varModule.getName(), varName);\n          }\n        } else {\n          t.report(n, STRICT_MODULE_DEP_ERROR,\n                   currModule.getName(), varModule.getName(), varName);\n        }\n      }\n    }\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "NameRefInExternsCheck.visit",
    "class_name": "com.google.javascript.jscomp.VarCheck$NameRefInExternsCheck",
    "signature": "com.google.javascript.jscomp.VarCheck$NameRefInExternsCheck.visit(NodeTraversal,Node,Node)",
    "snippet": "    public void visit(NodeTraversal t, Node n, Node parent) {\n      if (n.getType() == Token.NAME) {\n        switch (parent.getType()) {\n          case Token.VAR:\n          case Token.FUNCTION:\n          case Token.LP:\n            // These are okay.\n            break;\n          case Token.GETPROP:\n            if (n == parent.getFirstChild()) {\n              Scope scope = t.getScope();\n              Scope.Var var = scope.getVar(n.getString());\n              if (var == null) {\n                t.report(n, UNDEFINED_EXTERN_VAR_ERROR, n.getString());\n                varsToDeclareInExterns.add(n.getString());\n              }\n            }\n            break;\n          default:\n            t.report(n, NAME_REFERENCE_IN_EXTERNS_ERROR, n.getString());\n\n            Scope scope = t.getScope();\n            Scope.Var var = scope.getVar(n.getString());\n            if (var == null) {\n              varsToDeclareInExterns.add(n.getString());\n            }\n            break;\n        }\n      }\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "VariableMap.VariableMap",
    "class_name": "com.google.javascript.jscomp.VariableMap",
    "signature": "com.google.javascript.jscomp.VariableMap.VariableMap(Map)",
    "snippet": "  VariableMap(Map<String, String> map) {\n    this.map = Collections.unmodifiableMap(map);\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "VariableNameGenerator.VariableNameGenerator",
    "class_name": "com.google.javascript.jscomp.VariableNameGenerator",
    "signature": "com.google.javascript.jscomp.VariableNameGenerator.VariableNameGenerator(Scope)",
    "snippet": "  VariableNameGenerator(Scope scope) {\n    this.scope = scope;\n    Set<String> usedNames = Sets.newHashSet();\n    names = new NameGenerator(usedNames, \"\", null);\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "VariableReferenceCheck.VariableReferenceCheck",
    "class_name": "com.google.javascript.jscomp.VariableReferenceCheck",
    "signature": "com.google.javascript.jscomp.VariableReferenceCheck.VariableReferenceCheck(AbstractCompiler,CheckLevel)",
    "snippet": "  public VariableReferenceCheck(AbstractCompiler compiler,\n      CheckLevel checkLevel) {\n    this.compiler = compiler;\n    this.checkLevel = checkLevel;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "VariableReferenceCheck.process",
    "class_name": "com.google.javascript.jscomp.VariableReferenceCheck",
    "signature": "com.google.javascript.jscomp.VariableReferenceCheck.process(Node,Node)",
    "snippet": "  @Override\n  public void process(Node externs, Node root) {\n    ReferenceCollectingCallback callback = new ReferenceCollectingCallback(\n        compiler, new ReferenceCheckingBehavior());\n    callback.process(externs, root);\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "ReferenceCheckingBehavior.afterExitScope",
    "class_name": "com.google.javascript.jscomp.VariableReferenceCheck$ReferenceCheckingBehavior",
    "signature": "com.google.javascript.jscomp.VariableReferenceCheck$ReferenceCheckingBehavior.afterExitScope(NodeTraversal,ReferenceMap)",
    "snippet": "    @Override\n    public void afterExitScope(NodeTraversal t, ReferenceMap referenceMap) {\n      // TODO(bashir) In hot-swap version this means that for global scope we\n      // only go through all global variables accessed in the modified file not\n      // all global variables. This should be fixed.\n\n      // Check all vars after finishing a scope\n      for (Iterator<Var> it = t.getScope().getVars(); it.hasNext();) {\n        Var v = it.next();\n        checkVar(t, v, referenceMap.getReferences(v).references);\n      }\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "ReferenceCheckingBehavior.checkVar",
    "class_name": "com.google.javascript.jscomp.VariableReferenceCheck$ReferenceCheckingBehavior",
    "signature": "com.google.javascript.jscomp.VariableReferenceCheck$ReferenceCheckingBehavior.checkVar(NodeTraversal,Var,List)",
    "snippet": "    private void checkVar(NodeTraversal t, Var v, List<Reference> references) {\n      blocksWithDeclarations.clear();\n      boolean isDeclaredInScope = false;\n      boolean isUnhoistedNamedFunction = false;\n      Reference hoistedFn = null;\n\n      // Look for hoisted functions.\n      for (Reference reference : references) {\n        if (reference.isHoistedFunction()) {\n          blocksWithDeclarations.add(reference.getBasicBlock());\n          isDeclaredInScope = true;\n          hoistedFn = reference;\n          break;\n        } else if (NodeUtil.isFunctionDeclaration(\n            reference.getNode().getParent())) {\n          isUnhoistedNamedFunction = true;\n        }\n      }\n\n      for (Reference reference : references) {\n        if (reference == hoistedFn) {\n          continue;\n        }\n\n        BasicBlock basicBlock = reference.getBasicBlock();\n        boolean isDeclaration = reference.isDeclaration();\n\n        boolean allowDupe =\n            SyntacticScopeCreator.hasDuplicateDeclarationSuppression(\n                reference.getNode(), v);\n        if (isDeclaration && !allowDupe) {\n          // Look through all the declarations we've found so far, and\n          // check if any of them are before this block.\n          for (BasicBlock declaredBlock : blocksWithDeclarations) {\n            if (declaredBlock.provablyExecutesBefore(basicBlock)) {\n              compiler.report(\n                  JSError.make(reference.getSourceFile().getName(),\n                      reference.getNode(),\n                      checkLevel,\n                      REDECLARED_VARIABLE, v.name));\n              break;\n            }\n          }\n        }\n\n        if (isUnhoistedNamedFunction && !isDeclaration && isDeclaredInScope) {\n          // Only allow an unhoisted named function to be used within the\n          // block it is declared.\n          for (BasicBlock declaredBlock : blocksWithDeclarations) {\n            if (!declaredBlock.provablyExecutesBefore(basicBlock)) {\n              compiler.report(\n                  JSError.make(reference.getSourceFile().getName(),\n                      reference.getNode(),\n                      AMBIGUOUS_FUNCTION_DECL, v.name));\n              break;\n            }\n          }\n        }\n\n        if (!isDeclaration && !isDeclaredInScope) {\n          // Don't check the order of refer in externs files.\n          if (!reference.getSourceFile().isExtern()) {\n            // Special case to deal with var goog = goog || {}\n            Node grandparent = reference.getGrandparent();\n            if (grandparent.getType() == Token.NAME\n                && grandparent.getString() == v.name) {\n              continue;\n            }\n\n            // Only generate warnings if the scopes do not match in order\n            // to deal with possible forward declarations and recursion\n            if (reference.getScope() == v.scope) {\n              compiler.report(\n                  JSError.make(reference.getSourceFile().getName(),\n                               reference.getNode(),\n                               checkLevel,\n                               UNDECLARED_REFERENCE, v.name));\n            }\n          }\n        }\n\n        if (isDeclaration) {\n          blocksWithDeclarations.add(basicBlock);\n          isDeclaredInScope = true;\n        }\n      }\n    }",
    "comment": " If the variable is declared more than once in a basic block, generate a warning. Also check if a variable is used in a given scope before it is declared, which suggest a likely error. Relies on the fact that references is in parse-tree order. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "WarningLevel.addDefaultWarnings",
    "class_name": "com.google.javascript.jscomp.WarningLevel",
    "signature": "com.google.javascript.jscomp.WarningLevel.addDefaultWarnings(CompilerOptions)",
    "snippet": "  private static void addDefaultWarnings(CompilerOptions options) {\n    options.checkSuspiciousCode = true;\n    options.checkUnreachableCode = CheckLevel.WARNING;\n    options.checkControlStructures = true;\n  }",
    "comment": " Add the default checking pass to the compilation options. @param options The CompilerOptions object to set the options on. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "WarningLevel.addVerboseWarnings",
    "class_name": "com.google.javascript.jscomp.WarningLevel",
    "signature": "com.google.javascript.jscomp.WarningLevel.addVerboseWarnings(CompilerOptions)",
    "snippet": "  private static void addVerboseWarnings(CompilerOptions options) {\n    addDefaultWarnings(options);\n\n    // checkSuspiciousCode needs to be enabled for CheckGlobalThis to get run.\n    options.checkSuspiciousCode = true;\n    options.checkGlobalThisLevel = CheckLevel.WARNING;\n    options.checkSymbols = true;\n    options.checkMissingReturn = CheckLevel.WARNING;\n\n    // checkTypes has the side-effect of asserting that the\n    // correct number of arguments are passed to a function.\n    // Because the CodingConvention used with the web service does not provide a\n    // way for optional arguments to be specified, these warnings may result in\n    // false positives.\n    options.checkTypes = true;\n    options.checkGlobalNamesLevel = CheckLevel.WARNING;\n    options.aggressiveVarCheck = CheckLevel.WARNING;\n    options.setWarningLevel(\n        DiagnosticGroups.MISSING_PROPERTIES, CheckLevel.WARNING);\n    options.setWarningLevel(\n        DiagnosticGroups.DEPRECATED, CheckLevel.WARNING);\n  }",
    "comment": " Add all the check pass that are possibly relevant to a non googler. @param options The CompilerOptions object to set the options on. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "WarningLevel.setOptionsForWarningLevel",
    "class_name": "com.google.javascript.jscomp.WarningLevel",
    "signature": "com.google.javascript.jscomp.WarningLevel.setOptionsForWarningLevel(CompilerOptions)",
    "snippet": "  public void setOptionsForWarningLevel(CompilerOptions options) {\n    switch (this) {\n      case QUIET:\n        silenceAllWarnings(options);\n        break;\n      case DEFAULT:\n        addDefaultWarnings(options);\n        break;\n      case VERBOSE:\n        addVerboseWarnings(options);\n        break;\n      default:\n        throw new RuntimeException(\"Unknown warning level.\");\n    }\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "WarningsGuard.getPriority",
    "class_name": "com.google.javascript.jscomp.WarningsGuard",
    "signature": "com.google.javascript.jscomp.WarningsGuard.getPriority()",
    "snippet": "  protected int getPriority() {\n    return Priority.DEFAULT.value;\n  }",
    "comment": " The priority in which warnings guards are applied. Lower means the guard will be applied sooner. Expressed on a scale of 1 to 100. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "DiGraph.isConnected",
    "class_name": "com.google.javascript.jscomp.graph.DiGraph",
    "signature": "com.google.javascript.jscomp.graph.DiGraph.isConnected(N,E,N)",
    "snippet": "  @Override\n  public boolean isConnected(N n1, E e, N n2) {\n    return isConnectedInDirection(n1, e, n2) ||\n        isConnectedInDirection(n2, e, n1);\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "FixedPointGraphTraversal.FixedPointGraphTraversal",
    "class_name": "com.google.javascript.jscomp.graph.FixedPointGraphTraversal",
    "signature": "com.google.javascript.jscomp.graph.FixedPointGraphTraversal.FixedPointGraphTraversal(EdgeCallback)",
    "snippet": "  public FixedPointGraphTraversal(EdgeCallback<N, E> callback) {\n    this.callback = callback;\n  }",
    "comment": " Create a new traversal. @param callback A callback for updating the state of the graph each time an edge is traversed. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "FixedPointGraphTraversal.computeFixedPoint",
    "class_name": "com.google.javascript.jscomp.graph.FixedPointGraphTraversal",
    "signature": "com.google.javascript.jscomp.graph.FixedPointGraphTraversal.computeFixedPoint(DiGraph,N)",
    "snippet": "  public void computeFixedPoint(DiGraph<N, E> graph, N entry) {\n    Set<N> entrySet = Sets.newHashSet();\n    entrySet.add(entry);\n    computeFixedPoint(graph, entrySet);\n  }",
    "comment": " Compute a fixed point for the given graph, entering from the given node. @param graph The graph to traverse. @param entry The node to begin traversing from. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "FixedPointGraphTraversal.computeFixedPoint",
    "class_name": "com.google.javascript.jscomp.graph.FixedPointGraphTraversal",
    "signature": "com.google.javascript.jscomp.graph.FixedPointGraphTraversal.computeFixedPoint(DiGraph,Set)",
    "snippet": "  public void computeFixedPoint(DiGraph<N, E> graph, Set<N> entrySet) {\n    int cycleCount = 0;\n    long nodeCount = graph.getNodes().size();\n\n    // Choose a bail-out heuristically in case the computation\n    // doesn't converge.\n    long maxIterations = Math.max(nodeCount * nodeCount * nodeCount, 100);\n\n    // Use a LinkedHashSet, so that the traversal is deterministic.\n    LinkedHashSet<DiGraphNode<N, E>> workSet =\n        Sets.newLinkedHashSet();\n    for (N n : entrySet) {\n      workSet.add(graph.getDirectedGraphNode(n));\n    }\n    for (; !workSet.isEmpty() && cycleCount < maxIterations; cycleCount++) {\n      // For every out edge in the workSet, traverse that edge. If that\n      // edge updates the state of the graph, then add the destination\n      // node to the resultSet, so that we can update all of its out edges\n      // on the next iteration.\n      DiGraphNode<N, E> source = workSet.iterator().next();\n      N sourceValue = source.getValue();\n\n      workSet.remove(source);\n\n      List<DiGraphEdge<N, E>> outEdges = source.getOutEdges();\n      for (DiGraphEdge<N, E> edge : outEdges) {\n        N destNode = edge.getDestination().getValue();\n        if (callback.traverseEdge(sourceValue, edge.getValue(), destNode)) {\n          workSet.add(edge.getDestination());\n        }\n      }\n    }\n\n    Preconditions.checkState(cycleCount != maxIterations,\n        NON_HALTING_ERROR_MSG);\n  }",
    "comment": " Compute a fixed point for the given graph, entering from the given nodes. @param graph The graph to traverse. @param entrySet The nodes to begin traversing from. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "FixedPointGraphTraversal.newTraversal",
    "class_name": "com.google.javascript.jscomp.graph.FixedPointGraphTraversal",
    "signature": "com.google.javascript.jscomp.graph.FixedPointGraphTraversal.newTraversal(EdgeCallback)",
    "snippet": "  public static <NODE, EDGE> FixedPointGraphTraversal<NODE, EDGE> newTraversal(\n      EdgeCallback<NODE, EDGE> callback) {\n    return new FixedPointGraphTraversal<NODE, EDGE>(callback);\n  }",
    "comment": " Helper method for creating new traversals. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "Graph.clearNodeAnnotations",
    "class_name": "com.google.javascript.jscomp.graph.Graph",
    "signature": "com.google.javascript.jscomp.graph.Graph.clearNodeAnnotations()",
    "snippet": "  public final void clearNodeAnnotations() {\n    for (GraphNode<N, E> n : getNodes()) {\n      n.setAnnotation(null);\n    }\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "Graph.connectIfNotFound",
    "class_name": "com.google.javascript.jscomp.graph.Graph",
    "signature": "com.google.javascript.jscomp.graph.Graph.connectIfNotFound(N,E,N)",
    "snippet": "  public final void connectIfNotFound(N n1, E edge, N n2) {\n    if (!isConnected(n1, edge, n2)) {\n      connect(n1, edge, n2);\n    }\n  }",
    "comment": " Connects two nodes in the graph with an edge if such edge does not already exists between the nodes.  @param n1 First node. @param edge The edge. @param n2 Second node. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "Graph.getNodeOrFail",
    "class_name": "com.google.javascript.jscomp.graph.Graph",
    "signature": "com.google.javascript.jscomp.graph.Graph.getNodeOrFail(N)",
    "snippet": "  @SuppressWarnings(\"unchecked\")\n  <T extends GraphNode<N, E>> T getNodeOrFail(N val) {\n    T node = (T) getNode(val);\n    if (node == null) {\n      throw new IllegalArgumentException(val + \" does not exist in graph\");\n    }\n    return node;\n  }",
    "comment": " Gets the node of the specified type, or throws an IllegalArgumentException. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "GraphColoring.GraphColoring",
    "class_name": "com.google.javascript.jscomp.graph.GraphColoring",
    "signature": "com.google.javascript.jscomp.graph.GraphColoring.GraphColoring(AdjacencyGraph)",
    "snippet": "  public GraphColoring(AdjacencyGraph<N, E> graph) {\n    this.graph = graph;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "GreedyGraphColoring.color",
    "class_name": "com.google.javascript.jscomp.graph.GraphColoring$GreedyGraphColoring",
    "signature": "com.google.javascript.jscomp.graph.GraphColoring$GreedyGraphColoring.color()",
    "snippet": "    @Override\n    public int color() {\n      graph.clearNodeAnnotations();\n      List<GraphNode<N, E>> worklist = Lists.newArrayList(graph.getNodes());\n\n      // Sort nodes by degree.\n      Collections.sort(worklist, new Comparator<GraphNode<N, E>>() {\n        @Override\n        public int compare(GraphNode<N, E> o1, GraphNode<N, E> o2) {\n          int result = graph.getWeight(o2.getValue())\n              - graph.getWeight(o1.getValue());\n          return result == 0 && tieBreaker != null ?\n              tieBreaker.compare(o1.getValue(), o2.getValue()) : result;\n        }\n      });\n\n      // Idea: From the highest to lowest degree, assign any uncolored node with\n      // a unique color if none of its neighbor has been assigned that color.\n      int count = 0;\n      do {\n        Color color = new Color(count);\n        SubGraph<N, E> subgraph = graph.newSubGraph();\n        for (Iterator<GraphNode<N, E>> i = worklist.iterator(); i.hasNext();) {\n          GraphNode<N, E> node = i.next();\n          if (subgraph.isIndependentOf(node.getValue())) {\n            subgraph.addNode(node.getValue());\n            node.setAnnotation(color);\n            i.remove();\n          }\n        }\n        count++;\n      } while (!worklist.isEmpty());\n      @SuppressWarnings(\"unchecked\")\n      N[] map = (N[]) new Object[count];\n      colorToNodeMap = map;\n      return count;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "GraphReachability.GraphReachability",
    "class_name": "com.google.javascript.jscomp.graph.GraphReachability",
    "signature": "com.google.javascript.jscomp.graph.GraphReachability.GraphReachability(DiGraph)",
    "snippet": "  public GraphReachability(DiGraph<N, E> graph) {\n    this(graph, null);\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "GraphReachability.GraphReachability",
    "class_name": "com.google.javascript.jscomp.graph.GraphReachability",
    "signature": "com.google.javascript.jscomp.graph.GraphReachability.GraphReachability(DiGraph,Predicate)",
    "snippet": "  public GraphReachability(DiGraph<N, E> graph,\n                           Predicate<EdgeTuple<N, E>> edgePredicate) {\n    this.graph = graph;\n    this.edgePredicate = edgePredicate;\n  }",
    "comment": " @param graph The graph. @param edgePredicate Given the predecessor P of the a node S and the edge coming from P to S, this predicate should return true if S is reachable from P using the edge. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "GraphReachability.compute",
    "class_name": "com.google.javascript.jscomp.graph.GraphReachability",
    "signature": "com.google.javascript.jscomp.graph.GraphReachability.compute(N)",
    "snippet": "  public void compute(N entry) {\n    graph.clearNodeAnnotations();\n    graph.getNode(entry).setAnnotation(REACHABLE);\n    FixedPointGraphTraversal.newTraversal(this)\n        .computeFixedPoint(graph, entry);\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "GraphReachability.traverseEdge",
    "class_name": "com.google.javascript.jscomp.graph.GraphReachability",
    "signature": "com.google.javascript.jscomp.graph.GraphReachability.traverseEdge(N,E,N)",
    "snippet": "  @Override\n  public boolean traverseEdge(N source, E e, N destination) {\n    if (graph.getNode(source).getAnnotation() == REACHABLE &&\n        (edgePredicate == null ||\n            edgePredicate.apply(new EdgeTuple<N, E>(source, e, destination)))) {\n      GraphNode<N, E> destNode = graph.getNode(destination);\n      if (destNode.getAnnotation() != REACHABLE) {\n        destNode.setAnnotation(REACHABLE);\n        return true;\n      }\n    }\n    return false;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "LinkedDirectedGraph.LinkedDirectedGraph",
    "class_name": "com.google.javascript.jscomp.graph.LinkedDirectedGraph",
    "signature": "com.google.javascript.jscomp.graph.LinkedDirectedGraph.LinkedDirectedGraph(boolean,boolean)",
    "snippet": "  protected LinkedDirectedGraph(\n      boolean useNodeAnnotations, boolean useEdgeAnnotations) {\n    this.useNodeAnnotations = useNodeAnnotations;\n    this.useEdgeAnnotations = useEdgeAnnotations;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "LinkedDirectedGraph.connect",
    "class_name": "com.google.javascript.jscomp.graph.LinkedDirectedGraph",
    "signature": "com.google.javascript.jscomp.graph.LinkedDirectedGraph.connect(N,E,N)",
    "snippet": "  @Override\n  public void connect(N srcValue, E edgeValue, N destValue) {\n    LinkedDirectedGraphNode<N, E> src = getNodeOrFail(srcValue);\n    LinkedDirectedGraphNode<N, E> dest = getNodeOrFail(destValue);\n    LinkedDirectedGraphEdge<N, E> edge =\n        useEdgeAnnotations ?\n        new AnnotatedLinkedDirectedGraphEdge<N, E>(src, edgeValue, dest) :\n        new LinkedDirectedGraphEdge<N, E>(src, edgeValue, dest);\n    src.getOutEdges().add(edge);\n    dest.getInEdges().add(edge);\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "LinkedDirectedGraph.createDirectedGraphNode",
    "class_name": "com.google.javascript.jscomp.graph.LinkedDirectedGraph",
    "signature": "com.google.javascript.jscomp.graph.LinkedDirectedGraph.createDirectedGraphNode(N)",
    "snippet": "  @Override\n  public DiGraphNode<N, E> createDirectedGraphNode(N nodeValue) {\n    LinkedDirectedGraphNode<N, E> node = nodes.get(nodeValue);\n    if (node == null) {\n      node = useNodeAnnotations ?\n          new AnnotatedLinkedDirectedGraphNode<N, E>(nodeValue) :\n          new LinkedDirectedGraphNode<N, E>(nodeValue);\n      nodes.put(nodeValue, node);\n    }\n    return node;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "LinkedDirectedGraph.createNode",
    "class_name": "com.google.javascript.jscomp.graph.LinkedDirectedGraph",
    "signature": "com.google.javascript.jscomp.graph.LinkedDirectedGraph.createNode(N)",
    "snippet": "  @Override\n  public GraphNode<N, E> createNode(N value) {\n    return createDirectedGraphNode(value);\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "LinkedDirectedGraph.getDirectedGraphNode",
    "class_name": "com.google.javascript.jscomp.graph.LinkedDirectedGraph",
    "signature": "com.google.javascript.jscomp.graph.LinkedDirectedGraph.getDirectedGraphNode(N)",
    "snippet": "  @Override\n  public DiGraphNode<N, E> getDirectedGraphNode(N nodeValue) {\n    return nodes.get(nodeValue);\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "LinkedDirectedGraph.getDirectedGraphNodes",
    "class_name": "com.google.javascript.jscomp.graph.LinkedDirectedGraph",
    "signature": "com.google.javascript.jscomp.graph.LinkedDirectedGraph.getDirectedGraphNodes()",
    "snippet": "  @Override\n  public Iterable<DiGraphNode<N, E>> getDirectedGraphNodes() {\n    return Collections.<DiGraphNode<N, E>>unmodifiableCollection(\n        nodes.values());\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "LinkedDirectedGraph.getDirectedPredNodes",
    "class_name": "com.google.javascript.jscomp.graph.LinkedDirectedGraph",
    "signature": "com.google.javascript.jscomp.graph.LinkedDirectedGraph.getDirectedPredNodes(DiGraphNode)",
    "snippet": "  @Override\n  public List<DiGraphNode<N, E>> getDirectedPredNodes(\n      DiGraphNode<N, E> dNode) {\n    if (dNode == null) {\n      throw new IllegalArgumentException(dNode + \" is null\");\n    }\n    List<DiGraphNode<N, E>> nodeList = Lists.newArrayList();\n    for (DiGraphEdge<N, E> edge : dNode.getInEdges()) {\n      nodeList.add(edge.getSource());\n    }\n    return nodeList;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "LinkedDirectedGraph.getDirectedSuccNodes",
    "class_name": "com.google.javascript.jscomp.graph.LinkedDirectedGraph",
    "signature": "com.google.javascript.jscomp.graph.LinkedDirectedGraph.getDirectedSuccNodes(DiGraphNode)",
    "snippet": "  @Override\n  public List<DiGraphNode<N, E>> getDirectedSuccNodes(\n      DiGraphNode<N, E> dNode) {\n    if (dNode == null) {\n      throw new IllegalArgumentException(dNode + \" is null\");\n    }\n    List<DiGraphNode<N, E>> nodeList = Lists.newArrayList();\n    for (DiGraphEdge<N, E> edge : dNode.getOutEdges()) {\n      nodeList.add(edge.getDestination());\n    }\n    return nodeList;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "LinkedDirectedGraph.getNode",
    "class_name": "com.google.javascript.jscomp.graph.LinkedDirectedGraph",
    "signature": "com.google.javascript.jscomp.graph.LinkedDirectedGraph.getNode(N)",
    "snippet": "  @Override\n  public GraphNode<N, E> getNode(N nodeValue) {\n    return getDirectedGraphNode(nodeValue);\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "LinkedDirectedGraph.getNodes",
    "class_name": "com.google.javascript.jscomp.graph.LinkedDirectedGraph",
    "signature": "com.google.javascript.jscomp.graph.LinkedDirectedGraph.getNodes()",
    "snippet": "  @Override\n  public Collection<GraphNode<N, E>> getNodes() {\n    return Collections.<GraphNode<N, E>>unmodifiableCollection(nodes.values());\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "LinkedDirectedGraph.getOutEdges",
    "class_name": "com.google.javascript.jscomp.graph.LinkedDirectedGraph",
    "signature": "com.google.javascript.jscomp.graph.LinkedDirectedGraph.getOutEdges(N)",
    "snippet": "  @Override\n  public List<DiGraphEdge<N, E>> getOutEdges(N nodeValue) {\n    LinkedDirectedGraphNode<N, E> node = getNodeOrFail(nodeValue);\n    return Collections.<DiGraphEdge<N, E>>unmodifiableList(node.getOutEdges());\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "LinkedDirectedGraph.isConnectedInDirection",
    "class_name": "com.google.javascript.jscomp.graph.LinkedDirectedGraph",
    "signature": "com.google.javascript.jscomp.graph.LinkedDirectedGraph.isConnectedInDirection(N,E,N)",
    "snippet": "  @Override\n  public boolean isConnectedInDirection(N n1, E edgeValue, N n2) {\n    return isConnectedInDirection(n1, Predicates.equalTo(edgeValue), n2);\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "LinkedDirectedGraph.isConnectedInDirection",
    "class_name": "com.google.javascript.jscomp.graph.LinkedDirectedGraph",
    "signature": "com.google.javascript.jscomp.graph.LinkedDirectedGraph.isConnectedInDirection(N,Predicate,N)",
    "snippet": "  private boolean isConnectedInDirection(N n1, Predicate<E> edgeMatcher, N n2) {\n    // Verify the nodes.\n    DiGraphNode<N, E> dNode1 = getNodeOrFail(n1);\n    DiGraphNode<N, E> dNode2 = getNodeOrFail(n2);\n    for (DiGraphEdge<N, E> outEdge : dNode1.getOutEdges()) {\n      if (outEdge.getDestination() == dNode2 &&\n          edgeMatcher.apply(outEdge.getValue())) {\n        return true;\n      }\n    }\n\n    return false;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "AnnotatedLinkedDirectedGraphNode.getAnnotation",
    "class_name": "com.google.javascript.jscomp.graph.LinkedDirectedGraph$AnnotatedLinkedDirectedGraphNode",
    "signature": "com.google.javascript.jscomp.graph.LinkedDirectedGraph$AnnotatedLinkedDirectedGraphNode.getAnnotation()",
    "snippet": "    @SuppressWarnings(\"unchecked\")\n    @Override\n    public <A extends Annotation> A getAnnotation() {\n      return (A) annotation;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "AnnotatedLinkedDirectedGraphNode.setAnnotation",
    "class_name": "com.google.javascript.jscomp.graph.LinkedDirectedGraph$AnnotatedLinkedDirectedGraphNode",
    "signature": "com.google.javascript.jscomp.graph.LinkedDirectedGraph$AnnotatedLinkedDirectedGraphNode.setAnnotation(Annotation)",
    "snippet": "    @Override\n    public void setAnnotation(Annotation data) {\n      annotation = data;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "LinkedDirectedGraphEdge.getDestination",
    "class_name": "com.google.javascript.jscomp.graph.LinkedDirectedGraph$LinkedDirectedGraphEdge",
    "signature": "com.google.javascript.jscomp.graph.LinkedDirectedGraph$LinkedDirectedGraphEdge.getDestination()",
    "snippet": "    @Override\n    public DiGraphNode<N, E> getDestination() {\n      return destNode;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "LinkedDirectedGraphEdge.getSource",
    "class_name": "com.google.javascript.jscomp.graph.LinkedDirectedGraph$LinkedDirectedGraphEdge",
    "signature": "com.google.javascript.jscomp.graph.LinkedDirectedGraph$LinkedDirectedGraphEdge.getSource()",
    "snippet": "    @Override\n    public DiGraphNode<N, E> getSource() {\n      return sourceNode;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "LinkedDirectedGraphEdge.getValue",
    "class_name": "com.google.javascript.jscomp.graph.LinkedDirectedGraph$LinkedDirectedGraphEdge",
    "signature": "com.google.javascript.jscomp.graph.LinkedDirectedGraph$LinkedDirectedGraphEdge.getValue()",
    "snippet": "    @Override\n    public E getValue() {\n      return value;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "LinkedDirectedGraphNode.getInEdges",
    "class_name": "com.google.javascript.jscomp.graph.LinkedDirectedGraph$LinkedDirectedGraphNode",
    "signature": "com.google.javascript.jscomp.graph.LinkedDirectedGraph$LinkedDirectedGraphNode.getInEdges()",
    "snippet": "    @Override\n    public List<DiGraphEdge<N, E>> getInEdges() {\n      return inEdgeList;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "LinkedDirectedGraphNode.getOutEdges",
    "class_name": "com.google.javascript.jscomp.graph.LinkedDirectedGraph$LinkedDirectedGraphNode",
    "signature": "com.google.javascript.jscomp.graph.LinkedDirectedGraph$LinkedDirectedGraphNode.getOutEdges()",
    "snippet": "    @Override\n    public List<DiGraphEdge<N, E>> getOutEdges() {\n      return outEdgeList;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "LinkedDirectedGraphNode.getValue",
    "class_name": "com.google.javascript.jscomp.graph.LinkedDirectedGraph$LinkedDirectedGraphNode",
    "signature": "com.google.javascript.jscomp.graph.LinkedDirectedGraph$LinkedDirectedGraphNode.getValue()",
    "snippet": "    @Override\n    public N getValue() {\n      return value;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "LinkedUndirectedGraph.LinkedUndirectedGraph",
    "class_name": "com.google.javascript.jscomp.graph.LinkedUndirectedGraph",
    "signature": "com.google.javascript.jscomp.graph.LinkedUndirectedGraph.LinkedUndirectedGraph(boolean,boolean)",
    "snippet": "  protected LinkedUndirectedGraph(\n      boolean useNodeAnnotations, boolean useEdgeAnnotations) {\n    this.useNodeAnnotations = useNodeAnnotations;\n    this.useEdgeAnnotations = useEdgeAnnotations;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "LinkedUndirectedGraph.create",
    "class_name": "com.google.javascript.jscomp.graph.LinkedUndirectedGraph",
    "signature": "com.google.javascript.jscomp.graph.LinkedUndirectedGraph.create()",
    "snippet": "  public static <N, E> LinkedUndirectedGraph<N, E> create() {\n    return new LinkedUndirectedGraph<N, E>(true, true);\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "LinkedUndirectedGraph.getNodes",
    "class_name": "com.google.javascript.jscomp.graph.LinkedUndirectedGraph",
    "signature": "com.google.javascript.jscomp.graph.LinkedUndirectedGraph.getNodes()",
    "snippet": "  @Override\n  public Collection<GraphNode<N, E>> getNodes() {\n    return Collections.<GraphNode<N, E>> unmodifiableCollection(nodes.values());\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "LinkedUndirectedGraph.newSubGraph",
    "class_name": "com.google.javascript.jscomp.graph.LinkedUndirectedGraph",
    "signature": "com.google.javascript.jscomp.graph.LinkedUndirectedGraph.newSubGraph()",
    "snippet": "  public SubGraph<N, E> newSubGraph() {\n    return new SimpleSubGraph<N, E>(this);\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "Config.Config",
    "class_name": "com.google.javascript.jscomp.parsing.Config",
    "signature": "com.google.javascript.jscomp.parsing.Config.Config(Set,Set,boolean,LanguageMode,boolean)",
    "snippet": "  Config(Set<String> annotationWhitelist, Set<String> suppressionNames,\n      boolean isIdeMode, LanguageMode languageMode,\n      boolean acceptConstKeyword) {\n    this.annotationNames = buildAnnotationNames(annotationWhitelist);\n    this.parseJsDocDocumentation = isIdeMode;\n    this.suppressionNames = suppressionNames;\n    this.isIdeMode = isIdeMode;\n    this.languageMode = languageMode;\n    this.acceptConstKeyword = acceptConstKeyword;\n  }",
    "comment": " Annotation names. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "Config.buildAnnotationNames",
    "class_name": "com.google.javascript.jscomp.parsing.Config",
    "signature": "com.google.javascript.jscomp.parsing.Config.buildAnnotationNames(Set)",
    "snippet": "  private static Map<String, Annotation> buildAnnotationNames(\n      Set<String> annotationWhitelist) {\n    ImmutableMap.Builder<String, Annotation> annotationBuilder =\n        ImmutableMap.builder();\n    annotationBuilder.putAll(Annotation.recognizedAnnotations);\n    for (String unrecognizedAnnotation : annotationWhitelist) {\n      if (!Annotation.recognizedAnnotations.containsKey(\n              unrecognizedAnnotation)) {\n        annotationBuilder.put(\n            unrecognizedAnnotation, Annotation.NOT_IMPLEMENTED);\n      }\n    }\n    return annotationBuilder.build();\n  }",
    "comment": " Create the annotation names from the user-specified annotation whitelist. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "IRFactory.createJsDocInfoParser",
    "class_name": "com.google.javascript.jscomp.parsing.IRFactory",
    "signature": "com.google.javascript.jscomp.parsing.IRFactory.createJsDocInfoParser(Comment)",
    "snippet": "  private JsDocInfoParser createJsDocInfoParser(Comment node) {\n    String comment = node.getValue();\n    int lineno = node.getLineno();\n    int position = node.getAbsolutePosition();\n\n    // The JsDocInfoParser expects the comment without the initial '/**'.\n    int numOpeningChars = 3;\n    JsDocInfoParser jsdocParser =\n      new JsDocInfoParser(\n          new JsDocTokenStream(comment.substring(numOpeningChars),\n                               lineno,\n                               position2charno(position) + numOpeningChars),\n          node,\n          sourceFile,\n          config,\n          errorReporter);\n    jsdocParser.setFileLevelJsDocBuilder(fileLevelJsDocBuilder);\n    jsdocParser.setFileOverviewJSDocInfo(fileOverviewInfo);\n    jsdocParser.parse();\n    return jsdocParser;\n  }",
    "comment": " Creates a JsDocInfoParser and parses the JsDoc string.  Used both for handling individual JSDoc comments and for handling file-level JSDoc comments (@fileoverview and @license).  @param node The JsDoc Comment node to parse. @return A JSDocInfoParser. Will contain either fileoverview jsdoc, or normal jsdoc, or no jsdoc (if the method parses to the wrong level). ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "IRFactory.createTemplateNode",
    "class_name": "com.google.javascript.jscomp.parsing.IRFactory",
    "signature": "com.google.javascript.jscomp.parsing.IRFactory.createTemplateNode()",
    "snippet": "  private Node createTemplateNode() {\n    // The Node type choice is arbitrary.\n    Node templateNode = new Node(Token.SCRIPT);\n    templateNode.setStaticSourceFile(sourceFile);\n    return templateNode;\n  }",
    "comment": "This reduces the cost of these properties to O(nodes) to O(files).",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "IRFactory.handleJsDoc",
    "class_name": "com.google.javascript.jscomp.parsing.IRFactory",
    "signature": "com.google.javascript.jscomp.parsing.IRFactory.handleJsDoc(AstNode)",
    "snippet": "  private JSDocInfo handleJsDoc(AstNode node) {\n    Comment comment = node.getJsDocNode();\n    if (comment != null) {\n      JsDocInfoParser jsDocParser = createJsDocInfoParser(comment);\n      comment.setParsed(true);\n      if (!handlePossibleFileOverviewJsDoc(jsDocParser)) {\n        return jsDocParser.retrieveAndResetParsedJSDocInfo();\n      }\n    }\n    return null;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "IRFactory.handlePossibleFileOverviewJsDoc",
    "class_name": "com.google.javascript.jscomp.parsing.IRFactory",
    "signature": "com.google.javascript.jscomp.parsing.IRFactory.handlePossibleFileOverviewJsDoc(JsDocInfoParser)",
    "snippet": "  private boolean handlePossibleFileOverviewJsDoc(\n      JsDocInfoParser jsDocParser) {\n    if (jsDocParser.getFileOverviewJSDocInfo() != fileOverviewInfo) {\n      fileOverviewInfo = jsDocParser.getFileOverviewJSDocInfo();\n      return true;\n    }\n    return false;\n  }",
    "comment": " @return true if the jsDocParser represents a fileoverview. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "IRFactory.justTransform",
    "class_name": "com.google.javascript.jscomp.parsing.IRFactory",
    "signature": "com.google.javascript.jscomp.parsing.IRFactory.justTransform(AstNode)",
    "snippet": "  private Node justTransform(AstNode node) {\n    return transformDispatcher.process(node);\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "IRFactory.maybeSetLengthFrom",
    "class_name": "com.google.javascript.jscomp.parsing.IRFactory",
    "signature": "com.google.javascript.jscomp.parsing.IRFactory.maybeSetLengthFrom(Node,AstNode)",
    "snippet": "  private void maybeSetLengthFrom(Node node, AstNode source) {\n    if (config.isIdeMode) {\n      node.setLength(source.getLength());\n    }\n  }",
    "comment": "Set the length on the node if we're in IDE mode.",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "IRFactory.newNode",
    "class_name": "com.google.javascript.jscomp.parsing.IRFactory",
    "signature": "com.google.javascript.jscomp.parsing.IRFactory.newNode(int)",
    "snippet": "  private Node newNode(int type) {\n    return new Node(type).clonePropsFrom(templateNode);\n  }",
    "comment": "Simple helper to create nodes and set the initial node properties.",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "IRFactory.newNode",
    "class_name": "com.google.javascript.jscomp.parsing.IRFactory",
    "signature": "com.google.javascript.jscomp.parsing.IRFactory.newNode(int,Node,Node)",
    "snippet": "  private Node newNode(int type, Node child1, Node child2) {\n    return new Node(type, child1, child2).clonePropsFrom(templateNode);\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "IRFactory.newNumberNode",
    "class_name": "com.google.javascript.jscomp.parsing.IRFactory",
    "signature": "com.google.javascript.jscomp.parsing.IRFactory.newNumberNode(Double)",
    "snippet": "  private Node newNumberNode(Double value) {\n    return Node.newNumber(value).clonePropsFrom(templateNode);\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "IRFactory.newStringNode",
    "class_name": "com.google.javascript.jscomp.parsing.IRFactory",
    "signature": "com.google.javascript.jscomp.parsing.IRFactory.newStringNode(int,String)",
    "snippet": "  private Node newStringNode(int type, String value) {\n    return Node.newString(type, value).clonePropsFrom(templateNode);\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "IRFactory.position2charno",
    "class_name": "com.google.javascript.jscomp.parsing.IRFactory",
    "signature": "com.google.javascript.jscomp.parsing.IRFactory.position2charno(int)",
    "snippet": "  private int position2charno(int position) {\n    int lineIndex = sourceString.lastIndexOf('\\n', position);\n    if (lineIndex == -1) {\n      return position;\n    } else {\n      // Subtract one for initial position being 0.\n      return position - lineIndex - 1;\n    }\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "IRFactory.setFileOverviewJsDoc",
    "class_name": "com.google.javascript.jscomp.parsing.IRFactory",
    "signature": "com.google.javascript.jscomp.parsing.IRFactory.setFileOverviewJsDoc(Node)",
    "snippet": "  private void setFileOverviewJsDoc(Node irNode) {\n    // Only after we've seen all @fileoverview entries, attach the\n    // last one to the root node, and copy the found license strings\n    // to that node.\n    irNode.setJSDocInfo(rootNodeJsDocHolder.getJSDocInfo());\n    if (fileOverviewInfo != null) {\n      if ((irNode.getJSDocInfo() != null) &&\n          (irNode.getJSDocInfo().getLicense() != null)) {\n        fileOverviewInfo.setLicense(irNode.getJSDocInfo().getLicense());\n      }\n      irNode.setJSDocInfo(fileOverviewInfo);\n    }\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "IRFactory.setSourceInfo",
    "class_name": "com.google.javascript.jscomp.parsing.IRFactory",
    "signature": "com.google.javascript.jscomp.parsing.IRFactory.setSourceInfo(Node,AstNode)",
    "snippet": "  private void setSourceInfo(Node irNode, AstNode node) {\n    // If we have a named function, set the position to that of the name.\n    if (irNode.getType() == Token.FUNCTION &&\n        irNode.getFirstChild().getLineno() != -1) {\n      irNode.setLineno(irNode.getFirstChild().getLineno());\n      irNode.setCharno(irNode.getFirstChild().getCharno());\n      maybeSetLengthFrom(irNode, node);\n    } else {\n      if (irNode.getLineno() == -1) {\n        // If we didn't already set the line, then set it now.  This avoids\n        // cases like ParenthesizedExpression where we just return a previous\n        // node, but don't want the new node to get its parent's line number.\n        int lineno = node.getLineno();\n        irNode.setLineno(lineno);\n        int charno = position2charno(node.getAbsolutePosition());\n        irNode.setCharno(charno);\n        maybeSetLengthFrom(irNode, node);\n      }\n    }\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "IRFactory.transform",
    "class_name": "com.google.javascript.jscomp.parsing.IRFactory",
    "signature": "com.google.javascript.jscomp.parsing.IRFactory.transform(AstNode)",
    "snippet": "  private Node transform(AstNode node) {\n    JSDocInfo jsDocInfo = handleJsDoc(node);\n    Node irNode = justTransform(node);\n    if (jsDocInfo != null) {\n      irNode.setJSDocInfo(jsDocInfo);\n    }\n    setSourceInfo(irNode, node);\n    return irNode;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "IRFactory.transformNameAsString",
    "class_name": "com.google.javascript.jscomp.parsing.IRFactory",
    "signature": "com.google.javascript.jscomp.parsing.IRFactory.transformNameAsString(Name)",
    "snippet": "  private Node transformNameAsString(Name node) {\n    JSDocInfo jsDocInfo = handleJsDoc(node);\n    Node irNode = transformDispatcher.processName(node, true);\n    if (jsDocInfo != null) {\n      irNode.setJSDocInfo(jsDocInfo);\n    }\n    setSourceInfo(irNode, node);\n    return irNode;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "IRFactory.transformTokenType",
    "class_name": "com.google.javascript.jscomp.parsing.IRFactory",
    "signature": "com.google.javascript.jscomp.parsing.IRFactory.transformTokenType(int)",
    "snippet": "  private static int transformTokenType(int token) {\n    switch (token) {\n      case com.google.javascript.jscomp.mozilla.rhino.Token.RETURN:\n        return Token.RETURN;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.BITOR:\n        return Token.BITOR;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.BITXOR:\n        return Token.BITXOR;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.BITAND:\n        return Token.BITAND;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.EQ:\n        return Token.EQ;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.NE:\n        return Token.NE;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.LT:\n        return Token.LT;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.LE:\n        return Token.LE;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.GT:\n        return Token.GT;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.GE:\n        return Token.GE;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.LSH:\n        return Token.LSH;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.RSH:\n        return Token.RSH;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.URSH:\n        return Token.URSH;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.ADD:\n        return Token.ADD;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.SUB:\n        return Token.SUB;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.MUL:\n        return Token.MUL;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.DIV:\n        return Token.DIV;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.MOD:\n        return Token.MOD;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.NOT:\n        return Token.NOT;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.BITNOT:\n        return Token.BITNOT;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.POS:\n        return Token.POS;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.NEG:\n        return Token.NEG;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.NEW:\n        return Token.NEW;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.DELPROP:\n        return Token.DELPROP;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.TYPEOF:\n        return Token.TYPEOF;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.GETPROP:\n        return Token.GETPROP;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.SETPROP:\n        return Token.SETPROP;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.GETELEM:\n        return Token.GETELEM;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.SETELEM:\n        return Token.SETELEM;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.CALL:\n        return Token.CALL;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.NAME:\n        return Token.NAME;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.NUMBER:\n        return Token.NUMBER;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.STRING:\n        return Token.STRING;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.NULL:\n        return Token.NULL;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.THIS:\n        return Token.THIS;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.FALSE:\n        return Token.FALSE;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.TRUE:\n        return Token.TRUE;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.SHEQ:\n        return Token.SHEQ;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.SHNE:\n        return Token.SHNE;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.REGEXP:\n        return Token.REGEXP;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.THROW:\n        return Token.THROW;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.IN:\n        return Token.IN;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.INSTANCEOF:\n        return Token.INSTANCEOF;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.ARRAYLIT:\n        return Token.ARRAYLIT;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.OBJECTLIT:\n        return Token.OBJECTLIT;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.TRY:\n        return Token.TRY;\n      // The LP represents a parameter list\n      case com.google.javascript.jscomp.mozilla.rhino.Token.LP:\n        return Token.LP;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.COMMA:\n        return Token.COMMA;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.ASSIGN:\n        return Token.ASSIGN;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.ASSIGN_BITOR:\n        return Token.ASSIGN_BITOR;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.ASSIGN_BITXOR:\n        return Token.ASSIGN_BITXOR;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.ASSIGN_BITAND:\n        return Token.ASSIGN_BITAND;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.ASSIGN_LSH:\n        return Token.ASSIGN_LSH;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.ASSIGN_RSH:\n        return Token.ASSIGN_RSH;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.ASSIGN_URSH:\n        return Token.ASSIGN_URSH;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.ASSIGN_ADD:\n        return Token.ASSIGN_ADD;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.ASSIGN_SUB:\n        return Token.ASSIGN_SUB;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.ASSIGN_MUL:\n        return Token.ASSIGN_MUL;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.ASSIGN_DIV:\n        return Token.ASSIGN_DIV;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.ASSIGN_MOD:\n        return Token.ASSIGN_MOD;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.HOOK:\n        return Token.HOOK;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.COLON:\n        return Token.COLON;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.OR:\n        return Token.OR;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.AND:\n        return Token.AND;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.INC:\n        return Token.INC;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.DEC:\n        return Token.DEC;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.FUNCTION:\n        return Token.FUNCTION;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.IF:\n        return Token.IF;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.ELSE:\n        return Token.ELSE;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.SWITCH:\n        return Token.SWITCH;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.CASE:\n        return Token.CASE;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.DEFAULT:\n        return Token.DEFAULT;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.WHILE:\n        return Token.WHILE;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.DO:\n        return Token.DO;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.FOR:\n        return Token.FOR;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.BREAK:\n        return Token.BREAK;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.CONTINUE:\n        return Token.CONTINUE;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.VAR:\n        return Token.VAR;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.WITH:\n        return Token.WITH;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.CATCH:\n        return Token.CATCH;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.FINALLY:\n        return Token.FINALLY;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.VOID:\n        return Token.VOID;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.EMPTY:\n        return Token.EMPTY;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.BLOCK:\n        return Token.BLOCK;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.LABEL:\n        return Token.LABEL;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.EXPR_VOID:\n      case com.google.javascript.jscomp.mozilla.rhino.Token.EXPR_RESULT:\n        return Token.EXPR_RESULT;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.SCRIPT:\n        return Token.SCRIPT;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.GET:\n        return Token.GET;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.SET:\n        return Token.SET;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.CONST:\n        return Token.CONST;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.DEBUGGER:\n        return Token.DEBUGGER;\n    }\n\n    // Token without name\n    throw new IllegalStateException(String.valueOf(token));\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "IRFactory.transformTree",
    "class_name": "com.google.javascript.jscomp.parsing.IRFactory",
    "signature": "com.google.javascript.jscomp.parsing.IRFactory.transformTree(AstRoot,StaticSourceFile,String,Config,ErrorReporter)",
    "snippet": "  public static Node transformTree(AstRoot node,\n                                   StaticSourceFile sourceFile,\n                                   String sourceString,\n                                   Config config,\n                                   ErrorReporter errorReporter) {\n    IRFactory irFactory = new IRFactory(sourceString, sourceFile,\n        config, errorReporter);\n    Node irNode = irFactory.transform(node);\n\n    if (node.getComments() != null) {\n      for (Comment comment : node.getComments()) {\n        if (comment.getCommentType() == CommentType.JSDOC &&\n            !comment.isParsed()) {\n          irFactory.handlePossibleFileOverviewJsDoc(comment);\n        } else if (comment.getCommentType() == CommentType.BLOCK) {\n          irFactory.handleBlockComment(comment);\n        }\n      }\n    }\n\n    irFactory.setFileOverviewJsDoc(irNode);\n\n    return irNode;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "TransformDispatcher.isDirective",
    "class_name": "com.google.javascript.jscomp.parsing.IRFactory$TransformDispatcher",
    "signature": "com.google.javascript.jscomp.parsing.IRFactory$TransformDispatcher.isDirective(Node)",
    "snippet": "    private boolean isDirective(Node n) {\n      if (n == null) return false;\n\n      int nType = n.getType();\n      return (nType == Token.EXPR_RESULT || nType == Token.EXPR_VOID) &&\n          n.getFirstChild().getType() == Token.STRING &&\n          ALLOWED_DIRECTIVES.contains(n.getFirstChild().getString());\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "TransformDispatcher.isReservedKeyword",
    "class_name": "com.google.javascript.jscomp.parsing.IRFactory$TransformDispatcher",
    "signature": "com.google.javascript.jscomp.parsing.IRFactory$TransformDispatcher.isReservedKeyword(String)",
    "snippet": "    private boolean isReservedKeyword(String identifier) {\n      return reservedKeywords != null && reservedKeywords.contains(identifier);\n    }",
    "comment": " @return Whether the ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "TransformDispatcher.parseDirectives",
    "class_name": "com.google.javascript.jscomp.parsing.IRFactory$TransformDispatcher",
    "signature": "com.google.javascript.jscomp.parsing.IRFactory$TransformDispatcher.parseDirectives(Node)",
    "snippet": "    private void parseDirectives(Node node) {\n      // Remove all the directives, and encode them in the AST.\n      Set<String> directives = null;\n      while (isDirective(node.getFirstChild())) {\n        String directive = node.removeFirstChild().getFirstChild().getString();\n        if (directives == null) {\n          directives = Sets.newHashSet(directive);\n        } else {\n          directives.add(directive);\n        }\n      }\n\n      if (directives != null) {\n        node.setDirectives(directives);\n      }\n    }",
    "comment": " Parse the directives, encode them in the AST, and remove their nodes.  For information on ES5 directives, see section 14.1 of Ecma-262, Edition 5.  It would be nice if Rhino would eventually take care of this for us, but right now their directive-processing is a one-off. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "TransformDispatcher.processAssignment",
    "class_name": "com.google.javascript.jscomp.parsing.IRFactory$TransformDispatcher",
    "signature": "com.google.javascript.jscomp.parsing.IRFactory$TransformDispatcher.processAssignment(Assignment)",
    "snippet": "    @Override\n    Node processAssignment(Assignment assignmentNode) {\n      Node assign = processInfixExpression(assignmentNode);\n      Node target = assign.getFirstChild();\n      if (!validAssignmentTarget(target)) {\n        errorReporter.error(\n          \"invalid assignment target\",\n          sourceName,\n          target.getLineno(), \"\", 0);\n      }\n      return assign;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "TransformDispatcher.processAstRoot",
    "class_name": "com.google.javascript.jscomp.parsing.IRFactory$TransformDispatcher",
    "signature": "com.google.javascript.jscomp.parsing.IRFactory$TransformDispatcher.processAstRoot(AstRoot)",
    "snippet": "    @Override\n    Node processAstRoot(AstRoot rootNode) {\n      Node node = newNode(Token.SCRIPT);\n      for (com.google.javascript.jscomp.mozilla.rhino.Node child : rootNode) {\n        node.addChildToBack(transform((AstNode)child));\n      }\n      parseDirectives(node);\n      return node;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "TransformDispatcher.processBlock",
    "class_name": "com.google.javascript.jscomp.parsing.IRFactory$TransformDispatcher",
    "signature": "com.google.javascript.jscomp.parsing.IRFactory$TransformDispatcher.processBlock(Block)",
    "snippet": "    @Override\n    Node processBlock(Block blockNode) {\n      return processGeneric(blockNode);\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "TransformDispatcher.processExpressionStatement",
    "class_name": "com.google.javascript.jscomp.parsing.IRFactory$TransformDispatcher",
    "signature": "com.google.javascript.jscomp.parsing.IRFactory$TransformDispatcher.processExpressionStatement(ExpressionStatement)",
    "snippet": "    @Override\n    Node processExpressionStatement(ExpressionStatement statementNode) {\n      Node node = newNode(transformTokenType(statementNode.getType()));\n      node.addChildToBack(transform(statementNode.getExpression()));\n      return node;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "TransformDispatcher.processFunctionNode",
    "class_name": "com.google.javascript.jscomp.parsing.IRFactory$TransformDispatcher",
    "signature": "com.google.javascript.jscomp.parsing.IRFactory$TransformDispatcher.processFunctionNode(FunctionNode)",
    "snippet": "    @Override\n    Node processFunctionNode(FunctionNode functionNode) {\n      Name name = functionNode.getFunctionName();\n      Boolean isUnnamedFunction = false;\n      if (name == null) {\n        int functionType = functionNode.getFunctionType();\n        if (functionType != FunctionNode.FUNCTION_EXPRESSION) {\n          errorReporter.error(\n            \"unnamed function statement\",\n            sourceName,\n            functionNode.getLineno(), \"\", 0);\n        }\n        name = new Name();\n        name.setIdentifier(\"\");\n        isUnnamedFunction = true;\n      }\n      Node node = newNode(Token.FUNCTION);\n      Node newName = transform(name);\n      if (isUnnamedFunction) {\n        // Old Rhino tagged the empty name node with the line number of the\n        // declaration.\n        newName.setLineno(functionNode.getLineno());\n        // TODO(bowdidge) Mark line number of paren correctly.\n        // Same problem as below - the left paren might not be on the\n        // same line as the function keyword.\n        int lpColumn = functionNode.getAbsolutePosition() +\n            functionNode.getLp();\n        newName.setCharno(position2charno(lpColumn));\n        maybeSetLengthFrom(newName, name);\n      }\n\n      node.addChildToBack(newName);\n      Node lp = newNode(Token.LP);\n      // The left paren's complicated because it's not represented by an\n      // AstNode, so there's nothing that has the actual line number that it\n      // appeared on.  We know the paren has to appear on the same line as the\n      // function name (or else a semicolon will be inserted.)  If there's no\n      // function name, assume the paren was on the same line as the function.\n      // TODO(bowdidge): Mark line number of paren correctly.\n      Name fnName = functionNode.getFunctionName();\n      if (fnName != null) {\n        lp.setLineno(fnName.getLineno());\n      } else {\n        lp.setLineno(functionNode.getLineno());\n      }\n      int lparenCharno = functionNode.getLp() +\n          functionNode.getAbsolutePosition();\n\n      lp.setCharno(position2charno(lparenCharno));\n      for (AstNode param : functionNode.getParams()) {\n        lp.addChildToBack(transform(param));\n      }\n      node.addChildToBack(lp);\n\n      Node bodyNode = transform(functionNode.getBody());\n      parseDirectives(bodyNode);\n      node.addChildToBack(bodyNode);\n     return node;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "TransformDispatcher.processGeneric",
    "class_name": "com.google.javascript.jscomp.parsing.IRFactory$TransformDispatcher",
    "signature": "com.google.javascript.jscomp.parsing.IRFactory$TransformDispatcher.processGeneric(Node)",
    "snippet": "    private Node processGeneric(\n        com.google.javascript.jscomp.mozilla.rhino.Node n) {\n      Node node = newNode(transformTokenType(n.getType()));\n      for (com.google.javascript.jscomp.mozilla.rhino.Node child : n) {\n        node.addChildToBack(transform((AstNode)child));\n      }\n      return node;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "TransformDispatcher.processInfixExpression",
    "class_name": "com.google.javascript.jscomp.parsing.IRFactory$TransformDispatcher",
    "signature": "com.google.javascript.jscomp.parsing.IRFactory$TransformDispatcher.processInfixExpression(InfixExpression)",
    "snippet": "    @Override\n    Node processInfixExpression(InfixExpression exprNode) {\n      Node n =  newNode(\n          transformTokenType(exprNode.getType()),\n          transform(exprNode.getLeft()),\n          transform(exprNode.getRight()));\n      // Set the line number here so we can fine-tune it in ways transform\n      // doesn't do.\n      n.setLineno(exprNode.getLineno());\n      // Position in new ASTNode is to start of expression, but old-fashioned\n      // line numbers from Node reference the operator token.  Add the offset\n      // to the operator to get the correct character number.\n      n.setCharno(position2charno(exprNode.getAbsolutePosition() +\n          exprNode.getOperatorPosition()));\n      maybeSetLengthFrom(n, exprNode);\n      return n;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "TransformDispatcher.processKeywordLiteral",
    "class_name": "com.google.javascript.jscomp.parsing.IRFactory$TransformDispatcher",
    "signature": "com.google.javascript.jscomp.parsing.IRFactory$TransformDispatcher.processKeywordLiteral(KeywordLiteral)",
    "snippet": "    @Override\n    Node processKeywordLiteral(KeywordLiteral literalNode) {\n      return newNode(transformTokenType(literalNode.getType()));\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "TransformDispatcher.processName",
    "class_name": "com.google.javascript.jscomp.parsing.IRFactory$TransformDispatcher",
    "signature": "com.google.javascript.jscomp.parsing.IRFactory$TransformDispatcher.processName(Name)",
    "snippet": "    @Override\n    Node processName(Name nameNode) {\n      return processName(nameNode, false);\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "TransformDispatcher.processName",
    "class_name": "com.google.javascript.jscomp.parsing.IRFactory$TransformDispatcher",
    "signature": "com.google.javascript.jscomp.parsing.IRFactory$TransformDispatcher.processName(Name,boolean)",
    "snippet": "    Node processName(Name nameNode, boolean asString) {\n      if (asString) {\n        return newStringNode(Token.STRING, nameNode.getIdentifier());\n      } else {\n        if (isReservedKeyword(nameNode.getIdentifier())) {\n          errorReporter.error(\n            \"identifier is a reserved word\",\n            sourceName,\n            nameNode.getLineno(), \"\", 0);\n        }\n        return newStringNode(Token.NAME, nameNode.getIdentifier());\n      }\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "TransformDispatcher.processNumberLiteral",
    "class_name": "com.google.javascript.jscomp.parsing.IRFactory$TransformDispatcher",
    "signature": "com.google.javascript.jscomp.parsing.IRFactory$TransformDispatcher.processNumberLiteral(NumberLiteral)",
    "snippet": "    @Override\n    Node processNumberLiteral(NumberLiteral literalNode) {\n      return newNumberNode(literalNode.getNumber());\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "TransformDispatcher.processPropertyGet",
    "class_name": "com.google.javascript.jscomp.parsing.IRFactory$TransformDispatcher",
    "signature": "com.google.javascript.jscomp.parsing.IRFactory$TransformDispatcher.processPropertyGet(PropertyGet)",
    "snippet": "    @Override\n    Node processPropertyGet(PropertyGet getNode) {\n      return newNode(\n          Token.GETPROP,\n          transform(getNode.getTarget()),\n          transformAsString(getNode.getProperty()));\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "TransformDispatcher.processVariableDeclaration",
    "class_name": "com.google.javascript.jscomp.parsing.IRFactory$TransformDispatcher",
    "signature": "com.google.javascript.jscomp.parsing.IRFactory$TransformDispatcher.processVariableDeclaration(VariableDeclaration)",
    "snippet": "    @Override\n    Node processVariableDeclaration(VariableDeclaration declarationNode) {\n      if (!config.acceptConstKeyword && declarationNode.getType() ==\n          com.google.javascript.jscomp.mozilla.rhino.Token.CONST) {\n        processIllegalToken(declarationNode);\n      }\n\n      Node node = newNode(Token.VAR);\n      for (VariableInitializer child : declarationNode.getVariables()) {\n        node.addChildToBack(transform(child));\n      }\n      return node;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "TransformDispatcher.processVariableInitializer",
    "class_name": "com.google.javascript.jscomp.parsing.IRFactory$TransformDispatcher",
    "signature": "com.google.javascript.jscomp.parsing.IRFactory$TransformDispatcher.processVariableInitializer(VariableInitializer)",
    "snippet": "    @Override\n    Node processVariableInitializer(VariableInitializer initializerNode) {\n      Node node = transform(initializerNode.getTarget());\n      if (initializerNode.getInitializer() != null) {\n        node.addChildToBack(transform(initializerNode.getInitializer()));\n        node.setLineno(node.getLineno());\n        maybeSetLengthFrom(node, initializerNode);\n      }\n      return node;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "TransformDispatcher.transformAsString",
    "class_name": "com.google.javascript.jscomp.parsing.IRFactory$TransformDispatcher",
    "signature": "com.google.javascript.jscomp.parsing.IRFactory$TransformDispatcher.transformAsString(AstNode)",
    "snippet": "    private Node transformAsString(AstNode n) {\n      Node ret;\n      if (n instanceof Name) {\n        ret = transformNameAsString((Name)n);\n      } else if (n instanceof NumberLiteral) {\n        ret = transformNumberAsString((NumberLiteral)n);\n        ret.putBooleanProp(Node.QUOTED_PROP, true);\n      } else {\n        ret = transform(n);\n        ret.putBooleanProp(Node.QUOTED_PROP, true);\n      }\n      Preconditions.checkState(ret.getType() == Token.STRING);\n      return ret;\n    }",
    "comment": " Transforms the given node and then sets its type to Token.STRING if it was Token.NAME. If its type was already Token.STRING, then quotes it. Used for properties, as the old AST uses String tokens, while the new one uses Name tokens for unquoted strings. For example, in var o = {'a' : 1, b: 2}; the string 'a' is quoted, while the name b is turned into a string, but unquoted. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "TransformDispatcher.validAssignmentTarget",
    "class_name": "com.google.javascript.jscomp.parsing.IRFactory$TransformDispatcher",
    "signature": "com.google.javascript.jscomp.parsing.IRFactory$TransformDispatcher.validAssignmentTarget(Node)",
    "snippet": "    private boolean validAssignmentTarget(Node target) {\n      switch (target.getType()) {\n        case Token.NAME:\n        case Token.GETPROP:\n        case Token.GETELEM:\n          return true;\n      }\n      return false;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "JsDocInfoParser.JsDocInfoParser",
    "class_name": "com.google.javascript.jscomp.parsing.JsDocInfoParser",
    "signature": "com.google.javascript.jscomp.parsing.JsDocInfoParser.JsDocInfoParser(JsDocTokenStream,Comment,StaticSourceFile,Config,ErrorReporter)",
    "snippet": "  JsDocInfoParser(JsDocTokenStream stream,\n                  Comment commentNode,\n                  StaticSourceFile sourceFile,\n                  Config config,\n                  ErrorReporter errorReporter) {\n    this.stream = stream;\n    this.sourceFile = sourceFile;\n\n    // Sometimes this will be null in tests.\n    this.sourceName = sourceFile == null ? null : sourceFile.getName();\n\n    this.jsdocBuilder = new JSDocInfoBuilder(config.parseJsDocDocumentation);\n    if (commentNode != null) {\n      this.jsdocBuilder.recordOriginalCommentString(commentNode.getValue());\n    }\n    this.annotationNames = config.annotationNames;\n    this.suppressionNames = config.suppressionNames;\n\n    this.errorReporter = errorReporter;\n    this.templateNode = this.createTemplateNode();\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "JsDocInfoParser.checkExtendedTypes",
    "class_name": "com.google.javascript.jscomp.parsing.JsDocInfoParser",
    "signature": "com.google.javascript.jscomp.parsing.JsDocInfoParser.checkExtendedTypes(List)",
    "snippet": "  private void checkExtendedTypes(List<ExtendedTypeInfo> extendedTypes) {\n    for (ExtendedTypeInfo typeInfo : extendedTypes) {\n      // If interface, record the multiple extended interfaces\n      if (jsdocBuilder.isInterfaceRecorded()) {\n        if (!jsdocBuilder.recordExtendedInterface(typeInfo.type)) {\n          parser.addParserWarning(\"msg.jsdoc.extends.duplicate\",\n              typeInfo.lineno, typeInfo.charno);\n        }\n      } else {\n        if (!jsdocBuilder.recordBaseType(typeInfo.type)) {\n          parser.addTypeWarning(\"msg.jsdoc.incompat.type\",\n              typeInfo.lineno, typeInfo.charno);\n        }\n      }\n    }\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "JsDocInfoParser.createJSTypeExpression",
    "class_name": "com.google.javascript.jscomp.parsing.JsDocInfoParser",
    "signature": "com.google.javascript.jscomp.parsing.JsDocInfoParser.createJSTypeExpression(Node)",
    "snippet": "  private JSTypeExpression createJSTypeExpression(Node n) {\n    return n == null ? null :\n        new JSTypeExpression(n, sourceName);\n  }",
    "comment": " Constructs a new {@code JSTypeExpression}. @param n A node. May be null. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "JsDocInfoParser.createTemplateNode",
    "class_name": "com.google.javascript.jscomp.parsing.JsDocInfoParser",
    "signature": "com.google.javascript.jscomp.parsing.JsDocInfoParser.createTemplateNode()",
    "snippet": "  private Node createTemplateNode() {\n    // The Node type choice is arbitrary.\n    Node templateNode = new Node(Token.SCRIPT);\n    templateNode.setStaticSourceFile(sourceFile);\n    return templateNode;\n  }",
    "comment": "e.g., source-name, between all nodes.",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "JsDocInfoParser.current",
    "class_name": "com.google.javascript.jscomp.parsing.JsDocInfoParser",
    "signature": "com.google.javascript.jscomp.parsing.JsDocInfoParser.current()",
    "snippet": "  private JsDocToken current() {\n    JsDocToken t = unreadToken;\n    unreadToken = NO_UNREAD_TOKEN;\n    return t;\n  }",
    "comment": " Gets the current token, invalidating it in the process. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "JsDocInfoParser.eatTokensUntilEOL",
    "class_name": "com.google.javascript.jscomp.parsing.JsDocInfoParser",
    "signature": "com.google.javascript.jscomp.parsing.JsDocInfoParser.eatTokensUntilEOL()",
    "snippet": "  private JsDocToken eatTokensUntilEOL() {\n    return eatTokensUntilEOL(next());\n  }",
    "comment": " Eats tokens until {@link JsDocToken#EOL} included, and switches back the state to {@link State#SEARCHING_ANNOTATION}. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "JsDocInfoParser.eatTokensUntilEOL",
    "class_name": "com.google.javascript.jscomp.parsing.JsDocInfoParser",
    "signature": "com.google.javascript.jscomp.parsing.JsDocInfoParser.eatTokensUntilEOL(JsDocToken)",
    "snippet": "  private JsDocToken eatTokensUntilEOL(JsDocToken token) {\n    do {\n      if (token == JsDocToken.EOL || token == JsDocToken.EOC ||\n          token == JsDocToken.EOF) {\n        state = State.SEARCHING_ANNOTATION;\n        return token;\n      }\n      token = next();\n    } while (true);\n  }",
    "comment": " Eats tokens until {@link JsDocToken#EOL} included, and switches back the state to {@link State#SEARCHING_ANNOTATION}. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "JsDocInfoParser.getFileOverviewJSDocInfo",
    "class_name": "com.google.javascript.jscomp.parsing.JsDocInfoParser",
    "signature": "com.google.javascript.jscomp.parsing.JsDocInfoParser.getFileOverviewJSDocInfo()",
    "snippet": "  JSDocInfo getFileOverviewJSDocInfo() {\n    return fileOverviewJSDocInfo;\n  }",
    "comment": " Gets the fileoverview JSDocInfo, if any. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "JsDocInfoParser.hasParsedFileOverviewDocInfo",
    "class_name": "com.google.javascript.jscomp.parsing.JsDocInfoParser",
    "signature": "com.google.javascript.jscomp.parsing.JsDocInfoParser.hasParsedFileOverviewDocInfo()",
    "snippet": "  private boolean hasParsedFileOverviewDocInfo() {\n    return jsdocBuilder.isPopulatedWithFileOverview();\n  }",
    "comment": " Determines whether the parser has been populated with docinfo with a fileoverview tag. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "JsDocInfoParser.lookAheadForTypeAnnotation",
    "class_name": "com.google.javascript.jscomp.parsing.JsDocInfoParser",
    "signature": "com.google.javascript.jscomp.parsing.JsDocInfoParser.lookAheadForTypeAnnotation()",
    "snippet": "  private boolean lookAheadForTypeAnnotation() {\n    boolean matchedLc = false;\n    int c;\n    while (true) {\n      c = stream.getChar();\n      if (c == ' ') {\n        continue;\n      } else if (c == '{') {\n        matchedLc = true;\n        break;\n      } else {\n        break;\n      }\n    }\n    stream.ungetChar(c);\n    return matchedLc;\n  }",
    "comment": " Look ahead for a type annotation by advancing the character stream. Does not modify the token stream. This is kind of a hack, and is only necessary because we use the token stream to parse types, but need the underlying character stream to get JsDoc descriptions. @return Whether we found a type annotation. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "JsDocInfoParser.match",
    "class_name": "com.google.javascript.jscomp.parsing.JsDocInfoParser",
    "signature": "com.google.javascript.jscomp.parsing.JsDocInfoParser.match(JsDocToken)",
    "snippet": "  private boolean match(JsDocToken token) {\n    unreadToken = next();\n    return unreadToken == token;\n  }",
    "comment": " Tests whether the next symbol of the token stream matches the specific token. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "JsDocInfoParser.newNode",
    "class_name": "com.google.javascript.jscomp.parsing.JsDocInfoParser",
    "signature": "com.google.javascript.jscomp.parsing.JsDocInfoParser.newNode(int)",
    "snippet": "  private Node newNode(int type) {\n    return new Node(type, stream.getLineno(),\n        stream.getCharno()).clonePropsFrom(templateNode);\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "JsDocInfoParser.newStringNode",
    "class_name": "com.google.javascript.jscomp.parsing.JsDocInfoParser",
    "signature": "com.google.javascript.jscomp.parsing.JsDocInfoParser.newStringNode(String)",
    "snippet": "  private Node newStringNode(String s) {\n    return Node.newString(s, stream.getLineno(),\n        stream.getCharno()).clonePropsFrom(templateNode);\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "JsDocInfoParser.next",
    "class_name": "com.google.javascript.jscomp.parsing.JsDocInfoParser",
    "signature": "com.google.javascript.jscomp.parsing.JsDocInfoParser.next()",
    "snippet": "  private JsDocToken next() {\n    if (unreadToken == NO_UNREAD_TOKEN) {\n      return stream.getJsDocToken();\n    } else {\n      return current();\n    }\n  }",
    "comment": " Gets the next token of the token stream or the buffered token if a matching was previously made. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "JsDocInfoParser.parse",
    "class_name": "com.google.javascript.jscomp.parsing.JsDocInfoParser",
    "signature": "com.google.javascript.jscomp.parsing.JsDocInfoParser.parse()",
    "snippet": "  boolean parse() {\n    int lineno;\n    int charno;\n\n    // JSTypes are represented as Rhino AST nodes, and then resolved later.\n    JSTypeExpression type;\n\n    state = State.SEARCHING_ANNOTATION;\n    skipEOLs();\n\n    JsDocToken token = next();\n\n    List<ExtendedTypeInfo> extendedTypes = Lists.newArrayList();\n\n    // Always record that we have a comment.\n    if (jsdocBuilder.shouldParseDocumentation()) {\n      ExtractionInfo blockInfo = extractBlockComment(token);\n      token = blockInfo.token;\n      if (!blockInfo.string.isEmpty()) {\n        jsdocBuilder.recordBlockDescription(blockInfo.string);\n      }\n    } else {\n      if (token != JsDocToken.ANNOTATION &&\n          token != JsDocToken.EOC) {\n        // Mark that there was a description, but don't bother marking\n        // what it was.\n        jsdocBuilder.recordBlockDescription(\"\");\n      }\n    }\n\n    // Parse the actual JsDoc.\n    retry: for (;;) {\n      switch (token) {\n        case ANNOTATION:\n          if (state == State.SEARCHING_ANNOTATION) {\n            state = State.SEARCHING_NEWLINE;\n            lineno = stream.getLineno();\n            charno = stream.getCharno();\n\n            String annotationName = stream.getString();\n            Annotation annotation = annotationNames.get(annotationName);\n            if (annotation == null) {\n              parser.addParserWarning(\"msg.bad.jsdoc.tag\", annotationName,\n                  stream.getLineno(), stream.getCharno());\n            } else {\n              // Mark the beginning of the annotation.\n              jsdocBuilder.markAnnotation(annotationName, lineno, charno);\n\n              switch (annotation) {\n                case AUTHOR:\n                  if (jsdocBuilder.shouldParseDocumentation()) {\n                    ExtractionInfo authorInfo = extractSingleLineBlock();\n                    String author = authorInfo.string;\n\n                    if (author.length() == 0) {\n                      parser.addParserWarning(\"msg.jsdoc.authormissing\",\n                          stream.getLineno(), stream.getCharno());\n                    } else {\n                      jsdocBuilder.addAuthor(author);\n                    }\n                    token = authorInfo.token;\n                  } else {\n                    token = eatTokensUntilEOL(token);\n                  }\n                  continue retry;\n\n                case CONSTANT:\n                  if (!jsdocBuilder.recordConstancy()) {\n                    parser.addParserWarning(\"msg.jsdoc.const\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case CONSTRUCTOR:\n                  if (!jsdocBuilder.recordConstructor()) {\n                    if (jsdocBuilder.isInterfaceRecorded()) {\n                      parser.addTypeWarning(\"msg.jsdoc.interface.constructor\",\n                          stream.getLineno(), stream.getCharno());\n                    } else {\n                      parser.addTypeWarning(\"msg.jsdoc.incompat.type\",\n                          stream.getLineno(), stream.getCharno());\n                    }\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case DEPRECATED:\n                  if (!jsdocBuilder.recordDeprecated()) {\n                    parser.addParserWarning(\"msg.jsdoc.deprecated\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n\n                  // Find the reason/description, if any.\n                  ExtractionInfo reasonInfo =\n                      extractMultilineTextualBlock(token);\n\n                  String reason = reasonInfo.string;\n\n                  if (reason.length() > 0) {\n                    jsdocBuilder.recordDeprecationReason(reason);\n                  }\n\n                  token = reasonInfo.token;\n                  continue retry;\n\n                case INTERFACE:\n                  if (!jsdocBuilder.recordInterface()) {\n                    if (jsdocBuilder.isConstructorRecorded()) {\n                      parser.addTypeWarning(\"msg.jsdoc.interface.constructor\",\n                          stream.getLineno(), stream.getCharno());\n                    } else {\n                      parser.addTypeWarning(\"msg.jsdoc.incompat.type\",\n                          stream.getLineno(), stream.getCharno());\n                    }\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case DESC:\n                  if (jsdocBuilder.isDescriptionRecorded()) {\n                    parser.addParserWarning(\"msg.jsdoc.desc.extra\",\n                        stream.getLineno(), stream.getCharno());\n                    token = eatTokensUntilEOL();\n                    continue retry;\n                  } else {\n                    ExtractionInfo descriptionInfo =\n                        extractMultilineTextualBlock(token);\n\n                    String description = descriptionInfo.string;\n\n                    jsdocBuilder.recordDescription(description);\n                    token = descriptionInfo.token;\n                    continue retry;\n                  }\n\n                case FILE_OVERVIEW:\n                  String fileOverview = \"\";\n                  if (jsdocBuilder.shouldParseDocumentation()) {\n                    ExtractionInfo fileOverviewInfo =\n                        extractMultilineTextualBlock(token,\n                            WhitespaceOption.TRIM);\n\n                    fileOverview = fileOverviewInfo.string;\n\n                    token = fileOverviewInfo.token;\n                  } else {\n                    token = eatTokensUntilEOL(token);\n                  }\n\n                  if (!jsdocBuilder.recordFileOverview(fileOverview) ||\n                      fileOverviewJSDocInfo != null) {\n                    parser.addParserWarning(\"msg.jsdoc.fileoverview.extra\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  continue retry;\n\n                case LICENSE:\n                case PRESERVE:\n                  ExtractionInfo preserveInfo =\n                      extractMultilineTextualBlock(token,\n                                                   WhitespaceOption.PRESERVE);\n\n                  String preserve = preserveInfo.string;\n\n                  if (preserve.length() > 0) {\n                    if (fileLevelJsDocBuilder != null) {\n                      fileLevelJsDocBuilder.append(preserve);\n                    }\n                  }\n\n                  token = preserveInfo.token;\n                  continue retry;\n\n                case ENUM:\n                  token = next();\n                  lineno = stream.getLineno();\n                  charno = stream.getCharno();\n\n                  type = null;\n                  if (token != JsDocToken.EOL && token != JsDocToken.EOC) {\n                    type = createJSTypeExpression(\n                        parseAndRecordTypeNode(token));\n                  }\n\n                  if (type == null) {\n                    type = createJSTypeExpression(newStringNode(\"number\"));\n                  }\n                  if (!jsdocBuilder.recordEnumParameterType(type)) {\n                    parser.addTypeWarning(\n                        \"msg.jsdoc.incompat.type\", lineno, charno);\n                  }\n                  token = eatTokensUntilEOL(token);\n                  continue retry;\n\n                case EXPORT:\n                  if (!jsdocBuilder.recordExport()) {\n                    parser.addParserWarning(\"msg.jsdoc.export\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case EXTERNS:\n                  if (!jsdocBuilder.recordExterns()) {\n                    parser.addParserWarning(\"msg.jsdoc.externs\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case JAVA_DISPATCH:\n                  if (!jsdocBuilder.recordJavaDispatch()) {\n                    parser.addParserWarning(\"msg.jsdoc.javadispatch\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case EXTENDS:\n                case IMPLEMENTS:\n                  skipEOLs();\n                  token = next();\n                  lineno = stream.getLineno();\n                  charno = stream.getCharno();\n                  boolean matchingRc = false;\n\n                  if (token == JsDocToken.LC) {\n                    token = next();\n                    matchingRc = true;\n                  }\n\n                  if (token == JsDocToken.STRING) {\n                    Node typeNode = parseAndRecordTypeNameNode(\n                        token, lineno, charno, matchingRc);\n\n                    lineno = stream.getLineno();\n                    charno = stream.getCharno();\n\n                    typeNode = wrapNode(Token.BANG, typeNode);\n                    if (typeNode != null && !matchingRc) {\n                      typeNode.putBooleanProp(Node.BRACELESS_TYPE, true);\n                    }\n                    type = createJSTypeExpression(typeNode);\n\n                    if (annotation == Annotation.EXTENDS) {\n                      // record the extended type, check later\n                      extendedTypes.add(new ExtendedTypeInfo(\n                          type, stream.getLineno(), stream.getCharno()));\n                    } else {\n                      Preconditions.checkState(\n                          annotation == Annotation.IMPLEMENTS);\n                      if (!jsdocBuilder.recordImplementedInterface(type)) {\n                        parser.addTypeWarning(\"msg.jsdoc.implements.duplicate\",\n                            lineno, charno);\n                      }\n                    }\n                    token = next();\n                    if (matchingRc) {\n                      if (token != JsDocToken.RC) {\n                        parser.addTypeWarning(\"msg.jsdoc.missing.rc\",\n                            stream.getLineno(), stream.getCharno());\n                      }\n                    } else if (token != JsDocToken.EOL &&\n                        token != JsDocToken.EOF && token != JsDocToken.EOC) {\n                      parser.addTypeWarning(\"msg.end.annotation.expected\",\n                          stream.getLineno(), stream.getCharno());\n                    }\n                  } else {\n                    parser.addTypeWarning(\"msg.no.type.name\", lineno, charno);\n                  }\n                  token = eatTokensUntilEOL(token);\n                  continue retry;\n\n                case HIDDEN:\n                  if (!jsdocBuilder.recordHiddenness()) {\n                    parser.addParserWarning(\"msg.jsdoc.hidden\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case LENDS:\n                  skipEOLs();\n\n                  matchingRc = false;\n                  if (match(JsDocToken.LC)) {\n                    token = next();\n                    matchingRc = true;\n                  }\n\n                  if (match(JsDocToken.STRING)) {\n                    token = next();\n                    if (!jsdocBuilder.recordLends(stream.getString())) {\n                      parser.addTypeWarning(\"msg.jsdoc.lends.incompatible\",\n                          stream.getLineno(), stream.getCharno());\n                    }\n                  } else {\n                    parser.addTypeWarning(\"msg.jsdoc.lends.missing\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n\n                  if (matchingRc && !match(JsDocToken.RC)) {\n                    parser.addTypeWarning(\"msg.jsdoc.missing.rc\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case MEANING:\n                  ExtractionInfo meaningInfo =\n                      extractMultilineTextualBlock(token);\n                  String meaning = meaningInfo.string;\n                  token = meaningInfo.token;\n                  if (!jsdocBuilder.recordMeaning(meaning)) {\n                    parser.addParserWarning(\"msg.jsdoc.meaning.extra\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  continue retry;\n\n                case NO_ALIAS:\n                  if (!jsdocBuilder.recordNoAlias()) {\n                    parser.addParserWarning(\"msg.jsdoc.noalias\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case NO_COMPILE:\n                  if (!jsdocBuilder.recordNoCompile()) {\n                    parser.addParserWarning(\"msg.jsdoc.nocompile\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case NO_TYPE_CHECK:\n                  if (!jsdocBuilder.recordNoTypeCheck()) {\n                    parser.addParserWarning(\"msg.jsdoc.nocheck\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case NOT_IMPLEMENTED:\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case INHERIT_DOC:\n                case OVERRIDE:\n                  if (!jsdocBuilder.recordOverride()) {\n                    parser.addTypeWarning(\"msg.jsdoc.override\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case THROWS:\n                  skipEOLs();\n                  token = next();\n                  lineno = stream.getLineno();\n                  charno = stream.getCharno();\n                  type = null;\n\n                  if (token == JsDocToken.LC) {\n                    type = createJSTypeExpression(\n                        parseAndRecordTypeNode(token));\n\n                    if (type == null) {\n                      // parsing error reported during recursive descent\n                      // recovering parsing\n                      token = eatTokensUntilEOL();\n                      continue retry;\n                    }\n                  }\n\n                  // *Update* the token to that after the type annotation.\n                  token = current();\n\n                  // Save the throw type.\n                  jsdocBuilder.recordThrowType(type);\n\n                  // Find the throw's description (if applicable).\n                  if (jsdocBuilder.shouldParseDocumentation()) {\n                    ExtractionInfo descriptionInfo =\n                        extractMultilineTextualBlock(token);\n\n                    String description = descriptionInfo.string;\n\n                    if (description.length() > 0) {\n                      jsdocBuilder.recordThrowDescription(type, description);\n                    }\n\n                    token = descriptionInfo.token;\n                  } else {\n                    token = eatTokensUntilEOL(token);\n                  }\n                  continue retry;\n\n                case PARAM:\n                  skipEOLs();\n                  token = next();\n                  lineno = stream.getLineno();\n                  charno = stream.getCharno();\n                  type = null;\n\n                  if (token == JsDocToken.LC) {\n                    type = createJSTypeExpression(\n                        parseAndRecordParamTypeNode(token));\n\n                    if (type == null) {\n                      // parsing error reported during recursive descent\n                      // recovering parsing\n                      token = eatTokensUntilEOL();\n                      continue retry;\n                    }\n                    skipEOLs();\n                    token = next();\n                    lineno = stream.getLineno();\n                    charno = stream.getCharno();\n                  }\n\n                  String name = null;\n                  boolean isBracketedParam = JsDocToken.LB == token;\n                  if (isBracketedParam) {\n                    token = next();\n                  }\n\n                  if (JsDocToken.STRING != token) {\n                    parser.addTypeWarning(\"msg.missing.variable.name\",\n                        lineno, charno);\n                  } else {\n                    name = stream.getString();\n\n                    if (isBracketedParam) {\n                      token = next();\n\n                      // Throw out JsDocToolkit's \"default\" parameter\n                      // annotation.  It makes no sense under our type\n                      // system.\n                      if (JsDocToken.EQUALS == token) {\n                        token = next();\n                        if (JsDocToken.STRING == token) {\n                          token = next();\n                        }\n                      }\n\n                      if (JsDocToken.RB != token) {\n                        reportTypeSyntaxWarning(\"msg.jsdoc.missing.rb\");\n                      } else if (type != null) {\n                        // Make the type expression optional, if it isn't\n                        // already.\n                        type = JSTypeExpression.makeOptionalArg(type);\n                      }\n                    }\n\n                    // If the param name has a DOT in it, just throw it out\n                    // quietly. We do not handle the JsDocToolkit method\n                    // for handling properties of params.\n                    if (name.indexOf('.') > -1) {\n                      name = null;\n                    } else if (!jsdocBuilder.recordParameter(name, type)) {\n                      if (jsdocBuilder.hasParameter(name)) {\n                        parser.addTypeWarning(\"msg.dup.variable.name\", name,\n                            lineno, charno);\n                      } else {\n                        parser.addTypeWarning(\"msg.jsdoc.incompat.type\", name,\n                            lineno, charno);\n                      }\n                    }\n                  }\n\n                  if (name == null) {\n                    token = eatTokensUntilEOL(token);\n                    continue retry;\n                  }\n\n                  jsdocBuilder.markName(name, lineno, charno);\n\n                  // Find the parameter's description (if applicable).\n                  if (jsdocBuilder.shouldParseDocumentation()) {\n                    ExtractionInfo paramDescriptionInfo =\n                        extractMultilineTextualBlock(token);\n\n                    String paramDescription = paramDescriptionInfo.string;\n\n                    if (paramDescription.length() > 0) {\n                      jsdocBuilder.recordParameterDescription(name,\n                          paramDescription);\n                    }\n\n                    token = paramDescriptionInfo.token;\n                  } else {\n                    token = eatTokensUntilEOL(token);\n                  }\n                  continue retry;\n\n                case PRESERVE_TRY:\n                  if (!jsdocBuilder.recordPreserveTry()) {\n                    parser.addParserWarning(\"msg.jsdoc.preservertry\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case PRIVATE:\n                  if (!jsdocBuilder.recordVisibility(Visibility.PRIVATE)) {\n                    parser.addParserWarning(\"msg.jsdoc.visibility.private\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case PROTECTED:\n                  if (!jsdocBuilder.recordVisibility(Visibility.PROTECTED)) {\n                    parser.addParserWarning(\"msg.jsdoc.visibility.protected\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case PUBLIC:\n                  if (!jsdocBuilder.recordVisibility(Visibility.PUBLIC)) {\n                    parser.addParserWarning(\"msg.jsdoc.visibility.public\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case NO_SHADOW:\n                  if (!jsdocBuilder.recordNoShadow()) {\n                    parser.addParserWarning(\"msg.jsdoc.noshadow\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case NO_SIDE_EFFECTS:\n                  if (!jsdocBuilder.recordNoSideEffects()) {\n                    parser.addParserWarning(\"msg.jsdoc.nosideeffects\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case MODIFIES:\n                  token = parseModifiesTag(next());\n                  continue retry;\n\n                case IMPLICIT_CAST:\n                  if (!jsdocBuilder.recordImplicitCast()) {\n                    parser.addTypeWarning(\"msg.jsdoc.implicitcast\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case SEE:\n                  if (jsdocBuilder.shouldParseDocumentation()) {\n                    ExtractionInfo referenceInfo = extractSingleLineBlock();\n                    String reference = referenceInfo.string;\n\n                    if (reference.length() == 0) {\n                      parser.addParserWarning(\"msg.jsdoc.seemissing\",\n                          stream.getLineno(), stream.getCharno());\n                    } else {\n                      jsdocBuilder.addReference(reference);\n                    }\n\n                    token = referenceInfo.token;\n                  } else {\n                    token = eatTokensUntilEOL(token);\n                  }\n                  continue retry;\n\n                case SUPPRESS:\n                  token = parseSuppressTag(next());\n                  continue retry;\n\n                case TEMPLATE:\n                  ExtractionInfo templateInfo = extractSingleLineBlock();\n                  String templateTypeName = templateInfo.string;\n\n                  if (templateTypeName.length() == 0) {\n                    parser.addTypeWarning(\"msg.jsdoc.templatemissing\",\n                          stream.getLineno(), stream.getCharno());\n                  } else if (!jsdocBuilder.recordTemplateTypeName(\n                      templateTypeName)) {\n                    parser.addTypeWarning(\"msg.jsdoc.template.at.most.once\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n\n                  token = templateInfo.token;\n                  continue retry;\n\n                case VERSION:\n                  ExtractionInfo versionInfo = extractSingleLineBlock();\n                  String version = versionInfo.string;\n\n                  if (version.length() == 0) {\n                    parser.addParserWarning(\"msg.jsdoc.versionmissing\",\n                          stream.getLineno(), stream.getCharno());\n                  } else {\n                    if (!jsdocBuilder.recordVersion(version)) {\n                       parser.addParserWarning(\"msg.jsdoc.extraversion\",\n                          stream.getLineno(), stream.getCharno());\n                    }\n                  }\n\n                  token = versionInfo.token;\n                  continue retry;\n\n                case DEFINE:\n                case RETURN:\n                case THIS:\n                case TYPE:\n                case TYPEDEF:\n                  lineno = stream.getLineno();\n                  charno = stream.getCharno();\n\n                  Node typeNode = null;\n                  if (!lookAheadForTypeAnnotation() &&\n                      annotation == Annotation.RETURN) {\n                    // If RETURN doesn't have a type annotation, record\n                    // it as the unknown type.\n                    typeNode = newNode(Token.QMARK);\n                  } else {\n                    skipEOLs();\n                    token = next();\n                    typeNode = parseAndRecordTypeNode(token);\n                  }\n\n                  if (annotation == Annotation.THIS) {\n                    typeNode = wrapNode(Token.BANG, typeNode);\n                    if (typeNode != null && token != JsDocToken.LC) {\n                      typeNode.putBooleanProp(Node.BRACELESS_TYPE, true);\n                    }\n                  }\n                  type = createJSTypeExpression(typeNode);\n\n                  if (type == null) {\n                    // error reported during recursive descent\n                    // recovering parsing\n                  } else {\n                    switch (annotation) {\n                      case DEFINE:\n                        if (!jsdocBuilder.recordDefineType(type)) {\n                          parser.addParserWarning(\"msg.jsdoc.define\",\n                              lineno, charno);\n                        }\n                        break;\n\n                      case RETURN:\n                        if (!jsdocBuilder.recordReturnType(type)) {\n                          parser.addTypeWarning(\n                              \"msg.jsdoc.incompat.type\", lineno, charno);\n                          break;\n                        }\n\n                        // Find the return's description (if applicable).\n                        if (jsdocBuilder.shouldParseDocumentation()) {\n                          ExtractionInfo returnDescriptionInfo =\n                              extractMultilineTextualBlock(token);\n\n                          String returnDescription =\n                              returnDescriptionInfo.string;\n\n                          if (returnDescription.length() > 0) {\n                            jsdocBuilder.recordReturnDescription(\n                                returnDescription);\n                          }\n\n                          token = returnDescriptionInfo.token;\n                        } else {\n                          token = eatTokensUntilEOL(token);\n                        }\n                        continue retry;\n\n                      case THIS:\n                        if (!jsdocBuilder.recordThisType(type)) {\n                          parser.addTypeWarning(\n                              \"msg.jsdoc.incompat.type\", lineno, charno);\n                        }\n                        break;\n\n                      case TYPE:\n                        if (!jsdocBuilder.recordType(type)) {\n                          parser.addTypeWarning(\n                              \"msg.jsdoc.incompat.type\", lineno, charno);\n                        }\n                        break;\n\n                      case TYPEDEF:\n                        if (!jsdocBuilder.recordTypedef(type)) {\n                          parser.addTypeWarning(\n                              \"msg.jsdoc.incompat.type\", lineno, charno);\n                        }\n                        break;\n                    }\n                  }\n\n                  token = eatTokensUntilEOL();\n                  continue retry;\n              }\n            }\n          }\n          break;\n\n        case EOC:\n          if (hasParsedFileOverviewDocInfo()) {\n            fileOverviewJSDocInfo = retrieveAndResetParsedJSDocInfo();\n          }\n          checkExtendedTypes(extendedTypes);\n          return true;\n\n        case EOF:\n          // discard any accumulated information\n          jsdocBuilder.build(null);\n          parser.addParserWarning(\"msg.unexpected.eof\",\n              stream.getLineno(), stream.getCharno());\n          checkExtendedTypes(extendedTypes);\n          return false;\n\n        case EOL:\n          if (state == State.SEARCHING_NEWLINE) {\n            state = State.SEARCHING_ANNOTATION;\n          }\n          token = next();\n          continue retry;\n\n        default:\n          if (token == JsDocToken.STAR && state == State.SEARCHING_ANNOTATION) {\n            token = next();\n            continue retry;\n          } else {\n            state = State.SEARCHING_NEWLINE;\n            token = eatTokensUntilEOL();\n            continue retry;\n          }\n      }\n\n      // next token\n      token = next();\n    }\n  }",
    "comment": " Parses a {@link JSDocInfo} object. This parsing method reads all tokens returned by the {@link JsDocTokenStream#getJsDocToken()} method until the {@link JsDocToken#EOC} is returned.  @return {@code true} if JSDoc information was correctly parsed, {@code false} otherwise ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "JsDocInfoParser.parseAndRecordParamTypeNode",
    "class_name": "com.google.javascript.jscomp.parsing.JsDocInfoParser",
    "signature": "com.google.javascript.jscomp.parsing.JsDocInfoParser.parseAndRecordParamTypeNode(JsDocToken)",
    "snippet": "  private Node parseAndRecordParamTypeNode(JsDocToken token) {\n    Preconditions.checkArgument(token == JsDocToken.LC);\n    int lineno = stream.getLineno();\n    int startCharno = stream.getCharno();\n\n    Node typeNode = parseParamTypeExpressionAnnotation(token);\n    int endCharno = stream.getCharno();\n\n    jsdocBuilder.markTypeNode(typeNode, lineno, startCharno, endCharno,\n        true);\n    return typeNode;\n  }",
    "comment": " Looks for a type expression at the current token and if found, returns it. Note that this method consumes input.  Parameter type expressions are special for two reasons: <ol> <li>They must begin with '{', to distinguish type names from param names. <li>They may end in '=', to denote optionality. </ol>  @param token The current token. @return The type expression found or null if none. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "JsDocInfoParser.parseAndRecordTypeNode",
    "class_name": "com.google.javascript.jscomp.parsing.JsDocInfoParser",
    "signature": "com.google.javascript.jscomp.parsing.JsDocInfoParser.parseAndRecordTypeNode(JsDocToken)",
    "snippet": "  private Node parseAndRecordTypeNode(JsDocToken token) {\n    return parseAndRecordTypeNode(token, token == JsDocToken.LC);\n  }",
    "comment": " Looks for a type expression at the current token and if found, returns it. Note that this method consumes input.  @param token The current token. @return The type expression found or null if none. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "JsDocInfoParser.parseAndRecordTypeNode",
    "class_name": "com.google.javascript.jscomp.parsing.JsDocInfoParser",
    "signature": "com.google.javascript.jscomp.parsing.JsDocInfoParser.parseAndRecordTypeNode(JsDocToken,boolean)",
    "snippet": "  private Node parseAndRecordTypeNode(JsDocToken token, boolean matchingLC) {\n    return parseAndRecordTypeNode(token, stream.getLineno(), stream.getCharno(),\n        matchingLC, false);\n  }",
    "comment": " Looks for a type expression at the current token and if found, returns it. Note that this method consumes input.  @param token The current token. @param matchingLC Whether the type expression starts with a \"{\". @return The type expression found or null if none. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "JsDocInfoParser.parseAndRecordTypeNode",
    "class_name": "com.google.javascript.jscomp.parsing.JsDocInfoParser",
    "signature": "com.google.javascript.jscomp.parsing.JsDocInfoParser.parseAndRecordTypeNode(JsDocToken,int,int,boolean,boolean)",
    "snippet": "  private Node parseAndRecordTypeNode(JsDocToken token, int lineno,\n                                      int startCharno,\n                                      boolean matchingLC,\n                                      boolean onlyParseSimpleNames) {\n    Node typeNode = null;\n\n    if (onlyParseSimpleNames) {\n      typeNode = parseTypeNameAnnotation(token);\n    } else {\n      typeNode = parseTypeExpressionAnnotation(token);\n    }\n\n    if (typeNode != null && !matchingLC) {\n      typeNode.putBooleanProp(Node.BRACELESS_TYPE, true);\n    }\n\n    int endCharno = stream.getCharno();\n\n    jsdocBuilder.markTypeNode(typeNode, lineno, startCharno, endCharno,\n        matchingLC);\n\n    return typeNode;\n  }",
    "comment": " Looks for a parameter type expression at the current token and if found, returns it. Note that this method consumes input.  @param token The current token. @param lineno The line of the type expression. @param startCharno The starting character position of the type expression. @param matchingLC Whether the type expression starts with a \"{\". @param onlyParseSimpleNames If true, only simple type names are parsed (via a call to parseTypeNameAnnotation instead of parseTypeExpressionAnnotation). @return The type expression found or null if none. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "JsDocInfoParser.parseBasicTypeExpression",
    "class_name": "com.google.javascript.jscomp.parsing.JsDocInfoParser",
    "signature": "com.google.javascript.jscomp.parsing.JsDocInfoParser.parseBasicTypeExpression(JsDocToken)",
    "snippet": "  private Node parseBasicTypeExpression(JsDocToken token) {\n    if (token == JsDocToken.STAR) {\n      return newNode(Token.STAR);\n    } else if (token == JsDocToken.LB) {\n      skipEOLs();\n      return parseArrayType(next());\n    } else if (token == JsDocToken.LC) {\n      skipEOLs();\n      return parseRecordType(next());\n    } else if (token == JsDocToken.LP) {\n      skipEOLs();\n      return parseUnionType(next());\n    } else if (token == JsDocToken.STRING) {\n      String string = stream.getString();\n      if (\"function\".equals(string)) {\n        skipEOLs();\n        return parseFunctionType(next());\n      } else if (\"null\".equals(string) || \"undefined\".equals(string)) {\n        return newStringNode(string);\n      } else {\n        return parseTypeName(token);\n      }\n    }\n\n    restoreLookAhead(token);\n    return reportGenericTypeSyntaxWarning();\n  }",
    "comment": " BasicTypeExpression := '*' | 'null' | 'undefined' | TypeName | FunctionType | UnionType | RecordType | ArrayType ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "JsDocInfoParser.parseParamTypeExpressionAnnotation",
    "class_name": "com.google.javascript.jscomp.parsing.JsDocInfoParser",
    "signature": "com.google.javascript.jscomp.parsing.JsDocInfoParser.parseParamTypeExpressionAnnotation(JsDocToken)",
    "snippet": "  private Node parseParamTypeExpressionAnnotation(JsDocToken token) {\n    Preconditions.checkArgument(token == JsDocToken.LC);\n\n    skipEOLs();\n\n    boolean restArg = false;\n    token = next();\n    if (token == JsDocToken.ELLIPSIS) {\n      token = next();\n      if (token == JsDocToken.RC) {\n        // EMPTY represents the UNKNOWN type in the Type AST.\n        return wrapNode(Token.ELLIPSIS, new Node(Token.EMPTY));\n      }\n      restArg = true;\n    }\n\n    Node typeNode = parseTopLevelTypeExpression(token);\n    if (typeNode != null) {\n      skipEOLs();\n      if (restArg) {\n        typeNode = wrapNode(Token.ELLIPSIS, typeNode);\n      } else if (match(JsDocToken.EQUALS)) {\n        next();\n        skipEOLs();\n        typeNode = wrapNode(Token.EQUALS, typeNode);\n      }\n\n      if (!match(JsDocToken.RC)) {\n        reportTypeSyntaxWarning(\"msg.jsdoc.missing.rc\");\n      } else {\n        next();\n      }\n    }\n\n    return typeNode;\n  }",
    "comment": " ParamTypeExpressionAnnotation := '{' OptionalParameterType '}' | '{' TopLevelTypeExpression '}' | '{' '...' TopLevelTypeExpression '}'  OptionalParameterType := TopLevelTypeExpression '=' ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "JsDocInfoParser.parseTopLevelTypeExpression",
    "class_name": "com.google.javascript.jscomp.parsing.JsDocInfoParser",
    "signature": "com.google.javascript.jscomp.parsing.JsDocInfoParser.parseTopLevelTypeExpression(JsDocToken)",
    "snippet": "  private Node parseTopLevelTypeExpression(JsDocToken token) {\n    Node typeExpr = parseTypeExpression(token);\n    if (typeExpr != null) {\n      // top-level unions are allowed\n      if (match(JsDocToken.PIPE)) {\n        next();\n        if (match(JsDocToken.PIPE)) {\n          // We support double pipes for backwards-compatibility.\n          next();\n        }\n        skipEOLs();\n        token = next();\n        return parseUnionTypeWithAlternate(token, typeExpr);\n      }\n    }\n    return typeExpr;\n  }",
    "comment": " TopLevelTypeExpression := TypeExpression | TypeUnionList  We made this rule up, for the sake of backwards compatibility. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "JsDocInfoParser.parseTypeExpression",
    "class_name": "com.google.javascript.jscomp.parsing.JsDocInfoParser",
    "signature": "com.google.javascript.jscomp.parsing.JsDocInfoParser.parseTypeExpression(JsDocToken)",
    "snippet": "  private Node parseTypeExpression(JsDocToken token) {\n    if (token == JsDocToken.QMARK) {\n      // A QMARK could mean that a type is nullable, or that it's unknown.\n      // We use look-ahead 1 to determine whether it's unknown. Otherwise,\n      // we assume it means nullable. There are 5 cases:\n      // {?} - right curly\n      // {?=} - equals\n      // {function(?, number)} - comma\n      // {function(number, ?)} - right paren\n      // {function(): ?|number} - pipe\n      // I'm not a big fan of using look-ahead for this, but it makes\n      // the type language a lot nicer.\n      token = next();\n      if (token == JsDocToken.COMMA ||\n          token == JsDocToken.EQUALS ||\n          token == JsDocToken.RC ||\n          token == JsDocToken.RP ||\n          token == JsDocToken.PIPE) {\n        restoreLookAhead(token);\n        return newNode(Token.QMARK);\n      }\n\n      return wrapNode(Token.QMARK, parseBasicTypeExpression(token));\n    } else if (token == JsDocToken.BANG) {\n      return wrapNode(Token.BANG, parseBasicTypeExpression(next()));\n    } else {\n      Node basicTypeExpr = parseBasicTypeExpression(token);\n      if (basicTypeExpr != null) {\n        if (match(JsDocToken.QMARK)) {\n          next();\n          return wrapNode(Token.QMARK, basicTypeExpr);\n        } else if (match(JsDocToken.BANG)) {\n          next();\n          return wrapNode(Token.BANG, basicTypeExpr);\n        }\n      }\n\n      return basicTypeExpr;\n    }\n  }",
    "comment": " TypeExpression := BasicTypeExpression | '?' BasicTypeExpression | '!' BasicTypeExpression | BasicTypeExpression '?' | BasicTypeExpression '!' | '?' ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "JsDocInfoParser.parseTypeExpressionAnnotation",
    "class_name": "com.google.javascript.jscomp.parsing.JsDocInfoParser",
    "signature": "com.google.javascript.jscomp.parsing.JsDocInfoParser.parseTypeExpressionAnnotation(JsDocToken)",
    "snippet": "  private Node parseTypeExpressionAnnotation(JsDocToken token) {\n    if (token == JsDocToken.LC) {\n      skipEOLs();\n      Node typeNode = parseTopLevelTypeExpression(next());\n      if (typeNode != null) {\n        skipEOLs();\n        if (!match(JsDocToken.RC)) {\n          reportTypeSyntaxWarning(\"msg.jsdoc.missing.rc\");\n        } else {\n          next();\n        }\n      }\n\n      return typeNode;\n    } else {\n      return parseTypeExpression(token);\n    }\n  }",
    "comment": " TypeExpressionAnnotation := TypeExpression | '{' TopLevelTypeExpression '}' ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "JsDocInfoParser.parseTypeName",
    "class_name": "com.google.javascript.jscomp.parsing.JsDocInfoParser",
    "signature": "com.google.javascript.jscomp.parsing.JsDocInfoParser.parseTypeName(JsDocToken)",
    "snippet": "  private Node parseTypeName(JsDocToken token) {\n    if (token != JsDocToken.STRING) {\n      return reportGenericTypeSyntaxWarning();\n    }\n\n    String typeName = stream.getString();\n    while (match(JsDocToken.EOL) &&\n        typeName.charAt(typeName.length() - 1) == '.') {\n      skipEOLs();\n      if (match(JsDocToken.STRING)) {\n        next();\n        typeName += stream.getString();\n      }\n    }\n\n    Node typeNameNode = newStringNode(typeName);\n\n    if (match(JsDocToken.LT)) {\n      next();\n      skipEOLs();\n      Node memberType = parseTypeExpressionList(next());\n      if (memberType != null) {\n        typeNameNode.addChildToFront(memberType);\n\n        skipEOLs();\n        if (!match(JsDocToken.GT)) {\n          return reportTypeSyntaxWarning(\"msg.jsdoc.missing.gt\");\n        }\n\n        next();\n      }\n    }\n    return typeNameNode;\n  }",
    "comment": " TypeName := NameExpression | NameExpression TypeApplication TypeApplication := '.<' TypeExpressionList '>' TypeExpressionList := TypeExpression // a white lie ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "JsDocInfoParser.retrieveAndResetParsedJSDocInfo",
    "class_name": "com.google.javascript.jscomp.parsing.JsDocInfoParser",
    "signature": "com.google.javascript.jscomp.parsing.JsDocInfoParser.retrieveAndResetParsedJSDocInfo()",
    "snippet": "  JSDocInfo retrieveAndResetParsedJSDocInfo() {\n    return jsdocBuilder.build(sourceName);\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "JsDocInfoParser.setFileLevelJsDocBuilder",
    "class_name": "com.google.javascript.jscomp.parsing.JsDocInfoParser",
    "signature": "com.google.javascript.jscomp.parsing.JsDocInfoParser.setFileLevelJsDocBuilder(FileLevelJsDocBuilder)",
    "snippet": "  void setFileLevelJsDocBuilder(\n      Node.FileLevelJsDocBuilder fileLevelJsDocBuilder) {\n    this.fileLevelJsDocBuilder = fileLevelJsDocBuilder;\n  }",
    "comment": " Sets the JsDocBuilder for the file-level (root) node of this parse. The parser uses the builder to append any preserve annotations it encounters in jsdoc comments.  @param fileLevelJsDocBuilder ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "JsDocInfoParser.setFileOverviewJSDocInfo",
    "class_name": "com.google.javascript.jscomp.parsing.JsDocInfoParser",
    "signature": "com.google.javascript.jscomp.parsing.JsDocInfoParser.setFileOverviewJSDocInfo(JSDocInfo)",
    "snippet": "  void setFileOverviewJSDocInfo(JSDocInfo fileOverviewJSDocInfo) {\n    this.fileOverviewJSDocInfo = fileOverviewJSDocInfo;\n  }",
    "comment": " Sets the file overview JSDocInfo, in order to warn about multiple uses of the @fileoverview tag in a file. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "JsDocInfoParser.skipEOLs",
    "class_name": "com.google.javascript.jscomp.parsing.JsDocInfoParser",
    "signature": "com.google.javascript.jscomp.parsing.JsDocInfoParser.skipEOLs()",
    "snippet": "  private void skipEOLs() {\n    while (match(JsDocToken.EOL)) {\n      next();\n      if (match(JsDocToken.STAR)) {\n        next();\n      }\n    }\n  }",
    "comment": " Skips all EOLs and all empty lines in the JSDoc. Call this method if you want the JSDoc entry to span multiple lines. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "JsDocInfoParser.wrapNode",
    "class_name": "com.google.javascript.jscomp.parsing.JsDocInfoParser",
    "signature": "com.google.javascript.jscomp.parsing.JsDocInfoParser.wrapNode(int,Node)",
    "snippet": "  private Node wrapNode(int type, Node n) {\n    return n == null ? null :\n        new Node(type, n, stream.getLineno(),\n            stream.getCharno()).clonePropsFrom(templateNode);\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "JsDocTokenStream.JsDocTokenStream",
    "class_name": "com.google.javascript.jscomp.parsing.JsDocTokenStream",
    "signature": "com.google.javascript.jscomp.parsing.JsDocTokenStream.JsDocTokenStream(String,int,int)",
    "snippet": "  JsDocTokenStream(String sourceString, int lineno, int initCharno) {\n    Preconditions.checkNotNull(sourceString);\n    this.lineno = lineno;\n    this.sourceString = sourceString;\n    this.sourceEnd = sourceString.length();\n    this.sourceCursor = this.cursor = 0;\n    this.initLineno = lineno;\n    this.initCharno = initCharno;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "JsDocTokenStream.addToString",
    "class_name": "com.google.javascript.jscomp.parsing.JsDocTokenStream",
    "signature": "com.google.javascript.jscomp.parsing.JsDocTokenStream.addToString(int)",
    "snippet": "  private void addToString(int c) {\n    int N = stringBufferTop;\n    if (N == stringBuffer.length) {\n        char[] tmp = new char[stringBuffer.length * 2];\n        System.arraycopy(stringBuffer, 0, tmp, 0, N);\n        stringBuffer = tmp;\n    }\n    stringBuffer[N] = (char)c;\n    stringBufferTop = N + 1;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "JsDocTokenStream.getChar",
    "class_name": "com.google.javascript.jscomp.parsing.JsDocTokenStream",
    "signature": "com.google.javascript.jscomp.parsing.JsDocTokenStream.getChar()",
    "snippet": "  protected int getChar() {\n    if (ungetCursor != 0) {\n      cursor++;\n      --ungetCursor;\n      if (charno == -1) {\n        charno = getOffset();\n      }\n      return ungetBuffer[ungetCursor];\n    }\n\n    for(;;) {\n      int c;\n      if (sourceCursor == sourceEnd) {\n        hitEOF = true;\n        if (charno == -1) {\n          charno = getOffset();\n        }\n        return EOF_CHAR;\n      }\n      cursor++;\n      c = sourceString.charAt(sourceCursor++);\n\n\n      if (lineEndChar >= 0) {\n        if (lineEndChar == '\\r' && c == '\\n') {\n          lineEndChar = '\\n';\n          continue;\n        }\n        lineEndChar = -1;\n        lineStart = sourceCursor - 1;\n        lineno++;\n      }\n\n      if (c <= 127) {\n        if (c == '\\n' || c == '\\r') {\n          lineEndChar = c;\n          c = '\\n';\n        }\n      } else {\n        if (isJSFormatChar(c)) {\n          continue;\n        }\n        if (ScriptRuntime.isJSLineTerminator(c)) {\n          lineEndChar = c;\n          c = '\\n';\n        }\n      }\n\n      if (charno == -1) {\n        charno = getOffset();\n      }\n\n      return c;\n    }\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "JsDocTokenStream.getCharIgnoreLineEnd",
    "class_name": "com.google.javascript.jscomp.parsing.JsDocTokenStream",
    "signature": "com.google.javascript.jscomp.parsing.JsDocTokenStream.getCharIgnoreLineEnd()",
    "snippet": "  private int getCharIgnoreLineEnd() {\n    if (ungetCursor != 0) {\n      cursor++;\n      --ungetCursor;\n      if (charno == -1) {\n        charno = getOffset();\n      }\n      return ungetBuffer[ungetCursor];\n    }\n\n    for(;;) {\n      int c;\n      if (sourceCursor == sourceEnd) {\n        hitEOF = true;\n        if (charno == -1) {\n          charno = getOffset();\n        }\n        return EOF_CHAR;\n      }\n      cursor++;\n      c = sourceString.charAt(sourceCursor++);\n\n\n      if (c <= 127) {\n        if (c == '\\n' || c == '\\r') {\n          lineEndChar = c;\n          c = '\\n';\n        }\n      } else {\n        if (isJSFormatChar(c)) {\n          continue;\n        }\n        if (ScriptRuntime.isJSLineTerminator(c)) {\n          lineEndChar = c;\n          c = '\\n';\n        }\n      }\n\n      if (charno == -1) {\n        charno = getOffset();\n      }\n\n      return c;\n    }\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "JsDocTokenStream.getCharno",
    "class_name": "com.google.javascript.jscomp.parsing.JsDocTokenStream",
    "signature": "com.google.javascript.jscomp.parsing.JsDocTokenStream.getCharno()",
    "snippet": "  final int getCharno() {\n    return lineno == initLineno? initCharno + charno : charno;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "JsDocTokenStream.getJsDocToken",
    "class_name": "com.google.javascript.jscomp.parsing.JsDocTokenStream",
    "signature": "com.google.javascript.jscomp.parsing.JsDocTokenStream.getJsDocToken()",
    "snippet": "  @SuppressWarnings(\"fallthrough\")\n  final JsDocToken getJsDocToken() {\n    int c;\n    stringBufferTop = 0;\n    for (;;) {\n      // eat white spaces\n      for (;;) {\n        charno = -1;\n        c = getChar();\n        if (c == EOF_CHAR) {\n          return JsDocToken.EOF;\n        } else if (c == '\\n') {\n          return JsDocToken.EOL;\n        } else if (!isJSSpace(c)) {\n          break;\n        }\n      }\n\n      switch (c) {\n        // annotation, e.g. @type or @constructor\n        case '@':\n          do {\n            c = getChar();\n            if (isAlpha(c)) {\n              addToString(c);\n            } else {\n              ungetChar(c);\n              this.string = getStringFromBuffer();\n              stringBufferTop = 0;\n              return JsDocToken.ANNOTATION;\n            }\n          } while (true);\n\n        case '*':\n          if (matchChar('/')) {\n            return JsDocToken.EOC;\n          } else {\n            return JsDocToken.STAR;\n          }\n\n        case ',':\n          return JsDocToken.COMMA;\n\n        case '>':\n          return JsDocToken.GT;\n\n        case '(':\n          return JsDocToken.LP;\n\n        case ')':\n          return JsDocToken.RP;\n\n        case '{':\n          return JsDocToken.LC;\n\n        case '}':\n          return JsDocToken.RC;\n\n        case '[':\n          return JsDocToken.LB;\n\n        case ']':\n          return JsDocToken.RB;\n\n        case '?':\n          return JsDocToken.QMARK;\n\n        case '!':\n          return JsDocToken.BANG;\n\n        case ':':\n          return JsDocToken.COLON;\n\n        case '=':\n          return JsDocToken.EQUALS;\n\n        case '|':\n          matchChar('|');\n          return JsDocToken.PIPE;\n\n        case '.':\n          c = getChar();\n          if (c == '<') {\n            return JsDocToken.LT;\n          } else {\n            if (c == '.') {\n              c = getChar();\n              if (c == '.') {\n                return JsDocToken.ELLIPSIS;\n              } else {\n                addToString('.');\n              }\n            }\n            // we may backtrack across line boundary\n            ungetBuffer[ungetCursor++] = c;\n            c = '.';\n          }\n          // fall through\n\n        default: {\n          // recognize a jsdoc string but discard last . if it is followed by\n          // a non-jsdoc comment char, e.g. Array.<\n          int c1 = c;\n          addToString(c);\n          int c2 = getChar();\n          if (!isJSDocString(c2)) {\n            ungetChar(c2);\n            this.string = getStringFromBuffer();\n            stringBufferTop = 0;\n            return JsDocToken.STRING;\n          } else {\n            do {\n              c1 = c2;\n              c2 = getChar();\n              if (c1 == '.' && c2 == '<') {\n                ungetChar(c2);\n                ungetChar(c1);\n                this.string = getStringFromBuffer();\n                stringBufferTop = 0;\n                return JsDocToken.STRING;\n              } else {\n                if (isJSDocString(c2)) {\n                  addToString(c1);\n                } else {\n                  ungetChar(c2);\n                  addToString(c1);\n                  this.string = getStringFromBuffer();\n                  stringBufferTop = 0;\n                  return JsDocToken.STRING;\n                }\n              }\n            } while (true);\n          }\n        }\n      }\n    }\n  }",
    "comment": " Tokenizes JSDoc comments. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "JsDocTokenStream.getLineno",
    "class_name": "com.google.javascript.jscomp.parsing.JsDocTokenStream",
    "signature": "com.google.javascript.jscomp.parsing.JsDocTokenStream.getLineno()",
    "snippet": "  final int getLineno() { return lineno; }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "JsDocTokenStream.getOffset",
    "class_name": "com.google.javascript.jscomp.parsing.JsDocTokenStream",
    "signature": "com.google.javascript.jscomp.parsing.JsDocTokenStream.getOffset()",
    "snippet": "  final int getOffset() {\n    return sourceCursor - lineStart - ungetCursor - 1;\n  }",
    "comment": " Returns the offset into the current line. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "JsDocTokenStream.getString",
    "class_name": "com.google.javascript.jscomp.parsing.JsDocTokenStream",
    "signature": "com.google.javascript.jscomp.parsing.JsDocTokenStream.getString()",
    "snippet": "  final String getString() { return string; }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "JsDocTokenStream.getStringFromBuffer",
    "class_name": "com.google.javascript.jscomp.parsing.JsDocTokenStream",
    "signature": "com.google.javascript.jscomp.parsing.JsDocTokenStream.getStringFromBuffer()",
    "snippet": "  private String getStringFromBuffer() {\n    tokenEnd = cursor;\n    return new String(stringBuffer, 0, stringBufferTop);\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "JsDocTokenStream.isAlpha",
    "class_name": "com.google.javascript.jscomp.parsing.JsDocTokenStream",
    "signature": "com.google.javascript.jscomp.parsing.JsDocTokenStream.isAlpha(int)",
    "snippet": "  private static boolean isAlpha(int c) {\n    // Use 'Z' < 'a'\n    if (c <= 'Z') {\n      return 'A' <= c;\n    } else {\n      return 'a' <= c && c <= 'z';\n    }\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "JsDocTokenStream.isJSDocString",
    "class_name": "com.google.javascript.jscomp.parsing.JsDocTokenStream",
    "signature": "com.google.javascript.jscomp.parsing.JsDocTokenStream.isJSDocString(int)",
    "snippet": "  private boolean isJSDocString(int c) {\n    switch (c) {\n      case '@':\n      case '*':\n      case ',':\n      case '>':\n      case ':':\n      case '(':\n      case ')':\n      case '{':\n      case '}':\n      case '[':\n      case ']':\n      case '?':\n      case '!':\n      case '|':\n      case '=':\n      case EOF_CHAR:\n      case '\\n':\n        return false;\n\n      default:\n        return !isJSSpace(c);\n    }\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "JsDocTokenStream.isJSSpace",
    "class_name": "com.google.javascript.jscomp.parsing.JsDocTokenStream",
    "signature": "com.google.javascript.jscomp.parsing.JsDocTokenStream.isJSSpace(int)",
    "snippet": "  static boolean isJSSpace(int c) {\n    if (c <= 127) {\n      return c == 0x20 || c == 0x9 || c == 0xC || c == 0xB;\n    } else {\n      return c == 0xA0\n          || Character.getType((char)c) == Character.SPACE_SEPARATOR;\n    }\n  }",
    "comment": "As defined in ECMA.  jsscan.c uses C isspace() (which allows \\v, I think.)  note that code in getChar() implicitly accepts '\\r' == \\u000D as well. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "JsDocTokenStream.matchChar",
    "class_name": "com.google.javascript.jscomp.parsing.JsDocTokenStream",
    "signature": "com.google.javascript.jscomp.parsing.JsDocTokenStream.matchChar(int)",
    "snippet": "  private boolean matchChar(int test) {\n    int c = getCharIgnoreLineEnd();\n    if (c == test) {\n      tokenEnd = cursor;\n      return true;\n    } else {\n      ungetCharIgnoreLineEnd(c);\n      return false;\n    }\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "JsDocTokenStream.ungetChar",
    "class_name": "com.google.javascript.jscomp.parsing.JsDocTokenStream",
    "signature": "com.google.javascript.jscomp.parsing.JsDocTokenStream.ungetChar(int)",
    "snippet": "  void ungetChar(int c) {\n    // can not unread past across line boundary\n    assert(!(ungetCursor != 0 && ungetBuffer[ungetCursor - 1] == '\\n'));\n    ungetBuffer[ungetCursor++] = c;\n    cursor--;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "JsDocTokenStream.ungetCharIgnoreLineEnd",
    "class_name": "com.google.javascript.jscomp.parsing.JsDocTokenStream",
    "signature": "com.google.javascript.jscomp.parsing.JsDocTokenStream.ungetCharIgnoreLineEnd(int)",
    "snippet": "  private void ungetCharIgnoreLineEnd(int c) {\n    ungetBuffer[ungetCursor++] = c;\n    cursor--;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "ParserRunner.createConfig",
    "class_name": "com.google.javascript.jscomp.parsing.ParserRunner",
    "signature": "com.google.javascript.jscomp.parsing.ParserRunner.createConfig(boolean,LanguageMode,boolean,Set)",
    "snippet": "  public static Config createConfig(boolean isIdeMode,\n                                    LanguageMode languageMode,\n                                    boolean acceptConstKeyword,\n                                    Set<String> extraAnnotationNames) {\n    initResourceConfig();\n    Set<String> effectiveAnnotationNames;\n    if (extraAnnotationNames == null) {\n      effectiveAnnotationNames = annotationNames;\n    } else {\n      effectiveAnnotationNames = new HashSet<String>(annotationNames);\n      effectiveAnnotationNames.addAll(extraAnnotationNames);\n    }\n    return new Config(effectiveAnnotationNames, suppressionNames,\n        isIdeMode, languageMode, acceptConstKeyword);\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "ParserRunner.extractList",
    "class_name": "com.google.javascript.jscomp.parsing.ParserRunner",
    "signature": "com.google.javascript.jscomp.parsing.ParserRunner.extractList(String)",
    "snippet": "  private static Set<String> extractList(String configProp) {\n    String[] names = configProp.split(\",\");\n    Set<String> trimmedNames = Sets.newHashSet();\n    for (String name : names) {\n      trimmedNames.add(name.trim());\n    }\n    return ImmutableSet.copyOf(trimmedNames);\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "ParserRunner.initResourceConfig",
    "class_name": "com.google.javascript.jscomp.parsing.ParserRunner",
    "signature": "com.google.javascript.jscomp.parsing.ParserRunner.initResourceConfig()",
    "snippet": "  private static synchronized void initResourceConfig() {\n    if (annotationNames != null) {\n      return;\n    }\n\n    ResourceBundle config = ResourceBundle.getBundle(configResource);\n    annotationNames = extractList(config.getString(\"jsdoc.annotations\"));\n    suppressionNames = extractList(config.getString(\"jsdoc.suppressions\"));\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "ParserRunner.parse",
    "class_name": "com.google.javascript.jscomp.parsing.ParserRunner",
    "signature": "com.google.javascript.jscomp.parsing.ParserRunner.parse(StaticSourceFile,String,Config,ErrorReporter,Logger)",
    "snippet": "  public static Node parse(StaticSourceFile sourceFile,\n                           String sourceString,\n                           Config config,\n                           ErrorReporter errorReporter,\n                           Logger logger) throws IOException {\n    Context cx = Context.enter();\n    cx.setErrorReporter(errorReporter);\n    cx.setLanguageVersion(Context.VERSION_1_5);\n    CompilerEnvirons compilerEnv = new CompilerEnvirons();\n    compilerEnv.initFromContext(cx);\n    compilerEnv.setRecordingComments(true);\n    compilerEnv.setRecordingLocalJsDocComments(true);\n    // ES5 specifically allows trailing commas\n    compilerEnv.setWarnTrailingComma(\n        config.languageMode == LanguageMode.ECMASCRIPT3);\n\n    if (config.isIdeMode || config.languageMode != LanguageMode.ECMASCRIPT3) {\n      // Do our own identifier check for ECMASCRIPT 5\n      compilerEnv.setReservedKeywordAsIdentifier(true);\n      compilerEnv.setAllowKeywordAsObjectPropertyName(true);\n    }\n\n    if (config.isIdeMode) {\n      compilerEnv.setAllowMemberExprAsFunctionName(true);\n    }\n\n    Parser p = new Parser(compilerEnv, errorReporter);\n    AstRoot astRoot = null;\n    try {\n      astRoot = p.parse(sourceString, sourceFile.getName(), 1);\n    } catch (EvaluatorException e) {\n      logger.info(\n          \"Error parsing \" + sourceFile.getName() + \": \" + e.getMessage());\n    } finally {\n      Context.exit();\n    }\n    Node root = null;\n    if (astRoot != null) {\n      root = IRFactory.transformTree(\n          astRoot, sourceFile, sourceString, config, errorReporter);\n      root.setIsSyntheticBlock(true);\n    }\n    return root;\n  }",
    "comment": " Parses the JavaScript text given by a reader.  @param sourceName The filename. @param sourceString Source code from the file. @param errorReporter An error. @param logger A logger. @return The AST of the given text. @throws IOException ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "TypeSafeDispatcher.process",
    "class_name": "com.google.javascript.jscomp.parsing.TypeSafeDispatcher",
    "signature": "com.google.javascript.jscomp.parsing.TypeSafeDispatcher.process(AstNode)",
    "snippet": "  public T process(AstNode node) {\n    switch (node.getType()) {\n      case Token.ADD:\n      case Token.AND:\n      case Token.BITAND:\n      case Token.BITOR:\n      case Token.BITXOR:\n      case Token.COMMA:\n      case Token.DIV:\n      case Token.EQ:\n      case Token.GE:\n      case Token.GT:\n      case Token.IN:\n      case Token.INSTANCEOF:\n      case Token.LE:\n      case Token.LSH:\n      case Token.LT:\n      case Token.MOD:\n      case Token.MUL:\n      case Token.NE:\n      case Token.OR:\n      case Token.RSH:\n      case Token.SHEQ:\n      case Token.SHNE:\n      case Token.SUB:\n      case Token.URSH:\n        return processInfixExpression((InfixExpression) node);\n      case Token.ARRAYLIT:\n        return processArrayLiteral((ArrayLiteral) node);\n      case Token.ASSIGN:\n      case Token.ASSIGN_ADD:\n      case Token.ASSIGN_BITAND:\n      case Token.ASSIGN_BITOR:\n      case Token.ASSIGN_BITXOR:\n      case Token.ASSIGN_DIV:\n      case Token.ASSIGN_LSH:\n      case Token.ASSIGN_MOD:\n      case Token.ASSIGN_MUL:\n      case Token.ASSIGN_RSH:\n      case Token.ASSIGN_SUB:\n      case Token.ASSIGN_URSH:\n        return processAssignment((Assignment) node);\n      case Token.BITNOT:\n      case Token.DEC:\n      case Token.DELPROP:\n      case Token.INC:\n      case Token.NEG:\n      case Token.NOT:\n      case Token.POS:\n      case Token.TYPEOF:\n      case Token.VOID:\n        return processUnaryExpression((UnaryExpression) node);\n      case Token.BLOCK:\n        if (node instanceof Block) {\n          return processBlock((Block) node);\n        } else  if (node instanceof Scope) {\n          return processScope((Scope) node);\n        } else {\n          throw new IllegalStateException(\"Unexpected node type.  class: \" +\n                                          node.getClass() +\n                                          \" type: \" +\n                                          Token.typeToName(node.getType()));\n        }\n      case Token.BREAK:\n        return processBreakStatement((BreakStatement) node);\n      case Token.CALL:\n        return processFunctionCall((FunctionCall) node);\n      case Token.CASE:\n      case Token.DEFAULT:\n        return processSwitchCase((SwitchCase) node);\n      case Token.CATCH:\n      case Token.FINALLY:\n        return processCatchClause((CatchClause) node);\n      case Token.COLON:\n        return processObjectProperty((ObjectProperty) node);\n      case Token.CONTINUE:\n        return processContinueStatement((ContinueStatement) node);\n      case Token.DO:\n        return processDoLoop((DoLoop) node);\n      case Token.EMPTY:\n        return processEmptyExpression((EmptyExpression) node);\n      case Token.EXPR_RESULT:\n      case Token.EXPR_VOID:\n        if (node instanceof ExpressionStatement) {\n          return processExpressionStatement((ExpressionStatement) node);\n        } else  if (node instanceof LabeledStatement) {\n          return processLabeledStatement((LabeledStatement) node);\n        } else {\n          throw new IllegalStateException(\"Unexpected node type.  class: \" +\n                                          node.getClass() +\n                                          \" type: \" +\n                                          Token.typeToName(node.getType()));\n        }\n      case Token.DEBUGGER:\n      case Token.FALSE:\n      case Token.NULL:\n      case Token.THIS:\n      case Token.TRUE:\n        return processKeywordLiteral((KeywordLiteral) node);\n      case Token.FOR:\n        if (node instanceof ForInLoop) {\n          return processForInLoop((ForInLoop) node);\n        } else  if (node instanceof ForLoop) {\n          return processForLoop((ForLoop) node);\n        } else {\n          throw new IllegalStateException(\"Unexpected node type.  class: \" +\n                                          node.getClass() +\n                                          \" type: \" +\n                                          Token.typeToName(node.getType()));\n        }\n      case Token.FUNCTION:\n        return processFunctionNode((FunctionNode) node);\n      case Token.GETELEM:\n        return processElementGet((ElementGet) node);\n      case Token.GETPROP:\n        return processPropertyGet((PropertyGet) node);\n      case Token.HOOK:\n        return processConditionalExpression((ConditionalExpression) node);\n      case Token.IF:\n        return processIfStatement((IfStatement) node);\n      case Token.LABEL:\n        return processLabel((Label) node);\n      case Token.LP:\n        return processParenthesizedExpression((ParenthesizedExpression) node);\n      case Token.NAME:\n        return processName((Name) node);\n      case Token.NEW:\n        return processNewExpression((NewExpression) node);\n      case Token.NUMBER:\n        return processNumberLiteral((NumberLiteral) node);\n      case Token.OBJECTLIT:\n        return processObjectLiteral((ObjectLiteral) node);\n      case Token.REGEXP:\n        return processRegExpLiteral((RegExpLiteral) node);\n      case Token.RETURN:\n        return processReturnStatement((ReturnStatement) node);\n      case Token.SCRIPT:\n        return processAstRoot((AstRoot) node);\n      case Token.STRING:\n        return processStringLiteral((StringLiteral) node);\n      case Token.SWITCH:\n        return processSwitchStatement((SwitchStatement) node);\n      case Token.THROW:\n        return processThrowStatement((ThrowStatement) node);\n      case Token.TRY:\n        return processTryStatement((TryStatement) node);\n      case Token.CONST:\n      case Token.VAR:\n        if (node instanceof VariableDeclaration) {\n          return processVariableDeclaration((VariableDeclaration) node);\n        } else  if (node instanceof VariableInitializer) {\n          return processVariableInitializer((VariableInitializer) node);\n        } else {\n          throw new IllegalStateException(\"Unexpected node type.  class: \" +\n                                          node.getClass() +\n                                          \" type: \" +\n                                          Token.typeToName(node.getType()));\n        }\n      case Token.WHILE:\n        return processWhileLoop((WhileLoop) node);\n      case Token.WITH:\n        return processWithStatement((WithStatement) node);\n    }\n    return processIllegalToken(node);\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "Context.getCurrentContext",
    "class_name": "com.google.javascript.rhino.Context",
    "signature": "com.google.javascript.rhino.Context.getCurrentContext()",
    "snippet": "    public static Context getCurrentContext() {\n        return threadContexts.get();\n    }",
    "comment": " Get the current Context.  The current Context is per-thread; this method looks up the Context associated with the current thread. <p>  @return the Context associated with the current thread, or null if no context is associated with the current thread. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "JSDocInfo.JSDocInfo",
    "class_name": "com.google.javascript.rhino.JSDocInfo",
    "signature": "com.google.javascript.rhino.JSDocInfo.JSDocInfo(boolean)",
    "snippet": "  JSDocInfo(boolean includeDocumentation) {\n    this.includeDocumentation = includeDocumentation;\n  }",
    "comment": " Creates a {@link JSDocInfo} object. This object should be created using a {@link JSDocInfoBuilder}. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "JSDocInfo.addMarker",
    "class_name": "com.google.javascript.rhino.JSDocInfo",
    "signature": "com.google.javascript.rhino.JSDocInfo.addMarker()",
    "snippet": "  Marker addMarker() {\n    if (!lazyInitDocumentation()) {\n      return null;\n    }\n\n    if (documentation.markers == null) {\n      documentation.markers = Lists.newArrayList();\n    }\n\n    Marker marker = new Marker();\n    documentation.markers.add(marker);\n    return marker;\n  }",
    "comment": " Adds a marker to the documentation (if it exists) and returns the marker. Returns null otherwise. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "JSDocInfo.declareParam",
    "class_name": "com.google.javascript.rhino.JSDocInfo",
    "signature": "com.google.javascript.rhino.JSDocInfo.declareParam(JSTypeExpression,String)",
    "snippet": "  boolean declareParam(JSTypeExpression jsType, String parameter) {\n    lazyInitInfo();\n    if (info.parameters == null) {\n      info.parameters = new LinkedHashMap<String, JSTypeExpression>();\n    }\n    if (!info.parameters.containsKey(parameter)) {\n      info.parameters.put(parameter, jsType);\n      return true;\n    } else {\n      return false;\n    }\n  }",
    "comment": " Declares a parameter. Parameters are described using the {@code @param} annotation.  @param jsType the parameter's type, it may be {@code null} when the {@code @param} annotation did not specify a type. @param parameter the parameter's name ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "JSDocInfo.getBaseType",
    "class_name": "com.google.javascript.rhino.JSDocInfo",
    "signature": "com.google.javascript.rhino.JSDocInfo.getBaseType()",
    "snippet": "  public JSTypeExpression getBaseType() {\n    return (info == null) ? null : info.baseType;\n  }",
    "comment": " Gets the base type specified by the {@code @extends} annotation. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "JSDocInfo.getExtendedInterfacesCount",
    "class_name": "com.google.javascript.rhino.JSDocInfo",
    "signature": "com.google.javascript.rhino.JSDocInfo.getExtendedInterfacesCount()",
    "snippet": "  public int getExtendedInterfacesCount() {\n    if (info == null || info.extendedInterfaces == null) {\n      return 0;\n    }\n    return info.extendedInterfaces.size();\n  }",
    "comment": " Gets the number of extended interfaces specified ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "JSDocInfo.getFlag",
    "class_name": "com.google.javascript.rhino.JSDocInfo",
    "signature": "com.google.javascript.rhino.JSDocInfo.getFlag(int)",
    "snippet": "  private boolean getFlag(int mask) {\n    return (bitset & mask) != 0x00;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "JSDocInfo.getImplementedInterfaceCount",
    "class_name": "com.google.javascript.rhino.JSDocInfo",
    "signature": "com.google.javascript.rhino.JSDocInfo.getImplementedInterfaceCount()",
    "snippet": "  public int getImplementedInterfaceCount() {\n    if (info == null || info.implementedInterfaces == null) {\n      return 0;\n    }\n    return info.implementedInterfaces.size();\n  }",
    "comment": " Gets the number of interfaces specified by the {@code @implements} annotation. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "JSDocInfo.getImplementedInterfaces",
    "class_name": "com.google.javascript.rhino.JSDocInfo",
    "signature": "com.google.javascript.rhino.JSDocInfo.getImplementedInterfaces()",
    "snippet": "  public List<JSTypeExpression> getImplementedInterfaces() {\n    if (info == null || info.implementedInterfaces == null) {\n      return ImmutableList.of();\n    }\n    return Collections.unmodifiableList(info.implementedInterfaces);\n  }",
    "comment": " Returns the types specified by the {@code @implements} annotation.  @return An immutable list of JSTypeExpression objects that can be resolved to types. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "JSDocInfo.getLendsName",
    "class_name": "com.google.javascript.rhino.JSDocInfo",
    "signature": "com.google.javascript.rhino.JSDocInfo.getLendsName()",
    "snippet": "  public String getLendsName() {\n    return (info == null) ? null : info.lendsName;\n  }",
    "comment": " Gets the name we're lending to in a {@code @lends} annotation.  In many reflection APIs, you pass an anonymous object to a function, and that function mixes the anonymous object into another object. The {@code @lends} annotation allows the type system to track those property assignments. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "JSDocInfo.getParameterCount",
    "class_name": "com.google.javascript.rhino.JSDocInfo",
    "signature": "com.google.javascript.rhino.JSDocInfo.getParameterCount()",
    "snippet": "  public int getParameterCount() {\n    if (info == null || info.parameters == null) {\n      return 0;\n    }\n    return info.parameters.size();\n  }",
    "comment": " Gets the number of parameters defined. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "JSDocInfo.getParameterNames",
    "class_name": "com.google.javascript.rhino.JSDocInfo",
    "signature": "com.google.javascript.rhino.JSDocInfo.getParameterNames()",
    "snippet": "  public Set<String> getParameterNames() {\n    if (info == null || info.parameters == null) {\n      return ImmutableSet.of();\n    }\n    return ImmutableSet.copyOf(info.parameters.keySet());\n  }",
    "comment": " Returns the set of names of the defined parameters. The iteration order of the returned set is not the order in which parameters are defined.  @return the set of names of the defined parameters. The returned set is immutable. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "JSDocInfo.getParameterType",
    "class_name": "com.google.javascript.rhino.JSDocInfo",
    "signature": "com.google.javascript.rhino.JSDocInfo.getParameterType(String)",
    "snippet": "  public JSTypeExpression getParameterType(String parameter) {\n    if (info == null || info.parameters == null) {\n      return null;\n    }\n    return info.parameters.get(parameter);\n  }",
    "comment": " Gets the parameter type. @param parameter the parameter's name @return the parameter's type or {@code null} if this parameter is not defined or has a {@code null} type ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "JSDocInfo.getReturnType",
    "class_name": "com.google.javascript.rhino.JSDocInfo",
    "signature": "com.google.javascript.rhino.JSDocInfo.getReturnType()",
    "snippet": "  public JSTypeExpression getReturnType() {\n    return getType(TYPEFIELD_RETURN);\n  }",
    "comment": " Gets the return type specified by the {@code @return} annotation. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "JSDocInfo.getSuppressions",
    "class_name": "com.google.javascript.rhino.JSDocInfo",
    "signature": "com.google.javascript.rhino.JSDocInfo.getSuppressions()",
    "snippet": "  public Set<String> getSuppressions() {\n    Set<String> suppressions = info == null ? null : info.suppressions;\n    return suppressions == null ? Collections.<String>emptySet() : suppressions;\n  }",
    "comment": " Returns the set of suppressed warnings. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "JSDocInfo.getTemplateTypeName",
    "class_name": "com.google.javascript.rhino.JSDocInfo",
    "signature": "com.google.javascript.rhino.JSDocInfo.getTemplateTypeName()",
    "snippet": "  public String getTemplateTypeName() {\n    if (info == null) {\n      return null;\n    }\n    return info.templateTypeName;\n  }",
    "comment": "Gets the template type name. */",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "JSDocInfo.getThisType",
    "class_name": "com.google.javascript.rhino.JSDocInfo",
    "signature": "com.google.javascript.rhino.JSDocInfo.getThisType()",
    "snippet": "  public JSTypeExpression getThisType() {\n    return thisType;\n  }",
    "comment": " Gets the type specified by the {@code @this} annotation. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "JSDocInfo.getType",
    "class_name": "com.google.javascript.rhino.JSDocInfo",
    "signature": "com.google.javascript.rhino.JSDocInfo.getType()",
    "snippet": "  public JSTypeExpression getType() {\n    return getType(TYPEFIELD_TYPE);\n  }",
    "comment": " Gets the type specified by the {@code @type} annotation. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "JSDocInfo.getType",
    "class_name": "com.google.javascript.rhino.JSDocInfo",
    "signature": "com.google.javascript.rhino.JSDocInfo.getType(int)",
    "snippet": "  private JSTypeExpression getType(int typefield) {\n    if ((MASK_TYPEFIELD & bitset) == typefield) {\n      return type;\n    } else {\n      return null;\n    }\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "JSDocInfo.getVisibility",
    "class_name": "com.google.javascript.rhino.JSDocInfo",
    "signature": "com.google.javascript.rhino.JSDocInfo.getVisibility()",
    "snippet": "  public Visibility getVisibility() {\n    return visibility;\n  }",
    "comment": " Gets the visibility specified by {@code @private}, {@code @protected} or {@code @public} annotation. If no visibility is specified, visibility is inherited from the base class. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "JSDocInfo.hasBaseType",
    "class_name": "com.google.javascript.rhino.JSDocInfo",
    "signature": "com.google.javascript.rhino.JSDocInfo.hasBaseType()",
    "snippet": "  public boolean hasBaseType() {\n    return getBaseType() != null;\n  }",
    "comment": " Returns whether this {@link JSDocInfo} contains a type for {@code @extends} annotation. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "JSDocInfo.hasEnumParameterType",
    "class_name": "com.google.javascript.rhino.JSDocInfo",
    "signature": "com.google.javascript.rhino.JSDocInfo.hasEnumParameterType()",
    "snippet": "  public boolean hasEnumParameterType() {\n    return hasType(TYPEFIELD_ENUM);\n  }",
    "comment": " Returns whether an enum parameter type, specified using the {@code @enum} annotation, is present on this JSDoc. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "JSDocInfo.hasFileOverview",
    "class_name": "com.google.javascript.rhino.JSDocInfo",
    "signature": "com.google.javascript.rhino.JSDocInfo.hasFileOverview()",
    "snippet": "  public boolean hasFileOverview() {\n    return getFlag(MASK_FILEOVERVIEW);\n  }",
    "comment": " Returns whether this has a fileoverview flag. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "JSDocInfo.hasModifies",
    "class_name": "com.google.javascript.rhino.JSDocInfo",
    "signature": "com.google.javascript.rhino.JSDocInfo.hasModifies()",
    "snippet": "  public boolean hasModifies() {\n    return info != null && info.modifies != null;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "JSDocInfo.hasParameterType",
    "class_name": "com.google.javascript.rhino.JSDocInfo",
    "signature": "com.google.javascript.rhino.JSDocInfo.hasParameterType(String)",
    "snippet": "  public boolean hasParameterType(String parameter) {\n    return getParameterType(parameter) != null;\n  }",
    "comment": " Returns whether the parameter has an attached type.  @return {@code true} if the parameter has an attached type, {@code false} if the parameter has no attached type or does not exist. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "JSDocInfo.hasReturnType",
    "class_name": "com.google.javascript.rhino.JSDocInfo",
    "signature": "com.google.javascript.rhino.JSDocInfo.hasReturnType()",
    "snippet": "  public boolean hasReturnType() {\n    return hasType(TYPEFIELD_RETURN);\n  }",
    "comment": " Returns whether this {@link JSDocInfo} contains a type for {@code @return} annotation. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "JSDocInfo.hasThisType",
    "class_name": "com.google.javascript.rhino.JSDocInfo",
    "signature": "com.google.javascript.rhino.JSDocInfo.hasThisType()",
    "snippet": "  public boolean hasThisType() {\n    return thisType != null;\n  }",
    "comment": " Returns whether this {@link JSDocInfo} contains a type for {@code @this} annotation. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "JSDocInfo.hasType",
    "class_name": "com.google.javascript.rhino.JSDocInfo",
    "signature": "com.google.javascript.rhino.JSDocInfo.hasType()",
    "snippet": "  public boolean hasType() {\n    return hasType(TYPEFIELD_TYPE);\n  }",
    "comment": " Returns whether a type, specified using the {@code @type} annotation, is present on this JSDoc. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "JSDocInfo.hasType",
    "class_name": "com.google.javascript.rhino.JSDocInfo",
    "signature": "com.google.javascript.rhino.JSDocInfo.hasType(int)",
    "snippet": "  private boolean hasType(int mask) {\n    return (bitset & MASK_TYPEFIELD) == mask;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "JSDocInfo.hasTypedefType",
    "class_name": "com.google.javascript.rhino.JSDocInfo",
    "signature": "com.google.javascript.rhino.JSDocInfo.hasTypedefType()",
    "snippet": "  public boolean hasTypedefType() {\n    return hasType(TYPEFIELD_TYPEDEF);\n  }",
    "comment": " Returns whether a typedef parameter type, specified using the {@code @typedef} annotation, is present on this JSDoc. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "JSDocInfo.isConstant",
    "class_name": "com.google.javascript.rhino.JSDocInfo",
    "signature": "com.google.javascript.rhino.JSDocInfo.isConstant()",
    "snippet": "  public boolean isConstant() {\n    return getFlag(MASK_CONSTANT) || isDefine();\n  }",
    "comment": " Returns whether the {@code @const} annotation is present on this {@link JSDocInfo}. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "JSDocInfo.isConstructor",
    "class_name": "com.google.javascript.rhino.JSDocInfo",
    "signature": "com.google.javascript.rhino.JSDocInfo.isConstructor()",
    "snippet": "  public boolean isConstructor() {\n    return getFlag(MASK_CONSTRUCTOR);\n  }",
    "comment": " Returns whether the {@code @constructor} annotation is present on this {@link JSDocInfo}. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "JSDocInfo.isDefine",
    "class_name": "com.google.javascript.rhino.JSDocInfo",
    "signature": "com.google.javascript.rhino.JSDocInfo.isDefine()",
    "snippet": "  public boolean isDefine() {\n    return getFlag(MASK_DEFINE);\n  }",
    "comment": " Returns whether the {@code @define} annotation is present on this {@link JSDocInfo}. If this annotation is present, then the {@link #getType()} method will retrieve the define type. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "JSDocInfo.isDeprecated",
    "class_name": "com.google.javascript.rhino.JSDocInfo",
    "signature": "com.google.javascript.rhino.JSDocInfo.isDeprecated()",
    "snippet": "  public boolean isDeprecated() {\n    return getFlag(MASK_DEPRECATED);\n  }",
    "comment": " Returns whether the {@code @deprecated} annotation is present on this {@link JSDocInfo}. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "JSDocInfo.isExterns",
    "class_name": "com.google.javascript.rhino.JSDocInfo",
    "signature": "com.google.javascript.rhino.JSDocInfo.isExterns()",
    "snippet": "  public boolean isExterns() {\n    return getFlag(MASK_EXTERNS);\n  }",
    "comment": " Returns whether the {@code @externs} annotation is present on this {@link JSDocInfo}. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "JSDocInfo.isImplicitCast",
    "class_name": "com.google.javascript.rhino.JSDocInfo",
    "signature": "com.google.javascript.rhino.JSDocInfo.isImplicitCast()",
    "snippet": "  public boolean isImplicitCast() {\n    return getFlag(MASK_IMPLICITCAST);\n  }",
    "comment": " Returns whether the {@code @implicitCast} annotation is present on this {@link JSDocInfo}. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "JSDocInfo.isInterface",
    "class_name": "com.google.javascript.rhino.JSDocInfo",
    "signature": "com.google.javascript.rhino.JSDocInfo.isInterface()",
    "snippet": "  public boolean isInterface() {\n    return getFlag(MASK_INTERFACE);\n  }",
    "comment": " Returns whether the {@code @interface} annotation is present on this {@link JSDocInfo}. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "JSDocInfo.isJavaDispatch",
    "class_name": "com.google.javascript.rhino.JSDocInfo",
    "signature": "com.google.javascript.rhino.JSDocInfo.isJavaDispatch()",
    "snippet": "  public boolean isJavaDispatch() {\n    return getFlag(MASK_JAVADISPATCH);\n  }",
    "comment": " Returns whether the {@code @javadispath} annotation is present on this {@link JSDocInfo}. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "JSDocInfo.isNoCompile",
    "class_name": "com.google.javascript.rhino.JSDocInfo",
    "signature": "com.google.javascript.rhino.JSDocInfo.isNoCompile()",
    "snippet": "  public boolean isNoCompile() {\n    return getFlag(MASK_NOCOMPILE);\n  }",
    "comment": " Returns whether the {@code @nocompile} annotation is present on this {@link JSDocInfo}. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "JSDocInfo.isNoSideEffects",
    "class_name": "com.google.javascript.rhino.JSDocInfo",
    "signature": "com.google.javascript.rhino.JSDocInfo.isNoSideEffects()",
    "snippet": "  public boolean isNoSideEffects() {\n    return getFlag(MASK_NOSIDEEFFECTS);\n  }",
    "comment": " Returns whether the {@code @nosideeffects} annotation is present on this {@link JSDocInfo}. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "JSDocInfo.isNoTypeCheck",
    "class_name": "com.google.javascript.rhino.JSDocInfo",
    "signature": "com.google.javascript.rhino.JSDocInfo.isNoTypeCheck()",
    "snippet": "  public boolean isNoTypeCheck() {\n    return getFlag(MASK_NOCHECK);\n  }",
    "comment": " Returns whether the {@code @nocheck} annotation is present on this {@link JSDocInfo}. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "JSDocInfo.isOverride",
    "class_name": "com.google.javascript.rhino.JSDocInfo",
    "signature": "com.google.javascript.rhino.JSDocInfo.isOverride()",
    "snippet": "  public boolean isOverride() {\n    return getFlag(MASK_OVERRIDE);\n  }",
    "comment": " Returns whether the {@code @override} annotation is present on this {@link JSDocInfo}. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "JSDocInfo.lazyInitDocumentation",
    "class_name": "com.google.javascript.rhino.JSDocInfo",
    "signature": "com.google.javascript.rhino.JSDocInfo.lazyInitDocumentation()",
    "snippet": "  private boolean lazyInitDocumentation() {\n    if (!includeDocumentation) {\n      return false;\n    }\n\n    if (documentation == null) {\n      documentation = new LazilyInitializedDocumentation();\n    }\n\n    return true;\n  }",
    "comment": " Lazily initializes the documentation information object, but only if the JSDocInfo was told to keep such information around. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "JSDocInfo.lazyInitInfo",
    "class_name": "com.google.javascript.rhino.JSDocInfo",
    "signature": "com.google.javascript.rhino.JSDocInfo.lazyInitInfo()",
    "snippet": "  private void lazyInitInfo() {\n    if (info == null) {\n      info = new LazilyInitializedInfo();\n    }\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "JSDocInfo.setConstructor",
    "class_name": "com.google.javascript.rhino.JSDocInfo",
    "signature": "com.google.javascript.rhino.JSDocInfo.setConstructor(boolean)",
    "snippet": "  void setConstructor(boolean value) {\n    setFlag(value, MASK_CONSTRUCTOR);\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "JSDocInfo.setFlag",
    "class_name": "com.google.javascript.rhino.JSDocInfo",
    "signature": "com.google.javascript.rhino.JSDocInfo.setFlag(boolean,int)",
    "snippet": "  private void setFlag(boolean value, int mask) {\n    if (value) {\n      bitset |= mask;\n    } else {\n      bitset &= ~mask;\n    }\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "JSDocInfo.setNoSideEffects",
    "class_name": "com.google.javascript.rhino.JSDocInfo",
    "signature": "com.google.javascript.rhino.JSDocInfo.setNoSideEffects(boolean)",
    "snippet": "  void setNoSideEffects(boolean value) {\n    setFlag(value, MASK_NOSIDEEFFECTS);\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "JSDocInfo.setReturnType",
    "class_name": "com.google.javascript.rhino.JSDocInfo",
    "signature": "com.google.javascript.rhino.JSDocInfo.setReturnType(JSTypeExpression)",
    "snippet": "  void setReturnType(JSTypeExpression type) {\n    setType(type, TYPEFIELD_RETURN);\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "JSDocInfo.setSourceName",
    "class_name": "com.google.javascript.rhino.JSDocInfo",
    "signature": "com.google.javascript.rhino.JSDocInfo.setSourceName(String)",
    "snippet": "  void setSourceName(String sourceName) {\n    this.sourceName = sourceName;\n  }",
    "comment": "Sets the name of the source file that contains this JSDoc. */",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "JSDocInfo.setThisType",
    "class_name": "com.google.javascript.rhino.JSDocInfo",
    "signature": "com.google.javascript.rhino.JSDocInfo.setThisType(JSTypeExpression)",
    "snippet": "  void setThisType(JSTypeExpression type) {\n    this.thisType = type;\n  }",
    "comment": " Sets the type specified by the {@code @this} annotation. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "JSDocInfo.setType",
    "class_name": "com.google.javascript.rhino.JSDocInfo",
    "signature": "com.google.javascript.rhino.JSDocInfo.setType(JSTypeExpression)",
    "snippet": "  void setType(JSTypeExpression type) {\n    setType(type, TYPEFIELD_TYPE);\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "JSDocInfo.setType",
    "class_name": "com.google.javascript.rhino.JSDocInfo",
    "signature": "com.google.javascript.rhino.JSDocInfo.setType(JSTypeExpression,int)",
    "snippet": "  private void setType(JSTypeExpression type, int mask) {\n    if ((bitset & MASK_TYPEFIELD) != 0) {\n      throw new IllegalStateException(\n          \"API tried to add two incompatible type tags. \" +\n          \"This should have been blocked and emitted a warning.\");\n    }\n    this.bitset = (bitset & MASK_FLAGS) | mask;\n    this.type = type;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "JSDocInfo.setVisibility",
    "class_name": "com.google.javascript.rhino.JSDocInfo",
    "signature": "com.google.javascript.rhino.JSDocInfo.setVisibility(Visibility)",
    "snippet": "  public void setVisibility(Visibility visibility) {\n    this.visibility = visibility;\n  }",
    "comment": "Visible for testing.",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "JSDocInfoBuilder.JSDocInfoBuilder",
    "class_name": "com.google.javascript.rhino.JSDocInfoBuilder",
    "signature": "com.google.javascript.rhino.JSDocInfoBuilder.JSDocInfoBuilder(boolean)",
    "snippet": "  public JSDocInfoBuilder(boolean parseDocumentation) {\n    this.currentInfo = new JSDocInfo(parseDocumentation);\n    this.parseDocumentation = parseDocumentation;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "JSDocInfoBuilder.build",
    "class_name": "com.google.javascript.rhino.JSDocInfoBuilder",
    "signature": "com.google.javascript.rhino.JSDocInfoBuilder.build(String)",
    "snippet": "  public JSDocInfo build(String sourceName) {\n    if (populated) {\n      JSDocInfo built = currentInfo;\n      built.setSourceName(sourceName);\n      populateDefaults(built);\n      populated = false;\n      currentInfo = new JSDocInfo(this.parseDocumentation);\n      return built;\n    } else {\n      return null;\n    }\n  }",
    "comment": " Builds a {@link JSDocInfo} object based on the populated information and returns it. Once this method is called, the builder can be reused to build another {@link JSDocInfo} object.  @param sourceName The source file containing the JSDoc. @return a {@link JSDocInfo} object populated with the values given to this builder. If no value was populated, this method simply returns {@code null} ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "JSDocInfoBuilder.hasAnySingletonSideEffectTags",
    "class_name": "com.google.javascript.rhino.JSDocInfoBuilder",
    "signature": "com.google.javascript.rhino.JSDocInfoBuilder.hasAnySingletonSideEffectTags()",
    "snippet": "  private boolean hasAnySingletonSideEffectTags() {\n    return currentInfo.isNoSideEffects() ||\n        currentInfo.hasModifies();\n  }",
    "comment": " Whether the current doc info has any of the singleton type tags that may not appear with other type tags, like {@code @type} or {@code @typedef}. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "JSDocInfoBuilder.hasAnySingletonTypeTags",
    "class_name": "com.google.javascript.rhino.JSDocInfoBuilder",
    "signature": "com.google.javascript.rhino.JSDocInfoBuilder.hasAnySingletonTypeTags()",
    "snippet": "  private boolean hasAnySingletonTypeTags() {\n    return currentInfo.hasType() ||\n        currentInfo.hasTypedefType() ||\n        currentInfo.hasEnumParameterType();\n  }",
    "comment": " Whether the current doc info has any of the singleton type tags that may not appear with other type tags, like {@code @type} or {@code @typedef}. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "JSDocInfoBuilder.hasAnyTypeRelatedTags",
    "class_name": "com.google.javascript.rhino.JSDocInfoBuilder",
    "signature": "com.google.javascript.rhino.JSDocInfoBuilder.hasAnyTypeRelatedTags()",
    "snippet": "  private boolean hasAnyTypeRelatedTags() {\n    return currentInfo.isConstructor() ||\n        currentInfo.isInterface() ||\n        currentInfo.getParameterCount() > 0 ||\n        currentInfo.hasReturnType() ||\n        currentInfo.hasBaseType() ||\n        currentInfo.getExtendedInterfacesCount() > 0 ||\n        currentInfo.getLendsName() != null ||\n        currentInfo.hasThisType() ||\n        hasAnySingletonTypeTags();\n  }",
    "comment": " Whether the current doc info has other type tags, like {@code @param} or {@code @return} or {@code @type} or etc. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "JSDocInfoBuilder.isPopulated",
    "class_name": "com.google.javascript.rhino.JSDocInfoBuilder",
    "signature": "com.google.javascript.rhino.JSDocInfoBuilder.isPopulated()",
    "snippet": "  public boolean isPopulated() {\n    return populated;\n  }",
    "comment": " Returns whether this builder is populated with information that can be used to {@link #build} a {@link JSDocInfo} object. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "JSDocInfoBuilder.isPopulatedWithFileOverview",
    "class_name": "com.google.javascript.rhino.JSDocInfoBuilder",
    "signature": "com.google.javascript.rhino.JSDocInfoBuilder.isPopulatedWithFileOverview()",
    "snippet": "  public boolean isPopulatedWithFileOverview() {\n    return isPopulated() &&\n        (currentInfo.hasFileOverview() || currentInfo.isExterns() ||\n         currentInfo.isNoCompile());\n  }",
    "comment": " Returns whether this builder is populated with information that can be used to {@link #build} a {@link JSDocInfo} object that has a fileoverview tag. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "JSDocInfoBuilder.markAnnotation",
    "class_name": "com.google.javascript.rhino.JSDocInfoBuilder",
    "signature": "com.google.javascript.rhino.JSDocInfoBuilder.markAnnotation(String,int,int)",
    "snippet": "  public void markAnnotation(String annotation, int lineno, int charno) {\n    JSDocInfo.Marker marker = currentInfo.addMarker();\n\n    if (marker != null) {\n      marker.annotation = new JSDocInfo.StringPosition();\n      marker.annotation.setItem(annotation);\n      marker.annotation.setPositionInformation(lineno, charno, lineno,\n                                               charno + annotation.length());\n    }\n\n    currentMarker = marker;\n  }",
    "comment": " Adds a marker to the current JSDocInfo and populates the marker with the annotation information. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "JSDocInfoBuilder.markName",
    "class_name": "com.google.javascript.rhino.JSDocInfoBuilder",
    "signature": "com.google.javascript.rhino.JSDocInfoBuilder.markName(String,int,int)",
    "snippet": "  public void markName(String name, int lineno, int charno) {\n    if (currentMarker != null) {\n      currentMarker.name = new JSDocInfo.StringPosition();\n      currentMarker.name.setItem(name);\n      currentMarker.name.setPositionInformation(lineno, charno,\n                                                lineno, charno + name.length());\n    }\n  }",
    "comment": " Adds a name declaration to the current marker. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "JSDocInfoBuilder.markTypeNode",
    "class_name": "com.google.javascript.rhino.JSDocInfoBuilder",
    "signature": "com.google.javascript.rhino.JSDocInfoBuilder.markTypeNode(Node,int,int,int,boolean)",
    "snippet": "  public void markTypeNode(Node typeNode, int lineno, int startCharno,\n      int endCharno, boolean hasLC) {\n    if (currentMarker != null) {\n      currentMarker.type = new JSDocInfo.TypePosition();\n      currentMarker.type.setItem(typeNode);\n      currentMarker.type.hasBrackets = hasLC;\n      currentMarker.type.setPositionInformation(lineno, startCharno,\n                                                lineno, endCharno);\n    }\n  }",
    "comment": " Adds a type declaration to the current marker. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "JSDocInfoBuilder.populateDefaults",
    "class_name": "com.google.javascript.rhino.JSDocInfoBuilder",
    "signature": "com.google.javascript.rhino.JSDocInfoBuilder.populateDefaults(JSDocInfo)",
    "snippet": "  private static void populateDefaults(JSDocInfo info) {\n    if (info.getVisibility() == null) {\n      info.setVisibility(Visibility.INHERITED);\n    }\n  }",
    "comment": "Generate defaults when certain parameters are not specified. */",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "JSDocInfoBuilder.recordConstructor",
    "class_name": "com.google.javascript.rhino.JSDocInfoBuilder",
    "signature": "com.google.javascript.rhino.JSDocInfoBuilder.recordConstructor()",
    "snippet": "  public boolean recordConstructor() {\n    if (!hasAnySingletonTypeTags() &&\n        !currentInfo.isConstructor() && !currentInfo.isInterface()) {\n      currentInfo.setConstructor(true);\n      populated = true;\n      return true;\n    } else {\n      return false;\n    }\n  }",
    "comment": " Records that the {@link JSDocInfo} being built should have its {@link JSDocInfo#isConstructor()} flag set to {@code true}.  @return {@code true} if the constructor was recorded and {@code false} if it was already defined or it was incompatible with the existing flags ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "JSDocInfoBuilder.recordNoSideEffects",
    "class_name": "com.google.javascript.rhino.JSDocInfoBuilder",
    "signature": "com.google.javascript.rhino.JSDocInfoBuilder.recordNoSideEffects()",
    "snippet": "  public boolean recordNoSideEffects() {\n    if (!hasAnySingletonSideEffectTags()\n        && !currentInfo.isNoSideEffects()) {\n      currentInfo.setNoSideEffects(true);\n      populated = true;\n      return true;\n    } else {\n      return false;\n    }\n  }",
    "comment": " Records that the {@link JSDocInfo} being built should have its {@link JSDocInfo#isNoSideEffects()} flag set to {@code true}. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "JSDocInfoBuilder.recordOriginalCommentString",
    "class_name": "com.google.javascript.rhino.JSDocInfoBuilder",
    "signature": "com.google.javascript.rhino.JSDocInfoBuilder.recordOriginalCommentString(String)",
    "snippet": "  public void recordOriginalCommentString(String sourceComment) {\n    if (parseDocumentation) {\n      currentInfo.setOriginalCommentString(sourceComment);\n    }\n  }",
    "comment": " Sets the original JSDoc comment string. This is a no-op if the builder isn't configured to record documentation. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "JSDocInfoBuilder.recordParameter",
    "class_name": "com.google.javascript.rhino.JSDocInfoBuilder",
    "signature": "com.google.javascript.rhino.JSDocInfoBuilder.recordParameter(String,JSTypeExpression)",
    "snippet": "  public boolean recordParameter(String parameterName, JSTypeExpression type) {\n    if (!hasAnySingletonTypeTags() &&\n        currentInfo.declareParam(type, parameterName)) {\n      populated = true;\n      return true;\n    } else {\n      return false;\n    }\n  }",
    "comment": " Records a typed parameter.  @return {@code true} if the typed parameter was recorded and {@code false} if a parameter with the same name was already defined ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "JSDocInfoBuilder.recordReturnType",
    "class_name": "com.google.javascript.rhino.JSDocInfoBuilder",
    "signature": "com.google.javascript.rhino.JSDocInfoBuilder.recordReturnType(JSTypeExpression)",
    "snippet": "  public boolean recordReturnType(JSTypeExpression jsType) {\n    if (jsType != null && currentInfo.getReturnType() == null &&\n        !hasAnySingletonTypeTags()) {\n      currentInfo.setReturnType(jsType);\n      populated = true;\n      return true;\n    } else {\n      return false;\n    }\n  }",
    "comment": " Records a return type.  @return {@code true} if the return type was recorded and {@code false} if it is invalid or was already defined ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "JSDocInfoBuilder.recordThisType",
    "class_name": "com.google.javascript.rhino.JSDocInfoBuilder",
    "signature": "com.google.javascript.rhino.JSDocInfoBuilder.recordThisType(JSTypeExpression)",
    "snippet": "  public boolean recordThisType(JSTypeExpression type) {\n    if (type != null && !hasAnySingletonTypeTags() &&\n        !currentInfo.hasThisType()) {\n      currentInfo.setThisType(type);\n      populated = true;\n      return true;\n    } else {\n      return false;\n    }\n  }",
    "comment": " Records a type for {@code @this} annotation.  @return {@code true} if the type was recorded and {@code false} if it is invalid or if it collided with {@code @enum} or {@code @type} annotations ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "JSDocInfoBuilder.recordType",
    "class_name": "com.google.javascript.rhino.JSDocInfoBuilder",
    "signature": "com.google.javascript.rhino.JSDocInfoBuilder.recordType(JSTypeExpression)",
    "snippet": "  public boolean recordType(JSTypeExpression type) {\n    if (type != null && !hasAnyTypeRelatedTags()) {\n      currentInfo.setType(type);\n      populated = true;\n      return true;\n    } else {\n      return false;\n    }\n  }",
    "comment": " Records a type.  @return {@code true} if the type was recorded and {@code false} if it is invalid or was already defined ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "JSDocInfoBuilder.shouldParseDocumentation",
    "class_name": "com.google.javascript.rhino.JSDocInfoBuilder",
    "signature": "com.google.javascript.rhino.JSDocInfoBuilder.shouldParseDocumentation()",
    "snippet": "  public boolean shouldParseDocumentation() {\n    return parseDocumentation;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "JSTypeExpression.JSTypeExpression",
    "class_name": "com.google.javascript.rhino.JSTypeExpression",
    "signature": "com.google.javascript.rhino.JSTypeExpression.JSTypeExpression(Node,String)",
    "snippet": "  public JSTypeExpression(Node root, String sourceName) {\n    this.root = root;\n    this.sourceName = sourceName;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "JSTypeExpression.evaluate",
    "class_name": "com.google.javascript.rhino.JSTypeExpression",
    "signature": "com.google.javascript.rhino.JSTypeExpression.evaluate(StaticScope,JSTypeRegistry)",
    "snippet": "  public JSType evaluate(StaticScope<JSType> scope, JSTypeRegistry registry) {\n    return registry.createFromTypeNodes(root, sourceName, scope);\n  }",
    "comment": " Evaluates the type expression into a {@code JSType} object. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "JSTypeExpression.isOptionalArg",
    "class_name": "com.google.javascript.rhino.JSTypeExpression",
    "signature": "com.google.javascript.rhino.JSTypeExpression.isOptionalArg()",
    "snippet": "  public boolean isOptionalArg() {\n    return root.getType() == Token.EQUALS;\n  }",
    "comment": " @return Whether this expression denotes an optional {@code @param}. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "JSTypeExpression.isVarArgs",
    "class_name": "com.google.javascript.rhino.JSTypeExpression",
    "signature": "com.google.javascript.rhino.JSTypeExpression.isVarArgs()",
    "snippet": "  public boolean isVarArgs() {\n    return root.getType() == Token.ELLIPSIS;\n  }",
    "comment": " @return Whether this expression denotes a rest args {@code @param}. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "Node.Node",
    "class_name": "com.google.javascript.rhino.Node",
    "signature": "com.google.javascript.rhino.Node.Node(int)",
    "snippet": "  public Node(int nodeType) {\n    type = nodeType;\n    parent = null;\n    sourcePosition = -1;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "Node.Node",
    "class_name": "com.google.javascript.rhino.Node",
    "signature": "com.google.javascript.rhino.Node.Node(int,Node)",
    "snippet": "  public Node(int nodeType, Node child) {\n    Preconditions.checkArgument(child.parent == null,\n        \"new child has existing parent\");\n    Preconditions.checkArgument(child.next == null,\n        \"new child has existing sibling\");\n\n    type = nodeType;\n    parent = null;\n    first = last = child;\n    child.next = null;\n    child.parent = this;\n    sourcePosition = -1;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "Node.Node",
    "class_name": "com.google.javascript.rhino.Node",
    "signature": "com.google.javascript.rhino.Node.Node(int,Node,Node)",
    "snippet": "  public Node(int nodeType, Node left, Node right) {\n    Preconditions.checkArgument(left.parent == null,\n        \"first new child has existing parent\");\n    Preconditions.checkArgument(left.next == null,\n        \"first new child has existing sibling\");\n    Preconditions.checkArgument(right.parent == null,\n        \"second new child has existing parent\");\n    Preconditions.checkArgument(right.next == null,\n        \"second new child has existing sibling\");\n    type = nodeType;\n    parent = null;\n    first = left;\n    last = right;\n    left.next = right;\n    left.parent = this;\n    right.next = null;\n    right.parent = this;\n    sourcePosition = -1;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "Node.Node",
    "class_name": "com.google.javascript.rhino.Node",
    "signature": "com.google.javascript.rhino.Node.Node(int,Node,int,int)",
    "snippet": "  public Node(int nodeType, Node child, int lineno, int charno) {\n    this(nodeType, child);\n    sourcePosition = mergeLineCharNo(lineno, charno);\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "Node.Node",
    "class_name": "com.google.javascript.rhino.Node",
    "signature": "com.google.javascript.rhino.Node.Node(int,int,int)",
    "snippet": "  public Node(int nodeType, int lineno, int charno) {\n    type = nodeType;\n    parent = null;\n    sourcePosition = mergeLineCharNo(lineno, charno);\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "Node.addChildToBack",
    "class_name": "com.google.javascript.rhino.Node",
    "signature": "com.google.javascript.rhino.Node.addChildToBack(Node)",
    "snippet": "  public void addChildToBack(Node child) {\n    Preconditions.checkArgument(child.parent == null);\n    Preconditions.checkArgument(child.next == null);\n    child.parent = this;\n    child.next = null;\n    if (last == null) {\n      first = last = child;\n      return;\n    }\n    last.next = child;\n    last = child;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "Node.children",
    "class_name": "com.google.javascript.rhino.Node",
    "signature": "com.google.javascript.rhino.Node.children()",
    "snippet": "  public Iterable<Node> children() {\n    if (first == null) {\n      return Collections.emptySet();\n    } else {\n      return new SiblingNodeIterable(first);\n    }\n  }",
    "comment": " <p>Return an iterable object that iterates over this nodes's children. The iterator does not support the optional operation {@link Iterator#remove()}.</p>  <p>To iterate over a node's siblings, one can write</p> <pre>Node n = ...; for (Node child : n.children()) { ...</pre> ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "Node.clonePropsFrom",
    "class_name": "com.google.javascript.rhino.Node",
    "signature": "com.google.javascript.rhino.Node.clonePropsFrom(Node)",
    "snippet": "  public Node clonePropsFrom(Node other) {\n    Preconditions.checkState(this.propListHead == null,\n        \"Node has existing properties.\");\n    this.propListHead = other.propListHead;\n    return this;\n  }",
    "comment": " Clone the properties from the provided node without copying the property object.  The recieving node may not have any existing properties. @param other The node to clone properties from. @return this node. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "Node.createProp",
    "class_name": "com.google.javascript.rhino.Node",
    "signature": "com.google.javascript.rhino.Node.createProp(int,Object,PropListItem)",
    "snippet": "  PropListItem createProp(int propType, Object value, PropListItem next) {\n    return new ObjectPropListItem(propType, value, next);\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "Node.createProp",
    "class_name": "com.google.javascript.rhino.Node",
    "signature": "com.google.javascript.rhino.Node.createProp(int,int,PropListItem)",
    "snippet": "  PropListItem createProp(int propType, int value, PropListItem next) {\n    return new IntPropListItem(propType, value, next);\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "Node.extractCharno",
    "class_name": "com.google.javascript.rhino.Node",
    "signature": "com.google.javascript.rhino.Node.extractCharno(int)",
    "snippet": "  protected static int extractCharno(int lineCharNo) {\n    if (lineCharNo == -1) {\n      return -1;\n    } else {\n      return lineCharNo & COLUMN_MASK;\n    }\n  }",
    "comment": " Extracts the character number and character number from a merged line char number (see {@link #mergeLineCharNo(int, int)}). ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "Node.extractLineno",
    "class_name": "com.google.javascript.rhino.Node",
    "signature": "com.google.javascript.rhino.Node.extractLineno(int)",
    "snippet": "  protected static int extractLineno(int lineCharNo) {\n    if (lineCharNo == -1) {\n      return -1;\n    } else {\n      return lineCharNo >>> COLUMN_BITS;\n    }\n  }",
    "comment": " Extracts the line number and character number from a merged line char number (see {@link #mergeLineCharNo(int, int)}). ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "Node.getBooleanProp",
    "class_name": "com.google.javascript.rhino.Node",
    "signature": "com.google.javascript.rhino.Node.getBooleanProp(int)",
    "snippet": "  public boolean getBooleanProp(int propType) {\n    return getIntProp(propType) != 0;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "Node.getCharno",
    "class_name": "com.google.javascript.rhino.Node",
    "signature": "com.google.javascript.rhino.Node.getCharno()",
    "snippet": "  public int getCharno() {\n    return extractCharno(sourcePosition);\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "Node.getChildAtIndex",
    "class_name": "com.google.javascript.rhino.Node",
    "signature": "com.google.javascript.rhino.Node.getChildAtIndex(int)",
    "snippet": "  public Node getChildAtIndex(int i) {\n    Node n = first;\n    while (i > 0) {\n      n = n.next;\n      i--;\n    }\n    return n;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "Node.getChildBefore",
    "class_name": "com.google.javascript.rhino.Node",
    "signature": "com.google.javascript.rhino.Node.getChildBefore(Node)",
    "snippet": "  public Node getChildBefore(Node child) {\n    if (child == first) {\n      return null;\n    }\n    Node n = first;\n    while (n.next != child) {\n      n = n.next;\n      if (n == null) {\n        throw new RuntimeException(\"node is not a child\");\n      }\n    }\n    return n;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "Node.getChildCount",
    "class_name": "com.google.javascript.rhino.Node",
    "signature": "com.google.javascript.rhino.Node.getChildCount()",
    "snippet": "  public int getChildCount() {\n    int c = 0;\n    for (Node n = first; n != null; n = n.next)\n      c++;\n\n    return c;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "Node.getFirstChild",
    "class_name": "com.google.javascript.rhino.Node",
    "signature": "com.google.javascript.rhino.Node.getFirstChild()",
    "snippet": "  public Node getFirstChild() {\n    return first;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "Node.getIntProp",
    "class_name": "com.google.javascript.rhino.Node",
    "signature": "com.google.javascript.rhino.Node.getIntProp(int)",
    "snippet": "  public int getIntProp(int propType) {\n    PropListItem item = lookupProperty(propType);\n    if (item == null) {\n      return 0;\n    }\n    return item.getIntValue();\n  }",
    "comment": " Returns the integer value for the property, or 0 if the property is not defined. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "Node.getJSDocInfo",
    "class_name": "com.google.javascript.rhino.Node",
    "signature": "com.google.javascript.rhino.Node.getJSDocInfo()",
    "snippet": "  public JSDocInfo getJSDocInfo() {\n    return (JSDocInfo) getProp(JSDOC_INFO_PROP);\n  }",
    "comment": " Get the {@link JSDocInfo} attached to this node. @return the information or {@code null} if no JSDoc is attached to this node ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "Node.getJSType",
    "class_name": "com.google.javascript.rhino.Node",
    "signature": "com.google.javascript.rhino.Node.getJSType()",
    "snippet": "  public JSType getJSType() {\n      return jsType;\n  }",
    "comment": "Custom annotations",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "Node.getJsDocBuilderForNode",
    "class_name": "com.google.javascript.rhino.Node",
    "signature": "com.google.javascript.rhino.Node.getJsDocBuilderForNode()",
    "snippet": "  public FileLevelJsDocBuilder getJsDocBuilderForNode() {\n    return new FileLevelJsDocBuilder();\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "Node.getLastChild",
    "class_name": "com.google.javascript.rhino.Node",
    "signature": "com.google.javascript.rhino.Node.getLastChild()",
    "snippet": "  public Node getLastChild() {\n    return last;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "Node.getLineno",
    "class_name": "com.google.javascript.rhino.Node",
    "signature": "com.google.javascript.rhino.Node.getLineno()",
    "snippet": "  public int getLineno() {\n    return extractLineno(sourcePosition);\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "Node.getNext",
    "class_name": "com.google.javascript.rhino.Node",
    "signature": "com.google.javascript.rhino.Node.getNext()",
    "snippet": "  public Node getNext() {\n    return next;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "Node.getParent",
    "class_name": "com.google.javascript.rhino.Node",
    "signature": "com.google.javascript.rhino.Node.getParent()",
    "snippet": "  public Node getParent() {\n    return parent;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "Node.getProp",
    "class_name": "com.google.javascript.rhino.Node",
    "signature": "com.google.javascript.rhino.Node.getProp(int)",
    "snippet": "  public Object getProp(int propType) {\n    if (propType == SOURCENAME_PROP) {\n      return getSourceFileName();\n    }\n\n    PropListItem item = lookupProperty(propType);\n    if (item == null) {\n      return null;\n    }\n    return item.getObjectValue();\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "Node.getQualifiedName",
    "class_name": "com.google.javascript.rhino.Node",
    "signature": "com.google.javascript.rhino.Node.getQualifiedName()",
    "snippet": "  public String getQualifiedName() {\n    if (type == Token.NAME) {\n      return getString();\n    } else if (type == Token.GETPROP) {\n      String left = getFirstChild().getQualifiedName();\n      if (left == null) {\n        return null;\n      }\n      return left + \".\" + getLastChild().getString();\n    } else if (type == Token.THIS) {\n      return \"this\";\n    } else {\n      return null;\n    }\n  }",
    "comment": " This function takes a set of GETPROP nodes and produces a string that is each property separated by dots. If the node ultimately under the left sub-tree is not a simple name, this is not a valid qualified name.  @return a null if this is not a qualified name, or a dot-separated string of the name and properties. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "Node.getSourceFileName",
    "class_name": "com.google.javascript.rhino.Node",
    "signature": "com.google.javascript.rhino.Node.getSourceFileName()",
    "snippet": "  public String getSourceFileName() {\n    StaticSourceFile file = getStaticSourceFile();\n    return file == null ? null : file.getName();\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "Node.getStaticSourceFile",
    "class_name": "com.google.javascript.rhino.Node",
    "signature": "com.google.javascript.rhino.Node.getStaticSourceFile()",
    "snippet": "  public StaticSourceFile getStaticSourceFile() {\n    return ((StaticSourceFile) this.getProp(STATIC_SOURCE_FILE));\n  }",
    "comment": "Returns the source file associated with this input. May be null */",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "Node.getType",
    "class_name": "com.google.javascript.rhino.Node",
    "signature": "com.google.javascript.rhino.Node.getType()",
    "snippet": "  public int getType() {\n    return type;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "Node.hasChild",
    "class_name": "com.google.javascript.rhino.Node",
    "signature": "com.google.javascript.rhino.Node.hasChild(Node)",
    "snippet": "  public boolean hasChild(Node child) {\n    for (Node n = first; n != null; n = n.getNext()) {\n      if (child == n) {\n        return true;\n      }\n    }\n    return false;\n  }",
    "comment": "Intended for testing and verification only.",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "Node.hasChildren",
    "class_name": "com.google.javascript.rhino.Node",
    "signature": "com.google.javascript.rhino.Node.hasChildren()",
    "snippet": "  public boolean hasChildren() {\n    return first != null;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "Node.hasMoreThanOneChild",
    "class_name": "com.google.javascript.rhino.Node",
    "signature": "com.google.javascript.rhino.Node.hasMoreThanOneChild()",
    "snippet": "  public boolean hasMoreThanOneChild() {\n    return first != null && first != last;\n  }",
    "comment": " Check for more than one child more efficiently than by iterating over all the children as is done with Node.getChildCount().  @return Whether the node more than one child. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "Node.hasOneChild",
    "class_name": "com.google.javascript.rhino.Node",
    "signature": "com.google.javascript.rhino.Node.hasOneChild()",
    "snippet": "  public boolean hasOneChild() {\n    return first != null && first == last;\n  }",
    "comment": " Check for one child more efficiently than by iterating over all the children as is done with Node.getChildCount().  @return Whether the node has exactly one child. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "Node.isQualifiedName",
    "class_name": "com.google.javascript.rhino.Node",
    "signature": "com.google.javascript.rhino.Node.isQualifiedName()",
    "snippet": "  public boolean isQualifiedName() {\n    switch (getType()) {\n      case Token.NAME:\n      case Token.THIS:\n        return true;\n      case Token.GETPROP:\n        return getFirstChild().isQualifiedName();\n      default:\n        return false;\n    }\n  }",
    "comment": " Returns whether a node corresponds to a simple or a qualified name, such as <code>x</code> or <code>a.b.c</code> or <code>this.a</code>. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "Node.isSyntheticBlock",
    "class_name": "com.google.javascript.rhino.Node",
    "signature": "com.google.javascript.rhino.Node.isSyntheticBlock()",
    "snippet": "  public boolean isSyntheticBlock() {\n    return getBooleanProp(SYNTHETIC_BLOCK_PROP);\n  }",
    "comment": " Returns whether this is a synthetic block that should not be considered a real source block. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "Node.isVarArgs",
    "class_name": "com.google.javascript.rhino.Node",
    "signature": "com.google.javascript.rhino.Node.isVarArgs()",
    "snippet": "  public boolean isVarArgs() {\n    return getBooleanProp(VAR_ARGS_NAME);\n  }",
    "comment": " Returns whether this node is a variable length argument node. This method's return value is meaningful only on {@link Token#NAME} nodes used to define a {@link Token#FUNCTION}'s argument list. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "Node.lookupProperty",
    "class_name": "com.google.javascript.rhino.Node",
    "signature": "com.google.javascript.rhino.Node.lookupProperty(int)",
    "snippet": "  @VisibleForTesting\n  PropListItem lookupProperty(int propType) {\n    PropListItem x = propListHead;\n    while (x != null && propType != x.getType()) {\n      x = x.getNext();\n    }\n    return x;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "Node.mergeLineCharNo",
    "class_name": "com.google.javascript.rhino.Node",
    "signature": "com.google.javascript.rhino.Node.mergeLineCharNo(int,int)",
    "snippet": "  protected static int mergeLineCharNo(int lineno, int charno) {\n    if (lineno < 0 || charno < 0) {\n      return -1;\n    } else if ((charno & ~COLUMN_MASK) != 0) {\n      return lineno << COLUMN_BITS | COLUMN_MASK;\n    } else {\n      return lineno << COLUMN_BITS | (charno & COLUMN_MASK);\n    }\n  }",
    "comment": " Merges the line number and character number in one integer. The Character number takes the first 12 bits and the line number takes the rest. If the character number is greater than <code>2<sup>12</sup>-1</code> it is adjusted to <code>2<sup>12</sup>-1</code>. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "Node.newNumber",
    "class_name": "com.google.javascript.rhino.Node",
    "signature": "com.google.javascript.rhino.Node.newNumber(double)",
    "snippet": "  public static Node newNumber(double number) {\n    return new NumberNode(number);\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "Node.newString",
    "class_name": "com.google.javascript.rhino.Node",
    "signature": "com.google.javascript.rhino.Node.newString(String,int,int)",
    "snippet": "  public static Node newString(String str, int lineno, int charno) {\n    return new StringNode(Token.STRING, str, lineno, charno);\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "Node.newString",
    "class_name": "com.google.javascript.rhino.Node",
    "signature": "com.google.javascript.rhino.Node.newString(int,String)",
    "snippet": "  public static Node newString(int type, String str) {\n    return new StringNode(type, str);\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "Node.putBooleanProp",
    "class_name": "com.google.javascript.rhino.Node",
    "signature": "com.google.javascript.rhino.Node.putBooleanProp(int,boolean)",
    "snippet": "  public void putBooleanProp(int propType, boolean value) {\n    putIntProp(propType, value ? 1 : 0);\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "Node.putIntProp",
    "class_name": "com.google.javascript.rhino.Node",
    "signature": "com.google.javascript.rhino.Node.putIntProp(int,int)",
    "snippet": "  public void putIntProp(int propType, int value) {\n    removeProp(propType);\n    if (value != 0) {\n      propListHead = createProp(propType, value, propListHead);\n    }\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "Node.putProp",
    "class_name": "com.google.javascript.rhino.Node",
    "signature": "com.google.javascript.rhino.Node.putProp(int,Object)",
    "snippet": "  public void putProp(int propType, Object value) {\n    if (propType == SOURCENAME_PROP) {\n      putProp(\n          STATIC_SOURCE_FILE, new SimpleSourceFile((String) value, false));\n      return;\n    }\n\n    removeProp(propType);\n    if (value != null) {\n      propListHead = createProp(propType, value, propListHead);\n    }\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "Node.removeProp",
    "class_name": "com.google.javascript.rhino.Node",
    "signature": "com.google.javascript.rhino.Node.removeProp(PropListItem,int)",
    "snippet": "  private PropListItem removeProp(PropListItem item, int propType) {\n    if (item == null) {\n      return null;\n    } else if (item.getType() == propType) {\n      return item.getNext();\n    } else {\n      PropListItem result = removeProp(item.getNext(), propType);\n      if (result != item.getNext()) {\n        return item.chain(result);\n      } else {\n        return item;\n      }\n    }\n  }",
    "comment": " @param item The item to inspect @param propType The property to look for @return The replacement list if the property was removed, or 'item' otherwise. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "Node.removeProp",
    "class_name": "com.google.javascript.rhino.Node",
    "signature": "com.google.javascript.rhino.Node.removeProp(int)",
    "snippet": "  public void removeProp(int propType) {\n    PropListItem result = removeProp(propListHead, propType);\n    if (result != propListHead) {\n      propListHead = result;\n    }\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "Node.setCharno",
    "class_name": "com.google.javascript.rhino.Node",
    "signature": "com.google.javascript.rhino.Node.setCharno(int)",
    "snippet": "  public void setCharno(int charno) {\n      sourcePosition = mergeLineCharNo(getLineno(), charno);\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "Node.setIsSyntheticBlock",
    "class_name": "com.google.javascript.rhino.Node",
    "signature": "com.google.javascript.rhino.Node.setIsSyntheticBlock(boolean)",
    "snippet": "  public void setIsSyntheticBlock(boolean val) {\n    putBooleanProp(SYNTHETIC_BLOCK_PROP, val);\n  }",
    "comment": " Sets whether this is a synthetic block that should not be considered a real source block. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "Node.setJSDocInfo",
    "class_name": "com.google.javascript.rhino.Node",
    "signature": "com.google.javascript.rhino.Node.setJSDocInfo(JSDocInfo)",
    "snippet": "  public void setJSDocInfo(JSDocInfo info) {\n      putProp(JSDOC_INFO_PROP, info);\n  }",
    "comment": " Sets the {@link JSDocInfo} attached to this node. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "Node.setJSType",
    "class_name": "com.google.javascript.rhino.Node",
    "signature": "com.google.javascript.rhino.Node.setJSType(JSType)",
    "snippet": "  public void setJSType(JSType jsType) {\n      this.jsType = jsType;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "Node.setLineno",
    "class_name": "com.google.javascript.rhino.Node",
    "signature": "com.google.javascript.rhino.Node.setLineno(int)",
    "snippet": "  public void setLineno(int lineno) {\n      int charno = getCharno();\n      if (charno == -1) {\n        charno = 0;\n      }\n      sourcePosition = mergeLineCharNo(lineno, charno);\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "Node.setOptionalArg",
    "class_name": "com.google.javascript.rhino.Node",
    "signature": "com.google.javascript.rhino.Node.setOptionalArg(boolean)",
    "snippet": "  public void setOptionalArg(boolean optionalArg) {\n    putBooleanProp(OPT_ARG_NAME, optionalArg);\n  }",
    "comment": " Sets whether this node is an optional argument node. This method is meaningful only on {@link Token#NAME} nodes used to define a {@link Token#FUNCTION}'s argument list. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "Node.setStaticSourceFile",
    "class_name": "com.google.javascript.rhino.Node",
    "signature": "com.google.javascript.rhino.Node.setStaticSourceFile(StaticSourceFile)",
    "snippet": "  public void setStaticSourceFile(StaticSourceFile file) {\n    this.putProp(STATIC_SOURCE_FILE, file);\n  }",
    "comment": "Source position management",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "Node.setVarArgs",
    "class_name": "com.google.javascript.rhino.Node",
    "signature": "com.google.javascript.rhino.Node.setVarArgs(boolean)",
    "snippet": "  public void setVarArgs(boolean varArgs) {\n    putBooleanProp(VAR_ARGS_NAME, varArgs);\n  }",
    "comment": " Sets whether this node is a variable length argument node. This method is meaningful only on {@link Token#NAME} nodes used to define a {@link Token#FUNCTION}'s argument list. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "Node.tokenToName",
    "class_name": "com.google.javascript.rhino.Node",
    "signature": "com.google.javascript.rhino.Node.tokenToName(int)",
    "snippet": "  public static String tokenToName(int token) {\n    switch (token) {\n      case Token.ERROR:           return \"error\";\n      case Token.EOF:             return \"eof\";\n      case Token.EOL:             return \"eol\";\n      case Token.ENTERWITH:       return \"enterwith\";\n      case Token.LEAVEWITH:       return \"leavewith\";\n      case Token.RETURN:          return \"return\";\n      case Token.GOTO:            return \"goto\";\n      case Token.IFEQ:            return \"ifeq\";\n      case Token.IFNE:            return \"ifne\";\n      case Token.SETNAME:         return \"setname\";\n      case Token.BITOR:           return \"bitor\";\n      case Token.BITXOR:          return \"bitxor\";\n      case Token.BITAND:          return \"bitand\";\n      case Token.EQ:              return \"eq\";\n      case Token.NE:              return \"ne\";\n      case Token.LT:              return \"lt\";\n      case Token.LE:              return \"le\";\n      case Token.GT:              return \"gt\";\n      case Token.GE:              return \"ge\";\n      case Token.LSH:             return \"lsh\";\n      case Token.RSH:             return \"rsh\";\n      case Token.URSH:            return \"ursh\";\n      case Token.ADD:             return \"add\";\n      case Token.SUB:             return \"sub\";\n      case Token.MUL:             return \"mul\";\n      case Token.DIV:             return \"div\";\n      case Token.MOD:             return \"mod\";\n      case Token.BITNOT:          return \"bitnot\";\n      case Token.NEG:             return \"neg\";\n      case Token.NEW:             return \"new\";\n      case Token.DELPROP:         return \"delprop\";\n      case Token.TYPEOF:          return \"typeof\";\n      case Token.GETPROP:         return \"getprop\";\n      case Token.SETPROP:         return \"setprop\";\n      case Token.GETELEM:         return \"getelem\";\n      case Token.SETELEM:         return \"setelem\";\n      case Token.CALL:            return \"call\";\n      case Token.NAME:            return \"name\";\n      case Token.NUMBER:          return \"number\";\n      case Token.STRING:          return \"string\";\n      case Token.NULL:            return \"null\";\n      case Token.THIS:            return \"this\";\n      case Token.FALSE:           return \"false\";\n      case Token.TRUE:            return \"true\";\n      case Token.SHEQ:            return \"sheq\";\n      case Token.SHNE:            return \"shne\";\n      case Token.REGEXP:          return \"regexp\";\n      case Token.POS:             return \"pos\";\n      case Token.BINDNAME:        return \"bindname\";\n      case Token.THROW:           return \"throw\";\n      case Token.IN:              return \"in\";\n      case Token.INSTANCEOF:      return \"instanceof\";\n      case Token.GETVAR:          return \"getvar\";\n      case Token.SETVAR:          return \"setvar\";\n      case Token.TRY:             return \"try\";\n      case Token.TYPEOFNAME:      return \"typeofname\";\n      case Token.THISFN:          return \"thisfn\";\n      case Token.SEMI:            return \"semi\";\n      case Token.LB:              return \"lb\";\n      case Token.RB:              return \"rb\";\n      case Token.LC:              return \"lc\";\n      case Token.RC:              return \"rc\";\n      case Token.LP:              return \"lp\";\n      case Token.RP:              return \"rp\";\n      case Token.COMMA:           return \"comma\";\n      case Token.ASSIGN:          return \"assign\";\n      case Token.ASSIGN_BITOR:    return \"assign_bitor\";\n      case Token.ASSIGN_BITXOR:   return \"assign_bitxor\";\n      case Token.ASSIGN_BITAND:   return \"assign_bitand\";\n      case Token.ASSIGN_LSH:      return \"assign_lsh\";\n      case Token.ASSIGN_RSH:      return \"assign_rsh\";\n      case Token.ASSIGN_URSH:     return \"assign_ursh\";\n      case Token.ASSIGN_ADD:      return \"assign_add\";\n      case Token.ASSIGN_SUB:      return \"assign_sub\";\n      case Token.ASSIGN_MUL:      return \"assign_mul\";\n      case Token.ASSIGN_DIV:      return \"assign_div\";\n      case Token.ASSIGN_MOD:      return \"assign_mod\";\n      case Token.HOOK:            return \"hook\";\n      case Token.COLON:           return \"colon\";\n      case Token.OR:              return \"or\";\n      case Token.AND:             return \"and\";\n      case Token.INC:             return \"inc\";\n      case Token.DEC:             return \"dec\";\n      case Token.DOT:             return \"dot\";\n      case Token.FUNCTION:        return \"function\";\n      case Token.EXPORT:          return \"export\";\n      case Token.IMPORT:          return \"import\";\n      case Token.IF:              return \"if\";\n      case Token.ELSE:            return \"else\";\n      case Token.SWITCH:          return \"switch\";\n      case Token.CASE:            return \"case\";\n      case Token.DEFAULT:         return \"default\";\n      case Token.WHILE:           return \"while\";\n      case Token.DO:              return \"do\";\n      case Token.FOR:             return \"for\";\n      case Token.BREAK:           return \"break\";\n      case Token.CONTINUE:        return \"continue\";\n      case Token.VAR:             return \"var\";\n      case Token.WITH:            return \"with\";\n      case Token.CATCH:           return \"catch\";\n      case Token.FINALLY:         return \"finally\";\n      case Token.RESERVED:        return \"reserved\";\n      case Token.NOT:             return \"not\";\n      case Token.VOID:            return \"void\";\n      case Token.BLOCK:           return \"block\";\n      case Token.ARRAYLIT:        return \"arraylit\";\n      case Token.OBJECTLIT:       return \"objectlit\";\n      case Token.LABEL:           return \"label\";\n      case Token.TARGET:          return \"target\";\n      case Token.LOOP:            return \"loop\";\n      case Token.EXPR_VOID:       return \"expr_void\";\n      case Token.EXPR_RESULT:     return \"expr_result\";\n      case Token.JSR:             return \"jsr\";\n      case Token.SCRIPT:          return \"script\";\n      case Token.EMPTY:           return \"empty\";\n      case Token.GET_REF:         return \"get_ref\";\n      case Token.REF_SPECIAL:     return \"ref_special\";\n    }\n    return \"<unknown=\"+token+\">\";\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "AbstractPropListItem.getNext",
    "class_name": "com.google.javascript.rhino.Node$AbstractPropListItem",
    "signature": "com.google.javascript.rhino.Node$AbstractPropListItem.getNext()",
    "snippet": "    public PropListItem getNext() {\n      return next;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "AbstractPropListItem.getType",
    "class_name": "com.google.javascript.rhino.Node$AbstractPropListItem",
    "signature": "com.google.javascript.rhino.Node$AbstractPropListItem.getType()",
    "snippet": "    public int getType() {\n      return propType;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "IntPropListItem.chain",
    "class_name": "com.google.javascript.rhino.Node$IntPropListItem",
    "signature": "com.google.javascript.rhino.Node$IntPropListItem.chain(PropListItem)",
    "snippet": "    @Override\n    public PropListItem chain(PropListItem next) {\n      return new IntPropListItem(getType(), intValue, next);\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "IntPropListItem.getIntValue",
    "class_name": "com.google.javascript.rhino.Node$IntPropListItem",
    "signature": "com.google.javascript.rhino.Node$IntPropListItem.getIntValue()",
    "snippet": "    @Override\n    public int getIntValue() {\n      return intValue;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "NumberNode.getDouble",
    "class_name": "com.google.javascript.rhino.Node$NumberNode",
    "signature": "com.google.javascript.rhino.Node$NumberNode.getDouble()",
    "snippet": "    @Override\n    public double getDouble() {\n      return this.number;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "ObjectPropListItem.getObjectValue",
    "class_name": "com.google.javascript.rhino.Node$ObjectPropListItem",
    "signature": "com.google.javascript.rhino.Node$ObjectPropListItem.getObjectValue()",
    "snippet": "    @Override\n    public Object getObjectValue() {\n      return objectValue;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "SiblingNodeIterable.hasNext",
    "class_name": "com.google.javascript.rhino.Node$SiblingNodeIterable",
    "signature": "com.google.javascript.rhino.Node$SiblingNodeIterable.hasNext()",
    "snippet": "    public boolean hasNext() {\n      return current != null;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "SiblingNodeIterable.iterator",
    "class_name": "com.google.javascript.rhino.Node$SiblingNodeIterable",
    "signature": "com.google.javascript.rhino.Node$SiblingNodeIterable.iterator()",
    "snippet": "    public Iterator<Node> iterator() {\n      if (!used) {\n        used = true;\n        return this;\n      } else {\n        // We have already used the current object as an iterator;\n        // we must create a new SiblingNodeIterable based on this\n        // iterable's start node.\n        //\n        // Since the primary use case for Node.children is in for\n        // loops, this branch is extremely unlikely.\n        return (new SiblingNodeIterable(start)).iterator();\n      }\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "SiblingNodeIterable.next",
    "class_name": "com.google.javascript.rhino.Node$SiblingNodeIterable",
    "signature": "com.google.javascript.rhino.Node$SiblingNodeIterable.next()",
    "snippet": "    public Node next() {\n      if (current == null) {\n        throw new NoSuchElementException();\n      }\n      try {\n        return current;\n      } finally {\n        current = current.getNext();\n      }\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "StringNode.getString",
    "class_name": "com.google.javascript.rhino.Node$StringNode",
    "signature": "com.google.javascript.rhino.Node$StringNode.getString()",
    "snippet": "    @Override\n    public String getString() {\n      return this.str;\n    }",
    "comment": " returns the string content. @return non null. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "StringNode.setString",
    "class_name": "com.google.javascript.rhino.Node$StringNode",
    "signature": "com.google.javascript.rhino.Node$StringNode.setString(String)",
    "snippet": "    @Override\n    public void setString(String str) {\n      if (null == str) {\n        throw new IllegalArgumentException(\"StringNode: str is null\");\n      }\n      this.str = str;\n    }",
    "comment": " sets the string content. @param str the new value.  Non null. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "ScriptRuntime.getMessage",
    "class_name": "com.google.javascript.rhino.ScriptRuntime",
    "signature": "com.google.javascript.rhino.ScriptRuntime.getMessage(String,Object[])",
    "snippet": "    public static String getMessage(String messageId, Object[] arguments)\n    {\n        final String defaultResource\n            = \"rhino_ast.java.com.google.javascript.rhino.Messages\";\n\n        Context cx = Context.getCurrentContext();\n        Locale locale = cx != null ? cx.getLocale() : Locale.getDefault();\n\n        // ResourceBundle does cacheing.\n        ResourceBundle rb = ResourceBundle.getBundle(defaultResource, locale);\n\n        String formatString;\n        try {\n            formatString = rb.getString(messageId);\n        } catch (java.util.MissingResourceException mre) {\n            throw new RuntimeException\n                (\"no message resource found for message property \"+ messageId);\n        }\n\n        /*\n         * It's OK to format the string, even if 'arguments' is null;\n         * we need to format it anyway, to make double ''s collapse to\n         * single 's.\n         */\n        // TODO: MessageFormat is not available on pJava\n        MessageFormat formatter = new MessageFormat(formatString);\n        return formatter.format(arguments);\n    }",
    "comment": "OPT there's a noticable delay for the first error!  Maybe it'd make sense to use a ListResourceBundle instead of a properties file to avoid (synchronized) text parsing. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "ScriptRuntime.getMessage0",
    "class_name": "com.google.javascript.rhino.ScriptRuntime",
    "signature": "com.google.javascript.rhino.ScriptRuntime.getMessage0(String)",
    "snippet": "    public static String getMessage0(String messageId)\n    {\n        return getMessage(messageId, null);\n    }",
    "comment": "------------------",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "AllType.AllType",
    "class_name": "com.google.javascript.rhino.jstype.AllType",
    "signature": "com.google.javascript.rhino.jstype.AllType.AllType(JSTypeRegistry)",
    "snippet": "  AllType(JSTypeRegistry registry) {\n    super(registry);\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "AllType.isAllType",
    "class_name": "com.google.javascript.rhino.jstype.AllType",
    "signature": "com.google.javascript.rhino.jstype.AllType.isAllType()",
    "snippet": "  @Override\n  public boolean isAllType() {\n    return true;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "AllType.resolveInternal",
    "class_name": "com.google.javascript.rhino.jstype.AllType",
    "signature": "com.google.javascript.rhino.jstype.AllType.resolveInternal(ErrorReporter,StaticScope)",
    "snippet": "  @Override\n  JSType resolveInternal(ErrorReporter t, StaticScope<JSType> scope) {\n    return this;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "AllType.toString",
    "class_name": "com.google.javascript.rhino.jstype.AllType",
    "signature": "com.google.javascript.rhino.jstype.AllType.toString()",
    "snippet": "  @Override\n  public String toString() {\n    return \"*\";\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "ArrowType.ArrowType",
    "class_name": "com.google.javascript.rhino.jstype.ArrowType",
    "signature": "com.google.javascript.rhino.jstype.ArrowType.ArrowType(JSTypeRegistry,Node,JSType)",
    "snippet": "  ArrowType(JSTypeRegistry registry, Node parameters,\n      JSType returnType) {\n    this(registry, parameters, returnType, false);\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "ArrowType.ArrowType",
    "class_name": "com.google.javascript.rhino.jstype.ArrowType",
    "signature": "com.google.javascript.rhino.jstype.ArrowType.ArrowType(JSTypeRegistry,Node,JSType,boolean)",
    "snippet": "  ArrowType(JSTypeRegistry registry, Node parameters,\n      JSType returnType, boolean returnTypeInferred) {\n    super(registry);\n\n    this.parameters = parameters == null ?\n        registry.createParametersWithVarArgs(getNativeType(UNKNOWN_TYPE)) :\n        parameters;\n    this.returnType = returnType == null ?\n        getNativeType(UNKNOWN_TYPE) : returnType;\n    this.returnTypeInferred = returnTypeInferred;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "ArrowType.hasEqualParameters",
    "class_name": "com.google.javascript.rhino.jstype.ArrowType",
    "signature": "com.google.javascript.rhino.jstype.ArrowType.hasEqualParameters(ArrowType)",
    "snippet": "  boolean hasEqualParameters(ArrowType that) {\n    Node thisParam = parameters.getFirstChild();\n    Node otherParam = that.parameters.getFirstChild();\n    while (thisParam != null && otherParam != null) {\n      JSType thisParamType = thisParam.getJSType();\n      JSType otherParamType = otherParam.getJSType();\n      if (thisParamType != null) {\n        // Both parameter lists give a type for this param, it should be equal\n        if (otherParamType != null &&\n            !thisParamType.isEquivalentTo(otherParamType)) {\n          return false;\n        }\n      } else {\n        if (otherParamType != null) {\n          return false;\n        }\n      }\n      thisParam = thisParam.getNext();\n      otherParam = otherParam.getNext();\n    }\n    // One of the parameters is null, so the types are only equal if both\n    // parameter lists are null (they are equal).\n    return thisParam == otherParam;\n  }",
    "comment": " @return True if our parameter spec is equal to {@code that}'s parameter spec. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "ArrowType.isEquivalentTo",
    "class_name": "com.google.javascript.rhino.jstype.ArrowType",
    "signature": "com.google.javascript.rhino.jstype.ArrowType.isEquivalentTo(JSType)",
    "snippet": "  @Override\n  public boolean isEquivalentTo(JSType object) {\n    // Please keep this method in sync with the hashCode() method below.\n    if (!(object instanceof ArrowType)) {\n      return false;\n    }\n    ArrowType that = (ArrowType) object;\n    if (!returnType.isEquivalentTo(that.returnType)) {\n      return false;\n    }\n    return hasEqualParameters(that);\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "ArrowType.resolveInternal",
    "class_name": "com.google.javascript.rhino.jstype.ArrowType",
    "signature": "com.google.javascript.rhino.jstype.ArrowType.resolveInternal(ErrorReporter,StaticScope)",
    "snippet": "  @Override\n  JSType resolveInternal(ErrorReporter t, StaticScope<JSType> scope) {\n    returnType = safeResolve(returnType, t, scope);\n    if (parameters != null) {\n      for (Node paramNode = parameters.getFirstChild();\n           paramNode != null; paramNode = paramNode.getNext()) {\n        paramNode.setJSType(paramNode.getJSType().resolve(t, scope));\n      }\n    }\n    return this;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "BooleanType.BooleanType",
    "class_name": "com.google.javascript.rhino.jstype.BooleanType",
    "signature": "com.google.javascript.rhino.jstype.BooleanType.BooleanType(JSTypeRegistry)",
    "snippet": "  BooleanType(JSTypeRegistry registry) {\n    super(registry);\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "BooleanType.getDisplayName",
    "class_name": "com.google.javascript.rhino.jstype.BooleanType",
    "signature": "com.google.javascript.rhino.jstype.BooleanType.getDisplayName()",
    "snippet": "  @Override\n  public String getDisplayName() {\n    return \"boolean\";\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "BooleanType.toString",
    "class_name": "com.google.javascript.rhino.jstype.BooleanType",
    "signature": "com.google.javascript.rhino.jstype.BooleanType.toString()",
    "snippet": "  @Override\n  public String toString() {\n    return getDisplayName();\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "ErrorFunctionType.ErrorFunctionType",
    "class_name": "com.google.javascript.rhino.jstype.ErrorFunctionType",
    "signature": "com.google.javascript.rhino.jstype.ErrorFunctionType.ErrorFunctionType(JSTypeRegistry,String)",
    "snippet": "  ErrorFunctionType(JSTypeRegistry registry, String name) {\n    super(\n        registry, name, null,\n        registry.createArrowType(\n            registry.createOptionalParameters(\n                registry.getNativeType(ALL_TYPE),\n                registry.getNativeType(ALL_TYPE),\n                registry.getNativeType(ALL_TYPE)),\n            null),\n        null, null, true, true);\n\n    // NOTE(nicksantos): Errors have the weird behavior in that they can\n    // be called as functions, and they will return instances of themselves.\n    // Error('x') instanceof Error => true\n    //\n    // In user-defined types, we would deal with this case by creating\n    // a NamedType with the name \"Error\" and then resolve it later.\n    //\n    // For native types, we don't really want the native types to\n    // depend on type-resolution. So we just set the return type manually\n    // at the end of construction.\n    //\n    // There's similar logic in JSTypeRegistry for Array and RegExp.\n    getInternalArrowType().returnType = getInstanceType();\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "FunctionBuilder.FunctionBuilder",
    "class_name": "com.google.javascript.rhino.jstype.FunctionBuilder",
    "signature": "com.google.javascript.rhino.jstype.FunctionBuilder.FunctionBuilder(JSTypeRegistry)",
    "snippet": "  public FunctionBuilder(JSTypeRegistry registry) {\n    this.registry = registry;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "FunctionBuilder.build",
    "class_name": "com.google.javascript.rhino.jstype.FunctionBuilder",
    "signature": "com.google.javascript.rhino.jstype.FunctionBuilder.build()",
    "snippet": "  public FunctionType build() {\n    return new FunctionType(registry, name, sourceNode,\n        new ArrowType(registry, parametersNode, returnType, inferredReturnType),\n        typeOfThis, templateTypeName, isConstructor, isNativeType);\n  }",
    "comment": "Construct a new function type. */",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "FunctionBuilder.withName",
    "class_name": "com.google.javascript.rhino.jstype.FunctionBuilder",
    "signature": "com.google.javascript.rhino.jstype.FunctionBuilder.withName(String)",
    "snippet": "  public FunctionBuilder withName(String name) {\n    this.name = name;\n    return this;\n  }",
    "comment": "Set the name of the function type. */",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "FunctionBuilder.withParamsNode",
    "class_name": "com.google.javascript.rhino.jstype.FunctionBuilder",
    "signature": "com.google.javascript.rhino.jstype.FunctionBuilder.withParamsNode(Node)",
    "snippet": "  public FunctionBuilder withParamsNode(Node parametersNode) {\n    this.parametersNode = parametersNode;\n    return this;\n  }",
    "comment": " Set the parameters of the function type with a specially-formatted node. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "FunctionBuilder.withReturnType",
    "class_name": "com.google.javascript.rhino.jstype.FunctionBuilder",
    "signature": "com.google.javascript.rhino.jstype.FunctionBuilder.withReturnType(JSType)",
    "snippet": "  public FunctionBuilder withReturnType(JSType returnType) {\n    this.returnType = returnType;\n    return this;\n  }",
    "comment": "Set the return type. */",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "FunctionBuilder.withReturnType",
    "class_name": "com.google.javascript.rhino.jstype.FunctionBuilder",
    "signature": "com.google.javascript.rhino.jstype.FunctionBuilder.withReturnType(JSType,boolean)",
    "snippet": "  public FunctionBuilder withReturnType(JSType returnType, boolean inferred) {\n    this.returnType = returnType;\n    this.inferredReturnType = inferred;\n    return this;\n  }",
    "comment": "Set the return type and whether it's inferred. */",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "FunctionBuilder.withSourceNode",
    "class_name": "com.google.javascript.rhino.jstype.FunctionBuilder",
    "signature": "com.google.javascript.rhino.jstype.FunctionBuilder.withSourceNode(Node)",
    "snippet": "  public FunctionBuilder withSourceNode(Node sourceNode) {\n    this.sourceNode = sourceNode;\n    return this;\n  }",
    "comment": "Set the source node of the function type. */",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "FunctionBuilder.withTemplateName",
    "class_name": "com.google.javascript.rhino.jstype.FunctionBuilder",
    "signature": "com.google.javascript.rhino.jstype.FunctionBuilder.withTemplateName(String)",
    "snippet": "  public FunctionBuilder withTemplateName(String templateTypeName) {\n    this.templateTypeName = templateTypeName;\n    return this;\n  }",
    "comment": "Set the template name. */",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "FunctionBuilder.withTypeOfThis",
    "class_name": "com.google.javascript.rhino.jstype.FunctionBuilder",
    "signature": "com.google.javascript.rhino.jstype.FunctionBuilder.withTypeOfThis(ObjectType)",
    "snippet": "  public FunctionBuilder withTypeOfThis(ObjectType typeOfThis) {\n    this.typeOfThis = typeOfThis;\n    return this;\n  }",
    "comment": "Set the \"this\" type. */",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "FunctionParamBuilder.FunctionParamBuilder",
    "class_name": "com.google.javascript.rhino.jstype.FunctionParamBuilder",
    "signature": "com.google.javascript.rhino.jstype.FunctionParamBuilder.FunctionParamBuilder(JSTypeRegistry)",
    "snippet": "  public FunctionParamBuilder(JSTypeRegistry registry) {\n    this.registry = registry;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "FunctionParamBuilder.addOptionalParams",
    "class_name": "com.google.javascript.rhino.jstype.FunctionParamBuilder",
    "signature": "com.google.javascript.rhino.jstype.FunctionParamBuilder.addOptionalParams(JSType[])",
    "snippet": "  public boolean addOptionalParams(JSType ...types) {\n    if (hasVarArgs()) {\n      return false;\n    }\n\n    for (JSType type : types) {\n      newParameter(registry.createOptionalType(type)).setOptionalArg(true);\n    }\n    return true;\n  }",
    "comment": " Add optional parameters of the given type to the end of the param list. @param types Types for each optional parameter. The builder will make them undefineable. @return False if this is called after var args are added. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "FunctionParamBuilder.addRequiredParams",
    "class_name": "com.google.javascript.rhino.jstype.FunctionParamBuilder",
    "signature": "com.google.javascript.rhino.jstype.FunctionParamBuilder.addRequiredParams(JSType[])",
    "snippet": "  public boolean addRequiredParams(JSType ...types) {\n    if (hasOptionalOrVarArgs()) {\n      return false;\n    }\n\n    for (JSType type : types) {\n      newParameter(type);\n    }\n    return true;\n  }",
    "comment": " Add parameters of the given type to the end of the param list. @return False if this is called after optional params are added. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "FunctionParamBuilder.addVarArgs",
    "class_name": "com.google.javascript.rhino.jstype.FunctionParamBuilder",
    "signature": "com.google.javascript.rhino.jstype.FunctionParamBuilder.addVarArgs(JSType)",
    "snippet": "  public boolean addVarArgs(JSType type) {\n    if (hasVarArgs()) {\n      return false;\n    }\n\n    // There are two types of variable argument functions:\n    // 1) Programmer-defined var args\n    // 2) Native bottom types that can accept any argument.\n    // For the first one, \"undefined\" is a valid value for all arguments.\n    // For the second, we do not want to cast it up to undefined.\n    if (!type.isEmptyType()) {\n      type = registry.createOptionalType(type);\n    }\n    newParameter(type).setVarArgs(true);\n    return true;\n  }",
    "comment": " Add variable arguments to the end of the parameter list. @return False if this is called after var args are added. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "FunctionParamBuilder.build",
    "class_name": "com.google.javascript.rhino.jstype.FunctionParamBuilder",
    "signature": "com.google.javascript.rhino.jstype.FunctionParamBuilder.build()",
    "snippet": "  public Node build() {\n    return root;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "FunctionParamBuilder.hasOptionalOrVarArgs",
    "class_name": "com.google.javascript.rhino.jstype.FunctionParamBuilder",
    "signature": "com.google.javascript.rhino.jstype.FunctionParamBuilder.hasOptionalOrVarArgs()",
    "snippet": "  private boolean hasOptionalOrVarArgs() {\n    Node lastChild = root.getLastChild();\n    return lastChild != null &&\n        (lastChild.isOptionalArg() || lastChild.isVarArgs());\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "FunctionParamBuilder.hasVarArgs",
    "class_name": "com.google.javascript.rhino.jstype.FunctionParamBuilder",
    "signature": "com.google.javascript.rhino.jstype.FunctionParamBuilder.hasVarArgs()",
    "snippet": "  public boolean hasVarArgs() {\n    Node lastChild = root.getLastChild();\n    return lastChild != null && lastChild.isVarArgs();\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "FunctionParamBuilder.newParameter",
    "class_name": "com.google.javascript.rhino.jstype.FunctionParamBuilder",
    "signature": "com.google.javascript.rhino.jstype.FunctionParamBuilder.newParameter(JSType)",
    "snippet": "  private Node newParameter(JSType type) {\n    Node paramNode = Node.newString(Token.NAME, \"\");\n    paramNode.setJSType(type);\n    root.addChildToBack(paramNode);\n    return paramNode;\n  }",
    "comment": "Add a parameter to the list with the given type.",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "FunctionPrototypeType.FunctionPrototypeType",
    "class_name": "com.google.javascript.rhino.jstype.FunctionPrototypeType",
    "signature": "com.google.javascript.rhino.jstype.FunctionPrototypeType.FunctionPrototypeType(JSTypeRegistry,FunctionType,ObjectType)",
    "snippet": "  FunctionPrototypeType(JSTypeRegistry registry, FunctionType ownerFunction,\n      ObjectType implicitPrototype) {\n    this(registry, ownerFunction, implicitPrototype, false);\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "FunctionPrototypeType.FunctionPrototypeType",
    "class_name": "com.google.javascript.rhino.jstype.FunctionPrototypeType",
    "signature": "com.google.javascript.rhino.jstype.FunctionPrototypeType.FunctionPrototypeType(JSTypeRegistry,FunctionType,ObjectType,boolean)",
    "snippet": "  FunctionPrototypeType(JSTypeRegistry registry, FunctionType ownerFunction,\n      ObjectType implicitPrototype, boolean isNative) {\n    super(registry, null /* has no class name */, implicitPrototype,\n        isNative);\n    this.ownerFunction = ownerFunction;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "FunctionPrototypeType.getCtorExtendedInterfaces",
    "class_name": "com.google.javascript.rhino.jstype.FunctionPrototypeType",
    "signature": "com.google.javascript.rhino.jstype.FunctionPrototypeType.getCtorExtendedInterfaces()",
    "snippet": "  @Override\n  public Iterable<ObjectType> getCtorExtendedInterfaces() {\n    if (getOwnerFunction() != null) {\n      return getOwnerFunction().getExtendedInterfaces();\n    } else {\n      return ImmutableSet.of();\n    }\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "FunctionPrototypeType.getCtorImplementedInterfaces",
    "class_name": "com.google.javascript.rhino.jstype.FunctionPrototypeType",
    "signature": "com.google.javascript.rhino.jstype.FunctionPrototypeType.getCtorImplementedInterfaces()",
    "snippet": "  @Override\n  public Iterable<ObjectType> getCtorImplementedInterfaces() {\n    return getOwnerFunction().getImplementedInterfaces();\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "FunctionPrototypeType.getOwnerFunction",
    "class_name": "com.google.javascript.rhino.jstype.FunctionPrototypeType",
    "signature": "com.google.javascript.rhino.jstype.FunctionPrototypeType.getOwnerFunction()",
    "snippet": "  public FunctionType getOwnerFunction() {\n    return ownerFunction;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "FunctionPrototypeType.getReferenceName",
    "class_name": "com.google.javascript.rhino.jstype.FunctionPrototypeType",
    "signature": "com.google.javascript.rhino.jstype.FunctionPrototypeType.getReferenceName()",
    "snippet": "  @Override\n  public String getReferenceName() {\n    if (ownerFunction == null) {\n      return \"{...}.prototype\";\n    } else {\n      return ownerFunction.getReferenceName() + \".prototype\";\n    }\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "FunctionPrototypeType.hasReferenceName",
    "class_name": "com.google.javascript.rhino.jstype.FunctionPrototypeType",
    "signature": "com.google.javascript.rhino.jstype.FunctionPrototypeType.hasReferenceName()",
    "snippet": "  @Override\n  public boolean hasReferenceName() {\n    return ownerFunction != null && ownerFunction.hasReferenceName();\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "FunctionType.FunctionType",
    "class_name": "com.google.javascript.rhino.jstype.FunctionType",
    "signature": "com.google.javascript.rhino.jstype.FunctionType.FunctionType(JSTypeRegistry,String,Node,ArrowType,ObjectType,String,boolean,boolean)",
    "snippet": "  FunctionType(JSTypeRegistry registry, String name, Node source,\n      ArrowType arrowType, ObjectType typeOfThis,\n      String templateTypeName,  boolean isConstructor, boolean nativeType) {\n    super(registry, name,\n        registry.getNativeObjectType(JSTypeNative.FUNCTION_INSTANCE_TYPE),\n        nativeType);\n    Preconditions.checkArgument(source == null ||\n        Token.FUNCTION == source.getType());\n    Preconditions.checkNotNull(arrowType);\n    this.source = source;\n    this.kind = isConstructor ? Kind.CONSTRUCTOR : Kind.ORDINARY;\n    if (isConstructor) {\n      this.typeOfThis = typeOfThis != null ?\n          typeOfThis : new InstanceObjectType(registry, this, nativeType);\n    } else {\n      this.typeOfThis = typeOfThis != null ?\n          typeOfThis :\n          registry.getNativeObjectType(JSTypeNative.UNKNOWN_TYPE);\n    }\n    this.call = arrowType;\n    this.templateTypeName = templateTypeName;\n  }",
    "comment": "Creates an instance for a function that might be a constructor. */",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "FunctionType.addSubType",
    "class_name": "com.google.javascript.rhino.jstype.FunctionType",
    "signature": "com.google.javascript.rhino.jstype.FunctionType.addSubType(FunctionType)",
    "snippet": "  private void addSubType(FunctionType subType) {\n    if (subTypes == null) {\n      subTypes = Lists.newArrayList();\n    }\n    subTypes.add(subType);\n  }",
    "comment": "Adds a type to the list of subtypes for this type. */",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "FunctionType.appendVarArgsString",
    "class_name": "com.google.javascript.rhino.jstype.FunctionType",
    "signature": "com.google.javascript.rhino.jstype.FunctionType.appendVarArgsString(StringBuilder,JSType)",
    "snippet": "  private void appendVarArgsString(StringBuilder builder, JSType paramType) {\n    if (paramType.isUnionType()) {\n      // Remove the optionalness from the var arg.\n      paramType = ((UnionType) paramType).getRestrictedUnion(\n          registry.getNativeType(JSTypeNative.VOID_TYPE));\n    }\n    builder.append(\"...[\").append(paramType.toString()).append(\"]\");\n  }",
    "comment": "Gets the string representation of a var args param. */",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "FunctionType.clearCachedValues",
    "class_name": "com.google.javascript.rhino.jstype.FunctionType",
    "signature": "com.google.javascript.rhino.jstype.FunctionType.clearCachedValues()",
    "snippet": "  @Override\n  public void clearCachedValues() {\n    super.clearCachedValues();\n\n    if (subTypes != null) {\n      for (FunctionType subType : subTypes) {\n        subType.clearCachedValues();\n      }\n    }\n\n    if (!isNativeObjectType()) {\n      if (hasInstanceType()) {\n        getInstanceType().clearCachedValues();\n      }\n\n      if (prototype != null) {\n        prototype.clearCachedValues();\n      }\n    }\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "FunctionType.defineProperty",
    "class_name": "com.google.javascript.rhino.jstype.FunctionType",
    "signature": "com.google.javascript.rhino.jstype.FunctionType.defineProperty(String,JSType,boolean,Node)",
    "snippet": "  @Override\n  boolean defineProperty(String name, JSType type,\n      boolean inferred, Node propertyNode) {\n    if (\"prototype\".equals(name)) {\n      ObjectType objType = type.toObjectType();\n      if (objType != null) {\n        if (objType.isEquivalentTo(prototype)) {\n          return true;\n        }\n        return setPrototype(\n            new FunctionPrototypeType(\n                registry, this, objType, isNativeObjectType()));\n      } else {\n        return false;\n      }\n    }\n    return super.defineProperty(name, type, inferred, propertyNode);\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "FunctionType.getAllImplementedInterfaces",
    "class_name": "com.google.javascript.rhino.jstype.FunctionType",
    "signature": "com.google.javascript.rhino.jstype.FunctionType.getAllImplementedInterfaces()",
    "snippet": "  public Iterable<ObjectType> getAllImplementedInterfaces() {\n    // Store them in a linked hash set, so that the compile job is\n    // deterministic.\n    Set<ObjectType> interfaces = Sets.newLinkedHashSet();\n\n    for (ObjectType type : getImplementedInterfaces()) {\n      addRelatedInterfaces(type, interfaces);\n    }\n    return interfaces;\n  }",
    "comment": " Returns all interfaces implemented by a class or its superclass and any superclasses for any of those interfaces. If this is called before all types are resolved, it may return an incomplete set. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "FunctionType.getExtendedInterfaces",
    "class_name": "com.google.javascript.rhino.jstype.FunctionType",
    "signature": "com.google.javascript.rhino.jstype.FunctionType.getExtendedInterfaces()",
    "snippet": "  public Iterable<ObjectType> getExtendedInterfaces() {\n    return extendedInterfaces;\n  }",
    "comment": "Returns interfaces directly extended by an interface */",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "FunctionType.getImplementedInterfaces",
    "class_name": "com.google.javascript.rhino.jstype.FunctionType",
    "signature": "com.google.javascript.rhino.jstype.FunctionType.getImplementedInterfaces()",
    "snippet": "  public Iterable<ObjectType> getImplementedInterfaces() {\n    FunctionType superCtor = isConstructor() ?\n        getSuperClassConstructor() : null;\n    if (superCtor == null) {\n      return implementedInterfaces;\n    } else {\n      return Iterables.concat(\n          implementedInterfaces, superCtor.getImplementedInterfaces());\n    }\n  }",
    "comment": "Returns interfaces implemented directly by a class or its superclass. */",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "FunctionType.getInstanceType",
    "class_name": "com.google.javascript.rhino.jstype.FunctionType",
    "signature": "com.google.javascript.rhino.jstype.FunctionType.getInstanceType()",
    "snippet": "  public ObjectType getInstanceType() {\n    Preconditions.checkState(hasInstanceType());\n    return typeOfThis;\n  }",
    "comment": " Gets the type of instance of this function. @throws IllegalStateException if this function is not a constructor (see {@link #isConstructor()}). ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "FunctionType.getInternalArrowType",
    "class_name": "com.google.javascript.rhino.jstype.FunctionType",
    "signature": "com.google.javascript.rhino.jstype.FunctionType.getInternalArrowType()",
    "snippet": "  ArrowType getInternalArrowType() {\n    return call;\n  }",
    "comment": "Gets the internal arrow type. For use by subclasses only. */",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "FunctionType.getParametersNode",
    "class_name": "com.google.javascript.rhino.jstype.FunctionType",
    "signature": "com.google.javascript.rhino.jstype.FunctionType.getParametersNode()",
    "snippet": "  public Node getParametersNode() {\n    return call.parameters;\n  }",
    "comment": "Gets an LP node that contains all params. May be null. */",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "FunctionType.getPrototype",
    "class_name": "com.google.javascript.rhino.jstype.FunctionType",
    "signature": "com.google.javascript.rhino.jstype.FunctionType.getPrototype()",
    "snippet": "  public FunctionPrototypeType getPrototype() {\n    // lazy initialization of the prototype field\n    if (prototype == null) {\n      setPrototype(new FunctionPrototypeType(registry, this, null));\n    }\n    return prototype;\n  }",
    "comment": " Gets the {@code prototype} property of this function type. This is equivalent to {@code (ObjectType) getPropertyType(\"prototype\")}. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "FunctionType.getReturnType",
    "class_name": "com.google.javascript.rhino.jstype.FunctionType",
    "signature": "com.google.javascript.rhino.jstype.FunctionType.getReturnType()",
    "snippet": "  public JSType getReturnType() {\n    return call.returnType;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "FunctionType.getSource",
    "class_name": "com.google.javascript.rhino.jstype.FunctionType",
    "signature": "com.google.javascript.rhino.jstype.FunctionType.getSource()",
    "snippet": "  public Node getSource() {\n    return source;\n  }",
    "comment": " Gets the source node or null if this is an unknown function. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "FunctionType.getSuperClassConstructor",
    "class_name": "com.google.javascript.rhino.jstype.FunctionType",
    "signature": "com.google.javascript.rhino.jstype.FunctionType.getSuperClassConstructor()",
    "snippet": "  public FunctionType getSuperClassConstructor() {\n    Preconditions.checkArgument(isConstructor() || isInterface());\n    ObjectType maybeSuperInstanceType = getPrototype().getImplicitPrototype();\n    if (maybeSuperInstanceType == null) {\n      return null;\n    }\n    return maybeSuperInstanceType.getConstructor();\n  }",
    "comment": " Given a constructor or an interface type, get its superclass constructor or {@code null} if none exists. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "FunctionType.getTypeOfThis",
    "class_name": "com.google.javascript.rhino.jstype.FunctionType",
    "signature": "com.google.javascript.rhino.jstype.FunctionType.getTypeOfThis()",
    "snippet": "  @Override\n  public ObjectType getTypeOfThis() {\n    return typeOfThis.isNoObjectType() ?\n        registry.getNativeObjectType(JSTypeNative.OBJECT_TYPE) : typeOfThis;\n  }",
    "comment": " Gets the type of {@code this} in this function. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "FunctionType.hasCachedValues",
    "class_name": "com.google.javascript.rhino.jstype.FunctionType",
    "signature": "com.google.javascript.rhino.jstype.FunctionType.hasCachedValues()",
    "snippet": "  @Override\n  public boolean hasCachedValues() {\n    return prototype != null || super.hasCachedValues();\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "FunctionType.hasEqualCallType",
    "class_name": "com.google.javascript.rhino.jstype.FunctionType",
    "signature": "com.google.javascript.rhino.jstype.FunctionType.hasEqualCallType(FunctionType)",
    "snippet": "  public boolean hasEqualCallType(FunctionType otherType) {\n    return this.call.isEquivalentTo(otherType.call);\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "FunctionType.hasInstanceType",
    "class_name": "com.google.javascript.rhino.jstype.FunctionType",
    "signature": "com.google.javascript.rhino.jstype.FunctionType.hasInstanceType()",
    "snippet": "  public boolean hasInstanceType() {\n    return isConstructor() || isInterface();\n  }",
    "comment": " Returns whether this function type has an instance type. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "FunctionType.hasProperty",
    "class_name": "com.google.javascript.rhino.jstype.FunctionType",
    "signature": "com.google.javascript.rhino.jstype.FunctionType.hasProperty(String)",
    "snippet": "  @Override\n  public boolean hasProperty(String name) {\n    return super.hasProperty(name) || \"prototype\".equals(name);\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "FunctionType.isConstructor",
    "class_name": "com.google.javascript.rhino.jstype.FunctionType",
    "signature": "com.google.javascript.rhino.jstype.FunctionType.isConstructor()",
    "snippet": "  @Override\n  public boolean isConstructor() {\n    return kind == Kind.CONSTRUCTOR;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "FunctionType.isEquivalentTo",
    "class_name": "com.google.javascript.rhino.jstype.FunctionType",
    "signature": "com.google.javascript.rhino.jstype.FunctionType.isEquivalentTo(JSType)",
    "snippet": "  @Override\n  public boolean isEquivalentTo(JSType otherType) {\n    if (!(otherType instanceof FunctionType)) {\n      return false;\n    }\n    FunctionType that = (FunctionType) otherType;\n    if (!that.isFunctionType()) {\n      return false;\n    }\n    if (this.isConstructor()) {\n      if (that.isConstructor()) {\n        return this == that;\n      }\n      return false;\n    }\n    if (this.isInterface()) {\n      if (that.isInterface()) {\n        return this.getReferenceName().equals(that.getReferenceName());\n      }\n      return false;\n    }\n    if (that.isInterface()) {\n      return false;\n    }\n    return this.typeOfThis.isEquivalentTo(that.typeOfThis) &&\n        this.call.isEquivalentTo(that.call);\n  }",
    "comment": " Two function types are equal if their signatures match. Since they don't have signatures, two interfaces are equal if their names match. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "FunctionType.isFunctionType",
    "class_name": "com.google.javascript.rhino.jstype.FunctionType",
    "signature": "com.google.javascript.rhino.jstype.FunctionType.isFunctionType()",
    "snippet": "  @Override\n  public boolean isFunctionType() {\n    return true;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "FunctionType.isInterface",
    "class_name": "com.google.javascript.rhino.jstype.FunctionType",
    "signature": "com.google.javascript.rhino.jstype.FunctionType.isInterface()",
    "snippet": "  @Override\n  public boolean isInterface() {\n    return kind == Kind.INTERFACE;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "FunctionType.isOrdinaryFunction",
    "class_name": "com.google.javascript.rhino.jstype.FunctionType",
    "signature": "com.google.javascript.rhino.jstype.FunctionType.isOrdinaryFunction()",
    "snippet": "  @Override\n  public boolean isOrdinaryFunction() {\n    return kind == Kind.ORDINARY;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "FunctionType.isSubtype",
    "class_name": "com.google.javascript.rhino.jstype.FunctionType",
    "signature": "com.google.javascript.rhino.jstype.FunctionType.isSubtype(JSType)",
    "snippet": "  @Override\n  public boolean isSubtype(JSType that) {\n    if (JSType.isSubtype(this, that)) {\n      return true;\n    }\n\n    if (that.isFunctionType()) {\n      if (((FunctionType) that).isInterface()) {\n        // Any function can be assigned to an interface function.\n        return true;\n      }\n      if (this.isInterface()) {\n        // An interface function cannot be assigned to anything.\n        return false;\n      }\n      // If functionA is a subtype of functionB, then their \"this\" types\n      // should be contravariant. However, this causes problems because\n      // of the way we enforce overrides. Because function(this:SubFoo)\n      // is not a subtype of function(this:Foo), our override check treats\n      // this as an error. It also screws up out standard method\n      // for aliasing constructors. Let's punt on all this for now.\n      // TODO(nicksantos): fix this.\n      FunctionType other = (FunctionType) that;\n      boolean treatThisTypesAsCovariant =\n        // If either one of these is a ctor, skip 'this' checking.\n        this.isConstructor() || other.isConstructor() ||\n\n        // An interface 'this'-type is non-restrictive.\n        // In practical terms, if C implements I, and I has a method m,\n        // then any m doesn't necessarily have to C#m's 'this'\n        // type doesn't need to match I.\n        (other.typeOfThis.getConstructor() != null &&\n             other.typeOfThis.getConstructor().isInterface()) ||\n\n        // If one of the 'this' types is covariant of the other,\n        // then we'll treat them as covariant (see comment above).\n        other.typeOfThis.isSubtype(this.typeOfThis) ||\n        this.typeOfThis.isSubtype(other.typeOfThis);\n      return treatThisTypesAsCovariant && this.call.isSubtype(other.call);\n    }\n\n    return getNativeType(JSTypeNative.FUNCTION_PROTOTYPE).isSubtype(that);\n  }",
    "comment": " A function is a subtype of another if their call methods are related via subtyping and {@code this} is a subtype of {@code that} with regard to the prototype chain. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "FunctionType.resolveInternal",
    "class_name": "com.google.javascript.rhino.jstype.FunctionType",
    "signature": "com.google.javascript.rhino.jstype.FunctionType.resolveInternal(ErrorReporter,StaticScope)",
    "snippet": "  @Override\n  JSType resolveInternal(ErrorReporter t, StaticScope<JSType> scope) {\n    setResolvedTypeInternal(this);\n\n    call = (ArrowType) safeResolve(call, t, scope);\n    prototype = (FunctionPrototypeType) safeResolve(prototype, t, scope);\n\n    // Warning about typeOfThis if it doesn't resolve to an ObjectType\n    // is handled further upstream.\n    //\n    // TODO(nicksantos): Handle this correctly if we have a UnionType.\n    //\n    // TODO(nicksantos): In ES3, the runtime coerces \"null\" to the global\n    // activation object. In ES5, it leaves it as null. Just punt on this\n    // issue for now by coercing out null. This is complicated by the\n    // fact that when most people write @this {Foo}, they really don't\n    // mean \"nullable Foo\". For certain tags (like @extends) we de-nullify\n    // the name for them.\n    JSType maybeTypeOfThis = safeResolve(typeOfThis, t, scope);\n    if (maybeTypeOfThis != null) {\n      maybeTypeOfThis = maybeTypeOfThis.restrictByNotNullOrUndefined();\n    }\n    if (maybeTypeOfThis instanceof ObjectType) {\n      typeOfThis = (ObjectType) maybeTypeOfThis;\n    }\n\n    boolean changed = false;\n    ImmutableList.Builder<ObjectType> resolvedInterfaces =\n        ImmutableList.builder();\n    for (ObjectType iface : implementedInterfaces) {\n      ObjectType resolvedIface = (ObjectType) iface.resolve(t, scope);\n      resolvedInterfaces.add(resolvedIface);\n      changed |= (resolvedIface != iface);\n    }\n    if (changed) {\n      implementedInterfaces = resolvedInterfaces.build();\n    }\n\n    if (subTypes != null) {\n      for (int i = 0; i < subTypes.size(); i++) {\n        subTypes.set(i, (FunctionType) subTypes.get(i).resolve(t, scope));\n      }\n    }\n\n    return super.resolveInternal(t, scope);\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "FunctionType.setImplementedInterfaces",
    "class_name": "com.google.javascript.rhino.jstype.FunctionType",
    "signature": "com.google.javascript.rhino.jstype.FunctionType.setImplementedInterfaces(List)",
    "snippet": "  public void setImplementedInterfaces(List<ObjectType> implementedInterfaces) {\n    // Records this type for each implemented interface.\n    for (ObjectType type : implementedInterfaces) {\n      registry.registerTypeImplementingInterface(this, type);\n    }\n    this.implementedInterfaces = ImmutableList.copyOf(implementedInterfaces);\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "FunctionType.setInstanceType",
    "class_name": "com.google.javascript.rhino.jstype.FunctionType",
    "signature": "com.google.javascript.rhino.jstype.FunctionType.setInstanceType(ObjectType)",
    "snippet": "  void setInstanceType(ObjectType instanceType) {\n    typeOfThis = instanceType;\n  }",
    "comment": " Sets the instance type. This should only be used for special native types. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "FunctionType.setPrototype",
    "class_name": "com.google.javascript.rhino.jstype.FunctionType",
    "signature": "com.google.javascript.rhino.jstype.FunctionType.setPrototype(FunctionPrototypeType)",
    "snippet": "  public boolean setPrototype(FunctionPrototypeType prototype) {\n    if (prototype == null) {\n      return false;\n    }\n    // getInstanceType fails if the function is not a constructor\n    if (isConstructor() && prototype == getInstanceType()) {\n      return false;\n    }\n\n    boolean replacedPrototype = prototype != null;\n    this.prototype = prototype;\n\n    if (isConstructor() || isInterface()) {\n      FunctionType superClass = getSuperClassConstructor();\n      if (superClass != null) {\n        superClass.addSubType(this);\n      }\n\n      if (isInterface()) {\n        for (ObjectType interfaceType : getExtendedInterfaces()) {\n          if (interfaceType.getConstructor() != null) {\n            interfaceType.getConstructor().addSubType(this);\n          }\n        }\n      }\n    }\n\n    if (replacedPrototype) {\n      clearCachedValues();\n    }\n\n    return true;\n  }",
    "comment": " Sets the prototype. @param prototype the prototype. If this value is {@code null} it will silently be discarded. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "FunctionType.setPrototypeBasedOn",
    "class_name": "com.google.javascript.rhino.jstype.FunctionType",
    "signature": "com.google.javascript.rhino.jstype.FunctionType.setPrototypeBasedOn(ObjectType)",
    "snippet": "  public void setPrototypeBasedOn(ObjectType baseType) {\n    if (prototype == null) {\n      setPrototype(\n          new FunctionPrototypeType(\n              registry, this, baseType, isNativeObjectType()));\n    } else {\n      prototype.setImplicitPrototype(baseType);\n    }\n  }",
    "comment": " Sets the prototype, creating the prototype object from the given base type. @param baseType The base type. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "FunctionType.setSource",
    "class_name": "com.google.javascript.rhino.jstype.FunctionType",
    "signature": "com.google.javascript.rhino.jstype.FunctionType.setSource(Node)",
    "snippet": "  public void setSource(Node source) {\n    this.source = source;\n  }",
    "comment": " Sets the source node. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "FunctionType.toString",
    "class_name": "com.google.javascript.rhino.jstype.FunctionType",
    "signature": "com.google.javascript.rhino.jstype.FunctionType.toString()",
    "snippet": "  @Override\n  public String toString() {\n    if (this == registry.getNativeType(JSTypeNative.FUNCTION_INSTANCE_TYPE)) {\n      return \"Function\";\n    }\n\n    StringBuilder b = new StringBuilder(32);\n    b.append(\"function (\");\n    int paramNum = call.parameters.getChildCount();\n    boolean hasKnownTypeOfThis = !typeOfThis.isUnknownType();\n    if (hasKnownTypeOfThis) {\n      if (isConstructor()) {\n        b.append(\"new:\");\n      } else {\n        b.append(\"this:\");\n      }\n      b.append(typeOfThis.toString());\n    }\n    if (paramNum > 0) {\n      if (hasKnownTypeOfThis) {\n        b.append(\", \");\n      }\n      Node p = call.parameters.getFirstChild();\n      if (p.isVarArgs()) {\n        appendVarArgsString(b, p.getJSType());\n      } else {\n        b.append(p.getJSType().toString());\n      }\n      p = p.getNext();\n      while (p != null) {\n        b.append(\", \");\n        if (p.isVarArgs()) {\n          appendVarArgsString(b, p.getJSType());\n        } else {\n          b.append(p.getJSType().toString());\n        }\n        p = p.getNext();\n      }\n    }\n    b.append(\"): \");\n    b.append(call.returnType);\n    return b.toString();\n  }",
    "comment": " Informally, a function is represented by {@code function (params): returnType} where the {@code params} is a comma separated list of types, the first one being a special {@code this:T} if the function expects a known type for {@code this}. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "InstanceObjectType.InstanceObjectType",
    "class_name": "com.google.javascript.rhino.jstype.InstanceObjectType",
    "signature": "com.google.javascript.rhino.jstype.InstanceObjectType.InstanceObjectType(JSTypeRegistry,FunctionType,boolean)",
    "snippet": "  InstanceObjectType(JSTypeRegistry registry, FunctionType constructor,\n                     boolean isNativeType) {\n    super(registry, null, null, isNativeType);\n    Preconditions.checkNotNull(constructor);\n    this.constructor = constructor;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "InstanceObjectType.defineProperty",
    "class_name": "com.google.javascript.rhino.jstype.InstanceObjectType",
    "signature": "com.google.javascript.rhino.jstype.InstanceObjectType.defineProperty(String,JSType,boolean,Node)",
    "snippet": "  @Override\n  boolean defineProperty(String name, JSType type, boolean inferred,\n      Node propertyNode) {\n    ObjectType proto = getImplicitPrototype();\n    if (proto != null && proto.hasOwnDeclaredProperty(name)) {\n      return false;\n    }\n    return super.defineProperty(name, type, inferred, propertyNode);\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "InstanceObjectType.getConstructor",
    "class_name": "com.google.javascript.rhino.jstype.InstanceObjectType",
    "signature": "com.google.javascript.rhino.jstype.InstanceObjectType.getConstructor()",
    "snippet": "  @Override\n  public FunctionType getConstructor() {\n    return constructor;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "InstanceObjectType.getCtorExtendedInterfaces",
    "class_name": "com.google.javascript.rhino.jstype.InstanceObjectType",
    "signature": "com.google.javascript.rhino.jstype.InstanceObjectType.getCtorExtendedInterfaces()",
    "snippet": "  @Override\n  public Iterable<ObjectType> getCtorExtendedInterfaces() {\n    return getConstructor().getExtendedInterfaces();\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "InstanceObjectType.getImplicitPrototype",
    "class_name": "com.google.javascript.rhino.jstype.InstanceObjectType",
    "signature": "com.google.javascript.rhino.jstype.InstanceObjectType.getImplicitPrototype()",
    "snippet": "  @Override\n  public ObjectType getImplicitPrototype() {\n    return getConstructor().getPrototype();\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "InstanceObjectType.getReferenceName",
    "class_name": "com.google.javascript.rhino.jstype.InstanceObjectType",
    "signature": "com.google.javascript.rhino.jstype.InstanceObjectType.getReferenceName()",
    "snippet": "  @Override\n  public String getReferenceName() {\n    return getConstructor().getReferenceName();\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "InstanceObjectType.hasReferenceName",
    "class_name": "com.google.javascript.rhino.jstype.InstanceObjectType",
    "signature": "com.google.javascript.rhino.jstype.InstanceObjectType.hasReferenceName()",
    "snippet": "  @Override\n  public boolean hasReferenceName() {\n    return getConstructor().hasReferenceName();\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "InstanceObjectType.hashCode",
    "class_name": "com.google.javascript.rhino.jstype.InstanceObjectType",
    "signature": "com.google.javascript.rhino.jstype.InstanceObjectType.hashCode()",
    "snippet": "  @Override\n  public int hashCode() {\n    if (hasReferenceName()) {\n      return getReferenceName().hashCode();\n    } else {\n      return super.hashCode();\n    }\n  }",
    "comment": " If this is equal to a NamedType object, its hashCode must be equal to the hashCode of the NamedType object. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "InstanceObjectType.isEquivalentTo",
    "class_name": "com.google.javascript.rhino.jstype.InstanceObjectType",
    "signature": "com.google.javascript.rhino.jstype.InstanceObjectType.isEquivalentTo(JSType)",
    "snippet": "  @Override\n  public boolean isEquivalentTo(JSType that) {\n    if (this == that) {\n      return true;\n    } else if (this.isNominalType()) {\n      ObjectType thatObj = ObjectType.cast(that);\n      if (thatObj != null && thatObj.isNominalType()) {\n        return getReferenceName().equals(thatObj.getReferenceName());\n      }\n    }\n    return false;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "InstanceObjectType.isNominalType",
    "class_name": "com.google.javascript.rhino.jstype.InstanceObjectType",
    "signature": "com.google.javascript.rhino.jstype.InstanceObjectType.isNominalType()",
    "snippet": "  @Override\n  public boolean isNominalType() {\n    return hasReferenceName();\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "InstanceObjectType.toString",
    "class_name": "com.google.javascript.rhino.jstype.InstanceObjectType",
    "signature": "com.google.javascript.rhino.jstype.InstanceObjectType.toString()",
    "snippet": "  @Override\n  public String toString() {\n    if (constructor.hasReferenceName()) {\n      return constructor.getReferenceName();\n    } else {\n      return super.toString();\n    }\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "JSType.JSType",
    "class_name": "com.google.javascript.rhino.jstype.JSType",
    "signature": "com.google.javascript.rhino.jstype.JSType.JSType(JSTypeRegistry)",
    "snippet": "  JSType(JSTypeRegistry registry) {\n    this.registry = registry;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "JSType.autoboxesTo",
    "class_name": "com.google.javascript.rhino.jstype.JSType",
    "signature": "com.google.javascript.rhino.jstype.JSType.autoboxesTo()",
    "snippet": "  public JSType autoboxesTo() {\n    return null;\n  }",
    "comment": " Gets the type to which this type auto-boxes.  @return the auto-boxed type or {@code null} if this type does not auto-box ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "JSType.canAssignTo",
    "class_name": "com.google.javascript.rhino.jstype.JSType",
    "signature": "com.google.javascript.rhino.jstype.JSType.canAssignTo(JSType)",
    "snippet": "  public boolean canAssignTo(JSType that) {\n    if (this.isSubtype(that)) {\n      return true;\n    }\n    return false;\n  }",
    "comment": " Tests whether values of {@code this} type can be safely assigned to values of {@code that} type.<p>  The default implementation verifies that {@code this} is a subtype of {@code that}.<p> ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "JSType.dereference",
    "class_name": "com.google.javascript.rhino.jstype.JSType",
    "signature": "com.google.javascript.rhino.jstype.JSType.dereference()",
    "snippet": "  public final ObjectType dereference() {\n    JSType restricted = restrictByNotNullOrUndefined();\n    JSType autobox = restricted.autoboxesTo();\n    return ObjectType.cast(autobox == null ? restricted : autobox);\n  }",
    "comment": " Dereference a type for property access.  Autoboxes the type, filters null/undefined, and returns the result iff it's an object. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "JSType.equals",
    "class_name": "com.google.javascript.rhino.jstype.JSType",
    "signature": "com.google.javascript.rhino.jstype.JSType.equals(Object)",
    "snippet": "  @Override\n  public boolean equals(Object jsType) {\n    return (jsType instanceof JSType) ?\n        isEquivalentTo((JSType) jsType) : false;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "JSType.filterNoResolvedType",
    "class_name": "com.google.javascript.rhino.jstype.JSType",
    "signature": "com.google.javascript.rhino.jstype.JSType.filterNoResolvedType(JSType)",
    "snippet": "  static JSType filterNoResolvedType(JSType type) {\n    if (type.isNoResolvedType()) {\n      // inf(UnresolvedType1, UnresolvedType2) needs to resolve\n      // to the base unresolved type, so that the relation is symmetric.\n      return type.getNativeType(JSTypeNative.NO_RESOLVED_TYPE);\n    } else if (type instanceof UnionType) {\n      UnionType unionType = (UnionType) type;\n      boolean needsFiltering = false;\n      for (JSType alt : unionType.getAlternates()) {\n        if (alt.isNoResolvedType()) {\n          needsFiltering = true;\n          break;\n        }\n      }\n\n      if (needsFiltering) {\n        UnionTypeBuilder builder = new UnionTypeBuilder(type.registry);\n        for (JSType alt : unionType.getAlternates()) {\n          if (!alt.isNoResolvedType()) {\n            builder.addAlternate(alt);\n          }\n        }\n        return builder.build();\n      }\n    }\n    return type;\n  }",
    "comment": " When computing infimums, we may get a situation like inf(Type1, Type2) where both types are unresolved, so they're technically subtypes of one another.  If this happens, filter them down to NoResolvedType. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "JSType.getJSDocInfo",
    "class_name": "com.google.javascript.rhino.jstype.JSType",
    "signature": "com.google.javascript.rhino.jstype.JSType.getJSDocInfo()",
    "snippet": "  public JSDocInfo getJSDocInfo() {\n    return null;\n  }",
    "comment": " Gets the docInfo for this type. By default, documentation cannot be attached to arbitrary types. This must be overridden for programmer-defined types. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "JSType.getLeastSupertype",
    "class_name": "com.google.javascript.rhino.jstype.JSType",
    "signature": "com.google.javascript.rhino.jstype.JSType.getLeastSupertype(JSType)",
    "snippet": "  public JSType getLeastSupertype(JSType that) {\n    if (that.isUnionType()) {\n      // Union types have their own implementation of getLeastSupertype.\n      return that.getLeastSupertype(this);\n    }\n    return getLeastSupertype(this, that);\n  }",
    "comment": " Gets the least supertype of {@code this} and {@code that}. The least supertype is the join (&#8744;) or supremum of both types in the type lattice.<p> Examples: <ul> <li>{@code number &#8744; *} = {@code *}</li> <li>{@code number &#8744; Object} = {@code (number, Object)}</li> <li>{@code Number &#8744; Object} = {@code Object}</li> </ul> @return {@code this &#8744; that} ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "JSType.getLeastSupertype",
    "class_name": "com.google.javascript.rhino.jstype.JSType",
    "signature": "com.google.javascript.rhino.jstype.JSType.getLeastSupertype(JSType,JSType)",
    "snippet": "  static JSType getLeastSupertype(JSType thisType, JSType thatType) {\n    boolean areEquivalent = thisType.isEquivalentTo(thatType);\n    return areEquivalent ? thisType :\n        filterNoResolvedType(\n            thisType.registry.createUnionType(thisType, thatType));\n  }",
    "comment": " A generic implementation meant to be used as a helper for common getLeastSupertype implementations. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "JSType.getNativeType",
    "class_name": "com.google.javascript.rhino.jstype.JSType",
    "signature": "com.google.javascript.rhino.jstype.JSType.getNativeType(JSTypeNative)",
    "snippet": "  JSType getNativeType(JSTypeNative typeId) {\n    return registry.getNativeType(typeId);\n  }",
    "comment": " Utility method for less verbose code. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "JSType.hashCode",
    "class_name": "com.google.javascript.rhino.jstype.JSType",
    "signature": "com.google.javascript.rhino.jstype.JSType.hashCode()",
    "snippet": "  @Override\n  public int hashCode() {\n    return System.identityHashCode(this);\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "JSType.isAllType",
    "class_name": "com.google.javascript.rhino.jstype.JSType",
    "signature": "com.google.javascript.rhino.jstype.JSType.isAllType()",
    "snippet": "  public boolean isAllType() {\n    return false;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "JSType.isConstructor",
    "class_name": "com.google.javascript.rhino.jstype.JSType",
    "signature": "com.google.javascript.rhino.jstype.JSType.isConstructor()",
    "snippet": "  public boolean isConstructor() {\n    return false;\n  }",
    "comment": " Whether this type is a {@link FunctionType} that is a constructor or a named type that points to such a type. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "JSType.isEmptyType",
    "class_name": "com.google.javascript.rhino.jstype.JSType",
    "signature": "com.google.javascript.rhino.jstype.JSType.isEmptyType()",
    "snippet": "  public final boolean isEmptyType() {\n    return isNoType() || isNoObjectType() || isNoResolvedType() ||\n        (registry.getNativeFunctionType(\n             JSTypeNative.LEAST_FUNCTION_TYPE) == this);\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "JSType.isEnumType",
    "class_name": "com.google.javascript.rhino.jstype.JSType",
    "signature": "com.google.javascript.rhino.jstype.JSType.isEnumType()",
    "snippet": "  public boolean isEnumType() {\n    return false;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "JSType.isEquivalentTo",
    "class_name": "com.google.javascript.rhino.jstype.JSType",
    "signature": "com.google.javascript.rhino.jstype.JSType.isEquivalentTo(JSType)",
    "snippet": "  public boolean isEquivalentTo(JSType jsType) {\n    if (jsType instanceof ProxyObjectType) {\n      return jsType.isEquivalentTo(this);\n    }\n    // Relies on the fact that for the base {@link JSType}, only one\n    // instance of each sub-type will ever be created in a given registry, so\n    // there is no need to verify members. If the object pointers are not\n    // identical, then the type member must be different.\n    return this == jsType;\n  }",
    "comment": " Checks if two types are equivalent. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "JSType.isFunctionPrototypeType",
    "class_name": "com.google.javascript.rhino.jstype.JSType",
    "signature": "com.google.javascript.rhino.jstype.JSType.isFunctionPrototypeType()",
    "snippet": "  public boolean isFunctionPrototypeType() {\n    return false;\n  }",
    "comment": "Whether this is the prototype of a function. */",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "JSType.isFunctionType",
    "class_name": "com.google.javascript.rhino.jstype.JSType",
    "signature": "com.google.javascript.rhino.jstype.JSType.isFunctionType()",
    "snippet": "  public boolean isFunctionType() {\n    return false;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "JSType.isInstanceType",
    "class_name": "com.google.javascript.rhino.jstype.JSType",
    "signature": "com.google.javascript.rhino.jstype.JSType.isInstanceType()",
    "snippet": "  public boolean isInstanceType() {\n    return false;\n  }",
    "comment": " Whether this type is an Instance object of some constructor. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "JSType.isInterface",
    "class_name": "com.google.javascript.rhino.jstype.JSType",
    "signature": "com.google.javascript.rhino.jstype.JSType.isInterface()",
    "snippet": "  public boolean isInterface() {\n    return false;\n  }",
    "comment": " Whether this type is a {@link FunctionType} that is an interface or a named type that points to such a type. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "JSType.isNoObjectType",
    "class_name": "com.google.javascript.rhino.jstype.JSType",
    "signature": "com.google.javascript.rhino.jstype.JSType.isNoObjectType()",
    "snippet": "  public boolean isNoObjectType() {\n    return false;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "JSType.isNoResolvedType",
    "class_name": "com.google.javascript.rhino.jstype.JSType",
    "signature": "com.google.javascript.rhino.jstype.JSType.isNoResolvedType()",
    "snippet": "  public boolean isNoResolvedType() {\n    return false;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "JSType.isNoType",
    "class_name": "com.google.javascript.rhino.jstype.JSType",
    "signature": "com.google.javascript.rhino.jstype.JSType.isNoType()",
    "snippet": "  public boolean isNoType() {\n    return false;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "JSType.isSubtype",
    "class_name": "com.google.javascript.rhino.jstype.JSType",
    "signature": "com.google.javascript.rhino.jstype.JSType.isSubtype(JSType,JSType)",
    "snippet": "  static boolean isSubtype(JSType thisType, JSType thatType) {\n    // unknown\n    if (thatType.isUnknownType()) {\n      return true;\n    }\n    // equality\n    if (thisType.isEquivalentTo(thatType)) {\n      return true;\n    }\n    // all type\n    if (thatType.isAllType()) {\n      return true;\n    }\n    // unions\n    if (thatType instanceof UnionType) {\n      UnionType union = (UnionType)thatType;\n      for (JSType element : union.alternates) {\n        if (thisType.isSubtype(element)) {\n          return true;\n        }\n      }\n    }\n    // named types\n    if (thatType instanceof NamedType) {\n      return thisType.isSubtype(((NamedType)thatType).getReferencedType());\n    }\n    return false;\n  }",
    "comment": " A generic implementation meant to be used as a helper for common subtyping cases. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "JSType.isUnionType",
    "class_name": "com.google.javascript.rhino.jstype.JSType",
    "signature": "com.google.javascript.rhino.jstype.JSType.isUnionType()",
    "snippet": "  public boolean isUnionType() {\n    return false;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "JSType.isUnknownType",
    "class_name": "com.google.javascript.rhino.jstype.JSType",
    "signature": "com.google.javascript.rhino.jstype.JSType.isUnknownType()",
    "snippet": "  public boolean isUnknownType() {\n    return false;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "JSType.resolve",
    "class_name": "com.google.javascript.rhino.jstype.JSType",
    "signature": "com.google.javascript.rhino.jstype.JSType.resolve(ErrorReporter,StaticScope)",
    "snippet": "  public final JSType resolve(ErrorReporter t, StaticScope<JSType> scope) {\n    if (resolved) {\n      // TODO(nicksantos): Check to see if resolve() looped back on itself.\n      // Preconditions.checkNotNull(resolveResult);\n      if (resolveResult == null) {\n        return registry.getNativeType(JSTypeNative.UNKNOWN_TYPE);\n      }\n      return resolveResult;\n    }\n    resolved = true;\n    resolveResult = resolveInternal(t, scope);\n    resolveResult.setResolvedTypeInternal(resolveResult);\n    return resolveResult;\n  }",
    "comment": " Resolve this type in the given scope.  The returned value must be equal to {@code this}, as defined by {@link #isEquivalentTo}. It may or may not be the same object. This method may modify the internal state of {@code this}, as long as it does so in a way that preserves Object equality.  For efficiency, we should only resolve a type once per compilation job. For incremental compilations, one compilation job may need the artifacts from a previous generation, so we will eventually need a generational flag instead of a boolean one. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "JSType.restrictByNotNullOrUndefined",
    "class_name": "com.google.javascript.rhino.jstype.JSType",
    "signature": "com.google.javascript.rhino.jstype.JSType.restrictByNotNullOrUndefined()",
    "snippet": "  public JSType restrictByNotNullOrUndefined() {\n    return this;\n  }",
    "comment": " If this is a union type, returns a union type that does not include the null or undefined type. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "JSType.safeResolve",
    "class_name": "com.google.javascript.rhino.jstype.JSType",
    "signature": "com.google.javascript.rhino.jstype.JSType.safeResolve(JSType,ErrorReporter,StaticScope)",
    "snippet": "  static final JSType safeResolve(\n      JSType type, ErrorReporter t, StaticScope<JSType> scope) {\n    return type == null ? null : type.resolve(t, scope);\n  }",
    "comment": " A null-safe resolve. @see #resolve ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "JSType.setResolvedTypeInternal",
    "class_name": "com.google.javascript.rhino.jstype.JSType",
    "signature": "com.google.javascript.rhino.jstype.JSType.setResolvedTypeInternal(JSType)",
    "snippet": "  void setResolvedTypeInternal(JSType type) {\n    resolveResult = type;\n    resolved = true;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "JSType.setValidator",
    "class_name": "com.google.javascript.rhino.jstype.JSType",
    "signature": "com.google.javascript.rhino.jstype.JSType.setValidator(Predicate)",
    "snippet": "  public boolean setValidator(Predicate<JSType> validator) {\n    return validator.apply(this);\n  }",
    "comment": " Certain types have constraints on them at resolution-time. For example, a type in an {@code @extends} annotation must be an object. Clients should inject a validator that emits a warning if the type does not validate, and return false. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "JSType.toObjectType",
    "class_name": "com.google.javascript.rhino.jstype.JSType",
    "signature": "com.google.javascript.rhino.jstype.JSType.toObjectType()",
    "snippet": "  public ObjectType toObjectType() {\n    return this instanceof ObjectType ? (ObjectType) this : null;\n  }",
    "comment": " Casts this to an ObjectType, or returns null if this is not an ObjectType.  Does not change the underlying JS type. If you want to simulate JS autoboxing or dereferencing, you should use autoboxesTo() or dereference(). Those methods may change the underlying JS type. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "JSTypeRegistry.JSTypeRegistry",
    "class_name": "com.google.javascript.rhino.jstype.JSTypeRegistry",
    "signature": "com.google.javascript.rhino.jstype.JSTypeRegistry.JSTypeRegistry(ErrorReporter,boolean)",
    "snippet": "  public JSTypeRegistry(\n      ErrorReporter reporter, boolean tolerateUndefinedValues) {\n    this.reporter = reporter;\n    nativeTypes = new JSType[JSTypeNative.values().length];\n    namesToTypes = new HashMap<String, JSType>();\n    resetForTypeCheck();\n    this.tolerateUndefinedValues = tolerateUndefinedValues;\n  }",
    "comment": " Constructs a new type registry populated with the built-in types. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "JSTypeRegistry.addReferenceTypeIndexedByProperty",
    "class_name": "com.google.javascript.rhino.jstype.JSTypeRegistry",
    "signature": "com.google.javascript.rhino.jstype.JSTypeRegistry.addReferenceTypeIndexedByProperty(String,JSType)",
    "snippet": "  private void addReferenceTypeIndexedByProperty(\n      String propertyName, JSType type) {\n    if (type instanceof ObjectType && ((ObjectType) type).hasReferenceName()) {\n      Map<String, ObjectType> typeSet =\n          eachRefTypeIndexedByProperty.get(propertyName);\n      if (typeSet == null) {\n        typeSet = Maps.newHashMap();\n        eachRefTypeIndexedByProperty.put(propertyName, typeSet);\n      }\n      ObjectType objType = (ObjectType) type;\n      typeSet.put(objType.getReferenceName(), objType);\n    } else if (type instanceof NamedType) {\n      addReferenceTypeIndexedByProperty(\n          propertyName, ((NamedType) type).getReferencedType());\n    } else if (type instanceof UnionType) {\n      for (JSType alternate : ((UnionType) type).getAlternates()) {\n        addReferenceTypeIndexedByProperty(propertyName, alternate);\n      }\n    }\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "JSTypeRegistry.clearTemplateTypeName",
    "class_name": "com.google.javascript.rhino.jstype.JSTypeRegistry",
    "signature": "com.google.javascript.rhino.jstype.JSTypeRegistry.clearTemplateTypeName()",
    "snippet": "  public void clearTemplateTypeName() {\n    templateTypeName = null;\n    templateType = null;\n  }",
    "comment": " Clears the template type name. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "JSTypeRegistry.createArrowType",
    "class_name": "com.google.javascript.rhino.jstype.JSTypeRegistry",
    "signature": "com.google.javascript.rhino.jstype.JSTypeRegistry.createArrowType(Node)",
    "snippet": "  ArrowType createArrowType(Node parametersNode) {\n    return new ArrowType(this, parametersNode, null);\n  }",
    "comment": " Creates an arrow type with an unknown return type.  @param parametersNode the parameters' types, formatted as a Node with param names and optionality info. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "JSTypeRegistry.createArrowType",
    "class_name": "com.google.javascript.rhino.jstype.JSTypeRegistry",
    "signature": "com.google.javascript.rhino.jstype.JSTypeRegistry.createArrowType(Node,JSType)",
    "snippet": "  ArrowType createArrowType(Node parametersNode, JSType returnType) {\n    return new ArrowType(this, parametersNode, returnType);\n  }",
    "comment": " Creates an arrow type, an abstract representation of the parameters and return value of a function.  @param parametersNode the parameters' types, formatted as a Node with param names and optionality info. @param returnType the function's return type ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "JSTypeRegistry.createConstructorType",
    "class_name": "com.google.javascript.rhino.jstype.JSTypeRegistry",
    "signature": "com.google.javascript.rhino.jstype.JSTypeRegistry.createConstructorType(String,Node,Node,JSType)",
    "snippet": "  public FunctionType createConstructorType(String name, Node source,\n      Node parameters, JSType returnType) {\n    return new FunctionType(this, name, source,\n        createArrowType(parameters, returnType), null,\n        null, true, false);\n  }",
    "comment": " Creates a constructor function type. @param name the function's name or {@code null} to indicate that the function is anonymous. @param source the node defining this function. Its type ({@link Node#getType()}) must be {@link Token#FUNCTION}. @param parameters the function's parameters or {@code null} to indicate that the parameter types are unknown. @param returnType the function's return type or {@code null} to indicate that the return type is unknown. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "JSTypeRegistry.createDefaultObjectUnion",
    "class_name": "com.google.javascript.rhino.jstype.JSTypeRegistry",
    "signature": "com.google.javascript.rhino.jstype.JSTypeRegistry.createDefaultObjectUnion(JSType)",
    "snippet": "  public JSType createDefaultObjectUnion(JSType type) {\n    return shouldTolerateUndefinedValues()\n        ? createOptionalNullableType(type)\n        : createNullableType(type);\n  }",
    "comment": " Creates a type representing nullable values of the given type. @return the union of the type and the Null type ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "JSTypeRegistry.createFromTypeNodes",
    "class_name": "com.google.javascript.rhino.jstype.JSTypeRegistry",
    "signature": "com.google.javascript.rhino.jstype.JSTypeRegistry.createFromTypeNodes(Node,String,StaticScope)",
    "snippet": "  public JSType createFromTypeNodes(Node n, String sourceName,\n      StaticScope<JSType> scope) {\n    if (resolveMode == ResolveMode.LAZY_EXPRESSIONS) {\n      // If the type expression doesn't contain any names, just\n      // resolve it anyway.\n      boolean hasNames = hasTypeName(n);\n      if (hasNames) {\n        return new UnresolvedTypeExpression(this, n, sourceName);\n      }\n    }\n    return createFromTypeNodesInternal(n, sourceName, scope);\n  }",
    "comment": " Creates a JSType from the nodes representing a type. @param n The node with type info. @param sourceName The source file name. @param scope A scope for doing type name lookups. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "JSTypeRegistry.createFromTypeNodesInternal",
    "class_name": "com.google.javascript.rhino.jstype.JSTypeRegistry",
    "signature": "com.google.javascript.rhino.jstype.JSTypeRegistry.createFromTypeNodesInternal(Node,String,StaticScope)",
    "snippet": "  private JSType createFromTypeNodesInternal(Node n, String sourceName,\n      StaticScope<JSType> scope) {\n    switch (n.getType()) {\n      case Token.LC: // Record type.\n        return createRecordTypeFromNodes(\n            n.getFirstChild(), sourceName, scope);\n\n      case Token.BANG: // Not nullable\n        return createFromTypeNodesInternal(\n            n.getFirstChild(), sourceName, scope)\n            .restrictByNotNullOrUndefined();\n\n      case Token.QMARK: // Nullable or unknown\n        Node firstChild = n.getFirstChild();\n        if (firstChild == null) {\n          return getNativeType(UNKNOWN_TYPE);\n        }\n        return createDefaultObjectUnion(\n            createFromTypeNodesInternal(\n                firstChild, sourceName, scope));\n\n      case Token.EQUALS: // Optional\n        return createOptionalType(\n            createFromTypeNodesInternal(\n                n.getFirstChild(), sourceName, scope));\n\n      case Token.ELLIPSIS: // Var args\n        return createOptionalType(\n            createFromTypeNodesInternal(\n                n.getFirstChild(), sourceName, scope));\n\n      case Token.STAR: // The AllType\n        return getNativeType(ALL_TYPE);\n\n      case Token.LB: // Array type\n        // TODO(nicksantos): Enforce membership restrictions on the Array.\n        return getNativeType(ARRAY_TYPE);\n\n      case Token.PIPE: // Union type\n        UnionTypeBuilder builder = new UnionTypeBuilder(this);\n        for (Node child = n.getFirstChild(); child != null;\n             child = child.getNext()) {\n          builder.addAlternate(\n              createFromTypeNodesInternal(child, sourceName, scope));\n        }\n        return builder.build();\n\n      case Token.EMPTY: // When the return value of a function is not specified\n        return getNativeType(UNKNOWN_TYPE);\n\n      case Token.VOID: // Only allowed in the return value of a function.\n        return getNativeType(VOID_TYPE);\n\n      case Token.STRING:\n        JSType namedType = getType(scope, n.getString(), sourceName,\n            n.getLineno(), n.getCharno());\n        if (resolveMode != ResolveMode.LAZY_NAMES) {\n          namedType = namedType.resolveInternal(reporter, scope);\n        }\n        if ((namedType instanceof ObjectType) &&\n            !(nonNullableTypeNames.contains(n.getString()))) {\n          Node typeList = n.getFirstChild();\n          if (typeList != null &&\n              (\"Array\".equals(n.getString()) ||\n               \"Object\".equals(n.getString()))) {\n            JSType parameterType =\n                createFromTypeNodesInternal(\n                    typeList.getLastChild(), sourceName, scope);\n            namedType = new ParameterizedType(\n                this, (ObjectType) namedType, parameterType);\n            if (typeList.hasMoreThanOneChild()) {\n              JSType indexType =\n                  createFromTypeNodesInternal(\n                      typeList.getFirstChild(), sourceName, scope);\n              namedType = new IndexedType(\n                  this, (ObjectType) namedType, indexType);\n            }\n          }\n          return createDefaultObjectUnion(namedType);\n        } else {\n          return namedType;\n        }\n\n      case Token.FUNCTION:\n        ObjectType thisType = null;\n        boolean isConstructor = false;\n        Node current = n.getFirstChild();\n        if (current.getType() == Token.THIS ||\n            current.getType() == Token.NEW) {\n          Node contextNode = current.getFirstChild();\n          thisType =\n              ObjectType.cast(\n                  createFromTypeNodesInternal(\n                      contextNode, sourceName, scope)\n                  .restrictByNotNullOrUndefined());\n          if (thisType == null) {\n            reporter.warning(\n                ScriptRuntime.getMessage0(\n                    current.getType() == Token.THIS ?\n                    \"msg.jsdoc.function.thisnotobject\" :\n                    \"msg.jsdoc.function.newnotobject\"),\n                sourceName,\n                contextNode.getLineno(), \"\", contextNode.getCharno());\n          }\n\n          isConstructor = current.getType() == Token.NEW;\n          current = current.getNext();\n        }\n\n        FunctionParamBuilder paramBuilder = new FunctionParamBuilder(this);\n\n        if (current.getType() == Token.LP) {\n          Node args = current.getFirstChild();\n          for (Node arg = current.getFirstChild(); arg != null;\n               arg = arg.getNext()) {\n            if (arg.getType() == Token.ELLIPSIS) {\n              if (arg.getChildCount() == 0) {\n                paramBuilder.addVarArgs(getNativeType(UNKNOWN_TYPE));\n              } else {\n                paramBuilder.addVarArgs(\n                    createFromTypeNodesInternal(\n                        arg.getFirstChild(), sourceName, scope));\n              }\n            } else {\n              JSType type = createFromTypeNodesInternal(\n                  arg, sourceName, scope);\n              if (arg.getType() == Token.EQUALS) {\n                boolean addSuccess = paramBuilder.addOptionalParams(type);\n                if (!addSuccess) {\n                  reporter.warning(\n                      ScriptRuntime.getMessage0(\"msg.jsdoc.function.varargs\"),\n                      sourceName, arg.getLineno(), \"\", arg.getCharno());\n                }\n              } else {\n                paramBuilder.addRequiredParams(type);\n              }\n            }\n          }\n          current = current.getNext();\n        }\n\n        JSType returnType =\n            createFromTypeNodesInternal(current, sourceName, scope);\n\n        return new FunctionBuilder(this)\n            .withParams(paramBuilder)\n            .withReturnType(returnType)\n            .withTypeOfThis(thisType)\n            .setIsConstructor(isConstructor)\n            .build();\n    }\n\n    throw new IllegalStateException(\n        \"Unexpected node in type expression: \" + n.toString());\n  }",
    "comment": "@see #createFromTypeNodes(Node, String, StaticScope, boolean) */",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "JSTypeRegistry.createFunctionType",
    "class_name": "com.google.javascript.rhino.jstype.JSTypeRegistry",
    "signature": "com.google.javascript.rhino.jstype.JSTypeRegistry.createFunctionType(JSType,Node)",
    "snippet": "  public FunctionType createFunctionType(\n      JSType returnType, Node parameters) {\n    return new FunctionBuilder(this)\n        .withParamsNode(parameters)\n        .withReturnType(returnType)\n        .build();\n  }",
    "comment": " @param parameters the function's parameters or {@code null} to indicate that the parameter types are unknown. @param returnType the function's return type or {@code null} to indicate that the return type is unknown. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "JSTypeRegistry.createFunctionType",
    "class_name": "com.google.javascript.rhino.jstype.JSTypeRegistry",
    "signature": "com.google.javascript.rhino.jstype.JSTypeRegistry.createFunctionType(JSType,boolean,JSType[])",
    "snippet": "  public FunctionType createFunctionType(JSType returnType,\n      boolean lastVarArgs, JSType... parameterTypes) {\n    if (lastVarArgs) {\n      return createFunctionTypeWithVarArgs(returnType, parameterTypes);\n    } else {\n      return createFunctionType(returnType, parameterTypes);\n    }\n  }",
    "comment": " Creates a function type. @param returnType the function's return type @param lastVarArgs whether the last parameter type should be considered as an extensible var_args parameter @param parameterTypes the parameters' types ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "JSTypeRegistry.createFunctionTypeWithVarArgs",
    "class_name": "com.google.javascript.rhino.jstype.JSTypeRegistry",
    "signature": "com.google.javascript.rhino.jstype.JSTypeRegistry.createFunctionTypeWithVarArgs(JSType,JSType[])",
    "snippet": "  public FunctionType createFunctionTypeWithVarArgs(\n      JSType returnType, JSType... parameterTypes) {\n    return createFunctionType(\n        returnType, createParametersWithVarArgs(parameterTypes));\n  }",
    "comment": " Creates a function type. The last parameter type of the function is considered a variable length argument.  @param returnType the function's return type @param parameterTypes the parameters' types ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "JSTypeRegistry.createNullableType",
    "class_name": "com.google.javascript.rhino.jstype.JSTypeRegistry",
    "signature": "com.google.javascript.rhino.jstype.JSTypeRegistry.createNullableType(JSType)",
    "snippet": "  public JSType createNullableType(JSType type) {\n    return createUnionType(type, getNativeType(JSTypeNative.NULL_TYPE));\n  }",
    "comment": " Creates a type representing nullable values of the given type. @return the union of the type and the Null type ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "JSTypeRegistry.createOptionalParameters",
    "class_name": "com.google.javascript.rhino.jstype.JSTypeRegistry",
    "signature": "com.google.javascript.rhino.jstype.JSTypeRegistry.createOptionalParameters(JSType[])",
    "snippet": "  public Node createOptionalParameters(JSType... parameterTypes) {\n    FunctionParamBuilder builder = new FunctionParamBuilder(this);\n    builder.addOptionalParams(parameterTypes);\n    return builder.build();\n  }",
    "comment": " Creates a tree hierarchy representing a typed parameter list in which every parameter is optional. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "JSTypeRegistry.createOptionalType",
    "class_name": "com.google.javascript.rhino.jstype.JSTypeRegistry",
    "signature": "com.google.javascript.rhino.jstype.JSTypeRegistry.createOptionalType(JSType)",
    "snippet": "  public JSType createOptionalType(JSType type) {\n    if (type instanceof UnknownType || type.isAllType()) {\n      return type;\n    } else {\n      return createUnionType(type, getNativeType(JSTypeNative.VOID_TYPE));\n    }\n  }",
    "comment": " Creates a type representing optional values of the given type. @return the union of the type and the void type ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "JSTypeRegistry.createParameters",
    "class_name": "com.google.javascript.rhino.jstype.JSTypeRegistry",
    "signature": "com.google.javascript.rhino.jstype.JSTypeRegistry.createParameters(boolean,JSType[])",
    "snippet": "  private Node createParameters(boolean lastVarArgs, JSType... parameterTypes) {\n    FunctionParamBuilder builder = new FunctionParamBuilder(this);\n    int max = parameterTypes.length - 1;\n    for (int i = 0; i <= max; i++) {\n      if (lastVarArgs && i == max) {\n        builder.addVarArgs(parameterTypes[i]);\n      } else {\n        builder.addRequiredParams(parameterTypes[i]);\n      }\n    }\n    return builder.build();\n  }",
    "comment": " Creates a tree hierarchy representing a typed argument list.  @param lastVarArgs whether the last type should considered as a variable length argument. @param parameterTypes the parameter types. The last element of this array is considered a variable length argument is {@code lastVarArgs} is {@code true}. @return a tree hierarchy representing a typed argument list ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "JSTypeRegistry.createParametersWithVarArgs",
    "class_name": "com.google.javascript.rhino.jstype.JSTypeRegistry",
    "signature": "com.google.javascript.rhino.jstype.JSTypeRegistry.createParametersWithVarArgs(JSType[])",
    "snippet": "  public Node createParametersWithVarArgs(JSType... parameterTypes) {\n    return createParameters(true, parameterTypes);\n  }",
    "comment": " Creates a tree hierarchy representing a typed argument list. The last parameter type is considered a variable length argument.  @param parameterTypes the parameter types. The last element of this array is considered a variable length argument. @return a tree hierarchy representing a typed argument list. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "JSTypeRegistry.createUnionType",
    "class_name": "com.google.javascript.rhino.jstype.JSTypeRegistry",
    "signature": "com.google.javascript.rhino.jstype.JSTypeRegistry.createUnionType(JSTypeNative[])",
    "snippet": "  public JSType createUnionType(JSTypeNative... variants) {\n    UnionTypeBuilder builder = new UnionTypeBuilder(this);\n    for (JSTypeNative typeId : variants) {\n      builder.addAlternate(getNativeType(typeId));\n    }\n    return builder.build();\n  }",
    "comment": " Creates a union type whose variants are the builtin types specified by the arguments. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "JSTypeRegistry.createUnionType",
    "class_name": "com.google.javascript.rhino.jstype.JSTypeRegistry",
    "signature": "com.google.javascript.rhino.jstype.JSTypeRegistry.createUnionType(JSType[])",
    "snippet": "  public JSType createUnionType(JSType... variants) {\n    UnionTypeBuilder builder = new UnionTypeBuilder(this);\n    for (JSType type : variants) {\n      builder.addAlternate(type);\n    }\n    return builder.build();\n  }",
    "comment": " Creates a union type whose variants are the arguments. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "JSTypeRegistry.declareType",
    "class_name": "com.google.javascript.rhino.jstype.JSTypeRegistry",
    "signature": "com.google.javascript.rhino.jstype.JSTypeRegistry.declareType(String,JSType)",
    "snippet": "  public boolean declareType(String name, JSType t) {\n    if (namesToTypes.containsKey(name)) {\n      return false;\n    }\n    register(t, name);\n    return true;\n  }",
    "comment": " Records declared global type names. This makes resolution faster and more robust in the common case.  @param name The name of the type to be recorded. @param t The actual type being associated with the name. @return True if this name is not already defined, false otherwise. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "JSTypeRegistry.getErrorReporter",
    "class_name": "com.google.javascript.rhino.jstype.JSTypeRegistry",
    "signature": "com.google.javascript.rhino.jstype.JSTypeRegistry.getErrorReporter()",
    "snippet": "  public ErrorReporter getErrorReporter() {\n    return reporter;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "JSTypeRegistry.getNativeFunctionType",
    "class_name": "com.google.javascript.rhino.jstype.JSTypeRegistry",
    "signature": "com.google.javascript.rhino.jstype.JSTypeRegistry.getNativeFunctionType(JSTypeNative)",
    "snippet": "  public FunctionType getNativeFunctionType(JSTypeNative typeId) {\n    return (FunctionType) getNativeType(typeId);\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "JSTypeRegistry.getNativeObjectType",
    "class_name": "com.google.javascript.rhino.jstype.JSTypeRegistry",
    "signature": "com.google.javascript.rhino.jstype.JSTypeRegistry.getNativeObjectType(JSTypeNative)",
    "snippet": "  public ObjectType getNativeObjectType(JSTypeNative typeId) {\n    return (ObjectType) getNativeType(typeId);\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "JSTypeRegistry.getNativeType",
    "class_name": "com.google.javascript.rhino.jstype.JSTypeRegistry",
    "signature": "com.google.javascript.rhino.jstype.JSTypeRegistry.getNativeType(JSTypeNative)",
    "snippet": "  public JSType getNativeType(JSTypeNative typeId) {\n    return nativeTypes[typeId.ordinal()];\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "JSTypeRegistry.getType",
    "class_name": "com.google.javascript.rhino.jstype.JSTypeRegistry",
    "signature": "com.google.javascript.rhino.jstype.JSTypeRegistry.getType(StaticScope,String,String,int,int)",
    "snippet": "  public JSType getType(StaticScope<JSType> scope, String jsTypeName,\n      String sourceName, int lineno, int charno) {\n    JSType type = getType(jsTypeName);\n    if (type == null) {\n      // TODO(user): Each instance should support named type creation using\n      // interning.\n      NamedType namedType =\n          new NamedType(this, jsTypeName, sourceName, lineno, charno);\n      unresolvedNamedTypes.put(scope, namedType);\n      type = namedType;\n    }\n    return type;\n  }",
    "comment": " Looks up a type by name. To allow for forward references to types, an unrecognized string has to be bound to a NamedType object that will be resolved later.  @param scope A scope for doing type name resolution. @param jsTypeName The name string. @param sourceName The name of the source file where this reference appears. @param lineno The line number of the reference. @return a NamedType if the string argument is not one of the known types, otherwise the corresponding JSType object. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "JSTypeRegistry.getType",
    "class_name": "com.google.javascript.rhino.jstype.JSTypeRegistry",
    "signature": "com.google.javascript.rhino.jstype.JSTypeRegistry.getType(String)",
    "snippet": "  public JSType getType(String jsTypeName) {\n    // TODO(user): Push every local type name out of namesToTypes so that\n    // NamedType#resolve is correct.\n    if (jsTypeName.equals(templateTypeName)) {\n      return templateType;\n    }\n    return namesToTypes.get(jsTypeName);\n  }",
    "comment": " Looks up a type by name.  @param jsTypeName The name string. @return the corresponding JSType object or {@code null} it cannot be found ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "JSTypeRegistry.initializeBuiltInTypes",
    "class_name": "com.google.javascript.rhino.jstype.JSTypeRegistry",
    "signature": "com.google.javascript.rhino.jstype.JSTypeRegistry.initializeBuiltInTypes()",
    "snippet": "  private void initializeBuiltInTypes() {\n    // These locals shouldn't be all caps.\n    BooleanType BOOLEAN_TYPE = new BooleanType(this);\n    registerNativeType(JSTypeNative.BOOLEAN_TYPE, BOOLEAN_TYPE);\n\n    NullType NULL_TYPE = new NullType(this);\n    registerNativeType(JSTypeNative.NULL_TYPE, NULL_TYPE);\n\n    NumberType NUMBER_TYPE = new NumberType(this);\n    registerNativeType(JSTypeNative.NUMBER_TYPE, NUMBER_TYPE);\n\n    StringType STRING_TYPE = new StringType(this);\n    registerNativeType(JSTypeNative.STRING_TYPE, STRING_TYPE);\n\n    UnknownType UNKNOWN_TYPE = new UnknownType(this, false);\n    registerNativeType(JSTypeNative.UNKNOWN_TYPE, UNKNOWN_TYPE);\n    registerNativeType(\n        JSTypeNative.CHECKED_UNKNOWN_TYPE, new UnknownType(this, true));\n\n    VoidType VOID_TYPE = new VoidType(this);\n    registerNativeType(JSTypeNative.VOID_TYPE, VOID_TYPE);\n\n    AllType ALL_TYPE = new AllType(this);\n    registerNativeType(JSTypeNative.ALL_TYPE, ALL_TYPE);\n\n    // Top Level Prototype (the One)\n    // The initializations of TOP_LEVEL_PROTOTYPE and OBJECT_FUNCTION_TYPE\n    // use each other's results, so at least one of them will get null\n    // instead of an actual type; however, this seems to be benign.\n    ObjectType TOP_LEVEL_PROTOTYPE =\n        new FunctionPrototypeType(this, null, null, true);\n    registerNativeType(JSTypeNative.TOP_LEVEL_PROTOTYPE, TOP_LEVEL_PROTOTYPE);\n\n    // Object\n    FunctionType OBJECT_FUNCTION_TYPE =\n        new FunctionType(this, \"Object\", null,\n            createArrowType(createOptionalParameters(ALL_TYPE), UNKNOWN_TYPE),\n            null, null, true, true);\n    OBJECT_FUNCTION_TYPE.defineDeclaredProperty(\n        \"prototype\", TOP_LEVEL_PROTOTYPE, null);\n    registerNativeType(JSTypeNative.OBJECT_FUNCTION_TYPE, OBJECT_FUNCTION_TYPE);\n\n    ObjectType OBJECT_PROTOTYPE = OBJECT_FUNCTION_TYPE.getPrototype();\n    registerNativeType(JSTypeNative.OBJECT_PROTOTYPE, OBJECT_PROTOTYPE);\n\n    ObjectType OBJECT_TYPE = OBJECT_FUNCTION_TYPE.getInstanceType();\n    registerNativeType(JSTypeNative.OBJECT_TYPE, OBJECT_TYPE);\n\n    // Function\n    FunctionType FUNCTION_FUNCTION_TYPE =\n        new FunctionType(this, \"Function\", null,\n            createArrowType(\n                createParametersWithVarArgs(ALL_TYPE), UNKNOWN_TYPE),\n            null, null, true, true);\n    FUNCTION_FUNCTION_TYPE.setPrototypeBasedOn(OBJECT_TYPE);\n    registerNativeType(\n        JSTypeNative.FUNCTION_FUNCTION_TYPE, FUNCTION_FUNCTION_TYPE);\n\n    ObjectType FUNCTION_PROTOTYPE = FUNCTION_FUNCTION_TYPE.getPrototype();\n    registerNativeType(JSTypeNative.FUNCTION_PROTOTYPE, FUNCTION_PROTOTYPE);\n\n    NoType NO_TYPE = new NoType(this);\n    registerNativeType(JSTypeNative.NO_TYPE, NO_TYPE);\n\n    NoObjectType NO_OBJECT_TYPE = new NoObjectType(this);\n    registerNativeType(JSTypeNative.NO_OBJECT_TYPE, NO_OBJECT_TYPE);\n\n    NoObjectType NO_RESOLVED_TYPE = new NoResolvedType(this);\n    registerNativeType(JSTypeNative.NO_RESOLVED_TYPE, NO_RESOLVED_TYPE);\n\n    // Array\n    FunctionType ARRAY_FUNCTION_TYPE =\n      new FunctionType(this, \"Array\", null,\n          createArrowType(createParametersWithVarArgs(ALL_TYPE), null),\n          null, null, true, true);\n    ARRAY_FUNCTION_TYPE.getInternalArrowType().returnType =\n        ARRAY_FUNCTION_TYPE.getInstanceType();\n\n    ObjectType arrayPrototype = ARRAY_FUNCTION_TYPE.getPrototype();\n    registerNativeType(JSTypeNative.ARRAY_FUNCTION_TYPE, ARRAY_FUNCTION_TYPE);\n\n    ObjectType ARRAY_TYPE = ARRAY_FUNCTION_TYPE.getInstanceType();\n    registerNativeType(JSTypeNative.ARRAY_TYPE, ARRAY_TYPE);\n\n    // Boolean\n    FunctionType BOOLEAN_OBJECT_FUNCTION_TYPE =\n        new FunctionType(this, \"Boolean\", null,\n            createArrowType(createParameters(false, ALL_TYPE), BOOLEAN_TYPE),\n            null, null, true, true);\n    ObjectType booleanPrototype = BOOLEAN_OBJECT_FUNCTION_TYPE.getPrototype();\n    registerNativeType(\n        JSTypeNative.BOOLEAN_OBJECT_FUNCTION_TYPE,\n        BOOLEAN_OBJECT_FUNCTION_TYPE);\n\n    ObjectType BOOLEAN_OBJECT_TYPE =\n        BOOLEAN_OBJECT_FUNCTION_TYPE.getInstanceType();\n    registerNativeType(JSTypeNative.BOOLEAN_OBJECT_TYPE, BOOLEAN_OBJECT_TYPE);\n\n    // Date\n    FunctionType DATE_FUNCTION_TYPE =\n      new FunctionType(this, \"Date\", null,\n          createArrowType(\n              createOptionalParameters(UNKNOWN_TYPE, UNKNOWN_TYPE, UNKNOWN_TYPE,\n                  UNKNOWN_TYPE, UNKNOWN_TYPE, UNKNOWN_TYPE, UNKNOWN_TYPE),\n              STRING_TYPE),\n          null, null, true, true);\n    ObjectType datePrototype = DATE_FUNCTION_TYPE.getPrototype();\n    registerNativeType(JSTypeNative.DATE_FUNCTION_TYPE, DATE_FUNCTION_TYPE);\n\n    ObjectType DATE_TYPE = DATE_FUNCTION_TYPE.getInstanceType();\n    registerNativeType(JSTypeNative.DATE_TYPE, DATE_TYPE);\n\n    // Error\n    FunctionType ERROR_FUNCTION_TYPE = new ErrorFunctionType(this, \"Error\");\n    registerNativeType(JSTypeNative.ERROR_FUNCTION_TYPE, ERROR_FUNCTION_TYPE);\n\n    ObjectType ERROR_TYPE = ERROR_FUNCTION_TYPE.getInstanceType();\n    registerNativeType(JSTypeNative.ERROR_TYPE, ERROR_TYPE);\n\n    // EvalError\n    FunctionType EVAL_ERROR_FUNCTION_TYPE =\n        new ErrorFunctionType(this, \"EvalError\");\n    EVAL_ERROR_FUNCTION_TYPE.setPrototypeBasedOn(ERROR_TYPE);\n    registerNativeType(\n        JSTypeNative.EVAL_ERROR_FUNCTION_TYPE, EVAL_ERROR_FUNCTION_TYPE);\n\n    ObjectType EVAL_ERROR_TYPE = EVAL_ERROR_FUNCTION_TYPE.getInstanceType();\n    registerNativeType(JSTypeNative.EVAL_ERROR_TYPE, EVAL_ERROR_TYPE);\n\n    // RangeError\n    FunctionType RANGE_ERROR_FUNCTION_TYPE =\n        new ErrorFunctionType(this, \"RangeError\");\n    RANGE_ERROR_FUNCTION_TYPE.setPrototypeBasedOn(ERROR_TYPE);\n    registerNativeType(\n        JSTypeNative.RANGE_ERROR_FUNCTION_TYPE, RANGE_ERROR_FUNCTION_TYPE);\n\n    ObjectType RANGE_ERROR_TYPE = RANGE_ERROR_FUNCTION_TYPE.getInstanceType();\n    registerNativeType(JSTypeNative.RANGE_ERROR_TYPE, RANGE_ERROR_TYPE);\n\n    // ReferenceError\n    FunctionType REFERENCE_ERROR_FUNCTION_TYPE =\n        new ErrorFunctionType(this, \"ReferenceError\");\n    REFERENCE_ERROR_FUNCTION_TYPE.setPrototypeBasedOn(ERROR_TYPE);\n    registerNativeType(\n        JSTypeNative.REFERENCE_ERROR_FUNCTION_TYPE,\n        REFERENCE_ERROR_FUNCTION_TYPE);\n\n    ObjectType REFERENCE_ERROR_TYPE =\n        REFERENCE_ERROR_FUNCTION_TYPE.getInstanceType();\n    registerNativeType(JSTypeNative.REFERENCE_ERROR_TYPE, REFERENCE_ERROR_TYPE);\n\n    // SyntaxError\n    FunctionType SYNTAX_ERROR_FUNCTION_TYPE =\n        new ErrorFunctionType(this, \"SyntaxError\");\n    SYNTAX_ERROR_FUNCTION_TYPE.setPrototypeBasedOn(ERROR_TYPE);\n    registerNativeType(\n        JSTypeNative.SYNTAX_ERROR_FUNCTION_TYPE, SYNTAX_ERROR_FUNCTION_TYPE);\n\n    ObjectType SYNTAX_ERROR_TYPE = SYNTAX_ERROR_FUNCTION_TYPE.getInstanceType();\n    registerNativeType(JSTypeNative.SYNTAX_ERROR_TYPE, SYNTAX_ERROR_TYPE);\n\n    // TypeError\n    FunctionType TYPE_ERROR_FUNCTION_TYPE =\n        new ErrorFunctionType(this, \"TypeError\");\n    TYPE_ERROR_FUNCTION_TYPE.setPrototypeBasedOn(ERROR_TYPE);\n    registerNativeType(\n        JSTypeNative.TYPE_ERROR_FUNCTION_TYPE, TYPE_ERROR_FUNCTION_TYPE);\n\n    ObjectType TYPE_ERROR_TYPE = TYPE_ERROR_FUNCTION_TYPE.getInstanceType();\n    registerNativeType(JSTypeNative.TYPE_ERROR_TYPE, TYPE_ERROR_TYPE);\n\n    // URIError\n    FunctionType URI_ERROR_FUNCTION_TYPE =\n        new ErrorFunctionType(this, \"URIError\");\n    URI_ERROR_FUNCTION_TYPE.setPrototypeBasedOn(ERROR_TYPE);\n    registerNativeType(\n        JSTypeNative.URI_ERROR_FUNCTION_TYPE, URI_ERROR_FUNCTION_TYPE);\n\n    ObjectType URI_ERROR_TYPE = URI_ERROR_FUNCTION_TYPE.getInstanceType();\n    registerNativeType(JSTypeNative.URI_ERROR_TYPE, URI_ERROR_TYPE);\n\n    // Number\n    FunctionType NUMBER_OBJECT_FUNCTION_TYPE =\n        new FunctionType(this, \"Number\", null,\n            createArrowType(createParameters(false, ALL_TYPE), NUMBER_TYPE),\n            null, null, true, true);\n    ObjectType numberPrototype = NUMBER_OBJECT_FUNCTION_TYPE.getPrototype();\n    registerNativeType(\n        JSTypeNative.NUMBER_OBJECT_FUNCTION_TYPE, NUMBER_OBJECT_FUNCTION_TYPE);\n\n    ObjectType NUMBER_OBJECT_TYPE =\n        NUMBER_OBJECT_FUNCTION_TYPE.getInstanceType();\n    registerNativeType(JSTypeNative.NUMBER_OBJECT_TYPE, NUMBER_OBJECT_TYPE);\n\n    // RegExp\n    FunctionType REGEXP_FUNCTION_TYPE =\n      new FunctionType(this, \"RegExp\", null,\n          createArrowType(createOptionalParameters(ALL_TYPE, ALL_TYPE)),\n          null, null, true, true);\n    REGEXP_FUNCTION_TYPE.getInternalArrowType().returnType =\n        REGEXP_FUNCTION_TYPE.getInstanceType();\n\n    ObjectType regexpPrototype = REGEXP_FUNCTION_TYPE.getPrototype();\n    registerNativeType(JSTypeNative.REGEXP_FUNCTION_TYPE, REGEXP_FUNCTION_TYPE);\n\n    ObjectType REGEXP_TYPE = REGEXP_FUNCTION_TYPE.getInstanceType();\n    registerNativeType(JSTypeNative.REGEXP_TYPE, REGEXP_TYPE);\n\n    // String\n    FunctionType STRING_OBJECT_FUNCTION_TYPE =\n        new FunctionType(this, \"String\", null,\n            createArrowType(createParameters(false, ALL_TYPE), STRING_TYPE),\n            null, null, true, true);\n    ObjectType stringPrototype = STRING_OBJECT_FUNCTION_TYPE.getPrototype();\n    registerNativeType(\n        JSTypeNative.STRING_OBJECT_FUNCTION_TYPE, STRING_OBJECT_FUNCTION_TYPE);\n\n    ObjectType STRING_OBJECT_TYPE =\n        STRING_OBJECT_FUNCTION_TYPE.getInstanceType();\n    registerNativeType(\n        JSTypeNative.STRING_OBJECT_TYPE, STRING_OBJECT_TYPE);\n\n    // (Object,string,number)\n    JSType OBJECT_NUMBER_STRING =\n        createUnionType(OBJECT_TYPE, NUMBER_TYPE, STRING_TYPE);\n    registerNativeType(JSTypeNative.OBJECT_NUMBER_STRING, OBJECT_NUMBER_STRING);\n\n    // (Object,string,number,boolean)\n    JSType OBJECT_NUMBER_STRING_BOOLEAN =\n        createUnionType(OBJECT_TYPE, NUMBER_TYPE, STRING_TYPE, BOOLEAN_TYPE);\n    registerNativeType(JSTypeNative.OBJECT_NUMBER_STRING_BOOLEAN,\n        OBJECT_NUMBER_STRING_BOOLEAN);\n\n    // (string,number,boolean)\n    JSType NUMBER_STRING_BOOLEAN =\n        createUnionType(NUMBER_TYPE, STRING_TYPE, BOOLEAN_TYPE);\n    registerNativeType(JSTypeNative.NUMBER_STRING_BOOLEAN,\n        NUMBER_STRING_BOOLEAN);\n\n    // (string,number)\n    JSType NUMBER_STRING = createUnionType(NUMBER_TYPE, STRING_TYPE);\n    registerNativeType(JSTypeNative.NUMBER_STRING, NUMBER_STRING);\n\n    // Native object properties are filled in by externs...\n\n    // (String, string)\n    JSType STRING_VALUE_OR_OBJECT_TYPE =\n        createUnionType(STRING_OBJECT_TYPE, STRING_TYPE);\n    registerNativeType(\n        JSTypeNative.STRING_VALUE_OR_OBJECT_TYPE, STRING_VALUE_OR_OBJECT_TYPE);\n\n    // (Number, number)\n    JSType NUMBER_VALUE_OR_OBJECT_TYPE =\n        createUnionType(NUMBER_OBJECT_TYPE, NUMBER_TYPE);\n    registerNativeType(\n        JSTypeNative.NUMBER_VALUE_OR_OBJECT_TYPE, NUMBER_VALUE_OR_OBJECT_TYPE);\n\n    // unknown function type, i.e. (?...) -> ?\n    FunctionType U2U_FUNCTION_TYPE =\n        createFunctionType(UNKNOWN_TYPE, true, UNKNOWN_TYPE);\n    registerNativeType(JSTypeNative.U2U_FUNCTION_TYPE, U2U_FUNCTION_TYPE);\n\n    // unknown constructor type, i.e. (?...) -> ? with the NoObject type\n    // as instance type\n    FunctionType U2U_CONSTRUCTOR_TYPE =\n        // This is equivalent to\n        // createConstructorType(UNKNOWN_TYPE, true, UNKNOWN_TYPE), but,\n        // in addition, overrides getInstanceType() to return the NoObject type\n        // instead of a new anonymous object.\n        new FunctionType(this, \"Function\", null,\n            createArrowType(\n                createParametersWithVarArgs(UNKNOWN_TYPE),\n                UNKNOWN_TYPE),\n            NO_OBJECT_TYPE, null, true, true) {\n          private static final long serialVersionUID = 1L;\n\n          @Override public FunctionType getConstructor() {\n            return registry.getNativeFunctionType(\n                JSTypeNative.FUNCTION_FUNCTION_TYPE);\n          }\n        };\n\n    // The U2U_CONSTRUCTOR is weird, because it's the supertype of its\n    // own constructor.\n    registerNativeType(JSTypeNative.U2U_CONSTRUCTOR_TYPE, U2U_CONSTRUCTOR_TYPE);\n    registerNativeType(\n        JSTypeNative.FUNCTION_INSTANCE_TYPE, U2U_CONSTRUCTOR_TYPE);\n\n    FUNCTION_FUNCTION_TYPE.setInstanceType(U2U_CONSTRUCTOR_TYPE);\n    U2U_CONSTRUCTOR_TYPE.setImplicitPrototype(FUNCTION_PROTOTYPE);\n\n    // least function type, i.e. (All...) -> NoType\n    FunctionType LEAST_FUNCTION_TYPE =\n        createFunctionType(NO_TYPE, true, ALL_TYPE);\n    registerNativeType(JSTypeNative.LEAST_FUNCTION_TYPE, LEAST_FUNCTION_TYPE);\n\n    // the 'this' object in the global scope\n    FunctionType GLOBAL_THIS_CTOR =\n        new FunctionType(this, \"global this\", null,\n            createArrowType(createParameters(false, ALL_TYPE), NUMBER_TYPE),\n            null, null, true, true);\n    ObjectType GLOBAL_THIS = GLOBAL_THIS_CTOR.getInstanceType();\n    registerNativeType(JSTypeNative.GLOBAL_THIS, GLOBAL_THIS);\n\n    // greatest function type, i.e. (NoType...) -> All\n    FunctionType GREATEST_FUNCTION_TYPE =\n      createFunctionType(ALL_TYPE, true, NO_TYPE);\n    registerNativeType(JSTypeNative.GREATEST_FUNCTION_TYPE,\n        GREATEST_FUNCTION_TYPE);\n\n    // Register the prototype property. See the comments below in\n    // registerPropertyOnType about the bootstrapping process.\n    registerPropertyOnType(\"prototype\", OBJECT_FUNCTION_TYPE);\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "JSTypeRegistry.initializeRegistry",
    "class_name": "com.google.javascript.rhino.jstype.JSTypeRegistry",
    "signature": "com.google.javascript.rhino.jstype.JSTypeRegistry.initializeRegistry()",
    "snippet": "  private void initializeRegistry() {\n    register(getNativeType(JSTypeNative.ARRAY_TYPE));\n    register(getNativeType(JSTypeNative.BOOLEAN_OBJECT_TYPE));\n    register(getNativeType(JSTypeNative.BOOLEAN_TYPE));\n    register(getNativeType(JSTypeNative.DATE_TYPE));\n    register(getNativeType(JSTypeNative.NULL_TYPE));\n    register(getNativeType(JSTypeNative.NULL_TYPE), \"Null\");\n    register(getNativeType(JSTypeNative.NUMBER_OBJECT_TYPE));\n    register(getNativeType(JSTypeNative.NUMBER_TYPE));\n    register(getNativeType(JSTypeNative.OBJECT_TYPE));\n    register(getNativeType(JSTypeNative.ERROR_TYPE));\n    register(getNativeType(JSTypeNative.URI_ERROR_TYPE));\n    register(getNativeType(JSTypeNative.EVAL_ERROR_TYPE));\n    register(getNativeType(JSTypeNative.TYPE_ERROR_TYPE));\n    register(getNativeType(JSTypeNative.RANGE_ERROR_TYPE));\n    register(getNativeType(JSTypeNative.REFERENCE_ERROR_TYPE));\n    register(getNativeType(JSTypeNative.SYNTAX_ERROR_TYPE));\n    register(getNativeType(JSTypeNative.REGEXP_TYPE));\n    register(getNativeType(JSTypeNative.STRING_OBJECT_TYPE));\n    register(getNativeType(JSTypeNative.STRING_TYPE));\n    register(getNativeType(JSTypeNative.VOID_TYPE));\n    register(getNativeType(JSTypeNative.VOID_TYPE), \"Undefined\");\n    register(getNativeType(JSTypeNative.VOID_TYPE), \"void\");\n    register(getNativeType(JSTypeNative.FUNCTION_INSTANCE_TYPE), \"Function\");\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "JSTypeRegistry.register",
    "class_name": "com.google.javascript.rhino.jstype.JSTypeRegistry",
    "signature": "com.google.javascript.rhino.jstype.JSTypeRegistry.register(JSType)",
    "snippet": "  private void register(JSType type) {\n    register(type, type.toString());\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "JSTypeRegistry.register",
    "class_name": "com.google.javascript.rhino.jstype.JSTypeRegistry",
    "signature": "com.google.javascript.rhino.jstype.JSTypeRegistry.register(JSType,String)",
    "snippet": "  private void register(JSType type, String name) {\n    namesToTypes.put(name, type);\n\n    // Add all the namespaces in which this name lives.\n    while (name.indexOf('.') > 0) {\n      name = name.substring(0, name.lastIndexOf('.'));\n      namespaces.add(name);\n    }\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "JSTypeRegistry.registerNativeType",
    "class_name": "com.google.javascript.rhino.jstype.JSTypeRegistry",
    "signature": "com.google.javascript.rhino.jstype.JSTypeRegistry.registerNativeType(JSTypeNative,JSType)",
    "snippet": "  private void registerNativeType(JSTypeNative typeId, JSType type) {\n    nativeTypes[typeId.ordinal()] = type;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "JSTypeRegistry.registerPropertyOnType",
    "class_name": "com.google.javascript.rhino.jstype.JSTypeRegistry",
    "signature": "com.google.javascript.rhino.jstype.JSTypeRegistry.registerPropertyOnType(String,JSType)",
    "snippet": "  public void registerPropertyOnType(String propertyName, JSType type) {\n    UnionTypeBuilder typeSet = typesIndexedByProperty.get(propertyName);\n    if (typeSet == null) {\n      typeSet = new UnionTypeBuilder(this);\n      typesIndexedByProperty.put(propertyName, typeSet);\n    }\n\n    typeSet.addAlternate(type);\n    addReferenceTypeIndexedByProperty(propertyName, type);\n\n    // Clear cached values that depend on typesIndexedByProperty.\n    greatestSubtypeByProperty.remove(propertyName);\n  }",
    "comment": " Tells the type system that {@code owner} may have a property named {@code propertyName}. This allows the registry to keep track of what types a property is defined upon.  This is NOT the same as saying that {@code owner} must have a property named type. ObjectType#hasProperty attempts to minimize false positives (\"if we're not sure, then don't type check this property\"). The type registry, on the other hand, should attempt to minimize false negatives (\"if this property is assigned anywhere in the program, it must show up in the type registry\"). ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "JSTypeRegistry.resetForTypeCheck",
    "class_name": "com.google.javascript.rhino.jstype.JSTypeRegistry",
    "signature": "com.google.javascript.rhino.jstype.JSTypeRegistry.resetForTypeCheck()",
    "snippet": "  public void resetForTypeCheck() {\n    typesIndexedByProperty.clear();\n    eachRefTypeIndexedByProperty.clear();\n    initializeBuiltInTypes();\n    namesToTypes.clear();\n    namespaces.clear();\n    initializeRegistry();\n  }",
    "comment": " Reset to run the TypeCheck pass. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "JSTypeRegistry.resolveTypesInScope",
    "class_name": "com.google.javascript.rhino.jstype.JSTypeRegistry",
    "signature": "com.google.javascript.rhino.jstype.JSTypeRegistry.resolveTypesInScope(StaticScope)",
    "snippet": "  public void resolveTypesInScope(StaticScope<JSType> scope) {\n    for (NamedType type : unresolvedNamedTypes.get(scope)) {\n      type.resolve(reporter, scope);\n    }\n\n    resolvedNamedTypes.putAll(scope, unresolvedNamedTypes.removeAll(scope));\n\n    if (scope != null && scope.getParentScope() == null) {\n      // By default, the global \"this\" type is just an anonymous object.\n      // If the user has defined a Window type, make the Window the\n      // implicit prototype of \"this\".\n      PrototypeObjectType globalThis = (PrototypeObjectType) getNativeType(\n          JSTypeNative.GLOBAL_THIS);\n      JSType windowType = getType(\"Window\");\n      if (globalThis.isUnknownType()) {\n        ObjectType windowObjType = ObjectType.cast(windowType);\n        if (windowObjType != null) {\n          globalThis.setImplicitPrototype(windowObjType);\n        } else {\n          globalThis.setImplicitPrototype(\n              getNativeObjectType(JSTypeNative.OBJECT_TYPE));\n        }\n      }\n    }\n  }",
    "comment": " Resolve all the unresolved types in the given scope. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "JSTypeRegistry.setTemplateTypeName",
    "class_name": "com.google.javascript.rhino.jstype.JSTypeRegistry",
    "signature": "com.google.javascript.rhino.jstype.JSTypeRegistry.setTemplateTypeName(String)",
    "snippet": "  public void setTemplateTypeName(String name) {\n    templateTypeName = name;\n    templateType = new TemplateType(this, name);\n  }",
    "comment": " Sets the template type name. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "JSTypeRegistry.shouldTolerateUndefinedValues",
    "class_name": "com.google.javascript.rhino.jstype.JSTypeRegistry",
    "signature": "com.google.javascript.rhino.jstype.JSTypeRegistry.shouldTolerateUndefinedValues()",
    "snippet": "  public boolean shouldTolerateUndefinedValues() {\n    return tolerateUndefinedValues;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "NoObjectType.NoObjectType",
    "class_name": "com.google.javascript.rhino.jstype.NoObjectType",
    "signature": "com.google.javascript.rhino.jstype.NoObjectType.NoObjectType(JSTypeRegistry)",
    "snippet": "  NoObjectType(JSTypeRegistry registry) {\n    super(registry, null, null,\n          registry.createArrowType(null, null),\n          null, null, true, true);\n    getInternalArrowType().returnType = this;\n    this.setInstanceType(this);\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "NoObjectType.resolveInternal",
    "class_name": "com.google.javascript.rhino.jstype.NoObjectType",
    "signature": "com.google.javascript.rhino.jstype.NoObjectType.resolveInternal(ErrorReporter,StaticScope)",
    "snippet": "  @Override\n  JSType resolveInternal(ErrorReporter t, StaticScope<JSType> scope) {\n    return this;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "NoResolvedType.NoResolvedType",
    "class_name": "com.google.javascript.rhino.jstype.NoResolvedType",
    "signature": "com.google.javascript.rhino.jstype.NoResolvedType.NoResolvedType(JSTypeRegistry)",
    "snippet": "  NoResolvedType(JSTypeRegistry registry) {\n    super(registry);\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "NoType.NoType",
    "class_name": "com.google.javascript.rhino.jstype.NoType",
    "signature": "com.google.javascript.rhino.jstype.NoType.NoType(JSTypeRegistry)",
    "snippet": "  NoType(JSTypeRegistry registry) {\n    super(registry);\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "NoType.isNoType",
    "class_name": "com.google.javascript.rhino.jstype.NoType",
    "signature": "com.google.javascript.rhino.jstype.NoType.isNoType()",
    "snippet": "  @Override\n  public boolean isNoType() {\n    return true;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "NullType.NullType",
    "class_name": "com.google.javascript.rhino.jstype.NullType",
    "signature": "com.google.javascript.rhino.jstype.NullType.NullType(JSTypeRegistry)",
    "snippet": "  NullType(JSTypeRegistry registry) {\n    super(registry);\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "NullType.getDisplayName",
    "class_name": "com.google.javascript.rhino.jstype.NullType",
    "signature": "com.google.javascript.rhino.jstype.NullType.getDisplayName()",
    "snippet": "  @Override\n  public String getDisplayName() {\n    return \"null\";\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "NullType.restrictByNotNullOrUndefined",
    "class_name": "com.google.javascript.rhino.jstype.NullType",
    "signature": "com.google.javascript.rhino.jstype.NullType.restrictByNotNullOrUndefined()",
    "snippet": "  @Override\n  public JSType restrictByNotNullOrUndefined() {\n    return registry.getNativeType(JSTypeNative.NO_TYPE);\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "NullType.toString",
    "class_name": "com.google.javascript.rhino.jstype.NullType",
    "signature": "com.google.javascript.rhino.jstype.NullType.toString()",
    "snippet": "  @Override\n  public String toString() {\n    return getDisplayName();\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "NumberType.NumberType",
    "class_name": "com.google.javascript.rhino.jstype.NumberType",
    "signature": "com.google.javascript.rhino.jstype.NumberType.NumberType(JSTypeRegistry)",
    "snippet": "  NumberType(JSTypeRegistry registry) {\n    super(registry);\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "NumberType.getDisplayName",
    "class_name": "com.google.javascript.rhino.jstype.NumberType",
    "signature": "com.google.javascript.rhino.jstype.NumberType.getDisplayName()",
    "snippet": "  @Override\n  public String getDisplayName() {\n    return \"number\";\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "NumberType.toString",
    "class_name": "com.google.javascript.rhino.jstype.NumberType",
    "signature": "com.google.javascript.rhino.jstype.NumberType.toString()",
    "snippet": "  @Override\n  public String toString() {\n    return getDisplayName();\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "ObjectType.ObjectType",
    "class_name": "com.google.javascript.rhino.jstype.ObjectType",
    "signature": "com.google.javascript.rhino.jstype.ObjectType.ObjectType(JSTypeRegistry)",
    "snippet": "  ObjectType(JSTypeRegistry registry) {\n    super(registry);\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "ObjectType.cast",
    "class_name": "com.google.javascript.rhino.jstype.ObjectType",
    "signature": "com.google.javascript.rhino.jstype.ObjectType.cast(JSType)",
    "snippet": "  public static ObjectType cast(JSType type) {\n    return type == null ? null : type.toObjectType();\n  }",
    "comment": " A null-safe version of JSType#toObjectType. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "ObjectType.clearCachedValues",
    "class_name": "com.google.javascript.rhino.jstype.ObjectType",
    "signature": "com.google.javascript.rhino.jstype.ObjectType.clearCachedValues()",
    "snippet": "  public void clearCachedValues() {\n    unknown = true;\n  }",
    "comment": " Clear cached values. Should be called before making changes to a prototype that may have been changed since creation. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "ObjectType.createDelegateSuffix",
    "class_name": "com.google.javascript.rhino.jstype.ObjectType",
    "signature": "com.google.javascript.rhino.jstype.ObjectType.createDelegateSuffix(String)",
    "snippet": "  public static String createDelegateSuffix(String suffix) {\n    return \"(\" + suffix + \")\";\n  }",
    "comment": " Creates a suffix for a proxy delegate. @see #getNormalizedReferenceName ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "ObjectType.defineDeclaredProperty",
    "class_name": "com.google.javascript.rhino.jstype.ObjectType",
    "signature": "com.google.javascript.rhino.jstype.ObjectType.defineDeclaredProperty(String,JSType,Node)",
    "snippet": "  public final boolean defineDeclaredProperty(String propertyName,\n      JSType type, Node propertyNode) {\n    boolean result = defineProperty(propertyName, type, false,\n        propertyNode);\n\n    // All property definitions go through this method\n    // or defineDeclaredProperty. Because the properties defined an an\n    // object can affect subtyping, it's slightly more efficient\n    // to register this after defining the property.\n    registry.registerPropertyOnType(propertyName, this);\n\n    return result;\n  }",
    "comment": " Defines a property whose type is synthesized (i.e. not inferred). @param propertyName the property's name @param type the type @param propertyNode the node corresponding to the declaration of property which might later be accessed using {@code getPropertyNode}. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "ObjectType.defineInferredProperty",
    "class_name": "com.google.javascript.rhino.jstype.ObjectType",
    "signature": "com.google.javascript.rhino.jstype.ObjectType.defineInferredProperty(String,JSType,Node)",
    "snippet": "  public final boolean defineInferredProperty(String propertyName,\n      JSType type, Node propertyNode) {\n    if (hasProperty(propertyName)) {\n      JSType originalType = getPropertyType(propertyName);\n      type = originalType == null ? type :\n          originalType.getLeastSupertype(type);\n    }\n\n    boolean result = defineProperty(propertyName, type, true,\n        propertyNode);\n\n    // All property definitions go through this method\n    // or defineDeclaredProperty. Because the properties defined an an\n    // object can affect subtyping, it's slightly more efficient\n    // to register this after defining the property.\n    registry.registerPropertyOnType(propertyName, this);\n\n    return result;\n  }",
    "comment": " Defines a property whose type is inferred. @param propertyName the property's name @param type the type @param propertyNode the node corresponding to the inferred definition of property that might later be accessed using {@code getPropertyNode}. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "ObjectType.findPropertyType",
    "class_name": "com.google.javascript.rhino.jstype.ObjectType",
    "signature": "com.google.javascript.rhino.jstype.ObjectType.findPropertyType(String)",
    "snippet": "  @Override\n  public JSType findPropertyType(String propertyName) {\n    return hasProperty(propertyName) ?\n        getPropertyType(propertyName) : null;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "ObjectType.getCtorExtendedInterfaces",
    "class_name": "com.google.javascript.rhino.jstype.ObjectType",
    "signature": "com.google.javascript.rhino.jstype.ObjectType.getCtorExtendedInterfaces()",
    "snippet": "  public Iterable<ObjectType> getCtorExtendedInterfaces() {\n    return ImmutableSet.of();\n  }",
    "comment": " Gets the interfaces extended by the interface associated with this type. Intended to be overriden by subclasses. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "ObjectType.getJSDocInfo",
    "class_name": "com.google.javascript.rhino.jstype.ObjectType",
    "signature": "com.google.javascript.rhino.jstype.ObjectType.getJSDocInfo()",
    "snippet": "  @Override\n  public JSDocInfo getJSDocInfo() {\n    if (docInfo != null) {\n      return docInfo;\n    } else if (getImplicitPrototype() != null) {\n      return getImplicitPrototype().getJSDocInfo();\n    } else {\n      return super.getJSDocInfo();\n    }\n  }",
    "comment": " Gets the docInfo for this type. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "ObjectType.getOwnPropertyJSDocInfo",
    "class_name": "com.google.javascript.rhino.jstype.ObjectType",
    "signature": "com.google.javascript.rhino.jstype.ObjectType.getOwnPropertyJSDocInfo(String)",
    "snippet": "  public JSDocInfo getOwnPropertyJSDocInfo(String propertyName) {\n    return null;\n  }",
    "comment": " Gets the docInfo on the specified property on this type.  This should not be done implemented recursively, as you generally need to know exactly on which type in the prototype chain the JSDocInfo exists. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "ObjectType.hasCachedValues",
    "class_name": "com.google.javascript.rhino.jstype.ObjectType",
    "signature": "com.google.javascript.rhino.jstype.ObjectType.hasCachedValues()",
    "snippet": "  public boolean hasCachedValues() {\n    return !unknown;\n  }",
    "comment": " Returns true if any cached valeus have been set for this type.  If true, then the prototype chain should not be changed, as it might invalidate the cached values. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "ObjectType.hasOwnDeclaredProperty",
    "class_name": "com.google.javascript.rhino.jstype.ObjectType",
    "signature": "com.google.javascript.rhino.jstype.ObjectType.hasOwnDeclaredProperty(String)",
    "snippet": "  boolean hasOwnDeclaredProperty(String name) {\n    return hasOwnProperty(name) && isPropertyTypeDeclared(name);\n  }",
    "comment": " Whether the given property is declared on this object. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "ObjectType.hasReferenceName",
    "class_name": "com.google.javascript.rhino.jstype.ObjectType",
    "signature": "com.google.javascript.rhino.jstype.ObjectType.hasReferenceName()",
    "snippet": "  public boolean hasReferenceName() {\n    return false;\n  }",
    "comment": " Returns true if the object is named. @return true if the object is named, false if it is anonymous ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "ObjectType.isImplicitPrototype",
    "class_name": "com.google.javascript.rhino.jstype.ObjectType",
    "signature": "com.google.javascript.rhino.jstype.ObjectType.isImplicitPrototype(ObjectType)",
    "snippet": "  final boolean isImplicitPrototype(ObjectType prototype) {\n    for (ObjectType current = this;\n         current != null;\n         current = current.getImplicitPrototype()) {\n      if (current.isEquivalentTo(prototype)) {\n        return true;\n      }\n    }\n    return false;\n  }",
    "comment": " Checks that the prototype is an implicit prototype of this object. Since each object has an implicit prototype, an implicit prototype's implicit prototype is also this implicit prototype's.  @param prototype any prototype based object  @return {@code true} if {@code prototype} is {@code equal} to any object in this object's implicit prototype chain. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "ObjectType.isUnknownType",
    "class_name": "com.google.javascript.rhino.jstype.ObjectType",
    "signature": "com.google.javascript.rhino.jstype.ObjectType.isUnknownType()",
    "snippet": "  @Override\n  public boolean isUnknownType() {\n    // If the object is unknown now, check the supertype again,\n    // because it might have been resolved since the last check.\n    if (unknown) {\n      ObjectType implicitProto = getImplicitPrototype();\n      if (implicitProto == null ||\n          implicitProto.isNativeObjectType()) {\n        unknown = false;\n        for (ObjectType interfaceType : getCtorExtendedInterfaces()) {\n          if (interfaceType.isUnknownType()) {\n            unknown = true;\n            break;\n          }\n        }\n      } else {\n        unknown = implicitProto.isUnknownType();\n      }\n    }\n    return unknown;\n  }",
    "comment": " We treat this as the unknown type if any of its implicit prototype properties is unknown. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "ObjectType.setJSDocInfo",
    "class_name": "com.google.javascript.rhino.jstype.ObjectType",
    "signature": "com.google.javascript.rhino.jstype.ObjectType.setJSDocInfo(JSDocInfo)",
    "snippet": "  public void setJSDocInfo(JSDocInfo info) {\n    docInfo = info;\n  }",
    "comment": " Sets the docInfo for this type from the given {@link JSDocInfo}. The {@code JSDocInfo} may be {@code null}. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "PrototypeObjectType.PrototypeObjectType",
    "class_name": "com.google.javascript.rhino.jstype.PrototypeObjectType",
    "signature": "com.google.javascript.rhino.jstype.PrototypeObjectType.PrototypeObjectType(JSTypeRegistry,String,ObjectType,boolean)",
    "snippet": "  PrototypeObjectType(JSTypeRegistry registry, String className,\n      ObjectType implicitPrototype, boolean nativeType) {\n    super(registry);\n    this.properties = Maps.newTreeMap();\n    this.className = className;\n    this.nativeType = nativeType;\n    if (nativeType || implicitPrototype != null) {\n      setImplicitPrototype(implicitPrototype);\n    } else {\n      setImplicitPrototype(\n          registry.getNativeObjectType(JSTypeNative.OBJECT_TYPE));\n    }\n  }",
    "comment": " Creates an object type, allowing specification of the implicit prototype when creating native objects. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "PrototypeObjectType.defineProperty",
    "class_name": "com.google.javascript.rhino.jstype.PrototypeObjectType",
    "signature": "com.google.javascript.rhino.jstype.PrototypeObjectType.defineProperty(String,JSType,boolean,Node)",
    "snippet": "  @Override\n  boolean defineProperty(String name, JSType type, boolean inferred,\n      Node propertyNode) {\n    if (hasOwnDeclaredProperty(name)) {\n      return false;\n    }\n    Property newProp = new Property(\n        name, type, inferred, propertyNode);\n    Property oldProp = properties.get(name);\n    if (oldProp != null) {\n      // This is to keep previously inferred jsdoc info, e.g., in a\n      // replaceScript scenario.\n      newProp.docInfo = oldProp.docInfo;\n    }\n    properties.put(name, newProp);\n    return true;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "PrototypeObjectType.getConstructor",
    "class_name": "com.google.javascript.rhino.jstype.PrototypeObjectType",
    "signature": "com.google.javascript.rhino.jstype.PrototypeObjectType.getConstructor()",
    "snippet": "  @Override\n  public FunctionType getConstructor() {\n    return null;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "PrototypeObjectType.getImplicitPrototype",
    "class_name": "com.google.javascript.rhino.jstype.PrototypeObjectType",
    "signature": "com.google.javascript.rhino.jstype.PrototypeObjectType.getImplicitPrototype()",
    "snippet": "  @Override\n  public ObjectType getImplicitPrototype() {\n    return implicitPrototypeFallback;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "PrototypeObjectType.getPropertyType",
    "class_name": "com.google.javascript.rhino.jstype.PrototypeObjectType",
    "signature": "com.google.javascript.rhino.jstype.PrototypeObjectType.getPropertyType(String)",
    "snippet": "  @Override\n  public JSType getPropertyType(String property) {\n    StaticSlot<JSType> slot = getSlot(property);\n    if (slot == null) {\n      return getNativeType(JSTypeNative.UNKNOWN_TYPE);\n    }\n    return slot.getType();\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "PrototypeObjectType.getReferenceName",
    "class_name": "com.google.javascript.rhino.jstype.PrototypeObjectType",
    "signature": "com.google.javascript.rhino.jstype.PrototypeObjectType.getReferenceName()",
    "snippet": "  @Override\n  public String getReferenceName() {\n    if (className != null) {\n      return className;\n    } else {\n      return null;\n    }\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "PrototypeObjectType.getSlot",
    "class_name": "com.google.javascript.rhino.jstype.PrototypeObjectType",
    "signature": "com.google.javascript.rhino.jstype.PrototypeObjectType.getSlot(String)",
    "snippet": "  @Override\n  public StaticSlot<JSType> getSlot(String name) {\n    if (properties.containsKey(name)) {\n      return properties.get(name);\n    }\n    ObjectType implicitPrototype = getImplicitPrototype();\n    if (implicitPrototype != null) {\n      StaticSlot<JSType> prop = implicitPrototype.getSlot(name);\n      if (prop != null) {\n        return prop;\n      }\n    }\n    for (ObjectType interfaceType : getCtorExtendedInterfaces()) {\n      StaticSlot<JSType> prop = interfaceType.getSlot(name);\n      if (prop != null) {\n        return prop;\n      }\n    }\n    return null;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "PrototypeObjectType.hasCachedValues",
    "class_name": "com.google.javascript.rhino.jstype.PrototypeObjectType",
    "signature": "com.google.javascript.rhino.jstype.PrototypeObjectType.hasCachedValues()",
    "snippet": "  @Override\n  public boolean hasCachedValues() {\n    return super.hasCachedValues();\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "PrototypeObjectType.hasOwnProperty",
    "class_name": "com.google.javascript.rhino.jstype.PrototypeObjectType",
    "signature": "com.google.javascript.rhino.jstype.PrototypeObjectType.hasOwnProperty(String)",
    "snippet": "  @Override\n  public boolean hasOwnProperty(String propertyName) {\n    return properties.get(propertyName) != null;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "PrototypeObjectType.hasProperty",
    "class_name": "com.google.javascript.rhino.jstype.PrototypeObjectType",
    "signature": "com.google.javascript.rhino.jstype.PrototypeObjectType.hasProperty(String)",
    "snippet": "  @Override\n  public boolean hasProperty(String propertyName) {\n    // Unknown types have all properties.\n    return isUnknownType() || getSlot(propertyName) != null;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "PrototypeObjectType.hasReferenceName",
    "class_name": "com.google.javascript.rhino.jstype.PrototypeObjectType",
    "signature": "com.google.javascript.rhino.jstype.PrototypeObjectType.hasReferenceName()",
    "snippet": "  @Override\n  public boolean hasReferenceName() {\n    return className != null;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "PrototypeObjectType.implicitPrototypeChainIsUnknown",
    "class_name": "com.google.javascript.rhino.jstype.PrototypeObjectType",
    "signature": "com.google.javascript.rhino.jstype.PrototypeObjectType.implicitPrototypeChainIsUnknown()",
    "snippet": "  private boolean implicitPrototypeChainIsUnknown() {\n    ObjectType p = getImplicitPrototype();\n    while (p != null) {\n      if (p.isUnknownType()) {\n        return true;\n      }\n      p = p.getImplicitPrototype();\n    }\n    return false;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "PrototypeObjectType.isNativeObjectType",
    "class_name": "com.google.javascript.rhino.jstype.PrototypeObjectType",
    "signature": "com.google.javascript.rhino.jstype.PrototypeObjectType.isNativeObjectType()",
    "snippet": "  @Override\n  public boolean isNativeObjectType() {\n    return nativeType;\n  }",
    "comment": "Whether this is a built-in object. */",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "PrototypeObjectType.isPropertyTypeDeclared",
    "class_name": "com.google.javascript.rhino.jstype.PrototypeObjectType",
    "signature": "com.google.javascript.rhino.jstype.PrototypeObjectType.isPropertyTypeDeclared(String)",
    "snippet": "  @Override\n  public boolean isPropertyTypeDeclared(String property) {\n    StaticSlot<JSType> slot = getSlot(property);\n    if (slot == null) {\n      return false;\n    }\n    return !slot.isTypeInferred();\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "PrototypeObjectType.isSubtype",
    "class_name": "com.google.javascript.rhino.jstype.PrototypeObjectType",
    "signature": "com.google.javascript.rhino.jstype.PrototypeObjectType.isSubtype(JSType)",
    "snippet": "  @Override\n  public boolean isSubtype(JSType that) {\n    if (JSType.isSubtype(this, that)) {\n      return true;\n    }\n\n    // Union types\n    if (that instanceof UnionType) {\n      // The static {@code JSType.isSubtype} check already decomposed\n      // union types, so we don't need to check those again.\n      return false;\n    }\n\n    // record types\n    if (that instanceof RecordType) {\n      return RecordType.isSubtype(this, (RecordType) that);\n    }\n\n    // Interfaces\n    // Find all the interfaces implemented by this class and compare each one\n    // to the interface instance.\n    ObjectType thatObj = that.toObjectType();\n    ObjectType thatCtor = thatObj == null ? null : thatObj.getConstructor();\n    if (thatCtor != null && thatCtor.isInterface()) {\n      Iterable<ObjectType> thisInterfaces = getCtorImplementedInterfaces();\n      for (ObjectType thisInterface : thisInterfaces) {\n        if (thisInterface.isSubtype(that)) {\n          return true;\n        }\n      }\n    }\n\n    if (getConstructor() != null && getConstructor().isInterface()) {\n      for (ObjectType thisInterface : getCtorExtendedInterfaces()) {\n        if (thisInterface.isSubtype(that)) {\n          return true;\n        }\n      }\n    }\n\n    // other prototype based objects\n    if (isUnknownType() || implicitPrototypeChainIsUnknown()) {\n      // If unsure, say 'yes', to avoid spurious warnings.\n      // TODO(user): resolve the prototype chain completely in all cases,\n      // to avoid guessing.\n      return true;\n    }\n    return this.isImplicitPrototype(thatObj);\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "PrototypeObjectType.resolveInternal",
    "class_name": "com.google.javascript.rhino.jstype.PrototypeObjectType",
    "signature": "com.google.javascript.rhino.jstype.PrototypeObjectType.resolveInternal(ErrorReporter,StaticScope)",
    "snippet": "  @Override\n  JSType resolveInternal(ErrorReporter t, StaticScope<JSType> scope) {\n    setResolvedTypeInternal(this);\n\n    ObjectType implicitPrototype = getImplicitPrototype();\n    if (implicitPrototype != null) {\n      implicitPrototypeFallback =\n          (ObjectType) implicitPrototype.resolve(t, scope);\n    }\n    for (Property prop : properties.values()) {\n      prop.type = safeResolve(prop.type, t, scope);\n    }\n    return this;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "PrototypeObjectType.setImplicitPrototype",
    "class_name": "com.google.javascript.rhino.jstype.PrototypeObjectType",
    "signature": "com.google.javascript.rhino.jstype.PrototypeObjectType.setImplicitPrototype(ObjectType)",
    "snippet": "  final void setImplicitPrototype(ObjectType implicitPrototype) {\n    checkState(!hasCachedValues());\n    this.implicitPrototypeFallback = implicitPrototype;\n  }",
    "comment": " This should only be reset on the FunctionPrototypeType, only to fix an incorrectly established prototype chain due to the user having a mismatch in super class declaration, and only before properties on that type are processed. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "PrototypeObjectType.setPropertyJSDocInfo",
    "class_name": "com.google.javascript.rhino.jstype.PrototypeObjectType",
    "signature": "com.google.javascript.rhino.jstype.PrototypeObjectType.setPropertyJSDocInfo(String,JSDocInfo)",
    "snippet": "  @Override\n  public void setPropertyJSDocInfo(String propertyName, JSDocInfo info) {\n    if (info != null) {\n      if (!properties.containsKey(propertyName)) {\n        // If docInfo was attached, but the type of the property\n        // was not defined anywhere, then we consider this an explicit\n        // declaration of the property.\n        defineInferredProperty(propertyName, getPropertyType(propertyName),\n            null);\n      }\n\n      // The prototype property is not represented as a normal Property.\n      // We probably don't want to attach any JSDoc to it anyway.\n      Property property = properties.get(propertyName);\n      if (property != null) {\n        property.docInfo = info;\n      }\n    }\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "PrototypeObjectType.toString",
    "class_name": "com.google.javascript.rhino.jstype.PrototypeObjectType",
    "signature": "com.google.javascript.rhino.jstype.PrototypeObjectType.toString()",
    "snippet": "  @Override\n  public String toString() {\n    if (hasReferenceName()) {\n      return getReferenceName();\n    } else if (prettyPrint) {\n      // Use a tree set so that the properties are sorted.\n      Set<String> propertyNames = Sets.newTreeSet();\n      for (ObjectType current = this;\n           current != null && !current.isNativeObjectType() &&\n               propertyNames.size() <= MAX_PRETTY_PRINTED_PROPERTIES;\n           current = current.getImplicitPrototype()) {\n        propertyNames.addAll(current.getOwnPropertyNames());\n      }\n\n      StringBuilder sb = new StringBuilder();\n      sb.append(\"{\");\n\n      int i = 0;\n      for (String property : propertyNames) {\n        if (i > 0) {\n          sb.append(\", \");\n        }\n\n        sb.append(property);\n        sb.append(\": \");\n        sb.append(getPropertyType(property).toString());\n\n        ++i;\n        if (i == MAX_PRETTY_PRINTED_PROPERTIES) {\n          sb.append(\", ...\");\n          break;\n        }\n      }\n\n      sb.append(\"}\");\n      return sb.toString();\n    } else {\n      return \"{...}\";\n    }\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "Property.getType",
    "class_name": "com.google.javascript.rhino.jstype.PrototypeObjectType$Property",
    "signature": "com.google.javascript.rhino.jstype.PrototypeObjectType$Property.getType()",
    "snippet": "    @Override\n    public JSType getType() {\n      return type;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "Property.isTypeInferred",
    "class_name": "com.google.javascript.rhino.jstype.PrototypeObjectType$Property",
    "signature": "com.google.javascript.rhino.jstype.PrototypeObjectType$Property.isTypeInferred()",
    "snippet": "    @Override\n    public boolean isTypeInferred() {\n      return inferred;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "ProxyObjectType.ProxyObjectType",
    "class_name": "com.google.javascript.rhino.jstype.ProxyObjectType",
    "signature": "com.google.javascript.rhino.jstype.ProxyObjectType.ProxyObjectType(JSTypeRegistry,JSType)",
    "snippet": "  ProxyObjectType(JSTypeRegistry registry, JSType referencedType) {\n    super(registry);\n    setReferencedType(referencedType);\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "ProxyObjectType.setReferencedType",
    "class_name": "com.google.javascript.rhino.jstype.ProxyObjectType",
    "signature": "com.google.javascript.rhino.jstype.ProxyObjectType.setReferencedType(JSType)",
    "snippet": "  void setReferencedType(JSType referencedType) {\n    this.referencedType = referencedType;\n    if (referencedType instanceof ObjectType) {\n      this.referencedObjType = (ObjectType) referencedType;\n    } else {\n      this.referencedObjType = null;\n    }\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "SimpleSlot.SimpleSlot",
    "class_name": "com.google.javascript.rhino.jstype.SimpleSlot",
    "signature": "com.google.javascript.rhino.jstype.SimpleSlot.SimpleSlot(String,JSType,boolean)",
    "snippet": "  public SimpleSlot(String name, JSType type, boolean inferred) {\n    this.name = name;\n    this.type = type;\n    this.inferred = inferred;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "StringType.StringType",
    "class_name": "com.google.javascript.rhino.jstype.StringType",
    "signature": "com.google.javascript.rhino.jstype.StringType.StringType(JSTypeRegistry)",
    "snippet": "  StringType(JSTypeRegistry registry) {\n    super(registry);\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "StringType.autoboxesTo",
    "class_name": "com.google.javascript.rhino.jstype.StringType",
    "signature": "com.google.javascript.rhino.jstype.StringType.autoboxesTo()",
    "snippet": "  @Override\n  public JSType autoboxesTo() {\n    return getNativeType(JSTypeNative.STRING_OBJECT_TYPE);\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "StringType.getDisplayName",
    "class_name": "com.google.javascript.rhino.jstype.StringType",
    "signature": "com.google.javascript.rhino.jstype.StringType.getDisplayName()",
    "snippet": "  @Override\n  public String getDisplayName() {\n    return \"string\";\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "StringType.toString",
    "class_name": "com.google.javascript.rhino.jstype.StringType",
    "signature": "com.google.javascript.rhino.jstype.StringType.toString()",
    "snippet": "  @Override\n  public String toString() {\n    return getDisplayName();\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "TemplateType.TemplateType",
    "class_name": "com.google.javascript.rhino.jstype.TemplateType",
    "signature": "com.google.javascript.rhino.jstype.TemplateType.TemplateType(JSTypeRegistry,String)",
    "snippet": "  TemplateType(JSTypeRegistry registry, String name) {\n    super(registry, registry.getNativeObjectType(JSTypeNative.UNKNOWN_TYPE));\n    this.name = name;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "UnionType.UnionType",
    "class_name": "com.google.javascript.rhino.jstype.UnionType",
    "signature": "com.google.javascript.rhino.jstype.UnionType.UnionType(JSTypeRegistry,Collection)",
    "snippet": "  UnionType(JSTypeRegistry registry, Collection<JSType> alternates) {\n    super(registry);\n    this.alternates = alternates;\n    this.hashcode = this.alternates.hashCode();\n  }",
    "comment": " Creates a union type.  @param alternates the alternates of the union ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "UnionType.isUnknownType",
    "class_name": "com.google.javascript.rhino.jstype.UnionType",
    "signature": "com.google.javascript.rhino.jstype.UnionType.isUnknownType()",
    "snippet": "  @Override\n  public boolean isUnknownType() {\n    for (JSType t : alternates) {\n      if (t.isUnknownType()) {\n        return true;\n      }\n    }\n    return false;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "UnionType.resolveInternal",
    "class_name": "com.google.javascript.rhino.jstype.UnionType",
    "signature": "com.google.javascript.rhino.jstype.UnionType.resolveInternal(ErrorReporter,StaticScope)",
    "snippet": "  @Override\n  JSType resolveInternal(ErrorReporter t, StaticScope<JSType> scope) {\n    setResolvedTypeInternal(this); // for circularly defined types.\n\n    boolean changed = false;\n    ImmutableList.Builder<JSType> resolvedTypes = ImmutableList.builder();\n    for (JSType alternate : alternates) {\n      JSType newAlternate = alternate.resolve(t, scope);\n      changed |= (alternate != newAlternate);\n      resolvedTypes.add(alternate);\n    }\n    if (changed) {\n      Collection<JSType> newAlternates = resolvedTypes.build();\n      Preconditions.checkState(\n          newAlternates.hashCode() == this.hashcode);\n      alternates = newAlternates;\n    }\n    return this;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "UnionType.restrictByNotNullOrUndefined",
    "class_name": "com.google.javascript.rhino.jstype.UnionType",
    "signature": "com.google.javascript.rhino.jstype.UnionType.restrictByNotNullOrUndefined()",
    "snippet": "  @Override\n  public JSType restrictByNotNullOrUndefined() {\n    UnionTypeBuilder restricted = new UnionTypeBuilder(registry);\n    for (JSType t : alternates) {\n      restricted.addAlternate(t.restrictByNotNullOrUndefined());\n    }\n    return restricted.build();\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "UnionTypeBuilder.UnionTypeBuilder",
    "class_name": "com.google.javascript.rhino.jstype.UnionTypeBuilder",
    "signature": "com.google.javascript.rhino.jstype.UnionTypeBuilder.UnionTypeBuilder(JSTypeRegistry)",
    "snippet": "  UnionTypeBuilder(JSTypeRegistry registry) {\n    this.registry = registry;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "UnionTypeBuilder.addAlternate",
    "class_name": "com.google.javascript.rhino.jstype.UnionTypeBuilder",
    "signature": "com.google.javascript.rhino.jstype.UnionTypeBuilder.addAlternate(JSType)",
    "snippet": "  UnionTypeBuilder addAlternate(JSType alternate) {\n    // build() returns the bottom type by default, so we can\n    // just bail out early here.\n    if (alternate.isNoType()) {\n      return this;\n    }\n\n    isAllType = isAllType || alternate.isAllType();\n\n    boolean isAlternateUnknown = alternate instanceof UnknownType;\n    isNativeUnknownType = isNativeUnknownType || isAlternateUnknown;\n    if (isAlternateUnknown) {\n      areAllUnknownsChecked = areAllUnknownsChecked &&\n          alternate.isCheckedUnknownType();\n    }\n    if (!isAllType && !isNativeUnknownType) {\n      if (alternate instanceof UnionType) {\n        UnionType union = (UnionType) alternate;\n        for (JSType unionAlt : union.getAlternates()) {\n          addAlternate(unionAlt);\n        }\n      } else {\n        if (alternates.size() > MAX_UNION_SIZE) {\n          return this;\n        }\n\n        // Look through the alternates we've got so far,\n        // and check if any of them are duplicates of\n        // one another.\n        Iterator<JSType> it = alternates.iterator();\n        while (it.hasNext()) {\n          JSType current = it.next();\n\n          // Unknown and NoResolved types may just be names that haven't\n          // been resolved yet. So keep these in the union, and just use\n          // equality checking for simple de-duping.\n          if (alternate.isUnknownType() ||\n              current.isUnknownType() ||\n              alternate.isNoResolvedType() ||\n              current.isNoResolvedType()) {\n            if (alternate.isEquivalentTo(current)) {\n              // Alternate is unnecessary.\n              return this;\n            }\n          } else {\n            if (alternate.isSubtype(current)) {\n              // Alternate is unnecessary.\n              return this;\n            } else if (current.isSubtype(alternate)) {\n              // Alternate makes current obsolete\n              it.remove();\n            }\n          }\n        }\n        alternates.add(alternate);\n        result = null; // invalidate the memoized result\n      }\n    } else {\n      result = null;\n    }\n    return this;\n  }",
    "comment": " Adds an alternate to the union type under construction. Returns this for easy chaining. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "UnionTypeBuilder.build",
    "class_name": "com.google.javascript.rhino.jstype.UnionTypeBuilder",
    "signature": "com.google.javascript.rhino.jstype.UnionTypeBuilder.build()",
    "snippet": "  JSType build() {\n    if (result == null) {\n      result = reduceAlternatesWithoutUnion();\n      if (result == null) {\n        result = new UnionType(registry, getAlternateListCopy());\n      }\n    }\n    return result;\n  }",
    "comment": " Creates a union. @return A UnionType if it has two or more alternates, the only alternate if it has one and otherwise {@code NO_TYPE}. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "UnionTypeBuilder.getAlternateListCopy",
    "class_name": "com.google.javascript.rhino.jstype.UnionTypeBuilder",
    "signature": "com.google.javascript.rhino.jstype.UnionTypeBuilder.getAlternateListCopy()",
    "snippet": "  private Collection<JSType> getAlternateListCopy() {\n    // TODO(nicksantos): Until we're at a place where we're no longer\n    // using java's built-in equals to test type equivalence, we need\n    // hash codes to be the same. So the alternates need to be sorted.\n    Collections.sort(alternates, typeSorter);\n\n    return ImmutableList.copyOf(alternates);\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "UnionTypeBuilder.reduceAlternatesWithoutUnion",
    "class_name": "com.google.javascript.rhino.jstype.UnionTypeBuilder",
    "signature": "com.google.javascript.rhino.jstype.UnionTypeBuilder.reduceAlternatesWithoutUnion()",
    "snippet": "  private JSType reduceAlternatesWithoutUnion() {\n    if (isAllType) {\n      return registry.getNativeType(ALL_TYPE);\n    } else if (isNativeUnknownType) {\n      if (areAllUnknownsChecked) {\n        return registry.getNativeType(CHECKED_UNKNOWN_TYPE);\n      } else {\n        return registry.getNativeType(UNKNOWN_TYPE);\n      }\n    } else {\n      int size = alternates.size();\n      if (size > MAX_UNION_SIZE) {\n        return registry.getNativeType(UNKNOWN_TYPE);\n      } else if (size > 1) {\n        return null;\n      } else if (size == 1) {\n        return alternates.iterator().next();\n      } else {\n        return registry.getNativeType(NO_TYPE);\n      }\n    }\n  }",
    "comment": " Reduce the alternates into a non-union type. If the alternates can't be accurately represented with a non-union type, return null. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "UnknownType.UnknownType",
    "class_name": "com.google.javascript.rhino.jstype.UnknownType",
    "signature": "com.google.javascript.rhino.jstype.UnknownType.UnknownType(JSTypeRegistry,boolean)",
    "snippet": "  UnknownType(JSTypeRegistry registry, boolean isChecked) {\n    super(registry);\n    this.isChecked = isChecked;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "UnknownType.defineProperty",
    "class_name": "com.google.javascript.rhino.jstype.UnknownType",
    "signature": "com.google.javascript.rhino.jstype.UnknownType.defineProperty(String,JSType,boolean,Node)",
    "snippet": "  @Override\n  boolean defineProperty(String propertyName, JSType type,\n      boolean inferred, Node propertyNode) {\n    // nothing to define\n    return true;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "UnknownType.getImplicitPrototype",
    "class_name": "com.google.javascript.rhino.jstype.UnknownType",
    "signature": "com.google.javascript.rhino.jstype.UnknownType.getImplicitPrototype()",
    "snippet": "  @Override\n  public ObjectType getImplicitPrototype() {\n    return null;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "UnknownType.getPropertyType",
    "class_name": "com.google.javascript.rhino.jstype.UnknownType",
    "signature": "com.google.javascript.rhino.jstype.UnknownType.getPropertyType(String)",
    "snippet": "  @Override\n  public JSType getPropertyType(String propertyName) {\n    return this;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "UnknownType.getReferenceName",
    "class_name": "com.google.javascript.rhino.jstype.UnknownType",
    "signature": "com.google.javascript.rhino.jstype.UnknownType.getReferenceName()",
    "snippet": "  @Override\n  public String getReferenceName() {\n    return isChecked ? \"??\" : \"?\";\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "UnknownType.hasProperty",
    "class_name": "com.google.javascript.rhino.jstype.UnknownType",
    "signature": "com.google.javascript.rhino.jstype.UnknownType.hasProperty(String)",
    "snippet": "  @Override\n  public boolean hasProperty(String propertyName) {\n    return true;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "UnknownType.isCheckedUnknownType",
    "class_name": "com.google.javascript.rhino.jstype.UnknownType",
    "signature": "com.google.javascript.rhino.jstype.UnknownType.isCheckedUnknownType()",
    "snippet": "  @Override\n  public boolean isCheckedUnknownType() {\n    return isChecked;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "UnknownType.isPropertyTypeDeclared",
    "class_name": "com.google.javascript.rhino.jstype.UnknownType",
    "signature": "com.google.javascript.rhino.jstype.UnknownType.isPropertyTypeDeclared(String)",
    "snippet": "  @Override\n  public boolean isPropertyTypeDeclared(String propertyName) {\n    return false;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "UnknownType.isPropertyTypeInferred",
    "class_name": "com.google.javascript.rhino.jstype.UnknownType",
    "signature": "com.google.javascript.rhino.jstype.UnknownType.isPropertyTypeInferred(String)",
    "snippet": "  @Override\n  public boolean isPropertyTypeInferred(String propertyName) {\n    return false;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "UnknownType.isUnknownType",
    "class_name": "com.google.javascript.rhino.jstype.UnknownType",
    "signature": "com.google.javascript.rhino.jstype.UnknownType.isUnknownType()",
    "snippet": "  @Override\n  public boolean isUnknownType() {\n    return true;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "UnknownType.resolveInternal",
    "class_name": "com.google.javascript.rhino.jstype.UnknownType",
    "signature": "com.google.javascript.rhino.jstype.UnknownType.resolveInternal(ErrorReporter,StaticScope)",
    "snippet": "  @Override\n  JSType resolveInternal(ErrorReporter t, StaticScope<JSType> scope) {\n    return this;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "UnknownType.toString",
    "class_name": "com.google.javascript.rhino.jstype.UnknownType",
    "signature": "com.google.javascript.rhino.jstype.UnknownType.toString()",
    "snippet": "  @Override\n  public String toString() {\n    return getReferenceName();\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "ValueType.ValueType",
    "class_name": "com.google.javascript.rhino.jstype.ValueType",
    "signature": "com.google.javascript.rhino.jstype.ValueType.ValueType(JSTypeRegistry)",
    "snippet": "  ValueType(JSTypeRegistry registry) {\n    super(registry);\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "ValueType.isSubtype",
    "class_name": "com.google.javascript.rhino.jstype.ValueType",
    "signature": "com.google.javascript.rhino.jstype.ValueType.isSubtype(JSType)",
    "snippet": "  @Override\n  public boolean isSubtype(JSType that) {\n    return JSType.isSubtype(this, that);\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "ValueType.resolveInternal",
    "class_name": "com.google.javascript.rhino.jstype.ValueType",
    "signature": "com.google.javascript.rhino.jstype.ValueType.resolveInternal(ErrorReporter,StaticScope)",
    "snippet": "  @Override\n  final JSType resolveInternal(ErrorReporter t, StaticScope<JSType> scope) {\n    return this;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "VoidType.VoidType",
    "class_name": "com.google.javascript.rhino.jstype.VoidType",
    "signature": "com.google.javascript.rhino.jstype.VoidType.VoidType(JSTypeRegistry)",
    "snippet": "  VoidType(JSTypeRegistry registry) {\n    super(registry);\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "VoidType.getDisplayName",
    "class_name": "com.google.javascript.rhino.jstype.VoidType",
    "signature": "com.google.javascript.rhino.jstype.VoidType.getDisplayName()",
    "snippet": "  @Override\n  public String getDisplayName() {\n    return \"undefined\";\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "VoidType.toString",
    "class_name": "com.google.javascript.rhino.jstype.VoidType",
    "signature": "com.google.javascript.rhino.jstype.VoidType.toString()",
    "snippet": "  @Override\n  public String toString() {\n    return getDisplayName();\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  }
]