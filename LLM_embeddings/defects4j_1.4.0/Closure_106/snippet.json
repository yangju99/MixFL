[
  {
    "name": "AbstractMessageFormatter.AbstractMessageFormatter",
    "class_name": "com.google.javascript.jscomp.AbstractMessageFormatter",
    "signature": "com.google.javascript.jscomp.AbstractMessageFormatter.AbstractMessageFormatter(SourceExcerptProvider)",
    "snippet": "  public AbstractMessageFormatter(SourceExcerptProvider source) {\n    this.source = source;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "AbstractMessageFormatter.setColorize",
    "class_name": "com.google.javascript.jscomp.AbstractMessageFormatter",
    "signature": "com.google.javascript.jscomp.AbstractMessageFormatter.setColorize(boolean)",
    "snippet": "  public void setColorize(boolean colorize) {\n    this.colorize = colorize;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "BasicErrorManager.getErrorCount",
    "class_name": "com.google.javascript.jscomp.BasicErrorManager",
    "signature": "com.google.javascript.jscomp.BasicErrorManager.getErrorCount()",
    "snippet": "  public int getErrorCount() {\n    return errorCount;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "BasicErrorManager.getErrors",
    "class_name": "com.google.javascript.jscomp.BasicErrorManager",
    "signature": "com.google.javascript.jscomp.BasicErrorManager.getErrors()",
    "snippet": "  public JSError[] getErrors() {\n    return toArray(CheckLevel.ERROR);\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "BasicErrorManager.getWarningCount",
    "class_name": "com.google.javascript.jscomp.BasicErrorManager",
    "signature": "com.google.javascript.jscomp.BasicErrorManager.getWarningCount()",
    "snippet": "  public int getWarningCount() {\n    return warningCount;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "BasicErrorManager.getWarnings",
    "class_name": "com.google.javascript.jscomp.BasicErrorManager",
    "signature": "com.google.javascript.jscomp.BasicErrorManager.getWarnings()",
    "snippet": "  public JSError[] getWarnings() {\n    return toArray(CheckLevel.WARNING);\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "BasicErrorManager.report",
    "class_name": "com.google.javascript.jscomp.BasicErrorManager",
    "signature": "com.google.javascript.jscomp.BasicErrorManager.report(CheckLevel,JSError)",
    "snippet": "  public void report(CheckLevel level, JSError error) {\n    if (messages.add(Pair.of(error, level))) {\n      if (level == CheckLevel.ERROR) {\n        errorCount++;\n      } else if (level == CheckLevel.WARNING) {\n        warningCount++;\n      }\n    }\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "BasicErrorManager.toArray",
    "class_name": "com.google.javascript.jscomp.BasicErrorManager",
    "signature": "com.google.javascript.jscomp.BasicErrorManager.toArray(CheckLevel)",
    "snippet": "  private JSError[] toArray(CheckLevel level) {\n    List<JSError> errors = new ArrayList<JSError>(messages.size());\n    for (Pair<JSError, CheckLevel> p : messages) {\n      if (p.second == level) {\n        errors.add(p.first);\n      }\n    }\n    return errors.toArray(new JSError[errors.size()]);\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "LeveledJSErrorComparator.compare",
    "class_name": "com.google.javascript.jscomp.BasicErrorManager$LeveledJSErrorComparator",
    "signature": "com.google.javascript.jscomp.BasicErrorManager$LeveledJSErrorComparator.compare(Pair,Pair)",
    "snippet": "    public int compare(Pair<JSError, CheckLevel> p1,\n        Pair<JSError, CheckLevel> p2) {\n      // null is the smallest value\n      if (p2 == null) {\n        if (p1 == null) {\n          return 0;\n        } else {\n          return P1_GT_P2;\n        }\n      }\n\n      // check level\n      if (p1.second != p2.second) {\n        return p2.second.compareTo(p1.second);\n      }\n\n      // sourceName comparison\n      String source1 = p1.first.sourceName;\n      String source2 = p2.first.sourceName;\n      if (source1 != null && source2 != null) {\n        int sourceCompare = source1.compareTo(source2);\n        if (sourceCompare != 0) {\n          return sourceCompare;\n        }\n      } else if (source1 == null && source2 != null) {\n        return P1_LT_P2;\n      } else if (source1 != null && source2 == null) {\n        return P1_GT_P2;\n      }\n      // lineno comparison\n      int lineno1 = p1.first.lineNumber;\n      int lineno2 = p2.first.lineNumber;\n      if (lineno1 != lineno2) {\n        return lineno1 - lineno2;\n      } else if (lineno1 < 0 && 0 <= lineno2) {\n        return P1_LT_P2;\n      } else if (0 <= lineno1 && lineno2 < 0) {\n        return P1_GT_P2;\n      }\n      // charno comparison\n      int charno1 = p1.first.getCharno();\n      int charno2 = p2.first.getCharno();\n      if (charno1 != charno2) {\n        return charno1 - charno2;\n      } else if (charno1 < 0 && 0 <= charno2) {\n        return P1_LT_P2;\n      } else if (0 <= charno1 && charno2 < 0) {\n        return P1_GT_P2;\n      }\n      // description\n      return p1.first.description.compareTo(p2.first.description);\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "CheckLevel.isOn",
    "class_name": "com.google.javascript.jscomp.CheckLevel",
    "signature": "com.google.javascript.jscomp.CheckLevel.isOn()",
    "snippet": "  boolean isOn() {\n    return this != OFF;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "CheckSideEffects.CheckSideEffects",
    "class_name": "com.google.javascript.jscomp.CheckSideEffects",
    "signature": "com.google.javascript.jscomp.CheckSideEffects.CheckSideEffects(CheckLevel)",
    "snippet": "  CheckSideEffects(CheckLevel level) {\n    this.level = level;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "CheckSideEffects.visit",
    "class_name": "com.google.javascript.jscomp.CheckSideEffects",
    "signature": "com.google.javascript.jscomp.CheckSideEffects.visit(NodeTraversal,Node,Node)",
    "snippet": "  public void visit(NodeTraversal t, Node n, Node parent) {\n    // VOID nodes appear when there are extra semicolons at the BLOCK level.\n    // I've been unable to think of any cases where this indicates a bug,\n    // and apparently some people like keeping these semicolons around,\n    // so we'll allow it.\n    if (n.getType() == Token.EMPTY ||\n        n.getType() == Token.COMMA) {\n      return;\n    }\n\n    if (parent == null)\n      return;\n\n    int pt = parent.getType();\n    if (pt == Token.COMMA) {\n      if (n == parent.getLastChild()) {\n        for (Node an : parent.getAncestors()) {\n          int ancestorType = an.getType();\n          if (ancestorType == Token.COMMA)\n            continue;\n          if (ancestorType != Token.EXPR_RESULT &&\n              ancestorType != Token.BLOCK)\n            return;\n          else\n            break;\n        }\n      }\n    } else if (pt != Token.EXPR_RESULT && pt != Token.BLOCK) {\n      if (pt == Token.FOR && parent.getChildCount() == 4 &&\n          (n == parent.getFirstChild() ||\n           n == parent.getFirstChild().getNext().getNext())) {\n        // Fall through and look for warnings for the 1st and 3rd child\n        // of a for.\n      } else {\n        return;  // it might be ok to not have a side-effect\n      }\n    }\n    if (NodeUtil.isSimpleOperatorType(n.getType()) ||\n        !NodeUtil.mayHaveSideEffects(n)) {\n      if (n.isQualifiedName() && n.getJSDocInfo() != null) {\n        // This no-op statement was there so that JSDoc information could\n        // be attached to the name. This check should not complain about it.\n        return;\n      } else if (NodeUtil.isExpressionNode(n)) {\n        // we already reported the problem when we visited the child.\n        return;\n      }\n\n      String msg = \"This code lacks side-effects. Is there a bug?\";\n      if (n.getType() == Token.STRING) {\n        msg = \"Is there a missing '+' on the previous line?\";\n      }\n\n      t.getCompiler().report(\n          JSError.make(t, n, level, USELESS_CODE_ERROR, msg));\n    }\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "RecentChange.hasCodeChanged",
    "class_name": "com.google.javascript.jscomp.CodeChangeHandler$RecentChange",
    "signature": "com.google.javascript.jscomp.CodeChangeHandler$RecentChange.hasCodeChanged()",
    "snippet": "    boolean hasCodeChanged() {\n      return hasChanged;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "RecentChange.reset",
    "class_name": "com.google.javascript.jscomp.CodeChangeHandler$RecentChange",
    "signature": "com.google.javascript.jscomp.CodeChangeHandler$RecentChange.reset()",
    "snippet": "    void reset() {\n      hasChanged = false;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "CodingConventionAnnotator.CodingConventionAnnotator",
    "class_name": "com.google.javascript.jscomp.CodingConventionAnnotator",
    "signature": "com.google.javascript.jscomp.CodingConventionAnnotator.CodingConventionAnnotator(AbstractCompiler)",
    "snippet": "  public CodingConventionAnnotator(AbstractCompiler compiler) {\n    this.compiler = compiler;\n    this.convention = compiler.getCodingConvention();\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "CodingConventionAnnotator.process",
    "class_name": "com.google.javascript.jscomp.CodingConventionAnnotator",
    "signature": "com.google.javascript.jscomp.CodingConventionAnnotator.process(Node,Node)",
    "snippet": "  @Override\n  public void process(Node externs, Node root) {\n    if (externs != null) {\n      NodeTraversal.traverse(compiler, externs, this);\n    }\n    if (root != null) {\n      NodeTraversal.traverse(compiler, root, this);\n    }\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "CodingConventionAnnotator.visit",
    "class_name": "com.google.javascript.jscomp.CodingConventionAnnotator",
    "signature": "com.google.javascript.jscomp.CodingConventionAnnotator.visit(NodeTraversal,Node,Node)",
    "snippet": "  @Override\n  public void visit(NodeTraversal t, Node n, Node parent) {\n    switch (n.getType()) {\n      case Token.NAME:\n      case Token.STRING:\n        if (convention.isConstant(n.getString())) {\n          n.putBooleanProp(Node.IS_CONSTANT_NAME, true);\n        }\n        break;\n\n      case Token.FUNCTION:\n        JSDocInfo fnInfo = n.getJSDocInfo();\n        if (fnInfo == null) {\n          // Look for the info on other nodes.\n          if (parent.getType() == Token.ASSIGN) {\n            // on ASSIGNs\n            fnInfo = parent.getJSDocInfo();\n          } else if (parent.getType() == Token.NAME) {\n            // on var NAME = function() { ... };\n            fnInfo = parent.getParent().getJSDocInfo();\n          }\n        }\n\n        // Compute which function parameters are optional and\n        // which are var_args.\n        Node args = n.getFirstChild().getNext();\n        for (Node arg = args.getFirstChild();\n             arg != null;\n             arg = arg.getNext()) {\n          String argName = arg.getString();\n          JSTypeExpression typeExpr = fnInfo == null ?\n              null : fnInfo.getParameterType(argName);\n\n          if (convention.isOptionalParameter(arg) ||\n              typeExpr != null && typeExpr.isOptionalArg()) {\n            arg.putBooleanProp(Node.IS_OPTIONAL_PARAM, true);\n          }\n          if (convention.isVarArgsParameter(arg) ||\n              typeExpr != null && typeExpr.isVarArgs()) {\n            arg.putBooleanProp(Node.IS_VAR_ARGS_PARAM, true);\n          }\n        }\n        break;\n    }\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "CollapseProperties.CollapseProperties",
    "class_name": "com.google.javascript.jscomp.CollapseProperties",
    "signature": "com.google.javascript.jscomp.CollapseProperties.CollapseProperties(AbstractCompiler,boolean,boolean)",
    "snippet": "  CollapseProperties(AbstractCompiler compiler,\n      boolean collapsePropertiesOnExternTypes, boolean inlineAliases) {\n    this.compiler = compiler;\n    this.collapsePropertiesOnExternTypes = collapsePropertiesOnExternTypes;\n    this.inlineAliases = inlineAliases;\n  }",
    "comment": " Creates an instance.  @param compiler The JSCompiler, for reporting code changes @param collapsePropertiesOnExternTypes if true, will rename user-defined static properties on externed typed. E.g. String.foo. @param inlineAliases Whether we're allowed to inline local aliases of namespaces, etc. ",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "CollapseProperties.addStubsForUndeclaredProperties",
    "class_name": "com.google.javascript.jscomp.CollapseProperties",
    "signature": "com.google.javascript.jscomp.CollapseProperties.addStubsForUndeclaredProperties(Name,String,Node,Node)",
    "snippet": "  private int addStubsForUndeclaredProperties(\n      Name n, String alias, Node parent, Node addAfter) {\n    Preconditions.checkArgument(NodeUtil.isStatementBlock(parent));\n    int numStubs = 0;\n    if (n.props != null) {\n      for (Name p : n.props) {\n        if (p.needsToBeStubbed()) {\n          String propAlias = alias + '$' + p.name;\n          Node nameNode = Node.newString(Token.NAME, propAlias);\n          Node newVar = new Node(Token.VAR, nameNode);\n          if (addAfter == null) {\n            parent.addChildToFront(newVar);\n          } else {\n            parent.addChildAfter(newVar, addAfter);\n            addAfter = newVar;\n          }\n          numStubs++;\n          compiler.reportCodeChange();\n\n          // Determine if this is a constant var by checking the first\n          // reference to it. Don't check the declaration, as it might be null.\n          if (p.refs.get(0).node.getLastChild().getBooleanProp(\n                Node.IS_CONSTANT_NAME)) {\n            nameNode.putBooleanProp(Node.IS_CONSTANT_NAME, true);\n          }\n        }\n      }\n    }\n    return numStubs;\n  }",
    "comment": " Adds global variable \"stubs\" for any properties of a global name that are only set in a local scope or read but never set.  @param n An object representing a global name (e.g. \"a\", \"a.b.c\") @param alias The flattened name of the object whose properties we are adding stubs for (e.g. \"a$b$c\") @param parent The node to which new global variables should be added as children @param addAfter The child of after which new variables should be added (may be null) @return The number of variables added ",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "CollapseProperties.checkForHosedThisReferences",
    "class_name": "com.google.javascript.jscomp.CollapseProperties",
    "signature": "com.google.javascript.jscomp.CollapseProperties.checkForHosedThisReferences(Node,JSDocInfo,Name)",
    "snippet": "  private void checkForHosedThisReferences(Node function, JSDocInfo docInfo,\n      final Name name) {\n    // A function is getting collapsed. Make sure that if it refers to\n    // \"this\", it must be a constructor or documented with @this.\n    if (docInfo == null ||\n        (!docInfo.isConstructor() && !docInfo.hasThisType())) {\n      NodeTraversal.traverse(compiler, function.getLastChild(),\n          new NodeTraversal.AbstractShallowCallback() {\n            public void visit(NodeTraversal t, Node n, Node parent) {\n              if (n.getType() == Token.THIS) {\n                compiler.report(\n                    JSError.make(name.declaration.sourceName, n,\n                        UNSAFE_THIS, name.fullName()));\n              }\n            }\n          });\n    }\n  }",
    "comment": " Warns about any references to \"this\" in the given FUNCTION. The function is getting collapsed, so the references will change. ",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "CollapseProperties.checkNamespaces",
    "class_name": "com.google.javascript.jscomp.CollapseProperties",
    "signature": "com.google.javascript.jscomp.CollapseProperties.checkNamespaces()",
    "snippet": "  private void checkNamespaces() {\n    for (Name name : nameMap.values()) {\n      if (name.isNamespace() && name.refs != null &&\n          (name.aliasingGets > 0 || name.localSets + name.globalSets > 1)) {\n        boolean initialized = name.declaration != null;\n        for (Ref ref : name.refs) {\n          if (ref.type == Ref.Type.SET_FROM_GLOBAL ||\n              ref.type == Ref.Type.SET_FROM_LOCAL) {\n            if (initialized) {\n              warnAboutNamespaceRedefinition(name, ref);\n            }\n\n            initialized = true;\n          } else if (ref.type == Ref.Type.ALIASING_GET) {\n            warnAboutNamespaceAliasing(name, ref);\n          }\n        }\n      }\n    }\n  }",
    "comment": " Runs through all namespaces (prefixes of classes and enums), and checks if any of them have been used in an unsafe way. ",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "CollapseProperties.collapseDeclarationOfNameAndDescendants",
    "class_name": "com.google.javascript.jscomp.CollapseProperties",
    "signature": "com.google.javascript.jscomp.CollapseProperties.collapseDeclarationOfNameAndDescendants(Name,String)",
    "snippet": "  private void collapseDeclarationOfNameAndDescendants(Name n, String alias) {\n    boolean canCollapseChildNames = n.canCollapseUnannotatedChildNames();\n\n    // Handle this name first so that nested object literals get unrolled.\n    if (n.canCollapse() && canCollapseChildNames) {\n      updateObjLitOrFunctionDeclaration(n, alias);\n    }\n\n    if (n.props != null) {\n      for (Name p : n.props) {\n        // Recurse first so that saved node ancestries are intact when needed.\n        collapseDeclarationOfNameAndDescendants(p, alias + '$' + p.name);\n\n        if (!p.inExterns && canCollapseChildNames && p.declaration != null &&\n            p.declaration.node != null &&\n            p.declaration.node.getParent() != null &&\n            p.declaration.node.getParent().getType() == Token.ASSIGN) {\n          updateSimpleDeclaration(alias + '$' + p.name, p.declaration);\n        }\n      }\n    }\n  }",
    "comment": " Collapses definitions of the collapsible properties of a global name. Recurses on subnames that also represent JavaScript objects with collapsible properties.  @param n A node representing a global name @param alias The flattened name for {@code n} ",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "CollapseProperties.declareVarsForObjLitValues",
    "class_name": "com.google.javascript.jscomp.CollapseProperties",
    "signature": "com.google.javascript.jscomp.CollapseProperties.declareVarsForObjLitValues(String,Node,Node,Node,Node,boolean)",
    "snippet": "  private int declareVarsForObjLitValues(\n      String alias, Node objlit, Node varNode, Node nameToAddAfter,\n      Node varParent, boolean discardKeys) {\n    int numVars = 0;\n    int arbitraryNameCounter = 0;\n\n    for (Node key = objlit.getFirstChild(), nextKey; key != null;\n         key = nextKey) {\n      Node value = key.getNext();\n      nextKey = value.getNext();\n\n      // We generate arbitrary names for keys that aren't valid JavaScript\n      // identifiers, since those keys are never referenced. (If they were,\n      // this object literal's child names wouldn't be collapsible.) The only\n      // reason that we don't eliminate them entirely is the off chance that\n      // their values are expressions that have side effects.\n      boolean isJsIdentifier = key.getType() != Token.NUMBER &&\n                               TokenStream.isJSIdentifier(key.getString());\n      String propAlias = alias + '$' +\n          (isJsIdentifier ? key.getString()\n              : String.valueOf(++arbitraryNameCounter));\n      String qName = propAlias.replace('$', '.');\n\n      Node refNode = null;\n      if (discardKeys) {\n        objlit.removeChild(key);\n        objlit.removeChild(value);\n      } else {\n        // Substitute a reference for the value.\n        refNode = Node.newString(Token.NAME, propAlias);\n        if (key.getBooleanProp(Node.IS_CONSTANT_NAME)) {\n          refNode.putBooleanProp(Node.IS_CONSTANT_NAME, true);\n        }\n        objlit.replaceChildAfter(key, refNode);\n      }\n\n      // Declare the collapsed name as a variable with the original value.\n      Node nameNode = Node.newString(Token.NAME, propAlias);\n      nameNode.addChildToFront(value);\n      if (key.getBooleanProp(Node.IS_CONSTANT_NAME)) {\n        nameNode.putBooleanProp(Node.IS_CONSTANT_NAME, true);\n      }\n      Node newVar = new Node(Token.VAR, nameNode);\n      if (nameToAddAfter != null) {\n        varParent.addChildAfter(newVar, nameToAddAfter);\n      } else {\n        varParent.addChildBefore(newVar, varNode);\n      }\n      compiler.reportCodeChange();\n      nameToAddAfter = newVar;\n\n      if (isJsIdentifier) {\n        // Update the global name's node ancestry if it hasn't already been\n        // done. (Duplicate keys in an object literal can bring us here twice\n        // for the same global name.)\n        Name p = nameMap.get(qName);\n        if (p != null) {\n          if (!discardKeys) {\n            Ref newAlias =\n                p.declaration.cloneAndReclassify(Ref.Type.ALIASING_GET);\n            newAlias.node = refNode;\n            p.addRef(newAlias);\n          }\n\n          p.declaration.node = nameNode;\n\n          if (value.getType() == Token.FUNCTION) {\n            checkForHosedThisReferences(value, value.getJSDocInfo(), p);\n          }\n        }\n      }\n\n      numVars++;\n    }\n    return numVars;\n  }",
    "comment": " Declares global variables to serve as aliases for the values in an object literal, optionally removing all of the object literal's keys and values.  @param alias The object literal's flattened name (e.g. \"a$b$c\") @param objlit The OBJLIT node @param varNode The VAR node to which new global variables should be added as children @param nameToAddAfter The child of {@code varNode} after which new variables should be added (may be null) @param varParent {@code varNode}'s parent @param discardKeys Whether to eliminate the object literal's keys after declaring variables for its values @return The number of variables added ",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "CollapseProperties.flattenNameRef",
    "class_name": "com.google.javascript.jscomp.CollapseProperties",
    "signature": "com.google.javascript.jscomp.CollapseProperties.flattenNameRef(String,Node,Node,String)",
    "snippet": "  private void flattenNameRef(String alias, Node n, Node parent,\n      String originalName) {\n    // BEFORE:\n    //   getprop\n    //     getprop\n    //       name a\n    //       string b\n    //     string c\n    // AFTER:\n    //   name a$b$c\n    Node ref = NodeUtil.newName(alias, n, originalName);\n    if (n.getLastChild().getBooleanProp(Node.IS_CONSTANT_NAME)) {\n      ref.putBooleanProp(Node.IS_CONSTANT_NAME, true);\n    }\n    parent.replaceChild(n, ref);\n    compiler.reportCodeChange();\n  }",
    "comment": " Replaces a GETPROP a.b.c with a NAME a$b$c.  @param alias A flattened prefix name (e.g. \"a$b\") @param n The GETPROP node corresponding to the original name (e.g. \"a.b\") @param parent {@code n}'s parent @param originalName String version of the property name. ",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "CollapseProperties.flattenNameRefAtDepth",
    "class_name": "com.google.javascript.jscomp.CollapseProperties",
    "signature": "com.google.javascript.jscomp.CollapseProperties.flattenNameRefAtDepth(String,Node,int,String)",
    "snippet": "  private void flattenNameRefAtDepth(String alias, Node n, int depth,\n      String originalName) {\n    // This method has to work for both GETPROP chains and, in rare cases,\n    // OBJLIT keys, possibly nested. That's why we check for children before\n    // proceeding. In the OBJLIT case, we don't need to do anything.\n    for (int i = 1; i < depth && n.hasChildren(); i++) {\n      n = n.getFirstChild();\n    }\n    if (n.hasChildren()) {\n      flattenNameRef(alias, n.getFirstChild(), n, originalName);\n    }\n  }",
    "comment": " Flattens a particular prefix of a single name reference.  @param alias A flattened prefix name (e.g. \"a$b\") @param n The node corresponding to a subproperty name (e.g. \"a.b.c.d\") @param depth The difference in depth between the property name and the prefix name (e.g. 2) @param originalName String version of the property name. ",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "CollapseProperties.flattenPrefixes",
    "class_name": "com.google.javascript.jscomp.CollapseProperties",
    "signature": "com.google.javascript.jscomp.CollapseProperties.flattenPrefixes(String,Name,int)",
    "snippet": "  private void flattenPrefixes(String alias, Name n, int depth) {\n    // Only flatten the prefix of a name declaration if the name being\n    // initialized is fully qualified (i.e. not an object literal key).\n    String originalName = n.fullName();\n    if (n.declaration != null && n.declaration.node != null &&\n        n.declaration.node.getType() == Token.GETPROP) {\n      flattenNameRefAtDepth(alias, n.declaration.node, depth, originalName);\n    }\n\n    if (n.refs != null) {\n      for (Ref r : n.refs) {\n\n        // References inside a complex assign (a = x.y = 0)\n        // have twins. We should only flatten one of the twins.\n        if (r.getTwin() == null || r.isSet()) {\n          flattenNameRefAtDepth(alias, r.node, depth, originalName);\n        }\n      }\n    }\n\n    if (n.props != null) {\n      for (Name p : n.props) {\n        flattenPrefixes(alias, p, depth + 1);\n      }\n    }\n  }",
    "comment": " Flattens all occurrences of a name as a prefix of subnames beginning with a particular subname.  @param n A global property name (e.g. \"a.b.c.d\") @param alias A flattened prefix name (e.g. \"a$b\") @param depth The difference in depth between the property name and the prefix name (e.g. 2) ",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "CollapseProperties.flattenReferencesTo",
    "class_name": "com.google.javascript.jscomp.CollapseProperties",
    "signature": "com.google.javascript.jscomp.CollapseProperties.flattenReferencesTo(Name,String)",
    "snippet": "  private void flattenReferencesTo(Name n, String alias) {\n    if (n.refs != null) {\n      String originalName = n.fullName();\n      for (Ref r : n.refs) {\n        Node rParent = r.node.getParent();\n\n        // There are two cases when we shouldn't flatten a reference:\n        // 1) Object literal keys, because duplicate keys show up as refs.\n        // 2) References inside a complex assign. (a = x.y = 0). These are\n        //    called TWIN references, because they show up twice in the\n        //    reference list. Only collapse the set, not the alias.\n        if (!NodeUtil.isObjectLitKey(r.node, rParent) &&\n            (r.getTwin() == null || r.isSet())) {\n          flattenNameRef(alias, r.node, rParent, originalName);\n        }\n      }\n    }\n\n    // Flatten all occurrences of a name as a prefix of its subnames. For\n    // example, if {@code n} corresponds to the name \"a.b\", then \"a.b\" will be\n    // replaced with \"a$b\" in all occurrences of \"a.b.c\", \"a.b.c.d\", etc.\n    if (n.props != null) {\n      for (Name p : n.props) {\n        flattenPrefixes(alias, p, 1);\n      }\n    }\n  }",
    "comment": " Flattens all references to a collapsible property of a global name except its initial definition.  @param n A global property name (e.g. \"a.b\" or \"a.b.c.d\") @param alias The flattened name (e.g. \"a$b\" or \"a$b$c$d\") ",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "CollapseProperties.flattenReferencesToCollapsibleDescendantNames",
    "class_name": "com.google.javascript.jscomp.CollapseProperties",
    "signature": "com.google.javascript.jscomp.CollapseProperties.flattenReferencesToCollapsibleDescendantNames(Name,String)",
    "snippet": "  private void flattenReferencesToCollapsibleDescendantNames(\n      Name n, String alias) {\n    if (n.props == null) return;\n\n    for (Name p : n.props) {\n      String propAlias = alias + '$' + p.name;\n\n      if (p.canCollapse()) {\n        flattenReferencesTo(p, propAlias);\n      }\n\n      flattenReferencesToCollapsibleDescendantNames(p, propAlias);\n    }\n  }",
    "comment": " Flattens all references to collapsible properties of a global name except their initial definitions. Recurses on subnames.  @param n An object representing a global name @param alias The flattened name for {@code n} ",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "CollapseProperties.inlineAliases",
    "class_name": "com.google.javascript.jscomp.CollapseProperties",
    "signature": "com.google.javascript.jscomp.CollapseProperties.inlineAliases(GlobalNamespace)",
    "snippet": "  private void inlineAliases(GlobalNamespace namespace) {\n    // Invariant: All the names in the worklist meet condition (a).\n    Deque<Name> workList = new ArrayDeque<Name>(namespace.getNameForest());\n    while (!workList.isEmpty()) {\n      Name name = workList.pop();\n\n      if (name.globalSets == 1 && name.localSets == 0 &&\n          name.aliasingGets > 0) {\n        // {@code name} meets condition (b). Find all of its local aliases\n        // and try to inline them.\n        List<Ref> refs = Lists.newArrayList(name.refs);\n        for (Ref ref : refs) {\n          if (ref.type == Type.ALIASING_GET && ref.scope.isLocal()) {\n            // {@code name} meets condition (c). Try to inline it.\n            if (inlineAliasIfPossible(ref, namespace)) {\n              name.removeRef(ref);\n            }\n          }\n        }\n      }\n\n      // Check if {@code name} has any aliases left after the\n      // local-alias-inlining above.\n      if ((name.type == Name.Type.OBJECTLIT ||\n           name.type == Name.Type.FUNCTION) &&\n          name.aliasingGets == 0 && name.props != null) {\n        // All of {@code name}'s children meet condition (a), so they can be\n        // added to the worklist.\n        workList.addAll(name.props);\n      }\n    }\n  }",
    "comment": " For each qualified name N in the global scope, we check if: (a) No ancestor of N is ever aliased or assigned an unknown value type. (If N = \"a.b.c\", \"a\" and \"a.b\" are never aliased). (b) N has exactly one write, and it lives in the global scope. (c) N is aliased in a local scope.  If (a) is true, then GlobalNamespace must know all the writes to N. If (a) and (b) are true, then N cannot change during the execution of a local scope. If (a) and (b) and (c) are true, then the alias can be inlined if the alias obeys the usual rules for how we decide whether a variable is inlineable. @see InlineVariables ",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "CollapseProperties.process",
    "class_name": "com.google.javascript.jscomp.CollapseProperties",
    "signature": "com.google.javascript.jscomp.CollapseProperties.process(Node,Node)",
    "snippet": "  public void process(Node externs, Node root) {\n    GlobalNamespace namespace;\n    if (collapsePropertiesOnExternTypes) {\n      namespace = new GlobalNamespace(compiler, externs, root);\n    } else {\n      namespace = new GlobalNamespace(compiler, root);\n    }\n\n    if (inlineAliases) {\n      inlineAliases(namespace);\n    }\n    nameMap = namespace.getNameIndex();\n    globalNames = namespace.getNameForest();\n    checkNamespaces();\n\n    for (Name n : globalNames) {\n      flattenReferencesToCollapsibleDescendantNames(n, n.name);\n    }\n\n    // We collapse property definitions after collapsing property references\n    // because this step can alter the parse tree above property references,\n    // invalidating the node ancestry stored with each reference.\n    for (Name n : globalNames) {\n      collapseDeclarationOfNameAndDescendants(n, n.name);\n    }\n  }",
    "comment": " {@inheritDoc} ",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "CollapseProperties.updateObjLitOrFunctionDeclaration",
    "class_name": "com.google.javascript.jscomp.CollapseProperties",
    "signature": "com.google.javascript.jscomp.CollapseProperties.updateObjLitOrFunctionDeclaration(Name,String)",
    "snippet": "  private void updateObjLitOrFunctionDeclaration(Name n, String alias) {\n    switch (n.declaration.node.getParent().getType()) {\n      case Token.ASSIGN:\n        updateObjLitOrFunctionDeclarationAtAssignNode(n, alias);\n        break;\n      case Token.VAR:\n        updateObjLitOrFunctionDeclarationAtVarNode(n);\n        break;\n      case Token.FUNCTION:\n        updateFunctionDeclarationAtFunctionNode(n);\n        break;\n    }\n  }",
    "comment": " Updates the first initialization (a.k.a \"declaration\") of a global name. This involves flattening the global name (if it's not just a global variable name already), collapsing object literal keys into global variables, declaring stub global variables for properties added later in a local scope, and eliminating the global name entirely (if possible).  @param n An object representing a global name (e.g. \"a\", \"a.b.c\") @param alias The flattened name for {@code n} (e.g. \"a\", \"a$b$c\") ",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "CollapseProperties.updateObjLitOrFunctionDeclarationAtAssignNode",
    "class_name": "com.google.javascript.jscomp.CollapseProperties",
    "signature": "com.google.javascript.jscomp.CollapseProperties.updateObjLitOrFunctionDeclarationAtAssignNode(Name,String)",
    "snippet": "  private void updateObjLitOrFunctionDeclarationAtAssignNode(\n      Name n, String alias) {\n    // NOTE: It's important that we don't add additional nodes\n    // (e.g. a var node before the exprstmt) because the exprstmt might be\n    // the child of an if statement that's not inside a block).\n\n    Ref ref = n.declaration;\n    Node rvalue = ref.node.getNext();\n    Node varNode = new Node(Token.VAR);\n    Node varParent = ref.node.getAncestor(3);\n    Node gramps = ref.node.getAncestor(2);\n    boolean isObjLit = rvalue.getType() == Token.OBJECTLIT;\n\n    if (isObjLit && n.canEliminate()) {\n      // Eliminate the object literal altogether.\n      varParent.replaceChild(gramps, varNode);\n      ref.node = null;\n\n    } else {\n      if (rvalue.getType() == Token.FUNCTION) {\n        checkForHosedThisReferences(rvalue, n.docInfo, n);\n      }\n\n      ref.node.getParent().removeChild(rvalue);\n\n      Node nameNode = NodeUtil.newName(\n          alias, ref.node.getAncestor(2), n.fullName());\n\n      if (ref.node.getLastChild().getBooleanProp(Node.IS_CONSTANT_NAME)) {\n        nameNode.putBooleanProp(Node.IS_CONSTANT_NAME, true);\n      }\n\n      varNode.addChildToBack(nameNode);\n      nameNode.addChildToFront(rvalue);\n      varParent.replaceChild(gramps, varNode);\n\n      // Update the node ancestry stored in the reference.\n      ref.node = nameNode;\n    }\n\n    if (isObjLit) {\n      boolean discardKeys = n.aliasingGets == 0;\n      declareVarsForObjLitValues(\n          alias, rvalue,\n          varNode, varParent.getChildBefore(varNode), varParent,\n          discardKeys);\n    }\n\n    addStubsForUndeclaredProperties(n, alias, varParent, varNode);\n\n    if (!varNode.hasChildren()) {\n      varParent.removeChild(varNode);\n    }\n\n    compiler.reportCodeChange();\n  }",
    "comment": " Updates the first initialization (a.k.a \"declaration\") of a global name that occurs at an ASSIGN node. See comment for {@link #updateObjLitOrFunctionDeclaration}.  @param n An object representing a global name (e.g. \"a\", \"a.b.c\") @param alias The flattened name for {@code n} (e.g. \"a\", \"a$b$c\") ",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "CollapseProperties.updateObjLitOrFunctionDeclarationAtVarNode",
    "class_name": "com.google.javascript.jscomp.CollapseProperties",
    "signature": "com.google.javascript.jscomp.CollapseProperties.updateObjLitOrFunctionDeclarationAtVarNode(Name)",
    "snippet": "  private void updateObjLitOrFunctionDeclarationAtVarNode(Name n) {\n    Ref ref = n.declaration;\n    String name = ref.node.getString();\n    Node rvalue = ref.node.getFirstChild();\n    Node varNode = ref.node.getParent();\n    Node gramps = varNode.getParent();\n\n    boolean isObjLit = rvalue.getType() == Token.OBJECTLIT;\n    int numChanges = 0;\n\n    if (isObjLit) {\n      boolean discardKeys = n.aliasingGets == 0;\n      numChanges += declareVarsForObjLitValues(\n          name, rvalue, varNode, gramps.getChildBefore(varNode),\n          gramps, discardKeys);\n    }\n\n    numChanges += addStubsForUndeclaredProperties(n, name, gramps, varNode);\n\n    if (isObjLit && n.canEliminate()) {\n      varNode.removeChild(ref.node);\n      if (!varNode.hasChildren()) {\n        gramps.removeChild(varNode);\n      }\n      numChanges++;\n\n      // Clear out the object reference, since we've eliminated it from the\n      // parse tree.\n      ref.node = null;\n    }\n\n    if (numChanges > 0) {\n      compiler.reportCodeChange();\n    }\n  }",
    "comment": " Updates the first initialization (a.k.a \"declaration\") of a global name that occurs at a VAR node. See comment for {@link #updateObjLitOrFunctionDeclaration}.  @param n An object representing a global name (e.g. \"a\") ",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "CollapseProperties.updateSimpleDeclaration",
    "class_name": "com.google.javascript.jscomp.CollapseProperties",
    "signature": "com.google.javascript.jscomp.CollapseProperties.updateSimpleDeclaration(String,Ref)",
    "snippet": "  private void updateSimpleDeclaration(String alias, Ref ref) {\n    Node rvalue = ref.node.getNext();\n    Node parent = ref.node.getParent();\n    Node gramps = parent.getParent();\n    Node greatGramps = gramps.getParent();\n    Node greatGreatGramps = greatGramps.getParent();\n\n    // Create the new alias node.\n    Node nameNode = NodeUtil.newName(alias, gramps.getFirstChild(),\n        alias.replace(\"$\", \".\"));\n    if (ref.node.getLastChild().getBooleanProp(Node.IS_CONSTANT_NAME)) {\n      nameNode.putBooleanProp(Node.IS_CONSTANT_NAME, true);\n    }\n\n    if (gramps.getType() == Token.EXPR_RESULT) {\n      // BEFORE: a.b.c = ...;\n      //   exprstmt\n      //     assign\n      //       getprop\n      //         getprop\n      //           name a\n      //           string b\n      //         string c\n      //       NODE\n      // AFTER: var a$b$c = ...;\n      //   var\n      //     name a$b$c\n      //       NODE\n\n      // Remove the rvalue (NODE).\n      parent.removeChild(rvalue);\n      nameNode.addChildToFront(rvalue);\n\n      Node varNode = new Node(Token.VAR, nameNode);\n      greatGramps.replaceChild(gramps, varNode);\n    } else {\n      // This must be a complex assignment.\n      Preconditions.checkNotNull(ref.getTwin());\n\n      // BEFORE:\n      // ... (x.y = 3);\n      //\n      // AFTER:\n      // var x$y;\n      // ... (x$y = 3);\n\n      Node current = gramps;\n      Node currentParent = gramps.getParent();\n      for (; currentParent.getType() != Token.SCRIPT &&\n             currentParent.getType() != Token.BLOCK;\n           current = currentParent,\n           currentParent = currentParent.getParent()) {}\n\n      // Create a stub variable declaration right\n      // before the current statement.\n      Node stubVar = new Node(Token.VAR, nameNode.cloneTree());\n      currentParent.addChildBefore(stubVar, current);\n\n      parent.replaceChild(ref.node, nameNode);\n    }\n\n    compiler.reportCodeChange();\n  }",
    "comment": " Updates the initial assignment to a collapsible property at global scope by changing it to a variable declaration (e.g. a.b = 1 -> var a$b = 1). The property's value may either be a primitive or an object literal or function whose properties aren't collapsible.  @param alias The flattened property name (e.g. \"a$b\") @param ref An object containing information about the assignment getting updated ",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "CombinedCompilerPass.CombinedCompilerPass",
    "class_name": "com.google.javascript.jscomp.CombinedCompilerPass",
    "signature": "com.google.javascript.jscomp.CombinedCompilerPass.CombinedCompilerPass(AbstractCompiler,Callback[])",
    "snippet": "  CombinedCompilerPass(\n      AbstractCompiler compiler, Callback... callbacks) {\n    this.compiler = compiler;\n    this.callbacks = new CallbackWrapper[callbacks.length];\n    for (int i = 0; i < callbacks.length; i++) {\n      this.callbacks[i] = new CallbackWrapper(callbacks[i]);\n    }\n  }",
    "comment": " Creates a combined compiler pass. @param compiler the compiler ",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "CombinedCompilerPass.enterScope",
    "class_name": "com.google.javascript.jscomp.CombinedCompilerPass",
    "signature": "com.google.javascript.jscomp.CombinedCompilerPass.enterScope(NodeTraversal)",
    "snippet": "  @Override\n  public void enterScope(NodeTraversal t) {\n    for (CallbackWrapper callback : callbacks) {\n      callback.enterScopeIfActive(t);\n    }\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "CombinedCompilerPass.exitScope",
    "class_name": "com.google.javascript.jscomp.CombinedCompilerPass",
    "signature": "com.google.javascript.jscomp.CombinedCompilerPass.exitScope(NodeTraversal)",
    "snippet": "  @Override\n  public void exitScope(NodeTraversal t) {\n    for (CallbackWrapper callback : callbacks) {\n      callback.exitScopeIfActive(t);\n    }\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "CombinedCompilerPass.process",
    "class_name": "com.google.javascript.jscomp.CombinedCompilerPass",
    "signature": "com.google.javascript.jscomp.CombinedCompilerPass.process(Node,Node)",
    "snippet": "  @Override\n  public final void process(Node externs, Node root) {\n    NodeTraversal.traverse(compiler, root, this);\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "CombinedCompilerPass.shouldTraverse",
    "class_name": "com.google.javascript.jscomp.CombinedCompilerPass",
    "signature": "com.google.javascript.jscomp.CombinedCompilerPass.shouldTraverse(NodeTraversal,Node,Node)",
    "snippet": "  @Override\n  public boolean shouldTraverse(NodeTraversal t, Node n, Node parent) {\n    for (CallbackWrapper callback : callbacks) {\n      callback.shouldTraverseIfActive(t, n, parent);\n    }\n    // Note that this method could return false if all callbacks are inactive.\n    // This apparent optimization would make this method more expensive\n    // in the typical case where not all nodes are inactive. It is\n    // very unlikely that many all callbacks would be inactive at the same\n    // time (indeed, there are several checking passes that never return false).\n    return true;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "CombinedCompilerPass.visit",
    "class_name": "com.google.javascript.jscomp.CombinedCompilerPass",
    "signature": "com.google.javascript.jscomp.CombinedCompilerPass.visit(NodeTraversal,Node,Node)",
    "snippet": "  @Override\n  public void visit(NodeTraversal t, Node n, Node parent) {\n    for (CallbackWrapper callback : callbacks) {\n      callback.visitOrMaybeActivate(t, n, parent);\n    }\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "CallbackWrapper.enterScopeIfActive",
    "class_name": "com.google.javascript.jscomp.CombinedCompilerPass$CallbackWrapper",
    "signature": "com.google.javascript.jscomp.CombinedCompilerPass$CallbackWrapper.enterScopeIfActive(NodeTraversal)",
    "snippet": "    void enterScopeIfActive(NodeTraversal t) {\n      if (isActive() && scopedCallback != null) {\n        scopedCallback.enterScope(t);\n      }\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "CallbackWrapper.exitScopeIfActive",
    "class_name": "com.google.javascript.jscomp.CombinedCompilerPass$CallbackWrapper",
    "signature": "com.google.javascript.jscomp.CombinedCompilerPass$CallbackWrapper.exitScopeIfActive(NodeTraversal)",
    "snippet": "    void exitScopeIfActive(NodeTraversal t) {\n      if (isActive() && scopedCallback != null) {\n        scopedCallback.exitScope(t);\n      }\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "CallbackWrapper.isActive",
    "class_name": "com.google.javascript.jscomp.CombinedCompilerPass$CallbackWrapper",
    "signature": "com.google.javascript.jscomp.CombinedCompilerPass$CallbackWrapper.isActive()",
    "snippet": "    boolean isActive() {\n      return waiting == null;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "CallbackWrapper.shouldTraverseIfActive",
    "class_name": "com.google.javascript.jscomp.CombinedCompilerPass$CallbackWrapper",
    "signature": "com.google.javascript.jscomp.CombinedCompilerPass$CallbackWrapper.shouldTraverseIfActive(NodeTraversal,Node,Node)",
    "snippet": "    void shouldTraverseIfActive(NodeTraversal t, Node n, Node parent) {\n      if (isActive() && !callback.shouldTraverse(t, n, parent)) {\n        waiting = n;\n      }\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "CallbackWrapper.visitOrMaybeActivate",
    "class_name": "com.google.javascript.jscomp.CombinedCompilerPass$CallbackWrapper",
    "signature": "com.google.javascript.jscomp.CombinedCompilerPass$CallbackWrapper.visitOrMaybeActivate(NodeTraversal,Node,Node)",
    "snippet": "    void visitOrMaybeActivate(NodeTraversal t, Node n, Node parent) {\n      if (isActive()) {\n        callback.visit(t, n, parent);\n      } else if (waiting == n) {\n        waiting = null;\n      }\n    }",
    "comment": " Visits the node unless the wrapped callback is inactive. Activates the callback if appropriate.  ",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "Compiler.Compiler",
    "class_name": "com.google.javascript.jscomp.Compiler",
    "signature": "com.google.javascript.jscomp.Compiler.Compiler()",
    "snippet": "  public Compiler() {\n    addChangeHandler(recentChange);\n    this.typeValidator = new TypeValidator(this);\n    setErrorManager(new LoggerErrorManager(createMessageFormatter(), logger_));\n  }",
    "comment": " Creates a Compiler that reports errors and warnings to its logger. ",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "Compiler.addChangeHandler",
    "class_name": "com.google.javascript.jscomp.Compiler",
    "signature": "com.google.javascript.jscomp.Compiler.addChangeHandler(CodeChangeHandler)",
    "snippet": "  @Override\n  void addChangeHandler(CodeChangeHandler handler) {\n    codeChangeHandlers.add(handler);\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "Compiler.annotateCodingConvention",
    "class_name": "com.google.javascript.jscomp.Compiler",
    "signature": "com.google.javascript.jscomp.Compiler.annotateCodingConvention(Node)",
    "snippet": "  @Override\n  void annotateCodingConvention(Node root) {\n    Tracer tracer = newTracer(\"annotateCodingConvention\");\n    CompilerPass pass = new CodingConventionAnnotator(this);\n    pass.process(null, root);\n    stopTracer(tracer, \"annotateCodingConvention\");\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "Compiler.createDefaultOptions",
    "class_name": "com.google.javascript.jscomp.Compiler",
    "signature": "com.google.javascript.jscomp.Compiler.createDefaultOptions()",
    "snippet": "  CompilerOptions createDefaultOptions() {\n    return new CompilerOptions();\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "Compiler.createMessageFormatter",
    "class_name": "com.google.javascript.jscomp.Compiler",
    "signature": "com.google.javascript.jscomp.Compiler.createMessageFormatter()",
    "snippet": "  private MessageFormatter createMessageFormatter() {\n    boolean colorize = options_.shouldColorizeErrorOutput();\n    return options_.errorFormat.toFormatter(this, colorize);\n  }",
    "comment": " Creates a message formatter instance corresponding to the value of {@link CompilerOptions}. ",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "Compiler.getCodingConvention",
    "class_name": "com.google.javascript.jscomp.Compiler",
    "signature": "com.google.javascript.jscomp.Compiler.getCodingConvention()",
    "snippet": "  @Override\n  public CodingConvention getCodingConvention() {\n    return codingConvention;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "Compiler.getDefaultErrorReporter",
    "class_name": "com.google.javascript.jscomp.Compiler",
    "signature": "com.google.javascript.jscomp.Compiler.getDefaultErrorReporter()",
    "snippet": "  @Override\n  ErrorReporter getDefaultErrorReporter() {\n    return defaultErrorReporter;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "Compiler.getErrorCount",
    "class_name": "com.google.javascript.jscomp.Compiler",
    "signature": "com.google.javascript.jscomp.Compiler.getErrorCount()",
    "snippet": "  public int getErrorCount() {\n    return errorManager.getErrorCount();\n  }",
    "comment": " Gets the number of errors. ",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "Compiler.getErrors",
    "class_name": "com.google.javascript.jscomp.Compiler",
    "signature": "com.google.javascript.jscomp.Compiler.getErrors()",
    "snippet": "  public JSError[] getErrors() {\n    return errorManager.getErrors();\n  }",
    "comment": " Returns the array of errors (never null). ",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "Compiler.getTypeRegistry",
    "class_name": "com.google.javascript.jscomp.Compiler",
    "signature": "com.google.javascript.jscomp.Compiler.getTypeRegistry()",
    "snippet": "  @Override\n  public JSTypeRegistry getTypeRegistry() {\n    if (typeRegistry == null) {\n      typeRegistry = new JSTypeRegistry(oldErrorReporter);\n    }\n    return typeRegistry;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "Compiler.getWarnings",
    "class_name": "com.google.javascript.jscomp.Compiler",
    "signature": "com.google.javascript.jscomp.Compiler.getWarnings()",
    "snippet": "  public JSError[] getWarnings() {\n    return errorManager.getWarnings();\n  }",
    "comment": " Returns the array of warnings (never null). ",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "Compiler.hasErrors",
    "class_name": "com.google.javascript.jscomp.Compiler",
    "signature": "com.google.javascript.jscomp.Compiler.hasErrors()",
    "snippet": "  public boolean hasErrors() {\n    return hasHaltingErrors();\n  }",
    "comment": " Consults the {@link ErrorManager} to see if we've encountered errors that should halt compilation. <p>  If {@link CompilerOptions#ideMode} is {@code true}, this function always returns {@code false} without consulting the error manager. The error manager will continue to be told about new errors and warnings, but the compiler will complete compilation of all inputs.<p> ",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "Compiler.hasHaltingErrors",
    "class_name": "com.google.javascript.jscomp.Compiler",
    "signature": "com.google.javascript.jscomp.Compiler.hasHaltingErrors()",
    "snippet": "  @Override\n  boolean hasHaltingErrors() {\n    return !isIdeMode() && getErrorCount() > 0;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "Compiler.init",
    "class_name": "com.google.javascript.jscomp.Compiler",
    "signature": "com.google.javascript.jscomp.Compiler.init(JSSourceFile[],JSSourceFile[],CompilerOptions)",
    "snippet": "  public void init(JSSourceFile[] externs, JSSourceFile[] inputs,\n      CompilerOptions options) {\n    externs_ = makeCompilerInput(externs, true);\n    modules_ = null;\n    moduleGraph_ = null;\n    inputs_ = makeCompilerInput(inputs, false);\n    options_ = options;\n\n    initInputsByNameMap();\n  }",
    "comment": " Initializes the instance state needed for a compile job. ",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "Compiler.initInputsByNameMap",
    "class_name": "com.google.javascript.jscomp.Compiler",
    "signature": "com.google.javascript.jscomp.Compiler.initInputsByNameMap()",
    "snippet": "  void initInputsByNameMap() {\n    inputsByName_ = new HashMap<String, CompilerInput>();\n    for (CompilerInput input : externs_) {\n      String name = input.getName();\n      if (!inputsByName_.containsKey(name)) {\n        inputsByName_.put(name, input);\n      } else {\n        report(JSError.make(DUPLICATE_EXTERN_INPUT, name));\n      }\n    }\n    for (CompilerInput input : inputs_) {\n      String name = input.getName();\n      if (!inputsByName_.containsKey(name)) {\n        inputsByName_.put(name, input);\n      } else {\n        report(JSError.make(DUPLICATE_INPUT, name));\n      }\n    }\n  }",
    "comment": " Creates a map to make looking up an input by name fast. Also checks for duplicate inputs. ",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "Compiler.isIdeMode",
    "class_name": "com.google.javascript.jscomp.Compiler",
    "signature": "com.google.javascript.jscomp.Compiler.isIdeMode()",
    "snippet": "  @Override\n  public boolean isIdeMode() {\n    return options_.ideMode;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "Compiler.makeCompilerInput",
    "class_name": "com.google.javascript.jscomp.Compiler",
    "signature": "com.google.javascript.jscomp.Compiler.makeCompilerInput(JSSourceFile[],boolean)",
    "snippet": "  private CompilerInput[] makeCompilerInput(\n      JSSourceFile[] files, boolean isExtern) {\n    CompilerInput [] inputs = new CompilerInput[files.length];\n    for (int i = 0; i < files.length; ++i) {\n      inputs[i] = new CompilerInput(files[i], isExtern);\n    }\n    return inputs;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "Compiler.newTracer",
    "class_name": "com.google.javascript.jscomp.Compiler",
    "signature": "com.google.javascript.jscomp.Compiler.newTracer(String)",
    "snippet": "  Tracer newTracer(String passName) {\n    String comment = passName\n        + (recentChange.hasCodeChanged() ? \" on recently changed AST\" : \"\");\n    if (options_.tracer.isOn()) {\n      tracker.recordPassStart(passName);\n    }\n    return new Tracer(\"Compiler\", comment);\n  }",
    "comment": " Returns a new tracer for the given pass name. ",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "Compiler.normalizeNodeTypes",
    "class_name": "com.google.javascript.jscomp.Compiler",
    "signature": "com.google.javascript.jscomp.Compiler.normalizeNodeTypes(Node)",
    "snippet": "  @Override\n  void normalizeNodeTypes(Node root) {\n    Tracer tracer = newTracer(\"normalizeNodeTypes\");\n\n    // TODO(johnlenz): Move the Node type normalizer into the general\n    // Normalization pass once we force everybody to turn it on. It's\n    // confusing to have a mandatory normalization pass and an optional\n    // one.\n    CompilerPass pass = new NodeTypeNormalizer();\n    pass.process(null, root);\n\n    stopTracer(tracer, \"normalizeNodeTypes\");\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "Compiler.parseInputs",
    "class_name": "com.google.javascript.jscomp.Compiler",
    "signature": "com.google.javascript.jscomp.Compiler.parseInputs()",
    "snippet": "  Node parseInputs() {\n    boolean devMode = options_.devMode != DevMode.OFF;\n\n    // If old roots exist (we are parsing a second time), detach each of the\n    // individual file parse trees.\n    if (externsRoot != null) {\n      externsRoot.detachChildren();\n    }\n    if (jsRoot != null) {\n      jsRoot.detachChildren();\n    }\n\n    // Parse main js sources.\n    jsRoot = new Node(Token.BLOCK);\n    jsRoot.setIsSyntheticBlock(true);\n\n    if (options_.tracer.isOn()) {\n      tracker = new PerformanceTracker(jsRoot,\n          options_.tracer == TracerMode.ALL);\n      addChangeHandler(tracker.getCodeChangeHandler());\n    }\n\n    Tracer tracer = newTracer(\"parseInputs\");\n\n    try {\n      // Parse externs sources.\n      externsRoot = new Node(Token.BLOCK);\n      externsRoot.setIsSyntheticBlock(true);\n      for (CompilerInput input : externs_) {\n        Node n = input.getAstRoot(this);\n        if (hasErrors()) {\n          return null;\n        }\n        externsRoot.addChildToBack(n);\n      }\n\n      for (CompilerInput input : inputs_) {\n        Node n = input.getAstRoot(this);\n        if (hasErrors()) {\n          return null;\n        }\n\n        // Inputs can have a null AST during initial parse.\n        if (n == null) {\n          continue;\n        }\n\n        if (devMode) {\n          sanityCheck.create(this).process(null, n);\n          if (hasErrors()) {\n            return null;\n          }\n        }\n\n        if (options_.sourceMapOutputPath != null ||\n            options_.nameReferenceReportPath != null) {\n\n          // Annotate the nodes in the tree with information from the\n          // input file. This information is used to construct the SourceMap.\n          SourceInformationAnnotator sia =\n              new SourceInformationAnnotator(input.getName());\n          NodeTraversal.traverse(this, n, sia);\n        }\n\n        jsRoot.addChildToBack(n);\n      }\n\n      externAndJsRoot = new Node(Token.BLOCK, externsRoot, jsRoot);\n      externAndJsRoot.setIsSyntheticBlock(true);\n\n      return externAndJsRoot;\n    } finally {\n      stopTracer(tracer, \"parseInputs\");\n    }\n  }",
    "comment": " Parses the externs and main inputs.  @return A synthetic root node whose two children are the externs root and the main root ",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "Compiler.report",
    "class_name": "com.google.javascript.jscomp.Compiler",
    "signature": "com.google.javascript.jscomp.Compiler.report(JSError)",
    "snippet": "  @Override\n  void report(JSError error) {\n    CheckLevel level = error.level;\n    WarningsGuard guard = options_.getWarningsGuard();\n    if (guard != null) {\n      CheckLevel newLevel = guard.level(error);\n      if (newLevel != null) {\n        level = newLevel;\n      }\n    }\n\n    if (level.isOn()) {\n      errorManager.report(level, error);\n    }\n  }",
    "comment": "------------------------------------------------------------------------",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "Compiler.setCodingConvention",
    "class_name": "com.google.javascript.jscomp.Compiler",
    "signature": "com.google.javascript.jscomp.Compiler.setCodingConvention(CodingConvention)",
    "snippet": "  public void setCodingConvention(CodingConvention convention) {\n    Preconditions.checkState(convention != null);\n    codingConvention = convention;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "Compiler.setErrorManager",
    "class_name": "com.google.javascript.jscomp.Compiler",
    "signature": "com.google.javascript.jscomp.Compiler.setErrorManager(ErrorManager)",
    "snippet": "  public void setErrorManager(ErrorManager errorManager) {\n    Preconditions.checkNotNull(\n        errorManager, \"the error manager cannot be null\");\n    this.errorManager = errorManager;\n  }",
    "comment": " Sets the error manager.  @param errorManager the error manager, it cannot be {@code null} ",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "Compiler.stopTracer",
    "class_name": "com.google.javascript.jscomp.Compiler",
    "signature": "com.google.javascript.jscomp.Compiler.stopTracer(Tracer,String)",
    "snippet": "  void stopTracer(Tracer t, String passName) {\n    long result = t.stop();\n    if (options_.tracer.isOn()) {\n      tracker.recordPassStop(passName, result);\n    }\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "CompilerInput.CompilerInput",
    "class_name": "com.google.javascript.jscomp.CompilerInput",
    "signature": "com.google.javascript.jscomp.CompilerInput.CompilerInput(JSSourceFile,boolean)",
    "snippet": "  public CompilerInput(JSSourceFile file, boolean isExtern) {\n    this.ast = new JsAst(file);\n    this.name = file.getName();\n    this.isExtern = isExtern;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "CompilerInput.getAstRoot",
    "class_name": "com.google.javascript.jscomp.CompilerInput",
    "signature": "com.google.javascript.jscomp.CompilerInput.getAstRoot(AbstractCompiler)",
    "snippet": "  @Override\n  public Node getAstRoot(AbstractCompiler compiler) {\n    return ast.getAstRoot(compiler);\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "CompilerInput.getName",
    "class_name": "com.google.javascript.jscomp.CompilerInput",
    "signature": "com.google.javascript.jscomp.CompilerInput.getName()",
    "snippet": "  public String getName() {\n    return name;\n  }",
    "comment": "Returns a name for this input. Must be unique across all inputs. */",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "CompilerOptions.CompilerOptions",
    "class_name": "com.google.javascript.jscomp.CompilerOptions",
    "signature": "com.google.javascript.jscomp.CompilerOptions.CompilerOptions()",
    "snippet": "  public CompilerOptions() {\n    // Checks\n    skipAllPasses = false;\n    nameAnonymousFunctionsOnly = false;\n    devMode = DevMode.OFF;\n    checkSymbols = false;\n    checkShadowVars = CheckLevel.OFF;\n    aggressiveVarCheck = CheckLevel.OFF;\n    checkFunctions = CheckLevel.OFF;\n    checkMethods = CheckLevel.OFF;\n    checkDuplicateMessages = false;\n    allowLegacyJsMessages = false;\n    strictMessageReplacement = false;\n    checkSuspiciousCode = false;\n    checkControlStructures = false;\n    checkUndefinedProperties = CheckLevel.OFF;\n    checkUnusedPropertiesEarly = false;\n    checkTypes = false;\n    tightenTypes = false;\n    inferTypesInGlobalScope = false;\n    checkTypedPropertyCalls = false;\n    reportMissingOverride = CheckLevel.OFF;\n    reportUnknownTypes = CheckLevel.OFF;\n    checkRequires = CheckLevel.OFF;\n    checkProvides = CheckLevel.OFF;\n    checkGlobalNamesLevel = CheckLevel.OFF;\n    brokenClosureRequiresLevel = CheckLevel.ERROR;\n    checkGlobalThisLevel = CheckLevel.WARNING;\n    checkUnreachableCode = CheckLevel.OFF;\n    checkMissingReturn = CheckLevel.OFF;\n    checkMissingGetCssNameLevel = CheckLevel.OFF;\n    checkMissingGetCssNameBlacklist = null;\n    checkEs5Strict = false;\n    checkCaja = false;\n    computeFunctionSideEffects = false;\n    chainCalls = false;\n\n    // Optimizations\n    foldConstants = false;\n    removeConstantExpressions = false;\n    coalesceVariableNames = false;\n    deadAssignmentElimination = false;\n    inlineConstantVars = false;\n    inlineFunctions = false;\n    crossModuleCodeMotion = false;\n    crossModuleMethodMotion = false;\n    inlineGetters = false;\n    inlineVariables = false;\n    smartNameRemoval = false;\n    removeDeadCode = false;\n    extractPrototypeMemberDeclarations = false;\n    removeUnusedPrototypeProperties = false;\n    removeUnusedPrototypePropertiesInExterns = false;\n    removeUnusedVars = false;\n    removeUnusedVarsInGlobalScope = true;\n    aliasExternals = false;\n    collapseVariableDeclarations = false;\n    collapseAnonymousFunctions = false;\n    aliasableStrings = Collections.emptySet();\n    aliasStringsBlacklist = \"\";\n    aliasAllStrings = false;\n    convertToDottedProperties = false;\n    rewriteFunctionExpressions = false;\n    optimizeParameters = false;\n\n    // Renaming\n    variableRenaming = VariableRenamingPolicy.OFF;\n    propertyRenaming = PropertyRenamingPolicy.OFF;\n    labelRenaming = false;\n    generatePseudoNames = false;\n    renamePrefix = null;\n    aliasKeywords = false;\n    collapseProperties = false;\n    collapsePropertiesOnExternTypes = false;\n    devirtualizePrototypeMethods = false;\n    disambiguateProperties = false;\n    ambiguateProperties = false;\n    anonymousFunctionNaming = AnonymousFunctionNamingPolicy.OFF;\n    exportTestFunctions = false;\n\n    // Alterations\n    instrumentForCoverage = false;\n    instrumentForCoverageOnly = false;\n    syntheticBlockStartMarker = null;\n    syntheticBlockEndMarker = null;\n    locale = null;\n    markAsCompiled = false;\n    removeTryCatchFinally = false;\n    closurePass = false;\n    rewriteNewDateGoogNow = true;\n    stripTypes = Collections.emptySet();\n    stripNameSuffixes = Collections.emptySet();\n    stripNamePrefixes = Collections.emptySet();\n    stripTypePrefixes = Collections.emptySet();\n    customPasses = null;\n    markNoSideEffectCalls = false;\n    defineReplacements = Maps.newHashMap();\n    moveFunctionDeclarations = false;\n    instrumentationTemplate = null;\n    appNameStr = \"\";\n    recordFunctionInformation = false;\n    generateExports = false;\n    cssRenamingMap = null;\n    processObjectPropertyString = false;\n    idGenerators = Collections.emptySet();\n\n    // Output\n    printInputDelimiter = false;\n    prettyPrint = false;\n    lineBreak = false;\n    reportPath = null;\n    tracer = TracerMode.OFF;\n    colorizeErrorOutput = false;\n    errorFormat = ErrorFormat.SINGLELINE;\n    warningsGuard = null;\n    debugFunctionSideEffectsPath = null;\n    jsOutputFile = \"\";\n    nameReferenceReportPath = null;\n    nameReferenceGraphPath = null;\n  }",
    "comment": " Initializes compiler options. All options are disabled by default.  Command-line frontends to the compiler should set these properties like a builder. ",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "CompilerOptions.addWarningsGuard",
    "class_name": "com.google.javascript.jscomp.CompilerOptions",
    "signature": "com.google.javascript.jscomp.CompilerOptions.addWarningsGuard(WarningsGuard)",
    "snippet": "  public void addWarningsGuard(WarningsGuard guard) {\n    if (warningsGuard == null) {\n      warningsGuard = new ComposeWarningsGuard(guard);\n    } else {\n      warningsGuard.addGuard(guard);\n    }\n  }",
    "comment": " Add a guard to the set of warnings guards. ",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "CompilerOptions.getWarningsGuard",
    "class_name": "com.google.javascript.jscomp.CompilerOptions",
    "signature": "com.google.javascript.jscomp.CompilerOptions.getWarningsGuard()",
    "snippet": "  WarningsGuard getWarningsGuard() {\n    return warningsGuard;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "CompilerOptions.setWarningLevel",
    "class_name": "com.google.javascript.jscomp.CompilerOptions",
    "signature": "com.google.javascript.jscomp.CompilerOptions.setWarningLevel(DiagnosticGroup,CheckLevel)",
    "snippet": "  public void setWarningLevel(DiagnosticGroup type, CheckLevel level) {\n    addWarningsGuard(new DiagnosticGroupWarningsGuard(type, level));\n  }",
    "comment": " Configure the given type of warning to the given level. ",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "CompilerOptions.shouldColorizeErrorOutput",
    "class_name": "com.google.javascript.jscomp.CompilerOptions",
    "signature": "com.google.javascript.jscomp.CompilerOptions.shouldColorizeErrorOutput()",
    "snippet": "  public boolean shouldColorizeErrorOutput() {\n    return colorizeErrorOutput;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "TracerMode.isOn",
    "class_name": "com.google.javascript.jscomp.CompilerOptions$TracerMode",
    "signature": "com.google.javascript.jscomp.CompilerOptions$TracerMode.isOn()",
    "snippet": "    boolean isOn() {\n      return this != OFF;\n    }",
    "comment": "Collect no timing and size metrics.",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "ComposeWarningsGuard.ComposeWarningsGuard",
    "class_name": "com.google.javascript.jscomp.ComposeWarningsGuard",
    "signature": "com.google.javascript.jscomp.ComposeWarningsGuard.ComposeWarningsGuard(List)",
    "snippet": "  public ComposeWarningsGuard(List<WarningsGuard> guards) {\n    this.guards = new PriorityQueue<WarningsGuard>(\n        5,\n        new Comparator<WarningsGuard>() {\n      @Override\n      public int compare(WarningsGuard a, WarningsGuard b) {\n        return a.getPriority() - b.getPriority();\n      }\n    });\n    addGuards(guards);\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "ComposeWarningsGuard.ComposeWarningsGuard",
    "class_name": "com.google.javascript.jscomp.ComposeWarningsGuard",
    "signature": "com.google.javascript.jscomp.ComposeWarningsGuard.ComposeWarningsGuard(WarningsGuard[])",
    "snippet": "  public ComposeWarningsGuard(WarningsGuard... guards) {\n    this(Lists.newArrayList(guards));\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "ComposeWarningsGuard.addGuard",
    "class_name": "com.google.javascript.jscomp.ComposeWarningsGuard",
    "signature": "com.google.javascript.jscomp.ComposeWarningsGuard.addGuard(WarningsGuard)",
    "snippet": "  void addGuard(WarningsGuard guard) {\n    if (guard instanceof ComposeWarningsGuard) {\n      addGuards(((ComposeWarningsGuard) guard).guards);\n    } else {\n      this.guards.add(guard);\n    }\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "ComposeWarningsGuard.addGuards",
    "class_name": "com.google.javascript.jscomp.ComposeWarningsGuard",
    "signature": "com.google.javascript.jscomp.ComposeWarningsGuard.addGuards(Iterable)",
    "snippet": "  private void addGuards(Iterable<WarningsGuard> guards) {\n    for (WarningsGuard guard : guards) {\n      addGuard(guard);\n    }\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "ComposeWarningsGuard.level",
    "class_name": "com.google.javascript.jscomp.ComposeWarningsGuard",
    "signature": "com.google.javascript.jscomp.ComposeWarningsGuard.level(JSError)",
    "snippet": "  @Override\n  public CheckLevel level(JSError error) {\n    for (WarningsGuard guard : guards) {\n      CheckLevel newLevel = guard.level(error);\n      if (newLevel != null) {\n        return newLevel;\n      }\n    }\n    return null;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "DiagnosticGroup.DiagnosticGroup",
    "class_name": "com.google.javascript.jscomp.DiagnosticGroup",
    "signature": "com.google.javascript.jscomp.DiagnosticGroup.DiagnosticGroup(DiagnosticGroup[])",
    "snippet": "  public DiagnosticGroup(DiagnosticGroup ...groups) {\n    Set<DiagnosticType> set = Sets.newHashSet();\n\n    for (DiagnosticGroup group : groups) {\n      set.addAll(group.types);\n    }\n\n    this.types = ImmutableSet.copyOf(set);\n  }",
    "comment": " Create a composite group. ",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "DiagnosticGroup.DiagnosticGroup",
    "class_name": "com.google.javascript.jscomp.DiagnosticGroup",
    "signature": "com.google.javascript.jscomp.DiagnosticGroup.DiagnosticGroup(DiagnosticType[])",
    "snippet": "  public DiagnosticGroup(DiagnosticType ...types) {\n    this.types = ImmutableSet.copyOf(Arrays.asList(types));\n  }",
    "comment": " Create a group that matches all errors of the given types. ",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "DiagnosticGroup.matches",
    "class_name": "com.google.javascript.jscomp.DiagnosticGroup",
    "signature": "com.google.javascript.jscomp.DiagnosticGroup.matches(DiagnosticType)",
    "snippet": "  public boolean matches(DiagnosticType type) {\n    return types.contains(type);\n  }",
    "comment": " Returns whether the given type matches a type in this group. ",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "DiagnosticGroup.matches",
    "class_name": "com.google.javascript.jscomp.DiagnosticGroup",
    "signature": "com.google.javascript.jscomp.DiagnosticGroup.matches(JSError)",
    "snippet": "  public boolean matches(JSError error) {\n    return matches(error.getType());\n  }",
    "comment": " Returns whether the given error's type matches a type in this group. ",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "DiagnosticGroupWarningsGuard.DiagnosticGroupWarningsGuard",
    "class_name": "com.google.javascript.jscomp.DiagnosticGroupWarningsGuard",
    "signature": "com.google.javascript.jscomp.DiagnosticGroupWarningsGuard.DiagnosticGroupWarningsGuard(DiagnosticGroup,CheckLevel)",
    "snippet": "  public DiagnosticGroupWarningsGuard(\n      DiagnosticGroup group, CheckLevel level) {\n    this.group = group;\n    this.level = level;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "DiagnosticGroupWarningsGuard.level",
    "class_name": "com.google.javascript.jscomp.DiagnosticGroupWarningsGuard",
    "signature": "com.google.javascript.jscomp.DiagnosticGroupWarningsGuard.level(JSError)",
    "snippet": "  @Override\n  public CheckLevel level(JSError error) {\n    return group.matches(error) ? level : null;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "DiagnosticGroups.registerGroup",
    "class_name": "com.google.javascript.jscomp.DiagnosticGroups",
    "signature": "com.google.javascript.jscomp.DiagnosticGroups.registerGroup(String,DiagnosticGroup)",
    "snippet": "  static DiagnosticGroup registerGroup(String name,\n      DiagnosticGroup group) {\n    groupsByName.put(name, group);\n    return group;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "DiagnosticType.disabled",
    "class_name": "com.google.javascript.jscomp.DiagnosticType",
    "signature": "com.google.javascript.jscomp.DiagnosticType.disabled(String,String)",
    "snippet": "  public static DiagnosticType disabled(String name,\n      String descriptionFormat) {\n    return make(name, CheckLevel.OFF, descriptionFormat);\n  }",
    "comment": " Create a DiagnosticType at level CheckLevel.OFF  @param name An identifier @param descriptionFormat A format string @return A new DiagnosticType ",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "DiagnosticType.error",
    "class_name": "com.google.javascript.jscomp.DiagnosticType",
    "signature": "com.google.javascript.jscomp.DiagnosticType.error(String,String)",
    "snippet": "  public static DiagnosticType error(String name, String descriptionFormat) {\n    return make(name, CheckLevel.ERROR, descriptionFormat);\n  }",
    "comment": " Create a DiagnosticType at level CheckLevel.ERROR  @param name An identifier @param descriptionFormat A format string @return A new DiagnosticType ",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "DiagnosticType.make",
    "class_name": "com.google.javascript.jscomp.DiagnosticType",
    "signature": "com.google.javascript.jscomp.DiagnosticType.make(String,CheckLevel,String)",
    "snippet": "  public static DiagnosticType make(String name, CheckLevel level,\n                                    String descriptionFormat) {\n    return\n        new DiagnosticType(name, level, new MessageFormat(descriptionFormat));\n  }",
    "comment": " Create a DiagnosticType at a given CheckLevel.  @param name An identifier @param level Either CheckLevel.ERROR or CheckLevel.WARNING @param descriptionFormat A format string @return A new DiagnosticType ",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "DiagnosticType.warning",
    "class_name": "com.google.javascript.jscomp.DiagnosticType",
    "signature": "com.google.javascript.jscomp.DiagnosticType.warning(String,String)",
    "snippet": "  public static DiagnosticType warning(String name, String descriptionFormat) {\n    return make(name, CheckLevel.WARNING, descriptionFormat);\n  }",
    "comment": " Create a DiagnosticType at level CheckLevel.WARNING  @param name An identifier @param descriptionFormat A format string @return A new DiagnosticType ",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "GlobalNamespace.GlobalNamespace",
    "class_name": "com.google.javascript.jscomp.GlobalNamespace",
    "signature": "com.google.javascript.jscomp.GlobalNamespace.GlobalNamespace(AbstractCompiler,Node)",
    "snippet": "  GlobalNamespace(AbstractCompiler compiler, Node root) {\n    this(compiler, null, root);\n  }",
    "comment": " Creates an instance that may emit warnings when building the namespace.  @param compiler The AbstractCompiler, for reporting code changes @param root The root of the rest of the code to build a namespace for. ",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "GlobalNamespace.GlobalNamespace",
    "class_name": "com.google.javascript.jscomp.GlobalNamespace",
    "signature": "com.google.javascript.jscomp.GlobalNamespace.GlobalNamespace(AbstractCompiler,Node,Node)",
    "snippet": "  GlobalNamespace(AbstractCompiler compiler, Node externsRoot, Node root) {\n    this.compiler = compiler;\n    this.externsRoot = externsRoot;\n    this.root = root;\n  }",
    "comment": " Creates an instance that may emit warnings when building the namespace.  @param compiler The AbstractCompiler, for reporting code changes @param externsRoot The root of the externs to build a namespace for. If this is null, externs and properties defined on extern types will not be included in the global namespace.  If non-null, it allows user-defined function on extern types to be included in the global namespace.  E.g. String.foo. @param root The root of the rest of the code to build a namespace for. ",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "GlobalNamespace.getNameForest",
    "class_name": "com.google.javascript.jscomp.GlobalNamespace",
    "signature": "com.google.javascript.jscomp.GlobalNamespace.getNameForest()",
    "snippet": "  List<Name> getNameForest() {\n    if (!generated) {\n      process();\n    }\n    return globalNames;\n  }",
    "comment": " Gets a list of the roots of the forest of the global names, where the roots are the top-level names. ",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "GlobalNamespace.getNameIndex",
    "class_name": "com.google.javascript.jscomp.GlobalNamespace",
    "signature": "com.google.javascript.jscomp.GlobalNamespace.getNameIndex()",
    "snippet": "  Map<String, Name> getNameIndex() {\n    if (!generated) {\n      process();\n    }\n    return nameMap;\n  }",
    "comment": " Gets an index of all the global names, indexed by full qualified name (as in \"a\", \"a.b.c\", etc.). ",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "GlobalNamespace.getTopVarName",
    "class_name": "com.google.javascript.jscomp.GlobalNamespace",
    "signature": "com.google.javascript.jscomp.GlobalNamespace.getTopVarName(String)",
    "snippet": "  private String getTopVarName(String name) {\n    int firstDotIndex = name.indexOf('.');\n    return firstDotIndex == -1 ? name : name.substring(0, firstDotIndex);\n  }",
    "comment": " Gets the top variable name from a possibly namespaced name.  @param name A variable or qualified property name (e.g. \"a\" or \"a.b.c.d\") @return The top variable name (e.g. \"a\") ",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "GlobalNamespace.isGlobalNameReference",
    "class_name": "com.google.javascript.jscomp.GlobalNamespace",
    "signature": "com.google.javascript.jscomp.GlobalNamespace.isGlobalNameReference(String,Scope)",
    "snippet": "  private boolean isGlobalNameReference(String name, Scope s) {\n    String topVarName = getTopVarName(name);\n    return isGlobalVarReference(topVarName, s);\n  }",
    "comment": " Determines whether a name reference in a particular scope is a global name reference.  @param name A variable or property name (e.g. \"a\" or \"a.b.c.d\") @param s The scope in which the name is referenced @return Whether the name reference is a global name reference ",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "GlobalNamespace.isGlobalScope",
    "class_name": "com.google.javascript.jscomp.GlobalNamespace",
    "signature": "com.google.javascript.jscomp.GlobalNamespace.isGlobalScope(Scope)",
    "snippet": "  private boolean isGlobalScope(Scope s) {\n    return s.getParent() == null;\n  }",
    "comment": " Gets whether a scope is the global scope.  @param s A scope @return Whether the scope is the global scope ",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "GlobalNamespace.isGlobalVarReference",
    "class_name": "com.google.javascript.jscomp.GlobalNamespace",
    "signature": "com.google.javascript.jscomp.GlobalNamespace.isGlobalVarReference(String,Scope)",
    "snippet": "  private boolean isGlobalVarReference(String name, Scope s) {\n    Scope.Var v = s.getVar(name);\n    if (v == null && externsScope != null) {\n      v = externsScope.getVar(name);\n    }\n    return v != null && !v.isLocal();\n  }",
    "comment": " Determines whether a variable name reference in a particular scope is a global variable reference.  @param name A variable name (e.g. \"a\") @param s The scope in which the name is referenced @return Whether the name reference is a global variable reference ",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "GlobalNamespace.process",
    "class_name": "com.google.javascript.jscomp.GlobalNamespace",
    "signature": "com.google.javascript.jscomp.GlobalNamespace.process()",
    "snippet": "  private void process() {\n    if (externsRoot != null) {\n      inExterns = true;\n      NodeTraversal.traverse(compiler, externsRoot, new BuildGlobalNamespace());\n    }\n    inExterns = false;\n\n    NodeTraversal.traverse(compiler, root, new BuildGlobalNamespace());\n    generated = true;\n  }",
    "comment": " Builds the namespace lazily. ",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "BuildGlobalNamespace.getOrCreateName",
    "class_name": "com.google.javascript.jscomp.GlobalNamespace$BuildGlobalNamespace",
    "signature": "com.google.javascript.jscomp.GlobalNamespace$BuildGlobalNamespace.getOrCreateName(String)",
    "snippet": "    Name getOrCreateName(String name) {\n      Name node = nameMap.get(name);\n      if (node == null) {\n        int i = name.lastIndexOf('.');\n        if (i >= 0) {\n          String parentName = name.substring(0, i);\n          Name parent = getOrCreateName(parentName);\n          node = parent.addProperty(name.substring(i + 1), inExterns);\n        } else {\n          node = new Name(name, null, inExterns);\n          globalNames.add(node);\n        }\n        nameMap.put(name, node);\n      }\n      return node;\n    }",
    "comment": " Gets a {@link Name} instance for a global name. Creates it if necessary, as well as instances for any of its prefixes that are not yet defined.  @param name A global name (e.g. \"a\", \"a.b.c.d\") @return The {@link Name} instance for {@code name} ",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "BuildGlobalNamespace.getValueType",
    "class_name": "com.google.javascript.jscomp.GlobalNamespace$BuildGlobalNamespace",
    "signature": "com.google.javascript.jscomp.GlobalNamespace$BuildGlobalNamespace.getValueType(Node)",
    "snippet": "    Name.Type getValueType(Node n) {\n      switch (n.getType()) {\n        case Token.OBJECTLIT:\n          return Name.Type.OBJECTLIT;\n        case Token.FUNCTION:\n          return Name.Type.FUNCTION;\n        case Token.OR:\n          // Recurse on the second value. If the first value were an object\n          // literal or function, then the OR would be meaningless and the\n          // second value would be dead code. Assume that if the second value\n          // is an object literal or function, then the first value will also\n          // evaluate to one when it doesn't evaluate to false.\n          return getValueType(n.getLastChild());\n        case Token.HOOK:\n          // The same line of reasoning used for the OR case applies here.\n          Node second = n.getFirstChild().getNext();\n          Name.Type t = getValueType(second);\n          if (t != Name.Type.OTHER) return t;\n          Node third = second.getNext();\n          return getValueType(third);\n      }\n      return Name.Type.OTHER;\n    }",
    "comment": " Gets the type of a value or simple expression.  @param n An rvalue in an assignment or variable declaration (not null) @return A {@link Name.Type} ",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "BuildGlobalNamespace.handleGet",
    "class_name": "com.google.javascript.jscomp.GlobalNamespace$BuildGlobalNamespace",
    "signature": "com.google.javascript.jscomp.GlobalNamespace$BuildGlobalNamespace.handleGet(NodeTraversal,Node,Node,String)",
    "snippet": "    void handleGet(NodeTraversal t, Node n, Node parent, String name) {\n      if (maybeHandlePrototypePrefix(t, n, parent, name)) return;\n\n      Ref.Type type = Ref.Type.DIRECT_GET;\n      if (parent != null) {\n        switch (parent.getType()) {\n          case Token.IF:\n          case Token.TYPEOF:\n          case Token.VOID:\n          case Token.NOT:\n          case Token.BITNOT:\n          case Token.POS:\n          case Token.NEG:\n            break;\n          case Token.CALL:\n            type = n == parent.getFirstChild()\n                   ? Ref.Type.CALL_GET\n                   : Ref.Type.ALIASING_GET;\n            break;\n          case Token.NEW:\n            type = n == parent.getFirstChild()\n                   ? Ref.Type.DIRECT_GET\n                   : Ref.Type.ALIASING_GET;\n            break;\n          case Token.OR:\n          case Token.AND:\n            // This node is x or y in (x||y) or (x&&y). We only know that an\n            // alias is not getting created for this name if the result is used\n            // in a boolean context or assigned to the same name\n            // (e.g. var a = a || {}).\n            type = determineGetTypeForHookOrBooleanExpr(t, parent, name);\n            break;\n          case Token.HOOK:\n            if (n != parent.getFirstChild()) {\n              // This node is y or z in (x?y:z). We only know that an alias is\n              // not getting created for this name if the result is assigned to\n              // the same name (e.g. var a = a ? a : {}).\n              type = determineGetTypeForHookOrBooleanExpr(t, parent, name);\n            }\n            break;\n          default:\n            type = Ref.Type.ALIASING_GET;\n            break;\n        }\n      }\n\n      handleGet(t, n, parent, name, type);\n    }",
    "comment": " Updates our respresentation of the global namespace to reflect a read of a global name.  @param t The traversal @param n The node currently being visited @param parent {@code n}'s parent @param name The global name (e.g. \"a\" or \"a.b.c.d\") ",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "BuildGlobalNamespace.handleGet",
    "class_name": "com.google.javascript.jscomp.GlobalNamespace$BuildGlobalNamespace",
    "signature": "com.google.javascript.jscomp.GlobalNamespace$BuildGlobalNamespace.handleGet(NodeTraversal,Node,Node,String,Type)",
    "snippet": "    void handleGet(NodeTraversal t, Node n, Node parent,\n        String name, Ref.Type type) {\n      Name node = getOrCreateName(name);\n\n      // No need to look up additional ancestors, since they won't be used.\n      node.addRef(new Ref(t, n, type));\n    }",
    "comment": " Updates our respresentation of the global namespace to reflect a read of a global name.  @param t The current node traversal @param n The node currently being visited @param parent {@code n}'s parent @param name The global name (e.g. \"a\" or \"a.b.c.d\") @param type The reference type ",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "BuildGlobalNamespace.handleSetFromGlobal",
    "class_name": "com.google.javascript.jscomp.GlobalNamespace$BuildGlobalNamespace",
    "signature": "com.google.javascript.jscomp.GlobalNamespace$BuildGlobalNamespace.handleSetFromGlobal(NodeTraversal,Node,Node,String,boolean,Type)",
    "snippet": "    void handleSetFromGlobal(NodeTraversal t, Node n, Node parent, String name,\n                             boolean isPropAssign, Name.Type type) {\n      if (maybeHandlePrototypePrefix(t, n, parent, name)) return;\n\n      Name nameObj = getOrCreateName(name);\n      nameObj.type = type;\n\n      Ref set = new Ref(t, n, Ref.Type.SET_FROM_GLOBAL);\n      nameObj.addRef(set);\n\n      if (isNestedAssign(parent)) {\n        // This assignment is both a set and a get that creates an alias.\n        Ref get = new Ref(t, n, Ref.Type.ALIASING_GET);\n        nameObj.addRef(get);\n        Ref.markTwins(set, get);\n      } else if (isConstructorOrEnumDeclaration(n, parent)) {\n        // Names with a @constructor or @enum annotation are always collapsed\n        nameObj.setIsClassOrEnum();\n      }\n    }",
    "comment": " Updates our respresentation of the global namespace to reflect an assignment to a global name in global scope.  @param t The traversal @param n The node currently being visited @param parent {@code n}'s parent @param name The global name (e.g. \"a\" or \"a.b.c.d\") @param isPropAssign Whether this set corresponds to a property assignment of the form <code>a.b.c = ...;</code> @param type The type of the value that the name is being assigned ",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "BuildGlobalNamespace.isConstructorOrEnumDeclaration",
    "class_name": "com.google.javascript.jscomp.GlobalNamespace$BuildGlobalNamespace",
    "signature": "com.google.javascript.jscomp.GlobalNamespace$BuildGlobalNamespace.isConstructorOrEnumDeclaration(Node,Node)",
    "snippet": "    private boolean isConstructorOrEnumDeclaration(Node n, Node parent) {\n      JSDocInfo info;\n      int valueNodeType;\n      switch (parent.getType()) {\n        case Token.ASSIGN:\n          info = parent.getJSDocInfo();\n          valueNodeType = n.getNext().getType();\n          break;\n        case Token.VAR:\n          info = n.getJSDocInfo();\n          if (info == null) {\n            info = parent.getJSDocInfo();\n          }\n          Node valueNode = n.getFirstChild();\n          valueNodeType = valueNode != null ? valueNode.getType() : Token.VOID;\n          break;\n        default:\n          return false;\n      }\n      // Heed the annotations only if they're sensibly used.\n      return info != null &&\n             (info.isConstructor() && valueNodeType == Token.FUNCTION ||\n              info.hasEnumParameterType() && valueNodeType == Token.OBJECTLIT);\n    }",
    "comment": " Determines whether a set operation is a constructor or enumeration declaration. The set operation may either be an assignment to a name, a variable declaration, or an object literal key mapping.  @param n The node that represents the name being set @param parent Parent node of {@code n} (an ASSIGN, VAR, or OBJLIT node) @return Whether the set operation is either a constructor or enum declaration ",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "BuildGlobalNamespace.isNestedAssign",
    "class_name": "com.google.javascript.jscomp.GlobalNamespace$BuildGlobalNamespace",
    "signature": "com.google.javascript.jscomp.GlobalNamespace$BuildGlobalNamespace.isNestedAssign(Node)",
    "snippet": "    boolean isNestedAssign(Node parent) {\n      return parent.getType() == Token.ASSIGN &&\n             !NodeUtil.isExpressionNode(parent.getParent());\n    }",
    "comment": " Determines whether an assignment is nested (i.e. whether its return value is used).  @param parent The parent of the current traversal node (not null) @return Whether it appears that the return value of the assignment is used ",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "BuildGlobalNamespace.maybeHandlePrototypePrefix",
    "class_name": "com.google.javascript.jscomp.GlobalNamespace$BuildGlobalNamespace",
    "signature": "com.google.javascript.jscomp.GlobalNamespace$BuildGlobalNamespace.maybeHandlePrototypePrefix(NodeTraversal,Node,Node,String)",
    "snippet": "    boolean maybeHandlePrototypePrefix(NodeTraversal t, Node n, Node parent,\n        String name) {\n      // We use a string-based approach instead of inspecting the parse tree\n      // to avoid complexities with object literals, possibly nested, beneath\n      // assignments.\n\n      int numLevelsToRemove;\n      String prefix;\n      if (name.endsWith(\".prototype\")) {\n        numLevelsToRemove = 1;\n        prefix = name.substring(0, name.length() - 10);\n      } else {\n        int i = name.indexOf(\".prototype.\");\n        if (i == -1) {\n          return false;\n        }\n        prefix = name.substring(0, i);\n        numLevelsToRemove = 2;\n        i = name.indexOf('.', i + 11);\n        while (i >= 0) {\n          numLevelsToRemove++;\n          i = name.indexOf('.', i + 1);\n        }\n      }\n\n      if (parent != null && NodeUtil.isObjectLitKey(n, parent)) {\n        // Object literal keys have no prefix that's referenced directly per\n        // key, so we're done.\n        return true;\n      }\n\n      for (int i = 0; i < numLevelsToRemove; i++) {\n        parent = n;\n        n = n.getFirstChild();\n      }\n\n      handleGet(t, n, parent, prefix, Ref.Type.PROTOTYPE_GET);\n      return true;\n    }",
    "comment": " Updates our respresentation of the global namespace to reflect a read of a global name's longest prefix before the \"prototype\" property if the name includes the \"prototype\" property. Does nothing otherwise.  @param t The current node traversal @param n The node currently being visited @param parent {@code n}'s parent @param name The global name (e.g. \"a\" or \"a.b.c.d\") @return Whether the name was handled ",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "BuildGlobalNamespace.visit",
    "class_name": "com.google.javascript.jscomp.GlobalNamespace$BuildGlobalNamespace",
    "signature": "com.google.javascript.jscomp.GlobalNamespace$BuildGlobalNamespace.visit(NodeTraversal,Node,Node)",
    "snippet": "    public void visit(NodeTraversal t, Node n, Node parent) {\n      if (nodeFilter != null && !nodeFilter.apply(n)) {\n        return;\n      }\n\n      // If we are traversing the externs, then we save a pointer to the scope\n      // generated by them, so that we can do lookups in it later.\n      if (externsRoot != null && n == externsRoot) {\n        externsScope = t.getScope();\n      }\n\n      String name;\n      boolean isSet = false;\n      Name.Type type = Name.Type.OTHER;\n      boolean isPropAssign = false;\n\n      switch (n.getType()) {\n        case Token.STRING:\n          // This may be a key in an object literal declaration.\n          name = null;\n          if (parent != null && parent.getType() == Token.OBJECTLIT) {\n            name = getNameForObjLitKey(n);\n          }\n          if (name == null) return;\n          isSet = true;\n          type = getValueType(n.getNext());\n          break;\n        case Token.NAME:\n          // This may be a variable get or set.\n          if (parent != null) {\n            switch (parent.getType()) {\n              case Token.VAR:\n                isSet = true;\n                Node rvalue = n.getFirstChild();\n                type = rvalue == null ? Name.Type.OTHER : getValueType(rvalue);\n                break;\n              case Token.ASSIGN:\n                if (parent.getFirstChild() == n) {\n                  isSet = true;\n                  type = getValueType(n.getNext());\n                }\n                break;\n              case Token.GETPROP:\n                return;\n              case Token.FUNCTION:\n                Node gramps = parent.getParent();\n                if (gramps == null ||\n                    NodeUtil.isFunctionAnonymous(parent)) return;\n                isSet = true;\n                type = Name.Type.FUNCTION;\n                break;\n            }\n          }\n          name = n.getString();\n          break;\n        case Token.GETPROP:\n          // This may be a namespaced name get or set.\n          if (parent != null) {\n            switch (parent.getType()) {\n              case Token.ASSIGN:\n                if (parent.getFirstChild() == n) {\n                  isSet = true;\n                  type = getValueType(n.getNext());\n                  isPropAssign = true;\n                }\n                break;\n              case Token.GETPROP:\n                return;\n            }\n          }\n          name = n.getQualifiedName();\n          if (name == null) return;\n          break;\n        default:\n          return;\n      }\n\n      // We are only interested in global names.\n      Scope scope = t.getScope();\n      if (!isGlobalNameReference(name, scope)) {\n        return;\n      }\n\n      if (isSet) {\n        if (isGlobalScope(scope)) {\n          handleSetFromGlobal(t, n, parent, name, isPropAssign, type);\n        } else {\n          handleSetFromLocal(t, n, parent, name);\n        }\n      } else {\n        handleGet(t, n, parent, name);\n      }\n    }",
    "comment": "{@inheritDoc} */",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "Name.addProperty",
    "class_name": "com.google.javascript.jscomp.GlobalNamespace$Name",
    "signature": "com.google.javascript.jscomp.GlobalNamespace$Name.addProperty(String,boolean)",
    "snippet": "    Name addProperty(String name, boolean inExterns) {\n      if (props == null) {\n        props = new ArrayList<Name>();\n      }\n      Name node = new Name(name, this, inExterns);\n      props.add(node);\n      return node;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "Name.addRef",
    "class_name": "com.google.javascript.jscomp.GlobalNamespace$Name",
    "signature": "com.google.javascript.jscomp.GlobalNamespace$Name.addRef(Ref)",
    "snippet": "    void addRef(Ref ref) {\n      switch (ref.type) {\n        case SET_FROM_GLOBAL:\n          if (declaration == null) {\n            declaration = ref;\n            docInfo = getDocInfoForDeclaration(ref);\n          } else {\n            addRefInternal(ref);\n          }\n          globalSets++;\n          break;\n        case SET_FROM_LOCAL:\n          addRefInternal(ref);\n          localSets++;\n          break;\n        case PROTOTYPE_GET:\n        case DIRECT_GET:\n          addRefInternal(ref);\n          totalGets++;\n          break;\n        case ALIASING_GET:\n          addRefInternal(ref);\n          aliasingGets++;\n          totalGets++;\n          break;\n        case CALL_GET:\n          addRefInternal(ref);\n          callGets++;\n          totalGets++;\n          break;\n        default:\n          throw new IllegalStateException();\n      }\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "Name.addRefInternal",
    "class_name": "com.google.javascript.jscomp.GlobalNamespace$Name",
    "signature": "com.google.javascript.jscomp.GlobalNamespace$Name.addRefInternal(Ref)",
    "snippet": "    void addRefInternal(Ref ref) {\n      if (refs == null) {\n        refs = new LinkedList<Ref>();\n      }\n      refs.add(ref);\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "Name.canCollapse",
    "class_name": "com.google.javascript.jscomp.GlobalNamespace$Name",
    "signature": "com.google.javascript.jscomp.GlobalNamespace$Name.canCollapse()",
    "snippet": "    boolean canCollapse() {\n      return !inExterns && (isClassOrEnum ||\n          (parent == null || parent.canCollapseUnannotatedChildNames()) &&\n          (globalSets > 0 || localSets > 0));\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "Name.canCollapseUnannotatedChildNames",
    "class_name": "com.google.javascript.jscomp.GlobalNamespace$Name",
    "signature": "com.google.javascript.jscomp.GlobalNamespace$Name.canCollapseUnannotatedChildNames()",
    "snippet": "    boolean canCollapseUnannotatedChildNames() {\n      if (type == Type.OTHER || globalSets != 1 || localSets != 0) {\n        return false;\n      }\n\n      // Don't try to collapse if the one global set is a twin reference.\n      // We could theoretically handle this case in CollapseProperties, but\n      // it's probably not worth the effort.\n\n      if (isClassOrEnum) {\n        return true;\n      }\n      return (type == Type.FUNCTION || aliasingGets == 0) &&\n          (parent == null || parent.canCollapseUnannotatedChildNames());\n    }",
    "comment": "",
    "is_bug": true,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "Name.canEliminate",
    "class_name": "com.google.javascript.jscomp.GlobalNamespace$Name",
    "signature": "com.google.javascript.jscomp.GlobalNamespace$Name.canEliminate()",
    "snippet": "    boolean canEliminate() {\n      if (!canCollapseUnannotatedChildNames() || totalGets > 0) {\n        return false;\n      }\n\n      if (props != null) {\n        for (Name n : props) {\n          if (!n.canCollapse()) {\n            return false;\n          }\n        }\n      }\n      return true;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "Name.fullName",
    "class_name": "com.google.javascript.jscomp.GlobalNamespace$Name",
    "signature": "com.google.javascript.jscomp.GlobalNamespace$Name.fullName()",
    "snippet": "    String fullName() {\n      return parent == null ? name : parent.fullName() + '.' + name;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "Name.getDocInfoForDeclaration",
    "class_name": "com.google.javascript.jscomp.GlobalNamespace$Name",
    "signature": "com.google.javascript.jscomp.GlobalNamespace$Name.getDocInfoForDeclaration(Ref)",
    "snippet": "    private static JSDocInfo getDocInfoForDeclaration(Ref ref) {\n      if (ref.node != null) {\n        Node refParent = ref.node.getParent();\n        switch (refParent.getType()) {\n          case Token.FUNCTION:\n          case Token.ASSIGN:\n            return refParent.getJSDocInfo();\n          case Token.VAR:\n            return ref.node == refParent.getFirstChild() ?\n                refParent.getJSDocInfo() : ref.node.getJSDocInfo();\n        }\n      }\n\n      return null;\n    }",
    "comment": " Tries to get the doc info for a given declaration ref. ",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "Name.isNamespace",
    "class_name": "com.google.javascript.jscomp.GlobalNamespace$Name",
    "signature": "com.google.javascript.jscomp.GlobalNamespace$Name.isNamespace()",
    "snippet": "    boolean isNamespace() {\n      return hasClassOrEnumDescendant && type == Type.OBJECTLIT;\n    }",
    "comment": " Determines whether this name is a prefix of at least one class or enum name. Because classes and enums are always collapsed, the namespace will have different properties in compiled code than in uncompiled code.  For example, if foo.bar.DomHelper is a class, then foo and foo.bar are considered namespaces. ",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "Name.needsToBeStubbed",
    "class_name": "com.google.javascript.jscomp.GlobalNamespace$Name",
    "signature": "com.google.javascript.jscomp.GlobalNamespace$Name.needsToBeStubbed()",
    "snippet": "    boolean needsToBeStubbed() {\n      return globalSets == 0 && localSets > 0;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "Ref.getTwin",
    "class_name": "com.google.javascript.jscomp.GlobalNamespace$Ref",
    "signature": "com.google.javascript.jscomp.GlobalNamespace$Ref.getTwin()",
    "snippet": "    Ref getTwin() {\n      return twin;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "Ref.isSet",
    "class_name": "com.google.javascript.jscomp.GlobalNamespace$Ref",
    "signature": "com.google.javascript.jscomp.GlobalNamespace$Ref.isSet()",
    "snippet": "    boolean isSet() {\n      return type == Type.SET_FROM_GLOBAL || type == Type.SET_FROM_LOCAL;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "Ref.markTwins",
    "class_name": "com.google.javascript.jscomp.GlobalNamespace$Ref",
    "signature": "com.google.javascript.jscomp.GlobalNamespace$Ref.markTwins(Ref,Ref)",
    "snippet": "    static void markTwins(Ref a, Ref b) {\n      Preconditions.checkArgument(\n          (a.type == Type.ALIASING_GET || b.type == Type.ALIASING_GET) &&\n          (a.type == Type.SET_FROM_GLOBAL || a.type == Type.SET_FROM_LOCAL ||\n           b.type == Type.SET_FROM_GLOBAL || b.type == Type.SET_FROM_LOCAL));\n      a.twin = b;\n      b.twin = a;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "GoogleCodingConvention.isConstant",
    "class_name": "com.google.javascript.jscomp.GoogleCodingConvention",
    "signature": "com.google.javascript.jscomp.GoogleCodingConvention.isConstant(String)",
    "snippet": "  @Override\n  public boolean isConstant(String name) {\n    if (name.length() <= 1) {\n      return false;\n    }\n\n    // In compiled code, '$' is often a namespace delimiter. To allow inlining\n    // of namespaced constants, we strip off any namespaces here.\n    int pos = name.lastIndexOf('$');\n    if (pos >= 0) {\n      name = name.substring(pos + 1);\n      if (name.length() == 0) {\n        return false;\n      }\n    }\n\n    if (!Character.isUpperCase(name.charAt(0))) {\n      return false;\n    }\n\n    // hack way of checking that there aren't any lower-case letters\n    return name.toUpperCase().equals(name);\n  }",
    "comment": " {@inheritDoc}  <p>This enforces the Google const name convention, that the first character after the last $ must be an upper-case letter and all subsequent letters must be upper case. The name must be at least 2 characters long.  <p>Examples: <pre> aaa          Not constant - lower-case letters in the name A            Not constant - too short goog$A       Constant - letters after the $ are upper-case. AA17         Constant - digits can appear after the first letter goog$7A      Not constant - first character after the $ must be upper case. $A           Constant - doesn't have to be anything in front of the $ </pre> ",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "JSError.getCharno",
    "class_name": "com.google.javascript.jscomp.JSError",
    "signature": "com.google.javascript.jscomp.JSError.getCharno()",
    "snippet": "  public int getCharno() {\n    return charno;\n  }",
    "comment": " Get the character number. ",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "JSError.getType",
    "class_name": "com.google.javascript.jscomp.JSError",
    "signature": "com.google.javascript.jscomp.JSError.getType()",
    "snippet": "  public DiagnosticType getType() {\n    return type;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "JSError.make",
    "class_name": "com.google.javascript.jscomp.JSError",
    "signature": "com.google.javascript.jscomp.JSError.make(NodeTraversal,Node,CheckLevel,DiagnosticType,String[])",
    "snippet": "  public static JSError make(NodeTraversal t, Node n,\n      CheckLevel level, DiagnosticType type, String... arguments) {\n    return new JSError(t.getSourceName(), n.getLineno(), n.getCharno(), type,\n        level, arguments);\n  }",
    "comment": " Creates a JSError during NodeTraversal.  @param t Determines source file name containing current script @param n Determines the line and char position within the source file name @param type The DiagnosticType @param arguments Arguments to be incorporated into the message ",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "JSError.toString",
    "class_name": "com.google.javascript.jscomp.JSError",
    "signature": "com.google.javascript.jscomp.JSError.toString()",
    "snippet": "  @Override\n  public String toString() {\n    // TODO(user): remove custom toString.\n    return type.key + \". \" + description + \" at \" +\n      (sourceName != null && sourceName.length() > 0 ?\n       sourceName : \"(unknown source)\") + \" line \" +\n      (lineNumber != -1 ? String.valueOf(lineNumber) : \"(unknown line)\");\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "JSSourceFile.fromCode",
    "class_name": "com.google.javascript.jscomp.JSSourceFile",
    "signature": "com.google.javascript.jscomp.JSSourceFile.fromCode(String,String)",
    "snippet": "  public static JSSourceFile fromCode(String fileName, String code) {\n    return new JSSourceFile(SourceFile.fromCode(fileName, code));\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "JSSourceFile.getCode",
    "class_name": "com.google.javascript.jscomp.JSSourceFile",
    "signature": "com.google.javascript.jscomp.JSSourceFile.getCode()",
    "snippet": "  @Override\n  public String getCode() throws IOException {\n    return referenced.getCode();\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "JsAst.JsAst",
    "class_name": "com.google.javascript.jscomp.JsAst",
    "signature": "com.google.javascript.jscomp.JsAst.JsAst(SourceFile)",
    "snippet": "  public JsAst(SourceFile sourceFile) {\n    this.sourceFile = sourceFile;\n    this.fileName = sourceFile.getName();\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "JsAst.createAst",
    "class_name": "com.google.javascript.jscomp.JsAst",
    "signature": "com.google.javascript.jscomp.JsAst.createAst(AbstractCompiler)",
    "snippet": "  private void createAst(AbstractCompiler compiler) {\n    try {\n      parse(compiler, sourceFile.getName(), sourceFile.getCode());\n    } catch (IOException e) {\n      compiler.report(\n          JSError.make(Compiler.READ_ERROR, sourceFile.getName()));\n    }\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "JsAst.getAstRoot",
    "class_name": "com.google.javascript.jscomp.JsAst",
    "signature": "com.google.javascript.jscomp.JsAst.getAstRoot(AbstractCompiler)",
    "snippet": "  @Override\n  public Node getAstRoot(AbstractCompiler compiler) {\n    if (root == null) {\n      createAst(compiler);\n    }\n    return root;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "JsAst.parse",
    "class_name": "com.google.javascript.jscomp.JsAst",
    "signature": "com.google.javascript.jscomp.JsAst.parse(AbstractCompiler,String,String)",
    "snippet": "  private void parse(AbstractCompiler compiler, String sourceName,\n      String sourceStr) {\n    try {\n      logger_.fine(\"Parsing: \" + sourceName);\n      root = ParserRunner.parse(sourceName, sourceStr, compiler.isIdeMode(),\n          compiler.getTypeRegistry(),\n          compiler.getDefaultErrorReporter(),\n          logger_);\n    } catch (IOException e) {\n      compiler.report(JSError.make(Compiler.READ_ERROR, sourceName));\n    }\n\n    if (root == null) {\n      // There was a parse error or IOException, so use a dummy block.\n      root = new Node(Token.BLOCK);\n    } else {\n      compiler.normalizeNodeTypes(root);\n      compiler.annotateCodingConvention(root);\n    }\n\n    // Set the source name so that the compiler passes can track\n    // the source file and module.\n    root.putProp(Node.SOURCENAME_PROP, sourceName);\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "LightweightMessageFormatter.LightweightMessageFormatter",
    "class_name": "com.google.javascript.jscomp.LightweightMessageFormatter",
    "signature": "com.google.javascript.jscomp.LightweightMessageFormatter.LightweightMessageFormatter(SourceExcerptProvider)",
    "snippet": "  public LightweightMessageFormatter(SourceExcerptProvider source) {\n    this(source, LINE);\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "LightweightMessageFormatter.LightweightMessageFormatter",
    "class_name": "com.google.javascript.jscomp.LightweightMessageFormatter",
    "signature": "com.google.javascript.jscomp.LightweightMessageFormatter.LightweightMessageFormatter(SourceExcerptProvider,SourceExcerpt)",
    "snippet": "  public LightweightMessageFormatter(SourceExcerptProvider source,\n      SourceExcerpt excerpt) {\n    super(source);\n    this.excerpt = excerpt;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "LoggerErrorManager.LoggerErrorManager",
    "class_name": "com.google.javascript.jscomp.LoggerErrorManager",
    "signature": "com.google.javascript.jscomp.LoggerErrorManager.LoggerErrorManager(MessageFormatter,Logger)",
    "snippet": "  public LoggerErrorManager(MessageFormatter formatter, Logger logger) {\n    this.formatter = formatter;\n    this.logger = logger;\n  }",
    "comment": " Creates an instance. ",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "NodeTraversal.NodeTraversal",
    "class_name": "com.google.javascript.jscomp.NodeTraversal",
    "signature": "com.google.javascript.jscomp.NodeTraversal.NodeTraversal(AbstractCompiler,Callback)",
    "snippet": "  public NodeTraversal(AbstractCompiler compiler, Callback cb) {\n    this(compiler, cb, new SyntacticScopeCreator(compiler));\n  }",
    "comment": " Creates a node traversal using the specified callback interface. ",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "NodeTraversal.NodeTraversal",
    "class_name": "com.google.javascript.jscomp.NodeTraversal",
    "signature": "com.google.javascript.jscomp.NodeTraversal.NodeTraversal(AbstractCompiler,Callback,ScopeCreator)",
    "snippet": "  public NodeTraversal(AbstractCompiler compiler, Callback cb,\n      ScopeCreator scopeCreator) {\n    this.callback = cb;\n    if (cb instanceof ScopedCallback) {\n      this.scopeCallback = (ScopedCallback) cb;\n    }\n    this.compiler = compiler;\n    this.sourceName = \"\";\n    this.scopeCreator = scopeCreator;\n  }",
    "comment": " Creates a node traversal using the specified callback interface and the scope creator. ",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "NodeTraversal.getCompiler",
    "class_name": "com.google.javascript.jscomp.NodeTraversal",
    "signature": "com.google.javascript.jscomp.NodeTraversal.getCompiler()",
    "snippet": "  public Compiler getCompiler() {\n    // TODO(nicksantos): Remove this type cast. This is just temporary\n    // while refactoring.\n    return (Compiler) compiler;\n  }",
    "comment": " Gets the compiler. ",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "NodeTraversal.getSourceName",
    "class_name": "com.google.javascript.jscomp.NodeTraversal",
    "signature": "com.google.javascript.jscomp.NodeTraversal.getSourceName()",
    "snippet": "  public String getSourceName() {\n    return sourceName;\n  }",
    "comment": " Gets the current input source name.  @return A string that may be empty, but not null ",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "NodeTraversal.getSourceName",
    "class_name": "com.google.javascript.jscomp.NodeTraversal",
    "signature": "com.google.javascript.jscomp.NodeTraversal.getSourceName(Node)",
    "snippet": "  private static String getSourceName(Node n) {\n    String name = (String) n.getProp(Node.SOURCENAME_PROP);\n    return name == null ? \"\" : name;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "NodeTraversal.popScope",
    "class_name": "com.google.javascript.jscomp.NodeTraversal",
    "signature": "com.google.javascript.jscomp.NodeTraversal.popScope()",
    "snippet": "  private void popScope() {\n    if (scopeCallback != null) {\n      scopeCallback.exitScope(this);\n    }\n    if (scopeRoots.isEmpty()) {\n      scopes.pop();\n    } else {\n      scopeRoots.pop();\n    }\n    cfgs.pop();\n  }",
    "comment": "Pops back to the previous scope (e.g. when leaving a function). */",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "NodeTraversal.pushScope",
    "class_name": "com.google.javascript.jscomp.NodeTraversal",
    "signature": "com.google.javascript.jscomp.NodeTraversal.pushScope(Node)",
    "snippet": "  private void pushScope(Node node) {\n    Preconditions.checkState(curNode != null);\n    scopeRoots.push(node);\n    cfgs.push(null);\n    if (scopeCallback != null) {\n      scopeCallback.enterScope(this);\n    }\n  }",
    "comment": "Creates a new scope (e.g. when entering a function). */",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "NodeTraversal.traverse",
    "class_name": "com.google.javascript.jscomp.NodeTraversal",
    "signature": "com.google.javascript.jscomp.NodeTraversal.traverse(AbstractCompiler,Node,Callback)",
    "snippet": "  public static void traverse(\n      AbstractCompiler compiler, Node root, Callback cb) {\n    NodeTraversal t = new NodeTraversal(compiler, cb);\n    t.traverse(root);\n  }",
    "comment": " Traverses a node recursively. ",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "NodeTraversal.traverse",
    "class_name": "com.google.javascript.jscomp.NodeTraversal",
    "signature": "com.google.javascript.jscomp.NodeTraversal.traverse(Node)",
    "snippet": "  public void traverse(Node root) {\n    try {\n      sourceName = \"\";\n      curNode = root;\n      pushScope(root);\n      traverseBranch(root, null);\n      popScope();\n    } catch (Exception unexpectedException) {\n      throwUnexpectedException(unexpectedException);\n    }\n  }",
    "comment": " Traverses a parse tree recursively. ",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "NodeTraversal.traverseBranch",
    "class_name": "com.google.javascript.jscomp.NodeTraversal",
    "signature": "com.google.javascript.jscomp.NodeTraversal.traverseBranch(Node,Node)",
    "snippet": "  @SuppressWarnings(\"fallthrough\")\n  private void traverseBranch(Node n, Node parent) {\n    int type = n.getType();\n    if (type == Token.SCRIPT) {\n      sourceName = getSourceName(n);\n    }\n\n    curNode = n;\n    if (!callback.shouldTraverse(this, n, parent)) return;\n\n    switch (type) {\n      case Token.CATCH:\n        Preconditions.checkState(n.getChildCount() == 3);\n        Preconditions.checkState(n.getFirstChild().getType() == Token.NAME);\n        // the first child is the catch var and the third child\n        // is the code block\n        traverseBranch(n.getFirstChild(), n);\n        traverseBranch(n.getFirstChild().getNext().getNext(), n);\n        break;\n\n      case Token.FUNCTION:\n        traverseFunction(n, parent);\n        break;\n\n      default:\n        for (Node child = n.getFirstChild(); child != null; ) {\n          // child could be replaced, in which case our child node\n          // would no longer point to the true next\n          Node next = child.getNext();\n          traverseBranch(child, n);\n          child = next;\n        }\n        break;\n    }\n\n    curNode = n;\n    callback.visit(this, n, parent);\n  }",
    "comment": " Traverses a branch. ",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "NodeTraversal.traverseFunction",
    "class_name": "com.google.javascript.jscomp.NodeTraversal",
    "signature": "com.google.javascript.jscomp.NodeTraversal.traverseFunction(Node,Node)",
    "snippet": "  private void traverseFunction(Node n, Node parent) {\n    Preconditions.checkState(n.getChildCount() == 3);\n    Preconditions.checkState(n.getType() == Token.FUNCTION);\n\n    final Node fnName = n.getFirstChild();\n\n    boolean anonymous = parent != null && NodeUtil.isFunctionAnonymous(n);\n\n    if (!anonymous) {\n      // Named functions are parent of the containing scope.\n      traverseBranch(fnName, n);\n    }\n\n    curNode = n;\n    pushScope(n);\n\n    if (anonymous) {\n      // Anonymous function names are parent of the contained scope.\n      traverseBranch(fnName, n);\n    }\n\n    final Node args = fnName.getNext();\n    final Node body = args.getNext();\n\n    // Args\n    traverseBranch(args, n);\n\n    // Body\n    Preconditions.checkState(body.getNext() == null &&\n            body.getType() == Token.BLOCK);\n    traverseBranch(body, n);\n\n    popScope();\n  }",
    "comment": " Traverses a function. ",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "AbstractPostOrderCallback.shouldTraverse",
    "class_name": "com.google.javascript.jscomp.NodeTraversal$AbstractPostOrderCallback",
    "signature": "com.google.javascript.jscomp.NodeTraversal$AbstractPostOrderCallback.shouldTraverse(NodeTraversal,Node,Node)",
    "snippet": "    public final boolean shouldTraverse(NodeTraversal nodeTraversal, Node n,\n        Node parent) {\n      return true;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "NodeTypeNormalizer.NodeTypeNormalizer",
    "class_name": "com.google.javascript.jscomp.NodeTypeNormalizer",
    "signature": "com.google.javascript.jscomp.NodeTypeNormalizer.NodeTypeNormalizer()",
    "snippet": "  NodeTypeNormalizer() {\n    this(null);\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "NodeTypeNormalizer.NodeTypeNormalizer",
    "class_name": "com.google.javascript.jscomp.NodeTypeNormalizer",
    "signature": "com.google.javascript.jscomp.NodeTypeNormalizer.NodeTypeNormalizer(CodeChangeHandler)",
    "snippet": "  NodeTypeNormalizer(CodeChangeHandler changeHandler) {\n    this.changeHandler = changeHandler;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "NodeTypeNormalizer.normalizeBlocks",
    "class_name": "com.google.javascript.jscomp.NodeTypeNormalizer",
    "signature": "com.google.javascript.jscomp.NodeTypeNormalizer.normalizeBlocks(Node)",
    "snippet": "  private void normalizeBlocks(Node n) {\n    if (NodeUtil.isControlStructure(n)\n        && n.getType() != Token.LABEL\n        && n.getType() != Token.SWITCH) {\n      for (Node c = n.getFirstChild(); c != null; c = c.getNext()) {\n        if (NodeUtil.isControlStructureCodeBlock(n,c) &&\n            c.getType() != Token.BLOCK) {\n          Node newBlock = new Node(Token.BLOCK);\n          n.replaceChild(c, newBlock);\n          if (c.getType() != Token.EMPTY) {\n            newBlock.addChildrenToFront(c);\n          } else {\n            newBlock.setWasEmptyNode(true);\n          }\n          c = newBlock;\n          reportChange();\n        }\n      }\n    }\n  }",
    "comment": " Add blocks to IF, WHILE, DO, etc. ",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "NodeTypeNormalizer.normalizeJsDocAnnotations",
    "class_name": "com.google.javascript.jscomp.NodeTypeNormalizer",
    "signature": "com.google.javascript.jscomp.NodeTypeNormalizer.normalizeJsDocAnnotations(Node)",
    "snippet": "  private void normalizeJsDocAnnotations(Node n) {\n    if (n.getType() == Token.OBJECTLIT) {\n      for (Node key = n.getFirstChild();\n           key != null; key = key.getNext().getNext()) {\n        Node value = key.getNext();\n        if (key.getJSDocInfo() != null &&\n            key.getNext().getType() == Token.FUNCTION) {\n          value.setJSDocInfo(key.getJSDocInfo());\n        }\n      }\n    }\n\n    for (Node child = n.getFirstChild();\n         child != null; child = child.getNext()) {\n      normalizeJsDocAnnotations(child);\n    }\n  }",
    "comment": " Normalize where JSDoc annotations appear on the AST.  In the AST that Rhino gives us, it needs to make a distinction between jsdoc on the object literal node and jsdoc on the object literal value. For example, <pre> var x = { JSDOC / a: 'b', c: / JSDOC / 'd' }; </pre>  But in few narrow cases (in particular, function literals), it's a lot easier for us if the doc is attached to the value. ",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "NodeTypeNormalizer.normalizeNodeTypes",
    "class_name": "com.google.javascript.jscomp.NodeTypeNormalizer",
    "signature": "com.google.javascript.jscomp.NodeTypeNormalizer.normalizeNodeTypes(Node)",
    "snippet": "  private void normalizeNodeTypes(Node n) {\n    if (n.getType() == Token.EXPR_VOID) {\n      n.setType(Token.EXPR_RESULT);\n      reportChange();\n    }\n\n    // Remove unused properties to minimize differences between ASTs\n    // produced by the two parsers.\n    if (n.getType() == Token.FUNCTION) {\n      n.removeProp(Node.FUNCTION_PROP);\n      reportChange();\n    }\n\n    normalizeBlocks(n);\n\n    for (Node child = n.getFirstChild();\n         child != null; child = child.getNext()) {\n      // This pass is run during the CompilerTestCase validation, so this\n      // parent pointer check serves as a more general check.\n      Preconditions.checkState(child.getParent() == n);\n\n      normalizeNodeTypes(child);\n    }\n  }",
    "comment": " Covert EXPR_VOID to EXPR_RESULT to simplify the rest of the code. ",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "NodeTypeNormalizer.process",
    "class_name": "com.google.javascript.jscomp.NodeTypeNormalizer",
    "signature": "com.google.javascript.jscomp.NodeTypeNormalizer.process(Node,Node)",
    "snippet": "  @Override\n  public void process(Node externs, Node root) {\n    normalizeNodeTypes(root);\n    normalizeJsDocAnnotations(root);\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "NodeTypeNormalizer.reportChange",
    "class_name": "com.google.javascript.jscomp.NodeTypeNormalizer",
    "signature": "com.google.javascript.jscomp.NodeTypeNormalizer.reportChange()",
    "snippet": "  private void reportChange() {\n    if (changeHandler != null) {\n      changeHandler.reportChange();\n    }\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "NodeUtil.checkForStateChangeHelper",
    "class_name": "com.google.javascript.jscomp.NodeUtil",
    "signature": "com.google.javascript.jscomp.NodeUtil.checkForStateChangeHelper(Node,boolean)",
    "snippet": "  private static boolean checkForStateChangeHelper(\n      Node n, boolean checkForNewObjects) {\n    // Rather than id which ops may have side effects, id the ones\n    // that we know to be safe\n    switch (n.getType()) {\n      // other side-effect free statements and expressions\n      case Token.AND:\n      case Token.BLOCK:\n      case Token.EXPR_RESULT:\n      case Token.HOOK:\n      case Token.IF:\n      case Token.IN:\n      case Token.LP:\n      case Token.NUMBER:\n      case Token.OR:\n      case Token.THIS:\n      case Token.TRUE:\n      case Token.FALSE:\n      case Token.NULL:\n      case Token.STRING:\n      case Token.SWITCH:\n      case Token.TRY:\n      case Token.EMPTY:\n        break;\n\n      // Throws are by definition side effects\n      case Token.THROW:\n        return true;\n\n      case Token.OBJECTLIT:\n      case Token.ARRAYLIT:\n      case Token.REGEXP:\n        if (checkForNewObjects) {\n          return true;\n        }\n        break;\n\n      case Token.VAR:    // empty var statement (no declaration)\n      case Token.NAME:   // variable by itself\n        if (n.getFirstChild() != null)\n          return true;\n\n        break;\n\n      case Token.FUNCTION:\n        // Anonymous functions don't have side-effects, but named ones\n        // change the namespace. Therefore, we check if the function has\n        // a name. Either way, we don't need to check the children, since\n        // they aren't executed at declaration time.\n        //\n        return !isFunctionAnonymous(n);\n\n      case Token.NEW:\n        {\n          if (checkForNewObjects) {\n            return true;\n          }\n\n          // calls to constructors that have no side effects have the\n          // no side effect property set.\n          if (n.isNoSideEffectsCall()) {\n            break;\n          }\n\n          // certain constructors are certified side effect free\n          Node constructor = n.getFirstChild();\n          if (Token.NAME == constructor.getType()) {\n            String className = constructor.getString();\n            if (CONSTRUCTORS_WITHOUT_SIDE_EFFECTS.contains(className)) {\n              // loop below will see if the constructor parameters have\n              // side-effects\n              break;\n            }\n          } else {\n            // the constructor could also be an expression like\n            // new (useArray ? Object : Array)();\n          }\n        }\n        return true;\n\n      case Token.CALL:\n        // calls to functions that have no side effects have the no\n        // side effect property set.\n        if (n.isNoSideEffectsCall()) {\n          // loop below will see if the function parameters have\n          // side-effects\n          break;\n        }\n        return true;\n\n      default:\n        if (isSimpleOperatorType(n.getType()))\n          break;\n\n        return true;\n    }\n\n    for (Node c = n.getFirstChild(); c != null; c = c.getNext()) {\n      if (checkForStateChangeHelper(c, checkForNewObjects)) {\n        return true;\n      }\n    }\n\n    return false;\n  }",
    "comment": " Returns true if some node in n's subtree changes application state. If {@code checkForNewObjects} is true, we assume that newly created mutable objects (like object literals) change state. Otherwise, we assume that they have no side effects. ",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "NodeUtil.isControlStructure",
    "class_name": "com.google.javascript.jscomp.NodeUtil",
    "signature": "com.google.javascript.jscomp.NodeUtil.isControlStructure(Node)",
    "snippet": "  static boolean isControlStructure(Node n) {\n    switch (n.getType()) {\n      case Token.FOR:\n      case Token.DO:\n      case Token.WHILE:\n      case Token.WITH:\n      case Token.IF:\n      case Token.LABEL:\n      case Token.TRY:\n      case Token.CATCH:\n      case Token.SWITCH:\n      case Token.CASE:\n      case Token.DEFAULT:\n        return true;\n      default:\n        return false;\n    }\n  }",
    "comment": " Determines whether the given node is a FOR, DO, WHILE, WITH, or IF node. ",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "NodeUtil.isExpressionNode",
    "class_name": "com.google.javascript.jscomp.NodeUtil",
    "signature": "com.google.javascript.jscomp.NodeUtil.isExpressionNode(Node)",
    "snippet": "  static boolean isExpressionNode(Node n) {\n    return n.getType() == Token.EXPR_RESULT;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "NodeUtil.isFunctionAnonymous",
    "class_name": "com.google.javascript.jscomp.NodeUtil",
    "signature": "com.google.javascript.jscomp.NodeUtil.isFunctionAnonymous(Node)",
    "snippet": "  static boolean isFunctionAnonymous(Node n) {\n    return !isStatement(n);\n  }",
    "comment": " Is a FUNCTION node an anonymous function? An anonymous function is one that has either no name or a name that is not added to the current scope.  <p>Some examples of anonymous functions: <pre> function () {} (function f() {})() [ function f() {} ] var f = function f() {}; for (function f() {};;) {} </pre>  <p>Some examples of functions that are <em>not</em> anonymous: <pre> function f() {} if (x); else function f() {} for (;;) { function f() {} } </pre>  @param n A FUNCTION node @return Whether n is an anonymous function ",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "NodeUtil.isSimpleOperatorType",
    "class_name": "com.google.javascript.jscomp.NodeUtil",
    "signature": "com.google.javascript.jscomp.NodeUtil.isSimpleOperatorType(int)",
    "snippet": "  static boolean isSimpleOperatorType(int type) {\n    switch (type) {\n      case Token.ADD:\n      case Token.BITAND:\n      case Token.BITNOT:\n      case Token.BITOR:\n      case Token.BITXOR:\n      case Token.COMMA:\n      case Token.DIV:\n      case Token.EQ:\n      case Token.GE:\n      case Token.GETELEM:\n      case Token.GETPROP:\n      case Token.GT:\n      case Token.INSTANCEOF:\n      case Token.LE:\n      case Token.LSH:\n      case Token.LT:\n      case Token.MOD:\n      case Token.MUL:\n      case Token.NE:\n      case Token.NOT:\n      case Token.RSH:\n      case Token.SHEQ:\n      case Token.SHNE:\n      case Token.SUB:\n      case Token.TYPEOF:\n      case Token.VOID:\n      case Token.POS:\n      case Token.NEG:\n      case Token.URSH:\n        return true;\n\n      default:\n        return false;\n    }\n  }",
    "comment": " A \"simple\" operator is one whose children are expressions, has no direct side-effects (unlike '+='), and has no conditional aspects (unlike '||'). ",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "NodeUtil.isStatement",
    "class_name": "com.google.javascript.jscomp.NodeUtil",
    "signature": "com.google.javascript.jscomp.NodeUtil.isStatement(Node)",
    "snippet": "  static boolean isStatement(Node n) {\n    Node parent = n.getParent();\n    // It is not possible to determine definitely if a node is a statement\n    // or not if it is not part of the AST.  A FUNCTION node, for instance,\n    // is either part of an expression (as a anonymous function) or as\n    // a statement.\n    Preconditions.checkState(parent != null);\n    switch (parent.getType()) {\n      case Token.SCRIPT:\n      case Token.BLOCK:\n      case Token.LABEL:\n        return true;\n      default:\n        return false;\n    }\n  }",
    "comment": " @return Whether the node is used as a statement. ",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "NodeUtil.mayHaveSideEffects",
    "class_name": "com.google.javascript.jscomp.NodeUtil",
    "signature": "com.google.javascript.jscomp.NodeUtil.mayHaveSideEffects(Node)",
    "snippet": "  static boolean mayHaveSideEffects(Node n) {\n    return checkForStateChangeHelper(n, false);\n  }",
    "comment": " Returns true if the node which may have side effects when executed. ",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "PassFactory.PassFactory",
    "class_name": "com.google.javascript.jscomp.PassFactory",
    "signature": "com.google.javascript.jscomp.PassFactory.PassFactory(String,boolean)",
    "snippet": "  protected PassFactory(String name, boolean isOneTimePass) {\n    this.name = name;\n    this.isOneTimePass = isOneTimePass;\n  }",
    "comment": " @param name The name of the pass that this factory creates. @param isOneTimePass If true, the pass produced by this factory can only be run once. ",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "RhinoErrorReporter.forNewRhino",
    "class_name": "com.google.javascript.jscomp.RhinoErrorReporter",
    "signature": "com.google.javascript.jscomp.RhinoErrorReporter.forNewRhino(AbstractCompiler)",
    "snippet": "  public static com.google.javascript.jscomp.mozilla.rhino.ErrorReporter\n      forNewRhino(AbstractCompiler compiler) {\n    return new NewRhinoErrorReporter(compiler);\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "RhinoErrorReporter.forOldRhino",
    "class_name": "com.google.javascript.jscomp.RhinoErrorReporter",
    "signature": "com.google.javascript.jscomp.RhinoErrorReporter.forOldRhino(AbstractCompiler)",
    "snippet": "  public static ErrorReporter forOldRhino(AbstractCompiler compiler) {\n    return new OldRhinoErrorReporter(compiler);\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "RhinoErrorReporter.replacePlaceHolders",
    "class_name": "com.google.javascript.jscomp.RhinoErrorReporter",
    "signature": "com.google.javascript.jscomp.RhinoErrorReporter.replacePlaceHolders(String)",
    "snippet": "  private String replacePlaceHolders(String s) {\n    s = Pattern.quote(s);\n    return s.replaceAll(\"\\\\{\\\\d+\\\\}\", \"\\\\\\\\E.*\\\\\\\\Q\");\n  }",
    "comment": " For each message such as \"Not a good use of {0}\", replace the place holder {0} with a wild card that matches all possible strings. Also put the any non-place-holder in quotes for regex matching later. ",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "Scope.Scope",
    "class_name": "com.google.javascript.jscomp.Scope",
    "signature": "com.google.javascript.jscomp.Scope.Scope(Node,AbstractCompiler)",
    "snippet": "  Scope(Node rootNode, AbstractCompiler compiler) {\n    this.parent = null;\n    this.rootNode = rootNode;\n    thisType = compiler.getTypeRegistry().getNativeObjectType(GLOBAL_THIS);\n    this.isBottom = false;\n  }",
    "comment": " Creates a global Scope. @param rootNode  Typically the global BLOCK node. ",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "Scope.declare",
    "class_name": "com.google.javascript.jscomp.Scope",
    "signature": "com.google.javascript.jscomp.Scope.declare(String,Node,JSType,CompilerInput)",
    "snippet": "  Var declare(String name, Node nameNode, JSType type, CompilerInput input) {\n    return declare(name, nameNode, type, input, true);\n  }",
    "comment": " Declares a variable whose type is inferred.  @param name name of the variable @param nameNode the NAME node declaring the variable @param type the variable's type @param input the input in which this variable is defined. ",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "Scope.declare",
    "class_name": "com.google.javascript.jscomp.Scope",
    "signature": "com.google.javascript.jscomp.Scope.declare(String,Node,JSType,CompilerInput,boolean)",
    "snippet": "  Var declare(String name, Node nameNode,\n      JSType type, CompilerInput input, boolean inferred) {\n    Preconditions.checkState(name != null && name.length() > 0);\n\n    // Make sure that it's declared only once\n    Preconditions.checkState(vars.get(name) == null);\n\n    Var var = new Var(inferred);\n    var.name = name;\n    var.nameNode = nameNode;\n    var.type = type;\n    var.referenced = false;\n    var.scope = this;\n    var.index = vars.size();\n    var.input = input;\n\n    // native variables do not have a name node.\n    // TODO(user): make Var abstract and have NativeVar, NormalVar.\n    JSDocInfo info = NodeUtil.getInfoForNameNode(nameNode);\n\n    var.isDefine = info != null && info.isDefine();\n    var.info = info;\n\n    vars.put(name, var);\n    return var;\n  }",
    "comment": " Declares a variable.  @param name name of the variable @param nameNode the NAME node declaring the variable @param type the variable's type @param input the input in which this variable is defined. @param inferred Whether this variable's type is inferred (as opposed to declared). ",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "Scope.getParent",
    "class_name": "com.google.javascript.jscomp.Scope",
    "signature": "com.google.javascript.jscomp.Scope.getParent()",
    "snippet": "  public Scope getParent() {\n    return parent;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "Scope.getVar",
    "class_name": "com.google.javascript.jscomp.Scope",
    "signature": "com.google.javascript.jscomp.Scope.getVar(String)",
    "snippet": "  public Var getVar(String name) {\n    Var var = vars.get(name);\n    if (var != null) {\n      return var;\n    } else if (parent != null) { // Recurse up the parent Scope\n      return parent.getVar(name);\n    } else {\n      return null;\n    }\n  }",
    "comment": " Returns the variable, may be null ",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "Scope.isDeclared",
    "class_name": "com.google.javascript.jscomp.Scope",
    "signature": "com.google.javascript.jscomp.Scope.isDeclared(String,boolean)",
    "snippet": "  public boolean isDeclared(String name, boolean recurse) {\n    Scope scope = this;\n    if (scope.vars.containsKey(name))\n      return true;\n\n    if (scope.parent != null && recurse) {\n      return scope.parent.isDeclared(name, recurse);\n    }\n    return false;\n  }",
    "comment": " Returns true if a variable is declared. ",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "Scope.isGlobal",
    "class_name": "com.google.javascript.jscomp.Scope",
    "signature": "com.google.javascript.jscomp.Scope.isGlobal()",
    "snippet": "  public boolean isGlobal() {\n    return parent == null;\n  }",
    "comment": " Returns whether this is the global scope. ",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "Scope.isLocal",
    "class_name": "com.google.javascript.jscomp.Scope",
    "signature": "com.google.javascript.jscomp.Scope.isLocal()",
    "snippet": "  public boolean isLocal() {\n    return !isGlobal();\n  }",
    "comment": " Returns whether this is a local scope (i.e. not the global scope). ",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "Var.isLocal",
    "class_name": "com.google.javascript.jscomp.Scope$Var",
    "signature": "com.google.javascript.jscomp.Scope$Var.isLocal()",
    "snippet": "    public boolean isLocal() {\n      return scope.isLocal();\n    }",
    "comment": " Returns whether this is a local variable. ",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "SourceFile.SourceFile",
    "class_name": "com.google.javascript.jscomp.SourceFile",
    "signature": "com.google.javascript.jscomp.SourceFile.SourceFile(String)",
    "snippet": "  SourceFile(String fileName) {\n    this.fileName = fileName;\n    // Starting point: offset 0 is at line 1.\n    this.lastOffset = 0;\n    this.lastLine = 1;\n  }",
    "comment": " Construct a new abstract source file.  @param fileName The file name of the source file. It does not necessarily need to correspond to a real path. But it should be unique. Will appear in warning messages emitted by the compiler. ",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "SourceFile.fromCode",
    "class_name": "com.google.javascript.jscomp.SourceFile",
    "signature": "com.google.javascript.jscomp.SourceFile.fromCode(String,String)",
    "snippet": "  public static SourceFile fromCode(String fileName, String code) {\n    return new Preloaded(fileName, code);\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "SourceFile.getCode",
    "class_name": "com.google.javascript.jscomp.SourceFile",
    "signature": "com.google.javascript.jscomp.SourceFile.getCode()",
    "snippet": "  public String getCode() throws IOException {\n    return code;\n  }",
    "comment": " Gets all the code in this source file.  @throws IOException  ",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "SourceFile.getName",
    "class_name": "com.google.javascript.jscomp.SourceFile",
    "signature": "com.google.javascript.jscomp.SourceFile.getName()",
    "snippet": "  public String getName() {\n    return fileName;\n  }",
    "comment": "Returns a unique name for the source file. */",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "SourceFile.setCode",
    "class_name": "com.google.javascript.jscomp.SourceFile",
    "signature": "com.google.javascript.jscomp.SourceFile.setCode(String)",
    "snippet": "  private void setCode(String sourceCode) {\n    code = sourceCode;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "SyntacticScopeCreator.SyntacticScopeCreator",
    "class_name": "com.google.javascript.jscomp.SyntacticScopeCreator",
    "signature": "com.google.javascript.jscomp.SyntacticScopeCreator.SyntacticScopeCreator(AbstractCompiler)",
    "snippet": "  SyntacticScopeCreator(AbstractCompiler compiler) {\n    this.compiler = compiler;\n    this.redeclarationHandler = new DefaultRedeclarationHandler();\n  }",
    "comment": " Creates a ScopeCreator. ",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "TypeValidator.TypeValidator",
    "class_name": "com.google.javascript.jscomp.TypeValidator",
    "signature": "com.google.javascript.jscomp.TypeValidator.TypeValidator(AbstractCompiler)",
    "snippet": "  TypeValidator(AbstractCompiler compiler) {\n    this.compiler = compiler;\n    this.typeRegistry = compiler.getTypeRegistry();\n    this.allValueTypes = typeRegistry.createUnionType(\n        STRING_TYPE, NUMBER_TYPE, BOOLEAN_TYPE, NULL_TYPE, VOID_TYPE);\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "Config.Config",
    "class_name": "com.google.javascript.jscomp.parsing.Config",
    "signature": "com.google.javascript.jscomp.parsing.Config.Config(JSTypeRegistry,Set,boolean)",
    "snippet": "  Config(JSTypeRegistry registry, Set<String> annotationWhitelist,\n      boolean parseJsDocDocumentation) {\n    this.registry = registry;\n    this.annotationWhitelist = annotationWhitelist;\n    this.parseJsDocDocumentation = parseJsDocDocumentation;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "IRFactory.justTransform",
    "class_name": "com.google.javascript.jscomp.parsing.IRFactory",
    "signature": "com.google.javascript.jscomp.parsing.IRFactory.justTransform(AstNode)",
    "snippet": "  private Node justTransform(AstNode node) {\n    return transformDispatcher.process(node);\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "IRFactory.parseAllJsDocInfo",
    "class_name": "com.google.javascript.jscomp.parsing.IRFactory",
    "signature": "com.google.javascript.jscomp.parsing.IRFactory.parseAllJsDocInfo(Node,Comment[],int)",
    "snippet": "  private int parseAllJsDocInfo(Node node, Comment[] comments, int ci) {\n    if (ci >= comments.length) {\n      // There are no comments left.\n      return ci;\n    }\n\n    // Parse the JsDoc string on the current node, if any.\n    if (node.getProp(TMP_JSDOC_PROP) != null) {\n      String jsDoc = (String) node.getProp(TMP_JSDOC_PROP);\n\n      // Find the match of the JsDoc string in the array of comments.\n      while (comments[ci].getCommentType() != JSDOC ||\n          !comments[ci].getValue().equals(jsDoc)) {\n        ci++;\n        Preconditions.checkState(ci < comments.length);\n      }\n\n      JSDocInfo info = parseJSDocInfo(jsDoc, comments[ci].getLineno(),\n          comments[ci].getAbsolutePosition());\n      node.setJSDocInfo(info);\n      if (info != null && info.hasEnumParameterType()) {\n        if (node.getType() == Token.NAME) {\n          registry.identifyEnumName(node.getString());\n        } else if (node.getType() == Token.VAR &&\n            node.getChildCount() == 1) {\n          registry.identifyEnumName(node.getFirstChild().getString());\n        } else if (node.getType() == Token.ASSIGN) {\n          registry.identifyEnumName(node.getFirstChild().getQualifiedName());\n        }\n      }\n\n      ci++;\n      node.removeProp(TMP_JSDOC_PROP);\n    }\n\n    // Recurse on the children.\n    for (Node child : node.children()) {\n      ci = parseAllJsDocInfo(child, comments, ci);\n    }\n\n    return ci;\n  }",
    "comment": " Parses all temporary JsDoc strings in this node and all its children recursively as well. Assumes the remaining JsDoc strings are contained in pre-order with skips allowed, in the given comments, after the given index.  @param node The current node to start parsing at. @param comments An array of all comments in the source. @param ci Current index into the array of comments.  @return Current index into the array of comments after parsing this node. ",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "IRFactory.parseJSDocInfo",
    "class_name": "com.google.javascript.jscomp.parsing.IRFactory",
    "signature": "com.google.javascript.jscomp.parsing.IRFactory.parseJSDocInfo(String,int,int)",
    "snippet": "  private JSDocInfo parseJSDocInfo(String comment, int lineno, int position) {\n    return parseJSDocInfo(comment, lineno, position, null, null);\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "IRFactory.parseJSDocInfo",
    "class_name": "com.google.javascript.jscomp.parsing.IRFactory",
    "signature": "com.google.javascript.jscomp.parsing.IRFactory.parseJSDocInfo(String,int,int,FileLevelJsDocBuilder,JSDocInfo)",
    "snippet": "  private JSDocInfo parseJSDocInfo(String comment, int lineno, int position,\n      Node.FileLevelJsDocBuilder fileLevelJsDocBuilder,\n      JSDocInfo fileOverviewInfo) {\n    // The JsDocInfoParser expects the comment without the initial '/**'.\n    int numOpeningChars = 3;\n    JsDocInfoParser jsdocParser =\n      new JsDocInfoParser(\n          new JsDocTokenStream(comment.substring(numOpeningChars),\n                               lineno,\n                               position2charno(position) + numOpeningChars),\n          sourceName,\n          config,\n          errorReporter);\n    jsdocParser.setFileLevelJsDocBuilder(fileLevelJsDocBuilder);\n    jsdocParser.setFileOverviewJSDocInfo(fileOverviewInfo);\n    jsdocParser.parse();\n    if (fileLevelJsDocBuilder != null) {\n      return jsdocParser.getFileOverviewJSDocInfo();\n    } else {\n      return jsdocParser.retrieveAndResetParsedJSDocInfo();\n    }\n  }",
    "comment": " Parse a JsDoc string into a JSDocInfo.  Used both for handling individual JSDoc comments (when it returns the new JSDocInfo for the node) and for handling file-level JSDoc comments (@fileoverview and @license).  In this second case, it returns a JSDocInfo if it found another @fileoverview, or null if not.  Also in the second case, all @license text found gets shoved into the fileLevelJsDocBuilder object.  @param comment The JsDoc comment to parse. @param lineno The line number of the node this comment is attached to. @param fileLevelJsDocBuilder The builder for file-level JSDocInfo. If not null, this method parses to a fileOverview JSDocInfo as opposed to a node-level one. @param fileOverviewInfo The current @fileoverview JSDocInfo, so that the parser may warn if another @fileoverview is found. May be null. @return A JSDocInfo. May be null if the method parses to the wrong level. ",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "IRFactory.position2charno",
    "class_name": "com.google.javascript.jscomp.parsing.IRFactory",
    "signature": "com.google.javascript.jscomp.parsing.IRFactory.position2charno(int)",
    "snippet": "  private int position2charno(int position) {\n    int lineIndex = sourceString.lastIndexOf('\\n', position);\n    if (lineIndex == -1) {\n      return position;\n    } else {\n      // Subtract one for initial position being 0.\n      return position - lineIndex - 1;\n    }\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "IRFactory.transform",
    "class_name": "com.google.javascript.jscomp.parsing.IRFactory",
    "signature": "com.google.javascript.jscomp.parsing.IRFactory.transform(AstNode)",
    "snippet": "  private Node transform(AstNode node) {\n    Node irNode = justTransform(node);\n    // If we have a named function, set the position to that of the name.\n    if (irNode.getType() == Token.FUNCTION &&\n        irNode.getFirstChild().getLineno() != -1) {\n      irNode.setLineno(irNode.getFirstChild().getLineno());\n      irNode.setCharno(irNode.getFirstChild().getCharno());\n    } else {\n      if (irNode.getLineno() == -1) {\n        // If we didn't already set the line, then set it now.  This avoids\n        // cases like ParenthesizedExpression where we just return a previous\n        // node, but don't want the new node to get its parent's line number.\n        int lineno = node.getLineno();\n        irNode.setLineno(lineno);\n        int charno = position2charno(node.getAbsolutePosition());\n        irNode.setCharno(charno);\n      }\n    }\n    if (node.getJsDoc() != null) {\n      irNode.putProp(TMP_JSDOC_PROP, node.getJsDoc());\n    }\n    return irNode;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "IRFactory.transformTokenType",
    "class_name": "com.google.javascript.jscomp.parsing.IRFactory",
    "signature": "com.google.javascript.jscomp.parsing.IRFactory.transformTokenType(int)",
    "snippet": "  private static int transformTokenType(int token) {\n    switch (token) {\n      case com.google.javascript.jscomp.mozilla.rhino.Token.ERROR:\n        return Token.ERROR;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.EOF:\n        return Token.EOF;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.EOL:\n        return Token.EOL;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.ENTERWITH:\n        return Token.ENTERWITH;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.LEAVEWITH:\n        return Token.LEAVEWITH;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.RETURN:\n        return Token.RETURN;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.GOTO:\n        return Token.GOTO;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.IFEQ:\n        return Token.IFEQ;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.IFNE:\n        return Token.IFNE;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.SETNAME:\n        return Token.SETNAME;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.BITOR:\n        return Token.BITOR;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.BITXOR:\n        return Token.BITXOR;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.BITAND:\n        return Token.BITAND;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.EQ:\n        return Token.EQ;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.NE:\n        return Token.NE;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.LT:\n        return Token.LT;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.LE:\n        return Token.LE;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.GT:\n        return Token.GT;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.GE:\n        return Token.GE;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.LSH:\n        return Token.LSH;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.RSH:\n        return Token.RSH;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.URSH:\n        return Token.URSH;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.ADD:\n        return Token.ADD;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.SUB:\n        return Token.SUB;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.MUL:\n        return Token.MUL;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.DIV:\n        return Token.DIV;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.MOD:\n        return Token.MOD;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.NOT:\n        return Token.NOT;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.BITNOT:\n        return Token.BITNOT;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.POS:\n        return Token.POS;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.NEG:\n        return Token.NEG;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.NEW:\n        return Token.NEW;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.DELPROP:\n        return Token.DELPROP;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.TYPEOF:\n        return Token.TYPEOF;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.GETPROP:\n        return Token.GETPROP;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.SETPROP:\n        return Token.SETPROP;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.GETELEM:\n        return Token.GETELEM;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.SETELEM:\n        return Token.SETELEM;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.CALL:\n        return Token.CALL;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.NAME:\n        return Token.NAME;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.NUMBER:\n        return Token.NUMBER;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.STRING:\n        return Token.STRING;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.NULL:\n        return Token.NULL;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.THIS:\n        return Token.THIS;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.FALSE:\n        return Token.FALSE;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.TRUE:\n        return Token.TRUE;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.SHEQ:\n        return Token.SHEQ;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.SHNE:\n        return Token.SHNE;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.REGEXP:\n        return Token.REGEXP;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.BINDNAME:\n        return Token.BINDNAME;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.THROW:\n        return Token.THROW;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.RETHROW:\n        return Token.RETHROW;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.IN:\n        return Token.IN;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.INSTANCEOF:\n        return Token.INSTANCEOF;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.LOCAL_LOAD:\n        return Token.LOCAL_LOAD;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.GETVAR:\n        return Token.GETVAR;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.SETVAR:\n        return Token.SETVAR;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.CATCH_SCOPE:\n        return Token.CATCH_SCOPE;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.ENUM_INIT_KEYS:\n        return Token.ENUM_INIT_KEYS;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.ENUM_INIT_VALUES:\n        return Token.ENUM_INIT_VALUES;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.ENUM_NEXT:\n        return Token.ENUM_NEXT;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.ENUM_ID:\n        return Token.ENUM_ID;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.THISFN:\n        return Token.THISFN;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.RETURN_RESULT:\n        return Token.RETURN_RESULT;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.ARRAYLIT:\n        return Token.ARRAYLIT;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.OBJECTLIT:\n        return Token.OBJECTLIT;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.GET_REF:\n        return Token.GET_REF;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.SET_REF:\n        return Token.SET_REF;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.DEL_REF:\n        return Token.DEL_REF;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.REF_CALL:\n        return Token.REF_CALL;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.REF_SPECIAL:\n        return Token.REF_SPECIAL;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.DEFAULTNAMESPACE:\n        return Token.DEFAULTNAMESPACE;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.ESCXMLTEXT:\n        return Token.ESCXMLTEXT;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.ESCXMLATTR:\n        return Token.ESCXMLATTR;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.REF_MEMBER:\n        return Token.REF_MEMBER;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.REF_NS_MEMBER:\n        return Token.REF_NS_MEMBER;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.REF_NAME:\n        return Token.REF_NAME;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.REF_NS_NAME:\n        return Token.REF_NS_NAME;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.TRY:\n        return Token.TRY;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.SEMI:\n        return Token.SEMI;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.LB:\n        return Token.LB;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.RB:\n        return Token.RB;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.LC:\n        return Token.LC;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.RC:\n        return Token.RC;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.LP:\n        return Token.LP;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.RP:\n        return Token.RP;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.COMMA:\n        return Token.COMMA;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.ASSIGN:\n        return Token.ASSIGN;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.ASSIGN_BITOR:\n        return Token.ASSIGN_BITOR;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.ASSIGN_BITXOR:\n        return Token.ASSIGN_BITXOR;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.ASSIGN_BITAND:\n        return Token.ASSIGN_BITAND;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.ASSIGN_LSH:\n        return Token.ASSIGN_LSH;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.ASSIGN_RSH:\n        return Token.ASSIGN_RSH;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.ASSIGN_URSH:\n        return Token.ASSIGN_URSH;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.ASSIGN_ADD:\n        return Token.ASSIGN_ADD;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.ASSIGN_SUB:\n        return Token.ASSIGN_SUB;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.ASSIGN_MUL:\n        return Token.ASSIGN_MUL;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.ASSIGN_DIV:\n        return Token.ASSIGN_DIV;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.ASSIGN_MOD:\n        return Token.ASSIGN_MOD;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.HOOK:\n        return Token.HOOK;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.COLON:\n        return Token.COLON;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.OR:\n        return Token.OR;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.AND:\n        return Token.AND;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.INC:\n        return Token.INC;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.DEC:\n        return Token.DEC;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.DOT:\n        return Token.DOT;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.FUNCTION:\n        return Token.FUNCTION;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.EXPORT:\n        return Token.EXPORT;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.IMPORT:\n        return Token.IMPORT;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.IF:\n        return Token.IF;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.ELSE:\n        return Token.ELSE;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.SWITCH:\n        return Token.SWITCH;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.CASE:\n        return Token.CASE;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.DEFAULT:\n        return Token.DEFAULT;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.WHILE:\n        return Token.WHILE;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.DO:\n        return Token.DO;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.FOR:\n        return Token.FOR;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.BREAK:\n        return Token.BREAK;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.CONTINUE:\n        return Token.CONTINUE;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.VAR:\n        return Token.VAR;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.WITH:\n        return Token.WITH;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.CATCH:\n        return Token.CATCH;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.FINALLY:\n        return Token.FINALLY;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.VOID:\n        return Token.VOID;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.RESERVED:\n        return Token.RESERVED;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.EMPTY:\n        return Token.EMPTY;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.BLOCK:\n        return Token.BLOCK;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.LABEL:\n        return Token.LABEL;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.TARGET:\n        return Token.TARGET;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.LOOP:\n        return Token.LOOP;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.EXPR_VOID:\n        return Token.EXPR_VOID;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.EXPR_RESULT:\n        return Token.EXPR_RESULT;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.JSR:\n        return Token.JSR;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.SCRIPT:\n        return Token.SCRIPT;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.TYPEOFNAME:\n        return Token.TYPEOFNAME;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.USE_STACK:\n        return Token.USE_STACK;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.SETPROP_OP:\n        return Token.SETPROP_OP;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.SETELEM_OP:\n        return Token.SETELEM_OP;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.LOCAL_BLOCK:\n        return Token.LOCAL_BLOCK;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.SET_REF_OP:\n        return Token.SET_REF_OP;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.DOTDOT:\n        return Token.DOTDOT;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.COLONCOLON:\n        return Token.COLONCOLON;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.XML:\n        return Token.XML;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.DOTQUERY:\n        return Token.DOTQUERY;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.XMLATTR:\n        return Token.XMLATTR;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.XMLEND:\n        return Token.XMLEND;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.TO_OBJECT:\n        return Token.TO_OBJECT;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.TO_DOUBLE:\n        return Token.TO_DOUBLE;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.GET:\n        return Token.GET;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.SET:\n        return Token.SET;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.CONST:\n        return Token.CONST;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.SETCONST:\n        return Token.SETCONST;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.DEBUGGER:\n        return Token.DEBUGGER;\n    }\n\n    // Token without name\n    throw new IllegalStateException(String.valueOf(token));\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "IRFactory.transformTree",
    "class_name": "com.google.javascript.jscomp.parsing.IRFactory",
    "signature": "com.google.javascript.jscomp.parsing.IRFactory.transformTree(AstRoot,String,Config,ErrorReporter)",
    "snippet": "  public static Node transformTree(AstRoot node,\n                                   String sourceString,\n                                   Config config,\n                                   ErrorReporter errorReporter) {\n    IRFactory irFactory = new IRFactory(sourceString, node.getSourceName(),\n        config, errorReporter);\n    Node irNode = irFactory.transform(node);\n    // @license text gets appended onto the fileLevelJsDocBuilder as found,\n    // and stored straight into the JSDocInfo for the root node.\n    Node.FileLevelJsDocBuilder fileLevelJsDocBuilder =\n        irNode.getJsDocBuilderForNode();\n    // fileOverviewInfo stores the last bit of fileoverview data we saw.\n    // We only permit one, so throwing away extras is fair.\n    // The fileOverviewInfo gets passed into parseJSDocInfo so that\n    // it can detect when multiple @fileoverviews exist in the same file.\n    JSDocInfo fileOverviewInfo = null;\n    if (node.getComments() != null) {\n      for (Comment comment : node.getComments()) {\n        if (comment.getCommentType() == JSDOC &&\n            (comment.getValue().contains(\"@fileoverview\") ||\n             comment.getValue().contains(\"@preserve\") ||\n             comment.getValue().contains(\"@license\"))) {\n          JSDocInfo info = irFactory.parseJSDocInfo(comment.getValue(),\n              comment.getLineno(), comment.getAbsolutePosition(),\n              fileLevelJsDocBuilder, fileOverviewInfo);\n          if (info != null && fileOverviewInfo == null) {\n            fileOverviewInfo = info;\n          }\n        }\n      }\n\n      // Only after we've seen all @fileoverview entries, attach the\n      // last one to the root node, and copy the found license strings\n      // to that node.\n      if (fileOverviewInfo != null) {\n        if ((irNode.getJSDocInfo() != null) &&\n            (irNode.getJSDocInfo().getLicense() != null)) {\n          fileOverviewInfo.setLicense(irNode.getJSDocInfo().getLicense());\n        }\n        irNode.setJSDocInfo(fileOverviewInfo);\n      }\n\n      Comment[] comments = new Comment[node.getComments().size()];\n      comments = node.getComments().toArray(comments);\n      irFactory.parseAllJsDocInfo(irNode, comments, 0);\n    }\n    return irNode;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "TransformDispatcher.processAstRoot",
    "class_name": "com.google.javascript.jscomp.parsing.IRFactory$TransformDispatcher",
    "signature": "com.google.javascript.jscomp.parsing.IRFactory$TransformDispatcher.processAstRoot(AstRoot)",
    "snippet": "    @Override\n    Node processAstRoot(AstRoot rootNode) {\n      Node node = new ScriptOrFnNode(Token.SCRIPT);\n      for (com.google.javascript.jscomp.mozilla.rhino.Node child : rootNode) {\n        node.addChildToBack(transform((AstNode)child));\n      }\n      return node;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "TransformDispatcher.processBlock",
    "class_name": "com.google.javascript.jscomp.parsing.IRFactory$TransformDispatcher",
    "signature": "com.google.javascript.jscomp.parsing.IRFactory$TransformDispatcher.processBlock(Block)",
    "snippet": "    @Override\n    Node processBlock(Block blockNode) {\n      return processGeneric(blockNode);\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "TransformDispatcher.processExpressionStatement",
    "class_name": "com.google.javascript.jscomp.parsing.IRFactory$TransformDispatcher",
    "signature": "com.google.javascript.jscomp.parsing.IRFactory$TransformDispatcher.processExpressionStatement(ExpressionStatement)",
    "snippet": "    @Override\n    Node processExpressionStatement(ExpressionStatement statementNode) {\n      Node node = new Node(transformTokenType(statementNode.getType()));\n      node.addChildToBack(transform(statementNode.getExpression()));\n      return node;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "TransformDispatcher.processFunctionNode",
    "class_name": "com.google.javascript.jscomp.parsing.IRFactory$TransformDispatcher",
    "signature": "com.google.javascript.jscomp.parsing.IRFactory$TransformDispatcher.processFunctionNode(FunctionNode)",
    "snippet": "   @Override\n  Node processFunctionNode(FunctionNode functionNode) {\n      Name name = functionNode.getFunctionName();\n      Boolean isUnnamedFunction = false;\n      if (name == null) {\n        name = new Name();\n        name.setIdentifier(\"\");\n        isUnnamedFunction = true;\n      }\n      Node node = new com.google.javascript.rhino.FunctionNode(\n          name.getIdentifier());\n      node.putProp(Node.SOURCENAME_PROP, functionNode.getSourceName());\n      Node newName = transform(name);\n      if (isUnnamedFunction) {\n        // Old Rhino tagged the empty name node with the line number of the\n        // declaration.\n        newName.setLineno(functionNode.getLineno());\n        // TODO(user) Mark line number of paren correctly.\n        // Same problem as below - the left paren might not be on the\n        // same line as the function keyword.\n        int lpColumn = functionNode.getAbsolutePosition() +\n            functionNode.getLp();\n        newName.setCharno(position2charno(lpColumn));\n      }\n\n      node.addChildToBack(newName);\n      Node lp = new Node(Token.LP);\n      // The left paren's complicated because it's not represented by an\n      // AstNode, so there's nothing that has the actual line number that it\n      // appeared on.  We know the paren has to appear on the same line as the\n      // function name (or else a semicolon will be inserted.)  If there's no\n      // function name, assume the paren was on the same line as the function.\n      // TODO(user): Mark line number of paren correctly.\n      Name fnName = functionNode.getFunctionName();\n      if (fnName != null) {\n        lp.setLineno(fnName.getLineno());\n      } else {\n        lp.setLineno(functionNode.getLineno());\n      }\n      int lparenCharno = functionNode.getLp() +\n          functionNode.getAbsolutePosition();\n\n      lp.setCharno(position2charno(lparenCharno));\n      for (AstNode param : functionNode.getParams()) {\n        lp.addChildToBack(transform(param));\n      }\n      node.addChildToBack(lp);\n      node.addChildToBack(transform(functionNode.getBody()));\n     return node;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "TransformDispatcher.processGeneric",
    "class_name": "com.google.javascript.jscomp.parsing.IRFactory$TransformDispatcher",
    "signature": "com.google.javascript.jscomp.parsing.IRFactory$TransformDispatcher.processGeneric(Node)",
    "snippet": "    private Node processGeneric(\n        com.google.javascript.jscomp.mozilla.rhino.Node n) {\n      Node node = new Node(transformTokenType(n.getType()));\n      for (com.google.javascript.jscomp.mozilla.rhino.Node child : n) {\n        node.addChildToBack(transform((AstNode)child));\n      }\n      return node;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "TransformDispatcher.processKeywordLiteral",
    "class_name": "com.google.javascript.jscomp.parsing.IRFactory$TransformDispatcher",
    "signature": "com.google.javascript.jscomp.parsing.IRFactory$TransformDispatcher.processKeywordLiteral(KeywordLiteral)",
    "snippet": "    @Override\n    Node processKeywordLiteral(KeywordLiteral literalNode) {\n      return new Node(transformTokenType(literalNode.getType()));\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "TransformDispatcher.processName",
    "class_name": "com.google.javascript.jscomp.parsing.IRFactory$TransformDispatcher",
    "signature": "com.google.javascript.jscomp.parsing.IRFactory$TransformDispatcher.processName(Name)",
    "snippet": "    @Override\n    Node processName(Name nameNode) {\n      return Node.newString(Token.NAME, nameNode.getIdentifier());\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "TransformDispatcher.processPropertyGet",
    "class_name": "com.google.javascript.jscomp.parsing.IRFactory$TransformDispatcher",
    "signature": "com.google.javascript.jscomp.parsing.IRFactory$TransformDispatcher.processPropertyGet(PropertyGet)",
    "snippet": "    @Override\n    Node processPropertyGet(PropertyGet getNode) {\n      return new Node(\n          Token.GETPROP,\n          transform(getNode.getTarget()),\n          transformAsString(getNode.getProperty()));\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "TransformDispatcher.transformAsString",
    "class_name": "com.google.javascript.jscomp.parsing.IRFactory$TransformDispatcher",
    "signature": "com.google.javascript.jscomp.parsing.IRFactory$TransformDispatcher.transformAsString(AstNode)",
    "snippet": "    private Node transformAsString(AstNode n) {\n      Node ret = transform(n);\n      if (ret.getType() == Token.STRING) {\n        ret.putBooleanProp(Node.QUOTED_PROP, true);\n      } else if (ret.getType() == Token.NAME) {\n        ret.setType(Token.STRING);\n      }\n      return ret;\n    }",
    "comment": " Transforms the given node and then sets its type to Token.STRING if it was Token.NAME. If its type was already Token.STRING, then quotes it. Used for properties, as the old AST uses String tokens, while the new one uses Name tokens for unquoted strings. For example, in var o = {'a' : 1, b: 2}; the string 'a' is quoted, while the name b is turned into a string, but unquoted. ",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "JsDocInfoParser.JsDocInfoParser",
    "class_name": "com.google.javascript.jscomp.parsing.JsDocInfoParser",
    "signature": "com.google.javascript.jscomp.parsing.JsDocInfoParser.JsDocInfoParser(JsDocTokenStream,String,Config,ErrorReporter)",
    "snippet": "  JsDocInfoParser(JsDocTokenStream stream,\n                  String sourceName,\n                  Config config,\n                  ErrorReporter errorReporter) {\n    this.stream = stream;\n    this.sourceName = sourceName;\n    this.typeRegistry = config.registry;\n    this.jsdocBuilder = new JSDocInfoBuilder(config.parseJsDocDocumentation);\n    this.annotationNames = buildAnnotationNames(config);\n\n    this.errorReporter = errorReporter;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "JsDocInfoParser.buildAnnotationNames",
    "class_name": "com.google.javascript.jscomp.parsing.JsDocInfoParser",
    "signature": "com.google.javascript.jscomp.parsing.JsDocInfoParser.buildAnnotationNames(Config)",
    "snippet": "  private static Map<String, Annotation> buildAnnotationNames(Config config) {\n    ImmutableMapBuilder<String, Annotation> annotationBuilder =\n        ImmutableMapBuilder.fromMap(recognizedAnnotations);\n    for (String unrecognizedAnnotation : config.annotationWhitelist) {\n      if (!recognizedAnnotations.containsKey(unrecognizedAnnotation)) {\n        annotationBuilder.put(\n            unrecognizedAnnotation, Annotation.NOT_IMPLEMENTED);\n      }\n    }\n    return annotationBuilder.getMap();\n  }",
    "comment": "Create the annotation names from the user-specified config. */",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "JsDocInfoParser.extractBlockComment",
    "class_name": "com.google.javascript.jscomp.parsing.JsDocInfoParser",
    "signature": "com.google.javascript.jscomp.parsing.JsDocInfoParser.extractBlockComment(JsDocToken)",
    "snippet": "  private ExtractionInfo extractBlockComment(JsDocToken token) {\n    StringBuilder builder = new StringBuilder();\n\n    boolean ignoreStar = true;\n\n    do {\n      switch (token) {\n        case ANNOTATION:\n        case EOC:\n        case EOF:\n          return new ExtractionInfo(builder.toString().trim(), token);\n\n        case STAR:\n          if (!ignoreStar) {\n            if (builder.length() > 0) {\n              builder.append(' ');\n            }\n\n            builder.append('*');\n          }\n\n          token = next();\n          continue;\n\n        case EOL:\n          ignoreStar = true;\n          builder.append('\\n');\n          token = next();\n          continue;\n\n        default:\n          if (!ignoreStar && builder.length() > 0) {\n            builder.append(' ');\n          }\n\n          ignoreStar = false;\n\n          builder.append(toString(token));\n\n          String line = stream.getRemainingJSDocLine();\n          line = trimEnd(line);\n          builder.append(line);\n          token = next();\n      }\n    } while (true);\n  }",
    "comment": " Extracts the top-level block comment from the JsDoc comment, if any. This method differs from the extractMultilineTextualBlock in that it terminates under different conditions (it doesn't have the same prechecks), it does not first read in the remaining of the current line and its conditions for ignoring the \"*\" (STAR) are different.  @param token The starting token.  @return The extraction information. ",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "JsDocInfoParser.hasParsedFileOverviewDocInfo",
    "class_name": "com.google.javascript.jscomp.parsing.JsDocInfoParser",
    "signature": "com.google.javascript.jscomp.parsing.JsDocInfoParser.hasParsedFileOverviewDocInfo()",
    "snippet": "  private boolean hasParsedFileOverviewDocInfo() {\n    return jsdocBuilder.isPopulatedWithFileOverview();\n  }",
    "comment": " Determines whether the parser has been populated with docinfo with a fileoverview tag. ",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "JsDocInfoParser.next",
    "class_name": "com.google.javascript.jscomp.parsing.JsDocInfoParser",
    "signature": "com.google.javascript.jscomp.parsing.JsDocInfoParser.next()",
    "snippet": "  private JsDocToken next() {\n    if (unreadToken == NO_UNREAD_TOKEN) {\n      return stream.getJsDocToken();\n    } else {\n      return current();\n    }\n  }",
    "comment": " Gets the next token of the token stream or the buffered token if a matching was previously made. ",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "JsDocInfoParser.parse",
    "class_name": "com.google.javascript.jscomp.parsing.JsDocInfoParser",
    "signature": "com.google.javascript.jscomp.parsing.JsDocInfoParser.parse()",
    "snippet": "  boolean parse() {\n    int lineno;\n    int charno;\n\n    // JSTypes are represented as Rhino AST nodes, and then resolved later.\n    JSTypeExpression type;\n\n    state = State.SEARCHING_ANNOTATION;\n    JsDocToken token = next();\n\n    ExtractionInfo blockInfo = extractBlockComment(token);\n    token = blockInfo.token;\n\n    // If we have a block level comment, record it.\n    if (blockInfo.string.length() > 0) {\n      jsdocBuilder.recordBlockDescription(blockInfo.string);\n    }\n\n    // Parse the actual JsDoc.\n    retry: for (;;) {\n      switch (token) {\n        case ANNOTATION:\n          if (state == State.SEARCHING_ANNOTATION) {\n            state = State.SEARCHING_NEWLINE;\n            lineno = stream.getLineno();\n            charno = stream.getCharno();\n\n            String annotationName = stream.getString();\n            Annotation annotation = annotationNames.get(annotationName);\n            if (annotation == null) {\n              parser.addWarning(\"msg.bad.jsdoc.tag\", annotationName,\n                  stream.getLineno(), stream.getCharno());\n            } else {\n              // Mark the beginning of the annotation.\n              jsdocBuilder.markAnnotation(annotationName, lineno, charno);\n\n              switch (annotation) {\n                case AUTHOR:\n                  ExtractionInfo authorInfo = extractSingleLineBlock();\n                  String author = authorInfo.string;\n\n                  if (author.length() == 0) {\n                    parser.addWarning(\"msg.jsdoc.authormissing\",\n                          stream.getLineno(), stream.getCharno());\n                  } else {\n                    jsdocBuilder.addAuthor(author);\n                  }\n\n                  token = authorInfo.token;\n                  continue retry;\n\n                case CONSTANT:\n                  if (!jsdocBuilder.recordConstancy()) {\n                    parser.addWarning(\"msg.jsdoc.const\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case CONSTRUCTOR:\n                  if (!jsdocBuilder.recordConstructor()) {\n                    if (jsdocBuilder.isInterfaceRecorded()) {\n                      parser.addWarning(\"msg.jsdoc.interface.constructor\",\n                          stream.getLineno(), stream.getCharno());\n                    } else {\n                      parser.addWarning(\"msg.jsdoc.incompat.type\",\n                          stream.getLineno(), stream.getCharno());\n                    }\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case DEPRECATED:\n                  if (!jsdocBuilder.recordDeprecated()) {\n                    parser.addWarning(\"msg.jsdoc.deprecated\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n\n                  // Find the reason/description, if any.\n                  ExtractionInfo reasonInfo =\n                      extractMultilineTextualBlock(token);\n\n                  String reason = reasonInfo.string;\n\n                  if (reason.length() > 0) {\n                    jsdocBuilder.recordDeprecationReason(reason);\n                  }\n\n                  token = reasonInfo.token;\n                  continue retry;\n\n                case INTERFACE:\n                  if (!jsdocBuilder.recordInterface()) {\n                    if (jsdocBuilder.isConstructorRecorded()) {\n                      parser.addWarning(\"msg.jsdoc.interface.constructor\",\n                          stream.getLineno(), stream.getCharno());\n                    } else {\n                      parser.addWarning(\"msg.jsdoc.incompat.type\",\n                          stream.getLineno(), stream.getCharno());\n                    }\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case DESC:\n                  if (jsdocBuilder.isDescriptionRecorded()) {\n                    parser.addWarning(\"msg.jsdoc.desc.extra\",\n                        stream.getLineno(), stream.getCharno());\n                    token = eatTokensUntilEOL();\n                    continue retry;\n                  } else {\n                    ExtractionInfo descriptionInfo =\n                        extractMultilineTextualBlock(token);\n\n                    String description = descriptionInfo.string;\n\n                    jsdocBuilder.recordDescription(description);\n                    token = descriptionInfo.token;\n                    continue retry;\n                  }\n\n                case FILE_OVERVIEW:\n                  ExtractionInfo fileOverviewInfo =\n                      extractMultilineTextualBlock(token,\n                                                   WhitespaceOption.TRIM);\n\n                  String fileOverview = fileOverviewInfo.string;\n\n                  if (!jsdocBuilder.recordFileOverview(fileOverview) ||\n                      fileOverviewJSDocInfo != null) {\n                    parser.addWarning(\"msg.jsdoc.fileoverview.extra\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  token = fileOverviewInfo.token;\n                  continue retry;\n\n                case LICENSE:\n                case PRESERVE:\n                  ExtractionInfo preserveInfo =\n                      extractMultilineTextualBlock(token,\n                                                   WhitespaceOption.PRESERVE);\n\n                  String preserve = preserveInfo.string;\n\n                  if (preserve.length() > 0) {\n                    if (fileLevelJsDocBuilder != null) {\n                      fileLevelJsDocBuilder.append(preserve);\n                    }\n                  }\n\n                  token = preserveInfo.token;\n                  continue retry;\n\n                case ENUM:\n                  token = next();\n                  lineno = stream.getLineno();\n                  charno = stream.getCharno();\n\n                  type = null;\n                  if (token != JsDocToken.EOL && token != JsDocToken.EOC) {\n                    type = createJSTypeExpression(\n                        parseAndRecordTypeNode(token));\n                  }\n\n                  if (type == null) {\n                    type = createJSTypeExpression(newStringNode(\"number\"));\n                  }\n                  if (!jsdocBuilder.recordEnumParameterType(type)) {\n                    parser.addWarning(\"msg.jsdoc.incompat.type\", lineno, charno);\n                  }\n                  token = eatTokensUntilEOL(token);\n                  continue retry;\n\n                case EXPORT:\n                  if (!jsdocBuilder.recordExport()) {\n                    parser.addWarning(\"msg.jsdoc.export\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case EXTENDS:\n                case IMPLEMENTS:\n                  skipEOLs();\n                  token = next();\n                  lineno = stream.getLineno();\n                  charno = stream.getCharno();\n                  boolean matchingRc = false;\n\n                  if (token == JsDocToken.LC) {\n                    token = next();\n                    matchingRc = true;\n                  }\n\n                  if (token == JsDocToken.STRING) {\n                    Node typeNode = parseAndRecordTypeNameNode(\n                        token, lineno, charno, matchingRc);\n\n                    lineno = stream.getLineno();\n                    charno = stream.getCharno();\n\n                    typeNode = wrapNode(Token.BANG, typeNode);\n                    if (typeNode != null && !matchingRc) {\n                      typeNode.putBooleanProp(Node.BRACELESS_TYPE, true);\n                    }\n                    type = createJSTypeExpression(typeNode);\n\n                    if (annotation == Annotation.EXTENDS) {\n                      if (!jsdocBuilder.recordBaseType(type)) {\n                        parser.addWarning(\n                            \"msg.jsdoc.incompat.type\", lineno, charno);\n                      }\n                    } else {\n                      Preconditions.checkState(\n                          annotation == Annotation.IMPLEMENTS);\n                      if (!jsdocBuilder.recordImplementedInterface(type)) {\n                        parser.addWarning(\"msg.jsdoc.implements.duplicate\",\n                            lineno, charno);\n                      }\n                    }\n                    token = next();\n                    if (matchingRc) {\n                      if (token != JsDocToken.RC) {\n                        parser.addWarning(\"msg.jsdoc.missing.rc\",\n                            stream.getLineno(), stream.getCharno());\n                      }\n                    } else if (token != JsDocToken.EOL &&\n                        token != JsDocToken.EOF && token != JsDocToken.EOC) {\n                      parser.addWarning(\"msg.end.annotation.expected\",\n                          stream.getLineno(), stream.getCharno());\n                    }\n                  } else {\n                    parser.addWarning(\"msg.no.type.name\", lineno, charno);\n                  }\n                  token = eatTokensUntilEOL(token);\n                  continue retry;\n\n                case HIDDEN:\n                  if (!jsdocBuilder.recordHiddenness()) {\n                    parser.addWarning(\"msg.jsdoc.hidden\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case NO_ALIAS:\n                  if (!jsdocBuilder.recordNoAlias()) {\n                    parser.addWarning(\"msg.jsdoc.noalias\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case NO_TYPE_CHECK:\n                  if (!jsdocBuilder.recordNoTypeCheck()) {\n                    parser.addWarning(\"msg.jsdoc.nocheck\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case NOT_IMPLEMENTED:\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case INHERIT_DOC:\n                case OVERRIDE:\n                  if (!jsdocBuilder.recordOverride()) {\n                    parser.addWarning(\"msg.jsdoc.override\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case THROWS:\n                  skipEOLs();\n                  token = next();\n                  lineno = stream.getLineno();\n                  charno = stream.getCharno();\n                  type = null;\n\n                  if (token == JsDocToken.LC) {\n                    type = createJSTypeExpression(\n                        parseAndRecordTypeNode(token));\n\n                    if (type == null) {\n                      // parsing error reported during recursive descent\n                      // recovering parsing\n                      token = eatTokensUntilEOL();\n                      continue retry;\n                    }\n                  }\n\n                  // *Update* the token to that after the type annotation.\n                  token = current();\n\n                  // Save the throw type.\n                  jsdocBuilder.recordThrowType(type);\n\n                  // Find the throw's description (if applicable).\n                  ExtractionInfo descriptionInfo =\n                      extractMultilineTextualBlock(token);\n\n                  String description = descriptionInfo.string;\n\n                  if (description.length() > 0) {\n                    jsdocBuilder.recordThrowDescription(type, description);\n                  }\n\n                  token = descriptionInfo.token;\n                  continue retry;\n\n                case PARAM:\n                  skipEOLs();\n                  token = next();\n                  lineno = stream.getLineno();\n                  charno = stream.getCharno();\n                  type = null;\n\n                  if (token == JsDocToken.LC) {\n                    type = createJSTypeExpression(\n                        parseAndRecordParamTypeNode(token));\n\n                    if (type == null) {\n                      // parsing error reported during recursive descent\n                      // recovering parsing\n                      token = eatTokensUntilEOL();\n                      continue retry;\n                    }\n                    skipEOLs();\n                    token = next();\n                    lineno = stream.getLineno();\n                    charno = stream.getCharno();\n                  }\n\n                  String name = null;\n\n                  if (JsDocToken.STRING != token) {\n                    parser.addWarning(\"msg.missing.variable.name\",\n                        lineno, charno);\n                  } else {\n                    name = stream.getString();\n                    if (!jsdocBuilder.recordParameter(name, type)) {\n                      if (jsdocBuilder.hasParameter(name)) {\n                        parser.addWarning(\"msg.dup.variable.name\", name,\n                            lineno, charno);\n                      } else {\n                        parser.addWarning(\"msg.jsdoc.incompat.type\", name,\n                            lineno, charno);\n                      }\n                    }\n                  }\n\n                  if (name == null) {\n                    token = eatTokensUntilEOL(token);\n                    continue retry;\n                  }\n\n                  jsdocBuilder.markName(name, lineno, charno);\n\n                  // Find the parameter's description (if applicable).\n                  ExtractionInfo paramDescriptionInfo =\n                      extractMultilineTextualBlock(token);\n\n                  String paramDescription = paramDescriptionInfo.string;\n\n                  if (paramDescription.length() > 0) {\n                    jsdocBuilder.recordParameterDescription(name,\n                                                            paramDescription);\n                  }\n\n                  token = paramDescriptionInfo.token;\n                  continue retry;\n\n                case PRESERVE_TRY:\n                  if (!jsdocBuilder.recordPreserveTry()) {\n                    parser.addWarning(\"msg.jsdoc.preservertry\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case PRIVATE:\n                  if (!jsdocBuilder.recordVisibility(Visibility.PRIVATE)) {\n                    parser.addWarning(\"msg.jsdoc.visibility.private\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case PROTECTED:\n                  if (!jsdocBuilder.recordVisibility(Visibility.PROTECTED)) {\n                    parser.addWarning(\"msg.jsdoc.visibility.protected\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case PUBLIC:\n                  if (!jsdocBuilder.recordVisibility(Visibility.PUBLIC)) {\n                    parser.addWarning(\"msg.jsdoc.visibility.public\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case NO_SHADOW:\n                  if (!jsdocBuilder.recordNoShadow()) {\n                    parser.addWarning(\"msg.jsdoc.noshadow\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case NO_SIDE_EFFECTS:\n                  if (!jsdocBuilder.recordNoSideEffects()) {\n                    parser.addWarning(\"msg.jsdoc.nosideeffects\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case IMPLICIT_CAST:\n                  if (!jsdocBuilder.recordImplicitCast()) {\n                    parser.addWarning(\"msg.jsdoc.implicitcast\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case SEE:\n                  ExtractionInfo referenceInfo = extractSingleLineBlock();\n                  String reference = referenceInfo.string;\n\n                  if (reference.length() == 0) {\n                    parser.addWarning(\"msg.jsdoc.seemissing\",\n                          stream.getLineno(), stream.getCharno());\n                  } else {\n                    jsdocBuilder.addReference(reference);\n                  }\n\n                  token = referenceInfo.token;\n                  continue retry;\n\n                case SUPPRESS:\n                  token = parseSuppressTag(next());\n                  continue retry;\n\n                case TEMPLATE:\n                  ExtractionInfo templateInfo = extractSingleLineBlock();\n                  String templateTypeName = templateInfo.string;\n\n                  if (templateTypeName.length() == 0) {\n                    parser.addWarning(\"msg.jsdoc.templatemissing\",\n                          stream.getLineno(), stream.getCharno());\n                  } else if (!jsdocBuilder.recordTemplateTypeName(\n                      templateTypeName)) {\n                    parser.addWarning(\"msg.jsdoc.template.at.most.once\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n\n                  token = templateInfo.token;\n                  continue retry;\n\n                case VERSION:\n                  ExtractionInfo versionInfo = extractSingleLineBlock();\n                  String version = versionInfo.string;\n\n                  if (version.length() == 0) {\n                    parser.addWarning(\"msg.jsdoc.versionmissing\",\n                          stream.getLineno(), stream.getCharno());\n                  } else {\n                    if (!jsdocBuilder.recordVersion(version)) {\n                       parser.addWarning(\"msg.jsdoc.extraversion\",\n                          stream.getLineno(), stream.getCharno());\n                    }\n                  }\n\n                  token = versionInfo.token;\n                  continue retry;\n\n                case DEFINE:\n                case RETURN:\n                case THIS:\n                case TYPE:\n                case TYPEDEF:\n                  skipEOLs();\n                  lineno = stream.getLineno();\n                  charno = stream.getCharno();\n\n                  token = next();\n\n                  Node typeNode = parseAndRecordTypeNode(token, lineno, charno);\n\n                  if (annotation == Annotation.THIS) {\n                    typeNode = wrapNode(Token.BANG, typeNode);\n                    if (typeNode != null && token != JsDocToken.LC) {\n                      typeNode.putBooleanProp(Node.BRACELESS_TYPE, true);\n                    }\n                  }\n                  type = createJSTypeExpression(typeNode);\n\n                  if (type == null) {\n                    // error reported during recursive descent\n                    // recovering parsing\n                  } else {\n                    switch (annotation) {\n                      case DEFINE:\n                        if (!isValidDefineType(typeNode)) {\n                          parser.addWarning(\"msg.jsdoc.define.badtype\",\n                              lineno, charno);\n                        } else if (!jsdocBuilder.recordDefineType(type)) {\n                          parser.addWarning(\"msg.jsdoc.define\",\n                              lineno, charno);\n                        }\n                        break;\n\n                      case RETURN:\n                        if (!jsdocBuilder.recordReturnType(type)) {\n                          parser.addWarning(\n                              \"msg.jsdoc.incompat.type\", lineno, charno);\n                          break;\n                        }\n\n                        // *Update* the token to that after the type annotation.\n                        token = current();\n\n                        // Find the return's description (if applicable).\n                        ExtractionInfo returnDescriptionInfo =\n                            extractMultilineTextualBlock(token);\n\n                        String returnDescription = returnDescriptionInfo.string;\n\n                        if (returnDescription.length() > 0) {\n                          jsdocBuilder.recordReturnDescription(\n                              returnDescription);\n                        }\n\n                        token = returnDescriptionInfo.token;\n                        continue retry;\n\n                      case THIS:\n                        if (!jsdocBuilder.recordThisType(type)) {\n                          parser.addWarning(\n                              \"msg.jsdoc.incompat.type\", lineno, charno);\n                        }\n                        break;\n\n                      case TYPE:\n                        if (!jsdocBuilder.recordType(type)) {\n                          parser.addWarning(\n                              \"msg.jsdoc.incompat.type\", lineno, charno);\n                        }\n                        break;\n\n                      case TYPEDEF:\n                        if (!jsdocBuilder.recordTypedef(type)) {\n                          parser.addWarning(\n                              \"msg.jsdoc.incompat.type\", lineno, charno);\n                        }\n                        break;\n                    }\n\n                    token = eatTokensUntilEOL();\n                  }\n                  continue retry;\n              }\n            }\n          }\n          break;\n\n        case EOC:\n          if (hasParsedFileOverviewDocInfo()) {\n            fileOverviewJSDocInfo = retrieveAndResetParsedJSDocInfo();\n          }\n\n          return true;\n\n        case EOF:\n          // discard any accumulated information\n          jsdocBuilder.build(null);\n          parser.addWarning(\"msg.unexpected.eof\",\n              stream.getLineno(), stream.getCharno());\n          return false;\n\n        case EOL:\n          if (state == State.SEARCHING_NEWLINE) {\n            state = State.SEARCHING_ANNOTATION;\n          }\n          token = next();\n          continue retry;\n\n        default:\n          if (token == JsDocToken.STAR && state == State.SEARCHING_ANNOTATION) {\n            token = next();\n            continue retry;\n          } else {\n            state = State.SEARCHING_NEWLINE;\n            token = eatTokensUntilEOL();\n            continue retry;\n          }\n      }\n\n      // next token\n      token = next();\n    }\n  }",
    "comment": " Parses a {@link JSDocInfo} object. This parsing method reads all tokens returned by the {@link JsDocTokenStream#getJsDocToken()} method until the {@link JsDocToken#EOC} is returned.  @return {@code true} if JSDoc information was correctly parsed, {@code false} otherwise ",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "JsDocInfoParser.retrieveAndResetParsedJSDocInfo",
    "class_name": "com.google.javascript.jscomp.parsing.JsDocInfoParser",
    "signature": "com.google.javascript.jscomp.parsing.JsDocInfoParser.retrieveAndResetParsedJSDocInfo()",
    "snippet": "  JSDocInfo retrieveAndResetParsedJSDocInfo() {\n    return jsdocBuilder.build(sourceName);\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "JsDocInfoParser.setFileLevelJsDocBuilder",
    "class_name": "com.google.javascript.jscomp.parsing.JsDocInfoParser",
    "signature": "com.google.javascript.jscomp.parsing.JsDocInfoParser.setFileLevelJsDocBuilder(FileLevelJsDocBuilder)",
    "snippet": "  void setFileLevelJsDocBuilder(\n      Node.FileLevelJsDocBuilder fileLevelJsDocBuilder) {\n    this.fileLevelJsDocBuilder = fileLevelJsDocBuilder;\n  }",
    "comment": " Sets the JsDocBuilder for the file-level (root) node of this parse. The parser uses the builder to append any preserve annotations it encounters in jsdoc comments.  @param fileLevelJsDocBuilder ",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "JsDocInfoParser.setFileOverviewJSDocInfo",
    "class_name": "com.google.javascript.jscomp.parsing.JsDocInfoParser",
    "signature": "com.google.javascript.jscomp.parsing.JsDocInfoParser.setFileOverviewJSDocInfo(JSDocInfo)",
    "snippet": "  void setFileOverviewJSDocInfo(JSDocInfo fileOverviewJSDocInfo) {\n    this.fileOverviewJSDocInfo = fileOverviewJSDocInfo;\n  }",
    "comment": " Sets the file overview JSDocInfo, in order to warn about multiple uses of the @fileoverview tag in a file. ",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "JsDocInfoParser.toString",
    "class_name": "com.google.javascript.jscomp.parsing.JsDocInfoParser",
    "signature": "com.google.javascript.jscomp.parsing.JsDocInfoParser.toString(JsDocToken)",
    "snippet": "  private String toString(JsDocToken token) {\n    switch (token) {\n      case ANNOTATION:\n        return \"@\" + stream.getString();\n\n      case BANG:\n        return \"!\";\n\n      case COMMA:\n        return \",\";\n\n      case COLON:\n        return \":\";\n\n      case GT:\n        return \">\";\n\n      case LB:\n        return \"[\";\n\n      case LC:\n        return \"{\";\n\n      case LP:\n        return \"(\";\n\n      case LT:\n        return \".<\";\n\n      case QMARK:\n        return \"?\";\n\n      case PIPE:\n        return \"|\";\n\n      case RB:\n        return \"]\";\n\n      case RC:\n        return \"}\";\n\n      case RP:\n        return \")\";\n\n      case STAR:\n        return \"*\";\n\n      case ELLIPSIS:\n        return \"...\";\n\n      case EQUALS:\n        return \"=\";\n\n      case STRING:\n        return stream.getString();\n\n      default:\n        throw new IllegalStateException(token.toString());\n    }\n  }",
    "comment": " Converts a JSDoc token to its string representation. ",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "JsDocInfoParser.trimEnd",
    "class_name": "com.google.javascript.jscomp.parsing.JsDocInfoParser",
    "signature": "com.google.javascript.jscomp.parsing.JsDocInfoParser.trimEnd(String)",
    "snippet": "  private static String trimEnd(String s) {\n    int trimCount = 0;\n    while (trimCount < s.length()) {\n      char ch = s.charAt(s.length() - trimCount - 1);\n      if (Character.isWhitespace(ch)) {\n        trimCount++;\n      } else {\n        break;\n      }\n    }\n\n    if (trimCount == 0) {\n      return s;\n    }\n    return s.substring(0, s.length() - trimCount);\n  }",
    "comment": " Trim characters from only the end of a string. This method will remove all whitespace characters (defined by Character.isWhitespace(char), in addition to the characters provided, from the end of the provided string.  @param s String to be trimmed @return String with whitespace and characters in extraChars removed from the end. ",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "JsDocTokenStream.JsDocTokenStream",
    "class_name": "com.google.javascript.jscomp.parsing.JsDocTokenStream",
    "signature": "com.google.javascript.jscomp.parsing.JsDocTokenStream.JsDocTokenStream(String,int,int)",
    "snippet": "  JsDocTokenStream(String sourceString, int lineno, int initCharno) {\n    Preconditions.checkNotNull(sourceString);\n    this.lineno = lineno;\n    this.sourceString = sourceString;\n    this.sourceEnd = sourceString.length();\n    this.sourceCursor = this.cursor = 0;\n    this.initLineno = lineno;\n    this.initCharno = initCharno;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "JsDocTokenStream.addToString",
    "class_name": "com.google.javascript.jscomp.parsing.JsDocTokenStream",
    "signature": "com.google.javascript.jscomp.parsing.JsDocTokenStream.addToString(int)",
    "snippet": "  private void addToString(int c) {\n    int N = stringBufferTop;\n    if (N == stringBuffer.length) {\n        char[] tmp = new char[stringBuffer.length * 2];\n        System.arraycopy(stringBuffer, 0, tmp, 0, N);\n        stringBuffer = tmp;\n    }\n    stringBuffer[N] = (char)c;\n    stringBufferTop = N + 1;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "JsDocTokenStream.getChar",
    "class_name": "com.google.javascript.jscomp.parsing.JsDocTokenStream",
    "signature": "com.google.javascript.jscomp.parsing.JsDocTokenStream.getChar()",
    "snippet": "  protected int getChar() {\n    if (ungetCursor != 0) {\n      cursor++;\n      --ungetCursor;\n      if (charno == -1) {\n        charno = getOffset();\n      }\n      return ungetBuffer[ungetCursor];\n    }\n\n    for(;;) {\n      int c;\n      if (sourceCursor == sourceEnd) {\n        hitEOF = true;\n        if (charno == -1) {\n          charno = getOffset();\n        }\n        return EOF_CHAR;\n      }\n      cursor++;\n      c = sourceString.charAt(sourceCursor++);\n\n\n      if (lineEndChar >= 0) {\n        if (lineEndChar == '\\r' && c == '\\n') {\n          lineEndChar = '\\n';\n          continue;\n        }\n        lineEndChar = -1;\n        lineStart = sourceCursor - 1;\n        lineno++;\n      }\n\n      if (c <= 127) {\n        if (c == '\\n' || c == '\\r') {\n          lineEndChar = c;\n          c = '\\n';\n        }\n      } else {\n        if (isJSFormatChar(c)) {\n          continue;\n        }\n        if (ScriptRuntime.isJSLineTerminator(c)) {\n          lineEndChar = c;\n          c = '\\n';\n        }\n      }\n\n      if (charno == -1) {\n        charno = getOffset();\n      }\n\n      return c;\n    }\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "JsDocTokenStream.getCharIgnoreLineEnd",
    "class_name": "com.google.javascript.jscomp.parsing.JsDocTokenStream",
    "signature": "com.google.javascript.jscomp.parsing.JsDocTokenStream.getCharIgnoreLineEnd()",
    "snippet": "  private int getCharIgnoreLineEnd() {\n    if (ungetCursor != 0) {\n      cursor++;\n      --ungetCursor;\n      if (charno == -1) {\n        charno = getOffset();\n      }\n      return ungetBuffer[ungetCursor];\n    }\n\n    for(;;) {\n      int c;\n      if (sourceCursor == sourceEnd) {\n        hitEOF = true;\n        if (charno == -1) {\n          charno = getOffset();\n        }\n        return EOF_CHAR;\n      }\n      cursor++;\n      c = sourceString.charAt(sourceCursor++);\n\n\n      if (c <= 127) {\n        if (c == '\\n' || c == '\\r') {\n          lineEndChar = c;\n          c = '\\n';\n        }\n      } else {\n        if (isJSFormatChar(c)) {\n          continue;\n        }\n        if (ScriptRuntime.isJSLineTerminator(c)) {\n          lineEndChar = c;\n          c = '\\n';\n        }\n      }\n\n      if (charno == -1) {\n        charno = getOffset();\n      }\n\n      return c;\n    }\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "JsDocTokenStream.getJsDocToken",
    "class_name": "com.google.javascript.jscomp.parsing.JsDocTokenStream",
    "signature": "com.google.javascript.jscomp.parsing.JsDocTokenStream.getJsDocToken()",
    "snippet": "  @SuppressWarnings(\"fallthrough\")\n  final JsDocToken getJsDocToken() {\n    int c;\n    stringBufferTop = 0;\n    for (;;) {\n      // eat white spaces\n      for (;;) {\n        charno = -1;\n        c = getChar();\n        if (c == EOF_CHAR) {\n          return JsDocToken.EOF;\n        } else if (c == '\\n') {\n          return JsDocToken.EOL;\n        } else if (!isJSSpace(c)) {\n          break;\n        }\n      }\n\n      switch (c) {\n        // annotation, e.g. @type or @constructor\n        case '@':\n          do {\n            c = getChar();\n            if (isAlpha(c)) {\n              addToString(c);\n            } else {\n              ungetChar(c);\n              this.string = getStringFromBuffer();\n              stringBufferTop = 0;\n              return JsDocToken.ANNOTATION;\n            }\n          } while (true);\n\n        case '*':\n          if (matchChar('/')) {\n            return JsDocToken.EOC;\n          } else {\n            return JsDocToken.STAR;\n          }\n\n        case ',':\n          return JsDocToken.COMMA;\n\n        case '>':\n          return JsDocToken.GT;\n\n        case '(':\n          return JsDocToken.LP;\n\n        case ')':\n          return JsDocToken.RP;\n\n        case '{':\n          return JsDocToken.LC;\n\n        case '}':\n          return JsDocToken.RC;\n\n        case '[':\n          return JsDocToken.LB;\n\n        case ']':\n          return JsDocToken.RB;\n\n        case '?':\n          return JsDocToken.QMARK;\n\n        case '!':\n          return JsDocToken.BANG;\n\n        case ':':\n          return JsDocToken.COLON;\n\n        case '=':\n          return JsDocToken.EQUALS;\n\n        case '|':\n          matchChar('|');\n          return JsDocToken.PIPE;\n\n        case '.':\n          c = getChar();\n          if (c == '<') {\n            return JsDocToken.LT;\n          } else {\n            if (c == '.') {\n              c = getChar();\n              if (c == '.') {\n                return JsDocToken.ELLIPSIS;\n              } else {\n                addToString('.');\n              }\n            }\n            // we may backtrack across line boundary\n            ungetBuffer[ungetCursor++] = c;\n            c = '.';\n          }\n          // fall through\n\n        default: {\n          // recognize a jsdoc string but discard last . if it is followed by\n          // a non-jsdoc comment char, e.g. Array.<\n          int c1 = c;\n          addToString(c);\n          int c2 = getChar();\n          if (!isJSDocString(c2)) {\n            ungetChar(c2);\n            this.string = getStringFromBuffer();\n            stringBufferTop = 0;\n            return JsDocToken.STRING;\n          } else {\n            do {\n              c1 = c2;\n              c2 = getChar();\n              if (c1 == '.' && c2 == '<') {\n                ungetChar(c2);\n                ungetChar(c1);\n                this.string = getStringFromBuffer();\n                stringBufferTop = 0;\n                return JsDocToken.STRING;\n              } else {\n                if (isJSDocString(c2)) {\n                  addToString(c1);\n                } else {\n                  ungetChar(c2);\n                  addToString(c1);\n                  this.string = getStringFromBuffer();\n                  stringBufferTop = 0;\n                  return JsDocToken.STRING;\n                }\n              }\n            } while (true);\n          }\n        }\n      }\n    }\n  }",
    "comment": " Tokenizes JSDoc comments. ",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "JsDocTokenStream.getOffset",
    "class_name": "com.google.javascript.jscomp.parsing.JsDocTokenStream",
    "signature": "com.google.javascript.jscomp.parsing.JsDocTokenStream.getOffset()",
    "snippet": "  final int getOffset() {\n    return sourceCursor - lineStart - ungetCursor - 1;\n  }",
    "comment": " Returns the offset into the current line. ",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "JsDocTokenStream.getRemainingJSDocLine",
    "class_name": "com.google.javascript.jscomp.parsing.JsDocTokenStream",
    "signature": "com.google.javascript.jscomp.parsing.JsDocTokenStream.getRemainingJSDocLine()",
    "snippet": "  @SuppressWarnings(\"fallthrough\")\n  String getRemainingJSDocLine() {\n    int c;\n    for (;;) {\n      c = getChar();\n      switch (c) {\n        case '*':\n          if (peekChar() != '/') {\n            addToString(c);\n            break;\n          }\n          // fall through\n        case EOF_CHAR:\n        case '\\n':\n          ungetChar(c);\n          this.string = getStringFromBuffer();\n          stringBufferTop = 0;\n          return this.string;\n\n        default:\n          addToString(c);\n          break;\n      }\n    }\n  }",
    "comment": " Gets the remaining JSDoc line without the {@link JsDocToken#EOL}, {@link JsDocToken#EOF} or {@link JsDocToken#EOC}. ",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "JsDocTokenStream.getString",
    "class_name": "com.google.javascript.jscomp.parsing.JsDocTokenStream",
    "signature": "com.google.javascript.jscomp.parsing.JsDocTokenStream.getString()",
    "snippet": "  final String getString() { return string; }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "JsDocTokenStream.getStringFromBuffer",
    "class_name": "com.google.javascript.jscomp.parsing.JsDocTokenStream",
    "signature": "com.google.javascript.jscomp.parsing.JsDocTokenStream.getStringFromBuffer()",
    "snippet": "  private String getStringFromBuffer() {\n    tokenEnd = cursor;\n    return new String(stringBuffer, 0, stringBufferTop);\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "JsDocTokenStream.isJSDocString",
    "class_name": "com.google.javascript.jscomp.parsing.JsDocTokenStream",
    "signature": "com.google.javascript.jscomp.parsing.JsDocTokenStream.isJSDocString(int)",
    "snippet": "  private boolean isJSDocString(int c) {\n    switch (c) {\n      case '@':\n      case '*':\n      case ',':\n      case '>':\n      case ':':\n      case '(':\n      case ')':\n      case '{':\n      case '}':\n      case '[':\n      case ']':\n      case '?':\n      case '!':\n      case '|':\n      case '=':\n      case EOF_CHAR:\n      case '\\n':\n        return false;\n\n      default:\n        return !isJSSpace(c);\n    }\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "JsDocTokenStream.isJSSpace",
    "class_name": "com.google.javascript.jscomp.parsing.JsDocTokenStream",
    "signature": "com.google.javascript.jscomp.parsing.JsDocTokenStream.isJSSpace(int)",
    "snippet": "  static boolean isJSSpace(int c) {\n    if (c <= 127) {\n      return c == 0x20 || c == 0x9 || c == 0xC || c == 0xB;\n    } else {\n      return c == 0xA0\n          || Character.getType((char)c) == Character.SPACE_SEPARATOR;\n    }\n  }",
    "comment": "As defined in ECMA.  jsscan.c uses C isspace() (which allows \\v, I think.)  note that code in getChar() implicitly accepts '\\r' == \\u000D as well. ",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "JsDocTokenStream.matchChar",
    "class_name": "com.google.javascript.jscomp.parsing.JsDocTokenStream",
    "signature": "com.google.javascript.jscomp.parsing.JsDocTokenStream.matchChar(int)",
    "snippet": "  private boolean matchChar(int test) {\n    int c = getCharIgnoreLineEnd();\n    if (c == test) {\n      tokenEnd = cursor;\n      return true;\n    } else {\n      ungetCharIgnoreLineEnd(c);\n      return false;\n    }\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "JsDocTokenStream.peekChar",
    "class_name": "com.google.javascript.jscomp.parsing.JsDocTokenStream",
    "signature": "com.google.javascript.jscomp.parsing.JsDocTokenStream.peekChar()",
    "snippet": "  private int peekChar() {\n    int c = getChar();\n    ungetChar(c);\n    return c;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "JsDocTokenStream.ungetChar",
    "class_name": "com.google.javascript.jscomp.parsing.JsDocTokenStream",
    "signature": "com.google.javascript.jscomp.parsing.JsDocTokenStream.ungetChar(int)",
    "snippet": "  private void ungetChar(int c) {\n    // can not unread past across line boundary\n    assert(!(ungetCursor != 0 && ungetBuffer[ungetCursor - 1] == '\\n'));\n    ungetBuffer[ungetCursor++] = c;\n    cursor--;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "ParserRunner.initAnnotationNames",
    "class_name": "com.google.javascript.jscomp.parsing.ParserRunner",
    "signature": "com.google.javascript.jscomp.parsing.ParserRunner.initAnnotationNames()",
    "snippet": "  private static synchronized void initAnnotationNames() {\n    if (annotationNames != null) {\n      return;\n    }\n\n    Set<String> trimmedNames = Sets.newHashSet();\n    ResourceBundle config = ResourceBundle.getBundle(configResource);\n    String[] names = config.getString(\"jsdoc.annotations\").split(\",\");\n    for (String name : names) {\n      trimmedNames.add(name.trim());\n    }\n    annotationNames = ImmutableSet.copyOf(trimmedNames);\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "ParserRunner.parse",
    "class_name": "com.google.javascript.jscomp.parsing.ParserRunner",
    "signature": "com.google.javascript.jscomp.parsing.ParserRunner.parse(String,String,boolean,JSTypeRegistry,ErrorReporter,Logger)",
    "snippet": "  public static Node parse(String sourceName,\n                           String sourceString,\n                           boolean isIdeMode,\n                           JSTypeRegistry typeRegistry,\n                           ErrorReporter errorReporter,\n                           Logger logger) throws IOException {\n    initAnnotationNames();\n\n    Context cx = Context.enter();\n    cx.setErrorReporter(errorReporter);\n    cx.setLanguageVersion(Context.VERSION_1_5);\n    CompilerEnvirons compilerEnv = new CompilerEnvirons();\n    compilerEnv.initFromContext(cx);\n    compilerEnv.setRecordingComments(true);\n    compilerEnv.setRecordingLocalJsDocComments(true);\n    compilerEnv.setWarnTrailingComma(true);\n    if (isIdeMode) {\n      compilerEnv.setReservedKeywordAsIdentifier(true);\n      compilerEnv.setAllowMemberExprAsFunctionName(true);\n    }\n\n    Parser p = new Parser(compilerEnv, errorReporter);\n    AstRoot astRoot = null;\n    try {\n      astRoot = p.parse(sourceString, sourceName, 1);\n    } catch (EvaluatorException e) {\n      logger.info(\"Error parsing \" + sourceName + \": \" + e.getMessage());\n    } finally {\n      Context.exit();\n    }\n    Node root = null;\n    if (astRoot != null) {\n      Config config = new Config(\n          typeRegistry, annotationNames, isIdeMode);\n      root = IRFactory.transformTree(\n          astRoot, sourceString, config, errorReporter);\n      root.setIsSyntheticBlock(true);\n    }\n    return root;\n  }",
    "comment": " Parses the JavaScript text given by a reader.  @param sourceName The filename. @param sourceString Source code from the file. @param isIdeMode Whether in IDE mode, which affects the environment. @param typeRegistry The type registry. @param errorReporter An error. @param logger A logger. @return The AST of the given text. @throws IOException ",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "TypeSafeDispatcher.process",
    "class_name": "com.google.javascript.jscomp.parsing.TypeSafeDispatcher",
    "signature": "com.google.javascript.jscomp.parsing.TypeSafeDispatcher.process(AstNode)",
    "snippet": "  public T process(AstNode node) {\n    switch (node.getType()) {\n      case Token.ADD:\n      case Token.AND:\n      case Token.BITAND:\n      case Token.BITOR:\n      case Token.BITXOR:\n      case Token.COMMA:\n      case Token.DIV:\n      case Token.EQ:\n      case Token.GE:\n      case Token.GT:\n      case Token.IN:\n      case Token.INSTANCEOF:\n      case Token.LE:\n      case Token.LSH:\n      case Token.LT:\n      case Token.MOD:\n      case Token.MUL:\n      case Token.NE:\n      case Token.OR:\n      case Token.RSH:\n      case Token.SHEQ:\n      case Token.SHNE:\n      case Token.SUB:\n      case Token.URSH:\n        return processInfixExpression((InfixExpression) node);\n      case Token.ARRAYLIT:\n        return processArrayLiteral((ArrayLiteral) node);\n      case Token.ASSIGN:\n      case Token.ASSIGN_ADD:\n      case Token.ASSIGN_BITAND:\n      case Token.ASSIGN_BITOR:\n      case Token.ASSIGN_BITXOR:\n      case Token.ASSIGN_DIV:\n      case Token.ASSIGN_LSH:\n      case Token.ASSIGN_MOD:\n      case Token.ASSIGN_MUL:\n      case Token.ASSIGN_RSH:\n      case Token.ASSIGN_SUB:\n      case Token.ASSIGN_URSH:\n        return processAssignment((Assignment) node);\n      case Token.BITNOT:\n      case Token.DEC:\n      case Token.DELPROP:\n      case Token.INC:\n      case Token.NEG:\n      case Token.NOT:\n      case Token.POS:\n      case Token.TYPEOF:\n      case Token.VOID:\n        return processUnaryExpression((UnaryExpression) node);\n      case Token.BLOCK:\n        if (node instanceof Block) {\n          return processBlock((Block) node);\n        } else  if (node instanceof Scope) {\n          return processScope((Scope) node);\n        } else {\n          throw new IllegalStateException(\"Unexpected node type.  class: \" +\n                                          node.getClass() +\n                                          \" type: \" +\n                                          Token.typeToName(node.getType()));\n        }\n      case Token.BREAK:\n        return processBreakStatement((BreakStatement) node);\n      case Token.CALL:\n        return processFunctionCall((FunctionCall) node);\n      case Token.CASE:\n      case Token.DEFAULT:\n        return processSwitchCase((SwitchCase) node);\n      case Token.CATCH:\n      case Token.FINALLY:\n        return processCatchClause((CatchClause) node);\n      case Token.COLON:\n        return processObjectProperty((ObjectProperty) node);\n      case Token.CONTINUE:\n        return processContinueStatement((ContinueStatement) node);\n      case Token.DO:\n        return processDoLoop((DoLoop) node);\n      case Token.EMPTY:\n        return processEmptyExpression((EmptyExpression) node);\n      case Token.EXPR_RESULT:\n      case Token.EXPR_VOID:\n        if (node instanceof ExpressionStatement) {\n          return processExpressionStatement((ExpressionStatement) node);\n        } else  if (node instanceof LabeledStatement) {\n          return processLabeledStatement((LabeledStatement) node);\n        } else {\n          throw new IllegalStateException(\"Unexpected node type.  class: \" +\n                                          node.getClass() +\n                                          \" type: \" +\n                                          Token.typeToName(node.getType()));\n        }\n      case Token.DEBUGGER:\n      case Token.FALSE:\n      case Token.NULL:\n      case Token.THIS:\n      case Token.TRUE:\n        return processKeywordLiteral((KeywordLiteral) node);\n      case Token.FOR:\n        if (node instanceof ForInLoop) {\n          return processForInLoop((ForInLoop) node);\n        } else  if (node instanceof ForLoop) {\n          return processForLoop((ForLoop) node);\n        } else {\n          throw new IllegalStateException(\"Unexpected node type.  class: \" +\n                                          node.getClass() +\n                                          \" type: \" +\n                                          Token.typeToName(node.getType()));\n        }\n      case Token.FUNCTION:\n        return processFunctionNode((FunctionNode) node);\n      case Token.GETELEM:\n        return processElementGet((ElementGet) node);\n      case Token.GETPROP:\n        return processPropertyGet((PropertyGet) node);\n      case Token.HOOK:\n        return processConditionalExpression((ConditionalExpression) node);\n      case Token.IF:\n        return processIfStatement((IfStatement) node);\n      case Token.LABEL:\n        return processLabel((Label) node);\n      case Token.LP:\n        return processParenthesizedExpression((ParenthesizedExpression) node);\n      case Token.NAME:\n        return processName((Name) node);\n      case Token.NEW:\n        return processNewExpression((NewExpression) node);\n      case Token.NUMBER:\n        return processNumberLiteral((NumberLiteral) node);\n      case Token.OBJECTLIT:\n        return processObjectLiteral((ObjectLiteral) node);\n      case Token.REGEXP:\n        return processRegExpLiteral((RegExpLiteral) node);\n      case Token.RETURN:\n        return processReturnStatement((ReturnStatement) node);\n      case Token.SCRIPT:\n        return processAstRoot((AstRoot) node);\n      case Token.STRING:\n        return processStringLiteral((StringLiteral) node);\n      case Token.SWITCH:\n        return processSwitchStatement((SwitchStatement) node);\n      case Token.THROW:\n        return processThrowStatement((ThrowStatement) node);\n      case Token.TRY:\n        return processTryStatement((TryStatement) node);\n      case Token.VAR:\n        if (node instanceof VariableDeclaration) {\n          return processVariableDeclaration((VariableDeclaration) node);\n        } else  if (node instanceof VariableInitializer) {\n          return processVariableInitializer((VariableInitializer) node);\n        } else {\n          throw new IllegalStateException(\"Unexpected node type.  class: \" +\n                                          node.getClass() +\n                                          \" type: \" +\n                                          Token.typeToName(node.getType()));\n        }\n      case Token.WHILE:\n        return processWhileLoop((WhileLoop) node);\n      case Token.WITH:\n        return processWithStatement((WithStatement) node);\n    }\n    return processIllegalToken(node);\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "Context.getCurrentContext",
    "class_name": "com.google.javascript.rhino.Context",
    "signature": "com.google.javascript.rhino.Context.getCurrentContext()",
    "snippet": "    public static Context getCurrentContext() {\n        return threadContexts.get();\n    }",
    "comment": " Get the current Context.  The current Context is per-thread; this method looks up the Context associated with the current thread. <p>  @return the Context associated with the current thread, or null if no context is associated with the current thread. ",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "FunctionNode.FunctionNode",
    "class_name": "com.google.javascript.rhino.FunctionNode",
    "signature": "com.google.javascript.rhino.FunctionNode.FunctionNode(String)",
    "snippet": "    public FunctionNode(String name) {\n        super(Token.FUNCTION);\n        functionName = name;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "JSDocInfo.JSDocInfo",
    "class_name": "com.google.javascript.rhino.JSDocInfo",
    "signature": "com.google.javascript.rhino.JSDocInfo.JSDocInfo(boolean)",
    "snippet": "  JSDocInfo(boolean includeDocumentation) {\n    this.includeDocumentation = includeDocumentation;\n  }",
    "comment": " Creates a {@link JSDocInfo} object. This object should be created using a {@link JSDocInfoBuilder}. ",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "JSDocInfo.documentBlock",
    "class_name": "com.google.javascript.rhino.JSDocInfo",
    "signature": "com.google.javascript.rhino.JSDocInfo.documentBlock(String)",
    "snippet": "  boolean documentBlock(String description) {\n    if (!lazyInitDocumentation()) {\n      return true;\n    }\n\n    if (documentation.blockDescription != null) {\n      return false;\n    }\n\n    documentation.blockDescription = description;\n    return true;\n  }",
    "comment": " Documents the block-level comment/description.  @param description the description ",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "JSDocInfo.lazyInitDocumentation",
    "class_name": "com.google.javascript.rhino.JSDocInfo",
    "signature": "com.google.javascript.rhino.JSDocInfo.lazyInitDocumentation()",
    "snippet": "  private boolean lazyInitDocumentation() {\n    if (!includeDocumentation) {\n      return false;\n    }\n\n    if (documentation == null) {\n      documentation = new LazilyInitializedDocumentation();\n    }\n\n    return true;\n  }",
    "comment": " Lazily initializes the documentation information object, but only if the JSDocInfo was told to keep such information around. ",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "JSDocInfoBuilder.JSDocInfoBuilder",
    "class_name": "com.google.javascript.rhino.JSDocInfoBuilder",
    "signature": "com.google.javascript.rhino.JSDocInfoBuilder.JSDocInfoBuilder(boolean)",
    "snippet": "  public JSDocInfoBuilder(boolean parseDocumentation) {\n    this.currentInfo = new JSDocInfo(parseDocumentation);\n    this.parseDocumentation = parseDocumentation;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "JSDocInfoBuilder.build",
    "class_name": "com.google.javascript.rhino.JSDocInfoBuilder",
    "signature": "com.google.javascript.rhino.JSDocInfoBuilder.build(String)",
    "snippet": "  public JSDocInfo build(String sourceName) {\n    if (populated) {\n      JSDocInfo built = currentInfo;\n      built.setSourceName(sourceName);\n      populateDefaults(built);\n      populated = false;\n      currentInfo = new JSDocInfo(this.parseDocumentation);\n      return built;\n    } else {\n      return null;\n    }\n  }",
    "comment": " Builds a {@link JSDocInfo} object based on the populated information and returns it. Once this method is called, the builder can be reused to build another {@link JSDocInfo} object.  @param sourceName The source file containing the JSDoc. @return a {@link JSDocInfo} object populated with the values given to this builder. If no value was populated, this method simply returns {@code null} ",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "JSDocInfoBuilder.isPopulated",
    "class_name": "com.google.javascript.rhino.JSDocInfoBuilder",
    "signature": "com.google.javascript.rhino.JSDocInfoBuilder.isPopulated()",
    "snippet": "  public boolean isPopulated() {\n    return populated;\n  }",
    "comment": " Returns whether this builder is populated with information that can be used to {@link #build} a {@link JSDocInfo} object. ",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "JSDocInfoBuilder.isPopulatedWithFileOverview",
    "class_name": "com.google.javascript.rhino.JSDocInfoBuilder",
    "signature": "com.google.javascript.rhino.JSDocInfoBuilder.isPopulatedWithFileOverview()",
    "snippet": "  public boolean isPopulatedWithFileOverview() {\n    return isPopulated() && currentInfo.hasFileOverview();\n  }",
    "comment": " Returns whether this builder is populated with information that can be used to {@link #build} a {@link JSDocInfo} object that has a fileoverview tag. ",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "JSDocInfoBuilder.recordBlockDescription",
    "class_name": "com.google.javascript.rhino.JSDocInfoBuilder",
    "signature": "com.google.javascript.rhino.JSDocInfoBuilder.recordBlockDescription(String)",
    "snippet": "  public boolean recordBlockDescription(String description) {\n    if (parseDocumentation) {\n    populated = true;\n    }\n    return currentInfo.documentBlock(description);\n  }",
    "comment": " Records a block-level description.  @return {@code true} if the description was recorded. ",
    "is_bug": true,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "Node.Node",
    "class_name": "com.google.javascript.rhino.Node",
    "signature": "com.google.javascript.rhino.Node.Node(int)",
    "snippet": "    public Node(int nodeType) {\n        type = nodeType;\n        parent = null;\n        sourcePosition = -1;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "Node.Node",
    "class_name": "com.google.javascript.rhino.Node",
    "signature": "com.google.javascript.rhino.Node.Node(int,Node,Node)",
    "snippet": "    public Node(int nodeType, Node left, Node right) {\n        Preconditions.checkArgument(left.parent == null,\n            \"first new child has existing parent\");\n        Preconditions.checkArgument(left.next == null,\n            \"first new child has existing sibling\");\n        Preconditions.checkArgument(right.parent == null,\n            \"second new child has existing parent\");\n        Preconditions.checkArgument(right.next == null,\n            \"second new child has existing sibling\");\n        type = nodeType;\n        parent = null;\n        first = left;\n        last = right;\n        left.next = right;\n        left.parent = this;\n        right.next = null;\n        right.parent = this;\n        sourcePosition = -1;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "Node.addChildToBack",
    "class_name": "com.google.javascript.rhino.Node",
    "signature": "com.google.javascript.rhino.Node.addChildToBack(Node)",
    "snippet": "    public void addChildToBack(Node child) {\n        Preconditions.checkArgument(child.parent == null);\n        Preconditions.checkArgument(child.next == null);\n        child.parent = this;\n        child.next = null;\n        if (last == null) {\n            first = last = child;\n            return;\n        }\n        last.next = child;\n        last = child;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "Node.children",
    "class_name": "com.google.javascript.rhino.Node",
    "signature": "com.google.javascript.rhino.Node.children()",
    "snippet": "    public Iterable<Node> children() {\n      if (first == null) {\n        return Collections.emptySet();\n      } else {\n        return new SiblingNodeIterable(first);\n      }\n    }",
    "comment": " <p>Return an iterable object that iterates over this nodes's children. The iterator does not support the optional operation {@link Iterator#remove()}.</p>  <p>To iterate over a node's siblings, one can write</p> <pre>Node n = ...; for (Node child : n.children()) { ...</pre> ",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "Node.cloneNode",
    "class_name": "com.google.javascript.rhino.Node",
    "signature": "com.google.javascript.rhino.Node.cloneNode()",
    "snippet": "    public Node cloneNode() {\n        Node result;\n        try {\n            result = (Node) super.clone();\n            result.next = null;\n            result.first = null;\n            result.last = null;\n            result.parent = null;\n        }\n        catch (CloneNotSupportedException e) {\n            throw new RuntimeException(e.getMessage());\n        }\n        return result;\n    }",
    "comment": " @return A detached clone of the Node, specifically excluding its children. ",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "Node.cloneTree",
    "class_name": "com.google.javascript.rhino.Node",
    "signature": "com.google.javascript.rhino.Node.cloneTree()",
    "snippet": "    public Node cloneTree() {\n        Node result = cloneNode();\n        for (Node n2 = getFirstChild(); n2 != null; n2 = n2.getNext()) {\n            Node n2clone = n2.cloneTree();\n            n2clone.parent = result;\n            if (result.last != null) {\n                result.last.next = n2clone;\n            }\n            if (result.first == null) {\n                result.first = n2clone;\n            }\n            result.last = n2clone;\n        }\n        return result;\n    }",
    "comment": " @return A detached clone of the Node and all its children. ",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "Node.ensureProperty",
    "class_name": "com.google.javascript.rhino.Node",
    "signature": "com.google.javascript.rhino.Node.ensureProperty(int)",
    "snippet": "    private PropListItem ensureProperty(int propType)\n    {\n        PropListItem item = lookupProperty(propType);\n        if (item == null) {\n            item = new PropListItem();\n            item.type = propType;\n            item.next = propListHead;\n            propListHead = item;\n        }\n        return item;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "Node.extractCharno",
    "class_name": "com.google.javascript.rhino.Node",
    "signature": "com.google.javascript.rhino.Node.extractCharno(int)",
    "snippet": "    protected static int extractCharno(int lineCharNo) {\n      if (lineCharNo == -1) {\n        return -1;\n      } else {\n        return lineCharNo & COLUMN_MASK;\n      }\n    }",
    "comment": " Extracts the character number and character number from a merged line char number (see {@link #mergeLineCharNo(int, int)}). ",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "Node.extractLineno",
    "class_name": "com.google.javascript.rhino.Node",
    "signature": "com.google.javascript.rhino.Node.extractLineno(int)",
    "snippet": "    protected static int extractLineno(int lineCharNo) {\n      if (lineCharNo == -1) {\n        return -1;\n      } else {\n        return lineCharNo >>> COLUMN_BITS;\n      }\n    }",
    "comment": " Extracts the line number and character number from a merged line char number (see {@link #mergeLineCharNo(int, int)}). ",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "Node.getCharno",
    "class_name": "com.google.javascript.rhino.Node",
    "signature": "com.google.javascript.rhino.Node.getCharno()",
    "snippet": "    public int getCharno() {\n        return extractCharno(sourcePosition);\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "Node.getChildCount",
    "class_name": "com.google.javascript.rhino.Node",
    "signature": "com.google.javascript.rhino.Node.getChildCount()",
    "snippet": "    public int getChildCount() {\n        int c = 0;\n        for (Node n = first; n != null; n = n.next)\n            c++;\n\n        return c;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "Node.getFirstChild",
    "class_name": "com.google.javascript.rhino.Node",
    "signature": "com.google.javascript.rhino.Node.getFirstChild()",
    "snippet": "    public Node getFirstChild() {\n        return first;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "Node.getJSDocInfo",
    "class_name": "com.google.javascript.rhino.Node",
    "signature": "com.google.javascript.rhino.Node.getJSDocInfo()",
    "snippet": "    public JSDocInfo getJSDocInfo()\n    {\n        return (JSDocInfo) getProp(JSDOC_INFO_PROP);\n    }",
    "comment": " Get the {@link JSDocInfo} attached to this node. @return the information or {@code null} if no JSDoc is attached to this node ",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "Node.getJSType",
    "class_name": "com.google.javascript.rhino.Node",
    "signature": "com.google.javascript.rhino.Node.getJSType()",
    "snippet": "    public JSType getJSType() {\n        return jsType;\n    }",
    "comment": "Custom annotations",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "Node.getJsDocBuilderForNode",
    "class_name": "com.google.javascript.rhino.Node",
    "signature": "com.google.javascript.rhino.Node.getJsDocBuilderForNode()",
    "snippet": "    public FileLevelJsDocBuilder getJsDocBuilderForNode() {\n      return new FileLevelJsDocBuilder();\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "Node.getLastChild",
    "class_name": "com.google.javascript.rhino.Node",
    "signature": "com.google.javascript.rhino.Node.getLastChild()",
    "snippet": "    public Node getLastChild() {\n        return last;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "Node.getLineno",
    "class_name": "com.google.javascript.rhino.Node",
    "signature": "com.google.javascript.rhino.Node.getLineno()",
    "snippet": "    public int getLineno() {\n        return extractLineno(sourcePosition);\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "Node.getNext",
    "class_name": "com.google.javascript.rhino.Node",
    "signature": "com.google.javascript.rhino.Node.getNext()",
    "snippet": "    public Node getNext() {\n        return next;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "Node.getParent",
    "class_name": "com.google.javascript.rhino.Node",
    "signature": "com.google.javascript.rhino.Node.getParent()",
    "snippet": "    public Node getParent() {\n        return parent;\n    }",
    "comment": "Accessors",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "Node.getProp",
    "class_name": "com.google.javascript.rhino.Node",
    "signature": "com.google.javascript.rhino.Node.getProp(int)",
    "snippet": "    public Object getProp(int propType)\n    {\n        PropListItem item = lookupProperty(propType);\n        if (item == null) { return null; }\n        return item.objectValue;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "Node.getType",
    "class_name": "com.google.javascript.rhino.Node",
    "signature": "com.google.javascript.rhino.Node.getType()",
    "snippet": "    public int getType() {\n        return type;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "Node.isQualifiedName",
    "class_name": "com.google.javascript.rhino.Node",
    "signature": "com.google.javascript.rhino.Node.isQualifiedName()",
    "snippet": "    public boolean isQualifiedName() {\n        switch (getType()) {\n            case Token.NAME:\n            case Token.THIS:\n                return true;\n            case Token.GETPROP:\n                return getFirstChild().isQualifiedName();\n            default:\n                return false;\n        }\n    }",
    "comment": " Returns whether a node corresponds to a simple or a qualified name, such as <code>x</code> or <code>a.b.c</code> or <code>this.a</code>. ",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "Node.lookupProperty",
    "class_name": "com.google.javascript.rhino.Node",
    "signature": "com.google.javascript.rhino.Node.lookupProperty(int)",
    "snippet": "    private PropListItem lookupProperty(int propType)\n    {\n        PropListItem x = propListHead;\n        while (x != null && propType != x.type) {\n            x = x.next;\n        }\n        return x;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "Node.mergeLineCharNo",
    "class_name": "com.google.javascript.rhino.Node",
    "signature": "com.google.javascript.rhino.Node.mergeLineCharNo(int,int)",
    "snippet": "    protected static int mergeLineCharNo(int lineno, int charno) {\n      if (lineno < 0 || charno < 0) {\n        return -1;\n      } else if ((charno & ~COLUMN_MASK) != 0) {\n        return lineno << COLUMN_BITS | COLUMN_MASK;\n      } else {\n        return lineno << COLUMN_BITS | (charno & COLUMN_MASK);\n      }\n    }",
    "comment": " Merges the line number and character number in one integer. The Character number takes the first 12 bits and the line number takes the rest. If the character number is greater than <code>2<sup>12</sup>-1</code> it is adjusted to <code>2<sup>12</sup>-1</code>. ",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "Node.newString",
    "class_name": "com.google.javascript.rhino.Node",
    "signature": "com.google.javascript.rhino.Node.newString(int,String)",
    "snippet": "    public static Node newString(int type, String str) {\n        return new StringNode(type, str);\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "Node.putBooleanProp",
    "class_name": "com.google.javascript.rhino.Node",
    "signature": "com.google.javascript.rhino.Node.putBooleanProp(int,boolean)",
    "snippet": "    public void putBooleanProp(int propType, boolean prop) {\n        putIntProp(propType, prop ? 1 : 0);\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "Node.putIntProp",
    "class_name": "com.google.javascript.rhino.Node",
    "signature": "com.google.javascript.rhino.Node.putIntProp(int,int)",
    "snippet": "    public void putIntProp(int propType, int prop)\n    {\n        PropListItem item = ensureProperty(propType);\n        item.intValue = prop;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "Node.putProp",
    "class_name": "com.google.javascript.rhino.Node",
    "signature": "com.google.javascript.rhino.Node.putProp(int,Object)",
    "snippet": "    public void putProp(int propType, Object prop)\n    {\n        if (prop == null) {\n            removeProp(propType);\n        } else {\n            PropListItem item = ensureProperty(propType);\n            item.objectValue = prop;\n        }\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "Node.removeProp",
    "class_name": "com.google.javascript.rhino.Node",
    "signature": "com.google.javascript.rhino.Node.removeProp(int)",
    "snippet": "    public void removeProp(int propType)\n    {\n        PropListItem x = propListHead;\n        if (x != null) {\n            PropListItem prev = null;\n            while (x.type != propType) {\n                prev = x;\n                x = x.next;\n                if (x == null) { return; }\n            }\n            if (prev == null) {\n                propListHead = x.next;\n            } else {\n                prev.next = x.next;\n            }\n        }\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "Node.setCharno",
    "class_name": "com.google.javascript.rhino.Node",
    "signature": "com.google.javascript.rhino.Node.setCharno(int)",
    "snippet": "    public void setCharno(int charno) {\n        sourcePosition = mergeLineCharNo(getLineno(), charno);\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "Node.setIsSyntheticBlock",
    "class_name": "com.google.javascript.rhino.Node",
    "signature": "com.google.javascript.rhino.Node.setIsSyntheticBlock(boolean)",
    "snippet": "    public void setIsSyntheticBlock(boolean val) {\n        putBooleanProp(SYNTHETIC_BLOCK_PROP, val);\n    }",
    "comment": " Sets whether this is a synthetic block that should not be considered a real source block. ",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "Node.setJSDocInfo",
    "class_name": "com.google.javascript.rhino.Node",
    "signature": "com.google.javascript.rhino.Node.setJSDocInfo(JSDocInfo)",
    "snippet": "    public void setJSDocInfo(JSDocInfo info)\n    {\n        putProp(JSDOC_INFO_PROP, info);\n    }",
    "comment": " Sets the {@link JSDocInfo} attached to this node. ",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "Node.setJSType",
    "class_name": "com.google.javascript.rhino.Node",
    "signature": "com.google.javascript.rhino.Node.setJSType(JSType)",
    "snippet": "    public void setJSType(JSType jsType) {\n        this.jsType = jsType;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "Node.setLineno",
    "class_name": "com.google.javascript.rhino.Node",
    "signature": "com.google.javascript.rhino.Node.setLineno(int)",
    "snippet": "    public void setLineno(int lineno) {\n        int charno = getCharno();\n        if (charno == -1) {\n          charno = 0;\n        }\n        sourcePosition = mergeLineCharNo(lineno, charno);\n    }",
    "comment": "Source position management",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "Node.setOptionalArg",
    "class_name": "com.google.javascript.rhino.Node",
    "signature": "com.google.javascript.rhino.Node.setOptionalArg(boolean)",
    "snippet": "    public void setOptionalArg(boolean optionalArg)\n    {\n        putBooleanProp(OPT_ARG_NAME, optionalArg);\n    }",
    "comment": " Sets whether this node is an optional argument node. This method is meaningful only on {@link Token#NAME} nodes used to define a {@link Token#FUNCTION}'s argument list. ",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "Node.setType",
    "class_name": "com.google.javascript.rhino.Node",
    "signature": "com.google.javascript.rhino.Node.setType(int)",
    "snippet": "    public void setType(int type) {\n        this.type = type;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "Node.setVarArgs",
    "class_name": "com.google.javascript.rhino.Node",
    "signature": "com.google.javascript.rhino.Node.setVarArgs(boolean)",
    "snippet": "    public void setVarArgs(boolean varArgs)\n    {\n        putBooleanProp(VAR_ARGS_NAME, varArgs);\n    }",
    "comment": " Sets whether this node is a variable length argument node. This method is meaningful only on {@link Token#NAME} nodes used to define a {@link Token#FUNCTION}'s argument list. ",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "SiblingNodeIterable.hasNext",
    "class_name": "com.google.javascript.rhino.Node$SiblingNodeIterable",
    "signature": "com.google.javascript.rhino.Node$SiblingNodeIterable.hasNext()",
    "snippet": "        public boolean hasNext() {\n            return current != null;\n        }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "SiblingNodeIterable.iterator",
    "class_name": "com.google.javascript.rhino.Node$SiblingNodeIterable",
    "signature": "com.google.javascript.rhino.Node$SiblingNodeIterable.iterator()",
    "snippet": "        public Iterator<Node> iterator() {\n          if (!used) {\n            used = true;\n            return this;\n          } else {\n            // We have already used the current object as an iterator;\n            // we must create a new SiblingNodeIterable based on this\n            // iterable's start node.\n            //\n            // Since the primary use case for Node.children is in for\n            // loops, this branch is extremely unlikely.\n            return (new SiblingNodeIterable(start)).iterator();\n          }\n        }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "SiblingNodeIterable.next",
    "class_name": "com.google.javascript.rhino.Node$SiblingNodeIterable",
    "signature": "com.google.javascript.rhino.Node$SiblingNodeIterable.next()",
    "snippet": "        public Node next() {\n            if (current == null) {\n              throw new NoSuchElementException();\n            }\n            try {\n                return current;\n            } finally {\n                current = current.getNext();\n            }\n        }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "StringNode.getString",
    "class_name": "com.google.javascript.rhino.Node$StringNode",
    "signature": "com.google.javascript.rhino.Node$StringNode.getString()",
    "snippet": "        @Override public String getString() {\n            return this.str;\n        }",
    "comment": "returns the string content. @return non null. ",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "ObjArray.ObjArray",
    "class_name": "com.google.javascript.rhino.ObjArray",
    "signature": "com.google.javascript.rhino.ObjArray.ObjArray()",
    "snippet": "    public ObjArray() { }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "ObjToIntMap.ObjToIntMap",
    "class_name": "com.google.javascript.rhino.ObjToIntMap",
    "signature": "com.google.javascript.rhino.ObjToIntMap.ObjToIntMap(int)",
    "snippet": "    public ObjToIntMap(int keyCountHint) {\n        if (keyCountHint < 0) Kit.codeBug();\n        // Table grow when number of stored keys >= 3/4 of max capacity\n        int minimalCapacity = keyCountHint * 4 / 3;\n        int i;\n        for (i = 2; (1 << i) < minimalCapacity; ++i) { }\n        power = i;\n        if (check && power < 2) Kit.codeBug();\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "ScriptOrFnNode.ScriptOrFnNode",
    "class_name": "com.google.javascript.rhino.ScriptOrFnNode",
    "signature": "com.google.javascript.rhino.ScriptOrFnNode.ScriptOrFnNode(int)",
    "snippet": "    public ScriptOrFnNode(int nodeType) {\n        super(nodeType);\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "ScriptRuntime.getMessage",
    "class_name": "com.google.javascript.rhino.ScriptRuntime",
    "signature": "com.google.javascript.rhino.ScriptRuntime.getMessage(String,Object[])",
    "snippet": "    public static String getMessage(String messageId, Object[] arguments)\n    {\n        final String defaultResource\n            = \"rhino_ast.java.com.google.javascript.rhino.Messages\";\n\n        Context cx = Context.getCurrentContext();\n        Locale locale = cx != null ? cx.getLocale() : Locale.getDefault();\n\n        // ResourceBundle does cacheing.\n        ResourceBundle rb = ResourceBundle.getBundle(defaultResource, locale);\n\n        String formatString;\n        try {\n            formatString = rb.getString(messageId);\n        } catch (java.util.MissingResourceException mre) {\n            throw new RuntimeException\n                (\"no message resource found for message property \"+ messageId);\n        }\n\n        /*\n         * It's OK to format the string, even if 'arguments' is null;\n         * we need to format it anyway, to make double ''s collapse to\n         * single 's.\n         */\n        // TODO: MessageFormat is not available on pJava\n        MessageFormat formatter = new MessageFormat(formatString);\n        return formatter.format(arguments);\n    }",
    "comment": "OPT there's a noticable delay for the first error!  Maybe it'd make sense to use a ListResourceBundle instead of a properties file to avoid (synchronized) text parsing. ",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "ScriptRuntime.getMessage0",
    "class_name": "com.google.javascript.rhino.ScriptRuntime",
    "signature": "com.google.javascript.rhino.ScriptRuntime.getMessage0(String)",
    "snippet": "    public static String getMessage0(String messageId)\n    {\n        return getMessage(messageId, null);\n    }",
    "comment": "------------------",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "AllType.AllType",
    "class_name": "com.google.javascript.rhino.jstype.AllType",
    "signature": "com.google.javascript.rhino.jstype.AllType.AllType(JSTypeRegistry)",
    "snippet": "  AllType(JSTypeRegistry registry) {\n    super(registry);\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "AllType.isAllType",
    "class_name": "com.google.javascript.rhino.jstype.AllType",
    "signature": "com.google.javascript.rhino.jstype.AllType.isAllType()",
    "snippet": "  @Override\n  public boolean isAllType() {\n    return true;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "ArrowType.ArrowType",
    "class_name": "com.google.javascript.rhino.jstype.ArrowType",
    "signature": "com.google.javascript.rhino.jstype.ArrowType.ArrowType(JSTypeRegistry,Node,JSType)",
    "snippet": "  ArrowType(JSTypeRegistry registry, Node parameters,\n      JSType returnType) {\n    super(registry);\n    this.parameters = parameters;\n    this.returnType = returnType;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "ArrowType.hashCode",
    "class_name": "com.google.javascript.rhino.jstype.ArrowType",
    "signature": "com.google.javascript.rhino.jstype.ArrowType.hashCode()",
    "snippet": "  @Override\n  public int hashCode() {\n    int hashCode = 0;\n    if (returnType != null) {\n      hashCode += returnType.hashCode();\n    }\n    if (parameters != null) {\n      Node param = parameters.getFirstChild();\n      while (param != null) {\n        JSType paramType = param.getJSType();\n        if (paramType != null) {\n          hashCode += paramType.hashCode();\n        }\n        param = param.getNext();\n      }\n    }\n    return hashCode;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "BooleanType.BooleanType",
    "class_name": "com.google.javascript.rhino.jstype.BooleanType",
    "signature": "com.google.javascript.rhino.jstype.BooleanType.BooleanType(JSTypeRegistry)",
    "snippet": "  BooleanType(JSTypeRegistry registry) {\n    super(registry);\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "BooleanType.toString",
    "class_name": "com.google.javascript.rhino.jstype.BooleanType",
    "signature": "com.google.javascript.rhino.jstype.BooleanType.toString()",
    "snippet": "  @Override\n  public String toString() {\n    return \"boolean\";\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "BooleanType.visit",
    "class_name": "com.google.javascript.rhino.jstype.BooleanType",
    "signature": "com.google.javascript.rhino.jstype.BooleanType.visit(Visitor)",
    "snippet": "  @Override\n  public <T> T visit(Visitor<T> visitor) {\n    return visitor.caseBooleanType();\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "ErrorFunctionType.ErrorFunctionType",
    "class_name": "com.google.javascript.rhino.jstype.ErrorFunctionType",
    "signature": "com.google.javascript.rhino.jstype.ErrorFunctionType.ErrorFunctionType(JSTypeRegistry,String)",
    "snippet": "  ErrorFunctionType(JSTypeRegistry registry, String name) {\n    super(registry, name, null,\n          registry.createOptionalParameters(\n              registry.getNativeType(ALL_TYPE),\n              registry.getNativeType(ALL_TYPE),\n              registry.getNativeType(ALL_TYPE)),\n          null, null, null, true, true);\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "ErrorFunctionType.getReturnType",
    "class_name": "com.google.javascript.rhino.jstype.ErrorFunctionType",
    "signature": "com.google.javascript.rhino.jstype.ErrorFunctionType.getReturnType()",
    "snippet": "  @Override\n  public JSType getReturnType() {\n    return getInstanceType();\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "FunctionParamBuilder.FunctionParamBuilder",
    "class_name": "com.google.javascript.rhino.jstype.FunctionParamBuilder",
    "signature": "com.google.javascript.rhino.jstype.FunctionParamBuilder.FunctionParamBuilder(JSTypeRegistry)",
    "snippet": "  public FunctionParamBuilder(JSTypeRegistry registry) {\n    this.registry = registry;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "FunctionParamBuilder.addOptionalParams",
    "class_name": "com.google.javascript.rhino.jstype.FunctionParamBuilder",
    "signature": "com.google.javascript.rhino.jstype.FunctionParamBuilder.addOptionalParams(JSType[])",
    "snippet": "  public boolean addOptionalParams(JSType ...types) {\n    if (hasVarArgs()) {\n      return false;\n    }\n\n    for (JSType type : types) {\n      newParameter(registry.createOptionalType(type)).setOptionalArg(true);\n    }\n    return true;\n  }",
    "comment": " Add optional parameters of the given type to the end of the param list. @param types Types for each optional parameter. The builder will make them undefineable. @return False if this is called after var args are added. ",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "FunctionParamBuilder.addRequiredParams",
    "class_name": "com.google.javascript.rhino.jstype.FunctionParamBuilder",
    "signature": "com.google.javascript.rhino.jstype.FunctionParamBuilder.addRequiredParams(JSType[])",
    "snippet": "  public boolean addRequiredParams(JSType ...types) {\n    if (hasOptionalOrVarArgs()) {\n      return false;\n    }\n\n    for (JSType type : types) {\n      newParameter(type);\n    }\n    return true;\n  }",
    "comment": " Add parameters of the given type to the end of the param list. @return False if this is called after optional params are added. ",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "FunctionParamBuilder.addVarArgs",
    "class_name": "com.google.javascript.rhino.jstype.FunctionParamBuilder",
    "signature": "com.google.javascript.rhino.jstype.FunctionParamBuilder.addVarArgs(JSType)",
    "snippet": "  public boolean addVarArgs(JSType type) {\n    if (hasVarArgs()) {\n      return false;\n    }\n\n    // There are two types of variable argument functions:\n    // 1) Programmer-defined var args\n    // 2) Native bottom types that can accept any argument.\n    // For the first one, \"undefined\" is a valid value for all arguments.\n    // For the second, we do not want to cast it up to undefined.\n    if (!type.isEmptyType()) {\n      type = registry.createOptionalType(type);\n    }\n    newParameter(type).setVarArgs(true);\n    return true;\n  }",
    "comment": " Add variable arguments to the end of the parameter list. @return False if this is called after var args are added. ",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "FunctionParamBuilder.build",
    "class_name": "com.google.javascript.rhino.jstype.FunctionParamBuilder",
    "signature": "com.google.javascript.rhino.jstype.FunctionParamBuilder.build()",
    "snippet": "  public Node build() {\n    return root;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "FunctionParamBuilder.hasOptionalOrVarArgs",
    "class_name": "com.google.javascript.rhino.jstype.FunctionParamBuilder",
    "signature": "com.google.javascript.rhino.jstype.FunctionParamBuilder.hasOptionalOrVarArgs()",
    "snippet": "  private boolean hasOptionalOrVarArgs() {\n    Node lastChild = root.getLastChild();\n    return lastChild != null &&\n        (lastChild.isOptionalArg() || lastChild.isVarArgs());\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "FunctionParamBuilder.hasVarArgs",
    "class_name": "com.google.javascript.rhino.jstype.FunctionParamBuilder",
    "signature": "com.google.javascript.rhino.jstype.FunctionParamBuilder.hasVarArgs()",
    "snippet": "  public boolean hasVarArgs() {\n    Node lastChild = root.getLastChild();\n    return lastChild != null && lastChild.isVarArgs();\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "FunctionParamBuilder.newParameter",
    "class_name": "com.google.javascript.rhino.jstype.FunctionParamBuilder",
    "signature": "com.google.javascript.rhino.jstype.FunctionParamBuilder.newParameter(JSType)",
    "snippet": "  private Node newParameter(JSType type) {\n    Node paramNode = Node.newString(Token.NAME, \"\");\n    paramNode.setJSType(type);\n    root.addChildToBack(paramNode);\n    return paramNode;\n  }",
    "comment": "Add a parameter to the list with the given type.",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "FunctionPrototypeType.FunctionPrototypeType",
    "class_name": "com.google.javascript.rhino.jstype.FunctionPrototypeType",
    "signature": "com.google.javascript.rhino.jstype.FunctionPrototypeType.FunctionPrototypeType(JSTypeRegistry,FunctionType,ObjectType)",
    "snippet": "  FunctionPrototypeType(JSTypeRegistry registry, FunctionType ownerFunction,\n      ObjectType implicitPrototype) {\n    this(registry, ownerFunction, implicitPrototype, false);\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "FunctionPrototypeType.FunctionPrototypeType",
    "class_name": "com.google.javascript.rhino.jstype.FunctionPrototypeType",
    "signature": "com.google.javascript.rhino.jstype.FunctionPrototypeType.FunctionPrototypeType(JSTypeRegistry,FunctionType,ObjectType,boolean)",
    "snippet": "  FunctionPrototypeType(JSTypeRegistry registry, FunctionType ownerFunction,\n      ObjectType implicitPrototype, boolean isNative) {\n    super(registry, null /* has no class name */, implicitPrototype,\n        isNative);\n    this.ownerFunction = ownerFunction;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "FunctionType.FunctionType",
    "class_name": "com.google.javascript.rhino.jstype.FunctionType",
    "signature": "com.google.javascript.rhino.jstype.FunctionType.FunctionType(JSTypeRegistry,String,Node,Node,JSType)",
    "snippet": "  @VisibleForTesting\n  public FunctionType(JSTypeRegistry registry, String name, Node source,\n      Node parameters, JSType returnType) {\n    this(registry, name, source, parameters, returnType, null, null, false,\n         false);\n  }",
    "comment": " Creates a function type. @param registry the owner registry for this type @param name the function's name or {@code null} to indicate that the function is anonymous. @param source the node defining this function. Its type ({@link Node#getType()}) must be {@link Token#FUNCTION}. @param parameters the function's parameters or {@code null} to indicate that the parameter types are unknown. @param returnType the function's return type or {@code null} to indicate that the return type is unknown. ",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "FunctionType.FunctionType",
    "class_name": "com.google.javascript.rhino.jstype.FunctionType",
    "signature": "com.google.javascript.rhino.jstype.FunctionType.FunctionType(JSTypeRegistry,String,Node,Node,JSType,ObjectType,String,boolean,boolean)",
    "snippet": "  FunctionType(JSTypeRegistry registry, String name, Node source,\n      Node parameters, JSType returnType, ObjectType typeOfThis,\n      String templateTypeName,  boolean isConstructor, boolean nativeType) {\n    super(registry, name,\n        registry.getNativeObjectType(JSTypeNative.FUNCTION_INSTANCE_TYPE),\n        nativeType);\n    Preconditions.checkArgument(source == null ||\n        Token.FUNCTION == source.getType());\n    this.source = source;\n    this.kind = isConstructor ? Kind.CONSTRUCTOR : Kind.ORDINARY;\n    if (isConstructor) {\n      this.typeOfThis = typeOfThis != null && typeOfThis.isNoObjectType() ?\n          typeOfThis : new InstanceObjectType(registry, this, nativeType);\n    } else {\n      this.typeOfThis = typeOfThis != null ?\n          typeOfThis :\n          registry.getNativeObjectType(JSTypeNative.UNKNOWN_TYPE);\n    }\n    // The call type should be set up last because we are calling getReturnType,\n    // which may be overloaded and depend on other properties being set.\n    this.call = new ArrowType(registry, parameters,\n        (returnType == null ? getReturnType() : returnType));\n    this.templateTypeName = templateTypeName;\n  }",
    "comment": "Creates an instance for a function that might be a constructor. */",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "FunctionType.addSubType",
    "class_name": "com.google.javascript.rhino.jstype.FunctionType",
    "signature": "com.google.javascript.rhino.jstype.FunctionType.addSubType(FunctionType)",
    "snippet": "  private void addSubType(FunctionType subType) {\n    if (subTypes == null) {\n      subTypes = Lists.newArrayList();\n    }\n    subTypes.add(subType);\n  }",
    "comment": "Adds a type to the list of subtypes for this type. */",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "FunctionType.defineProperty",
    "class_name": "com.google.javascript.rhino.jstype.FunctionType",
    "signature": "com.google.javascript.rhino.jstype.FunctionType.defineProperty(String,JSType,boolean,boolean)",
    "snippet": "  @Override\n  boolean defineProperty(String name, JSType type,\n      boolean inferred, boolean inExterns) {\n    if (\"prototype\".equals(name)) {\n      if (type instanceof ObjectType) {\n        ObjectType objType = (ObjectType) type;\n        return setPrototype(\n            new FunctionPrototypeType(\n                registry, this, objType, isNativeObjectType()));\n      } else {\n        return false;\n      }\n    }\n    return super.defineProperty(name, type, inferred, inExterns);\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "FunctionType.getImplementedInterfaces",
    "class_name": "com.google.javascript.rhino.jstype.FunctionType",
    "signature": "com.google.javascript.rhino.jstype.FunctionType.getImplementedInterfaces()",
    "snippet": "  public List<ObjectType> getImplementedInterfaces() {\n    if (implementedInterfaces == null) {\n      return ImmutableList.of();\n    } else {\n      return implementedInterfaces;\n    }\n  }",
    "comment": "Returns interfaces implemented directly by a class or its superclass. */",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "FunctionType.getInstanceType",
    "class_name": "com.google.javascript.rhino.jstype.FunctionType",
    "signature": "com.google.javascript.rhino.jstype.FunctionType.getInstanceType()",
    "snippet": "  public ObjectType getInstanceType() {\n    Preconditions.checkState(hasInstanceType());\n    return typeOfThis;\n  }",
    "comment": " Gets the type of instance of this function. @throws IllegalStateException if this function is not a constructor (see {@link #isConstructor()}). ",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "FunctionType.getPrototype",
    "class_name": "com.google.javascript.rhino.jstype.FunctionType",
    "signature": "com.google.javascript.rhino.jstype.FunctionType.getPrototype()",
    "snippet": "  public FunctionPrototypeType getPrototype() {\n    // lazy initialization of the prototype field\n    if (prototype == null) {\n      setPrototype(new FunctionPrototypeType(registry, this, null));\n    }\n    return prototype;\n  }",
    "comment": " Gets the {@code prototype} property of this function type. This is equivalent to {@code (ObjectType) getPropertyType(\"prototype\")}. ",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "FunctionType.getSuperClassConstructor",
    "class_name": "com.google.javascript.rhino.jstype.FunctionType",
    "signature": "com.google.javascript.rhino.jstype.FunctionType.getSuperClassConstructor()",
    "snippet": "  public FunctionType getSuperClassConstructor() {\n    Preconditions.checkArgument(isConstructor() || isInterface());\n    ObjectType maybeSuperInstanceType = getPrototype().getImplicitPrototype();\n    if (maybeSuperInstanceType == null) {\n      return null;\n    }\n    return maybeSuperInstanceType.getConstructor();\n  }",
    "comment": " Given a constructor or an interface type, get its superclass constructor or {@code null} if none exists. ",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "FunctionType.hasCachedValues",
    "class_name": "com.google.javascript.rhino.jstype.FunctionType",
    "signature": "com.google.javascript.rhino.jstype.FunctionType.hasCachedValues()",
    "snippet": "  @Override\n  public boolean hasCachedValues() {\n    return prototype != null || super.hasCachedValues();\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "FunctionType.hasInstanceType",
    "class_name": "com.google.javascript.rhino.jstype.FunctionType",
    "signature": "com.google.javascript.rhino.jstype.FunctionType.hasInstanceType()",
    "snippet": "  public boolean hasInstanceType() {\n    return isConstructor() || isInterface();\n  }",
    "comment": " Returns whether this function type has an instance type. ",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "FunctionType.hashCode",
    "class_name": "com.google.javascript.rhino.jstype.FunctionType",
    "signature": "com.google.javascript.rhino.jstype.FunctionType.hashCode()",
    "snippet": "  @Override\n  public int hashCode() {\n    return isInterface() ? getName().hashCode() : call.hashCode();\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "FunctionType.isConstructor",
    "class_name": "com.google.javascript.rhino.jstype.FunctionType",
    "signature": "com.google.javascript.rhino.jstype.FunctionType.isConstructor()",
    "snippet": "  @Override\n  public boolean isConstructor() {\n    return kind == Kind.CONSTRUCTOR;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "FunctionType.isInterface",
    "class_name": "com.google.javascript.rhino.jstype.FunctionType",
    "signature": "com.google.javascript.rhino.jstype.FunctionType.isInterface()",
    "snippet": "  @Override\n  public boolean isInterface() {\n    return kind == Kind.INTERFACE;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "FunctionType.setInstanceType",
    "class_name": "com.google.javascript.rhino.jstype.FunctionType",
    "signature": "com.google.javascript.rhino.jstype.FunctionType.setInstanceType(ObjectType)",
    "snippet": "  void setInstanceType(ObjectType instanceType) {\n    typeOfThis = instanceType;\n  }",
    "comment": "Sets the instance type. This should only be used for special native types. */",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "FunctionType.setPrototype",
    "class_name": "com.google.javascript.rhino.jstype.FunctionType",
    "signature": "com.google.javascript.rhino.jstype.FunctionType.setPrototype(FunctionPrototypeType)",
    "snippet": "  public boolean setPrototype(FunctionPrototypeType prototype) {\n    if (prototype == null) {\n      return false;\n    }\n    // getInstanceType fails if the function is not a constructor\n    if (isConstructor() && prototype == getInstanceType()) {\n      return false;\n    }\n\n    this.prototype = prototype;\n\n    if (isConstructor() || isInterface()) {\n      FunctionType superClass = getSuperClassConstructor();\n      if (superClass != null) {\n        superClass.addSubType(this);\n      }\n    }\n    return true;\n  }",
    "comment": " Sets the prototype. @param prototype the prototype. If this value is {@code null} it will silently be discarded. ",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "FunctionType.setPrototypeBasedOn",
    "class_name": "com.google.javascript.rhino.jstype.FunctionType",
    "signature": "com.google.javascript.rhino.jstype.FunctionType.setPrototypeBasedOn(ObjectType)",
    "snippet": "  public void setPrototypeBasedOn(ObjectType baseType) {\n    if (prototype == null) {\n      setPrototype(\n          new FunctionPrototypeType(\n              registry, this, baseType, isNativeObjectType()));\n    } else {\n      prototype.setImplicitPrototype(baseType);\n    }\n  }",
    "comment": " Sets the prototype, creating the prototype object from the given base type. @param baseType The base type. ",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "InstanceObjectType.InstanceObjectType",
    "class_name": "com.google.javascript.rhino.jstype.InstanceObjectType",
    "signature": "com.google.javascript.rhino.jstype.InstanceObjectType.InstanceObjectType(JSTypeRegistry,FunctionType,boolean)",
    "snippet": "  InstanceObjectType(JSTypeRegistry registry, FunctionType constructor,\n                     boolean isNativeType) {\n    super(registry, null, null, isNativeType);\n    Preconditions.checkNotNull(constructor);\n    this.constructor = constructor;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "InstanceObjectType.defineProperty",
    "class_name": "com.google.javascript.rhino.jstype.InstanceObjectType",
    "signature": "com.google.javascript.rhino.jstype.InstanceObjectType.defineProperty(String,JSType,boolean,boolean)",
    "snippet": "  @Override\n  boolean defineProperty(String name, JSType type, boolean inferred,\n      boolean inExterns) {\n    ObjectType proto = getImplicitPrototype();\n    if (proto != null && proto.hasOwnDeclaredProperty(name)) {\n      return false;\n    }\n    return super.defineProperty(name, type, inferred, inExterns);\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "InstanceObjectType.equals",
    "class_name": "com.google.javascript.rhino.jstype.InstanceObjectType",
    "signature": "com.google.javascript.rhino.jstype.InstanceObjectType.equals(Object)",
    "snippet": "  @Override\n  public boolean equals(Object that) {\n    if (this == that) {\n      return true;\n    } else if (this.isNominalType() && that instanceof JSType &&\n        ((JSType) that).isNominalType()) {\n      return getName().equals(((ObjectType) that).getName());\n    }\n    return false;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "InstanceObjectType.getConstructor",
    "class_name": "com.google.javascript.rhino.jstype.InstanceObjectType",
    "signature": "com.google.javascript.rhino.jstype.InstanceObjectType.getConstructor()",
    "snippet": "  @Override\n  public FunctionType getConstructor() {\n    return constructor;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "InstanceObjectType.getImplicitPrototype",
    "class_name": "com.google.javascript.rhino.jstype.InstanceObjectType",
    "signature": "com.google.javascript.rhino.jstype.InstanceObjectType.getImplicitPrototype()",
    "snippet": "  @Override\n  public ObjectType getImplicitPrototype() {\n    return getConstructor().getPrototype();\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "InstanceObjectType.getName",
    "class_name": "com.google.javascript.rhino.jstype.InstanceObjectType",
    "signature": "com.google.javascript.rhino.jstype.InstanceObjectType.getName()",
    "snippet": "  @Override\n  public String getName() {\n    return getConstructor().getName();\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "InstanceObjectType.hasName",
    "class_name": "com.google.javascript.rhino.jstype.InstanceObjectType",
    "signature": "com.google.javascript.rhino.jstype.InstanceObjectType.hasName()",
    "snippet": "  @Override\n  public boolean hasName() {\n    return getConstructor().hasName();\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "InstanceObjectType.hashCode",
    "class_name": "com.google.javascript.rhino.jstype.InstanceObjectType",
    "signature": "com.google.javascript.rhino.jstype.InstanceObjectType.hashCode()",
    "snippet": "  @Override\n  public int hashCode() {\n    if (hasName()) {\n      return getName().hashCode();\n    } else {\n      return super.hashCode();\n    }\n  }",
    "comment": " If this is equal to a NamedType object, its hashCode must be equal to the hashCode of the NamedType object. ",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "InstanceObjectType.isNominalType",
    "class_name": "com.google.javascript.rhino.jstype.InstanceObjectType",
    "signature": "com.google.javascript.rhino.jstype.InstanceObjectType.isNominalType()",
    "snippet": "  @Override\n  boolean isNominalType() {\n    return hasName();\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "InstanceObjectType.isSubtype",
    "class_name": "com.google.javascript.rhino.jstype.InstanceObjectType",
    "signature": "com.google.javascript.rhino.jstype.InstanceObjectType.isSubtype(JSType)",
    "snippet": "  @Override\n  public boolean isSubtype(JSType that) {\n    if (super.isSubtype(that)) {\n      return true;\n    }\n    List<ObjectType> thisInterfaces =\n        getConstructor().getImplementedInterfaces();\n    if (thisInterfaces != null) {\n      List<ObjectType> thatInterfaces = that.keepAssignableInterfaces();\n      for (ObjectType thatInterface : thatInterfaces) {\n        for (ObjectType thisInterface : thisInterfaces) {\n          if (thisInterface.isSubtype(thatInterface)) {\n            return true;\n          }\n        }\n      }\n    }\n    return false;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "InstanceObjectType.toString",
    "class_name": "com.google.javascript.rhino.jstype.InstanceObjectType",
    "signature": "com.google.javascript.rhino.jstype.InstanceObjectType.toString()",
    "snippet": "  @Override\n  public String toString() {\n    return constructor.getName();\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "JSType.JSType",
    "class_name": "com.google.javascript.rhino.jstype.JSType",
    "signature": "com.google.javascript.rhino.jstype.JSType.JSType(JSTypeRegistry)",
    "snippet": "  JSType(JSTypeRegistry registry) {\n    this.registry = registry;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "JSType.equals",
    "class_name": "com.google.javascript.rhino.jstype.JSType",
    "signature": "com.google.javascript.rhino.jstype.JSType.equals(Object)",
    "snippet": "  @Override public boolean equals(Object jsType) {\n    if (jsType instanceof ProxyObjectType) {\n      return jsType.equals(this);\n    }\n    return this == jsType;\n  }",
    "comment": " This method relies on the fact that for the base {@link JSType}, only one instance of each sub-type will ever be created in a given registry, so there is no need to verify members. If the object pointers are not identical, then the type member must be different. ",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "JSType.hashCode",
    "class_name": "com.google.javascript.rhino.jstype.JSType",
    "signature": "com.google.javascript.rhino.jstype.JSType.hashCode()",
    "snippet": "  @Override\n  public int hashCode() {\n    return System.identityHashCode(this);\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "JSType.isAllType",
    "class_name": "com.google.javascript.rhino.jstype.JSType",
    "signature": "com.google.javascript.rhino.jstype.JSType.isAllType()",
    "snippet": "  public boolean isAllType() {\n    return false;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "JSType.isEmptyType",
    "class_name": "com.google.javascript.rhino.jstype.JSType",
    "signature": "com.google.javascript.rhino.jstype.JSType.isEmptyType()",
    "snippet": "  public final boolean isEmptyType() {\n    return isNoType() || isNoObjectType();\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "JSType.isNoObjectType",
    "class_name": "com.google.javascript.rhino.jstype.JSType",
    "signature": "com.google.javascript.rhino.jstype.JSType.isNoObjectType()",
    "snippet": "  public boolean isNoObjectType() {\n    return false;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "JSType.isNoType",
    "class_name": "com.google.javascript.rhino.jstype.JSType",
    "signature": "com.google.javascript.rhino.jstype.JSType.isNoType()",
    "snippet": "  public boolean isNoType() {\n    return false;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "JSType.isNominalType",
    "class_name": "com.google.javascript.rhino.jstype.JSType",
    "signature": "com.google.javascript.rhino.jstype.JSType.isNominalType()",
    "snippet": "  boolean isNominalType() {\n    return false;\n  }",
    "comment": " Whether this type is a nominal type (a named instance object or a named enum). ",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "JSType.isSubtype",
    "class_name": "com.google.javascript.rhino.jstype.JSType",
    "signature": "com.google.javascript.rhino.jstype.JSType.isSubtype(JSType,JSType)",
    "snippet": "  static boolean isSubtype(JSType thisType, JSType thatType) {\n    // unknown\n    if (thatType.isUnknownType()) {\n      return true;\n    }\n    // equality\n    if (thisType.equals(thatType)) {\n      return true;\n    }\n    // all type\n    if (thatType.isAllType()) {\n      return true;\n    }\n    // unions\n    if (thatType instanceof UnionType) {\n      UnionType union = (UnionType)thatType;\n      for (JSType element : union.alternates) {\n        if (thisType.isSubtype(element)) {\n          return true;\n        }\n      }\n    }\n    // named types\n    if (thatType instanceof NamedType) {\n      return thisType.isSubtype(((NamedType)thatType).referencedType);\n    }\n    return false;\n  }",
    "comment": " A generic implementation meant to be used as a helper for common subtyping cases. ",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "JSType.isUnknownType",
    "class_name": "com.google.javascript.rhino.jstype.JSType",
    "signature": "com.google.javascript.rhino.jstype.JSType.isUnknownType()",
    "snippet": "  public boolean isUnknownType() {\n    return false;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "JSType.keepAssignableInterfaces",
    "class_name": "com.google.javascript.rhino.jstype.JSType",
    "signature": "com.google.javascript.rhino.jstype.JSType.keepAssignableInterfaces()",
    "snippet": "  List<ObjectType> keepAssignableInterfaces() {\n    return visit(keepAssignableInterfacesVisitor);\n  }",
    "comment": " Computes the list of interfaces that can be assigned to this type. @return A list of interface types (may contain duplicates). ",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "JSTypeRegistry.JSTypeRegistry",
    "class_name": "com.google.javascript.rhino.jstype.JSTypeRegistry",
    "signature": "com.google.javascript.rhino.jstype.JSTypeRegistry.JSTypeRegistry(ErrorReporter)",
    "snippet": "  public JSTypeRegistry(ErrorReporter reporter) {\n    this.reporter = reporter;\n    nativeTypes = new JSType[JSTypeNative.values().length];\n    namesToTypes = new HashMap<String, JSType>();\n    resetForTypeCheck();\n  }",
    "comment": " Constructs a new type registry populated with the built-in types. ",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "JSTypeRegistry.createFunctionType",
    "class_name": "com.google.javascript.rhino.jstype.JSTypeRegistry",
    "signature": "com.google.javascript.rhino.jstype.JSTypeRegistry.createFunctionType(JSType,boolean,JSType[])",
    "snippet": "  public FunctionType createFunctionType(JSType returnType,\n      boolean lastVarArgs, JSType... parameterTypes) {\n    if (lastVarArgs) {\n      return createFunctionTypeWithVarArgs(returnType, parameterTypes);\n    } else {\n      return createFunctionType(returnType, parameterTypes);\n    }\n  }",
    "comment": " Creates a function type. @param returnType the function's return type @param lastVarArgs whether the last parameter type should be considered as an extensible var_args parameter @param parameterTypes the parameters' types ",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "JSTypeRegistry.createFunctionTypeWithVarArgs",
    "class_name": "com.google.javascript.rhino.jstype.JSTypeRegistry",
    "signature": "com.google.javascript.rhino.jstype.JSTypeRegistry.createFunctionTypeWithVarArgs(JSType,JSType[])",
    "snippet": "  public FunctionType createFunctionTypeWithVarArgs(\n      JSType returnType, JSType... parameterTypes) {\n    return new FunctionType(\n        this, null, null, createParametersWithVarArgs(parameterTypes), returnType);\n  }",
    "comment": " Creates a function type. The last parameter type of the function is considered a variable length argument.  @param returnType the function's return type @param parameterTypes the parameters' types ",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "JSTypeRegistry.createNullableType",
    "class_name": "com.google.javascript.rhino.jstype.JSTypeRegistry",
    "signature": "com.google.javascript.rhino.jstype.JSTypeRegistry.createNullableType(JSType)",
    "snippet": "  public JSType createNullableType(JSType type) {\n    return createUnionType(type, getNativeType(JSTypeNative.NULL_TYPE));\n  }",
    "comment": " Creates a type representing nullable values of the given type. @return the union of the type and the Null type ",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "JSTypeRegistry.createObjectType",
    "class_name": "com.google.javascript.rhino.jstype.JSTypeRegistry",
    "signature": "com.google.javascript.rhino.jstype.JSTypeRegistry.createObjectType(String,Node,ObjectType)",
    "snippet": "  public ObjectType createObjectType(String name, Node n,\n      ObjectType implicitPrototype) {\n    return new PrototypeObjectType(this, name, implicitPrototype);\n  }",
    "comment": " Create an object type. ",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "JSTypeRegistry.createOptionalParameters",
    "class_name": "com.google.javascript.rhino.jstype.JSTypeRegistry",
    "signature": "com.google.javascript.rhino.jstype.JSTypeRegistry.createOptionalParameters(JSType[])",
    "snippet": "  public Node createOptionalParameters(JSType... parameterTypes) {\n    FunctionParamBuilder builder = new FunctionParamBuilder(this);\n    builder.addOptionalParams(parameterTypes);\n    return builder.build();\n  }",
    "comment": " Creates a tree hierarchy representing a typed parameter list in which every parameter is optional. ",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "JSTypeRegistry.createOptionalType",
    "class_name": "com.google.javascript.rhino.jstype.JSTypeRegistry",
    "signature": "com.google.javascript.rhino.jstype.JSTypeRegistry.createOptionalType(JSType)",
    "snippet": "  public JSType createOptionalType(JSType type) {\n    if (type instanceof UnknownType || type.isAllType()) {\n      return type;\n    } else {\n      return createUnionType(type, getNativeType(JSTypeNative.VOID_TYPE));\n    }\n  }",
    "comment": " Creates a type representing optional values of the given type. @return the union of the type and the void type ",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "JSTypeRegistry.createParameters",
    "class_name": "com.google.javascript.rhino.jstype.JSTypeRegistry",
    "signature": "com.google.javascript.rhino.jstype.JSTypeRegistry.createParameters(boolean,JSType[])",
    "snippet": "  private Node createParameters(boolean lastVarArgs, JSType... parameterTypes) {\n    FunctionParamBuilder builder = new FunctionParamBuilder(this);\n    int max = parameterTypes.length - 1;\n    for (int i = 0; i <= max; i++) {\n      if (lastVarArgs && i == max) {\n        builder.addVarArgs(parameterTypes[i]);\n      } else {\n        builder.addRequiredParams(parameterTypes[i]);\n      }\n    }\n    return builder.build();\n  }",
    "comment": " Creates a tree hierarchy representing a typed argument list.  @param lastVarArgs whether the last type should considered as a variable length argument. @param parameterTypes the parameter types. The last element of this array is considered a variable length argument is {@code lastVarArgs} is {@code true}. @return a tree hierarchy representing a typed argument list ",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "JSTypeRegistry.createParametersWithVarArgs",
    "class_name": "com.google.javascript.rhino.jstype.JSTypeRegistry",
    "signature": "com.google.javascript.rhino.jstype.JSTypeRegistry.createParametersWithVarArgs(JSType[])",
    "snippet": "  public Node createParametersWithVarArgs(JSType... parameterTypes) {\n    return createParameters(true, parameterTypes);\n  }",
    "comment": " Creates a tree hierarchy representing a typed argument list. The last parameter type is considered a variable length argument.  @param parameterTypes the parameter types. The last element of this array is considered a variable length argument. @return a tree hierarchy representing a typed argument list. ",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "JSTypeRegistry.createUnionType",
    "class_name": "com.google.javascript.rhino.jstype.JSTypeRegistry",
    "signature": "com.google.javascript.rhino.jstype.JSTypeRegistry.createUnionType(JSTypeNative[])",
    "snippet": "  public JSType createUnionType(JSTypeNative... variants) {\n    UnionTypeBuilder builder = new UnionTypeBuilder(this);\n    for (JSTypeNative typeId : variants) {\n      builder.addAlternate(getNativeType(typeId));\n    }\n    return builder.build();\n  }",
    "comment": " Creates a union type whose variants are the builtin types specified by the arguments. ",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "JSTypeRegistry.createUnionType",
    "class_name": "com.google.javascript.rhino.jstype.JSTypeRegistry",
    "signature": "com.google.javascript.rhino.jstype.JSTypeRegistry.createUnionType(JSType[])",
    "snippet": "  public JSType createUnionType(JSType... variants) {\n    UnionTypeBuilder builder = new UnionTypeBuilder(this);\n    for (JSType type : variants) {\n      builder.addAlternate(type);\n    }\n    return builder.build();\n  }",
    "comment": " Creates a union type whose variants are the arguments. ",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "JSTypeRegistry.getNativeFunctionType",
    "class_name": "com.google.javascript.rhino.jstype.JSTypeRegistry",
    "signature": "com.google.javascript.rhino.jstype.JSTypeRegistry.getNativeFunctionType(JSTypeNative)",
    "snippet": "  public FunctionType getNativeFunctionType(JSTypeNative typeId) {\n    return (FunctionType) getNativeType(typeId);\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "JSTypeRegistry.getNativeObjectType",
    "class_name": "com.google.javascript.rhino.jstype.JSTypeRegistry",
    "signature": "com.google.javascript.rhino.jstype.JSTypeRegistry.getNativeObjectType(JSTypeNative)",
    "snippet": "  public ObjectType getNativeObjectType(JSTypeNative typeId) {\n    return (ObjectType) getNativeType(typeId);\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "JSTypeRegistry.getNativeType",
    "class_name": "com.google.javascript.rhino.jstype.JSTypeRegistry",
    "signature": "com.google.javascript.rhino.jstype.JSTypeRegistry.getNativeType(JSTypeNative)",
    "snippet": "  public JSType getNativeType(JSTypeNative typeId) {\n    return nativeTypes[typeId.ordinal()];\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "JSTypeRegistry.initializeBuiltInTypes",
    "class_name": "com.google.javascript.rhino.jstype.JSTypeRegistry",
    "signature": "com.google.javascript.rhino.jstype.JSTypeRegistry.initializeBuiltInTypes()",
    "snippet": "  private void initializeBuiltInTypes() {\n    // These locals shouldn't be all caps.\n    BooleanType BOOLEAN_TYPE = new BooleanType(this);\n    registerNativeType(JSTypeNative.BOOLEAN_TYPE, BOOLEAN_TYPE);\n\n    NullType NULL_TYPE = new NullType(this);\n    registerNativeType(JSTypeNative.NULL_TYPE, NULL_TYPE);\n\n    NumberType NUMBER_TYPE = new NumberType(this);\n    registerNativeType(JSTypeNative.NUMBER_TYPE, NUMBER_TYPE);\n\n    StringType STRING_TYPE = new StringType(this);\n    registerNativeType(JSTypeNative.STRING_TYPE, STRING_TYPE);\n\n    UnknownType UNKNOWN_TYPE = new UnknownType(this, false);\n    registerNativeType(JSTypeNative.UNKNOWN_TYPE, UNKNOWN_TYPE);\n    registerNativeType(\n        JSTypeNative.CHECKED_UNKNOWN_TYPE, new UnknownType(this, true));\n\n    VoidType VOID_TYPE = new VoidType(this);\n    registerNativeType(JSTypeNative.VOID_TYPE, VOID_TYPE);\n\n    AllType ALL_TYPE = new AllType(this);\n    registerNativeType(JSTypeNative.ALL_TYPE, ALL_TYPE);\n\n    // Top Level Prototype (the One)\n    // The initializations of TOP_LEVEL_PROTOTYPE and OBJECT_FUNCTION_TYPE\n    // use each other's results, so at least one of them will get null\n    // instead of an actual type; however, this seems to be benign.\n    ObjectType TOP_LEVEL_PROTOTYPE =\n        new FunctionPrototypeType(this, null, null, true);\n    registerNativeType(JSTypeNative.TOP_LEVEL_PROTOTYPE, TOP_LEVEL_PROTOTYPE);\n\n    // Object\n    FunctionType OBJECT_FUNCTION_TYPE =\n        new FunctionType(this, \"Object\", null,\n            createOptionalParameters(ALL_TYPE), UNKNOWN_TYPE,\n            null, null, true, true);\n    OBJECT_FUNCTION_TYPE.defineDeclaredProperty(\n        \"prototype\", TOP_LEVEL_PROTOTYPE, true);\n    registerNativeType(JSTypeNative.OBJECT_FUNCTION_TYPE, OBJECT_FUNCTION_TYPE);\n\n    ObjectType OBJECT_PROTOTYPE = OBJECT_FUNCTION_TYPE.getPrototype();\n    registerNativeType(JSTypeNative.OBJECT_PROTOTYPE, OBJECT_PROTOTYPE);\n\n    ObjectType OBJECT_TYPE = OBJECT_FUNCTION_TYPE.getInstanceType();\n    registerNativeType(JSTypeNative.OBJECT_TYPE, OBJECT_TYPE);\n\n    // Function\n    FunctionType FUNCTION_FUNCTION_TYPE =\n        new FunctionType(this, \"Function\", null,\n            createParametersWithVarArgs(ALL_TYPE), UNKNOWN_TYPE,\n            null, null, true, true);\n    FUNCTION_FUNCTION_TYPE.setPrototypeBasedOn(OBJECT_TYPE);\n    registerNativeType(\n        JSTypeNative.FUNCTION_FUNCTION_TYPE, FUNCTION_FUNCTION_TYPE);\n\n    ObjectType FUNCTION_PROTOTYPE = FUNCTION_FUNCTION_TYPE.getPrototype();\n    registerNativeType(JSTypeNative.FUNCTION_PROTOTYPE, FUNCTION_PROTOTYPE);\n\n    NoType NO_TYPE = new NoType(this);\n    registerNativeType(JSTypeNative.NO_TYPE, NO_TYPE);\n\n    NoObjectType NO_OBJECT_TYPE = new NoObjectType(this);\n    registerNativeType(JSTypeNative.NO_OBJECT_TYPE, NO_OBJECT_TYPE);\n\n    // Array\n    FunctionType ARRAY_FUNCTION_TYPE =\n      new FunctionType(this, \"Array\", null,\n          createParametersWithVarArgs(ALL_TYPE), null, null, null, true, true) {\n        private static final long serialVersionUID = 1L;\n\n        @Override\n        public JSType getReturnType() {\n          return getInstanceType();\n        }\n      };\n    ObjectType arrayPrototype = ARRAY_FUNCTION_TYPE.getPrototype();\n    registerNativeType(JSTypeNative.ARRAY_FUNCTION_TYPE, ARRAY_FUNCTION_TYPE);\n\n    ObjectType ARRAY_TYPE = ARRAY_FUNCTION_TYPE.getInstanceType();\n    registerNativeType(JSTypeNative.ARRAY_TYPE, ARRAY_TYPE);\n\n    // Boolean\n    FunctionType BOOLEAN_OBJECT_FUNCTION_TYPE =\n        new FunctionType(this, \"Boolean\", null,\n            createParameters(false, ALL_TYPE), BOOLEAN_TYPE, null, null, true,\n            true);\n    ObjectType booleanPrototype = BOOLEAN_OBJECT_FUNCTION_TYPE.getPrototype();\n    registerNativeType(\n        JSTypeNative.BOOLEAN_OBJECT_FUNCTION_TYPE, BOOLEAN_OBJECT_FUNCTION_TYPE);\n\n    ObjectType BOOLEAN_OBJECT_TYPE =\n        BOOLEAN_OBJECT_FUNCTION_TYPE.getInstanceType();\n    registerNativeType(JSTypeNative.BOOLEAN_OBJECT_TYPE, BOOLEAN_OBJECT_TYPE);\n\n    // Date\n    FunctionType DATE_FUNCTION_TYPE =\n      new FunctionType(this, \"Date\", null,\n          createOptionalParameters(UNKNOWN_TYPE, UNKNOWN_TYPE, UNKNOWN_TYPE,\n              UNKNOWN_TYPE, UNKNOWN_TYPE, UNKNOWN_TYPE, UNKNOWN_TYPE),\n          STRING_TYPE, null, null, true, true);\n    ObjectType datePrototype = DATE_FUNCTION_TYPE.getPrototype();\n    registerNativeType(JSTypeNative.DATE_FUNCTION_TYPE, DATE_FUNCTION_TYPE);\n\n    ObjectType DATE_TYPE = DATE_FUNCTION_TYPE.getInstanceType();\n    registerNativeType(JSTypeNative.DATE_TYPE, DATE_TYPE);\n\n    // Error\n    FunctionType ERROR_FUNCTION_TYPE = new ErrorFunctionType(this, \"Error\");\n    registerNativeType(JSTypeNative.ERROR_FUNCTION_TYPE, ERROR_FUNCTION_TYPE);\n\n    ObjectType ERROR_TYPE = ERROR_FUNCTION_TYPE.getInstanceType();\n    registerNativeType(JSTypeNative.ERROR_TYPE, ERROR_TYPE);\n\n    // EvalError\n    FunctionType EVAL_ERROR_FUNCTION_TYPE =\n        new ErrorFunctionType(this, \"EvalError\");\n    EVAL_ERROR_FUNCTION_TYPE.setPrototypeBasedOn(ERROR_TYPE);\n    registerNativeType(\n        JSTypeNative.EVAL_ERROR_FUNCTION_TYPE, EVAL_ERROR_FUNCTION_TYPE);\n\n    ObjectType EVAL_ERROR_TYPE = EVAL_ERROR_FUNCTION_TYPE.getInstanceType();\n    registerNativeType(JSTypeNative.EVAL_ERROR_TYPE, EVAL_ERROR_TYPE);\n\n    // RangeError\n    FunctionType RANGE_ERROR_FUNCTION_TYPE =\n        new ErrorFunctionType(this, \"RangeError\");\n    RANGE_ERROR_FUNCTION_TYPE.setPrototypeBasedOn(ERROR_TYPE);\n    registerNativeType(\n        JSTypeNative.RANGE_ERROR_FUNCTION_TYPE, RANGE_ERROR_FUNCTION_TYPE);\n\n    ObjectType RANGE_ERROR_TYPE = RANGE_ERROR_FUNCTION_TYPE.getInstanceType();\n    registerNativeType(JSTypeNative.RANGE_ERROR_TYPE, RANGE_ERROR_TYPE);\n\n    // ReferenceError\n    FunctionType REFERENCE_ERROR_FUNCTION_TYPE =\n        new ErrorFunctionType(this, \"ReferenceError\");\n    REFERENCE_ERROR_FUNCTION_TYPE.setPrototypeBasedOn(ERROR_TYPE);\n    registerNativeType(\n        JSTypeNative.REFERENCE_ERROR_FUNCTION_TYPE, REFERENCE_ERROR_FUNCTION_TYPE);\n\n    ObjectType REFERENCE_ERROR_TYPE =\n        REFERENCE_ERROR_FUNCTION_TYPE.getInstanceType();\n    registerNativeType(JSTypeNative.REFERENCE_ERROR_TYPE, REFERENCE_ERROR_TYPE);\n\n    // SyntaxError\n    FunctionType SYNTAX_ERROR_FUNCTION_TYPE =\n        new ErrorFunctionType(this, \"SyntaxError\");\n    SYNTAX_ERROR_FUNCTION_TYPE.setPrototypeBasedOn(ERROR_TYPE);\n    registerNativeType(\n        JSTypeNative.SYNTAX_ERROR_FUNCTION_TYPE, SYNTAX_ERROR_FUNCTION_TYPE);\n\n    ObjectType SYNTAX_ERROR_TYPE = SYNTAX_ERROR_FUNCTION_TYPE.getInstanceType();\n    registerNativeType(JSTypeNative.SYNTAX_ERROR_TYPE, SYNTAX_ERROR_TYPE);\n\n    // TypeError\n    FunctionType TYPE_ERROR_FUNCTION_TYPE =\n        new ErrorFunctionType(this, \"TypeError\");\n    TYPE_ERROR_FUNCTION_TYPE.setPrototypeBasedOn(ERROR_TYPE);\n    registerNativeType(\n        JSTypeNative.TYPE_ERROR_FUNCTION_TYPE, TYPE_ERROR_FUNCTION_TYPE);\n\n    ObjectType TYPE_ERROR_TYPE = TYPE_ERROR_FUNCTION_TYPE.getInstanceType();\n    registerNativeType(JSTypeNative.TYPE_ERROR_TYPE, TYPE_ERROR_TYPE);\n\n    // URIError\n    FunctionType URI_ERROR_FUNCTION_TYPE =\n        new ErrorFunctionType(this, \"URIError\");\n    URI_ERROR_FUNCTION_TYPE.setPrototypeBasedOn(ERROR_TYPE);\n    registerNativeType(\n        JSTypeNative.URI_ERROR_FUNCTION_TYPE, URI_ERROR_FUNCTION_TYPE);\n\n    ObjectType URI_ERROR_TYPE = URI_ERROR_FUNCTION_TYPE.getInstanceType();\n    registerNativeType(JSTypeNative.URI_ERROR_TYPE, URI_ERROR_TYPE);\n\n    // Number\n    FunctionType NUMBER_OBJECT_FUNCTION_TYPE =\n        new FunctionType(this, \"Number\", null, createParameters(false, ALL_TYPE),\n            NUMBER_TYPE, null, null, true, true);\n    ObjectType numberPrototype = NUMBER_OBJECT_FUNCTION_TYPE.getPrototype();\n    registerNativeType(\n        JSTypeNative.NUMBER_OBJECT_FUNCTION_TYPE, NUMBER_OBJECT_FUNCTION_TYPE);\n\n    ObjectType NUMBER_OBJECT_TYPE =\n        NUMBER_OBJECT_FUNCTION_TYPE.getInstanceType();\n    registerNativeType(JSTypeNative.NUMBER_OBJECT_TYPE, NUMBER_OBJECT_TYPE);\n\n    // RegExp\n    FunctionType REGEXP_FUNCTION_TYPE =\n      new FunctionType(this, \"RegExp\", null,\n          createOptionalParameters(ALL_TYPE, ALL_TYPE),\n          null, null, null, true, true) {\n        private static final long serialVersionUID = 1L;\n\n        @Override\n        public JSType getReturnType() {\n          return getInstanceType();\n        }\n      };\n    ObjectType regexpPrototype = REGEXP_FUNCTION_TYPE.getPrototype();\n    registerNativeType(JSTypeNative.REGEXP_FUNCTION_TYPE, REGEXP_FUNCTION_TYPE);\n\n    ObjectType REGEXP_TYPE = REGEXP_FUNCTION_TYPE.getInstanceType();\n    registerNativeType(JSTypeNative.REGEXP_TYPE, REGEXP_TYPE);\n\n    // String\n    FunctionType STRING_OBJECT_FUNCTION_TYPE =\n        new FunctionType(this, \"String\", null, createParameters(false, ALL_TYPE),\n        STRING_TYPE, null, null, true, true);\n    ObjectType stringPrototype = STRING_OBJECT_FUNCTION_TYPE.getPrototype();\n    registerNativeType(\n        JSTypeNative.STRING_OBJECT_FUNCTION_TYPE, STRING_OBJECT_FUNCTION_TYPE);\n\n    ObjectType STRING_OBJECT_TYPE =\n        STRING_OBJECT_FUNCTION_TYPE.getInstanceType();\n    registerNativeType(\n        JSTypeNative.STRING_OBJECT_TYPE, STRING_OBJECT_TYPE);\n\n    // (Object,string,number)\n    JSType OBJECT_NUMBER_STRING =\n        createUnionType(OBJECT_TYPE, NUMBER_TYPE, STRING_TYPE);\n    registerNativeType(JSTypeNative.OBJECT_NUMBER_STRING, OBJECT_NUMBER_STRING);\n\n    // (Object,string,number,boolean)\n    JSType OBJECT_NUMBER_STRING_BOOLEAN =\n        createUnionType(OBJECT_TYPE, NUMBER_TYPE, STRING_TYPE, BOOLEAN_TYPE);\n    registerNativeType(JSTypeNative.OBJECT_NUMBER_STRING_BOOLEAN,\n        OBJECT_NUMBER_STRING_BOOLEAN);\n\n    // (string,number,boolean)\n    JSType NUMBER_STRING_BOOLEAN =\n        createUnionType(NUMBER_TYPE, STRING_TYPE, BOOLEAN_TYPE);\n    registerNativeType(JSTypeNative.NUMBER_STRING_BOOLEAN,\n        NUMBER_STRING_BOOLEAN);\n\n    // (string,number)\n    JSType NUMBER_STRING = createUnionType(NUMBER_TYPE, STRING_TYPE);\n    registerNativeType(JSTypeNative.NUMBER_STRING, NUMBER_STRING);\n\n    // Native object properties are filled in by externs...\n\n    // (String, string)\n    JSType STRING_VALUE_OR_OBJECT_TYPE =\n        createUnionType(STRING_OBJECT_TYPE, STRING_TYPE);\n    registerNativeType(\n        JSTypeNative.STRING_VALUE_OR_OBJECT_TYPE, STRING_VALUE_OR_OBJECT_TYPE);\n\n    // (Number, number)\n    JSType NUMBER_VALUE_OR_OBJECT_TYPE =\n        createUnionType(NUMBER_OBJECT_TYPE, NUMBER_TYPE);\n    registerNativeType(\n        JSTypeNative.NUMBER_VALUE_OR_OBJECT_TYPE, NUMBER_VALUE_OR_OBJECT_TYPE);\n\n    // unknown function type, i.e. (?...) -> ?\n    FunctionType U2U_FUNCTION_TYPE =\n        createFunctionType(UNKNOWN_TYPE, true, UNKNOWN_TYPE);\n    registerNativeType(JSTypeNative.U2U_FUNCTION_TYPE, U2U_FUNCTION_TYPE);\n\n    // unknown constructor type, i.e. (?...) -> ? with the NoObject type\n    // as instance type\n    FunctionType U2U_CONSTRUCTOR_TYPE =\n        // This is equivalent to\n        // createConstructorType(UNKNOWN_TYPE, true, UNKNOWN_TYPE), but,\n        // in addition, overrides getInstanceType() to return the NoObject type\n        // instead of a new anonymous object.\n        new FunctionType(this, \"Function\", null,\n          createParametersWithVarArgs(\n              UNKNOWN_TYPE), UNKNOWN_TYPE, NO_OBJECT_TYPE, null, true, true) {\n          private static final long serialVersionUID = 1L;\n\n          @Override public FunctionType getConstructor() {\n            return registry.getNativeFunctionType(\n                JSTypeNative.FUNCTION_FUNCTION_TYPE);\n          }\n        };\n\n    // The U2U_CONSTRUCTOR is weird, because it's the supertype of its\n    // own constructor.\n    registerNativeType(JSTypeNative.U2U_CONSTRUCTOR_TYPE, U2U_CONSTRUCTOR_TYPE);\n    registerNativeType(\n        JSTypeNative.FUNCTION_INSTANCE_TYPE, U2U_CONSTRUCTOR_TYPE);\n\n    FUNCTION_FUNCTION_TYPE.setInstanceType(U2U_CONSTRUCTOR_TYPE);\n    U2U_CONSTRUCTOR_TYPE.setImplicitPrototype(FUNCTION_PROTOTYPE);\n\n    // least function type, i.e. (All...) -> NoType\n    FunctionType LEAST_FUNCTION_TYPE =\n        createFunctionType(NO_TYPE, true, ALL_TYPE);\n    registerNativeType(JSTypeNative.LEAST_FUNCTION_TYPE, LEAST_FUNCTION_TYPE);\n\n    // the 'this' object in the global scope\n    ObjectType GLOBAL_THIS = createObjectType(\"global this\", null,\n        UNKNOWN_TYPE /* to be resolved later */);\n    registerNativeType(JSTypeNative.GLOBAL_THIS, GLOBAL_THIS);\n\n    // greatest function type, i.e. (NoType...) -> All\n    FunctionType GREATEST_FUNCTION_TYPE =\n      createFunctionType(ALL_TYPE, true, NO_TYPE);\n    registerNativeType(JSTypeNative.GREATEST_FUNCTION_TYPE,\n        GREATEST_FUNCTION_TYPE);\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "JSTypeRegistry.initializeRegistry",
    "class_name": "com.google.javascript.rhino.jstype.JSTypeRegistry",
    "signature": "com.google.javascript.rhino.jstype.JSTypeRegistry.initializeRegistry()",
    "snippet": "  private void initializeRegistry() {\n    register(getNativeType(JSTypeNative.ARRAY_TYPE));\n    register(getNativeType(JSTypeNative.BOOLEAN_OBJECT_TYPE));\n    register(getNativeType(JSTypeNative.BOOLEAN_TYPE));\n    register(getNativeType(JSTypeNative.DATE_TYPE));\n    register(getNativeType(JSTypeNative.NULL_TYPE));\n    register(getNativeType(JSTypeNative.NULL_TYPE), \"Null\");\n    register(getNativeType(JSTypeNative.NUMBER_OBJECT_TYPE));\n    register(getNativeType(JSTypeNative.NUMBER_TYPE));\n    register(getNativeType(JSTypeNative.OBJECT_TYPE));\n    register(getNativeType(JSTypeNative.ERROR_TYPE));\n    register(getNativeType(JSTypeNative.URI_ERROR_TYPE));\n    register(getNativeType(JSTypeNative.EVAL_ERROR_TYPE));\n    register(getNativeType(JSTypeNative.TYPE_ERROR_TYPE));\n    register(getNativeType(JSTypeNative.RANGE_ERROR_TYPE));\n    register(getNativeType(JSTypeNative.REFERENCE_ERROR_TYPE));\n    register(getNativeType(JSTypeNative.SYNTAX_ERROR_TYPE));\n    register(getNativeType(JSTypeNative.REGEXP_TYPE));\n    register(getNativeType(JSTypeNative.STRING_OBJECT_TYPE));\n    register(getNativeType(JSTypeNative.STRING_TYPE));\n    register(getNativeType(JSTypeNative.VOID_TYPE));\n    register(getNativeType(JSTypeNative.VOID_TYPE), \"Undefined\");\n    register(getNativeType(JSTypeNative.VOID_TYPE), \"void\");\n    register(getNativeType(JSTypeNative.FUNCTION_INSTANCE_TYPE), \"Function\");\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "JSTypeRegistry.register",
    "class_name": "com.google.javascript.rhino.jstype.JSTypeRegistry",
    "signature": "com.google.javascript.rhino.jstype.JSTypeRegistry.register(JSType)",
    "snippet": "  private void register(JSType type) {\n    register(type, type.toString());\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "JSTypeRegistry.register",
    "class_name": "com.google.javascript.rhino.jstype.JSTypeRegistry",
    "signature": "com.google.javascript.rhino.jstype.JSTypeRegistry.register(JSType,String)",
    "snippet": "  private void register(JSType type, String name) {\n    namesToTypes.put(name, type);\n\n    // Add all the namespaces in which this name lives.\n    while (name.indexOf('.') > 0) {\n      name = name.substring(0, name.lastIndexOf('.'));\n      namespaces.add(name);\n    }\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "JSTypeRegistry.registerNativeType",
    "class_name": "com.google.javascript.rhino.jstype.JSTypeRegistry",
    "signature": "com.google.javascript.rhino.jstype.JSTypeRegistry.registerNativeType(JSTypeNative,JSType)",
    "snippet": "  private void registerNativeType(JSTypeNative typeId, JSType type) {\n    nativeTypes[typeId.ordinal()] = type;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "JSTypeRegistry.registerPropertyOnType",
    "class_name": "com.google.javascript.rhino.jstype.JSTypeRegistry",
    "signature": "com.google.javascript.rhino.jstype.JSTypeRegistry.registerPropertyOnType(String,ObjectType)",
    "snippet": "  public void registerPropertyOnType(String propertyName, ObjectType owner) {\n    Set<ObjectType> typeSet = typesIndexedByProperty.get(propertyName);\n    if (typeSet == null) {\n      typesIndexedByProperty.put(propertyName, typeSet = Sets.newHashSet());\n    }\n    greatestSubtypeByProperty.remove(propertyName);\n    typeSet.add(owner);\n  }",
    "comment": " Tells the type system that {@code owner} may have a property named {@code propertyName}. This allows the registry to keep track of what types a property is defined upon.  This is NOT the same as saying that {@code owner} must have a property named type. ObjectType#hasProperty attempts to minimize false positives (\"if we're not sure, then don't type check this property\"). The type registry, on the other hand, should attempt to minimize false negatives (\"if this property is assigned anywhere in the program, it must show up in the type registry\"). ",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "JSTypeRegistry.resetForTypeCheck",
    "class_name": "com.google.javascript.rhino.jstype.JSTypeRegistry",
    "signature": "com.google.javascript.rhino.jstype.JSTypeRegistry.resetForTypeCheck()",
    "snippet": "  public void resetForTypeCheck() {\n    typesIndexedByProperty.clear();\n    initializeBuiltInTypes();\n    namesToTypes.clear();\n    namespaces.clear();\n    initializeRegistry();\n  }",
    "comment": " Reset to run the TypeCheck pass. ",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "NoObjectType.NoObjectType",
    "class_name": "com.google.javascript.rhino.jstype.NoObjectType",
    "signature": "com.google.javascript.rhino.jstype.NoObjectType.NoObjectType(JSTypeRegistry)",
    "snippet": "  NoObjectType(JSTypeRegistry registry) {\n    super(registry, null, null, null, null, null, null, true, true);\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "NoObjectType.getReturnType",
    "class_name": "com.google.javascript.rhino.jstype.NoObjectType",
    "signature": "com.google.javascript.rhino.jstype.NoObjectType.getReturnType()",
    "snippet": "  @Override\n  public JSType getReturnType() {\n    return this;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "NoObjectType.isNoObjectType",
    "class_name": "com.google.javascript.rhino.jstype.NoObjectType",
    "signature": "com.google.javascript.rhino.jstype.NoObjectType.isNoObjectType()",
    "snippet": "  @Override\n  public boolean isNoObjectType() {\n    return true;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "NoType.NoType",
    "class_name": "com.google.javascript.rhino.jstype.NoType",
    "signature": "com.google.javascript.rhino.jstype.NoType.NoType(JSTypeRegistry)",
    "snippet": "  NoType(JSTypeRegistry registry) {\n    super(registry);\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "NoType.isNoType",
    "class_name": "com.google.javascript.rhino.jstype.NoType",
    "signature": "com.google.javascript.rhino.jstype.NoType.isNoType()",
    "snippet": "  @Override\n  public boolean isNoType() {\n    return true;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "NullType.NullType",
    "class_name": "com.google.javascript.rhino.jstype.NullType",
    "signature": "com.google.javascript.rhino.jstype.NullType.NullType(JSTypeRegistry)",
    "snippet": "  NullType(JSTypeRegistry registry) {\n    super(registry);\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "NullType.toString",
    "class_name": "com.google.javascript.rhino.jstype.NullType",
    "signature": "com.google.javascript.rhino.jstype.NullType.toString()",
    "snippet": "  @Override\n  public String toString() {\n    return \"null\";\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "NullType.visit",
    "class_name": "com.google.javascript.rhino.jstype.NullType",
    "signature": "com.google.javascript.rhino.jstype.NullType.visit(Visitor)",
    "snippet": "  @Override\n  public <T> T visit(Visitor<T> visitor) {\n    return visitor.caseNullType();\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "NumberType.NumberType",
    "class_name": "com.google.javascript.rhino.jstype.NumberType",
    "signature": "com.google.javascript.rhino.jstype.NumberType.NumberType(JSTypeRegistry)",
    "snippet": "  NumberType(JSTypeRegistry registry) {\n    super(registry);\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "NumberType.toString",
    "class_name": "com.google.javascript.rhino.jstype.NumberType",
    "signature": "com.google.javascript.rhino.jstype.NumberType.toString()",
    "snippet": "  @Override\n  public String toString() {\n    return \"number\";\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "NumberType.visit",
    "class_name": "com.google.javascript.rhino.jstype.NumberType",
    "signature": "com.google.javascript.rhino.jstype.NumberType.visit(Visitor)",
    "snippet": "  @Override\n  public <T> T visit(Visitor<T> visitor) {\n    return visitor.caseNumberType();\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "ObjectType.ObjectType",
    "class_name": "com.google.javascript.rhino.jstype.ObjectType",
    "signature": "com.google.javascript.rhino.jstype.ObjectType.ObjectType(JSTypeRegistry)",
    "snippet": "  ObjectType(JSTypeRegistry registry) {\n    super(registry);\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "ObjectType.defineDeclaredProperty",
    "class_name": "com.google.javascript.rhino.jstype.ObjectType",
    "signature": "com.google.javascript.rhino.jstype.ObjectType.defineDeclaredProperty(String,JSType,boolean)",
    "snippet": "  public final boolean defineDeclaredProperty(String propertyName,\n      JSType type, boolean inExterns) {\n    // All property definitions go through this method\n    // or defineInferredProperty.\n    registry.registerPropertyOnType(propertyName, this);\n\n    return defineProperty(propertyName, type, false, inExterns);\n  }",
    "comment": " Defines a property whose type is synthesized (i.e. not inferred). @param propertyName the property's name @param type the type @param inExterns {@code true} if this property was defined in an externs file. TightenTypes assumes that any function passed to an externs property could be called, so setting this incorrectly could result in live code being removed. ",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "ObjectType.hasCachedValues",
    "class_name": "com.google.javascript.rhino.jstype.ObjectType",
    "signature": "com.google.javascript.rhino.jstype.ObjectType.hasCachedValues()",
    "snippet": "  public boolean hasCachedValues() {\n    return !unknown;\n  }",
    "comment": " Returns true if any cached valeus have been set for this type.  If true, then the prototype chain should not be changed, as it might invalidate the cached values. ",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "ObjectType.hasOwnDeclaredProperty",
    "class_name": "com.google.javascript.rhino.jstype.ObjectType",
    "signature": "com.google.javascript.rhino.jstype.ObjectType.hasOwnDeclaredProperty(String)",
    "snippet": "  boolean hasOwnDeclaredProperty(String name) {\n    return hasOwnProperty(name) && isPropertyTypeDeclared(name);\n  }",
    "comment": " Whether the given property is declared on this object. ",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "ObjectType.isUnknownType",
    "class_name": "com.google.javascript.rhino.jstype.ObjectType",
    "signature": "com.google.javascript.rhino.jstype.ObjectType.isUnknownType()",
    "snippet": "  @Override\n  public boolean isUnknownType() {\n    // If the object is unknown now, check the supertype again,\n    // because it might have been resolved since the last check.\n    if (unknown) {\n      ObjectType implicitProto = getImplicitPrototype();\n      if (implicitProto == null ||\n          implicitProto.isNativeObjectType()) {\n        unknown = false;\n      } else {\n        unknown = implicitProto.isUnknownType();\n      }\n    }\n    return unknown;\n  }",
    "comment": " We treat this as the unknown type if any of its implicit prototype properties is unknown. ",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "PrototypeObjectType.PrototypeObjectType",
    "class_name": "com.google.javascript.rhino.jstype.PrototypeObjectType",
    "signature": "com.google.javascript.rhino.jstype.PrototypeObjectType.PrototypeObjectType(JSTypeRegistry,String,ObjectType)",
    "snippet": "  PrototypeObjectType(JSTypeRegistry registry, String className,\n      ObjectType implicitPrototype) {\n    this(registry, className, implicitPrototype, false);\n  }",
    "comment": " Creates an object type.  @param className the name of the class.  May be {@code null} to denote an anonymous class.  @param implicitPrototype the implicit prototype (a.k.a. {@code [[Prototype]]}) as defined by ECMA-262. If the implicit prototype is {@code null} the implicit prototype will be set to the {@link JSTypeNative#OBJECT_TYPE}. ",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "PrototypeObjectType.PrototypeObjectType",
    "class_name": "com.google.javascript.rhino.jstype.PrototypeObjectType",
    "signature": "com.google.javascript.rhino.jstype.PrototypeObjectType.PrototypeObjectType(JSTypeRegistry,String,ObjectType,boolean)",
    "snippet": "  PrototypeObjectType(JSTypeRegistry registry, String className,\n      ObjectType implicitPrototype, boolean nativeType) {\n    super(registry);\n    this.properties = Maps.newHashMap();\n    this.className = className;\n    this.nativeType = nativeType;\n    if (nativeType) {\n      this.implicitPrototype = implicitPrototype;\n    } else if (implicitPrototype == null) {\n      this.implicitPrototype =\n          registry.getNativeObjectType(JSTypeNative.OBJECT_TYPE);\n    } else {\n      this.implicitPrototype = implicitPrototype;\n    }\n  }",
    "comment": " Creates an object type, allowing specification of the implicit prototype when creating native objects. ",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "PrototypeObjectType.defineProperty",
    "class_name": "com.google.javascript.rhino.jstype.PrototypeObjectType",
    "signature": "com.google.javascript.rhino.jstype.PrototypeObjectType.defineProperty(String,JSType,boolean,boolean)",
    "snippet": "  @Override\n  boolean defineProperty(String name, JSType type, boolean inferred,\n      boolean inExterns) {\n    if (hasOwnDeclaredProperty(name)) {\n      return false;\n    }\n    properties.put(name, new Property(type, inferred, inExterns));\n    return true;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "PrototypeObjectType.getConstructor",
    "class_name": "com.google.javascript.rhino.jstype.PrototypeObjectType",
    "signature": "com.google.javascript.rhino.jstype.PrototypeObjectType.getConstructor()",
    "snippet": "  @Override\n  public FunctionType getConstructor() {\n    return null;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "PrototypeObjectType.getImplicitPrototype",
    "class_name": "com.google.javascript.rhino.jstype.PrototypeObjectType",
    "signature": "com.google.javascript.rhino.jstype.PrototypeObjectType.getImplicitPrototype()",
    "snippet": "  @Override\n  public ObjectType getImplicitPrototype() {\n    return implicitPrototype;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "PrototypeObjectType.getName",
    "class_name": "com.google.javascript.rhino.jstype.PrototypeObjectType",
    "signature": "com.google.javascript.rhino.jstype.PrototypeObjectType.getName()",
    "snippet": "  @Override\n  public String getName() {\n    if (className != null) {\n      return className;\n    } else {\n      return \"{...}\";\n    }\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "PrototypeObjectType.hasCachedValues",
    "class_name": "com.google.javascript.rhino.jstype.PrototypeObjectType",
    "signature": "com.google.javascript.rhino.jstype.PrototypeObjectType.hasCachedValues()",
    "snippet": "  @Override\n  public boolean hasCachedValues() {\n    return super.hasCachedValues();\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "PrototypeObjectType.hasName",
    "class_name": "com.google.javascript.rhino.jstype.PrototypeObjectType",
    "signature": "com.google.javascript.rhino.jstype.PrototypeObjectType.hasName()",
    "snippet": "  @Override\n  public boolean hasName() {\n    return className != null;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "PrototypeObjectType.hasOwnProperty",
    "class_name": "com.google.javascript.rhino.jstype.PrototypeObjectType",
    "signature": "com.google.javascript.rhino.jstype.PrototypeObjectType.hasOwnProperty(String)",
    "snippet": "  @Override\n  public boolean hasOwnProperty(String propertyName) {\n    return properties.get(propertyName) != null;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "PrototypeObjectType.isNativeObjectType",
    "class_name": "com.google.javascript.rhino.jstype.PrototypeObjectType",
    "signature": "com.google.javascript.rhino.jstype.PrototypeObjectType.isNativeObjectType()",
    "snippet": "  @Override\n  public boolean isNativeObjectType() {\n    return nativeType;\n  }",
    "comment": "Whether this is a built-in object. */",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "PrototypeObjectType.isSubtype",
    "class_name": "com.google.javascript.rhino.jstype.PrototypeObjectType",
    "signature": "com.google.javascript.rhino.jstype.PrototypeObjectType.isSubtype(JSType)",
    "snippet": "  @Override\n  public boolean isSubtype(JSType that) {\n    if (JSType.isSubtype(this, that)) {\n      return true;\n    }\n    // record types\n    if (that instanceof RecordType) {\n      return RecordType.isSubtype(this, (RecordType) that);\n    }\n    // prototype based objects\n    if (that instanceof ObjectType) {\n      if (isUnknownType() || implicitPrototypeChainIsUnknown()) {\n        // If unsure, say 'yes', to avoid spurious warnings.\n        // TODO(user): resolve the prototype chain completely in all cases,\n        // to avoid guessing.\n        return true;\n      }\n      return this.isImplicitPrototype((ObjectType) that);\n    }\n    return false;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "PrototypeObjectType.setImplicitPrototype",
    "class_name": "com.google.javascript.rhino.jstype.PrototypeObjectType",
    "signature": "com.google.javascript.rhino.jstype.PrototypeObjectType.setImplicitPrototype(ObjectType)",
    "snippet": "  void setImplicitPrototype(ObjectType implicitPrototype) {\n    checkState(!hasCachedValues());\n    this.implicitPrototype = implicitPrototype;\n  }",
    "comment": " This should only be reset on the FunctionPrototypeType, only to fix an incorrectly established prototype chain due to the user having a mismatch in super class declaration, and only before properties on that type are processed. ",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "StringType.StringType",
    "class_name": "com.google.javascript.rhino.jstype.StringType",
    "signature": "com.google.javascript.rhino.jstype.StringType.StringType(JSTypeRegistry)",
    "snippet": "  StringType(JSTypeRegistry registry) {\n    super(registry);\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "StringType.toString",
    "class_name": "com.google.javascript.rhino.jstype.StringType",
    "signature": "com.google.javascript.rhino.jstype.StringType.toString()",
    "snippet": "  @Override\n  public String toString() {\n    return \"string\";\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "StringType.visit",
    "class_name": "com.google.javascript.rhino.jstype.StringType",
    "signature": "com.google.javascript.rhino.jstype.StringType.visit(Visitor)",
    "snippet": "  @Override\n  public <T> T visit(Visitor<T> visitor) {\n    return visitor.caseStringType();\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "UnionType.UnionType",
    "class_name": "com.google.javascript.rhino.jstype.UnionType",
    "signature": "com.google.javascript.rhino.jstype.UnionType.UnionType(JSTypeRegistry,Set)",
    "snippet": "  UnionType(JSTypeRegistry registry, Set<JSType> alternates) {\n    super(registry);\n    this.alternates = alternates;\n  }",
    "comment": " Creates a union type.  @param alternates the alternates of the union ",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "UnionTypeBuilder.UnionTypeBuilder",
    "class_name": "com.google.javascript.rhino.jstype.UnionTypeBuilder",
    "signature": "com.google.javascript.rhino.jstype.UnionTypeBuilder.UnionTypeBuilder(JSTypeRegistry)",
    "snippet": "  UnionTypeBuilder(JSTypeRegistry registry) {\n    this.registry = registry;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "UnionTypeBuilder.addAlternate",
    "class_name": "com.google.javascript.rhino.jstype.UnionTypeBuilder",
    "signature": "com.google.javascript.rhino.jstype.UnionTypeBuilder.addAlternate(JSType)",
    "snippet": "  UnionTypeBuilder addAlternate(JSType alternate) {\n    // build() returns the bottom type by default, so we can\n    // just bail out early here.\n    if (alternate.isNoType()) {\n      return this;\n    }\n\n    isAllType = isAllType || alternate.isAllType();\n\n    boolean isAlternateUnknown = alternate instanceof UnknownType;\n    isNativeUnknownType = isNativeUnknownType || isAlternateUnknown;\n    if (isAlternateUnknown) {\n      areAllUnknownsChecked = areAllUnknownsChecked &&\n          alternate.isCheckedUnknownType();\n    }\n    if (!isAllType && !isNativeUnknownType) {\n      if (alternate instanceof UnionType) {\n        UnionType union = (UnionType) alternate;\n        for (JSType unionAlt : union.getAlternates()) {\n          addAlternate(unionAlt);\n        }\n      } else {\n        if (!alternate.isUnknownType()) {\n          Iterator<JSType> it = alternates.iterator();\n          while (it.hasNext()) {\n            JSType current = it.next();\n            if (!current.isUnknownType()) {\n              if (alternate.isSubtype(current)) {\n                // Alternate is unnecessary.\n                return this;\n              } else if (current.isSubtype(alternate)) {\n                // Alternate makes current obsolete\n                it.remove();\n              }\n            }\n          }\n        }\n        alternates.add(alternate);\n        result = null; // invalidate the memoized result\n      }\n    } else {\n      result = null;\n    }\n    return this;\n  }",
    "comment": " Adds an alternate to the union type under construction. Returns this for easy chaining. ",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "UnionTypeBuilder.build",
    "class_name": "com.google.javascript.rhino.jstype.UnionTypeBuilder",
    "signature": "com.google.javascript.rhino.jstype.UnionTypeBuilder.build()",
    "snippet": "  JSType build() {\n    if (result == null) {\n      if (isAllType) {\n        result = registry.getNativeType(ALL_TYPE);\n      } else if (isNativeUnknownType) {\n        if (areAllUnknownsChecked) {\n          result = registry.getNativeType(CHECKED_UNKNOWN_TYPE);\n        } else {\n          result = registry.getNativeType(UNKNOWN_TYPE);\n        }\n      } else {\n        Set<JSType> alternateSet = Sets.newUnmodifiableHashSet(alternates);\n        int size = alternateSet.size();\n        if (size > MAX_UNION_SIZE) {\n          result = registry.getNativeType(UNKNOWN_TYPE);\n        } else {\n          if (size > 1) {\n            result = new UnionType(registry, alternateSet);\n          } else if (size == 1) {\n            result = alternates.iterator().next();\n          } else {\n            result = registry.getNativeType(NO_TYPE);\n          }\n        }\n      }\n    }\n    return result;\n  }",
    "comment": " Creates a union. @return A UnionType if it has two or more alternates, the only alternate if it has one and otherwise {@code NO_TYPE}. ",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "UnknownType.UnknownType",
    "class_name": "com.google.javascript.rhino.jstype.UnknownType",
    "signature": "com.google.javascript.rhino.jstype.UnknownType.UnknownType(JSTypeRegistry,boolean)",
    "snippet": "  UnknownType(JSTypeRegistry registry, boolean isChecked) {\n    super(registry);\n    this.isChecked = isChecked;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "ValueType.ValueType",
    "class_name": "com.google.javascript.rhino.jstype.ValueType",
    "signature": "com.google.javascript.rhino.jstype.ValueType.ValueType(JSTypeRegistry)",
    "snippet": "  ValueType(JSTypeRegistry registry) {\n    super(registry);\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "ValueType.isSubtype",
    "class_name": "com.google.javascript.rhino.jstype.ValueType",
    "signature": "com.google.javascript.rhino.jstype.ValueType.isSubtype(JSType)",
    "snippet": "  @Override\n  public boolean isSubtype(JSType that) {\n    return JSType.isSubtype(this, that);\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "VoidType.VoidType",
    "class_name": "com.google.javascript.rhino.jstype.VoidType",
    "signature": "com.google.javascript.rhino.jstype.VoidType.VoidType(JSTypeRegistry)",
    "snippet": "  VoidType(JSTypeRegistry registry) {\n    super(registry);\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "VoidType.toString",
    "class_name": "com.google.javascript.rhino.jstype.VoidType",
    "signature": "com.google.javascript.rhino.jstype.VoidType.toString()",
    "snippet": "  @Override\n  public String toString() {\n    return \"undefined\";\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  }
]