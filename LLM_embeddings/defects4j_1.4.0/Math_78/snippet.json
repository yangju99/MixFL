[
  {
    "name": "ConvergingAlgorithmImpl.ConvergingAlgorithmImpl",
    "class_name": "org.apache.commons.math.ConvergingAlgorithmImpl",
    "signature": "org.apache.commons.math.ConvergingAlgorithmImpl.ConvergingAlgorithmImpl(int,double)",
    "snippet": "    protected ConvergingAlgorithmImpl(final int defaultMaximalIterationCount,\n                                      final double defaultAbsoluteAccuracy) {\n        this.defaultAbsoluteAccuracy = defaultAbsoluteAccuracy;\n        this.defaultRelativeAccuracy = 1.0e-14;\n        this.absoluteAccuracy = defaultAbsoluteAccuracy;\n        this.relativeAccuracy = defaultRelativeAccuracy;\n        this.defaultMaximalIterationCount = defaultMaximalIterationCount;\n        this.maximalIterationCount = defaultMaximalIterationCount;\n        this.iterationCount = 0;\n    }",
    "comment": " Construct an algorithm with given iteration count and accuracy.  @param defaultAbsoluteAccuracy maximum absolute error @param defaultMaximalIterationCount maximum number of iterations @throws IllegalArgumentException if f is null or the defaultAbsoluteAccuracy is not valid ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "ConvergingAlgorithmImpl.setAbsoluteAccuracy",
    "class_name": "org.apache.commons.math.ConvergingAlgorithmImpl",
    "signature": "org.apache.commons.math.ConvergingAlgorithmImpl.setAbsoluteAccuracy(double)",
    "snippet": "    public void setAbsoluteAccuracy(double accuracy) {\n        absoluteAccuracy = accuracy;\n    }",
    "comment": "{@inheritDoc} */",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "ConvergingAlgorithmImpl.setMaximalIterationCount",
    "class_name": "org.apache.commons.math.ConvergingAlgorithmImpl",
    "signature": "org.apache.commons.math.ConvergingAlgorithmImpl.setMaximalIterationCount(int)",
    "snippet": "    public void setMaximalIterationCount(int count) {\n        maximalIterationCount = count;\n    }",
    "comment": "{@inheritDoc} */",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "MathRuntimeException.buildMessage",
    "class_name": "org.apache.commons.math.MathRuntimeException",
    "signature": "org.apache.commons.math.MathRuntimeException.buildMessage(Locale,String,Object[])",
    "snippet": "    private static String buildMessage(final Locale locale, final String pattern,\n                                       final Object ... arguments) {\n        return (pattern == null) ? \"\" : new MessageFormat(translate(pattern, locale), locale).format(arguments);\n    }",
    "comment": " Builds a message string by from a pattern and its arguments. @param locale Locale in which the message should be translated @param pattern format specifier @param arguments format arguments @return a message string ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "MathRuntimeException.createIllegalArgumentException",
    "class_name": "org.apache.commons.math.MathRuntimeException",
    "signature": "org.apache.commons.math.MathRuntimeException.createIllegalArgumentException(String,Object[])",
    "snippet": "    public static IllegalArgumentException createIllegalArgumentException(final String pattern,\n                                                                          final Object ... arguments) {\n        return new IllegalArgumentException() {\n\n            /** Serializable version identifier. */\n            private static final long serialVersionUID = -6555453980658317913L;\n\n            /** {@inheritDoc} */\n            @Override\n            public String getMessage() {\n                return buildMessage(Locale.US, pattern, arguments);\n            }\n\n            /** {@inheritDoc} */\n            @Override\n            public String getLocalizedMessage() {\n                return buildMessage(Locale.getDefault(), pattern, arguments);\n            }\n\n        };\n    }",
    "comment": " Constructs a new <code>IllegalArgumentException</code> with specified formatted detail message. Message formatting is delegated to {@link java.text.MessageFormat}. @param pattern format specifier @param arguments format arguments @return built exception ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "MathRuntimeException.translate",
    "class_name": "org.apache.commons.math.MathRuntimeException",
    "signature": "org.apache.commons.math.MathRuntimeException.translate(String,Locale)",
    "snippet": "    private static String translate(final String s, final Locale locale) {\n        try {\n            ResourceBundle bundle =\n                    ResourceBundle.getBundle(\"org.apache.commons.math.MessagesResources\", locale);\n            if (bundle.getLocale().getLanguage().equals(locale.getLanguage())) {\n                // the value of the resource is the translated string\n                return bundle.getString(s);\n            }\n\n        } catch (MissingResourceException mre) {\n            // do nothing here\n        }\n\n        // the locale is not supported or the resource is unknown\n        // don't translate and fall back to using the string as is\n        return s;\n\n    }",
    "comment": " Translate a string to a given locale. @param s string to translate @param locale locale into which to translate the string @return translated string or original string for unsupported locales or unknown strings ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "BrentSolver.BrentSolver",
    "class_name": "org.apache.commons.math.analysis.solvers.BrentSolver",
    "signature": "org.apache.commons.math.analysis.solvers.BrentSolver.BrentSolver()",
    "snippet": "    public BrentSolver() {\n        super(100, 1E-6);\n    }",
    "comment": " Construct a solver. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "BrentSolver.solve",
    "class_name": "org.apache.commons.math.analysis.solvers.BrentSolver",
    "signature": "org.apache.commons.math.analysis.solvers.BrentSolver.solve(UnivariateRealFunction,double,double)",
    "snippet": "    public double solve(final UnivariateRealFunction f,\n                        final double min, final double max)\n        throws MaxIterationsExceededException,\n        FunctionEvaluationException {\n\n        clearResult();\n        verifyInterval(min, max);\n\n        double ret = Double.NaN;\n\n        double yMin = f.value(min);\n        double yMax = f.value(max);\n\n        // Verify bracketing\n        double sign = yMin * yMax;\n        if (sign > 0) {\n            // check if either value is close to a zero\n            if (Math.abs(yMin) <= functionValueAccuracy) {\n                setResult(min, 0);\n                ret = min;\n            } else if (Math.abs(yMax) <= functionValueAccuracy) {\n                setResult(max, 0);\n                ret = max;\n            } else {\n                // neither value is close to zero and min and max do not bracket root.\n                throw MathRuntimeException.createIllegalArgumentException(\n                        \"function values at endpoints do not have different signs.  \" +\n                        \"Endpoints: [{0}, {1}], Values: [{2}, {3}]\",\n                        min, max, yMin, yMax);\n            }\n        } else if (sign < 0){\n            // solve using only the first endpoint as initial guess\n            ret = solve(f, min, yMin, max, yMax, min, yMin);\n        } else {\n            // either min or max is a root\n            if (yMin == 0.0) {\n                ret = min;\n            } else {\n                ret = max;\n            }\n        }\n\n        return ret;\n    }",
    "comment": " Find a zero in the given interval. <p> Requires that the values of the function at the endpoints have opposite signs. An <code>IllegalArgumentException</code> is thrown if this is not the case.</p>  @param f the function to solve @param min the lower bound for the interval. @param max the upper bound for the interval. @return the value where the function is zero @throws MaxIterationsExceededException if the maximum iteration count is exceeded @throws FunctionEvaluationException if an error occurs evaluating the function @throws IllegalArgumentException if min is not less than max or the signs of the values of the function at the endpoints are not opposites ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "BrentSolver.solve",
    "class_name": "org.apache.commons.math.analysis.solvers.BrentSolver",
    "signature": "org.apache.commons.math.analysis.solvers.BrentSolver.solve(UnivariateRealFunction,double,double,double,double,double,double)",
    "snippet": "    private double solve(final UnivariateRealFunction f,\n                         double x0, double y0,\n                         double x1, double y1,\n                         double x2, double y2)\n    throws MaxIterationsExceededException, FunctionEvaluationException {\n\n        double delta = x1 - x0;\n        double oldDelta = delta;\n\n        int i = 0;\n        while (i < maximalIterationCount) {\n            if (Math.abs(y2) < Math.abs(y1)) {\n                // use the bracket point if is better than last approximation\n                x0 = x1;\n                x1 = x2;\n                x2 = x0;\n                y0 = y1;\n                y1 = y2;\n                y2 = y0;\n            }\n            if (Math.abs(y1) <= functionValueAccuracy) {\n                // Avoid division by very small values. Assume\n                // the iteration has converged (the problem may\n                // still be ill conditioned)\n                setResult(x1, i);\n                return result;\n            }\n            double dx = x2 - x1;\n            double tolerance =\n                Math.max(relativeAccuracy * Math.abs(x1), absoluteAccuracy);\n            if (Math.abs(dx) <= tolerance) {\n                setResult(x1, i);\n                return result;\n            }\n            if ((Math.abs(oldDelta) < tolerance) ||\n                    (Math.abs(y0) <= Math.abs(y1))) {\n                // Force bisection.\n                delta = 0.5 * dx;\n                oldDelta = delta;\n            } else {\n                double r3 = y1 / y0;\n                double p;\n                double p1;\n                // the equality test (x0 == x2) is intentional,\n                // it is part of the original Brent's method,\n                // it should NOT be replaced by proximity test\n                if (x0 == x2) {\n                    // Linear interpolation.\n                    p = dx * r3;\n                    p1 = 1.0 - r3;\n                } else {\n                    // Inverse quadratic interpolation.\n                    double r1 = y0 / y2;\n                    double r2 = y1 / y2;\n                    p = r3 * (dx * r1 * (r1 - r2) - (x1 - x0) * (r2 - 1.0));\n                    p1 = (r1 - 1.0) * (r2 - 1.0) * (r3 - 1.0);\n                }\n                if (p > 0.0) {\n                    p1 = -p1;\n                } else {\n                    p = -p;\n                }\n                if (2.0 * p >= 1.5 * dx * p1 - Math.abs(tolerance * p1) ||\n                        p >= Math.abs(0.5 * oldDelta * p1)) {\n                    // Inverse quadratic interpolation gives a value\n                    // in the wrong direction, or progress is slow.\n                    // Fall back to bisection.\n                    delta = 0.5 * dx;\n                    oldDelta = delta;\n                } else {\n                    oldDelta = delta;\n                    delta = p / p1;\n                }\n            }\n            // Save old X1, Y1\n            x0 = x1;\n            y0 = y1;\n            // Compute new X1, Y1\n            if (Math.abs(delta) > tolerance) {\n                x1 = x1 + delta;\n            } else if (dx > 0.0) {\n                x1 = x1 + 0.5 * tolerance;\n            } else if (dx <= 0.0) {\n                x1 = x1 - 0.5 * tolerance;\n            }\n            y1 = f.value(x1);\n            if ((y1 > 0) == (y2 > 0)) {\n                x2 = x0;\n                y2 = y0;\n                delta = x1 - x0;\n                oldDelta = delta;\n            }\n            i++;\n        }\n        throw new MaxIterationsExceededException(maximalIterationCount);\n    }",
    "comment": " Find a zero starting search according to the three provided points. @param f the function to solve @param x0 old approximation for the root @param y0 function value at the approximation for the root @param x1 last calculated approximation for the root @param y1 function value at the last calculated approximation for the root @param x2 bracket point (must be set to x0 if no bracket point is known, this will force starting with linear interpolation) @param y2 function value at the bracket point. @return the value where the function is zero @throws MaxIterationsExceededException if the maximum iteration count is exceeded @throws FunctionEvaluationException if an error occurs evaluating the function ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "UnivariateRealSolverImpl.UnivariateRealSolverImpl",
    "class_name": "org.apache.commons.math.analysis.solvers.UnivariateRealSolverImpl",
    "signature": "org.apache.commons.math.analysis.solvers.UnivariateRealSolverImpl.UnivariateRealSolverImpl(int,double)",
    "snippet": "    protected UnivariateRealSolverImpl(final int defaultMaximalIterationCount,\n                                       final double defaultAbsoluteAccuracy) {\n        super(defaultMaximalIterationCount, defaultAbsoluteAccuracy);\n        this.defaultFunctionValueAccuracy = 1.0e-15;\n        this.functionValueAccuracy = defaultFunctionValueAccuracy;\n    }",
    "comment": " Construct a solver with given iteration count and accuracy.  @param defaultAbsoluteAccuracy maximum absolute error @param defaultMaximalIterationCount maximum number of iterations @throws IllegalArgumentException if f is null or the defaultAbsoluteAccuracy is not valid ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "UnivariateRealSolverImpl.clearResult",
    "class_name": "org.apache.commons.math.analysis.solvers.UnivariateRealSolverImpl",
    "signature": "org.apache.commons.math.analysis.solvers.UnivariateRealSolverImpl.clearResult()",
    "snippet": "    protected final void clearResult() {\n        this.iterationCount = 0;\n        this.resultComputed = false;\n    }",
    "comment": " Convenience function for implementations. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "UnivariateRealSolverImpl.setResult",
    "class_name": "org.apache.commons.math.analysis.solvers.UnivariateRealSolverImpl",
    "signature": "org.apache.commons.math.analysis.solvers.UnivariateRealSolverImpl.setResult(double,int)",
    "snippet": "    protected final void setResult(final double newResult, final int iterationCount) {\n        this.result         = newResult;\n        this.iterationCount = iterationCount;\n        this.resultComputed = true;\n    }",
    "comment": " Convenience function for implementations.  @param newResult the result to set @param iterationCount the iteration count to set ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "UnivariateRealSolverImpl.verifyInterval",
    "class_name": "org.apache.commons.math.analysis.solvers.UnivariateRealSolverImpl",
    "signature": "org.apache.commons.math.analysis.solvers.UnivariateRealSolverImpl.verifyInterval(double,double)",
    "snippet": "    protected void verifyInterval(final double lower, final double upper) {\n        if (lower >= upper) {\n            throw MathRuntimeException.createIllegalArgumentException(\n                    \"endpoints do not specify an interval: [{0}, {1}]\",\n                    lower, upper);\n        }\n    }",
    "comment": " Verifies that the endpoints specify an interval, throws IllegalArgumentException if not  @param lower  lower endpoint @param upper upper endpoint @throws IllegalArgumentException ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "EventState.EventState",
    "class_name": "org.apache.commons.math.ode.events.EventState",
    "signature": "org.apache.commons.math.ode.events.EventState.EventState(EventHandler,double,double,int)",
    "snippet": "    public EventState(final EventHandler handler, final double maxCheckInterval,\n                      final double convergence, final int maxIterationCount) {\n        this.handler           = handler;\n        this.maxCheckInterval  = maxCheckInterval;\n        this.convergence       = Math.abs(convergence);\n        this.maxIterationCount = maxIterationCount;\n\n        // some dummy values ...\n        t0                = Double.NaN;\n        g0                = Double.NaN;\n        g0Positive        = true;\n        pendingEvent      = false;\n        pendingEventTime  = Double.NaN;\n        previousEventTime = Double.NaN;\n        increasing        = true;\n        nextAction        = EventHandler.CONTINUE;\n\n    }",
    "comment": "Simple constructor. @param handler event handler @param maxCheckInterval maximal time interval between switching function checks (this interval prevents missing sign changes in case the integration steps becomes very large) @param convergence convergence threshold in the event time search @param maxIterationCount upper limit of the iteration count in the event time search ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "EventState.evaluateStep",
    "class_name": "org.apache.commons.math.ode.events.EventState",
    "signature": "org.apache.commons.math.ode.events.EventState.evaluateStep(StepInterpolator)",
    "snippet": "    public boolean evaluateStep(final StepInterpolator interpolator)\n        throws DerivativeException, EventException, ConvergenceException {\n\n        try {\n\n            forward = interpolator.isForward();\n            final double t1 = interpolator.getCurrentTime();\n            final int    n  = Math.max(1, (int) Math.ceil(Math.abs(t1 - t0) / maxCheckInterval));\n            final double h  = (t1 - t0) / n;\n\n            double ta = t0;\n            double ga = g0;\n            double tb = t0 + (interpolator.isForward() ? convergence : -convergence);\n            for (int i = 0; i < n; ++i) {\n\n                // evaluate handler value at the end of the substep\n                tb += h;\n                interpolator.setInterpolatedTime(tb);\n                final double gb = handler.g(tb, interpolator.getInterpolatedState());\n\n                // check events occurrence\n                if (g0Positive ^ (gb >= 0)) {\n                    // there is a sign change: an event is expected during this step\n\n                        // this is a corner case:\n                        // - there was an event near ta,\n                        // - there is another event between ta and tb\n                        // - when ta was computed, convergence was reached on the \"wrong side\" of the interval\n                        // this implies that the real sign of ga is the same as gb, so we need to slightly\n                        // shift ta to make sure ga and gb get opposite signs and the solver won't complain\n                        // about bracketing\n                            // this should never happen\n                         \n                    // variation direction, with respect to the integration direction\n                    increasing = gb >= ga;\n\n                    final UnivariateRealFunction f = new UnivariateRealFunction() {\n                        public double value(final double t) throws FunctionEvaluationException {\n                            try {\n                                interpolator.setInterpolatedTime(t);\n                                return handler.g(t, interpolator.getInterpolatedState());\n                            } catch (DerivativeException e) {\n                                throw new FunctionEvaluationException(e, t);\n                            } catch (EventException e) {\n                                throw new FunctionEvaluationException(e, t);\n                            }\n                        }\n                    };\n                    final BrentSolver solver = new BrentSolver();\n                    solver.setAbsoluteAccuracy(convergence);\n                    solver.setMaximalIterationCount(maxIterationCount);\n                    final double root = (ta <= tb) ? solver.solve(f, ta, tb) : solver.solve(f, tb, ta);\n                    if ((Math.abs(root - ta) <= convergence) &&\n                         (Math.abs(root - previousEventTime) <= convergence)) {\n                        // we have either found nothing or found (again ?) a past event, we simply ignore it\n                        ta = tb;\n                        ga = gb;\n                    } else if (Double.isNaN(previousEventTime) ||\n                               (Math.abs(previousEventTime - root) > convergence)) {\n                        pendingEventTime = root;\n                        if (pendingEvent && (Math.abs(t1 - pendingEventTime) <= convergence)) {\n                            // we were already waiting for this event which was\n                            // found during a previous call for a step that was\n                            // rejected, this step must now be accepted since it\n                            // properly ends exactly at the event occurrence\n                            return false;\n                        }\n                        // either we were not waiting for the event or it has\n                        // moved in such a way the step cannot be accepted\n                        pendingEvent = true;\n                        return true;\n                    }\n\n                } else {\n                    // no sign change: there is no event for now\n                    ta = tb;\n                    ga = gb;\n                }\n\n            }\n\n            // no event during the whole step\n            pendingEvent     = false;\n            pendingEventTime = Double.NaN;\n            return false;\n\n        } catch (FunctionEvaluationException e) {\n            final Throwable cause = e.getCause();\n            if ((cause != null) && (cause instanceof DerivativeException)) {\n                throw (DerivativeException) cause;\n            } else if ((cause != null) && (cause instanceof EventException)) {\n                throw (EventException) cause;\n            }\n            throw new EventException(e);\n        }\n\n    }",
    "comment": "Evaluate the impact of the proposed step on the event handler. @param interpolator step interpolator for the proposed step @return true if the event handler triggers an event before the end of the proposed step (this implies the step should be rejected) @exception DerivativeException if the interpolator fails to compute the switching function somewhere within the step @exception EventException if the switching function cannot be evaluated @exception ConvergenceException if an event cannot be located ",
    "is_bug": true,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "EventState.getEventTime",
    "class_name": "org.apache.commons.math.ode.events.EventState",
    "signature": "org.apache.commons.math.ode.events.EventState.getEventTime()",
    "snippet": "    public double getEventTime() {\n        return pendingEventTime;\n    }",
    "comment": "Get the occurrence time of the event triggered in the current step. @return occurrence time of the event triggered in the current step. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "EventState.reinitializeBegin",
    "class_name": "org.apache.commons.math.ode.events.EventState",
    "signature": "org.apache.commons.math.ode.events.EventState.reinitializeBegin(double,double[])",
    "snippet": "    public void reinitializeBegin(final double tStart, final double[] yStart)\n        throws EventException {\n        t0 = tStart;\n        g0 = handler.g(tStart, yStart);\n        g0Positive = g0 >= 0;\n    }",
    "comment": "Reinitialize the beginning of the step. @param tStart value of the independent <i>time</i> variable at the beginning of the step @param yStart array containing the current value of the state vector at the beginning of the step @exception EventException if the event handler value cannot be evaluated at the beginning of the step ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "EventState.stepAccepted",
    "class_name": "org.apache.commons.math.ode.events.EventState",
    "signature": "org.apache.commons.math.ode.events.EventState.stepAccepted(double,double[])",
    "snippet": "    public void stepAccepted(final double t, final double[] y)\n        throws EventException {\n\n        t0 = t;\n        g0 = handler.g(t, y);\n\n        if (pendingEvent) {\n            // force the sign to its value \"just after the event\"\n            previousEventTime = t;\n            g0Positive        = increasing;\n            nextAction        = handler.eventOccurred(t, y, !(increasing ^ forward));\n        } else {\n            g0Positive = g0 >= 0;\n            nextAction = EventHandler.CONTINUE;\n        }\n    }",
    "comment": "Acknowledge the fact the step has been accepted by the integrator. @param t value of the independent <i>time</i> variable at the end of the step @param y array containing the current value of the state vector at the end of the step @exception EventException if the value of the event handler cannot be evaluated ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "AbstractStepInterpolator.AbstractStepInterpolator",
    "class_name": "org.apache.commons.math.ode.sampling.AbstractStepInterpolator",
    "signature": "org.apache.commons.math.ode.sampling.AbstractStepInterpolator.AbstractStepInterpolator(double[],boolean)",
    "snippet": "  protected AbstractStepInterpolator(final double[] y, final boolean forward) {\n\n    previousTime      = Double.NaN;\n    currentTime       = Double.NaN;\n    h                 = Double.NaN;\n    interpolatedTime  = Double.NaN;\n\n    currentState            = y;\n    interpolatedState       = new double[y.length];\n    interpolatedDerivatives = new double[y.length];\n\n    finalized         = false;\n    this.forward      = forward;\n    this.dirtyState   = true;\n\n  }",
    "comment": "Simple constructor. @param y reference to the integrator array holding the state at the end of the step @param forward integration direction indicator ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "AbstractStepInterpolator.getCurrentTime",
    "class_name": "org.apache.commons.math.ode.sampling.AbstractStepInterpolator",
    "signature": "org.apache.commons.math.ode.sampling.AbstractStepInterpolator.getCurrentTime()",
    "snippet": "  public double getCurrentTime() {\n    return currentTime;\n  }",
    "comment": "{@inheritDoc} */",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "AbstractStepInterpolator.getInterpolatedState",
    "class_name": "org.apache.commons.math.ode.sampling.AbstractStepInterpolator",
    "signature": "org.apache.commons.math.ode.sampling.AbstractStepInterpolator.getInterpolatedState()",
    "snippet": "  public double[] getInterpolatedState() throws DerivativeException {\n\n      // lazy evaluation of the state\n      if (dirtyState) {\n          final double oneMinusThetaH = currentTime - interpolatedTime;\n          final double theta = (h == 0) ? 0 : (h - oneMinusThetaH) / h;\n          computeInterpolatedStateAndDerivatives(theta, oneMinusThetaH);\n          dirtyState = false;\n      }\n\n      return interpolatedState;\n\n  }",
    "comment": "{@inheritDoc} */",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "AbstractStepInterpolator.isForward",
    "class_name": "org.apache.commons.math.ode.sampling.AbstractStepInterpolator",
    "signature": "org.apache.commons.math.ode.sampling.AbstractStepInterpolator.isForward()",
    "snippet": "  public boolean isForward() {\n    return forward;\n  }",
    "comment": "{@inheritDoc} */",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "AbstractStepInterpolator.setInterpolatedTime",
    "class_name": "org.apache.commons.math.ode.sampling.AbstractStepInterpolator",
    "signature": "org.apache.commons.math.ode.sampling.AbstractStepInterpolator.setInterpolatedTime(double)",
    "snippet": "  public void setInterpolatedTime(final double time) {\n      interpolatedTime = time;\n      dirtyState       = true;\n  }",
    "comment": "{@inheritDoc} */",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "AbstractStepInterpolator.shift",
    "class_name": "org.apache.commons.math.ode.sampling.AbstractStepInterpolator",
    "signature": "org.apache.commons.math.ode.sampling.AbstractStepInterpolator.shift()",
    "snippet": "  public void shift() {\n    previousTime = currentTime;\n  }",
    "comment": "Shift one step forward. Copy the current time into the previous time, hence preparing the interpolator for future calls to {@link #storeTime storeTime} ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "AbstractStepInterpolator.storeTime",
    "class_name": "org.apache.commons.math.ode.sampling.AbstractStepInterpolator",
    "signature": "org.apache.commons.math.ode.sampling.AbstractStepInterpolator.storeTime(double)",
    "snippet": "  public void storeTime(final double t) {\n\n    currentTime = t;\n    h           = currentTime - previousTime;\n    setInterpolatedTime(t);\n\n    // the step is not finalized anymore\n    finalized  = false;\n\n  }",
    "comment": "Store the current step time. @param t current time ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "DummyStepInterpolator.DummyStepInterpolator",
    "class_name": "org.apache.commons.math.ode.sampling.DummyStepInterpolator",
    "signature": "org.apache.commons.math.ode.sampling.DummyStepInterpolator.DummyStepInterpolator(double[],boolean)",
    "snippet": "  public DummyStepInterpolator(final double[] y, final boolean forward) {\n    super(y, forward);\n  }",
    "comment": "Simple constructor. @param y reference to the integrator array holding the state at the end of the step @param forward integration direction indicator ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "DummyStepInterpolator.computeInterpolatedStateAndDerivatives",
    "class_name": "org.apache.commons.math.ode.sampling.DummyStepInterpolator",
    "signature": "org.apache.commons.math.ode.sampling.DummyStepInterpolator.computeInterpolatedStateAndDerivatives(double,double)",
    "snippet": "  @Override\n  protected void computeInterpolatedStateAndDerivatives(final double theta, final double oneMinusThetaH)\n    throws DerivativeException {\n      System.arraycopy(currentState, 0, interpolatedState, 0, currentState.length);\n  }",
    "comment": "Compute the state at the interpolated time. In this class, this method does nothing: the interpolated state is always the state at the end of the current step. @param theta normalized interpolation abscissa within the step (theta is zero at the previous time step and one at the current time step) @param oneMinusThetaH time gap between the interpolated time and the current time @throws DerivativeException this exception is propagated to the caller if the underlying user function triggers one ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  }
]