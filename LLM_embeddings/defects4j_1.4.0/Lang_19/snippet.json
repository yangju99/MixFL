[
  {
    "name": "CharSequenceTranslator.translate",
    "class_name": "org.apache.commons.lang3.text.translate.CharSequenceTranslator",
    "signature": "org.apache.commons.lang3.text.translate.CharSequenceTranslator.translate(CharSequence)",
    "snippet": "    public final String translate(CharSequence input) {\n        if (input == null) {\n            return null;\n        }\n        try {\n            StringWriter writer = new StringWriter(input.length() * 2);\n            translate(input, writer);\n            return writer.toString();\n        } catch (IOException ioe) {\n            // this should never ever happen while writing to a StringWriter\n            throw new RuntimeException(ioe);\n        }\n    }",
    "comment": " Helper for non-Writer usage.  @param input CharSequence to be translated @return String output of translation ",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "CharSequenceTranslator.translate",
    "class_name": "org.apache.commons.lang3.text.translate.CharSequenceTranslator",
    "signature": "org.apache.commons.lang3.text.translate.CharSequenceTranslator.translate(CharSequence,Writer)",
    "snippet": "    public final void translate(CharSequence input, Writer out) throws IOException {\n        if (out == null) {\n            throw new IllegalArgumentException(\"The Writer must not be null\");\n        }\n        if (input == null) {\n            return;\n        }\n        int sz = Character.codePointCount(input, 0, input.length());\n        for (int i = 0; i < sz; i++) {\n\n            // consumed is the number of codepoints consumed\n            int consumed = translate(input, i, out);\n\n            if (consumed == 0) {\n                out.write(Character.toChars(Character.codePointAt(input, i)));\n            } else {\n                // contract with translators is that they have to understand codepoints \n                // and they just took care of a surrogate pair\n                for (int j = 0; j < consumed; j++) {\n                    if (i < sz - 2) {\n                        i += Character.charCount(Character.codePointAt(input, i));\n                    } else {\n                        // If the String ends with a high surrogate, just add the 1 and don't worry about such things\n                        i++;\n                    }\n                }\n                // for loop will increment 1 anyway, so remove 1 to account for that\n                i--;\n            }\n        }\n    }",
    "comment": " Translate an input onto a Writer. This is intentionally final as its algorithm is  tightly coupled with the abstract method of this class.   @param input CharSequence that is being translated @param out Writer to translate the text to @throws IOException if and only if the Writer produces an IOException ",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "NumericEntityUnescaper.translate",
    "class_name": "org.apache.commons.lang3.text.translate.NumericEntityUnescaper",
    "signature": "org.apache.commons.lang3.text.translate.NumericEntityUnescaper.translate(CharSequence,int,Writer)",
    "snippet": "    @Override\n    public int translate(CharSequence input, int index, Writer out) throws IOException {\n        int seqEnd = input.length();\n        // Uses -2 to ensure there is something after the &#\n        if(input.charAt(index) == '&' && index < seqEnd - 1 && input.charAt(index + 1) == '#') {\n            int start = index + 2;\n            boolean isHex = false;\n\n            char firstChar = input.charAt(start);\n            if(firstChar == 'x' || firstChar == 'X') {\n                start++;\n                isHex = true;\n\n                // Check there's more than just an x after the &#\n            }\n\n            int end = start;\n            // Note that this supports character codes without a ; on the end\n            while(input.charAt(end) != ';') \n            {\n                end++;\n            }\n\n            int entityValue;\n            try {\n                if(isHex) {\n                    entityValue = Integer.parseInt(input.subSequence(start, end).toString(), 16);\n                } else {\n                    entityValue = Integer.parseInt(input.subSequence(start, end).toString(), 10);\n                }\n            } catch(NumberFormatException nfe) {\n            System.err.println(\"FAIL: \" + input.subSequence(start, end) + \"[\" + start +\"][\"+ end +\"]\");\n                return 0;\n            }\n\n            if(entityValue > 0xFFFF) {\n                char[] chrs = Character.toChars(entityValue);\n                out.write(chrs[0]);\n                out.write(chrs[1]);\n            } else {\n                out.write(entityValue);\n            }\n\n\n            return 2 + (end - start) + (isHex ? 1 : 0) + 1;\n        }\n        return 0;\n    }",
    "comment": " {@inheritDoc} ",
    "is_bug": true,
    "failing_test_cases": 2,
    "buggy_methods": 1
  }
]