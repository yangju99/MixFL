[
  {
    "name": "Sinc.Sinc",
    "class_name": "org.apache.commons.math3.analysis.function.Sinc",
    "signature": "org.apache.commons.math3.analysis.function.Sinc.Sinc()",
    "snippet": "    public Sinc() {\n        this(false);\n    }",
    "comment": " The sinc function, {@code sin(x) / x}. ",
    "is_bug": false,
    "failing_test_cases": 28,
    "buggy_methods": 7
  },
  {
    "name": "Sinc.Sinc",
    "class_name": "org.apache.commons.math3.analysis.function.Sinc",
    "signature": "org.apache.commons.math3.analysis.function.Sinc.Sinc(boolean)",
    "snippet": "    public Sinc(boolean normalized) {\n        this.normalized = normalized;\n    }",
    "comment": " Instantiates the sinc function.  @param normalized If {@code true}, the function is <code> sin(&pi;x) / &pi;x</code>, otherwise {@code sin(x) / x}. ",
    "is_bug": false,
    "failing_test_cases": 28,
    "buggy_methods": 7
  },
  {
    "name": "Sinc.value",
    "class_name": "org.apache.commons.math3.analysis.function.Sinc",
    "signature": "org.apache.commons.math3.analysis.function.Sinc.value(double)",
    "snippet": "    public double value(final double x) {\n        final double scaledX = normalized ? FastMath.PI * x : x;\n        if (FastMath.abs(scaledX) <= SHORTCUT) {\n            // use Taylor series\n            final double scaledX2 = scaledX * scaledX;\n            return ((scaledX2 - 20) * scaledX2 + 120) / 120;\n        } else {\n            // use definition expression\n            return FastMath.sin(scaledX) / scaledX;\n        }\n    }",
    "comment": "{@inheritDoc} */",
    "is_bug": false,
    "failing_test_cases": 28,
    "buggy_methods": 7
  },
  {
    "name": "AbstractUnivariateSolver.AbstractUnivariateSolver",
    "class_name": "org.apache.commons.math3.analysis.solvers.AbstractUnivariateSolver",
    "signature": "org.apache.commons.math3.analysis.solvers.AbstractUnivariateSolver.AbstractUnivariateSolver(double)",
    "snippet": "    protected AbstractUnivariateSolver(final double absoluteAccuracy) {\n        super(absoluteAccuracy);\n    }",
    "comment": " Construct a solver with given absolute accuracy.  @param absoluteAccuracy Maximum absolute error. ",
    "is_bug": false,
    "failing_test_cases": 28,
    "buggy_methods": 7
  },
  {
    "name": "BaseAbstractUnivariateSolver.BaseAbstractUnivariateSolver",
    "class_name": "org.apache.commons.math3.analysis.solvers.BaseAbstractUnivariateSolver",
    "signature": "org.apache.commons.math3.analysis.solvers.BaseAbstractUnivariateSolver.BaseAbstractUnivariateSolver(double)",
    "snippet": "    protected BaseAbstractUnivariateSolver(final double absoluteAccuracy) {\n        this(DEFAULT_RELATIVE_ACCURACY,\n             absoluteAccuracy,\n             DEFAULT_FUNCTION_VALUE_ACCURACY);\n    }",
    "comment": " Construct a solver with given absolute accuracy.  @param absoluteAccuracy Maximum absolute error. ",
    "is_bug": false,
    "failing_test_cases": 28,
    "buggy_methods": 7
  },
  {
    "name": "BaseAbstractUnivariateSolver.BaseAbstractUnivariateSolver",
    "class_name": "org.apache.commons.math3.analysis.solvers.BaseAbstractUnivariateSolver",
    "signature": "org.apache.commons.math3.analysis.solvers.BaseAbstractUnivariateSolver.BaseAbstractUnivariateSolver(double,double,double)",
    "snippet": "    protected BaseAbstractUnivariateSolver(final double relativeAccuracy,\n                                               final double absoluteAccuracy,\n                                               final double functionValueAccuracy) {\n        this.absoluteAccuracy = absoluteAccuracy;\n        this.relativeAccuracy = relativeAccuracy;\n        this.functionValueAccuracy = functionValueAccuracy;\n    }",
    "comment": " Construct a solver with given accuracies.  @param relativeAccuracy Maximum relative error. @param absoluteAccuracy Maximum absolute error. @param functionValueAccuracy Maximum function value error. ",
    "is_bug": false,
    "failing_test_cases": 28,
    "buggy_methods": 7
  },
  {
    "name": "BaseAbstractUnivariateSolver.computeObjectiveValue",
    "class_name": "org.apache.commons.math3.analysis.solvers.BaseAbstractUnivariateSolver",
    "signature": "org.apache.commons.math3.analysis.solvers.BaseAbstractUnivariateSolver.computeObjectiveValue(double)",
    "snippet": "    protected double computeObjectiveValue(double point)\n        throws TooManyEvaluationsException {\n        incrementEvaluationCount();\n        return function.value(point);\n    }",
    "comment": " Compute the objective function value.  @param point Point at which the objective function must be evaluated. @return the objective function value at specified point. @throws TooManyEvaluationsException if the maximal number of evaluations is exceeded. ",
    "is_bug": false,
    "failing_test_cases": 28,
    "buggy_methods": 7
  },
  {
    "name": "BaseAbstractUnivariateSolver.getAbsoluteAccuracy",
    "class_name": "org.apache.commons.math3.analysis.solvers.BaseAbstractUnivariateSolver",
    "signature": "org.apache.commons.math3.analysis.solvers.BaseAbstractUnivariateSolver.getAbsoluteAccuracy()",
    "snippet": "    public double getAbsoluteAccuracy() {\n        return absoluteAccuracy;\n    }",
    "comment": " {@inheritDoc} ",
    "is_bug": false,
    "failing_test_cases": 28,
    "buggy_methods": 7
  },
  {
    "name": "BaseAbstractUnivariateSolver.getEvaluations",
    "class_name": "org.apache.commons.math3.analysis.solvers.BaseAbstractUnivariateSolver",
    "signature": "org.apache.commons.math3.analysis.solvers.BaseAbstractUnivariateSolver.getEvaluations()",
    "snippet": "    public int getEvaluations() {\n        return evaluations.getCount();\n    }",
    "comment": "{@inheritDoc} */",
    "is_bug": false,
    "failing_test_cases": 28,
    "buggy_methods": 7
  },
  {
    "name": "BaseAbstractUnivariateSolver.getFunctionValueAccuracy",
    "class_name": "org.apache.commons.math3.analysis.solvers.BaseAbstractUnivariateSolver",
    "signature": "org.apache.commons.math3.analysis.solvers.BaseAbstractUnivariateSolver.getFunctionValueAccuracy()",
    "snippet": "    public double getFunctionValueAccuracy() {\n        return functionValueAccuracy;\n    }",
    "comment": " {@inheritDoc} ",
    "is_bug": false,
    "failing_test_cases": 28,
    "buggy_methods": 7
  },
  {
    "name": "BaseAbstractUnivariateSolver.getMax",
    "class_name": "org.apache.commons.math3.analysis.solvers.BaseAbstractUnivariateSolver",
    "signature": "org.apache.commons.math3.analysis.solvers.BaseAbstractUnivariateSolver.getMax()",
    "snippet": "    public double getMax() {\n        return searchMax;\n    }",
    "comment": " @return the higher end of the search interval. ",
    "is_bug": false,
    "failing_test_cases": 28,
    "buggy_methods": 7
  },
  {
    "name": "BaseAbstractUnivariateSolver.getMin",
    "class_name": "org.apache.commons.math3.analysis.solvers.BaseAbstractUnivariateSolver",
    "signature": "org.apache.commons.math3.analysis.solvers.BaseAbstractUnivariateSolver.getMin()",
    "snippet": "    public double getMin() {\n        return searchMin;\n    }",
    "comment": " @return the lower end of the search interval. ",
    "is_bug": false,
    "failing_test_cases": 28,
    "buggy_methods": 7
  },
  {
    "name": "BaseAbstractUnivariateSolver.getRelativeAccuracy",
    "class_name": "org.apache.commons.math3.analysis.solvers.BaseAbstractUnivariateSolver",
    "signature": "org.apache.commons.math3.analysis.solvers.BaseAbstractUnivariateSolver.getRelativeAccuracy()",
    "snippet": "    public double getRelativeAccuracy() {\n        return relativeAccuracy;\n    }",
    "comment": " {@inheritDoc} ",
    "is_bug": false,
    "failing_test_cases": 28,
    "buggy_methods": 7
  },
  {
    "name": "BaseAbstractUnivariateSolver.getStartValue",
    "class_name": "org.apache.commons.math3.analysis.solvers.BaseAbstractUnivariateSolver",
    "signature": "org.apache.commons.math3.analysis.solvers.BaseAbstractUnivariateSolver.getStartValue()",
    "snippet": "    public double getStartValue() {\n        return searchStart;\n    }",
    "comment": " @return the initial guess. ",
    "is_bug": false,
    "failing_test_cases": 28,
    "buggy_methods": 7
  },
  {
    "name": "BaseAbstractUnivariateSolver.incrementEvaluationCount",
    "class_name": "org.apache.commons.math3.analysis.solvers.BaseAbstractUnivariateSolver",
    "signature": "org.apache.commons.math3.analysis.solvers.BaseAbstractUnivariateSolver.incrementEvaluationCount()",
    "snippet": "    protected void incrementEvaluationCount()\n        throws TooManyEvaluationsException {\n        try {\n            evaluations.incrementCount();\n        } catch (MaxCountExceededException e) {\n            throw new TooManyEvaluationsException(e.getMax());\n        }\n    }",
    "comment": " Increment the evaluation count by one. Method {@link #computeObjectiveValue(double)} calls this method internally. It is provided for subclasses that do not exclusively use {@code computeObjectiveValue} to solve the function. See e.g. {@link AbstractUnivariateDifferentiableSolver}.  @throws TooManyEvaluationsException when the allowed number of function evaluations has been exhausted. ",
    "is_bug": false,
    "failing_test_cases": 28,
    "buggy_methods": 7
  },
  {
    "name": "BaseAbstractUnivariateSolver.verifySequence",
    "class_name": "org.apache.commons.math3.analysis.solvers.BaseAbstractUnivariateSolver",
    "signature": "org.apache.commons.math3.analysis.solvers.BaseAbstractUnivariateSolver.verifySequence(double,double,double)",
    "snippet": "    protected void verifySequence(final double lower,\n                                  final double initial,\n                                  final double upper)\n        throws NumberIsTooLargeException {\n        UnivariateSolverUtils.verifySequence(lower, initial, upper);\n    }",
    "comment": " Check that {@code lower < initial < upper}.  @param lower Lower endpoint. @param initial Initial value. @param upper Upper endpoint. @throws NumberIsTooLargeException if {@code lower >= initial} or {@code initial >= upper}. ",
    "is_bug": false,
    "failing_test_cases": 28,
    "buggy_methods": 7
  },
  {
    "name": "BrentSolver.BrentSolver",
    "class_name": "org.apache.commons.math3.analysis.solvers.BrentSolver",
    "signature": "org.apache.commons.math3.analysis.solvers.BrentSolver.BrentSolver()",
    "snippet": "    public BrentSolver() {\n        this(DEFAULT_ABSOLUTE_ACCURACY);\n    }",
    "comment": " Construct a solver with default accuracy (1e-6). ",
    "is_bug": false,
    "failing_test_cases": 28,
    "buggy_methods": 7
  },
  {
    "name": "BrentSolver.BrentSolver",
    "class_name": "org.apache.commons.math3.analysis.solvers.BrentSolver",
    "signature": "org.apache.commons.math3.analysis.solvers.BrentSolver.BrentSolver(double)",
    "snippet": "    public BrentSolver(double absoluteAccuracy) {\n        super(absoluteAccuracy);\n    }",
    "comment": " Construct a solver.  @param absoluteAccuracy Absolute accuracy. ",
    "is_bug": false,
    "failing_test_cases": 28,
    "buggy_methods": 7
  },
  {
    "name": "BrentSolver.brent",
    "class_name": "org.apache.commons.math3.analysis.solvers.BrentSolver",
    "signature": "org.apache.commons.math3.analysis.solvers.BrentSolver.brent(double,double,double,double)",
    "snippet": "    private double brent(double lo, double hi,\n                         double fLo, double fHi) {\n        double a = lo;\n        double fa = fLo;\n        double b = hi;\n        double fb = fHi;\n        double c = a;\n        double fc = fa;\n        double d = b - a;\n        double e = d;\n\n        final double t = getAbsoluteAccuracy();\n        final double eps = getRelativeAccuracy();\n\n        while (true) {\n            if (FastMath.abs(fc) < FastMath.abs(fb)) {\n                a = b;\n                b = c;\n                c = a;\n                fa = fb;\n                fb = fc;\n                fc = fa;\n            }\n\n            final double tol = 2 * eps * FastMath.abs(b) + t;\n            final double m = 0.5 * (c - b);\n\n            if (FastMath.abs(m) <= tol ||\n                Precision.equals(fb, 0))  {\n                return b;\n            }\n            if (FastMath.abs(e) < tol ||\n                FastMath.abs(fa) <= FastMath.abs(fb)) {\n                // Force bisection.\n                d = m;\n                e = d;\n            } else {\n                double s = fb / fa;\n                double p;\n                double q;\n                // The equality test (a == c) is intentional,\n                // it is part of the original Brent's method and\n                // it should NOT be replaced by proximity test.\n                if (a == c) {\n                    // Linear interpolation.\n                    p = 2 * m * s;\n                    q = 1 - s;\n                } else {\n                    // Inverse quadratic interpolation.\n                    q = fa / fc;\n                    final double r = fb / fc;\n                    p = s * (2 * m * q * (q - r) - (b - a) * (r - 1));\n                    q = (q - 1) * (r - 1) * (s - 1);\n                }\n                if (p > 0) {\n                    q = -q;\n                } else {\n                    p = -p;\n                }\n                s = e;\n                e = d;\n                if (p >= 1.5 * m * q - FastMath.abs(tol * q) ||\n                    p >= FastMath.abs(0.5 * s * q)) {\n                    // Inverse quadratic interpolation gives a value\n                    // in the wrong direction, or progress is slow.\n                    // Fall back to bisection.\n                    d = m;\n                    e = d;\n                } else {\n                    d = p / q;\n                }\n            }\n            a = b;\n            fa = fb;\n\n            if (FastMath.abs(d) > tol) {\n                b += d;\n            } else if (m > 0) {\n                b += tol;\n            } else {\n                b -= tol;\n            }\n            fb = computeObjectiveValue(b);\n            if ((fb > 0 && fc > 0) ||\n                (fb <= 0 && fc <= 0)) {\n                c = a;\n                fc = fa;\n                d = b - a;\n                e = d;\n            }\n        }\n    }",
    "comment": " Search for a zero inside the provided interval. This implementation is based on the algorithm described at page 58 of the book <quote> <b>Algorithms for Minimization Without Derivatives</b> <it>Richard P. Brent</it> Dover 0-486-41998-3 </quote>  @param lo Lower bound of the search interval. @param hi Higher bound of the search interval. @param fLo Function value at the lower bound of the search interval. @param fHi Function value at the higher bound of the search interval. @return the value where the function is zero. ",
    "is_bug": false,
    "failing_test_cases": 28,
    "buggy_methods": 7
  },
  {
    "name": "BrentSolver.doSolve",
    "class_name": "org.apache.commons.math3.analysis.solvers.BrentSolver",
    "signature": "org.apache.commons.math3.analysis.solvers.BrentSolver.doSolve()",
    "snippet": "    @Override\n    protected double doSolve()\n        throws NoBracketingException,\n               TooManyEvaluationsException,\n               NumberIsTooLargeException {\n        double min = getMin();\n        double max = getMax();\n        final double initial = getStartValue();\n        final double functionValueAccuracy = getFunctionValueAccuracy();\n\n        verifySequence(min, initial, max);\n\n        // Return the initial guess if it is good enough.\n        double yInitial = computeObjectiveValue(initial);\n        if (FastMath.abs(yInitial) <= functionValueAccuracy) {\n            return initial;\n        }\n\n        // Return the first endpoint if it is good enough.\n        double yMin = computeObjectiveValue(min);\n        if (FastMath.abs(yMin) <= functionValueAccuracy) {\n            return min;\n        }\n\n        // Reduce interval if min and initial bracket the root.\n        if (yInitial * yMin < 0) {\n            return brent(min, initial, yMin, yInitial);\n        }\n\n        // Return the second endpoint if it is good enough.\n        double yMax = computeObjectiveValue(max);\n        if (FastMath.abs(yMax) <= functionValueAccuracy) {\n            return max;\n        }\n\n        // Reduce interval if initial and max bracket the root.\n        if (yInitial * yMax < 0) {\n            return brent(initial, max, yInitial, yMax);\n        }\n\n        throw new NoBracketingException(min, max, yMin, yMax);\n    }",
    "comment": " {@inheritDoc} ",
    "is_bug": false,
    "failing_test_cases": 28,
    "buggy_methods": 7
  },
  {
    "name": "UnivariateSolverUtils.verifyInterval",
    "class_name": "org.apache.commons.math3.analysis.solvers.UnivariateSolverUtils",
    "signature": "org.apache.commons.math3.analysis.solvers.UnivariateSolverUtils.verifyInterval(double,double)",
    "snippet": "    public static void verifyInterval(final double lower,\n                                      final double upper)\n        throws NumberIsTooLargeException {\n        if (lower >= upper) {\n            throw new NumberIsTooLargeException(LocalizedFormats.ENDPOINTS_NOT_AN_INTERVAL,\n                                                lower, upper, false);\n        }\n    }",
    "comment": " Check that the endpoints specify an interval.  @param lower Lower endpoint. @param upper Upper endpoint. @throws NumberIsTooLargeException if {@code lower >= upper}. ",
    "is_bug": false,
    "failing_test_cases": 28,
    "buggy_methods": 7
  },
  {
    "name": "UnivariateSolverUtils.verifySequence",
    "class_name": "org.apache.commons.math3.analysis.solvers.UnivariateSolverUtils",
    "signature": "org.apache.commons.math3.analysis.solvers.UnivariateSolverUtils.verifySequence(double,double,double)",
    "snippet": "    public static void verifySequence(final double lower,\n                                      final double initial,\n                                      final double upper)\n        throws NumberIsTooLargeException {\n        verifyInterval(lower, initial);\n        verifyInterval(initial, upper);\n    }",
    "comment": " Check that {@code lower < initial < upper}.  @param lower Lower endpoint. @param initial Initial value. @param upper Upper endpoint. @throws NumberIsTooLargeException if {@code lower >= initial} or {@code initial >= upper}. ",
    "is_bug": false,
    "failing_test_cases": 28,
    "buggy_methods": 7
  },
  {
    "name": "AbstractRealMatrix.AbstractRealMatrix",
    "class_name": "org.apache.commons.math3.linear.AbstractRealMatrix",
    "signature": "org.apache.commons.math3.linear.AbstractRealMatrix.AbstractRealMatrix(int,int)",
    "snippet": "    protected AbstractRealMatrix(final int rowDimension,\n        final int columnDimension)\n        throws NotStrictlyPositiveException {\n        if (rowDimension < 1) {\n            throw new NotStrictlyPositiveException(rowDimension);\n        }\n        if (columnDimension < 1) {\n            throw new NotStrictlyPositiveException(columnDimension);\n        }\n    }",
    "comment": " Create a new RealMatrix with the supplied row and column dimensions.  @param rowDimension  the number of rows in the new matrix @param columnDimension  the number of columns in the new matrix @throws NotStrictlyPositiveException if row or column dimension is not positive ",
    "is_bug": false,
    "failing_test_cases": 28,
    "buggy_methods": 7
  },
  {
    "name": "Array2DRowRealMatrix.Array2DRowRealMatrix",
    "class_name": "org.apache.commons.math3.linear.Array2DRowRealMatrix",
    "signature": "org.apache.commons.math3.linear.Array2DRowRealMatrix.Array2DRowRealMatrix(double[][])",
    "snippet": "    public Array2DRowRealMatrix(final double[][] d)\n        throws DimensionMismatchException, NoDataException, NullArgumentException {\n        copyIn(d);\n    }",
    "comment": " Create a new {@code RealMatrix} using the input array as the underlying data array. <p>The input array is copied, not referenced. This constructor has the same effect as calling {@link #Array2DRowRealMatrix(double[][], boolean)} with the second argument set to {@code true}.</p>  @param d Data for the new matrix. @throws DimensionMismatchException if {@code d} is not rectangular. @throws NoDataException if {@code d} row or colum dimension is zero. @throws NullArgumentException if {@code d} is {@code null}. @see #Array2DRowRealMatrix(double[][], boolean) ",
    "is_bug": false,
    "failing_test_cases": 28,
    "buggy_methods": 7
  },
  {
    "name": "Array2DRowRealMatrix.Array2DRowRealMatrix",
    "class_name": "org.apache.commons.math3.linear.Array2DRowRealMatrix",
    "signature": "org.apache.commons.math3.linear.Array2DRowRealMatrix.Array2DRowRealMatrix(double[][],boolean)",
    "snippet": "    public Array2DRowRealMatrix(final double[][] d, final boolean copyArray)\n        throws DimensionMismatchException, NoDataException,\n        NullArgumentException {\n        if (copyArray) {\n            copyIn(d);\n        } else {\n            if (d == null) {\n                throw new NullArgumentException();\n            }\n            final int nRows = d.length;\n            if (nRows == 0) {\n                throw new NoDataException(LocalizedFormats.AT_LEAST_ONE_ROW);\n            }\n            final int nCols = d[0].length;\n            if (nCols == 0) {\n                throw new NoDataException(LocalizedFormats.AT_LEAST_ONE_COLUMN);\n            }\n            for (int r = 1; r < nRows; r++) {\n                if (d[r].length != nCols) {\n                    throw new DimensionMismatchException(d[r].length, nCols);\n                }\n            }\n            data = d;\n        }\n    }",
    "comment": " Create a new RealMatrix using the input array as the underlying data array. If an array is built specially in order to be embedded in a RealMatrix and not used directly, the {@code copyArray} may be set to {@code false}. This will prevent the copying and improve performance as no new array will be built and no data will be copied.  @param d Data for new matrix. @param copyArray if {@code true}, the input array will be copied, otherwise it will be referenced. @throws DimensionMismatchException if {@code d} is not rectangular. @throws NoDataException if {@code d} row or colum dimension is zero. @throws NullArgumentException if {@code d} is {@code null}. @see #Array2DRowRealMatrix(double[][]) ",
    "is_bug": false,
    "failing_test_cases": 28,
    "buggy_methods": 7
  },
  {
    "name": "Array2DRowRealMatrix.Array2DRowRealMatrix",
    "class_name": "org.apache.commons.math3.linear.Array2DRowRealMatrix",
    "signature": "org.apache.commons.math3.linear.Array2DRowRealMatrix.Array2DRowRealMatrix(int,int)",
    "snippet": "    public Array2DRowRealMatrix(final int rowDimension,\n                                final int columnDimension)\n        throws NotStrictlyPositiveException {\n        super(rowDimension, columnDimension);\n        data = new double[rowDimension][columnDimension];\n    }",
    "comment": " Create a new RealMatrix with the supplied row and column dimensions.  @param rowDimension Number of rows in the new matrix. @param columnDimension Number of columns in the new matrix. @throws NotStrictlyPositiveException if the row or column dimension is not positive. ",
    "is_bug": false,
    "failing_test_cases": 28,
    "buggy_methods": 7
  },
  {
    "name": "Array2DRowRealMatrix.copyIn",
    "class_name": "org.apache.commons.math3.linear.Array2DRowRealMatrix",
    "signature": "org.apache.commons.math3.linear.Array2DRowRealMatrix.copyIn(double[][])",
    "snippet": "    private void copyIn(final double[][] in)\n        throws DimensionMismatchException, NoDataException, NullArgumentException {\n        setSubMatrix(in, 0, 0);\n    }",
    "comment": " Replace data with a fresh copy of the input array.  @param in Data to copy. @throws NoDataException if the input array is empty. @throws DimensionMismatchException if the input array is not rectangular. @throws NullArgumentException if the input array is {@code null}. ",
    "is_bug": false,
    "failing_test_cases": 28,
    "buggy_methods": 7
  },
  {
    "name": "Array2DRowRealMatrix.copyOut",
    "class_name": "org.apache.commons.math3.linear.Array2DRowRealMatrix",
    "signature": "org.apache.commons.math3.linear.Array2DRowRealMatrix.copyOut()",
    "snippet": "    private double[][] copyOut() {\n        final int nRows = this.getRowDimension();\n        final double[][] out = new double[nRows][this.getColumnDimension()];\n        // can't copy 2-d array in one shot, otherwise get row references\n        for (int i = 0; i < nRows; i++) {\n            System.arraycopy(data[i], 0, out[i], 0, data[i].length);\n        }\n        return out;\n    }",
    "comment": " Get a fresh copy of the underlying data array.  @return a copy of the underlying data array. ",
    "is_bug": false,
    "failing_test_cases": 28,
    "buggy_methods": 7
  },
  {
    "name": "Array2DRowRealMatrix.createMatrix",
    "class_name": "org.apache.commons.math3.linear.Array2DRowRealMatrix",
    "signature": "org.apache.commons.math3.linear.Array2DRowRealMatrix.createMatrix(int,int)",
    "snippet": "    @Override\n    public RealMatrix createMatrix(final int rowDimension,\n                                   final int columnDimension)\n        throws NotStrictlyPositiveException {\n        return new Array2DRowRealMatrix(rowDimension, columnDimension);\n    }",
    "comment": "{@inheritDoc} */",
    "is_bug": false,
    "failing_test_cases": 28,
    "buggy_methods": 7
  },
  {
    "name": "Array2DRowRealMatrix.getColumnDimension",
    "class_name": "org.apache.commons.math3.linear.Array2DRowRealMatrix",
    "signature": "org.apache.commons.math3.linear.Array2DRowRealMatrix.getColumnDimension()",
    "snippet": "    @Override\n    public int getColumnDimension() {\n        return ((data == null) || (data[0] == null)) ? 0 : data[0].length;\n    }",
    "comment": "{@inheritDoc} */",
    "is_bug": false,
    "failing_test_cases": 28,
    "buggy_methods": 7
  },
  {
    "name": "Array2DRowRealMatrix.getData",
    "class_name": "org.apache.commons.math3.linear.Array2DRowRealMatrix",
    "signature": "org.apache.commons.math3.linear.Array2DRowRealMatrix.getData()",
    "snippet": "    @Override\n    public double[][] getData() {\n        return copyOut();\n    }",
    "comment": "{@inheritDoc} */",
    "is_bug": false,
    "failing_test_cases": 28,
    "buggy_methods": 7
  },
  {
    "name": "Array2DRowRealMatrix.getEntry",
    "class_name": "org.apache.commons.math3.linear.Array2DRowRealMatrix",
    "signature": "org.apache.commons.math3.linear.Array2DRowRealMatrix.getEntry(int,int)",
    "snippet": "    @Override\n    public double getEntry(final int row, final int column)\n        throws OutOfRangeException {\n        MatrixUtils.checkMatrixIndex(this, row, column);\n        return data[row][column];\n    }",
    "comment": "{@inheritDoc} */",
    "is_bug": false,
    "failing_test_cases": 28,
    "buggy_methods": 7
  },
  {
    "name": "Array2DRowRealMatrix.getRowDimension",
    "class_name": "org.apache.commons.math3.linear.Array2DRowRealMatrix",
    "signature": "org.apache.commons.math3.linear.Array2DRowRealMatrix.getRowDimension()",
    "snippet": "    @Override\n    public int getRowDimension() {\n        return (data == null) ? 0 : data.length;\n    }",
    "comment": "{@inheritDoc} */",
    "is_bug": false,
    "failing_test_cases": 28,
    "buggy_methods": 7
  },
  {
    "name": "Array2DRowRealMatrix.setEntry",
    "class_name": "org.apache.commons.math3.linear.Array2DRowRealMatrix",
    "signature": "org.apache.commons.math3.linear.Array2DRowRealMatrix.setEntry(int,int,double)",
    "snippet": "    @Override\n    public void setEntry(final int row, final int column, final double value)\n        throws OutOfRangeException {\n        MatrixUtils.checkMatrixIndex(this, row, column);\n        data[row][column] = value;\n    }",
    "comment": "{@inheritDoc} */",
    "is_bug": false,
    "failing_test_cases": 28,
    "buggy_methods": 7
  },
  {
    "name": "Array2DRowRealMatrix.setSubMatrix",
    "class_name": "org.apache.commons.math3.linear.Array2DRowRealMatrix",
    "signature": "org.apache.commons.math3.linear.Array2DRowRealMatrix.setSubMatrix(double[][],int,int)",
    "snippet": "    @Override\n    public void setSubMatrix(final double[][] subMatrix, final int row,\n                             final int column)\n        throws NoDataException, OutOfRangeException,\n        DimensionMismatchException, NullArgumentException {\n        if (data == null) {\n            if (row > 0) {\n                throw new MathIllegalStateException(LocalizedFormats.FIRST_ROWS_NOT_INITIALIZED_YET, row);\n            }\n            if (column > 0) {\n                throw new MathIllegalStateException(LocalizedFormats.FIRST_COLUMNS_NOT_INITIALIZED_YET, column);\n            }\n            MathUtils.checkNotNull(subMatrix);\n            final int nRows = subMatrix.length;\n            if (nRows == 0) {\n                throw new NoDataException(LocalizedFormats.AT_LEAST_ONE_ROW);\n            }\n\n            final int nCols = subMatrix[0].length;\n            if (nCols == 0) {\n                throw new NoDataException(LocalizedFormats.AT_LEAST_ONE_COLUMN);\n            }\n            data = new double[subMatrix.length][nCols];\n            for (int i = 0; i < data.length; ++i) {\n                if (subMatrix[i].length != nCols) {\n                    throw new DimensionMismatchException(subMatrix[i].length, nCols);\n                }\n                System.arraycopy(subMatrix[i], 0, data[i + row], column, nCols);\n            }\n        } else {\n            super.setSubMatrix(subMatrix, row, column);\n        }\n\n    }",
    "comment": "{@inheritDoc} */",
    "is_bug": false,
    "failing_test_cases": 28,
    "buggy_methods": 7
  },
  {
    "name": "Array2DRowRealMatrix.walkInRowOrder",
    "class_name": "org.apache.commons.math3.linear.Array2DRowRealMatrix",
    "signature": "org.apache.commons.math3.linear.Array2DRowRealMatrix.walkInRowOrder(RealMatrixPreservingVisitor)",
    "snippet": "    @Override\n    public double walkInRowOrder(final RealMatrixPreservingVisitor visitor) {\n        final int rows    = getRowDimension();\n        final int columns = getColumnDimension();\n        visitor.start(rows, columns, 0, rows - 1, 0, columns - 1);\n        for (int i = 0; i < rows; ++i) {\n            final double[] rowI = data[i];\n            for (int j = 0; j < columns; ++j) {\n                visitor.visit(i, j, rowI[j]);\n            }\n        }\n        return visitor.end();\n    }",
    "comment": "{@inheritDoc} */",
    "is_bug": false,
    "failing_test_cases": 28,
    "buggy_methods": 7
  },
  {
    "name": "ArrayRealVector.ArrayRealVector",
    "class_name": "org.apache.commons.math3.linear.ArrayRealVector",
    "signature": "org.apache.commons.math3.linear.ArrayRealVector.ArrayRealVector(double[])",
    "snippet": "    public ArrayRealVector(double[] d) {\n        data = d.clone();\n    }",
    "comment": " Construct a vector from an array, copying the input array.  @param d Array. ",
    "is_bug": false,
    "failing_test_cases": 28,
    "buggy_methods": 7
  },
  {
    "name": "ArrayRealVector.ArrayRealVector",
    "class_name": "org.apache.commons.math3.linear.ArrayRealVector",
    "signature": "org.apache.commons.math3.linear.ArrayRealVector.ArrayRealVector(double[],boolean)",
    "snippet": "    public ArrayRealVector(double[] d, boolean copyArray)\n        throws NullArgumentException {\n        if (d == null) {\n            throw new NullArgumentException();\n        }\n        data = copyArray ? d.clone() :  d;\n    }",
    "comment": " Create a new ArrayRealVector using the input array as the underlying data array. If an array is built specially in order to be embedded in a ArrayRealVector and not used directly, the {@code copyArray} may be set to {@code false}. This will prevent the copying and improve performance as no new array will be built and no data will be copied.  @param d Data for the new vector. @param copyArray if {@code true}, the input array will be copied, otherwise it will be referenced. @throws NullArgumentException if {@code d} is {@code null}. @see #ArrayRealVector(double[]) ",
    "is_bug": false,
    "failing_test_cases": 28,
    "buggy_methods": 7
  },
  {
    "name": "ArrayRealVector.checkVectorDimensions",
    "class_name": "org.apache.commons.math3.linear.ArrayRealVector",
    "signature": "org.apache.commons.math3.linear.ArrayRealVector.checkVectorDimensions(int)",
    "snippet": "    @Override\n    protected void checkVectorDimensions(int n)\n        throws DimensionMismatchException {\n        if (data.length != n) {\n            throw new DimensionMismatchException(data.length, n);\n        }\n    }",
    "comment": " Check if instance dimension is equal to some expected value.  @param n Expected dimension. @throws DimensionMismatchException if the dimension is inconsistent with vector size. ",
    "is_bug": false,
    "failing_test_cases": 28,
    "buggy_methods": 7
  },
  {
    "name": "ArrayRealVector.dotProduct",
    "class_name": "org.apache.commons.math3.linear.ArrayRealVector",
    "signature": "org.apache.commons.math3.linear.ArrayRealVector.dotProduct(RealVector)",
    "snippet": "    @Override\n    public double dotProduct(RealVector v) throws DimensionMismatchException {\n        if (v instanceof ArrayRealVector) {\n            final double[] vData = ((ArrayRealVector) v).data;\n            checkVectorDimensions(vData.length);\n            double dot = 0;\n            for (int i = 0; i < data.length; i++) {\n                dot += data[i] * vData[i];\n            }\n            return dot;\n        }\n        return super.dotProduct(v);\n    }",
    "comment": "{@inheritDoc} */",
    "is_bug": false,
    "failing_test_cases": 28,
    "buggy_methods": 7
  },
  {
    "name": "ArrayRealVector.getDataRef",
    "class_name": "org.apache.commons.math3.linear.ArrayRealVector",
    "signature": "org.apache.commons.math3.linear.ArrayRealVector.getDataRef()",
    "snippet": "    public double[] getDataRef() {\n        return data;\n    }",
    "comment": " Get a reference to the underlying data array. This method does not make a fresh copy of the underlying data.  @return the array of entries. ",
    "is_bug": false,
    "failing_test_cases": 28,
    "buggy_methods": 7
  },
  {
    "name": "ArrayRealVector.getDimension",
    "class_name": "org.apache.commons.math3.linear.ArrayRealVector",
    "signature": "org.apache.commons.math3.linear.ArrayRealVector.getDimension()",
    "snippet": "    @Override\n    public int getDimension() {\n        return data.length;\n    }",
    "comment": "{@inheritDoc} */",
    "is_bug": false,
    "failing_test_cases": 28,
    "buggy_methods": 7
  },
  {
    "name": "ArrayRealVector.getEntry",
    "class_name": "org.apache.commons.math3.linear.ArrayRealVector",
    "signature": "org.apache.commons.math3.linear.ArrayRealVector.getEntry(int)",
    "snippet": "    @Override\n    public double getEntry(int index) throws OutOfRangeException {\n        try {\n            return data[index];\n        } catch (IndexOutOfBoundsException e) {\n            throw new OutOfRangeException(LocalizedFormats.INDEX, index, 0,\n                getDimension() - 1);\n        }\n    }",
    "comment": "{@inheritDoc} */",
    "is_bug": false,
    "failing_test_cases": 28,
    "buggy_methods": 7
  },
  {
    "name": "ArrayRealVector.toArray",
    "class_name": "org.apache.commons.math3.linear.ArrayRealVector",
    "signature": "org.apache.commons.math3.linear.ArrayRealVector.toArray()",
    "snippet": "    @Override\n    public double[] toArray(){\n        return data.clone();\n    }",
    "comment": "{@inheritDoc} */",
    "is_bug": false,
    "failing_test_cases": 28,
    "buggy_methods": 7
  },
  {
    "name": "BlockRealMatrix.BlockRealMatrix",
    "class_name": "org.apache.commons.math3.linear.BlockRealMatrix",
    "signature": "org.apache.commons.math3.linear.BlockRealMatrix.BlockRealMatrix(double[][])",
    "snippet": "    public BlockRealMatrix(final double[][] rawData)\n        throws DimensionMismatchException, NotStrictlyPositiveException {\n        this(rawData.length, rawData[0].length, toBlocksLayout(rawData), false);\n    }",
    "comment": " Create a new dense matrix copying entries from raw layout data. <p>The input array <em>must</em> already be in raw layout.</p> <p>Calling this constructor is equivalent to call: <pre>matrix = new BlockRealMatrix(rawData.length, rawData[0].length, toBlocksLayout(rawData), false);</pre> </p>  @param rawData data for new matrix, in raw layout @throws DimensionMismatchException if the shape of {@code blockData} is inconsistent with block layout. @throws NotStrictlyPositiveException if row or column dimension is not positive. @see #BlockRealMatrix(int, int, double[][], boolean) ",
    "is_bug": false,
    "failing_test_cases": 28,
    "buggy_methods": 7
  },
  {
    "name": "BlockRealMatrix.BlockRealMatrix",
    "class_name": "org.apache.commons.math3.linear.BlockRealMatrix",
    "signature": "org.apache.commons.math3.linear.BlockRealMatrix.BlockRealMatrix(int,int)",
    "snippet": "    public BlockRealMatrix(final int rows, final int columns)\n        throws NotStrictlyPositiveException {\n        super(rows, columns);\n        this.rows = rows;\n        this.columns = columns;\n\n        // number of blocks\n        blockRows = (rows + BLOCK_SIZE - 1) / BLOCK_SIZE;\n        blockColumns = (columns + BLOCK_SIZE - 1) / BLOCK_SIZE;\n\n        // allocate storage blocks, taking care of smaller ones at right and bottom\n        blocks = createBlocksLayout(rows, columns);\n    }",
    "comment": " Create a new matrix with the supplied row and column dimensions.  @param rows  the number of rows in the new matrix @param columns  the number of columns in the new matrix @throws NotStrictlyPositiveException if row or column dimension is not positive. ",
    "is_bug": false,
    "failing_test_cases": 28,
    "buggy_methods": 7
  },
  {
    "name": "BlockRealMatrix.BlockRealMatrix",
    "class_name": "org.apache.commons.math3.linear.BlockRealMatrix",
    "signature": "org.apache.commons.math3.linear.BlockRealMatrix.BlockRealMatrix(int,int,double[][],boolean)",
    "snippet": "    public BlockRealMatrix(final int rows, final int columns,\n                           final double[][] blockData, final boolean copyArray)\n        throws DimensionMismatchException, NotStrictlyPositiveException {\n        super(rows, columns);\n        this.rows = rows;\n        this.columns = columns;\n\n        // number of blocks\n        blockRows = (rows + BLOCK_SIZE - 1) / BLOCK_SIZE;\n        blockColumns = (columns + BLOCK_SIZE - 1) / BLOCK_SIZE;\n\n        if (copyArray) {\n            // allocate storage blocks, taking care of smaller ones at right and bottom\n            blocks = new double[blockRows * blockColumns][];\n        } else {\n            // reference existing array\n            blocks = blockData;\n        }\n\n        int index = 0;\n        for (int iBlock = 0; iBlock < blockRows; ++iBlock) {\n            final int iHeight = blockHeight(iBlock);\n            for (int jBlock = 0; jBlock < blockColumns; ++jBlock, ++index) {\n                if (blockData[index].length != iHeight * blockWidth(jBlock)) {\n                    throw new DimensionMismatchException(blockData[index].length,\n                                                         iHeight * blockWidth(jBlock));\n                }\n                if (copyArray) {\n                    blocks[index] = blockData[index].clone();\n                }\n            }\n        }\n    }",
    "comment": " Create a new dense matrix copying entries from block layout data. <p>The input array <em>must</em> already be in blocks layout.</p>  @param rows Number of rows in the new matrix. @param columns Number of columns in the new matrix. @param blockData data for new matrix @param copyArray Whether the input array will be copied or referenced. @throws DimensionMismatchException if the shape of {@code blockData} is inconsistent with block layout. @throws NotStrictlyPositiveException if row or column dimension is not positive. @see #createBlocksLayout(int, int) @see #toBlocksLayout(double[][]) @see #BlockRealMatrix(double[][]) ",
    "is_bug": false,
    "failing_test_cases": 28,
    "buggy_methods": 7
  },
  {
    "name": "BlockRealMatrix.blockHeight",
    "class_name": "org.apache.commons.math3.linear.BlockRealMatrix",
    "signature": "org.apache.commons.math3.linear.BlockRealMatrix.blockHeight(int)",
    "snippet": "    private int blockHeight(final int blockRow) {\n        return (blockRow == blockRows - 1) ? rows - blockRow * BLOCK_SIZE : BLOCK_SIZE;\n    }",
    "comment": " Get the height of a block. @param blockRow row index (in block sense) of the block @return height (number of rows) of the block ",
    "is_bug": false,
    "failing_test_cases": 28,
    "buggy_methods": 7
  },
  {
    "name": "BlockRealMatrix.blockWidth",
    "class_name": "org.apache.commons.math3.linear.BlockRealMatrix",
    "signature": "org.apache.commons.math3.linear.BlockRealMatrix.blockWidth(int)",
    "snippet": "    private int blockWidth(final int blockColumn) {\n        return (blockColumn == blockColumns - 1) ? columns - blockColumn * BLOCK_SIZE : BLOCK_SIZE;\n    }",
    "comment": " Get the width of a block. @param blockColumn column index (in block sense) of the block @return width (number of columns) of the block ",
    "is_bug": false,
    "failing_test_cases": 28,
    "buggy_methods": 7
  },
  {
    "name": "BlockRealMatrix.createBlocksLayout",
    "class_name": "org.apache.commons.math3.linear.BlockRealMatrix",
    "signature": "org.apache.commons.math3.linear.BlockRealMatrix.createBlocksLayout(int,int)",
    "snippet": "    public static double[][] createBlocksLayout(final int rows, final int columns) {\n        final int blockRows = (rows    + BLOCK_SIZE - 1) / BLOCK_SIZE;\n        final int blockColumns = (columns + BLOCK_SIZE - 1) / BLOCK_SIZE;\n\n        final double[][] blocks = new double[blockRows * blockColumns][];\n        int blockIndex = 0;\n        for (int iBlock = 0; iBlock < blockRows; ++iBlock) {\n            final int pStart = iBlock * BLOCK_SIZE;\n            final int pEnd = FastMath.min(pStart + BLOCK_SIZE, rows);\n            final int iHeight = pEnd - pStart;\n            for (int jBlock = 0; jBlock < blockColumns; ++jBlock) {\n                final int qStart = jBlock * BLOCK_SIZE;\n                final int qEnd = FastMath.min(qStart + BLOCK_SIZE, columns);\n                final int jWidth = qEnd - qStart;\n                blocks[blockIndex] = new double[iHeight * jWidth];\n                ++blockIndex;\n            }\n        }\n\n        return blocks;\n    }",
    "comment": " Create a data array in blocks layout. <p> This method can be used to create the array argument of the {@link #BlockRealMatrix(int, int, double[][], boolean)} constructor. </p> @param rows Number of rows in the new matrix. @param columns Number of columns in the new matrix. @return a new data array in blocks layout. @see #toBlocksLayout(double[][]) @see #BlockRealMatrix(int, int, double[][], boolean) ",
    "is_bug": false,
    "failing_test_cases": 28,
    "buggy_methods": 7
  },
  {
    "name": "BlockRealMatrix.getColumnDimension",
    "class_name": "org.apache.commons.math3.linear.BlockRealMatrix",
    "signature": "org.apache.commons.math3.linear.BlockRealMatrix.getColumnDimension()",
    "snippet": "    @Override\n    public int getColumnDimension() {\n        return columns;\n    }",
    "comment": "{@inheritDoc} */",
    "is_bug": false,
    "failing_test_cases": 28,
    "buggy_methods": 7
  },
  {
    "name": "BlockRealMatrix.getRowDimension",
    "class_name": "org.apache.commons.math3.linear.BlockRealMatrix",
    "signature": "org.apache.commons.math3.linear.BlockRealMatrix.getRowDimension()",
    "snippet": "    @Override\n    public int getRowDimension() {\n        return rows;\n    }",
    "comment": "{@inheritDoc} */",
    "is_bug": false,
    "failing_test_cases": 28,
    "buggy_methods": 7
  },
  {
    "name": "BlockRealMatrix.operate",
    "class_name": "org.apache.commons.math3.linear.BlockRealMatrix",
    "signature": "org.apache.commons.math3.linear.BlockRealMatrix.operate(double[])",
    "snippet": "    @Override\n    public double[] operate(final double[] v)\n        throws DimensionMismatchException {\n        if (v.length != columns) {\n            throw new DimensionMismatchException(v.length, columns);\n        }\n        final double[] out = new double[rows];\n\n        // perform multiplication block-wise, to ensure good cache behavior\n        for (int iBlock = 0; iBlock < blockRows; ++iBlock) {\n            final int pStart = iBlock * BLOCK_SIZE;\n            final int pEnd = FastMath.min(pStart + BLOCK_SIZE, rows);\n            for (int jBlock = 0; jBlock < blockColumns; ++jBlock) {\n                final double[] block  = blocks[iBlock * blockColumns + jBlock];\n                final int qStart = jBlock * BLOCK_SIZE;\n                final int qEnd = FastMath.min(qStart + BLOCK_SIZE, columns);\n                int k = 0;\n                for (int p = pStart; p < pEnd; ++p) {\n                    double sum = 0;\n                    int q = qStart;\n                    while (q < qEnd - 3) {\n                        sum += block[k]     * v[q]     +\n                               block[k + 1] * v[q + 1] +\n                               block[k + 2] * v[q + 2] +\n                               block[k + 3] * v[q + 3];\n                        k += 4;\n                        q += 4;\n                    }\n                    while (q < qEnd) {\n                        sum += block[k++] * v[q++];\n                    }\n                    out[p] += sum;\n                }\n            }\n        }\n\n        return out;\n    }",
    "comment": "{@inheritDoc} */",
    "is_bug": false,
    "failing_test_cases": 28,
    "buggy_methods": 7
  },
  {
    "name": "BlockRealMatrix.toBlocksLayout",
    "class_name": "org.apache.commons.math3.linear.BlockRealMatrix",
    "signature": "org.apache.commons.math3.linear.BlockRealMatrix.toBlocksLayout(double[][])",
    "snippet": "    public static double[][] toBlocksLayout(final double[][] rawData)\n        throws DimensionMismatchException {\n        final int rows = rawData.length;\n        final int columns = rawData[0].length;\n        final int blockRows = (rows    + BLOCK_SIZE - 1) / BLOCK_SIZE;\n        final int blockColumns = (columns + BLOCK_SIZE - 1) / BLOCK_SIZE;\n\n        // safety checks\n        for (int i = 0; i < rawData.length; ++i) {\n            final int length = rawData[i].length;\n            if (length != columns) {\n                throw new DimensionMismatchException(columns, length);\n            }\n        }\n\n        // convert array\n        final double[][] blocks = new double[blockRows * blockColumns][];\n        int blockIndex = 0;\n        for (int iBlock = 0; iBlock < blockRows; ++iBlock) {\n            final int pStart = iBlock * BLOCK_SIZE;\n            final int pEnd = FastMath.min(pStart + BLOCK_SIZE, rows);\n            final int iHeight = pEnd - pStart;\n            for (int jBlock = 0; jBlock < blockColumns; ++jBlock) {\n                final int qStart = jBlock * BLOCK_SIZE;\n                final int qEnd = FastMath.min(qStart + BLOCK_SIZE, columns);\n                final int jWidth = qEnd - qStart;\n\n                // allocate new block\n                final double[] block = new double[iHeight * jWidth];\n                blocks[blockIndex] = block;\n\n                // copy data\n                int index = 0;\n                for (int p = pStart; p < pEnd; ++p) {\n                    System.arraycopy(rawData[p], qStart, block, index, jWidth);\n                    index += jWidth;\n                }\n                ++blockIndex;\n            }\n        }\n\n        return blocks;\n    }",
    "comment": " Convert a data array from raw layout to blocks layout. <p> Raw layout is the straightforward layout where element at row i and column j is in array element <code>rawData[i][j]</code>. Blocks layout is the layout used in {@link BlockRealMatrix} instances, where the matrix is split in square blocks (except at right and bottom side where blocks may be rectangular to fit matrix size) and each block is stored in a flattened one-dimensional array. </p> <p> This method creates an array in blocks layout from an input array in raw layout. It can be used to provide the array argument of the {@link #BlockRealMatrix(int, int, double[][], boolean)} constructor. </p> @param rawData Data array in raw layout. @return a new data array containing the same entries but in blocks layout. @throws DimensionMismatchException if {@code rawData} is not rectangular. @see #createBlocksLayout(int, int) @see #BlockRealMatrix(int, int, double[][], boolean) ",
    "is_bug": false,
    "failing_test_cases": 28,
    "buggy_methods": 7
  },
  {
    "name": "BlockRealMatrix.transpose",
    "class_name": "org.apache.commons.math3.linear.BlockRealMatrix",
    "signature": "org.apache.commons.math3.linear.BlockRealMatrix.transpose()",
    "snippet": "    @Override\n    public BlockRealMatrix transpose() {\n        final int nRows = getRowDimension();\n        final int nCols = getColumnDimension();\n        final BlockRealMatrix out = new BlockRealMatrix(nCols, nRows);\n\n        // perform transpose block-wise, to ensure good cache behavior\n        int blockIndex = 0;\n        for (int iBlock = 0; iBlock < blockColumns; ++iBlock) {\n            for (int jBlock = 0; jBlock < blockRows; ++jBlock) {\n                // transpose current block\n                final double[] outBlock = out.blocks[blockIndex];\n                final double[] tBlock = blocks[jBlock * blockColumns + iBlock];\n                final int pStart = iBlock * BLOCK_SIZE;\n                final int pEnd = FastMath.min(pStart + BLOCK_SIZE, columns);\n                final int qStart = jBlock * BLOCK_SIZE;\n                final int qEnd = FastMath.min(qStart + BLOCK_SIZE, rows);\n                int k = 0;\n                for (int p = pStart; p < pEnd; ++p) {\n                    final int lInc = pEnd - pStart;\n                    int l = p - pStart;\n                    for (int q = qStart; q < qEnd; ++q) {\n                        outBlock[k] = tBlock[l];\n                        ++k;\n                        l+= lInc;\n                    }\n                }\n                // go to next block\n                ++blockIndex;\n            }\n        }\n\n        return out;\n    }",
    "comment": "{@inheritDoc} */",
    "is_bug": false,
    "failing_test_cases": 28,
    "buggy_methods": 7
  },
  {
    "name": "DefaultRealMatrixPreservingVisitor.end",
    "class_name": "org.apache.commons.math3.linear.DefaultRealMatrixPreservingVisitor",
    "signature": "org.apache.commons.math3.linear.DefaultRealMatrixPreservingVisitor.end()",
    "snippet": "    public double end() {\n        return 0;\n    }",
    "comment": "{@inheritDoc} */",
    "is_bug": false,
    "failing_test_cases": 28,
    "buggy_methods": 7
  },
  {
    "name": "DefaultRealMatrixPreservingVisitor.start",
    "class_name": "org.apache.commons.math3.linear.DefaultRealMatrixPreservingVisitor",
    "signature": "org.apache.commons.math3.linear.DefaultRealMatrixPreservingVisitor.start(int,int,int,int,int,int)",
    "snippet": "    public void start(int rows, int columns,\n                      int startRow, int endRow, int startColumn, int endColumn) {\n    }",
    "comment": "{@inheritDoc} */",
    "is_bug": false,
    "failing_test_cases": 28,
    "buggy_methods": 7
  },
  {
    "name": "DiagonalMatrix.DiagonalMatrix",
    "class_name": "org.apache.commons.math3.linear.DiagonalMatrix",
    "signature": "org.apache.commons.math3.linear.DiagonalMatrix.DiagonalMatrix(double[])",
    "snippet": "    public DiagonalMatrix(final double[] d) {\n        this(d, true);\n    }",
    "comment": " Creates a matrix using the input array as the underlying data. <br/> The input array is copied, not referenced.  @param d Data for the new matrix. ",
    "is_bug": false,
    "failing_test_cases": 28,
    "buggy_methods": 7
  },
  {
    "name": "DiagonalMatrix.DiagonalMatrix",
    "class_name": "org.apache.commons.math3.linear.DiagonalMatrix",
    "signature": "org.apache.commons.math3.linear.DiagonalMatrix.DiagonalMatrix(double[],boolean)",
    "snippet": "    public DiagonalMatrix(final double[] d, final boolean copyArray)\n        throws NullArgumentException {\n        MathUtils.checkNotNull(d);\n        data = copyArray ? d.clone() : d;\n    }",
    "comment": " Creates a matrix using the input array as the underlying data. <br/> If an array is created specially in order to be embedded in a this instance and not used directly, the {@code copyArray} may be set to {@code false}. This will prevent the copying and improve performance as no new array will be built and no data will be copied.  @param d Data for new matrix. @param copyArray if {@code true}, the input array will be copied, otherwise it will be referenced. @exception NullArgumentException if d is null ",
    "is_bug": false,
    "failing_test_cases": 28,
    "buggy_methods": 7
  },
  {
    "name": "DiagonalMatrix.DiagonalMatrix",
    "class_name": "org.apache.commons.math3.linear.DiagonalMatrix",
    "signature": "org.apache.commons.math3.linear.DiagonalMatrix.DiagonalMatrix(int)",
    "snippet": "    public DiagonalMatrix(final int dimension)\n        throws NotStrictlyPositiveException {\n        super(dimension, dimension);\n        data = new double[dimension];\n    }",
    "comment": " Creates a matrix with the supplied dimension.  @param dimension Number of rows and columns in the new matrix. @throws NotStrictlyPositiveException if the dimension is not positive. ",
    "is_bug": false,
    "failing_test_cases": 28,
    "buggy_methods": 7
  },
  {
    "name": "DiagonalMatrix.copy",
    "class_name": "org.apache.commons.math3.linear.DiagonalMatrix",
    "signature": "org.apache.commons.math3.linear.DiagonalMatrix.copy()",
    "snippet": "    @Override\n    public RealMatrix copy() {\n        return new DiagonalMatrix(data);\n    }",
    "comment": "{@inheritDoc} */",
    "is_bug": false,
    "failing_test_cases": 28,
    "buggy_methods": 7
  },
  {
    "name": "DiagonalMatrix.getColumnDimension",
    "class_name": "org.apache.commons.math3.linear.DiagonalMatrix",
    "signature": "org.apache.commons.math3.linear.DiagonalMatrix.getColumnDimension()",
    "snippet": "    @Override\n    public int getColumnDimension() {\n        return data.length;\n    }",
    "comment": "{@inheritDoc} */",
    "is_bug": false,
    "failing_test_cases": 28,
    "buggy_methods": 7
  },
  {
    "name": "DiagonalMatrix.getDataRef",
    "class_name": "org.apache.commons.math3.linear.DiagonalMatrix",
    "signature": "org.apache.commons.math3.linear.DiagonalMatrix.getDataRef()",
    "snippet": "    public double[] getDataRef() {\n        return data;\n    }",
    "comment": " Gets a reference to the underlying data array.  @return 1-dimensional array of entries. ",
    "is_bug": false,
    "failing_test_cases": 28,
    "buggy_methods": 7
  },
  {
    "name": "DiagonalMatrix.getEntry",
    "class_name": "org.apache.commons.math3.linear.DiagonalMatrix",
    "signature": "org.apache.commons.math3.linear.DiagonalMatrix.getEntry(int,int)",
    "snippet": "    @Override\n    public double getEntry(final int row, final int column)\n        throws OutOfRangeException {\n        MatrixUtils.checkMatrixIndex(this, row, column);\n        return row == column ? data[row] : 0;\n    }",
    "comment": "{@inheritDoc} */",
    "is_bug": false,
    "failing_test_cases": 28,
    "buggy_methods": 7
  },
  {
    "name": "DiagonalMatrix.getRowDimension",
    "class_name": "org.apache.commons.math3.linear.DiagonalMatrix",
    "signature": "org.apache.commons.math3.linear.DiagonalMatrix.getRowDimension()",
    "snippet": "    @Override\n    public int getRowDimension() {\n        return data.length;\n    }",
    "comment": "{@inheritDoc} */",
    "is_bug": false,
    "failing_test_cases": 28,
    "buggy_methods": 7
  },
  {
    "name": "DiagonalMatrix.multiply",
    "class_name": "org.apache.commons.math3.linear.DiagonalMatrix",
    "signature": "org.apache.commons.math3.linear.DiagonalMatrix.multiply(DiagonalMatrix)",
    "snippet": "    public DiagonalMatrix multiply(final DiagonalMatrix m)\n        throws DimensionMismatchException {\n        MatrixUtils.checkMultiplicationCompatible(this, m);\n\n        final int dim = getRowDimension();\n        final double[] outData = new double[dim];\n        for (int i = 0; i < dim; i++) {\n            outData[i] = data[i] * m.data[i];\n        }\n\n        return new DiagonalMatrix(outData, false);\n    }",
    "comment": " Returns the result of postmultiplying {@code this} by {@code m}.  @param m matrix to postmultiply by @return {@code this * m} @throws DimensionMismatchException if {@code columnDimension(this) != rowDimension(m)} ",
    "is_bug": false,
    "failing_test_cases": 28,
    "buggy_methods": 7
  },
  {
    "name": "DiagonalMatrix.multiply",
    "class_name": "org.apache.commons.math3.linear.DiagonalMatrix",
    "signature": "org.apache.commons.math3.linear.DiagonalMatrix.multiply(RealMatrix)",
    "snippet": "    public RealMatrix multiply(final RealMatrix m)\n        throws DimensionMismatchException {\n        if (m instanceof DiagonalMatrix) {\n            return multiply((DiagonalMatrix) m);\n        } else {\n            MatrixUtils.checkMultiplicationCompatible(this, m);\n            final int nRows = m.getRowDimension();\n            final int nCols = m.getColumnDimension();\n            final double[][] product = new double[nRows][nCols];\n            for (int r = 0; r < nRows; r++) {\n                for (int c = 0; c < nCols; c++) {\n                    product[r][c] = data[r] * m.getEntry(r, c);\n                }\n            }\n            return new Array2DRowRealMatrix(product, false);\n        }\n    }",
    "comment": " Returns the result of postmultiplying {@code this} by {@code m}.  @param m matrix to postmultiply by @return {@code this * m} @throws DimensionMismatchException if {@code columnDimension(this) != rowDimension(m)} ",
    "is_bug": false,
    "failing_test_cases": 28,
    "buggy_methods": 7
  },
  {
    "name": "DiagonalMatrix.operate",
    "class_name": "org.apache.commons.math3.linear.DiagonalMatrix",
    "signature": "org.apache.commons.math3.linear.DiagonalMatrix.operate(double[])",
    "snippet": "    @Override\n    public double[] operate(final double[] v)\n        throws DimensionMismatchException {\n        return multiply(new DiagonalMatrix(v, false)).getDataRef();\n    }",
    "comment": "{@inheritDoc} */",
    "is_bug": false,
    "failing_test_cases": 28,
    "buggy_methods": 7
  },
  {
    "name": "DiagonalMatrix.setEntry",
    "class_name": "org.apache.commons.math3.linear.DiagonalMatrix",
    "signature": "org.apache.commons.math3.linear.DiagonalMatrix.setEntry(int,int,double)",
    "snippet": "    @Override\n    public void setEntry(final int row, final int column, final double value)\n        throws OutOfRangeException, NumberIsTooLargeException {\n        if (row == column) {\n            MatrixUtils.checkRowIndex(this, row);\n            data[row] = value;\n        } else {\n            ensureZero(value);\n        }\n    }",
    "comment": "{@inheritDoc} @throws NumberIsTooLargeException if {@code row != column} and value is non-zero. ",
    "is_bug": false,
    "failing_test_cases": 28,
    "buggy_methods": 7
  },
  {
    "name": "LUDecomposition.LUDecomposition",
    "class_name": "org.apache.commons.math3.linear.LUDecomposition",
    "signature": "org.apache.commons.math3.linear.LUDecomposition.LUDecomposition(RealMatrix)",
    "snippet": "    public LUDecomposition(RealMatrix matrix) {\n        this(matrix, DEFAULT_TOO_SMALL);\n    }",
    "comment": " Calculates the LU-decomposition of the given matrix. This constructor uses 1e-11 as default value for the singularity threshold.  @param matrix Matrix to decompose. @throws NonSquareMatrixException if matrix is not square. ",
    "is_bug": false,
    "failing_test_cases": 28,
    "buggy_methods": 7
  },
  {
    "name": "LUDecomposition.LUDecomposition",
    "class_name": "org.apache.commons.math3.linear.LUDecomposition",
    "signature": "org.apache.commons.math3.linear.LUDecomposition.LUDecomposition(RealMatrix,double)",
    "snippet": "    public LUDecomposition(RealMatrix matrix, double singularityThreshold) {\n        if (!matrix.isSquare()) {\n            throw new NonSquareMatrixException(matrix.getRowDimension(),\n                                               matrix.getColumnDimension());\n        }\n\n        final int m = matrix.getColumnDimension();\n        lu = matrix.getData();\n        pivot = new int[m];\n        cachedL = null;\n        cachedU = null;\n        cachedP = null;\n\n        // Initialize permutation array and parity\n        for (int row = 0; row < m; row++) {\n            pivot[row] = row;\n        }\n        even     = true;\n        singular = false;\n\n        // Loop over columns\n        for (int col = 0; col < m; col++) {\n\n            // upper\n            for (int row = 0; row < col; row++) {\n                final double[] luRow = lu[row];\n                double sum = luRow[col];\n                for (int i = 0; i < row; i++) {\n                    sum -= luRow[i] * lu[i][col];\n                }\n                luRow[col] = sum;\n            }\n\n            // lower\n            int max = col; // permutation row\n            double largest = Double.NEGATIVE_INFINITY;\n            for (int row = col; row < m; row++) {\n                final double[] luRow = lu[row];\n                double sum = luRow[col];\n                for (int i = 0; i < col; i++) {\n                    sum -= luRow[i] * lu[i][col];\n                }\n                luRow[col] = sum;\n\n                // maintain best permutation choice\n                if (FastMath.abs(sum) > largest) {\n                    largest = FastMath.abs(sum);\n                    max = row;\n                }\n            }\n\n            // Singularity check\n            if (FastMath.abs(lu[max][col]) < singularityThreshold) {\n                singular = true;\n                return;\n            }\n\n            // Pivot if necessary\n            if (max != col) {\n                double tmp = 0;\n                final double[] luMax = lu[max];\n                final double[] luCol = lu[col];\n                for (int i = 0; i < m; i++) {\n                    tmp = luMax[i];\n                    luMax[i] = luCol[i];\n                    luCol[i] = tmp;\n                }\n                int temp = pivot[max];\n                pivot[max] = pivot[col];\n                pivot[col] = temp;\n                even = !even;\n            }\n\n            // Divide the lower elements by the \"winning\" diagonal elt.\n            final double luDiag = lu[col][col];\n            for (int row = col + 1; row < m; row++) {\n                lu[row][col] /= luDiag;\n            }\n        }\n    }",
    "comment": " Calculates the LU-decomposition of the given matrix. @param matrix The matrix to decompose. @param singularityThreshold threshold (based on partial row norm) under which a matrix is considered singular @throws NonSquareMatrixException if matrix is not square ",
    "is_bug": false,
    "failing_test_cases": 28,
    "buggy_methods": 7
  },
  {
    "name": "LUDecomposition.getSolver",
    "class_name": "org.apache.commons.math3.linear.LUDecomposition",
    "signature": "org.apache.commons.math3.linear.LUDecomposition.getSolver()",
    "snippet": "    public DecompositionSolver getSolver() {\n        return new Solver(lu, pivot, singular);\n    }",
    "comment": " Get a solver for finding the A &times; X = B solution in exact linear sense. @return a solver ",
    "is_bug": false,
    "failing_test_cases": 28,
    "buggy_methods": 7
  },
  {
    "name": "Solver.solve",
    "class_name": "org.apache.commons.math3.linear.LUDecomposition$Solver",
    "signature": "org.apache.commons.math3.linear.LUDecomposition$Solver.solve(RealVector)",
    "snippet": "        public RealVector solve(RealVector b) {\n            final int m = pivot.length;\n            if (b.getDimension() != m) {\n                throw new DimensionMismatchException(b.getDimension(), m);\n            }\n            if (singular) {\n                throw new SingularMatrixException();\n            }\n\n            final double[] bp = new double[m];\n\n            // Apply permutations to b\n            for (int row = 0; row < m; row++) {\n                bp[row] = b.getEntry(pivot[row]);\n            }\n\n            // Solve LY = b\n            for (int col = 0; col < m; col++) {\n                final double bpCol = bp[col];\n                for (int i = col + 1; i < m; i++) {\n                    bp[i] -= bpCol * lu[i][col];\n                }\n            }\n\n            // Solve UX = Y\n            for (int col = m - 1; col >= 0; col--) {\n                bp[col] /= lu[col][col];\n                final double bpCol = bp[col];\n                for (int i = 0; i < col; i++) {\n                    bp[i] -= bpCol * lu[i][col];\n                }\n            }\n\n            return new ArrayRealVector(bp, false);\n        }",
    "comment": "{@inheritDoc} */",
    "is_bug": false,
    "failing_test_cases": 28,
    "buggy_methods": 7
  },
  {
    "name": "MatrixUtils.checkAdditionCompatible",
    "class_name": "org.apache.commons.math3.linear.MatrixUtils",
    "signature": "org.apache.commons.math3.linear.MatrixUtils.checkAdditionCompatible(AnyMatrix,AnyMatrix)",
    "snippet": "    public static void checkAdditionCompatible(final AnyMatrix left, final AnyMatrix right)\n        throws MatrixDimensionMismatchException {\n        if ((left.getRowDimension()    != right.getRowDimension()) ||\n            (left.getColumnDimension() != right.getColumnDimension())) {\n            throw new MatrixDimensionMismatchException(left.getRowDimension(), left.getColumnDimension(),\n                                                       right.getRowDimension(), right.getColumnDimension());\n        }\n    }",
    "comment": " Check if matrices are addition compatible.  @param left Left hand side matrix. @param right Right hand side matrix. @throws MatrixDimensionMismatchException if the matrices are not addition compatible. ",
    "is_bug": false,
    "failing_test_cases": 28,
    "buggy_methods": 7
  },
  {
    "name": "MatrixUtils.checkColumnIndex",
    "class_name": "org.apache.commons.math3.linear.MatrixUtils",
    "signature": "org.apache.commons.math3.linear.MatrixUtils.checkColumnIndex(AnyMatrix,int)",
    "snippet": "    public static void checkColumnIndex(final AnyMatrix m, final int column)\n        throws OutOfRangeException {\n        if (column < 0 || column >= m.getColumnDimension()) {\n            throw new OutOfRangeException(LocalizedFormats.COLUMN_INDEX,\n                                           column, 0, m.getColumnDimension() - 1);\n        }\n    }",
    "comment": " Check if a column index is valid.  @param m Matrix. @param column Column index to check. @throws OutOfRangeException if {@code column} is not a valid index. ",
    "is_bug": false,
    "failing_test_cases": 28,
    "buggy_methods": 7
  },
  {
    "name": "MatrixUtils.checkMatrixIndex",
    "class_name": "org.apache.commons.math3.linear.MatrixUtils",
    "signature": "org.apache.commons.math3.linear.MatrixUtils.checkMatrixIndex(AnyMatrix,int,int)",
    "snippet": "    public static void checkMatrixIndex(final AnyMatrix m,\n                                        final int row, final int column)\n        throws OutOfRangeException {\n        checkRowIndex(m, row);\n        checkColumnIndex(m, column);\n    }",
    "comment": " Check if matrix indices are valid.  @param m Matrix. @param row Row index to check. @param column Column index to check. @throws OutOfRangeException if {@code row} or {@code column} is not a valid index. ",
    "is_bug": false,
    "failing_test_cases": 28,
    "buggy_methods": 7
  },
  {
    "name": "MatrixUtils.checkMultiplicationCompatible",
    "class_name": "org.apache.commons.math3.linear.MatrixUtils",
    "signature": "org.apache.commons.math3.linear.MatrixUtils.checkMultiplicationCompatible(AnyMatrix,AnyMatrix)",
    "snippet": "    public static void checkMultiplicationCompatible(final AnyMatrix left, final AnyMatrix right)\n        throws DimensionMismatchException {\n\n        if (left.getColumnDimension() != right.getRowDimension()) {\n            throw new DimensionMismatchException(left.getColumnDimension(),\n                                                 right.getRowDimension());\n        }\n    }",
    "comment": " Check if matrices are multiplication compatible  @param left Left hand side matrix. @param right Right hand side matrix. @throws DimensionMismatchException if matrices are not multiplication compatible. ",
    "is_bug": false,
    "failing_test_cases": 28,
    "buggy_methods": 7
  },
  {
    "name": "MatrixUtils.checkRowIndex",
    "class_name": "org.apache.commons.math3.linear.MatrixUtils",
    "signature": "org.apache.commons.math3.linear.MatrixUtils.checkRowIndex(AnyMatrix,int)",
    "snippet": "    public static void checkRowIndex(final AnyMatrix m, final int row)\n        throws OutOfRangeException {\n        if (row < 0 ||\n            row >= m.getRowDimension()) {\n            throw new OutOfRangeException(LocalizedFormats.ROW_INDEX,\n                                          row, 0, m.getRowDimension() - 1);\n        }\n    }",
    "comment": " Check if a row index is valid.  @param m Matrix. @param row Row index to check. @throws OutOfRangeException if {@code row} is not a valid index. ",
    "is_bug": false,
    "failing_test_cases": 28,
    "buggy_methods": 7
  },
  {
    "name": "MatrixUtils.checkSubtractionCompatible",
    "class_name": "org.apache.commons.math3.linear.MatrixUtils",
    "signature": "org.apache.commons.math3.linear.MatrixUtils.checkSubtractionCompatible(AnyMatrix,AnyMatrix)",
    "snippet": "    public static void checkSubtractionCompatible(final AnyMatrix left, final AnyMatrix right)\n        throws MatrixDimensionMismatchException {\n        if ((left.getRowDimension()    != right.getRowDimension()) ||\n            (left.getColumnDimension() != right.getColumnDimension())) {\n            throw new MatrixDimensionMismatchException(left.getRowDimension(), left.getColumnDimension(),\n                                                       right.getRowDimension(), right.getColumnDimension());\n        }\n    }",
    "comment": " Check if matrices are subtraction compatible  @param left Left hand side matrix. @param right Right hand side matrix. @throws MatrixDimensionMismatchException if the matrices are not addition compatible. ",
    "is_bug": false,
    "failing_test_cases": 28,
    "buggy_methods": 7
  },
  {
    "name": "MatrixUtils.createColumnRealMatrix",
    "class_name": "org.apache.commons.math3.linear.MatrixUtils",
    "signature": "org.apache.commons.math3.linear.MatrixUtils.createColumnRealMatrix(double[])",
    "snippet": "    public static RealMatrix createColumnRealMatrix(double[] columnData)\n        throws NoDataException, NullArgumentException {\n        if (columnData == null) {\n            throw new NullArgumentException();\n        }\n        final int nRows = columnData.length;\n        final RealMatrix m = createRealMatrix(nRows, 1);\n        for (int i = 0; i < nRows; ++i) {\n            m.setEntry(i, 0, columnData[i]);\n        }\n        return m;\n    }",
    "comment": " Creates a column {@link RealMatrix} using the data from the input array.  @param columnData  the input column data @return a columnData x 1 RealMatrix @throws NoDataException if {@code columnData} is empty. @throws NullArgumentException if {@code columnData} is {@code null}. ",
    "is_bug": false,
    "failing_test_cases": 28,
    "buggy_methods": 7
  },
  {
    "name": "MatrixUtils.createRealDiagonalMatrix",
    "class_name": "org.apache.commons.math3.linear.MatrixUtils",
    "signature": "org.apache.commons.math3.linear.MatrixUtils.createRealDiagonalMatrix(double[])",
    "snippet": "    public static RealMatrix createRealDiagonalMatrix(final double[] diagonal) {\n        final RealMatrix m = createRealMatrix(diagonal.length, diagonal.length);\n        for (int i = 0; i < diagonal.length; ++i) {\n            m.setEntry(i, i, diagonal[i]);\n        }\n        return m;\n    }",
    "comment": " Returns a diagonal matrix with specified elements.  @param diagonal diagonal elements of the matrix (the array elements will be copied) @return diagonal matrix @since 2.0 ",
    "is_bug": false,
    "failing_test_cases": 28,
    "buggy_methods": 7
  },
  {
    "name": "MatrixUtils.createRealMatrix",
    "class_name": "org.apache.commons.math3.linear.MatrixUtils",
    "signature": "org.apache.commons.math3.linear.MatrixUtils.createRealMatrix(double[][])",
    "snippet": "    public static RealMatrix createRealMatrix(double[][] data)\n        throws NullArgumentException, DimensionMismatchException,\n        NoDataException {\n        if (data == null ||\n            data[0] == null) {\n            throw new NullArgumentException();\n        }\n        return (data.length * data[0].length <= 4096) ?\n                new Array2DRowRealMatrix(data) : new BlockRealMatrix(data);\n    }",
    "comment": " Returns a {@link RealMatrix} whose entries are the the values in the the input array. <p>The type of matrix returned depends on the dimension. Below 2<sup>12</sup> elements (i.e. 4096 elements or 64&times;64 for a square matrix) which can be stored in a 32kB array, a {@link Array2DRowRealMatrix} instance is built. Above this threshold a {@link BlockRealMatrix} instance is built.</p> <p>The input array is copied, not referenced.</p>  @param data input array @return  RealMatrix containing the values of the array @throws org.apache.commons.math3.exception.DimensionMismatchException if {@code data} is not rectangular (not all rows have the same length). @throws NoDataException if a row or column is empty. @throws NullArgumentException if either {@code data} or {@code data[0]} is {@code null}. @throws DimensionMismatchException if {@code data} is not rectangular. @see #createRealMatrix(int, int) ",
    "is_bug": false,
    "failing_test_cases": 28,
    "buggy_methods": 7
  },
  {
    "name": "MatrixUtils.createRealMatrix",
    "class_name": "org.apache.commons.math3.linear.MatrixUtils",
    "signature": "org.apache.commons.math3.linear.MatrixUtils.createRealMatrix(int,int)",
    "snippet": "    public static RealMatrix createRealMatrix(final int rows, final int columns) {\n        return (rows * columns <= 4096) ?\n                new Array2DRowRealMatrix(rows, columns) : new BlockRealMatrix(rows, columns);\n    }",
    "comment": " Returns a {@link RealMatrix} with specified dimensions. <p>The type of matrix returned depends on the dimension. Below 2<sup>12</sup> elements (i.e. 4096 elements or 64&times;64 for a square matrix) which can be stored in a 32kB array, a {@link Array2DRowRealMatrix} instance is built. Above this threshold a {@link BlockRealMatrix} instance is built.</p> <p>The matrix elements are all set to 0.0.</p> @param rows number of rows of the matrix @param columns number of columns of the matrix @return  RealMatrix with specified dimensions @see #createRealMatrix(double[][]) ",
    "is_bug": false,
    "failing_test_cases": 28,
    "buggy_methods": 7
  },
  {
    "name": "MatrixUtils.isSymmetric",
    "class_name": "org.apache.commons.math3.linear.MatrixUtils",
    "signature": "org.apache.commons.math3.linear.MatrixUtils.isSymmetric(RealMatrix,double)",
    "snippet": "    public static boolean isSymmetric(RealMatrix matrix,\n                                      double eps) {\n        return isSymmetricInternal(matrix, eps, false);\n    }",
    "comment": " Checks whether a matrix is symmetric.  @param matrix Matrix to check. @param eps Relative tolerance. @return {@code true} if {@code matrix} is symmetric. @since 3.1 ",
    "is_bug": false,
    "failing_test_cases": 28,
    "buggy_methods": 7
  },
  {
    "name": "MatrixUtils.isSymmetricInternal",
    "class_name": "org.apache.commons.math3.linear.MatrixUtils",
    "signature": "org.apache.commons.math3.linear.MatrixUtils.isSymmetricInternal(RealMatrix,double,boolean)",
    "snippet": "    private static boolean isSymmetricInternal(RealMatrix matrix,\n                                               double relativeTolerance,\n                                               boolean raiseException) {\n        final int rows = matrix.getRowDimension();\n        if (rows != matrix.getColumnDimension()) {\n            if (raiseException) {\n                throw new NonSquareMatrixException(rows, matrix.getColumnDimension());\n            } else {\n                return false;\n            }\n        }\n        for (int i = 0; i < rows; i++) {\n            for (int j = i + 1; j < rows; j++) {\n                final double mij = matrix.getEntry(i, j);\n                final double mji = matrix.getEntry(j, i);\n                if (FastMath.abs(mij - mji) >\n                    FastMath.max(FastMath.abs(mij), FastMath.abs(mji)) * relativeTolerance) {\n                    if (raiseException) {\n                        throw new NonSymmetricMatrixException(i, j, relativeTolerance);\n                    } else {\n                        return false;\n                    }\n                }\n            }\n        }\n        return true;\n    }",
    "comment": " Checks whether a matrix is symmetric, within a given relative tolerance.  @param matrix Matrix to check. @param relativeTolerance Tolerance of the symmetry check. @param raiseException If {@code true}, an exception will be raised if the matrix is not symmetric. @return {@code true} if {@code matrix} is symmetric. @throws NonSquareMatrixException if the matrix is not square. @throws NonSymmetricMatrixException if the matrix is not symmetric. ",
    "is_bug": false,
    "failing_test_cases": 28,
    "buggy_methods": 7
  },
  {
    "name": "RealMatrixFormat.RealMatrixFormat",
    "class_name": "org.apache.commons.math3.linear.RealMatrixFormat",
    "signature": "org.apache.commons.math3.linear.RealMatrixFormat.RealMatrixFormat(NumberFormat)",
    "snippet": "    public RealMatrixFormat(final NumberFormat format) {\n        this(DEFAULT_PREFIX, DEFAULT_SUFFIX, DEFAULT_ROW_PREFIX, DEFAULT_ROW_SUFFIX,\n                DEFAULT_ROW_SEPARATOR, DEFAULT_COLUMN_SEPARATOR, format);\n    }",
    "comment": " Create an instance with a custom number format for components. @param format the custom format for components. ",
    "is_bug": false,
    "failing_test_cases": 28,
    "buggy_methods": 7
  },
  {
    "name": "RealMatrixFormat.RealMatrixFormat",
    "class_name": "org.apache.commons.math3.linear.RealMatrixFormat",
    "signature": "org.apache.commons.math3.linear.RealMatrixFormat.RealMatrixFormat(String,String,String,String,String,String,NumberFormat)",
    "snippet": "    public RealMatrixFormat(final String prefix, final String suffix,\n                            final String rowPrefix, final String rowSuffix,\n                            final String rowSeparator, final String columnSeparator,\n                            final NumberFormat format) {\n        this.prefix            = prefix;\n        this.suffix            = suffix;\n        this.rowPrefix         = rowPrefix;\n        this.rowSuffix         = rowSuffix;\n        this.rowSeparator      = rowSeparator;\n        this.columnSeparator   = columnSeparator;\n        this.format            = format;\n        // disable grouping to prevent parsing problems\n        this.format.setGroupingUsed(false);\n    }",
    "comment": " Create an instance with custom prefix, suffix, separator and format for components. @param prefix prefix to use instead of the default \"{\" @param suffix suffix to use instead of the default \"}\" @param rowPrefix row prefix to use instead of the default \"{\" @param rowSuffix row suffix to use instead of the default \"}\" @param rowSeparator tow separator to use instead of the default \";\" @param columnSeparator column separator to use instead of the default \", \" @param format the custom format for components. ",
    "is_bug": false,
    "failing_test_cases": 28,
    "buggy_methods": 7
  },
  {
    "name": "RealMatrixFormat.getFormat",
    "class_name": "org.apache.commons.math3.linear.RealMatrixFormat",
    "signature": "org.apache.commons.math3.linear.RealMatrixFormat.getFormat()",
    "snippet": "    public NumberFormat getFormat() {\n        return format;\n    }",
    "comment": " Get the components format. @return components format. ",
    "is_bug": false,
    "failing_test_cases": 28,
    "buggy_methods": 7
  },
  {
    "name": "RealMatrixFormat.getInstance",
    "class_name": "org.apache.commons.math3.linear.RealMatrixFormat",
    "signature": "org.apache.commons.math3.linear.RealMatrixFormat.getInstance(Locale)",
    "snippet": "    public static RealMatrixFormat getInstance(final Locale locale) {\n        return new RealMatrixFormat(CompositeFormat.getDefaultNumberFormat(locale));\n    }",
    "comment": " Returns the default real vector format for the given locale. @param locale the specific locale used by the format. @return the real vector format specific to the given locale. ",
    "is_bug": false,
    "failing_test_cases": 28,
    "buggy_methods": 7
  },
  {
    "name": "RealVectorFormat.RealVectorFormat",
    "class_name": "org.apache.commons.math3.linear.RealVectorFormat",
    "signature": "org.apache.commons.math3.linear.RealVectorFormat.RealVectorFormat(NumberFormat)",
    "snippet": "    public RealVectorFormat(final NumberFormat format) {\n        this(DEFAULT_PREFIX, DEFAULT_SUFFIX, DEFAULT_SEPARATOR, format);\n    }",
    "comment": " Create an instance with a custom number format for components. @param format the custom format for components. ",
    "is_bug": false,
    "failing_test_cases": 28,
    "buggy_methods": 7
  },
  {
    "name": "RealVectorFormat.RealVectorFormat",
    "class_name": "org.apache.commons.math3.linear.RealVectorFormat",
    "signature": "org.apache.commons.math3.linear.RealVectorFormat.RealVectorFormat(String,String,String,NumberFormat)",
    "snippet": "    public RealVectorFormat(final String prefix, final String suffix,\n                            final String separator, final NumberFormat format) {\n        this.prefix      = prefix;\n        this.suffix      = suffix;\n        this.separator   = separator;\n        trimmedPrefix    = prefix.trim();\n        trimmedSuffix    = suffix.trim();\n        trimmedSeparator = separator.trim();\n        this.format      = format;\n    }",
    "comment": " Create an instance with custom prefix, suffix, separator and format for components. @param prefix prefix to use instead of the default \"{\" @param suffix suffix to use instead of the default \"}\" @param separator separator to use instead of the default \"; \" @param format the custom format for components. ",
    "is_bug": false,
    "failing_test_cases": 28,
    "buggy_methods": 7
  },
  {
    "name": "RealVectorFormat.getInstance",
    "class_name": "org.apache.commons.math3.linear.RealVectorFormat",
    "signature": "org.apache.commons.math3.linear.RealVectorFormat.getInstance()",
    "snippet": "    public static RealVectorFormat getInstance() {\n        return getInstance(Locale.getDefault());\n    }",
    "comment": " Returns the default real vector format for the current locale. @return the default real vector format. ",
    "is_bug": false,
    "failing_test_cases": 28,
    "buggy_methods": 7
  },
  {
    "name": "RealVectorFormat.getInstance",
    "class_name": "org.apache.commons.math3.linear.RealVectorFormat",
    "signature": "org.apache.commons.math3.linear.RealVectorFormat.getInstance(Locale)",
    "snippet": "    public static RealVectorFormat getInstance(final Locale locale) {\n        return new RealVectorFormat(CompositeFormat.getDefaultNumberFormat(locale));\n    }",
    "comment": " Returns the default real vector format for the given locale. @param locale the specific locale used by the format. @return the real vector format specific to the given locale. ",
    "is_bug": false,
    "failing_test_cases": 28,
    "buggy_methods": 7
  },
  {
    "name": "AbstractConvergenceChecker.AbstractConvergenceChecker",
    "class_name": "org.apache.commons.math3.optim.AbstractConvergenceChecker",
    "signature": "org.apache.commons.math3.optim.AbstractConvergenceChecker.AbstractConvergenceChecker(double,double)",
    "snippet": "    public AbstractConvergenceChecker(final double relativeThreshold,\n                                      final double absoluteThreshold) {\n        this.relativeThreshold = relativeThreshold;\n        this.absoluteThreshold = absoluteThreshold;\n    }",
    "comment": " Build an instance with a specified thresholds.  @param relativeThreshold relative tolerance threshold @param absoluteThreshold absolute tolerance threshold ",
    "is_bug": false,
    "failing_test_cases": 28,
    "buggy_methods": 7
  },
  {
    "name": "AbstractConvergenceChecker.getAbsoluteThreshold",
    "class_name": "org.apache.commons.math3.optim.AbstractConvergenceChecker",
    "signature": "org.apache.commons.math3.optim.AbstractConvergenceChecker.getAbsoluteThreshold()",
    "snippet": "    public double getAbsoluteThreshold() {\n        return absoluteThreshold;\n    }",
    "comment": " @return the absolute threshold. ",
    "is_bug": false,
    "failing_test_cases": 28,
    "buggy_methods": 7
  },
  {
    "name": "AbstractConvergenceChecker.getRelativeThreshold",
    "class_name": "org.apache.commons.math3.optim.AbstractConvergenceChecker",
    "signature": "org.apache.commons.math3.optim.AbstractConvergenceChecker.getRelativeThreshold()",
    "snippet": "    public double getRelativeThreshold() {\n        return relativeThreshold;\n    }",
    "comment": " @return the relative threshold. ",
    "is_bug": false,
    "failing_test_cases": 28,
    "buggy_methods": 7
  },
  {
    "name": "BaseMultivariateOptimizer.BaseMultivariateOptimizer",
    "class_name": "org.apache.commons.math3.optim.BaseMultivariateOptimizer",
    "signature": "org.apache.commons.math3.optim.BaseMultivariateOptimizer.BaseMultivariateOptimizer(ConvergenceChecker)",
    "snippet": "    protected BaseMultivariateOptimizer(ConvergenceChecker<PAIR> checker) {\n        super(checker);\n    }",
    "comment": " @param checker Convergence checker. ",
    "is_bug": false,
    "failing_test_cases": 28,
    "buggy_methods": 7
  },
  {
    "name": "BaseMultivariateOptimizer.checkParameters",
    "class_name": "org.apache.commons.math3.optim.BaseMultivariateOptimizer",
    "signature": "org.apache.commons.math3.optim.BaseMultivariateOptimizer.checkParameters()",
    "snippet": "    private void checkParameters() {\n        if (start != null) {\n            final int dim = start.length;\n            if (lowerBound != null) {\n                if (lowerBound.length != dim) {\n                    throw new DimensionMismatchException(lowerBound.length, dim);\n                }\n                for (int i = 0; i < dim; i++) {\n                    final double v = start[i];\n                    final double lo = lowerBound[i];\n                    if (v < lo) {\n                        throw new NumberIsTooSmallException(v, lo, true);\n                    }\n                }\n            }\n            if (upperBound != null) {\n                if (upperBound.length != dim) {\n                    throw new DimensionMismatchException(upperBound.length, dim);\n                }\n                for (int i = 0; i < dim; i++) {\n                    final double v = start[i];\n                    final double hi = upperBound[i];\n                    if (v > hi) {\n                        throw new NumberIsTooLargeException(v, hi, true);\n                    }\n                }\n            }\n        }\n    }",
    "comment": " Check parameters consistency. ",
    "is_bug": false,
    "failing_test_cases": 28,
    "buggy_methods": 7
  },
  {
    "name": "BaseMultivariateOptimizer.getLowerBound",
    "class_name": "org.apache.commons.math3.optim.BaseMultivariateOptimizer",
    "signature": "org.apache.commons.math3.optim.BaseMultivariateOptimizer.getLowerBound()",
    "snippet": "    public double[] getLowerBound() {\n        return lowerBound == null ? null : lowerBound.clone();\n    }",
    "comment": " @return the lower bounds, or {@code null} if not set. ",
    "is_bug": false,
    "failing_test_cases": 28,
    "buggy_methods": 7
  },
  {
    "name": "BaseMultivariateOptimizer.getStartPoint",
    "class_name": "org.apache.commons.math3.optim.BaseMultivariateOptimizer",
    "signature": "org.apache.commons.math3.optim.BaseMultivariateOptimizer.getStartPoint()",
    "snippet": "    public double[] getStartPoint() {\n        return start == null ? null : start.clone();\n    }",
    "comment": " Gets the initial guess.  @return the initial guess, or {@code null} if not set. ",
    "is_bug": false,
    "failing_test_cases": 28,
    "buggy_methods": 7
  },
  {
    "name": "BaseMultivariateOptimizer.getUpperBound",
    "class_name": "org.apache.commons.math3.optim.BaseMultivariateOptimizer",
    "signature": "org.apache.commons.math3.optim.BaseMultivariateOptimizer.getUpperBound()",
    "snippet": "    public double[] getUpperBound() {\n        return upperBound == null ? null : upperBound.clone();\n    }",
    "comment": " @return the upper bounds, or {@code null} if not set. ",
    "is_bug": false,
    "failing_test_cases": 28,
    "buggy_methods": 7
  },
  {
    "name": "BaseMultivariateOptimizer.optimize",
    "class_name": "org.apache.commons.math3.optim.BaseMultivariateOptimizer",
    "signature": "org.apache.commons.math3.optim.BaseMultivariateOptimizer.optimize(OptimizationData[])",
    "snippet": "    @Override\n    public PAIR optimize(OptimizationData... optData) {\n        // Perform optimization.\n        return super.optimize(optData);\n    }",
    "comment": " {@inheritDoc}  @param optData Optimization data. In addition to those documented in {@link BaseOptimizer#parseOptimizationData(OptimizationData[]) BaseOptimizer}, this method will register the following data: <ul> <li>{@link InitialGuess}</li> <li>{@link SimpleBounds}</li> </ul> @return {@inheritDoc} ",
    "is_bug": false,
    "failing_test_cases": 28,
    "buggy_methods": 7
  },
  {
    "name": "BaseMultivariateOptimizer.parseOptimizationData",
    "class_name": "org.apache.commons.math3.optim.BaseMultivariateOptimizer",
    "signature": "org.apache.commons.math3.optim.BaseMultivariateOptimizer.parseOptimizationData(OptimizationData[])",
    "snippet": "    @Override\n    protected void parseOptimizationData(OptimizationData... optData) {\n        // Allow base class to register its own data.\n        super.parseOptimizationData(optData);\n\n        // The existing values (as set by the previous call) are reused if\n        // not provided in the argument list.\n        for (OptimizationData data : optData) {\n            if (data instanceof InitialGuess) {\n                start = ((InitialGuess) data).getInitialGuess();\n                continue;\n            }\n            if (data instanceof SimpleBounds) {\n                final SimpleBounds bounds = (SimpleBounds) data;\n                lowerBound = bounds.getLower();\n                upperBound = bounds.getUpper();\n                continue;\n            }\n        }\n\n        // Check input consistency.\n        checkParameters();\n    }",
    "comment": " Scans the list of (required and optional) optimization data that characterize the problem.  @param optData Optimization data. The following data will be looked for: <ul> <li>{@link InitialGuess}</li> <li>{@link SimpleBounds}</li> </ul> ",
    "is_bug": false,
    "failing_test_cases": 28,
    "buggy_methods": 7
  },
  {
    "name": "BaseOptimizer.BaseOptimizer",
    "class_name": "org.apache.commons.math3.optim.BaseOptimizer",
    "signature": "org.apache.commons.math3.optim.BaseOptimizer.BaseOptimizer(ConvergenceChecker)",
    "snippet": "    protected BaseOptimizer(ConvergenceChecker<PAIR> checker) {\n        this.checker = checker;\n\n        evaluations = new Incrementor(0, new MaxEvalCallback());\n        iterations = new Incrementor(0, new MaxIterCallback());\n    }",
    "comment": " @param checker Convergence checker. ",
    "is_bug": true,
    "failing_test_cases": 28,
    "buggy_methods": 7
  },
  {
    "name": "BaseOptimizer.getConvergenceChecker",
    "class_name": "org.apache.commons.math3.optim.BaseOptimizer",
    "signature": "org.apache.commons.math3.optim.BaseOptimizer.getConvergenceChecker()",
    "snippet": "    public ConvergenceChecker<PAIR> getConvergenceChecker() {\n        return checker;\n    }",
    "comment": " Gets the convergence checker.  @return the object used to check for convergence. ",
    "is_bug": false,
    "failing_test_cases": 28,
    "buggy_methods": 7
  },
  {
    "name": "BaseOptimizer.getIterations",
    "class_name": "org.apache.commons.math3.optim.BaseOptimizer",
    "signature": "org.apache.commons.math3.optim.BaseOptimizer.getIterations()",
    "snippet": "    public int getIterations() {\n        return iterations.getCount();\n    }",
    "comment": " Gets the number of iterations performed by the algorithm. The number iterations corresponds to the last call to the {@code optimize} method. It is 0 if the method has not been called yet.  @return the number of evaluations of the objective function. ",
    "is_bug": false,
    "failing_test_cases": 28,
    "buggy_methods": 7
  },
  {
    "name": "BaseOptimizer.getMaxEvaluations",
    "class_name": "org.apache.commons.math3.optim.BaseOptimizer",
    "signature": "org.apache.commons.math3.optim.BaseOptimizer.getMaxEvaluations()",
    "snippet": "    public int getMaxEvaluations() {\n        return evaluations.getMaximalCount();\n    }",
    "comment": " Gets the maximal number of function evaluations.  @return the maximal number of function evaluations. ",
    "is_bug": false,
    "failing_test_cases": 28,
    "buggy_methods": 7
  },
  {
    "name": "BaseOptimizer.incrementEvaluationCount",
    "class_name": "org.apache.commons.math3.optim.BaseOptimizer",
    "signature": "org.apache.commons.math3.optim.BaseOptimizer.incrementEvaluationCount()",
    "snippet": "    protected void incrementEvaluationCount()\n        throws TooManyEvaluationsException {\n        evaluations.incrementCount();\n    }",
    "comment": " Increment the evaluation count.  @throws TooManyEvaluationsException if the allowed evaluations have been exhausted. ",
    "is_bug": false,
    "failing_test_cases": 28,
    "buggy_methods": 7
  },
  {
    "name": "BaseOptimizer.optimize",
    "class_name": "org.apache.commons.math3.optim.BaseOptimizer",
    "signature": "org.apache.commons.math3.optim.BaseOptimizer.optimize(OptimizationData[])",
    "snippet": "    public PAIR optimize(OptimizationData... optData)\n        throws TooManyEvaluationsException,\n               TooManyIterationsException {\n        // Parse options.\n        parseOptimizationData(optData);\n\n        // Reset counters.\n        evaluations.resetCount();\n        iterations.resetCount();\n        // Perform optimization.\n        return doOptimize();\n    }",
    "comment": " Stores data and performs the optimization. <br/> The list of parameters is open-ended so that sub-classes can extend it with arguments specific to their concrete implementations. <br/> When the method is called multiple times, instance data is overwritten only when actually present in the list of arguments: when not specified, data set in a previous call is retained (and thus is optional in subsequent calls). <br/> Important note: Subclasses <em>must</em> override {@link #parseOptimizationData(OptimizationData[])} if they need to register their own options; but then, they <em>must</em> also call {@code super.parseOptimizationData(optData)} within that method.  @param optData Optimization data. This method will register the following data: <ul> <li>{@link MaxEval}</li> <li>{@link MaxIter}</li> </ul> @return a point/value pair that satifies the convergence criteria. @throws TooManyEvaluationsException if the maximal number of evaluations is exceeded. @throws TooManyIterationsException if the maximal number of iterations is exceeded. ",
    "is_bug": false,
    "failing_test_cases": 28,
    "buggy_methods": 7
  },
  {
    "name": "BaseOptimizer.parseOptimizationData",
    "class_name": "org.apache.commons.math3.optim.BaseOptimizer",
    "signature": "org.apache.commons.math3.optim.BaseOptimizer.parseOptimizationData(OptimizationData[])",
    "snippet": "    protected void parseOptimizationData(OptimizationData... optData) {\n        // The existing values (as set by the previous call) are reused if\n        // not provided in the argument list.\n        for (OptimizationData data : optData) {\n            if (data instanceof MaxEval) {\n                evaluations.setMaximalCount(((MaxEval) data).getMaxEval());\n                continue;\n            }\n            if (data instanceof MaxIter) {\n                iterations.setMaximalCount(((MaxIter) data).getMaxIter());\n                continue;\n            }\n        }\n    }",
    "comment": " Scans the list of (required and optional) optimization data that characterize the problem.  @param optData Optimization data. The following data will be looked for: <ul> <li>{@link MaxEval}</li> <li>{@link MaxIter}</li> </ul> ",
    "is_bug": false,
    "failing_test_cases": 28,
    "buggy_methods": 7
  },
  {
    "name": "InitialGuess.InitialGuess",
    "class_name": "org.apache.commons.math3.optim.InitialGuess",
    "signature": "org.apache.commons.math3.optim.InitialGuess.InitialGuess(double[])",
    "snippet": "    public InitialGuess(double[] startPoint) {\n        init = startPoint.clone();\n    }",
    "comment": " @param startPoint Initial guess. ",
    "is_bug": false,
    "failing_test_cases": 28,
    "buggy_methods": 7
  },
  {
    "name": "InitialGuess.getInitialGuess",
    "class_name": "org.apache.commons.math3.optim.InitialGuess",
    "signature": "org.apache.commons.math3.optim.InitialGuess.getInitialGuess()",
    "snippet": "    public double[] getInitialGuess() {\n        return init.clone();\n    }",
    "comment": " Gets the initial guess.  @return the initial guess. ",
    "is_bug": false,
    "failing_test_cases": 28,
    "buggy_methods": 7
  },
  {
    "name": "MaxEval.MaxEval",
    "class_name": "org.apache.commons.math3.optim.MaxEval",
    "signature": "org.apache.commons.math3.optim.MaxEval.MaxEval(int)",
    "snippet": "    public MaxEval(int max) {\n        if (max <= 0) {\n            throw new NotStrictlyPositiveException(max);\n        }\n\n        maxEval = max;\n    }",
    "comment": " @param max Allowed number of evalutations. @throws NotStrictlyPositiveException if {@code max <= 0}. ",
    "is_bug": false,
    "failing_test_cases": 28,
    "buggy_methods": 7
  },
  {
    "name": "MaxEval.getMaxEval",
    "class_name": "org.apache.commons.math3.optim.MaxEval",
    "signature": "org.apache.commons.math3.optim.MaxEval.getMaxEval()",
    "snippet": "    public int getMaxEval() {\n        return maxEval;\n    }",
    "comment": " Gets the maximum number of evaluations.  @return the allowed number of evaluations. ",
    "is_bug": false,
    "failing_test_cases": 28,
    "buggy_methods": 7
  },
  {
    "name": "PointValuePair.PointValuePair",
    "class_name": "org.apache.commons.math3.optim.PointValuePair",
    "signature": "org.apache.commons.math3.optim.PointValuePair.PointValuePair(double[],double)",
    "snippet": "    public PointValuePair(final double[] point,\n                          final double value) {\n        this(point, value, true);\n    }",
    "comment": " Builds a point/objective function value pair.  @param point Point coordinates. This instance will store a copy of the array, not the array passed as argument. @param value Value of the objective function at the point. ",
    "is_bug": false,
    "failing_test_cases": 28,
    "buggy_methods": 7
  },
  {
    "name": "PointValuePair.PointValuePair",
    "class_name": "org.apache.commons.math3.optim.PointValuePair",
    "signature": "org.apache.commons.math3.optim.PointValuePair.PointValuePair(double[],double,boolean)",
    "snippet": "    public PointValuePair(final double[] point,\n                          final double value,\n                          final boolean copyArray) {\n        super(copyArray ? ((point == null) ? null :\n                           point.clone()) :\n              point,\n              value);\n    }",
    "comment": " Builds a point/objective function value pair.  @param point Point coordinates. @param value Value of the objective function at the point. @param copyArray if {@code true}, the input array will be copied, otherwise it will be referenced. ",
    "is_bug": false,
    "failing_test_cases": 28,
    "buggy_methods": 7
  },
  {
    "name": "PointValuePair.getPoint",
    "class_name": "org.apache.commons.math3.optim.PointValuePair",
    "signature": "org.apache.commons.math3.optim.PointValuePair.getPoint()",
    "snippet": "    public double[] getPoint() {\n        final double[] p = getKey();\n        return p == null ? null : p.clone();\n    }",
    "comment": " Gets the point.  @return a copy of the stored point. ",
    "is_bug": false,
    "failing_test_cases": 28,
    "buggy_methods": 7
  },
  {
    "name": "PointVectorValuePair.PointVectorValuePair",
    "class_name": "org.apache.commons.math3.optim.PointVectorValuePair",
    "signature": "org.apache.commons.math3.optim.PointVectorValuePair.PointVectorValuePair(double[],double[])",
    "snippet": "    public PointVectorValuePair(final double[] point,\n                                final double[] value) {\n        this(point, value, true);\n    }",
    "comment": " Builds a point/objective function value pair.  @param point Point coordinates. This instance will store a copy of the array, not the array passed as argument. @param value Value of the objective function at the point. ",
    "is_bug": false,
    "failing_test_cases": 28,
    "buggy_methods": 7
  },
  {
    "name": "PointVectorValuePair.PointVectorValuePair",
    "class_name": "org.apache.commons.math3.optim.PointVectorValuePair",
    "signature": "org.apache.commons.math3.optim.PointVectorValuePair.PointVectorValuePair(double[],double[],boolean)",
    "snippet": "    public PointVectorValuePair(final double[] point,\n                                final double[] value,\n                                final boolean copyArray) {\n        super(copyArray ?\n              ((point == null) ? null :\n               point.clone()) :\n              point,\n              copyArray ?\n              ((value == null) ? null :\n               value.clone()) :\n              value);\n    }",
    "comment": " Build a point/objective function value pair.  @param point Point coordinates. @param value Value of the objective function at the point. @param copyArray if {@code true}, the input arrays will be copied, otherwise they will be referenced. ",
    "is_bug": false,
    "failing_test_cases": 28,
    "buggy_methods": 7
  },
  {
    "name": "PointVectorValuePair.getValueRef",
    "class_name": "org.apache.commons.math3.optim.PointVectorValuePair",
    "signature": "org.apache.commons.math3.optim.PointVectorValuePair.getValueRef()",
    "snippet": "    public double[] getValueRef() {\n        return super.getValue();\n    }",
    "comment": " Gets a reference to the value of the objective function.  @return a reference to the internal array storing the value of the objective function. ",
    "is_bug": false,
    "failing_test_cases": 28,
    "buggy_methods": 7
  },
  {
    "name": "SimpleBounds.SimpleBounds",
    "class_name": "org.apache.commons.math3.optim.SimpleBounds",
    "signature": "org.apache.commons.math3.optim.SimpleBounds.SimpleBounds(double[],double[])",
    "snippet": "    public SimpleBounds(double[] lB,\n                        double[] uB) {\n        lower = lB.clone();\n        upper = uB.clone();\n    }",
    "comment": " @param lB Lower bounds. @param uB Upper bounds. ",
    "is_bug": false,
    "failing_test_cases": 28,
    "buggy_methods": 7
  },
  {
    "name": "SimpleBounds.getLower",
    "class_name": "org.apache.commons.math3.optim.SimpleBounds",
    "signature": "org.apache.commons.math3.optim.SimpleBounds.getLower()",
    "snippet": "    public double[] getLower() {\n        return lower.clone();\n    }",
    "comment": " Gets the lower bounds.  @return the lower bounds. ",
    "is_bug": false,
    "failing_test_cases": 28,
    "buggy_methods": 7
  },
  {
    "name": "SimpleBounds.getUpper",
    "class_name": "org.apache.commons.math3.optim.SimpleBounds",
    "signature": "org.apache.commons.math3.optim.SimpleBounds.getUpper()",
    "snippet": "    public double[] getUpper() {\n        return upper.clone();\n    }",
    "comment": " Gets the upper bounds.  @return the upper bounds. ",
    "is_bug": false,
    "failing_test_cases": 28,
    "buggy_methods": 7
  },
  {
    "name": "SimpleBounds.unbounded",
    "class_name": "org.apache.commons.math3.optim.SimpleBounds",
    "signature": "org.apache.commons.math3.optim.SimpleBounds.unbounded(int)",
    "snippet": "    public static SimpleBounds unbounded(int dim) {\n        final double[] lB = new double[dim];\n        Arrays.fill(lB, Double.NEGATIVE_INFINITY);\n        final double[] uB = new double[dim];\n        Arrays.fill(uB, Double.POSITIVE_INFINITY);\n\n        return new SimpleBounds(lB, uB);\n    }",
    "comment": " Factory method that creates instance of this class that represents unbounded ranges.  @param dim Number of parameters. @return a new instance suitable for passing to an optimizer that requires bounds specification. ",
    "is_bug": false,
    "failing_test_cases": 28,
    "buggy_methods": 7
  },
  {
    "name": "SimpleValueChecker.SimpleValueChecker",
    "class_name": "org.apache.commons.math3.optim.SimpleValueChecker",
    "signature": "org.apache.commons.math3.optim.SimpleValueChecker.SimpleValueChecker(double,double)",
    "snippet": "    public SimpleValueChecker(final double relativeThreshold,\n                              final double absoluteThreshold) {\n        super(relativeThreshold, absoluteThreshold);\n        maxIterationCount = ITERATION_CHECK_DISABLED;\n    }",
    "comment": "Build an instance with specified thresholds.  In order to perform only relative checks, the absolute tolerance must be set to a negative value. In order to perform only absolute checks, the relative tolerance must be set to a negative value.  @param relativeThreshold relative tolerance threshold @param absoluteThreshold absolute tolerance threshold ",
    "is_bug": false,
    "failing_test_cases": 28,
    "buggy_methods": 7
  },
  {
    "name": "SimpleValueChecker.converged",
    "class_name": "org.apache.commons.math3.optim.SimpleValueChecker",
    "signature": "org.apache.commons.math3.optim.SimpleValueChecker.converged(int,PointValuePair,PointValuePair)",
    "snippet": "    @Override\n    public boolean converged(final int iteration,\n                             final PointValuePair previous,\n                             final PointValuePair current) {\n        if (maxIterationCount != ITERATION_CHECK_DISABLED) {\n            if (iteration >= maxIterationCount) {\n                return true;\n            }\n        }\n\n        final double p = previous.getValue();\n        final double c = current.getValue();\n        final double difference = FastMath.abs(p - c);\n        final double size = FastMath.max(FastMath.abs(p), FastMath.abs(c));\n        return difference <= size * getRelativeThreshold() ||\n            difference <= getAbsoluteThreshold();\n    }",
    "comment": " Check if the optimization algorithm has converged considering the last two points. This method may be called several time from the same algorithm iteration with different points. This can be detected by checking the iteration number at each call if needed. Each time this method is called, the previous and current point correspond to points with the same role at each iteration, so they can be compared. As an example, simplex-based algorithms call this method for all points of the simplex, not only for the best or worst ones.  @param iteration Index of current iteration @param previous Best point in the previous iteration. @param current Best point in the current iteration. @return {@code true} if the algorithm has converged. ",
    "is_bug": false,
    "failing_test_cases": 28,
    "buggy_methods": 7
  },
  {
    "name": "SimpleVectorValueChecker.SimpleVectorValueChecker",
    "class_name": "org.apache.commons.math3.optim.SimpleVectorValueChecker",
    "signature": "org.apache.commons.math3.optim.SimpleVectorValueChecker.SimpleVectorValueChecker(double,double)",
    "snippet": "    public SimpleVectorValueChecker(final double relativeThreshold,\n                                    final double absoluteThreshold) {\n        super(relativeThreshold, absoluteThreshold);\n        maxIterationCount = ITERATION_CHECK_DISABLED;\n    }",
    "comment": " Build an instance with specified thresholds.  In order to perform only relative checks, the absolute tolerance must be set to a negative value. In order to perform only absolute checks, the relative tolerance must be set to a negative value.  @param relativeThreshold relative tolerance threshold @param absoluteThreshold absolute tolerance threshold ",
    "is_bug": false,
    "failing_test_cases": 28,
    "buggy_methods": 7
  },
  {
    "name": "SimpleVectorValueChecker.converged",
    "class_name": "org.apache.commons.math3.optim.SimpleVectorValueChecker",
    "signature": "org.apache.commons.math3.optim.SimpleVectorValueChecker.converged(int,PointVectorValuePair,PointVectorValuePair)",
    "snippet": "    @Override\n    public boolean converged(final int iteration,\n                             final PointVectorValuePair previous,\n                             final PointVectorValuePair current) {\n        if (maxIterationCount != ITERATION_CHECK_DISABLED) {\n            if (iteration >= maxIterationCount) {\n                return true;\n            }\n        }\n\n        final double[] p = previous.getValueRef();\n        final double[] c = current.getValueRef();\n        for (int i = 0; i < p.length; ++i) {\n            final double pi         = p[i];\n            final double ci         = c[i];\n            final double difference = FastMath.abs(pi - ci);\n            final double size       = FastMath.max(FastMath.abs(pi), FastMath.abs(ci));\n            if (difference > size * getRelativeThreshold() &&\n                difference > getAbsoluteThreshold()) {\n                return false;\n            }\n        }\n        return true;\n    }",
    "comment": " Check if the optimization algorithm has converged considering the last two points. This method may be called several times from the same algorithm iteration with different points. This can be detected by checking the iteration number at each call if needed. Each time this method is called, the previous and current point correspond to points with the same role at each iteration, so they can be compared. As an example, simplex-based algorithms call this method for all points of the simplex, not only for the best or worst ones.  @param iteration Index of current iteration @param previous Best point in the previous iteration. @param current Best point in the current iteration. @return {@code true} if the arguments satify the convergence criterion. ",
    "is_bug": false,
    "failing_test_cases": 28,
    "buggy_methods": 7
  },
  {
    "name": "GradientMultivariateOptimizer.GradientMultivariateOptimizer",
    "class_name": "org.apache.commons.math3.optim.nonlinear.scalar.GradientMultivariateOptimizer",
    "signature": "org.apache.commons.math3.optim.nonlinear.scalar.GradientMultivariateOptimizer.GradientMultivariateOptimizer(ConvergenceChecker)",
    "snippet": "    protected GradientMultivariateOptimizer(ConvergenceChecker<PointValuePair> checker) {\n        super(checker);\n    }",
    "comment": " @param checker Convergence checker. ",
    "is_bug": false,
    "failing_test_cases": 28,
    "buggy_methods": 7
  },
  {
    "name": "GradientMultivariateOptimizer.computeObjectiveGradient",
    "class_name": "org.apache.commons.math3.optim.nonlinear.scalar.GradientMultivariateOptimizer",
    "signature": "org.apache.commons.math3.optim.nonlinear.scalar.GradientMultivariateOptimizer.computeObjectiveGradient(double[])",
    "snippet": "    protected double[] computeObjectiveGradient(final double[] params) {\n        return gradient.value(params);\n    }",
    "comment": " Compute the gradient vector.  @param params Point at which the gradient must be evaluated. @return the gradient at the specified point. ",
    "is_bug": false,
    "failing_test_cases": 28,
    "buggy_methods": 7
  },
  {
    "name": "GradientMultivariateOptimizer.optimize",
    "class_name": "org.apache.commons.math3.optim.nonlinear.scalar.GradientMultivariateOptimizer",
    "signature": "org.apache.commons.math3.optim.nonlinear.scalar.GradientMultivariateOptimizer.optimize(OptimizationData[])",
    "snippet": "    @Override\n    public PointValuePair optimize(OptimizationData... optData)\n        throws TooManyEvaluationsException {\n        // Set up base class and perform computation.\n        return super.optimize(optData);\n    }",
    "comment": " {@inheritDoc}  @param optData Optimization data. In addition to those documented in {@link MultivariateOptimizer#parseOptimizationData(OptimizationData[]) MultivariateOptimizer}, this method will register the following data: <ul> <li>{@link ObjectiveFunctionGradient}</li> </ul> @return {@inheritDoc} @throws TooManyEvaluationsException if the maximal number of evaluations (of the objective function) is exceeded. ",
    "is_bug": false,
    "failing_test_cases": 28,
    "buggy_methods": 7
  },
  {
    "name": "GradientMultivariateOptimizer.parseOptimizationData",
    "class_name": "org.apache.commons.math3.optim.nonlinear.scalar.GradientMultivariateOptimizer",
    "signature": "org.apache.commons.math3.optim.nonlinear.scalar.GradientMultivariateOptimizer.parseOptimizationData(OptimizationData[])",
    "snippet": "    @Override\n    protected void parseOptimizationData(OptimizationData... optData) {\n        // Allow base class to register its own data.\n        super.parseOptimizationData(optData);\n\n        // The existing values (as set by the previous call) are reused if\n        // not provided in the argument list.\n        for (OptimizationData data : optData) {\n            if  (data instanceof ObjectiveFunctionGradient) {\n                gradient = ((ObjectiveFunctionGradient) data).getObjectiveFunctionGradient();\n                // If more data must be parsed, this statement _must_ be\n                // changed to \"continue\".\n                break;\n            }\n        }\n    }",
    "comment": " Scans the list of (required and optional) optimization data that characterize the problem.  @param optData Optimization data. The following data will be looked for: <ul> <li>{@link ObjectiveFunctionGradient}</li> </ul> ",
    "is_bug": false,
    "failing_test_cases": 28,
    "buggy_methods": 7
  },
  {
    "name": "MultivariateOptimizer.MultivariateOptimizer",
    "class_name": "org.apache.commons.math3.optim.nonlinear.scalar.MultivariateOptimizer",
    "signature": "org.apache.commons.math3.optim.nonlinear.scalar.MultivariateOptimizer.MultivariateOptimizer(ConvergenceChecker)",
    "snippet": "    protected MultivariateOptimizer(ConvergenceChecker<PointValuePair> checker) {\n        super(checker);\n    }",
    "comment": " @param checker Convergence checker. ",
    "is_bug": false,
    "failing_test_cases": 28,
    "buggy_methods": 7
  },
  {
    "name": "MultivariateOptimizer.computeObjectiveValue",
    "class_name": "org.apache.commons.math3.optim.nonlinear.scalar.MultivariateOptimizer",
    "signature": "org.apache.commons.math3.optim.nonlinear.scalar.MultivariateOptimizer.computeObjectiveValue(double[])",
    "snippet": "    protected double computeObjectiveValue(double[] params) {\n        super.incrementEvaluationCount();\n        return function.value(params);\n    }",
    "comment": " Computes the objective function value. This method <em>must</em> be called by subclasses to enforce the evaluation counter limit.  @param params Point at which the objective function must be evaluated. @return the objective function value at the specified point. @throws TooManyEvaluationsException if the maximal number of evaluations is exceeded. ",
    "is_bug": false,
    "failing_test_cases": 28,
    "buggy_methods": 7
  },
  {
    "name": "MultivariateOptimizer.getGoalType",
    "class_name": "org.apache.commons.math3.optim.nonlinear.scalar.MultivariateOptimizer",
    "signature": "org.apache.commons.math3.optim.nonlinear.scalar.MultivariateOptimizer.getGoalType()",
    "snippet": "    public GoalType getGoalType() {\n        return goal;\n    }",
    "comment": " @return the optimization type. ",
    "is_bug": false,
    "failing_test_cases": 28,
    "buggy_methods": 7
  },
  {
    "name": "MultivariateOptimizer.optimize",
    "class_name": "org.apache.commons.math3.optim.nonlinear.scalar.MultivariateOptimizer",
    "signature": "org.apache.commons.math3.optim.nonlinear.scalar.MultivariateOptimizer.optimize(OptimizationData[])",
    "snippet": "    @Override\n    public PointValuePair optimize(OptimizationData... optData)\n        throws TooManyEvaluationsException {\n        // Set up base class and perform computation.\n        return super.optimize(optData);\n    }",
    "comment": " {@inheritDoc}  @param optData Optimization data. In addition to those documented in {@link BaseMultivariateOptimizer#parseOptimizationData(OptimizationData[]) BaseMultivariateOptimizer}, this method will register the following data: <ul> <li>{@link ObjectiveFunction}</li> <li>{@link GoalType}</li> </ul> @return {@inheritDoc} @throws TooManyEvaluationsException if the maximal number of evaluations is exceeded. ",
    "is_bug": false,
    "failing_test_cases": 28,
    "buggy_methods": 7
  },
  {
    "name": "MultivariateOptimizer.parseOptimizationData",
    "class_name": "org.apache.commons.math3.optim.nonlinear.scalar.MultivariateOptimizer",
    "signature": "org.apache.commons.math3.optim.nonlinear.scalar.MultivariateOptimizer.parseOptimizationData(OptimizationData[])",
    "snippet": "    @Override\n    protected void parseOptimizationData(OptimizationData... optData) {\n        // Allow base class to register its own data.\n        super.parseOptimizationData(optData);\n\n        // The existing values (as set by the previous call) are reused if\n        // not provided in the argument list.\n        for (OptimizationData data : optData) {\n            if (data instanceof GoalType) {\n                goal = (GoalType) data;\n                continue;\n            }\n            if (data instanceof ObjectiveFunction) {\n                function = ((ObjectiveFunction) data).getObjectiveFunction();\n                continue;\n            }\n        }\n    }",
    "comment": " Scans the list of (required and optional) optimization data that characterize the problem.  @param optData Optimization data. The following data will be looked for: <ul> <li>{@link ObjectiveFunction}</li> <li>{@link GoalType}</li> </ul> ",
    "is_bug": false,
    "failing_test_cases": 28,
    "buggy_methods": 7
  },
  {
    "name": "ObjectiveFunction.ObjectiveFunction",
    "class_name": "org.apache.commons.math3.optim.nonlinear.scalar.ObjectiveFunction",
    "signature": "org.apache.commons.math3.optim.nonlinear.scalar.ObjectiveFunction.ObjectiveFunction(MultivariateFunction)",
    "snippet": "    public ObjectiveFunction(MultivariateFunction f) {\n        function = f;\n    }",
    "comment": " @param f Function to be optimized. ",
    "is_bug": false,
    "failing_test_cases": 28,
    "buggy_methods": 7
  },
  {
    "name": "ObjectiveFunction.getObjectiveFunction",
    "class_name": "org.apache.commons.math3.optim.nonlinear.scalar.ObjectiveFunction",
    "signature": "org.apache.commons.math3.optim.nonlinear.scalar.ObjectiveFunction.getObjectiveFunction()",
    "snippet": "    public MultivariateFunction getObjectiveFunction() {\n        return function;\n    }",
    "comment": " Gets the function to be optimized.  @return the objective function. ",
    "is_bug": false,
    "failing_test_cases": 28,
    "buggy_methods": 7
  },
  {
    "name": "ObjectiveFunctionGradient.ObjectiveFunctionGradient",
    "class_name": "org.apache.commons.math3.optim.nonlinear.scalar.ObjectiveFunctionGradient",
    "signature": "org.apache.commons.math3.optim.nonlinear.scalar.ObjectiveFunctionGradient.ObjectiveFunctionGradient(MultivariateVectorFunction)",
    "snippet": "    public ObjectiveFunctionGradient(MultivariateVectorFunction g) {\n        gradient = g;\n    }",
    "comment": " @param g Gradient of the function to be optimized. ",
    "is_bug": false,
    "failing_test_cases": 28,
    "buggy_methods": 7
  },
  {
    "name": "ObjectiveFunctionGradient.getObjectiveFunctionGradient",
    "class_name": "org.apache.commons.math3.optim.nonlinear.scalar.ObjectiveFunctionGradient",
    "signature": "org.apache.commons.math3.optim.nonlinear.scalar.ObjectiveFunctionGradient.getObjectiveFunctionGradient()",
    "snippet": "    public MultivariateVectorFunction getObjectiveFunctionGradient() {\n        return gradient;\n    }",
    "comment": " Gets the gradient of the function to be optimized.  @return the objective function gradient. ",
    "is_bug": false,
    "failing_test_cases": 28,
    "buggy_methods": 7
  },
  {
    "name": "NonLinearConjugateGradientOptimizer.NonLinearConjugateGradientOptimizer",
    "class_name": "org.apache.commons.math3.optim.nonlinear.scalar.gradient.NonLinearConjugateGradientOptimizer",
    "signature": "org.apache.commons.math3.optim.nonlinear.scalar.gradient.NonLinearConjugateGradientOptimizer.NonLinearConjugateGradientOptimizer(Formula,ConvergenceChecker)",
    "snippet": "    public NonLinearConjugateGradientOptimizer(final Formula updateFormula,\n                                               ConvergenceChecker<PointValuePair> checker) {\n        this(updateFormula,\n             checker,\n             new BrentSolver(),\n             new IdentityPreconditioner());\n    }",
    "comment": " Constructor with default {@link BrentSolver line search solver} and {@link IdentityPreconditioner preconditioner}.  @param updateFormula formula to use for updating the &beta; parameter, must be one of {@link Formula#FLETCHER_REEVES} or {@link Formula#POLAK_RIBIERE}. @param checker Convergence checker. ",
    "is_bug": false,
    "failing_test_cases": 28,
    "buggy_methods": 7
  },
  {
    "name": "NonLinearConjugateGradientOptimizer.NonLinearConjugateGradientOptimizer",
    "class_name": "org.apache.commons.math3.optim.nonlinear.scalar.gradient.NonLinearConjugateGradientOptimizer",
    "signature": "org.apache.commons.math3.optim.nonlinear.scalar.gradient.NonLinearConjugateGradientOptimizer.NonLinearConjugateGradientOptimizer(Formula,ConvergenceChecker,UnivariateSolver,Preconditioner)",
    "snippet": "    public NonLinearConjugateGradientOptimizer(final Formula updateFormula,\n                                               ConvergenceChecker<PointValuePair> checker,\n                                               final UnivariateSolver lineSearchSolver,\n                                               final Preconditioner preconditioner) {\n        super(checker);\n\n        this.updateFormula = updateFormula;\n        solver = lineSearchSolver;\n        this.preconditioner = preconditioner;\n        initialStep = 1;\n    }",
    "comment": " @param updateFormula formula to use for updating the &beta; parameter, must be one of {@link Formula#FLETCHER_REEVES} or {@link Formula#POLAK_RIBIERE}. @param checker Convergence checker. @param lineSearchSolver Solver to use during line search. @param preconditioner Preconditioner. ",
    "is_bug": false,
    "failing_test_cases": 28,
    "buggy_methods": 7
  },
  {
    "name": "NonLinearConjugateGradientOptimizer.checkParameters",
    "class_name": "org.apache.commons.math3.optim.nonlinear.scalar.gradient.NonLinearConjugateGradientOptimizer",
    "signature": "org.apache.commons.math3.optim.nonlinear.scalar.gradient.NonLinearConjugateGradientOptimizer.checkParameters()",
    "snippet": "    private void checkParameters() {\n        if (getLowerBound() != null ||\n            getUpperBound() != null) {\n            throw new MathUnsupportedOperationException(LocalizedFormats.CONSTRAINT);\n        }\n    }",
    "comment": " @throws MathUnsupportedOperationException if bounds were passed to the {@link #optimize(OptimizationData[]) optimize} method. ",
    "is_bug": false,
    "failing_test_cases": 28,
    "buggy_methods": 7
  },
  {
    "name": "NonLinearConjugateGradientOptimizer.doOptimize",
    "class_name": "org.apache.commons.math3.optim.nonlinear.scalar.gradient.NonLinearConjugateGradientOptimizer",
    "signature": "org.apache.commons.math3.optim.nonlinear.scalar.gradient.NonLinearConjugateGradientOptimizer.doOptimize()",
    "snippet": "    @Override\n    protected PointValuePair doOptimize() {\n        final ConvergenceChecker<PointValuePair> checker = getConvergenceChecker();\n        final double[] point = getStartPoint();\n        final GoalType goal = getGoalType();\n        final int n = point.length;\n        double[] r = computeObjectiveGradient(point);\n        if (goal == GoalType.MINIMIZE) {\n            for (int i = 0; i < n; i++) {\n                r[i] = -r[i];\n            }\n        }\n\n        // Initial search direction.\n        double[] steepestDescent = preconditioner.precondition(point, r);\n        double[] searchDirection = steepestDescent.clone();\n\n        double delta = 0;\n        for (int i = 0; i < n; ++i) {\n            delta += r[i] * searchDirection[i];\n        }\n\n        PointValuePair current = null;\n        int iter = 0;\n        int maxEval = getMaxEvaluations();\n        while (true) {\n            ++iter;\n\n            final double objective = computeObjectiveValue(point);\n            PointValuePair previous = current;\n            current = new PointValuePair(point, objective);\n            if (previous != null) {\n                if (checker.converged(iter, previous, current)) {\n                    // We have found an optimum.\n                    return current;\n                }\n            }\n\n            // Find the optimal step in the search direction.\n            final UnivariateFunction lsf = new LineSearchFunction(point, searchDirection);\n            final double uB = findUpperBound(lsf, 0, initialStep);\n            // XXX Last parameters is set to a value close to zero in order to\n            // work around the divergence problem in the \"testCircleFitting\"\n            // unit test (see MATH-439).\n            final double step = solver.solve(maxEval, lsf, 0, uB, 1e-15);\n            maxEval -= solver.getEvaluations(); // Subtract used up evaluations.\n\n            // Validate new point.\n            for (int i = 0; i < point.length; ++i) {\n                point[i] += step * searchDirection[i];\n            }\n\n            r = computeObjectiveGradient(point);\n            if (goal == GoalType.MINIMIZE) {\n                for (int i = 0; i < n; ++i) {\n                    r[i] = -r[i];\n                }\n            }\n\n            // Compute beta.\n            final double deltaOld = delta;\n            final double[] newSteepestDescent = preconditioner.precondition(point, r);\n            delta = 0;\n            for (int i = 0; i < n; ++i) {\n                delta += r[i] * newSteepestDescent[i];\n            }\n\n            final double beta;\n            switch (updateFormula) {\n            case FLETCHER_REEVES:\n                beta = delta / deltaOld;\n                break;\n            case POLAK_RIBIERE:\n                double deltaMid = 0;\n                for (int i = 0; i < r.length; ++i) {\n                    deltaMid += r[i] * steepestDescent[i];\n                }\n                beta = (delta - deltaMid) / deltaOld;\n                break;\n            default:\n                // Should never happen.\n                throw new MathInternalError();\n            }\n            steepestDescent = newSteepestDescent;\n\n            // Compute conjugate search direction.\n            if (iter % n == 0 ||\n                beta < 0) {\n                // Break conjugation: reset search direction.\n                searchDirection = steepestDescent.clone();\n            } else {\n                // Compute new conjugate search direction.\n                for (int i = 0; i < n; ++i) {\n                    searchDirection[i] = steepestDescent[i] + beta * searchDirection[i];\n                }\n            }\n        }\n    }",
    "comment": "{@inheritDoc} */",
    "is_bug": true,
    "failing_test_cases": 28,
    "buggy_methods": 7
  },
  {
    "name": "NonLinearConjugateGradientOptimizer.findUpperBound",
    "class_name": "org.apache.commons.math3.optim.nonlinear.scalar.gradient.NonLinearConjugateGradientOptimizer",
    "signature": "org.apache.commons.math3.optim.nonlinear.scalar.gradient.NonLinearConjugateGradientOptimizer.findUpperBound(UnivariateFunction,double,double)",
    "snippet": "    private double findUpperBound(final UnivariateFunction f,\n                                  final double a, final double h) {\n        final double yA = f.value(a);\n        double yB = yA;\n        for (double step = h; step < Double.MAX_VALUE; step *= FastMath.max(2, yA / yB)) {\n            final double b = a + step;\n            yB = f.value(b);\n            if (yA * yB <= 0) {\n                return b;\n            }\n        }\n        throw new MathIllegalStateException(LocalizedFormats.UNABLE_TO_BRACKET_OPTIMUM_IN_LINE_SEARCH);\n    }",
    "comment": " Finds the upper bound b ensuring bracketing of a root between a and b.  @param f function whose root must be bracketed. @param a lower bound of the interval. @param h initial step to try. @return b such that f(a) and f(b) have opposite signs. @throws MathIllegalStateException if no bracket can be found. ",
    "is_bug": false,
    "failing_test_cases": 28,
    "buggy_methods": 7
  },
  {
    "name": "NonLinearConjugateGradientOptimizer.optimize",
    "class_name": "org.apache.commons.math3.optim.nonlinear.scalar.gradient.NonLinearConjugateGradientOptimizer",
    "signature": "org.apache.commons.math3.optim.nonlinear.scalar.gradient.NonLinearConjugateGradientOptimizer.optimize(OptimizationData[])",
    "snippet": "    @Override\n    public PointValuePair optimize(OptimizationData... optData)\n        throws TooManyEvaluationsException {\n        // Set up base class and perform computation.\n        return super.optimize(optData);\n    }",
    "comment": " {@inheritDoc}  @param optData Optimization data. In addition to those documented in {@link GradientMultivariateOptimizer#parseOptimizationData(OptimizationData[]) GradientMultivariateOptimizer}, this method will register the following data: <ul> <li>{@link BracketingStep}</li> </ul> @return {@inheritDoc} @throws TooManyEvaluationsException if the maximal number of evaluations (of the objective function) is exceeded. ",
    "is_bug": false,
    "failing_test_cases": 28,
    "buggy_methods": 7
  },
  {
    "name": "NonLinearConjugateGradientOptimizer.parseOptimizationData",
    "class_name": "org.apache.commons.math3.optim.nonlinear.scalar.gradient.NonLinearConjugateGradientOptimizer",
    "signature": "org.apache.commons.math3.optim.nonlinear.scalar.gradient.NonLinearConjugateGradientOptimizer.parseOptimizationData(OptimizationData[])",
    "snippet": "    @Override\n    protected void parseOptimizationData(OptimizationData... optData) {\n        // Allow base class to register its own data.\n        super.parseOptimizationData(optData);\n\n        // The existing values (as set by the previous call) are reused if\n        // not provided in the argument list.\n        for (OptimizationData data : optData) {\n            if  (data instanceof BracketingStep) {\n                initialStep = ((BracketingStep) data).getBracketingStep();\n                // If more data must be parsed, this statement _must_ be\n                // changed to \"continue\".\n                break;\n            }\n        }\n\n        checkParameters();\n    }",
    "comment": " Scans the list of (required and optional) optimization data that characterize the problem.  @param optData Optimization data. The following data will be looked for: <ul> <li>{@link BracketingStep}</li> </ul> ",
    "is_bug": false,
    "failing_test_cases": 28,
    "buggy_methods": 7
  },
  {
    "name": "IdentityPreconditioner.precondition",
    "class_name": "org.apache.commons.math3.optim.nonlinear.scalar.gradient.NonLinearConjugateGradientOptimizer$IdentityPreconditioner",
    "signature": "org.apache.commons.math3.optim.nonlinear.scalar.gradient.NonLinearConjugateGradientOptimizer$IdentityPreconditioner.precondition(double[],double[])",
    "snippet": "        public double[] precondition(double[] variables, double[] r) {\n            return r.clone();\n        }",
    "comment": "{@inheritDoc} */",
    "is_bug": false,
    "failing_test_cases": 28,
    "buggy_methods": 7
  },
  {
    "name": "LineSearchFunction.value",
    "class_name": "org.apache.commons.math3.optim.nonlinear.scalar.gradient.NonLinearConjugateGradientOptimizer$LineSearchFunction",
    "signature": "org.apache.commons.math3.optim.nonlinear.scalar.gradient.NonLinearConjugateGradientOptimizer$LineSearchFunction.value(double)",
    "snippet": "        public double value(double x) {\n            // current point in the search direction\n            final double[] shiftedPoint = currentPoint.clone();\n            for (int i = 0; i < shiftedPoint.length; ++i) {\n                shiftedPoint[i] += x * searchDirection[i];\n            }\n\n            // gradient of the objective function\n            final double[] gradient = computeObjectiveGradient(shiftedPoint);\n\n            // dot product with the search direction\n            double dotProduct = 0;\n            for (int i = 0; i < gradient.length; ++i) {\n                dotProduct += gradient[i] * searchDirection[i];\n            }\n\n            return dotProduct;\n        }",
    "comment": "{@inheritDoc} */",
    "is_bug": false,
    "failing_test_cases": 28,
    "buggy_methods": 7
  },
  {
    "name": "AbstractSimplex.AbstractSimplex",
    "class_name": "org.apache.commons.math3.optim.nonlinear.scalar.noderiv.AbstractSimplex",
    "signature": "org.apache.commons.math3.optim.nonlinear.scalar.noderiv.AbstractSimplex.AbstractSimplex(double[])",
    "snippet": "    protected AbstractSimplex(final double[] steps) {\n        if (steps == null) {\n            throw new NullArgumentException();\n        }\n        if (steps.length == 0) {\n            throw new ZeroException();\n        }\n        dimension = steps.length;\n\n        // Only the relative position of the n final vertices with respect\n        // to the first one are stored.\n        startConfiguration = new double[dimension][dimension];\n        for (int i = 0; i < dimension; i++) {\n            final double[] vertexI = startConfiguration[i];\n            for (int j = 0; j < i + 1; j++) {\n                if (steps[j] == 0) {\n                    throw new ZeroException(LocalizedFormats.EQUAL_VERTICES_IN_SIMPLEX);\n                }\n                System.arraycopy(steps, 0, vertexI, 0, j + 1);\n            }\n        }\n    }",
    "comment": " The start configuration for simplex is built from a box parallel to the canonical axes of the space. The simplex is the subset of vertices of a box parallel to the canonical axes. It is built as the path followed while traveling from one vertex of the box to the diagonally opposite vertex moving only along the box edges. The first vertex of the box will be located at the start point of the optimization. As an example, in dimension 3 a simplex has 4 vertices. Setting the steps to (1, 10, 2) and the start point to (1, 1, 1) would imply the start simplex would be: { (1, 1, 1), (2, 1, 1), (2, 11, 1), (2, 11, 3) }. The first vertex would be set to the start point at (1, 1, 1) and the last vertex would be set to the diagonally opposite vertex at (2, 11, 3).  @param steps Steps along the canonical axes representing box edges. They may be negative but not zero. @throws NullArgumentException if {@code steps} is {@code null}. @throws ZeroException if one of the steps is zero. ",
    "is_bug": false,
    "failing_test_cases": 28,
    "buggy_methods": 7
  },
  {
    "name": "AbstractSimplex.build",
    "class_name": "org.apache.commons.math3.optim.nonlinear.scalar.noderiv.AbstractSimplex",
    "signature": "org.apache.commons.math3.optim.nonlinear.scalar.noderiv.AbstractSimplex.build(double[])",
    "snippet": "    public void build(final double[] startPoint) {\n        if (dimension != startPoint.length) {\n            throw new DimensionMismatchException(dimension, startPoint.length);\n        }\n\n        // Set first vertex.\n        simplex = new PointValuePair[dimension + 1];\n        simplex[0] = new PointValuePair(startPoint, Double.NaN);\n\n        // Set remaining vertices.\n        for (int i = 0; i < dimension; i++) {\n            final double[] confI = startConfiguration[i];\n            final double[] vertexI = new double[dimension];\n            for (int k = 0; k < dimension; k++) {\n                vertexI[k] = startPoint[k] + confI[k];\n            }\n            simplex[i + 1] = new PointValuePair(vertexI, Double.NaN);\n        }\n    }",
    "comment": " Build an initial simplex.  @param startPoint First point of the simplex. @throws DimensionMismatchException if the start point does not match simplex dimension. ",
    "is_bug": false,
    "failing_test_cases": 28,
    "buggy_methods": 7
  },
  {
    "name": "AbstractSimplex.evaluate",
    "class_name": "org.apache.commons.math3.optim.nonlinear.scalar.noderiv.AbstractSimplex",
    "signature": "org.apache.commons.math3.optim.nonlinear.scalar.noderiv.AbstractSimplex.evaluate(MultivariateFunction,Comparator)",
    "snippet": "    public void evaluate(final MultivariateFunction evaluationFunction,\n                         final Comparator<PointValuePair> comparator) {\n        // Evaluate the objective function at all non-evaluated simplex points.\n        for (int i = 0; i < simplex.length; i++) {\n            final PointValuePair vertex = simplex[i];\n            final double[] point = vertex.getPointRef();\n            if (Double.isNaN(vertex.getValue())) {\n                simplex[i] = new PointValuePair(point, evaluationFunction.value(point), false);\n            }\n        }\n\n        // Sort the simplex from best to worst.\n        Arrays.sort(simplex, comparator);\n    }",
    "comment": " Evaluate all the non-evaluated points of the simplex.  @param evaluationFunction Evaluation function. @param comparator Comparator to use to sort simplex vertices from best to worst. @throws org.apache.commons.math3.exception.TooManyEvaluationsException if the maximal number of evaluations is exceeded. ",
    "is_bug": false,
    "failing_test_cases": 28,
    "buggy_methods": 7
  },
  {
    "name": "AbstractSimplex.getDimension",
    "class_name": "org.apache.commons.math3.optim.nonlinear.scalar.noderiv.AbstractSimplex",
    "signature": "org.apache.commons.math3.optim.nonlinear.scalar.noderiv.AbstractSimplex.getDimension()",
    "snippet": "    public int getDimension() {\n        return dimension;\n    }",
    "comment": " Get simplex dimension.  @return the dimension of the simplex. ",
    "is_bug": false,
    "failing_test_cases": 28,
    "buggy_methods": 7
  },
  {
    "name": "AbstractSimplex.getPoint",
    "class_name": "org.apache.commons.math3.optim.nonlinear.scalar.noderiv.AbstractSimplex",
    "signature": "org.apache.commons.math3.optim.nonlinear.scalar.noderiv.AbstractSimplex.getPoint(int)",
    "snippet": "    public PointValuePair getPoint(int index) {\n        if (index < 0 ||\n            index >= simplex.length) {\n            throw new OutOfRangeException(index, 0, simplex.length - 1);\n        }\n        return simplex[index];\n    }",
    "comment": " Get the simplex point stored at the requested {@code index}.  @param index Location. @return the point at location {@code index}. ",
    "is_bug": false,
    "failing_test_cases": 28,
    "buggy_methods": 7
  },
  {
    "name": "AbstractSimplex.getPoints",
    "class_name": "org.apache.commons.math3.optim.nonlinear.scalar.noderiv.AbstractSimplex",
    "signature": "org.apache.commons.math3.optim.nonlinear.scalar.noderiv.AbstractSimplex.getPoints()",
    "snippet": "    public PointValuePair[] getPoints() {\n        final PointValuePair[] copy = new PointValuePair[simplex.length];\n        System.arraycopy(simplex, 0, copy, 0, simplex.length);\n        return copy;\n    }",
    "comment": " Get the points of the simplex.  @return all the simplex points. ",
    "is_bug": false,
    "failing_test_cases": 28,
    "buggy_methods": 7
  },
  {
    "name": "AbstractSimplex.getSize",
    "class_name": "org.apache.commons.math3.optim.nonlinear.scalar.noderiv.AbstractSimplex",
    "signature": "org.apache.commons.math3.optim.nonlinear.scalar.noderiv.AbstractSimplex.getSize()",
    "snippet": "    public int getSize() {\n        return simplex.length;\n    }",
    "comment": " Get simplex size. After calling the {@link #build(double[]) build} method, this method will will be equivalent to {@code getDimension() + 1}.  @return the size of the simplex. ",
    "is_bug": false,
    "failing_test_cases": 28,
    "buggy_methods": 7
  },
  {
    "name": "AbstractSimplex.setPoint",
    "class_name": "org.apache.commons.math3.optim.nonlinear.scalar.noderiv.AbstractSimplex",
    "signature": "org.apache.commons.math3.optim.nonlinear.scalar.noderiv.AbstractSimplex.setPoint(int,PointValuePair)",
    "snippet": "    protected void setPoint(int index, PointValuePair point) {\n        if (index < 0 ||\n            index >= simplex.length) {\n            throw new OutOfRangeException(index, 0, simplex.length - 1);\n        }\n        simplex[index] = point;\n    }",
    "comment": " Store a new point at location {@code index}. Note that no deep-copy of {@code point} is performed.  @param index Location. @param point New value. ",
    "is_bug": false,
    "failing_test_cases": 28,
    "buggy_methods": 7
  },
  {
    "name": "AbstractSimplex.setPoints",
    "class_name": "org.apache.commons.math3.optim.nonlinear.scalar.noderiv.AbstractSimplex",
    "signature": "org.apache.commons.math3.optim.nonlinear.scalar.noderiv.AbstractSimplex.setPoints(PointValuePair[])",
    "snippet": "    protected void setPoints(PointValuePair[] points) {\n        if (points.length != simplex.length) {\n            throw new DimensionMismatchException(points.length, simplex.length);\n        }\n        simplex = points;\n    }",
    "comment": " Replace all points. Note that no deep-copy of {@code points} is performed.  @param points New Points. ",
    "is_bug": false,
    "failing_test_cases": 28,
    "buggy_methods": 7
  },
  {
    "name": "CMAESOptimizer.CMAESOptimizer",
    "class_name": "org.apache.commons.math3.optim.nonlinear.scalar.noderiv.CMAESOptimizer",
    "signature": "org.apache.commons.math3.optim.nonlinear.scalar.noderiv.CMAESOptimizer.CMAESOptimizer(int,double,boolean,int,int,RandomGenerator,boolean,ConvergenceChecker)",
    "snippet": "    public CMAESOptimizer(int maxIterations,\n                          double stopFitness,\n                          boolean isActiveCMA,\n                          int diagonalOnly,\n                          int checkFeasableCount,\n                          RandomGenerator random,\n                          boolean generateStatistics,\n                          ConvergenceChecker<PointValuePair> checker) {\n        super(checker);\n        this.maxIterations = maxIterations;\n        this.stopFitness = stopFitness;\n        this.isActiveCMA = isActiveCMA;\n        this.diagonalOnly = diagonalOnly;\n        this.checkFeasableCount = checkFeasableCount;\n        this.random = random;\n        this.generateStatistics = generateStatistics;\n    }",
    "comment": " @param maxIterations Maximal number of iterations. @param stopFitness Whether to stop if objective function value is smaller than {@code stopFitness}. @param isActiveCMA Chooses the covariance matrix update method. @param diagonalOnly Number of initial iterations, where the covariance matrix remains diagonal. @param checkFeasableCount Determines how often new random objective variables are generated in case they are out of bounds. @param random Random generator. @param generateStatistics Whether statistic data is collected. @param checker Convergence checker.  @since 3.1 ",
    "is_bug": false,
    "failing_test_cases": 28,
    "buggy_methods": 7
  },
  {
    "name": "CMAESOptimizer.checkParameters",
    "class_name": "org.apache.commons.math3.optim.nonlinear.scalar.noderiv.CMAESOptimizer",
    "signature": "org.apache.commons.math3.optim.nonlinear.scalar.noderiv.CMAESOptimizer.checkParameters()",
    "snippet": "    private void checkParameters() {\n        final double[] init = getStartPoint();\n        final double[] lB = getLowerBound();\n        final double[] uB = getUpperBound();\n\n        if (inputSigma != null) {\n            if (inputSigma.length != init.length) {\n                throw new DimensionMismatchException(inputSigma.length, init.length);\n            }\n            for (int i = 0; i < init.length; i++) {\n                if (inputSigma[i] > uB[i] - lB[i]) {\n                    throw new OutOfRangeException(inputSigma[i], 0, uB[i] - lB[i]);\n                }\n            }\n        }\n    }",
    "comment": " Checks dimensions and values of boundaries and inputSigma if defined. ",
    "is_bug": false,
    "failing_test_cases": 28,
    "buggy_methods": 7
  },
  {
    "name": "CMAESOptimizer.copyColumn",
    "class_name": "org.apache.commons.math3.optim.nonlinear.scalar.noderiv.CMAESOptimizer",
    "signature": "org.apache.commons.math3.optim.nonlinear.scalar.noderiv.CMAESOptimizer.copyColumn(RealMatrix,int,RealMatrix,int)",
    "snippet": "    private static void copyColumn(final RealMatrix m1, int col1,\n                                   RealMatrix m2, int col2) {\n        for (int i = 0; i < m1.getRowDimension(); i++) {\n            m2.setEntry(i, col2, m1.getEntry(i, col1));\n        }\n    }",
    "comment": " Copies a column from m1 to m2.  @param m1 Source matrix. @param col1 Source column. @param m2 Target matrix. @param col2 Target column. ",
    "is_bug": false,
    "failing_test_cases": 28,
    "buggy_methods": 7
  },
  {
    "name": "CMAESOptimizer.diag",
    "class_name": "org.apache.commons.math3.optim.nonlinear.scalar.noderiv.CMAESOptimizer",
    "signature": "org.apache.commons.math3.optim.nonlinear.scalar.noderiv.CMAESOptimizer.diag(RealMatrix)",
    "snippet": "    private static RealMatrix diag(final RealMatrix m) {\n        if (m.getColumnDimension() == 1) {\n            final double[][] d = new double[m.getRowDimension()][m.getRowDimension()];\n            for (int i = 0; i < m.getRowDimension(); i++) {\n                d[i][i] = m.getEntry(i, 0);\n            }\n            return new Array2DRowRealMatrix(d, false);\n        } else {\n            final double[][] d = new double[m.getRowDimension()][1];\n            for (int i = 0; i < m.getColumnDimension(); i++) {\n                d[i][0] = m.getEntry(i, i);\n            }\n            return new Array2DRowRealMatrix(d, false);\n        }\n    }",
    "comment": " @param m Input matrix. @return the diagonal n-by-n matrix if m is a column matrix or the column matrix representing the diagonal if m is a n-by-n matrix. ",
    "is_bug": false,
    "failing_test_cases": 28,
    "buggy_methods": 7
  },
  {
    "name": "CMAESOptimizer.divide",
    "class_name": "org.apache.commons.math3.optim.nonlinear.scalar.noderiv.CMAESOptimizer",
    "signature": "org.apache.commons.math3.optim.nonlinear.scalar.noderiv.CMAESOptimizer.divide(RealMatrix,RealMatrix)",
    "snippet": "    private static RealMatrix divide(final RealMatrix m, final RealMatrix n) {\n        final double[][] d = new double[m.getRowDimension()][m.getColumnDimension()];\n        for (int r = 0; r < m.getRowDimension(); r++) {\n            for (int c = 0; c < m.getColumnDimension(); c++) {\n                d[r][c] = m.getEntry(r, c) / n.getEntry(r, c);\n            }\n        }\n        return new Array2DRowRealMatrix(d, false);\n    }",
    "comment": " @param m Input matrix 1. @param n Input matrix 2. @return Matrix where the elements of m and n are element-wise divided. ",
    "is_bug": false,
    "failing_test_cases": 28,
    "buggy_methods": 7
  },
  {
    "name": "CMAESOptimizer.doOptimize",
    "class_name": "org.apache.commons.math3.optim.nonlinear.scalar.noderiv.CMAESOptimizer",
    "signature": "org.apache.commons.math3.optim.nonlinear.scalar.noderiv.CMAESOptimizer.doOptimize()",
    "snippet": "    @Override\n    protected PointValuePair doOptimize() {\n         // -------------------- Initialization --------------------------------\n        isMinimize = getGoalType().equals(GoalType.MINIMIZE);\n        final FitnessFunction fitfun = new FitnessFunction();\n        final double[] guess = getStartPoint();\n        // number of objective variables/problem dimension\n        dimension = guess.length;\n        initializeCMA(guess);\n        iterations = 0;\n        double bestValue = fitfun.value(guess);\n        push(fitnessHistory, bestValue);\n        PointValuePair optimum\n            = new PointValuePair(getStartPoint(),\n                                 isMinimize ? bestValue : -bestValue);\n        PointValuePair lastResult = null;\n\n        // -------------------- Generation Loop --------------------------------\n\n        generationLoop:\n        for (iterations = 1; iterations <= maxIterations; iterations++) {\n\n            // Generate and evaluate lambda offspring\n            final RealMatrix arz = randn1(dimension, lambda);\n            final RealMatrix arx = zeros(dimension, lambda);\n            final double[] fitness = new double[lambda];\n            // generate random offspring\n            for (int k = 0; k < lambda; k++) {\n                RealMatrix arxk = null;\n                for (int i = 0; i < checkFeasableCount + 1; i++) {\n                    if (diagonalOnly <= 0) {\n                        arxk = xmean.add(BD.multiply(arz.getColumnMatrix(k))\n                                         .scalarMultiply(sigma)); // m + sig * Normal(0,C)\n                    } else {\n                        arxk = xmean.add(times(diagD,arz.getColumnMatrix(k))\n                                         .scalarMultiply(sigma));\n                    }\n                    if (i >= checkFeasableCount ||\n                        fitfun.isFeasible(arxk.getColumn(0))) {\n                        break;\n                    }\n                    // regenerate random arguments for row\n                    arz.setColumn(k, randn(dimension));\n                }\n                copyColumn(arxk, 0, arx, k);\n                try {\n                    fitness[k] = fitfun.value(arx.getColumn(k)); // compute fitness\n                } catch (TooManyEvaluationsException e) {\n                    break generationLoop;\n                }\n            }\n            // Sort by fitness and compute weighted mean into xmean\n            final int[] arindex = sortedIndices(fitness);\n            // Calculate new xmean, this is selection and recombination\n            final RealMatrix xold = xmean; // for speed up of Eq. (2) and (3)\n            final RealMatrix bestArx = selectColumns(arx, MathArrays.copyOf(arindex, mu));\n            xmean = bestArx.multiply(weights);\n            final RealMatrix bestArz = selectColumns(arz, MathArrays.copyOf(arindex, mu));\n            final RealMatrix zmean = bestArz.multiply(weights);\n            final boolean hsig = updateEvolutionPaths(zmean, xold);\n            if (diagonalOnly <= 0) {\n                updateCovariance(hsig, bestArx, arz, arindex, xold);\n            } else {\n                updateCovarianceDiagonalOnly(hsig, bestArz);\n            }\n            // Adapt step size sigma - Eq. (5)\n            sigma *= Math.exp(Math.min(1, (normps/chiN - 1) * cs / damps));\n            final double bestFitness = fitness[arindex[0]];\n            final double worstFitness = fitness[arindex[arindex.length - 1]];\n            if (bestValue > bestFitness) {\n                bestValue = bestFitness;\n                lastResult = optimum;\n                optimum = new PointValuePair(fitfun.repair(bestArx.getColumn(0)),\n                                             isMinimize ? bestFitness : -bestFitness);\n                if (getConvergenceChecker() != null &&\n                    lastResult != null) {\n                    if (getConvergenceChecker().converged(iterations, optimum, lastResult)) {\n                        break generationLoop;\n                    }\n                }\n            }\n            // handle termination criteria\n            // Break, if fitness is good enough\n            if (stopFitness != 0) { // only if stopFitness is defined\n                if (bestFitness < (isMinimize ? stopFitness : -stopFitness)) {\n                    break generationLoop;\n                }\n            }\n            final double[] sqrtDiagC = sqrt(diagC).getColumn(0);\n            final double[] pcCol = pc.getColumn(0);\n            for (int i = 0; i < dimension; i++) {\n                if (sigma * Math.max(Math.abs(pcCol[i]), sqrtDiagC[i]) > stopTolX) {\n                    break;\n                }\n                if (i >= dimension - 1) {\n                    break generationLoop;\n                }\n            }\n            for (int i = 0; i < dimension; i++) {\n                if (sigma * sqrtDiagC[i] > stopTolUpX) {\n                    break generationLoop;\n                }\n            }\n            final double historyBest = min(fitnessHistory);\n            final double historyWorst = max(fitnessHistory);\n            if (iterations > 2 &&\n                Math.max(historyWorst, worstFitness) -\n                Math.min(historyBest, bestFitness) < stopTolFun) {\n                break generationLoop;\n            }\n            if (iterations > fitnessHistory.length &&\n                historyWorst - historyBest < stopTolHistFun) {\n                break generationLoop;\n            }\n            // condition number of the covariance matrix exceeds 1e14\n            if (max(diagD) / min(diagD) > 1e7) {\n                break generationLoop;\n            }\n            // user defined termination\n            if (getConvergenceChecker() != null) {\n                final PointValuePair current\n                    = new PointValuePair(bestArx.getColumn(0),\n                                         isMinimize ? bestFitness : -bestFitness);\n                if (lastResult != null &&\n                    getConvergenceChecker().converged(iterations, current, lastResult)) {\n                    break generationLoop;\n                    }\n                lastResult = current;\n            }\n            // Adjust step size in case of equal function values (flat fitness)\n            if (bestValue == fitness[arindex[(int)(0.1+lambda/4.)]]) {\n                sigma = sigma * Math.exp(0.2 + cs / damps);\n            }\n            if (iterations > 2 && Math.max(historyWorst, bestFitness) -\n                Math.min(historyBest, bestFitness) == 0) {\n                sigma = sigma * Math.exp(0.2 + cs / damps);\n            }\n            // store best in history\n            push(fitnessHistory,bestFitness);\n            fitfun.setValueRange(worstFitness-bestFitness);\n            if (generateStatistics) {\n                statisticsSigmaHistory.add(sigma);\n                statisticsFitnessHistory.add(bestFitness);\n                statisticsMeanHistory.add(xmean.transpose());\n                statisticsDHistory.add(diagD.transpose().scalarMultiply(1E5));\n            }\n        }\n        return optimum;\n    }",
    "comment": "{@inheritDoc} */",
    "is_bug": true,
    "failing_test_cases": 28,
    "buggy_methods": 7
  },
  {
    "name": "CMAESOptimizer.eye",
    "class_name": "org.apache.commons.math3.optim.nonlinear.scalar.noderiv.CMAESOptimizer",
    "signature": "org.apache.commons.math3.optim.nonlinear.scalar.noderiv.CMAESOptimizer.eye(int,int)",
    "snippet": "    private static RealMatrix eye(int n, int m) {\n        final double[][] d = new double[n][m];\n        for (int r = 0; r < n; r++) {\n            if (r < m) {\n                d[r][r] = 1;\n            }\n        }\n        return new Array2DRowRealMatrix(d, false);\n    }",
    "comment": " @param n Number of rows. @param m Number of columns. @return n-by-m matrix of 0 values out of diagonal, and 1 values on the diagonal. ",
    "is_bug": false,
    "failing_test_cases": 28,
    "buggy_methods": 7
  },
  {
    "name": "CMAESOptimizer.initializeCMA",
    "class_name": "org.apache.commons.math3.optim.nonlinear.scalar.noderiv.CMAESOptimizer",
    "signature": "org.apache.commons.math3.optim.nonlinear.scalar.noderiv.CMAESOptimizer.initializeCMA(double[])",
    "snippet": "    private void initializeCMA(double[] guess) {\n        if (lambda <= 0) {\n            throw new NotStrictlyPositiveException(lambda);\n        }\n        // initialize sigma\n        final double[][] sigmaArray = new double[guess.length][1];\n        for (int i = 0; i < guess.length; i++) {\n            sigmaArray[i][0] = inputSigma[i];\n        }\n        final RealMatrix insigma = new Array2DRowRealMatrix(sigmaArray, false);\n        sigma = max(insigma); // overall standard deviation\n\n        // initialize termination criteria\n        stopTolUpX = 1e3 * max(insigma);\n        stopTolX = 1e-11 * max(insigma);\n        stopTolFun = 1e-12;\n        stopTolHistFun = 1e-13;\n\n        // initialize selection strategy parameters\n        mu = lambda / 2; // number of parents/points for recombination\n        logMu2 = Math.log(mu + 0.5);\n        weights = log(sequence(1, mu, 1)).scalarMultiply(-1).scalarAdd(logMu2);\n        double sumw = 0;\n        double sumwq = 0;\n        for (int i = 0; i < mu; i++) {\n            double w = weights.getEntry(i, 0);\n            sumw += w;\n            sumwq += w * w;\n        }\n        weights = weights.scalarMultiply(1 / sumw);\n        mueff = sumw * sumw / sumwq; // variance-effectiveness of sum w_i x_i\n\n        // initialize dynamic strategy parameters and constants\n        cc = (4 + mueff / dimension) /\n                (dimension + 4 + 2 * mueff / dimension);\n        cs = (mueff + 2) / (dimension + mueff + 3.);\n        damps = (1 + 2 * Math.max(0, Math.sqrt((mueff - 1) /\n                                               (dimension + 1)) - 1)) *\n            Math.max(0.3,\n                     1 - dimension / (1e-6 + maxIterations)) + cs; // minor increment\n        ccov1 = 2 / ((dimension + 1.3) * (dimension + 1.3) + mueff);\n        ccovmu = Math.min(1 - ccov1, 2 * (mueff - 2 + 1 / mueff) /\n                          ((dimension + 2) * (dimension + 2) + mueff));\n        ccov1Sep = Math.min(1, ccov1 * (dimension + 1.5) / 3);\n        ccovmuSep = Math.min(1 - ccov1, ccovmu * (dimension + 1.5) / 3);\n        chiN = Math.sqrt(dimension) *\n            (1 - 1 / ((double) 4 * dimension) + 1 / ((double) 21 * dimension * dimension));\n        // intialize CMA internal values - updated each generation\n        xmean = MatrixUtils.createColumnRealMatrix(guess); // objective variables\n        diagD = insigma.scalarMultiply(1 / sigma);\n        diagC = square(diagD);\n        pc = zeros(dimension, 1); // evolution paths for C and sigma\n        ps = zeros(dimension, 1); // B defines the coordinate system\n        normps = ps.getFrobeniusNorm();\n\n        B = eye(dimension, dimension);\n        D = ones(dimension, 1); // diagonal D defines the scaling\n        BD = times(B, repmat(diagD.transpose(), dimension, 1));\n        C = B.multiply(diag(square(D)).multiply(B.transpose())); // covariance\n        historySize = 10 + (int) (3 * 10 * dimension / (double) lambda);\n        fitnessHistory = new double[historySize]; // history of fitness values\n        for (int i = 0; i < historySize; i++) {\n            fitnessHistory[i] = Double.MAX_VALUE;\n        }\n    }",
    "comment": " Initialization of the dynamic search parameters  @param guess Initial guess for the arguments of the fitness function. ",
    "is_bug": false,
    "failing_test_cases": 28,
    "buggy_methods": 7
  },
  {
    "name": "CMAESOptimizer.inverse",
    "class_name": "org.apache.commons.math3.optim.nonlinear.scalar.noderiv.CMAESOptimizer",
    "signature": "org.apache.commons.math3.optim.nonlinear.scalar.noderiv.CMAESOptimizer.inverse(int[])",
    "snippet": "    private static int[] inverse(final int[] indices) {\n        final int[] inverse = new int[indices.length];\n        for (int i = 0; i < indices.length; i++) {\n            inverse[indices[i]] = i;\n        }\n        return inverse;\n    }",
    "comment": " @param indices Input index array. @return the inverse of the mapping defined by indices. ",
    "is_bug": false,
    "failing_test_cases": 28,
    "buggy_methods": 7
  },
  {
    "name": "CMAESOptimizer.log",
    "class_name": "org.apache.commons.math3.optim.nonlinear.scalar.noderiv.CMAESOptimizer",
    "signature": "org.apache.commons.math3.optim.nonlinear.scalar.noderiv.CMAESOptimizer.log(RealMatrix)",
    "snippet": "    private static RealMatrix log(final RealMatrix m) {\n        final double[][] d = new double[m.getRowDimension()][m.getColumnDimension()];\n        for (int r = 0; r < m.getRowDimension(); r++) {\n            for (int c = 0; c < m.getColumnDimension(); c++) {\n                d[r][c] = Math.log(m.getEntry(r, c));\n            }\n        }\n        return new Array2DRowRealMatrix(d, false);\n    }",
    "comment": " @param m Input matrix @return Matrix representing the element-wise logarithm of m. ",
    "is_bug": false,
    "failing_test_cases": 28,
    "buggy_methods": 7
  },
  {
    "name": "CMAESOptimizer.max",
    "class_name": "org.apache.commons.math3.optim.nonlinear.scalar.noderiv.CMAESOptimizer",
    "signature": "org.apache.commons.math3.optim.nonlinear.scalar.noderiv.CMAESOptimizer.max(RealMatrix)",
    "snippet": "    private static double max(final RealMatrix m) {\n        double max = -Double.MAX_VALUE;\n        for (int r = 0; r < m.getRowDimension(); r++) {\n            for (int c = 0; c < m.getColumnDimension(); c++) {\n                double e = m.getEntry(r, c);\n                if (max < e) {\n                    max = e;\n                }\n            }\n        }\n        return max;\n    }",
    "comment": " @param m Input matrix. @return the maximum of the matrix element values. ",
    "is_bug": false,
    "failing_test_cases": 28,
    "buggy_methods": 7
  },
  {
    "name": "CMAESOptimizer.max",
    "class_name": "org.apache.commons.math3.optim.nonlinear.scalar.noderiv.CMAESOptimizer",
    "signature": "org.apache.commons.math3.optim.nonlinear.scalar.noderiv.CMAESOptimizer.max(double[])",
    "snippet": "    private static double max(final double[] m) {\n        double max = -Double.MAX_VALUE;\n        for (int r = 0; r < m.length; r++) {\n            if (max < m[r]) {\n                max = m[r];\n            }\n        }\n        return max;\n    }",
    "comment": " @param m Input array. @return the maximum of the array values. ",
    "is_bug": false,
    "failing_test_cases": 28,
    "buggy_methods": 7
  },
  {
    "name": "CMAESOptimizer.min",
    "class_name": "org.apache.commons.math3.optim.nonlinear.scalar.noderiv.CMAESOptimizer",
    "signature": "org.apache.commons.math3.optim.nonlinear.scalar.noderiv.CMAESOptimizer.min(RealMatrix)",
    "snippet": "    private static double min(final RealMatrix m) {\n        double min = Double.MAX_VALUE;\n        for (int r = 0; r < m.getRowDimension(); r++) {\n            for (int c = 0; c < m.getColumnDimension(); c++) {\n                double e = m.getEntry(r, c);\n                if (min > e) {\n                    min = e;\n                }\n            }\n        }\n        return min;\n    }",
    "comment": " @param m Input matrix. @return the minimum of the matrix element values. ",
    "is_bug": false,
    "failing_test_cases": 28,
    "buggy_methods": 7
  },
  {
    "name": "CMAESOptimizer.min",
    "class_name": "org.apache.commons.math3.optim.nonlinear.scalar.noderiv.CMAESOptimizer",
    "signature": "org.apache.commons.math3.optim.nonlinear.scalar.noderiv.CMAESOptimizer.min(double[])",
    "snippet": "    private static double min(final double[] m) {\n        double min = Double.MAX_VALUE;\n        for (int r = 0; r < m.length; r++) {\n            if (min > m[r]) {\n                min = m[r];\n            }\n        }\n        return min;\n    }",
    "comment": " @param m Input array. @return the minimum of the array values. ",
    "is_bug": false,
    "failing_test_cases": 28,
    "buggy_methods": 7
  },
  {
    "name": "CMAESOptimizer.ones",
    "class_name": "org.apache.commons.math3.optim.nonlinear.scalar.noderiv.CMAESOptimizer",
    "signature": "org.apache.commons.math3.optim.nonlinear.scalar.noderiv.CMAESOptimizer.ones(int,int)",
    "snippet": "    private static RealMatrix ones(int n, int m) {\n        final double[][] d = new double[n][m];\n        for (int r = 0; r < n; r++) {\n            Arrays.fill(d[r], 1);\n        }\n        return new Array2DRowRealMatrix(d, false);\n    }",
    "comment": " @param n Number of rows. @param m Number of columns. @return n-by-m matrix filled with 1. ",
    "is_bug": false,
    "failing_test_cases": 28,
    "buggy_methods": 7
  },
  {
    "name": "CMAESOptimizer.optimize",
    "class_name": "org.apache.commons.math3.optim.nonlinear.scalar.noderiv.CMAESOptimizer",
    "signature": "org.apache.commons.math3.optim.nonlinear.scalar.noderiv.CMAESOptimizer.optimize(OptimizationData[])",
    "snippet": "    @Override\n    public PointValuePair optimize(OptimizationData... optData)\n        throws TooManyEvaluationsException,\n               DimensionMismatchException {\n        // Set up base class and perform computation.\n        return super.optimize(optData);\n    }",
    "comment": " {@inheritDoc}  @param optData Optimization data. In addition to those documented in {@link MultivariateOptimizer#parseOptimizationData(OptimizationData[]) MultivariateOptimizer}, this method will register the following data: <ul> <li>{@link Sigma}</li> <li>{@link PopulationSize}</li> </ul> @return {@inheritDoc} @throws TooManyEvaluationsException if the maximal number of evaluations is exceeded. @throws DimensionMismatchException if the initial guess, target, and weight arguments have inconsistent dimensions. ",
    "is_bug": false,
    "failing_test_cases": 28,
    "buggy_methods": 7
  },
  {
    "name": "CMAESOptimizer.parseOptimizationData",
    "class_name": "org.apache.commons.math3.optim.nonlinear.scalar.noderiv.CMAESOptimizer",
    "signature": "org.apache.commons.math3.optim.nonlinear.scalar.noderiv.CMAESOptimizer.parseOptimizationData(OptimizationData[])",
    "snippet": "    @Override\n    protected void parseOptimizationData(OptimizationData... optData) {\n        // Allow base class to register its own data.\n        super.parseOptimizationData(optData);\n\n        // The existing values (as set by the previous call) are reused if\n        // not provided in the argument list.\n        for (OptimizationData data : optData) {\n            if (data instanceof Sigma) {\n                inputSigma = ((Sigma) data).getSigma();\n                continue;\n            }\n            if (data instanceof PopulationSize) {\n                lambda = ((PopulationSize) data).getPopulationSize();\n                continue;\n            }\n        }\n\n        checkParameters();\n    }",
    "comment": " Scans the list of (required and optional) optimization data that characterize the problem.  @param optData Optimization data. The following data will be looked for: <ul> <li>{@link Sigma}</li> <li>{@link PopulationSize}</li> </ul> ",
    "is_bug": false,
    "failing_test_cases": 28,
    "buggy_methods": 7
  },
  {
    "name": "CMAESOptimizer.push",
    "class_name": "org.apache.commons.math3.optim.nonlinear.scalar.noderiv.CMAESOptimizer",
    "signature": "org.apache.commons.math3.optim.nonlinear.scalar.noderiv.CMAESOptimizer.push(double[],double)",
    "snippet": "    private static void push(double[] vals, double val) {\n        for (int i = vals.length-1; i > 0; i--) {\n            vals[i] = vals[i-1];\n        }\n        vals[0] = val;\n    }",
    "comment": " Pushes the current best fitness value in a history queue.  @param vals History queue. @param val Current best fitness value. ",
    "is_bug": false,
    "failing_test_cases": 28,
    "buggy_methods": 7
  },
  {
    "name": "CMAESOptimizer.randn1",
    "class_name": "org.apache.commons.math3.optim.nonlinear.scalar.noderiv.CMAESOptimizer",
    "signature": "org.apache.commons.math3.optim.nonlinear.scalar.noderiv.CMAESOptimizer.randn1(int,int)",
    "snippet": "    private RealMatrix randn1(int size, int popSize) {\n        final double[][] d = new double[size][popSize];\n        for (int r = 0; r < size; r++) {\n            for (int c = 0; c < popSize; c++) {\n                d[r][c] = random.nextGaussian();\n            }\n        }\n        return new Array2DRowRealMatrix(d, false);\n    }",
    "comment": " @param size Number of rows. @param popSize Population size. @return a 2-dimensional matrix of Gaussian random numbers. ",
    "is_bug": false,
    "failing_test_cases": 28,
    "buggy_methods": 7
  },
  {
    "name": "CMAESOptimizer.repmat",
    "class_name": "org.apache.commons.math3.optim.nonlinear.scalar.noderiv.CMAESOptimizer",
    "signature": "org.apache.commons.math3.optim.nonlinear.scalar.noderiv.CMAESOptimizer.repmat(RealMatrix,int,int)",
    "snippet": "    private static RealMatrix repmat(final RealMatrix mat, int n, int m) {\n        final int rd = mat.getRowDimension();\n        final int cd = mat.getColumnDimension();\n        final double[][] d = new double[n * rd][m * cd];\n        for (int r = 0; r < n * rd; r++) {\n            for (int c = 0; c < m * cd; c++) {\n                d[r][c] = mat.getEntry(r % rd, c % cd);\n            }\n        }\n        return new Array2DRowRealMatrix(d, false);\n    }",
    "comment": " @param mat Input matrix. @param n Number of row replicates. @param m Number of column replicates. @return a matrix which replicates the input matrix in both directions. ",
    "is_bug": false,
    "failing_test_cases": 28,
    "buggy_methods": 7
  },
  {
    "name": "CMAESOptimizer.reverse",
    "class_name": "org.apache.commons.math3.optim.nonlinear.scalar.noderiv.CMAESOptimizer",
    "signature": "org.apache.commons.math3.optim.nonlinear.scalar.noderiv.CMAESOptimizer.reverse(int[])",
    "snippet": "    private static int[] reverse(final int[] indices) {\n        final int[] reverse = new int[indices.length];\n        for (int i = 0; i < indices.length; i++) {\n            reverse[i] = indices[indices.length - i - 1];\n        }\n        return reverse;\n    }",
    "comment": " @param indices Input index array. @return the indices in inverse order (last is first). ",
    "is_bug": false,
    "failing_test_cases": 28,
    "buggy_methods": 7
  },
  {
    "name": "CMAESOptimizer.selectColumns",
    "class_name": "org.apache.commons.math3.optim.nonlinear.scalar.noderiv.CMAESOptimizer",
    "signature": "org.apache.commons.math3.optim.nonlinear.scalar.noderiv.CMAESOptimizer.selectColumns(RealMatrix,int[])",
    "snippet": "    private static RealMatrix selectColumns(final RealMatrix m, final int[] cols) {\n        final double[][] d = new double[m.getRowDimension()][cols.length];\n        for (int r = 0; r < m.getRowDimension(); r++) {\n            for (int c = 0; c < cols.length; c++) {\n                d[r][c] = m.getEntry(r, cols[c]);\n            }\n        }\n        return new Array2DRowRealMatrix(d, false);\n    }",
    "comment": " @param m Input matrix. @param cols Columns to select. @return Matrix representing the selected columns. ",
    "is_bug": false,
    "failing_test_cases": 28,
    "buggy_methods": 7
  },
  {
    "name": "CMAESOptimizer.sequence",
    "class_name": "org.apache.commons.math3.optim.nonlinear.scalar.noderiv.CMAESOptimizer",
    "signature": "org.apache.commons.math3.optim.nonlinear.scalar.noderiv.CMAESOptimizer.sequence(double,double,double)",
    "snippet": "    private static RealMatrix sequence(double start, double end, double step) {\n        final int size = (int) ((end - start) / step + 1);\n        final double[][] d = new double[size][1];\n        double value = start;\n        for (int r = 0; r < size; r++) {\n            d[r][0] = value;\n            value += step;\n        }\n        return new Array2DRowRealMatrix(d, false);\n    }",
    "comment": " @param start Start value. @param end End value. @param step Step size. @return a sequence as column matrix. ",
    "is_bug": false,
    "failing_test_cases": 28,
    "buggy_methods": 7
  },
  {
    "name": "CMAESOptimizer.sortedIndices",
    "class_name": "org.apache.commons.math3.optim.nonlinear.scalar.noderiv.CMAESOptimizer",
    "signature": "org.apache.commons.math3.optim.nonlinear.scalar.noderiv.CMAESOptimizer.sortedIndices(double[])",
    "snippet": "    private int[] sortedIndices(final double[] doubles) {\n        final DoubleIndex[] dis = new DoubleIndex[doubles.length];\n        for (int i = 0; i < doubles.length; i++) {\n            dis[i] = new DoubleIndex(doubles[i], i);\n        }\n        Arrays.sort(dis);\n        final int[] indices = new int[doubles.length];\n        for (int i = 0; i < doubles.length; i++) {\n            indices[i] = dis[i].index;\n        }\n        return indices;\n    }",
    "comment": " Sorts fitness values.  @param doubles Array of values to be sorted. @return a sorted array of indices pointing into doubles. ",
    "is_bug": false,
    "failing_test_cases": 28,
    "buggy_methods": 7
  },
  {
    "name": "CMAESOptimizer.sqrt",
    "class_name": "org.apache.commons.math3.optim.nonlinear.scalar.noderiv.CMAESOptimizer",
    "signature": "org.apache.commons.math3.optim.nonlinear.scalar.noderiv.CMAESOptimizer.sqrt(RealMatrix)",
    "snippet": "    private static RealMatrix sqrt(final RealMatrix m) {\n        final double[][] d = new double[m.getRowDimension()][m.getColumnDimension()];\n        for (int r = 0; r < m.getRowDimension(); r++) {\n            for (int c = 0; c < m.getColumnDimension(); c++) {\n                d[r][c] = Math.sqrt(m.getEntry(r, c));\n            }\n        }\n        return new Array2DRowRealMatrix(d, false);\n    }",
    "comment": " @param m Input matrix. @return Matrix representing the element-wise square root of m. ",
    "is_bug": false,
    "failing_test_cases": 28,
    "buggy_methods": 7
  },
  {
    "name": "CMAESOptimizer.square",
    "class_name": "org.apache.commons.math3.optim.nonlinear.scalar.noderiv.CMAESOptimizer",
    "signature": "org.apache.commons.math3.optim.nonlinear.scalar.noderiv.CMAESOptimizer.square(RealMatrix)",
    "snippet": "    private static RealMatrix square(final RealMatrix m) {\n        final double[][] d = new double[m.getRowDimension()][m.getColumnDimension()];\n        for (int r = 0; r < m.getRowDimension(); r++) {\n            for (int c = 0; c < m.getColumnDimension(); c++) {\n                double e = m.getEntry(r, c);\n                d[r][c] = e * e;\n            }\n        }\n        return new Array2DRowRealMatrix(d, false);\n    }",
    "comment": " @param m Input matrix. @return Matrix representing the element-wise square of m. ",
    "is_bug": false,
    "failing_test_cases": 28,
    "buggy_methods": 7
  },
  {
    "name": "CMAESOptimizer.sumRows",
    "class_name": "org.apache.commons.math3.optim.nonlinear.scalar.noderiv.CMAESOptimizer",
    "signature": "org.apache.commons.math3.optim.nonlinear.scalar.noderiv.CMAESOptimizer.sumRows(RealMatrix)",
    "snippet": "    private static RealMatrix sumRows(final RealMatrix m) {\n        final double[][] d = new double[1][m.getColumnDimension()];\n        for (int c = 0; c < m.getColumnDimension(); c++) {\n            double sum = 0;\n            for (int r = 0; r < m.getRowDimension(); r++) {\n                sum += m.getEntry(r, c);\n            }\n            d[0][c] = sum;\n        }\n        return new Array2DRowRealMatrix(d, false);\n    }",
    "comment": " @param m Input matrix. @return Row matrix representing the sums of the rows. ",
    "is_bug": false,
    "failing_test_cases": 28,
    "buggy_methods": 7
  },
  {
    "name": "CMAESOptimizer.times",
    "class_name": "org.apache.commons.math3.optim.nonlinear.scalar.noderiv.CMAESOptimizer",
    "signature": "org.apache.commons.math3.optim.nonlinear.scalar.noderiv.CMAESOptimizer.times(RealMatrix,RealMatrix)",
    "snippet": "    private static RealMatrix times(final RealMatrix m, final RealMatrix n) {\n        final double[][] d = new double[m.getRowDimension()][m.getColumnDimension()];\n        for (int r = 0; r < m.getRowDimension(); r++) {\n            for (int c = 0; c < m.getColumnDimension(); c++) {\n                d[r][c] = m.getEntry(r, c) * n.getEntry(r, c);\n            }\n        }\n        return new Array2DRowRealMatrix(d, false);\n    }",
    "comment": " @param m Input matrix 1. @param n Input matrix 2. @return the matrix where the elements of m and n are element-wise multiplied. ",
    "is_bug": false,
    "failing_test_cases": 28,
    "buggy_methods": 7
  },
  {
    "name": "CMAESOptimizer.triu",
    "class_name": "org.apache.commons.math3.optim.nonlinear.scalar.noderiv.CMAESOptimizer",
    "signature": "org.apache.commons.math3.optim.nonlinear.scalar.noderiv.CMAESOptimizer.triu(RealMatrix,int)",
    "snippet": "    private static RealMatrix triu(final RealMatrix m, int k) {\n        final double[][] d = new double[m.getRowDimension()][m.getColumnDimension()];\n        for (int r = 0; r < m.getRowDimension(); r++) {\n            for (int c = 0; c < m.getColumnDimension(); c++) {\n                d[r][c] = r <= c - k ? m.getEntry(r, c) : 0;\n            }\n        }\n        return new Array2DRowRealMatrix(d, false);\n    }",
    "comment": " @param m Input matrix. @param k Diagonal position. @return Upper triangular part of matrix. ",
    "is_bug": false,
    "failing_test_cases": 28,
    "buggy_methods": 7
  },
  {
    "name": "CMAESOptimizer.updateBD",
    "class_name": "org.apache.commons.math3.optim.nonlinear.scalar.noderiv.CMAESOptimizer",
    "signature": "org.apache.commons.math3.optim.nonlinear.scalar.noderiv.CMAESOptimizer.updateBD(double)",
    "snippet": "    private void updateBD(double negccov) {\n        if (ccov1 + ccovmu + negccov > 0 &&\n            (iterations % 1. / (ccov1 + ccovmu + negccov) / dimension / 10.) < 1) {\n            // to achieve O(N^2)\n            C = triu(C, 0).add(triu(C, 1).transpose());\n            // enforce symmetry to prevent complex numbers\n            final EigenDecomposition eig = new EigenDecomposition(C);\n            B = eig.getV(); // eigen decomposition, B==normalized eigenvectors\n            D = eig.getD();\n            diagD = diag(D);\n            if (min(diagD) <= 0) {\n                for (int i = 0; i < dimension; i++) {\n                    if (diagD.getEntry(i, 0) < 0) {\n                        diagD.setEntry(i, 0, 0);\n                    }\n                }\n                final double tfac = max(diagD) / 1e14;\n                C = C.add(eye(dimension, dimension).scalarMultiply(tfac));\n                diagD = diagD.add(ones(dimension, 1).scalarMultiply(tfac));\n            }\n            if (max(diagD) > 1e14 * min(diagD)) {\n                final double tfac = max(diagD) / 1e14 - min(diagD);\n                C = C.add(eye(dimension, dimension).scalarMultiply(tfac));\n                diagD = diagD.add(ones(dimension, 1).scalarMultiply(tfac));\n            }\n            diagC = diag(C);\n            diagD = sqrt(diagD); // D contains standard deviations now\n            BD = times(B, repmat(diagD.transpose(), dimension, 1)); // O(n^2)\n        }\n    }",
    "comment": " Update B and D from C.  @param negccov Negative covariance factor. ",
    "is_bug": false,
    "failing_test_cases": 28,
    "buggy_methods": 7
  },
  {
    "name": "CMAESOptimizer.updateCovariance",
    "class_name": "org.apache.commons.math3.optim.nonlinear.scalar.noderiv.CMAESOptimizer",
    "signature": "org.apache.commons.math3.optim.nonlinear.scalar.noderiv.CMAESOptimizer.updateCovariance(boolean,RealMatrix,RealMatrix,int[],RealMatrix)",
    "snippet": "    private void updateCovariance(boolean hsig, final RealMatrix bestArx,\n                                  final RealMatrix arz, final int[] arindex,\n                                  final RealMatrix xold) {\n        double negccov = 0;\n        if (ccov1 + ccovmu > 0) {\n            final RealMatrix arpos = bestArx.subtract(repmat(xold, 1, mu))\n                .scalarMultiply(1 / sigma); // mu difference vectors\n            final RealMatrix roneu = pc.multiply(pc.transpose())\n                .scalarMultiply(ccov1); // rank one update\n            // minor correction if hsig==false\n            double oldFac = hsig ? 0 : ccov1 * cc * (2 - cc);\n            oldFac += 1 - ccov1 - ccovmu;\n            if (isActiveCMA) {\n                // Adapt covariance matrix C active CMA\n                negccov = (1 - ccovmu) * 0.25 * mueff /\n                    (Math.pow(dimension + 2, 1.5) + 2 * mueff);\n                // keep at least 0.66 in all directions, small popsize are most\n                // critical\n                final double negminresidualvariance = 0.66;\n                // where to make up for the variance loss\n                final double negalphaold = 0.5;\n                // prepare vectors, compute negative updating matrix Cneg\n                final int[] arReverseIndex = reverse(arindex);\n                RealMatrix arzneg = selectColumns(arz, MathArrays.copyOf(arReverseIndex, mu));\n                RealMatrix arnorms = sqrt(sumRows(square(arzneg)));\n                final int[] idxnorms = sortedIndices(arnorms.getRow(0));\n                final RealMatrix arnormsSorted = selectColumns(arnorms, idxnorms);\n                final int[] idxReverse = reverse(idxnorms);\n                final RealMatrix arnormsReverse = selectColumns(arnorms, idxReverse);\n                arnorms = divide(arnormsReverse, arnormsSorted);\n                final int[] idxInv = inverse(idxnorms);\n                final RealMatrix arnormsInv = selectColumns(arnorms, idxInv);\n                // check and set learning rate negccov\n                final double negcovMax = (1 - negminresidualvariance) /\n                    square(arnormsInv).multiply(weights).getEntry(0, 0);\n                if (negccov > negcovMax) {\n                    negccov = negcovMax;\n                }\n                arzneg = times(arzneg, repmat(arnormsInv, dimension, 1));\n                final RealMatrix artmp = BD.multiply(arzneg);\n                final RealMatrix Cneg = artmp.multiply(diag(weights)).multiply(artmp.transpose());\n                oldFac += negalphaold * negccov;\n                C = C.scalarMultiply(oldFac)\n                    .add(roneu) // regard old matrix\n                    .add(arpos.scalarMultiply( // plus rank one update\n                                              ccovmu + (1 - negalphaold) * negccov) // plus rank mu update\n                         .multiply(times(repmat(weights, 1, dimension),\n                                         arpos.transpose())))\n                    .subtract(Cneg.scalarMultiply(negccov));\n            } else {\n                // Adapt covariance matrix C - nonactive\n                C = C.scalarMultiply(oldFac) // regard old matrix\n                    .add(roneu) // plus rank one update\n                    .add(arpos.scalarMultiply(ccovmu) // plus rank mu update\n                         .multiply(times(repmat(weights, 1, dimension),\n                                         arpos.transpose())));\n            }\n        }\n        updateBD(negccov);\n    }",
    "comment": " Update of the covariance matrix C.  @param hsig Flag indicating a small correction. @param bestArx Fitness-sorted matrix of the argument vectors producing the current offspring. @param arz Unsorted matrix containing the gaussian random values of the current offspring. @param arindex Indices indicating the fitness-order of the current offspring. @param xold xmean matrix of the previous generation. ",
    "is_bug": false,
    "failing_test_cases": 28,
    "buggy_methods": 7
  },
  {
    "name": "CMAESOptimizer.updateCovarianceDiagonalOnly",
    "class_name": "org.apache.commons.math3.optim.nonlinear.scalar.noderiv.CMAESOptimizer",
    "signature": "org.apache.commons.math3.optim.nonlinear.scalar.noderiv.CMAESOptimizer.updateCovarianceDiagonalOnly(boolean,RealMatrix)",
    "snippet": "    private void updateCovarianceDiagonalOnly(boolean hsig,\n                                              final RealMatrix bestArz) {\n        // minor correction if hsig==false\n        double oldFac = hsig ? 0 : ccov1Sep * cc * (2 - cc);\n        oldFac += 1 - ccov1Sep - ccovmuSep;\n        diagC = diagC.scalarMultiply(oldFac) // regard old matrix\n            .add(square(pc).scalarMultiply(ccov1Sep)) // plus rank one update\n            .add((times(diagC, square(bestArz).multiply(weights))) // plus rank mu update\n                 .scalarMultiply(ccovmuSep));\n        diagD = sqrt(diagC); // replaces eig(C)\n        if (diagonalOnly > 1 &&\n            iterations > diagonalOnly) {\n            // full covariance matrix from now on\n            diagonalOnly = 0;\n            B = eye(dimension, dimension);\n            BD = diag(diagD);\n            C = diag(diagC);\n        }\n    }",
    "comment": " Update of the covariance matrix C for diagonalOnly > 0  @param hsig Flag indicating a small correction. @param bestArz Fitness-sorted matrix of the gaussian random values of the current offspring. ",
    "is_bug": false,
    "failing_test_cases": 28,
    "buggy_methods": 7
  },
  {
    "name": "CMAESOptimizer.updateEvolutionPaths",
    "class_name": "org.apache.commons.math3.optim.nonlinear.scalar.noderiv.CMAESOptimizer",
    "signature": "org.apache.commons.math3.optim.nonlinear.scalar.noderiv.CMAESOptimizer.updateEvolutionPaths(RealMatrix,RealMatrix)",
    "snippet": "    private boolean updateEvolutionPaths(RealMatrix zmean, RealMatrix xold) {\n        ps = ps.scalarMultiply(1 - cs).add(\n                B.multiply(zmean).scalarMultiply(\n                        Math.sqrt(cs * (2 - cs) * mueff)));\n        normps = ps.getFrobeniusNorm();\n        final boolean hsig = normps /\n            Math.sqrt(1 - Math.pow(1 - cs, 2 * iterations)) /\n            chiN < 1.4 + 2 / ((double) dimension + 1);\n        pc = pc.scalarMultiply(1 - cc);\n        if (hsig) {\n            pc = pc.add(xmean.subtract(xold).scalarMultiply(Math.sqrt(cc * (2 - cc) * mueff) / sigma));\n        }\n        return hsig;\n    }",
    "comment": " Update of the evolution paths ps and pc.  @param zmean Weighted row matrix of the gaussian random numbers generating the current offspring. @param xold xmean matrix of the previous generation. @return hsig flag indicating a small correction. ",
    "is_bug": false,
    "failing_test_cases": 28,
    "buggy_methods": 7
  },
  {
    "name": "CMAESOptimizer.zeros",
    "class_name": "org.apache.commons.math3.optim.nonlinear.scalar.noderiv.CMAESOptimizer",
    "signature": "org.apache.commons.math3.optim.nonlinear.scalar.noderiv.CMAESOptimizer.zeros(int,int)",
    "snippet": "    private static RealMatrix zeros(int n, int m) {\n        return new Array2DRowRealMatrix(n, m);\n    }",
    "comment": " @param n Number of rows. @param m Number of columns. @return n-by-m matrix of zero values. ",
    "is_bug": false,
    "failing_test_cases": 28,
    "buggy_methods": 7
  },
  {
    "name": "DoubleIndex.compareTo",
    "class_name": "org.apache.commons.math3.optim.nonlinear.scalar.noderiv.CMAESOptimizer$DoubleIndex",
    "signature": "org.apache.commons.math3.optim.nonlinear.scalar.noderiv.CMAESOptimizer$DoubleIndex.compareTo(DoubleIndex)",
    "snippet": "        public int compareTo(DoubleIndex o) {\n            return Double.compare(value, o.value);\n        }",
    "comment": "{@inheritDoc} */",
    "is_bug": false,
    "failing_test_cases": 28,
    "buggy_methods": 7
  },
  {
    "name": "FitnessFunction.penalty",
    "class_name": "org.apache.commons.math3.optim.nonlinear.scalar.noderiv.CMAESOptimizer$FitnessFunction",
    "signature": "org.apache.commons.math3.optim.nonlinear.scalar.noderiv.CMAESOptimizer$FitnessFunction.penalty(double[],double[])",
    "snippet": "        private double penalty(final double[] x, final double[] repaired) {\n            double penalty = 0;\n            for (int i = 0; i < x.length; i++) {\n                double diff = Math.abs(x[i] - repaired[i]);\n                penalty += diff * valueRange;\n            }\n            return isMinimize ? penalty : -penalty;\n        }",
    "comment": " @param x Normalized objective variables. @param repaired Repaired objective variables. @return Penalty value according to the violation of the bounds. ",
    "is_bug": false,
    "failing_test_cases": 28,
    "buggy_methods": 7
  },
  {
    "name": "FitnessFunction.repair",
    "class_name": "org.apache.commons.math3.optim.nonlinear.scalar.noderiv.CMAESOptimizer$FitnessFunction",
    "signature": "org.apache.commons.math3.optim.nonlinear.scalar.noderiv.CMAESOptimizer$FitnessFunction.repair(double[])",
    "snippet": "        private double[] repair(final double[] x) {\n            final double[] lB = CMAESOptimizer.this.getLowerBound();\n            final double[] uB = CMAESOptimizer.this.getUpperBound();\n\n            final double[] repaired = new double[x.length];\n            for (int i = 0; i < x.length; i++) {\n                if (x[i] < lB[i]) {\n                    repaired[i] = lB[i];\n                } else if (x[i] > uB[i]) {\n                    repaired[i] = uB[i];\n                } else {\n                    repaired[i] = x[i];\n                }\n            }\n            return repaired;\n        }",
    "comment": " @param x Normalized objective variables. @return the repaired (i.e. all in bounds) objective variables. ",
    "is_bug": false,
    "failing_test_cases": 28,
    "buggy_methods": 7
  },
  {
    "name": "FitnessFunction.setValueRange",
    "class_name": "org.apache.commons.math3.optim.nonlinear.scalar.noderiv.CMAESOptimizer$FitnessFunction",
    "signature": "org.apache.commons.math3.optim.nonlinear.scalar.noderiv.CMAESOptimizer$FitnessFunction.setValueRange(double)",
    "snippet": "        public void setValueRange(double valueRange) {\n            this.valueRange = valueRange;\n        }",
    "comment": " @param valueRange Adjusts the penalty computation. ",
    "is_bug": false,
    "failing_test_cases": 28,
    "buggy_methods": 7
  },
  {
    "name": "FitnessFunction.value",
    "class_name": "org.apache.commons.math3.optim.nonlinear.scalar.noderiv.CMAESOptimizer$FitnessFunction",
    "signature": "org.apache.commons.math3.optim.nonlinear.scalar.noderiv.CMAESOptimizer$FitnessFunction.value(double[])",
    "snippet": "        public double value(final double[] point) {\n            double value;\n            if (isRepairMode) {\n                double[] repaired = repair(point);\n                value = CMAESOptimizer.this.computeObjectiveValue(repaired) +\n                    penalty(point, repaired);\n            } else {\n                value = CMAESOptimizer.this.computeObjectiveValue(point);\n            }\n            return isMinimize ? value : -value;\n        }",
    "comment": " @param point Normalized objective variables. @return the objective value + penalty for violated bounds. ",
    "is_bug": false,
    "failing_test_cases": 28,
    "buggy_methods": 7
  },
  {
    "name": "PopulationSize.getPopulationSize",
    "class_name": "org.apache.commons.math3.optim.nonlinear.scalar.noderiv.CMAESOptimizer$PopulationSize",
    "signature": "org.apache.commons.math3.optim.nonlinear.scalar.noderiv.CMAESOptimizer$PopulationSize.getPopulationSize()",
    "snippet": "        public int getPopulationSize() {\n            return lambda;\n        }",
    "comment": " @return the population size. ",
    "is_bug": false,
    "failing_test_cases": 28,
    "buggy_methods": 7
  },
  {
    "name": "Sigma.getSigma",
    "class_name": "org.apache.commons.math3.optim.nonlinear.scalar.noderiv.CMAESOptimizer$Sigma",
    "signature": "org.apache.commons.math3.optim.nonlinear.scalar.noderiv.CMAESOptimizer$Sigma.getSigma()",
    "snippet": "        public double[] getSigma() {\n            return sigma.clone();\n        }",
    "comment": " @return the sigma values. ",
    "is_bug": false,
    "failing_test_cases": 28,
    "buggy_methods": 7
  },
  {
    "name": "MultiDirectionalSimplex.MultiDirectionalSimplex",
    "class_name": "org.apache.commons.math3.optim.nonlinear.scalar.noderiv.MultiDirectionalSimplex",
    "signature": "org.apache.commons.math3.optim.nonlinear.scalar.noderiv.MultiDirectionalSimplex.MultiDirectionalSimplex(double[])",
    "snippet": "    public MultiDirectionalSimplex(final double[] steps) {\n        this(steps, DEFAULT_KHI, DEFAULT_GAMMA);\n    }",
    "comment": " Build a multi-directional simplex with default coefficients. The default values are 2.0 for khi and 0.5 for gamma.  @param steps Steps along the canonical axes representing box edges. They may be negative but not zero. See ",
    "is_bug": false,
    "failing_test_cases": 28,
    "buggy_methods": 7
  },
  {
    "name": "MultiDirectionalSimplex.MultiDirectionalSimplex",
    "class_name": "org.apache.commons.math3.optim.nonlinear.scalar.noderiv.MultiDirectionalSimplex",
    "signature": "org.apache.commons.math3.optim.nonlinear.scalar.noderiv.MultiDirectionalSimplex.MultiDirectionalSimplex(double[],double,double)",
    "snippet": "    public MultiDirectionalSimplex(final double[] steps,\n                                   final double khi, final double gamma) {\n        super(steps);\n\n        this.khi   = khi;\n        this.gamma = gamma;\n    }",
    "comment": " Build a multi-directional simplex with specified coefficients.  @param steps Steps along the canonical axes representing box edges. They may be negative but not zero. See {@link AbstractSimplex#AbstractSimplex(double[])}. @param khi Expansion coefficient. @param gamma Contraction coefficient. ",
    "is_bug": false,
    "failing_test_cases": 28,
    "buggy_methods": 7
  },
  {
    "name": "MultiDirectionalSimplex.evaluateNewSimplex",
    "class_name": "org.apache.commons.math3.optim.nonlinear.scalar.noderiv.MultiDirectionalSimplex",
    "signature": "org.apache.commons.math3.optim.nonlinear.scalar.noderiv.MultiDirectionalSimplex.evaluateNewSimplex(MultivariateFunction,PointValuePair[],double,Comparator)",
    "snippet": "    private PointValuePair evaluateNewSimplex(final MultivariateFunction evaluationFunction,\n                                                  final PointValuePair[] original,\n                                                  final double coeff,\n                                                  final Comparator<PointValuePair> comparator) {\n        final double[] xSmallest = original[0].getPointRef();\n        // Perform a linear transformation on all the simplex points,\n        // except the first one.\n        setPoint(0, original[0]);\n        final int dim = getDimension();\n        for (int i = 1; i < getSize(); i++) {\n            final double[] xOriginal = original[i].getPointRef();\n            final double[] xTransformed = new double[dim];\n            for (int j = 0; j < dim; j++) {\n                xTransformed[j] = xSmallest[j] + coeff * (xSmallest[j] - xOriginal[j]);\n            }\n            setPoint(i, new PointValuePair(xTransformed, Double.NaN, false));\n        }\n\n        // Evaluate the simplex.\n        evaluate(evaluationFunction, comparator);\n\n        return getPoint(0);\n    }",
    "comment": " Compute and evaluate a new simplex.  @param evaluationFunction Evaluation function. @param original Original simplex (to be preserved). @param coeff Linear coefficient. @param comparator Comparator to use to sort simplex vertices from best to poorest. @return the best point in the transformed simplex. @throws org.apache.commons.math3.exception.TooManyEvaluationsException if the maximal number of evaluations is exceeded. ",
    "is_bug": false,
    "failing_test_cases": 28,
    "buggy_methods": 7
  },
  {
    "name": "MultiDirectionalSimplex.iterate",
    "class_name": "org.apache.commons.math3.optim.nonlinear.scalar.noderiv.MultiDirectionalSimplex",
    "signature": "org.apache.commons.math3.optim.nonlinear.scalar.noderiv.MultiDirectionalSimplex.iterate(MultivariateFunction,Comparator)",
    "snippet": "    @Override\n    public void iterate(final MultivariateFunction evaluationFunction,\n                        final Comparator<PointValuePair> comparator) {\n        // Save the original simplex.\n        final PointValuePair[] original = getPoints();\n        final PointValuePair best = original[0];\n\n        // Perform a reflection step.\n        final PointValuePair reflected = evaluateNewSimplex(evaluationFunction,\n                                                                original, 1, comparator);\n        if (comparator.compare(reflected, best) < 0) {\n            // Compute the expanded simplex.\n            final PointValuePair[] reflectedSimplex = getPoints();\n            final PointValuePair expanded = evaluateNewSimplex(evaluationFunction,\n                                                                   original, khi, comparator);\n            if (comparator.compare(reflected, expanded) <= 0) {\n                // Keep the reflected simplex.\n                setPoints(reflectedSimplex);\n            }\n            // Keep the expanded simplex.\n            return;\n        }\n\n        // Compute the contracted simplex.\n        evaluateNewSimplex(evaluationFunction, original, gamma, comparator);\n\n    }",
    "comment": "{@inheritDoc} */",
    "is_bug": false,
    "failing_test_cases": 28,
    "buggy_methods": 7
  },
  {
    "name": "NelderMeadSimplex.NelderMeadSimplex",
    "class_name": "org.apache.commons.math3.optim.nonlinear.scalar.noderiv.NelderMeadSimplex",
    "signature": "org.apache.commons.math3.optim.nonlinear.scalar.noderiv.NelderMeadSimplex.NelderMeadSimplex(double[])",
    "snippet": "    public NelderMeadSimplex(final double[] steps) {\n        this(steps, DEFAULT_RHO, DEFAULT_KHI, DEFAULT_GAMMA, DEFAULT_SIGMA);\n    }",
    "comment": " Build a Nelder-Mead simplex with default coefficients. The default coefficients are 1.0 for rho, 2.0 for khi and 0.5 for both gamma and sigma.  @param steps Steps along the canonical axes representing box edges. They may be negative but not zero. See ",
    "is_bug": false,
    "failing_test_cases": 28,
    "buggy_methods": 7
  },
  {
    "name": "NelderMeadSimplex.NelderMeadSimplex",
    "class_name": "org.apache.commons.math3.optim.nonlinear.scalar.noderiv.NelderMeadSimplex",
    "signature": "org.apache.commons.math3.optim.nonlinear.scalar.noderiv.NelderMeadSimplex.NelderMeadSimplex(double[],double,double,double,double)",
    "snippet": "    public NelderMeadSimplex(final double[] steps,\n                             final double rho, final double khi,\n                             final double gamma, final double sigma) {\n        super(steps);\n\n        this.rho = rho;\n        this.khi = khi;\n        this.gamma = gamma;\n        this.sigma = sigma;\n    }",
    "comment": " Build a Nelder-Mead simplex with specified coefficients.  @param steps Steps along the canonical axes representing box edges. They may be negative but not zero. See {@link AbstractSimplex#AbstractSimplex(double[])}. @param rho Reflection coefficient. @param khi Expansion coefficient. @param gamma Contraction coefficient. @param sigma Shrinkage coefficient. @throws IllegalArgumentException if one of the steps is zero. ",
    "is_bug": false,
    "failing_test_cases": 28,
    "buggy_methods": 7
  },
  {
    "name": "NelderMeadSimplex.iterate",
    "class_name": "org.apache.commons.math3.optim.nonlinear.scalar.noderiv.NelderMeadSimplex",
    "signature": "org.apache.commons.math3.optim.nonlinear.scalar.noderiv.NelderMeadSimplex.iterate(MultivariateFunction,Comparator)",
    "snippet": "    @Override\n    public void iterate(final MultivariateFunction evaluationFunction,\n                        final Comparator<PointValuePair> comparator) {\n        // The simplex has n + 1 points if dimension is n.\n        final int n = getDimension();\n\n        // Interesting values.\n        final PointValuePair best = getPoint(0);\n        final PointValuePair secondBest = getPoint(n - 1);\n        final PointValuePair worst = getPoint(n);\n        final double[] xWorst = worst.getPointRef();\n\n        // Compute the centroid of the best vertices (dismissing the worst\n        // point at index n).\n        final double[] centroid = new double[n];\n        for (int i = 0; i < n; i++) {\n            final double[] x = getPoint(i).getPointRef();\n            for (int j = 0; j < n; j++) {\n                centroid[j] += x[j];\n            }\n        }\n        final double scaling = 1.0 / n;\n        for (int j = 0; j < n; j++) {\n            centroid[j] *= scaling;\n        }\n\n        // compute the reflection point\n        final double[] xR = new double[n];\n        for (int j = 0; j < n; j++) {\n            xR[j] = centroid[j] + rho * (centroid[j] - xWorst[j]);\n        }\n        final PointValuePair reflected\n            = new PointValuePair(xR, evaluationFunction.value(xR), false);\n\n        if (comparator.compare(best, reflected) <= 0 &&\n            comparator.compare(reflected, secondBest) < 0) {\n            // Accept the reflected point.\n            replaceWorstPoint(reflected, comparator);\n        } else if (comparator.compare(reflected, best) < 0) {\n            // Compute the expansion point.\n            final double[] xE = new double[n];\n            for (int j = 0; j < n; j++) {\n                xE[j] = centroid[j] + khi * (xR[j] - centroid[j]);\n            }\n            final PointValuePair expanded\n                = new PointValuePair(xE, evaluationFunction.value(xE), false);\n\n            if (comparator.compare(expanded, reflected) < 0) {\n                // Accept the expansion point.\n                replaceWorstPoint(expanded, comparator);\n            } else {\n                // Accept the reflected point.\n                replaceWorstPoint(reflected, comparator);\n            }\n        } else {\n            if (comparator.compare(reflected, worst) < 0) {\n                // Perform an outside contraction.\n                final double[] xC = new double[n];\n                for (int j = 0; j < n; j++) {\n                    xC[j] = centroid[j] + gamma * (xR[j] - centroid[j]);\n                }\n                final PointValuePair outContracted\n                    = new PointValuePair(xC, evaluationFunction.value(xC), false);\n                if (comparator.compare(outContracted, reflected) <= 0) {\n                    // Accept the contraction point.\n                    replaceWorstPoint(outContracted, comparator);\n                    return;\n                }\n            } else {\n                // Perform an inside contraction.\n                final double[] xC = new double[n];\n                for (int j = 0; j < n; j++) {\n                    xC[j] = centroid[j] - gamma * (centroid[j] - xWorst[j]);\n                }\n                final PointValuePair inContracted\n                    = new PointValuePair(xC, evaluationFunction.value(xC), false);\n\n                if (comparator.compare(inContracted, worst) < 0) {\n                    // Accept the contraction point.\n                    replaceWorstPoint(inContracted, comparator);\n                    return;\n                }\n            }\n\n            // Perform a shrink.\n            final double[] xSmallest = getPoint(0).getPointRef();\n            for (int i = 1; i <= n; i++) {\n                final double[] x = getPoint(i).getPoint();\n                for (int j = 0; j < n; j++) {\n                    x[j] = xSmallest[j] + sigma * (x[j] - xSmallest[j]);\n                }\n                setPoint(i, new PointValuePair(x, Double.NaN, false));\n            }\n            evaluate(evaluationFunction, comparator);\n        }\n    }",
    "comment": "{@inheritDoc} */",
    "is_bug": false,
    "failing_test_cases": 28,
    "buggy_methods": 7
  },
  {
    "name": "PowellOptimizer.PowellOptimizer",
    "class_name": "org.apache.commons.math3.optim.nonlinear.scalar.noderiv.PowellOptimizer",
    "signature": "org.apache.commons.math3.optim.nonlinear.scalar.noderiv.PowellOptimizer.PowellOptimizer(double,double)",
    "snippet": "    public PowellOptimizer(double rel,\n                           double abs) {\n        this(rel, abs, null);\n    }",
    "comment": " The parameters control the default convergence checking procedure. <br/> The internal line search tolerances are set to the square-root of their corresponding value in the multivariate optimizer.  @param rel Relative threshold. @param abs Absolute threshold. @throws NotStrictlyPositiveException if {@code abs <= 0}. @throws NumberIsTooSmallException if {@code rel < 2 * Math.ulp(1d)}. ",
    "is_bug": false,
    "failing_test_cases": 28,
    "buggy_methods": 7
  },
  {
    "name": "PowellOptimizer.PowellOptimizer",
    "class_name": "org.apache.commons.math3.optim.nonlinear.scalar.noderiv.PowellOptimizer",
    "signature": "org.apache.commons.math3.optim.nonlinear.scalar.noderiv.PowellOptimizer.PowellOptimizer(double,double,ConvergenceChecker)",
    "snippet": "    public PowellOptimizer(double rel,\n                           double abs,\n                           ConvergenceChecker<PointValuePair> checker) {\n        this(rel, abs, FastMath.sqrt(rel), FastMath.sqrt(abs), checker);\n    }",
    "comment": " This constructor allows to specify a user-defined convergence checker, in addition to the parameters that control the default convergence checking procedure. <br/> The internal line search tolerances are set to the square-root of their corresponding value in the multivariate optimizer.  @param rel Relative threshold. @param abs Absolute threshold. @param checker Convergence checker. @throws NotStrictlyPositiveException if {@code abs <= 0}. @throws NumberIsTooSmallException if {@code rel < 2 * Math.ulp(1d)}. ",
    "is_bug": false,
    "failing_test_cases": 28,
    "buggy_methods": 7
  },
  {
    "name": "PowellOptimizer.PowellOptimizer",
    "class_name": "org.apache.commons.math3.optim.nonlinear.scalar.noderiv.PowellOptimizer",
    "signature": "org.apache.commons.math3.optim.nonlinear.scalar.noderiv.PowellOptimizer.PowellOptimizer(double,double,double,double)",
    "snippet": "    public PowellOptimizer(double rel,\n                           double abs,\n                           double lineRel,\n                           double lineAbs) {\n        this(rel, abs, lineRel, lineAbs, null);\n    }",
    "comment": " Builds an instance with the default convergence checking procedure.  @param rel Relative threshold. @param abs Absolute threshold. @param lineRel Relative threshold for the internal line search optimizer. @param lineAbs Absolute threshold for the internal line search optimizer. @throws NotStrictlyPositiveException if {@code abs <= 0}. @throws NumberIsTooSmallException if {@code rel < 2 * Math.ulp(1d)}. ",
    "is_bug": false,
    "failing_test_cases": 28,
    "buggy_methods": 7
  },
  {
    "name": "PowellOptimizer.PowellOptimizer",
    "class_name": "org.apache.commons.math3.optim.nonlinear.scalar.noderiv.PowellOptimizer",
    "signature": "org.apache.commons.math3.optim.nonlinear.scalar.noderiv.PowellOptimizer.PowellOptimizer(double,double,double,double,ConvergenceChecker)",
    "snippet": "    public PowellOptimizer(double rel,\n                           double abs,\n                           double lineRel,\n                           double lineAbs,\n                           ConvergenceChecker<PointValuePair> checker) {\n        super(checker);\n\n        if (rel < MIN_RELATIVE_TOLERANCE) {\n            throw new NumberIsTooSmallException(rel, MIN_RELATIVE_TOLERANCE, true);\n        }\n        if (abs <= 0) {\n            throw new NotStrictlyPositiveException(abs);\n        }\n        relativeThreshold = rel;\n        absoluteThreshold = abs;\n\n        // Create the line search optimizer.\n        line = new LineSearch(lineRel,\n                              lineAbs);\n    }",
    "comment": " This constructor allows to specify a user-defined convergence checker, in addition to the parameters that control the default convergence checking procedure and the line search tolerances.  @param rel Relative threshold for this optimizer. @param abs Absolute threshold for this optimizer. @param lineRel Relative threshold for the internal line search optimizer. @param lineAbs Absolute threshold for the internal line search optimizer. @param checker Convergence checker. @throws NotStrictlyPositiveException if {@code abs <= 0}. @throws NumberIsTooSmallException if {@code rel < 2 * Math.ulp(1d)}. ",
    "is_bug": false,
    "failing_test_cases": 28,
    "buggy_methods": 7
  },
  {
    "name": "PowellOptimizer.checkParameters",
    "class_name": "org.apache.commons.math3.optim.nonlinear.scalar.noderiv.PowellOptimizer",
    "signature": "org.apache.commons.math3.optim.nonlinear.scalar.noderiv.PowellOptimizer.checkParameters()",
    "snippet": "    private void checkParameters() {\n        if (getLowerBound() != null ||\n            getUpperBound() != null) {\n            throw new MathUnsupportedOperationException(LocalizedFormats.CONSTRAINT);\n        }\n    }",
    "comment": " @throws MathUnsupportedOperationException if bounds were passed to the {@link #optimize(OptimizationData[]) optimize} method. ",
    "is_bug": false,
    "failing_test_cases": 28,
    "buggy_methods": 7
  },
  {
    "name": "PowellOptimizer.doOptimize",
    "class_name": "org.apache.commons.math3.optim.nonlinear.scalar.noderiv.PowellOptimizer",
    "signature": "org.apache.commons.math3.optim.nonlinear.scalar.noderiv.PowellOptimizer.doOptimize()",
    "snippet": "    @Override\n    protected PointValuePair doOptimize() {\n        checkParameters();\n\n        final GoalType goal = getGoalType();\n        final double[] guess = getStartPoint();\n        final int n = guess.length;\n\n        final double[][] direc = new double[n][n];\n        for (int i = 0; i < n; i++) {\n            direc[i][i] = 1;\n        }\n\n        final ConvergenceChecker<PointValuePair> checker\n            = getConvergenceChecker();\n\n        double[] x = guess;\n        double fVal = computeObjectiveValue(x);\n        double[] x1 = x.clone();\n        int iter = 0;\n        while (true) {\n            ++iter;\n\n            double fX = fVal;\n            double fX2 = 0;\n            double delta = 0;\n            int bigInd = 0;\n            double alphaMin = 0;\n\n            for (int i = 0; i < n; i++) {\n                final double[] d = MathArrays.copyOf(direc[i]);\n\n                fX2 = fVal;\n\n                final UnivariatePointValuePair optimum = line.search(x, d);\n                fVal = optimum.getValue();\n                alphaMin = optimum.getPoint();\n                final double[][] result = newPointAndDirection(x, d, alphaMin);\n                x = result[0];\n\n                if ((fX2 - fVal) > delta) {\n                    delta = fX2 - fVal;\n                    bigInd = i;\n                }\n            }\n\n            // Default convergence check.\n            boolean stop = 2 * (fX - fVal) <=\n                (relativeThreshold * (FastMath.abs(fX) + FastMath.abs(fVal)) +\n                 absoluteThreshold);\n\n            final PointValuePair previous = new PointValuePair(x1, fX);\n            final PointValuePair current = new PointValuePair(x, fVal);\n            if (!stop) { // User-defined stopping criteria.\n                if (checker != null) {\n                    stop = checker.converged(iter, previous, current);\n                }\n            }\n            if (stop) {\n                if (goal == GoalType.MINIMIZE) {\n                    return (fVal < fX) ? current : previous;\n                } else {\n                    return (fVal > fX) ? current : previous;\n                }\n            }\n\n            final double[] d = new double[n];\n            final double[] x2 = new double[n];\n            for (int i = 0; i < n; i++) {\n                d[i] = x[i] - x1[i];\n                x2[i] = 2 * x[i] - x1[i];\n            }\n\n            x1 = x.clone();\n            fX2 = computeObjectiveValue(x2);\n\n            if (fX > fX2) {\n                double t = 2 * (fX + fX2 - 2 * fVal);\n                double temp = fX - fVal - delta;\n                t *= temp * temp;\n                temp = fX - fX2;\n                t -= delta * temp * temp;\n\n                if (t < 0.0) {\n                    final UnivariatePointValuePair optimum = line.search(x, d);\n                    fVal = optimum.getValue();\n                    alphaMin = optimum.getPoint();\n                    final double[][] result = newPointAndDirection(x, d, alphaMin);\n                    x = result[0];\n\n                    final int lastInd = n - 1;\n                    direc[bigInd] = direc[lastInd];\n                    direc[lastInd] = result[1];\n                }\n            }\n        }\n    }",
    "comment": "{@inheritDoc} */",
    "is_bug": true,
    "failing_test_cases": 28,
    "buggy_methods": 7
  },
  {
    "name": "PowellOptimizer.newPointAndDirection",
    "class_name": "org.apache.commons.math3.optim.nonlinear.scalar.noderiv.PowellOptimizer",
    "signature": "org.apache.commons.math3.optim.nonlinear.scalar.noderiv.PowellOptimizer.newPointAndDirection(double[],double[],double)",
    "snippet": "    private double[][] newPointAndDirection(double[] p,\n                                            double[] d,\n                                            double optimum) {\n        final int n = p.length;\n        final double[] nP = new double[n];\n        final double[] nD = new double[n];\n        for (int i = 0; i < n; i++) {\n            nD[i] = d[i] * optimum;\n            nP[i] = p[i] + nD[i];\n        }\n\n        final double[][] result = new double[2][];\n        result[0] = nP;\n        result[1] = nD;\n\n        return result;\n    }",
    "comment": " Compute a new point (in the original space) and a new direction vector, resulting from the line search.  @param p Point used in the line search. @param d Direction used in the line search. @param optimum Optimum found by the line search. @return a 2-element array containing the new point (at index 0) and the new direction (at index 1). ",
    "is_bug": false,
    "failing_test_cases": 28,
    "buggy_methods": 7
  },
  {
    "name": "LineSearch.search",
    "class_name": "org.apache.commons.math3.optim.nonlinear.scalar.noderiv.PowellOptimizer$LineSearch",
    "signature": "org.apache.commons.math3.optim.nonlinear.scalar.noderiv.PowellOptimizer$LineSearch.search(double[],double[])",
    "snippet": "        public UnivariatePointValuePair search(final double[] p, final double[] d) {\n            final int n = p.length;\n            final UnivariateFunction f = new UnivariateFunction() {\n                    public double value(double alpha) {\n                        final double[] x = new double[n];\n                        for (int i = 0; i < n; i++) {\n                            x[i] = p[i] + alpha * d[i];\n                        }\n                        final double obj = PowellOptimizer.this.computeObjectiveValue(x);\n                        return obj;\n                    }\n                };\n\n            final GoalType goal = PowellOptimizer.this.getGoalType();\n            bracket.search(f, goal, 0, 1);\n            // Passing \"MAX_VALUE\" as a dummy value because it is the enclosing\n            // class that counts the number of evaluations (and will eventually\n            // generate the exception).\n            return optimize(new MaxEval(Integer.MAX_VALUE),\n                            new UnivariateObjectiveFunction(f),\n                            goal,\n                            new SearchInterval(bracket.getLo(),\n                                               bracket.getHi(),\n                                               bracket.getMid()));\n        }",
    "comment": " Find the minimum of the function {@code f(p + alpha * d)}.  @param p Starting point. @param d Search direction. @return the optimum. @throws org.apache.commons.math3.exception.TooManyEvaluationsException if the number of evaluations is exceeded. ",
    "is_bug": false,
    "failing_test_cases": 28,
    "buggy_methods": 7
  },
  {
    "name": "SimplexOptimizer.SimplexOptimizer",
    "class_name": "org.apache.commons.math3.optim.nonlinear.scalar.noderiv.SimplexOptimizer",
    "signature": "org.apache.commons.math3.optim.nonlinear.scalar.noderiv.SimplexOptimizer.SimplexOptimizer(ConvergenceChecker)",
    "snippet": "    public SimplexOptimizer(ConvergenceChecker<PointValuePair> checker) {\n        super(checker);\n    }",
    "comment": " @param checker Convergence checker. ",
    "is_bug": false,
    "failing_test_cases": 28,
    "buggy_methods": 7
  },
  {
    "name": "SimplexOptimizer.SimplexOptimizer",
    "class_name": "org.apache.commons.math3.optim.nonlinear.scalar.noderiv.SimplexOptimizer",
    "signature": "org.apache.commons.math3.optim.nonlinear.scalar.noderiv.SimplexOptimizer.SimplexOptimizer(double,double)",
    "snippet": "    public SimplexOptimizer(double rel, double abs) {\n        this(new SimpleValueChecker(rel, abs));\n    }",
    "comment": " @param rel Relative threshold. @param abs Absolute threshold. ",
    "is_bug": false,
    "failing_test_cases": 28,
    "buggy_methods": 7
  },
  {
    "name": "SimplexOptimizer.checkParameters",
    "class_name": "org.apache.commons.math3.optim.nonlinear.scalar.noderiv.SimplexOptimizer",
    "signature": "org.apache.commons.math3.optim.nonlinear.scalar.noderiv.SimplexOptimizer.checkParameters()",
    "snippet": "    private void checkParameters() {\n        if (simplex == null) {\n            throw new NullArgumentException();\n        }\n        if (getLowerBound() != null ||\n            getUpperBound() != null) {\n            throw new MathUnsupportedOperationException(LocalizedFormats.CONSTRAINT);\n        }\n    }",
    "comment": " @throws MathUnsupportedOperationException if bounds were passed to the {@link #optimize(OptimizationData[]) optimize} method. @throws NullArgumentException if no initial simplex was passed to the {@link #optimize(OptimizationData[]) optimize} method. ",
    "is_bug": false,
    "failing_test_cases": 28,
    "buggy_methods": 7
  },
  {
    "name": "SimplexOptimizer.doOptimize",
    "class_name": "org.apache.commons.math3.optim.nonlinear.scalar.noderiv.SimplexOptimizer",
    "signature": "org.apache.commons.math3.optim.nonlinear.scalar.noderiv.SimplexOptimizer.doOptimize()",
    "snippet": "    @Override\n    protected PointValuePair doOptimize() {\n        checkParameters();\n\n        // Indirect call to \"computeObjectiveValue\" in order to update the\n        // evaluations counter.\n        final MultivariateFunction evalFunc\n            = new MultivariateFunction() {\n                public double value(double[] point) {\n                    return computeObjectiveValue(point);\n                }\n            };\n\n        final boolean isMinim = getGoalType() == GoalType.MINIMIZE;\n        final Comparator<PointValuePair> comparator\n            = new Comparator<PointValuePair>() {\n            public int compare(final PointValuePair o1,\n                               final PointValuePair o2) {\n                final double v1 = o1.getValue();\n                final double v2 = o2.getValue();\n                return isMinim ? Double.compare(v1, v2) : Double.compare(v2, v1);\n            }\n        };\n\n        // Initialize search.\n        simplex.build(getStartPoint());\n        simplex.evaluate(evalFunc, comparator);\n\n        PointValuePair[] previous = null;\n        int iteration = 0;\n        final ConvergenceChecker<PointValuePair> checker = getConvergenceChecker();\n        while (true) {\n            if (iteration > 0) {\n                boolean converged = true;\n                for (int i = 0; i < simplex.getSize(); i++) {\n                    PointValuePair prev = previous[i];\n                    converged = converged &&\n                        checker.converged(iteration, prev, simplex.getPoint(i));\n                }\n                if (converged) {\n                    // We have found an optimum.\n                    return simplex.getPoint(0);\n                }\n            }\n\n            // We still need to search.\n            previous = simplex.getPoints();\n            simplex.iterate(evalFunc, comparator);\n\n\t\t\t++iteration;\n        }\n    }",
    "comment": "{@inheritDoc} */",
    "is_bug": true,
    "failing_test_cases": 28,
    "buggy_methods": 7
  },
  {
    "name": "SimplexOptimizer.optimize",
    "class_name": "org.apache.commons.math3.optim.nonlinear.scalar.noderiv.SimplexOptimizer",
    "signature": "org.apache.commons.math3.optim.nonlinear.scalar.noderiv.SimplexOptimizer.optimize(OptimizationData[])",
    "snippet": "    @Override\n    public PointValuePair optimize(OptimizationData... optData) {\n        // Set up base class and perform computation.\n        return super.optimize(optData);\n    }",
    "comment": " {@inheritDoc}  @param optData Optimization data. In addition to those documented in {@link MultivariateOptimizer#parseOptimizationData(OptimizationData[]) MultivariateOptimizer}, this method will register the following data: <ul> <li>{@link AbstractSimplex}</li> </ul> @return {@inheritDoc} ",
    "is_bug": false,
    "failing_test_cases": 28,
    "buggy_methods": 7
  },
  {
    "name": "SimplexOptimizer.parseOptimizationData",
    "class_name": "org.apache.commons.math3.optim.nonlinear.scalar.noderiv.SimplexOptimizer",
    "signature": "org.apache.commons.math3.optim.nonlinear.scalar.noderiv.SimplexOptimizer.parseOptimizationData(OptimizationData[])",
    "snippet": "    @Override\n    protected void parseOptimizationData(OptimizationData... optData) {\n        // Allow base class to register its own data.\n        super.parseOptimizationData(optData);\n\n        // The existing values (as set by the previous call) are reused if\n        // not provided in the argument list.\n        for (OptimizationData data : optData) {\n            if (data instanceof AbstractSimplex) {\n                simplex = (AbstractSimplex) data;\n                // If more data must be parsed, this statement _must_ be\n                // changed to \"continue\".\n                break;\n            }\n        }\n    }",
    "comment": " Scans the list of (required and optional) optimization data that characterize the problem.  @param optData Optimization data. The following data will be looked for: <ul> <li>{@link AbstractSimplex}</li> </ul> ",
    "is_bug": false,
    "failing_test_cases": 28,
    "buggy_methods": 7
  },
  {
    "name": "JacobianMultivariateVectorOptimizer.JacobianMultivariateVectorOptimizer",
    "class_name": "org.apache.commons.math3.optim.nonlinear.vector.JacobianMultivariateVectorOptimizer",
    "signature": "org.apache.commons.math3.optim.nonlinear.vector.JacobianMultivariateVectorOptimizer.JacobianMultivariateVectorOptimizer(ConvergenceChecker)",
    "snippet": "    protected JacobianMultivariateVectorOptimizer(ConvergenceChecker<PointVectorValuePair> checker) {\n        super(checker);\n    }",
    "comment": " @param checker Convergence checker. ",
    "is_bug": false,
    "failing_test_cases": 28,
    "buggy_methods": 7
  },
  {
    "name": "JacobianMultivariateVectorOptimizer.computeJacobian",
    "class_name": "org.apache.commons.math3.optim.nonlinear.vector.JacobianMultivariateVectorOptimizer",
    "signature": "org.apache.commons.math3.optim.nonlinear.vector.JacobianMultivariateVectorOptimizer.computeJacobian(double[])",
    "snippet": "    protected double[][] computeJacobian(final double[] params) {\n        return jacobian.value(params);\n    }",
    "comment": " Computes the Jacobian matrix.  @param params Point at which the Jacobian must be evaluated. @return the Jacobian at the specified point. ",
    "is_bug": false,
    "failing_test_cases": 28,
    "buggy_methods": 7
  },
  {
    "name": "JacobianMultivariateVectorOptimizer.optimize",
    "class_name": "org.apache.commons.math3.optim.nonlinear.vector.JacobianMultivariateVectorOptimizer",
    "signature": "org.apache.commons.math3.optim.nonlinear.vector.JacobianMultivariateVectorOptimizer.optimize(OptimizationData[])",
    "snippet": "    @Override\n    public PointVectorValuePair optimize(OptimizationData... optData)\n        throws TooManyEvaluationsException,\n               DimensionMismatchException {\n        // Set up base class and perform computation.\n        return super.optimize(optData);\n    }",
    "comment": " {@inheritDoc}  @param optData Optimization data. In addition to those documented in {@link MultivariateVectorOptimizer#optimize(OptimizationData...)} MultivariateOptimizer}, this method will register the following data: <ul> <li>{@link ModelFunctionJacobian}</li> </ul> @return {@inheritDoc} @throws TooManyEvaluationsException if the maximal number of evaluations is exceeded. @throws DimensionMismatchException if the initial guess, target, and weight arguments have inconsistent dimensions. ",
    "is_bug": false,
    "failing_test_cases": 28,
    "buggy_methods": 7
  },
  {
    "name": "JacobianMultivariateVectorOptimizer.parseOptimizationData",
    "class_name": "org.apache.commons.math3.optim.nonlinear.vector.JacobianMultivariateVectorOptimizer",
    "signature": "org.apache.commons.math3.optim.nonlinear.vector.JacobianMultivariateVectorOptimizer.parseOptimizationData(OptimizationData[])",
    "snippet": "    @Override\n    protected void parseOptimizationData(OptimizationData... optData) {\n        // Allow base class to register its own data.\n        super.parseOptimizationData(optData);\n\n        // The existing values (as set by the previous call) are reused if\n        // not provided in the argument list.\n        for (OptimizationData data : optData) {\n            if (data instanceof ModelFunctionJacobian) {\n                jacobian = ((ModelFunctionJacobian) data).getModelFunctionJacobian();\n                // If more data must be parsed, this statement _must_ be\n                // changed to \"continue\".\n                break;\n            }\n        }\n    }",
    "comment": " Scans the list of (required and optional) optimization data that characterize the problem.  @param optData Optimization data. The following data will be looked for: <ul> <li>{@link ModelFunctionJacobian}</li> </ul> ",
    "is_bug": false,
    "failing_test_cases": 28,
    "buggy_methods": 7
  },
  {
    "name": "ModelFunction.ModelFunction",
    "class_name": "org.apache.commons.math3.optim.nonlinear.vector.ModelFunction",
    "signature": "org.apache.commons.math3.optim.nonlinear.vector.ModelFunction.ModelFunction(MultivariateVectorFunction)",
    "snippet": "    public ModelFunction(MultivariateVectorFunction m) {\n        model = m;\n    }",
    "comment": " @param m Model function to be optimized. ",
    "is_bug": false,
    "failing_test_cases": 28,
    "buggy_methods": 7
  },
  {
    "name": "ModelFunction.getModelFunction",
    "class_name": "org.apache.commons.math3.optim.nonlinear.vector.ModelFunction",
    "signature": "org.apache.commons.math3.optim.nonlinear.vector.ModelFunction.getModelFunction()",
    "snippet": "    public MultivariateVectorFunction getModelFunction() {\n        return model;\n    }",
    "comment": " Gets the model function to be optimized.  @return the model function. ",
    "is_bug": false,
    "failing_test_cases": 28,
    "buggy_methods": 7
  },
  {
    "name": "ModelFunctionJacobian.ModelFunctionJacobian",
    "class_name": "org.apache.commons.math3.optim.nonlinear.vector.ModelFunctionJacobian",
    "signature": "org.apache.commons.math3.optim.nonlinear.vector.ModelFunctionJacobian.ModelFunctionJacobian(MultivariateMatrixFunction)",
    "snippet": "    public ModelFunctionJacobian(MultivariateMatrixFunction j) {\n        jacobian = j;\n    }",
    "comment": " @param j Jacobian of the model function to be optimized. ",
    "is_bug": false,
    "failing_test_cases": 28,
    "buggy_methods": 7
  },
  {
    "name": "ModelFunctionJacobian.getModelFunctionJacobian",
    "class_name": "org.apache.commons.math3.optim.nonlinear.vector.ModelFunctionJacobian",
    "signature": "org.apache.commons.math3.optim.nonlinear.vector.ModelFunctionJacobian.getModelFunctionJacobian()",
    "snippet": "    public MultivariateMatrixFunction getModelFunctionJacobian() {\n        return jacobian;\n    }",
    "comment": " Gets the Jacobian of the model function to be optimized.  @return the model function Jacobian. ",
    "is_bug": false,
    "failing_test_cases": 28,
    "buggy_methods": 7
  },
  {
    "name": "MultivariateVectorOptimizer.MultivariateVectorOptimizer",
    "class_name": "org.apache.commons.math3.optim.nonlinear.vector.MultivariateVectorOptimizer",
    "signature": "org.apache.commons.math3.optim.nonlinear.vector.MultivariateVectorOptimizer.MultivariateVectorOptimizer(ConvergenceChecker)",
    "snippet": "    protected MultivariateVectorOptimizer(ConvergenceChecker<PointVectorValuePair> checker) {\n        super(checker);\n    }",
    "comment": " @param checker Convergence checker. ",
    "is_bug": false,
    "failing_test_cases": 28,
    "buggy_methods": 7
  },
  {
    "name": "MultivariateVectorOptimizer.checkParameters",
    "class_name": "org.apache.commons.math3.optim.nonlinear.vector.MultivariateVectorOptimizer",
    "signature": "org.apache.commons.math3.optim.nonlinear.vector.MultivariateVectorOptimizer.checkParameters()",
    "snippet": "    private void checkParameters() {\n        if (target.length != weightMatrix.getColumnDimension()) {\n            throw new DimensionMismatchException(target.length,\n                                                 weightMatrix.getColumnDimension());\n        }\n    }",
    "comment": " Check parameters consistency.  @throws DimensionMismatchException if {@link #target} and {@link #weightMatrix} have inconsistent dimensions. ",
    "is_bug": false,
    "failing_test_cases": 28,
    "buggy_methods": 7
  },
  {
    "name": "MultivariateVectorOptimizer.computeObjectiveValue",
    "class_name": "org.apache.commons.math3.optim.nonlinear.vector.MultivariateVectorOptimizer",
    "signature": "org.apache.commons.math3.optim.nonlinear.vector.MultivariateVectorOptimizer.computeObjectiveValue(double[])",
    "snippet": "    protected double[] computeObjectiveValue(double[] params) {\n        super.incrementEvaluationCount();\n        return model.value(params);\n    }",
    "comment": " Computes the objective function value. This method <em>must</em> be called by subclasses to enforce the evaluation counter limit.  @param params Point at which the objective function must be evaluated. @return the objective function value at the specified point. @throws TooManyEvaluationsException if the maximal number of evaluations (of the model vector function) is exceeded. ",
    "is_bug": false,
    "failing_test_cases": 28,
    "buggy_methods": 7
  },
  {
    "name": "MultivariateVectorOptimizer.getTarget",
    "class_name": "org.apache.commons.math3.optim.nonlinear.vector.MultivariateVectorOptimizer",
    "signature": "org.apache.commons.math3.optim.nonlinear.vector.MultivariateVectorOptimizer.getTarget()",
    "snippet": "    public double[] getTarget() {\n        return target.clone();\n    }",
    "comment": " Gets the observed values to be matched by the objective vector function.  @return the target values. ",
    "is_bug": false,
    "failing_test_cases": 28,
    "buggy_methods": 7
  },
  {
    "name": "MultivariateVectorOptimizer.getWeight",
    "class_name": "org.apache.commons.math3.optim.nonlinear.vector.MultivariateVectorOptimizer",
    "signature": "org.apache.commons.math3.optim.nonlinear.vector.MultivariateVectorOptimizer.getWeight()",
    "snippet": "    public RealMatrix getWeight() {\n        return weightMatrix.copy();\n    }",
    "comment": " Gets the weight matrix of the observations.  @return the weight matrix. ",
    "is_bug": false,
    "failing_test_cases": 28,
    "buggy_methods": 7
  },
  {
    "name": "MultivariateVectorOptimizer.optimize",
    "class_name": "org.apache.commons.math3.optim.nonlinear.vector.MultivariateVectorOptimizer",
    "signature": "org.apache.commons.math3.optim.nonlinear.vector.MultivariateVectorOptimizer.optimize(OptimizationData[])",
    "snippet": "    public PointVectorValuePair optimize(OptimizationData... optData)\n        throws TooManyEvaluationsException,\n               DimensionMismatchException {\n        // Set up base class and perform computation.\n        return super.optimize(optData);\n    }",
    "comment": " {@inheritDoc}  @param optData Optimization data. In addition to those documented in {@link BaseMultivariateOptimizer#parseOptimizationData(OptimizationData[]) BaseMultivariateOptimizer}, this method will register the following data: <ul> <li>{@link Target}</li> <li>{@link Weight}</li> <li>{@link ModelFunction}</li> </ul> @return {@inheritDoc} @throws TooManyEvaluationsException if the maximal number of evaluations is exceeded. @throws DimensionMismatchException if the initial guess, target, and weight arguments have inconsistent dimensions. ",
    "is_bug": false,
    "failing_test_cases": 28,
    "buggy_methods": 7
  },
  {
    "name": "MultivariateVectorOptimizer.parseOptimizationData",
    "class_name": "org.apache.commons.math3.optim.nonlinear.vector.MultivariateVectorOptimizer",
    "signature": "org.apache.commons.math3.optim.nonlinear.vector.MultivariateVectorOptimizer.parseOptimizationData(OptimizationData[])",
    "snippet": "    @Override\n    protected void parseOptimizationData(OptimizationData... optData) {\n        // Allow base class to register its own data.\n        super.parseOptimizationData(optData);\n\n        // The existing values (as set by the previous call) are reused if\n        // not provided in the argument list.\n        for (OptimizationData data : optData) {\n            if (data instanceof ModelFunction) {\n                model = ((ModelFunction) data).getModelFunction();\n                continue;\n            }\n            if (data instanceof Target) {\n                target = ((Target) data).getTarget();\n                continue;\n            }\n            if (data instanceof Weight) {\n                weightMatrix = ((Weight) data).getWeight();\n                continue;\n            }\n        }\n\n        // Check input consistency.\n        checkParameters();\n    }",
    "comment": " Scans the list of (required and optional) optimization data that characterize the problem.  @param optData Optimization data. The following data will be looked for: <ul> <li>{@link Target}</li> <li>{@link Weight}</li> <li>{@link ModelFunction}</li> </ul> ",
    "is_bug": false,
    "failing_test_cases": 28,
    "buggy_methods": 7
  },
  {
    "name": "Target.Target",
    "class_name": "org.apache.commons.math3.optim.nonlinear.vector.Target",
    "signature": "org.apache.commons.math3.optim.nonlinear.vector.Target.Target(double[])",
    "snippet": "    public Target(double[] observations) {\n        target = observations.clone();\n    }",
    "comment": " @param observations Target values. ",
    "is_bug": false,
    "failing_test_cases": 28,
    "buggy_methods": 7
  },
  {
    "name": "Target.getTarget",
    "class_name": "org.apache.commons.math3.optim.nonlinear.vector.Target",
    "signature": "org.apache.commons.math3.optim.nonlinear.vector.Target.getTarget()",
    "snippet": "    public double[] getTarget() {\n        return target.clone();\n    }",
    "comment": " Gets the initial guess.  @return the initial guess. ",
    "is_bug": false,
    "failing_test_cases": 28,
    "buggy_methods": 7
  },
  {
    "name": "Weight.Weight",
    "class_name": "org.apache.commons.math3.optim.nonlinear.vector.Weight",
    "signature": "org.apache.commons.math3.optim.nonlinear.vector.Weight.Weight(double[])",
    "snippet": "    public Weight(double[] weight) {\n        weightMatrix = new DiagonalMatrix(weight);\n    }",
    "comment": " Creates a diagonal weight matrix.  @param weight List of the values of the diagonal. ",
    "is_bug": false,
    "failing_test_cases": 28,
    "buggy_methods": 7
  },
  {
    "name": "Weight.getWeight",
    "class_name": "org.apache.commons.math3.optim.nonlinear.vector.Weight",
    "signature": "org.apache.commons.math3.optim.nonlinear.vector.Weight.getWeight()",
    "snippet": "    public RealMatrix getWeight() {\n        return weightMatrix.copy();\n    }",
    "comment": " Gets the initial guess.  @return the initial guess. ",
    "is_bug": false,
    "failing_test_cases": 28,
    "buggy_methods": 7
  },
  {
    "name": "AbstractLeastSquaresOptimizer.AbstractLeastSquaresOptimizer",
    "class_name": "org.apache.commons.math3.optim.nonlinear.vector.jacobian.AbstractLeastSquaresOptimizer",
    "signature": "org.apache.commons.math3.optim.nonlinear.vector.jacobian.AbstractLeastSquaresOptimizer.AbstractLeastSquaresOptimizer(ConvergenceChecker)",
    "snippet": "    protected AbstractLeastSquaresOptimizer(ConvergenceChecker<PointVectorValuePair> checker) {\n        super(checker);\n    }",
    "comment": " @param checker Convergence checker. ",
    "is_bug": false,
    "failing_test_cases": 28,
    "buggy_methods": 7
  },
  {
    "name": "AbstractLeastSquaresOptimizer.computeCost",
    "class_name": "org.apache.commons.math3.optim.nonlinear.vector.jacobian.AbstractLeastSquaresOptimizer",
    "signature": "org.apache.commons.math3.optim.nonlinear.vector.jacobian.AbstractLeastSquaresOptimizer.computeCost(double[])",
    "snippet": "    protected double computeCost(double[] residuals) {\n        final ArrayRealVector r = new ArrayRealVector(residuals);\n        return FastMath.sqrt(r.dotProduct(getWeight().operate(r)));\n    }",
    "comment": " Computes the cost.  @param residuals Residuals. @return the cost. @see #computeResiduals(double[]) ",
    "is_bug": false,
    "failing_test_cases": 28,
    "buggy_methods": 7
  },
  {
    "name": "AbstractLeastSquaresOptimizer.computeResiduals",
    "class_name": "org.apache.commons.math3.optim.nonlinear.vector.jacobian.AbstractLeastSquaresOptimizer",
    "signature": "org.apache.commons.math3.optim.nonlinear.vector.jacobian.AbstractLeastSquaresOptimizer.computeResiduals(double[])",
    "snippet": "    protected double[] computeResiduals(double[] objectiveValue) {\n        final double[] target = getTarget();\n        if (objectiveValue.length != target.length) {\n            throw new DimensionMismatchException(target.length,\n                                                 objectiveValue.length);\n        }\n\n        final double[] residuals = new double[target.length];\n        for (int i = 0; i < target.length; i++) {\n            residuals[i] = target[i] - objectiveValue[i];\n        }\n\n        return residuals;\n    }",
    "comment": " Computes the residuals. The residual is the difference between the observed (target) values and the model (objective function) value. There is one residual for each element of the vector-valued function.  @param objectiveValue Value of the the objective function. This is the value returned from a call to {@link #computeObjectiveValue(double[]) computeObjectiveValue} (whose array argument contains the model parameters). @return the residuals. @throws DimensionMismatchException if {@code params} has a wrong length. ",
    "is_bug": false,
    "failing_test_cases": 28,
    "buggy_methods": 7
  },
  {
    "name": "AbstractLeastSquaresOptimizer.computeWeightedJacobian",
    "class_name": "org.apache.commons.math3.optim.nonlinear.vector.jacobian.AbstractLeastSquaresOptimizer",
    "signature": "org.apache.commons.math3.optim.nonlinear.vector.jacobian.AbstractLeastSquaresOptimizer.computeWeightedJacobian(double[])",
    "snippet": "    protected RealMatrix computeWeightedJacobian(double[] params) {\n        return weightMatrixSqrt.multiply(MatrixUtils.createRealMatrix(computeJacobian(params)));\n    }",
    "comment": " Computes the weighted Jacobian matrix.  @param params Model parameters at which to compute the Jacobian. @return the weighted Jacobian: W<sup>1/2</sup> J. @throws DimensionMismatchException if the Jacobian dimension does not match problem dimension. ",
    "is_bug": false,
    "failing_test_cases": 28,
    "buggy_methods": 7
  },
  {
    "name": "AbstractLeastSquaresOptimizer.optimize",
    "class_name": "org.apache.commons.math3.optim.nonlinear.vector.jacobian.AbstractLeastSquaresOptimizer",
    "signature": "org.apache.commons.math3.optim.nonlinear.vector.jacobian.AbstractLeastSquaresOptimizer.optimize(OptimizationData[])",
    "snippet": "    @Override\n    public PointVectorValuePair optimize(OptimizationData... optData)\n        throws TooManyEvaluationsException {\n        // Set up base class and perform computation.\n        return super.optimize(optData);\n    }",
    "comment": " {@inheritDoc}  @param optData Optimization data. In addition to those documented in {@link JacobianMultivariateVectorOptimizer#parseOptimizationData(OptimizationData[]) JacobianMultivariateVectorOptimizer}, this method will register the following data: <ul> <li>{@link org.apache.commons.math3.optim.nonlinear.vector.Weight}</li> </ul> @return {@inheritDoc} @throws TooManyEvaluationsException if the maximal number of evaluations is exceeded. @throws DimensionMismatchException if the initial guess, target, and weight arguments have inconsistent dimensions. ",
    "is_bug": false,
    "failing_test_cases": 28,
    "buggy_methods": 7
  },
  {
    "name": "AbstractLeastSquaresOptimizer.parseOptimizationData",
    "class_name": "org.apache.commons.math3.optim.nonlinear.vector.jacobian.AbstractLeastSquaresOptimizer",
    "signature": "org.apache.commons.math3.optim.nonlinear.vector.jacobian.AbstractLeastSquaresOptimizer.parseOptimizationData(OptimizationData[])",
    "snippet": "    @Override\n    protected void parseOptimizationData(OptimizationData... optData) {\n        // Allow base class to register its own data.\n        super.parseOptimizationData(optData);\n\n        // The existing values (as set by the previous call) are reused if\n        // not provided in the argument list.\n        for (OptimizationData data : optData) {\n            if (data instanceof Weight) {\n                weightMatrixSqrt = squareRoot(((Weight) data).getWeight());\n                // If more data must be parsed, this statement _must_ be\n                // changed to \"continue\".\n                break;\n            }\n        }\n    }",
    "comment": " Scans the list of (required and optional) optimization data that characterize the problem. If the weight matrix is specified, the {@link #weightMatrixSqrt} field is recomputed.  @param optData Optimization data. The following data will be looked for: <ul> <li>{@link Weight}</li> </ul> ",
    "is_bug": false,
    "failing_test_cases": 28,
    "buggy_methods": 7
  },
  {
    "name": "AbstractLeastSquaresOptimizer.setCost",
    "class_name": "org.apache.commons.math3.optim.nonlinear.vector.jacobian.AbstractLeastSquaresOptimizer",
    "signature": "org.apache.commons.math3.optim.nonlinear.vector.jacobian.AbstractLeastSquaresOptimizer.setCost(double)",
    "snippet": "    protected void setCost(double cost) {\n        this.cost = cost;\n    }",
    "comment": " Sets the cost.  @param cost Cost value. ",
    "is_bug": false,
    "failing_test_cases": 28,
    "buggy_methods": 7
  },
  {
    "name": "AbstractLeastSquaresOptimizer.squareRoot",
    "class_name": "org.apache.commons.math3.optim.nonlinear.vector.jacobian.AbstractLeastSquaresOptimizer",
    "signature": "org.apache.commons.math3.optim.nonlinear.vector.jacobian.AbstractLeastSquaresOptimizer.squareRoot(RealMatrix)",
    "snippet": "    private RealMatrix squareRoot(RealMatrix m) {\n        if (m instanceof DiagonalMatrix) {\n            final int dim = m.getRowDimension();\n            final RealMatrix sqrtM = new DiagonalMatrix(dim);\n            for (int i = 0; i < dim; i++) {\n                sqrtM.setEntry(i, i, FastMath.sqrt(m.getEntry(i, i)));\n            }\n            return sqrtM;\n        } else {\n            final EigenDecomposition dec = new EigenDecomposition(m);\n            return dec.getSquareRoot();\n        }\n    }",
    "comment": " Computes the square-root of the weight matrix.  @param m Symmetric, positive-definite (weight) matrix. @return the square-root of the weight matrix. ",
    "is_bug": false,
    "failing_test_cases": 28,
    "buggy_methods": 7
  },
  {
    "name": "GaussNewtonOptimizer.GaussNewtonOptimizer",
    "class_name": "org.apache.commons.math3.optim.nonlinear.vector.jacobian.GaussNewtonOptimizer",
    "signature": "org.apache.commons.math3.optim.nonlinear.vector.jacobian.GaussNewtonOptimizer.GaussNewtonOptimizer(ConvergenceChecker)",
    "snippet": "    public GaussNewtonOptimizer(ConvergenceChecker<PointVectorValuePair> checker) {\n        this(true, checker);\n    }",
    "comment": " Simple constructor with default settings. The normal equations will be solved using LU decomposition.  @param checker Convergence checker. ",
    "is_bug": false,
    "failing_test_cases": 28,
    "buggy_methods": 7
  },
  {
    "name": "GaussNewtonOptimizer.GaussNewtonOptimizer",
    "class_name": "org.apache.commons.math3.optim.nonlinear.vector.jacobian.GaussNewtonOptimizer",
    "signature": "org.apache.commons.math3.optim.nonlinear.vector.jacobian.GaussNewtonOptimizer.GaussNewtonOptimizer(boolean,ConvergenceChecker)",
    "snippet": "    public GaussNewtonOptimizer(final boolean useLU,\n                                ConvergenceChecker<PointVectorValuePair> checker) {\n        super(checker);\n        this.useLU = useLU;\n    }",
    "comment": " @param useLU If {@code true}, the normal equations will be solved using LU decomposition, otherwise they will be solved using QR decomposition. @param checker Convergence checker. ",
    "is_bug": false,
    "failing_test_cases": 28,
    "buggy_methods": 7
  },
  {
    "name": "GaussNewtonOptimizer.checkParameters",
    "class_name": "org.apache.commons.math3.optim.nonlinear.vector.jacobian.GaussNewtonOptimizer",
    "signature": "org.apache.commons.math3.optim.nonlinear.vector.jacobian.GaussNewtonOptimizer.checkParameters()",
    "snippet": "    private void checkParameters() {\n        if (getLowerBound() != null ||\n            getUpperBound() != null) {\n            throw new MathUnsupportedOperationException(LocalizedFormats.CONSTRAINT);\n        }\n    }",
    "comment": " @throws MathUnsupportedOperationException if bounds were passed to the {@link #optimize(OptimizationData[]) optimize} method. ",
    "is_bug": false,
    "failing_test_cases": 28,
    "buggy_methods": 7
  },
  {
    "name": "GaussNewtonOptimizer.doOptimize",
    "class_name": "org.apache.commons.math3.optim.nonlinear.vector.jacobian.GaussNewtonOptimizer",
    "signature": "org.apache.commons.math3.optim.nonlinear.vector.jacobian.GaussNewtonOptimizer.doOptimize()",
    "snippet": "    @Override\n    public PointVectorValuePair doOptimize() {\n        checkParameters();\n\n        final ConvergenceChecker<PointVectorValuePair> checker\n            = getConvergenceChecker();\n\n        // Computation will be useless without a checker (see \"for-loop\").\n        if (checker == null) {\n            throw new NullArgumentException();\n        }\n\n        final double[] targetValues = getTarget();\n        final int nR = targetValues.length; // Number of observed data.\n\n        final RealMatrix weightMatrix = getWeight();\n        // Diagonal of the weight matrix.\n        final double[] residualsWeights = new double[nR];\n        for (int i = 0; i < nR; i++) {\n            residualsWeights[i] = weightMatrix.getEntry(i, i);\n        }\n\n        final double[] currentPoint = getStartPoint();\n        final int nC = currentPoint.length;\n\n        // iterate until convergence is reached\n        PointVectorValuePair current = null;\n        int iter = 0;\n        for (boolean converged = false; !converged;) {\n            ++iter;\n\n            // evaluate the objective function and its jacobian\n            PointVectorValuePair previous = current;\n            // Value of the objective function at \"currentPoint\".\n            final double[] currentObjective = computeObjectiveValue(currentPoint);\n            final double[] currentResiduals = computeResiduals(currentObjective);\n            final RealMatrix weightedJacobian = computeWeightedJacobian(currentPoint);\n            current = new PointVectorValuePair(currentPoint, currentObjective);\n\n            // build the linear problem\n            final double[]   b = new double[nC];\n            final double[][] a = new double[nC][nC];\n            for (int i = 0; i < nR; ++i) {\n\n                final double[] grad   = weightedJacobian.getRow(i);\n                final double weight   = residualsWeights[i];\n                final double residual = currentResiduals[i];\n\n                // compute the normal equation\n                final double wr = weight * residual;\n                for (int j = 0; j < nC; ++j) {\n                    b[j] += wr * grad[j];\n                }\n\n                // build the contribution matrix for measurement i\n                for (int k = 0; k < nC; ++k) {\n                    double[] ak = a[k];\n                    double wgk = weight * grad[k];\n                    for (int l = 0; l < nC; ++l) {\n                        ak[l] += wgk * grad[l];\n                    }\n                }\n            }\n\n            try {\n                // solve the linearized least squares problem\n                RealMatrix mA = new BlockRealMatrix(a);\n                DecompositionSolver solver = useLU ?\n                        new LUDecomposition(mA).getSolver() :\n                        new QRDecomposition(mA).getSolver();\n                final double[] dX = solver.solve(new ArrayRealVector(b, false)).toArray();\n                // update the estimated parameters\n                for (int i = 0; i < nC; ++i) {\n                    currentPoint[i] += dX[i];\n                }\n            } catch (SingularMatrixException e) {\n                throw new ConvergenceException(LocalizedFormats.UNABLE_TO_SOLVE_SINGULAR_PROBLEM);\n            }\n\n            // Check convergence.\n            if (previous != null) {\n                converged = checker.converged(iter, previous, current);\n                if (converged) {\n                    setCost(computeCost(currentResiduals));\n                    return current;\n                }\n            }\n        }\n        // Must never happen.\n        throw new MathInternalError();\n    }",
    "comment": "{@inheritDoc} */",
    "is_bug": true,
    "failing_test_cases": 28,
    "buggy_methods": 7
  },
  {
    "name": "LevenbergMarquardtOptimizer.LevenbergMarquardtOptimizer",
    "class_name": "org.apache.commons.math3.optim.nonlinear.vector.jacobian.LevenbergMarquardtOptimizer",
    "signature": "org.apache.commons.math3.optim.nonlinear.vector.jacobian.LevenbergMarquardtOptimizer.LevenbergMarquardtOptimizer()",
    "snippet": "    public LevenbergMarquardtOptimizer() {\n        this(100, 1e-10, 1e-10, 1e-10, Precision.SAFE_MIN);\n    }",
    "comment": " Build an optimizer for least squares problems with default values for all the tuning parameters (see the {@link #LevenbergMarquardtOptimizer(double,double,double,double,double) other contructor}. The default values for the algorithm settings are: <ul> <li>Initial step bound factor: 100</li> <li>Cost relative tolerance: 1e-10</li> <li>Parameters relative tolerance: 1e-10</li> <li>Orthogonality tolerance: 1e-10</li> <li>QR ranking threshold: {@link Precision#SAFE_MIN}</li> </ul> ",
    "is_bug": false,
    "failing_test_cases": 28,
    "buggy_methods": 7
  },
  {
    "name": "LevenbergMarquardtOptimizer.LevenbergMarquardtOptimizer",
    "class_name": "org.apache.commons.math3.optim.nonlinear.vector.jacobian.LevenbergMarquardtOptimizer",
    "signature": "org.apache.commons.math3.optim.nonlinear.vector.jacobian.LevenbergMarquardtOptimizer.LevenbergMarquardtOptimizer(double,double,double,double,double)",
    "snippet": "    public LevenbergMarquardtOptimizer(double initialStepBoundFactor,\n                                       double costRelativeTolerance,\n                                       double parRelativeTolerance,\n                                       double orthoTolerance,\n                                       double threshold) {\n        super(null); // No custom convergence criterion.\n        this.initialStepBoundFactor = initialStepBoundFactor;\n        this.costRelativeTolerance = costRelativeTolerance;\n        this.parRelativeTolerance = parRelativeTolerance;\n        this.orthoTolerance = orthoTolerance;\n        this.qrRankingThreshold = threshold;\n    }",
    "comment": " The arguments control the behaviour of the default convergence checking procedure. Additional criteria can defined through the setting of a {@link ConvergenceChecker}.  @param initialStepBoundFactor Positive input variable used in determining the initial step bound. This bound is set to the product of initialStepBoundFactor and the euclidean norm of {@code diag * x} if non-zero, or else to {@code initialStepBoundFactor} itself. In most cases factor should lie in the interval {@code (0.1, 100.0)}. {@code 100} is a generally recommended value. @param costRelativeTolerance Desired relative error in the sum of squares. @param parRelativeTolerance Desired relative error in the approximate solution parameters. @param orthoTolerance Desired max cosine on the orthogonality between the function vector and the columns of the Jacobian. @param threshold Desired threshold for QR ranking. If the squared norm of a column vector is smaller or equal to this threshold during QR decomposition, it is considered to be a zero vector and hence the rank of the matrix is reduced. ",
    "is_bug": false,
    "failing_test_cases": 28,
    "buggy_methods": 7
  },
  {
    "name": "LevenbergMarquardtOptimizer.checkParameters",
    "class_name": "org.apache.commons.math3.optim.nonlinear.vector.jacobian.LevenbergMarquardtOptimizer",
    "signature": "org.apache.commons.math3.optim.nonlinear.vector.jacobian.LevenbergMarquardtOptimizer.checkParameters()",
    "snippet": "    private void checkParameters() {\n        if (getLowerBound() != null ||\n            getUpperBound() != null) {\n            throw new MathUnsupportedOperationException(LocalizedFormats.CONSTRAINT);\n        }\n    }",
    "comment": " @throws MathUnsupportedOperationException if bounds were passed to the {@link #optimize(OptimizationData[]) optimize} method. ",
    "is_bug": false,
    "failing_test_cases": 28,
    "buggy_methods": 7
  },
  {
    "name": "LevenbergMarquardtOptimizer.determineLMDirection",
    "class_name": "org.apache.commons.math3.optim.nonlinear.vector.jacobian.LevenbergMarquardtOptimizer",
    "signature": "org.apache.commons.math3.optim.nonlinear.vector.jacobian.LevenbergMarquardtOptimizer.determineLMDirection(double[],double[],double[],double[])",
    "snippet": "    private void determineLMDirection(double[] qy, double[] diag,\n                                      double[] lmDiag, double[] work) {\n\n        // copy R and Qty to preserve input and initialize s\n        //  in particular, save the diagonal elements of R in lmDir\n        for (int j = 0; j < solvedCols; ++j) {\n            int pj = permutation[j];\n            for (int i = j + 1; i < solvedCols; ++i) {\n                weightedJacobian[i][pj] = weightedJacobian[j][permutation[i]];\n            }\n            lmDir[j] = diagR[pj];\n            work[j]  = qy[j];\n        }\n\n        // eliminate the diagonal matrix d using a Givens rotation\n        for (int j = 0; j < solvedCols; ++j) {\n\n            // prepare the row of d to be eliminated, locating the\n            // diagonal element using p from the Q.R. factorization\n            int pj = permutation[j];\n            double dpj = diag[pj];\n            if (dpj != 0) {\n                Arrays.fill(lmDiag, j + 1, lmDiag.length, 0);\n            }\n            lmDiag[j] = dpj;\n\n            //  the transformations to eliminate the row of d\n            // modify only a single element of Qty\n            // beyond the first n, which is initially zero.\n            double qtbpj = 0;\n            for (int k = j; k < solvedCols; ++k) {\n                int pk = permutation[k];\n\n                // determine a Givens rotation which eliminates the\n                // appropriate element in the current row of d\n                if (lmDiag[k] != 0) {\n\n                    final double sin;\n                    final double cos;\n                    double rkk = weightedJacobian[k][pk];\n                    if (FastMath.abs(rkk) < FastMath.abs(lmDiag[k])) {\n                        final double cotan = rkk / lmDiag[k];\n                        sin   = 1.0 / FastMath.sqrt(1.0 + cotan * cotan);\n                        cos   = sin * cotan;\n                    } else {\n                        final double tan = lmDiag[k] / rkk;\n                        cos = 1.0 / FastMath.sqrt(1.0 + tan * tan);\n                        sin = cos * tan;\n                    }\n\n                    // compute the modified diagonal element of R and\n                    // the modified element of (Qty,0)\n                    weightedJacobian[k][pk] = cos * rkk + sin * lmDiag[k];\n                    final double temp = cos * work[k] + sin * qtbpj;\n                    qtbpj = -sin * work[k] + cos * qtbpj;\n                    work[k] = temp;\n\n                    // accumulate the tranformation in the row of s\n                    for (int i = k + 1; i < solvedCols; ++i) {\n                        double rik = weightedJacobian[i][pk];\n                        final double temp2 = cos * rik + sin * lmDiag[i];\n                        lmDiag[i] = -sin * rik + cos * lmDiag[i];\n                        weightedJacobian[i][pk] = temp2;\n                    }\n                }\n            }\n\n            // store the diagonal element of s and restore\n            // the corresponding diagonal element of R\n            lmDiag[j] = weightedJacobian[j][permutation[j]];\n            weightedJacobian[j][permutation[j]] = lmDir[j];\n        }\n\n        // solve the triangular system for z, if the system is\n        // singular, then obtain a least squares solution\n        int nSing = solvedCols;\n        for (int j = 0; j < solvedCols; ++j) {\n            if ((lmDiag[j] == 0) && (nSing == solvedCols)) {\n                nSing = j;\n            }\n            if (nSing < solvedCols) {\n                work[j] = 0;\n            }\n        }\n        if (nSing > 0) {\n            for (int j = nSing - 1; j >= 0; --j) {\n                int pj = permutation[j];\n                double sum = 0;\n                for (int i = j + 1; i < nSing; ++i) {\n                    sum += weightedJacobian[i][pj] * work[i];\n                }\n                work[j] = (work[j] - sum) / lmDiag[j];\n            }\n        }\n\n        // permute the components of z back to components of lmDir\n        for (int j = 0; j < lmDir.length; ++j) {\n            lmDir[permutation[j]] = work[j];\n        }\n    }",
    "comment": " Solve a*x = b and d*x = 0 in the least squares sense. <p>This implementation is a translation in Java of the MINPACK <a href=\"http://www.netlib.org/minpack/qrsolv.f\">qrsolv</a> routine.</p> <p>This method sets the lmDir and lmDiag attributes.</p> <p>The authors of the original fortran function are:</p> <ul> <li>Argonne National Laboratory. MINPACK project. March 1980</li> <li>Burton  S. Garbow</li> <li>Kenneth E. Hillstrom</li> <li>Jorge   J. More</li> </ul> <p>Luc Maisonobe did the Java translation.</p>  @param qy array containing qTy @param diag diagonal matrix @param lmDiag diagonal elements associated with lmDir @param work work array ",
    "is_bug": false,
    "failing_test_cases": 28,
    "buggy_methods": 7
  },
  {
    "name": "LevenbergMarquardtOptimizer.determineLMParameter",
    "class_name": "org.apache.commons.math3.optim.nonlinear.vector.jacobian.LevenbergMarquardtOptimizer",
    "signature": "org.apache.commons.math3.optim.nonlinear.vector.jacobian.LevenbergMarquardtOptimizer.determineLMParameter(double[],double,double[],double[],double[],double[])",
    "snippet": "    private void determineLMParameter(double[] qy, double delta, double[] diag,\n                                      double[] work1, double[] work2, double[] work3) {\n        final int nC = weightedJacobian[0].length;\n\n        // compute and store in x the gauss-newton direction, if the\n        // jacobian is rank-deficient, obtain a least squares solution\n        for (int j = 0; j < rank; ++j) {\n            lmDir[permutation[j]] = qy[j];\n        }\n        for (int j = rank; j < nC; ++j) {\n            lmDir[permutation[j]] = 0;\n        }\n        for (int k = rank - 1; k >= 0; --k) {\n            int pk = permutation[k];\n            double ypk = lmDir[pk] / diagR[pk];\n            for (int i = 0; i < k; ++i) {\n                lmDir[permutation[i]] -= ypk * weightedJacobian[i][pk];\n            }\n            lmDir[pk] = ypk;\n        }\n\n        // evaluate the function at the origin, and test\n        // for acceptance of the Gauss-Newton direction\n        double dxNorm = 0;\n        for (int j = 0; j < solvedCols; ++j) {\n            int pj = permutation[j];\n            double s = diag[pj] * lmDir[pj];\n            work1[pj] = s;\n            dxNorm += s * s;\n        }\n        dxNorm = FastMath.sqrt(dxNorm);\n        double fp = dxNorm - delta;\n        if (fp <= 0.1 * delta) {\n            lmPar = 0;\n            return;\n        }\n\n        // if the jacobian is not rank deficient, the Newton step provides\n        // a lower bound, parl, for the zero of the function,\n        // otherwise set this bound to zero\n        double sum2;\n        double parl = 0;\n        if (rank == solvedCols) {\n            for (int j = 0; j < solvedCols; ++j) {\n                int pj = permutation[j];\n                work1[pj] *= diag[pj] / dxNorm;\n            }\n            sum2 = 0;\n            for (int j = 0; j < solvedCols; ++j) {\n                int pj = permutation[j];\n                double sum = 0;\n                for (int i = 0; i < j; ++i) {\n                    sum += weightedJacobian[i][pj] * work1[permutation[i]];\n                }\n                double s = (work1[pj] - sum) / diagR[pj];\n                work1[pj] = s;\n                sum2 += s * s;\n            }\n            parl = fp / (delta * sum2);\n        }\n\n        // calculate an upper bound, paru, for the zero of the function\n        sum2 = 0;\n        for (int j = 0; j < solvedCols; ++j) {\n            int pj = permutation[j];\n            double sum = 0;\n            for (int i = 0; i <= j; ++i) {\n                sum += weightedJacobian[i][pj] * qy[i];\n            }\n            sum /= diag[pj];\n            sum2 += sum * sum;\n        }\n        double gNorm = FastMath.sqrt(sum2);\n        double paru = gNorm / delta;\n        if (paru == 0) {\n            // 2.2251e-308 is the smallest positive real for IEE754\n            paru = 2.2251e-308 / FastMath.min(delta, 0.1);\n        }\n\n        // if the input par lies outside of the interval (parl,paru),\n        // set par to the closer endpoint\n        lmPar = FastMath.min(paru, FastMath.max(lmPar, parl));\n        if (lmPar == 0) {\n            lmPar = gNorm / dxNorm;\n        }\n\n        for (int countdown = 10; countdown >= 0; --countdown) {\n\n            // evaluate the function at the current value of lmPar\n            if (lmPar == 0) {\n                lmPar = FastMath.max(2.2251e-308, 0.001 * paru);\n            }\n            double sPar = FastMath.sqrt(lmPar);\n            for (int j = 0; j < solvedCols; ++j) {\n                int pj = permutation[j];\n                work1[pj] = sPar * diag[pj];\n            }\n            determineLMDirection(qy, work1, work2, work3);\n\n            dxNorm = 0;\n            for (int j = 0; j < solvedCols; ++j) {\n                int pj = permutation[j];\n                double s = diag[pj] * lmDir[pj];\n                work3[pj] = s;\n                dxNorm += s * s;\n            }\n            dxNorm = FastMath.sqrt(dxNorm);\n            double previousFP = fp;\n            fp = dxNorm - delta;\n\n            // if the function is small enough, accept the current value\n            // of lmPar, also test for the exceptional cases where parl is zero\n            if ((FastMath.abs(fp) <= 0.1 * delta) ||\n                    ((parl == 0) && (fp <= previousFP) && (previousFP < 0))) {\n                return;\n            }\n\n            // compute the Newton correction\n            for (int j = 0; j < solvedCols; ++j) {\n                int pj = permutation[j];\n                work1[pj] = work3[pj] * diag[pj] / dxNorm;\n            }\n            for (int j = 0; j < solvedCols; ++j) {\n                int pj = permutation[j];\n                work1[pj] /= work2[j];\n                double tmp = work1[pj];\n                for (int i = j + 1; i < solvedCols; ++i) {\n                    work1[permutation[i]] -= weightedJacobian[i][pj] * tmp;\n                }\n            }\n            sum2 = 0;\n            for (int j = 0; j < solvedCols; ++j) {\n                double s = work1[permutation[j]];\n                sum2 += s * s;\n            }\n            double correction = fp / (delta * sum2);\n\n            // depending on the sign of the function, update parl or paru.\n            if (fp > 0) {\n                parl = FastMath.max(parl, lmPar);\n            } else if (fp < 0) {\n                paru = FastMath.min(paru, lmPar);\n            }\n\n            // compute an improved estimate for lmPar\n            lmPar = FastMath.max(parl, lmPar + correction);\n\n        }\n    }",
    "comment": " Determine the Levenberg-Marquardt parameter. <p>This implementation is a translation in Java of the MINPACK <a href=\"http://www.netlib.org/minpack/lmpar.f\">lmpar</a> routine.</p> <p>This method sets the lmPar and lmDir attributes.</p> <p>The authors of the original fortran function are:</p> <ul> <li>Argonne National Laboratory. MINPACK project. March 1980</li> <li>Burton  S. Garbow</li> <li>Kenneth E. Hillstrom</li> <li>Jorge   J. More</li> </ul> <p>Luc Maisonobe did the Java translation.</p>  @param qy array containing qTy @param delta upper bound on the euclidean norm of diagR * lmDir @param diag diagonal matrix @param work1 work array @param work2 work array @param work3 work array ",
    "is_bug": false,
    "failing_test_cases": 28,
    "buggy_methods": 7
  },
  {
    "name": "LevenbergMarquardtOptimizer.doOptimize",
    "class_name": "org.apache.commons.math3.optim.nonlinear.vector.jacobian.LevenbergMarquardtOptimizer",
    "signature": "org.apache.commons.math3.optim.nonlinear.vector.jacobian.LevenbergMarquardtOptimizer.doOptimize()",
    "snippet": "    @Override\n    protected PointVectorValuePair doOptimize() {\n        checkParameters();\n\n        final int nR = getTarget().length; // Number of observed data.\n        final double[] currentPoint = getStartPoint();\n        final int nC = currentPoint.length; // Number of parameters.\n\n        // arrays shared with the other private methods\n        solvedCols  = FastMath.min(nR, nC);\n        diagR       = new double[nC];\n        jacNorm     = new double[nC];\n        beta        = new double[nC];\n        permutation = new int[nC];\n        lmDir       = new double[nC];\n\n        // local point\n        double   delta   = 0;\n        double   xNorm   = 0;\n        double[] diag    = new double[nC];\n        double[] oldX    = new double[nC];\n        double[] oldRes  = new double[nR];\n        double[] oldObj  = new double[nR];\n        double[] qtf     = new double[nR];\n        double[] work1   = new double[nC];\n        double[] work2   = new double[nC];\n        double[] work3   = new double[nC];\n\n        final RealMatrix weightMatrixSqrt = getWeightSquareRoot();\n\n        // Evaluate the function at the starting point and calculate its norm.\n        double[] currentObjective = computeObjectiveValue(currentPoint);\n        double[] currentResiduals = computeResiduals(currentObjective);\n        PointVectorValuePair current = new PointVectorValuePair(currentPoint, currentObjective);\n        double currentCost = computeCost(currentResiduals);\n\n        // Outer loop.\n        lmPar = 0;\n        boolean firstIteration = true;\n        int iter = 0;\n        final ConvergenceChecker<PointVectorValuePair> checker = getConvergenceChecker();\n        while (true) {\n            ++iter;\n            final PointVectorValuePair previous = current;\n\n            // QR decomposition of the jacobian matrix\n            qrDecomposition(computeWeightedJacobian(currentPoint));\n\n            weightedResidual = weightMatrixSqrt.operate(currentResiduals);\n            for (int i = 0; i < nR; i++) {\n                qtf[i] = weightedResidual[i];\n            }\n\n            // compute Qt.res\n            qTy(qtf);\n\n            // now we don't need Q anymore,\n            // so let jacobian contain the R matrix with its diagonal elements\n            for (int k = 0; k < solvedCols; ++k) {\n                int pk = permutation[k];\n                weightedJacobian[k][pk] = diagR[pk];\n            }\n\n            if (firstIteration) {\n                // scale the point according to the norms of the columns\n                // of the initial jacobian\n                xNorm = 0;\n                for (int k = 0; k < nC; ++k) {\n                    double dk = jacNorm[k];\n                    if (dk == 0) {\n                        dk = 1.0;\n                    }\n                    double xk = dk * currentPoint[k];\n                    xNorm  += xk * xk;\n                    diag[k] = dk;\n                }\n                xNorm = FastMath.sqrt(xNorm);\n\n                // initialize the step bound delta\n                delta = (xNorm == 0) ? initialStepBoundFactor : (initialStepBoundFactor * xNorm);\n            }\n\n            // check orthogonality between function vector and jacobian columns\n            double maxCosine = 0;\n            if (currentCost != 0) {\n                for (int j = 0; j < solvedCols; ++j) {\n                    int    pj = permutation[j];\n                    double s  = jacNorm[pj];\n                    if (s != 0) {\n                        double sum = 0;\n                        for (int i = 0; i <= j; ++i) {\n                            sum += weightedJacobian[i][pj] * qtf[i];\n                        }\n                        maxCosine = FastMath.max(maxCosine, FastMath.abs(sum) / (s * currentCost));\n                    }\n                }\n            }\n            if (maxCosine <= orthoTolerance) {\n                // Convergence has been reached.\n                setCost(currentCost);\n                return current;\n            }\n\n            // rescale if necessary\n            for (int j = 0; j < nC; ++j) {\n                diag[j] = FastMath.max(diag[j], jacNorm[j]);\n            }\n\n            // Inner loop.\n            for (double ratio = 0; ratio < 1.0e-4;) {\n\n                // save the state\n                for (int j = 0; j < solvedCols; ++j) {\n                    int pj = permutation[j];\n                    oldX[pj] = currentPoint[pj];\n                }\n                final double previousCost = currentCost;\n                double[] tmpVec = weightedResidual;\n                weightedResidual = oldRes;\n                oldRes    = tmpVec;\n                tmpVec    = currentObjective;\n                currentObjective = oldObj;\n                oldObj    = tmpVec;\n\n                // determine the Levenberg-Marquardt parameter\n                determineLMParameter(qtf, delta, diag, work1, work2, work3);\n\n                // compute the new point and the norm of the evolution direction\n                double lmNorm = 0;\n                for (int j = 0; j < solvedCols; ++j) {\n                    int pj = permutation[j];\n                    lmDir[pj] = -lmDir[pj];\n                    currentPoint[pj] = oldX[pj] + lmDir[pj];\n                    double s = diag[pj] * lmDir[pj];\n                    lmNorm  += s * s;\n                }\n                lmNorm = FastMath.sqrt(lmNorm);\n                // on the first iteration, adjust the initial step bound.\n                if (firstIteration) {\n                    delta = FastMath.min(delta, lmNorm);\n                }\n\n                // Evaluate the function at x + p and calculate its norm.\n                currentObjective = computeObjectiveValue(currentPoint);\n                currentResiduals = computeResiduals(currentObjective);\n                current = new PointVectorValuePair(currentPoint, currentObjective);\n                currentCost = computeCost(currentResiduals);\n\n                // compute the scaled actual reduction\n                double actRed = -1.0;\n                if (0.1 * currentCost < previousCost) {\n                    double r = currentCost / previousCost;\n                    actRed = 1.0 - r * r;\n                }\n\n                // compute the scaled predicted reduction\n                // and the scaled directional derivative\n                for (int j = 0; j < solvedCols; ++j) {\n                    int pj = permutation[j];\n                    double dirJ = lmDir[pj];\n                    work1[j] = 0;\n                    for (int i = 0; i <= j; ++i) {\n                        work1[i] += weightedJacobian[i][pj] * dirJ;\n                    }\n                }\n                double coeff1 = 0;\n                for (int j = 0; j < solvedCols; ++j) {\n                    coeff1 += work1[j] * work1[j];\n                }\n                double pc2 = previousCost * previousCost;\n                coeff1 = coeff1 / pc2;\n                double coeff2 = lmPar * lmNorm * lmNorm / pc2;\n                double preRed = coeff1 + 2 * coeff2;\n                double dirDer = -(coeff1 + coeff2);\n\n                // ratio of the actual to the predicted reduction\n                ratio = (preRed == 0) ? 0 : (actRed / preRed);\n\n                // update the step bound\n                if (ratio <= 0.25) {\n                    double tmp =\n                        (actRed < 0) ? (0.5 * dirDer / (dirDer + 0.5 * actRed)) : 0.5;\n                        if ((0.1 * currentCost >= previousCost) || (tmp < 0.1)) {\n                            tmp = 0.1;\n                        }\n                        delta = tmp * FastMath.min(delta, 10.0 * lmNorm);\n                        lmPar /= tmp;\n                } else if ((lmPar == 0) || (ratio >= 0.75)) {\n                    delta = 2 * lmNorm;\n                    lmPar *= 0.5;\n                }\n\n                // test for successful iteration.\n                if (ratio >= 1.0e-4) {\n                    // successful iteration, update the norm\n                    firstIteration = false;\n                    xNorm = 0;\n                    for (int k = 0; k < nC; ++k) {\n                        double xK = diag[k] * currentPoint[k];\n                        xNorm += xK * xK;\n                    }\n                    xNorm = FastMath.sqrt(xNorm);\n\n                    // tests for convergence.\n                    if (checker != null) {\n                        // we use the vectorial convergence checker\n                        if (checker.converged(iter, previous, current)) {\n                            setCost(currentCost);\n                            return current;\n                        }\n                    }\n                } else {\n                    // failed iteration, reset the previous values\n                    currentCost = previousCost;\n                    for (int j = 0; j < solvedCols; ++j) {\n                        int pj = permutation[j];\n                        currentPoint[pj] = oldX[pj];\n                    }\n                    tmpVec    = weightedResidual;\n                    weightedResidual = oldRes;\n                    oldRes    = tmpVec;\n                    tmpVec    = currentObjective;\n                    currentObjective = oldObj;\n                    oldObj    = tmpVec;\n                    // Reset \"current\" to previous values.\n                    current = new PointVectorValuePair(currentPoint, currentObjective);\n                }\n\n                // Default convergence criteria.\n                if ((FastMath.abs(actRed) <= costRelativeTolerance &&\n                     preRed <= costRelativeTolerance &&\n                     ratio <= 2.0) ||\n                    delta <= parRelativeTolerance * xNorm) {\n                    setCost(currentCost);\n                    return current;\n                }\n\n                // tests for termination and stringent tolerances\n                // (2.2204e-16 is the machine epsilon for IEEE754)\n                if ((FastMath.abs(actRed) <= 2.2204e-16) && (preRed <= 2.2204e-16) && (ratio <= 2.0)) {\n                    throw new ConvergenceException(LocalizedFormats.TOO_SMALL_COST_RELATIVE_TOLERANCE,\n                                                   costRelativeTolerance);\n                } else if (delta <= 2.2204e-16 * xNorm) {\n                    throw new ConvergenceException(LocalizedFormats.TOO_SMALL_PARAMETERS_RELATIVE_TOLERANCE,\n                                                   parRelativeTolerance);\n                } else if (maxCosine <= 2.2204e-16)  {\n                    throw new ConvergenceException(LocalizedFormats.TOO_SMALL_ORTHOGONALITY_TOLERANCE,\n                                                   orthoTolerance);\n                }\n            }\n        }\n    }",
    "comment": "{@inheritDoc} */",
    "is_bug": true,
    "failing_test_cases": 28,
    "buggy_methods": 7
  },
  {
    "name": "LevenbergMarquardtOptimizer.qTy",
    "class_name": "org.apache.commons.math3.optim.nonlinear.vector.jacobian.LevenbergMarquardtOptimizer",
    "signature": "org.apache.commons.math3.optim.nonlinear.vector.jacobian.LevenbergMarquardtOptimizer.qTy(double[])",
    "snippet": "    private void qTy(double[] y) {\n        final int nR = weightedJacobian.length;\n        final int nC = weightedJacobian[0].length;\n\n        for (int k = 0; k < nC; ++k) {\n            int pk = permutation[k];\n            double gamma = 0;\n            for (int i = k; i < nR; ++i) {\n                gamma += weightedJacobian[i][pk] * y[i];\n            }\n            gamma *= beta[pk];\n            for (int i = k; i < nR; ++i) {\n                y[i] -= gamma * weightedJacobian[i][pk];\n            }\n        }\n    }",
    "comment": " Compute the product Qt.y for some Q.R. decomposition.  @param y vector to multiply (will be overwritten with the result) ",
    "is_bug": false,
    "failing_test_cases": 28,
    "buggy_methods": 7
  },
  {
    "name": "LevenbergMarquardtOptimizer.qrDecomposition",
    "class_name": "org.apache.commons.math3.optim.nonlinear.vector.jacobian.LevenbergMarquardtOptimizer",
    "signature": "org.apache.commons.math3.optim.nonlinear.vector.jacobian.LevenbergMarquardtOptimizer.qrDecomposition(RealMatrix)",
    "snippet": "    private void qrDecomposition(RealMatrix jacobian) throws ConvergenceException {\n        // Code in this class assumes that the weighted Jacobian is -(W^(1/2) J),\n        // hence the multiplication by -1.\n        weightedJacobian = jacobian.scalarMultiply(-1).getData();\n\n        final int nR = weightedJacobian.length;\n        final int nC = weightedJacobian[0].length;\n\n        // initializations\n        for (int k = 0; k < nC; ++k) {\n            permutation[k] = k;\n            double norm2 = 0;\n            for (int i = 0; i < nR; ++i) {\n                double akk = weightedJacobian[i][k];\n                norm2 += akk * akk;\n            }\n            jacNorm[k] = FastMath.sqrt(norm2);\n        }\n\n        // transform the matrix column after column\n        for (int k = 0; k < nC; ++k) {\n\n            // select the column with the greatest norm on active components\n            int nextColumn = -1;\n            double ak2 = Double.NEGATIVE_INFINITY;\n            for (int i = k; i < nC; ++i) {\n                double norm2 = 0;\n                for (int j = k; j < nR; ++j) {\n                    double aki = weightedJacobian[j][permutation[i]];\n                    norm2 += aki * aki;\n                }\n                if (Double.isInfinite(norm2) || Double.isNaN(norm2)) {\n                    throw new ConvergenceException(LocalizedFormats.UNABLE_TO_PERFORM_QR_DECOMPOSITION_ON_JACOBIAN,\n                                                   nR, nC);\n                }\n                if (norm2 > ak2) {\n                    nextColumn = i;\n                    ak2        = norm2;\n                }\n            }\n            if (ak2 <= qrRankingThreshold) {\n                rank = k;\n                return;\n            }\n            int pk                  = permutation[nextColumn];\n            permutation[nextColumn] = permutation[k];\n            permutation[k]          = pk;\n\n            // choose alpha such that Hk.u = alpha ek\n            double akk   = weightedJacobian[k][pk];\n            double alpha = (akk > 0) ? -FastMath.sqrt(ak2) : FastMath.sqrt(ak2);\n            double betak = 1.0 / (ak2 - akk * alpha);\n            beta[pk]     = betak;\n\n            // transform the current column\n            diagR[pk]        = alpha;\n            weightedJacobian[k][pk] -= alpha;\n\n            // transform the remaining columns\n            for (int dk = nC - 1 - k; dk > 0; --dk) {\n                double gamma = 0;\n                for (int j = k; j < nR; ++j) {\n                    gamma += weightedJacobian[j][pk] * weightedJacobian[j][permutation[k + dk]];\n                }\n                gamma *= betak;\n                for (int j = k; j < nR; ++j) {\n                    weightedJacobian[j][permutation[k + dk]] -= gamma * weightedJacobian[j][pk];\n                }\n            }\n        }\n        rank = solvedCols;\n    }",
    "comment": " Decompose a matrix A as A.P = Q.R using Householder transforms. <p>As suggested in the P. Lascaux and R. Theodor book <i>Analyse num&eacute;rique matricielle appliqu&eacute;e &agrave; l'art de l'ing&eacute;nieur</i> (Masson, 1986), instead of representing the Householder transforms with u<sub>k</sub> unit vectors such that: <pre> H<sub>k</sub> = I - 2u<sub>k</sub>.u<sub>k</sub><sup>t</sup> </pre> we use <sub>k</sub> non-unit vectors such that: <pre> H<sub>k</sub> = I - beta<sub>k</sub>v<sub>k</sub>.v<sub>k</sub><sup>t</sup> </pre> where v<sub>k</sub> = a<sub>k</sub> - alpha<sub>k</sub> e<sub>k</sub>. The beta<sub>k</sub> coefficients are provided upon exit as recomputing them from the v<sub>k</sub> vectors would be costly.</p> <p>This decomposition handles rank deficient cases since the tranformations are performed in non-increasing columns norms order thanks to columns pivoting. The diagonal elements of the R matrix are therefore also in non-increasing absolute values order.</p>  @param jacobian Weighted Jacobian matrix at the current point. @exception ConvergenceException if the decomposition cannot be performed ",
    "is_bug": false,
    "failing_test_cases": 28,
    "buggy_methods": 7
  },
  {
    "name": "BracketFinder.BracketFinder",
    "class_name": "org.apache.commons.math3.optim.univariate.BracketFinder",
    "signature": "org.apache.commons.math3.optim.univariate.BracketFinder.BracketFinder()",
    "snippet": "    public BracketFinder() {\n        this(100, 50);\n    }",
    "comment": " Constructor with default values {@code 100, 50} (see the {@link #BracketFinder(double,int) other constructor}). ",
    "is_bug": false,
    "failing_test_cases": 28,
    "buggy_methods": 7
  },
  {
    "name": "BracketFinder.BracketFinder",
    "class_name": "org.apache.commons.math3.optim.univariate.BracketFinder",
    "signature": "org.apache.commons.math3.optim.univariate.BracketFinder.BracketFinder(double,int)",
    "snippet": "    public BracketFinder(double growLimit,\n                         int maxEvaluations) {\n        if (growLimit <= 0) {\n            throw new NotStrictlyPositiveException(growLimit);\n        }\n        if (maxEvaluations <= 0) {\n            throw new NotStrictlyPositiveException(maxEvaluations);\n        }\n\n        this.growLimit = growLimit;\n        evaluations.setMaximalCount(maxEvaluations);\n    }",
    "comment": " Create a bracketing interval finder.  @param growLimit Expanding factor. @param maxEvaluations Maximum number of evaluations allowed for finding a bracketing interval. ",
    "is_bug": false,
    "failing_test_cases": 28,
    "buggy_methods": 7
  },
  {
    "name": "BracketFinder.eval",
    "class_name": "org.apache.commons.math3.optim.univariate.BracketFinder",
    "signature": "org.apache.commons.math3.optim.univariate.BracketFinder.eval(UnivariateFunction,double)",
    "snippet": "    private double eval(UnivariateFunction f, double x) {\n        try {\n            evaluations.incrementCount();\n        } catch (MaxCountExceededException e) {\n            throw new TooManyEvaluationsException(e.getMax());\n        }\n        return f.value(x);\n    }",
    "comment": " @param f Function. @param x Argument. @return {@code f(x)} @throws TooManyEvaluationsException if the maximal number of evaluations is exceeded. ",
    "is_bug": false,
    "failing_test_cases": 28,
    "buggy_methods": 7
  },
  {
    "name": "BracketFinder.getHi",
    "class_name": "org.apache.commons.math3.optim.univariate.BracketFinder",
    "signature": "org.apache.commons.math3.optim.univariate.BracketFinder.getHi()",
    "snippet": "    public double getHi() {\n        return hi;\n    }",
    "comment": " @return the higher bound of the bracket. @see #getFHi() ",
    "is_bug": false,
    "failing_test_cases": 28,
    "buggy_methods": 7
  },
  {
    "name": "BracketFinder.getLo",
    "class_name": "org.apache.commons.math3.optim.univariate.BracketFinder",
    "signature": "org.apache.commons.math3.optim.univariate.BracketFinder.getLo()",
    "snippet": "    public double getLo() {\n        return lo;\n    }",
    "comment": " @return the lower bound of the bracket. @see #getFLo() ",
    "is_bug": false,
    "failing_test_cases": 28,
    "buggy_methods": 7
  },
  {
    "name": "BracketFinder.getMid",
    "class_name": "org.apache.commons.math3.optim.univariate.BracketFinder",
    "signature": "org.apache.commons.math3.optim.univariate.BracketFinder.getMid()",
    "snippet": "    public double getMid() {\n        return mid;\n    }",
    "comment": " @return a point in the middle of the bracket. @see #getFMid() ",
    "is_bug": false,
    "failing_test_cases": 28,
    "buggy_methods": 7
  },
  {
    "name": "BracketFinder.search",
    "class_name": "org.apache.commons.math3.optim.univariate.BracketFinder",
    "signature": "org.apache.commons.math3.optim.univariate.BracketFinder.search(UnivariateFunction,GoalType,double,double)",
    "snippet": "    public void search(UnivariateFunction func, GoalType goal, double xA, double xB) {\n        evaluations.resetCount();\n        final boolean isMinim = goal == GoalType.MINIMIZE;\n\n        double fA = eval(func, xA);\n        double fB = eval(func, xB);\n        if (isMinim ?\n            fA < fB :\n            fA > fB) {\n\n            double tmp = xA;\n            xA = xB;\n            xB = tmp;\n\n            tmp = fA;\n            fA = fB;\n            fB = tmp;\n        }\n\n        double xC = xB + GOLD * (xB - xA);\n        double fC = eval(func, xC);\n\n        while (isMinim ? fC < fB : fC > fB) {\n            double tmp1 = (xB - xA) * (fB - fC);\n            double tmp2 = (xB - xC) * (fB - fA);\n\n            double val = tmp2 - tmp1;\n            double denom = Math.abs(val) < EPS_MIN ? 2 * EPS_MIN : 2 * val;\n\n            double w = xB - ((xB - xC) * tmp2 - (xB - xA) * tmp1) / denom;\n            double wLim = xB + growLimit * (xC - xB);\n\n            double fW;\n            if ((w - xC) * (xB - w) > 0) {\n                fW = eval(func, w);\n                if (isMinim ?\n                    fW < fC :\n                    fW > fC) {\n                    xA = xB;\n                    xB = w;\n                    fA = fB;\n                    fB = fW;\n                    break;\n                } else if (isMinim ?\n                           fW > fB :\n                           fW < fB) {\n                    xC = w;\n                    fC = fW;\n                    break;\n                }\n                w = xC + GOLD * (xC - xB);\n                fW = eval(func, w);\n            } else if ((w - wLim) * (wLim - xC) >= 0) {\n                w = wLim;\n                fW = eval(func, w);\n            } else if ((w - wLim) * (xC - w) > 0) {\n                fW = eval(func, w);\n                if (isMinim ?\n                    fW < fC :\n                    fW > fC) {\n                    xB = xC;\n                    xC = w;\n                    w = xC + GOLD * (xC - xB);\n                    fB = fC;\n                    fC =fW;\n                    fW = eval(func, w);\n                }\n            } else {\n                w = xC + GOLD * (xC - xB);\n                fW = eval(func, w);\n            }\n\n            xA = xB;\n            fA = fB;\n            xB = xC;\n            fB = fC;\n            xC = w;\n            fC = fW;\n        }\n\n        lo = xA;\n        fLo = fA;\n        mid = xB;\n        fMid = fB;\n        hi = xC;\n        fHi = fC;\n\n        if (lo > hi) {\n            double tmp = lo;\n            lo = hi;\n            hi = tmp;\n\n            tmp = fLo;\n            fLo = fHi;\n            fHi = tmp;\n        }\n    }",
    "comment": " Search new points that bracket a local optimum of the function.  @param func Function whose optimum should be bracketed. @param goal {@link GoalType Goal type}. @param xA Initial point. @param xB Initial point. @throws TooManyEvaluationsException if the maximum number of evaluations is exceeded. ",
    "is_bug": false,
    "failing_test_cases": 28,
    "buggy_methods": 7
  },
  {
    "name": "BrentOptimizer.BrentOptimizer",
    "class_name": "org.apache.commons.math3.optim.univariate.BrentOptimizer",
    "signature": "org.apache.commons.math3.optim.univariate.BrentOptimizer.BrentOptimizer(double,double,ConvergenceChecker)",
    "snippet": "    public BrentOptimizer(double rel,\n                          double abs,\n                          ConvergenceChecker<UnivariatePointValuePair> checker) {\n        super(checker);\n\n        if (rel < MIN_RELATIVE_TOLERANCE) {\n            throw new NumberIsTooSmallException(rel, MIN_RELATIVE_TOLERANCE, true);\n        }\n        if (abs <= 0) {\n            throw new NotStrictlyPositiveException(abs);\n        }\n\n        relativeThreshold = rel;\n        absoluteThreshold = abs;\n    }",
    "comment": " The arguments are used implement the original stopping criterion of Brent's algorithm. {@code abs} and {@code rel} define a tolerance {@code tol = rel |x| + abs}. {@code rel} should be no smaller than <em>2 macheps</em> and preferably not much less than <em>sqrt(macheps)</em>, where <em>macheps</em> is the relative machine precision. {@code abs} must be positive.  @param rel Relative threshold. @param abs Absolute threshold. @param checker Additional, user-defined, convergence checking procedure. @throws NotStrictlyPositiveException if {@code abs <= 0}. @throws NumberIsTooSmallException if {@code rel < 2 * Math.ulp(1d)}. ",
    "is_bug": false,
    "failing_test_cases": 28,
    "buggy_methods": 7
  },
  {
    "name": "BrentOptimizer.best",
    "class_name": "org.apache.commons.math3.optim.univariate.BrentOptimizer",
    "signature": "org.apache.commons.math3.optim.univariate.BrentOptimizer.best(UnivariatePointValuePair,UnivariatePointValuePair,boolean)",
    "snippet": "    private UnivariatePointValuePair best(UnivariatePointValuePair a,\n                                          UnivariatePointValuePair b,\n                                          boolean isMinim) {\n        if (a == null) {\n            return b;\n        }\n        if (b == null) {\n            return a;\n        }\n\n        if (isMinim) {\n            return a.getValue() <= b.getValue() ? a : b;\n        } else {\n            return a.getValue() >= b.getValue() ? a : b;\n        }\n    }",
    "comment": " Selects the best of two points.  @param a Point and value. @param b Point and value. @param isMinim {@code true} if the selected point must be the one with the lowest value. @return the best point, or {@code null} if {@code a} and {@code b} are both {@code null}. When {@code a} and {@code b} have the same function value, {@code a} is returned. ",
    "is_bug": false,
    "failing_test_cases": 28,
    "buggy_methods": 7
  },
  {
    "name": "BrentOptimizer.doOptimize",
    "class_name": "org.apache.commons.math3.optim.univariate.BrentOptimizer",
    "signature": "org.apache.commons.math3.optim.univariate.BrentOptimizer.doOptimize()",
    "snippet": "    @Override\n    protected UnivariatePointValuePair doOptimize() {\n        final boolean isMinim = getGoalType() == GoalType.MINIMIZE;\n        final double lo = getMin();\n        final double mid = getStartValue();\n        final double hi = getMax();\n\n        // Optional additional convergence criteria.\n        final ConvergenceChecker<UnivariatePointValuePair> checker\n            = getConvergenceChecker();\n\n        double a;\n        double b;\n        if (lo < hi) {\n            a = lo;\n            b = hi;\n        } else {\n            a = hi;\n            b = lo;\n        }\n\n        double x = mid;\n        double v = x;\n        double w = x;\n        double d = 0;\n        double e = 0;\n        double fx = computeObjectiveValue(x);\n        if (!isMinim) {\n            fx = -fx;\n        }\n        double fv = fx;\n        double fw = fx;\n\n        UnivariatePointValuePair previous = null;\n        UnivariatePointValuePair current\n            = new UnivariatePointValuePair(x, isMinim ? fx : -fx);\n        // Best point encountered so far (which is the initial guess).\n        UnivariatePointValuePair best = current;\n\n        int iter = 0;\n        while (true) {\n            final double m = 0.5 * (a + b);\n            final double tol1 = relativeThreshold * FastMath.abs(x) + absoluteThreshold;\n            final double tol2 = 2 * tol1;\n\n            // Default stopping criterion.\n            final boolean stop = FastMath.abs(x - m) <= tol2 - 0.5 * (b - a);\n            if (!stop) {\n                double p = 0;\n                double q = 0;\n                double r = 0;\n                double u = 0;\n\n                if (FastMath.abs(e) > tol1) { // Fit parabola.\n                    r = (x - w) * (fx - fv);\n                    q = (x - v) * (fx - fw);\n                    p = (x - v) * q - (x - w) * r;\n                    q = 2 * (q - r);\n\n                    if (q > 0) {\n                        p = -p;\n                    } else {\n                        q = -q;\n                    }\n\n                    r = e;\n                    e = d;\n\n                    if (p > q * (a - x) &&\n                        p < q * (b - x) &&\n                        FastMath.abs(p) < FastMath.abs(0.5 * q * r)) {\n                        // Parabolic interpolation step.\n                        d = p / q;\n                        u = x + d;\n\n                        // f must not be evaluated too close to a or b.\n                        if (u - a < tol2 || b - u < tol2) {\n                            if (x <= m) {\n                                d = tol1;\n                            } else {\n                                d = -tol1;\n                            }\n                        }\n                    } else {\n                        // Golden section step.\n                        if (x < m) {\n                            e = b - x;\n                        } else {\n                            e = a - x;\n                        }\n                        d = GOLDEN_SECTION * e;\n                    }\n                } else {\n                    // Golden section step.\n                    if (x < m) {\n                        e = b - x;\n                    } else {\n                        e = a - x;\n                    }\n                    d = GOLDEN_SECTION * e;\n                }\n\n                // Update by at least \"tol1\".\n                if (FastMath.abs(d) < tol1) {\n                    if (d >= 0) {\n                        u = x + tol1;\n                    } else {\n                        u = x - tol1;\n                    }\n                } else {\n                    u = x + d;\n                }\n\n                double fu = computeObjectiveValue(u);\n                if (!isMinim) {\n                    fu = -fu;\n                }\n\n                // User-defined convergence checker.\n                previous = current;\n                current = new UnivariatePointValuePair(u, isMinim ? fu : -fu);\n                best = best(best,\n                            best(previous,\n                                 current,\n                                 isMinim),\n                            isMinim);\n\n                if (checker != null) {\n                    if (checker.converged(iter, previous, current)) {\n                        return best;\n                    }\n                }\n\n                // Update a, b, v, w and x.\n                if (fu <= fx) {\n                    if (u < x) {\n                        b = x;\n                    } else {\n                        a = x;\n                    }\n                    v = w;\n                    fv = fw;\n                    w = x;\n                    fw = fx;\n                    x = u;\n                    fx = fu;\n                } else {\n                    if (u < x) {\n                        a = u;\n                    } else {\n                        b = u;\n                    }\n                    if (fu <= fw ||\n                        Precision.equals(w, x)) {\n                        v = w;\n                        fv = fw;\n                        w = u;\n                        fw = fu;\n                    } else if (fu <= fv ||\n                               Precision.equals(v, x) ||\n                               Precision.equals(v, w)) {\n                        v = u;\n                        fv = fu;\n                    }\n                }\n            } else { // Default termination (Brent's criterion).\n                return best(best,\n                            best(previous,\n                                 current,\n                                 isMinim),\n                            isMinim);\n            }\n            ++iter;\n        }\n    }",
    "comment": "{@inheritDoc} */",
    "is_bug": false,
    "failing_test_cases": 28,
    "buggy_methods": 7
  },
  {
    "name": "SearchInterval.SearchInterval",
    "class_name": "org.apache.commons.math3.optim.univariate.SearchInterval",
    "signature": "org.apache.commons.math3.optim.univariate.SearchInterval.SearchInterval(double,double,double)",
    "snippet": "    public SearchInterval(double lo,\n                          double hi,\n                          double init) {\n        if (lo >= hi) {\n            throw new NumberIsTooLargeException(lo, hi, false);\n        }\n        if (init < lo ||\n            init > hi) {\n            throw new OutOfRangeException(init, lo, hi);\n        }\n\n        lower = lo;\n        upper = hi;\n        start = init;\n    }",
    "comment": " @param lo Lower bound. @param hi Upper bound. @param init Start value. @throws NumberIsTooLargeException if {@code lo >= hi}. @throws OutOfRangeException if {@code init < lo} or {@code init > hi}. ",
    "is_bug": false,
    "failing_test_cases": 28,
    "buggy_methods": 7
  },
  {
    "name": "SearchInterval.getMax",
    "class_name": "org.apache.commons.math3.optim.univariate.SearchInterval",
    "signature": "org.apache.commons.math3.optim.univariate.SearchInterval.getMax()",
    "snippet": "    public double getMax() {\n        return upper;\n    }",
    "comment": " Gets the upper bound.  @return the upper bound. ",
    "is_bug": false,
    "failing_test_cases": 28,
    "buggy_methods": 7
  },
  {
    "name": "SearchInterval.getMin",
    "class_name": "org.apache.commons.math3.optim.univariate.SearchInterval",
    "signature": "org.apache.commons.math3.optim.univariate.SearchInterval.getMin()",
    "snippet": "    public double getMin() {\n        return lower;\n    }",
    "comment": " Gets the lower bound.  @return the lower bound. ",
    "is_bug": false,
    "failing_test_cases": 28,
    "buggy_methods": 7
  },
  {
    "name": "SearchInterval.getStartValue",
    "class_name": "org.apache.commons.math3.optim.univariate.SearchInterval",
    "signature": "org.apache.commons.math3.optim.univariate.SearchInterval.getStartValue()",
    "snippet": "    public double getStartValue() {\n        return start;\n    }",
    "comment": " Gets the start value.  @return the start value. ",
    "is_bug": false,
    "failing_test_cases": 28,
    "buggy_methods": 7
  },
  {
    "name": "SimpleUnivariateValueChecker.SimpleUnivariateValueChecker",
    "class_name": "org.apache.commons.math3.optim.univariate.SimpleUnivariateValueChecker",
    "signature": "org.apache.commons.math3.optim.univariate.SimpleUnivariateValueChecker.SimpleUnivariateValueChecker(double,double)",
    "snippet": "    public SimpleUnivariateValueChecker(final double relativeThreshold,\n                                        final double absoluteThreshold) {\n        super(relativeThreshold, absoluteThreshold);\n        maxIterationCount = ITERATION_CHECK_DISABLED;\n    }",
    "comment": "Build an instance with specified thresholds.  In order to perform only relative checks, the absolute tolerance must be set to a negative value. In order to perform only absolute checks, the relative tolerance must be set to a negative value.  @param relativeThreshold relative tolerance threshold @param absoluteThreshold absolute tolerance threshold ",
    "is_bug": false,
    "failing_test_cases": 28,
    "buggy_methods": 7
  },
  {
    "name": "SimpleUnivariateValueChecker.converged",
    "class_name": "org.apache.commons.math3.optim.univariate.SimpleUnivariateValueChecker",
    "signature": "org.apache.commons.math3.optim.univariate.SimpleUnivariateValueChecker.converged(int,UnivariatePointValuePair,UnivariatePointValuePair)",
    "snippet": "    @Override\n    public boolean converged(final int iteration,\n                             final UnivariatePointValuePair previous,\n                             final UnivariatePointValuePair current) {\n        if (maxIterationCount != ITERATION_CHECK_DISABLED) {\n            if (iteration >= maxIterationCount) {\n                return true;\n            }\n        }\n\n        final double p = previous.getValue();\n        final double c = current.getValue();\n        final double difference = FastMath.abs(p - c);\n        final double size = FastMath.max(FastMath.abs(p), FastMath.abs(c));\n        return difference <= size * getRelativeThreshold() ||\n            difference <= getAbsoluteThreshold();\n    }",
    "comment": " Check if the optimization algorithm has converged considering the last two points. This method may be called several time from the same algorithm iteration with different points. This can be detected by checking the iteration number at each call if needed. Each time this method is called, the previous and current point correspond to points with the same role at each iteration, so they can be compared. As an example, simplex-based algorithms call this method for all points of the simplex, not only for the best or worst ones.  @param iteration Index of current iteration @param previous Best point in the previous iteration. @param current Best point in the current iteration. @return {@code true} if the algorithm has converged. ",
    "is_bug": false,
    "failing_test_cases": 28,
    "buggy_methods": 7
  },
  {
    "name": "UnivariateObjectiveFunction.UnivariateObjectiveFunction",
    "class_name": "org.apache.commons.math3.optim.univariate.UnivariateObjectiveFunction",
    "signature": "org.apache.commons.math3.optim.univariate.UnivariateObjectiveFunction.UnivariateObjectiveFunction(UnivariateFunction)",
    "snippet": "    public UnivariateObjectiveFunction(UnivariateFunction f) {\n        function = f;\n    }",
    "comment": " @param f Function to be optimized. ",
    "is_bug": false,
    "failing_test_cases": 28,
    "buggy_methods": 7
  },
  {
    "name": "UnivariateObjectiveFunction.getObjectiveFunction",
    "class_name": "org.apache.commons.math3.optim.univariate.UnivariateObjectiveFunction",
    "signature": "org.apache.commons.math3.optim.univariate.UnivariateObjectiveFunction.getObjectiveFunction()",
    "snippet": "    public UnivariateFunction getObjectiveFunction() {\n        return function;\n    }",
    "comment": " Gets the function to be optimized.  @return the objective function. ",
    "is_bug": false,
    "failing_test_cases": 28,
    "buggy_methods": 7
  },
  {
    "name": "UnivariateOptimizer.UnivariateOptimizer",
    "class_name": "org.apache.commons.math3.optim.univariate.UnivariateOptimizer",
    "signature": "org.apache.commons.math3.optim.univariate.UnivariateOptimizer.UnivariateOptimizer(ConvergenceChecker)",
    "snippet": "    protected UnivariateOptimizer(ConvergenceChecker<UnivariatePointValuePair> checker) {\n        super(checker);\n    }",
    "comment": " @param checker Convergence checker. ",
    "is_bug": false,
    "failing_test_cases": 28,
    "buggy_methods": 7
  },
  {
    "name": "UnivariateOptimizer.computeObjectiveValue",
    "class_name": "org.apache.commons.math3.optim.univariate.UnivariateOptimizer",
    "signature": "org.apache.commons.math3.optim.univariate.UnivariateOptimizer.computeObjectiveValue(double)",
    "snippet": "    protected double computeObjectiveValue(double x) {\n        super.incrementEvaluationCount();\n        return function.value(x);\n    }",
    "comment": " Computes the objective function value. This method <em>must</em> be called by subclasses to enforce the evaluation counter limit.  @param x Point at which the objective function must be evaluated. @return the objective function value at the specified point. @throws TooManyEvaluationsException if the maximal number of evaluations is exceeded. ",
    "is_bug": false,
    "failing_test_cases": 28,
    "buggy_methods": 7
  },
  {
    "name": "UnivariateOptimizer.getGoalType",
    "class_name": "org.apache.commons.math3.optim.univariate.UnivariateOptimizer",
    "signature": "org.apache.commons.math3.optim.univariate.UnivariateOptimizer.getGoalType()",
    "snippet": "    public GoalType getGoalType() {\n        return goal;\n    }",
    "comment": " @return the optimization type. ",
    "is_bug": false,
    "failing_test_cases": 28,
    "buggy_methods": 7
  },
  {
    "name": "UnivariateOptimizer.getMax",
    "class_name": "org.apache.commons.math3.optim.univariate.UnivariateOptimizer",
    "signature": "org.apache.commons.math3.optim.univariate.UnivariateOptimizer.getMax()",
    "snippet": "    public double getMax() {\n        return max;\n    }",
    "comment": " @return the upper bounds. ",
    "is_bug": false,
    "failing_test_cases": 28,
    "buggy_methods": 7
  },
  {
    "name": "UnivariateOptimizer.getMin",
    "class_name": "org.apache.commons.math3.optim.univariate.UnivariateOptimizer",
    "signature": "org.apache.commons.math3.optim.univariate.UnivariateOptimizer.getMin()",
    "snippet": "    public double getMin() {\n        return min;\n    }",
    "comment": " @return the lower bounds. ",
    "is_bug": false,
    "failing_test_cases": 28,
    "buggy_methods": 7
  },
  {
    "name": "UnivariateOptimizer.getStartValue",
    "class_name": "org.apache.commons.math3.optim.univariate.UnivariateOptimizer",
    "signature": "org.apache.commons.math3.optim.univariate.UnivariateOptimizer.getStartValue()",
    "snippet": "    public double getStartValue() {\n        return start;\n    }",
    "comment": " @return the initial guess. ",
    "is_bug": false,
    "failing_test_cases": 28,
    "buggy_methods": 7
  },
  {
    "name": "UnivariateOptimizer.optimize",
    "class_name": "org.apache.commons.math3.optim.univariate.UnivariateOptimizer",
    "signature": "org.apache.commons.math3.optim.univariate.UnivariateOptimizer.optimize(OptimizationData[])",
    "snippet": "    public UnivariatePointValuePair optimize(OptimizationData... optData)\n        throws TooManyEvaluationsException {\n        // Perform computation.\n        return super.optimize(optData);\n    }",
    "comment": " {@inheritDoc}  @param optData Optimization data. In addition to those documented in {@link BaseOptimizer#parseOptimizationData(OptimizationData[]) BaseOptimizer}, this method will register the following data: <ul> <li>{@link GoalType}</li> <li>{@link SearchInterval}</li> <li>{@link UnivariateObjectiveFunction}</li> </ul> @return {@inheritDoc} @throws TooManyEvaluationsException if the maximal number of evaluations is exceeded. ",
    "is_bug": false,
    "failing_test_cases": 28,
    "buggy_methods": 7
  },
  {
    "name": "UnivariateOptimizer.parseOptimizationData",
    "class_name": "org.apache.commons.math3.optim.univariate.UnivariateOptimizer",
    "signature": "org.apache.commons.math3.optim.univariate.UnivariateOptimizer.parseOptimizationData(OptimizationData[])",
    "snippet": "    @Override\n    protected void parseOptimizationData(OptimizationData... optData) {\n        // Allow base class to register its own data.\n        super.parseOptimizationData(optData);\n\n        // The existing values (as set by the previous call) are reused if\n        // not provided in the argument list.\n        for (OptimizationData data : optData) {\n            if (data instanceof SearchInterval) {\n                final SearchInterval interval = (SearchInterval) data;\n                min = interval.getMin();\n                max = interval.getMax();\n                start = interval.getStartValue();\n                continue;\n            }\n            if (data instanceof UnivariateObjectiveFunction) {\n                function = ((UnivariateObjectiveFunction) data).getObjectiveFunction();\n                continue;\n            }\n            if (data instanceof GoalType) {\n                goal = (GoalType) data;\n                continue;\n            }\n        }\n    }",
    "comment": " Scans the list of (required and optional) optimization data that characterize the problem.  @param optData Optimization data. The following data will be looked for: <ul> <li>{@link GoalType}</li> <li>{@link SearchInterval}</li> <li>{@link UnivariateObjectiveFunction}</li> </ul> ",
    "is_bug": false,
    "failing_test_cases": 28,
    "buggy_methods": 7
  },
  {
    "name": "UnivariatePointValuePair.UnivariatePointValuePair",
    "class_name": "org.apache.commons.math3.optim.univariate.UnivariatePointValuePair",
    "signature": "org.apache.commons.math3.optim.univariate.UnivariatePointValuePair.UnivariatePointValuePair(double,double)",
    "snippet": "    public UnivariatePointValuePair(final double point,\n                                    final double value) {\n        this.point = point;\n        this.value = value;\n    }",
    "comment": " Build a point/objective function value pair.  @param point Point. @param value Value of an objective function at the point ",
    "is_bug": false,
    "failing_test_cases": 28,
    "buggy_methods": 7
  },
  {
    "name": "UnivariatePointValuePair.getPoint",
    "class_name": "org.apache.commons.math3.optim.univariate.UnivariatePointValuePair",
    "signature": "org.apache.commons.math3.optim.univariate.UnivariatePointValuePair.getPoint()",
    "snippet": "    public double getPoint() {\n        return point;\n    }",
    "comment": " Get the point.  @return the point. ",
    "is_bug": false,
    "failing_test_cases": 28,
    "buggy_methods": 7
  },
  {
    "name": "UnivariatePointValuePair.getValue",
    "class_name": "org.apache.commons.math3.optim.univariate.UnivariatePointValuePair",
    "signature": "org.apache.commons.math3.optim.univariate.UnivariatePointValuePair.getValue()",
    "snippet": "    public double getValue() {\n        return value;\n    }",
    "comment": " Get the value of the objective function.  @return the stored value of the objective function. ",
    "is_bug": false,
    "failing_test_cases": 28,
    "buggy_methods": 7
  },
  {
    "name": "BitsStreamGenerator.BitsStreamGenerator",
    "class_name": "org.apache.commons.math3.random.BitsStreamGenerator",
    "signature": "org.apache.commons.math3.random.BitsStreamGenerator.BitsStreamGenerator()",
    "snippet": "    public BitsStreamGenerator() {\n        nextGaussian = Double.NaN;\n    }",
    "comment": " Creates a new random number generator. ",
    "is_bug": false,
    "failing_test_cases": 28,
    "buggy_methods": 7
  },
  {
    "name": "BitsStreamGenerator.clear",
    "class_name": "org.apache.commons.math3.random.BitsStreamGenerator",
    "signature": "org.apache.commons.math3.random.BitsStreamGenerator.clear()",
    "snippet": "    public void clear() {\n        nextGaussian = Double.NaN;\n    }",
    "comment": " Clears the cache used by the default implementation of {@link #nextGaussian}. ",
    "is_bug": false,
    "failing_test_cases": 28,
    "buggy_methods": 7
  },
  {
    "name": "BitsStreamGenerator.nextDouble",
    "class_name": "org.apache.commons.math3.random.BitsStreamGenerator",
    "signature": "org.apache.commons.math3.random.BitsStreamGenerator.nextDouble()",
    "snippet": "    public double nextDouble() {\n        final long high = ((long) next(26)) << 26;\n        final int  low  = next(26);\n        return (high | low) * 0x1.0p-52d;\n    }",
    "comment": "{@inheritDoc} */",
    "is_bug": false,
    "failing_test_cases": 28,
    "buggy_methods": 7
  },
  {
    "name": "BitsStreamGenerator.nextGaussian",
    "class_name": "org.apache.commons.math3.random.BitsStreamGenerator",
    "signature": "org.apache.commons.math3.random.BitsStreamGenerator.nextGaussian()",
    "snippet": "    public double nextGaussian() {\n\n        final double random;\n        if (Double.isNaN(nextGaussian)) {\n            // generate a new pair of gaussian numbers\n            final double x = nextDouble();\n            final double y = nextDouble();\n            final double alpha = 2 * FastMath.PI * x;\n            final double r      = FastMath.sqrt(-2 * FastMath.log(y));\n            random       = r * FastMath.cos(alpha);\n            nextGaussian = r * FastMath.sin(alpha);\n        } else {\n            // use the second element of the pair already generated\n            random = nextGaussian;\n            nextGaussian = Double.NaN;\n        }\n\n        return random;\n\n    }",
    "comment": "{@inheritDoc} */",
    "is_bug": false,
    "failing_test_cases": 28,
    "buggy_methods": 7
  },
  {
    "name": "MersenneTwister.MersenneTwister",
    "class_name": "org.apache.commons.math3.random.MersenneTwister",
    "signature": "org.apache.commons.math3.random.MersenneTwister.MersenneTwister()",
    "snippet": "    public MersenneTwister() {\n        mt = new int[N];\n        setSeed(System.currentTimeMillis() + System.identityHashCode(this));\n    }",
    "comment": "Creates a new random number generator. <p>The instance is initialized using the current time plus the system identity hash code of this instance as the seed.</p> ",
    "is_bug": false,
    "failing_test_cases": 28,
    "buggy_methods": 7
  },
  {
    "name": "MersenneTwister.next",
    "class_name": "org.apache.commons.math3.random.MersenneTwister",
    "signature": "org.apache.commons.math3.random.MersenneTwister.next(int)",
    "snippet": "    @Override\n    protected int next(int bits) {\n\n        int y;\n\n        if (mti >= N) { // generate N words at one time\n            int mtNext = mt[0];\n            for (int k = 0; k < N - M; ++k) {\n                int mtCurr = mtNext;\n                mtNext = mt[k + 1];\n                y = (mtCurr & 0x80000000) | (mtNext & 0x7fffffff);\n                mt[k] = mt[k + M] ^ (y >>> 1) ^ MAG01[y & 0x1];\n            }\n            for (int k = N - M; k < N - 1; ++k) {\n                int mtCurr = mtNext;\n                mtNext = mt[k + 1];\n                y = (mtCurr & 0x80000000) | (mtNext & 0x7fffffff);\n                mt[k] = mt[k + (M - N)] ^ (y >>> 1) ^ MAG01[y & 0x1];\n            }\n            y = (mtNext & 0x80000000) | (mt[0] & 0x7fffffff);\n            mt[N - 1] = mt[M - 1] ^ (y >>> 1) ^ MAG01[y & 0x1];\n\n            mti = 0;\n        }\n\n        y = mt[mti++];\n\n        // tempering\n        y ^=  y >>> 11;\n        y ^= (y <<   7) & 0x9d2c5680;\n        y ^= (y <<  15) & 0xefc60000;\n        y ^=  y >>> 18;\n\n        return y >>> (32 - bits);\n\n    }",
    "comment": "Generate next pseudorandom number. <p>This method is the core generation algorithm. It is used by all the public generation methods for the various primitive types {@link #nextBoolean()}, {@link #nextBytes(byte[])}, {@link #nextDouble()}, {@link #nextFloat()}, {@link #nextGaussian()}, {@link #nextInt()}, {@link #next(int)} and {@link #nextLong()}.</p> @param bits number of random bits to produce @return random bits generated ",
    "is_bug": false,
    "failing_test_cases": 28,
    "buggy_methods": 7
  },
  {
    "name": "MersenneTwister.setSeed",
    "class_name": "org.apache.commons.math3.random.MersenneTwister",
    "signature": "org.apache.commons.math3.random.MersenneTwister.setSeed(int)",
    "snippet": "    @Override\n    public void setSeed(int seed) {\n        // we use a long masked by 0xffffffffL as a poor man unsigned int\n        long longMT = seed;\n        // NB: unlike original C code, we are working with java longs, the cast below makes masking unnecessary\n        mt[0]= (int) longMT;\n        for (mti = 1; mti < N; ++mti) {\n            // See Knuth TAOCP Vol2. 3rd Ed. P.106 for multiplier.\n            // initializer from the 2002-01-09 C version by Makoto Matsumoto\n            longMT = (1812433253l * (longMT ^ (longMT >> 30)) + mti) & 0xffffffffL;\n            mt[mti]= (int) longMT;\n        }\n\n        clear(); // Clear normal deviate cache\n    }",
    "comment": "Reinitialize the generator as if just built with the given int seed. <p>The state of the generator is exactly the same as a new generator built with the same seed.</p> @param seed the initial seed (32 bits integer) ",
    "is_bug": false,
    "failing_test_cases": 28,
    "buggy_methods": 7
  },
  {
    "name": "MersenneTwister.setSeed",
    "class_name": "org.apache.commons.math3.random.MersenneTwister",
    "signature": "org.apache.commons.math3.random.MersenneTwister.setSeed(int[])",
    "snippet": "    @Override\n    public void setSeed(int[] seed) {\n\n        if (seed == null) {\n            setSeed(System.currentTimeMillis() + System.identityHashCode(this));\n            return;\n        }\n\n        setSeed(19650218);\n        int i = 1;\n        int j = 0;\n\n        for (int k = FastMath.max(N, seed.length); k != 0; k--) {\n            long l0 = (mt[i] & 0x7fffffffl)   | ((mt[i]   < 0) ? 0x80000000l : 0x0l);\n            long l1 = (mt[i-1] & 0x7fffffffl) | ((mt[i-1] < 0) ? 0x80000000l : 0x0l);\n            long l  = (l0 ^ ((l1 ^ (l1 >> 30)) * 1664525l)) + seed[j] + j; // non linear\n            mt[i]   = (int) (l & 0xffffffffl);\n            i++; j++;\n            if (i >= N) {\n                mt[0] = mt[N - 1];\n                i = 1;\n            }\n            if (j >= seed.length) {\n                j = 0;\n            }\n        }\n\n        for (int k = N - 1; k != 0; k--) {\n            long l0 = (mt[i] & 0x7fffffffl)   | ((mt[i]   < 0) ? 0x80000000l : 0x0l);\n            long l1 = (mt[i-1] & 0x7fffffffl) | ((mt[i-1] < 0) ? 0x80000000l : 0x0l);\n            long l  = (l0 ^ ((l1 ^ (l1 >> 30)) * 1566083941l)) - i; // non linear\n            mt[i]   = (int) (l & 0xffffffffL);\n            i++;\n            if (i >= N) {\n                mt[0] = mt[N - 1];\n                i = 1;\n            }\n        }\n\n        mt[0] = 0x80000000; // MSB is 1; assuring non-zero initial array\n\n        clear(); // Clear normal deviate cache\n\n    }",
    "comment": "Reinitialize the generator as if just built with the given int array seed. <p>The state of the generator is exactly the same as a new generator built with the same seed.</p> @param seed the initial seed (32 bits integers array), if null the seed of the generator will be the current system time plus the system identity hash code of this instance ",
    "is_bug": false,
    "failing_test_cases": 28,
    "buggy_methods": 7
  },
  {
    "name": "MersenneTwister.setSeed",
    "class_name": "org.apache.commons.math3.random.MersenneTwister",
    "signature": "org.apache.commons.math3.random.MersenneTwister.setSeed(long)",
    "snippet": "    @Override\n    public void setSeed(long seed) {\n        setSeed(new int[] { (int) (seed >>> 32), (int) (seed & 0xffffffffl) });\n    }",
    "comment": "Reinitialize the generator as if just built with the given long seed. <p>The state of the generator is exactly the same as a new generator built with the same seed.</p> @param seed the initial seed (64 bits integer) ",
    "is_bug": false,
    "failing_test_cases": 28,
    "buggy_methods": 7
  },
  {
    "name": "CompositeFormat.getDefaultNumberFormat",
    "class_name": "org.apache.commons.math3.util.CompositeFormat",
    "signature": "org.apache.commons.math3.util.CompositeFormat.getDefaultNumberFormat(Locale)",
    "snippet": "    public static NumberFormat getDefaultNumberFormat(final Locale locale) {\n        final NumberFormat nf = NumberFormat.getInstance(locale);\n        nf.setMaximumFractionDigits(10);\n        return nf;\n    }",
    "comment": " Create a default number format.  The default number format is based on {@link NumberFormat#getInstance(java.util.Locale)} with the only customizing that the maximum number of fraction digits is set to 10. @param locale the specific locale used by the format. @return the default number format specific to the given locale. ",
    "is_bug": false,
    "failing_test_cases": 28,
    "buggy_methods": 7
  },
  {
    "name": "FastMath.abs",
    "class_name": "org.apache.commons.math3.util.FastMath",
    "signature": "org.apache.commons.math3.util.FastMath.abs(double)",
    "snippet": "    public static double abs(double x) {\n        return (x < 0.0) ? -x : (x == 0.0) ? 0.0 : x; // -0.0 => +0.0\n    }",
    "comment": " Absolute value. @param x number from which absolute value is requested @return abs(x) ",
    "is_bug": false,
    "failing_test_cases": 28,
    "buggy_methods": 7
  },
  {
    "name": "FastMath.abs",
    "class_name": "org.apache.commons.math3.util.FastMath",
    "signature": "org.apache.commons.math3.util.FastMath.abs(long)",
    "snippet": "    public static long abs(final long x) {\n        return (x < 0l) ? -x : x;\n    }",
    "comment": " Absolute value. @param x number from which absolute value is requested @return abs(x) ",
    "is_bug": false,
    "failing_test_cases": 28,
    "buggy_methods": 7
  },
  {
    "name": "FastMath.max",
    "class_name": "org.apache.commons.math3.util.FastMath",
    "signature": "org.apache.commons.math3.util.FastMath.max(double,double)",
    "snippet": "    public static double max(final double a, final double b) {\n        if (a > b) {\n            return a;\n        }\n        if (a < b) {\n            return b;\n        }\n        /* if either arg is NaN, return NaN */\n        if (a != b) {\n            return Double.NaN;\n        }\n        /* min(+0.0,-0.0) == -0.0 */\n        /* 0x8000000000000000L == Double.doubleToRawLongBits(-0.0d) */\n        long bits = Double.doubleToRawLongBits(a);\n        if (bits == 0x8000000000000000L) {\n            return b;\n        }\n        return a;\n    }",
    "comment": "Compute the maximum of two values @param a first value @param b second value @return b if a is lesser or equal to b, a otherwise ",
    "is_bug": false,
    "failing_test_cases": 28,
    "buggy_methods": 7
  },
  {
    "name": "FastMath.min",
    "class_name": "org.apache.commons.math3.util.FastMath",
    "signature": "org.apache.commons.math3.util.FastMath.min(int,int)",
    "snippet": "    public static int min(final int a, final int b) {\n        return (a <= b) ? a : b;\n    }",
    "comment": "Compute the minimum of two values @param a first value @param b second value @return a if a is lesser or equal to b, b otherwise ",
    "is_bug": false,
    "failing_test_cases": 28,
    "buggy_methods": 7
  },
  {
    "name": "FastMathLiteralArrays.loadLnMant",
    "class_name": "org.apache.commons.math3.util.FastMathLiteralArrays",
    "signature": "org.apache.commons.math3.util.FastMathLiteralArrays.loadLnMant()",
    "snippet": "    static double[][] loadLnMant() {\n        return LN_MANT.clone();\n    }",
    "comment": " Load \"LN_MANT\".  @return a clone of the data array. ",
    "is_bug": false,
    "failing_test_cases": 28,
    "buggy_methods": 7
  },
  {
    "name": "Incrementor.Incrementor",
    "class_name": "org.apache.commons.math3.util.Incrementor",
    "signature": "org.apache.commons.math3.util.Incrementor.Incrementor()",
    "snippet": "    public Incrementor() {\n        this(0);\n    }",
    "comment": " Default constructor. For the new instance to be useful, the maximal count must be set by calling {@link #setMaximalCount(int) setMaximalCount}. ",
    "is_bug": false,
    "failing_test_cases": 28,
    "buggy_methods": 7
  },
  {
    "name": "Incrementor.Incrementor",
    "class_name": "org.apache.commons.math3.util.Incrementor",
    "signature": "org.apache.commons.math3.util.Incrementor.Incrementor(int)",
    "snippet": "    public Incrementor(int max) {\n        this(max,\n             new MaxCountExceededCallback() {\n                 /** {@inheritDoc} */\n                 public void trigger(int max) throws MaxCountExceededException {\n                     throw new MaxCountExceededException(max);\n                 }\n             });\n    }",
    "comment": " Defines a maximal count.  @param max Maximal count. ",
    "is_bug": false,
    "failing_test_cases": 28,
    "buggy_methods": 7
  },
  {
    "name": "Incrementor.Incrementor",
    "class_name": "org.apache.commons.math3.util.Incrementor",
    "signature": "org.apache.commons.math3.util.Incrementor.Incrementor(int,MaxCountExceededCallback)",
    "snippet": "    public Incrementor(int max, MaxCountExceededCallback cb)\n        throws NullArgumentException {\n        if (cb == null){\n            throw new NullArgumentException();\n        }\n        maximalCount = max;\n        maxCountCallback = cb;\n    }",
    "comment": " Defines a maximal count and a callback method to be triggered at counter exhaustion.  @param max Maximal count. @param cb Function to be called when the maximal count has been reached. @throws NullArgumentException if {@code cb} is {@code null} ",
    "is_bug": false,
    "failing_test_cases": 28,
    "buggy_methods": 7
  },
  {
    "name": "Incrementor.getCount",
    "class_name": "org.apache.commons.math3.util.Incrementor",
    "signature": "org.apache.commons.math3.util.Incrementor.getCount()",
    "snippet": "    public int getCount() {\n        return count;\n    }",
    "comment": " Gets the current count.  @return the current count. ",
    "is_bug": false,
    "failing_test_cases": 28,
    "buggy_methods": 7
  },
  {
    "name": "Incrementor.getMaximalCount",
    "class_name": "org.apache.commons.math3.util.Incrementor",
    "signature": "org.apache.commons.math3.util.Incrementor.getMaximalCount()",
    "snippet": "    public int getMaximalCount() {\n        return maximalCount;\n    }",
    "comment": " Gets the upper limit of the counter.  @return the counter upper limit. ",
    "is_bug": false,
    "failing_test_cases": 28,
    "buggy_methods": 7
  },
  {
    "name": "Incrementor.incrementCount",
    "class_name": "org.apache.commons.math3.util.Incrementor",
    "signature": "org.apache.commons.math3.util.Incrementor.incrementCount()",
    "snippet": "    public void incrementCount() throws MaxCountExceededException {\n        if (++count > maximalCount) {\n            maxCountCallback.trigger(maximalCount);\n        }\n    }",
    "comment": " Adds one to the current iteration count. At counter exhaustion, this method will call the {@link MaxCountExceededCallback#trigger(int) trigger} method of the callback object passed to the {@link #Incrementor(int,MaxCountExceededCallback) constructor}. If not explictly set, a default callback is used that will throw a {@code MaxCountExceededException}.  @throws MaxCountExceededException at counter exhaustion, unless a custom {@link MaxCountExceededCallback callback} has been set at construction. ",
    "is_bug": false,
    "failing_test_cases": 28,
    "buggy_methods": 7
  },
  {
    "name": "Incrementor.resetCount",
    "class_name": "org.apache.commons.math3.util.Incrementor",
    "signature": "org.apache.commons.math3.util.Incrementor.resetCount()",
    "snippet": "    public void resetCount() {\n        count = 0;\n    }",
    "comment": " Resets the counter to 0. ",
    "is_bug": false,
    "failing_test_cases": 28,
    "buggy_methods": 7
  },
  {
    "name": "Incrementor.setMaximalCount",
    "class_name": "org.apache.commons.math3.util.Incrementor",
    "signature": "org.apache.commons.math3.util.Incrementor.setMaximalCount(int)",
    "snippet": "    public void setMaximalCount(int max) {\n        maximalCount = max;\n    }",
    "comment": " Sets the upper limit for the counter. This does not automatically reset the current count to zero (see {@link #resetCount()}).  @param max Upper limit of the counter. ",
    "is_bug": false,
    "failing_test_cases": 28,
    "buggy_methods": 7
  },
  {
    "name": "MathArrays.copyOf",
    "class_name": "org.apache.commons.math3.util.MathArrays",
    "signature": "org.apache.commons.math3.util.MathArrays.copyOf(int[],int)",
    "snippet": "    public static int[] copyOf(int[] source, int len) {\n         final int[] output = new int[len];\n         System.arraycopy(source, 0, output, 0, FastMath.min(len, source.length));\n         return output;\n     }",
    "comment": " Creates a copy of the {@code source} array.  @param source Array to be copied. @param len Number of entries to copy. If smaller then the source length, the copy will be truncated, if larger it will padded with zeroes. @return the copied array. ",
    "is_bug": false,
    "failing_test_cases": 28,
    "buggy_methods": 7
  },
  {
    "name": "MathUtils.checkNotNull",
    "class_name": "org.apache.commons.math3.util.MathUtils",
    "signature": "org.apache.commons.math3.util.MathUtils.checkNotNull(Object)",
    "snippet": "    public static void checkNotNull(Object o)\n        throws NullArgumentException {\n        if (o == null) {\n            throw new NullArgumentException();\n        }\n    }",
    "comment": " Checks that an object is not null.  @param o Object to be checked. @throws NullArgumentException if {@code o} is {@code null}. ",
    "is_bug": false,
    "failing_test_cases": 28,
    "buggy_methods": 7
  },
  {
    "name": "Pair.Pair",
    "class_name": "org.apache.commons.math3.util.Pair",
    "signature": "org.apache.commons.math3.util.Pair.Pair(K,V)",
    "snippet": "    public Pair(K k, V v) {\n        key = k;\n        value = v;\n    }",
    "comment": " Create an entry representing a mapping from the specified key to the specified value.  @param k Key (first element of the pair). @param v Value (second element of the pair). ",
    "is_bug": false,
    "failing_test_cases": 28,
    "buggy_methods": 7
  },
  {
    "name": "Pair.getKey",
    "class_name": "org.apache.commons.math3.util.Pair",
    "signature": "org.apache.commons.math3.util.Pair.getKey()",
    "snippet": "    public K getKey() {\n        return key;\n    }",
    "comment": " Get the key.  @return the key (first element of the pair). ",
    "is_bug": false,
    "failing_test_cases": 28,
    "buggy_methods": 7
  },
  {
    "name": "Pair.getValue",
    "class_name": "org.apache.commons.math3.util.Pair",
    "signature": "org.apache.commons.math3.util.Pair.getValue()",
    "snippet": "    public V getValue() {\n        return value;\n    }",
    "comment": " Get the value.  @return the value (second element of the pair). ",
    "is_bug": false,
    "failing_test_cases": 28,
    "buggy_methods": 7
  },
  {
    "name": "Precision.equals",
    "class_name": "org.apache.commons.math3.util.Precision",
    "signature": "org.apache.commons.math3.util.Precision.equals(double,double)",
    "snippet": "    public static boolean equals(double x, double y) {\n        return equals(x, y, 1);\n    }",
    "comment": " Returns true iff they are equal as defined by {@link #equals(double,double,int) equals(x, y, 1)}.  @param x first value @param y second value @return {@code true} if the values are equal. ",
    "is_bug": false,
    "failing_test_cases": 28,
    "buggy_methods": 7
  },
  {
    "name": "Precision.equals",
    "class_name": "org.apache.commons.math3.util.Precision",
    "signature": "org.apache.commons.math3.util.Precision.equals(double,double,int)",
    "snippet": "    public static boolean equals(double x, double y, int maxUlps) {\n        long xInt = Double.doubleToLongBits(x);\n        long yInt = Double.doubleToLongBits(y);\n\n        // Make lexicographically ordered as a two's-complement integer.\n        if (xInt < 0) {\n            xInt = SGN_MASK - xInt;\n        }\n        if (yInt < 0) {\n            yInt = SGN_MASK - yInt;\n        }\n\n        final boolean isEqual = FastMath.abs(xInt - yInt) <= maxUlps;\n\n        return isEqual && !Double.isNaN(x) && !Double.isNaN(y);\n    }",
    "comment": " Returns true if both arguments are equal or within the range of allowed error (inclusive). Two float numbers are considered equal if there are {@code (maxUlps - 1)} (or fewer) floating point numbers between them, i.e. two adjacent floating point numbers are considered equal. Adapted from <a href=\"http://www.cygnus-software.com/papers/comparingfloats/comparingfloats.htm\"> Bruce Dawson</a>  @param x first value @param y second value @param maxUlps {@code (maxUlps - 1)} is the number of floating point values between {@code x} and {@code y}. @return {@code true} if there are fewer than {@code maxUlps} floating point values between {@code x} and {@code y}. ",
    "is_bug": false,
    "failing_test_cases": 28,
    "buggy_methods": 7
  }
]