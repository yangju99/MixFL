[
  {
    "name": "Answers.get",
    "class_name": "org.mockito.Answers",
    "signature": "org.mockito.Answers.get()",
    "snippet": "    public Answer<Object> get() {\n        return implementation;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "Matchers.reportMatcher",
    "class_name": "org.mockito.Matchers",
    "signature": "org.mockito.Matchers.reportMatcher(Matcher)",
    "snippet": "    private static HandyReturnValues reportMatcher(Matcher<?> matcher) {\n        return mockingProgress.getArgumentMatcherStorage().reportMatcher(matcher);\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "Matchers.same",
    "class_name": "org.mockito.Matchers",
    "signature": "org.mockito.Matchers.same(T)",
    "snippet": "    public static <T> T same(T value) {\n        return (T) reportMatcher(new Same(value)).<T>returnFor(value);\n    }",
    "comment": " Object argument that is the same as the given value. <p> See examples in javadoc for {@link Matchers} class  @param <T> the type of the object, it is passed through to prevent casts. @param value the given value. @return <code>null</code>. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "Mockito.mock",
    "class_name": "org.mockito.Mockito",
    "signature": "org.mockito.Mockito.mock(Class,MockSettings)",
    "snippet": "    public static <T> T mock(Class<T> classToMock, MockSettings mockSettings) {\n        return MOCKITO_CORE.mock(classToMock, mockSettings);\n    }",
    "comment": " Creates a mock with some non-standard settings. <p> The number of configuration points for a mock grows  so we need a fluent way to introduce new configuration without adding more and more overloaded Mockito.mock() methods.  Hence {@link MockSettings}. <pre> Listener mock = mock(Listener.class, withSettings() .name(\"firstListner\").defaultBehavior(RETURNS_SMART_NULLS)); );   </pre> <b>Use it carefully and occasionally</b>. What might be reason your test needs non-standard mocks?  Is the code under test so complicated that it requires non-standard mocks?  Wouldn't you prefer to refactor the code under test so it is testable in a simple way? <p> See also {@link Mockito#withSettings()} <p> See examples in javadoc for {@link Mockito} class  @param classToMock class or interface to mock @param mockSettings additional mock settings @return mock object ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "Mockito.times",
    "class_name": "org.mockito.Mockito",
    "signature": "org.mockito.Mockito.times(int)",
    "snippet": "    public static VerificationMode times(int wantedNumberOfInvocations) {\n        return VerificationModeFactory.times(wantedNumberOfInvocations);\n    }",
    "comment": " Allows verifying exact number of invocations. E.g: <pre> verify(mock, times(2)).someMethod(\"some arg\"); </pre>  See examples in javadoc for {@link Mockito} class  @param wantedNumberOfInvocations wanted number of invocations   @return verification mode ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "Mockito.verify",
    "class_name": "org.mockito.Mockito",
    "signature": "org.mockito.Mockito.verify(T)",
    "snippet": "    public static <T> T verify(T mock) {\n        return MOCKITO_CORE.verify(mock, times(1));\n    }",
    "comment": " Verifies certain behavior <b>happened once</b>  <p> Alias to <code>verify(mock, times(1))</code> E.g: <pre> verify(mock).someMethod(\"some arg\"); </pre> Above is equivalent to: <pre> verify(mock, times(1)).someMethod(\"some arg\"); </pre> <p> Arguments passed are compared using equals() method. Read about {@link ArgumentCaptor} or {@link ArgumentMatcher} to find out other ways of matching / asserting arguments passed. <p> Although it is possible to verify a stubbed invocation, usually <b>it's just redundant</b>. Let's say you've stubbed foo.bar().  If your code cares what foo.bar() returns then something else breaks(often before even verify() gets executed). If your code doesn't care what get(0) returns then it should not be stubbed.  Not convinced? See <a href=\"http://monkeyisland.pl/2008/04/26/asking-and-telling\">here</a>.  <p> See examples in javadoc for {@link Mockito} class  @param mock to be verified @return mock object itself ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "Mockito.withSettings",
    "class_name": "org.mockito.Mockito",
    "signature": "org.mockito.Mockito.withSettings()",
    "snippet": "    public static MockSettings withSettings() {\n        return new MockSettingsImpl().defaultAnswer(RETURNS_DEFAULTS);\n    }",
    "comment": " Allows mock creation with additional mock settings.  <p> Don't use it too often.  Consider writing simple tests that use simple mocks.  Repeat after me: simple tests push simple, KISSy, readable & maintainable code. If you cannot write a test in a simple way - refactor the code under test. <p> Examples of mock settings: <pre> Creates mock with different default answer & name Foo mock = mock(Foo.class, withSettings() .defaultAnswer(RETURNS_SMART_NULLS) .name(\"cool mockie\"));  Creates mock with different default answer, descriptive name and extra interfaces Foo mock = mock(Foo.class, withSettings() .defaultAnswer(RETURNS_SMART_NULLS) .name(\"cool mockie\") .extraInterfaces(Bar.class));     </pre> {@link MockSettings} has been introduced for two reasons.  Firstly, to make it easy to add another mock settings when the demand comes. Secondly, to enable combining different mock settings without introducing zillions of overloaded mock() methods. <p> See javadoc for {@link MockSettings} to learn about possible mock settings. <p>  @return mock settings instance with defaults. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "MockitoAnnotations.initMocks",
    "class_name": "org.mockito.MockitoAnnotations",
    "signature": "org.mockito.MockitoAnnotations.initMocks(Object)",
    "snippet": "    public static void initMocks(Object testClass) {\n        if (testClass == null) {\n            throw new MockitoException(\"testClass cannot be null. For info how to use @Mock annotations see examples in javadoc for MockitoAnnotations class\");\n        }\n        \n        Class<?> clazz = testClass.getClass();\n        while (clazz != Object.class) {\n            scan(testClass, clazz);\n            clazz = clazz.getSuperclass();\n        }\n    }",
    "comment": " Initializes objects annotated with Mockito annotations for given testClass: &#064;{@link org.mockito.Mock}, &#064;{@link Spy}, &#064;{@link Captor}, &#064;{@link InjectMocks}  <p> See examples in javadoc for {@link MockitoAnnotations} class. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "MockitoAnnotations.processAnnotationDeprecatedWay",
    "class_name": "org.mockito.MockitoAnnotations",
    "signature": "org.mockito.MockitoAnnotations.processAnnotationDeprecatedWay(AnnotationEngine,Object,Field)",
    "snippet": "    @SuppressWarnings(\"deprecation\")\n    static void processAnnotationDeprecatedWay(AnnotationEngine annotationEngine, Object testClass, Field field) {\n        boolean alreadyAssigned = false;\n        for(Annotation annotation : field.getAnnotations()) {\n            Object mock = annotationEngine.createMockFor(annotation, field);\n            if (mock != null) {\n                throwIfAlreadyAssigned(field, alreadyAssigned);\n                alreadyAssigned = true;                \n                try {\n                    new FieldSetter(testClass, field).set(mock);\n                } catch (Exception e) {\n                    throw new MockitoException(\"Problems setting field \" + field.getName() + \" annotated with \"\n                            + annotation, e);\n                }\n            }\n        }\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "MockitoAnnotations.scan",
    "class_name": "org.mockito.MockitoAnnotations",
    "signature": "org.mockito.MockitoAnnotations.scan(Object,Class)",
    "snippet": "    static void scan(Object testClass, Class<?> clazz) {\n        AnnotationEngine annotationEngine = new GlobalConfiguration().getAnnotationEngine();\n        Field[] fields = clazz.getDeclaredFields();\n        for (Field field : fields) {\n            //below can be removed later, when we get rid of deprecated stuff\n            if (annotationEngine.getClass() != new DefaultMockitoConfiguration().getAnnotationEngine().getClass()) {\n                //this means user has his own annotation engine and we have to respect that.\n                //we will do annotation processing the old way so that we are backwards compatible\n                processAnnotationDeprecatedWay(annotationEngine, testClass, field);                \n            } \n        }\n        //act 'the new' way\n        annotationEngine.process(clazz, testClass);\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "MockitoAnnotations.throwIfAlreadyAssigned",
    "class_name": "org.mockito.MockitoAnnotations",
    "signature": "org.mockito.MockitoAnnotations.throwIfAlreadyAssigned(Field,boolean)",
    "snippet": "    static void throwIfAlreadyAssigned(Field field, boolean alreadyAssigned) {\n        if (alreadyAssigned) {\n            new Reporter().moreThanOneAnnotationNotAllowed(field.getName());\n        }\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "DefaultMockitoConfiguration.getAnnotationEngine",
    "class_name": "org.mockito.configuration.DefaultMockitoConfiguration",
    "signature": "org.mockito.configuration.DefaultMockitoConfiguration.getAnnotationEngine()",
    "snippet": "    public AnnotationEngine getAnnotationEngine() {\n        return new InjectingAnnotationEngine();\n    }",
    "comment": "(non-Javadoc) @see org.mockito.IMockitoConfiguration#getAnnotationEngine() ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "DefaultMockitoConfiguration.getDefaultAnswer",
    "class_name": "org.mockito.configuration.DefaultMockitoConfiguration",
    "signature": "org.mockito.configuration.DefaultMockitoConfiguration.getDefaultAnswer()",
    "snippet": "    public Answer<Object> getDefaultAnswer() {\n        return new ReturnsEmptyValues();\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "MockHandler.MockHandler",
    "class_name": "org.mockito.internal.MockHandler",
    "signature": "org.mockito.internal.MockHandler.MockHandler(MockSettingsImpl)",
    "snippet": "    public MockHandler(MockSettingsImpl mockSettings) {\n        this.mockSettings = mockSettings;\n        this.mockingProgress = new ThreadSafeMockingProgress();\n        this.matchersBinder = new MatchersBinder();\n        this.invocationContainerImpl = new InvocationContainerImpl(mockingProgress);\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "MockHandler.handle",
    "class_name": "org.mockito.internal.MockHandler",
    "signature": "org.mockito.internal.MockHandler.handle(Invocation)",
    "snippet": "    public Object handle(Invocation invocation) throws Throwable {\n        if (invocationContainerImpl.hasAnswersForStubbing()) {\n            // stubbing voids with stubVoid() or doAnswer() style\n            InvocationMatcher invocationMatcher = matchersBinder.bindMatchers(mockingProgress\n                            .getArgumentMatcherStorage(), invocation);\n            invocationContainerImpl.setMethodForStubbing(invocationMatcher);\n            return null;\n        }\n        VerificationMode verificationMode = mockingProgress.pullVerificationMode();\n\n        InvocationMatcher invocationMatcher = matchersBinder.bindMatchers(mockingProgress.getArgumentMatcherStorage(),\n                        invocation);\n\n        mockingProgress.validateState();\n\n        //if verificationMode is not null then someone is doing verify()        \n        if (verificationMode != null) {\n            //We need to check if verification was started on the correct mock \n            // - see VerifyingWithAnExtraCallToADifferentMockTest (bug 138)\n            //TODO: can I avoid this cast here?\n            if (((MockAwareVerificationMode) verificationMode).getMock() == invocation.getMock()) {                \n                VerificationDataImpl data = new VerificationDataImpl(invocationContainerImpl, invocationMatcher);            \n                verificationMode.verify(data);\n                return null;\n            } else {\n                // this means there is an invocation on a different mock. Re-adding verification mode \n                // - see VerifyingWithAnExtraCallToADifferentMockTest (bug 138)\n                mockingProgress.verificationStarted(verificationMode);\n            }\n        }\n        \n        invocationContainerImpl.setInvocationForPotentialStubbing(invocationMatcher);\n        OngoingStubbingImpl<T> ongoingStubbing = new OngoingStubbingImpl<T>(invocationContainerImpl);\n        mockingProgress.reportOngoingStubbing(ongoingStubbing);\n\n        StubbedInvocationMatcher stubbedInvocation = invocationContainerImpl.findAnswerFor(invocation);\n\n        if (stubbedInvocation != null) {\n            stubbedInvocation.captureArgumentsFrom(invocation);\n            return stubbedInvocation.answer(invocation);\n        } else {\n            Object ret = mockSettings.getDefaultAnswer().answer(invocation);\n\n            // redo setting invocation for potential stubbing in case of partial\n            // mocks / spies.\n            // Without it, the real method inside 'when' might have delegated\n            // to other self method and overwrite the intended stubbed method\n            // with a different one. The reset is required to avoid runtime exception that validates return type with stubbed method signature.\n            invocationContainerImpl.resetInvocationForPotentialStubbing(invocationMatcher);\n            return ret;\n        }\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "MockitoCore.mock",
    "class_name": "org.mockito.internal.MockitoCore",
    "signature": "org.mockito.internal.MockitoCore.mock(Class,MockSettings)",
    "snippet": "    public <T> T mock(Class<T> classToMock, MockSettings mockSettings) {\n        T mock = mockUtil.createMock(classToMock, (MockSettingsImpl) mockSettings);\n        mockingProgress.mockingStarted(mock, classToMock, mockSettings);\n        return mock;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "MockitoCore.verify",
    "class_name": "org.mockito.internal.MockitoCore",
    "signature": "org.mockito.internal.MockitoCore.verify(T,VerificationMode)",
    "snippet": "    public <T> T verify(T mock, VerificationMode mode) {\n        if (mock == null) {\n            reporter.nullPassedToVerify();\n        } else if (!mockUtil.isMock(mock)) {\n            reporter.notAMockPassedToVerify(mock.getClass());\n        }\n        mockingProgress.verificationStarted(new MockAwareVerificationMode(mock, mode));\n        return mock;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "ClassPathLoader.loadConfiguration",
    "class_name": "org.mockito.internal.configuration.ClassPathLoader",
    "signature": "org.mockito.internal.configuration.ClassPathLoader.loadConfiguration()",
    "snippet": "    @SuppressWarnings({\"unchecked\"})\n    public IMockitoConfiguration loadConfiguration() {\n        //Trying to get config from classpath\n        Class configClass = null;\n        try {\n            configClass = (Class) Class.forName(\"org.mockito.configuration.MockitoConfiguration\");\n        } catch (ClassNotFoundException e) {\n            //that's ok, it means there is no global config, using default one. \n            return null;\n        }\n        \n        try {\n            return (IMockitoConfiguration) configClass.newInstance();\n        } catch (ClassCastException e) {\n            throw new MockitoConfigurationException(\"\\n\" +\n                    \"MockitoConfiguration class must implement org.mockito.configuration.IMockitoConfiguration interface.\", e);\n        } catch (Exception e) {\n            throw new MockitoConfigurationException(\"\\n\" +\n                    \"Unable to instantianate org.mockito.configuration.MockitoConfiguration class. Does it have a safe, no-arg constructor?\", e);\n        }\n    }",
    "comment": " @return configuration loaded from classpath or null ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "DefaultAnnotationEngine.createMockFor",
    "class_name": "org.mockito.internal.configuration.DefaultAnnotationEngine",
    "signature": "org.mockito.internal.configuration.DefaultAnnotationEngine.createMockFor(Annotation,Field)",
    "snippet": "    @SuppressWarnings(\"deprecation\")\n    public Object createMockFor(Annotation annotation, Field field) {\n        if (annotation instanceof Mock) {\n            return processAnnotationOn((Mock) annotation, field);\n        }\n        if (annotation instanceof MockitoAnnotations.Mock) {\n            return processAnnotationOn((MockitoAnnotations.Mock) annotation, field);\n        }\n        if (annotation instanceof Captor) {\n            return processAnnotationOn((Captor) annotation, field);\n        }        \n\n        return null;\n    }",
    "comment": "(non-Javadoc) @see org.mockito.AnnotationEngine#createMockFor(java.lang.annotation.Annotation, java.lang.reflect.Field) ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "DefaultAnnotationEngine.process",
    "class_name": "org.mockito.internal.configuration.DefaultAnnotationEngine",
    "signature": "org.mockito.internal.configuration.DefaultAnnotationEngine.process(Class,Object)",
    "snippet": "    public void process(Class<?> clazz, Object testClass) {\n        Field[] fields = clazz.getDeclaredFields();\n        for (Field field : fields) {\n            boolean alreadyAssigned = false;\n            for(Annotation annotation : field.getAnnotations()) {           \n                Object mock = createMockFor(annotation, field);\n                if (mock != null) {\n                    throwIfAlreadyAssigned(field, alreadyAssigned);                    \n                    alreadyAssigned = true;                    \n                    try {\n                        new FieldSetter(testClass, field).set(mock);\n                    } catch (Exception e) {\n                        throw new MockitoException(\"Problems setting field \" + field.getName() + \" annotated with \"\n                                + annotation, e);\n                    }\n                }        \n            }\n        }\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "DefaultAnnotationEngine.processAnnotationOn",
    "class_name": "org.mockito.internal.configuration.DefaultAnnotationEngine",
    "signature": "org.mockito.internal.configuration.DefaultAnnotationEngine.processAnnotationOn(Mock,Field)",
    "snippet": "    @SuppressWarnings(\"deprecation\")\n    private Object processAnnotationOn(org.mockito.MockitoAnnotations.Mock annotation, Field field) {\n        return Mockito.mock(field.getType(), field.getName());\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "DefaultAnnotationEngine.throwIfAlreadyAssigned",
    "class_name": "org.mockito.internal.configuration.DefaultAnnotationEngine",
    "signature": "org.mockito.internal.configuration.DefaultAnnotationEngine.throwIfAlreadyAssigned(Field,boolean)",
    "snippet": "    void throwIfAlreadyAssigned(Field field, boolean alreadyAssigned) {\n        if (alreadyAssigned) {\n            new Reporter().moreThanOneAnnotationNotAllowed(field.getName());\n        }\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "GlobalConfiguration.GlobalConfiguration",
    "class_name": "org.mockito.internal.configuration.GlobalConfiguration",
    "signature": "org.mockito.internal.configuration.GlobalConfiguration.GlobalConfiguration()",
    "snippet": "    public GlobalConfiguration() {\n        //Configuration should be loaded only once but I cannot really test it\n        if (globalConfiguration.get() == null) {\n            globalConfiguration.set(createConfig());\n        }\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "GlobalConfiguration.createConfig",
    "class_name": "org.mockito.internal.configuration.GlobalConfiguration",
    "signature": "org.mockito.internal.configuration.GlobalConfiguration.createConfig()",
    "snippet": "    private IMockitoConfiguration createConfig() {\n        IMockitoConfiguration defaultConfiguration = new DefaultMockitoConfiguration();\n        IMockitoConfiguration config = new ClassPathLoader().loadConfiguration();\n        if (config != null) {\n            return config;\n        } else {\n            return defaultConfiguration;\n        }\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "GlobalConfiguration.getAnnotationEngine",
    "class_name": "org.mockito.internal.configuration.GlobalConfiguration",
    "signature": "org.mockito.internal.configuration.GlobalConfiguration.getAnnotationEngine()",
    "snippet": "    public AnnotationEngine getAnnotationEngine() {\n        return globalConfiguration.get().getAnnotationEngine();\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "GlobalConfiguration.getDefaultAnswer",
    "class_name": "org.mockito.internal.configuration.GlobalConfiguration",
    "signature": "org.mockito.internal.configuration.GlobalConfiguration.getDefaultAnswer()",
    "snippet": "    public Answer<Object> getDefaultAnswer() {\n        return globalConfiguration.get().getDefaultAnswer();\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "GlobalConfiguration.getIt",
    "class_name": "org.mockito.internal.configuration.GlobalConfiguration",
    "signature": "org.mockito.internal.configuration.GlobalConfiguration.getIt()",
    "snippet": "    IMockitoConfiguration getIt() {\n        return globalConfiguration.get();\n    }",
    "comment": "back door for testing",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "GlobalConfiguration.validate",
    "class_name": "org.mockito.internal.configuration.GlobalConfiguration",
    "signature": "org.mockito.internal.configuration.GlobalConfiguration.validate()",
    "snippet": "    public static void validate() {\n        new GlobalConfiguration();\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "InjectingAnnotationEngine.createMockFor",
    "class_name": "org.mockito.internal.configuration.InjectingAnnotationEngine",
    "signature": "org.mockito.internal.configuration.InjectingAnnotationEngine.createMockFor(Annotation,Field)",
    "snippet": "    public Object createMockFor(Annotation annotation, Field field) {\n        return delegate.createMockFor(annotation, field);\n    }",
    "comment": "(non-Javadoc) @see org.mockito.AnnotationEngine#createMockFor(java.lang.annotation.Annotation, java.lang.reflect.Field) ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "InjectingAnnotationEngine.process",
    "class_name": "org.mockito.internal.configuration.InjectingAnnotationEngine",
    "signature": "org.mockito.internal.configuration.InjectingAnnotationEngine.process(Class,Object)",
    "snippet": "    public void process(Class<?> context, Object testClass) {\n        //this will create @Mocks, @Captors, etc:\n        delegate.process(context, testClass);\n        //this will create @Spies:\n        spyAnnotationEngine.process(context, testClass);\n        \n        //this injects mocks\n        Field[] fields = context.getDeclaredFields();\n        for (Field field : fields) {\n            if (field.isAnnotationPresent(InjectMocks.class)) {\n                assertNoAnnotations(field, Mock.class, org.mockito.MockitoAnnotations.Mock.class, Captor.class);\n                injectMocks(testClass);\n            }\n        }\n    } ",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "SpyAnnotationEngine.process",
    "class_name": "org.mockito.internal.configuration.SpyAnnotationEngine",
    "signature": "org.mockito.internal.configuration.SpyAnnotationEngine.process(Class,Object)",
    "snippet": "    @SuppressWarnings(\"deprecation\")\n    public void process(Class<?> context, Object testClass) {\n        Field[] fields = context.getDeclaredFields();\n        for (Field field : fields) {\n            if (field.isAnnotationPresent(Spy.class)) {\n                assertNoAnnotations(Spy.class, field, Mock.class, org.mockito.MockitoAnnotations.Mock.class, Captor.class);\n                Object instance = null;\n                try {\n                    instance = new FieldInitializer(testClass, field).initialize();\n                } catch (MockitoException e) {\n                    new Reporter().cannotInitializeForSpyAnnotation(field.getName(), e);\n                }\n                try {\n                    if (new MockUtil().isMock(instance)) {\n                        // instance has been spied earlier\n                        Mockito.reset(instance);\n                    } else {\n                        field.setAccessible(true);\n                        field.set(testClass, Mockito.mock(instance.getClass(), withSettings()\n                                .spiedInstance(instance)\n                                .defaultAnswer(Mockito.CALLS_REAL_METHODS)\n                                .name(field.getName())));\n                    }\n                } catch (IllegalAccessException e) {\n                    throw new MockitoException(\"Problems initiating spied field \" + field.getName(), e);\n                }\n            }\n        }\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "DelegatingMethod.DelegatingMethod",
    "class_name": "org.mockito.internal.creation.DelegatingMethod",
    "signature": "org.mockito.internal.creation.DelegatingMethod.DelegatingMethod(Method)",
    "snippet": "    public DelegatingMethod(Method method) {\n        assert method != null : \"Method cannot be null\";\n        this.method = method;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "DelegatingMethod.getJavaMethod",
    "class_name": "org.mockito.internal.creation.DelegatingMethod",
    "signature": "org.mockito.internal.creation.DelegatingMethod.getJavaMethod()",
    "snippet": "    public Method getJavaMethod() {\n        return method;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "DelegatingMethod.getReturnType",
    "class_name": "org.mockito.internal.creation.DelegatingMethod",
    "signature": "org.mockito.internal.creation.DelegatingMethod.getReturnType()",
    "snippet": "    public Class<?> getReturnType() {\n        return method.getReturnType();\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "DelegatingMethod.isVarArgs",
    "class_name": "org.mockito.internal.creation.DelegatingMethod",
    "signature": "org.mockito.internal.creation.DelegatingMethod.isVarArgs()",
    "snippet": "    public boolean isVarArgs() {\n        return method.isVarArgs();\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "DelegatingMockitoMethodProxy.DelegatingMockitoMethodProxy",
    "class_name": "org.mockito.internal.creation.DelegatingMockitoMethodProxy",
    "signature": "org.mockito.internal.creation.DelegatingMockitoMethodProxy.DelegatingMockitoMethodProxy(MethodProxy)",
    "snippet": "    public DelegatingMockitoMethodProxy(MethodProxy methodProxy) {\n        this.methodProxy = methodProxy;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "DelegatingMockitoMethodProxy.getMethodProxy",
    "class_name": "org.mockito.internal.creation.DelegatingMockitoMethodProxy",
    "signature": "org.mockito.internal.creation.DelegatingMockitoMethodProxy.getMethodProxy()",
    "snippet": "    public MethodProxy getMethodProxy() {\n        return methodProxy;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "MethodInterceptorFilter.MethodInterceptorFilter",
    "class_name": "org.mockito.internal.creation.MethodInterceptorFilter",
    "signature": "org.mockito.internal.creation.MethodInterceptorFilter.MethodInterceptorFilter(MockitoInvocationHandler,MockSettingsImpl)",
    "snippet": "    public MethodInterceptorFilter(MockitoInvocationHandler handler, MockSettingsImpl mockSettings) {\n        this.handler = handler;\n        this.mockSettings = mockSettings;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "MethodInterceptorFilter.createMockitoMethod",
    "class_name": "org.mockito.internal.creation.MethodInterceptorFilter",
    "signature": "org.mockito.internal.creation.MethodInterceptorFilter.createMockitoMethod(Method)",
    "snippet": "    public MockitoMethod createMockitoMethod(Method method) {\n        if (mockSettings.isSerializable()) {\n            return new SerializableMethod(method);\n        } else {\n            return new DelegatingMethod(method); \n        }\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "MethodInterceptorFilter.createMockitoMethodProxy",
    "class_name": "org.mockito.internal.creation.MethodInterceptorFilter",
    "signature": "org.mockito.internal.creation.MethodInterceptorFilter.createMockitoMethodProxy(MethodProxy)",
    "snippet": "    public MockitoMethodProxy createMockitoMethodProxy(MethodProxy methodProxy) {\n        if (mockSettings.isSerializable())\n            return new SerializableMockitoMethodProxy(methodProxy);\n        return new DelegatingMockitoMethodProxy(methodProxy);\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "MethodInterceptorFilter.intercept",
    "class_name": "org.mockito.internal.creation.MethodInterceptorFilter",
    "signature": "org.mockito.internal.creation.MethodInterceptorFilter.intercept(Object,Method,Object[],MethodProxy)",
    "snippet": "    public Object intercept(Object proxy, Method method, Object[] args, MethodProxy methodProxy)\n            throws Throwable {\n        if (objectMethodsGuru.isEqualsMethod(method)) {\n            return proxy == args[0];\n        } else if (objectMethodsGuru.isHashCodeMethod(method)) {\n            return hashCodeForMock(proxy);\n        }\n        \n        MockitoMethodProxy mockitoMethodProxy = createMockitoMethodProxy(methodProxy);\n        cglibHacker.setMockitoNamingPolicy(mockitoMethodProxy);\n        \n        MockitoMethod mockitoMethod = createMockitoMethod(method);\n        \n        FilteredCGLIBProxyRealMethod realMethod = new FilteredCGLIBProxyRealMethod(mockitoMethodProxy);\n        Invocation invocation = new Invocation(proxy, mockitoMethod, args, SequenceNumber.next(), realMethod);\n        return handler.handle(invocation);\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "MockSettingsImpl.defaultAnswer",
    "class_name": "org.mockito.internal.creation.MockSettingsImpl",
    "signature": "org.mockito.internal.creation.MockSettingsImpl.defaultAnswer(Answer)",
    "snippet": "    public MockSettings defaultAnswer(Answer defaultAnswer) {\n        this.defaultAnswer = defaultAnswer;\n        return this;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "MockSettingsImpl.getDefaultAnswer",
    "class_name": "org.mockito.internal.creation.MockSettingsImpl",
    "signature": "org.mockito.internal.creation.MockSettingsImpl.getDefaultAnswer()",
    "snippet": "    public Answer<Object> getDefaultAnswer() {\n        return defaultAnswer;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "MockSettingsImpl.getExtraInterfaces",
    "class_name": "org.mockito.internal.creation.MockSettingsImpl",
    "signature": "org.mockito.internal.creation.MockSettingsImpl.getExtraInterfaces()",
    "snippet": "    public Class<?>[] getExtraInterfaces() {\n        return extraInterfaces;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "MockSettingsImpl.getSpiedInstance",
    "class_name": "org.mockito.internal.creation.MockSettingsImpl",
    "signature": "org.mockito.internal.creation.MockSettingsImpl.getSpiedInstance()",
    "snippet": "    public Object getSpiedInstance() {\n        return spiedInstance;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "MockSettingsImpl.initiateMockName",
    "class_name": "org.mockito.internal.creation.MockSettingsImpl",
    "signature": "org.mockito.internal.creation.MockSettingsImpl.initiateMockName(Class)",
    "snippet": "    public void initiateMockName(Class classToMock) {\n        mockName = new MockName(name, classToMock);\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "MockSettingsImpl.isSerializable",
    "class_name": "org.mockito.internal.creation.MockSettingsImpl",
    "signature": "org.mockito.internal.creation.MockSettingsImpl.isSerializable()",
    "snippet": "    public boolean isSerializable() {\n        return serializable;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "MockSettingsImpl.name",
    "class_name": "org.mockito.internal.creation.MockSettingsImpl",
    "signature": "org.mockito.internal.creation.MockSettingsImpl.name(String)",
    "snippet": "    public MockSettings name(String name) {\n        this.name = name;\n        return this;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "CGLIBHacker.reflectOnCreateInfo",
    "class_name": "org.mockito.internal.creation.cglib.CGLIBHacker",
    "signature": "org.mockito.internal.creation.cglib.CGLIBHacker.reflectOnCreateInfo(MethodProxy)",
    "snippet": "    @SuppressWarnings(\"unchecked\")\n    private Field reflectOnCreateInfo(MethodProxy methodProxy) throws SecurityException, NoSuchFieldException {\n\n        Class cglibMethodProxyClass = methodProxy.getClass();\n        // in case methodProxy was extended by user, let's traverse the object\n        // graph to find the cglib methodProxy\n        // with all the fields we would like to change\n        while (cglibMethodProxyClass != MethodProxy.class) {\n            cglibMethodProxyClass = methodProxy.getClass().getSuperclass();\n        }\n        return cglibMethodProxyClass.getDeclaredField(\"createInfo\");\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "CGLIBHacker.setMockitoNamingPolicy",
    "class_name": "org.mockito.internal.creation.cglib.CGLIBHacker",
    "signature": "org.mockito.internal.creation.cglib.CGLIBHacker.setMockitoNamingPolicy(MockitoMethodProxy)",
    "snippet": "    public void setMockitoNamingPolicy(MockitoMethodProxy mockitoMethodProxy) {\n        try {\n            MethodProxy methodProxy = mockitoMethodProxy.getMethodProxy();\n            Field createInfoField = reflectOnCreateInfo(methodProxy);\n            createInfoField.setAccessible(true);\n            Object createInfo = createInfoField.get(methodProxy);\n            Field namingPolicyField = createInfo.getClass().getDeclaredField(\"namingPolicy\");\n            namingPolicyField.setAccessible(true);\n            if (namingPolicyField.get(createInfo) == null) {\n                namingPolicyField.set(createInfo, MockitoNamingPolicy.INSTANCE);\n            }\n        } catch (Exception e) {\n            throw new RuntimeException(\n                            \"Unable to set MockitoNamingPolicy on cglib generator which creates FastClasses\", e);\n        }\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "MockitoNamingPolicy.getTag",
    "class_name": "org.mockito.internal.creation.cglib.MockitoNamingPolicy",
    "signature": "org.mockito.internal.creation.cglib.MockitoNamingPolicy.getTag()",
    "snippet": "    @Override\n    protected String getTag() {\n        return \"ByMockitoWithCGLIB\";\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "ClassImposterizer.canImposterise",
    "class_name": "org.mockito.internal.creation.jmock.ClassImposterizer",
    "signature": "org.mockito.internal.creation.jmock.ClassImposterizer.canImposterise(Class)",
    "snippet": "    public boolean canImposterise(Class<?> type) {\n        return !type.isPrimitive() && !Modifier.isFinal(type.getModifiers());\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "ClassImposterizer.createProxy",
    "class_name": "org.mockito.internal.creation.jmock.ClassImposterizer",
    "signature": "org.mockito.internal.creation.jmock.ClassImposterizer.createProxy(Class,MethodInterceptor)",
    "snippet": "    private Object createProxy(Class<?> proxyClass, final MethodInterceptor interceptor) {\n        Factory proxy = (Factory) objenesis.newInstance(proxyClass);\n        proxy.setCallbacks(new Callback[] {interceptor, SerializableNoOp.SERIALIZABLE_INSTANCE });\n        return proxy;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "ClassImposterizer.setConstructorsAccessible",
    "class_name": "org.mockito.internal.creation.jmock.ClassImposterizer",
    "signature": "org.mockito.internal.creation.jmock.ClassImposterizer.setConstructorsAccessible(Class,boolean)",
    "snippet": "    private void setConstructorsAccessible(Class<?> mockedType, boolean accessible) {\n        for (Constructor<?> constructor : mockedType.getDeclaredConstructors()) {\n            constructor.setAccessible(accessible);\n        }\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "SearchingClassLoader.addIfNewElement",
    "class_name": "org.mockito.internal.creation.jmock.SearchingClassLoader",
    "signature": "org.mockito.internal.creation.jmock.SearchingClassLoader.addIfNewElement(List,ClassLoader)",
    "snippet": "    private static void addIfNewElement(List<ClassLoader> loaders, ClassLoader c) {\n        if (c != null && !loaders.contains(c)) {\n            loaders.add(c);\n        }\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "SearchingClassLoader.combine",
    "class_name": "org.mockito.internal.creation.jmock.SearchingClassLoader",
    "signature": "org.mockito.internal.creation.jmock.SearchingClassLoader.combine(List)",
    "snippet": "    private static ClassLoader combine(List<ClassLoader> parentLoaders) {\n        ClassLoader loader = parentLoaders.get(parentLoaders.size()-1);\n        \n        for (int i = parentLoaders.size()-2; i >= 0; i--) {\n            loader = new SearchingClassLoader(parentLoaders.get(i), loader);\n        }\n        \n        return loader;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "Localized.Localized",
    "class_name": "org.mockito.internal.debugging.Localized",
    "signature": "org.mockito.internal.debugging.Localized.Localized(T)",
    "snippet": "    public Localized(T object) {\n        this.object = object;\n        location = new Location();\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "Localized.getObject",
    "class_name": "org.mockito.internal.debugging.Localized",
    "signature": "org.mockito.internal.debugging.Localized.getObject()",
    "snippet": "    public T getObject() {\n        return object;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "Location.Location",
    "class_name": "org.mockito.internal.debugging.Location",
    "signature": "org.mockito.internal.debugging.Location.Location()",
    "snippet": "    public Location() {\n        this(new StackTraceFilter());\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "Location.Location",
    "class_name": "org.mockito.internal.debugging.Location",
    "signature": "org.mockito.internal.debugging.Location.Location(StackTraceFilter)",
    "snippet": "    public Location(StackTraceFilter stackTraceFilter) {\n        this.stackTraceFilter = stackTraceFilter;\n        stackTraceHolder = new Throwable();\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "ArgumentsComparator.argumentsMatch",
    "class_name": "org.mockito.internal.invocation.ArgumentsComparator",
    "signature": "org.mockito.internal.invocation.ArgumentsComparator.argumentsMatch(InvocationMatcher,Invocation)",
    "snippet": "    public boolean argumentsMatch(InvocationMatcher invocationMatcher, Invocation actual) {\n        Object[] actualArgs = actual.getArguments();\n        return argumentsMatch(invocationMatcher, actualArgs) || varArgsMatch(invocationMatcher, actual);\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "ArgumentsComparator.argumentsMatch",
    "class_name": "org.mockito.internal.invocation.ArgumentsComparator",
    "signature": "org.mockito.internal.invocation.ArgumentsComparator.argumentsMatch(InvocationMatcher,Object[])",
    "snippet": "    public boolean argumentsMatch(InvocationMatcher invocationMatcher, Object[] actualArgs) {\n        if (actualArgs.length != invocationMatcher.getMatchers().size()) {\n            return false;\n        }\n        for (int i = 0; i < actualArgs.length; i++) {\n            if (!invocationMatcher.getMatchers().get(i).matches(actualArgs[i])) {\n                return false;\n            }\n        }\n        return true;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "ArgumentsComparator.varArgsMatch",
    "class_name": "org.mockito.internal.invocation.ArgumentsComparator",
    "signature": "org.mockito.internal.invocation.ArgumentsComparator.varArgsMatch(InvocationMatcher,Invocation)",
    "snippet": "    private boolean varArgsMatch(InvocationMatcher invocationMatcher, Invocation actual) {\n        if (!actual.getMethod().isVarArgs()) {\n            //if the method is not vararg forget about it\n            return false;\n        }\n\n        //we must use raw arguments, not arguments...\n        Object[] rawArgs = actual.getRawArguments();\n        List<Matcher> matchers = invocationMatcher.getMatchers();\n\n        if (rawArgs.length != matchers.size()) {\n            return false;\n        }\n\n        for (int i = 0; i < rawArgs.length; i++) {\n            Matcher m = matchers.get(i);\n            //it's a vararg because it's the last array in the arg list\n            if (rawArgs[i] != null && rawArgs[i].getClass().isArray() && i == rawArgs.length-1) {\n                Matcher actualMatcher;\n                //this is necessary as the framework often decorates matchers\n                if (m instanceof MatcherDecorator) {\n                    actualMatcher = ((MatcherDecorator)m).getActualMatcher();\n                } else {\n                    actualMatcher = m;\n                }\n                //this is very important to only allow VarargMatchers here. If you're not sure why remove it and run all tests.\n                if (!(actualMatcher instanceof VarargMatcher) || !actualMatcher.matches(rawArgs[i])) {\n                    return false;\n                }\n            //it's not a vararg (i.e. some ordinary argument before varargs), just do the ordinary check\n            } else if (!m.matches(rawArgs[i])){\n                return false;\n            }\n        }\n\n        return true;\n    }",
    "comment": "ok, this method is a little bit messy but the vararg business unfortunately is messy...      ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "Invocation.Invocation",
    "class_name": "org.mockito.internal.invocation.Invocation",
    "signature": "org.mockito.internal.invocation.Invocation.Invocation(Object,MockitoMethod,Object[],int,RealMethod)",
    "snippet": "    public Invocation(Object mock, MockitoMethod mockitoMethod, Object[] args, int sequenceNumber, RealMethod realMethod) {\n        this.method = mockitoMethod;\n        this.mock = mock;\n        this.realMethod = realMethod;\n        this.arguments = expandVarArgs(mockitoMethod.isVarArgs(), args);\n        this.rawArguments = args;\n        this.sequenceNumber = sequenceNumber;\n        this.location = new Location();\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "Invocation.argumentsToMatchers",
    "class_name": "org.mockito.internal.invocation.Invocation",
    "signature": "org.mockito.internal.invocation.Invocation.argumentsToMatchers()",
    "snippet": "    protected List<Matcher> argumentsToMatchers() {\n        List<Matcher> matchers = new ArrayList<Matcher>(arguments.length);\n        for (Object arg : arguments) {\n            if (arg != null && arg.getClass().isArray()) {\n                matchers.add(new ArrayEquals(arg));\n            } else {\n                matchers.add(new Equals(arg));\n            }\n        }\n        return matchers;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "Invocation.expandVarArgs",
    "class_name": "org.mockito.internal.invocation.Invocation",
    "signature": "org.mockito.internal.invocation.Invocation.expandVarArgs(boolean,Object[])",
    "snippet": "    private static Object[] expandVarArgs(final boolean isVarArgs, final Object[] args) {\n        if (!isVarArgs || args[args.length - 1] != null && !args[args.length - 1].getClass().isArray()) {\n            return args == null ? new Object[0] : args;\n        }\n\n        final int nonVarArgsCount = args.length - 1;\n        Object[] varArgs;\n        if (args[nonVarArgsCount] == null) {\n            // in case someone deliberately passed null varArg array\n            varArgs = new Object[] { null };\n        } else {\n            varArgs = ArrayEquals.createObjectArray(args[nonVarArgsCount]);\n        }\n        final int varArgsCount = varArgs.length;\n        Object[] newArgs = new Object[nonVarArgsCount + varArgsCount];\n        System.arraycopy(args, 0, newArgs, 0, nonVarArgsCount);\n        System.arraycopy(varArgs, 0, newArgs, nonVarArgsCount, varArgsCount);\n        return newArgs;\n    }",
    "comment": "varArgs (1, a, b);",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "Invocation.getArguments",
    "class_name": "org.mockito.internal.invocation.Invocation",
    "signature": "org.mockito.internal.invocation.Invocation.getArguments()",
    "snippet": "    public Object[] getArguments() {\n        return arguments;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "Invocation.getArgumentsCount",
    "class_name": "org.mockito.internal.invocation.Invocation",
    "signature": "org.mockito.internal.invocation.Invocation.getArgumentsCount()",
    "snippet": "    public int getArgumentsCount() {\n        return arguments.length;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "Invocation.getMethod",
    "class_name": "org.mockito.internal.invocation.Invocation",
    "signature": "org.mockito.internal.invocation.Invocation.getMethod()",
    "snippet": "    public Method getMethod() {\n        return method.getJavaMethod();\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "Invocation.getMock",
    "class_name": "org.mockito.internal.invocation.Invocation",
    "signature": "org.mockito.internal.invocation.Invocation.getMock()",
    "snippet": "    public Object getMock() {\n        return mock;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "Invocation.isToString",
    "class_name": "org.mockito.internal.invocation.Invocation",
    "signature": "org.mockito.internal.invocation.Invocation.isToString()",
    "snippet": "    public boolean isToString() {\n        return new ObjectMethodsGuru().isToString(getMethod());\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "Invocation.isVerified",
    "class_name": "org.mockito.internal.invocation.Invocation",
    "signature": "org.mockito.internal.invocation.Invocation.isVerified()",
    "snippet": "    public boolean isVerified() {\n        return verified;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "InvocationMatcher.InvocationMatcher",
    "class_name": "org.mockito.internal.invocation.InvocationMatcher",
    "signature": "org.mockito.internal.invocation.InvocationMatcher.InvocationMatcher(Invocation,List)",
    "snippet": "    public InvocationMatcher(Invocation invocation, List<Matcher> matchers) {\n        this.invocation = invocation;\n        if (matchers.isEmpty()) {\n            this.matchers = invocation.argumentsToMatchers();\n        } else {\n            this.matchers = matchers;\n        }\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "InvocationMatcher.getInvocation",
    "class_name": "org.mockito.internal.invocation.InvocationMatcher",
    "signature": "org.mockito.internal.invocation.InvocationMatcher.getInvocation()",
    "snippet": "    public Invocation getInvocation() {\n        return this.invocation;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "InvocationMatcher.getMatchers",
    "class_name": "org.mockito.internal.invocation.InvocationMatcher",
    "signature": "org.mockito.internal.invocation.InvocationMatcher.getMatchers()",
    "snippet": "    public List<Matcher> getMatchers() {\n        return this.matchers;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "InvocationMatcher.getMethod",
    "class_name": "org.mockito.internal.invocation.InvocationMatcher",
    "signature": "org.mockito.internal.invocation.InvocationMatcher.getMethod()",
    "snippet": "    public Method getMethod() {\n        return invocation.getMethod();\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "InvocationMatcher.hasSameMethod",
    "class_name": "org.mockito.internal.invocation.InvocationMatcher",
    "signature": "org.mockito.internal.invocation.InvocationMatcher.hasSameMethod(Invocation)",
    "snippet": "    public boolean hasSameMethod(Invocation candidate) {        \n        //not using method.equals() for 1 good reason:\n        //sometimes java generates forwarding methods when generics are in play see JavaGenericsForwardingMethodsTest\n        Method m1 = invocation.getMethod();\n        Method m2 = candidate.getMethod();\n        \n        if (m1.getName() != null && m1.getName().equals(m2.getName())) {\n        \t/* Avoid unnecessary cloning */\n        \tClass[] params1 = m1.getParameterTypes();\n        \tClass[] params2 = m2.getParameterTypes();\n        \tif (params1.length == params2.length) {\n        \t    for (int i = 0; i < params1.length; i++) {\n        \t\tif (params1[i] != params2[i])\n        \t\t    return false;\n        \t    }\n        \t    return true;\n        \t}\n        }\n        return false;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "InvocationMatcher.hasSimilarMethod",
    "class_name": "org.mockito.internal.invocation.InvocationMatcher",
    "signature": "org.mockito.internal.invocation.InvocationMatcher.hasSimilarMethod(Invocation)",
    "snippet": "    public boolean hasSimilarMethod(Invocation candidate) {\n        String wantedMethodName = getMethod().getName();\n        String currentMethodName = candidate.getMethod().getName();\n        \n        final boolean methodNameEquals = wantedMethodName.equals(currentMethodName);\n        final boolean isUnverified = !candidate.isVerified();\n        final boolean mockIsTheSame = getInvocation().getMock() == candidate.getMock();\n        final boolean methodEquals = hasSameMethod(candidate);\n\n        if (!methodNameEquals || !isUnverified || !mockIsTheSame) {\n            return false;\n        }\n\n        final boolean overloadedButSameArgs = !methodEquals && safelyArgumentsMatch(candidate.getArguments());\n\n        return !overloadedButSameArgs;\n    }",
    "comment": " similar means the same method name, same mock, unverified  and: if arguments are the same cannot be overloaded ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "InvocationMatcher.matches",
    "class_name": "org.mockito.internal.invocation.InvocationMatcher",
    "signature": "org.mockito.internal.invocation.InvocationMatcher.matches(Invocation)",
    "snippet": "    public boolean matches(Invocation actual) {\n        return invocation.getMock().equals(actual.getMock())\n                && hasSameMethod(actual)\n                && new ArgumentsComparator().argumentsMatch(this, actual);\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "InvocationsFinder.findInvocations",
    "class_name": "org.mockito.internal.invocation.InvocationsFinder",
    "signature": "org.mockito.internal.invocation.InvocationsFinder.findInvocations(List,InvocationMatcher)",
    "snippet": "    public List<Invocation> findInvocations(List<Invocation> invocations, InvocationMatcher wanted) {\n        return ListUtil.filter(invocations, new RemoveNotMatching(wanted));\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "InvocationsFinder.findSimilarInvocation",
    "class_name": "org.mockito.internal.invocation.InvocationsFinder",
    "signature": "org.mockito.internal.invocation.InvocationsFinder.findSimilarInvocation(List,InvocationMatcher)",
    "snippet": "    public Invocation findSimilarInvocation(List<Invocation> invocations, InvocationMatcher wanted) {\n        Invocation firstSimilar = null;\n        for (Invocation invocation : invocations) {\n            if (!wanted.hasSimilarMethod(invocation)) {\n                continue;\n            }\n            if (firstSimilar == null) {\n                firstSimilar = invocation;\n            }\n            if (wanted.hasSameMethod(invocation)) {\n                return invocation;\n            }\n        }\n        \n        return firstSimilar;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "RemoveNotMatching.isOut",
    "class_name": "org.mockito.internal.invocation.InvocationsFinder$RemoveNotMatching",
    "signature": "org.mockito.internal.invocation.InvocationsFinder$RemoveNotMatching.isOut(Invocation)",
    "snippet": "        public boolean isOut(Invocation invocation) {\n            return !wanted.matches(invocation);\n        }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "MatchersBinder.bindMatchers",
    "class_name": "org.mockito.internal.invocation.MatchersBinder",
    "signature": "org.mockito.internal.invocation.MatchersBinder.bindMatchers(ArgumentMatcherStorage,Invocation)",
    "snippet": "    public InvocationMatcher bindMatchers(ArgumentMatcherStorage argumentMatcherStorage, Invocation invocation) {\n        List<Matcher> lastMatchers = argumentMatcherStorage.pullMatchers();\n        validateMatchers(invocation, lastMatchers);\n\n        InvocationMatcher invocationWithMatchers = new InvocationMatcher(invocation, lastMatchers);\n        return invocationWithMatchers;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "MatchersBinder.validateMatchers",
    "class_name": "org.mockito.internal.invocation.MatchersBinder",
    "signature": "org.mockito.internal.invocation.MatchersBinder.validateMatchers(Invocation,List)",
    "snippet": "    private void validateMatchers(Invocation invocation, List<Matcher> matchers) {\n        if (!matchers.isEmpty()) {\n            int recordedMatchersSize = matchers.size();\n            int expectedMatchersSize = invocation.getArgumentsCount();\n            if (expectedMatchersSize != recordedMatchersSize) {\n                new Reporter().invalidUseOfMatchers(expectedMatchersSize, recordedMatchersSize);\n            }\n        }\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "CGLIBProxyRealMethod.CGLIBProxyRealMethod",
    "class_name": "org.mockito.internal.invocation.realmethod.CGLIBProxyRealMethod",
    "signature": "org.mockito.internal.invocation.realmethod.CGLIBProxyRealMethod.CGLIBProxyRealMethod(MockitoMethodProxy)",
    "snippet": "    public CGLIBProxyRealMethod(MockitoMethodProxy methodProxy) {\n        this.methodProxy = methodProxy;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "FilteredCGLIBProxyRealMethod.FilteredCGLIBProxyRealMethod",
    "class_name": "org.mockito.internal.invocation.realmethod.FilteredCGLIBProxyRealMethod",
    "signature": "org.mockito.internal.invocation.realmethod.FilteredCGLIBProxyRealMethod.FilteredCGLIBProxyRealMethod(MockitoMethodProxy)",
    "snippet": "    public FilteredCGLIBProxyRealMethod(MockitoMethodProxy methodProxy) {\n        this(new CGLIBProxyRealMethod(methodProxy));\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "FilteredCGLIBProxyRealMethod.FilteredCGLIBProxyRealMethod",
    "class_name": "org.mockito.internal.invocation.realmethod.FilteredCGLIBProxyRealMethod",
    "signature": "org.mockito.internal.invocation.realmethod.FilteredCGLIBProxyRealMethod.FilteredCGLIBProxyRealMethod(RealMethod)",
    "snippet": "    public FilteredCGLIBProxyRealMethod(RealMethod realMethod) {\n        this.realMethod = realMethod;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "Equals.Equals",
    "class_name": "org.mockito.internal.matchers.Equals",
    "signature": "org.mockito.internal.matchers.Equals.Equals(Object)",
    "snippet": "    public Equals(Object wanted) {\n        this.wanted = wanted;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "LocalizedMatcher.LocalizedMatcher",
    "class_name": "org.mockito.internal.matchers.LocalizedMatcher",
    "signature": "org.mockito.internal.matchers.LocalizedMatcher.LocalizedMatcher(Matcher)",
    "snippet": "    public LocalizedMatcher(Matcher actualMatcher) {\n        this.actualMatcher = actualMatcher;\n        this.location = new Location();\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "LocalizedMatcher.describeTo",
    "class_name": "org.mockito.internal.matchers.LocalizedMatcher",
    "signature": "org.mockito.internal.matchers.LocalizedMatcher.describeTo(Description)",
    "snippet": "    public void describeTo(Description description) {\n        actualMatcher.describeTo(description);\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "LocalizedMatcher.matches",
    "class_name": "org.mockito.internal.matchers.LocalizedMatcher",
    "signature": "org.mockito.internal.matchers.LocalizedMatcher.matches(Object)",
    "snippet": "    public boolean matches(Object item) {\n        return actualMatcher.matches(item);\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "Same.Same",
    "class_name": "org.mockito.internal.matchers.Same",
    "signature": "org.mockito.internal.matchers.Same.Same(Object)",
    "snippet": "    public Same(Object wanted) {\n        this.wanted = wanted;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "Same.appendQuoting",
    "class_name": "org.mockito.internal.matchers.Same",
    "signature": "org.mockito.internal.matchers.Same.appendQuoting(Description)",
    "snippet": "    private void appendQuoting(Description description) {\n        if (wanted instanceof String) {\n            description.appendText(\"\\\"\");\n        } else if (wanted instanceof Character) {\n            description.appendText(\"'\");\n        }\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "Same.describeTo",
    "class_name": "org.mockito.internal.matchers.Same",
    "signature": "org.mockito.internal.matchers.Same.describeTo(Description)",
    "snippet": "    public void describeTo(Description description) {\n        description.appendText(\"same(\");\n        appendQuoting(description);\n        description.appendText(wanted.toString());\n        appendQuoting(description);\n        description.appendText(\")\");\n    }",
    "comment": "",
    "is_bug": true,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "Same.matches",
    "class_name": "org.mockito.internal.matchers.Same",
    "signature": "org.mockito.internal.matchers.Same.matches(Object)",
    "snippet": "    public boolean matches(Object actual) {\n        return wanted == actual;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "ArgumentMatcherStorageImpl.pullMatchers",
    "class_name": "org.mockito.internal.progress.ArgumentMatcherStorageImpl",
    "signature": "org.mockito.internal.progress.ArgumentMatcherStorageImpl.pullMatchers()",
    "snippet": "    public List<Matcher> pullMatchers() {\n        if (matcherStack.isEmpty()) {\n            return Collections.emptyList();\n        }\n        \n        List<LocalizedMatcher> matchers = new ArrayList<LocalizedMatcher>(matcherStack);\n        matcherStack.clear();\n        return (List) matchers;\n    }",
    "comment": "(non-Javadoc) @see org.mockito.internal.progress.ArgumentMatcherStorage#pullMatchers() ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "ArgumentMatcherStorageImpl.reportMatcher",
    "class_name": "org.mockito.internal.progress.ArgumentMatcherStorageImpl",
    "signature": "org.mockito.internal.progress.ArgumentMatcherStorageImpl.reportMatcher(Matcher)",
    "snippet": "    public HandyReturnValues reportMatcher(Matcher matcher) {\n        matcherStack.push(new LocalizedMatcher(matcher));\n        return new HandyReturnValues();\n    }",
    "comment": "(non-Javadoc) @see org.mockito.internal.progress.ArgumentMatcherStorage#reportMatcher(org.hamcrest.Matcher) ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "ArgumentMatcherStorageImpl.reset",
    "class_name": "org.mockito.internal.progress.ArgumentMatcherStorageImpl",
    "signature": "org.mockito.internal.progress.ArgumentMatcherStorageImpl.reset()",
    "snippet": "    public void reset() {\n        matcherStack.clear();\n    }",
    "comment": "(non-Javadoc) @see org.mockito.internal.progress.ArgumentMatcherStorage#reset() ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "ArgumentMatcherStorageImpl.validateState",
    "class_name": "org.mockito.internal.progress.ArgumentMatcherStorageImpl",
    "signature": "org.mockito.internal.progress.ArgumentMatcherStorageImpl.validateState()",
    "snippet": "    public void validateState() {\n        if (!matcherStack.isEmpty()) {\n            LocalizedMatcher lastMatcher = matcherStack.lastElement();\n            matcherStack.clear();\n            new Reporter().misplacedArgumentMatcher(lastMatcher.getLocation());\n        }\n    }",
    "comment": "(non-Javadoc) @see org.mockito.internal.progress.ArgumentMatcherStorage#validateState() ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "HandyReturnValues.returnFor",
    "class_name": "org.mockito.internal.progress.HandyReturnValues",
    "signature": "org.mockito.internal.progress.HandyReturnValues.returnFor(Class)",
    "snippet": "    public <T> T returnFor(Class<T> clazz) {\n        if (isPrimitiveWrapper(clazz)) {\n            return primitiveWrapperOf(clazz);\n        } \n        return primitiveValueOrNullFor(clazz);\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "MockingProgressImpl.getArgumentMatcherStorage",
    "class_name": "org.mockito.internal.progress.MockingProgressImpl",
    "signature": "org.mockito.internal.progress.MockingProgressImpl.getArgumentMatcherStorage()",
    "snippet": "    public ArgumentMatcherStorage getArgumentMatcherStorage() {\n        return argumentMatcherStorage;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "MockingProgressImpl.mockingStarted",
    "class_name": "org.mockito.internal.progress.MockingProgressImpl",
    "signature": "org.mockito.internal.progress.MockingProgressImpl.mockingStarted(Object,Class,MockSettings)",
    "snippet": "    public void mockingStarted(Object mock, Class classToMock, MockSettings mockSettings) {\n        if (listener != null && listener instanceof MockingStartedListener) {\n            ((MockingStartedListener) listener).mockingStarted(mock, classToMock, mockSettings);\n        }\n        validateMostStuff();\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "MockingProgressImpl.pullVerificationMode",
    "class_name": "org.mockito.internal.progress.MockingProgressImpl",
    "signature": "org.mockito.internal.progress.MockingProgressImpl.pullVerificationMode()",
    "snippet": "    public VerificationMode pullVerificationMode() {\n        if (verificationMode == null) {\n            return null;\n        }\n        \n        VerificationMode temp = verificationMode.getObject();\n        verificationMode = null;\n        return temp;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "MockingProgressImpl.reportOngoingStubbing",
    "class_name": "org.mockito.internal.progress.MockingProgressImpl",
    "signature": "org.mockito.internal.progress.MockingProgressImpl.reportOngoingStubbing(IOngoingStubbing)",
    "snippet": "    public void reportOngoingStubbing(IOngoingStubbing iOngoingStubbing) {\n        this.iOngoingStubbing = iOngoingStubbing;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "MockingProgressImpl.reset",
    "class_name": "org.mockito.internal.progress.MockingProgressImpl",
    "signature": "org.mockito.internal.progress.MockingProgressImpl.reset()",
    "snippet": "    public void reset() {\n        stubbingInProgress = null;\n        verificationMode = null;\n        getArgumentMatcherStorage().reset();\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "MockingProgressImpl.resetOngoingStubbing",
    "class_name": "org.mockito.internal.progress.MockingProgressImpl",
    "signature": "org.mockito.internal.progress.MockingProgressImpl.resetOngoingStubbing()",
    "snippet": "    public void resetOngoingStubbing() {\n        iOngoingStubbing = null;\n    }",
    "comment": "(non-Javadoc) @see org.mockito.internal.progress.MockingProgress#resetOngoingStubbing() ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "MockingProgressImpl.validateMostStuff",
    "class_name": "org.mockito.internal.progress.MockingProgressImpl",
    "signature": "org.mockito.internal.progress.MockingProgressImpl.validateMostStuff()",
    "snippet": "    private void validateMostStuff() {\n        //State is cool when GlobalConfiguration is already loaded\n        //this cannot really be tested functionally because I cannot dynamically mess up org.mockito.configuration.MockitoConfiguration class\n        GlobalConfiguration.validate();\n\n        if (verificationMode != null) {\n            Location location = verificationMode.getLocation();\n            verificationMode = null;\n            reporter.unfinishedVerificationException(location);\n        }\n\n        getArgumentMatcherStorage().validateState();\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "MockingProgressImpl.validateState",
    "class_name": "org.mockito.internal.progress.MockingProgressImpl",
    "signature": "org.mockito.internal.progress.MockingProgressImpl.validateState()",
    "snippet": "    public void validateState() {\n        validateMostStuff();\n        \n        //validate stubbing:\n        if (stubbingInProgress != null) {\n            Location temp = stubbingInProgress;\n            stubbingInProgress = null;\n            reporter.unfinishedStubbing(temp);\n        }\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "MockingProgressImpl.verificationStarted",
    "class_name": "org.mockito.internal.progress.MockingProgressImpl",
    "signature": "org.mockito.internal.progress.MockingProgressImpl.verificationStarted(VerificationMode)",
    "snippet": "    public void verificationStarted(VerificationMode verify) {\n        validateState();\n        resetOngoingStubbing();\n        verificationMode = new Localized(verify);\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "SequenceNumber.next",
    "class_name": "org.mockito.internal.progress.SequenceNumber",
    "signature": "org.mockito.internal.progress.SequenceNumber.next()",
    "snippet": "    public static synchronized int next() {\n        return sequenceNumber++;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "ThreadSafeMockingProgress.getArgumentMatcherStorage",
    "class_name": "org.mockito.internal.progress.ThreadSafeMockingProgress",
    "signature": "org.mockito.internal.progress.ThreadSafeMockingProgress.getArgumentMatcherStorage()",
    "snippet": "    public ArgumentMatcherStorage getArgumentMatcherStorage() {\n        return threadSafely().getArgumentMatcherStorage();\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "ThreadSafeMockingProgress.mockingStarted",
    "class_name": "org.mockito.internal.progress.ThreadSafeMockingProgress",
    "signature": "org.mockito.internal.progress.ThreadSafeMockingProgress.mockingStarted(Object,Class,MockSettings)",
    "snippet": "    public void mockingStarted(Object mock, Class classToMock, MockSettings mockSettings) {\n        threadSafely().mockingStarted(mock, classToMock, mockSettings);\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "ThreadSafeMockingProgress.pullVerificationMode",
    "class_name": "org.mockito.internal.progress.ThreadSafeMockingProgress",
    "signature": "org.mockito.internal.progress.ThreadSafeMockingProgress.pullVerificationMode()",
    "snippet": "    public VerificationMode pullVerificationMode() {\n        return threadSafely().pullVerificationMode();\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "ThreadSafeMockingProgress.reportOngoingStubbing",
    "class_name": "org.mockito.internal.progress.ThreadSafeMockingProgress",
    "signature": "org.mockito.internal.progress.ThreadSafeMockingProgress.reportOngoingStubbing(IOngoingStubbing)",
    "snippet": "    public void reportOngoingStubbing(IOngoingStubbing iOngoingStubbing) {\n        threadSafely().reportOngoingStubbing(iOngoingStubbing);\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "ThreadSafeMockingProgress.reset",
    "class_name": "org.mockito.internal.progress.ThreadSafeMockingProgress",
    "signature": "org.mockito.internal.progress.ThreadSafeMockingProgress.reset()",
    "snippet": "    public void reset() {\n        threadSafely().reset();\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "ThreadSafeMockingProgress.threadSafely",
    "class_name": "org.mockito.internal.progress.ThreadSafeMockingProgress",
    "signature": "org.mockito.internal.progress.ThreadSafeMockingProgress.threadSafely()",
    "snippet": "    static MockingProgress threadSafely() {\n        if (mockingProgress.get() == null) {\n            mockingProgress.set(new MockingProgressImpl());\n        }\n        return mockingProgress.get();\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "ThreadSafeMockingProgress.validateState",
    "class_name": "org.mockito.internal.progress.ThreadSafeMockingProgress",
    "signature": "org.mockito.internal.progress.ThreadSafeMockingProgress.validateState()",
    "snippet": "    public void validateState() {\n        threadSafely().validateState();\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "ThreadSafeMockingProgress.verificationStarted",
    "class_name": "org.mockito.internal.progress.ThreadSafeMockingProgress",
    "signature": "org.mockito.internal.progress.ThreadSafeMockingProgress.verificationStarted(VerificationMode)",
    "snippet": "    public void verificationStarted(VerificationMode verify) {\n        threadSafely().verificationStarted(verify);\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "InvocationContainerImpl.InvocationContainerImpl",
    "class_name": "org.mockito.internal.stubbing.InvocationContainerImpl",
    "signature": "org.mockito.internal.stubbing.InvocationContainerImpl.InvocationContainerImpl(MockingProgress)",
    "snippet": "    public InvocationContainerImpl(MockingProgress mockingProgress) {\n        this.mockingProgress = mockingProgress;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "InvocationContainerImpl.findAnswerFor",
    "class_name": "org.mockito.internal.stubbing.InvocationContainerImpl",
    "signature": "org.mockito.internal.stubbing.InvocationContainerImpl.findAnswerFor(Invocation)",
    "snippet": "    public StubbedInvocationMatcher findAnswerFor(Invocation invocation) {\n        synchronized (stubbed) {\n            for (StubbedInvocationMatcher s : stubbed) {\n                if (s.matches(invocation)) {\n                    s.markStubUsed(invocation);\n                    invocation.markStubbed(new StubInfo(s));\n                    return s;\n                }\n            }\n        }\n\n        return null;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "InvocationContainerImpl.getInvocations",
    "class_name": "org.mockito.internal.stubbing.InvocationContainerImpl",
    "signature": "org.mockito.internal.stubbing.InvocationContainerImpl.getInvocations()",
    "snippet": "    public List<Invocation> getInvocations() {\n        return registeredInvocations.getAll();\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "InvocationContainerImpl.hasAnswersForStubbing",
    "class_name": "org.mockito.internal.stubbing.InvocationContainerImpl",
    "signature": "org.mockito.internal.stubbing.InvocationContainerImpl.hasAnswersForStubbing()",
    "snippet": "    public boolean hasAnswersForStubbing() {\n        return !answersForStubbing.isEmpty();\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "InvocationContainerImpl.resetInvocationForPotentialStubbing",
    "class_name": "org.mockito.internal.stubbing.InvocationContainerImpl",
    "signature": "org.mockito.internal.stubbing.InvocationContainerImpl.resetInvocationForPotentialStubbing(InvocationMatcher)",
    "snippet": "    public void resetInvocationForPotentialStubbing(InvocationMatcher invocationMatcher) {\n        this.invocationForStubbing = invocationMatcher;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "InvocationContainerImpl.setInvocationForPotentialStubbing",
    "class_name": "org.mockito.internal.stubbing.InvocationContainerImpl",
    "signature": "org.mockito.internal.stubbing.InvocationContainerImpl.setInvocationForPotentialStubbing(InvocationMatcher)",
    "snippet": "    public void setInvocationForPotentialStubbing(InvocationMatcher invocation) {\n        registeredInvocations.add(invocation.getInvocation());\n        this.invocationForStubbing = invocation;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "OngoingStubbingImpl.OngoingStubbingImpl",
    "class_name": "org.mockito.internal.stubbing.OngoingStubbingImpl",
    "signature": "org.mockito.internal.stubbing.OngoingStubbingImpl.OngoingStubbingImpl(InvocationContainerImpl)",
    "snippet": "    public OngoingStubbingImpl(InvocationContainerImpl invocationContainerImpl) {\n        this.invocationContainerImpl = invocationContainerImpl;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "GloballyConfiguredAnswer.answer",
    "class_name": "org.mockito.internal.stubbing.defaultanswers.GloballyConfiguredAnswer",
    "signature": "org.mockito.internal.stubbing.defaultanswers.GloballyConfiguredAnswer.answer(InvocationOnMock)",
    "snippet": "    public Object answer(InvocationOnMock invocation) throws Throwable {\n        return new GlobalConfiguration().getDefaultAnswer().answer(invocation);\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "ReturnsEmptyValues.answer",
    "class_name": "org.mockito.internal.stubbing.defaultanswers.ReturnsEmptyValues",
    "signature": "org.mockito.internal.stubbing.defaultanswers.ReturnsEmptyValues.answer(InvocationOnMock)",
    "snippet": "    public Object answer(InvocationOnMock invocation) {\n        if (methodsGuru.isToString(invocation.getMethod())) {\n            Object mock = invocation.getMock();\n            MockName name = new MockUtil().getMockName(mock);\n            if (name.isSurrogate()) {\n                return \"Mock for \" + ClassNameFinder.classNameForMock(mock) + \", hashCode: \" + mock.hashCode();\n            } else {\n                return name.toString();\n            }\n        } else if (methodsGuru.isCompareToMethod(invocation.getMethod())) {\n            //see issue 184.\n            //mocks by default should not return 0 for compareTo because they are not the same. Hence we return 1 (anything but 0 is good).\n            //Only for compareTo() method by the Comparable interface\n            return 1;\n        }\n        \n        Class<?> returnType = invocation.getMethod().getReturnType();\n        return returnValueFor(returnType);\n    }",
    "comment": "(non-Javadoc) @see org.mockito.stubbing.Answer#answer(org.mockito.invocation.InvocationOnMock) ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "ReturnsEmptyValues.returnValueFor",
    "class_name": "org.mockito.internal.stubbing.defaultanswers.ReturnsEmptyValues",
    "signature": "org.mockito.internal.stubbing.defaultanswers.ReturnsEmptyValues.returnValueFor(Class)",
    "snippet": "    Object returnValueFor(Class<?> type) {\n        if (type.isPrimitive()) {\n            return primitiveOf(type);\n        } else if (Primitives.isPrimitiveWrapper(type)) {\n            return Primitives.primitiveWrapperOf(type);\n        //new instances are used instead of Collections.emptyList(), etc.\n        //to avoid UnsupportedOperationException if code under test modifies returned collection\n        } else if (type == Collection.class) {\n            return new LinkedList<Object>();\n        } else if (type == Set.class) {\n            return new HashSet<Object>();\n        } else if (type == HashSet.class) {\n            return new HashSet<Object>();\n        } else if (type == SortedSet.class) {\n            return new TreeSet<Object>();\n        } else if (type == TreeSet.class) {\n            return new TreeSet<Object>();\n        } else if (type == LinkedHashSet.class) {\n            return new LinkedHashSet<Object>();\n        } else if (type == List.class) {\n            return new LinkedList<Object>();\n        } else if (type == LinkedList.class) {\n            return new LinkedList<Object>();\n        } else if (type == ArrayList.class) {\n            return new ArrayList<Object>();\n        } else if (type == Map.class) {\n            return new HashMap<Object, Object>();\n        } else if (type == HashMap.class) {\n            return new HashMap<Object, Object>();\n        } else if (type == SortedMap.class) {\n            return new TreeMap<Object, Object>();\n        } else if (type == TreeMap.class) {\n            return new TreeMap<Object, Object>();\n        } else if (type == LinkedHashMap.class) {\n            return new LinkedHashMap<Object, Object>();\n        }       \n        //Let's not care about the rest of collections.\n        return null;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "ListUtil.filter",
    "class_name": "org.mockito.internal.util.ListUtil",
    "signature": "org.mockito.internal.util.ListUtil.filter(Collection,Filter)",
    "snippet": "    public static <T> LinkedList<T> filter(Collection<T> collection, Filter<T> filter) {\n        LinkedList<T> filtered = new LinkedList<T>();\n        for (T t : collection) {\n            if (!filter.isOut(t)) {\n                filtered.add(t);\n            }\n        }\n        return filtered;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "MockCreationValidator.isTypeMockable",
    "class_name": "org.mockito.internal.util.MockCreationValidator",
    "signature": "org.mockito.internal.util.MockCreationValidator.isTypeMockable(Class)",
    "snippet": "    public boolean isTypeMockable(Class<?> clz) {\n        return ClassImposterizer.INSTANCE.canImposterise(clz);\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "MockCreationValidator.validateExtraInterfaces",
    "class_name": "org.mockito.internal.util.MockCreationValidator",
    "signature": "org.mockito.internal.util.MockCreationValidator.validateExtraInterfaces(Class,Class[])",
    "snippet": "    public void validateExtraInterfaces(Class classToMock, Class ... extraInterfaces) {\n        if (extraInterfaces == null) {\n            return;\n        }\n        \n        for (Class i : extraInterfaces) {\n            if (classToMock == i) {\n                new Reporter().extraInterfacesCannotContainMockedType(classToMock);\n            }\n        }\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "MockCreationValidator.validateMockedType",
    "class_name": "org.mockito.internal.util.MockCreationValidator",
    "signature": "org.mockito.internal.util.MockCreationValidator.validateMockedType(Class,Object)",
    "snippet": "    public void validateMockedType(Class classToMock, Object spiedInstance) {\n        if (classToMock == null || spiedInstance == null) {\n            return;\n        }\n        if (!classToMock.equals(spiedInstance.getClass())) {\n            new Reporter().mockedTypeIsInconsistentWithSpiedInstanceType(classToMock, spiedInstance);\n        }\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "MockCreationValidator.validateType",
    "class_name": "org.mockito.internal.util.MockCreationValidator",
    "signature": "org.mockito.internal.util.MockCreationValidator.validateType(Class)",
    "snippet": "    public void validateType(Class classToMock) {\n        if (!isTypeMockable(classToMock)) {\n            new Reporter().cannotMockFinalClass(classToMock);\n        }\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "MockName.MockName",
    "class_name": "org.mockito.internal.util.MockName",
    "signature": "org.mockito.internal.util.MockName.MockName(String,Class)",
    "snippet": "    @SuppressWarnings(\"unchecked\")\n    public MockName(String mockName, Class classToMock) {\n        if (mockName == null) {\n            this.mockName = toInstanceName(classToMock);\n            this.surrogate = true;\n        } else {\n            this.mockName = mockName;\n        }\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "MockUtil.MockUtil",
    "class_name": "org.mockito.internal.util.MockUtil",
    "signature": "org.mockito.internal.util.MockUtil.MockUtil()",
    "snippet": "    public MockUtil() {\n        this(new MockCreationValidator());\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "MockUtil.MockUtil",
    "class_name": "org.mockito.internal.util.MockUtil",
    "signature": "org.mockito.internal.util.MockUtil.MockUtil(MockCreationValidator)",
    "snippet": "    public MockUtil(MockCreationValidator creationValidator) {\n        this.creationValidator = creationValidator;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "MockUtil.createMock",
    "class_name": "org.mockito.internal.util.MockUtil",
    "signature": "org.mockito.internal.util.MockUtil.createMock(Class,MockSettingsImpl)",
    "snippet": "    public <T> T createMock(Class<T> classToMock, MockSettingsImpl settings) {\n        creationValidator.validateType(classToMock);\n        creationValidator.validateExtraInterfaces(classToMock, settings.getExtraInterfaces());\n        creationValidator.validateMockedType(classToMock, settings.getSpiedInstance());\n\n        settings.initiateMockName(classToMock);\n\n        MockHandler<T> mockHandler = new MockHandler<T>(settings);\n        MethodInterceptorFilter filter = new MethodInterceptorFilter(mockHandler, settings);\n        Class<?>[] interfaces = settings.getExtraInterfaces();\n\n        Class<?>[] ancillaryTypes;\n        if (settings.isSerializable()) {\n            ancillaryTypes = interfaces == null ? new Class<?>[] {Serializable.class} : new ArrayUtils().concat(interfaces, Serializable.class);\n        } else {\n            ancillaryTypes = interfaces == null ? new Class<?>[0] : interfaces;\n        }\n\n        Object spiedInstance = settings.getSpiedInstance();\n        \n        T mock = ClassImposterizer.INSTANCE.imposterise(filter, classToMock, ancillaryTypes);\n        \n        if (spiedInstance != null) {\n            new LenientCopyTool().copyToMock(spiedInstance, mock);\n        }\n        \n        return mock;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "MockUtil.getInterceptor",
    "class_name": "org.mockito.internal.util.MockUtil",
    "signature": "org.mockito.internal.util.MockUtil.getInterceptor(T)",
    "snippet": "    private <T> MethodInterceptorFilter getInterceptor(T mock) {\n        if (!(mock instanceof Factory)) {\n            return null;\n        }\n        Factory factory = (Factory) mock;\n        Callback callback = factory.getCallback(0);\n        if (callback instanceof MethodInterceptorFilter) {\n            return (MethodInterceptorFilter) callback;\n        }\n        return null;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "MockUtil.isMock",
    "class_name": "org.mockito.internal.util.MockUtil",
    "signature": "org.mockito.internal.util.MockUtil.isMock(Object)",
    "snippet": "    public boolean isMock(Object mock) {\n        return mock != null && isMockitoMock(mock);\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "MockUtil.isMockitoMock",
    "class_name": "org.mockito.internal.util.MockUtil",
    "signature": "org.mockito.internal.util.MockUtil.isMockitoMock(T)",
    "snippet": "    private <T> boolean isMockitoMock(T mock) {\n        return getInterceptor(mock) != null;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "ObjectMethodsGuru.isCompareToMethod",
    "class_name": "org.mockito.internal.util.ObjectMethodsGuru",
    "signature": "org.mockito.internal.util.ObjectMethodsGuru.isCompareToMethod(Method)",
    "snippet": "    public boolean isCompareToMethod(Method method) {\n        return Comparable.class.isAssignableFrom(method.getDeclaringClass()) && method.getName().equals(\"compareTo\")\n                && method.getParameterTypes().length == 1 && method.getParameterTypes()[0] == method.getDeclaringClass();\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "ObjectMethodsGuru.isEqualsMethod",
    "class_name": "org.mockito.internal.util.ObjectMethodsGuru",
    "signature": "org.mockito.internal.util.ObjectMethodsGuru.isEqualsMethod(Method)",
    "snippet": "    public boolean isEqualsMethod(Method method) {\n        return method.getName().equals(\"equals\") && method.getParameterTypes().length == 1 && method.getParameterTypes()[0] == Object.class;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "ObjectMethodsGuru.isHashCodeMethod",
    "class_name": "org.mockito.internal.util.ObjectMethodsGuru",
    "signature": "org.mockito.internal.util.ObjectMethodsGuru.isHashCodeMethod(Method)",
    "snippet": "    public boolean isHashCodeMethod(Method method) {\n        return method.getName().equals(\"hashCode\") && method.getParameterTypes().length == 0;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "ObjectMethodsGuru.isToString",
    "class_name": "org.mockito.internal.util.ObjectMethodsGuru",
    "signature": "org.mockito.internal.util.ObjectMethodsGuru.isToString(Method)",
    "snippet": "    public boolean isToString(Method method) {\n        return isToString(new DelegatingMethod(method));\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "ObjectMethodsGuru.isToString",
    "class_name": "org.mockito.internal.util.ObjectMethodsGuru",
    "signature": "org.mockito.internal.util.ObjectMethodsGuru.isToString(MockitoMethod)",
    "snippet": "    public boolean isToString(MockitoMethod method) {\n        return method.getReturnType() == String.class && method.getParameterTypes().length == 0\n                && method.getName().equals(\"toString\");\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "Primitives.isPrimitiveWrapper",
    "class_name": "org.mockito.internal.util.Primitives",
    "signature": "org.mockito.internal.util.Primitives.isPrimitiveWrapper(Class)",
    "snippet": "    public static boolean isPrimitiveWrapper(Class<?> type) {\n        return wrapperReturnValues.containsKey(type);\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "AccessibilityChanger.enableAccess",
    "class_name": "org.mockito.internal.util.reflection.AccessibilityChanger",
    "signature": "org.mockito.internal.util.reflection.AccessibilityChanger.enableAccess(AccessibleObject)",
    "snippet": "    public void enableAccess(AccessibleObject accessibleObject) {\n        wasAccessible = accessibleObject.isAccessible();\n        accessibleObject.setAccessible(true);\n    }",
    "comment": " changes the accessibleObject accessibility and returns true if accessibility was changed ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "AccessibilityChanger.safelyDisableAccess",
    "class_name": "org.mockito.internal.util.reflection.AccessibilityChanger",
    "signature": "org.mockito.internal.util.reflection.AccessibilityChanger.safelyDisableAccess(AccessibleObject)",
    "snippet": "    public void safelyDisableAccess(AccessibleObject accessibleObject) {\n        assert wasAccessible != null;\n        try {\n            accessibleObject.setAccessible(wasAccessible);\n        } catch (Throwable t) {\n            //ignore\n        }\n    }",
    "comment": " safely disables access ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "FieldSetter.FieldSetter",
    "class_name": "org.mockito.internal.util.reflection.FieldSetter",
    "signature": "org.mockito.internal.util.reflection.FieldSetter.FieldSetter(Object,Field)",
    "snippet": "    public FieldSetter(Object target, Field field) {\n        this.target = target;\n        this.field = field;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "FieldSetter.set",
    "class_name": "org.mockito.internal.util.reflection.FieldSetter",
    "signature": "org.mockito.internal.util.reflection.FieldSetter.set(Object)",
    "snippet": "    public void set(Object value) {\n        AccessibilityChanger changer = new AccessibilityChanger();\n        changer.enableAccess(field);\n        try {\n            field.set(target, value);\n        } catch (Exception e) {\n            throw new RuntimeException(\"Problems setting value: [\" + value + \"] on object: [\" + target + \"] at field: [\" + field + \"]\");\n        }\n        changer.safelyDisableAccess(field);\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "MockAwareVerificationMode.MockAwareVerificationMode",
    "class_name": "org.mockito.internal.verification.MockAwareVerificationMode",
    "signature": "org.mockito.internal.verification.MockAwareVerificationMode.MockAwareVerificationMode(Object,VerificationMode)",
    "snippet": "    public MockAwareVerificationMode(Object mock, VerificationMode mode) {\n        this.mock = mock;\n        this.mode = mode;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "MockAwareVerificationMode.getMock",
    "class_name": "org.mockito.internal.verification.MockAwareVerificationMode",
    "signature": "org.mockito.internal.verification.MockAwareVerificationMode.getMock()",
    "snippet": "    public Object getMock() {\n        return mock;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "MockAwareVerificationMode.verify",
    "class_name": "org.mockito.internal.verification.MockAwareVerificationMode",
    "signature": "org.mockito.internal.verification.MockAwareVerificationMode.verify(VerificationData)",
    "snippet": "    public void verify(VerificationData data) {\n        mode.verify(data);\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "RegisteredInvocations.add",
    "class_name": "org.mockito.internal.verification.RegisteredInvocations",
    "signature": "org.mockito.internal.verification.RegisteredInvocations.add(Invocation)",
    "snippet": "    public void add(Invocation invocation) {\n        invocations.add(invocation);\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "RegisteredInvocations.getAll",
    "class_name": "org.mockito.internal.verification.RegisteredInvocations",
    "signature": "org.mockito.internal.verification.RegisteredInvocations.getAll()",
    "snippet": "    public List<Invocation> getAll() {\n        return ListUtil.filter(new LinkedList<Invocation>(invocations), new RemoveToString());\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "RemoveToString.isOut",
    "class_name": "org.mockito.internal.verification.RegisteredInvocations$RemoveToString",
    "signature": "org.mockito.internal.verification.RegisteredInvocations$RemoveToString.isOut(Invocation)",
    "snippet": "        public boolean isOut(Invocation invocation) {\n            return invocation.isToString();\n        }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "Times.Times",
    "class_name": "org.mockito.internal.verification.Times",
    "signature": "org.mockito.internal.verification.Times.Times(int)",
    "snippet": "    public Times(int wantedNumberOfInvocations) {\n        if (wantedNumberOfInvocations < 0) {\n            throw new MockitoException(\"Negative value is not allowed here\");\n        }\n        this.wantedCount = wantedNumberOfInvocations;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "Times.verify",
    "class_name": "org.mockito.internal.verification.Times",
    "signature": "org.mockito.internal.verification.Times.verify(VerificationData)",
    "snippet": "    public void verify(VerificationData data) {\n        if (wantedCount > 0) {\n            MissingInvocationChecker missingInvocation = new MissingInvocationChecker();\n            missingInvocation.check(data.getAllInvocations(), data.getWanted());\n        }\n        NumberOfInvocationsChecker numberOfInvocations = new NumberOfInvocationsChecker();\n        numberOfInvocations.check(data.getAllInvocations(), data.getWanted(), wantedCount);\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "VerificationDataImpl.VerificationDataImpl",
    "class_name": "org.mockito.internal.verification.VerificationDataImpl",
    "signature": "org.mockito.internal.verification.VerificationDataImpl.VerificationDataImpl(InvocationContainer,InvocationMatcher)",
    "snippet": "    public VerificationDataImpl(InvocationContainer invocations, InvocationMatcher wanted) {\n        this.invocations = invocations;\n        this.wanted = wanted;\n        this.assertWantedIsVerifiable();\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "VerificationDataImpl.assertWantedIsVerifiable",
    "class_name": "org.mockito.internal.verification.VerificationDataImpl",
    "signature": "org.mockito.internal.verification.VerificationDataImpl.assertWantedIsVerifiable()",
    "snippet": "    void assertWantedIsVerifiable() {\n        if (wanted == null) {\n            return;\n        }\n        ObjectMethodsGuru o = new ObjectMethodsGuru();\n        if (o.isToString(wanted.getMethod())) {\n            new Reporter().cannotVerifyToString();\n        }\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "VerificationDataImpl.getAllInvocations",
    "class_name": "org.mockito.internal.verification.VerificationDataImpl",
    "signature": "org.mockito.internal.verification.VerificationDataImpl.getAllInvocations()",
    "snippet": "    public List<Invocation> getAllInvocations() {\n        return invocations.getInvocations();\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "VerificationDataImpl.getWanted",
    "class_name": "org.mockito.internal.verification.VerificationDataImpl",
    "signature": "org.mockito.internal.verification.VerificationDataImpl.getWanted()",
    "snippet": "    public InvocationMatcher getWanted() {\n        return wanted;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "VerificationModeFactory.times",
    "class_name": "org.mockito.internal.verification.VerificationModeFactory",
    "signature": "org.mockito.internal.verification.VerificationModeFactory.times(int)",
    "snippet": "    public static Times times(int wantedNumberOfInvocations) {\n        return new Times(wantedNumberOfInvocations);\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "ArgumentMatchingTool.getSuspiciouslyNotMatchingArgsIndexes",
    "class_name": "org.mockito.internal.verification.argumentmatching.ArgumentMatchingTool",
    "signature": "org.mockito.internal.verification.argumentmatching.ArgumentMatchingTool.getSuspiciouslyNotMatchingArgsIndexes(List,Object[])",
    "snippet": "    public Integer[] getSuspiciouslyNotMatchingArgsIndexes(List<Matcher> matchers, Object[] arguments) {\n        if (matchers.size() != arguments.length) {\n            return new Integer[0];\n        }\n        \n        List<Integer> suspicious = new LinkedList<Integer>();\n        int i = 0;\n        for (Matcher m : matchers) {\n            if (m instanceof ContainsExtraTypeInformation \n                    && !safelyMatches(m, arguments[i]) \n                    && toStringEquals(m, arguments[i])\n                    && !((ContainsExtraTypeInformation) m).typeMatches(arguments[i])) {\n                suspicious.add(i);\n            }\n            i++;\n        }\n        return suspicious.toArray(new Integer[0]);\n    }",
    "comment": " Suspiciously not matching arguments are those that don't match, the toString() representation is the same but types are different. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "ArgumentMatchingTool.safelyMatches",
    "class_name": "org.mockito.internal.verification.argumentmatching.ArgumentMatchingTool",
    "signature": "org.mockito.internal.verification.argumentmatching.ArgumentMatchingTool.safelyMatches(Matcher,Object)",
    "snippet": "    private boolean safelyMatches(Matcher m, Object arg) {\n        try {\n            return m.matches(arg);\n        } catch (Throwable t) {\n            return false;\n        }\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "ArgumentMatchingTool.toStringEquals",
    "class_name": "org.mockito.internal.verification.argumentmatching.ArgumentMatchingTool",
    "signature": "org.mockito.internal.verification.argumentmatching.ArgumentMatchingTool.toStringEquals(Matcher,Object)",
    "snippet": "    private boolean toStringEquals(Matcher m, Object arg) {\n        return StringDescription.toString(m).equals(arg == null? \"null\" : arg.toString());\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "MissingInvocationChecker.MissingInvocationChecker",
    "class_name": "org.mockito.internal.verification.checkers.MissingInvocationChecker",
    "signature": "org.mockito.internal.verification.checkers.MissingInvocationChecker.MissingInvocationChecker()",
    "snippet": "    public MissingInvocationChecker() {\n        this(new InvocationsFinder(), new Reporter());\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "MissingInvocationChecker.MissingInvocationChecker",
    "class_name": "org.mockito.internal.verification.checkers.MissingInvocationChecker",
    "signature": "org.mockito.internal.verification.checkers.MissingInvocationChecker.MissingInvocationChecker(InvocationsFinder,Reporter)",
    "snippet": "    MissingInvocationChecker(InvocationsFinder finder, Reporter reporter) {\n        this.finder = finder;\n        this.reporter = reporter;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "MissingInvocationChecker.check",
    "class_name": "org.mockito.internal.verification.checkers.MissingInvocationChecker",
    "signature": "org.mockito.internal.verification.checkers.MissingInvocationChecker.check(List,InvocationMatcher)",
    "snippet": "    public void check(List<Invocation> invocations, InvocationMatcher wanted) {\n        List<Invocation> actualInvocations = finder.findInvocations(invocations, wanted);\n        \n        if (actualInvocations.isEmpty()) {\n            Invocation similar = finder.findSimilarInvocation(invocations, wanted);\n            if (similar != null) {\n                ArgumentMatchingTool argumentMatchingTool = new ArgumentMatchingTool();\n                Integer[] indexesOfSuspiciousArgs = argumentMatchingTool.getSuspiciouslyNotMatchingArgsIndexes(wanted.getMatchers(), similar.getArguments());\n                SmartPrinter smartPrinter = new SmartPrinter(wanted, similar, indexesOfSuspiciousArgs);\n                reporter.argumentsAreDifferent(smartPrinter.getWanted(), smartPrinter.getActual(), similar.getLocation());\n            } else {\n                reporter.wantedButNotInvoked(wanted, invocations);\n            }\n        }\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  }
]