[
  {
    "name": "Node.Node",
    "class_name": "com.google.javascript.rhino.Node",
    "signature": "com.google.javascript.rhino.Node.Node(int)",
    "snippet": "  public Node(int nodeType) {\n    type = nodeType;\n    parent = null;\n    sourcePosition = -1;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 1
  },
  {
    "name": "Node.addChildToBack",
    "class_name": "com.google.javascript.rhino.Node",
    "signature": "com.google.javascript.rhino.Node.addChildToBack(Node)",
    "snippet": "  public void addChildToBack(Node child) {\n    Preconditions.checkArgument(child.parent == null);\n    Preconditions.checkArgument(child.next == null);\n    child.parent = this;\n    child.next = null;\n    if (last == null) {\n      first = last = child;\n      return;\n    }\n    last.next = child;\n    last = child;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 1
  },
  {
    "name": "Node.createProp",
    "class_name": "com.google.javascript.rhino.Node",
    "signature": "com.google.javascript.rhino.Node.createProp(int,int,PropListItem)",
    "snippet": "  PropListItem createProp(int propType, int value, PropListItem next) {\n    return new IntPropListItem(propType, value, next);\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 1
  },
  {
    "name": "Node.getFirstChild",
    "class_name": "com.google.javascript.rhino.Node",
    "signature": "com.google.javascript.rhino.Node.getFirstChild()",
    "snippet": "  public Node getFirstChild() {\n    return first;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 1
  },
  {
    "name": "Node.getJSType",
    "class_name": "com.google.javascript.rhino.Node",
    "signature": "com.google.javascript.rhino.Node.getJSType()",
    "snippet": "  public JSType getJSType() {\n      return jsType;\n  }",
    "comment": "Custom annotations",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 1
  },
  {
    "name": "Node.getLastChild",
    "class_name": "com.google.javascript.rhino.Node",
    "signature": "com.google.javascript.rhino.Node.getLastChild()",
    "snippet": "  public Node getLastChild() {\n    return last;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 1
  },
  {
    "name": "Node.getNext",
    "class_name": "com.google.javascript.rhino.Node",
    "signature": "com.google.javascript.rhino.Node.getNext()",
    "snippet": "  public Node getNext() {\n    return next;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 1
  },
  {
    "name": "Node.newString",
    "class_name": "com.google.javascript.rhino.Node",
    "signature": "com.google.javascript.rhino.Node.newString(int,String)",
    "snippet": "  public static Node newString(int type, String str) {\n    return new StringNode(type, str);\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 1
  },
  {
    "name": "Node.putBooleanProp",
    "class_name": "com.google.javascript.rhino.Node",
    "signature": "com.google.javascript.rhino.Node.putBooleanProp(int,boolean)",
    "snippet": "  public void putBooleanProp(int propType, boolean value) {\n    putIntProp(propType, value ? 1 : 0);\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 1
  },
  {
    "name": "Node.putIntProp",
    "class_name": "com.google.javascript.rhino.Node",
    "signature": "com.google.javascript.rhino.Node.putIntProp(int,int)",
    "snippet": "  public void putIntProp(int propType, int value) {\n    removeProp(propType);\n    if (value != 0) {\n      propListHead = createProp(propType, value, propListHead);\n    }\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 1
  },
  {
    "name": "Node.removeProp",
    "class_name": "com.google.javascript.rhino.Node",
    "signature": "com.google.javascript.rhino.Node.removeProp(PropListItem,int)",
    "snippet": "  private PropListItem removeProp(PropListItem item, int propType) {\n    if (item == null) {\n      return null;\n    } else if (item.getType() == propType) {\n      return item.getNext();\n    } else {\n      PropListItem result = removeProp(item.getNext(), propType);\n      if (result != item.getNext()) {\n        return item.chain(result);\n      } else {\n        return item;\n      }\n    }\n  }",
    "comment": " @param item The item to inspect @param propType The property to look for @return The replacement list if the property was removed, or 'item' otherwise. ",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 1
  },
  {
    "name": "Node.removeProp",
    "class_name": "com.google.javascript.rhino.Node",
    "signature": "com.google.javascript.rhino.Node.removeProp(int)",
    "snippet": "  public void removeProp(int propType) {\n    PropListItem result = removeProp(propListHead, propType);\n    if (result != propListHead) {\n      propListHead = result;\n    }\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 1
  },
  {
    "name": "Node.setJSType",
    "class_name": "com.google.javascript.rhino.Node",
    "signature": "com.google.javascript.rhino.Node.setJSType(JSType)",
    "snippet": "  public void setJSType(JSType jsType) {\n      this.jsType = jsType;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 1
  },
  {
    "name": "Node.setOptionalArg",
    "class_name": "com.google.javascript.rhino.Node",
    "signature": "com.google.javascript.rhino.Node.setOptionalArg(boolean)",
    "snippet": "  public void setOptionalArg(boolean optionalArg) {\n    putBooleanProp(OPT_ARG_NAME, optionalArg);\n  }",
    "comment": " Sets whether this node is an optional argument node. This method is meaningful only on {@link Token#NAME} nodes used to define a {@link Token#FUNCTION}'s argument list. ",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 1
  },
  {
    "name": "Node.setVarArgs",
    "class_name": "com.google.javascript.rhino.Node",
    "signature": "com.google.javascript.rhino.Node.setVarArgs(boolean)",
    "snippet": "  public void setVarArgs(boolean varArgs) {\n    putBooleanProp(VAR_ARGS_NAME, varArgs);\n  }",
    "comment": " Sets whether this node is a variable length argument node. This method is meaningful only on {@link Token#NAME} nodes used to define a {@link Token#FUNCTION}'s argument list. ",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 1
  },
  {
    "name": "AllType.AllType",
    "class_name": "com.google.javascript.rhino.jstype.AllType",
    "signature": "com.google.javascript.rhino.jstype.AllType.AllType(JSTypeRegistry)",
    "snippet": "  AllType(JSTypeRegistry registry) {\n    super(registry);\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 1
  },
  {
    "name": "AllType.isAllType",
    "class_name": "com.google.javascript.rhino.jstype.AllType",
    "signature": "com.google.javascript.rhino.jstype.AllType.isAllType()",
    "snippet": "  @Override\n  public boolean isAllType() {\n    return true;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 1
  },
  {
    "name": "ArrowType.ArrowType",
    "class_name": "com.google.javascript.rhino.jstype.ArrowType",
    "signature": "com.google.javascript.rhino.jstype.ArrowType.ArrowType(JSTypeRegistry,Node,JSType)",
    "snippet": "  ArrowType(JSTypeRegistry registry, Node parameters,\n      JSType returnType) {\n    this(registry, parameters, returnType, false);\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 1
  },
  {
    "name": "ArrowType.ArrowType",
    "class_name": "com.google.javascript.rhino.jstype.ArrowType",
    "signature": "com.google.javascript.rhino.jstype.ArrowType.ArrowType(JSTypeRegistry,Node,JSType,boolean)",
    "snippet": "  ArrowType(JSTypeRegistry registry, Node parameters,\n      JSType returnType, boolean returnTypeInferred) {\n    super(registry);\n\n    this.parameters = parameters == null ?\n        registry.createParametersWithVarArgs(getNativeType(UNKNOWN_TYPE)) :\n        parameters;\n    this.returnType = returnType == null ?\n        getNativeType(UNKNOWN_TYPE) : returnType;\n    this.returnTypeInferred = returnTypeInferred;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 1
  },
  {
    "name": "ArrowType.hashCode",
    "class_name": "com.google.javascript.rhino.jstype.ArrowType",
    "signature": "com.google.javascript.rhino.jstype.ArrowType.hashCode()",
    "snippet": "  @Override\n  public int hashCode() {\n    int hashCode = 0;\n    if (returnType != null) {\n      hashCode += returnType.hashCode();\n    }\n    if (returnTypeInferred) {\n      hashCode += 1;\n    }\n    if (parameters != null) {\n      Node param = parameters.getFirstChild();\n      while (param != null) {\n        JSType paramType = param.getJSType();\n        if (paramType != null) {\n          hashCode += paramType.hashCode();\n        }\n        param = param.getNext();\n      }\n    }\n    return hashCode;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 1
  },
  {
    "name": "ArrowType.resolveInternal",
    "class_name": "com.google.javascript.rhino.jstype.ArrowType",
    "signature": "com.google.javascript.rhino.jstype.ArrowType.resolveInternal(ErrorReporter,StaticScope)",
    "snippet": "  @Override\n  JSType resolveInternal(ErrorReporter t, StaticScope<JSType> scope) {\n    returnType = safeResolve(returnType, t, scope);\n    if (parameters != null) {\n      for (Node paramNode = parameters.getFirstChild();\n           paramNode != null; paramNode = paramNode.getNext()) {\n        paramNode.setJSType(paramNode.getJSType().resolve(t, scope));\n      }\n    }\n    return this;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 1
  },
  {
    "name": "BooleanType.BooleanType",
    "class_name": "com.google.javascript.rhino.jstype.BooleanType",
    "signature": "com.google.javascript.rhino.jstype.BooleanType.BooleanType(JSTypeRegistry)",
    "snippet": "  BooleanType(JSTypeRegistry registry) {\n    super(registry);\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 1
  },
  {
    "name": "BooleanType.getDisplayName",
    "class_name": "com.google.javascript.rhino.jstype.BooleanType",
    "signature": "com.google.javascript.rhino.jstype.BooleanType.getDisplayName()",
    "snippet": "  @Override\n  public String getDisplayName() {\n    return \"boolean\";\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 1
  },
  {
    "name": "BooleanType.toString",
    "class_name": "com.google.javascript.rhino.jstype.BooleanType",
    "signature": "com.google.javascript.rhino.jstype.BooleanType.toString()",
    "snippet": "  @Override\n  public String toString() {\n    return getDisplayName();\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 1
  },
  {
    "name": "EnumElementType.EnumElementType",
    "class_name": "com.google.javascript.rhino.jstype.EnumElementType",
    "signature": "com.google.javascript.rhino.jstype.EnumElementType.EnumElementType(JSTypeRegistry,JSType,String)",
    "snippet": "  EnumElementType(JSTypeRegistry registry, JSType elementType,\n      String name) {\n    super(registry);\n    this.primitiveType = elementType;\n    this.primitiveObjectType = elementType.toObjectType();\n    this.name = name;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 1
  },
  {
    "name": "EnumType.EnumType",
    "class_name": "com.google.javascript.rhino.jstype.EnumType",
    "signature": "com.google.javascript.rhino.jstype.EnumType.EnumType(JSTypeRegistry,String,Node,JSType)",
    "snippet": "  EnumType(JSTypeRegistry registry, String name, Node source,\n      JSType elementsType) {\n    super(registry, \"enum{\" + name + \"}\", null);\n    this.source = source;\n    this.elementsType = new EnumElementType(registry, elementsType, name);\n  }",
    "comment": " Creates an enum type.  @param name the enum's name @param elementsType the base type of the individual elements ",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 1
  },
  {
    "name": "EnumType.getElementsType",
    "class_name": "com.google.javascript.rhino.jstype.EnumType",
    "signature": "com.google.javascript.rhino.jstype.EnumType.getElementsType()",
    "snippet": "  public EnumElementType getElementsType() {\n    return elementsType;\n  }",
    "comment": " Gets the elements' type. ",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 1
  },
  {
    "name": "ErrorFunctionType.ErrorFunctionType",
    "class_name": "com.google.javascript.rhino.jstype.ErrorFunctionType",
    "signature": "com.google.javascript.rhino.jstype.ErrorFunctionType.ErrorFunctionType(JSTypeRegistry,String)",
    "snippet": "  ErrorFunctionType(JSTypeRegistry registry, String name) {\n    super(\n        registry, name, null,\n        registry.createArrowType(\n            registry.createOptionalParameters(\n                registry.getNativeType(ALL_TYPE),\n                registry.getNativeType(ALL_TYPE),\n                registry.getNativeType(ALL_TYPE)),\n            null),\n        null, null, true, true);\n\n    // NOTE(nicksantos): Errors have the weird behavior in that they can\n    // be called as functions, and they will return instances of themselves.\n    // Error('x') instanceof Error => true\n    //\n    // In user-defined types, we would deal with this case by creating\n    // a NamedType with the name \"Error\" and then resolve it later.\n    //\n    // For native types, we don't really want the native types to\n    // depend on type-resolution. So we just set the return type manually\n    // at the end of construction.\n    //\n    // There's similar logic in JSTypeRegistry for Array and RegExp.\n    getInternalArrowType().returnType = getInstanceType();\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 1
  },
  {
    "name": "FunctionBuilder.FunctionBuilder",
    "class_name": "com.google.javascript.rhino.jstype.FunctionBuilder",
    "signature": "com.google.javascript.rhino.jstype.FunctionBuilder.FunctionBuilder(JSTypeRegistry)",
    "snippet": "  public FunctionBuilder(JSTypeRegistry registry) {\n    this.registry = registry;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 1
  },
  {
    "name": "FunctionBuilder.build",
    "class_name": "com.google.javascript.rhino.jstype.FunctionBuilder",
    "signature": "com.google.javascript.rhino.jstype.FunctionBuilder.build()",
    "snippet": "  public FunctionType build() {\n    return new FunctionType(registry, name, sourceNode,\n        new ArrowType(registry, parametersNode, returnType, inferredReturnType),\n        typeOfThis, templateTypeName, isConstructor, isNativeType);\n  }",
    "comment": "Construct a new function type. */",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 1
  },
  {
    "name": "FunctionBuilder.withParamsNode",
    "class_name": "com.google.javascript.rhino.jstype.FunctionBuilder",
    "signature": "com.google.javascript.rhino.jstype.FunctionBuilder.withParamsNode(Node)",
    "snippet": "  public FunctionBuilder withParamsNode(Node parametersNode) {\n    this.parametersNode = parametersNode;\n    return this;\n  }",
    "comment": " Set the parameters of the function type with a specially-formatted node. ",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 1
  },
  {
    "name": "FunctionBuilder.withReturnType",
    "class_name": "com.google.javascript.rhino.jstype.FunctionBuilder",
    "signature": "com.google.javascript.rhino.jstype.FunctionBuilder.withReturnType(JSType)",
    "snippet": "  public FunctionBuilder withReturnType(JSType returnType) {\n    this.returnType = returnType;\n    return this;\n  }",
    "comment": "Set the return type. */",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 1
  },
  {
    "name": "FunctionBuilder.withTypeOfThis",
    "class_name": "com.google.javascript.rhino.jstype.FunctionBuilder",
    "signature": "com.google.javascript.rhino.jstype.FunctionBuilder.withTypeOfThis(ObjectType)",
    "snippet": "  public FunctionBuilder withTypeOfThis(ObjectType typeOfThis) {\n    this.typeOfThis = typeOfThis;\n    return this;\n  }",
    "comment": "Set the \"this\" type. */",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 1
  },
  {
    "name": "FunctionParamBuilder.FunctionParamBuilder",
    "class_name": "com.google.javascript.rhino.jstype.FunctionParamBuilder",
    "signature": "com.google.javascript.rhino.jstype.FunctionParamBuilder.FunctionParamBuilder(JSTypeRegistry)",
    "snippet": "  public FunctionParamBuilder(JSTypeRegistry registry) {\n    this.registry = registry;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 1
  },
  {
    "name": "FunctionParamBuilder.addOptionalParams",
    "class_name": "com.google.javascript.rhino.jstype.FunctionParamBuilder",
    "signature": "com.google.javascript.rhino.jstype.FunctionParamBuilder.addOptionalParams(JSType[])",
    "snippet": "  public boolean addOptionalParams(JSType ...types) {\n    if (hasVarArgs()) {\n      return false;\n    }\n\n    for (JSType type : types) {\n      newParameter(registry.createOptionalType(type)).setOptionalArg(true);\n    }\n    return true;\n  }",
    "comment": " Add optional parameters of the given type to the end of the param list. @param types Types for each optional parameter. The builder will make them undefineable. @return False if this is called after var args are added. ",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 1
  },
  {
    "name": "FunctionParamBuilder.addRequiredParams",
    "class_name": "com.google.javascript.rhino.jstype.FunctionParamBuilder",
    "signature": "com.google.javascript.rhino.jstype.FunctionParamBuilder.addRequiredParams(JSType[])",
    "snippet": "  public boolean addRequiredParams(JSType ...types) {\n    if (hasOptionalOrVarArgs()) {\n      return false;\n    }\n\n    for (JSType type : types) {\n      newParameter(type);\n    }\n    return true;\n  }",
    "comment": " Add parameters of the given type to the end of the param list. @return False if this is called after optional params are added. ",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 1
  },
  {
    "name": "FunctionParamBuilder.addVarArgs",
    "class_name": "com.google.javascript.rhino.jstype.FunctionParamBuilder",
    "signature": "com.google.javascript.rhino.jstype.FunctionParamBuilder.addVarArgs(JSType)",
    "snippet": "  public boolean addVarArgs(JSType type) {\n    if (hasVarArgs()) {\n      return false;\n    }\n\n    // There are two types of variable argument functions:\n    // 1) Programmer-defined var args\n    // 2) Native bottom types that can accept any argument.\n    // For the first one, \"undefined\" is a valid value for all arguments.\n    // For the second, we do not want to cast it up to undefined.\n    if (!type.isEmptyType()) {\n      type = registry.createOptionalType(type);\n    }\n    newParameter(type).setVarArgs(true);\n    return true;\n  }",
    "comment": " Add variable arguments to the end of the parameter list. @return False if this is called after var args are added. ",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 1
  },
  {
    "name": "FunctionParamBuilder.build",
    "class_name": "com.google.javascript.rhino.jstype.FunctionParamBuilder",
    "signature": "com.google.javascript.rhino.jstype.FunctionParamBuilder.build()",
    "snippet": "  public Node build() {\n    return root;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 1
  },
  {
    "name": "FunctionParamBuilder.hasOptionalOrVarArgs",
    "class_name": "com.google.javascript.rhino.jstype.FunctionParamBuilder",
    "signature": "com.google.javascript.rhino.jstype.FunctionParamBuilder.hasOptionalOrVarArgs()",
    "snippet": "  private boolean hasOptionalOrVarArgs() {\n    Node lastChild = root.getLastChild();\n    return lastChild != null &&\n        (lastChild.isOptionalArg() || lastChild.isVarArgs());\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 1
  },
  {
    "name": "FunctionParamBuilder.hasVarArgs",
    "class_name": "com.google.javascript.rhino.jstype.FunctionParamBuilder",
    "signature": "com.google.javascript.rhino.jstype.FunctionParamBuilder.hasVarArgs()",
    "snippet": "  public boolean hasVarArgs() {\n    Node lastChild = root.getLastChild();\n    return lastChild != null && lastChild.isVarArgs();\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 1
  },
  {
    "name": "FunctionParamBuilder.newParameter",
    "class_name": "com.google.javascript.rhino.jstype.FunctionParamBuilder",
    "signature": "com.google.javascript.rhino.jstype.FunctionParamBuilder.newParameter(JSType)",
    "snippet": "  private Node newParameter(JSType type) {\n    Node paramNode = Node.newString(Token.NAME, \"\");\n    paramNode.setJSType(type);\n    root.addChildToBack(paramNode);\n    return paramNode;\n  }",
    "comment": "Add a parameter to the list with the given type.",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 1
  },
  {
    "name": "FunctionType.FunctionType",
    "class_name": "com.google.javascript.rhino.jstype.FunctionType",
    "signature": "com.google.javascript.rhino.jstype.FunctionType.FunctionType(JSTypeRegistry,String,Node,ArrowType,ObjectType,String,boolean,boolean)",
    "snippet": "  FunctionType(JSTypeRegistry registry, String name, Node source,\n      ArrowType arrowType, ObjectType typeOfThis,\n      String templateTypeName,  boolean isConstructor, boolean nativeType) {\n    super(registry, name,\n        registry.getNativeObjectType(JSTypeNative.FUNCTION_INSTANCE_TYPE),\n        nativeType);\n    setPrettyPrint(true);\n\n    Preconditions.checkArgument(source == null ||\n        Token.FUNCTION == source.getType());\n    Preconditions.checkNotNull(arrowType);\n    this.source = source;\n    this.kind = isConstructor ? Kind.CONSTRUCTOR : Kind.ORDINARY;\n    if (isConstructor) {\n      this.typeOfThis = typeOfThis != null ?\n          typeOfThis : new InstanceObjectType(registry, this, nativeType);\n    } else {\n      this.typeOfThis = typeOfThis != null ?\n          typeOfThis :\n          registry.getNativeObjectType(JSTypeNative.UNKNOWN_TYPE);\n    }\n    this.call = arrowType;\n    this.templateTypeName = templateTypeName;\n  }",
    "comment": "Creates an instance for a function that might be a constructor. */",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 1
  },
  {
    "name": "FunctionType.addSubType",
    "class_name": "com.google.javascript.rhino.jstype.FunctionType",
    "signature": "com.google.javascript.rhino.jstype.FunctionType.addSubType(FunctionType)",
    "snippet": "  private void addSubType(FunctionType subType) {\n    if (subTypes == null) {\n      subTypes = Lists.newArrayList();\n    }\n    subTypes.add(subType);\n  }",
    "comment": "Adds a type to the list of subtypes for this type. */",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 1
  },
  {
    "name": "FunctionType.forInterface",
    "class_name": "com.google.javascript.rhino.jstype.FunctionType",
    "signature": "com.google.javascript.rhino.jstype.FunctionType.forInterface(JSTypeRegistry,String,Node)",
    "snippet": "  static FunctionType forInterface(\n      JSTypeRegistry registry, String name, Node source) {\n    return new FunctionType(registry, name, source);\n  }",
    "comment": "Creates an instance for a function that is an interface. */",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 1
  },
  {
    "name": "FunctionType.getExtendedInterfaces",
    "class_name": "com.google.javascript.rhino.jstype.FunctionType",
    "signature": "com.google.javascript.rhino.jstype.FunctionType.getExtendedInterfaces()",
    "snippet": "  public Iterable<ObjectType> getExtendedInterfaces() {\n    return extendedInterfaces;\n  }",
    "comment": "Returns interfaces directly extended by an interface */",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 1
  },
  {
    "name": "FunctionType.getInstanceType",
    "class_name": "com.google.javascript.rhino.jstype.FunctionType",
    "signature": "com.google.javascript.rhino.jstype.FunctionType.getInstanceType()",
    "snippet": "  public ObjectType getInstanceType() {\n    Preconditions.checkState(hasInstanceType());\n    return typeOfThis;\n  }",
    "comment": " Gets the type of instance of this function. @throws IllegalStateException if this function is not a constructor (see {@link #isConstructor()}). ",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 1
  },
  {
    "name": "FunctionType.getInternalArrowType",
    "class_name": "com.google.javascript.rhino.jstype.FunctionType",
    "signature": "com.google.javascript.rhino.jstype.FunctionType.getInternalArrowType()",
    "snippet": "  ArrowType getInternalArrowType() {\n    return call;\n  }",
    "comment": "Gets the internal arrow type. For use by subclasses only. */",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 1
  },
  {
    "name": "FunctionType.getPrototype",
    "class_name": "com.google.javascript.rhino.jstype.FunctionType",
    "signature": "com.google.javascript.rhino.jstype.FunctionType.getPrototype()",
    "snippet": "  public ObjectType getPrototype() {\n    // lazy initialization of the prototype field\n    if (prototypeSlot == null) {\n      setPrototype(\n          new PrototypeObjectType(\n              registry,\n              this.getReferenceName() + \".prototype\",\n              registry.getNativeObjectType(OBJECT_TYPE),\n              isNativeObjectType()),\n          null);\n    }\n    return (ObjectType) prototypeSlot.getType();\n  }",
    "comment": " Gets the {@code prototype} property of this function type. This is equivalent to {@code (ObjectType) getPropertyType(\"prototype\")}. ",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 1
  },
  {
    "name": "FunctionType.getSuperClassConstructor",
    "class_name": "com.google.javascript.rhino.jstype.FunctionType",
    "signature": "com.google.javascript.rhino.jstype.FunctionType.getSuperClassConstructor()",
    "snippet": "  public FunctionType getSuperClassConstructor() {\n    Preconditions.checkArgument(isConstructor() || isInterface());\n    ObjectType maybeSuperInstanceType = getPrototype().getImplicitPrototype();\n    if (maybeSuperInstanceType == null) {\n      return null;\n    }\n    return maybeSuperInstanceType.getConstructor();\n  }",
    "comment": " Given a constructor or an interface type, get its superclass constructor or {@code null} if none exists. ",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 1
  },
  {
    "name": "FunctionType.hasCachedValues",
    "class_name": "com.google.javascript.rhino.jstype.FunctionType",
    "signature": "com.google.javascript.rhino.jstype.FunctionType.hasCachedValues()",
    "snippet": "  @Override\n  public boolean hasCachedValues() {\n    return prototypeSlot != null || super.hasCachedValues();\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 1
  },
  {
    "name": "FunctionType.hasInstanceType",
    "class_name": "com.google.javascript.rhino.jstype.FunctionType",
    "signature": "com.google.javascript.rhino.jstype.FunctionType.hasInstanceType()",
    "snippet": "  public boolean hasInstanceType() {\n    return isConstructor() || isInterface();\n  }",
    "comment": " Returns whether this function type has an instance type. ",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 1
  },
  {
    "name": "FunctionType.hashCode",
    "class_name": "com.google.javascript.rhino.jstype.FunctionType",
    "signature": "com.google.javascript.rhino.jstype.FunctionType.hashCode()",
    "snippet": "  @Override\n  public int hashCode() {\n    return isInterface() ? getReferenceName().hashCode() : call.hashCode();\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 1
  },
  {
    "name": "FunctionType.isConstructor",
    "class_name": "com.google.javascript.rhino.jstype.FunctionType",
    "signature": "com.google.javascript.rhino.jstype.FunctionType.isConstructor()",
    "snippet": "  @Override\n  public boolean isConstructor() {\n    return kind == Kind.CONSTRUCTOR;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 1
  },
  {
    "name": "FunctionType.isInterface",
    "class_name": "com.google.javascript.rhino.jstype.FunctionType",
    "signature": "com.google.javascript.rhino.jstype.FunctionType.isInterface()",
    "snippet": "  @Override\n  public boolean isInterface() {\n    return kind == Kind.INTERFACE;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 1
  },
  {
    "name": "FunctionType.resolveInternal",
    "class_name": "com.google.javascript.rhino.jstype.FunctionType",
    "signature": "com.google.javascript.rhino.jstype.FunctionType.resolveInternal(ErrorReporter,StaticScope)",
    "snippet": "  @Override\n  JSType resolveInternal(ErrorReporter t, StaticScope<JSType> scope) {\n    setResolvedTypeInternal(this);\n\n    call = (ArrowType) safeResolve(call, t, scope);\n    if (prototypeSlot != null) {\n      prototypeSlot.setType(\n          safeResolve(prototypeSlot.getType(), t, scope));\n    }\n\n    // Warning about typeOfThis if it doesn't resolve to an ObjectType\n    // is handled further upstream.\n    //\n    // TODO(nicksantos): Handle this correctly if we have a UnionType.\n    //\n    // TODO(nicksantos): In ES3, the runtime coerces \"null\" to the global\n    // activation object. In ES5, it leaves it as null. Just punt on this\n    // issue for now by coercing out null. This is complicated by the\n    // fact that when most people write @this {Foo}, they really don't\n    // mean \"nullable Foo\". For certain tags (like @extends) we de-nullify\n    // the name for them.\n    JSType maybeTypeOfThis = safeResolve(typeOfThis, t, scope);\n    if (maybeTypeOfThis != null) {\n      maybeTypeOfThis = maybeTypeOfThis.restrictByNotNullOrUndefined();\n    }\n    if (maybeTypeOfThis instanceof ObjectType) {\n      typeOfThis = (ObjectType) maybeTypeOfThis;\n    }\n\n    boolean changed = false;\n    ImmutableList.Builder<ObjectType> resolvedInterfaces =\n        ImmutableList.builder();\n    for (ObjectType iface : implementedInterfaces) {\n      ObjectType resolvedIface = (ObjectType) iface.resolve(t, scope);\n      resolvedInterfaces.add(resolvedIface);\n      changed |= (resolvedIface != iface);\n    }\n    if (changed) {\n      implementedInterfaces = resolvedInterfaces.build();\n    }\n\n    if (subTypes != null) {\n      for (int i = 0; i < subTypes.size(); i++) {\n        subTypes.set(\n            i, JSType.toMaybeFunctionType(subTypes.get(i).resolve(t, scope)));\n      }\n    }\n\n    return super.resolveInternal(t, scope);\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 1
  },
  {
    "name": "FunctionType.setExtendedInterfaces",
    "class_name": "com.google.javascript.rhino.jstype.FunctionType",
    "signature": "com.google.javascript.rhino.jstype.FunctionType.setExtendedInterfaces(List)",
    "snippet": "  public void setExtendedInterfaces(List<ObjectType> extendedInterfaces)\n    throws UnsupportedOperationException {\n    if (isInterface()) {\n      this.extendedInterfaces = ImmutableList.copyOf(extendedInterfaces);\n    } else {\n      throw new UnsupportedOperationException();\n    }\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 1
  },
  {
    "name": "FunctionType.setImplementedInterfaces",
    "class_name": "com.google.javascript.rhino.jstype.FunctionType",
    "signature": "com.google.javascript.rhino.jstype.FunctionType.setImplementedInterfaces(List)",
    "snippet": "  public void setImplementedInterfaces(List<ObjectType> implementedInterfaces) {\n    // Records this type for each implemented interface.\n    for (ObjectType type : implementedInterfaces) {\n      registry.registerTypeImplementingInterface(this, type);\n    }\n    this.implementedInterfaces = ImmutableList.copyOf(implementedInterfaces);\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 1
  },
  {
    "name": "FunctionType.setInstanceType",
    "class_name": "com.google.javascript.rhino.jstype.FunctionType",
    "signature": "com.google.javascript.rhino.jstype.FunctionType.setInstanceType(ObjectType)",
    "snippet": "  void setInstanceType(ObjectType instanceType) {\n    typeOfThis = instanceType;\n  }",
    "comment": " Sets the instance type. This should only be used for special native types. ",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 1
  },
  {
    "name": "FunctionType.setPrototype",
    "class_name": "com.google.javascript.rhino.jstype.FunctionType",
    "signature": "com.google.javascript.rhino.jstype.FunctionType.setPrototype(PrototypeObjectType,Node)",
    "snippet": "  boolean setPrototype(PrototypeObjectType prototype, Node propertyNode) {\n    if (prototype == null) {\n      return false;\n    }\n    // getInstanceType fails if the function is not a constructor\n    if (isConstructor() && prototype == getInstanceType()) {\n      return false;\n    }\n\n    PrototypeObjectType oldPrototype = prototypeSlot == null\n        ? null : (PrototypeObjectType) prototypeSlot.getType();\n    boolean replacedPrototype = oldPrototype != null;\n\n    this.prototypeSlot = new Property(\"prototype\", prototype, true,\n        propertyNode == null ? source : propertyNode);\n    prototype.setOwnerFunction(this);\n\n    if (oldPrototype != null) {\n      // Disassociating the old prototype makes this easier to debug--\n      // we don't have to worry about two prototypes running around.\n      oldPrototype.setOwnerFunction(null);\n    }\n\n    if (isConstructor() || isInterface()) {\n      FunctionType superClass = getSuperClassConstructor();\n      if (superClass != null) {\n        superClass.addSubType(this);\n      }\n\n      if (isInterface()) {\n        for (ObjectType interfaceType : getExtendedInterfaces()) {\n          if (interfaceType.getConstructor() != null) {\n            interfaceType.getConstructor().addSubType(this);\n          }\n        }\n      }\n    }\n\n    if (replacedPrototype) {\n      clearCachedValues();\n    }\n\n    return true;\n  }",
    "comment": " Sets the prototype. @param prototype the prototype. If this value is {@code null} it will silently be discarded. ",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 1
  },
  {
    "name": "FunctionType.setPrototypeBasedOn",
    "class_name": "com.google.javascript.rhino.jstype.FunctionType",
    "signature": "com.google.javascript.rhino.jstype.FunctionType.setPrototypeBasedOn(ObjectType)",
    "snippet": "  public void setPrototypeBasedOn(ObjectType baseType) {\n    setPrototypeBasedOn(baseType, null);\n  }",
    "comment": " Sets the prototype, creating the prototype object from the given base type. @param baseType The base type. ",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 1
  },
  {
    "name": "FunctionType.setPrototypeBasedOn",
    "class_name": "com.google.javascript.rhino.jstype.FunctionType",
    "signature": "com.google.javascript.rhino.jstype.FunctionType.setPrototypeBasedOn(ObjectType,Node)",
    "snippet": "  void setPrototypeBasedOn(ObjectType baseType, Node propertyNode) {\n    // This is a bit weird. We need to successfully handle these\n    // two cases:\n    // Foo.prototype = new Bar();\n    // and\n    // Foo.prototype = {baz: 3};\n    // In the first case, we do not want new properties to get\n    // added to Bar. In the second case, we do want new properties\n    // to get added to the type of the anonymous object.\n    //\n    // We handle this by breaking it into two cases:\n    //\n    // In the first case, we create a new PrototypeObjectType and set\n    // its implicit prototype to the type being assigned. This ensures\n    // that Bar will not get any properties of Foo.prototype, but properties\n    // later assigned to Bar will get inherited properly.\n    //\n    // In the second case, we just use the anonymous object as the prototype.\n    if (baseType.hasReferenceName() ||\n        isNativeObjectType() ||\n        baseType.isFunctionPrototypeType() ||\n        !(baseType instanceof PrototypeObjectType)) {\n\n      baseType = new PrototypeObjectType(\n          registry, this.getReferenceName() + \".prototype\", baseType);\n    }\n    setPrototype((PrototypeObjectType) baseType, propertyNode);\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 1
  },
  {
    "name": "FunctionType.toMaybeFunctionType",
    "class_name": "com.google.javascript.rhino.jstype.FunctionType",
    "signature": "com.google.javascript.rhino.jstype.FunctionType.toMaybeFunctionType()",
    "snippet": "  @Override\n  public FunctionType toMaybeFunctionType() {\n    return this;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 1
  },
  {
    "name": "InstanceObjectType.InstanceObjectType",
    "class_name": "com.google.javascript.rhino.jstype.InstanceObjectType",
    "signature": "com.google.javascript.rhino.jstype.InstanceObjectType.InstanceObjectType(JSTypeRegistry,FunctionType)",
    "snippet": "  InstanceObjectType(JSTypeRegistry registry, FunctionType constructor) {\n    this(registry, constructor, false);\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 1
  },
  {
    "name": "InstanceObjectType.InstanceObjectType",
    "class_name": "com.google.javascript.rhino.jstype.InstanceObjectType",
    "signature": "com.google.javascript.rhino.jstype.InstanceObjectType.InstanceObjectType(JSTypeRegistry,FunctionType,boolean)",
    "snippet": "  InstanceObjectType(JSTypeRegistry registry, FunctionType constructor,\n                     boolean isNativeType) {\n    super(registry, null, null, isNativeType);\n    Preconditions.checkNotNull(constructor);\n    this.constructor = constructor;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 1
  },
  {
    "name": "InstanceObjectType.defineProperty",
    "class_name": "com.google.javascript.rhino.jstype.InstanceObjectType",
    "signature": "com.google.javascript.rhino.jstype.InstanceObjectType.defineProperty(String,JSType,boolean,Node)",
    "snippet": "  @Override\n  boolean defineProperty(String name, JSType type, boolean inferred,\n      Node propertyNode) {\n    ObjectType proto = getImplicitPrototype();\n    if (proto != null && proto.hasOwnDeclaredProperty(name)) {\n      return false;\n    }\n    return super.defineProperty(name, type, inferred, propertyNode);\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 1
  },
  {
    "name": "InstanceObjectType.getConstructor",
    "class_name": "com.google.javascript.rhino.jstype.InstanceObjectType",
    "signature": "com.google.javascript.rhino.jstype.InstanceObjectType.getConstructor()",
    "snippet": "  @Override\n  public FunctionType getConstructor() {\n    return constructor;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 1
  },
  {
    "name": "InstanceObjectType.getCtorExtendedInterfaces",
    "class_name": "com.google.javascript.rhino.jstype.InstanceObjectType",
    "signature": "com.google.javascript.rhino.jstype.InstanceObjectType.getCtorExtendedInterfaces()",
    "snippet": "  @Override\n  public Iterable<ObjectType> getCtorExtendedInterfaces() {\n    return getConstructor().getExtendedInterfaces();\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 1
  },
  {
    "name": "InstanceObjectType.getImplicitPrototype",
    "class_name": "com.google.javascript.rhino.jstype.InstanceObjectType",
    "signature": "com.google.javascript.rhino.jstype.InstanceObjectType.getImplicitPrototype()",
    "snippet": "  @Override\n  public ObjectType getImplicitPrototype() {\n    return getConstructor().getPrototype();\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 1
  },
  {
    "name": "InstanceObjectType.getReferenceName",
    "class_name": "com.google.javascript.rhino.jstype.InstanceObjectType",
    "signature": "com.google.javascript.rhino.jstype.InstanceObjectType.getReferenceName()",
    "snippet": "  @Override\n  public String getReferenceName() {\n    return getConstructor().getReferenceName();\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 1
  },
  {
    "name": "InstanceObjectType.hasReferenceName",
    "class_name": "com.google.javascript.rhino.jstype.InstanceObjectType",
    "signature": "com.google.javascript.rhino.jstype.InstanceObjectType.hasReferenceName()",
    "snippet": "  @Override\n  public boolean hasReferenceName() {\n    return getConstructor().hasReferenceName();\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 1
  },
  {
    "name": "InstanceObjectType.hashCode",
    "class_name": "com.google.javascript.rhino.jstype.InstanceObjectType",
    "signature": "com.google.javascript.rhino.jstype.InstanceObjectType.hashCode()",
    "snippet": "  @Override\n  public int hashCode() {\n    if (hasReferenceName()) {\n      return getReferenceName().hashCode();\n    } else {\n      return super.hashCode();\n    }\n  }",
    "comment": " If this is equal to a NamedType object, its hashCode must be equal to the hashCode of the NamedType object. ",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 1
  },
  {
    "name": "InstanceObjectType.isEquivalentTo",
    "class_name": "com.google.javascript.rhino.jstype.InstanceObjectType",
    "signature": "com.google.javascript.rhino.jstype.InstanceObjectType.isEquivalentTo(JSType)",
    "snippet": "  @Override\n  public boolean isEquivalentTo(JSType that) {\n    if (this == that) {\n      return true;\n    } else if (this.isNominalType()) {\n      ObjectType thatObj = ObjectType.cast(that);\n      if (thatObj != null && thatObj.isNominalType()) {\n        return getReferenceName().equals(thatObj.getReferenceName());\n      }\n    }\n    return false;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 1
  },
  {
    "name": "InstanceObjectType.isNominalType",
    "class_name": "com.google.javascript.rhino.jstype.InstanceObjectType",
    "signature": "com.google.javascript.rhino.jstype.InstanceObjectType.isNominalType()",
    "snippet": "  @Override\n  public boolean isNominalType() {\n    return hasReferenceName();\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 1
  },
  {
    "name": "InstanceObjectType.toString",
    "class_name": "com.google.javascript.rhino.jstype.InstanceObjectType",
    "signature": "com.google.javascript.rhino.jstype.InstanceObjectType.toString()",
    "snippet": "  @Override\n  public String toString() {\n    if (constructor.hasReferenceName()) {\n      return constructor.getReferenceName();\n    } else {\n      return super.toString();\n    }\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 1
  },
  {
    "name": "JSType.JSType",
    "class_name": "com.google.javascript.rhino.jstype.JSType",
    "signature": "com.google.javascript.rhino.jstype.JSType.JSType(JSTypeRegistry)",
    "snippet": "  JSType(JSTypeRegistry registry) {\n    this.registry = registry;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 1
  },
  {
    "name": "JSType.getNativeType",
    "class_name": "com.google.javascript.rhino.jstype.JSType",
    "signature": "com.google.javascript.rhino.jstype.JSType.getNativeType(JSTypeNative)",
    "snippet": "  JSType getNativeType(JSTypeNative typeId) {\n    return registry.getNativeType(typeId);\n  }",
    "comment": " Utility method for less verbose code. ",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 1
  },
  {
    "name": "JSType.hashCode",
    "class_name": "com.google.javascript.rhino.jstype.JSType",
    "signature": "com.google.javascript.rhino.jstype.JSType.hashCode()",
    "snippet": "  @Override\n  public int hashCode() {\n    return System.identityHashCode(this);\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 1
  },
  {
    "name": "JSType.isAllType",
    "class_name": "com.google.javascript.rhino.jstype.JSType",
    "signature": "com.google.javascript.rhino.jstype.JSType.isAllType()",
    "snippet": "  public boolean isAllType() {\n    return false;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 1
  },
  {
    "name": "JSType.isEmptyType",
    "class_name": "com.google.javascript.rhino.jstype.JSType",
    "signature": "com.google.javascript.rhino.jstype.JSType.isEmptyType()",
    "snippet": "  public final boolean isEmptyType() {\n    return isNoType() || isNoObjectType() || isNoResolvedType() ||\n        (registry.getNativeFunctionType(\n             JSTypeNative.LEAST_FUNCTION_TYPE) == this);\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 1
  },
  {
    "name": "JSType.isEquivalentTo",
    "class_name": "com.google.javascript.rhino.jstype.JSType",
    "signature": "com.google.javascript.rhino.jstype.JSType.isEquivalentTo(JSType)",
    "snippet": "  public boolean isEquivalentTo(JSType jsType) {\n    if (jsType instanceof ProxyObjectType) {\n      return jsType.isEquivalentTo(this);\n    }\n    // Relies on the fact that for the base {@link JSType}, only one\n    // instance of each sub-type will ever be created in a given registry, so\n    // there is no need to verify members. If the object pointers are not\n    // identical, then the type member must be different.\n    return this == jsType;\n  }",
    "comment": " Checks if two types are equivalent. ",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 1
  },
  {
    "name": "JSType.isFunctionType",
    "class_name": "com.google.javascript.rhino.jstype.JSType",
    "signature": "com.google.javascript.rhino.jstype.JSType.isFunctionType()",
    "snippet": "  public final boolean isFunctionType() {\n    return toMaybeFunctionType() != null;\n  }",
    "comment": "Returns true if toMaybeFunctionType returns a non-null FunctionType. */",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 1
  },
  {
    "name": "JSType.isNoObjectType",
    "class_name": "com.google.javascript.rhino.jstype.JSType",
    "signature": "com.google.javascript.rhino.jstype.JSType.isNoObjectType()",
    "snippet": "  public boolean isNoObjectType() {\n    return false;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 1
  },
  {
    "name": "JSType.isNoResolvedType",
    "class_name": "com.google.javascript.rhino.jstype.JSType",
    "signature": "com.google.javascript.rhino.jstype.JSType.isNoResolvedType()",
    "snippet": "  public boolean isNoResolvedType() {\n    return false;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 1
  },
  {
    "name": "JSType.isNoType",
    "class_name": "com.google.javascript.rhino.jstype.JSType",
    "signature": "com.google.javascript.rhino.jstype.JSType.isNoType()",
    "snippet": "  public boolean isNoType() {\n    return false;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 1
  },
  {
    "name": "JSType.isNominalType",
    "class_name": "com.google.javascript.rhino.jstype.JSType",
    "signature": "com.google.javascript.rhino.jstype.JSType.isNominalType()",
    "snippet": "  public boolean isNominalType() {\n    return false;\n  }",
    "comment": " Whether this type is a nominal type (a named instance object or a named enum). ",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 1
  },
  {
    "name": "JSType.isRecordType",
    "class_name": "com.google.javascript.rhino.jstype.JSType",
    "signature": "com.google.javascript.rhino.jstype.JSType.isRecordType()",
    "snippet": "  public boolean isRecordType() {\n    return toMaybeRecordType() != null;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 1
  },
  {
    "name": "JSType.isResolved",
    "class_name": "com.google.javascript.rhino.jstype.JSType",
    "signature": "com.google.javascript.rhino.jstype.JSType.isResolved()",
    "snippet": "  public final boolean isResolved() {\n    return resolved;\n  }",
    "comment": "Whether the type has been resolved. */",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 1
  },
  {
    "name": "JSType.isSubtype",
    "class_name": "com.google.javascript.rhino.jstype.JSType",
    "signature": "com.google.javascript.rhino.jstype.JSType.isSubtype(JSType)",
    "snippet": "  public boolean isSubtype(JSType that) {\n    return isSubtypeHelper(this, that);\n  }",
    "comment": " Checks whether {@code this} is a subtype of {@code that}.<p>  Subtyping rules: <ul> <li>(unknown) &mdash; every type is a subtype of the Unknown type.</li> <li>(no) &mdash; the No type is a subtype of every type.</li> <li>(no-object) &mdash; the NoObject type is a subtype of every object type (i.e. subtypes of the Object type).</li> <li>(ref) &mdash; a type is a subtype of itself.</li> <li>(union-l) &mdash; A union type is a subtype of a type U if all the union type's constituents are a subtype of U. Formally<br> {@code (T<sub>1</sub>, &hellip;, T<sub>n</sub>) &lt;: U} if and only {@code T<sub>k</sub> &lt;: U} for all {@code k &isin; 1..n}.</li> <li>(union-r) &mdash; A type U is a subtype of a union type if it is a subtype of one of the union type's constituents. Formally<br> {@code U &lt;: (T<sub>1</sub>, &hellip;, T<sub>n</sub>)} if and only if {@code U &lt;: T<sub>k</sub>} for some index {@code k}.</li> <li>(objects) &mdash; an Object {@code O<sub>1</sub>} is a subtype of an object {@code O<sub>2</sub>} if it has more properties than {@code O<sub>2</sub>} and all common properties are pairwise subtypes.</li> </ul>  @return {@code this &lt;: that} ",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 1
  },
  {
    "name": "JSType.isSubtypeHelper",
    "class_name": "com.google.javascript.rhino.jstype.JSType",
    "signature": "com.google.javascript.rhino.jstype.JSType.isSubtypeHelper(JSType,JSType)",
    "snippet": "  static boolean isSubtypeHelper(JSType thisType, JSType thatType) {\n    // unknown\n    if (thatType.isUnknownType()) {\n      return true;\n    }\n    // equality\n    if (thisType.isEquivalentTo(thatType)) {\n      return true;\n    }\n    // all type\n    if (thatType.isAllType()) {\n      return true;\n    }\n    // unions\n    if (thatType.isUnionType()) {\n      UnionType union = thatType.toMaybeUnionType();\n      for (JSType element : union.alternates) {\n        if (thisType.isSubtype(element)) {\n          return true;\n        }\n      }\n    }\n    // proxy types\n    if (thatType instanceof ProxyObjectType) {\n      return thisType.isSubtype(\n          ((ProxyObjectType) thatType).getReferencedTypeInternal());\n    }\n    return false;\n  }",
    "comment": " A generic implementation meant to be used as a helper for common subtyping cases. ",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 1
  },
  {
    "name": "JSType.isUnionType",
    "class_name": "com.google.javascript.rhino.jstype.JSType",
    "signature": "com.google.javascript.rhino.jstype.JSType.isUnionType()",
    "snippet": "  public final boolean isUnionType() {\n    return toMaybeUnionType() != null;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 1
  },
  {
    "name": "JSType.isUnknownType",
    "class_name": "com.google.javascript.rhino.jstype.JSType",
    "signature": "com.google.javascript.rhino.jstype.JSType.isUnknownType()",
    "snippet": "  public boolean isUnknownType() {\n    return false;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 1
  },
  {
    "name": "JSType.resolve",
    "class_name": "com.google.javascript.rhino.jstype.JSType",
    "signature": "com.google.javascript.rhino.jstype.JSType.resolve(ErrorReporter,StaticScope)",
    "snippet": "  public final JSType resolve(ErrorReporter t, StaticScope<JSType> scope) {\n    if (resolved) {\n      // TODO(nicksantos): Check to see if resolve() looped back on itself.\n      // Preconditions.checkNotNull(resolveResult);\n      if (resolveResult == null) {\n        return registry.getNativeType(JSTypeNative.UNKNOWN_TYPE);\n      }\n      return resolveResult;\n    }\n    resolved = true;\n    resolveResult = resolveInternal(t, scope);\n    resolveResult.setResolvedTypeInternal(resolveResult);\n    return resolveResult;\n  }",
    "comment": " Resolve this type in the given scope.  The returned value must be equal to {@code this}, as defined by {@link #isEquivalentTo}. It may or may not be the same object. This method may modify the internal state of {@code this}, as long as it does so in a way that preserves Object equality.  For efficiency, we should only resolve a type once per compilation job. For incremental compilations, one compilation job may need the artifacts from a previous generation, so we will eventually need a generational flag instead of a boolean one. ",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 1
  },
  {
    "name": "JSType.restrictByNotNullOrUndefined",
    "class_name": "com.google.javascript.rhino.jstype.JSType",
    "signature": "com.google.javascript.rhino.jstype.JSType.restrictByNotNullOrUndefined()",
    "snippet": "  public JSType restrictByNotNullOrUndefined() {\n    return this;\n  }",
    "comment": " If this is a union type, returns a union type that does not include the null or undefined type. ",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 1
  },
  {
    "name": "JSType.safeResolve",
    "class_name": "com.google.javascript.rhino.jstype.JSType",
    "signature": "com.google.javascript.rhino.jstype.JSType.safeResolve(JSType,ErrorReporter,StaticScope)",
    "snippet": "  static final JSType safeResolve(\n      JSType type, ErrorReporter t, StaticScope<JSType> scope) {\n    return type == null ? null : type.resolve(t, scope);\n  }",
    "comment": " A null-safe resolve. @see #resolve ",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 1
  },
  {
    "name": "JSType.setResolvedTypeInternal",
    "class_name": "com.google.javascript.rhino.jstype.JSType",
    "signature": "com.google.javascript.rhino.jstype.JSType.setResolvedTypeInternal(JSType)",
    "snippet": "  void setResolvedTypeInternal(JSType type) {\n    resolveResult = type;\n    resolved = true;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 1
  },
  {
    "name": "JSType.toMaybeFunctionType",
    "class_name": "com.google.javascript.rhino.jstype.JSType",
    "signature": "com.google.javascript.rhino.jstype.JSType.toMaybeFunctionType()",
    "snippet": "  public FunctionType toMaybeFunctionType() {\n    return null;\n  }",
    "comment": " Downcasts this to a FunctionType, or returns null if this is not a function.  For the purposes of this function, we define a MaybeFunctionType as any type in the sub-lattice { x | LEAST_FUNCTION_TYPE <= x <= GREATEST_FUNCTION_TYPE } This definition excludes bottom types like NoType and NoObjectType.  This definition is somewhat arbitrary and axiomatic, but this is the definition that makes the most sense for the most callers. ",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 1
  },
  {
    "name": "JSType.toMaybeRecordType",
    "class_name": "com.google.javascript.rhino.jstype.JSType",
    "signature": "com.google.javascript.rhino.jstype.JSType.toMaybeRecordType()",
    "snippet": "  RecordType toMaybeRecordType() {\n    return null;\n  }",
    "comment": " Downcasts this to a RecordType, or returns null if this is not a RecordType. ",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 1
  },
  {
    "name": "JSType.toMaybeUnionType",
    "class_name": "com.google.javascript.rhino.jstype.JSType",
    "signature": "com.google.javascript.rhino.jstype.JSType.toMaybeUnionType()",
    "snippet": "  public UnionType toMaybeUnionType() {\n    return null;\n  }",
    "comment": " Downcasts this to a UnionType, or returns null if this is not a UnionType.  Named in honor of Haskell's Maybe type constructor. ",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 1
  },
  {
    "name": "JSType.toObjectType",
    "class_name": "com.google.javascript.rhino.jstype.JSType",
    "signature": "com.google.javascript.rhino.jstype.JSType.toObjectType()",
    "snippet": "  public ObjectType toObjectType() {\n    return this instanceof ObjectType ? (ObjectType) this : null;\n  }",
    "comment": " Casts this to an ObjectType, or returns null if this is not an ObjectType.  Does not change the underlying JS type. If you want to simulate JS autoboxing or dereferencing, you should use autoboxesTo() or dereference(). Those methods may change the underlying JS type. ",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 1
  },
  {
    "name": "JSTypeRegistry.JSTypeRegistry",
    "class_name": "com.google.javascript.rhino.jstype.JSTypeRegistry",
    "signature": "com.google.javascript.rhino.jstype.JSTypeRegistry.JSTypeRegistry(ErrorReporter)",
    "snippet": "  public JSTypeRegistry(ErrorReporter reporter) {\n    this(reporter, false);\n  }",
    "comment": " Constructs a new type registry populated with the built-in types. ",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 1
  },
  {
    "name": "JSTypeRegistry.JSTypeRegistry",
    "class_name": "com.google.javascript.rhino.jstype.JSTypeRegistry",
    "signature": "com.google.javascript.rhino.jstype.JSTypeRegistry.JSTypeRegistry(ErrorReporter,boolean)",
    "snippet": "  public JSTypeRegistry(\n      ErrorReporter reporter, boolean tolerateUndefinedValues) {\n    this.reporter = reporter;\n    nativeTypes = new JSType[JSTypeNative.values().length];\n    namesToTypes = new HashMap<String, JSType>();\n    resetForTypeCheck();\n    this.tolerateUndefinedValues = tolerateUndefinedValues;\n  }",
    "comment": " Constructs a new type registry populated with the built-in types. ",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 1
  },
  {
    "name": "JSTypeRegistry.addReferenceTypeIndexedByProperty",
    "class_name": "com.google.javascript.rhino.jstype.JSTypeRegistry",
    "signature": "com.google.javascript.rhino.jstype.JSTypeRegistry.addReferenceTypeIndexedByProperty(String,JSType)",
    "snippet": "  private void addReferenceTypeIndexedByProperty(\n      String propertyName, JSType type) {\n    if (type instanceof ObjectType && ((ObjectType) type).hasReferenceName()) {\n      Map<String, ObjectType> typeSet =\n          eachRefTypeIndexedByProperty.get(propertyName);\n      if (typeSet == null) {\n        typeSet = Maps.newHashMap();\n        eachRefTypeIndexedByProperty.put(propertyName, typeSet);\n      }\n      ObjectType objType = (ObjectType) type;\n      typeSet.put(objType.getReferenceName(), objType);\n    } else if (type instanceof NamedType) {\n      addReferenceTypeIndexedByProperty(\n          propertyName, ((NamedType) type).getReferencedType());\n    } else if (type.isUnionType()) {\n      for (JSType alternate : type.toMaybeUnionType().getAlternates()) {\n        addReferenceTypeIndexedByProperty(propertyName, alternate);\n      }\n    }\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 1
  },
  {
    "name": "JSTypeRegistry.createAnonymousObjectType",
    "class_name": "com.google.javascript.rhino.jstype.JSTypeRegistry",
    "signature": "com.google.javascript.rhino.jstype.JSTypeRegistry.createAnonymousObjectType()",
    "snippet": "  public ObjectType createAnonymousObjectType() {\n    PrototypeObjectType type =\n        new PrototypeObjectType(this, null, null);\n    type.setPrettyPrint(true);\n    return type;\n  }",
    "comment": " Create an anonymous object type. ",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 1
  },
  {
    "name": "JSTypeRegistry.createArrowType",
    "class_name": "com.google.javascript.rhino.jstype.JSTypeRegistry",
    "signature": "com.google.javascript.rhino.jstype.JSTypeRegistry.createArrowType(Node)",
    "snippet": "  ArrowType createArrowType(Node parametersNode) {\n    return new ArrowType(this, parametersNode, null);\n  }",
    "comment": " Creates an arrow type with an unknown return type.  @param parametersNode the parameters' types, formatted as a Node with param names and optionality info. ",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 1
  },
  {
    "name": "JSTypeRegistry.createArrowType",
    "class_name": "com.google.javascript.rhino.jstype.JSTypeRegistry",
    "signature": "com.google.javascript.rhino.jstype.JSTypeRegistry.createArrowType(Node,JSType)",
    "snippet": "  ArrowType createArrowType(Node parametersNode, JSType returnType) {\n    return new ArrowType(this, parametersNode, returnType);\n  }",
    "comment": " Creates an arrow type, an abstract representation of the parameters and return value of a function.  @param parametersNode the parameters' types, formatted as a Node with param names and optionality info. @param returnType the function's return type ",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 1
  },
  {
    "name": "JSTypeRegistry.createConstructorType",
    "class_name": "com.google.javascript.rhino.jstype.JSTypeRegistry",
    "signature": "com.google.javascript.rhino.jstype.JSTypeRegistry.createConstructorType(String,Node,Node,JSType)",
    "snippet": "  public FunctionType createConstructorType(String name, Node source,\n      Node parameters, JSType returnType) {\n    return new FunctionType(this, name, source,\n        createArrowType(parameters, returnType), null,\n        null, true, false);\n  }",
    "comment": " Creates a constructor function type. @param name the function's name or {@code null} to indicate that the function is anonymous. @param source the node defining this function. Its type ({@link Node#getType()}) must be {@link Token#FUNCTION}. @param parameters the function's parameters or {@code null} to indicate that the parameter types are unknown. @param returnType the function's return type or {@code null} to indicate that the return type is unknown. ",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 1
  },
  {
    "name": "JSTypeRegistry.createFunctionType",
    "class_name": "com.google.javascript.rhino.jstype.JSTypeRegistry",
    "signature": "com.google.javascript.rhino.jstype.JSTypeRegistry.createFunctionType(JSType,Node)",
    "snippet": "  public FunctionType createFunctionType(\n      JSType returnType, Node parameters) {\n    return new FunctionBuilder(this)\n        .withParamsNode(parameters)\n        .withReturnType(returnType)\n        .build();\n  }",
    "comment": " @param parameters the function's parameters or {@code null} to indicate that the parameter types are unknown. @param returnType the function's return type or {@code null} to indicate that the return type is unknown. ",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 1
  },
  {
    "name": "JSTypeRegistry.createFunctionType",
    "class_name": "com.google.javascript.rhino.jstype.JSTypeRegistry",
    "signature": "com.google.javascript.rhino.jstype.JSTypeRegistry.createFunctionType(JSType,boolean,JSType[])",
    "snippet": "  public FunctionType createFunctionType(JSType returnType,\n      boolean lastVarArgs, JSType... parameterTypes) {\n    if (lastVarArgs) {\n      return createFunctionTypeWithVarArgs(returnType, parameterTypes);\n    } else {\n      return createFunctionType(returnType, parameterTypes);\n    }\n  }",
    "comment": " Creates a function type. @param returnType the function's return type @param lastVarArgs whether the last parameter type should be considered as an extensible var_args parameter @param parameterTypes the parameters' types ",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 1
  },
  {
    "name": "JSTypeRegistry.createFunctionTypeWithVarArgs",
    "class_name": "com.google.javascript.rhino.jstype.JSTypeRegistry",
    "signature": "com.google.javascript.rhino.jstype.JSTypeRegistry.createFunctionTypeWithVarArgs(JSType,JSType[])",
    "snippet": "  public FunctionType createFunctionTypeWithVarArgs(\n      JSType returnType, JSType... parameterTypes) {\n    return createFunctionType(\n        returnType, createParametersWithVarArgs(parameterTypes));\n  }",
    "comment": " Creates a function type. The last parameter type of the function is considered a variable length argument.  @param returnType the function's return type @param parameterTypes the parameters' types ",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 1
  },
  {
    "name": "JSTypeRegistry.createNullableType",
    "class_name": "com.google.javascript.rhino.jstype.JSTypeRegistry",
    "signature": "com.google.javascript.rhino.jstype.JSTypeRegistry.createNullableType(JSType)",
    "snippet": "  public JSType createNullableType(JSType type) {\n    return createUnionType(type, getNativeType(JSTypeNative.NULL_TYPE));\n  }",
    "comment": " Creates a type representing nullable values of the given type. @return the union of the type and the Null type ",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 1
  },
  {
    "name": "JSTypeRegistry.createOptionalParameters",
    "class_name": "com.google.javascript.rhino.jstype.JSTypeRegistry",
    "signature": "com.google.javascript.rhino.jstype.JSTypeRegistry.createOptionalParameters(JSType[])",
    "snippet": "  public Node createOptionalParameters(JSType... parameterTypes) {\n    FunctionParamBuilder builder = new FunctionParamBuilder(this);\n    builder.addOptionalParams(parameterTypes);\n    return builder.build();\n  }",
    "comment": " Creates a tree hierarchy representing a typed parameter list in which every parameter is optional. ",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 1
  },
  {
    "name": "JSTypeRegistry.createOptionalType",
    "class_name": "com.google.javascript.rhino.jstype.JSTypeRegistry",
    "signature": "com.google.javascript.rhino.jstype.JSTypeRegistry.createOptionalType(JSType)",
    "snippet": "  public JSType createOptionalType(JSType type) {\n    if (type instanceof UnknownType || type.isAllType()) {\n      return type;\n    } else {\n      return createUnionType(type, getNativeType(JSTypeNative.VOID_TYPE));\n    }\n  }",
    "comment": " Creates a type representing optional values of the given type. @return the union of the type and the void type ",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 1
  },
  {
    "name": "JSTypeRegistry.createParameters",
    "class_name": "com.google.javascript.rhino.jstype.JSTypeRegistry",
    "signature": "com.google.javascript.rhino.jstype.JSTypeRegistry.createParameters(boolean,JSType[])",
    "snippet": "  private Node createParameters(boolean lastVarArgs, JSType... parameterTypes) {\n    FunctionParamBuilder builder = new FunctionParamBuilder(this);\n    int max = parameterTypes.length - 1;\n    for (int i = 0; i <= max; i++) {\n      if (lastVarArgs && i == max) {\n        builder.addVarArgs(parameterTypes[i]);\n      } else {\n        builder.addRequiredParams(parameterTypes[i]);\n      }\n    }\n    return builder.build();\n  }",
    "comment": " Creates a tree hierarchy representing a typed argument list.  @param lastVarArgs whether the last type should considered as a variable length argument. @param parameterTypes the parameter types. The last element of this array is considered a variable length argument is {@code lastVarArgs} is {@code true}. @return a tree hierarchy representing a typed argument list ",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 1
  },
  {
    "name": "JSTypeRegistry.createParametersWithVarArgs",
    "class_name": "com.google.javascript.rhino.jstype.JSTypeRegistry",
    "signature": "com.google.javascript.rhino.jstype.JSTypeRegistry.createParametersWithVarArgs(JSType[])",
    "snippet": "  public Node createParametersWithVarArgs(JSType... parameterTypes) {\n    return createParameters(true, parameterTypes);\n  }",
    "comment": " Creates a tree hierarchy representing a typed argument list. The last parameter type is considered a variable length argument.  @param parameterTypes the parameter types. The last element of this array is considered a variable length argument. @return a tree hierarchy representing a typed argument list. ",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 1
  },
  {
    "name": "JSTypeRegistry.createRecordType",
    "class_name": "com.google.javascript.rhino.jstype.JSTypeRegistry",
    "signature": "com.google.javascript.rhino.jstype.JSTypeRegistry.createRecordType(Map)",
    "snippet": "  public RecordType createRecordType(Map<String, RecordProperty> properties) {\n    return new RecordType(this, properties);\n  }",
    "comment": " Creates a record type. ",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 1
  },
  {
    "name": "JSTypeRegistry.createUnionType",
    "class_name": "com.google.javascript.rhino.jstype.JSTypeRegistry",
    "signature": "com.google.javascript.rhino.jstype.JSTypeRegistry.createUnionType(JSType[])",
    "snippet": "  public JSType createUnionType(JSType... variants) {\n    UnionTypeBuilder builder = new UnionTypeBuilder(this);\n    for (JSType type : variants) {\n      builder.addAlternate(type);\n    }\n    return builder.build();\n  }",
    "comment": " Creates a union type whose variants are the arguments. ",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 1
  },
  {
    "name": "JSTypeRegistry.forwardDeclareType",
    "class_name": "com.google.javascript.rhino.jstype.JSTypeRegistry",
    "signature": "com.google.javascript.rhino.jstype.JSTypeRegistry.forwardDeclareType(String)",
    "snippet": "  public void forwardDeclareType(String name) {\n    forwardDeclaredTypes.add(name);\n  }",
    "comment": " Records a forward-declared type name. We will not emit errors if this type name never resolves to anything. ",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 1
  },
  {
    "name": "JSTypeRegistry.getNativeFunctionType",
    "class_name": "com.google.javascript.rhino.jstype.JSTypeRegistry",
    "signature": "com.google.javascript.rhino.jstype.JSTypeRegistry.getNativeFunctionType(JSTypeNative)",
    "snippet": "  public FunctionType getNativeFunctionType(JSTypeNative typeId) {\n    return (FunctionType) getNativeType(typeId);\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 1
  },
  {
    "name": "JSTypeRegistry.getNativeObjectType",
    "class_name": "com.google.javascript.rhino.jstype.JSTypeRegistry",
    "signature": "com.google.javascript.rhino.jstype.JSTypeRegistry.getNativeObjectType(JSTypeNative)",
    "snippet": "  public ObjectType getNativeObjectType(JSTypeNative typeId) {\n    return (ObjectType) getNativeType(typeId);\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 1
  },
  {
    "name": "JSTypeRegistry.getNativeType",
    "class_name": "com.google.javascript.rhino.jstype.JSTypeRegistry",
    "signature": "com.google.javascript.rhino.jstype.JSTypeRegistry.getNativeType(JSTypeNative)",
    "snippet": "  public JSType getNativeType(JSTypeNative typeId) {\n    return nativeTypes[typeId.ordinal()];\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 1
  },
  {
    "name": "JSTypeRegistry.getType",
    "class_name": "com.google.javascript.rhino.jstype.JSTypeRegistry",
    "signature": "com.google.javascript.rhino.jstype.JSTypeRegistry.getType(String)",
    "snippet": "  public JSType getType(String jsTypeName) {\n    // TODO(user): Push every local type name out of namesToTypes so that\n    // NamedType#resolve is correct.\n    if (jsTypeName.equals(templateTypeName)) {\n      return templateType;\n    }\n    return namesToTypes.get(jsTypeName);\n  }",
    "comment": " Looks up a type by name.  @param jsTypeName The name string. @return the corresponding JSType object or {@code null} it cannot be found ",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 1
  },
  {
    "name": "JSTypeRegistry.initializeBuiltInTypes",
    "class_name": "com.google.javascript.rhino.jstype.JSTypeRegistry",
    "signature": "com.google.javascript.rhino.jstype.JSTypeRegistry.initializeBuiltInTypes()",
    "snippet": "  private void initializeBuiltInTypes() {\n    // These locals shouldn't be all caps.\n    BooleanType BOOLEAN_TYPE = new BooleanType(this);\n    registerNativeType(JSTypeNative.BOOLEAN_TYPE, BOOLEAN_TYPE);\n\n    NullType NULL_TYPE = new NullType(this);\n    registerNativeType(JSTypeNative.NULL_TYPE, NULL_TYPE);\n\n    NumberType NUMBER_TYPE = new NumberType(this);\n    registerNativeType(JSTypeNative.NUMBER_TYPE, NUMBER_TYPE);\n\n    StringType STRING_TYPE = new StringType(this);\n    registerNativeType(JSTypeNative.STRING_TYPE, STRING_TYPE);\n\n    UnknownType UNKNOWN_TYPE = new UnknownType(this, false);\n    registerNativeType(JSTypeNative.UNKNOWN_TYPE, UNKNOWN_TYPE);\n    registerNativeType(\n        JSTypeNative.CHECKED_UNKNOWN_TYPE, new UnknownType(this, true));\n\n    VoidType VOID_TYPE = new VoidType(this);\n    registerNativeType(JSTypeNative.VOID_TYPE, VOID_TYPE);\n\n    AllType ALL_TYPE = new AllType(this);\n    registerNativeType(JSTypeNative.ALL_TYPE, ALL_TYPE);\n\n    // Top Level Prototype (the One)\n    // The initializations of TOP_LEVEL_PROTOTYPE and OBJECT_FUNCTION_TYPE\n    // use each other's results, so at least one of them will get null\n    // instead of an actual type; however, this seems to be benign.\n    PrototypeObjectType TOP_LEVEL_PROTOTYPE =\n        new PrototypeObjectType(this, null, null, true);\n    registerNativeType(JSTypeNative.TOP_LEVEL_PROTOTYPE, TOP_LEVEL_PROTOTYPE);\n\n    // Object\n    FunctionType OBJECT_FUNCTION_TYPE =\n        new FunctionType(this, \"Object\", null,\n            createArrowType(createOptionalParameters(ALL_TYPE), UNKNOWN_TYPE),\n            null, null, true, true);\n\n    OBJECT_FUNCTION_TYPE.setPrototype(TOP_LEVEL_PROTOTYPE, null);\n    registerNativeType(JSTypeNative.OBJECT_FUNCTION_TYPE, OBJECT_FUNCTION_TYPE);\n\n    ObjectType OBJECT_TYPE = OBJECT_FUNCTION_TYPE.getInstanceType();\n    registerNativeType(JSTypeNative.OBJECT_TYPE, OBJECT_TYPE);\n\n    ObjectType OBJECT_PROTOTYPE = OBJECT_FUNCTION_TYPE.getPrototype();\n    registerNativeType(JSTypeNative.OBJECT_PROTOTYPE, OBJECT_PROTOTYPE);\n\n    // Function\n    FunctionType FUNCTION_FUNCTION_TYPE =\n        new FunctionType(this, \"Function\", null,\n            createArrowType(\n                createParametersWithVarArgs(ALL_TYPE), UNKNOWN_TYPE),\n            null, null, true, true);\n    FUNCTION_FUNCTION_TYPE.setPrototypeBasedOn(OBJECT_TYPE);\n    registerNativeType(\n        JSTypeNative.FUNCTION_FUNCTION_TYPE, FUNCTION_FUNCTION_TYPE);\n\n    ObjectType FUNCTION_PROTOTYPE = FUNCTION_FUNCTION_TYPE.getPrototype();\n    registerNativeType(JSTypeNative.FUNCTION_PROTOTYPE, FUNCTION_PROTOTYPE);\n\n    NoType NO_TYPE = new NoType(this);\n    registerNativeType(JSTypeNative.NO_TYPE, NO_TYPE);\n\n    NoObjectType NO_OBJECT_TYPE = new NoObjectType(this);\n    registerNativeType(JSTypeNative.NO_OBJECT_TYPE, NO_OBJECT_TYPE);\n\n    NoObjectType NO_RESOLVED_TYPE = new NoResolvedType(this);\n    registerNativeType(JSTypeNative.NO_RESOLVED_TYPE, NO_RESOLVED_TYPE);\n\n    // Array\n    FunctionType ARRAY_FUNCTION_TYPE =\n      new FunctionType(this, \"Array\", null,\n          createArrowType(createParametersWithVarArgs(ALL_TYPE), null),\n          null, null, true, true);\n    ARRAY_FUNCTION_TYPE.getInternalArrowType().returnType =\n        ARRAY_FUNCTION_TYPE.getInstanceType();\n\n    ObjectType arrayPrototype = ARRAY_FUNCTION_TYPE.getPrototype();\n    registerNativeType(JSTypeNative.ARRAY_FUNCTION_TYPE, ARRAY_FUNCTION_TYPE);\n\n    ObjectType ARRAY_TYPE = ARRAY_FUNCTION_TYPE.getInstanceType();\n    registerNativeType(JSTypeNative.ARRAY_TYPE, ARRAY_TYPE);\n\n    // Boolean\n    FunctionType BOOLEAN_OBJECT_FUNCTION_TYPE =\n        new FunctionType(this, \"Boolean\", null,\n            createArrowType(createParameters(false, ALL_TYPE), BOOLEAN_TYPE),\n            null, null, true, true);\n    ObjectType booleanPrototype = BOOLEAN_OBJECT_FUNCTION_TYPE.getPrototype();\n    registerNativeType(\n        JSTypeNative.BOOLEAN_OBJECT_FUNCTION_TYPE,\n        BOOLEAN_OBJECT_FUNCTION_TYPE);\n\n    ObjectType BOOLEAN_OBJECT_TYPE =\n        BOOLEAN_OBJECT_FUNCTION_TYPE.getInstanceType();\n    registerNativeType(JSTypeNative.BOOLEAN_OBJECT_TYPE, BOOLEAN_OBJECT_TYPE);\n\n    // Date\n    FunctionType DATE_FUNCTION_TYPE =\n      new FunctionType(this, \"Date\", null,\n          createArrowType(\n              createOptionalParameters(UNKNOWN_TYPE, UNKNOWN_TYPE, UNKNOWN_TYPE,\n                  UNKNOWN_TYPE, UNKNOWN_TYPE, UNKNOWN_TYPE, UNKNOWN_TYPE),\n              STRING_TYPE),\n          null, null, true, true);\n    ObjectType datePrototype = DATE_FUNCTION_TYPE.getPrototype();\n    registerNativeType(JSTypeNative.DATE_FUNCTION_TYPE, DATE_FUNCTION_TYPE);\n\n    ObjectType DATE_TYPE = DATE_FUNCTION_TYPE.getInstanceType();\n    registerNativeType(JSTypeNative.DATE_TYPE, DATE_TYPE);\n\n    // Error\n    FunctionType ERROR_FUNCTION_TYPE = new ErrorFunctionType(this, \"Error\");\n    registerNativeType(JSTypeNative.ERROR_FUNCTION_TYPE, ERROR_FUNCTION_TYPE);\n\n    ObjectType ERROR_TYPE = ERROR_FUNCTION_TYPE.getInstanceType();\n    registerNativeType(JSTypeNative.ERROR_TYPE, ERROR_TYPE);\n\n    // EvalError\n    FunctionType EVAL_ERROR_FUNCTION_TYPE =\n        new ErrorFunctionType(this, \"EvalError\");\n    EVAL_ERROR_FUNCTION_TYPE.setPrototypeBasedOn(ERROR_TYPE);\n    registerNativeType(\n        JSTypeNative.EVAL_ERROR_FUNCTION_TYPE, EVAL_ERROR_FUNCTION_TYPE);\n\n    ObjectType EVAL_ERROR_TYPE = EVAL_ERROR_FUNCTION_TYPE.getInstanceType();\n    registerNativeType(JSTypeNative.EVAL_ERROR_TYPE, EVAL_ERROR_TYPE);\n\n    // RangeError\n    FunctionType RANGE_ERROR_FUNCTION_TYPE =\n        new ErrorFunctionType(this, \"RangeError\");\n    RANGE_ERROR_FUNCTION_TYPE.setPrototypeBasedOn(ERROR_TYPE);\n    registerNativeType(\n        JSTypeNative.RANGE_ERROR_FUNCTION_TYPE, RANGE_ERROR_FUNCTION_TYPE);\n\n    ObjectType RANGE_ERROR_TYPE = RANGE_ERROR_FUNCTION_TYPE.getInstanceType();\n    registerNativeType(JSTypeNative.RANGE_ERROR_TYPE, RANGE_ERROR_TYPE);\n\n    // ReferenceError\n    FunctionType REFERENCE_ERROR_FUNCTION_TYPE =\n        new ErrorFunctionType(this, \"ReferenceError\");\n    REFERENCE_ERROR_FUNCTION_TYPE.setPrototypeBasedOn(ERROR_TYPE);\n    registerNativeType(\n        JSTypeNative.REFERENCE_ERROR_FUNCTION_TYPE,\n        REFERENCE_ERROR_FUNCTION_TYPE);\n\n    ObjectType REFERENCE_ERROR_TYPE =\n        REFERENCE_ERROR_FUNCTION_TYPE.getInstanceType();\n    registerNativeType(JSTypeNative.REFERENCE_ERROR_TYPE, REFERENCE_ERROR_TYPE);\n\n    // SyntaxError\n    FunctionType SYNTAX_ERROR_FUNCTION_TYPE =\n        new ErrorFunctionType(this, \"SyntaxError\");\n    SYNTAX_ERROR_FUNCTION_TYPE.setPrototypeBasedOn(ERROR_TYPE);\n    registerNativeType(\n        JSTypeNative.SYNTAX_ERROR_FUNCTION_TYPE, SYNTAX_ERROR_FUNCTION_TYPE);\n\n    ObjectType SYNTAX_ERROR_TYPE = SYNTAX_ERROR_FUNCTION_TYPE.getInstanceType();\n    registerNativeType(JSTypeNative.SYNTAX_ERROR_TYPE, SYNTAX_ERROR_TYPE);\n\n    // TypeError\n    FunctionType TYPE_ERROR_FUNCTION_TYPE =\n        new ErrorFunctionType(this, \"TypeError\");\n    TYPE_ERROR_FUNCTION_TYPE.setPrototypeBasedOn(ERROR_TYPE);\n    registerNativeType(\n        JSTypeNative.TYPE_ERROR_FUNCTION_TYPE, TYPE_ERROR_FUNCTION_TYPE);\n\n    ObjectType TYPE_ERROR_TYPE = TYPE_ERROR_FUNCTION_TYPE.getInstanceType();\n    registerNativeType(JSTypeNative.TYPE_ERROR_TYPE, TYPE_ERROR_TYPE);\n\n    // URIError\n    FunctionType URI_ERROR_FUNCTION_TYPE =\n        new ErrorFunctionType(this, \"URIError\");\n    URI_ERROR_FUNCTION_TYPE.setPrototypeBasedOn(ERROR_TYPE);\n    registerNativeType(\n        JSTypeNative.URI_ERROR_FUNCTION_TYPE, URI_ERROR_FUNCTION_TYPE);\n\n    ObjectType URI_ERROR_TYPE = URI_ERROR_FUNCTION_TYPE.getInstanceType();\n    registerNativeType(JSTypeNative.URI_ERROR_TYPE, URI_ERROR_TYPE);\n\n    // Number\n    FunctionType NUMBER_OBJECT_FUNCTION_TYPE =\n        new FunctionType(this, \"Number\", null,\n            createArrowType(createParameters(false, ALL_TYPE), NUMBER_TYPE),\n            null, null, true, true);\n    ObjectType numberPrototype = NUMBER_OBJECT_FUNCTION_TYPE.getPrototype();\n    registerNativeType(\n        JSTypeNative.NUMBER_OBJECT_FUNCTION_TYPE, NUMBER_OBJECT_FUNCTION_TYPE);\n\n    ObjectType NUMBER_OBJECT_TYPE =\n        NUMBER_OBJECT_FUNCTION_TYPE.getInstanceType();\n    registerNativeType(JSTypeNative.NUMBER_OBJECT_TYPE, NUMBER_OBJECT_TYPE);\n\n    // RegExp\n    FunctionType REGEXP_FUNCTION_TYPE =\n      new FunctionType(this, \"RegExp\", null,\n          createArrowType(createOptionalParameters(ALL_TYPE, ALL_TYPE)),\n          null, null, true, true);\n    REGEXP_FUNCTION_TYPE.getInternalArrowType().returnType =\n        REGEXP_FUNCTION_TYPE.getInstanceType();\n\n    ObjectType regexpPrototype = REGEXP_FUNCTION_TYPE.getPrototype();\n    registerNativeType(JSTypeNative.REGEXP_FUNCTION_TYPE, REGEXP_FUNCTION_TYPE);\n\n    ObjectType REGEXP_TYPE = REGEXP_FUNCTION_TYPE.getInstanceType();\n    registerNativeType(JSTypeNative.REGEXP_TYPE, REGEXP_TYPE);\n\n    // String\n    FunctionType STRING_OBJECT_FUNCTION_TYPE =\n        new FunctionType(this, \"String\", null,\n            createArrowType(createParameters(false, ALL_TYPE), STRING_TYPE),\n            null, null, true, true);\n    ObjectType stringPrototype = STRING_OBJECT_FUNCTION_TYPE.getPrototype();\n    registerNativeType(\n        JSTypeNative.STRING_OBJECT_FUNCTION_TYPE, STRING_OBJECT_FUNCTION_TYPE);\n\n    ObjectType STRING_OBJECT_TYPE =\n        STRING_OBJECT_FUNCTION_TYPE.getInstanceType();\n    registerNativeType(\n        JSTypeNative.STRING_OBJECT_TYPE, STRING_OBJECT_TYPE);\n\n    // (Object,string,number)\n    JSType OBJECT_NUMBER_STRING =\n        createUnionType(OBJECT_TYPE, NUMBER_TYPE, STRING_TYPE);\n    registerNativeType(JSTypeNative.OBJECT_NUMBER_STRING, OBJECT_NUMBER_STRING);\n\n    // (Object,string,number,boolean)\n    JSType OBJECT_NUMBER_STRING_BOOLEAN =\n        createUnionType(OBJECT_TYPE, NUMBER_TYPE, STRING_TYPE, BOOLEAN_TYPE);\n    registerNativeType(JSTypeNative.OBJECT_NUMBER_STRING_BOOLEAN,\n        OBJECT_NUMBER_STRING_BOOLEAN);\n\n    // (string,number,boolean)\n    JSType NUMBER_STRING_BOOLEAN =\n        createUnionType(NUMBER_TYPE, STRING_TYPE, BOOLEAN_TYPE);\n    registerNativeType(JSTypeNative.NUMBER_STRING_BOOLEAN,\n        NUMBER_STRING_BOOLEAN);\n\n    // (string,number)\n    JSType NUMBER_STRING = createUnionType(NUMBER_TYPE, STRING_TYPE);\n    registerNativeType(JSTypeNative.NUMBER_STRING, NUMBER_STRING);\n\n    // Native object properties are filled in by externs...\n\n    // (String, string)\n    JSType STRING_VALUE_OR_OBJECT_TYPE =\n        createUnionType(STRING_OBJECT_TYPE, STRING_TYPE);\n    registerNativeType(\n        JSTypeNative.STRING_VALUE_OR_OBJECT_TYPE, STRING_VALUE_OR_OBJECT_TYPE);\n\n    // (Number, number)\n    JSType NUMBER_VALUE_OR_OBJECT_TYPE =\n        createUnionType(NUMBER_OBJECT_TYPE, NUMBER_TYPE);\n    registerNativeType(\n        JSTypeNative.NUMBER_VALUE_OR_OBJECT_TYPE, NUMBER_VALUE_OR_OBJECT_TYPE);\n\n    // unknown function type, i.e. (?...) -> ?\n    FunctionType U2U_FUNCTION_TYPE =\n        createFunctionType(UNKNOWN_TYPE, true, UNKNOWN_TYPE);\n    registerNativeType(JSTypeNative.U2U_FUNCTION_TYPE, U2U_FUNCTION_TYPE);\n\n    // unknown constructor type, i.e. (?...) -> ? with the NoObject type\n    // as instance type\n    FunctionType U2U_CONSTRUCTOR_TYPE =\n        // This is equivalent to\n        // createConstructorType(UNKNOWN_TYPE, true, UNKNOWN_TYPE), but,\n        // in addition, overrides getInstanceType() to return the NoObject type\n        // instead of a new anonymous object.\n        new FunctionType(this, \"Function\", null,\n            createArrowType(\n                createParametersWithVarArgs(UNKNOWN_TYPE),\n                UNKNOWN_TYPE),\n            NO_OBJECT_TYPE, null, true, true) {\n          private static final long serialVersionUID = 1L;\n\n          @Override public FunctionType getConstructor() {\n            return registry.getNativeFunctionType(\n                JSTypeNative.FUNCTION_FUNCTION_TYPE);\n          }\n        };\n\n    // The U2U_CONSTRUCTOR is weird, because it's the supertype of its\n    // own constructor.\n    registerNativeType(JSTypeNative.U2U_CONSTRUCTOR_TYPE, U2U_CONSTRUCTOR_TYPE);\n    registerNativeType(\n        JSTypeNative.FUNCTION_INSTANCE_TYPE, U2U_CONSTRUCTOR_TYPE);\n\n    FUNCTION_FUNCTION_TYPE.setInstanceType(U2U_CONSTRUCTOR_TYPE);\n    U2U_CONSTRUCTOR_TYPE.setImplicitPrototype(FUNCTION_PROTOTYPE);\n\n    // least function type, i.e. (All...) -> NoType\n    FunctionType LEAST_FUNCTION_TYPE =\n        createFunctionType(NO_TYPE, true, ALL_TYPE);\n    registerNativeType(JSTypeNative.LEAST_FUNCTION_TYPE, LEAST_FUNCTION_TYPE);\n\n    // the 'this' object in the global scope\n    FunctionType GLOBAL_THIS_CTOR =\n        new FunctionType(this, \"global this\", null,\n            createArrowType(createParameters(false, ALL_TYPE), NUMBER_TYPE),\n            null, null, true, true);\n    ObjectType GLOBAL_THIS = GLOBAL_THIS_CTOR.getInstanceType();\n    registerNativeType(JSTypeNative.GLOBAL_THIS, GLOBAL_THIS);\n\n    // greatest function type, i.e. (NoType...) -> All\n    FunctionType GREATEST_FUNCTION_TYPE =\n      createFunctionType(ALL_TYPE, true, NO_TYPE);\n    registerNativeType(JSTypeNative.GREATEST_FUNCTION_TYPE,\n        GREATEST_FUNCTION_TYPE);\n\n    // Register the prototype property. See the comments below in\n    // registerPropertyOnType about the bootstrapping process.\n    registerPropertyOnType(\"prototype\", OBJECT_FUNCTION_TYPE);\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 1
  },
  {
    "name": "JSTypeRegistry.initializeRegistry",
    "class_name": "com.google.javascript.rhino.jstype.JSTypeRegistry",
    "signature": "com.google.javascript.rhino.jstype.JSTypeRegistry.initializeRegistry()",
    "snippet": "  private void initializeRegistry() {\n    register(getNativeType(JSTypeNative.ARRAY_TYPE));\n    register(getNativeType(JSTypeNative.BOOLEAN_OBJECT_TYPE));\n    register(getNativeType(JSTypeNative.BOOLEAN_TYPE));\n    register(getNativeType(JSTypeNative.DATE_TYPE));\n    register(getNativeType(JSTypeNative.NULL_TYPE));\n    register(getNativeType(JSTypeNative.NULL_TYPE), \"Null\");\n    register(getNativeType(JSTypeNative.NUMBER_OBJECT_TYPE));\n    register(getNativeType(JSTypeNative.NUMBER_TYPE));\n    register(getNativeType(JSTypeNative.OBJECT_TYPE));\n    register(getNativeType(JSTypeNative.ERROR_TYPE));\n    register(getNativeType(JSTypeNative.URI_ERROR_TYPE));\n    register(getNativeType(JSTypeNative.EVAL_ERROR_TYPE));\n    register(getNativeType(JSTypeNative.TYPE_ERROR_TYPE));\n    register(getNativeType(JSTypeNative.RANGE_ERROR_TYPE));\n    register(getNativeType(JSTypeNative.REFERENCE_ERROR_TYPE));\n    register(getNativeType(JSTypeNative.SYNTAX_ERROR_TYPE));\n    register(getNativeType(JSTypeNative.REGEXP_TYPE));\n    register(getNativeType(JSTypeNative.STRING_OBJECT_TYPE));\n    register(getNativeType(JSTypeNative.STRING_TYPE));\n    register(getNativeType(JSTypeNative.VOID_TYPE));\n    register(getNativeType(JSTypeNative.VOID_TYPE), \"Undefined\");\n    register(getNativeType(JSTypeNative.VOID_TYPE), \"void\");\n    register(getNativeType(JSTypeNative.FUNCTION_INSTANCE_TYPE), \"Function\");\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 1
  },
  {
    "name": "JSTypeRegistry.isForwardDeclaredType",
    "class_name": "com.google.javascript.rhino.jstype.JSTypeRegistry",
    "signature": "com.google.javascript.rhino.jstype.JSTypeRegistry.isForwardDeclaredType(String)",
    "snippet": "  public boolean isForwardDeclaredType(String name) {\n    return forwardDeclaredTypes.contains(name);\n  }",
    "comment": " Whether this is a forward-declared type name. ",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 1
  },
  {
    "name": "JSTypeRegistry.isLastGeneration",
    "class_name": "com.google.javascript.rhino.jstype.JSTypeRegistry",
    "signature": "com.google.javascript.rhino.jstype.JSTypeRegistry.isLastGeneration()",
    "snippet": "  boolean isLastGeneration() {\n    return lastGeneration;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 1
  },
  {
    "name": "JSTypeRegistry.register",
    "class_name": "com.google.javascript.rhino.jstype.JSTypeRegistry",
    "signature": "com.google.javascript.rhino.jstype.JSTypeRegistry.register(JSType)",
    "snippet": "  private void register(JSType type) {\n    register(type, type.toString());\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 1
  },
  {
    "name": "JSTypeRegistry.register",
    "class_name": "com.google.javascript.rhino.jstype.JSTypeRegistry",
    "signature": "com.google.javascript.rhino.jstype.JSTypeRegistry.register(JSType,String)",
    "snippet": "  private void register(JSType type, String name) {\n    namesToTypes.put(name, type);\n\n    // Add all the namespaces in which this name lives.\n    while (name.indexOf('.') > 0) {\n      name = name.substring(0, name.lastIndexOf('.'));\n      namespaces.add(name);\n    }\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 1
  },
  {
    "name": "JSTypeRegistry.registerNativeType",
    "class_name": "com.google.javascript.rhino.jstype.JSTypeRegistry",
    "signature": "com.google.javascript.rhino.jstype.JSTypeRegistry.registerNativeType(JSTypeNative,JSType)",
    "snippet": "  private void registerNativeType(JSTypeNative typeId, JSType type) {\n    nativeTypes[typeId.ordinal()] = type;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 1
  },
  {
    "name": "JSTypeRegistry.registerPropertyOnType",
    "class_name": "com.google.javascript.rhino.jstype.JSTypeRegistry",
    "signature": "com.google.javascript.rhino.jstype.JSTypeRegistry.registerPropertyOnType(String,JSType)",
    "snippet": "  public void registerPropertyOnType(String propertyName, JSType type) {\n    UnionTypeBuilder typeSet = typesIndexedByProperty.get(propertyName);\n    if (typeSet == null) {\n      typeSet = new UnionTypeBuilder(this, PROPERTY_CHECKING_UNION_SIZE);\n      typesIndexedByProperty.put(propertyName, typeSet);\n    }\n\n    typeSet.addAlternate(type);\n    addReferenceTypeIndexedByProperty(propertyName, type);\n\n    // Clear cached values that depend on typesIndexedByProperty.\n    greatestSubtypeByProperty.remove(propertyName);\n  }",
    "comment": " Tells the type system that {@code owner} may have a property named {@code propertyName}. This allows the registry to keep track of what types a property is defined upon.  This is NOT the same as saying that {@code owner} must have a property named type. ObjectType#hasProperty attempts to minimize false positives (\"if we're not sure, then don't type check this property\"). The type registry, on the other hand, should attempt to minimize false negatives (\"if this property is assigned anywhere in the program, it must show up in the type registry\"). ",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 1
  },
  {
    "name": "JSTypeRegistry.registerTypeImplementingInterface",
    "class_name": "com.google.javascript.rhino.jstype.JSTypeRegistry",
    "signature": "com.google.javascript.rhino.jstype.JSTypeRegistry.registerTypeImplementingInterface(FunctionType,ObjectType)",
    "snippet": "  void registerTypeImplementingInterface(\n      FunctionType type, ObjectType interfaceInstance) {\n    interfaceToImplementors.put(interfaceInstance.getReferenceName(), type);\n  }",
    "comment": " Tells the type system that {@code type} implements interface {@code InterfaceInstance}. {@code inter} must be an ObjectType for the instance of the interface as it could be a named type and not yet have the constructor. ",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 1
  },
  {
    "name": "JSTypeRegistry.resetForTypeCheck",
    "class_name": "com.google.javascript.rhino.jstype.JSTypeRegistry",
    "signature": "com.google.javascript.rhino.jstype.JSTypeRegistry.resetForTypeCheck()",
    "snippet": "  public void resetForTypeCheck() {\n    typesIndexedByProperty.clear();\n    eachRefTypeIndexedByProperty.clear();\n    initializeBuiltInTypes();\n    namesToTypes.clear();\n    namespaces.clear();\n    initializeRegistry();\n  }",
    "comment": " Reset to run the TypeCheck pass. ",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 1
  },
  {
    "name": "NamedType.NamedType",
    "class_name": "com.google.javascript.rhino.jstype.NamedType",
    "signature": "com.google.javascript.rhino.jstype.NamedType.NamedType(JSTypeRegistry,String,String,int,int)",
    "snippet": "  NamedType(JSTypeRegistry registry, String reference,\n      String sourceName, int lineno, int charno) {\n    super(registry, registry.getNativeObjectType(JSTypeNative.UNKNOWN_TYPE));\n\n    Preconditions.checkNotNull(reference);\n    this.reference = reference;\n    this.sourceName = sourceName;\n    this.lineno = lineno;\n    this.charno = charno;\n  }",
    "comment": " Create a named type based on the reference. ",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 1
  },
  {
    "name": "NamedType.checkEnumElementCycle",
    "class_name": "com.google.javascript.rhino.jstype.NamedType",
    "signature": "com.google.javascript.rhino.jstype.NamedType.checkEnumElementCycle(ErrorReporter)",
    "snippet": "  private void checkEnumElementCycle(ErrorReporter t) {\n    JSType referencedType = getReferencedType();\n    if (referencedType instanceof EnumElementType &&\n        ((EnumElementType) referencedType).getPrimitiveType() == this) {\n      handleTypeCycle(t);\n    }\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 1
  },
  {
    "name": "NamedType.finishPropertyContinuations",
    "class_name": "com.google.javascript.rhino.jstype.NamedType",
    "signature": "com.google.javascript.rhino.jstype.NamedType.finishPropertyContinuations()",
    "snippet": "  private void finishPropertyContinuations() {\n    ObjectType referencedObjType = getReferencedObjTypeInternal();\n    if (referencedObjType != null && !referencedObjType.isUnknownType()) {\n      if (propertyContinuations != null) {\n        for (PropertyContinuation c : propertyContinuations) {\n          c.commit(this);\n        }\n      }\n    }\n    propertyContinuations = null;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 1
  },
  {
    "name": "NamedType.getReferencedType",
    "class_name": "com.google.javascript.rhino.jstype.NamedType",
    "signature": "com.google.javascript.rhino.jstype.NamedType.getReferencedType()",
    "snippet": "  public JSType getReferencedType() {\n    return getReferencedTypeInternal();\n  }",
    "comment": "Returns the type to which this refers (which is unknown if unresolved). */",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 1
  },
  {
    "name": "NamedType.getTypedefType",
    "class_name": "com.google.javascript.rhino.jstype.NamedType",
    "signature": "com.google.javascript.rhino.jstype.NamedType.getTypedefType(ErrorReporter,StaticSlot,String)",
    "snippet": "  JSType getTypedefType(ErrorReporter t, StaticSlot<JSType> slot, String name) {\n    JSType type = slot.getType();\n    if (type != null) {\n      return type;\n    }\n    handleUnresolvedType(t, true);\n    return null;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 1
  },
  {
    "name": "NamedType.handleUnresolvedType",
    "class_name": "com.google.javascript.rhino.jstype.NamedType",
    "signature": "com.google.javascript.rhino.jstype.NamedType.handleUnresolvedType(ErrorReporter,boolean)",
    "snippet": "  private void handleUnresolvedType(\n      ErrorReporter t, boolean ignoreForwardReferencedTypes) {\n    if (registry.isLastGeneration()) {\n      boolean isForwardDeclared =\n          ignoreForwardReferencedTypes &&\n          registry.isForwardDeclaredType(reference);\n      if (!isForwardDeclared && registry.isLastGeneration()) {\n        t.warning(\"Bad type annotation. Unknown type \" + reference,\n            sourceName, lineno, charno);\n      } else {\n        setReferencedType(\n            registry.getNativeObjectType(\n                JSTypeNative.NO_RESOLVED_TYPE));\n\n        if (registry.isLastGeneration() && validator != null) {\n          validator.apply(getReferencedType());\n        }\n      }\n\n      setResolvedTypeInternal(getReferencedType());\n    } else {\n      setResolvedTypeInternal(this);\n    }\n  }",
    "comment": "type name.",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 1
  },
  {
    "name": "NamedType.hasReferenceName",
    "class_name": "com.google.javascript.rhino.jstype.NamedType",
    "signature": "com.google.javascript.rhino.jstype.NamedType.hasReferenceName()",
    "snippet": "  @Override\n  public boolean hasReferenceName() {\n    return true;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 1
  },
  {
    "name": "NamedType.lookupViaProperties",
    "class_name": "com.google.javascript.rhino.jstype.NamedType",
    "signature": "com.google.javascript.rhino.jstype.NamedType.lookupViaProperties(ErrorReporter,StaticScope)",
    "snippet": "  private JSType lookupViaProperties( ErrorReporter t,\n      StaticScope<JSType> enclosing) {\n    String[] componentNames = reference.split(\"\\\\.\", -1);\n    if (componentNames[0].length() == 0) {\n      return null;\n    }\n    StaticSlot<JSType> slot = enclosing.getSlot(componentNames[0]);\n    if (slot == null) {\n      return null;\n    }\n    // If the first component has a type of 'Unknown', then any type\n    // names using it should be regarded as silently 'Unknown' rather than be\n    // noisy about it.\n    JSType slotType = slot.getType();\n    if (slotType == null || slotType.isAllType() || slotType.isNoType()) {\n      return null;\n    }\n    JSType value = getTypedefType(t, slot, componentNames[0]);\n    if (value == null) {\n      return null;\n    }\n\n    // resolving component by component\n    for (int i = 1; i < componentNames.length; i++) {\n      ObjectType parentClass = ObjectType.cast(value);\n      if (parentClass == null) {\n        return null;\n      }\n      if (componentNames[i].length() == 0) {\n        return null;\n      }\n      value = parentClass.getPropertyType(componentNames[i]);\n    }\n    return value;\n  }",
    "comment": " Resolves a type by looking up its first component in the scope, and subsequent components as properties. The scope must have been fully parsed and a symbol table constructed. @return The type of the symbol, or null if the type could not be found. ",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 1
  },
  {
    "name": "NamedType.resolveInternal",
    "class_name": "com.google.javascript.rhino.jstype.NamedType",
    "signature": "com.google.javascript.rhino.jstype.NamedType.resolveInternal(ErrorReporter,StaticScope)",
    "snippet": "  @Override\n  JSType resolveInternal(ErrorReporter t, StaticScope<JSType> enclosing) {\n    // TODO(user): Investigate whether it is really necessary to keep two\n    // different mechanisms for resolving named types, and if so, which order\n    // makes more sense. Now, resolution via registry is first in order to\n    // avoid triggering the warnings built into the resolution via properties.\n    boolean resolved = resolveViaRegistry(t, enclosing);\n    if (detectImplicitPrototypeCycle()) {\n      handleTypeCycle(t);\n    }\n\n    if (resolved) {\n      super.resolveInternal(t, enclosing);\n      finishPropertyContinuations();\n      return registry.isLastGeneration() ?\n          getReferencedType() : this;\n    }\n\n    resolveViaProperties(t, enclosing);\n    if (detectImplicitPrototypeCycle()) {\n      handleTypeCycle(t);\n    }\n\n    super.resolveInternal(t, enclosing);\n    if (isResolved()) {\n      finishPropertyContinuations();\n    }\n    return registry.isLastGeneration() ?\n        getReferencedType() : this;\n  }",
    "comment": " Resolve the referenced type within the enclosing scope. ",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 1
  },
  {
    "name": "NamedType.resolveViaProperties",
    "class_name": "com.google.javascript.rhino.jstype.NamedType",
    "signature": "com.google.javascript.rhino.jstype.NamedType.resolveViaProperties(ErrorReporter,StaticScope)",
    "snippet": "  private void resolveViaProperties(ErrorReporter t,\n                                    StaticScope<JSType> enclosing) {\n    JSType value = lookupViaProperties(t, enclosing);\n    // last component of the chain\n    if (value != null && value.isFunctionType() &&\n        (value.isConstructor() || value.isInterface())) {\n      FunctionType functionType = value.toMaybeFunctionType();\n      setReferencedAndResolvedType(\n          functionType.getInstanceType(), t, enclosing);\n    } else if (value != null && value.isNoObjectType()) {\n      setReferencedAndResolvedType(\n          registry.getNativeFunctionType(\n              JSTypeNative.NO_OBJECT_TYPE).getInstanceType(), t, enclosing);\n    } else if (value instanceof EnumType) {\n      setReferencedAndResolvedType(\n          ((EnumType) value).getElementsType(), t, enclosing);\n    } else {\n      // We've been running into issues where people forward-declare\n      // non-named types. (This is legitimate...our dependency management\n      // code doubles as our forward-declaration code.)\n      //\n      // So if the type does resolve to an actual value, but it's not named,\n      // then don't respect the forward declaration.\n      handleUnresolvedType(t, value == null || value.isUnknownType());\n    }\n  }",
    "comment": " Resolves a named type by looking up its first component in the scope, and subsequent components as properties. The scope must have been fully parsed and a symbol table constructed. ",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 1
  },
  {
    "name": "NamedType.resolveViaRegistry",
    "class_name": "com.google.javascript.rhino.jstype.NamedType",
    "signature": "com.google.javascript.rhino.jstype.NamedType.resolveViaRegistry(ErrorReporter,StaticScope)",
    "snippet": "  private boolean resolveViaRegistry(\n      ErrorReporter t, StaticScope<JSType> enclosing) {\n    JSType type = registry.getType(reference);\n    if (type != null) {\n      setReferencedAndResolvedType(type, t, enclosing);\n      return true;\n    }\n    return false;\n  }",
    "comment": " Resolves a named type by looking it up in the registry. @return True if we resolved successfully. ",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 1
  },
  {
    "name": "NamedType.setReferencedAndResolvedType",
    "class_name": "com.google.javascript.rhino.jstype.NamedType",
    "signature": "com.google.javascript.rhino.jstype.NamedType.setReferencedAndResolvedType(JSType,ErrorReporter,StaticScope)",
    "snippet": "  private void setReferencedAndResolvedType(JSType type, ErrorReporter t,\n      StaticScope<JSType> enclosing) {\n    if (validator != null) {\n      validator.apply(type);\n    }\n    setReferencedType(type);\n    checkEnumElementCycle(t);\n    setResolvedTypeInternal(getReferencedType());\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 1
  },
  {
    "name": "NoObjectType.NoObjectType",
    "class_name": "com.google.javascript.rhino.jstype.NoObjectType",
    "signature": "com.google.javascript.rhino.jstype.NoObjectType.NoObjectType(JSTypeRegistry)",
    "snippet": "  NoObjectType(JSTypeRegistry registry) {\n    super(registry, null, null,\n          registry.createArrowType(null, null),\n          null, null, true, true);\n    getInternalArrowType().returnType = this;\n    this.setInstanceType(this);\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 1
  },
  {
    "name": "NoObjectType.getImplicitPrototype",
    "class_name": "com.google.javascript.rhino.jstype.NoObjectType",
    "signature": "com.google.javascript.rhino.jstype.NoObjectType.getImplicitPrototype()",
    "snippet": "  @Override\n  public ObjectType getImplicitPrototype() {\n    return null;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 1
  },
  {
    "name": "NoObjectType.resolveInternal",
    "class_name": "com.google.javascript.rhino.jstype.NoObjectType",
    "signature": "com.google.javascript.rhino.jstype.NoObjectType.resolveInternal(ErrorReporter,StaticScope)",
    "snippet": "  @Override\n  JSType resolveInternal(ErrorReporter t, StaticScope<JSType> scope) {\n    return this;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 1
  },
  {
    "name": "NoResolvedType.NoResolvedType",
    "class_name": "com.google.javascript.rhino.jstype.NoResolvedType",
    "signature": "com.google.javascript.rhino.jstype.NoResolvedType.NoResolvedType(JSTypeRegistry)",
    "snippet": "  NoResolvedType(JSTypeRegistry registry) {\n    super(registry);\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 1
  },
  {
    "name": "NoType.NoType",
    "class_name": "com.google.javascript.rhino.jstype.NoType",
    "signature": "com.google.javascript.rhino.jstype.NoType.NoType(JSTypeRegistry)",
    "snippet": "  NoType(JSTypeRegistry registry) {\n    super(registry);\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 1
  },
  {
    "name": "NoType.isNoType",
    "class_name": "com.google.javascript.rhino.jstype.NoType",
    "signature": "com.google.javascript.rhino.jstype.NoType.isNoType()",
    "snippet": "  @Override\n  public boolean isNoType() {\n    return true;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 1
  },
  {
    "name": "NullType.NullType",
    "class_name": "com.google.javascript.rhino.jstype.NullType",
    "signature": "com.google.javascript.rhino.jstype.NullType.NullType(JSTypeRegistry)",
    "snippet": "  NullType(JSTypeRegistry registry) {\n    super(registry);\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 1
  },
  {
    "name": "NullType.getDisplayName",
    "class_name": "com.google.javascript.rhino.jstype.NullType",
    "signature": "com.google.javascript.rhino.jstype.NullType.getDisplayName()",
    "snippet": "  @Override\n  public String getDisplayName() {\n    return \"null\";\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 1
  },
  {
    "name": "NullType.toString",
    "class_name": "com.google.javascript.rhino.jstype.NullType",
    "signature": "com.google.javascript.rhino.jstype.NullType.toString()",
    "snippet": "  @Override\n  public String toString() {\n    return getDisplayName();\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 1
  },
  {
    "name": "NumberType.NumberType",
    "class_name": "com.google.javascript.rhino.jstype.NumberType",
    "signature": "com.google.javascript.rhino.jstype.NumberType.NumberType(JSTypeRegistry)",
    "snippet": "  NumberType(JSTypeRegistry registry) {\n    super(registry);\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 1
  },
  {
    "name": "NumberType.getDisplayName",
    "class_name": "com.google.javascript.rhino.jstype.NumberType",
    "signature": "com.google.javascript.rhino.jstype.NumberType.getDisplayName()",
    "snippet": "  @Override\n  public String getDisplayName() {\n    return \"number\";\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 1
  },
  {
    "name": "NumberType.toString",
    "class_name": "com.google.javascript.rhino.jstype.NumberType",
    "signature": "com.google.javascript.rhino.jstype.NumberType.toString()",
    "snippet": "  @Override\n  public String toString() {\n    return getDisplayName();\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 1
  },
  {
    "name": "ObjectType.ObjectType",
    "class_name": "com.google.javascript.rhino.jstype.ObjectType",
    "signature": "com.google.javascript.rhino.jstype.ObjectType.ObjectType(JSTypeRegistry)",
    "snippet": "  ObjectType(JSTypeRegistry registry) {\n    super(registry);\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 1
  },
  {
    "name": "ObjectType.cast",
    "class_name": "com.google.javascript.rhino.jstype.ObjectType",
    "signature": "com.google.javascript.rhino.jstype.ObjectType.cast(JSType)",
    "snippet": "  public static ObjectType cast(JSType type) {\n    return type == null ? null : type.toObjectType();\n  }",
    "comment": " A null-safe version of JSType#toObjectType. ",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 1
  },
  {
    "name": "ObjectType.defineDeclaredProperty",
    "class_name": "com.google.javascript.rhino.jstype.ObjectType",
    "signature": "com.google.javascript.rhino.jstype.ObjectType.defineDeclaredProperty(String,JSType,Node)",
    "snippet": "  public final boolean defineDeclaredProperty(String propertyName,\n      JSType type, Node propertyNode) {\n    boolean result = defineProperty(propertyName, type, false,\n        propertyNode);\n\n    // All property definitions go through this method\n    // or defineDeclaredProperty. Because the properties defined an an\n    // object can affect subtyping, it's slightly more efficient\n    // to register this after defining the property.\n    registry.registerPropertyOnType(propertyName, this);\n\n    return result;\n  }",
    "comment": " Defines a property whose type is synthesized (i.e. not inferred). @param propertyName the property's name @param type the type @param propertyNode the node corresponding to the declaration of property which might later be accessed using {@code getPropertyNode}. ",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 1
  },
  {
    "name": "ObjectType.detectImplicitPrototypeCycle",
    "class_name": "com.google.javascript.rhino.jstype.ObjectType",
    "signature": "com.google.javascript.rhino.jstype.ObjectType.detectImplicitPrototypeCycle()",
    "snippet": "  final boolean detectImplicitPrototypeCycle() {\n    // detecting cycle\n    this.visited = true;\n    ObjectType p = getImplicitPrototype();\n    while (p != null) {\n      if (p.visited) {\n        return true;\n      } else {\n        p.visited = true;\n      }\n      p = p.getImplicitPrototype();\n    }\n\n    // clean up\n    p = this;\n    do {\n      p.visited = false;\n      p = p.getImplicitPrototype();\n    } while (p != null);\n    return false;\n  }",
    "comment": " Detects a cycle in the implicit prototype chain. This method accesses the {@link #getImplicitPrototype()} method and must therefore be invoked only after the object is sufficiently initialized to respond to calls to this method.<p>  The method is not thread safe.<p>  @return True iff an implicit prototype cycle was detected. ",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 1
  },
  {
    "name": "ObjectType.hasCachedValues",
    "class_name": "com.google.javascript.rhino.jstype.ObjectType",
    "signature": "com.google.javascript.rhino.jstype.ObjectType.hasCachedValues()",
    "snippet": "  public boolean hasCachedValues() {\n    return !unknown;\n  }",
    "comment": " Returns true if any cached values have been set for this type.  If true, then the prototype chain should not be changed, as it might invalidate the cached values. ",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 1
  },
  {
    "name": "ObjectType.hasOwnDeclaredProperty",
    "class_name": "com.google.javascript.rhino.jstype.ObjectType",
    "signature": "com.google.javascript.rhino.jstype.ObjectType.hasOwnDeclaredProperty(String)",
    "snippet": "  boolean hasOwnDeclaredProperty(String name) {\n    return hasOwnProperty(name) && isPropertyTypeDeclared(name);\n  }",
    "comment": " Whether the given property is declared on this object. ",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 1
  },
  {
    "name": "ObjectType.isFunctionPrototypeType",
    "class_name": "com.google.javascript.rhino.jstype.ObjectType",
    "signature": "com.google.javascript.rhino.jstype.ObjectType.isFunctionPrototypeType()",
    "snippet": "  @Override\n  public final boolean isFunctionPrototypeType() {\n    return getOwnerFunction() != null;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 1
  },
  {
    "name": "ObjectType.isImplicitPrototype",
    "class_name": "com.google.javascript.rhino.jstype.ObjectType",
    "signature": "com.google.javascript.rhino.jstype.ObjectType.isImplicitPrototype(ObjectType)",
    "snippet": "  final boolean isImplicitPrototype(ObjectType prototype) {\n    for (ObjectType current = this;\n         current != null;\n         current = current.getImplicitPrototype()) {\n      if (current.isEquivalentTo(prototype)) {\n        return true;\n      }\n    }\n    return false;\n  }",
    "comment": " Checks that the prototype is an implicit prototype of this object. Since each object has an implicit prototype, an implicit prototype's implicit prototype is also this implicit prototype's.  @param prototype any prototype based object  @return {@code true} if {@code prototype} is {@code equal} to any object in this object's implicit prototype chain. ",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 1
  },
  {
    "name": "ObjectType.isUnknownType",
    "class_name": "com.google.javascript.rhino.jstype.ObjectType",
    "signature": "com.google.javascript.rhino.jstype.ObjectType.isUnknownType()",
    "snippet": "  @Override\n  public boolean isUnknownType() {\n    // If the object is unknown now, check the supertype again,\n    // because it might have been resolved since the last check.\n    if (unknown) {\n      ObjectType implicitProto = getImplicitPrototype();\n      if (implicitProto == null ||\n          implicitProto.isNativeObjectType()) {\n        unknown = false;\n        for (ObjectType interfaceType : getCtorExtendedInterfaces()) {\n          if (interfaceType.isUnknownType()) {\n            unknown = true;\n            break;\n          }\n        }\n      } else {\n        unknown = implicitProto.isUnknownType();\n      }\n    }\n    return unknown;\n  }",
    "comment": " We treat this as the unknown type if any of its implicit prototype properties is unknown. ",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 1
  },
  {
    "name": "Property.getNode",
    "class_name": "com.google.javascript.rhino.jstype.ObjectType$Property",
    "signature": "com.google.javascript.rhino.jstype.ObjectType$Property.getNode()",
    "snippet": "    @Override\n    public Node getNode() {\n      return propertyNode;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 1
  },
  {
    "name": "Property.getType",
    "class_name": "com.google.javascript.rhino.jstype.ObjectType$Property",
    "signature": "com.google.javascript.rhino.jstype.ObjectType$Property.getType()",
    "snippet": "    @Override\n    public JSType getType() {\n      return type;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 1
  },
  {
    "name": "Property.isTypeInferred",
    "class_name": "com.google.javascript.rhino.jstype.ObjectType$Property",
    "signature": "com.google.javascript.rhino.jstype.ObjectType$Property.isTypeInferred()",
    "snippet": "    @Override\n    public boolean isTypeInferred() {\n      return inferred;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 1
  },
  {
    "name": "Property.setType",
    "class_name": "com.google.javascript.rhino.jstype.ObjectType$Property",
    "signature": "com.google.javascript.rhino.jstype.ObjectType$Property.setType(JSType)",
    "snippet": "    void setType(JSType type) {\n      this.type = type;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 1
  },
  {
    "name": "PrototypeObjectType.PrototypeObjectType",
    "class_name": "com.google.javascript.rhino.jstype.PrototypeObjectType",
    "signature": "com.google.javascript.rhino.jstype.PrototypeObjectType.PrototypeObjectType(JSTypeRegistry,String,ObjectType)",
    "snippet": "  PrototypeObjectType(JSTypeRegistry registry, String className,\n      ObjectType implicitPrototype) {\n    this(registry, className, implicitPrototype, false);\n  }",
    "comment": " Creates an object type.  @param className the name of the class.  May be {@code null} to denote an anonymous class.  @param implicitPrototype the implicit prototype (a.k.a. {@code [[Prototype]]}) as defined by ECMA-262. If the implicit prototype is {@code null} the implicit prototype will be set to the {@link JSTypeNative#OBJECT_TYPE}. ",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 1
  },
  {
    "name": "PrototypeObjectType.PrototypeObjectType",
    "class_name": "com.google.javascript.rhino.jstype.PrototypeObjectType",
    "signature": "com.google.javascript.rhino.jstype.PrototypeObjectType.PrototypeObjectType(JSTypeRegistry,String,ObjectType,boolean)",
    "snippet": "  PrototypeObjectType(JSTypeRegistry registry, String className,\n      ObjectType implicitPrototype, boolean nativeType) {\n    super(registry);\n    this.properties = Maps.newTreeMap();\n    this.className = className;\n    this.nativeType = nativeType;\n    if (nativeType || implicitPrototype != null) {\n      setImplicitPrototype(implicitPrototype);\n    } else {\n      setImplicitPrototype(\n          registry.getNativeObjectType(JSTypeNative.OBJECT_TYPE));\n    }\n  }",
    "comment": " Creates an object type, allowing specification of the implicit prototype when creating native objects. ",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 1
  },
  {
    "name": "PrototypeObjectType.defineProperty",
    "class_name": "com.google.javascript.rhino.jstype.PrototypeObjectType",
    "signature": "com.google.javascript.rhino.jstype.PrototypeObjectType.defineProperty(String,JSType,boolean,Node)",
    "snippet": "  @Override\n  boolean defineProperty(String name, JSType type, boolean inferred,\n      Node propertyNode) {\n    if (hasOwnDeclaredProperty(name)) {\n      return false;\n    }\n    Property newProp = new Property(\n        name, type, inferred, propertyNode);\n    Property oldProp = properties.get(name);\n    if (oldProp != null) {\n      // This is to keep previously inferred jsdoc info, e.g., in a\n      // replaceScript scenario.\n      newProp.setJSDocInfo(oldProp.getJSDocInfo());\n    }\n    properties.put(name, newProp);\n    return true;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 1
  },
  {
    "name": "PrototypeObjectType.getConstructor",
    "class_name": "com.google.javascript.rhino.jstype.PrototypeObjectType",
    "signature": "com.google.javascript.rhino.jstype.PrototypeObjectType.getConstructor()",
    "snippet": "  @Override\n  public FunctionType getConstructor() {\n    return null;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 1
  },
  {
    "name": "PrototypeObjectType.getCtorExtendedInterfaces",
    "class_name": "com.google.javascript.rhino.jstype.PrototypeObjectType",
    "signature": "com.google.javascript.rhino.jstype.PrototypeObjectType.getCtorExtendedInterfaces()",
    "snippet": "  @Override\n  public Iterable<ObjectType> getCtorExtendedInterfaces() {\n    return isFunctionPrototypeType()\n        ? getOwnerFunction().getExtendedInterfaces()\n        : ImmutableList.<ObjectType>of();\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 1
  },
  {
    "name": "PrototypeObjectType.getImplicitPrototype",
    "class_name": "com.google.javascript.rhino.jstype.PrototypeObjectType",
    "signature": "com.google.javascript.rhino.jstype.PrototypeObjectType.getImplicitPrototype()",
    "snippet": "  @Override\n  public ObjectType getImplicitPrototype() {\n    return implicitPrototypeFallback;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 1
  },
  {
    "name": "PrototypeObjectType.getOwnPropertyNames",
    "class_name": "com.google.javascript.rhino.jstype.PrototypeObjectType",
    "signature": "com.google.javascript.rhino.jstype.PrototypeObjectType.getOwnPropertyNames()",
    "snippet": "  @Override\n  public Set<String> getOwnPropertyNames() {\n    return properties.keySet();\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 1
  },
  {
    "name": "PrototypeObjectType.getOwnerFunction",
    "class_name": "com.google.javascript.rhino.jstype.PrototypeObjectType",
    "signature": "com.google.javascript.rhino.jstype.PrototypeObjectType.getOwnerFunction()",
    "snippet": "  @Override\n  public FunctionType getOwnerFunction() {\n    return ownerFunction;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 1
  },
  {
    "name": "PrototypeObjectType.getPropertiesCount",
    "class_name": "com.google.javascript.rhino.jstype.PrototypeObjectType",
    "signature": "com.google.javascript.rhino.jstype.PrototypeObjectType.getPropertiesCount()",
    "snippet": "  @Override\n  public int getPropertiesCount() {\n    ObjectType implicitPrototype = getImplicitPrototype();\n    if (implicitPrototype == null) {\n      return this.properties.size();\n    }\n    int localCount = 0;\n    for (String property : properties.keySet()) {\n      if (!implicitPrototype.hasProperty(property)) {\n        localCount++;\n      }\n    }\n    return implicitPrototype.getPropertiesCount() + localCount;\n  }",
    "comment": " Gets the number of properties of this object. ",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 1
  },
  {
    "name": "PrototypeObjectType.getPropertyNode",
    "class_name": "com.google.javascript.rhino.jstype.PrototypeObjectType",
    "signature": "com.google.javascript.rhino.jstype.PrototypeObjectType.getPropertyNode(String)",
    "snippet": "  @Override\n  public Node getPropertyNode(String propertyName) {\n    Property p = properties.get(propertyName);\n    if (p != null) {\n      return p.getNode();\n    }\n    ObjectType implicitPrototype = getImplicitPrototype();\n    if (implicitPrototype != null) {\n      return implicitPrototype.getPropertyNode(propertyName);\n    }\n    return null;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 1
  },
  {
    "name": "PrototypeObjectType.getPropertyType",
    "class_name": "com.google.javascript.rhino.jstype.PrototypeObjectType",
    "signature": "com.google.javascript.rhino.jstype.PrototypeObjectType.getPropertyType(String)",
    "snippet": "  @Override\n  public JSType getPropertyType(String property) {\n    StaticSlot<JSType> slot = getSlot(property);\n    if (slot == null) {\n      return getNativeType(JSTypeNative.UNKNOWN_TYPE);\n    }\n    return slot.getType();\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 1
  },
  {
    "name": "PrototypeObjectType.getReferenceName",
    "class_name": "com.google.javascript.rhino.jstype.PrototypeObjectType",
    "signature": "com.google.javascript.rhino.jstype.PrototypeObjectType.getReferenceName()",
    "snippet": "  @Override\n  public String getReferenceName() {\n    if (className != null) {\n      return className;\n    } else if (ownerFunction != null) {\n      return ownerFunction.getReferenceName() + \".prototype\";\n    } else {\n      return null;\n    }\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 1
  },
  {
    "name": "PrototypeObjectType.getSlot",
    "class_name": "com.google.javascript.rhino.jstype.PrototypeObjectType",
    "signature": "com.google.javascript.rhino.jstype.PrototypeObjectType.getSlot(String)",
    "snippet": "  @Override\n  public Property getSlot(String name) {\n    if (properties.containsKey(name)) {\n      return properties.get(name);\n    }\n    ObjectType implicitPrototype = getImplicitPrototype();\n    if (implicitPrototype != null) {\n      Property prop = implicitPrototype.getSlot(name);\n      if (prop != null) {\n        return prop;\n      }\n    }\n    for (ObjectType interfaceType : getCtorExtendedInterfaces()) {\n      Property prop = interfaceType.getSlot(name);\n      if (prop != null) {\n        return prop;\n      }\n    }\n    return null;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 1
  },
  {
    "name": "PrototypeObjectType.hasCachedValues",
    "class_name": "com.google.javascript.rhino.jstype.PrototypeObjectType",
    "signature": "com.google.javascript.rhino.jstype.PrototypeObjectType.hasCachedValues()",
    "snippet": "  @Override\n  public boolean hasCachedValues() {\n    return super.hasCachedValues();\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 1
  },
  {
    "name": "PrototypeObjectType.hasOwnProperty",
    "class_name": "com.google.javascript.rhino.jstype.PrototypeObjectType",
    "signature": "com.google.javascript.rhino.jstype.PrototypeObjectType.hasOwnProperty(String)",
    "snippet": "  @Override\n  public boolean hasOwnProperty(String propertyName) {\n    return properties.get(propertyName) != null;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 1
  },
  {
    "name": "PrototypeObjectType.hasProperty",
    "class_name": "com.google.javascript.rhino.jstype.PrototypeObjectType",
    "signature": "com.google.javascript.rhino.jstype.PrototypeObjectType.hasProperty(String)",
    "snippet": "  @Override\n  public boolean hasProperty(String propertyName) {\n    // Unknown types have all properties.\n    return isUnknownType() || getSlot(propertyName) != null;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 1
  },
  {
    "name": "PrototypeObjectType.hasReferenceName",
    "class_name": "com.google.javascript.rhino.jstype.PrototypeObjectType",
    "signature": "com.google.javascript.rhino.jstype.PrototypeObjectType.hasReferenceName()",
    "snippet": "  @Override\n  public boolean hasReferenceName() {\n    return className != null || ownerFunction != null;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 1
  },
  {
    "name": "PrototypeObjectType.implicitPrototypeChainIsUnknown",
    "class_name": "com.google.javascript.rhino.jstype.PrototypeObjectType",
    "signature": "com.google.javascript.rhino.jstype.PrototypeObjectType.implicitPrototypeChainIsUnknown()",
    "snippet": "  private boolean implicitPrototypeChainIsUnknown() {\n    ObjectType p = getImplicitPrototype();\n    while (p != null) {\n      if (p.isUnknownType()) {\n        return true;\n      }\n      p = p.getImplicitPrototype();\n    }\n    return false;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 1
  },
  {
    "name": "PrototypeObjectType.isNativeObjectType",
    "class_name": "com.google.javascript.rhino.jstype.PrototypeObjectType",
    "signature": "com.google.javascript.rhino.jstype.PrototypeObjectType.isNativeObjectType()",
    "snippet": "  @Override\n  public boolean isNativeObjectType() {\n    return nativeType;\n  }",
    "comment": "Whether this is a built-in object. */",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 1
  },
  {
    "name": "PrototypeObjectType.isPropertyTypeDeclared",
    "class_name": "com.google.javascript.rhino.jstype.PrototypeObjectType",
    "signature": "com.google.javascript.rhino.jstype.PrototypeObjectType.isPropertyTypeDeclared(String)",
    "snippet": "  @Override\n  public boolean isPropertyTypeDeclared(String property) {\n    StaticSlot<JSType> slot = getSlot(property);\n    if (slot == null) {\n      return false;\n    }\n    return !slot.isTypeInferred();\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 1
  },
  {
    "name": "PrototypeObjectType.isSubtype",
    "class_name": "com.google.javascript.rhino.jstype.PrototypeObjectType",
    "signature": "com.google.javascript.rhino.jstype.PrototypeObjectType.isSubtype(JSType)",
    "snippet": "  @Override\n  public boolean isSubtype(JSType that) {\n    if (JSType.isSubtypeHelper(this, that)) {\n      return true;\n    }\n\n    // Union types\n    if (that.isUnionType()) {\n      // The static {@code JSType.isSubtype} check already decomposed\n      // union types, so we don't need to check those again.\n      return false;\n    }\n\n    // record types\n    if (that.isRecordType()) {\n      return RecordType.isSubtype(this, that.toMaybeRecordType());\n    }\n\n    // Interfaces\n    // Find all the interfaces implemented by this class and compare each one\n    // to the interface instance.\n    ObjectType thatObj = that.toObjectType();\n    ObjectType thatCtor = thatObj == null ? null : thatObj.getConstructor();\n    if (thatCtor != null && thatCtor.isInterface()) {\n      Iterable<ObjectType> thisInterfaces = getCtorImplementedInterfaces();\n      for (ObjectType thisInterface : thisInterfaces) {\n        if (thisInterface.isSubtype(that)) {\n          return true;\n        }\n      }\n    }\n\n    if (getConstructor() != null && getConstructor().isInterface()) {\n      for (ObjectType thisInterface : getCtorExtendedInterfaces()) {\n        if (thisInterface.isSubtype(that)) {\n          return true;\n        }\n      }\n    }\n\n    // other prototype based objects\n    if (isUnknownType() || implicitPrototypeChainIsUnknown()) {\n      // If unsure, say 'yes', to avoid spurious warnings.\n      // TODO(user): resolve the prototype chain completely in all cases,\n      // to avoid guessing.\n      return true;\n    }\n    return this.isImplicitPrototype(thatObj);\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 1
  },
  {
    "name": "PrototypeObjectType.resolveInternal",
    "class_name": "com.google.javascript.rhino.jstype.PrototypeObjectType",
    "signature": "com.google.javascript.rhino.jstype.PrototypeObjectType.resolveInternal(ErrorReporter,StaticScope)",
    "snippet": "  @Override\n  JSType resolveInternal(ErrorReporter t, StaticScope<JSType> scope) {\n    setResolvedTypeInternal(this);\n\n    ObjectType implicitPrototype = getImplicitPrototype();\n    if (implicitPrototype != null) {\n      implicitPrototypeFallback =\n          (ObjectType) implicitPrototype.resolve(t, scope);\n    }\n    for (Property prop : properties.values()) {\n      prop.setType(safeResolve(prop.getType(), t, scope));\n    }\n    return this;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 1
  },
  {
    "name": "PrototypeObjectType.setImplicitPrototype",
    "class_name": "com.google.javascript.rhino.jstype.PrototypeObjectType",
    "signature": "com.google.javascript.rhino.jstype.PrototypeObjectType.setImplicitPrototype(ObjectType)",
    "snippet": "  final void setImplicitPrototype(ObjectType implicitPrototype) {\n    checkState(!hasCachedValues());\n    this.implicitPrototypeFallback = implicitPrototype;\n  }",
    "comment": " This should only be reset on the FunctionPrototypeType, only to fix an incorrectly established prototype chain due to the user having a mismatch in super class declaration, and only before properties on that type are processed. ",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 1
  },
  {
    "name": "PrototypeObjectType.setOwnerFunction",
    "class_name": "com.google.javascript.rhino.jstype.PrototypeObjectType",
    "signature": "com.google.javascript.rhino.jstype.PrototypeObjectType.setOwnerFunction(FunctionType)",
    "snippet": "  void setOwnerFunction(FunctionType type) {\n    Preconditions.checkState(ownerFunction == null || type == null);\n    ownerFunction = type;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 1
  },
  {
    "name": "PrototypeObjectType.setPrettyPrint",
    "class_name": "com.google.javascript.rhino.jstype.PrototypeObjectType",
    "signature": "com.google.javascript.rhino.jstype.PrototypeObjectType.setPrettyPrint(boolean)",
    "snippet": "  void setPrettyPrint(boolean prettyPrint) {\n    this.prettyPrint = prettyPrint;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 1
  },
  {
    "name": "PrototypeObjectType.toString",
    "class_name": "com.google.javascript.rhino.jstype.PrototypeObjectType",
    "signature": "com.google.javascript.rhino.jstype.PrototypeObjectType.toString()",
    "snippet": "  @Override\n  public String toString() {\n    if (hasReferenceName()) {\n      return getReferenceName();\n    } else if (prettyPrint) {\n      // Don't pretty print recursively.\n      prettyPrint = false;\n\n      // Use a tree set so that the properties are sorted.\n      Set<String> propertyNames = Sets.newTreeSet();\n      for (ObjectType current = this;\n           current != null && !current.isNativeObjectType() &&\n               propertyNames.size() <= MAX_PRETTY_PRINTED_PROPERTIES;\n           current = current.getImplicitPrototype()) {\n        propertyNames.addAll(current.getOwnPropertyNames());\n      }\n\n      StringBuilder sb = new StringBuilder();\n      sb.append(\"{\");\n\n      int i = 0;\n      for (String property : propertyNames) {\n        if (i > 0) {\n          sb.append(\", \");\n        }\n\n        sb.append(property);\n        sb.append(\": \");\n        sb.append(getPropertyType(property).toString());\n\n        ++i;\n        if (i == MAX_PRETTY_PRINTED_PROPERTIES) {\n          sb.append(\", ...\");\n          break;\n        }\n      }\n\n      sb.append(\"}\");\n\n      prettyPrint = true;\n      return sb.toString();\n    } else {\n      return \"{...}\";\n    }\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 1
  },
  {
    "name": "ProxyObjectType.ProxyObjectType",
    "class_name": "com.google.javascript.rhino.jstype.ProxyObjectType",
    "signature": "com.google.javascript.rhino.jstype.ProxyObjectType.ProxyObjectType(JSTypeRegistry,JSType)",
    "snippet": "  ProxyObjectType(JSTypeRegistry registry, JSType referencedType) {\n    super(registry);\n    setReferencedType(referencedType);\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 1
  },
  {
    "name": "ProxyObjectType.getConstructor",
    "class_name": "com.google.javascript.rhino.jstype.ProxyObjectType",
    "signature": "com.google.javascript.rhino.jstype.ProxyObjectType.getConstructor()",
    "snippet": "  @Override\n  public FunctionType getConstructor() {\n    return referencedObjType == null ? null :\n        referencedObjType.getConstructor();\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 1
  },
  {
    "name": "ProxyObjectType.getImplicitPrototype",
    "class_name": "com.google.javascript.rhino.jstype.ProxyObjectType",
    "signature": "com.google.javascript.rhino.jstype.ProxyObjectType.getImplicitPrototype()",
    "snippet": "  @Override\n  public ObjectType getImplicitPrototype() {\n    return referencedObjType == null ? null :\n        referencedObjType.getImplicitPrototype();\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 1
  },
  {
    "name": "ProxyObjectType.getReferencedObjTypeInternal",
    "class_name": "com.google.javascript.rhino.jstype.ProxyObjectType",
    "signature": "com.google.javascript.rhino.jstype.ProxyObjectType.getReferencedObjTypeInternal()",
    "snippet": "  ObjectType getReferencedObjTypeInternal() {\n    return referencedObjType;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 1
  },
  {
    "name": "ProxyObjectType.getReferencedTypeInternal",
    "class_name": "com.google.javascript.rhino.jstype.ProxyObjectType",
    "signature": "com.google.javascript.rhino.jstype.ProxyObjectType.getReferencedTypeInternal()",
    "snippet": "  JSType getReferencedTypeInternal() {\n    return referencedType;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 1
  },
  {
    "name": "ProxyObjectType.resolveInternal",
    "class_name": "com.google.javascript.rhino.jstype.ProxyObjectType",
    "signature": "com.google.javascript.rhino.jstype.ProxyObjectType.resolveInternal(ErrorReporter,StaticScope)",
    "snippet": "  @Override\n  JSType resolveInternal(ErrorReporter t, StaticScope<JSType> scope) {\n    setReferencedType(referencedType.resolve(t, scope));\n    return this;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 1
  },
  {
    "name": "ProxyObjectType.setReferencedType",
    "class_name": "com.google.javascript.rhino.jstype.ProxyObjectType",
    "signature": "com.google.javascript.rhino.jstype.ProxyObjectType.setReferencedType(JSType)",
    "snippet": "  void setReferencedType(JSType referencedType) {\n    this.referencedType = referencedType;\n    if (referencedType instanceof ObjectType) {\n      this.referencedObjType = (ObjectType) referencedType;\n    } else {\n      this.referencedObjType = null;\n    }\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 1
  },
  {
    "name": "RecordType.RecordType",
    "class_name": "com.google.javascript.rhino.jstype.RecordType",
    "signature": "com.google.javascript.rhino.jstype.RecordType.RecordType(JSTypeRegistry,Map)",
    "snippet": "  RecordType(JSTypeRegistry registry, Map<String, RecordProperty> properties) {\n    super(registry, null, null);\n    setPrettyPrint(true);\n\n    for (String property : properties.keySet()) {\n      RecordProperty prop = properties.get(property);\n      if (prop == null) {\n        throw new IllegalStateException(\n            \"RecordProperty associated with a property should not be null!\");\n      }\n      defineDeclaredProperty(property, prop.getType(), prop.getPropertyNode());\n    }\n\n    // Freeze the record type.\n    isFrozen = true;\n  }",
    "comment": " Creates a record type.  @param registry The type registry under which this type lives. @param properties A map of all the properties of this record type. @throws IllegalStateException if the {@code RecordProperty} associated with a property is null. ",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 1
  },
  {
    "name": "RecordType.defineProperty",
    "class_name": "com.google.javascript.rhino.jstype.RecordType",
    "signature": "com.google.javascript.rhino.jstype.RecordType.defineProperty(String,JSType,boolean,Node)",
    "snippet": "  @Override\n  boolean defineProperty(String propertyName, JSType type,\n      boolean inferred, Node propertyNode) {\n    if (isFrozen) {\n      return false;\n    }\n\n    if (!inferred) {\n      properties.put(propertyName, type);\n    }\n\n    return super.defineProperty(propertyName, type, inferred,\n        propertyNode);\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 1
  },
  {
    "name": "RecordType.getImplicitPrototype",
    "class_name": "com.google.javascript.rhino.jstype.RecordType",
    "signature": "com.google.javascript.rhino.jstype.RecordType.getImplicitPrototype()",
    "snippet": "  @Override\n  public ObjectType getImplicitPrototype() {\n    return registry.getNativeObjectType(JSTypeNative.OBJECT_TYPE);\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 1
  },
  {
    "name": "RecordType.getLeastSupertype",
    "class_name": "com.google.javascript.rhino.jstype.RecordType",
    "signature": "com.google.javascript.rhino.jstype.RecordType.getLeastSupertype(JSType)",
    "snippet": "  @Override\n  public JSType getLeastSupertype(JSType that) {\n    if (!that.isRecordType()) {\n      return super.getLeastSupertype(that);\n    }\n    RecordTypeBuilder builder = new RecordTypeBuilder(registry);\n    for (String property : properties.keySet()) {\n      if (that.toMaybeRecordType().hasProperty(property) &&\n          that.toMaybeRecordType().getPropertyType(property).isEquivalentTo(\n              getPropertyType(property))) {\n        builder.addProperty(property, getPropertyType(property),\n            getPropertyNode(property));\n      }\n    }\n    return builder.build();\n  }",
    "comment": "",
    "is_bug": true,
    "failing_test_cases": 3,
    "buggy_methods": 1
  },
  {
    "name": "RecordType.isEquivalentTo",
    "class_name": "com.google.javascript.rhino.jstype.RecordType",
    "signature": "com.google.javascript.rhino.jstype.RecordType.isEquivalentTo(JSType)",
    "snippet": "  @Override\n  public boolean isEquivalentTo(JSType other) {\n    if (!other.isRecordType()) {\n      return false;\n    }\n\n    // Compare properties.\n    RecordType otherRecord = other.toMaybeRecordType();\n    if (otherRecord == this) {\n      return true;\n    }\n\n    Set<String> keySet = properties.keySet();\n    Map<String, JSType> otherProps = otherRecord.properties;\n    if (!otherProps.keySet().equals(keySet)) {\n      return false;\n    }\n    for (String key : keySet) {\n      if (!otherProps.get(key).isEquivalentTo(properties.get(key))) {\n        return false;\n      }\n    }\n    return true;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 1
  },
  {
    "name": "RecordType.isSubtype",
    "class_name": "com.google.javascript.rhino.jstype.RecordType",
    "signature": "com.google.javascript.rhino.jstype.RecordType.isSubtype(JSType)",
    "snippet": "  @Override\n  public boolean isSubtype(JSType that) {\n    if (JSType.isSubtypeHelper(this, that)) {\n      return true;\n    }\n\n    // Top of the record types is the empty record, or OBJECT_TYPE.\n    if (registry.getNativeObjectType(\n            JSTypeNative.OBJECT_TYPE).isSubtype(that)) {\n      return true;\n    }\n\n    // A type is a subtype of a record type if it itself is a record\n    // type and it has at least the same members as the parent record type\n    // with the same types.\n    if (!that.isRecordType()) {\n      return false;\n    }\n\n    return RecordType.isSubtype(this, that.toMaybeRecordType());\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 1
  },
  {
    "name": "RecordType.isSubtype",
    "class_name": "com.google.javascript.rhino.jstype.RecordType",
    "signature": "com.google.javascript.rhino.jstype.RecordType.isSubtype(ObjectType,RecordType)",
    "snippet": "  static boolean isSubtype(ObjectType typeA, RecordType typeB) {\n    // typeA is a subtype of record type typeB iff:\n    // 1) typeA has all the properties declared in typeB.\n    // 2) And for each property of typeB,\n    //    2a) if the property of typeA is declared, it must be equal\n    //        to the type of the property of typeB,\n    //    2b) otherwise, it must be a subtype of the property of typeB.\n    //\n    // To figure out why this is true, consider the following pseudo-code:\n    // /** @type {{a: (Object,null)}} */ var x;\n    // /** @type {{a: !Object}} */ var y;\n    // var z = {a: {}};\n    // x.a = null;\n    //\n    // y cannot be assigned to x, because line 4 would violate y's declared\n    // properties. But z can be assigned to x. Even though z and y are the\n    // same type, the properties of z are inferred--and so an assignment\n    // to the property of z would not violate any restrictions on it.\n    for (String property : typeB.properties.keySet()) {\n      if (!typeA.hasProperty(property)) {\n        return false;\n      }\n\n      JSType propA = typeA.getPropertyType(property);\n      JSType propB = typeB.getPropertyType(property);\n      if (!propA.isUnknownType() && !propB.isUnknownType()) {\n        if (typeA.isPropertyTypeDeclared(property)) {\n          if (!propA.isEquivalentTo(propB)) {\n            return false;\n          }\n        } else {\n          if (!propA.isSubtype(propB)) {\n            return false;\n          }\n        }\n      }\n    }\n\n    return true;\n  }",
    "comment": "Determines if typeA is a subtype of typeB */",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 1
  },
  {
    "name": "RecordType.toMaybeRecordType",
    "class_name": "com.google.javascript.rhino.jstype.RecordType",
    "signature": "com.google.javascript.rhino.jstype.RecordType.toMaybeRecordType()",
    "snippet": "  @Override\n  RecordType toMaybeRecordType() {\n    return this;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 1
  },
  {
    "name": "RecordTypeBuilder.RecordTypeBuilder",
    "class_name": "com.google.javascript.rhino.jstype.RecordTypeBuilder",
    "signature": "com.google.javascript.rhino.jstype.RecordTypeBuilder.RecordTypeBuilder(JSTypeRegistry)",
    "snippet": "  public RecordTypeBuilder(JSTypeRegistry registry) {\n    this.registry = registry;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 1
  },
  {
    "name": "RecordTypeBuilder.addProperty",
    "class_name": "com.google.javascript.rhino.jstype.RecordTypeBuilder",
    "signature": "com.google.javascript.rhino.jstype.RecordTypeBuilder.addProperty(String,JSType,Node)",
    "snippet": "  public RecordTypeBuilder addProperty(String name, JSType type, Node\n      propertyNode) {\n    isEmpty = false;\n    if (properties.containsKey(name)) {\n      return null;\n    }\n    properties.put(name, new RecordProperty(type, propertyNode));\n    return this;\n  }",
    "comment": " Adds a property with the given name and type to the record type. @param name the name of the new property @param type the JSType of the new property @param propertyNode the node that holds this property definition @return The builder itself for chaining purposes, or null if there's a duplicate. ",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 1
  },
  {
    "name": "RecordTypeBuilder.build",
    "class_name": "com.google.javascript.rhino.jstype.RecordTypeBuilder",
    "signature": "com.google.javascript.rhino.jstype.RecordTypeBuilder.build()",
    "snippet": "  public JSType build() {\n     // If we have an empty record, simply return the object type.\n    if (isEmpty) {\n       return registry.getNativeObjectType(JSTypeNative.OBJECT_TYPE);\n    }\n\n    return registry.createRecordType(Collections.unmodifiableMap(properties));\n  }",
    "comment": " Creates a record. @return The record type. ",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 1
  },
  {
    "name": "RecordProperty.getPropertyNode",
    "class_name": "com.google.javascript.rhino.jstype.RecordTypeBuilder$RecordProperty",
    "signature": "com.google.javascript.rhino.jstype.RecordTypeBuilder$RecordProperty.getPropertyNode()",
    "snippet": "    public Node getPropertyNode() {\n      return propertyNode;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 1
  },
  {
    "name": "RecordProperty.getType",
    "class_name": "com.google.javascript.rhino.jstype.RecordTypeBuilder$RecordProperty",
    "signature": "com.google.javascript.rhino.jstype.RecordTypeBuilder$RecordProperty.getType()",
    "snippet": "    public JSType getType() {\n      return type;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 1
  },
  {
    "name": "SimpleSlot.SimpleSlot",
    "class_name": "com.google.javascript.rhino.jstype.SimpleSlot",
    "signature": "com.google.javascript.rhino.jstype.SimpleSlot.SimpleSlot(String,JSType,boolean)",
    "snippet": "  public SimpleSlot(String name, JSType type, boolean inferred) {\n    this.name = name;\n    this.type = type;\n    this.inferred = inferred;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 1
  },
  {
    "name": "SimpleSlot.getType",
    "class_name": "com.google.javascript.rhino.jstype.SimpleSlot",
    "signature": "com.google.javascript.rhino.jstype.SimpleSlot.getType()",
    "snippet": "  @Override\n  public JSType getType() {\n    return type;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 1
  },
  {
    "name": "StringType.StringType",
    "class_name": "com.google.javascript.rhino.jstype.StringType",
    "signature": "com.google.javascript.rhino.jstype.StringType.StringType(JSTypeRegistry)",
    "snippet": "  StringType(JSTypeRegistry registry) {\n    super(registry);\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 1
  },
  {
    "name": "StringType.getDisplayName",
    "class_name": "com.google.javascript.rhino.jstype.StringType",
    "signature": "com.google.javascript.rhino.jstype.StringType.getDisplayName()",
    "snippet": "  @Override\n  public String getDisplayName() {\n    return \"string\";\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 1
  },
  {
    "name": "StringType.toString",
    "class_name": "com.google.javascript.rhino.jstype.StringType",
    "signature": "com.google.javascript.rhino.jstype.StringType.toString()",
    "snippet": "  @Override\n  public String toString() {\n    return getDisplayName();\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 1
  },
  {
    "name": "UnionType.UnionType",
    "class_name": "com.google.javascript.rhino.jstype.UnionType",
    "signature": "com.google.javascript.rhino.jstype.UnionType.UnionType(JSTypeRegistry,Collection)",
    "snippet": "  UnionType(JSTypeRegistry registry, Collection<JSType> alternates) {\n    super(registry);\n    this.alternates = alternates;\n    this.hashcode = this.alternates.hashCode();\n  }",
    "comment": " Creates a union type.  @param alternates the alternates of the union ",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 1
  },
  {
    "name": "UnionType.isEquivalentTo",
    "class_name": "com.google.javascript.rhino.jstype.UnionType",
    "signature": "com.google.javascript.rhino.jstype.UnionType.isEquivalentTo(JSType)",
    "snippet": "  @Override\n  public boolean isEquivalentTo(JSType object) {\n    if (object == null) {\n      return false;\n    }\n    if (object.isUnionType()) {\n      UnionType that = object.toMaybeUnionType();\n      if (alternates.size() != that.alternates.size()) {\n        return false;\n      }\n      for (JSType alternate : that.alternates) {\n        if (!hasAlternate(alternate)) {\n          return false;\n        }\n      }\n      return true;\n    } else {\n      return false;\n    }\n  }",
    "comment": " Two union types are equal if they have the same number of alternates and all alternates are equal. ",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 1
  },
  {
    "name": "UnionType.toString",
    "class_name": "com.google.javascript.rhino.jstype.UnionType",
    "signature": "com.google.javascript.rhino.jstype.UnionType.toString()",
    "snippet": "  @Override public String toString() {\n    StringBuilder result = new StringBuilder();\n    boolean firstAlternate = true;\n\n    result.append(\"(\");\n    SortedSet<JSType> sorted = new TreeSet<JSType>(ALPHA);\n    sorted.addAll(alternates);\n    for (JSType t : sorted) {\n      if (!firstAlternate) {\n        result.append(\"|\");\n      }\n      result.append(t.toString());\n      firstAlternate = false;\n    }\n    result.append(\")\");\n    return result.toString();\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 1
  },
  {
    "name": "UnionTypeBuilder.UnionTypeBuilder",
    "class_name": "com.google.javascript.rhino.jstype.UnionTypeBuilder",
    "signature": "com.google.javascript.rhino.jstype.UnionTypeBuilder.UnionTypeBuilder(JSTypeRegistry)",
    "snippet": "  UnionTypeBuilder(JSTypeRegistry registry) {\n    this(registry, DEFAULT_MAX_UNION_SIZE);\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 1
  },
  {
    "name": "UnionTypeBuilder.UnionTypeBuilder",
    "class_name": "com.google.javascript.rhino.jstype.UnionTypeBuilder",
    "signature": "com.google.javascript.rhino.jstype.UnionTypeBuilder.UnionTypeBuilder(JSTypeRegistry,int)",
    "snippet": "  UnionTypeBuilder(JSTypeRegistry registry, int maxUnionSize) {\n    this.registry = registry;\n    this.maxUnionSize = maxUnionSize;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 1
  },
  {
    "name": "UnionTypeBuilder.addAlternate",
    "class_name": "com.google.javascript.rhino.jstype.UnionTypeBuilder",
    "signature": "com.google.javascript.rhino.jstype.UnionTypeBuilder.addAlternate(JSType)",
    "snippet": "  UnionTypeBuilder addAlternate(JSType alternate) {\n    // build() returns the bottom type by default, so we can\n    // just bail out early here.\n    if (alternate.isNoType()) {\n      return this;\n    }\n\n    isAllType = isAllType || alternate.isAllType();\n\n    boolean isAlternateUnknown = alternate instanceof UnknownType;\n    isNativeUnknownType = isNativeUnknownType || isAlternateUnknown;\n    if (isAlternateUnknown) {\n      areAllUnknownsChecked = areAllUnknownsChecked &&\n          alternate.isCheckedUnknownType();\n    }\n    if (!isAllType && !isNativeUnknownType) {\n      if (alternate.isUnionType()) {\n        UnionType union = alternate.toMaybeUnionType();\n        for (JSType unionAlt : union.getAlternates()) {\n          addAlternate(unionAlt);\n        }\n      } else {\n        if (alternates.size() > maxUnionSize) {\n          return this;\n        }\n\n        // Function types are special, because they have their\n        // own bizarro sub-lattice. See the commants on\n        // FunctionType#supAndInf helper and above at functionTypePosition.\n        if (alternate.isFunctionType() && functionTypePosition != -1) {\n          // See the comments on functionTypePosition above.\n          FunctionType other =\n              alternates.get(functionTypePosition).toMaybeFunctionType();\n          FunctionType supremum =\n              alternate.toMaybeFunctionType().supAndInfHelper(other, true);\n          alternates.set(functionTypePosition, supremum);\n          result = null;\n          return this;\n        }\n\n        // Look through the alternates we've got so far,\n        // and check if any of them are duplicates of\n        // one another.\n        int currentIndex = 0;\n        Iterator<JSType> it = alternates.iterator();\n        while (it.hasNext()) {\n          JSType current = it.next();\n\n          // Unknown and NoResolved types may just be names that haven't\n          // been resolved yet. So keep these in the union, and just use\n          // equality checking for simple de-duping.\n          if (alternate.isUnknownType() ||\n              current.isUnknownType() ||\n              alternate.isNoResolvedType() ||\n              current.isNoResolvedType()) {\n            if (alternate.isEquivalentTo(current)) {\n              // Alternate is unnecessary.\n              return this;\n            }\n          } else {\n            if (alternate.isSubtype(current)) {\n              // Alternate is unnecessary.\n              return this;\n            } else if (current.isSubtype(alternate)) {\n              // Alternate makes current obsolete\n              it.remove();\n\n              if (currentIndex == functionTypePosition) {\n                functionTypePosition = -1;\n              } else if (currentIndex < functionTypePosition) {\n                functionTypePosition--;\n                currentIndex--;\n              }\n            }\n          }\n          currentIndex++;\n        }\n\n        if (alternate.isFunctionType()) {\n          // See the comments on functionTypePosition above.\n          Preconditions.checkState(functionTypePosition == -1);\n          functionTypePosition = alternates.size();\n        }\n\n        alternates.add(alternate);\n        result = null; // invalidate the memoized result\n      }\n    } else {\n      result = null;\n    }\n    return this;\n  }",
    "comment": " Adds an alternate to the union type under construction. Returns this for easy chaining. ",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 1
  },
  {
    "name": "UnionTypeBuilder.build",
    "class_name": "com.google.javascript.rhino.jstype.UnionTypeBuilder",
    "signature": "com.google.javascript.rhino.jstype.UnionTypeBuilder.build()",
    "snippet": "  JSType build() {\n    if (result == null) {\n      result = reduceAlternatesWithoutUnion();\n      if (result == null) {\n        result = new UnionType(registry, getAlternateListCopy());\n      }\n    }\n    return result;\n  }",
    "comment": " Creates a union. @return A UnionType if it has two or more alternates, the only alternate if it has one and otherwise {@code NO_TYPE}. ",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 1
  },
  {
    "name": "UnionTypeBuilder.getAlternateListCopy",
    "class_name": "com.google.javascript.rhino.jstype.UnionTypeBuilder",
    "signature": "com.google.javascript.rhino.jstype.UnionTypeBuilder.getAlternateListCopy()",
    "snippet": "  private Collection<JSType> getAlternateListCopy() {\n    return ImmutableList.copyOf(alternates);\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 1
  },
  {
    "name": "UnionTypeBuilder.reduceAlternatesWithoutUnion",
    "class_name": "com.google.javascript.rhino.jstype.UnionTypeBuilder",
    "signature": "com.google.javascript.rhino.jstype.UnionTypeBuilder.reduceAlternatesWithoutUnion()",
    "snippet": "  private JSType reduceAlternatesWithoutUnion() {\n    if (isAllType) {\n      return registry.getNativeType(ALL_TYPE);\n    } else if (isNativeUnknownType) {\n      if (areAllUnknownsChecked) {\n        return registry.getNativeType(CHECKED_UNKNOWN_TYPE);\n      } else {\n        return registry.getNativeType(UNKNOWN_TYPE);\n      }\n    } else {\n      int size = alternates.size();\n      if (size > maxUnionSize) {\n        return registry.getNativeType(UNKNOWN_TYPE);\n      } else if (size > 1) {\n        return null;\n      } else if (size == 1) {\n        return alternates.iterator().next();\n      } else {\n        return registry.getNativeType(NO_TYPE);\n      }\n    }\n  }",
    "comment": " Reduce the alternates into a non-union type. If the alternates can't be accurately represented with a non-union type, return null. ",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 1
  },
  {
    "name": "UnknownType.UnknownType",
    "class_name": "com.google.javascript.rhino.jstype.UnknownType",
    "signature": "com.google.javascript.rhino.jstype.UnknownType.UnknownType(JSTypeRegistry,boolean)",
    "snippet": "  UnknownType(JSTypeRegistry registry, boolean isChecked) {\n    super(registry);\n    this.isChecked = isChecked;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 1
  },
  {
    "name": "UnknownType.getConstructor",
    "class_name": "com.google.javascript.rhino.jstype.UnknownType",
    "signature": "com.google.javascript.rhino.jstype.UnknownType.getConstructor()",
    "snippet": "  @Override\n  public FunctionType getConstructor() {\n    return null;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 1
  },
  {
    "name": "UnknownType.getImplicitPrototype",
    "class_name": "com.google.javascript.rhino.jstype.UnknownType",
    "signature": "com.google.javascript.rhino.jstype.UnknownType.getImplicitPrototype()",
    "snippet": "  @Override\n  public ObjectType getImplicitPrototype() {\n    return null;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 1
  },
  {
    "name": "UnknownType.resolveInternal",
    "class_name": "com.google.javascript.rhino.jstype.UnknownType",
    "signature": "com.google.javascript.rhino.jstype.UnknownType.resolveInternal(ErrorReporter,StaticScope)",
    "snippet": "  @Override\n  JSType resolveInternal(ErrorReporter t, StaticScope<JSType> scope) {\n    return this;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 1
  },
  {
    "name": "ValueType.ValueType",
    "class_name": "com.google.javascript.rhino.jstype.ValueType",
    "signature": "com.google.javascript.rhino.jstype.ValueType.ValueType(JSTypeRegistry)",
    "snippet": "  ValueType(JSTypeRegistry registry) {\n    super(registry);\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 1
  },
  {
    "name": "ValueType.resolveInternal",
    "class_name": "com.google.javascript.rhino.jstype.ValueType",
    "signature": "com.google.javascript.rhino.jstype.ValueType.resolveInternal(ErrorReporter,StaticScope)",
    "snippet": "  @Override\n  final JSType resolveInternal(ErrorReporter t, StaticScope<JSType> scope) {\n    return this;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 1
  },
  {
    "name": "VoidType.VoidType",
    "class_name": "com.google.javascript.rhino.jstype.VoidType",
    "signature": "com.google.javascript.rhino.jstype.VoidType.VoidType(JSTypeRegistry)",
    "snippet": "  VoidType(JSTypeRegistry registry) {\n    super(registry);\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 1
  },
  {
    "name": "VoidType.getDisplayName",
    "class_name": "com.google.javascript.rhino.jstype.VoidType",
    "signature": "com.google.javascript.rhino.jstype.VoidType.getDisplayName()",
    "snippet": "  @Override\n  public String getDisplayName() {\n    return \"undefined\";\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 1
  },
  {
    "name": "VoidType.toString",
    "class_name": "com.google.javascript.rhino.jstype.VoidType",
    "signature": "com.google.javascript.rhino.jstype.VoidType.toString()",
    "snippet": "  @Override\n  public String toString() {\n    return getDisplayName();\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 1
  }
]