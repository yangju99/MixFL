[
  {
    "name": "DateTimeFieldType.DateTimeFieldType",
    "class_name": "org.joda.time.DateTimeFieldType",
    "signature": "org.joda.time.DateTimeFieldType.DateTimeFieldType(String)",
    "snippet": "    protected DateTimeFieldType(String name) {\n        super();\n        iName = name;\n    }",
    "comment": " Constructor.  @param name  the name to use ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "DateTimeFieldType.centuryOfEra",
    "class_name": "org.joda.time.DateTimeFieldType",
    "signature": "org.joda.time.DateTimeFieldType.centuryOfEra()",
    "snippet": "    public static DateTimeFieldType centuryOfEra() {\n        return CENTURY_OF_ERA_TYPE;\n    }",
    "comment": " Get the century of era field type.  @return the DateTimeFieldType constant ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "DateTimeFieldType.clockhourOfDay",
    "class_name": "org.joda.time.DateTimeFieldType",
    "signature": "org.joda.time.DateTimeFieldType.clockhourOfDay()",
    "snippet": "    public static DateTimeFieldType clockhourOfDay() {\n        return CLOCKHOUR_OF_DAY_TYPE;\n    }",
    "comment": " Get the hour of day (offset to 1-24) field type.  @return the DateTimeFieldType constant ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "DateTimeFieldType.clockhourOfHalfday",
    "class_name": "org.joda.time.DateTimeFieldType",
    "signature": "org.joda.time.DateTimeFieldType.clockhourOfHalfday()",
    "snippet": "    public static DateTimeFieldType clockhourOfHalfday() {\n        return CLOCKHOUR_OF_HALFDAY_TYPE;\n    }",
    "comment": " Get the hour of am/pm (offset to 1-12) field type.  @return the DateTimeFieldType constant ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "DateTimeFieldType.dayOfMonth",
    "class_name": "org.joda.time.DateTimeFieldType",
    "signature": "org.joda.time.DateTimeFieldType.dayOfMonth()",
    "snippet": "    public static DateTimeFieldType dayOfMonth() {\n        return DAY_OF_MONTH_TYPE;\n    }",
    "comment": " Get the day of month field type.  @return the DateTimeFieldType constant ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "DateTimeFieldType.dayOfWeek",
    "class_name": "org.joda.time.DateTimeFieldType",
    "signature": "org.joda.time.DateTimeFieldType.dayOfWeek()",
    "snippet": "    public static DateTimeFieldType dayOfWeek() {\n        return DAY_OF_WEEK_TYPE;\n    }",
    "comment": " Get the day of week field type.  @return the DateTimeFieldType constant ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "DateTimeFieldType.dayOfYear",
    "class_name": "org.joda.time.DateTimeFieldType",
    "signature": "org.joda.time.DateTimeFieldType.dayOfYear()",
    "snippet": "    public static DateTimeFieldType dayOfYear() {\n        return DAY_OF_YEAR_TYPE;\n    }",
    "comment": " Get the day of year field type.  @return the DateTimeFieldType constant ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "DateTimeFieldType.era",
    "class_name": "org.joda.time.DateTimeFieldType",
    "signature": "org.joda.time.DateTimeFieldType.era()",
    "snippet": "    public static DateTimeFieldType era() {\n        return ERA_TYPE;\n    }",
    "comment": " Get the era field type.  @return the DateTimeFieldType constant ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "DateTimeFieldType.halfdayOfDay",
    "class_name": "org.joda.time.DateTimeFieldType",
    "signature": "org.joda.time.DateTimeFieldType.halfdayOfDay()",
    "snippet": "    public static DateTimeFieldType halfdayOfDay() {\n        return HALFDAY_OF_DAY_TYPE;\n    }",
    "comment": " Get the AM(0) PM(1) field type.  @return the DateTimeFieldType constant ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "DateTimeFieldType.hourOfDay",
    "class_name": "org.joda.time.DateTimeFieldType",
    "signature": "org.joda.time.DateTimeFieldType.hourOfDay()",
    "snippet": "    public static DateTimeFieldType hourOfDay() {\n        return HOUR_OF_DAY_TYPE;\n    }",
    "comment": " Get the hour of day (0-23) field type.  @return the DateTimeFieldType constant ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "DateTimeFieldType.hourOfHalfday",
    "class_name": "org.joda.time.DateTimeFieldType",
    "signature": "org.joda.time.DateTimeFieldType.hourOfHalfday()",
    "snippet": "    public static DateTimeFieldType hourOfHalfday() {\n        return HOUR_OF_HALFDAY_TYPE;\n    }",
    "comment": " Get the hour of am/pm (0-11) field type.  @return the DateTimeFieldType constant ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "DateTimeFieldType.millisOfDay",
    "class_name": "org.joda.time.DateTimeFieldType",
    "signature": "org.joda.time.DateTimeFieldType.millisOfDay()",
    "snippet": "    public static DateTimeFieldType millisOfDay() {\n        return MILLIS_OF_DAY_TYPE;\n    }",
    "comment": " Get the millis of day field type.  @return the DateTimeFieldType constant ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "DateTimeFieldType.millisOfSecond",
    "class_name": "org.joda.time.DateTimeFieldType",
    "signature": "org.joda.time.DateTimeFieldType.millisOfSecond()",
    "snippet": "    public static DateTimeFieldType millisOfSecond() {\n        return MILLIS_OF_SECOND_TYPE;\n    }",
    "comment": " Get the millis of second field type.  @return the DateTimeFieldType constant ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "DateTimeFieldType.minuteOfDay",
    "class_name": "org.joda.time.DateTimeFieldType",
    "signature": "org.joda.time.DateTimeFieldType.minuteOfDay()",
    "snippet": "    public static DateTimeFieldType minuteOfDay() {\n        return MINUTE_OF_DAY_TYPE;\n    }",
    "comment": " Get the minute of day field type.  @return the DateTimeFieldType constant ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "DateTimeFieldType.minuteOfHour",
    "class_name": "org.joda.time.DateTimeFieldType",
    "signature": "org.joda.time.DateTimeFieldType.minuteOfHour()",
    "snippet": "    public static DateTimeFieldType minuteOfHour() {\n        return MINUTE_OF_HOUR_TYPE;\n    }",
    "comment": " Get the minute of hour field type.  @return the DateTimeFieldType constant ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "DateTimeFieldType.monthOfYear",
    "class_name": "org.joda.time.DateTimeFieldType",
    "signature": "org.joda.time.DateTimeFieldType.monthOfYear()",
    "snippet": "    public static DateTimeFieldType monthOfYear() {\n        return MONTH_OF_YEAR_TYPE;\n    }",
    "comment": " Get the month of year field type.  @return the DateTimeFieldType constant ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "DateTimeFieldType.secondOfDay",
    "class_name": "org.joda.time.DateTimeFieldType",
    "signature": "org.joda.time.DateTimeFieldType.secondOfDay()",
    "snippet": "    public static DateTimeFieldType secondOfDay() {\n        return SECOND_OF_DAY_TYPE;\n    }",
    "comment": " Get the second of day field type.  @return the DateTimeFieldType constant ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "DateTimeFieldType.secondOfMinute",
    "class_name": "org.joda.time.DateTimeFieldType",
    "signature": "org.joda.time.DateTimeFieldType.secondOfMinute()",
    "snippet": "    public static DateTimeFieldType secondOfMinute() {\n        return SECOND_OF_MINUTE_TYPE;\n    }",
    "comment": " Get the second of minute field type.  @return the DateTimeFieldType constant ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "DateTimeFieldType.weekOfWeekyear",
    "class_name": "org.joda.time.DateTimeFieldType",
    "signature": "org.joda.time.DateTimeFieldType.weekOfWeekyear()",
    "snippet": "    public static DateTimeFieldType weekOfWeekyear() {\n        return WEEK_OF_WEEKYEAR_TYPE;\n    }",
    "comment": " Get the week of a week based year field type.  @return the DateTimeFieldType constant ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "DateTimeFieldType.weekyear",
    "class_name": "org.joda.time.DateTimeFieldType",
    "signature": "org.joda.time.DateTimeFieldType.weekyear()",
    "snippet": "    public static DateTimeFieldType weekyear() {\n        return WEEKYEAR_TYPE;\n    }",
    "comment": " Get the year of a week based year field type.  @return the DateTimeFieldType constant ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "DateTimeFieldType.weekyearOfCentury",
    "class_name": "org.joda.time.DateTimeFieldType",
    "signature": "org.joda.time.DateTimeFieldType.weekyearOfCentury()",
    "snippet": "    public static DateTimeFieldType weekyearOfCentury() {\n        return WEEKYEAR_OF_CENTURY_TYPE;\n    }",
    "comment": " Get the year of a week based year within a century field type.  @return the DateTimeFieldType constant ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "DateTimeFieldType.year",
    "class_name": "org.joda.time.DateTimeFieldType",
    "signature": "org.joda.time.DateTimeFieldType.year()",
    "snippet": "    public static DateTimeFieldType year() {\n        return YEAR_TYPE;\n    }",
    "comment": " Get the year field type.  @return the DateTimeFieldType constant ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "DateTimeFieldType.yearOfCentury",
    "class_name": "org.joda.time.DateTimeFieldType",
    "signature": "org.joda.time.DateTimeFieldType.yearOfCentury()",
    "snippet": "    public static DateTimeFieldType yearOfCentury() {\n        return YEAR_OF_CENTURY_TYPE;\n    }",
    "comment": " Get the year of century field type.  @return the DateTimeFieldType constant ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "DateTimeFieldType.yearOfEra",
    "class_name": "org.joda.time.DateTimeFieldType",
    "signature": "org.joda.time.DateTimeFieldType.yearOfEra()",
    "snippet": "    public static DateTimeFieldType yearOfEra() {\n        return YEAR_OF_ERA_TYPE;\n    }",
    "comment": " Get the year of era field type.  @return the DateTimeFieldType constant ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "StandardDateTimeFieldType.getDurationType",
    "class_name": "org.joda.time.DateTimeFieldType$StandardDateTimeFieldType",
    "signature": "org.joda.time.DateTimeFieldType$StandardDateTimeFieldType.getDurationType()",
    "snippet": "        public DurationFieldType getDurationType() {\n            return iUnitType;\n        }",
    "comment": "@inheritdoc */",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "StandardDateTimeFieldType.getRangeDurationType",
    "class_name": "org.joda.time.DateTimeFieldType$StandardDateTimeFieldType",
    "signature": "org.joda.time.DateTimeFieldType$StandardDateTimeFieldType.getRangeDurationType()",
    "snippet": "        public DurationFieldType getRangeDurationType() {\n            return iRangeType;\n        }",
    "comment": "@inheritdoc */",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "DateTimeUtils.checkPermission",
    "class_name": "org.joda.time.DateTimeUtils",
    "signature": "org.joda.time.DateTimeUtils.checkPermission()",
    "snippet": "    private static void checkPermission() throws SecurityException {\n        SecurityManager sm = System.getSecurityManager();\n        if (sm != null) {\n            sm.checkPermission(new JodaTimePermission(\"CurrentTime.setProvider\"));\n        }\n    }",
    "comment": " Checks whether the provider may be changed using permission 'CurrentTime.setProvider'.  @throws SecurityException if the provider may not be changed ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "DateTimeUtils.getChronology",
    "class_name": "org.joda.time.DateTimeUtils",
    "signature": "org.joda.time.DateTimeUtils.getChronology(Chronology)",
    "snippet": "    public static final Chronology getChronology(Chronology chrono) {\n        if (chrono == null) {\n            return ISOChronology.getInstance();\n        }\n        return chrono;\n    }",
    "comment": " Gets the chronology handling null. <p> If the chronology is <code>null</code>, {@link ISOChronology#getInstance()} will be returned. Otherwise, the chronology is returned.  @param chrono  the chronology to use, null means ISO in the default zone @return the chronology, never null ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "DateTimeUtils.getPeriodType",
    "class_name": "org.joda.time.DateTimeUtils",
    "signature": "org.joda.time.DateTimeUtils.getPeriodType(PeriodType)",
    "snippet": "    public static final PeriodType getPeriodType(PeriodType type) {\n        if (type == null) {\n            return PeriodType.standard();\n        }\n        return type;\n    }",
    "comment": " Gets the period type handling null. <p> If the zone is <code>null</code>, {@link PeriodType#standard()} will be returned. Otherwise, the type specified is returned.  @param type  the time zone to use, null means the standard type @return the type to use, never null ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "DateTimeUtils.put",
    "class_name": "org.joda.time.DateTimeUtils",
    "signature": "org.joda.time.DateTimeUtils.put(Map,String,String)",
    "snippet": "    private static void put(Map<String, DateTimeZone> map, String name, String id) {\n        try {\n            map.put(name, DateTimeZone.forID(id));\n        } catch (RuntimeException ex) {\n            // ignore\n        }\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "DateTimeUtils.setCurrentMillisFixed",
    "class_name": "org.joda.time.DateTimeUtils",
    "signature": "org.joda.time.DateTimeUtils.setCurrentMillisFixed(long)",
    "snippet": "    public static final void setCurrentMillisFixed(long fixedMillis) throws SecurityException {\n        checkPermission();\n        cMillisProvider = new FixedMillisProvider(fixedMillis);\n    }",
    "comment": " Sets the current time to return a fixed millisecond time. <p> This method changes the behaviour of {@link #currentTimeMillis()}. Whenever the current time is queried, the same millisecond time will be returned.  @param fixedMillis  the fixed millisecond time to use @throws SecurityException if the application does not have sufficient security rights ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "DateTimeUtils.setCurrentMillisSystem",
    "class_name": "org.joda.time.DateTimeUtils",
    "signature": "org.joda.time.DateTimeUtils.setCurrentMillisSystem()",
    "snippet": "    public static final void setCurrentMillisSystem() throws SecurityException {\n        checkPermission();\n        cMillisProvider = SYSTEM_MILLIS_PROVIDER;\n    }",
    "comment": " Resets the current time to return the system time. <p> This method changes the behaviour of {@link #currentTimeMillis()}. Whenever the current time is queried, {@link System#currentTimeMillis()} is used.  @throws SecurityException if the application does not have sufficient security rights ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "DateTimeZone.DateTimeZone",
    "class_name": "org.joda.time.DateTimeZone",
    "signature": "org.joda.time.DateTimeZone.DateTimeZone(String)",
    "snippet": "    protected DateTimeZone(String id) {\n        if (id == null) {\n            throw new IllegalArgumentException(\"Id must not be null\");\n        }\n        iID = id;\n    }",
    "comment": " Constructor.  @param id  the id to use @throws IllegalArgumentException if the id is null ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "DateTimeZone.forID",
    "class_name": "org.joda.time.DateTimeZone",
    "signature": "org.joda.time.DateTimeZone.forID(String)",
    "snippet": "    @FromString\n    public static DateTimeZone forID(String id) {\n        if (id == null) {\n            return getDefault();\n        }\n        if (id.equals(\"UTC\")) {\n            return DateTimeZone.UTC;\n        }\n        DateTimeZone zone = cProvider.getZone(id);\n        if (zone != null) {\n            return zone;\n        }\n        if (id.startsWith(\"+\") || id.startsWith(\"-\")) {\n            int offset = parseOffset(id);\n            if (offset == 0L) {\n                return DateTimeZone.UTC;\n            } else {\n                id = printOffset(offset);\n                return fixedOffsetZone(id, offset);\n            }\n        }\n        throw new IllegalArgumentException(\"The datetime zone id '\" + id + \"' is not recognised\");\n    }",
    "comment": " Gets a time zone instance for the specified time zone id. <p> The time zone id may be one of those returned by getAvailableIDs. Short ids, as accepted by {@link java.util.TimeZone}, are not accepted. All IDs must be specified in the long format. The exception is UTC, which is an acceptable id. <p> Alternatively a locale independent, fixed offset, datetime zone can be specified. The form <code>[+-]hh:mm</code> can be used.  @param id  the ID of the datetime zone, null means default @return the DateTimeZone object for the ID @throws IllegalArgumentException if the ID is not recognised ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "DateTimeZone.forTimeZone",
    "class_name": "org.joda.time.DateTimeZone",
    "signature": "org.joda.time.DateTimeZone.forTimeZone(TimeZone)",
    "snippet": "    public static DateTimeZone forTimeZone(TimeZone zone) {\n        if (zone == null) {\n            return getDefault();\n        }\n        final String id = zone.getID();\n        if (id.equals(\"UTC\")) {\n            return DateTimeZone.UTC;\n        }\n\n        // Convert from old alias before consulting provider since they may differ.\n        DateTimeZone dtz = null;\n        String convId = getConvertedId(id);\n        if (convId != null) {\n            dtz = cProvider.getZone(convId);\n        }\n        if (dtz == null) {\n            dtz = cProvider.getZone(id);\n        }\n        if (dtz != null) {\n            return dtz;\n        }\n\n        // Support GMT+/-hh:mm formats\n        if (convId == null) {\n            convId = zone.getID();\n            if (convId.startsWith(\"GMT+\") || convId.startsWith(\"GMT-\")) {\n                convId = convId.substring(3);\n                int offset = parseOffset(convId);\n                if (offset == 0L) {\n                    return DateTimeZone.UTC;\n                } else {\n                    convId = printOffset(offset);\n                    return fixedOffsetZone(convId, offset);\n                }\n            }\n        }\n        throw new IllegalArgumentException(\"The datetime zone id '\" + id + \"' is not recognised\");\n    }",
    "comment": " Gets a time zone instance for a JDK TimeZone. <p> DateTimeZone only accepts a subset of the IDs from TimeZone. The excluded IDs are the short three letter form (except UTC). This  method will attempt to convert between time zones created using the short IDs and the full version. <p> This method is not designed to parse time zones with rules created by applications using <code>SimpleTimeZone</code> directly.  @param zone  the zone to convert, null means default @return the DateTimeZone object for the zone @throws IllegalArgumentException if the zone is not recognised ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "DateTimeZone.getConvertedId",
    "class_name": "org.joda.time.DateTimeZone",
    "signature": "org.joda.time.DateTimeZone.getConvertedId(String)",
    "snippet": "    private static synchronized String getConvertedId(String id) {\n        Map<String, String> map = cZoneIdConversion;\n        if (map == null) {\n            // Backwards compatibility with TimeZone.\n            map = new HashMap<String, String>();\n            map.put(\"GMT\", \"UTC\");\n            map.put(\"WET\", \"WET\");\n            map.put(\"CET\", \"CET\");\n            map.put(\"MET\", \"CET\");\n            map.put(\"ECT\", \"CET\");\n            map.put(\"EET\", \"EET\");\n            map.put(\"MIT\", \"Pacific/Apia\");\n            map.put(\"HST\", \"Pacific/Honolulu\");  // JDK 1.1 compatible\n            map.put(\"AST\", \"America/Anchorage\");\n            map.put(\"PST\", \"America/Los_Angeles\");\n            map.put(\"MST\", \"America/Denver\");  // JDK 1.1 compatible\n            map.put(\"PNT\", \"America/Phoenix\");\n            map.put(\"CST\", \"America/Chicago\");\n            map.put(\"EST\", \"America/New_York\");  // JDK 1.1 compatible\n            map.put(\"IET\", \"America/Indiana/Indianapolis\");\n            map.put(\"PRT\", \"America/Puerto_Rico\");\n            map.put(\"CNT\", \"America/St_Johns\");\n            map.put(\"AGT\", \"America/Argentina/Buenos_Aires\");\n            map.put(\"BET\", \"America/Sao_Paulo\");\n            map.put(\"ART\", \"Africa/Cairo\");\n            map.put(\"CAT\", \"Africa/Harare\");\n            map.put(\"EAT\", \"Africa/Addis_Ababa\");\n            map.put(\"NET\", \"Asia/Yerevan\");\n            map.put(\"PLT\", \"Asia/Karachi\");\n            map.put(\"IST\", \"Asia/Kolkata\");\n            map.put(\"BST\", \"Asia/Dhaka\");\n            map.put(\"VST\", \"Asia/Ho_Chi_Minh\");\n            map.put(\"CTT\", \"Asia/Shanghai\");\n            map.put(\"JST\", \"Asia/Tokyo\");\n            map.put(\"ACT\", \"Australia/Darwin\");\n            map.put(\"AET\", \"Australia/Sydney\");\n            map.put(\"SST\", \"Pacific/Guadalcanal\");\n            map.put(\"NST\", \"Pacific/Auckland\");\n            cZoneIdConversion = map;\n        }\n        return map.get(id);\n    }",
    "comment": " Converts an old style id to a new style id.  @param id  the old style id @return the new style id, null if not found ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "DateTimeZone.getDefault",
    "class_name": "org.joda.time.DateTimeZone",
    "signature": "org.joda.time.DateTimeZone.getDefault()",
    "snippet": "    public static DateTimeZone getDefault() {\n        DateTimeZone zone = cDefault;\n        if (zone == null) {\n            synchronized(DateTimeZone.class) {\n                zone = cDefault;\n                if (zone == null) {\n                    DateTimeZone temp = null;\n                    try {\n                        try {\n                            String id = System.getProperty(\"user.timezone\");\n                            if (id != null) {  // null check avoids stack overflow\n                                temp = forID(id);\n                            }\n                        } catch (RuntimeException ex) {\n                            // ignored\n                        }\n                        if (temp == null) {\n                            temp = forTimeZone(TimeZone.getDefault());\n                        }\n                    } catch (IllegalArgumentException ex) {\n                        // ignored\n                    }\n                    if (temp == null) {\n                        temp = UTC;\n                    }\n                    cDefault = zone = temp;\n                }\n            }\n        }\n        return zone;\n    }",
    "comment": " Gets the default time zone. <p> The default time zone is derived from the system property {@code user.timezone}. If that is {@code null} or is not a valid identifier, then the value of the JDK {@code TimeZone} default is converted. If that fails, {@code UTC} is used. <p> NOTE: If the {@code java.util.TimeZone} default is updated <i>after</i> calling this method, then the change will not be picked up here.  @return the default datetime zone object ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "DateTimeZone.getDefaultNameProvider",
    "class_name": "org.joda.time.DateTimeZone",
    "signature": "org.joda.time.DateTimeZone.getDefaultNameProvider()",
    "snippet": "    private static NameProvider getDefaultNameProvider() {\n        NameProvider nameProvider = null;\n        try {\n            String providerClass = System.getProperty(\"org.joda.time.DateTimeZone.NameProvider\");\n            if (providerClass != null) {\n                try {\n                    nameProvider = (NameProvider) Class.forName(providerClass).newInstance();\n                } catch (Exception ex) {\n                    Thread thread = Thread.currentThread();\n                    thread.getThreadGroup().uncaughtException(thread, ex);\n                }\n            }\n        } catch (SecurityException ex) {\n            // ignore\n        }\n\n        if (nameProvider == null) {\n            nameProvider = new DefaultNameProvider();\n        }\n\n        return nameProvider;\n    }",
    "comment": " Gets the default name provider. <p> Tries the system property <code>org.joda.time.DateTimeZone.NameProvider</code>. Then uses <code>DefaultNameProvider</code>.  @return the default name provider ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "DateTimeZone.getDefaultProvider",
    "class_name": "org.joda.time.DateTimeZone",
    "signature": "org.joda.time.DateTimeZone.getDefaultProvider()",
    "snippet": "    private static Provider getDefaultProvider() {\n        Provider provider = null;\n\n        try {\n            String providerClass =\n                System.getProperty(\"org.joda.time.DateTimeZone.Provider\");\n            if (providerClass != null) {\n                try {\n                    provider = (Provider) Class.forName(providerClass).newInstance();\n                } catch (Exception ex) {\n                    Thread thread = Thread.currentThread();\n                    thread.getThreadGroup().uncaughtException(thread, ex);\n                }\n            }\n        } catch (SecurityException ex) {\n            // ignored\n        }\n\n        if (provider == null) {\n            try {\n                provider = new ZoneInfoProvider(\"org/joda/time/tz/data\");\n            } catch (Exception ex) {\n                Thread thread = Thread.currentThread();\n                thread.getThreadGroup().uncaughtException(thread, ex);\n            }\n        }\n\n        if (provider == null) {\n            provider = new UTCProvider();\n        }\n\n        return provider;\n    }",
    "comment": " Gets the default zone provider. <p> Tries the system property <code>org.joda.time.DateTimeZone.Provider</code>. Then tries a <code>ZoneInfoProvider</code> using the data in <code>org/joda/time/tz/data</code>. Then uses <code>UTCProvider</code>.  @return the default name provider ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "DateTimeZone.getID",
    "class_name": "org.joda.time.DateTimeZone",
    "signature": "org.joda.time.DateTimeZone.getID()",
    "snippet": "    @ToString\n    public final String getID() {\n        return iID;\n    }",
    "comment": " Gets the ID of this datetime zone.  @return the ID of this datetime zone ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "DateTimeZone.hashCode",
    "class_name": "org.joda.time.DateTimeZone",
    "signature": "org.joda.time.DateTimeZone.hashCode()",
    "snippet": "    public int hashCode() {\n        return 57 + getID().hashCode();\n    }",
    "comment": " Gets a hash code compatable with equals.  @return suitable hashcode ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "DateTimeZone.setDefault",
    "class_name": "org.joda.time.DateTimeZone",
    "signature": "org.joda.time.DateTimeZone.setDefault(DateTimeZone)",
    "snippet": "    public static void setDefault(DateTimeZone zone) throws SecurityException {\n        SecurityManager sm = System.getSecurityManager();\n        if (sm != null) {\n            sm.checkPermission(new JodaTimePermission(\"DateTimeZone.setDefault\"));\n        }\n        if (zone == null) {\n            throw new IllegalArgumentException(\"The datetime zone must not be null\");\n        }\n        synchronized(DateTimeZone.class) {\n            cDefault = zone;\n        }\n    }",
    "comment": " Sets the default time zone. <p> NOTE: Calling this method does <i>not</i> set the {@code java.util.TimeZone} default.  @param zone  the default datetime zone object, must not be null @throws IllegalArgumentException if the zone is null @throws SecurityException if the application has insufficient security rights ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "DateTimeZone.setNameProvider0",
    "class_name": "org.joda.time.DateTimeZone",
    "signature": "org.joda.time.DateTimeZone.setNameProvider0(NameProvider)",
    "snippet": "    private static void setNameProvider0(NameProvider nameProvider) {\n        if (nameProvider == null) {\n            nameProvider = getDefaultNameProvider();\n        }\n        cNameProvider = nameProvider;\n    }",
    "comment": " Sets the name provider factory without performing the security check.  @param nameProvider  provider to use, or null for default @throws IllegalArgumentException if the provider is invalid ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "DateTimeZone.setProvider0",
    "class_name": "org.joda.time.DateTimeZone",
    "signature": "org.joda.time.DateTimeZone.setProvider0(Provider)",
    "snippet": "    private static void setProvider0(Provider provider) {\n        if (provider == null) {\n            provider = getDefaultProvider();\n        }\n        Set<String> ids = provider.getAvailableIDs();\n        if (ids == null || ids.size() == 0) {\n            throw new IllegalArgumentException\n                (\"The provider doesn't have any available ids\");\n        }\n        if (!ids.contains(\"UTC\")) {\n            throw new IllegalArgumentException(\"The provider doesn't support UTC\");\n        }\n        if (!UTC.equals(provider.getZone(\"UTC\"))) {\n            throw new IllegalArgumentException(\"Invalid UTC zone provided\");\n        }\n        cProvider = provider;\n        cAvailableIDs = ids;\n    }",
    "comment": " Sets the zone provider factory without performing the security check.  @param provider  provider to use, or null for default @throws IllegalArgumentException if the provider is invalid ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "DurationFieldType.DurationFieldType",
    "class_name": "org.joda.time.DurationFieldType",
    "signature": "org.joda.time.DurationFieldType.DurationFieldType(String)",
    "snippet": "    protected DurationFieldType(String name) {\n        super();\n        iName = name;\n    }",
    "comment": " Constructor.  @param name  the name to use, which by convention, are plural. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "DurationFieldType.centuries",
    "class_name": "org.joda.time.DurationFieldType",
    "signature": "org.joda.time.DurationFieldType.centuries()",
    "snippet": "    public static DurationFieldType centuries() {\n        return CENTURIES_TYPE;\n    }",
    "comment": " Get the centuries field type.  @return the DateTimeFieldType constant ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "DurationFieldType.days",
    "class_name": "org.joda.time.DurationFieldType",
    "signature": "org.joda.time.DurationFieldType.days()",
    "snippet": "    public static DurationFieldType days() {\n        return DAYS_TYPE;\n    }",
    "comment": " Get the days field type.  @return the DateTimeFieldType constant ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "DurationFieldType.eras",
    "class_name": "org.joda.time.DurationFieldType",
    "signature": "org.joda.time.DurationFieldType.eras()",
    "snippet": "    public static DurationFieldType eras() {\n        return ERAS_TYPE;\n    }",
    "comment": " Get the eras field type.  @return the DateTimeFieldType constant ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "DurationFieldType.halfdays",
    "class_name": "org.joda.time.DurationFieldType",
    "signature": "org.joda.time.DurationFieldType.halfdays()",
    "snippet": "    public static DurationFieldType halfdays() {\n        return HALFDAYS_TYPE;\n    }",
    "comment": " Get the halfdays field type.  @return the DateTimeFieldType constant ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "DurationFieldType.hours",
    "class_name": "org.joda.time.DurationFieldType",
    "signature": "org.joda.time.DurationFieldType.hours()",
    "snippet": "    public static DurationFieldType hours() {\n        return HOURS_TYPE;\n    }",
    "comment": " Get the hours field type.  @return the DateTimeFieldType constant ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "DurationFieldType.millis",
    "class_name": "org.joda.time.DurationFieldType",
    "signature": "org.joda.time.DurationFieldType.millis()",
    "snippet": "    public static DurationFieldType millis() {\n        return MILLIS_TYPE;\n    }",
    "comment": " Get the millis field type.  @return the DateTimeFieldType constant ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "DurationFieldType.minutes",
    "class_name": "org.joda.time.DurationFieldType",
    "signature": "org.joda.time.DurationFieldType.minutes()",
    "snippet": "    public static DurationFieldType minutes() {\n        return MINUTES_TYPE;\n    }",
    "comment": " Get the minutes field type.  @return the DateTimeFieldType constant ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "DurationFieldType.months",
    "class_name": "org.joda.time.DurationFieldType",
    "signature": "org.joda.time.DurationFieldType.months()",
    "snippet": "    public static DurationFieldType months() {\n        return MONTHS_TYPE;\n    }",
    "comment": " Get the months field type.  @return the DateTimeFieldType constant ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "DurationFieldType.seconds",
    "class_name": "org.joda.time.DurationFieldType",
    "signature": "org.joda.time.DurationFieldType.seconds()",
    "snippet": "    public static DurationFieldType seconds() {\n        return SECONDS_TYPE;\n    }",
    "comment": " Get the seconds field type.  @return the DateTimeFieldType constant ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "DurationFieldType.weeks",
    "class_name": "org.joda.time.DurationFieldType",
    "signature": "org.joda.time.DurationFieldType.weeks()",
    "snippet": "    public static DurationFieldType weeks() {\n        return WEEKS_TYPE;\n    }",
    "comment": " Get the weeks field type.  @return the DateTimeFieldType constant ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "DurationFieldType.weekyears",
    "class_name": "org.joda.time.DurationFieldType",
    "signature": "org.joda.time.DurationFieldType.weekyears()",
    "snippet": "    public static DurationFieldType weekyears() {\n        return WEEKYEARS_TYPE;\n    }",
    "comment": " Get the weekyears field type.  @return the DateTimeFieldType constant ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "DurationFieldType.years",
    "class_name": "org.joda.time.DurationFieldType",
    "signature": "org.joda.time.DurationFieldType.years()",
    "snippet": "    public static DurationFieldType years() {\n        return YEARS_TYPE;\n    }",
    "comment": " Get the years field type.  @return the DateTimeFieldType constant ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "StandardDurationFieldType.hashCode",
    "class_name": "org.joda.time.DurationFieldType$StandardDurationFieldType",
    "signature": "org.joda.time.DurationFieldType$StandardDurationFieldType.hashCode()",
    "snippet": "        @Override\n        public int hashCode() {\n            return (1 << iOrdinal);\n        }",
    "comment": "@inheritdoc */",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "Period.Period",
    "class_name": "org.joda.time.Period",
    "signature": "org.joda.time.Period.Period()",
    "snippet": "    public Period() {\n        super(0L, null, null);\n    }",
    "comment": " Creates a new empty period with the standard set of fields. <p> One way to initialise a period is as follows: <pre> Period = new Period().withYears(6).withMonths(3).withSeconds(23); </pre> Bear in mind that this creates four period instances in total, three of which are immediately discarded. The alterative is more efficient, but less readable: <pre> Period = new Period(6, 3, 0, 0, 0, 0, 23, 0); </pre> The following is also slightly less wasteful: <pre> Period = Period.years(6).withMonths(3).withSeconds(23); </pre> ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "Period.Period",
    "class_name": "org.joda.time.Period",
    "signature": "org.joda.time.Period.Period(int,int,int,int,int,int,int,int)",
    "snippet": "    public Period(int years, int months, int weeks, int days,\n                  int hours, int minutes, int seconds, int millis) {\n        super(years, months, weeks, days, hours, minutes, seconds, millis, PeriodType.standard());\n    }",
    "comment": " Create a period from a set of field values using the standard set of fields.  @param years  amount of years in this period @param months  amount of months in this period @param weeks  amount of weeks in this period @param days  amount of days in this period @param hours  amount of hours in this period @param minutes  amount of minutes in this period @param seconds  amount of seconds in this period @param millis  amount of milliseconds in this period ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "Period.Period",
    "class_name": "org.joda.time.Period",
    "signature": "org.joda.time.Period.Period(int,int,int,int,int,int,int,int,PeriodType)",
    "snippet": "    public Period(int years, int months, int weeks, int days,\n                    int hours, int minutes, int seconds, int millis, PeriodType type) {\n        super(years, months, weeks, days, hours, minutes, seconds, millis, type);\n    }",
    "comment": " Create a period from a set of field values. <p> There is usually little need to use this constructor. The period type is used primarily to define how to split an interval into a period. As this constructor already is split, the period type does no real work.  @param years  amount of years in this period, which must be zero if unsupported @param months  amount of months in this period, which must be zero if unsupported @param weeks  amount of weeks in this period, which must be zero if unsupported @param days  amount of days in this period, which must be zero if unsupported @param hours  amount of hours in this period, which must be zero if unsupported @param minutes  amount of minutes in this period, which must be zero if unsupported @param seconds  amount of seconds in this period, which must be zero if unsupported @param millis  amount of milliseconds in this period, which must be zero if unsupported @param type  which set of fields this period supports, null means AllType @throws IllegalArgumentException if an unsupported field's value is non-zero ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "Period.millis",
    "class_name": "org.joda.time.Period",
    "signature": "org.joda.time.Period.millis(int)",
    "snippet": "    public static Period millis(int millis) {\n        return new Period(new int[] {0, 0, 0, 0, 0, 0, 0, millis}, PeriodType.standard());\n    }",
    "comment": " Create a period with a specified number of millis. <p> The standard period type is used, thus you can add other fields such as days or hours using the <code>withXxx()</code> methods. For example, <code>Period.millis(20).withSeconds(30);</code>  @param millis  the amount of millis in this period @return the period ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "Period.seconds",
    "class_name": "org.joda.time.Period",
    "signature": "org.joda.time.Period.seconds(int)",
    "snippet": "    public static Period seconds(int seconds) {\n        return new Period(new int[] {0, 0, 0, 0, 0, 0, seconds, 0}, PeriodType.standard());\n    }",
    "comment": " Create a period with a specified number of seconds. <p> The standard period type is used, thus you can add other fields such as days or hours using the <code>withXxx()</code> methods. For example, <code>Period.seconds(2).withMillis(30);</code> <p> If you want a second-based period that cannot have other fields added, then you should consider using {@link Seconds}.  @param seconds  the amount of seconds in this period @return the period ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "Period.withMillis",
    "class_name": "org.joda.time.Period",
    "signature": "org.joda.time.Period.withMillis(int)",
    "snippet": "    public Period withMillis(int millis) {\n        int[] values = getValues();  // cloned\n        getPeriodType().setIndexedField(this, PeriodType.MILLI_INDEX, values, millis);\n        return new Period(values, getPeriodType());\n    }",
    "comment": " Returns a new period with the specified number of millis. <p> This period instance is immutable and unaffected by this method call.  @param millis  the amount of millis to add, may be negative @return the new period with the increased millis @throws UnsupportedOperationException if the field is not supported ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "Period.years",
    "class_name": "org.joda.time.Period",
    "signature": "org.joda.time.Period.years(int)",
    "snippet": "    public static Period years(int years) {\n        return new Period(new int[] {years, 0, 0, 0, 0, 0, 0, 0, 0}, PeriodType.standard());\n    }",
    "comment": " Create a period with a specified number of years. <p> The standard period type is used, thus you can add other fields such as months or days using the <code>withXxx()</code> methods. For example, <code>Period.years(2).withMonths(6);</code> <p> If you want a year-based period that cannot have other fields added, then you should consider using {@link Years}.  @param years  the amount of years in this period @return the period ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "PeriodType.PeriodType",
    "class_name": "org.joda.time.PeriodType",
    "signature": "org.joda.time.PeriodType.PeriodType(String,DurationFieldType[],int[])",
    "snippet": "    protected PeriodType(String name, DurationFieldType[] types, int[] indices) {\n        super();\n        iName = name;\n        iTypes = types;\n        iIndices = indices;\n    }",
    "comment": " Constructor.  @param name  the name @param types  the types @param indices  the indices ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "PeriodType.indexOf",
    "class_name": "org.joda.time.PeriodType",
    "signature": "org.joda.time.PeriodType.indexOf(DurationFieldType)",
    "snippet": "    public int indexOf(DurationFieldType type) {\n        for (int i = 0, isize = size(); i < isize; i++) {\n            if (iTypes[i] == type) {\n                return i;\n            }\n        }\n        return -1;\n    }",
    "comment": " Gets the index of the field in this period.  @param type  the type to check, may be null which returns -1 @return the index of -1 if not supported ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "PeriodType.isSupported",
    "class_name": "org.joda.time.PeriodType",
    "signature": "org.joda.time.PeriodType.isSupported(DurationFieldType)",
    "snippet": "    public boolean isSupported(DurationFieldType type) {\n        return (indexOf(type) >= 0);\n    }",
    "comment": " Checks whether the field specified is supported by this period.  @param type  the type to check, may be null which returns false @return true if the field is supported ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "PeriodType.setIndexedField",
    "class_name": "org.joda.time.PeriodType",
    "signature": "org.joda.time.PeriodType.setIndexedField(ReadablePeriod,int,int[],int)",
    "snippet": "    boolean setIndexedField(ReadablePeriod period, int index, int[] values, int newValue) {\n        int realIndex = iIndices[index];\n        if (realIndex == -1) {\n            throw new UnsupportedOperationException(\"Field is not supported\");\n        }\n        values[realIndex] = newValue;\n        return true;\n    }",
    "comment": " Sets the indexed field part of the period.  @param period  the period to query @param index  the index to use @param values  the array to populate @param newValue  the value to set @throws UnsupportedOperationException if not supported ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "PeriodType.size",
    "class_name": "org.joda.time.PeriodType",
    "signature": "org.joda.time.PeriodType.size()",
    "snippet": "    public int size() {\n        return iTypes.length;\n    }",
    "comment": " Gets the number of fields in the period type.  @return the number of fields ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "PeriodType.standard",
    "class_name": "org.joda.time.PeriodType",
    "signature": "org.joda.time.PeriodType.standard()",
    "snippet": "    public static PeriodType standard() {\n        PeriodType type = cStandard;\n        if (type == null) {\n            type = new PeriodType(\n                \"Standard\",\n                new DurationFieldType[] {\n                    DurationFieldType.years(), DurationFieldType.months(),\n                    DurationFieldType.weeks(), DurationFieldType.days(),\n                    DurationFieldType.hours(), DurationFieldType.minutes(),\n                    DurationFieldType.seconds(), DurationFieldType.millis(),\n                },\n                new int[] { 0, 1, 2, 3, 4, 5, 6, 7, }\n            );\n            cStandard = type;\n        }\n        return type;\n    }",
    "comment": " Gets a type that defines all standard fields. <ul> <li>years <li>months <li>weeks <li>days <li>hours <li>minutes <li>seconds <li>milliseconds </ul>  @return the period type ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "PeriodType.yearDayTime",
    "class_name": "org.joda.time.PeriodType",
    "signature": "org.joda.time.PeriodType.yearDayTime()",
    "snippet": "    public static PeriodType yearDayTime() {\n        PeriodType type = cYDTime;\n        if (type == null) {\n            type = new PeriodType(\n                \"YearDayTime\",\n                new DurationFieldType[] {\n                    DurationFieldType.years(), DurationFieldType.days(),\n                    DurationFieldType.hours(), DurationFieldType.minutes(),\n                    DurationFieldType.seconds(), DurationFieldType.millis(),\n                },\n                new int[] { 0, -1, -1, 1, 2, 3, 4, 5, }\n            );\n            cYDTime = type;\n        }\n        return type;\n    }",
    "comment": " Gets a type that defines all standard fields except months and weeks. <ul> <li>years <li>days <li>hours <li>minutes <li>seconds <li>milliseconds </ul>  @return the period type ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "AbstractPeriod.AbstractPeriod",
    "class_name": "org.joda.time.base.AbstractPeriod",
    "signature": "org.joda.time.base.AbstractPeriod.AbstractPeriod()",
    "snippet": "    protected AbstractPeriod() {\n        super();\n    }",
    "comment": " Constructor. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "AbstractPeriod.get",
    "class_name": "org.joda.time.base.AbstractPeriod",
    "signature": "org.joda.time.base.AbstractPeriod.get(DurationFieldType)",
    "snippet": "    public int get(DurationFieldType type) {\n        int index = indexOf(type);\n        if (index == -1) {\n            return 0;\n        }\n        return getValue(index);\n    }",
    "comment": " Gets the value of one of the fields. <p> If the field type specified is not supported by the period then zero is returned.  @param type  the field type to query, null returns zero @return the value of that field, zero if field not supported ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "AbstractPeriod.getValues",
    "class_name": "org.joda.time.base.AbstractPeriod",
    "signature": "org.joda.time.base.AbstractPeriod.getValues()",
    "snippet": "    public int[] getValues() {\n        int[] result = new int[size()];\n        for (int i = 0; i < result.length; i++) {\n            result[i] = getValue(i);\n        }\n        return result;\n    }",
    "comment": " Gets an array of the value of each of the fields that this period supports. <p> The fields are returned largest to smallest, for example Hours, Minutes, Seconds. Each value corresponds to the same array index as <code>getFields()</code>  @return the current values of each field in an array that may be altered, largest to smallest ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "AbstractPeriod.indexOf",
    "class_name": "org.joda.time.base.AbstractPeriod",
    "signature": "org.joda.time.base.AbstractPeriod.indexOf(DurationFieldType)",
    "snippet": "    public int indexOf(DurationFieldType type) {\n        return getPeriodType().indexOf(type);\n    }",
    "comment": " Gets the index of the field in this period.  @param type  the type to check, may be null which returns -1 @return the index of -1 if not supported ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "AbstractPeriod.size",
    "class_name": "org.joda.time.base.AbstractPeriod",
    "signature": "org.joda.time.base.AbstractPeriod.size()",
    "snippet": "    public int size() {\n        return getPeriodType().size();\n    }",
    "comment": " Gets the number of fields that this period supports.  @return the number of fields supported @since 2.0 (previously on BasePeriod) ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "BasePeriod.BasePeriod",
    "class_name": "org.joda.time.base.BasePeriod",
    "signature": "org.joda.time.base.BasePeriod.BasePeriod(int,int,int,int,int,int,int,int,PeriodType)",
    "snippet": "    protected BasePeriod(int years, int months, int weeks, int days,\n                         int hours, int minutes, int seconds, int millis,\n                         PeriodType type) {\n        super();\n        type = checkPeriodType(type);\n        iType = type;\n        iValues = setPeriodInternal(years, months, weeks, days, hours, minutes, seconds, millis); // internal method\n    }",
    "comment": " Creates a period from a set of field values.  @param years  amount of years in this period, which must be zero if unsupported @param months  amount of months in this period, which must be zero if unsupported @param weeks  amount of weeks in this period, which must be zero if unsupported @param days  amount of days in this period, which must be zero if unsupported @param hours  amount of hours in this period, which must be zero if unsupported @param minutes  amount of minutes in this period, which must be zero if unsupported @param seconds  amount of seconds in this period, which must be zero if unsupported @param millis  amount of milliseconds in this period, which must be zero if unsupported @param type  which set of fields this period supports @throws IllegalArgumentException if period type is invalid @throws IllegalArgumentException if an unsupported field's value is non-zero ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "BasePeriod.BasePeriod",
    "class_name": "org.joda.time.base.BasePeriod",
    "signature": "org.joda.time.base.BasePeriod.BasePeriod(int[],PeriodType)",
    "snippet": "    protected BasePeriod(int[] values, PeriodType type) {\n        super();\n        iType = type;\n        iValues = values;\n    }",
    "comment": " Constructor used when we trust ourselves. Do not expose publically.  @param values  the values to use, not null, not cloned @param type  which set of fields this period supports, not null ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "BasePeriod.BasePeriod",
    "class_name": "org.joda.time.base.BasePeriod",
    "signature": "org.joda.time.base.BasePeriod.BasePeriod(long,PeriodType,Chronology)",
    "snippet": "    protected BasePeriod(long duration, PeriodType type, Chronology chrono) {\n        super();\n        type = checkPeriodType(type);\n        chrono = DateTimeUtils.getChronology(chrono);\n        iType = type;\n        iValues = chrono.get(this, duration);\n    }",
    "comment": " Creates a period from the given millisecond duration, which is only really suitable for durations less than one day. <p> Only fields that are precise will be used. Thus the largest precise field may have a large value.  @param duration  the duration, in milliseconds @param type  which set of fields this period supports, null means standard @param chrono  the chronology to use, null means ISO default @throws IllegalArgumentException if period type is invalid ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "BasePeriod.checkAndUpdate",
    "class_name": "org.joda.time.base.BasePeriod",
    "signature": "org.joda.time.base.BasePeriod.checkAndUpdate(DurationFieldType,int[],int)",
    "snippet": "    private void checkAndUpdate(DurationFieldType type, int[] values, int newValue) {\n        int index = indexOf(type);\n        if (index == -1) {\n            if (newValue != 0) {\n                throw new IllegalArgumentException(\n                    \"Period does not support field '\" + type.getName() + \"'\");\n            }\n        } else {\n            values[index] = newValue;\n        }\n    }",
    "comment": " Checks whether a field type is supported, and if so adds the new value to the relevant index in the specified array.  @param type  the field type @param values  the array to update @param newValue  the new value to store if successful ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "BasePeriod.checkPeriodType",
    "class_name": "org.joda.time.base.BasePeriod",
    "signature": "org.joda.time.base.BasePeriod.checkPeriodType(PeriodType)",
    "snippet": "    protected PeriodType checkPeriodType(PeriodType type) {\n        return DateTimeUtils.getPeriodType(type);\n    }",
    "comment": " Validates a period type, converting nulls to a default value and checking the type is suitable for this instance.  @param type  the type to check, may be null @return the validated type to use, not null @throws IllegalArgumentException if the period type is invalid ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "BasePeriod.getPeriodType",
    "class_name": "org.joda.time.base.BasePeriod",
    "signature": "org.joda.time.base.BasePeriod.getPeriodType()",
    "snippet": "    public PeriodType getPeriodType() {\n        return iType;\n    }",
    "comment": " Gets the period type.  @return the period type ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "BasePeriod.getValue",
    "class_name": "org.joda.time.base.BasePeriod",
    "signature": "org.joda.time.base.BasePeriod.getValue(int)",
    "snippet": "    public int getValue(int index) {\n        return iValues[index];\n    }",
    "comment": " Gets the value at the specified index.  @param index  the index to retrieve @return the value of the field at the specified index @throws IndexOutOfBoundsException if the index is invalid ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "BasePeriod.setPeriodInternal",
    "class_name": "org.joda.time.base.BasePeriod",
    "signature": "org.joda.time.base.BasePeriod.setPeriodInternal(int,int,int,int,int,int,int,int)",
    "snippet": "    private int[] setPeriodInternal(int years, int months, int weeks, int days,\n                                   int hours, int minutes, int seconds, int millis) {\n        int[] newValues = new int[size()];\n        checkAndUpdate(DurationFieldType.years(), newValues, years);\n        checkAndUpdate(DurationFieldType.months(), newValues, months);\n        checkAndUpdate(DurationFieldType.weeks(), newValues, weeks);\n        checkAndUpdate(DurationFieldType.days(), newValues, days);\n        checkAndUpdate(DurationFieldType.hours(), newValues, hours);\n        checkAndUpdate(DurationFieldType.minutes(), newValues, minutes);\n        checkAndUpdate(DurationFieldType.seconds(), newValues, seconds);\n        checkAndUpdate(DurationFieldType.millis(), newValues, millis);\n        return newValues;\n    }",
    "comment": " Private method called from constructor. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "AssembledChronology.AssembledChronology",
    "class_name": "org.joda.time.chrono.AssembledChronology",
    "signature": "org.joda.time.chrono.AssembledChronology.AssembledChronology(Chronology,Object)",
    "snippet": "    protected AssembledChronology(Chronology base, Object param) {\n        iBase = base;\n        iParam = param;\n        setFields();\n    }",
    "comment": " Constructor calls the assemble method, enabling subclasses to define its supported fields. If a base chronology is supplied, the field set initially contains references to each base chronology field. <p> Other methods in this class will delegate to the base chronology, if it can be determined that the base chronology will produce the same results as AbstractChronology.  @param base optional base chronology to copy initial fields from @param param optional param object avalable for assemble method ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "AssembledChronology.centuries",
    "class_name": "org.joda.time.chrono.AssembledChronology",
    "signature": "org.joda.time.chrono.AssembledChronology.centuries()",
    "snippet": "    public final DurationField centuries() {\n        return iCenturies;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "AssembledChronology.centuryOfEra",
    "class_name": "org.joda.time.chrono.AssembledChronology",
    "signature": "org.joda.time.chrono.AssembledChronology.centuryOfEra()",
    "snippet": "    public final DateTimeField centuryOfEra() {\n        return iCenturyOfEra;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "AssembledChronology.clockhourOfDay",
    "class_name": "org.joda.time.chrono.AssembledChronology",
    "signature": "org.joda.time.chrono.AssembledChronology.clockhourOfDay()",
    "snippet": "    public final DateTimeField clockhourOfDay() {\n        return iClockhourOfDay;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "AssembledChronology.clockhourOfHalfday",
    "class_name": "org.joda.time.chrono.AssembledChronology",
    "signature": "org.joda.time.chrono.AssembledChronology.clockhourOfHalfday()",
    "snippet": "    public final DateTimeField clockhourOfHalfday() {\n        return iClockhourOfHalfday;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "AssembledChronology.dayOfMonth",
    "class_name": "org.joda.time.chrono.AssembledChronology",
    "signature": "org.joda.time.chrono.AssembledChronology.dayOfMonth()",
    "snippet": "    public final DateTimeField dayOfMonth() {\n        return iDayOfMonth;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "AssembledChronology.dayOfWeek",
    "class_name": "org.joda.time.chrono.AssembledChronology",
    "signature": "org.joda.time.chrono.AssembledChronology.dayOfWeek()",
    "snippet": "    public final DateTimeField dayOfWeek() {\n        return iDayOfWeek;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "AssembledChronology.dayOfYear",
    "class_name": "org.joda.time.chrono.AssembledChronology",
    "signature": "org.joda.time.chrono.AssembledChronology.dayOfYear()",
    "snippet": "    public final DateTimeField dayOfYear() {\n        return iDayOfYear;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "AssembledChronology.days",
    "class_name": "org.joda.time.chrono.AssembledChronology",
    "signature": "org.joda.time.chrono.AssembledChronology.days()",
    "snippet": "    public final DurationField days() {\n        return iDays;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "AssembledChronology.era",
    "class_name": "org.joda.time.chrono.AssembledChronology",
    "signature": "org.joda.time.chrono.AssembledChronology.era()",
    "snippet": "    public final DateTimeField era() {\n        return iEra;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "AssembledChronology.eras",
    "class_name": "org.joda.time.chrono.AssembledChronology",
    "signature": "org.joda.time.chrono.AssembledChronology.eras()",
    "snippet": "    public final DurationField eras() {\n        return iEras;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "AssembledChronology.getBase",
    "class_name": "org.joda.time.chrono.AssembledChronology",
    "signature": "org.joda.time.chrono.AssembledChronology.getBase()",
    "snippet": "    protected final Chronology getBase() {\n        return iBase;\n    }",
    "comment": " Returns the same base chronology as passed into the constructor. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "AssembledChronology.getParam",
    "class_name": "org.joda.time.chrono.AssembledChronology",
    "signature": "org.joda.time.chrono.AssembledChronology.getParam()",
    "snippet": "    protected final Object getParam() {\n        return iParam;\n    }",
    "comment": " Returns the same param object as passed into the constructor. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "AssembledChronology.halfdayOfDay",
    "class_name": "org.joda.time.chrono.AssembledChronology",
    "signature": "org.joda.time.chrono.AssembledChronology.halfdayOfDay()",
    "snippet": "    public final DateTimeField halfdayOfDay() {\n        return iHalfdayOfDay;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "AssembledChronology.halfdays",
    "class_name": "org.joda.time.chrono.AssembledChronology",
    "signature": "org.joda.time.chrono.AssembledChronology.halfdays()",
    "snippet": "    public final DurationField halfdays() {\n        return iHalfdays;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "AssembledChronology.hourOfDay",
    "class_name": "org.joda.time.chrono.AssembledChronology",
    "signature": "org.joda.time.chrono.AssembledChronology.hourOfDay()",
    "snippet": "    public final DateTimeField hourOfDay() {\n        return iHourOfDay;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "AssembledChronology.hourOfHalfday",
    "class_name": "org.joda.time.chrono.AssembledChronology",
    "signature": "org.joda.time.chrono.AssembledChronology.hourOfHalfday()",
    "snippet": "    public final DateTimeField hourOfHalfday() {\n        return iHourOfHalfday;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "AssembledChronology.hours",
    "class_name": "org.joda.time.chrono.AssembledChronology",
    "signature": "org.joda.time.chrono.AssembledChronology.hours()",
    "snippet": "    public final DurationField hours() {\n        return iHours;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "AssembledChronology.millis",
    "class_name": "org.joda.time.chrono.AssembledChronology",
    "signature": "org.joda.time.chrono.AssembledChronology.millis()",
    "snippet": "    public final DurationField millis() {\n        return iMillis;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "AssembledChronology.millisOfDay",
    "class_name": "org.joda.time.chrono.AssembledChronology",
    "signature": "org.joda.time.chrono.AssembledChronology.millisOfDay()",
    "snippet": "    public final DateTimeField millisOfDay() {\n        return iMillisOfDay;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "AssembledChronology.millisOfSecond",
    "class_name": "org.joda.time.chrono.AssembledChronology",
    "signature": "org.joda.time.chrono.AssembledChronology.millisOfSecond()",
    "snippet": "    public final DateTimeField millisOfSecond() {\n        return iMillisOfSecond;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "AssembledChronology.minuteOfDay",
    "class_name": "org.joda.time.chrono.AssembledChronology",
    "signature": "org.joda.time.chrono.AssembledChronology.minuteOfDay()",
    "snippet": "    public final DateTimeField minuteOfDay() {\n        return iMinuteOfDay;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "AssembledChronology.minuteOfHour",
    "class_name": "org.joda.time.chrono.AssembledChronology",
    "signature": "org.joda.time.chrono.AssembledChronology.minuteOfHour()",
    "snippet": "    public final DateTimeField minuteOfHour() {\n        return iMinuteOfHour;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "AssembledChronology.minutes",
    "class_name": "org.joda.time.chrono.AssembledChronology",
    "signature": "org.joda.time.chrono.AssembledChronology.minutes()",
    "snippet": "    public final DurationField minutes() {\n        return iMinutes;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "AssembledChronology.monthOfYear",
    "class_name": "org.joda.time.chrono.AssembledChronology",
    "signature": "org.joda.time.chrono.AssembledChronology.monthOfYear()",
    "snippet": "    public final DateTimeField monthOfYear() {\n        return iMonthOfYear;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "AssembledChronology.months",
    "class_name": "org.joda.time.chrono.AssembledChronology",
    "signature": "org.joda.time.chrono.AssembledChronology.months()",
    "snippet": "    public final DurationField months() {\n        return iMonths;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "AssembledChronology.secondOfDay",
    "class_name": "org.joda.time.chrono.AssembledChronology",
    "signature": "org.joda.time.chrono.AssembledChronology.secondOfDay()",
    "snippet": "    public final DateTimeField secondOfDay() {\n        return iSecondOfDay;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "AssembledChronology.secondOfMinute",
    "class_name": "org.joda.time.chrono.AssembledChronology",
    "signature": "org.joda.time.chrono.AssembledChronology.secondOfMinute()",
    "snippet": "    public final DateTimeField secondOfMinute() {\n        return iSecondOfMinute;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "AssembledChronology.seconds",
    "class_name": "org.joda.time.chrono.AssembledChronology",
    "signature": "org.joda.time.chrono.AssembledChronology.seconds()",
    "snippet": "    public final DurationField seconds() {\n        return iSeconds;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "AssembledChronology.setFields",
    "class_name": "org.joda.time.chrono.AssembledChronology",
    "signature": "org.joda.time.chrono.AssembledChronology.setFields()",
    "snippet": "    private void setFields() {\n        Fields fields = new Fields();\n        if (iBase != null) {\n            fields.copyFieldsFrom(iBase);\n        }\n        assemble(fields);\n\n        {\n            DurationField f;\n            iMillis    = (f = fields.millis)    != null ? f : super.millis();\n            iSeconds   = (f = fields.seconds)   != null ? f : super.seconds();\n            iMinutes   = (f = fields.minutes)   != null ? f : super.minutes();\n            iHours     = (f = fields.hours)     != null ? f : super.hours();\n            iHalfdays  = (f = fields.halfdays)  != null ? f : super.halfdays();\n            iDays      = (f = fields.days)      != null ? f : super.days();\n            iWeeks     = (f = fields.weeks)     != null ? f : super.weeks();\n            iWeekyears = (f = fields.weekyears) != null ? f : super.weekyears();\n            iMonths    = (f = fields.months)    != null ? f : super.months();\n            iYears     = (f = fields.years)     != null ? f : super.years();\n            iCenturies = (f = fields.centuries) != null ? f : super.centuries();\n            iEras      = (f = fields.eras)      != null ? f : super.eras();\n        }\n\n        {\n            DateTimeField f;\n            iMillisOfSecond     = (f = fields.millisOfSecond)     != null ? f : super.millisOfSecond();\n            iMillisOfDay        = (f = fields.millisOfDay)        != null ? f : super.millisOfDay();\n            iSecondOfMinute     = (f = fields.secondOfMinute)     != null ? f : super.secondOfMinute();\n            iSecondOfDay        = (f = fields.secondOfDay)        != null ? f : super.secondOfDay();\n            iMinuteOfHour       = (f = fields.minuteOfHour)       != null ? f : super.minuteOfHour();\n            iMinuteOfDay        = (f = fields.minuteOfDay)        != null ? f : super.minuteOfDay();\n            iHourOfDay          = (f = fields.hourOfDay)          != null ? f : super.hourOfDay();\n            iClockhourOfDay     = (f = fields.clockhourOfDay)     != null ? f : super.clockhourOfDay();\n            iHourOfHalfday      = (f = fields.hourOfHalfday)      != null ? f : super.hourOfHalfday();\n            iClockhourOfHalfday = (f = fields.clockhourOfHalfday) != null ? f : super.clockhourOfHalfday();\n            iHalfdayOfDay       = (f = fields.halfdayOfDay)       != null ? f : super.halfdayOfDay();\n            iDayOfWeek          = (f = fields.dayOfWeek)          != null ? f : super.dayOfWeek();\n            iDayOfMonth         = (f = fields.dayOfMonth)         != null ? f : super.dayOfMonth();\n            iDayOfYear          = (f = fields.dayOfYear)          != null ? f : super.dayOfYear();\n            iWeekOfWeekyear     = (f = fields.weekOfWeekyear)     != null ? f : super.weekOfWeekyear();\n            iWeekyear           = (f = fields.weekyear)           != null ? f : super.weekyear();\n            iWeekyearOfCentury  = (f = fields.weekyearOfCentury)  != null ? f : super.weekyearOfCentury();\n            iMonthOfYear        = (f = fields.monthOfYear)        != null ? f : super.monthOfYear();\n            iYear               = (f = fields.year)               != null ? f : super.year();\n            iYearOfEra          = (f = fields.yearOfEra)          != null ? f : super.yearOfEra();\n            iYearOfCentury      = (f = fields.yearOfCentury)      != null ? f : super.yearOfCentury();\n            iCenturyOfEra       = (f = fields.centuryOfEra)       != null ? f : super.centuryOfEra();\n            iEra                = (f = fields.era)                != null ? f : super.era();\n        }\n\n        int flags;\n        if (iBase == null) {\n            flags = 0;\n        } else {\n            flags = \n                ((iHourOfDay      == iBase.hourOfDay()      &&\n                  iMinuteOfHour   == iBase.minuteOfHour()   &&\n                  iSecondOfMinute == iBase.secondOfMinute() &&\n                  iMillisOfSecond == iBase.millisOfSecond()   ) ? 1 : 0) |\n\n                ((iMillisOfDay == iBase.millisOfDay()) ? 2 : 0) |\n\n                ((iYear        == iBase.year()        &&\n                  iMonthOfYear == iBase.monthOfYear() &&\n                  iDayOfMonth  == iBase.dayOfMonth()    ) ? 4 : 0);\n        }\n\n        iBaseFlags = flags;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "AssembledChronology.weekOfWeekyear",
    "class_name": "org.joda.time.chrono.AssembledChronology",
    "signature": "org.joda.time.chrono.AssembledChronology.weekOfWeekyear()",
    "snippet": "    public final DateTimeField weekOfWeekyear() {\n        return iWeekOfWeekyear;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "AssembledChronology.weeks",
    "class_name": "org.joda.time.chrono.AssembledChronology",
    "signature": "org.joda.time.chrono.AssembledChronology.weeks()",
    "snippet": "    public final DurationField weeks() {\n        return iWeeks;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "AssembledChronology.weekyear",
    "class_name": "org.joda.time.chrono.AssembledChronology",
    "signature": "org.joda.time.chrono.AssembledChronology.weekyear()",
    "snippet": "    public final DateTimeField weekyear() {\n        return iWeekyear;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "AssembledChronology.weekyearOfCentury",
    "class_name": "org.joda.time.chrono.AssembledChronology",
    "signature": "org.joda.time.chrono.AssembledChronology.weekyearOfCentury()",
    "snippet": "    public final DateTimeField weekyearOfCentury() {\n        return iWeekyearOfCentury;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "AssembledChronology.weekyears",
    "class_name": "org.joda.time.chrono.AssembledChronology",
    "signature": "org.joda.time.chrono.AssembledChronology.weekyears()",
    "snippet": "    public final DurationField weekyears() {\n        return iWeekyears;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "AssembledChronology.year",
    "class_name": "org.joda.time.chrono.AssembledChronology",
    "signature": "org.joda.time.chrono.AssembledChronology.year()",
    "snippet": "    public final DateTimeField year() {\n        return iYear;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "AssembledChronology.yearOfCentury",
    "class_name": "org.joda.time.chrono.AssembledChronology",
    "signature": "org.joda.time.chrono.AssembledChronology.yearOfCentury()",
    "snippet": "    public final DateTimeField yearOfCentury() {\n        return iYearOfCentury;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "AssembledChronology.yearOfEra",
    "class_name": "org.joda.time.chrono.AssembledChronology",
    "signature": "org.joda.time.chrono.AssembledChronology.yearOfEra()",
    "snippet": "    public final DateTimeField yearOfEra() {\n        return iYearOfEra;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "AssembledChronology.years",
    "class_name": "org.joda.time.chrono.AssembledChronology",
    "signature": "org.joda.time.chrono.AssembledChronology.years()",
    "snippet": "    public final DurationField years() {\n        return iYears;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "Fields.copyFieldsFrom",
    "class_name": "org.joda.time.chrono.AssembledChronology$Fields",
    "signature": "org.joda.time.chrono.AssembledChronology$Fields.copyFieldsFrom(Chronology)",
    "snippet": "        public void copyFieldsFrom(Chronology chrono) {\n            {\n                DurationField f;\n                if (isSupported(f = chrono.millis())) {\n                    millis = f;\n                }\n                if (isSupported(f = chrono.seconds())) {\n                    seconds = f;\n                }\n                if (isSupported(f = chrono.minutes())) {\n                    minutes = f;\n                }\n                if (isSupported(f = chrono.hours())) {\n                    hours = f;\n                }\n                if (isSupported(f = chrono.halfdays())) {\n                    halfdays = f;\n                }\n                if (isSupported(f = chrono.days())) {\n                    days = f;\n                }\n                if (isSupported(f = chrono.weeks())) {\n                    weeks = f;\n                }\n                if (isSupported(f = chrono.weekyears())) {\n                    weekyears = f;\n                }\n                if (isSupported(f = chrono.months())) {\n                    months = f;\n                }\n                if (isSupported(f = chrono.years())) {\n                    years = f;\n                }\n                if (isSupported(f = chrono.centuries())) {\n                    centuries = f;\n                }\n                if (isSupported(f = chrono.eras())) {\n                    eras = f;\n                }\n            }\n\n            {\n                DateTimeField f;\n                if (isSupported(f = chrono.millisOfSecond())) {\n                    millisOfSecond = f;\n                }\n                if (isSupported(f = chrono.millisOfDay())) {\n                    millisOfDay = f;\n                }\n                if (isSupported(f = chrono.secondOfMinute())) {\n                    secondOfMinute = f;\n                }\n                if (isSupported(f = chrono.secondOfDay())) {\n                    secondOfDay = f;\n                }\n                if (isSupported(f = chrono.minuteOfHour())) {\n                    minuteOfHour = f;\n                }\n                if (isSupported(f = chrono.minuteOfDay())) {\n                    minuteOfDay = f;\n                }\n                if (isSupported(f = chrono.hourOfDay())) {\n                    hourOfDay = f;\n                }\n                if (isSupported(f = chrono.clockhourOfDay())) {\n                    clockhourOfDay = f;\n                }\n                if (isSupported(f = chrono.hourOfHalfday())) {\n                    hourOfHalfday = f;\n                }\n                if (isSupported(f = chrono.clockhourOfHalfday())) {\n                    clockhourOfHalfday = f;\n                }\n                if (isSupported(f = chrono.halfdayOfDay())) {\n                    halfdayOfDay = f;\n                }\n                if (isSupported(f = chrono.dayOfWeek())) {\n                    dayOfWeek = f;\n                }\n                if (isSupported(f = chrono.dayOfMonth())) {\n                    dayOfMonth = f;\n                }\n                if (isSupported(f = chrono.dayOfYear())) {\n                    dayOfYear = f;\n                }\n                if (isSupported(f = chrono.weekOfWeekyear())) {\n                    weekOfWeekyear = f;\n                }\n                if (isSupported(f = chrono.weekyear())) {\n                    weekyear = f;\n                }\n                if (isSupported(f = chrono.weekyearOfCentury())) {\n                    weekyearOfCentury = f;\n                }\n                if (isSupported(f = chrono.monthOfYear())) {\n                    monthOfYear = f;\n                }\n                if (isSupported(f = chrono.year())) {\n                    year = f;\n                }\n                if (isSupported(f = chrono.yearOfEra())) {\n                    yearOfEra = f;\n                }\n                if (isSupported(f = chrono.yearOfCentury())) {\n                    yearOfCentury = f;\n                }\n                if (isSupported(f = chrono.centuryOfEra())) {\n                    centuryOfEra = f;\n                }\n                if (isSupported(f = chrono.era())) {\n                    era = f;\n                }\n            }\n        }",
    "comment": " Copy the supported fields from a chronology into this container. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "Fields.isSupported",
    "class_name": "org.joda.time.chrono.AssembledChronology$Fields",
    "signature": "org.joda.time.chrono.AssembledChronology$Fields.isSupported(DateTimeField)",
    "snippet": "        private static boolean isSupported(DateTimeField field) {\n            return field == null ? false : field.isSupported();\n        }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "Fields.isSupported",
    "class_name": "org.joda.time.chrono.AssembledChronology$Fields",
    "signature": "org.joda.time.chrono.AssembledChronology$Fields.isSupported(DurationField)",
    "snippet": "        private static boolean isSupported(DurationField field) {\n            return field == null ? false : field.isSupported();\n        }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "BaseChronology.BaseChronology",
    "class_name": "org.joda.time.chrono.BaseChronology",
    "signature": "org.joda.time.chrono.BaseChronology.BaseChronology()",
    "snippet": "    protected BaseChronology() {\n        super();\n    }",
    "comment": " Restricted constructor. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "BaseChronology.eras",
    "class_name": "org.joda.time.chrono.BaseChronology",
    "signature": "org.joda.time.chrono.BaseChronology.eras()",
    "snippet": "    public DurationField eras() {\n        return UnsupportedDurationField.getInstance(DurationFieldType.eras());\n    }",
    "comment": " Get the eras duration field for this chronology.  @return DurationField or UnsupportedDurationField if unsupported ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "BaseChronology.get",
    "class_name": "org.joda.time.chrono.BaseChronology",
    "signature": "org.joda.time.chrono.BaseChronology.get(ReadablePeriod,long)",
    "snippet": "    public int[] get(ReadablePeriod period, long duration) {\n        int size = period.size();\n        int[] values = new int[size];\n        if (duration != 0) {\n            long current = 0;\n            for (int i = 0; i < size; i++) {\n                DurationField field = period.getFieldType(i).getField(this);\n                if (field.isPrecise()) {\n                    int value = field.getDifference(duration, current);\n                    current = field.add(current, value);\n                    values[i] = value;\n                }\n            }\n        }\n        return values;\n    }",
    "comment": " Gets the values of a period from an interval.  @param period  the period instant to use @param duration  the duration to query @return the values of the period extracted from the duration ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "BasicChronology.BasicChronology",
    "class_name": "org.joda.time.chrono.BasicChronology",
    "signature": "org.joda.time.chrono.BasicChronology.BasicChronology(Chronology,Object,int)",
    "snippet": "    BasicChronology(Chronology base, Object param, int minDaysInFirstWeek) {\n        super(base, param);\n\n        if (minDaysInFirstWeek < 1 || minDaysInFirstWeek > 7) {\n            throw new IllegalArgumentException\n                (\"Invalid min days in first week: \" + minDaysInFirstWeek);\n        }\n\n        iMinDaysInFirstWeek = minDaysInFirstWeek;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "BasicChronology.assemble",
    "class_name": "org.joda.time.chrono.BasicChronology",
    "signature": "org.joda.time.chrono.BasicChronology.assemble(Fields)",
    "snippet": "    protected void assemble(Fields fields) {\n        // First copy fields that are the same for all Gregorian and Julian\n        // chronologies.\n\n        fields.millis = cMillisField;\n        fields.seconds = cSecondsField;\n        fields.minutes = cMinutesField;\n        fields.hours = cHoursField;\n        fields.halfdays = cHalfdaysField;\n        fields.days = cDaysField;\n        fields.weeks = cWeeksField;\n\n        fields.millisOfSecond = cMillisOfSecondField;\n        fields.millisOfDay = cMillisOfDayField;\n        fields.secondOfMinute = cSecondOfMinuteField;\n        fields.secondOfDay = cSecondOfDayField;\n        fields.minuteOfHour = cMinuteOfHourField;\n        fields.minuteOfDay = cMinuteOfDayField;\n        fields.hourOfDay = cHourOfDayField;\n        fields.hourOfHalfday = cHourOfHalfdayField;\n        fields.clockhourOfDay = cClockhourOfDayField;\n        fields.clockhourOfHalfday = cClockhourOfHalfdayField;\n        fields.halfdayOfDay = cHalfdayOfDayField;\n\n        // Now create fields that have unique behavior for Gregorian and Julian\n        // chronologies.\n\n        fields.year = new BasicYearDateTimeField(this);\n        fields.yearOfEra = new GJYearOfEraDateTimeField(fields.year, this);\n\n        // Define one-based centuryOfEra and yearOfCentury.\n        DateTimeField field = new OffsetDateTimeField(\n            fields.yearOfEra, 99);\n        fields.centuryOfEra = new DividedDateTimeField(\n            field, DateTimeFieldType.centuryOfEra(), 100);\n        \n        field = new RemainderDateTimeField(\n            (DividedDateTimeField) fields.centuryOfEra);\n        fields.yearOfCentury = new OffsetDateTimeField(\n            field, DateTimeFieldType.yearOfCentury(), 1);\n\n        fields.era = new GJEraDateTimeField(this);\n        fields.dayOfWeek = new GJDayOfWeekDateTimeField(this, fields.days);\n        fields.dayOfMonth = new BasicDayOfMonthDateTimeField(this, fields.days);\n        fields.dayOfYear = new BasicDayOfYearDateTimeField(this, fields.days);\n        fields.monthOfYear = new GJMonthOfYearDateTimeField(this);\n        fields.weekyear = new BasicWeekyearDateTimeField(this);\n        fields.weekOfWeekyear = new BasicWeekOfWeekyearDateTimeField(this, fields.weeks);\n        \n        field = new RemainderDateTimeField(\n            fields.weekyear, DateTimeFieldType.weekyearOfCentury(), 100);\n        fields.weekyearOfCentury = new OffsetDateTimeField(\n            field, DateTimeFieldType.weekyearOfCentury(), 1);\n        \n        // The remaining (imprecise) durations are available from the newly\n        // created datetime fields.\n\n        fields.years = fields.year.getDurationField();\n        fields.centuries = fields.centuryOfEra.getDurationField();\n        fields.months = fields.monthOfYear.getDurationField();\n        fields.weekyears = fields.weekyear.getDurationField();\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "BasicChronology.getMaxMonth",
    "class_name": "org.joda.time.chrono.BasicChronology",
    "signature": "org.joda.time.chrono.BasicChronology.getMaxMonth()",
    "snippet": "    int getMaxMonth() {\n        return 12;\n    }",
    "comment": " Gets the maximum number of months.  @return 12 ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "BasicChronology.getZone",
    "class_name": "org.joda.time.chrono.BasicChronology",
    "signature": "org.joda.time.chrono.BasicChronology.getZone()",
    "snippet": "    public DateTimeZone getZone() {\n        Chronology base;\n        if ((base = getBase()) != null) {\n            return base.getZone();\n        }\n        return DateTimeZone.UTC;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "BasicDayOfMonthDateTimeField.BasicDayOfMonthDateTimeField",
    "class_name": "org.joda.time.chrono.BasicDayOfMonthDateTimeField",
    "signature": "org.joda.time.chrono.BasicDayOfMonthDateTimeField.BasicDayOfMonthDateTimeField(BasicChronology,DurationField)",
    "snippet": "    BasicDayOfMonthDateTimeField(BasicChronology chronology, DurationField days) {\n        super(DateTimeFieldType.dayOfMonth(), days);\n        iChronology = chronology;\n    }",
    "comment": " Restricted constructor. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "BasicDayOfMonthDateTimeField.getRangeDurationField",
    "class_name": "org.joda.time.chrono.BasicDayOfMonthDateTimeField",
    "signature": "org.joda.time.chrono.BasicDayOfMonthDateTimeField.getRangeDurationField()",
    "snippet": "    public DurationField getRangeDurationField() {\n        return iChronology.months();\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "BasicDayOfYearDateTimeField.BasicDayOfYearDateTimeField",
    "class_name": "org.joda.time.chrono.BasicDayOfYearDateTimeField",
    "signature": "org.joda.time.chrono.BasicDayOfYearDateTimeField.BasicDayOfYearDateTimeField(BasicChronology,DurationField)",
    "snippet": "    BasicDayOfYearDateTimeField(BasicChronology chronology, DurationField days) {\n        super(DateTimeFieldType.dayOfYear(), days);\n        iChronology = chronology;\n    }",
    "comment": " Restricted constructor ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "BasicDayOfYearDateTimeField.getRangeDurationField",
    "class_name": "org.joda.time.chrono.BasicDayOfYearDateTimeField",
    "signature": "org.joda.time.chrono.BasicDayOfYearDateTimeField.getRangeDurationField()",
    "snippet": "    public DurationField getRangeDurationField() {\n        return iChronology.years();\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "BasicGJChronology.BasicGJChronology",
    "class_name": "org.joda.time.chrono.BasicGJChronology",
    "signature": "org.joda.time.chrono.BasicGJChronology.BasicGJChronology(Chronology,Object,int)",
    "snippet": "    BasicGJChronology(Chronology base, Object param, int minDaysInFirstWeek) {\n        super(base, param, minDaysInFirstWeek);\n    }",
    "comment": " Constructor. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "BasicMonthOfYearDateTimeField.BasicMonthOfYearDateTimeField",
    "class_name": "org.joda.time.chrono.BasicMonthOfYearDateTimeField",
    "signature": "org.joda.time.chrono.BasicMonthOfYearDateTimeField.BasicMonthOfYearDateTimeField(BasicChronology,int)",
    "snippet": "    BasicMonthOfYearDateTimeField(BasicChronology chronology, int leapMonth) {\n        super(DateTimeFieldType.monthOfYear(), chronology.getAverageMillisPerMonth());\n        iChronology = chronology;\n        iMax = iChronology.getMaxMonth();\n        iLeapMonth = leapMonth;\n    }",
    "comment": " Restricted constructor.  @param leapMonth the month of year that leaps ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "BasicMonthOfYearDateTimeField.getLeapDurationField",
    "class_name": "org.joda.time.chrono.BasicMonthOfYearDateTimeField",
    "signature": "org.joda.time.chrono.BasicMonthOfYearDateTimeField.getLeapDurationField()",
    "snippet": "    public DurationField getLeapDurationField() {\n        return iChronology.days();\n    }",
    "comment": "-----------------------------------------------------------------------",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "BasicMonthOfYearDateTimeField.getRangeDurationField",
    "class_name": "org.joda.time.chrono.BasicMonthOfYearDateTimeField",
    "signature": "org.joda.time.chrono.BasicMonthOfYearDateTimeField.getRangeDurationField()",
    "snippet": "    public DurationField getRangeDurationField() {\n        return iChronology.years();\n    }",
    "comment": "-----------------------------------------------------------------------",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "BasicWeekOfWeekyearDateTimeField.BasicWeekOfWeekyearDateTimeField",
    "class_name": "org.joda.time.chrono.BasicWeekOfWeekyearDateTimeField",
    "signature": "org.joda.time.chrono.BasicWeekOfWeekyearDateTimeField.BasicWeekOfWeekyearDateTimeField(BasicChronology,DurationField)",
    "snippet": "    BasicWeekOfWeekyearDateTimeField(BasicChronology chronology, DurationField weeks) {\n        super(DateTimeFieldType.weekOfWeekyear(), weeks);\n        iChronology = chronology;\n    }",
    "comment": " Restricted constructor ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "BasicWeekOfWeekyearDateTimeField.getRangeDurationField",
    "class_name": "org.joda.time.chrono.BasicWeekOfWeekyearDateTimeField",
    "signature": "org.joda.time.chrono.BasicWeekOfWeekyearDateTimeField.getRangeDurationField()",
    "snippet": "    public DurationField getRangeDurationField() {\n        return iChronology.weekyears();\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "BasicWeekyearDateTimeField.BasicWeekyearDateTimeField",
    "class_name": "org.joda.time.chrono.BasicWeekyearDateTimeField",
    "signature": "org.joda.time.chrono.BasicWeekyearDateTimeField.BasicWeekyearDateTimeField(BasicChronology)",
    "snippet": "    BasicWeekyearDateTimeField(BasicChronology chronology) {\n        super(DateTimeFieldType.weekyear(), chronology.getAverageMillisPerYear());\n        iChronology = chronology;\n    }",
    "comment": " Restricted constructor ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "BasicWeekyearDateTimeField.getLeapDurationField",
    "class_name": "org.joda.time.chrono.BasicWeekyearDateTimeField",
    "signature": "org.joda.time.chrono.BasicWeekyearDateTimeField.getLeapDurationField()",
    "snippet": "    public DurationField getLeapDurationField() {\n        return iChronology.weeks();\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "BasicWeekyearDateTimeField.getRangeDurationField",
    "class_name": "org.joda.time.chrono.BasicWeekyearDateTimeField",
    "signature": "org.joda.time.chrono.BasicWeekyearDateTimeField.getRangeDurationField()",
    "snippet": "    public DurationField getRangeDurationField() {\n        return null;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "BasicYearDateTimeField.BasicYearDateTimeField",
    "class_name": "org.joda.time.chrono.BasicYearDateTimeField",
    "signature": "org.joda.time.chrono.BasicYearDateTimeField.BasicYearDateTimeField(BasicChronology)",
    "snippet": "    BasicYearDateTimeField(BasicChronology chronology) {\n        super(DateTimeFieldType.year(), chronology.getAverageMillisPerYear());\n        iChronology = chronology;\n    }",
    "comment": " Restricted constructor.  @param chronology  the chronology this field belogs to ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "BasicYearDateTimeField.getLeapDurationField",
    "class_name": "org.joda.time.chrono.BasicYearDateTimeField",
    "signature": "org.joda.time.chrono.BasicYearDateTimeField.getLeapDurationField()",
    "snippet": "    public DurationField getLeapDurationField() {\n        return iChronology.days();\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "BasicYearDateTimeField.getMaximumValue",
    "class_name": "org.joda.time.chrono.BasicYearDateTimeField",
    "signature": "org.joda.time.chrono.BasicYearDateTimeField.getMaximumValue()",
    "snippet": "    public int getMaximumValue() {\n        return iChronology.getMaxYear();\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "BasicYearDateTimeField.getRangeDurationField",
    "class_name": "org.joda.time.chrono.BasicYearDateTimeField",
    "signature": "org.joda.time.chrono.BasicYearDateTimeField.getRangeDurationField()",
    "snippet": "    public DurationField getRangeDurationField() {\n        return null;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "GJDayOfWeekDateTimeField.GJDayOfWeekDateTimeField",
    "class_name": "org.joda.time.chrono.GJDayOfWeekDateTimeField",
    "signature": "org.joda.time.chrono.GJDayOfWeekDateTimeField.GJDayOfWeekDateTimeField(BasicChronology,DurationField)",
    "snippet": "    GJDayOfWeekDateTimeField(BasicChronology chronology, DurationField days) {\n        super(DateTimeFieldType.dayOfWeek(), days);\n        iChronology = chronology;\n    }",
    "comment": " Restricted constructor. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "GJDayOfWeekDateTimeField.getRangeDurationField",
    "class_name": "org.joda.time.chrono.GJDayOfWeekDateTimeField",
    "signature": "org.joda.time.chrono.GJDayOfWeekDateTimeField.getRangeDurationField()",
    "snippet": "    public DurationField getRangeDurationField() {\n        return iChronology.weeks();\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "GJEraDateTimeField.GJEraDateTimeField",
    "class_name": "org.joda.time.chrono.GJEraDateTimeField",
    "signature": "org.joda.time.chrono.GJEraDateTimeField.GJEraDateTimeField(BasicChronology)",
    "snippet": "    GJEraDateTimeField(BasicChronology chronology) {\n        super(DateTimeFieldType.era());\n        iChronology = chronology;\n    }",
    "comment": " Restricted constructor ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "GJEraDateTimeField.getDurationField",
    "class_name": "org.joda.time.chrono.GJEraDateTimeField",
    "signature": "org.joda.time.chrono.GJEraDateTimeField.getDurationField()",
    "snippet": "    public DurationField getDurationField() {\n        return UnsupportedDurationField.getInstance(DurationFieldType.eras());\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "GJEraDateTimeField.getRangeDurationField",
    "class_name": "org.joda.time.chrono.GJEraDateTimeField",
    "signature": "org.joda.time.chrono.GJEraDateTimeField.getRangeDurationField()",
    "snippet": "    public DurationField getRangeDurationField() {\n        return null;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "GJMonthOfYearDateTimeField.GJMonthOfYearDateTimeField",
    "class_name": "org.joda.time.chrono.GJMonthOfYearDateTimeField",
    "signature": "org.joda.time.chrono.GJMonthOfYearDateTimeField.GJMonthOfYearDateTimeField(BasicChronology)",
    "snippet": "    GJMonthOfYearDateTimeField(BasicChronology chronology) {\n        super(chronology, 2);\n    }",
    "comment": " Restricted constructor ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "GJYearOfEraDateTimeField.GJYearOfEraDateTimeField",
    "class_name": "org.joda.time.chrono.GJYearOfEraDateTimeField",
    "signature": "org.joda.time.chrono.GJYearOfEraDateTimeField.GJYearOfEraDateTimeField(DateTimeField,BasicChronology)",
    "snippet": "    GJYearOfEraDateTimeField(DateTimeField yearField, BasicChronology chronology) {\n        super(yearField, DateTimeFieldType.yearOfEra());\n        iChronology = chronology;\n    }",
    "comment": " Restricted constructor. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "GJYearOfEraDateTimeField.getMaximumValue",
    "class_name": "org.joda.time.chrono.GJYearOfEraDateTimeField",
    "signature": "org.joda.time.chrono.GJYearOfEraDateTimeField.getMaximumValue()",
    "snippet": "    public int getMaximumValue() {\n        return getWrappedField().getMaximumValue();\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "GJYearOfEraDateTimeField.getMinimumValue",
    "class_name": "org.joda.time.chrono.GJYearOfEraDateTimeField",
    "signature": "org.joda.time.chrono.GJYearOfEraDateTimeField.getMinimumValue()",
    "snippet": "    public int getMinimumValue() {\n        return 1;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "GregorianChronology.assemble",
    "class_name": "org.joda.time.chrono.GregorianChronology",
    "signature": "org.joda.time.chrono.GregorianChronology.assemble(Fields)",
    "snippet": "    protected void assemble(Fields fields) {\n        if (getBase() == null) {\n            super.assemble(fields);\n        }\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "GregorianChronology.getAverageMillisPerMonth",
    "class_name": "org.joda.time.chrono.GregorianChronology",
    "signature": "org.joda.time.chrono.GregorianChronology.getAverageMillisPerMonth()",
    "snippet": "    long getAverageMillisPerMonth() {\n        return MILLIS_PER_MONTH;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "GregorianChronology.getAverageMillisPerYear",
    "class_name": "org.joda.time.chrono.GregorianChronology",
    "signature": "org.joda.time.chrono.GregorianChronology.getAverageMillisPerYear()",
    "snippet": "    long getAverageMillisPerYear() {\n        return MILLIS_PER_YEAR;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "GregorianChronology.getInstance",
    "class_name": "org.joda.time.chrono.GregorianChronology",
    "signature": "org.joda.time.chrono.GregorianChronology.getInstance(DateTimeZone)",
    "snippet": "    public static GregorianChronology getInstance(DateTimeZone zone) {\n        return getInstance(zone, 4);\n    }",
    "comment": " Gets an instance of the GregorianChronology in the given time zone.  @param zone  the time zone to get the chronology in, null is default @return a chronology in the specified time zone ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "GregorianChronology.getInstance",
    "class_name": "org.joda.time.chrono.GregorianChronology",
    "signature": "org.joda.time.chrono.GregorianChronology.getInstance(DateTimeZone,int)",
    "snippet": "    public static GregorianChronology getInstance(DateTimeZone zone, int minDaysInFirstWeek) {\n        if (zone == null) {\n            zone = DateTimeZone.getDefault();\n        }\n        GregorianChronology chrono;\n        synchronized (cCache) {\n            GregorianChronology[] chronos = cCache.get(zone);\n            if (chronos == null) {\n                chronos = new GregorianChronology[7];\n                cCache.put(zone, chronos);\n            }\n            try {\n                chrono = chronos[minDaysInFirstWeek - 1];\n            } catch (ArrayIndexOutOfBoundsException e) {\n                throw new IllegalArgumentException\n                    (\"Invalid min days in first week: \" + minDaysInFirstWeek);\n            }\n            if (chrono == null) {\n                if (zone == DateTimeZone.UTC) {\n                    chrono = new GregorianChronology(null, null, minDaysInFirstWeek);\n                } else {\n                    chrono = getInstance(DateTimeZone.UTC, minDaysInFirstWeek);\n                    chrono = new GregorianChronology\n                        (ZonedChronology.getInstance(chrono, zone), null, minDaysInFirstWeek);\n                }\n                chronos[minDaysInFirstWeek - 1] = chrono;\n            }\n        }\n        return chrono;\n    }",
    "comment": " Gets an instance of the GregorianChronology in the given time zone.  @param zone  the time zone to get the chronology in, null is default @param minDaysInFirstWeek  minimum number of days in first week of the year; default is 4 @return a chronology in the specified time zone ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "GregorianChronology.getInstanceUTC",
    "class_name": "org.joda.time.chrono.GregorianChronology",
    "signature": "org.joda.time.chrono.GregorianChronology.getInstanceUTC()",
    "snippet": "    public static GregorianChronology getInstanceUTC() {\n        return INSTANCE_UTC;\n    }",
    "comment": " Gets an instance of the GregorianChronology. The time zone of the returned instance is UTC.  @return a singleton UTC instance of the chronology ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "GregorianChronology.getMaxYear",
    "class_name": "org.joda.time.chrono.GregorianChronology",
    "signature": "org.joda.time.chrono.GregorianChronology.getMaxYear()",
    "snippet": "    int getMaxYear() {\n        return MAX_YEAR;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "ISOChronology.assemble",
    "class_name": "org.joda.time.chrono.ISOChronology",
    "signature": "org.joda.time.chrono.ISOChronology.assemble(Fields)",
    "snippet": "    protected void assemble(Fields fields) {\n        if (getBase().getZone() == DateTimeZone.UTC) {\n            // Use zero based century and year of century.\n            fields.centuryOfEra = new DividedDateTimeField(\n                ISOYearOfEraDateTimeField.INSTANCE, DateTimeFieldType.centuryOfEra(), 100);\n            fields.yearOfCentury = new RemainderDateTimeField(\n                (DividedDateTimeField) fields.centuryOfEra, DateTimeFieldType.yearOfCentury());\n            fields.weekyearOfCentury = new RemainderDateTimeField(\n                (DividedDateTimeField) fields.centuryOfEra, DateTimeFieldType.weekyearOfCentury());\n\n            fields.centuries = fields.centuryOfEra.getDurationField();\n        }\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "ISOChronology.getInstance",
    "class_name": "org.joda.time.chrono.ISOChronology",
    "signature": "org.joda.time.chrono.ISOChronology.getInstance()",
    "snippet": "    public static ISOChronology getInstance() {\n        return getInstance(DateTimeZone.getDefault());\n    }",
    "comment": " Gets an instance of the ISOChronology in the default time zone.  @return a chronology in the default time zone ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "ISOChronology.getInstance",
    "class_name": "org.joda.time.chrono.ISOChronology",
    "signature": "org.joda.time.chrono.ISOChronology.getInstance(DateTimeZone)",
    "snippet": "    public static ISOChronology getInstance(DateTimeZone zone) {\n        if (zone == null) {\n            zone = DateTimeZone.getDefault();\n        }\n        int index = System.identityHashCode(zone) & (FAST_CACHE_SIZE - 1);\n        ISOChronology chrono = cFastCache[index];\n        if (chrono != null && chrono.getZone() == zone) {\n            return chrono;\n        }\n        synchronized (cCache) {\n            chrono = cCache.get(zone);\n            if (chrono == null) {\n                chrono = new ISOChronology(ZonedChronology.getInstance(INSTANCE_UTC, zone));\n                cCache.put(zone, chrono);\n            }\n        }\n        cFastCache[index] = chrono;\n        return chrono;\n    }",
    "comment": " Gets an instance of the ISOChronology in the given time zone.  @param zone  the time zone to get the chronology in, null is default @return a chronology in the specified time zone ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "ISOChronology.withUTC",
    "class_name": "org.joda.time.chrono.ISOChronology",
    "signature": "org.joda.time.chrono.ISOChronology.withUTC()",
    "snippet": "    public Chronology withUTC() {\n        return INSTANCE_UTC;\n    }",
    "comment": " Gets the Chronology in the UTC time zone.  @return the chronology in UTC ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "ISOYearOfEraDateTimeField.getMaximumValue",
    "class_name": "org.joda.time.chrono.ISOYearOfEraDateTimeField",
    "signature": "org.joda.time.chrono.ISOYearOfEraDateTimeField.getMaximumValue()",
    "snippet": "    public int getMaximumValue() {\n        return getWrappedField().getMaximumValue();\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "ISOYearOfEraDateTimeField.getMinimumValue",
    "class_name": "org.joda.time.chrono.ISOYearOfEraDateTimeField",
    "signature": "org.joda.time.chrono.ISOYearOfEraDateTimeField.getMinimumValue()",
    "snippet": "    public int getMinimumValue() {\n        return 0;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "ZonedChronology.assemble",
    "class_name": "org.joda.time.chrono.ZonedChronology",
    "signature": "org.joda.time.chrono.ZonedChronology.assemble(Fields)",
    "snippet": "    protected void assemble(Fields fields) {\n        // Keep a local cache of converted fields so as not to create redundant\n        // objects.\n        HashMap<Object, Object> converted = new HashMap<Object, Object>();\n\n        // Convert duration fields...\n\n        fields.eras = convertField(fields.eras, converted);\n        fields.centuries = convertField(fields.centuries, converted);\n        fields.years = convertField(fields.years, converted);\n        fields.months = convertField(fields.months, converted);\n        fields.weekyears = convertField(fields.weekyears, converted);\n        fields.weeks = convertField(fields.weeks, converted);\n        fields.days = convertField(fields.days, converted);\n\n        fields.halfdays = convertField(fields.halfdays, converted);\n        fields.hours = convertField(fields.hours, converted);\n        fields.minutes = convertField(fields.minutes, converted);\n        fields.seconds = convertField(fields.seconds, converted);\n        fields.millis = convertField(fields.millis, converted);\n\n        // Convert datetime fields...\n\n        fields.year = convertField(fields.year, converted);\n        fields.yearOfEra = convertField(fields.yearOfEra, converted);\n        fields.yearOfCentury = convertField(fields.yearOfCentury, converted);\n        fields.centuryOfEra = convertField(fields.centuryOfEra, converted);\n        fields.era = convertField(fields.era, converted);\n        fields.dayOfWeek = convertField(fields.dayOfWeek, converted);\n        fields.dayOfMonth = convertField(fields.dayOfMonth, converted);\n        fields.dayOfYear = convertField(fields.dayOfYear, converted);\n        fields.monthOfYear = convertField(fields.monthOfYear, converted);\n        fields.weekOfWeekyear = convertField(fields.weekOfWeekyear, converted);\n        fields.weekyear = convertField(fields.weekyear, converted);\n        fields.weekyearOfCentury = convertField(fields.weekyearOfCentury, converted);\n\n        fields.millisOfSecond = convertField(fields.millisOfSecond, converted);\n        fields.millisOfDay = convertField(fields.millisOfDay, converted);\n        fields.secondOfMinute = convertField(fields.secondOfMinute, converted);\n        fields.secondOfDay = convertField(fields.secondOfDay, converted);\n        fields.minuteOfHour = convertField(fields.minuteOfHour, converted);\n        fields.minuteOfDay = convertField(fields.minuteOfDay, converted);\n        fields.hourOfDay = convertField(fields.hourOfDay, converted);\n        fields.hourOfHalfday = convertField(fields.hourOfHalfday, converted);\n        fields.clockhourOfDay = convertField(fields.clockhourOfDay, converted);\n        fields.clockhourOfHalfday = convertField(fields.clockhourOfHalfday, converted);\n        fields.halfdayOfDay = convertField(fields.halfdayOfDay, converted);\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "ZonedChronology.convertField",
    "class_name": "org.joda.time.chrono.ZonedChronology",
    "signature": "org.joda.time.chrono.ZonedChronology.convertField(DateTimeField,HashMap)",
    "snippet": "    private DateTimeField convertField(DateTimeField field, HashMap<Object, Object> converted) {\n        if (field == null || !field.isSupported()) {\n            return field;\n        }\n        if (converted.containsKey(field)) {\n            return (DateTimeField)converted.get(field);\n        }\n        ZonedDateTimeField zonedField =\n            new ZonedDateTimeField(field, getZone(),\n                                   convertField(field.getDurationField(), converted),\n                                   convertField(field.getRangeDurationField(), converted),\n                                   convertField(field.getLeapDurationField(), converted));\n        converted.put(field, zonedField);\n        return zonedField;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "ZonedChronology.convertField",
    "class_name": "org.joda.time.chrono.ZonedChronology",
    "signature": "org.joda.time.chrono.ZonedChronology.convertField(DurationField,HashMap)",
    "snippet": "    private DurationField convertField(DurationField field, HashMap<Object, Object> converted) {\n        if (field == null || !field.isSupported()) {\n            return field;\n        }\n        if (converted.containsKey(field)) {\n            return (DurationField)converted.get(field);\n        }\n        ZonedDurationField zonedField = new ZonedDurationField(field, getZone());\n        converted.put(field, zonedField);\n        return zonedField;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "ZonedChronology.getInstance",
    "class_name": "org.joda.time.chrono.ZonedChronology",
    "signature": "org.joda.time.chrono.ZonedChronology.getInstance(Chronology,DateTimeZone)",
    "snippet": "    public static ZonedChronology getInstance(Chronology base, DateTimeZone zone) {\n        if (base == null) {\n            throw new IllegalArgumentException(\"Must supply a chronology\");\n        }\n        base = base.withUTC();\n        if (base == null) {\n            throw new IllegalArgumentException(\"UTC chronology must not be null\");\n        }\n        if (zone == null) {\n            throw new IllegalArgumentException(\"DateTimeZone must not be null\");\n        }\n        return new ZonedChronology(base, zone);\n    }",
    "comment": " Create a ZonedChronology for any chronology, overriding any time zone it may already have.  @param base base chronology to wrap @param zone the time zone @throws IllegalArgumentException if chronology or time zone is null ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "ZonedChronology.getZone",
    "class_name": "org.joda.time.chrono.ZonedChronology",
    "signature": "org.joda.time.chrono.ZonedChronology.getZone()",
    "snippet": "    public DateTimeZone getZone() {\n        return (DateTimeZone)getParam();\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "ZonedChronology.useTimeArithmetic",
    "class_name": "org.joda.time.chrono.ZonedChronology",
    "signature": "org.joda.time.chrono.ZonedChronology.useTimeArithmetic(DurationField)",
    "snippet": "    static boolean useTimeArithmetic(DurationField field) {\n        // Use time of day arithmetic rules for unit durations less than\n        // typical time zone offsets.\n        return field != null && field.getUnitMillis() < DateTimeConstants.MILLIS_PER_HOUR * 12;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "ZonedDurationField.getUnitMillis",
    "class_name": "org.joda.time.chrono.ZonedChronology$ZonedDurationField",
    "signature": "org.joda.time.chrono.ZonedChronology$ZonedDurationField.getUnitMillis()",
    "snippet": "        public long getUnitMillis() {\n            return iField.getUnitMillis();\n        }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "BaseDateTimeField.BaseDateTimeField",
    "class_name": "org.joda.time.field.BaseDateTimeField",
    "signature": "org.joda.time.field.BaseDateTimeField.BaseDateTimeField(DateTimeFieldType)",
    "snippet": "    protected BaseDateTimeField(DateTimeFieldType type) {\n        super();\n        if (type == null) {\n            throw new IllegalArgumentException(\"The type must not be null\");\n        }\n        iType = type;\n    }",
    "comment": " Constructor. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "BaseDateTimeField.getLeapDurationField",
    "class_name": "org.joda.time.field.BaseDateTimeField",
    "signature": "org.joda.time.field.BaseDateTimeField.getLeapDurationField()",
    "snippet": "    public DurationField getLeapDurationField() {\n        return null;\n    }",
    "comment": " If this field were to leap, then it would be in units described by the returned duration. If this field doesn't ever leap, null is returned. <p> This implementation returns null. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "BaseDateTimeField.getType",
    "class_name": "org.joda.time.field.BaseDateTimeField",
    "signature": "org.joda.time.field.BaseDateTimeField.getType()",
    "snippet": "    public final DateTimeFieldType getType() {\n        return iType;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "BaseDateTimeField.isSupported",
    "class_name": "org.joda.time.field.BaseDateTimeField",
    "signature": "org.joda.time.field.BaseDateTimeField.isSupported()",
    "snippet": "    public final boolean isSupported() {\n        return true;\n    }",
    "comment": " @return true always ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "BaseDurationField.BaseDurationField",
    "class_name": "org.joda.time.field.BaseDurationField",
    "signature": "org.joda.time.field.BaseDurationField.BaseDurationField(DurationFieldType)",
    "snippet": "    protected BaseDurationField(DurationFieldType type) {\n        super();\n        if (type == null) {\n            throw new IllegalArgumentException(\"The type must not be null\");\n        }\n        iType = type;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "BaseDurationField.getType",
    "class_name": "org.joda.time.field.BaseDurationField",
    "signature": "org.joda.time.field.BaseDurationField.getType()",
    "snippet": "    public final DurationFieldType getType() {\n        return iType;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "BaseDurationField.isSupported",
    "class_name": "org.joda.time.field.BaseDurationField",
    "signature": "org.joda.time.field.BaseDurationField.isSupported()",
    "snippet": "    public final boolean isSupported() {\n        return true;\n    }",
    "comment": " @return true always ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "DecoratedDateTimeField.DecoratedDateTimeField",
    "class_name": "org.joda.time.field.DecoratedDateTimeField",
    "signature": "org.joda.time.field.DecoratedDateTimeField.DecoratedDateTimeField(DateTimeField,DateTimeFieldType)",
    "snippet": "    protected DecoratedDateTimeField(DateTimeField field, DateTimeFieldType type) {\n        super(type);\n        if (field == null) {\n            throw new IllegalArgumentException(\"The field must not be null\");\n        }\n        if (!field.isSupported()) {\n            throw new IllegalArgumentException(\"The field must be supported\");\n        }\n        iField = field;\n    }",
    "comment": " Constructor.  @param field  the field being decorated @param type  allow type to be overridden ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "DecoratedDateTimeField.getDurationField",
    "class_name": "org.joda.time.field.DecoratedDateTimeField",
    "signature": "org.joda.time.field.DecoratedDateTimeField.getDurationField()",
    "snippet": "    public DurationField getDurationField() {\n        return iField.getDurationField();\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "DecoratedDateTimeField.getRangeDurationField",
    "class_name": "org.joda.time.field.DecoratedDateTimeField",
    "signature": "org.joda.time.field.DecoratedDateTimeField.getRangeDurationField()",
    "snippet": "    public DurationField getRangeDurationField() {\n        return iField.getRangeDurationField();\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "DecoratedDateTimeField.getWrappedField",
    "class_name": "org.joda.time.field.DecoratedDateTimeField",
    "signature": "org.joda.time.field.DecoratedDateTimeField.getWrappedField()",
    "snippet": "    public final DateTimeField getWrappedField() {\n        return iField;\n    }",
    "comment": " Gets the wrapped date time field.  @return the wrapped DateTimeField ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "DecoratedDurationField.DecoratedDurationField",
    "class_name": "org.joda.time.field.DecoratedDurationField",
    "signature": "org.joda.time.field.DecoratedDurationField.DecoratedDurationField(DurationField,DurationFieldType)",
    "snippet": "    public DecoratedDurationField(DurationField field, DurationFieldType type) {\n        super(type);\n        if (field == null) {\n            throw new IllegalArgumentException(\"The field must not be null\");\n        }\n        if (!field.isSupported()) {\n            throw new IllegalArgumentException(\"The field must be supported\");\n        }\n        iField = field;\n    }",
    "comment": " Constructor.  @param field  the base field @param type  the type to actually use ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "DecoratedDurationField.getWrappedField",
    "class_name": "org.joda.time.field.DecoratedDurationField",
    "signature": "org.joda.time.field.DecoratedDurationField.getWrappedField()",
    "snippet": "    public final DurationField getWrappedField() {\n        return iField;\n    }",
    "comment": " Gets the wrapped duration field.  @return the wrapped DurationField ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "DividedDateTimeField.DividedDateTimeField",
    "class_name": "org.joda.time.field.DividedDateTimeField",
    "signature": "org.joda.time.field.DividedDateTimeField.DividedDateTimeField(DateTimeField,DateTimeFieldType,int)",
    "snippet": "    public DividedDateTimeField(DateTimeField field,\n                                DateTimeFieldType type, int divisor) {\n        super(field, type);\n                \n        if (divisor < 2) {\n            throw new IllegalArgumentException(\"The divisor must be at least 2\");\n        }\n\n        DurationField unitField = field.getDurationField();\n        if (unitField == null) {\n            iDurationField = null;\n        } else {\n            iDurationField = new ScaledDurationField(\n                unitField, type.getDurationType(), divisor);\n        }\n\n        iDivisor = divisor;\n\n        int i = field.getMinimumValue();\n        int min = (i >= 0) ? i / divisor : ((i + 1) / divisor - 1);\n\n        int j = field.getMaximumValue();\n        int max = (j >= 0) ? j / divisor : ((j + 1) / divisor - 1);\n\n        iMin = min;\n        iMax = max;\n    }",
    "comment": " Constructor.  @param field  the field to wrap, like \"year()\". @param type  the field type this field will actually use @param divisor  divisor, such as 100 years in a century @throws IllegalArgumentException if divisor is less than two ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "DividedDateTimeField.getDurationField",
    "class_name": "org.joda.time.field.DividedDateTimeField",
    "signature": "org.joda.time.field.DividedDateTimeField.getDurationField()",
    "snippet": "    public DurationField getDurationField() {\n        return iDurationField;\n    }",
    "comment": " Returns a scaled version of the wrapped field's unit duration field. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "ImpreciseDateTimeField.ImpreciseDateTimeField",
    "class_name": "org.joda.time.field.ImpreciseDateTimeField",
    "signature": "org.joda.time.field.ImpreciseDateTimeField.ImpreciseDateTimeField(DateTimeFieldType,long)",
    "snippet": "    public ImpreciseDateTimeField(DateTimeFieldType type, long unitMillis) {\n        super(type);\n        iUnitMillis = unitMillis;\n        iDurationField = new LinkedDurationField(type.getDurationType());\n    }",
    "comment": " Constructor.  @param type  the field type @param unitMillis  the average duration unit milliseconds ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "ImpreciseDateTimeField.getDurationField",
    "class_name": "org.joda.time.field.ImpreciseDateTimeField",
    "signature": "org.joda.time.field.ImpreciseDateTimeField.getDurationField()",
    "snippet": "    public final DurationField getDurationField() {\n        return iDurationField;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "LinkedDurationField.getUnitMillis",
    "class_name": "org.joda.time.field.ImpreciseDateTimeField$LinkedDurationField",
    "signature": "org.joda.time.field.ImpreciseDateTimeField$LinkedDurationField.getUnitMillis()",
    "snippet": "        public long getUnitMillis() {\n            return iUnitMillis;\n        }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "MillisDurationField.getType",
    "class_name": "org.joda.time.field.MillisDurationField",
    "signature": "org.joda.time.field.MillisDurationField.getType()",
    "snippet": "    public DurationFieldType getType() {\n        return DurationFieldType.millis();\n    }",
    "comment": "------------------------------------------------------------------------",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "MillisDurationField.getUnitMillis",
    "class_name": "org.joda.time.field.MillisDurationField",
    "signature": "org.joda.time.field.MillisDurationField.getUnitMillis()",
    "snippet": "    public final long getUnitMillis() {\n        return 1;\n    }",
    "comment": " Returns the amount of milliseconds per unit value of this field.  @return one always ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "MillisDurationField.hashCode",
    "class_name": "org.joda.time.field.MillisDurationField",
    "signature": "org.joda.time.field.MillisDurationField.hashCode()",
    "snippet": "    public int hashCode() {\n        return (int) getUnitMillis();\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "MillisDurationField.isPrecise",
    "class_name": "org.joda.time.field.MillisDurationField",
    "signature": "org.joda.time.field.MillisDurationField.isPrecise()",
    "snippet": "    public final boolean isPrecise() {\n        return true;\n    }",
    "comment": " Returns true as this field is precise.  @return true always ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "MillisDurationField.isSupported",
    "class_name": "org.joda.time.field.MillisDurationField",
    "signature": "org.joda.time.field.MillisDurationField.isSupported()",
    "snippet": "    public boolean isSupported() {\n        return true;\n    }",
    "comment": " Returns true as this field is supported.  @return true always ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "OffsetDateTimeField.OffsetDateTimeField",
    "class_name": "org.joda.time.field.OffsetDateTimeField",
    "signature": "org.joda.time.field.OffsetDateTimeField.OffsetDateTimeField(DateTimeField,DateTimeFieldType,int)",
    "snippet": "    public OffsetDateTimeField(DateTimeField field, DateTimeFieldType type, int offset) {\n        this(field, type, offset, Integer.MIN_VALUE, Integer.MAX_VALUE);\n    }",
    "comment": " Constructor.  @param field  the field to wrap, like \"year()\". @param type  the field type this field actually uses @param offset  offset to add to field values @throws IllegalArgumentException if offset is zero ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "OffsetDateTimeField.OffsetDateTimeField",
    "class_name": "org.joda.time.field.OffsetDateTimeField",
    "signature": "org.joda.time.field.OffsetDateTimeField.OffsetDateTimeField(DateTimeField,DateTimeFieldType,int,int,int)",
    "snippet": "    public OffsetDateTimeField(DateTimeField field, DateTimeFieldType type, int offset,\n                               int minValue, int maxValue) {\n        super(field, type);\n                \n        if (offset == 0) {\n            throw new IllegalArgumentException(\"The offset cannot be zero\");\n        }\n\n        iOffset = offset;\n\n        if (minValue < (field.getMinimumValue() + offset)) {\n            iMin = field.getMinimumValue() + offset;\n        } else {\n            iMin = minValue;\n        }\n        if (maxValue > (field.getMaximumValue() + offset)) {\n            iMax = field.getMaximumValue() + offset;\n        } else {\n            iMax = maxValue;\n        }\n    }",
    "comment": " Constructor.  @param field  the field to wrap, like \"year()\". @param type  the field type this field actually uses @param offset  offset to add to field values @param minValue  minimum allowed value @param maxValue  maximum allowed value @throws IllegalArgumentException if offset is zero ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "OffsetDateTimeField.OffsetDateTimeField",
    "class_name": "org.joda.time.field.OffsetDateTimeField",
    "signature": "org.joda.time.field.OffsetDateTimeField.OffsetDateTimeField(DateTimeField,int)",
    "snippet": "    public OffsetDateTimeField(DateTimeField field, int offset) {\n        this(field, (field == null ? null : field.getType()), offset, Integer.MIN_VALUE, Integer.MAX_VALUE);\n    }",
    "comment": " Constructor.  @param field  the field to wrap, like \"year()\". @param offset  offset to add to field values @throws IllegalArgumentException if offset is zero ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "OffsetDateTimeField.getMaximumValue",
    "class_name": "org.joda.time.field.OffsetDateTimeField",
    "signature": "org.joda.time.field.OffsetDateTimeField.getMaximumValue()",
    "snippet": "    public int getMaximumValue() {\n        return iMax;\n    }",
    "comment": " Get the maximum value for the field.  @return the maximum value ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "OffsetDateTimeField.getMinimumValue",
    "class_name": "org.joda.time.field.OffsetDateTimeField",
    "signature": "org.joda.time.field.OffsetDateTimeField.getMinimumValue()",
    "snippet": "    public int getMinimumValue() {\n        return iMin;\n    }",
    "comment": " Get the minimum value for the field.  @return the minimum value ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "PreciseDateTimeField.PreciseDateTimeField",
    "class_name": "org.joda.time.field.PreciseDateTimeField",
    "signature": "org.joda.time.field.PreciseDateTimeField.PreciseDateTimeField(DateTimeFieldType,DurationField,DurationField)",
    "snippet": "    public PreciseDateTimeField(DateTimeFieldType type,\n                                DurationField unit, DurationField range) {\n        super(type, unit);\n\n        if (!range.isPrecise()) {\n            throw new IllegalArgumentException(\"Range duration field must be precise\");\n        }\n\n        long rangeMillis = range.getUnitMillis();\n        iRange = (int)(rangeMillis / getUnitMillis());\n        if (iRange < 2) {\n            throw new IllegalArgumentException(\"The effective range must be at least 2\");\n        }\n\n        iRangeField = range;\n    }",
    "comment": " Constructor.  @param type  the field type this field uses @param unit  precise unit duration, like \"seconds()\". @param range precise range duration, preferably a multiple of the unit, like \"minutes()\". @throws IllegalArgumentException if either duration field is imprecise @throws IllegalArgumentException if unit milliseconds is less than one or effective value range is less than two. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "PreciseDateTimeField.getRangeDurationField",
    "class_name": "org.joda.time.field.PreciseDateTimeField",
    "signature": "org.joda.time.field.PreciseDateTimeField.getRangeDurationField()",
    "snippet": "    public DurationField getRangeDurationField() {\n        return iRangeField;\n    }",
    "comment": " Returns the range duration of this field. For example, if this field represents \"minute of hour\", then the range duration field is an hours.  @return the range duration of this field, or null if field has no range ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "PreciseDurationDateTimeField.PreciseDurationDateTimeField",
    "class_name": "org.joda.time.field.PreciseDurationDateTimeField",
    "signature": "org.joda.time.field.PreciseDurationDateTimeField.PreciseDurationDateTimeField(DateTimeFieldType,DurationField)",
    "snippet": "    public PreciseDurationDateTimeField(DateTimeFieldType type, DurationField unit) {\n        super(type);\n\n        if (!unit.isPrecise()) {\n            throw new IllegalArgumentException(\"Unit duration field must be precise\");\n        }\n\n        iUnitMillis = unit.getUnitMillis();\n        if (iUnitMillis < 1) {\n            throw new IllegalArgumentException(\"The unit milliseconds must be at least 1\");\n        }\n\n        iUnitField = unit;\n    }",
    "comment": " Constructor.  @param type  the field type @param unit  precise unit duration, like \"days()\". @throws IllegalArgumentException if duration field is imprecise @throws IllegalArgumentException if unit milliseconds is less than one ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "PreciseDurationDateTimeField.getDurationField",
    "class_name": "org.joda.time.field.PreciseDurationDateTimeField",
    "signature": "org.joda.time.field.PreciseDurationDateTimeField.getDurationField()",
    "snippet": "    public DurationField getDurationField() {\n        return iUnitField;\n    }",
    "comment": " Returns the duration per unit value of this field. For example, if this field represents \"minute of hour\", then the duration field is minutes.  @return the duration of this field, or UnsupportedDurationField if field has no duration ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "PreciseDurationDateTimeField.getMinimumValue",
    "class_name": "org.joda.time.field.PreciseDurationDateTimeField",
    "signature": "org.joda.time.field.PreciseDurationDateTimeField.getMinimumValue()",
    "snippet": "    public int getMinimumValue() {\n        return 0;\n    }",
    "comment": " Get the minimum value for the field.  @return the minimum value ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "PreciseDurationDateTimeField.getUnitMillis",
    "class_name": "org.joda.time.field.PreciseDurationDateTimeField",
    "signature": "org.joda.time.field.PreciseDurationDateTimeField.getUnitMillis()",
    "snippet": "    public final long getUnitMillis() {\n        return iUnitMillis;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "PreciseDurationField.PreciseDurationField",
    "class_name": "org.joda.time.field.PreciseDurationField",
    "signature": "org.joda.time.field.PreciseDurationField.PreciseDurationField(DurationFieldType,long)",
    "snippet": "    public PreciseDurationField(DurationFieldType type, long unitMillis) {\n        super(type);\n        iUnitMillis = unitMillis;\n    }",
    "comment": " Constructor.  @param type  the field type @param unitMillis  the unit milliseconds ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "PreciseDurationField.getUnitMillis",
    "class_name": "org.joda.time.field.PreciseDurationField",
    "signature": "org.joda.time.field.PreciseDurationField.getUnitMillis()",
    "snippet": "    public final long getUnitMillis() {\n        return iUnitMillis;\n    }",
    "comment": " Returns the amount of milliseconds per unit value of this field.  @return the unit size of this field, in milliseconds ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "PreciseDurationField.hashCode",
    "class_name": "org.joda.time.field.PreciseDurationField",
    "signature": "org.joda.time.field.PreciseDurationField.hashCode()",
    "snippet": "    public int hashCode() {\n        long millis = iUnitMillis;\n        int hash = (int) (millis ^ (millis >>> 32));\n        hash += getType().hashCode();\n        return hash;\n    }",
    "comment": " Gets a hash code for this instance.  @return a suitable hashcode ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "PreciseDurationField.isPrecise",
    "class_name": "org.joda.time.field.PreciseDurationField",
    "signature": "org.joda.time.field.PreciseDurationField.isPrecise()",
    "snippet": "    public final boolean isPrecise() {\n        return true;\n    }",
    "comment": " This field is precise.  @return true always ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "RemainderDateTimeField.RemainderDateTimeField",
    "class_name": "org.joda.time.field.RemainderDateTimeField",
    "signature": "org.joda.time.field.RemainderDateTimeField.RemainderDateTimeField(DateTimeField,DateTimeFieldType,int)",
    "snippet": "    public RemainderDateTimeField(DateTimeField field,\n                                  DateTimeFieldType type, int divisor) {\n        super(field, type);\n\n        if (divisor < 2) {\n            throw new IllegalArgumentException(\"The divisor must be at least 2\");\n        }\n\n        DurationField rangeField = field.getDurationField();\n        if (rangeField == null) {\n            iRangeField = null;\n        } else {\n            iRangeField = new ScaledDurationField(\n                rangeField, type.getRangeDurationType(), divisor);\n        }\n\n        iDivisor = divisor;\n    }",
    "comment": " Constructor.  @param field  the field to wrap, like \"year()\". @param type  the field type this field actually uses @param divisor  divisor, such as 100 years in a century @throws IllegalArgumentException if divisor is less than two ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "RemainderDateTimeField.RemainderDateTimeField",
    "class_name": "org.joda.time.field.RemainderDateTimeField",
    "signature": "org.joda.time.field.RemainderDateTimeField.RemainderDateTimeField(DividedDateTimeField)",
    "snippet": "    public RemainderDateTimeField(DividedDateTimeField dividedField) {\n        this(dividedField, dividedField.getType());\n    }",
    "comment": " Construct a RemainderDateTimeField that compliments the given DividedDateTimeField.  @param dividedField  complimentary divided field, like \"century()\". ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "RemainderDateTimeField.RemainderDateTimeField",
    "class_name": "org.joda.time.field.RemainderDateTimeField",
    "signature": "org.joda.time.field.RemainderDateTimeField.RemainderDateTimeField(DividedDateTimeField,DateTimeFieldType)",
    "snippet": "    public RemainderDateTimeField(DividedDateTimeField dividedField, DateTimeFieldType type) {\n        super(dividedField.getWrappedField(), type);\n        iDivisor = dividedField.iDivisor;\n        iRangeField = dividedField.iDurationField;\n    }",
    "comment": " Construct a RemainderDateTimeField that compliments the given DividedDateTimeField.  @param dividedField  complimentary divided field, like \"century()\". @param type  the field type this field actually uses ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "RemainderDateTimeField.getMaximumValue",
    "class_name": "org.joda.time.field.RemainderDateTimeField",
    "signature": "org.joda.time.field.RemainderDateTimeField.getMaximumValue()",
    "snippet": "    public int getMaximumValue() {\n        return iDivisor - 1;\n    }",
    "comment": " Get the maximum value for the field, which is always one less than the divisor.  @return the maximum value ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "RemainderDateTimeField.getMinimumValue",
    "class_name": "org.joda.time.field.RemainderDateTimeField",
    "signature": "org.joda.time.field.RemainderDateTimeField.getMinimumValue()",
    "snippet": "    public int getMinimumValue() {\n        return 0;\n    }",
    "comment": " Get the minimum value for the field, which is always zero.  @return the minimum value of zero. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "RemainderDateTimeField.getRangeDurationField",
    "class_name": "org.joda.time.field.RemainderDateTimeField",
    "signature": "org.joda.time.field.RemainderDateTimeField.getRangeDurationField()",
    "snippet": "    public DurationField getRangeDurationField() {\n        return iRangeField;\n    }",
    "comment": " Returns a scaled version of the wrapped field's unit duration field. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "ScaledDurationField.ScaledDurationField",
    "class_name": "org.joda.time.field.ScaledDurationField",
    "signature": "org.joda.time.field.ScaledDurationField.ScaledDurationField(DurationField,DurationFieldType,int)",
    "snippet": "    public ScaledDurationField(DurationField field, DurationFieldType type, int scalar) {\n        super(field, type);\n        if (scalar == 0 || scalar == 1) {\n            throw new IllegalArgumentException(\"The scalar must not be 0 or 1\");\n        }\n        iScalar = scalar;\n    }",
    "comment": " Constructor  @param field  the field to wrap, like \"year()\". @param type  the type this field will actually use @param scalar  scalar, such as 100 years in a century @throws IllegalArgumentException if scalar is zero or one. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "ScaledDurationField.getUnitMillis",
    "class_name": "org.joda.time.field.ScaledDurationField",
    "signature": "org.joda.time.field.ScaledDurationField.getUnitMillis()",
    "snippet": "    public long getUnitMillis() {\n        return getWrappedField().getUnitMillis() * iScalar;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "ScaledDurationField.hashCode",
    "class_name": "org.joda.time.field.ScaledDurationField",
    "signature": "org.joda.time.field.ScaledDurationField.hashCode()",
    "snippet": "    public int hashCode() {\n        long scalar = iScalar;\n        int hash = (int) (scalar ^ (scalar >>> 32));\n        hash += getType().hashCode();\n        hash += getWrappedField().hashCode();\n        return hash;\n    }",
    "comment": " Gets a hash code for this instance.  @return a suitable hashcode ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "UnsupportedDurationField.getInstance",
    "class_name": "org.joda.time.field.UnsupportedDurationField",
    "signature": "org.joda.time.field.UnsupportedDurationField.getInstance(DurationFieldType)",
    "snippet": "    public static synchronized UnsupportedDurationField getInstance(DurationFieldType type) {\n        UnsupportedDurationField field;\n        if (cCache == null) {\n            cCache = new HashMap<DurationFieldType, UnsupportedDurationField>(7);\n            field = null;\n        } else {\n            field = cCache.get(type);\n        }\n        if (field == null) {\n            field = new UnsupportedDurationField(type);\n            cCache.put(type, field);\n        }\n        return field;\n    }",
    "comment": " Gets an instance of UnsupportedDurationField for a specific named field. The returned instance is cached.  @param type  the type to obtain @return the instance ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "UnsupportedDurationField.getUnitMillis",
    "class_name": "org.joda.time.field.UnsupportedDurationField",
    "signature": "org.joda.time.field.UnsupportedDurationField.getUnitMillis()",
    "snippet": "    public long getUnitMillis() {\n        return 0;\n    }",
    "comment": " Always returns zero.  @return zero always ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "UnsupportedDurationField.isSupported",
    "class_name": "org.joda.time.field.UnsupportedDurationField",
    "signature": "org.joda.time.field.UnsupportedDurationField.isSupported()",
    "snippet": "    public boolean isSupported() {\n        return false;\n    }",
    "comment": " This field is not supported.  @return false always ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "ZeroIsMaxDateTimeField.ZeroIsMaxDateTimeField",
    "class_name": "org.joda.time.field.ZeroIsMaxDateTimeField",
    "signature": "org.joda.time.field.ZeroIsMaxDateTimeField.ZeroIsMaxDateTimeField(DateTimeField,DateTimeFieldType)",
    "snippet": "    public ZeroIsMaxDateTimeField(DateTimeField field, DateTimeFieldType type) {\n        super(field, type);\n        if (field.getMinimumValue() != 0) {\n            throw new IllegalArgumentException(\"Wrapped field's minumum value must be zero\");\n        }\n    }",
    "comment": " Constructor.  @param field  the base field @param type  the field type this field will actually use @throws IllegalArgumentException if wrapped field's minimum value is not zero ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "ZeroIsMaxDateTimeField.getLeapDurationField",
    "class_name": "org.joda.time.field.ZeroIsMaxDateTimeField",
    "signature": "org.joda.time.field.ZeroIsMaxDateTimeField.getLeapDurationField()",
    "snippet": "    public DurationField getLeapDurationField() {\n        return getWrappedField().getLeapDurationField();\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "FormatUtils.appendPaddedInteger",
    "class_name": "org.joda.time.format.FormatUtils",
    "signature": "org.joda.time.format.FormatUtils.appendPaddedInteger(StringBuffer,int,int)",
    "snippet": "    public static void appendPaddedInteger(StringBuffer buf, int value, int size) {\n        if (value < 0) {\n            buf.append('-');\n            if (value != Integer.MIN_VALUE) {\n                value = -value;\n            } else {\n                for (; size > 10; size--) {\n                    buf.append('0');\n                }\n                buf.append(\"\" + -(long)Integer.MIN_VALUE);\n                return;\n            }\n        }\n        if (value < 10) {\n            for (; size > 1; size--) {\n                buf.append('0');\n            }\n            buf.append((char)(value + '0'));\n        } else if (value < 100) {\n            for (; size > 2; size--) {\n                buf.append('0');\n            }\n            // Calculate value div/mod by 10 without using two expensive\n            // division operations. (2 ^ 27) / 10 = 13421772. Add one to\n            // value to correct rounding error.\n            int d = ((value + 1) * 13421772) >> 27;\n            buf.append((char) (d + '0'));\n            // Append remainder by calculating (value - d * 10).\n            buf.append((char) (value - (d << 3) - (d << 1) + '0'));\n        } else {\n            int digits;\n            if (value < 1000) {\n                digits = 3;\n            } else if (value < 10000) {\n                digits = 4;\n            } else {\n                digits = (int)(Math.log(value) / LOG_10) + 1;\n            }\n            for (; size > digits; size--) {\n                buf.append('0');\n            }\n            buf.append(Integer.toString(value));\n        }\n    }",
    "comment": " Converts an integer to a string, prepended with a variable amount of '0' pad characters, and appends it to the given buffer.  <p>This method is optimized for converting small values to strings.  @param buf receives integer converted to a string @param value value to convert to a string @param size minumum amount of digits to append ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "FormatUtils.appendUnpaddedInteger",
    "class_name": "org.joda.time.format.FormatUtils",
    "signature": "org.joda.time.format.FormatUtils.appendUnpaddedInteger(StringBuffer,int)",
    "snippet": "    public static void appendUnpaddedInteger(StringBuffer buf, int value) {\n        if (value < 0) {\n            buf.append('-');\n            if (value != Integer.MIN_VALUE) {\n                value = -value;\n            } else {\n                buf.append(\"\" + -(long)Integer.MIN_VALUE);\n                return;\n            }\n        }\n        if (value < 10) {\n            buf.append((char)(value + '0'));\n        } else if (value < 100) {\n            // Calculate value div/mod by 10 without using two expensive\n            // division operations. (2 ^ 27) / 10 = 13421772. Add one to\n            // value to correct rounding error.\n            int d = ((value + 1) * 13421772) >> 27;\n            buf.append((char) (d + '0'));\n            // Append remainder by calculating (value - d * 10).\n            buf.append((char) (value - (d << 3) - (d << 1) + '0'));\n        } else {\n            buf.append(Integer.toString(value));\n        }\n    }",
    "comment": " Converts an integer to a string, and appends it to the given buffer.  <p>This method is optimized for converting small values to strings.  @param buf receives integer converted to a string @param value value to convert to a string ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "FormatUtils.calculateDigitCount",
    "class_name": "org.joda.time.format.FormatUtils",
    "signature": "org.joda.time.format.FormatUtils.calculateDigitCount(long)",
    "snippet": "    public static int calculateDigitCount(long value) {\n        if (value < 0) {\n            if (value != Long.MIN_VALUE) {\n                return calculateDigitCount(-value) + 1;\n            } else {\n                return 20;\n            }\n        }\n        return \n            (value < 10 ? 1 :\n             (value < 100 ? 2 :\n              (value < 1000 ? 3 :\n               (value < 10000 ? 4 :\n                ((int)(Math.log(value) / LOG_10) + 1)))));\n    }",
    "comment": " Calculates the number of decimal digits for the given value, including the sign. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "ISOPeriodFormat.standard",
    "class_name": "org.joda.time.format.ISOPeriodFormat",
    "signature": "org.joda.time.format.ISOPeriodFormat.standard()",
    "snippet": "    public static PeriodFormatter standard() {\n        if (cStandard == null) {\n            cStandard = new PeriodFormatterBuilder()\n                .appendLiteral(\"P\")\n                .appendYears()\n                .appendSuffix(\"Y\")\n                .appendMonths()\n                .appendSuffix(\"M\")\n                .appendWeeks()\n                .appendSuffix(\"W\")\n                .appendDays()\n                .appendSuffix(\"D\")\n                .appendSeparatorIfFieldsAfter(\"T\")\n                .appendHours()\n                .appendSuffix(\"H\")\n                .appendMinutes()\n                .appendSuffix(\"M\")\n                .appendSecondsWithOptionalMillis()\n                .appendSuffix(\"S\")\n                .toFormatter();\n        }\n        return cStandard;\n    }",
    "comment": " The standard ISO format - PyYmMwWdDThHmMsS. Milliseconds are not output. Note that the ISO8601 standard actually indicates weeks should not be shown if any other field is present and vice versa.  @return the formatter ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "PeriodFormatter.PeriodFormatter",
    "class_name": "org.joda.time.format.PeriodFormatter",
    "signature": "org.joda.time.format.PeriodFormatter.PeriodFormatter(PeriodPrinter,PeriodParser)",
    "snippet": "    public PeriodFormatter(\n            PeriodPrinter printer, PeriodParser parser) {\n        super();\n        iPrinter = printer;\n        iParser = parser;\n        iLocale = null;\n        iParseType = null;\n    }",
    "comment": " Creates a new formatter, however you will normally use the factory or the builder.  @param printer  the internal printer, null if cannot print @param parser  the internal parser, null if cannot parse ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "PeriodFormatter.checkPeriod",
    "class_name": "org.joda.time.format.PeriodFormatter",
    "signature": "org.joda.time.format.PeriodFormatter.checkPeriod(ReadablePeriod)",
    "snippet": "    private void checkPeriod(ReadablePeriod period) {\n        if (period == null) {\n            throw new IllegalArgumentException(\"Period must not be null\");\n        }\n    }",
    "comment": " Checks whether the period is non-null.  @throws IllegalArgumentException if the period is null ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "PeriodFormatter.checkPrinter",
    "class_name": "org.joda.time.format.PeriodFormatter",
    "signature": "org.joda.time.format.PeriodFormatter.checkPrinter()",
    "snippet": "    private void checkPrinter() {\n        if (iPrinter == null) {\n            throw new UnsupportedOperationException(\"Printing not supported\");\n        }\n    }",
    "comment": " Checks whether printing is supported.  @throws UnsupportedOperationException if printing is not supported ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "PeriodFormatter.getParser",
    "class_name": "org.joda.time.format.PeriodFormatter",
    "signature": "org.joda.time.format.PeriodFormatter.getParser()",
    "snippet": "    public PeriodParser getParser() {\n        return iParser;\n    }",
    "comment": " Gets the internal parser object that performs the real parsing work.  @return the internal parser ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "PeriodFormatter.getPrinter",
    "class_name": "org.joda.time.format.PeriodFormatter",
    "signature": "org.joda.time.format.PeriodFormatter.getPrinter()",
    "snippet": "    public PeriodPrinter getPrinter() {\n        return iPrinter;\n    }",
    "comment": " Gets the internal printer object that performs the real printing work.  @return the internal printer ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "PeriodFormatter.print",
    "class_name": "org.joda.time.format.PeriodFormatter",
    "signature": "org.joda.time.format.PeriodFormatter.print(ReadablePeriod)",
    "snippet": "    public String print(ReadablePeriod period) {\n        checkPrinter();\n        checkPeriod(period);\n        \n        PeriodPrinter printer = getPrinter();\n        StringBuffer buf = new StringBuffer(printer.calculatePrintedLength(period, iLocale));\n        printer.printTo(buf, period, iLocale);\n        return buf.toString();\n    }",
    "comment": " Prints a ReadablePeriod to a new String.  @param period  the period to format, not null @return the printed result ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "PeriodFormatterBuilder.PeriodFormatterBuilder",
    "class_name": "org.joda.time.format.PeriodFormatterBuilder",
    "signature": "org.joda.time.format.PeriodFormatterBuilder.PeriodFormatterBuilder()",
    "snippet": "    public PeriodFormatterBuilder() {\n        clear();\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "PeriodFormatterBuilder.append0",
    "class_name": "org.joda.time.format.PeriodFormatterBuilder",
    "signature": "org.joda.time.format.PeriodFormatterBuilder.append0(PeriodPrinter,PeriodParser)",
    "snippet": "    private PeriodFormatterBuilder append0(PeriodPrinter printer, PeriodParser parser) {\n        iElementPairs.add(printer);\n        iElementPairs.add(parser);\n        iNotPrinter |= (printer == null);\n        iNotParser |= (parser == null);\n        return this;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "PeriodFormatterBuilder.appendDays",
    "class_name": "org.joda.time.format.PeriodFormatterBuilder",
    "signature": "org.joda.time.format.PeriodFormatterBuilder.appendDays()",
    "snippet": "    public PeriodFormatterBuilder appendDays() {\n        appendField(DAYS);\n        return this;\n    }",
    "comment": " Instruct the printer to emit an integer days field, if supported. <p> The number of printed and parsed digits can be controlled using {@link #minimumPrintedDigits(int)} and {@link #maximumParsedDigits(int)}.  @return this PeriodFormatterBuilder ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "PeriodFormatterBuilder.appendField",
    "class_name": "org.joda.time.format.PeriodFormatterBuilder",
    "signature": "org.joda.time.format.PeriodFormatterBuilder.appendField(int)",
    "snippet": "    private void appendField(int type) {\n        appendField(type, iMinPrintedDigits);\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "PeriodFormatterBuilder.appendField",
    "class_name": "org.joda.time.format.PeriodFormatterBuilder",
    "signature": "org.joda.time.format.PeriodFormatterBuilder.appendField(int,int)",
    "snippet": "    private void appendField(int type, int minPrinted) {\n        FieldFormatter field = new FieldFormatter(minPrinted, iPrintZeroSetting,\n            iMaxParsedDigits, iRejectSignedValues, type, iFieldFormatters, iPrefix, null);\n        append0(field, field);\n        iFieldFormatters[type] = field;\n        iPrefix = null;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "PeriodFormatterBuilder.appendHours",
    "class_name": "org.joda.time.format.PeriodFormatterBuilder",
    "signature": "org.joda.time.format.PeriodFormatterBuilder.appendHours()",
    "snippet": "    public PeriodFormatterBuilder appendHours() {\n        appendField(HOURS);\n        return this;\n    }",
    "comment": " Instruct the printer to emit an integer hours field, if supported. <p> The number of printed and parsed digits can be controlled using {@link #minimumPrintedDigits(int)} and {@link #maximumParsedDigits(int)}.  @return this PeriodFormatterBuilder ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "PeriodFormatterBuilder.appendLiteral",
    "class_name": "org.joda.time.format.PeriodFormatterBuilder",
    "signature": "org.joda.time.format.PeriodFormatterBuilder.appendLiteral(String)",
    "snippet": "    public PeriodFormatterBuilder appendLiteral(String text) {\n        if (text == null) {\n            throw new IllegalArgumentException(\"Literal must not be null\");\n        }\n        clearPrefix();\n        Literal literal = new Literal(text);\n        append0(literal, literal);\n        return this;\n    }",
    "comment": " Instructs the printer to emit specific text, and the parser to expect it. The parser is case-insensitive.  @return this PeriodFormatterBuilder @throws IllegalArgumentException if text is null ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "PeriodFormatterBuilder.appendMinutes",
    "class_name": "org.joda.time.format.PeriodFormatterBuilder",
    "signature": "org.joda.time.format.PeriodFormatterBuilder.appendMinutes()",
    "snippet": "    public PeriodFormatterBuilder appendMinutes() {\n        appendField(MINUTES);\n        return this;\n    }",
    "comment": " Instruct the printer to emit an integer minutes field, if supported. <p> The number of printed and parsed digits can be controlled using {@link #minimumPrintedDigits(int)} and {@link #maximumParsedDigits(int)}.  @return this PeriodFormatterBuilder ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "PeriodFormatterBuilder.appendMonths",
    "class_name": "org.joda.time.format.PeriodFormatterBuilder",
    "signature": "org.joda.time.format.PeriodFormatterBuilder.appendMonths()",
    "snippet": "    public PeriodFormatterBuilder appendMonths() {\n        appendField(MONTHS);\n        return this;\n    }",
    "comment": " Instruct the printer to emit an integer months field, if supported. <p> The number of printed and parsed digits can be controlled using {@link #minimumPrintedDigits(int)} and {@link #maximumParsedDigits(int)}.  @return this PeriodFormatterBuilder ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "PeriodFormatterBuilder.appendSecondsWithOptionalMillis",
    "class_name": "org.joda.time.format.PeriodFormatterBuilder",
    "signature": "org.joda.time.format.PeriodFormatterBuilder.appendSecondsWithOptionalMillis()",
    "snippet": "    public PeriodFormatterBuilder appendSecondsWithOptionalMillis() {\n        appendField(SECONDS_OPTIONAL_MILLIS);\n        return this;\n    }",
    "comment": " Instruct the printer to emit a combined seconds and millis field, if supported. The millis will overflow into the seconds if necessary. The millis are only output if non-zero.  @return this PeriodFormatterBuilder ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "PeriodFormatterBuilder.appendSeparator",
    "class_name": "org.joda.time.format.PeriodFormatterBuilder",
    "signature": "org.joda.time.format.PeriodFormatterBuilder.appendSeparator(String,String,String[],boolean,boolean)",
    "snippet": "    private PeriodFormatterBuilder appendSeparator(String text, String finalText,\n                                                   String[] variants,\n                                                   boolean useBefore, boolean useAfter) {\n        if (text == null || finalText == null) {\n            throw new IllegalArgumentException();\n        }\n\n        clearPrefix();\n        \n        // optimise zero formatter case\n        List<Object> pairs = iElementPairs;\n        if (pairs.size() == 0) {\n            if (useAfter && useBefore == false) {\n                Separator separator = new Separator(\n                        text, finalText, variants,\n                        Literal.EMPTY, Literal.EMPTY, useBefore, useAfter);\n                append0(separator, separator);\n            }\n            return this;\n        }\n        \n        // find the last separator added\n        int i;\n        Separator lastSeparator = null;\n        for (i=pairs.size(); --i>=0; ) {\n            if (pairs.get(i) instanceof Separator) {\n                lastSeparator = (Separator) pairs.get(i);\n                pairs = pairs.subList(i + 1, pairs.size());\n                break;\n            }\n            i--;  // element pairs\n        }\n        \n        // merge formatters\n        if (lastSeparator != null && pairs.size() == 0) {\n            throw new IllegalStateException(\"Cannot have two adjacent separators\");\n        } else {\n            Object[] comp = createComposite(pairs);\n            pairs.clear();\n            Separator separator = new Separator(\n                    text, finalText, variants,\n                    (PeriodPrinter) comp[0], (PeriodParser) comp[1],\n                    useBefore, useAfter);\n            pairs.add(separator);\n            pairs.add(separator);\n        }\n        \n        return this;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "PeriodFormatterBuilder.appendSeparatorIfFieldsAfter",
    "class_name": "org.joda.time.format.PeriodFormatterBuilder",
    "signature": "org.joda.time.format.PeriodFormatterBuilder.appendSeparatorIfFieldsAfter(String)",
    "snippet": "    public PeriodFormatterBuilder appendSeparatorIfFieldsAfter(String text) {\n        return appendSeparator(text, text, null, false, true);\n    }",
    "comment": " Append a separator, which is output only if fields are printed after the separator. <p> For example, <code>builder.appendDays().appendSeparatorIfFieldsAfter(\",\").appendHours()</code> will only output the comma if the hours fields is output. <p> The text will be parsed case-insensitively. <p> Note: appending a separator discontinues any further work on the latest appended field.  @param text  the text to use as a separator @return this PeriodFormatterBuilder @throws IllegalStateException if this separator follows a previous one ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "PeriodFormatterBuilder.appendSuffix",
    "class_name": "org.joda.time.format.PeriodFormatterBuilder",
    "signature": "org.joda.time.format.PeriodFormatterBuilder.appendSuffix(PeriodFieldAffix)",
    "snippet": "    private PeriodFormatterBuilder appendSuffix(PeriodFieldAffix suffix) {\n        final Object originalPrinter;\n        final Object originalParser;\n        if (iElementPairs.size() > 0) {\n            originalPrinter = iElementPairs.get(iElementPairs.size() - 2);\n            originalParser = iElementPairs.get(iElementPairs.size() - 1);\n        } else {\n            originalPrinter = null;\n            originalParser = null;\n        }\n\n        if (originalPrinter == null || originalParser == null ||\n                originalPrinter != originalParser ||\n                !(originalPrinter instanceof FieldFormatter)) {\n            throw new IllegalStateException(\"No field to apply suffix to\");\n        }\n\n        clearPrefix();\n        FieldFormatter newField = new FieldFormatter((FieldFormatter) originalPrinter, suffix);\n        iElementPairs.set(iElementPairs.size() - 2, newField);\n        iElementPairs.set(iElementPairs.size() - 1, newField);\n        iFieldFormatters[newField.getFieldType()] = newField;\n        \n        return this;\n    }",
    "comment": " Append a field suffix which applies only to the last appended field. If the field is not printed, neither is the suffix.  @param suffix custom suffix @return this PeriodFormatterBuilder @throws IllegalStateException if no field exists to append to @see #appendPrefix ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "PeriodFormatterBuilder.appendSuffix",
    "class_name": "org.joda.time.format.PeriodFormatterBuilder",
    "signature": "org.joda.time.format.PeriodFormatterBuilder.appendSuffix(String)",
    "snippet": "    public PeriodFormatterBuilder appendSuffix(String text) {\n        if (text == null) {\n            throw new IllegalArgumentException();\n        }\n        return appendSuffix(new SimpleAffix(text));\n    }",
    "comment": " Append a field suffix which applies only to the last appended field. If the field is not printed, neither is the suffix.  @param text text to print after field only if field is printed @return this PeriodFormatterBuilder @throws IllegalStateException if no field exists to append to @see #appendPrefix ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "PeriodFormatterBuilder.appendWeeks",
    "class_name": "org.joda.time.format.PeriodFormatterBuilder",
    "signature": "org.joda.time.format.PeriodFormatterBuilder.appendWeeks()",
    "snippet": "    public PeriodFormatterBuilder appendWeeks() {\n        appendField(WEEKS);\n        return this;\n    }",
    "comment": " Instruct the printer to emit an integer weeks field, if supported. <p> The number of printed and parsed digits can be controlled using {@link #minimumPrintedDigits(int)} and {@link #maximumParsedDigits(int)}.  @return this PeriodFormatterBuilder ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "PeriodFormatterBuilder.appendYears",
    "class_name": "org.joda.time.format.PeriodFormatterBuilder",
    "signature": "org.joda.time.format.PeriodFormatterBuilder.appendYears()",
    "snippet": "    public PeriodFormatterBuilder appendYears() {\n        appendField(YEARS);\n        return this;\n    }",
    "comment": " Instruct the printer to emit an integer years field, if supported. <p> The number of printed and parsed digits can be controlled using {@link #minimumPrintedDigits(int)} and {@link #maximumParsedDigits(int)}.  @return this PeriodFormatterBuilder ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "PeriodFormatterBuilder.clear",
    "class_name": "org.joda.time.format.PeriodFormatterBuilder",
    "signature": "org.joda.time.format.PeriodFormatterBuilder.clear()",
    "snippet": "    public void clear() {\n        iMinPrintedDigits = 1;\n        iPrintZeroSetting = PRINT_ZERO_RARELY_LAST;\n        iMaxParsedDigits = 10;\n        iRejectSignedValues = false;\n        iPrefix = null;\n        if (iElementPairs == null) {\n            iElementPairs = new ArrayList<Object>();\n        } else {\n            iElementPairs.clear();\n        }\n        iNotPrinter = false;\n        iNotParser = false;\n        iFieldFormatters = new FieldFormatter[10];\n    }",
    "comment": " Clears out all the appended elements, allowing this builder to be reused. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "PeriodFormatterBuilder.clearPrefix",
    "class_name": "org.joda.time.format.PeriodFormatterBuilder",
    "signature": "org.joda.time.format.PeriodFormatterBuilder.clearPrefix()",
    "snippet": "    private void clearPrefix() throws IllegalStateException {\n        if (iPrefix != null) {\n            throw new IllegalStateException(\"Prefix not followed by field\");\n        }\n        iPrefix = null;\n    }",
    "comment": "-----------------------------------------------------------------------",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "PeriodFormatterBuilder.createComposite",
    "class_name": "org.joda.time.format.PeriodFormatterBuilder",
    "signature": "org.joda.time.format.PeriodFormatterBuilder.createComposite(List)",
    "snippet": "    private static Object[] createComposite(List<Object> elementPairs) {\n        switch (elementPairs.size()) {\n            case 0:\n                return new Object[] {Literal.EMPTY, Literal.EMPTY};\n            case 1:\n                return new Object[] {elementPairs.get(0), elementPairs.get(1)};\n            default:\n                Composite comp = new Composite(elementPairs);\n                return new Object[] {comp, comp};\n        }\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "PeriodFormatterBuilder.toFormatter",
    "class_name": "org.joda.time.format.PeriodFormatterBuilder",
    "signature": "org.joda.time.format.PeriodFormatterBuilder.toFormatter()",
    "snippet": "    public PeriodFormatter toFormatter() {\n        PeriodFormatter formatter = toFormatter(iElementPairs, iNotPrinter, iNotParser);\n        iFieldFormatters = (FieldFormatter[]) iFieldFormatters.clone();\n        return formatter;\n    }",
    "comment": " Constructs a PeriodFormatter using all the appended elements. <p> This is the main method used by applications at the end of the build process to create a usable formatter. <p> Subsequent changes to this builder do not affect the returned formatter. <p> The returned formatter may not support both printing and parsing. The methods {@link PeriodFormatter#isPrinter()} and {@link PeriodFormatter#isParser()} will help you determine the state of the formatter.  @return the newly created formatter @throws IllegalStateException if the builder can produce neither a printer nor a parser ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "PeriodFormatterBuilder.toFormatter",
    "class_name": "org.joda.time.format.PeriodFormatterBuilder",
    "signature": "org.joda.time.format.PeriodFormatterBuilder.toFormatter(List,boolean,boolean)",
    "snippet": "    private static PeriodFormatter toFormatter(List<Object> elementPairs, boolean notPrinter, boolean notParser) {\n        if (notPrinter && notParser) {\n            throw new IllegalStateException(\"Builder has created neither a printer nor a parser\");\n        }\n        int size = elementPairs.size();\n        if (size >= 2 && elementPairs.get(0) instanceof Separator) {\n            Separator sep = (Separator) elementPairs.get(0);\n            if (sep.iAfterParser == null && sep.iAfterPrinter == null) {\n                PeriodFormatter f = toFormatter(elementPairs.subList(2, size), notPrinter, notParser);\n                sep = sep.finish(f.getPrinter(), f.getParser());\n                return new PeriodFormatter(sep, sep);\n            }\n        }\n        Object[] comp = createComposite(elementPairs);\n        if (notPrinter) {\n            return new PeriodFormatter(null, (PeriodParser) comp[1]);\n        } else if (notParser) {\n            return new PeriodFormatter((PeriodPrinter) comp[0], null);\n        } else {\n            return new PeriodFormatter((PeriodPrinter) comp[0], (PeriodParser) comp[1]);\n        }\n    }",
    "comment": "-----------------------------------------------------------------------",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "Composite.calculatePrintedLength",
    "class_name": "org.joda.time.format.PeriodFormatterBuilder$Composite",
    "signature": "org.joda.time.format.PeriodFormatterBuilder$Composite.calculatePrintedLength(ReadablePeriod,Locale)",
    "snippet": "        public int calculatePrintedLength(ReadablePeriod period, Locale locale) {\n            int sum = 0;\n            PeriodPrinter[] printers = iPrinters;\n            for (int i=printers.length; --i>=0; ) {\n                sum += printers[i].calculatePrintedLength(period, locale);\n            }\n            return sum;\n        }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "Composite.countFieldsToPrint",
    "class_name": "org.joda.time.format.PeriodFormatterBuilder$Composite",
    "signature": "org.joda.time.format.PeriodFormatterBuilder$Composite.countFieldsToPrint(ReadablePeriod,int,Locale)",
    "snippet": "        public int countFieldsToPrint(ReadablePeriod period, int stopAt, Locale locale) {\n            int sum = 0;\n            PeriodPrinter[] printers = iPrinters;\n            for (int i=printers.length; sum < stopAt && --i>=0; ) {\n                sum += printers[i].countFieldsToPrint(period, Integer.MAX_VALUE, locale);\n            }\n            return sum;\n        }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "Composite.decompose",
    "class_name": "org.joda.time.format.PeriodFormatterBuilder$Composite",
    "signature": "org.joda.time.format.PeriodFormatterBuilder$Composite.decompose(List,List,List)",
    "snippet": "        private void decompose(List<Object> elementPairs, List<Object> printerList, List<Object> parserList) {\n            int size = elementPairs.size();\n            for (int i=0; i<size; i+=2) {\n                Object element = elementPairs.get(i);\n                if (element instanceof PeriodPrinter) {\n                    if (element instanceof Composite) {\n                        addArrayToList(printerList, ((Composite) element).iPrinters);\n                    } else {\n                        printerList.add(element);\n                    }\n                }\n\n                element = elementPairs.get(i + 1);\n                if (element instanceof PeriodParser) {\n                    if (element instanceof Composite) {\n                        addArrayToList(parserList, ((Composite) element).iParsers);\n                    } else {\n                        parserList.add(element);\n                    }\n                }\n            }\n        }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "Composite.printTo",
    "class_name": "org.joda.time.format.PeriodFormatterBuilder$Composite",
    "signature": "org.joda.time.format.PeriodFormatterBuilder$Composite.printTo(StringBuffer,ReadablePeriod,Locale)",
    "snippet": "        public void printTo(StringBuffer buf, ReadablePeriod period, Locale locale) {\n            PeriodPrinter[] printers = iPrinters;\n            int len = printers.length;\n            for (int i=0; i<len; i++) {\n                printers[i].printTo(buf, period, locale);\n            }\n        }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "FieldFormatter.calculatePrintedLength",
    "class_name": "org.joda.time.format.PeriodFormatterBuilder$FieldFormatter",
    "signature": "org.joda.time.format.PeriodFormatterBuilder$FieldFormatter.calculatePrintedLength(ReadablePeriod,Locale)",
    "snippet": "        public int calculatePrintedLength(ReadablePeriod period, Locale locale) {\n            long valueLong = getFieldValue(period);\n            if (valueLong == Long.MAX_VALUE) {\n                return 0;\n            }\n\n            int sum = Math.max(FormatUtils.calculateDigitCount(valueLong), iMinPrintedDigits);\n            if (iFieldType >= SECONDS_MILLIS) {\n                // valueLong contains the seconds and millis fields\n                // the minimum output is 0.000, which is 4 or 5 digits with a negative\n                sum = Math.max(sum, 4);\n                // plus one for the decimal point\n                sum++;\n                if (iFieldType == SECONDS_OPTIONAL_MILLIS &&\n                        (Math.abs(valueLong) % DateTimeConstants.MILLIS_PER_SECOND) == 0) {\n                    sum -= 4; // remove three digits and decimal point\n                }\n                // reset valueLong to refer to the seconds part for the prefic/suffix calculation\n                valueLong = valueLong / DateTimeConstants.MILLIS_PER_SECOND;\n            }\n            int value = (int) valueLong;\n\n            if (iPrefix != null) {\n                sum += iPrefix.calculatePrintedLength(value);\n            }\n            if (iSuffix != null) {\n                sum += iSuffix.calculatePrintedLength(value);\n            }\n\n            return sum;\n        }",
    "comment": "",
    "is_bug": true,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "FieldFormatter.countFieldsToPrint",
    "class_name": "org.joda.time.format.PeriodFormatterBuilder$FieldFormatter",
    "signature": "org.joda.time.format.PeriodFormatterBuilder$FieldFormatter.countFieldsToPrint(ReadablePeriod,int,Locale)",
    "snippet": "        public int countFieldsToPrint(ReadablePeriod period, int stopAt, Locale locale) {\n            if (stopAt <= 0) {\n                return 0;\n            }\n            if (iPrintZeroSetting == PRINT_ZERO_ALWAYS || getFieldValue(period) != Long.MAX_VALUE) {\n                return 1;\n            }\n            return 0;\n        }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "FieldFormatter.getFieldType",
    "class_name": "org.joda.time.format.PeriodFormatterBuilder$FieldFormatter",
    "signature": "org.joda.time.format.PeriodFormatterBuilder$FieldFormatter.getFieldType()",
    "snippet": "        int getFieldType() {\n            return iFieldType;\n        }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "FieldFormatter.getFieldValue",
    "class_name": "org.joda.time.format.PeriodFormatterBuilder$FieldFormatter",
    "signature": "org.joda.time.format.PeriodFormatterBuilder$FieldFormatter.getFieldValue(ReadablePeriod)",
    "snippet": "        long getFieldValue(ReadablePeriod period) {\n            PeriodType type;\n            if (iPrintZeroSetting == PRINT_ZERO_ALWAYS) {\n                type = null; // Don't need to check if supported.\n            } else {\n                type = period.getPeriodType();\n            }\n            if (type != null && isSupported(type, iFieldType) == false) {\n                return Long.MAX_VALUE;\n            }\n\n            long value;\n\n            switch (iFieldType) {\n            default:\n                return Long.MAX_VALUE;\n            case YEARS:\n                value = period.get(DurationFieldType.years());\n                break;\n            case MONTHS:\n                value = period.get(DurationFieldType.months());\n                break;\n            case WEEKS:\n                value = period.get(DurationFieldType.weeks());\n                break;\n            case DAYS:\n                value = period.get(DurationFieldType.days());\n                break;\n            case HOURS:\n                value = period.get(DurationFieldType.hours());\n                break;\n            case MINUTES:\n                value = period.get(DurationFieldType.minutes());\n                break;\n            case SECONDS:\n                value = period.get(DurationFieldType.seconds());\n                break;\n            case MILLIS:\n                value = period.get(DurationFieldType.millis());\n                break;\n            case SECONDS_MILLIS: // drop through\n            case SECONDS_OPTIONAL_MILLIS:\n                int seconds = period.get(DurationFieldType.seconds());\n                int millis = period.get(DurationFieldType.millis());\n                value = (seconds * (long) DateTimeConstants.MILLIS_PER_SECOND) + millis;\n                break;\n            }\n\n            // determine if period is zero and this is the last field\n            if (value == 0) {\n                switch (iPrintZeroSetting) {\n                case PRINT_ZERO_NEVER:\n                    return Long.MAX_VALUE;\n                case PRINT_ZERO_RARELY_LAST:\n                    if (isZero(period) && iFieldFormatters[iFieldType] == this) {\n                        for (int i = iFieldType + 1; i <= MAX_FIELD; i++) {\n                            if (isSupported(type, i) && iFieldFormatters[i] != null) {\n                                return Long.MAX_VALUE;\n                            }\n                        }\n                    } else {\n                        return Long.MAX_VALUE;\n                    }\n                    break;\n                case PRINT_ZERO_RARELY_FIRST:\n                    if (isZero(period) && iFieldFormatters[iFieldType] == this) {\n                        int i = Math.min(iFieldType, 8);  // line split out for IBM JDK\n                        i--;                              // see bug 1660490\n                        for (; i >= 0 && i <= MAX_FIELD; i--) {\n                            if (isSupported(type, i) && iFieldFormatters[i] != null) {\n                                return Long.MAX_VALUE;\n                            }\n                        }\n                    } else {\n                        return Long.MAX_VALUE;\n                    }\n                    break;\n                }\n            }\n\n            return value;\n        }",
    "comment": " @return Long.MAX_VALUE if nothing to print, otherwise value ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "FieldFormatter.isSupported",
    "class_name": "org.joda.time.format.PeriodFormatterBuilder$FieldFormatter",
    "signature": "org.joda.time.format.PeriodFormatterBuilder$FieldFormatter.isSupported(PeriodType,int)",
    "snippet": "        boolean isSupported(PeriodType type, int field) {\n            switch (field) {\n            default:\n                return false;\n            case YEARS:\n                return type.isSupported(DurationFieldType.years());\n            case MONTHS:\n                return type.isSupported(DurationFieldType.months());\n            case WEEKS:\n                return type.isSupported(DurationFieldType.weeks());\n            case DAYS:\n                return type.isSupported(DurationFieldType.days());\n            case HOURS:\n                return type.isSupported(DurationFieldType.hours());\n            case MINUTES:\n                return type.isSupported(DurationFieldType.minutes());\n            case SECONDS:\n                return type.isSupported(DurationFieldType.seconds());\n            case MILLIS:\n                return type.isSupported(DurationFieldType.millis());\n            case SECONDS_MILLIS: // drop through\n            case SECONDS_OPTIONAL_MILLIS:\n                return type.isSupported(DurationFieldType.seconds()) ||\n                       type.isSupported(DurationFieldType.millis());\n            }\n        }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "FieldFormatter.isZero",
    "class_name": "org.joda.time.format.PeriodFormatterBuilder$FieldFormatter",
    "signature": "org.joda.time.format.PeriodFormatterBuilder$FieldFormatter.isZero(ReadablePeriod)",
    "snippet": "        boolean isZero(ReadablePeriod period) {\n            for (int i = 0, isize = period.size(); i < isize; i++) {\n                if (period.getValue(i) != 0) {\n                    return false;\n                }\n            }\n            return true;\n        }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "FieldFormatter.printTo",
    "class_name": "org.joda.time.format.PeriodFormatterBuilder$FieldFormatter",
    "signature": "org.joda.time.format.PeriodFormatterBuilder$FieldFormatter.printTo(StringBuffer,ReadablePeriod,Locale)",
    "snippet": "        public void printTo(StringBuffer buf, ReadablePeriod period, Locale locale) {\n            long valueLong = getFieldValue(period);\n            if (valueLong == Long.MAX_VALUE) {\n                return;\n            }\n            int value = (int) valueLong;\n            if (iFieldType >= SECONDS_MILLIS) {\n                value = (int) (valueLong / DateTimeConstants.MILLIS_PER_SECOND);\n            }\n\n            if (iPrefix != null) {\n                iPrefix.printTo(buf, value);\n            }\n            int minDigits = iMinPrintedDigits;\n            if (minDigits <= 1) {\n                FormatUtils.appendUnpaddedInteger(buf, value);\n            } else {\n                FormatUtils.appendPaddedInteger(buf, value, minDigits);\n            }\n            if (iFieldType >= SECONDS_MILLIS) {\n                int dp = (int) (Math.abs(valueLong) % DateTimeConstants.MILLIS_PER_SECOND);\n                if (iFieldType == SECONDS_MILLIS || dp > 0) {\n                    buf.append('.');\n                    FormatUtils.appendPaddedInteger(buf, dp, 3);\n                }\n            }\n            if (iSuffix != null) {\n                iSuffix.printTo(buf, value);\n            }\n        }",
    "comment": "",
    "is_bug": true,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "Literal.calculatePrintedLength",
    "class_name": "org.joda.time.format.PeriodFormatterBuilder$Literal",
    "signature": "org.joda.time.format.PeriodFormatterBuilder$Literal.calculatePrintedLength(ReadablePeriod,Locale)",
    "snippet": "        public int calculatePrintedLength(ReadablePeriod period, Locale locale) {\n            return iText.length();\n        }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "Literal.printTo",
    "class_name": "org.joda.time.format.PeriodFormatterBuilder$Literal",
    "signature": "org.joda.time.format.PeriodFormatterBuilder$Literal.printTo(StringBuffer,ReadablePeriod,Locale)",
    "snippet": "        public void printTo(StringBuffer buf, ReadablePeriod period, Locale locale) {\n            buf.append(iText);\n        }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "Separator.calculatePrintedLength",
    "class_name": "org.joda.time.format.PeriodFormatterBuilder$Separator",
    "signature": "org.joda.time.format.PeriodFormatterBuilder$Separator.calculatePrintedLength(ReadablePeriod,Locale)",
    "snippet": "        public int calculatePrintedLength(ReadablePeriod period, Locale locale) {\n            PeriodPrinter before = iBeforePrinter;\n            PeriodPrinter after = iAfterPrinter;\n            \n            int sum = before.calculatePrintedLength(period, locale)\n                    + after.calculatePrintedLength(period, locale);\n            \n            if (iUseBefore) {\n                if (before.countFieldsToPrint(period, 1, locale) > 0) {\n                    if (iUseAfter) {\n                        int afterCount = after.countFieldsToPrint(period, 2, locale);\n                        if (afterCount > 0) {\n                            sum += (afterCount > 1 ? iText : iFinalText).length();\n                        }\n                    } else {\n                        sum += iText.length();\n                    }\n                }\n            } else if (iUseAfter && after.countFieldsToPrint(period, 1, locale) > 0) {\n                sum += iText.length();\n            }\n            \n            return sum;\n        }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "Separator.finish",
    "class_name": "org.joda.time.format.PeriodFormatterBuilder$Separator",
    "signature": "org.joda.time.format.PeriodFormatterBuilder$Separator.finish(PeriodPrinter,PeriodParser)",
    "snippet": "        Separator finish(PeriodPrinter afterPrinter, PeriodParser afterParser) {\n            iAfterPrinter = afterPrinter;\n            iAfterParser = afterParser;\n            return this;\n        }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "Separator.printTo",
    "class_name": "org.joda.time.format.PeriodFormatterBuilder$Separator",
    "signature": "org.joda.time.format.PeriodFormatterBuilder$Separator.printTo(StringBuffer,ReadablePeriod,Locale)",
    "snippet": "        public void printTo(StringBuffer buf, ReadablePeriod period, Locale locale) {\n            PeriodPrinter before = iBeforePrinter;\n            PeriodPrinter after = iAfterPrinter;\n            \n            before.printTo(buf, period, locale);\n            if (iUseBefore) {\n                if (before.countFieldsToPrint(period, 1, locale) > 0) {\n                    if (iUseAfter) {\n                        int afterCount = after.countFieldsToPrint(period, 2, locale);\n                        if (afterCount > 0) {\n                            buf.append(afterCount > 1 ? iText : iFinalText);\n                        }\n                    } else {\n                        buf.append(iText);\n                    }\n                }\n            } else if (iUseAfter && after.countFieldsToPrint(period, 1, locale) > 0) {\n                buf.append(iText);\n            }\n            after.printTo(buf, period, locale);\n        }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "SimpleAffix.calculatePrintedLength",
    "class_name": "org.joda.time.format.PeriodFormatterBuilder$SimpleAffix",
    "signature": "org.joda.time.format.PeriodFormatterBuilder$SimpleAffix.calculatePrintedLength(int)",
    "snippet": "        public int calculatePrintedLength(int value) {\n            return iText.length();\n        }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "SimpleAffix.printTo",
    "class_name": "org.joda.time.format.PeriodFormatterBuilder$SimpleAffix",
    "signature": "org.joda.time.format.PeriodFormatterBuilder$SimpleAffix.printTo(StringBuffer,int)",
    "snippet": "        public void printTo(StringBuffer buf, int value) {\n            buf.append(iText);\n        }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "CachedDateTimeZone.forZone",
    "class_name": "org.joda.time.tz.CachedDateTimeZone",
    "signature": "org.joda.time.tz.CachedDateTimeZone.forZone(DateTimeZone)",
    "snippet": "    public static CachedDateTimeZone forZone(DateTimeZone zone) {\n        if (zone instanceof CachedDateTimeZone) {\n            return (CachedDateTimeZone)zone;\n        }\n        return new CachedDateTimeZone(zone);\n    }",
    "comment": " Returns a new CachedDateTimeZone unless given zone is already cached. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "CachedDateTimeZone.hashCode",
    "class_name": "org.joda.time.tz.CachedDateTimeZone",
    "signature": "org.joda.time.tz.CachedDateTimeZone.hashCode()",
    "snippet": "    public int hashCode() {\n        return iZone.hashCode();\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "DateTimeZoneBuilder.readFrom",
    "class_name": "org.joda.time.tz.DateTimeZoneBuilder",
    "signature": "org.joda.time.tz.DateTimeZoneBuilder.readFrom(DataInput,String)",
    "snippet": "    public static DateTimeZone readFrom(DataInput in, String id) throws IOException {\n        switch (in.readUnsignedByte()) {\n        case 'F':\n            DateTimeZone fixed = new FixedDateTimeZone\n                (id, in.readUTF(), (int)readMillis(in), (int)readMillis(in));\n            if (fixed.equals(DateTimeZone.UTC)) {\n                fixed = DateTimeZone.UTC;\n            }\n            return fixed;\n        case 'C':\n            return CachedDateTimeZone.forZone(PrecalculatedZone.readFrom(in, id));\n        case 'P':\n            return PrecalculatedZone.readFrom(in, id);\n        default:\n            throw new IOException(\"Invalid encoding\");\n        }\n    }",
    "comment": " Decodes a built DateTimeZone from the given stream, as encoded by writeTo.  @param in input stream to read encoded DateTimeZone from. @param id time zone id to assign ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "DateTimeZoneBuilder.readFrom",
    "class_name": "org.joda.time.tz.DateTimeZoneBuilder",
    "signature": "org.joda.time.tz.DateTimeZoneBuilder.readFrom(InputStream,String)",
    "snippet": "    public static DateTimeZone readFrom(InputStream in, String id) throws IOException {\n        if (in instanceof DataInput) {\n            return readFrom((DataInput)in, id);\n        } else {\n            return readFrom((DataInput)new DataInputStream(in), id);\n        }\n    }",
    "comment": " Decodes a built DateTimeZone from the given stream, as encoded by writeTo.  @param in input stream to read encoded DateTimeZone from. @param id time zone id to assign ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "DateTimeZoneBuilder.readMillis",
    "class_name": "org.joda.time.tz.DateTimeZoneBuilder",
    "signature": "org.joda.time.tz.DateTimeZoneBuilder.readMillis(DataInput)",
    "snippet": "    static long readMillis(DataInput in) throws IOException {\n        int v = in.readUnsignedByte();\n        switch (v >> 6) {\n        case 0: default:\n            // Form 00 (6 bits effective precision)\n            v = (v << (32 - 6)) >> (32 - 6);\n            return v * (30 * 60000L);\n\n        case 1:\n            // Form 01 (30 bits effective precision)\n            v = (v << (32 - 6)) >> (32 - 30);\n            v |= (in.readUnsignedByte()) << 16;\n            v |= (in.readUnsignedByte()) << 8;\n            v |= (in.readUnsignedByte());\n            return v * 60000L;\n\n        case 2:\n            // Form 10 (38 bits effective precision)\n            long w = (((long)v) << (64 - 6)) >> (64 - 38);\n            w |= (in.readUnsignedByte()) << 24;\n            w |= (in.readUnsignedByte()) << 16;\n            w |= (in.readUnsignedByte()) << 8;\n            w |= (in.readUnsignedByte());\n            return w * 1000L;\n\n        case 3:\n            // Form 11 (64 bits effective precision)\n            return in.readLong();\n        }\n    }",
    "comment": " Reads encoding generated by writeMillis. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "DSTZone.readFrom",
    "class_name": "org.joda.time.tz.DateTimeZoneBuilder$DSTZone",
    "signature": "org.joda.time.tz.DateTimeZoneBuilder$DSTZone.readFrom(DataInput,String)",
    "snippet": "        static DSTZone readFrom(DataInput in, String id) throws IOException {\n            return new DSTZone(id, (int)readMillis(in), \n                               Recurrence.readFrom(in), Recurrence.readFrom(in));\n        }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "OfYear.readFrom",
    "class_name": "org.joda.time.tz.DateTimeZoneBuilder$OfYear",
    "signature": "org.joda.time.tz.DateTimeZoneBuilder$OfYear.readFrom(DataInput)",
    "snippet": "        static OfYear readFrom(DataInput in) throws IOException {\n            return new OfYear((char)in.readUnsignedByte(),\n                              (int)in.readUnsignedByte(),\n                              (int)in.readByte(),\n                              (int)in.readUnsignedByte(),\n                              in.readBoolean(),\n                              (int)readMillis(in));\n        }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "PrecalculatedZone.readFrom",
    "class_name": "org.joda.time.tz.DateTimeZoneBuilder$PrecalculatedZone",
    "signature": "org.joda.time.tz.DateTimeZoneBuilder$PrecalculatedZone.readFrom(DataInput,String)",
    "snippet": "        static PrecalculatedZone readFrom(DataInput in, String id) throws IOException {\n            // Read string pool.\n            int poolSize = in.readUnsignedShort();\n            String[] pool = new String[poolSize];\n            for (int i=0; i<poolSize; i++) {\n                pool[i] = in.readUTF();\n            }\n\n            int size = in.readInt();\n            long[] transitions = new long[size];\n            int[] wallOffsets = new int[size];\n            int[] standardOffsets = new int[size];\n            String[] nameKeys = new String[size];\n            \n            for (int i=0; i<size; i++) {\n                transitions[i] = readMillis(in);\n                wallOffsets[i] = (int)readMillis(in);\n                standardOffsets[i] = (int)readMillis(in);\n                try {\n                    int index;\n                    if (poolSize < 256) {\n                        index = in.readUnsignedByte();\n                    } else {\n                        index = in.readUnsignedShort();\n                    }\n                    nameKeys[i] = pool[index];\n                } catch (ArrayIndexOutOfBoundsException e) {\n                    throw new IOException(\"Invalid encoding\");\n                }\n            }\n\n            DSTZone tailZone = null;\n            if (in.readBoolean()) {\n                tailZone = DSTZone.readFrom(in, id);\n            }\n\n            return new PrecalculatedZone\n                (id, transitions, wallOffsets, standardOffsets, nameKeys, tailZone);\n        }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "Recurrence.readFrom",
    "class_name": "org.joda.time.tz.DateTimeZoneBuilder$Recurrence",
    "signature": "org.joda.time.tz.DateTimeZoneBuilder$Recurrence.readFrom(DataInput)",
    "snippet": "        static Recurrence readFrom(DataInput in) throws IOException {\n            return new Recurrence(OfYear.readFrom(in), in.readUTF(), (int)readMillis(in));\n        }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "DefaultNameProvider.DefaultNameProvider",
    "class_name": "org.joda.time.tz.DefaultNameProvider",
    "signature": "org.joda.time.tz.DefaultNameProvider.DefaultNameProvider()",
    "snippet": "    public DefaultNameProvider() {\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "DefaultNameProvider.createCache",
    "class_name": "org.joda.time.tz.DefaultNameProvider",
    "signature": "org.joda.time.tz.DefaultNameProvider.createCache()",
    "snippet": "    private HashMap createCache() {\n        return new HashMap(7);\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "FixedDateTimeZone.FixedDateTimeZone",
    "class_name": "org.joda.time.tz.FixedDateTimeZone",
    "signature": "org.joda.time.tz.FixedDateTimeZone.FixedDateTimeZone(String,String,int,int)",
    "snippet": "    public FixedDateTimeZone(String id, String nameKey,\n                             int wallOffset, int standardOffset) {\n        super(id);\n        iNameKey = nameKey;\n        iWallOffset = wallOffset;\n        iStandardOffset = standardOffset;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "FixedDateTimeZone.equals",
    "class_name": "org.joda.time.tz.FixedDateTimeZone",
    "signature": "org.joda.time.tz.FixedDateTimeZone.equals(Object)",
    "snippet": "    public boolean equals(Object obj) {\n        if (this == obj) {\n            return true;\n        }\n        if (obj instanceof FixedDateTimeZone) {\n            FixedDateTimeZone other = (FixedDateTimeZone) obj;\n            return\n                getID().equals(other.getID()) &&\n                iStandardOffset == other.iStandardOffset &&\n                iWallOffset == other.iWallOffset;\n        }\n        return false;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "FixedDateTimeZone.hashCode",
    "class_name": "org.joda.time.tz.FixedDateTimeZone",
    "signature": "org.joda.time.tz.FixedDateTimeZone.hashCode()",
    "snippet": "    public int hashCode() {\n        return getID().hashCode() + 37 * iStandardOffset + 31 * iWallOffset;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "ZoneInfoProvider.ZoneInfoProvider",
    "class_name": "org.joda.time.tz.ZoneInfoProvider",
    "signature": "org.joda.time.tz.ZoneInfoProvider.ZoneInfoProvider(String)",
    "snippet": "    public ZoneInfoProvider(String resourcePath) throws IOException {\n        this(resourcePath, null, false);\n    }",
    "comment": " ZoneInfoProvider searches the given ClassLoader resource path for compiled data files. Resources are loaded from the ClassLoader that loaded this class.  @throws IOException if directory or map file cannot be read ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "ZoneInfoProvider.getAvailableIDs",
    "class_name": "org.joda.time.tz.ZoneInfoProvider",
    "signature": "org.joda.time.tz.ZoneInfoProvider.getAvailableIDs()",
    "snippet": "    public Set<String> getAvailableIDs() {\n        // Return a copy of the keys rather than an umodifiable collection.\n        // This prevents ConcurrentModificationExceptions from being thrown by\n        // some JVMs if zones are opened while this set is iterated over.\n        return new TreeSet<String>(iZoneInfoMap.keySet());\n    }",
    "comment": " Gets a list of all the available zone ids.  @return the zone ids ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "ZoneInfoProvider.getZone",
    "class_name": "org.joda.time.tz.ZoneInfoProvider",
    "signature": "org.joda.time.tz.ZoneInfoProvider.getZone(String)",
    "snippet": "    public DateTimeZone getZone(String id) {\n        if (id == null) {\n            return null;\n        }\n\n        Object obj = iZoneInfoMap.get(id);\n        if (obj == null) {\n            return null;\n        }\n\n        if (id.equals(obj)) {\n            // Load zone data for the first time.\n            return loadZoneData(id);\n        }\n\n        if (obj instanceof SoftReference<?>) {\n            @SuppressWarnings(\"unchecked\")\n            SoftReference<DateTimeZone> ref = (SoftReference<DateTimeZone>) obj;\n            DateTimeZone tz = ref.get();\n            if (tz != null) {\n                return tz;\n            }\n            // Reference cleared; load data again.\n            return loadZoneData(id);\n        }\n\n        // If this point is reached, mapping must link to another.\n        return getZone((String)obj);\n    }",
    "comment": " If an error is thrown while loading zone data, uncaughtException is called to log the error and null is returned for this and all future requests.  @param id  the id to load @return the loaded zone ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "ZoneInfoProvider.loadZoneData",
    "class_name": "org.joda.time.tz.ZoneInfoProvider",
    "signature": "org.joda.time.tz.ZoneInfoProvider.loadZoneData(String)",
    "snippet": "    private DateTimeZone loadZoneData(String id) {\n        InputStream in = null;\n        try {\n            in = openResource(id);\n            DateTimeZone tz = DateTimeZoneBuilder.readFrom(in, id);\n            iZoneInfoMap.put(id, new SoftReference<DateTimeZone>(tz));\n            return tz;\n        } catch (IOException ex) {\n            uncaughtException(ex);\n            iZoneInfoMap.remove(id);\n            return null;\n        } finally {\n            try {\n                if (in != null) {\n                    in.close();\n                }\n            } catch (IOException ex) {\n            }\n        }\n    }",
    "comment": " Loads the time zone data for one id.  @param id  the id to load @return the zone ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "ZoneInfoProvider.loadZoneInfoMap",
    "class_name": "org.joda.time.tz.ZoneInfoProvider",
    "signature": "org.joda.time.tz.ZoneInfoProvider.loadZoneInfoMap(InputStream)",
    "snippet": "    private static Map<String, Object> loadZoneInfoMap(InputStream in) throws IOException {\n        Map<String, Object> map = new ConcurrentHashMap<String, Object>();\n        DataInputStream din = new DataInputStream(in);\n        try {\n            readZoneInfoMap(din, map);\n        } finally {\n            try {\n                din.close();\n            } catch (IOException ex) {\n            }\n        }\n        map.put(\"UTC\", new SoftReference<DateTimeZone>(DateTimeZone.UTC));\n        return map;\n    }",
    "comment": " Loads the zone info map.  @param in  the input stream @return the map ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "ZoneInfoProvider.openResource",
    "class_name": "org.joda.time.tz.ZoneInfoProvider",
    "signature": "org.joda.time.tz.ZoneInfoProvider.openResource(String)",
    "snippet": "    private InputStream openResource(String name) throws IOException {\n        InputStream in;\n        if (iFileDir != null) {\n            in = new FileInputStream(new File(iFileDir, name));\n        } else {\n            String path = iResourcePath.concat(name);\n            if (iLoader != null) {\n                in = iLoader.getResourceAsStream(path);\n            } else {\n                in = ClassLoader.getSystemResourceAsStream(path);\n            }\n            if (in == null) {\n                StringBuilder buf = new StringBuilder(40)\n                    .append(\"Resource not found: \\\"\")\n                    .append(path)\n                    .append(\"\\\" ClassLoader: \")\n                    .append(iLoader != null ? iLoader.toString() : \"system\");\n                throw new IOException(buf.toString());\n            }\n        }\n        return in;\n    }",
    "comment": " Opens a resource from file or classpath.  @param name  the name to open @return the input stream @throws IOException if an error occurs ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "ZoneInfoProvider.readZoneInfoMap",
    "class_name": "org.joda.time.tz.ZoneInfoProvider",
    "signature": "org.joda.time.tz.ZoneInfoProvider.readZoneInfoMap(DataInputStream,Map)",
    "snippet": "    private static void readZoneInfoMap(DataInputStream din, Map<String, Object> zimap) throws IOException {\n        // Read the string pool.\n        int size = din.readUnsignedShort();\n        String[] pool = new String[size];\n        for (int i=0; i<size; i++) {\n            pool[i] = din.readUTF().intern();\n        }\n\n        // Read the mappings.\n        size = din.readUnsignedShort();\n        for (int i=0; i<size; i++) {\n            try {\n                zimap.put(pool[din.readUnsignedShort()], pool[din.readUnsignedShort()]);\n            } catch (ArrayIndexOutOfBoundsException ex) {\n                throw new IOException(\"Corrupt zone info map\");\n            }\n        }\n    }",
    "comment": " Reads the zone info map from file.  @param din  the input stream @param zimap  gets filled with string id to string id mappings ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  }
]