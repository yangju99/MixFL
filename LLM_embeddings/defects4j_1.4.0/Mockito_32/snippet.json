[
  {
    "name": "Answers.get",
    "class_name": "org.mockito.Answers",
    "signature": "org.mockito.Answers.get()",
    "snippet": "    public Answer<Object> get() {\n        return implementation;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "Mockito.spy",
    "class_name": "org.mockito.Mockito",
    "signature": "org.mockito.Mockito.spy(T)",
    "snippet": "    public static <T> T spy(T object) {\n        return MOCKITO_CORE.mock((Class<T>) object.getClass(), withSettings()\n                .spiedInstance(object)\n                .defaultAnswer(CALLS_REAL_METHODS));\n    }",
    "comment": " Creates a spy of the real object. The spy calls <b>real</b> methods unless they are stubbed. <p> Real spies should be used <b>carefully and occasionally</b>, for example when dealing with legacy code. <p> As usual you are going to read <b>the partial mock warning</b>: Object oriented programming is more less tackling complexity by dividing the complexity into separate, specific, SRPy objects. How does partial mock fit into this paradigm? Well, it just doesn't...  Partial mock usually means that the complexity has been moved to a different method on the same object. In most cases, this is not the way you want to design your application. <p> However, there are rare cases when partial mocks come handy:  dealing with code you cannot change easily (3rd party interfaces, interim refactoring of legacy code etc.) However, I wouldn't use partial mocks for new, test-driven & well-designed code. <p> Example:  <pre> List list = new LinkedList(); List spy = spy(list);  optionally, you can stub out some methods: when(spy.size()).thenReturn(100);  using the spy calls <b>real</b> methods spy.add(\"one\"); spy.add(\"two\");  prints \"one\" - the first element of a list System.out.println(spy.get(0));  size() method was stubbed - 100 is printed System.out.println(spy.size());  optionally, you can verify verify(spy).add(\"one\"); verify(spy).add(\"two\"); </pre>  <h4>Important gotcha on spying real objects!</h4>  1. Sometimes it's impossible to use {@link Mockito#when(Object)} for stubbing spies. Example:  <pre> List list = new LinkedList(); List spy = spy(list);  Impossible: real method is called so spy.get(0) throws IndexOutOfBoundsException (the list is yet empty) when(spy.get(0)).thenReturn(\"foo\");  You have to use doReturn() for stubbing doReturn(\"foo\").when(spy).get(0); </pre>  2. Watch out for final methods.  Mockito doesn't mock final methods so the bottom line is: when you spy on real objects + you try to stub a final method = trouble. What will happen is the real method will be called *on mock* but *not on the real instance* you passed to the spy() method. Typically you may get a NullPointerException because mock instances don't have fields initiated.  <p> See examples in javadoc for {@link Mockito} class  @param object to spy on @return a spy of the real object ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "Mockito.times",
    "class_name": "org.mockito.Mockito",
    "signature": "org.mockito.Mockito.times(int)",
    "snippet": "    public static VerificationMode times(int wantedNumberOfInvocations) {\n        return VerificationModeFactory.times(wantedNumberOfInvocations);\n    }",
    "comment": " Allows verifying exact number of invocations. E.g: <pre> verify(mock, times(2)).someMethod(\"some arg\"); </pre>  See examples in javadoc for {@link Mockito} class  @param wantedNumberOfInvocations wanted number of invocations   @return verification mode ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "Mockito.verify",
    "class_name": "org.mockito.Mockito",
    "signature": "org.mockito.Mockito.verify(T)",
    "snippet": "    public static <T> T verify(T mock) {\n        return MOCKITO_CORE.verify(mock, times(1));\n    }",
    "comment": " Verifies certain behavior <b>happened once</b>  <p> Alias to <code>verify(mock, times(1))</code> E.g: <pre> verify(mock).someMethod(\"some arg\"); </pre> Above is equivalent to: <pre> verify(mock, times(1)).someMethod(\"some arg\"); </pre> <p> Arguments passed are compared using equals() method. Read about {@link ArgumentCaptor} or {@link ArgumentMatcher} to find out other ways of matching / asserting arguments passed. <p> Although it is possible to verify a stubbed invocation, usually <b>it's just redundant</b>. Let's say you've stubbed foo.bar().  If your code cares what foo.bar() returns then something else breaks(often before even verify() gets executed). If your code doesn't care what get(0) returns then it should not be stubbed.  Not convinced? See <a href=\"http://monkeyisland.pl/2008/04/26/asking-and-telling\">here</a>.  <p> See examples in javadoc for {@link Mockito} class  @param mock to be verified @return mock object itself ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "Mockito.withSettings",
    "class_name": "org.mockito.Mockito",
    "signature": "org.mockito.Mockito.withSettings()",
    "snippet": "    public static MockSettings withSettings() {\n        return new MockSettingsImpl().defaultAnswer(RETURNS_DEFAULTS);\n    }",
    "comment": " Allows mock creation with additional mock settings.  <p> Don't use it too often.  Consider writing simple tests that use simple mocks.  Repeat after me: simple tests push simple, KISSy, readable & maintainable code. If you cannot write a test in a simple way - refactor the code under test. <p> Examples of mock settings: <pre> Creates mock with different default answer & name Foo mock = mock(Foo.class, withSettings() .defaultAnswer(RETURNS_SMART_NULLS) .name(\"cool mockie\"));  Creates mock with different default answer, descriptive name and extra interfaces Foo mock = mock(Foo.class, withSettings() .defaultAnswer(RETURNS_SMART_NULLS) .name(\"cool mockie\") .extraInterfaces(Bar.class));     </pre> {@link MockSettings} has been introduced for two reasons.  Firstly, to make it easy to add another mock settings when the demand comes. Secondly, to enable combining different mock settings without introducing zillions of overloaded mock() methods. <p> See javadoc for {@link MockSettings} to learn about possible mock settings. <p>  @return mock settings instance with defaults. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "MockitoAnnotations.initMocks",
    "class_name": "org.mockito.MockitoAnnotations",
    "signature": "org.mockito.MockitoAnnotations.initMocks(Object)",
    "snippet": "    public static void initMocks(Object testClass) {\n        if (testClass == null) {\n            throw new MockitoException(\"testClass cannot be null. For info how to use @Mock annotations see examples in javadoc for MockitoAnnotations class\");\n        }\n        \n        Class<?> clazz = testClass.getClass();\n        while (clazz != Object.class) {\n            scan(testClass, clazz);\n            clazz = clazz.getSuperclass();\n        }\n    }",
    "comment": " Initializes objects annotated with Mockito annotations for given testClass: &#064;{@link org.mockito.Mock}, &#064;{@link Spy}, &#064;{@link Captor}, &#064;{@link InjectMocks}  <p> See examples in javadoc for {@link MockitoAnnotations} class. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "MockitoAnnotations.processAnnotationDeprecatedWay",
    "class_name": "org.mockito.MockitoAnnotations",
    "signature": "org.mockito.MockitoAnnotations.processAnnotationDeprecatedWay(AnnotationEngine,Object,Field)",
    "snippet": "    @SuppressWarnings(\"deprecation\")\n    static void processAnnotationDeprecatedWay(AnnotationEngine annotationEngine, Object testClass, Field field) {\n        boolean alreadyAssigned = false;\n        for(Annotation annotation : field.getAnnotations()) {\n            Object mock = annotationEngine.createMockFor(annotation, field);\n            if (mock != null) {\n                throwIfAlreadyAssigned(field, alreadyAssigned);\n                alreadyAssigned = true;                \n                try {\n                    new FieldSetter(testClass, field).set(mock);\n                } catch (Exception e) {\n                    throw new MockitoException(\"Problems setting field \" + field.getName() + \" annotated with \"\n                            + annotation, e);\n                }\n            }\n        }\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "MockitoAnnotations.scan",
    "class_name": "org.mockito.MockitoAnnotations",
    "signature": "org.mockito.MockitoAnnotations.scan(Object,Class)",
    "snippet": "    static void scan(Object testClass, Class<?> clazz) {\n        AnnotationEngine annotationEngine = new GlobalConfiguration().getAnnotationEngine();\n        Field[] fields = clazz.getDeclaredFields();\n        for (Field field : fields) {\n            //below can be removed later, when we get rid of deprecated stuff\n            if (annotationEngine.getClass() != new DefaultMockitoConfiguration().getAnnotationEngine().getClass()) {\n                //this means user has his own annotation engine and we have to respect that.\n                //we will do annotation processing the old way so that we are backwards compatible\n                processAnnotationDeprecatedWay(annotationEngine, testClass, field);                \n            } \n        }\n        //act 'the new' way\n        annotationEngine.process(clazz, testClass);\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "DefaultMockitoConfiguration.getAnnotationEngine",
    "class_name": "org.mockito.configuration.DefaultMockitoConfiguration",
    "signature": "org.mockito.configuration.DefaultMockitoConfiguration.getAnnotationEngine()",
    "snippet": "    public AnnotationEngine getAnnotationEngine() {\n        return new InjectingAnnotationEngine();\n    }",
    "comment": "(non-Javadoc) @see org.mockito.IMockitoConfiguration#getAnnotationEngine() ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "Reporter.argumentsAreDifferent",
    "class_name": "org.mockito.exceptions.Reporter",
    "signature": "org.mockito.exceptions.Reporter.argumentsAreDifferent(String,String,Location)",
    "snippet": "    public void argumentsAreDifferent(String wanted, String actual, Location actualLocation) {\n        String message = join(\"Argument(s) are different! Wanted:\", \n                wanted,\n                new Location(),\n                \"Actual invocation has different arguments:\",\n                actual,\n                actualLocation,\n                \"\"\n                );\n        \n        if (JUnitTool.hasJUnit()) {\n            throw JUnitTool.createArgumentsAreDifferentException(message, wanted, actual);\n        } else {\n            throw new ArgumentsAreDifferent(message);\n        }\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "ArgumentsAreDifferent.ArgumentsAreDifferent",
    "class_name": "org.mockito.exceptions.verification.junit.ArgumentsAreDifferent",
    "signature": "org.mockito.exceptions.verification.junit.ArgumentsAreDifferent.ArgumentsAreDifferent(String,String,String)",
    "snippet": "    public ArgumentsAreDifferent(String message, String wanted, String actual) {\n        super(message, wanted, actual);\n        this.message = message;\n        \n        unfilteredStackTrace = getStackTrace();\n        ConditionalStackTraceFilter filter = new ConditionalStackTraceFilter();\n        filter.filter(this);\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "ArgumentsAreDifferent.getMessage",
    "class_name": "org.mockito.exceptions.verification.junit.ArgumentsAreDifferent",
    "signature": "org.mockito.exceptions.verification.junit.ArgumentsAreDifferent.getMessage()",
    "snippet": "    @Override\n    public String getMessage() {\n        return message;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "JUnitTool.createArgumentsAreDifferentException",
    "class_name": "org.mockito.exceptions.verification.junit.JUnitTool",
    "signature": "org.mockito.exceptions.verification.junit.JUnitTool.createArgumentsAreDifferentException(String,String,String)",
    "snippet": "    public static AssertionError createArgumentsAreDifferentException(String message, String wanted, String actual)  {\n        try {\n            Class<?> clazz = Class.forName(\"org.mockito.exceptions.verification.junit.ArgumentsAreDifferent\");\n            AssertionError throwable = (AssertionError) clazz.getConstructors()[0].newInstance(message, wanted, actual);\n            return throwable;\n        } catch (Throwable t) {\n//            throw the default exception in case of problems\n            return new ArgumentsAreDifferent(message);\n        }\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "JUnitTool.hasJUnit",
    "class_name": "org.mockito.exceptions.verification.junit.JUnitTool",
    "signature": "org.mockito.exceptions.verification.junit.JUnitTool.hasJUnit()",
    "snippet": "    public static boolean hasJUnit() {\n        return hasJUnit;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "MockHandler.MockHandler",
    "class_name": "org.mockito.internal.MockHandler",
    "signature": "org.mockito.internal.MockHandler.MockHandler(MockSettingsImpl)",
    "snippet": "    public MockHandler(MockSettingsImpl mockSettings) {\n        this.mockSettings = mockSettings;\n        this.mockingProgress = new ThreadSafeMockingProgress();\n        this.matchersBinder = new MatchersBinder();\n        this.invocationContainerImpl = new InvocationContainerImpl(mockingProgress);\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "MockHandler.getMockSettings",
    "class_name": "org.mockito.internal.MockHandler",
    "signature": "org.mockito.internal.MockHandler.getMockSettings()",
    "snippet": "    public MockSettingsImpl getMockSettings() {\n        return mockSettings;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "MockHandler.handle",
    "class_name": "org.mockito.internal.MockHandler",
    "signature": "org.mockito.internal.MockHandler.handle(Invocation)",
    "snippet": "    public Object handle(Invocation invocation) throws Throwable {\n        if (invocationContainerImpl.hasAnswersForStubbing()) {\n            // stubbing voids with stubVoid() or doAnswer() style\n            InvocationMatcher invocationMatcher = matchersBinder.bindMatchers(mockingProgress\n                            .getArgumentMatcherStorage(), invocation);\n            invocationContainerImpl.setMethodForStubbing(invocationMatcher);\n            return null;\n        }\n        VerificationMode verificationMode = mockingProgress.pullVerificationMode();\n\n        InvocationMatcher invocationMatcher = matchersBinder.bindMatchers(mockingProgress.getArgumentMatcherStorage(),\n                        invocation);\n\n        mockingProgress.validateState();\n\n        //if verificationMode is not null then someone is doing verify()        \n        if (verificationMode != null) {\n            //We need to check if verification was started on the correct mock \n            // - see VerifyingWithAnExtraCallToADifferentMockTest (bug 138)\n            //TODO: can I avoid this cast here?\n            if (((MockAwareVerificationMode) verificationMode).getMock() == invocation.getMock()) {                \n                VerificationDataImpl data = new VerificationDataImpl(invocationContainerImpl, invocationMatcher);            \n                verificationMode.verify(data);\n                return null;\n            } else {\n                // this means there is an invocation on a different mock. Re-adding verification mode \n                // - see VerifyingWithAnExtraCallToADifferentMockTest (bug 138)\n                mockingProgress.verificationStarted(verificationMode);\n            }\n        }\n        \n        invocationContainerImpl.setInvocationForPotentialStubbing(invocationMatcher);\n        OngoingStubbingImpl<T> ongoingStubbing = new OngoingStubbingImpl<T>(invocationContainerImpl);\n        mockingProgress.reportOngoingStubbing(ongoingStubbing);\n\n        StubbedInvocationMatcher stubbedInvocation = invocationContainerImpl.findAnswerFor(invocation);\n\n        if (stubbedInvocation != null) {\n            stubbedInvocation.captureArgumentsFrom(invocation);\n            return stubbedInvocation.answer(invocation);\n        } else {\n            Object ret = mockSettings.getDefaultAnswer().answer(invocation);\n\n            // redo setting invocation for potential stubbing in case of partial\n            // mocks / spies.\n            // Without it, the real method inside 'when' might have delegated\n            // to other self method and overwrite the intended stubbed method\n            // with a different one. The reset is required to avoid runtime exception that validates return type with stubbed method signature.\n            invocationContainerImpl.resetInvocationForPotentialStubbing(invocationMatcher);\n            return ret;\n        }\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "MockitoCore.mock",
    "class_name": "org.mockito.internal.MockitoCore",
    "signature": "org.mockito.internal.MockitoCore.mock(Class,MockSettings)",
    "snippet": "    public <T> T mock(Class<T> classToMock, MockSettings mockSettings) {\n        T mock = mockUtil.createMock(classToMock, (MockSettingsImpl) mockSettings);\n        mockingProgress.mockingStarted(mock, classToMock, mockSettings);\n        return mock;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "MockitoCore.verify",
    "class_name": "org.mockito.internal.MockitoCore",
    "signature": "org.mockito.internal.MockitoCore.verify(T,VerificationMode)",
    "snippet": "    public <T> T verify(T mock, VerificationMode mode) {\n        if (mock == null) {\n            reporter.nullPassedToVerify();\n        } else if (!mockUtil.isMock(mock)) {\n            reporter.notAMockPassedToVerify();\n        }\n        mockingProgress.verificationStarted(new MockAwareVerificationMode(mock, mode));\n        return mock;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "ClassPathLoader.loadConfiguration",
    "class_name": "org.mockito.internal.configuration.ClassPathLoader",
    "signature": "org.mockito.internal.configuration.ClassPathLoader.loadConfiguration()",
    "snippet": "    @SuppressWarnings({\"unchecked\"})\n    public IMockitoConfiguration loadConfiguration() {\n        //Trying to get config from classpath\n        Class configClass = null;\n        try {\n            configClass = (Class) Class.forName(\"org.mockito.configuration.MockitoConfiguration\");\n        } catch (ClassNotFoundException e) {\n            //that's ok, it means there is no global config, using default one. \n            return null;\n        }\n        \n        try {\n            return (IMockitoConfiguration) configClass.newInstance();\n        } catch (ClassCastException e) {\n            throw new MockitoConfigurationException(\"\\n\" +\n                    \"MockitoConfiguration class must implement org.mockito.configuration.IMockitoConfiguration interface.\", e);\n        } catch (Exception e) {\n            throw new MockitoConfigurationException(\"\\n\" +\n                    \"Unable to instantianate org.mockito.configuration.MockitoConfiguration class. Does it have a safe, no-arg constructor?\", e);\n        }\n    }",
    "comment": " @return configuration loaded from classpath or null ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "DefaultAnnotationEngine.createMockFor",
    "class_name": "org.mockito.internal.configuration.DefaultAnnotationEngine",
    "signature": "org.mockito.internal.configuration.DefaultAnnotationEngine.createMockFor(Annotation,Field)",
    "snippet": "    @SuppressWarnings(\"deprecation\")\n    public Object createMockFor(Annotation annotation, Field field) {\n        if (annotation instanceof Mock) {\n            return processAnnotationOn((Mock) annotation, field);\n        }\n        if (annotation instanceof MockitoAnnotations.Mock) {\n            return processAnnotationOn((MockitoAnnotations.Mock) annotation, field);\n        }\n        if (annotation instanceof Captor) {\n            return processAnnotationOn((Captor) annotation, field);\n        }        \n\n        return null;\n    }",
    "comment": "(non-Javadoc) @see org.mockito.AnnotationEngine#createMockFor(java.lang.annotation.Annotation, java.lang.reflect.Field) ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "DefaultAnnotationEngine.process",
    "class_name": "org.mockito.internal.configuration.DefaultAnnotationEngine",
    "signature": "org.mockito.internal.configuration.DefaultAnnotationEngine.process(Class,Object)",
    "snippet": "    public void process(Class<?> clazz, Object testClass) {\n        Field[] fields = clazz.getDeclaredFields();\n        for (Field field : fields) {\n            boolean alreadyAssigned = false;\n            for(Annotation annotation : field.getAnnotations()) {           \n                Object mock = createMockFor(annotation, field);\n                if (mock != null) {\n                    throwIfAlreadyAssigned(field, alreadyAssigned);                    \n                    alreadyAssigned = true;                    \n                    try {\n                        new FieldSetter(testClass, field).set(mock);\n                    } catch (Exception e) {\n                        throw new MockitoException(\"Problems setting field \" + field.getName() + \" annotated with \"\n                                + annotation, e);\n                    }\n                }        \n            }\n        }\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "GlobalConfiguration.GlobalConfiguration",
    "class_name": "org.mockito.internal.configuration.GlobalConfiguration",
    "signature": "org.mockito.internal.configuration.GlobalConfiguration.GlobalConfiguration()",
    "snippet": "    public GlobalConfiguration() {\n        //Configuration should be loaded only once but I cannot really test it\n        if (globalConfiguration.get() == null) {\n            globalConfiguration.set(createConfig());\n        }\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "GlobalConfiguration.cleansStackTrace",
    "class_name": "org.mockito.internal.configuration.GlobalConfiguration",
    "signature": "org.mockito.internal.configuration.GlobalConfiguration.cleansStackTrace()",
    "snippet": "    public boolean cleansStackTrace() {\n        return globalConfiguration.get().cleansStackTrace();\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "GlobalConfiguration.createConfig",
    "class_name": "org.mockito.internal.configuration.GlobalConfiguration",
    "signature": "org.mockito.internal.configuration.GlobalConfiguration.createConfig()",
    "snippet": "    private IMockitoConfiguration createConfig() {\n        IMockitoConfiguration defaultConfiguration = new DefaultMockitoConfiguration();\n        IMockitoConfiguration config = new ClassPathLoader().loadConfiguration();\n        if (config != null) {\n            return config;\n        } else {\n            return defaultConfiguration;\n        }\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "GlobalConfiguration.getAnnotationEngine",
    "class_name": "org.mockito.internal.configuration.GlobalConfiguration",
    "signature": "org.mockito.internal.configuration.GlobalConfiguration.getAnnotationEngine()",
    "snippet": "    public AnnotationEngine getAnnotationEngine() {\n        return globalConfiguration.get().getAnnotationEngine();\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "GlobalConfiguration.getIt",
    "class_name": "org.mockito.internal.configuration.GlobalConfiguration",
    "signature": "org.mockito.internal.configuration.GlobalConfiguration.getIt()",
    "snippet": "    IMockitoConfiguration getIt() {\n        return globalConfiguration.get();\n    }",
    "comment": "back door for testing",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "GlobalConfiguration.validate",
    "class_name": "org.mockito.internal.configuration.GlobalConfiguration",
    "signature": "org.mockito.internal.configuration.GlobalConfiguration.validate()",
    "snippet": "    public static void validate() {\n        new GlobalConfiguration();\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "InjectingAnnotationEngine.createMockFor",
    "class_name": "org.mockito.internal.configuration.InjectingAnnotationEngine",
    "signature": "org.mockito.internal.configuration.InjectingAnnotationEngine.createMockFor(Annotation,Field)",
    "snippet": "    public Object createMockFor(Annotation annotation, Field field) {\n        return delegate.createMockFor(annotation, field);\n    }",
    "comment": "(non-Javadoc) @see org.mockito.AnnotationEngine#createMockFor(java.lang.annotation.Annotation, java.lang.reflect.Field) ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "InjectingAnnotationEngine.process",
    "class_name": "org.mockito.internal.configuration.InjectingAnnotationEngine",
    "signature": "org.mockito.internal.configuration.InjectingAnnotationEngine.process(Class,Object)",
    "snippet": "    public void process(Class<?> context, Object testClass) {\n        //this will create @Mocks, @Captors, etc:\n        delegate.process(context, testClass);\n        //this will create @Spies:\n        spyAnnotationEngine.process(context, testClass);\n        \n        //this injects mocks\n        Field[] fields = context.getDeclaredFields();\n        for (Field field : fields) {\n            if (field.isAnnotationPresent(InjectMocks.class)) {\n                assertNoAnnotations(field, Mock.class, org.mockito.MockitoAnnotations.Mock.class, Captor.class);\n                injectMocks(testClass);\n            }\n        }\n    } ",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "SpyAnnotationEngine.assertNoAnnotations",
    "class_name": "org.mockito.internal.configuration.SpyAnnotationEngine",
    "signature": "org.mockito.internal.configuration.SpyAnnotationEngine.assertNoAnnotations(Class,Field,Class[])",
    "snippet": "    void assertNoAnnotations(Class annotation, Field field, Class ... undesiredAnnotations) {\n        for (Class u : undesiredAnnotations) {\n            if (field.isAnnotationPresent(u)) {\n                new Reporter().unsupportedCombinationOfAnnotations(annotation.getSimpleName(), annotation.getClass().getSimpleName());\n            }\n        }        \n    }    ",
    "comment": "TODO duplicated elsewhere",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "SpyAnnotationEngine.process",
    "class_name": "org.mockito.internal.configuration.SpyAnnotationEngine",
    "signature": "org.mockito.internal.configuration.SpyAnnotationEngine.process(Class,Object)",
    "snippet": "    @SuppressWarnings(\"deprecation\")\n    public void process(Class<?> context, Object testClass) {\n        Field[] fields = context.getDeclaredFields();\n        for (Field field : fields) {\n            if (field.isAnnotationPresent(Spy.class)) {\n                assertNoAnnotations(Spy.class, field, Mock.class, org.mockito.MockitoAnnotations.Mock.class, Captor.class);\n                boolean wasAccessible = field.isAccessible();\n                field.setAccessible(true);\n                try {\n                    Object instance = field.get(testClass);\n                    if (instance == null) {\n                        throw new MockitoException(\"Cannot create a @Spy for '\" + field.getName() + \"' field because the *instance* is missing\\n\" +\n                        \t\t  \"The instance must be created *before* initMocks();\\n\" +\n                                  \"Example of correct usage of @Spy:\\n\" +\n                            \t  \"   @Spy List mock = new LinkedList();\\n\" +\n                            \t  \"   //also, don't forget about MockitoAnnotations.initMocks();\");\n\n                    }\n                    if (new MockUtil().isMock(instance)) { \n                        // instance has been spied earlier\n                        Mockito.reset(instance);\n                    } else {\n                        field.set(testClass, Mockito.spy(instance));\n                    }\n                } catch (IllegalAccessException e) {\n                    throw new MockitoException(\"Problems initiating spied field \" + field.getName(), e);\n                } finally {\n                    field.setAccessible(wasAccessible);\n                }\n            }\n        }\n    }",
    "comment": "",
    "is_bug": true,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "AbstractMockitoMethodProxy.invokeSuper",
    "class_name": "org.mockito.internal.creation.AbstractMockitoMethodProxy",
    "signature": "org.mockito.internal.creation.AbstractMockitoMethodProxy.invokeSuper(Object,Object[])",
    "snippet": "    public Object invokeSuper(Object target, Object[] arguments) throws Throwable {\n        return getMethodProxy().invokeSuper(target, arguments);\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "DelegatingMethod.DelegatingMethod",
    "class_name": "org.mockito.internal.creation.DelegatingMethod",
    "signature": "org.mockito.internal.creation.DelegatingMethod.DelegatingMethod(Method)",
    "snippet": "    public DelegatingMethod(Method method) {\n        assert method != null : \"Method cannot be null\";\n        this.method = method;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "DelegatingMethod.getJavaMethod",
    "class_name": "org.mockito.internal.creation.DelegatingMethod",
    "signature": "org.mockito.internal.creation.DelegatingMethod.getJavaMethod()",
    "snippet": "    public Method getJavaMethod() {\n        return method;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "DelegatingMethod.getName",
    "class_name": "org.mockito.internal.creation.DelegatingMethod",
    "signature": "org.mockito.internal.creation.DelegatingMethod.getName()",
    "snippet": "    public String getName() {\n        return method.getName();\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "DelegatingMethod.getReturnType",
    "class_name": "org.mockito.internal.creation.DelegatingMethod",
    "signature": "org.mockito.internal.creation.DelegatingMethod.getReturnType()",
    "snippet": "    public Class<?> getReturnType() {\n        return method.getReturnType();\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "DelegatingMethod.isVarArgs",
    "class_name": "org.mockito.internal.creation.DelegatingMethod",
    "signature": "org.mockito.internal.creation.DelegatingMethod.isVarArgs()",
    "snippet": "    public boolean isVarArgs() {\n        return method.isVarArgs();\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "DelegatingMockitoMethodProxy.DelegatingMockitoMethodProxy",
    "class_name": "org.mockito.internal.creation.DelegatingMockitoMethodProxy",
    "signature": "org.mockito.internal.creation.DelegatingMockitoMethodProxy.DelegatingMockitoMethodProxy(MethodProxy)",
    "snippet": "    public DelegatingMockitoMethodProxy(MethodProxy methodProxy) {\n        this.methodProxy = methodProxy;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "DelegatingMockitoMethodProxy.getMethodProxy",
    "class_name": "org.mockito.internal.creation.DelegatingMockitoMethodProxy",
    "signature": "org.mockito.internal.creation.DelegatingMockitoMethodProxy.getMethodProxy()",
    "snippet": "    public MethodProxy getMethodProxy() {\n        return methodProxy;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "MethodInterceptorFilter.MethodInterceptorFilter",
    "class_name": "org.mockito.internal.creation.MethodInterceptorFilter",
    "signature": "org.mockito.internal.creation.MethodInterceptorFilter.MethodInterceptorFilter(MockitoInvocationHandler,MockSettingsImpl)",
    "snippet": "    public MethodInterceptorFilter(MockitoInvocationHandler handler, MockSettingsImpl mockSettings) {\n        this.handler = handler;\n        this.mockSettings = mockSettings;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "MethodInterceptorFilter.createMockitoMethod",
    "class_name": "org.mockito.internal.creation.MethodInterceptorFilter",
    "signature": "org.mockito.internal.creation.MethodInterceptorFilter.createMockitoMethod(Method)",
    "snippet": "    public MockitoMethod createMockitoMethod(Method method) {\n        if (mockSettings.isSerializable()) {\n            return new SerializableMethod(method);\n        } else {\n            return new DelegatingMethod(method); \n        }\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "MethodInterceptorFilter.createMockitoMethodProxy",
    "class_name": "org.mockito.internal.creation.MethodInterceptorFilter",
    "signature": "org.mockito.internal.creation.MethodInterceptorFilter.createMockitoMethodProxy(MethodProxy)",
    "snippet": "    public MockitoMethodProxy createMockitoMethodProxy(MethodProxy methodProxy) {\n        if (mockSettings.isSerializable())\n            return new SerializableMockitoMethodProxy(methodProxy);\n        return new DelegatingMockitoMethodProxy(methodProxy);\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "MethodInterceptorFilter.getHandler",
    "class_name": "org.mockito.internal.creation.MethodInterceptorFilter",
    "signature": "org.mockito.internal.creation.MethodInterceptorFilter.getHandler()",
    "snippet": "    public MockitoInvocationHandler getHandler() {\n        return handler;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "MethodInterceptorFilter.intercept",
    "class_name": "org.mockito.internal.creation.MethodInterceptorFilter",
    "signature": "org.mockito.internal.creation.MethodInterceptorFilter.intercept(Object,Method,Object[],MethodProxy)",
    "snippet": "    public Object intercept(Object proxy, Method method, Object[] args, MethodProxy methodProxy)\n            throws Throwable {\n        if (objectMethodsGuru.isEqualsMethod(method)) {\n            return proxy == args[0];\n        } else if (objectMethodsGuru.isHashCodeMethod(method)) {\n            return hashCodeForMock(proxy);\n        }\n        \n        MockitoMethodProxy mockitoMethodProxy = createMockitoMethodProxy(methodProxy);\n        cglibHacker.setMockitoNamingPolicy(mockitoMethodProxy);\n        \n        MockitoMethod mockitoMethod = createMockitoMethod(method);\n        \n        FilteredCGLIBProxyRealMethod realMethod = new FilteredCGLIBProxyRealMethod(mockitoMethodProxy);\n        Invocation invocation = new Invocation(proxy, mockitoMethod, args, SequenceNumber.next(), realMethod);\n        return handler.handle(invocation);\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "MockSettingsImpl.defaultAnswer",
    "class_name": "org.mockito.internal.creation.MockSettingsImpl",
    "signature": "org.mockito.internal.creation.MockSettingsImpl.defaultAnswer(Answer)",
    "snippet": "    public MockSettings defaultAnswer(Answer defaultAnswer) {\n        this.defaultAnswer = defaultAnswer;\n        return this;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "MockSettingsImpl.getDefaultAnswer",
    "class_name": "org.mockito.internal.creation.MockSettingsImpl",
    "signature": "org.mockito.internal.creation.MockSettingsImpl.getDefaultAnswer()",
    "snippet": "    public Answer<Object> getDefaultAnswer() {\n        return defaultAnswer;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "MockSettingsImpl.getExtraInterfaces",
    "class_name": "org.mockito.internal.creation.MockSettingsImpl",
    "signature": "org.mockito.internal.creation.MockSettingsImpl.getExtraInterfaces()",
    "snippet": "    public Class<?>[] getExtraInterfaces() {\n        return extraInterfaces;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "MockSettingsImpl.getMockName",
    "class_name": "org.mockito.internal.creation.MockSettingsImpl",
    "signature": "org.mockito.internal.creation.MockSettingsImpl.getMockName()",
    "snippet": "    public MockName getMockName() {\n        return mockName;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "MockSettingsImpl.getSpiedInstance",
    "class_name": "org.mockito.internal.creation.MockSettingsImpl",
    "signature": "org.mockito.internal.creation.MockSettingsImpl.getSpiedInstance()",
    "snippet": "    public Object getSpiedInstance() {\n        return spiedInstance;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "MockSettingsImpl.initiateMockName",
    "class_name": "org.mockito.internal.creation.MockSettingsImpl",
    "signature": "org.mockito.internal.creation.MockSettingsImpl.initiateMockName(Class)",
    "snippet": "    public void initiateMockName(Class classToMock) {\n        mockName = new MockName(name, classToMock);\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "MockSettingsImpl.isSerializable",
    "class_name": "org.mockito.internal.creation.MockSettingsImpl",
    "signature": "org.mockito.internal.creation.MockSettingsImpl.isSerializable()",
    "snippet": "    public boolean isSerializable() {\n        return serializable;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "MockSettingsImpl.spiedInstance",
    "class_name": "org.mockito.internal.creation.MockSettingsImpl",
    "signature": "org.mockito.internal.creation.MockSettingsImpl.spiedInstance(Object)",
    "snippet": "    public MockSettings spiedInstance(Object spiedInstance) {\n        this.spiedInstance = spiedInstance;\n        return this;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "CGLIBHacker.reflectOnCreateInfo",
    "class_name": "org.mockito.internal.creation.cglib.CGLIBHacker",
    "signature": "org.mockito.internal.creation.cglib.CGLIBHacker.reflectOnCreateInfo(MethodProxy)",
    "snippet": "    @SuppressWarnings(\"unchecked\")\n    private Field reflectOnCreateInfo(MethodProxy methodProxy) throws SecurityException, NoSuchFieldException {\n\n        Class cglibMethodProxyClass = methodProxy.getClass();\n        // in case methodProxy was extended by user, let's traverse the object\n        // graph to find the cglib methodProxy\n        // with all the fields we would like to change\n        while (cglibMethodProxyClass != MethodProxy.class) {\n            cglibMethodProxyClass = methodProxy.getClass().getSuperclass();\n        }\n        return cglibMethodProxyClass.getDeclaredField(\"createInfo\");\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "CGLIBHacker.setMockitoNamingPolicy",
    "class_name": "org.mockito.internal.creation.cglib.CGLIBHacker",
    "signature": "org.mockito.internal.creation.cglib.CGLIBHacker.setMockitoNamingPolicy(MockitoMethodProxy)",
    "snippet": "    public void setMockitoNamingPolicy(MockitoMethodProxy mockitoMethodProxy) {\n        try {\n            MethodProxy methodProxy = mockitoMethodProxy.getMethodProxy();\n            Field createInfoField = reflectOnCreateInfo(methodProxy);\n            createInfoField.setAccessible(true);\n            Object createInfo = createInfoField.get(methodProxy);\n            Field namingPolicyField = createInfo.getClass().getDeclaredField(\"namingPolicy\");\n            namingPolicyField.setAccessible(true);\n            if (namingPolicyField.get(createInfo) == null) {\n                namingPolicyField.set(createInfo, MockitoNamingPolicy.INSTANCE);\n            }\n        } catch (Exception e) {\n            throw new RuntimeException(\n                            \"Unable to set MockitoNamingPolicy on cglib generator which creates FastClasses\", e);\n        }\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "MockitoNamingPolicy.getTag",
    "class_name": "org.mockito.internal.creation.cglib.MockitoNamingPolicy",
    "signature": "org.mockito.internal.creation.cglib.MockitoNamingPolicy.getTag()",
    "snippet": "    @Override\n    protected String getTag() {\n        return \"ByMockitoWithCGLIB\";\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "ClassImposterizer.canImposterise",
    "class_name": "org.mockito.internal.creation.jmock.ClassImposterizer",
    "signature": "org.mockito.internal.creation.jmock.ClassImposterizer.canImposterise(Class)",
    "snippet": "    public boolean canImposterise(Class<?> type) {\n        return !type.isPrimitive() && !Modifier.isFinal(type.getModifiers());\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "ClassImposterizer.createProxy",
    "class_name": "org.mockito.internal.creation.jmock.ClassImposterizer",
    "signature": "org.mockito.internal.creation.jmock.ClassImposterizer.createProxy(Class,MethodInterceptor)",
    "snippet": "    private Object createProxy(Class<?> proxyClass, final MethodInterceptor interceptor) {\n        Factory proxy = (Factory) objenesis.newInstance(proxyClass);\n        proxy.setCallbacks(new Callback[] {interceptor, SerializableNoOp.SERIALIZABLE_INSTANCE });\n        return proxy;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "ClassImposterizer.setConstructorsAccessible",
    "class_name": "org.mockito.internal.creation.jmock.ClassImposterizer",
    "signature": "org.mockito.internal.creation.jmock.ClassImposterizer.setConstructorsAccessible(Class,boolean)",
    "snippet": "    private void setConstructorsAccessible(Class<?> mockedType, boolean accessible) {\n        for (Constructor<?> constructor : mockedType.getDeclaredConstructors()) {\n            constructor.setAccessible(accessible);\n        }\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "SearchingClassLoader.addIfNewElement",
    "class_name": "org.mockito.internal.creation.jmock.SearchingClassLoader",
    "signature": "org.mockito.internal.creation.jmock.SearchingClassLoader.addIfNewElement(List,ClassLoader)",
    "snippet": "    private static void addIfNewElement(List<ClassLoader> loaders, ClassLoader c) {\n        if (c != null && !loaders.contains(c)) {\n            loaders.add(c);\n        }\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "SearchingClassLoader.combine",
    "class_name": "org.mockito.internal.creation.jmock.SearchingClassLoader",
    "signature": "org.mockito.internal.creation.jmock.SearchingClassLoader.combine(List)",
    "snippet": "    private static ClassLoader combine(List<ClassLoader> parentLoaders) {\n        ClassLoader loader = parentLoaders.get(parentLoaders.size()-1);\n        \n        for (int i = parentLoaders.size()-2; i >= 0; i--) {\n            loader = new SearchingClassLoader(parentLoaders.get(i), loader);\n        }\n        \n        return loader;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "Localized.Localized",
    "class_name": "org.mockito.internal.debugging.Localized",
    "signature": "org.mockito.internal.debugging.Localized.Localized(T)",
    "snippet": "    public Localized(T object) {\n        this.object = object;\n        location = new Location();\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "Localized.getObject",
    "class_name": "org.mockito.internal.debugging.Localized",
    "signature": "org.mockito.internal.debugging.Localized.getObject()",
    "snippet": "    public T getObject() {\n        return object;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "Location.Location",
    "class_name": "org.mockito.internal.debugging.Location",
    "signature": "org.mockito.internal.debugging.Location.Location()",
    "snippet": "    public Location() {\n        this(new StackTraceFilter());\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "Location.Location",
    "class_name": "org.mockito.internal.debugging.Location",
    "signature": "org.mockito.internal.debugging.Location.Location(StackTraceFilter)",
    "snippet": "    public Location(StackTraceFilter filter) {\n        StackTraceElement[] stackTrace = Thread.currentThread().getStackTrace();\n        StackTraceElement[] filtered = filter.filter(stackTrace, false);\n        if (filtered.length == 0) {\n            where = \"-> at <<unknown line>>\";\n        } else {\n            where = \"-> at \" + filtered[0].toString();\n        }\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "Location.toString",
    "class_name": "org.mockito.internal.debugging.Location",
    "signature": "org.mockito.internal.debugging.Location.toString()",
    "snippet": "    @Override\n    public String toString() {\n        return where;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "ConditionalStackTraceFilter.filter",
    "class_name": "org.mockito.internal.exceptions.base.ConditionalStackTraceFilter",
    "signature": "org.mockito.internal.exceptions.base.ConditionalStackTraceFilter.filter(Throwable)",
    "snippet": "    public void filter(Throwable throwable) {\n        if (!config.cleansStackTrace()) {\n            return;\n        }\n        StackTraceElement[] filtered = filter.filter(throwable.getStackTrace(), true);\n        throwable.setStackTrace(filtered);\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "StackTraceFilter.filter",
    "class_name": "org.mockito.internal.exceptions.base.StackTraceFilter",
    "signature": "org.mockito.internal.exceptions.base.StackTraceFilter.filter(StackTraceElement[],boolean)",
    "snippet": "    public StackTraceElement[] filter(StackTraceElement[] target, boolean keepTop) {\n        //TODO: after 1.8 profile\n        List<StackTraceElement> unfilteredStackTrace = Arrays.asList(target);\n        \n        int lastBad = -1;\n        int firstBad = -1;\n        for (int i = 0; i < unfilteredStackTrace.size(); i++) {\n            if (!this.isBad(unfilteredStackTrace.get(i))) {\n                continue;\n            }\n            lastBad = i;\n            if (firstBad == -1) {\n                firstBad = i;\n            }\n        }\n        \n        List<StackTraceElement> top;\n        if (keepTop && firstBad != -1) {\n            top = unfilteredStackTrace.subList(0, firstBad);\n        } else {\n            top = new LinkedList<StackTraceElement>();\n        }\n        \n        List<StackTraceElement> bottom = unfilteredStackTrace.subList(lastBad + 1, unfilteredStackTrace.size());\n        List<StackTraceElement> filtered = new ArrayList<StackTraceElement>(top);\n        filtered.addAll(bottom);\n        return filtered.toArray(new StackTraceElement[]{});\n    }",
    "comment": " Example how the filter works (+/- means good/bad): [a+, b+, c-, d+, e+, f-, g+] -> [a+, b+, g+] Basically removes all bad from the middle. If any good are in the middle of bad those are also removed.  ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "StackTraceFilter.isBad",
    "class_name": "org.mockito.internal.exceptions.base.StackTraceFilter",
    "signature": "org.mockito.internal.exceptions.base.StackTraceFilter.isBad(StackTraceElement)",
    "snippet": "    public boolean isBad(StackTraceElement e) {\n        boolean fromMockObject = e.getClassName().contains(\"$$EnhancerByMockitoWithCGLIB$$\");\n        boolean fromOrgMockito = e.getClassName().startsWith(\"org.mockito.\");\n        boolean isRunner = e.getClassName().startsWith(\"org.mockito.runners.\");\n        boolean isInternalRunner = e.getClassName().startsWith(\"org.mockito.internal.runners.\");\n        return (fromMockObject || fromOrgMockito) && !isRunner && !isInternalRunner;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "ArgumentsComparator.argumentsMatch",
    "class_name": "org.mockito.internal.invocation.ArgumentsComparator",
    "signature": "org.mockito.internal.invocation.ArgumentsComparator.argumentsMatch(InvocationMatcher,Invocation)",
    "snippet": "    public boolean argumentsMatch(InvocationMatcher invocationMatcher, Invocation actual) {\n        Object[] actualArgs = actual.getArguments();\n        return argumentsMatch(invocationMatcher, actualArgs) || varArgsMatch(invocationMatcher, actual);\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "ArgumentsComparator.argumentsMatch",
    "class_name": "org.mockito.internal.invocation.ArgumentsComparator",
    "signature": "org.mockito.internal.invocation.ArgumentsComparator.argumentsMatch(InvocationMatcher,Object[])",
    "snippet": "    public boolean argumentsMatch(InvocationMatcher invocationMatcher, Object[] actualArgs) {\n        if (actualArgs.length != invocationMatcher.getMatchers().size()) {\n            return false;\n        }\n        for (int i = 0; i < actualArgs.length; i++) {\n            if (!invocationMatcher.getMatchers().get(i).matches(actualArgs[i])) {\n                return false;\n            }\n        }\n        return true;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "ArgumentsComparator.varArgsMatch",
    "class_name": "org.mockito.internal.invocation.ArgumentsComparator",
    "signature": "org.mockito.internal.invocation.ArgumentsComparator.varArgsMatch(InvocationMatcher,Invocation)",
    "snippet": "    private boolean varArgsMatch(InvocationMatcher invocationMatcher, Invocation actual) {\n        if (!actual.getMethod().isVarArgs()) {\n            //if the method is not vararg forget about it\n            return false;\n        }\n\n        //we must use raw arguments, not arguments...\n        Object[] rawArgs = actual.getRawArguments();\n        List<Matcher> matchers = invocationMatcher.getMatchers();\n\n        if (rawArgs.length != matchers.size()) {\n            return false;\n        }\n\n        for (int i = 0; i < rawArgs.length; i++) {\n            Matcher m = matchers.get(i);\n            //it's a vararg because it's the last array in the arg list\n            if (rawArgs[i] != null && rawArgs[i].getClass().isArray() && i == rawArgs.length-1) {\n                Matcher actualMatcher;\n                //this is necessary as the framework often decorates matchers\n                if (m instanceof MatcherDecorator) {\n                    actualMatcher = ((MatcherDecorator)m).getActualMatcher();\n                } else {\n                    actualMatcher = m;\n                }\n                //this is very important to only allow VarargMatchers here. If you're not sure why remove it and run all tests.\n                if (!(actualMatcher instanceof VarargMatcher) || !actualMatcher.matches(rawArgs[i])) {\n                    return false;\n                }\n            //it's not a vararg (i.e. some ordinary argument before varargs), just do the ordinary check\n            } else if (!m.matches(rawArgs[i])){\n                return false;\n            }\n        }\n\n        return true;\n    }",
    "comment": "ok, this method is a little bit messy but the vararg business unfortunately is messy...      ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "Invocation.Invocation",
    "class_name": "org.mockito.internal.invocation.Invocation",
    "signature": "org.mockito.internal.invocation.Invocation.Invocation(Object,MockitoMethod,Object[],int,RealMethod)",
    "snippet": "    public Invocation(Object mock, MockitoMethod mockitoMethod, Object[] args, int sequenceNumber, RealMethod realMethod) {\n        this.method = mockitoMethod;\n        this.mock = mock;\n        this.realMethod = realMethod;\n        this.arguments = expandVarArgs(mockitoMethod.isVarArgs(), args);\n        this.rawArguments = args;\n        this.sequenceNumber = sequenceNumber;\n        this.location = new Location();\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "Invocation.argumentsToMatchers",
    "class_name": "org.mockito.internal.invocation.Invocation",
    "signature": "org.mockito.internal.invocation.Invocation.argumentsToMatchers()",
    "snippet": "    protected List<Matcher> argumentsToMatchers() {\n        List<Matcher> matchers = new ArrayList<Matcher>(arguments.length);\n        for (Object arg : arguments) {\n            if (arg != null && arg.getClass().isArray()) {\n                matchers.add(new ArrayEquals(arg));\n            } else {\n                matchers.add(new Equals(arg));\n            }\n        }\n        return matchers;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "Invocation.callRealMethod",
    "class_name": "org.mockito.internal.invocation.Invocation",
    "signature": "org.mockito.internal.invocation.Invocation.callRealMethod()",
    "snippet": "    public Object callRealMethod() throws Throwable {\n        if (isDeclaredOnInterface()) {\n            new Reporter().cannotCallRealMethodOnInterface();\n        }\n        return realMethod.invoke(mock, rawArguments);\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "Invocation.expandVarArgs",
    "class_name": "org.mockito.internal.invocation.Invocation",
    "signature": "org.mockito.internal.invocation.Invocation.expandVarArgs(boolean,Object[])",
    "snippet": "    private static Object[] expandVarArgs(final boolean isVarArgs, final Object[] args) {\n        if (!isVarArgs || args[args.length - 1] != null && !args[args.length - 1].getClass().isArray()) {\n            return args == null ? new Object[0] : args;\n        }\n\n        final int nonVarArgsCount = args.length - 1;\n        Object[] varArgs;\n        if (args[nonVarArgsCount] == null) {\n            // in case someone deliberately passed null varArg array\n            varArgs = new Object[] { null };\n        } else {\n            varArgs = ArrayEquals.createObjectArray(args[nonVarArgsCount]);\n        }\n        final int varArgsCount = varArgs.length;\n        Object[] newArgs = new Object[nonVarArgsCount + varArgsCount];\n        System.arraycopy(args, 0, newArgs, 0, nonVarArgsCount);\n        System.arraycopy(varArgs, 0, newArgs, nonVarArgsCount, varArgsCount);\n        return newArgs;\n    }",
    "comment": "varArgs (1, a, b);",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "Invocation.getArguments",
    "class_name": "org.mockito.internal.invocation.Invocation",
    "signature": "org.mockito.internal.invocation.Invocation.getArguments()",
    "snippet": "    public Object[] getArguments() {\n        return arguments;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "Invocation.getLocation",
    "class_name": "org.mockito.internal.invocation.Invocation",
    "signature": "org.mockito.internal.invocation.Invocation.getLocation()",
    "snippet": "    public Location getLocation() {\n        return location;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "Invocation.getMethod",
    "class_name": "org.mockito.internal.invocation.Invocation",
    "signature": "org.mockito.internal.invocation.Invocation.getMethod()",
    "snippet": "    public Method getMethod() {\n        return method.getJavaMethod();\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "Invocation.getMock",
    "class_name": "org.mockito.internal.invocation.Invocation",
    "signature": "org.mockito.internal.invocation.Invocation.getMock()",
    "snippet": "    public Object getMock() {\n        return mock;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "Invocation.isDeclaredOnInterface",
    "class_name": "org.mockito.internal.invocation.Invocation",
    "signature": "org.mockito.internal.invocation.Invocation.isDeclaredOnInterface()",
    "snippet": "    public boolean isDeclaredOnInterface() {\n        return this.getMethod().getDeclaringClass().isInterface();\n    }      ",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "Invocation.isToString",
    "class_name": "org.mockito.internal.invocation.Invocation",
    "signature": "org.mockito.internal.invocation.Invocation.isToString(InvocationOnMock)",
    "snippet": "    public static boolean isToString(InvocationOnMock invocation) {\n        return new ObjectMethodsGuru().isToString(invocation.getMethod());\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "Invocation.isVerified",
    "class_name": "org.mockito.internal.invocation.Invocation",
    "signature": "org.mockito.internal.invocation.Invocation.isVerified()",
    "snippet": "    public boolean isVerified() {\n        return verified;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "Invocation.qualifiedMethodName",
    "class_name": "org.mockito.internal.invocation.Invocation",
    "signature": "org.mockito.internal.invocation.Invocation.qualifiedMethodName()",
    "snippet": "    private String qualifiedMethodName() {\n        return new MockUtil().getMockName(mock) + \".\" + method.getName();\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "Invocation.toString",
    "class_name": "org.mockito.internal.invocation.Invocation",
    "signature": "org.mockito.internal.invocation.Invocation.toString()",
    "snippet": "    public String toString() {\n        return toString(argumentsToMatchers(), new PrintSettings());\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "Invocation.toString",
    "class_name": "org.mockito.internal.invocation.Invocation",
    "signature": "org.mockito.internal.invocation.Invocation.toString(List,PrintSettings)",
    "snippet": "    protected String toString(List<Matcher> matchers, PrintSettings printSettings) {\n        MatchersPrinter matchersPrinter = new MatchersPrinter();\n        String method = qualifiedMethodName();\n        String invocation = method + matchersPrinter.getArgumentsLine(matchers, printSettings);\n        if (printSettings.isMultiline() || (!matchers.isEmpty() && invocation.length() > MAX_LINE_LENGTH)) {\n            return method + matchersPrinter.getArgumentsBlock(matchers, printSettings);\n        } else {\n            return invocation;\n        }\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "Invocation.toString",
    "class_name": "org.mockito.internal.invocation.Invocation",
    "signature": "org.mockito.internal.invocation.Invocation.toString(PrintSettings)",
    "snippet": "    public String toString(PrintSettings printSettings) {\n        return toString(argumentsToMatchers(), printSettings);\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "InvocationMatcher.InvocationMatcher",
    "class_name": "org.mockito.internal.invocation.InvocationMatcher",
    "signature": "org.mockito.internal.invocation.InvocationMatcher.InvocationMatcher(Invocation,List)",
    "snippet": "    public InvocationMatcher(Invocation invocation, List<Matcher> matchers) {\n        this.invocation = invocation;\n        if (matchers.isEmpty()) {\n            this.matchers = invocation.argumentsToMatchers();\n        } else {\n            this.matchers = matchers;\n        }\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "InvocationMatcher.getInvocation",
    "class_name": "org.mockito.internal.invocation.InvocationMatcher",
    "signature": "org.mockito.internal.invocation.InvocationMatcher.getInvocation()",
    "snippet": "    public Invocation getInvocation() {\n        return this.invocation;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "InvocationMatcher.getMatchers",
    "class_name": "org.mockito.internal.invocation.InvocationMatcher",
    "signature": "org.mockito.internal.invocation.InvocationMatcher.getMatchers()",
    "snippet": "    public List<Matcher> getMatchers() {\n        return this.matchers;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "InvocationMatcher.getMethod",
    "class_name": "org.mockito.internal.invocation.InvocationMatcher",
    "signature": "org.mockito.internal.invocation.InvocationMatcher.getMethod()",
    "snippet": "    public Method getMethod() {\n        return invocation.getMethod();\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "InvocationMatcher.hasSameMethod",
    "class_name": "org.mockito.internal.invocation.InvocationMatcher",
    "signature": "org.mockito.internal.invocation.InvocationMatcher.hasSameMethod(Invocation)",
    "snippet": "    public boolean hasSameMethod(Invocation candidate) {        \n        //not using method.equals() for 1 good reason:\n        //sometimes java generates forwarding methods when generics are in play see JavaGenericsForwardingMethodsTest\n        Method m1 = invocation.getMethod();\n        Method m2 = candidate.getMethod();\n        \n        if (m1.getName() != null && m1.getName().equals(m2.getName())) {\n        \t/* Avoid unnecessary cloning */\n        \tClass[] params1 = m1.getParameterTypes();\n        \tClass[] params2 = m2.getParameterTypes();\n        \tif (params1.length == params2.length) {\n        \t    for (int i = 0; i < params1.length; i++) {\n        \t\tif (params1[i] != params2[i])\n        \t\t    return false;\n        \t    }\n        \t    return true;\n        \t}\n        }\n        return false;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "InvocationMatcher.hasSimilarMethod",
    "class_name": "org.mockito.internal.invocation.InvocationMatcher",
    "signature": "org.mockito.internal.invocation.InvocationMatcher.hasSimilarMethod(Invocation)",
    "snippet": "    public boolean hasSimilarMethod(Invocation candidate) {\n        String wantedMethodName = getMethod().getName();\n        String currentMethodName = candidate.getMethod().getName();\n        \n        final boolean methodNameEquals = wantedMethodName.equals(currentMethodName);\n        final boolean isUnverified = !candidate.isVerified();\n        final boolean mockIsTheSame = getInvocation().getMock() == candidate.getMock();\n        final boolean methodEquals = hasSameMethod(candidate);\n\n        if (!methodNameEquals || !isUnverified || !mockIsTheSame) {\n            return false;\n        }\n\n        final boolean overloadedButSameArgs = !methodEquals && safelyArgumentsMatch(candidate.getArguments());\n\n        return !overloadedButSameArgs;\n    }",
    "comment": " similar means the same method name, same mock, unverified  and: if arguments are the same cannot be overloaded ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "InvocationMatcher.matches",
    "class_name": "org.mockito.internal.invocation.InvocationMatcher",
    "signature": "org.mockito.internal.invocation.InvocationMatcher.matches(Invocation)",
    "snippet": "    public boolean matches(Invocation actual) {\n        return invocation.getMock().equals(actual.getMock())\n                && hasSameMethod(actual)\n                && new ArgumentsComparator().argumentsMatch(this, actual);\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "InvocationMatcher.toString",
    "class_name": "org.mockito.internal.invocation.InvocationMatcher",
    "signature": "org.mockito.internal.invocation.InvocationMatcher.toString()",
    "snippet": "    public String toString() {\n        return invocation.toString(matchers, new PrintSettings());\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "InvocationMatcher.toString",
    "class_name": "org.mockito.internal.invocation.InvocationMatcher",
    "signature": "org.mockito.internal.invocation.InvocationMatcher.toString(PrintSettings)",
    "snippet": "    public String toString(PrintSettings printSettings) {\n        return invocation.toString(matchers, printSettings);\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "InvocationsFinder.findInvocations",
    "class_name": "org.mockito.internal.invocation.InvocationsFinder",
    "signature": "org.mockito.internal.invocation.InvocationsFinder.findInvocations(List,InvocationMatcher)",
    "snippet": "    public List<Invocation> findInvocations(List<Invocation> invocations, InvocationMatcher wanted) {\n        return ListUtil.filter(invocations, new RemoveNotMatching(wanted));\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "InvocationsFinder.findSimilarInvocation",
    "class_name": "org.mockito.internal.invocation.InvocationsFinder",
    "signature": "org.mockito.internal.invocation.InvocationsFinder.findSimilarInvocation(List,InvocationMatcher)",
    "snippet": "    public Invocation findSimilarInvocation(List<Invocation> invocations, InvocationMatcher wanted) {\n        Invocation firstSimilar = null;\n        for (Invocation invocation : invocations) {\n            if (!wanted.hasSimilarMethod(invocation)) {\n                continue;\n            }\n            if (firstSimilar == null) {\n                firstSimilar = invocation;\n            }\n            if (wanted.hasSameMethod(invocation)) {\n                return invocation;\n            }\n        }\n        \n        return firstSimilar;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "RemoveNotMatching.isOut",
    "class_name": "org.mockito.internal.invocation.InvocationsFinder$RemoveNotMatching",
    "signature": "org.mockito.internal.invocation.InvocationsFinder$RemoveNotMatching.isOut(Invocation)",
    "snippet": "        public boolean isOut(Invocation invocation) {\n            return !wanted.matches(invocation);\n        }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "MatchersBinder.bindMatchers",
    "class_name": "org.mockito.internal.invocation.MatchersBinder",
    "signature": "org.mockito.internal.invocation.MatchersBinder.bindMatchers(ArgumentMatcherStorage,Invocation)",
    "snippet": "    public InvocationMatcher bindMatchers(ArgumentMatcherStorage argumentMatcherStorage, Invocation invocation) {\n        List<Matcher> lastMatchers = argumentMatcherStorage.pullMatchers();\n        validateMatchers(invocation, lastMatchers);\n\n        InvocationMatcher invocationWithMatchers = new InvocationMatcher(invocation, lastMatchers);\n        return invocationWithMatchers;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "MatchersBinder.validateMatchers",
    "class_name": "org.mockito.internal.invocation.MatchersBinder",
    "signature": "org.mockito.internal.invocation.MatchersBinder.validateMatchers(Invocation,List)",
    "snippet": "    private void validateMatchers(Invocation invocation, List<Matcher> matchers) {\n        if (!matchers.isEmpty()) {\n            int recordedMatchersSize = matchers.size();\n            int expectedMatchersSize = invocation.getArgumentsCount();\n            if (expectedMatchersSize != recordedMatchersSize) {\n                new Reporter().invalidUseOfMatchers(expectedMatchersSize, recordedMatchersSize);\n            }\n        }\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "CGLIBProxyRealMethod.CGLIBProxyRealMethod",
    "class_name": "org.mockito.internal.invocation.realmethod.CGLIBProxyRealMethod",
    "signature": "org.mockito.internal.invocation.realmethod.CGLIBProxyRealMethod.CGLIBProxyRealMethod(MockitoMethodProxy)",
    "snippet": "    public CGLIBProxyRealMethod(MockitoMethodProxy methodProxy) {\n        this.methodProxy = methodProxy;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "CGLIBProxyRealMethod.invoke",
    "class_name": "org.mockito.internal.invocation.realmethod.CGLIBProxyRealMethod",
    "signature": "org.mockito.internal.invocation.realmethod.CGLIBProxyRealMethod.invoke(Object,Object[])",
    "snippet": "    public Object invoke(Object target, Object[] arguments) throws Throwable {\n        return methodProxy.invokeSuper(target, arguments);\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "FilteredCGLIBProxyRealMethod.FilteredCGLIBProxyRealMethod",
    "class_name": "org.mockito.internal.invocation.realmethod.FilteredCGLIBProxyRealMethod",
    "signature": "org.mockito.internal.invocation.realmethod.FilteredCGLIBProxyRealMethod.FilteredCGLIBProxyRealMethod(MockitoMethodProxy)",
    "snippet": "    public FilteredCGLIBProxyRealMethod(MockitoMethodProxy methodProxy) {\n        this(new CGLIBProxyRealMethod(methodProxy));\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "FilteredCGLIBProxyRealMethod.FilteredCGLIBProxyRealMethod",
    "class_name": "org.mockito.internal.invocation.realmethod.FilteredCGLIBProxyRealMethod",
    "signature": "org.mockito.internal.invocation.realmethod.FilteredCGLIBProxyRealMethod.FilteredCGLIBProxyRealMethod(RealMethod)",
    "snippet": "    public FilteredCGLIBProxyRealMethod(RealMethod realMethod) {\n        this.realMethod = realMethod;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "FilteredCGLIBProxyRealMethod.invoke",
    "class_name": "org.mockito.internal.invocation.realmethod.FilteredCGLIBProxyRealMethod",
    "signature": "org.mockito.internal.invocation.realmethod.FilteredCGLIBProxyRealMethod.invoke(Object,Object[])",
    "snippet": "    public Object invoke(Object target, Object[] arguments) throws Throwable {\n        try {\n            return realMethod.invoke(target, arguments);\n        } catch (Throwable t) {\n            new ConditionalStackTraceFilter().filter(t);\n            throw t;\n        }\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "Equality.areEqual",
    "class_name": "org.mockito.internal.matchers.Equality",
    "signature": "org.mockito.internal.matchers.Equality.areEqual(Object,Object)",
    "snippet": "    public static boolean areEqual(Object o1, Object o2) {\n        if (o1 == null || o2 == null) {\n            return o1 == null && o2 == null;\n        } else if (isArray(o1)) {\n            return isArray(o2) && areArraysEqual(o1, o2);\n        } else {\n            return o1.equals(o2);\n        }\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "Equality.isArray",
    "class_name": "org.mockito.internal.matchers.Equality",
    "signature": "org.mockito.internal.matchers.Equality.isArray(Object)",
    "snippet": "    static boolean isArray(Object o) {\n        return o.getClass().isArray();\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "Equals.Equals",
    "class_name": "org.mockito.internal.matchers.Equals",
    "signature": "org.mockito.internal.matchers.Equals.Equals(Object)",
    "snippet": "    public Equals(Object wanted) {\n        this.wanted = wanted;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "Equals.describe",
    "class_name": "org.mockito.internal.matchers.Equals",
    "signature": "org.mockito.internal.matchers.Equals.describe(Object)",
    "snippet": "    public String describe(Object object) {\n        String text = quoting();\n        if (object == null) {\n            text+=\"null\";\n        } else {\n            text+=object.toString();\n        }\n        text+= quoting();\n        return text;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "Equals.describeTo",
    "class_name": "org.mockito.internal.matchers.Equals",
    "signature": "org.mockito.internal.matchers.Equals.describeTo(Description)",
    "snippet": "    public void describeTo(Description description) {\n        description.appendText(describe(wanted));\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "Equals.matches",
    "class_name": "org.mockito.internal.matchers.Equals",
    "signature": "org.mockito.internal.matchers.Equals.matches(Object)",
    "snippet": "    public boolean matches(Object actual) {\n        return Equality.areEqual(this.wanted, actual);\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "Equals.quoting",
    "class_name": "org.mockito.internal.matchers.Equals",
    "signature": "org.mockito.internal.matchers.Equals.quoting()",
    "snippet": "    private String quoting() {\n        if (wanted instanceof String) {\n            return \"\\\"\";\n        } else if (wanted instanceof Character) {\n            return \"'\";\n        } else {\n            return \"\";\n        }\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "MatchersPrinter.applyPrintSettings",
    "class_name": "org.mockito.internal.matchers.MatchersPrinter",
    "signature": "org.mockito.internal.matchers.MatchersPrinter.applyPrintSettings(List,PrintSettings)",
    "snippet": "    private List<SelfDescribing> applyPrintSettings(List<Matcher> matchers, PrintSettings printSettings) {\n        List<SelfDescribing> withPrintSettings = new LinkedList<SelfDescribing>();\n        int i = 0;\n        for (final Matcher matcher : matchers) {\n            if (matcher instanceof ContainsExtraTypeInformation && printSettings.extraTypeInfoFor(i)) {\n                withPrintSettings.add(((ContainsExtraTypeInformation) matcher).withExtraTypeInfo());\n            } else {\n                withPrintSettings.add(matcher);\n            }\n            i++;\n        }\n        return withPrintSettings;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "MatchersPrinter.getArgumentsLine",
    "class_name": "org.mockito.internal.matchers.MatchersPrinter",
    "signature": "org.mockito.internal.matchers.MatchersPrinter.getArgumentsLine(List,PrintSettings)",
    "snippet": "    public String getArgumentsLine(List<Matcher> matchers, PrintSettings printSettings) {\n        Description result = new StringDescription();\n        result.appendList(\"(\", \", \", \");\", applyPrintSettings(matchers, printSettings));\n        return result.toString();\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "ArgumentMatcherStorageImpl.pullMatchers",
    "class_name": "org.mockito.internal.progress.ArgumentMatcherStorageImpl",
    "signature": "org.mockito.internal.progress.ArgumentMatcherStorageImpl.pullMatchers()",
    "snippet": "    public List<Matcher> pullMatchers() {\n        if (matcherStack.isEmpty()) {\n            return Collections.emptyList();\n        }\n        \n        List<LocalizedMatcher> matchers = new ArrayList<LocalizedMatcher>(matcherStack);\n        matcherStack.clear();\n        return (List) matchers;\n    }",
    "comment": "(non-Javadoc) @see org.mockito.internal.progress.ArgumentMatcherStorage#pullMatchers() ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "ArgumentMatcherStorageImpl.validateState",
    "class_name": "org.mockito.internal.progress.ArgumentMatcherStorageImpl",
    "signature": "org.mockito.internal.progress.ArgumentMatcherStorageImpl.validateState()",
    "snippet": "    public void validateState() {\n        if (!matcherStack.isEmpty()) {\n            LocalizedMatcher lastMatcher = matcherStack.lastElement();\n            matcherStack.clear();\n            new Reporter().misplacedArgumentMatcher(lastMatcher.getLocation());\n        }\n    }",
    "comment": "(non-Javadoc) @see org.mockito.internal.progress.ArgumentMatcherStorage#validateState() ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "MockingProgressImpl.getArgumentMatcherStorage",
    "class_name": "org.mockito.internal.progress.MockingProgressImpl",
    "signature": "org.mockito.internal.progress.MockingProgressImpl.getArgumentMatcherStorage()",
    "snippet": "    public ArgumentMatcherStorage getArgumentMatcherStorage() {\n        return argumentMatcherStorage;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "MockingProgressImpl.mockingStarted",
    "class_name": "org.mockito.internal.progress.MockingProgressImpl",
    "signature": "org.mockito.internal.progress.MockingProgressImpl.mockingStarted(Object,Class,MockSettings)",
    "snippet": "    public void mockingStarted(Object mock, Class classToMock, MockSettings mockSettings) {\n        if (listener != null && listener instanceof MockingStartedListener) {\n            ((MockingStartedListener) listener).mockingStarted(mock, classToMock, mockSettings);\n        }\n        validateState();\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "MockingProgressImpl.pullVerificationMode",
    "class_name": "org.mockito.internal.progress.MockingProgressImpl",
    "signature": "org.mockito.internal.progress.MockingProgressImpl.pullVerificationMode()",
    "snippet": "    public VerificationMode pullVerificationMode() {\n        if (verificationMode == null) {\n            return null;\n        }\n        \n        VerificationMode temp = verificationMode.getObject();\n        verificationMode = null;\n        return temp;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "MockingProgressImpl.reportOngoingStubbing",
    "class_name": "org.mockito.internal.progress.MockingProgressImpl",
    "signature": "org.mockito.internal.progress.MockingProgressImpl.reportOngoingStubbing(IOngoingStubbing)",
    "snippet": "    public void reportOngoingStubbing(IOngoingStubbing iOngoingStubbing) {\n        this.iOngoingStubbing = iOngoingStubbing;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "MockingProgressImpl.resetOngoingStubbing",
    "class_name": "org.mockito.internal.progress.MockingProgressImpl",
    "signature": "org.mockito.internal.progress.MockingProgressImpl.resetOngoingStubbing()",
    "snippet": "    public void resetOngoingStubbing() {\n        iOngoingStubbing = null;\n    }",
    "comment": "(non-Javadoc) @see org.mockito.internal.progress.MockingProgress#resetOngoingStubbing() ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "MockingProgressImpl.validateState",
    "class_name": "org.mockito.internal.progress.MockingProgressImpl",
    "signature": "org.mockito.internal.progress.MockingProgressImpl.validateState()",
    "snippet": "    public void validateState() {\n        //State is cool when GlobalConfiguration is already loaded\n        //this cannot really be tested functionally because I cannot dynamically mess up org.mockito.configuration.MockitoConfiguration class \n        GlobalConfiguration.validate();\n        \n        if (verificationMode != null) {\n            Location location = verificationMode.getLocation();\n            verificationMode = null;\n            reporter.unfinishedVerificationException(location);\n        }\n        \n        if (stubbingInProgress != null) {\n            Location temp = stubbingInProgress;\n            stubbingInProgress = null;\n            reporter.unfinishedStubbing(temp);\n        }\n      \n        getArgumentMatcherStorage().validateState();\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "MockingProgressImpl.verificationStarted",
    "class_name": "org.mockito.internal.progress.MockingProgressImpl",
    "signature": "org.mockito.internal.progress.MockingProgressImpl.verificationStarted(VerificationMode)",
    "snippet": "    public void verificationStarted(VerificationMode verify) {\n        validateState();\n        resetOngoingStubbing();\n        verificationMode = new Localized(verify);\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "SequenceNumber.next",
    "class_name": "org.mockito.internal.progress.SequenceNumber",
    "signature": "org.mockito.internal.progress.SequenceNumber.next()",
    "snippet": "    public static synchronized int next() {\n        return sequenceNumber++;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "ThreadSafeMockingProgress.getArgumentMatcherStorage",
    "class_name": "org.mockito.internal.progress.ThreadSafeMockingProgress",
    "signature": "org.mockito.internal.progress.ThreadSafeMockingProgress.getArgumentMatcherStorage()",
    "snippet": "    public ArgumentMatcherStorage getArgumentMatcherStorage() {\n        return threadSafely().getArgumentMatcherStorage();\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "ThreadSafeMockingProgress.mockingStarted",
    "class_name": "org.mockito.internal.progress.ThreadSafeMockingProgress",
    "signature": "org.mockito.internal.progress.ThreadSafeMockingProgress.mockingStarted(Object,Class,MockSettings)",
    "snippet": "    public void mockingStarted(Object mock, Class classToMock, MockSettings mockSettings) {\n        threadSafely().mockingStarted(mock, classToMock, mockSettings);\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "ThreadSafeMockingProgress.pullVerificationMode",
    "class_name": "org.mockito.internal.progress.ThreadSafeMockingProgress",
    "signature": "org.mockito.internal.progress.ThreadSafeMockingProgress.pullVerificationMode()",
    "snippet": "    public VerificationMode pullVerificationMode() {\n        return threadSafely().pullVerificationMode();\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "ThreadSafeMockingProgress.reportOngoingStubbing",
    "class_name": "org.mockito.internal.progress.ThreadSafeMockingProgress",
    "signature": "org.mockito.internal.progress.ThreadSafeMockingProgress.reportOngoingStubbing(IOngoingStubbing)",
    "snippet": "    public void reportOngoingStubbing(IOngoingStubbing iOngoingStubbing) {\n        threadSafely().reportOngoingStubbing(iOngoingStubbing);\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "ThreadSafeMockingProgress.threadSafely",
    "class_name": "org.mockito.internal.progress.ThreadSafeMockingProgress",
    "signature": "org.mockito.internal.progress.ThreadSafeMockingProgress.threadSafely()",
    "snippet": "    static MockingProgress threadSafely() {\n        if (mockingProgress.get() == null) {\n            mockingProgress.set(new MockingProgressImpl());\n        }\n        return mockingProgress.get();\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "ThreadSafeMockingProgress.validateState",
    "class_name": "org.mockito.internal.progress.ThreadSafeMockingProgress",
    "signature": "org.mockito.internal.progress.ThreadSafeMockingProgress.validateState()",
    "snippet": "    public void validateState() {\n        threadSafely().validateState();\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "ThreadSafeMockingProgress.verificationStarted",
    "class_name": "org.mockito.internal.progress.ThreadSafeMockingProgress",
    "signature": "org.mockito.internal.progress.ThreadSafeMockingProgress.verificationStarted(VerificationMode)",
    "snippet": "    public void verificationStarted(VerificationMode verify) {\n        threadSafely().verificationStarted(verify);\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "PrintSettings.extraTypeInfoFor",
    "class_name": "org.mockito.internal.reporting.PrintSettings",
    "signature": "org.mockito.internal.reporting.PrintSettings.extraTypeInfoFor(int)",
    "snippet": "    public boolean extraTypeInfoFor(int argumentIndex) {\n        return withTypeInfo.contains(argumentIndex);\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "PrintSettings.isMultiline",
    "class_name": "org.mockito.internal.reporting.PrintSettings",
    "signature": "org.mockito.internal.reporting.PrintSettings.isMultiline()",
    "snippet": "    public boolean isMultiline() {\n        return multiline;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "PrintSettings.setMatchersToBeDescribedWithExtraTypeInfo",
    "class_name": "org.mockito.internal.reporting.PrintSettings",
    "signature": "org.mockito.internal.reporting.PrintSettings.setMatchersToBeDescribedWithExtraTypeInfo(Integer[])",
    "snippet": "    public void setMatchersToBeDescribedWithExtraTypeInfo(Integer[] indexesOfMatchers) {\n        this.withTypeInfo = Arrays.asList(indexesOfMatchers);\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "PrintSettings.setMultiline",
    "class_name": "org.mockito.internal.reporting.PrintSettings",
    "signature": "org.mockito.internal.reporting.PrintSettings.setMultiline(boolean)",
    "snippet": "    public void setMultiline(boolean multiline) {\n        this.multiline = multiline;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "SmartPrinter.SmartPrinter",
    "class_name": "org.mockito.internal.reporting.SmartPrinter",
    "signature": "org.mockito.internal.reporting.SmartPrinter.SmartPrinter(PrintingFriendlyInvocation,PrintingFriendlyInvocation,Integer[])",
    "snippet": "    public SmartPrinter(PrintingFriendlyInvocation wanted, PrintingFriendlyInvocation actual, Integer ... indexesOfMatchersToBeDescribedWithExtraTypeInfo) {\n        PrintSettings printSettings = new PrintSettings();\n        printSettings.setMultiline(wanted.toString().contains(\"\\n\") || actual.toString().contains(\"\\n\"));\n        printSettings.setMatchersToBeDescribedWithExtraTypeInfo(indexesOfMatchersToBeDescribedWithExtraTypeInfo);\n        \n        this.wanted = wanted.toString(printSettings);\n        this.actual = actual.toString(printSettings);\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "SmartPrinter.getActual",
    "class_name": "org.mockito.internal.reporting.SmartPrinter",
    "signature": "org.mockito.internal.reporting.SmartPrinter.getActual()",
    "snippet": "    public String getActual() {\n        return actual;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "SmartPrinter.getWanted",
    "class_name": "org.mockito.internal.reporting.SmartPrinter",
    "signature": "org.mockito.internal.reporting.SmartPrinter.getWanted()",
    "snippet": "    public String getWanted() {\n        return wanted;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "InvocationContainerImpl.InvocationContainerImpl",
    "class_name": "org.mockito.internal.stubbing.InvocationContainerImpl",
    "signature": "org.mockito.internal.stubbing.InvocationContainerImpl.InvocationContainerImpl(MockingProgress)",
    "snippet": "    public InvocationContainerImpl(MockingProgress mockingProgress) {\n        this.mockingProgress = mockingProgress;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "InvocationContainerImpl.findAnswerFor",
    "class_name": "org.mockito.internal.stubbing.InvocationContainerImpl",
    "signature": "org.mockito.internal.stubbing.InvocationContainerImpl.findAnswerFor(Invocation)",
    "snippet": "    public StubbedInvocationMatcher findAnswerFor(Invocation invocation) {\n        synchronized (stubbed) {\n            for (StubbedInvocationMatcher s : stubbed) {\n                if (s.matches(invocation)) {\n                    s.markStubUsed(invocation);\n                    invocation.markStubbed(new StubInfo(s));\n                    return s;\n                }\n            }\n        }\n\n        return null;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "InvocationContainerImpl.getInvocations",
    "class_name": "org.mockito.internal.stubbing.InvocationContainerImpl",
    "signature": "org.mockito.internal.stubbing.InvocationContainerImpl.getInvocations()",
    "snippet": "    public List<Invocation> getInvocations() {\n        return registeredInvocations.getAll();\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "InvocationContainerImpl.hasAnswersForStubbing",
    "class_name": "org.mockito.internal.stubbing.InvocationContainerImpl",
    "signature": "org.mockito.internal.stubbing.InvocationContainerImpl.hasAnswersForStubbing()",
    "snippet": "    public boolean hasAnswersForStubbing() {\n        return !answersForStubbing.isEmpty();\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "InvocationContainerImpl.resetInvocationForPotentialStubbing",
    "class_name": "org.mockito.internal.stubbing.InvocationContainerImpl",
    "signature": "org.mockito.internal.stubbing.InvocationContainerImpl.resetInvocationForPotentialStubbing(InvocationMatcher)",
    "snippet": "    public void resetInvocationForPotentialStubbing(InvocationMatcher invocationMatcher) {\n        this.invocationForStubbing = invocationMatcher;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "InvocationContainerImpl.setInvocationForPotentialStubbing",
    "class_name": "org.mockito.internal.stubbing.InvocationContainerImpl",
    "signature": "org.mockito.internal.stubbing.InvocationContainerImpl.setInvocationForPotentialStubbing(InvocationMatcher)",
    "snippet": "    public void setInvocationForPotentialStubbing(InvocationMatcher invocation) {\n        registeredInvocations.add(invocation.getInvocation());\n        this.invocationForStubbing = invocation;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "OngoingStubbingImpl.OngoingStubbingImpl",
    "class_name": "org.mockito.internal.stubbing.OngoingStubbingImpl",
    "signature": "org.mockito.internal.stubbing.OngoingStubbingImpl.OngoingStubbingImpl(InvocationContainerImpl)",
    "snippet": "    public OngoingStubbingImpl(InvocationContainerImpl invocationContainerImpl) {\n        this.invocationContainerImpl = invocationContainerImpl;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "CallsRealMethods.answer",
    "class_name": "org.mockito.internal.stubbing.answers.CallsRealMethods",
    "signature": "org.mockito.internal.stubbing.answers.CallsRealMethods.answer(InvocationOnMock)",
    "snippet": "    public Object answer(InvocationOnMock invocation) throws Throwable {\n        return invocation.callRealMethod();\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "ListUtil.filter",
    "class_name": "org.mockito.internal.util.ListUtil",
    "signature": "org.mockito.internal.util.ListUtil.filter(Collection,Filter)",
    "snippet": "    public static <T> LinkedList<T> filter(Collection<T> collection, Filter<T> filter) {\n        LinkedList<T> filtered = new LinkedList<T>();\n        for (T t : collection) {\n            if (!filter.isOut(t)) {\n                filtered.add(t);\n            }\n        }\n        return filtered;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "MockCreationValidator.isTypeMockable",
    "class_name": "org.mockito.internal.util.MockCreationValidator",
    "signature": "org.mockito.internal.util.MockCreationValidator.isTypeMockable(Class)",
    "snippet": "    public boolean isTypeMockable(Class<?> clz) {\n        return ClassImposterizer.INSTANCE.canImposterise(clz);\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "MockCreationValidator.validateExtraInterfaces",
    "class_name": "org.mockito.internal.util.MockCreationValidator",
    "signature": "org.mockito.internal.util.MockCreationValidator.validateExtraInterfaces(Class,Class[])",
    "snippet": "    public void validateExtraInterfaces(Class classToMock, Class ... extraInterfaces) {\n        if (extraInterfaces == null) {\n            return;\n        }\n        \n        for (Class i : extraInterfaces) {\n            if (classToMock == i) {\n                new Reporter().extraInterfacesCannotContainMockedType(classToMock);\n            }\n        }\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "MockCreationValidator.validateMockedType",
    "class_name": "org.mockito.internal.util.MockCreationValidator",
    "signature": "org.mockito.internal.util.MockCreationValidator.validateMockedType(Class,Object)",
    "snippet": "    public void validateMockedType(Class classToMock, Object spiedInstance) {\n        if (classToMock == null || spiedInstance == null) {\n            return;\n        }\n        if (!classToMock.equals(spiedInstance.getClass())) {\n            new Reporter().mockedTypeIsInconsistentWithSpiedInstanceType(classToMock, spiedInstance);\n        }\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "MockCreationValidator.validateType",
    "class_name": "org.mockito.internal.util.MockCreationValidator",
    "signature": "org.mockito.internal.util.MockCreationValidator.validateType(Class)",
    "snippet": "    public void validateType(Class classToMock) {\n        if (!isTypeMockable(classToMock)) {\n            new Reporter().cannotMockFinalClass(classToMock);\n        }\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "MockName.MockName",
    "class_name": "org.mockito.internal.util.MockName",
    "signature": "org.mockito.internal.util.MockName.MockName(String,Class)",
    "snippet": "    @SuppressWarnings(\"unchecked\")\n    public MockName(String mockName, Class classToMock) {\n        if (mockName == null) {\n            this.mockName = toInstanceName(classToMock);\n            this.surrogate = true;\n        } else {\n            this.mockName = mockName;\n        }\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "MockName.toInstanceName",
    "class_name": "org.mockito.internal.util.MockName",
    "signature": "org.mockito.internal.util.MockName.toInstanceName(Class)",
    "snippet": "    private static String toInstanceName(Class<?> clazz) {\n        String className = clazz.getSimpleName();\n        if (className.length() == 0) {\n            //it's an anonymous class, let's get name from the parent\n            className = clazz.getSuperclass().getSimpleName();\n        }\n        //lower case first letter\n        return className.substring(0, 1).toLowerCase() + className.substring(1);\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "MockName.toString",
    "class_name": "org.mockito.internal.util.MockName",
    "signature": "org.mockito.internal.util.MockName.toString()",
    "snippet": "    @Override\n    public String toString() {\n        return mockName;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "MockUtil.MockUtil",
    "class_name": "org.mockito.internal.util.MockUtil",
    "signature": "org.mockito.internal.util.MockUtil.MockUtil()",
    "snippet": "    public MockUtil() {\n        this(new MockCreationValidator());\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "MockUtil.MockUtil",
    "class_name": "org.mockito.internal.util.MockUtil",
    "signature": "org.mockito.internal.util.MockUtil.MockUtil(MockCreationValidator)",
    "snippet": "    public MockUtil(MockCreationValidator creationValidator) {\n        this.creationValidator = creationValidator;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "MockUtil.createMock",
    "class_name": "org.mockito.internal.util.MockUtil",
    "signature": "org.mockito.internal.util.MockUtil.createMock(Class,MockSettingsImpl)",
    "snippet": "    public <T> T createMock(Class<T> classToMock, MockSettingsImpl settings) {\n        creationValidator.validateType(classToMock);\n        creationValidator.validateExtraInterfaces(classToMock, settings.getExtraInterfaces());\n        creationValidator.validateMockedType(classToMock, settings.getSpiedInstance());\n\n        settings.initiateMockName(classToMock);\n\n        MockHandler<T> mockHandler = new MockHandler<T>(settings);\n        MethodInterceptorFilter filter = new MethodInterceptorFilter(mockHandler, settings);\n        Class<?>[] interfaces = settings.getExtraInterfaces();\n\n        Class<?>[] ancillaryTypes;\n        if (settings.isSerializable()) {\n            ancillaryTypes = interfaces == null ? new Class<?>[] {Serializable.class} : new ArrayUtils().concat(interfaces, Serializable.class);\n        } else {\n            ancillaryTypes = interfaces == null ? new Class<?>[0] : interfaces;\n        }\n\n        Object spiedInstance = settings.getSpiedInstance();\n        \n        T mock = ClassImposterizer.INSTANCE.imposterise(filter, classToMock, ancillaryTypes);\n        \n        if (spiedInstance != null) {\n            new LenientCopyTool().copyToMock(spiedInstance, mock);\n        }\n        \n        return mock;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "MockUtil.getInterceptor",
    "class_name": "org.mockito.internal.util.MockUtil",
    "signature": "org.mockito.internal.util.MockUtil.getInterceptor(T)",
    "snippet": "    private <T> MethodInterceptorFilter getInterceptor(T mock) {\n        if (!(mock instanceof Factory)) {\n            return null;\n        }\n        Factory factory = (Factory) mock;\n        Callback callback = factory.getCallback(0);\n        if (callback instanceof MethodInterceptorFilter) {\n            return (MethodInterceptorFilter) callback;\n        }\n        return null;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "MockUtil.getMockHandler",
    "class_name": "org.mockito.internal.util.MockUtil",
    "signature": "org.mockito.internal.util.MockUtil.getMockHandler(T)",
    "snippet": "    public <T> MockHandlerInterface<T> getMockHandler(T mock) {\n        if (mock == null) {\n            throw new NotAMockException(\"Argument should be a mock, but is null!\");\n        }\n\n        if (isMockitoMock(mock)) {\n            return (MockHandlerInterface) getInterceptor(mock).getHandler();\n        } else {\n            throw new NotAMockException(\"Argument should be a mock, but is: \" + mock.getClass());\n        }\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "MockUtil.getMockName",
    "class_name": "org.mockito.internal.util.MockUtil",
    "signature": "org.mockito.internal.util.MockUtil.getMockName(Object)",
    "snippet": "    public MockName getMockName(Object mock) {\n        return getMockHandler(mock).getMockSettings().getMockName();\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "MockUtil.isMock",
    "class_name": "org.mockito.internal.util.MockUtil",
    "signature": "org.mockito.internal.util.MockUtil.isMock(Object)",
    "snippet": "    public boolean isMock(Object mock) {\n        return mock != null && isMockitoMock(mock);\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "MockUtil.isMockitoMock",
    "class_name": "org.mockito.internal.util.MockUtil",
    "signature": "org.mockito.internal.util.MockUtil.isMockitoMock(T)",
    "snippet": "    private <T> boolean isMockitoMock(T mock) {\n        return getInterceptor(mock) != null;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "ObjectMethodsGuru.isEqualsMethod",
    "class_name": "org.mockito.internal.util.ObjectMethodsGuru",
    "signature": "org.mockito.internal.util.ObjectMethodsGuru.isEqualsMethod(Method)",
    "snippet": "    public boolean isEqualsMethod(Method method) {\n        return method.getName().equals(\"equals\") && method.getParameterTypes().length == 1 && method.getParameterTypes()[0] == Object.class;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "ObjectMethodsGuru.isHashCodeMethod",
    "class_name": "org.mockito.internal.util.ObjectMethodsGuru",
    "signature": "org.mockito.internal.util.ObjectMethodsGuru.isHashCodeMethod(Method)",
    "snippet": "    public boolean isHashCodeMethod(Method method) {\n        return method.getName().equals(\"hashCode\") && method.getParameterTypes().length == 0;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "ObjectMethodsGuru.isToString",
    "class_name": "org.mockito.internal.util.ObjectMethodsGuru",
    "signature": "org.mockito.internal.util.ObjectMethodsGuru.isToString(Method)",
    "snippet": "    public boolean isToString(Method method) {\n        return isToString(new DelegatingMethod(method));\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "ObjectMethodsGuru.isToString",
    "class_name": "org.mockito.internal.util.ObjectMethodsGuru",
    "signature": "org.mockito.internal.util.ObjectMethodsGuru.isToString(MockitoMethod)",
    "snippet": "    public boolean isToString(MockitoMethod method) {\n        return method.getReturnType() == String.class && method.getParameterTypes().length == 0\n                && method.getName().equals(\"toString\");\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "StringJoiner.join",
    "class_name": "org.mockito.internal.util.StringJoiner",
    "signature": "org.mockito.internal.util.StringJoiner.join(Object[])",
    "snippet": "    public static String join(Object ... linesToBreak) {\n        StringBuilder out = new StringBuilder(\"\\n\");\n        for (Object line : linesToBreak) {\n            out.append(line.toString()).append(\"\\n\");\n        }\n        int lastBreak = out.lastIndexOf(\"\\n\");\n        return out.replace(lastBreak, lastBreak+1, \"\").toString();\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "AccessibilityChanger.enableAccess",
    "class_name": "org.mockito.internal.util.reflection.AccessibilityChanger",
    "signature": "org.mockito.internal.util.reflection.AccessibilityChanger.enableAccess(Field)",
    "snippet": "    public void enableAccess(Field field) {\n        wasAccessible = field.isAccessible();\n        field.setAccessible(true);\n    }",
    "comment": " changes the field accessibility and returns true if accessibility was changed ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "AccessibilityChanger.safelyDisableAccess",
    "class_name": "org.mockito.internal.util.reflection.AccessibilityChanger",
    "signature": "org.mockito.internal.util.reflection.AccessibilityChanger.safelyDisableAccess(Field)",
    "snippet": "    public void safelyDisableAccess(Field field) {\n        assert wasAccessible != null;\n        try {\n            field.setAccessible(wasAccessible);\n        } catch (Throwable t) {\n            //ignore\n        }\n    }",
    "comment": " safely disables access ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "FieldCopier.copyValue",
    "class_name": "org.mockito.internal.util.reflection.FieldCopier",
    "signature": "org.mockito.internal.util.reflection.FieldCopier.copyValue(T,T,Field)",
    "snippet": "    public <T> void copyValue(T from, T to, Field field) throws IllegalAccessException {\n        Object value = field.get(from);\n        field.set(to, value);\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "LenientCopyTool.copy",
    "class_name": "org.mockito.internal.util.reflection.LenientCopyTool",
    "signature": "org.mockito.internal.util.reflection.LenientCopyTool.copy(T,T,Class,Class)",
    "snippet": "    private <T> void copy(T from, T to, Class fromClazz, Class toClass) {\n        while (fromClazz != Object.class) {\n            copyValues(from, to, fromClazz);\n            fromClazz = fromClazz.getSuperclass();\n        }\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "LenientCopyTool.copyToMock",
    "class_name": "org.mockito.internal.util.reflection.LenientCopyTool",
    "signature": "org.mockito.internal.util.reflection.LenientCopyTool.copyToMock(T,T)",
    "snippet": "    public <T> void copyToMock(T from, T mock) {\n        copy(from, mock, from.getClass(), mock.getClass().getSuperclass());\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "LenientCopyTool.copyValues",
    "class_name": "org.mockito.internal.util.reflection.LenientCopyTool",
    "signature": "org.mockito.internal.util.reflection.LenientCopyTool.copyValues(T,T,Class)",
    "snippet": "    private <T> void copyValues(T from, T mock, Class classFrom) {\n        Field[] fields = classFrom.getDeclaredFields();\n\n        for (int i = 0; i < fields.length; i++) {\n            // ignore static fields\n            Field field = fields[i];\n            if (Modifier.isStatic(field.getModifiers())) {\n                continue;\n            }\n            AccessibilityChanger accessibilityChanger = new AccessibilityChanger();\n            try {\n                accessibilityChanger.enableAccess(field);\n                fieldCopier.copyValue(from, mock, field);\n            } catch (Throwable t) {\n                //Ignore - be lenient - if some field cannot be copied then let's be it\n            } finally {\n                accessibilityChanger.safelyDisableAccess(field);\n            }\n        }\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "MockAwareVerificationMode.MockAwareVerificationMode",
    "class_name": "org.mockito.internal.verification.MockAwareVerificationMode",
    "signature": "org.mockito.internal.verification.MockAwareVerificationMode.MockAwareVerificationMode(Object,VerificationMode)",
    "snippet": "    public MockAwareVerificationMode(Object mock, VerificationMode mode) {\n        this.mock = mock;\n        this.mode = mode;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "MockAwareVerificationMode.getMock",
    "class_name": "org.mockito.internal.verification.MockAwareVerificationMode",
    "signature": "org.mockito.internal.verification.MockAwareVerificationMode.getMock()",
    "snippet": "    public Object getMock() {\n        return mock;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "MockAwareVerificationMode.verify",
    "class_name": "org.mockito.internal.verification.MockAwareVerificationMode",
    "signature": "org.mockito.internal.verification.MockAwareVerificationMode.verify(VerificationData)",
    "snippet": "    public void verify(VerificationData data) {\n        mode.verify(data);\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "RegisteredInvocations.add",
    "class_name": "org.mockito.internal.verification.RegisteredInvocations",
    "signature": "org.mockito.internal.verification.RegisteredInvocations.add(Invocation)",
    "snippet": "    public void add(Invocation invocation) {\n        invocations.add(invocation);\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "RegisteredInvocations.getAll",
    "class_name": "org.mockito.internal.verification.RegisteredInvocations",
    "signature": "org.mockito.internal.verification.RegisteredInvocations.getAll()",
    "snippet": "    public List<Invocation> getAll() {\n        return ListUtil.filter(new LinkedList<Invocation>(invocations), new RemoveToString());\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "RemoveToString.isOut",
    "class_name": "org.mockito.internal.verification.RegisteredInvocations$RemoveToString",
    "signature": "org.mockito.internal.verification.RegisteredInvocations$RemoveToString.isOut(Invocation)",
    "snippet": "        public boolean isOut(Invocation invocation) {\n            return Invocation.isToString(invocation);\n        }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "Times.Times",
    "class_name": "org.mockito.internal.verification.Times",
    "signature": "org.mockito.internal.verification.Times.Times(int)",
    "snippet": "    public Times(int wantedNumberOfInvocations) {\n        if (wantedNumberOfInvocations < 0) {\n            throw new MockitoException(\"Negative value is not allowed here\");\n        }\n        this.wantedCount = wantedNumberOfInvocations;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "Times.verify",
    "class_name": "org.mockito.internal.verification.Times",
    "signature": "org.mockito.internal.verification.Times.verify(VerificationData)",
    "snippet": "    public void verify(VerificationData data) {\n        if (wantedCount > 0) {\n            MissingInvocationChecker missingInvocation = new MissingInvocationChecker();\n            missingInvocation.check(data.getAllInvocations(), data.getWanted());\n        }\n        NumberOfInvocationsChecker numberOfInvocations = new NumberOfInvocationsChecker();\n        numberOfInvocations.check(data.getAllInvocations(), data.getWanted(), wantedCount);\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "VerificationDataImpl.VerificationDataImpl",
    "class_name": "org.mockito.internal.verification.VerificationDataImpl",
    "signature": "org.mockito.internal.verification.VerificationDataImpl.VerificationDataImpl(InvocationContainer,InvocationMatcher)",
    "snippet": "    public VerificationDataImpl(InvocationContainer invocations, InvocationMatcher wanted) {\n        this.invocations = invocations;\n        this.wanted = wanted;\n        this.assertWantedIsVerifiable();\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "VerificationDataImpl.assertWantedIsVerifiable",
    "class_name": "org.mockito.internal.verification.VerificationDataImpl",
    "signature": "org.mockito.internal.verification.VerificationDataImpl.assertWantedIsVerifiable()",
    "snippet": "    void assertWantedIsVerifiable() {\n        if (wanted == null) {\n            return;\n        }\n        ObjectMethodsGuru o = new ObjectMethodsGuru();\n        if (o.isToString(wanted.getMethod())) {\n            new Reporter().cannotVerifyToString();\n        }\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "VerificationDataImpl.getAllInvocations",
    "class_name": "org.mockito.internal.verification.VerificationDataImpl",
    "signature": "org.mockito.internal.verification.VerificationDataImpl.getAllInvocations()",
    "snippet": "    public List<Invocation> getAllInvocations() {\n        return invocations.getInvocations();\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "VerificationDataImpl.getWanted",
    "class_name": "org.mockito.internal.verification.VerificationDataImpl",
    "signature": "org.mockito.internal.verification.VerificationDataImpl.getWanted()",
    "snippet": "    public InvocationMatcher getWanted() {\n        return wanted;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "VerificationModeFactory.times",
    "class_name": "org.mockito.internal.verification.VerificationModeFactory",
    "signature": "org.mockito.internal.verification.VerificationModeFactory.times(int)",
    "snippet": "    public static Times times(int wantedNumberOfInvocations) {\n        return new Times(wantedNumberOfInvocations);\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "ArgumentMatchingTool.getSuspiciouslyNotMatchingArgsIndexes",
    "class_name": "org.mockito.internal.verification.argumentmatching.ArgumentMatchingTool",
    "signature": "org.mockito.internal.verification.argumentmatching.ArgumentMatchingTool.getSuspiciouslyNotMatchingArgsIndexes(List,Object[])",
    "snippet": "    public Integer[] getSuspiciouslyNotMatchingArgsIndexes(List<Matcher> matchers, Object[] arguments) {\n        if (matchers.size() != arguments.length) {\n            return new Integer[0];\n        }\n        \n        List<Integer> suspicious = new LinkedList<Integer>();\n        int i = 0;\n        for (Matcher m : matchers) {\n            if (m instanceof ContainsExtraTypeInformation \n                    && !safelyMatches(m, arguments[i]) \n                    && toStringEquals(m, arguments[i])\n                    && !((ContainsExtraTypeInformation) m).typeMatches(arguments[i])) {\n                suspicious.add(i);\n            }\n            i++;\n        }\n        return suspicious.toArray(new Integer[0]);\n    }",
    "comment": " Suspiciously not matching arguments are those that don't match, the toString() representation is the same but types are different. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "ArgumentMatchingTool.safelyMatches",
    "class_name": "org.mockito.internal.verification.argumentmatching.ArgumentMatchingTool",
    "signature": "org.mockito.internal.verification.argumentmatching.ArgumentMatchingTool.safelyMatches(Matcher,Object)",
    "snippet": "    private boolean safelyMatches(Matcher m, Object arg) {\n        try {\n            return m.matches(arg);\n        } catch (Throwable t) {\n            return false;\n        }\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "ArgumentMatchingTool.toStringEquals",
    "class_name": "org.mockito.internal.verification.argumentmatching.ArgumentMatchingTool",
    "signature": "org.mockito.internal.verification.argumentmatching.ArgumentMatchingTool.toStringEquals(Matcher,Object)",
    "snippet": "    private boolean toStringEquals(Matcher m, Object arg) {\n        return StringDescription.toString(m).equals(arg == null? \"null\" : arg.toString());\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "MissingInvocationChecker.MissingInvocationChecker",
    "class_name": "org.mockito.internal.verification.checkers.MissingInvocationChecker",
    "signature": "org.mockito.internal.verification.checkers.MissingInvocationChecker.MissingInvocationChecker()",
    "snippet": "    public MissingInvocationChecker() {\n        this(new InvocationsFinder(), new Reporter());\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "MissingInvocationChecker.MissingInvocationChecker",
    "class_name": "org.mockito.internal.verification.checkers.MissingInvocationChecker",
    "signature": "org.mockito.internal.verification.checkers.MissingInvocationChecker.MissingInvocationChecker(InvocationsFinder,Reporter)",
    "snippet": "    MissingInvocationChecker(InvocationsFinder finder, Reporter reporter) {\n        this.finder = finder;\n        this.reporter = reporter;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "MissingInvocationChecker.check",
    "class_name": "org.mockito.internal.verification.checkers.MissingInvocationChecker",
    "signature": "org.mockito.internal.verification.checkers.MissingInvocationChecker.check(List,InvocationMatcher)",
    "snippet": "    public void check(List<Invocation> invocations, InvocationMatcher wanted) {\n        List<Invocation> actualInvocations = finder.findInvocations(invocations, wanted);\n        \n        if (actualInvocations.isEmpty()) {\n            Invocation similar = finder.findSimilarInvocation(invocations, wanted);\n            if (similar != null) {\n                ArgumentMatchingTool argumentMatchingTool = new ArgumentMatchingTool();\n                Integer[] indexesOfSuspiciousArgs = argumentMatchingTool.getSuspiciouslyNotMatchingArgsIndexes(wanted.getMatchers(), similar.getArguments());\n                SmartPrinter smartPrinter = new SmartPrinter(wanted, similar, indexesOfSuspiciousArgs);\n                reporter.argumentsAreDifferent(smartPrinter.getWanted(), smartPrinter.getActual(), similar.getLocation());\n            } else {\n                reporter.wantedButNotInvoked(wanted, invocations);\n            }\n        }\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  }
]