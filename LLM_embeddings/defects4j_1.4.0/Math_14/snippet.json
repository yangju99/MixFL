[
  {
    "name": "PolynomialFunction.PolynomialFunction",
    "class_name": "org.apache.commons.math3.analysis.polynomials.PolynomialFunction",
    "signature": "org.apache.commons.math3.analysis.polynomials.PolynomialFunction.PolynomialFunction(double[])",
    "snippet": "    public PolynomialFunction(double c[])\n        throws NullArgumentException, NoDataException {\n        super();\n        MathUtils.checkNotNull(c);\n        int n = c.length;\n        if (n == 0) {\n            throw new NoDataException(LocalizedFormats.EMPTY_POLYNOMIALS_COEFFICIENTS_ARRAY);\n        }\n        while ((n > 1) && (c[n - 1] == 0)) {\n            --n;\n        }\n        this.coefficients = new double[n];\n        System.arraycopy(c, 0, this.coefficients, 0, n);\n    }",
    "comment": " Construct a polynomial with the given coefficients.  The first element of the coefficients array is the constant term.  Higher degree coefficients follow in sequence.  The degree of the resulting polynomial is the index of the last non-null element of the array, or 0 if all elements are null. <p> The constructor makes a copy of the input array and assigns the copy to the coefficients property.</p>  @param c Polynomial coefficients. @throws NullArgumentException if {@code c} is {@code null}. @throws NoDataException if {@code c} is empty. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "PolynomialFunction.evaluate",
    "class_name": "org.apache.commons.math3.analysis.polynomials.PolynomialFunction",
    "signature": "org.apache.commons.math3.analysis.polynomials.PolynomialFunction.evaluate(double[],double)",
    "snippet": "    protected static double evaluate(double[] coefficients, double argument)\n        throws NullArgumentException, NoDataException {\n        MathUtils.checkNotNull(coefficients);\n        int n = coefficients.length;\n        if (n == 0) {\n            throw new NoDataException(LocalizedFormats.EMPTY_POLYNOMIALS_COEFFICIENTS_ARRAY);\n        }\n        double result = coefficients[n - 1];\n        for (int j = n - 2; j >= 0; j--) {\n            result = argument * result + coefficients[j];\n        }\n        return result;\n    }",
    "comment": " Uses Horner's Method to evaluate the polynomial with the given coefficients at the argument.  @param coefficients Coefficients of the polynomial to evaluate. @param argument Input value. @return the value of the polynomial. @throws NoDataException if {@code coefficients} is empty. @throws NullArgumentException if {@code coefficients} is {@code null}. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "PolynomialFunction.value",
    "class_name": "org.apache.commons.math3.analysis.polynomials.PolynomialFunction",
    "signature": "org.apache.commons.math3.analysis.polynomials.PolynomialFunction.value(double)",
    "snippet": "    public double value(double x) {\n       return evaluate(coefficients, x);\n    }",
    "comment": " Compute the value of the function for the given argument. <p> The value returned is <br/> <code>coefficients[n] * x^n + ... + coefficients[1] * x  + coefficients[0]</code> </p>  @param x Argument for which the function value should be computed. @return the value of the polynomial at the given point. @see UnivariateFunction#value(double) ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "CurveFitter.CurveFitter",
    "class_name": "org.apache.commons.math3.fitting.CurveFitter",
    "signature": "org.apache.commons.math3.fitting.CurveFitter.CurveFitter(MultivariateVectorOptimizer)",
    "snippet": "    public CurveFitter(final MultivariateVectorOptimizer optimizer) {\n        this.optimizer = optimizer;\n        observations = new ArrayList<WeightedObservedPoint>();\n    }",
    "comment": " Simple constructor.  @param optimizer Optimizer to use for the fitting. @since 3.1 ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "CurveFitter.addObservedPoint",
    "class_name": "org.apache.commons.math3.fitting.CurveFitter",
    "signature": "org.apache.commons.math3.fitting.CurveFitter.addObservedPoint(double,double,double)",
    "snippet": "    public void addObservedPoint(double weight, double x, double y) {\n        observations.add(new WeightedObservedPoint(weight, x, y));\n    }",
    "comment": "Add an observed weighted (x,y) point to the sample. @param weight weight of the observed point in the fit @param x abscissa of the point @param y observed value of the point at x, after fitting we should have f(x) as close as possible to this value @see #addObservedPoint(double, double) @see #addObservedPoint(WeightedObservedPoint) @see #getObservations() ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "TheoreticalValuesFunction.getModelFunction",
    "class_name": "org.apache.commons.math3.fitting.CurveFitter$TheoreticalValuesFunction",
    "signature": "org.apache.commons.math3.fitting.CurveFitter$TheoreticalValuesFunction.getModelFunction()",
    "snippet": "        public ModelFunction getModelFunction() {\n            return new ModelFunction(new MultivariateVectorFunction() {\n                    /** {@inheritDoc} */\n                    public double[] value(double[] point) {\n                        // compute the residuals\n                        final double[] values = new double[observations.size()];\n                        int i = 0;\n                        for (WeightedObservedPoint observed : observations) {\n                            values[i++] = f.value(observed.getX(), point);\n                        }\n\n                        return values;\n                    }\n                });\n        }",
    "comment": " @return the model function values. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "TheoreticalValuesFunction.getModelFunctionJacobian",
    "class_name": "org.apache.commons.math3.fitting.CurveFitter$TheoreticalValuesFunction",
    "signature": "org.apache.commons.math3.fitting.CurveFitter$TheoreticalValuesFunction.getModelFunctionJacobian()",
    "snippet": "        public ModelFunctionJacobian getModelFunctionJacobian() {\n            return new ModelFunctionJacobian(new MultivariateMatrixFunction() {\n                    public double[][] value(double[] point) {\n                        final double[][] jacobian = new double[observations.size()][];\n                        int i = 0;\n                        for (WeightedObservedPoint observed : observations) {\n                            jacobian[i++] = f.gradient(observed.getX(), point);\n                        }\n                        return jacobian;\n                    }\n                });\n        }",
    "comment": " @return the model function Jacobian. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "PolynomialFitter.PolynomialFitter",
    "class_name": "org.apache.commons.math3.fitting.PolynomialFitter",
    "signature": "org.apache.commons.math3.fitting.PolynomialFitter.PolynomialFitter(MultivariateVectorOptimizer)",
    "snippet": "    public PolynomialFitter(MultivariateVectorOptimizer optimizer) {\n        super(optimizer);\n    }",
    "comment": " Simple constructor.  @param optimizer Optimizer to use for the fitting. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "PolynomialFitter.fit",
    "class_name": "org.apache.commons.math3.fitting.PolynomialFitter",
    "signature": "org.apache.commons.math3.fitting.PolynomialFitter.fit(double[])",
    "snippet": "    public double[] fit(double[] guess) {\n        return fit(new PolynomialFunction.Parametric(), guess);\n    }",
    "comment": " Get the coefficients of the polynomial fitting the weighted data points. The degree of the fitting polynomial is {@code guess.length - 1}.  @param guess First guess for the coefficients. They must be sorted in increasing order of the polynomial's degree. @return the coefficients of the polynomial that best fits the observed points. @throws org.apache.commons.math3.exception.ConvergenceException if the algorithm failed to converge. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "WeightedObservedPoint.WeightedObservedPoint",
    "class_name": "org.apache.commons.math3.fitting.WeightedObservedPoint",
    "signature": "org.apache.commons.math3.fitting.WeightedObservedPoint.WeightedObservedPoint(double,double,double)",
    "snippet": "    public WeightedObservedPoint(final double weight, final double x, final double y) {\n        this.weight = weight;\n        this.x      = x;\n        this.y      = y;\n    }",
    "comment": " Simple constructor.  @param weight Weight of the measurement in the fitting process. @param x Abscissa of the measurement. @param y Ordinate of the measurement. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "WeightedObservedPoint.getWeight",
    "class_name": "org.apache.commons.math3.fitting.WeightedObservedPoint",
    "signature": "org.apache.commons.math3.fitting.WeightedObservedPoint.getWeight()",
    "snippet": "    public double getWeight() {\n        return weight;\n    }",
    "comment": " Gets the weight of the measurement in the fitting process.  @return the weight of the measurement in the fitting process. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "WeightedObservedPoint.getY",
    "class_name": "org.apache.commons.math3.fitting.WeightedObservedPoint",
    "signature": "org.apache.commons.math3.fitting.WeightedObservedPoint.getY()",
    "snippet": "    public double getY() {\n        return y;\n    }",
    "comment": " Gets the observed value of the function at x.  @return the observed value of the function at x. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "AbstractRealMatrix.AbstractRealMatrix",
    "class_name": "org.apache.commons.math3.linear.AbstractRealMatrix",
    "signature": "org.apache.commons.math3.linear.AbstractRealMatrix.AbstractRealMatrix(int,int)",
    "snippet": "    protected AbstractRealMatrix(final int rowDimension,\n        final int columnDimension)\n        throws NotStrictlyPositiveException {\n        if (rowDimension < 1) {\n            throw new NotStrictlyPositiveException(rowDimension);\n        }\n        if (columnDimension < 1) {\n            throw new NotStrictlyPositiveException(columnDimension);\n        }\n    }",
    "comment": " Create a new RealMatrix with the supplied row and column dimensions.  @param rowDimension  the number of rows in the new matrix @param columnDimension  the number of columns in the new matrix @throws NotStrictlyPositiveException if row or column dimension is not positive ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "BlockRealMatrix.BlockRealMatrix",
    "class_name": "org.apache.commons.math3.linear.BlockRealMatrix",
    "signature": "org.apache.commons.math3.linear.BlockRealMatrix.BlockRealMatrix(int,int)",
    "snippet": "    public BlockRealMatrix(final int rows, final int columns)\n        throws NotStrictlyPositiveException {\n        super(rows, columns);\n        this.rows = rows;\n        this.columns = columns;\n\n        // number of blocks\n        blockRows = (rows + BLOCK_SIZE - 1) / BLOCK_SIZE;\n        blockColumns = (columns + BLOCK_SIZE - 1) / BLOCK_SIZE;\n\n        // allocate storage blocks, taking care of smaller ones at right and bottom\n        blocks = createBlocksLayout(rows, columns);\n    }",
    "comment": " Create a new matrix with the supplied row and column dimensions.  @param rows  the number of rows in the new matrix @param columns  the number of columns in the new matrix @throws NotStrictlyPositiveException if row or column dimension is not positive. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "BlockRealMatrix.blockWidth",
    "class_name": "org.apache.commons.math3.linear.BlockRealMatrix",
    "signature": "org.apache.commons.math3.linear.BlockRealMatrix.blockWidth(int)",
    "snippet": "    private int blockWidth(final int blockColumn) {\n        return (blockColumn == blockColumns - 1) ? columns - blockColumn * BLOCK_SIZE : BLOCK_SIZE;\n    }",
    "comment": " Get the width of a block. @param blockColumn column index (in block sense) of the block @return width (number of columns) of the block ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "BlockRealMatrix.copy",
    "class_name": "org.apache.commons.math3.linear.BlockRealMatrix",
    "signature": "org.apache.commons.math3.linear.BlockRealMatrix.copy()",
    "snippet": "    @Override\n    public BlockRealMatrix copy() {\n        // create an empty matrix\n        BlockRealMatrix copied = new BlockRealMatrix(rows, columns);\n\n        // copy the blocks\n        for (int i = 0; i < blocks.length; ++i) {\n            System.arraycopy(blocks[i], 0, copied.blocks[i], 0, blocks[i].length);\n        }\n\n        return copied;\n    }",
    "comment": "{@inheritDoc} */",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "BlockRealMatrix.createBlocksLayout",
    "class_name": "org.apache.commons.math3.linear.BlockRealMatrix",
    "signature": "org.apache.commons.math3.linear.BlockRealMatrix.createBlocksLayout(int,int)",
    "snippet": "    public static double[][] createBlocksLayout(final int rows, final int columns) {\n        final int blockRows = (rows    + BLOCK_SIZE - 1) / BLOCK_SIZE;\n        final int blockColumns = (columns + BLOCK_SIZE - 1) / BLOCK_SIZE;\n\n        final double[][] blocks = new double[blockRows * blockColumns][];\n        int blockIndex = 0;\n        for (int iBlock = 0; iBlock < blockRows; ++iBlock) {\n            final int pStart = iBlock * BLOCK_SIZE;\n            final int pEnd = FastMath.min(pStart + BLOCK_SIZE, rows);\n            final int iHeight = pEnd - pStart;\n            for (int jBlock = 0; jBlock < blockColumns; ++jBlock) {\n                final int qStart = jBlock * BLOCK_SIZE;\n                final int qEnd = FastMath.min(qStart + BLOCK_SIZE, columns);\n                final int jWidth = qEnd - qStart;\n                blocks[blockIndex] = new double[iHeight * jWidth];\n                ++blockIndex;\n            }\n        }\n\n        return blocks;\n    }",
    "comment": " Create a data array in blocks layout. <p> This method can be used to create the array argument of the {@link #BlockRealMatrix(int, int, double[][], boolean)} constructor. </p> @param rows Number of rows in the new matrix. @param columns Number of columns in the new matrix. @return a new data array in blocks layout. @see #toBlocksLayout(double[][]) @see #BlockRealMatrix(int, int, double[][], boolean) ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "BlockRealMatrix.getColumnDimension",
    "class_name": "org.apache.commons.math3.linear.BlockRealMatrix",
    "signature": "org.apache.commons.math3.linear.BlockRealMatrix.getColumnDimension()",
    "snippet": "    @Override\n    public int getColumnDimension() {\n        return columns;\n    }",
    "comment": "{@inheritDoc} */",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "BlockRealMatrix.getRowDimension",
    "class_name": "org.apache.commons.math3.linear.BlockRealMatrix",
    "signature": "org.apache.commons.math3.linear.BlockRealMatrix.getRowDimension()",
    "snippet": "    @Override\n    public int getRowDimension() {\n        return rows;\n    }",
    "comment": "{@inheritDoc} */",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "BlockRealMatrix.setEntry",
    "class_name": "org.apache.commons.math3.linear.BlockRealMatrix",
    "signature": "org.apache.commons.math3.linear.BlockRealMatrix.setEntry(int,int,double)",
    "snippet": "    @Override\n    public void setEntry(final int row, final int column, final double value)\n        throws OutOfRangeException {\n        MatrixUtils.checkMatrixIndex(this, row, column);\n        final int iBlock = row / BLOCK_SIZE;\n        final int jBlock = column / BLOCK_SIZE;\n        final int k = (row - iBlock * BLOCK_SIZE) * blockWidth(jBlock) +\n            (column - jBlock * BLOCK_SIZE);\n        blocks[iBlock * blockColumns + jBlock][k] = value;\n    }",
    "comment": "{@inheritDoc} */",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "MatrixUtils.checkColumnIndex",
    "class_name": "org.apache.commons.math3.linear.MatrixUtils",
    "signature": "org.apache.commons.math3.linear.MatrixUtils.checkColumnIndex(AnyMatrix,int)",
    "snippet": "    public static void checkColumnIndex(final AnyMatrix m, final int column)\n        throws OutOfRangeException {\n        if (column < 0 || column >= m.getColumnDimension()) {\n            throw new OutOfRangeException(LocalizedFormats.COLUMN_INDEX,\n                                           column, 0, m.getColumnDimension() - 1);\n        }\n    }",
    "comment": " Check if a column index is valid.  @param m Matrix. @param column Column index to check. @throws OutOfRangeException if {@code column} is not a valid index. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "MatrixUtils.checkMatrixIndex",
    "class_name": "org.apache.commons.math3.linear.MatrixUtils",
    "signature": "org.apache.commons.math3.linear.MatrixUtils.checkMatrixIndex(AnyMatrix,int,int)",
    "snippet": "    public static void checkMatrixIndex(final AnyMatrix m,\n                                        final int row, final int column)\n        throws OutOfRangeException {\n        checkRowIndex(m, row);\n        checkColumnIndex(m, column);\n    }",
    "comment": " Check if matrix indices are valid.  @param m Matrix. @param row Row index to check. @param column Column index to check. @throws OutOfRangeException if {@code row} or {@code column} is not a valid index. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "MatrixUtils.checkRowIndex",
    "class_name": "org.apache.commons.math3.linear.MatrixUtils",
    "signature": "org.apache.commons.math3.linear.MatrixUtils.checkRowIndex(AnyMatrix,int)",
    "snippet": "    public static void checkRowIndex(final AnyMatrix m, final int row)\n        throws OutOfRangeException {\n        if (row < 0 ||\n            row >= m.getRowDimension()) {\n            throw new OutOfRangeException(LocalizedFormats.ROW_INDEX,\n                                          row, 0, m.getRowDimension() - 1);\n        }\n    }",
    "comment": " Check if a row index is valid.  @param m Matrix. @param row Row index to check. @throws OutOfRangeException if {@code row} is not a valid index. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "MatrixUtils.createRealMatrix",
    "class_name": "org.apache.commons.math3.linear.MatrixUtils",
    "signature": "org.apache.commons.math3.linear.MatrixUtils.createRealMatrix(int,int)",
    "snippet": "    public static RealMatrix createRealMatrix(final int rows, final int columns) {\n        return (rows * columns <= 4096) ?\n                new Array2DRowRealMatrix(rows, columns) : new BlockRealMatrix(rows, columns);\n    }",
    "comment": " Returns a {@link RealMatrix} with specified dimensions. <p>The type of matrix returned depends on the dimension. Below 2<sup>12</sup> elements (i.e. 4096 elements or 64&times;64 for a square matrix) which can be stored in a 32kB array, a {@link Array2DRowRealMatrix} instance is built. Above this threshold a {@link BlockRealMatrix} instance is built.</p> <p>The matrix elements are all set to 0.0.</p> @param rows number of rows of the matrix @param columns number of columns of the matrix @return  RealMatrix with specified dimensions @see #createRealMatrix(double[][]) ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "RealMatrixFormat.RealMatrixFormat",
    "class_name": "org.apache.commons.math3.linear.RealMatrixFormat",
    "signature": "org.apache.commons.math3.linear.RealMatrixFormat.RealMatrixFormat(NumberFormat)",
    "snippet": "    public RealMatrixFormat(final NumberFormat format) {\n        this(DEFAULT_PREFIX, DEFAULT_SUFFIX, DEFAULT_ROW_PREFIX, DEFAULT_ROW_SUFFIX,\n                DEFAULT_ROW_SEPARATOR, DEFAULT_COLUMN_SEPARATOR, format);\n    }",
    "comment": " Create an instance with a custom number format for components. @param format the custom format for components. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "RealMatrixFormat.RealMatrixFormat",
    "class_name": "org.apache.commons.math3.linear.RealMatrixFormat",
    "signature": "org.apache.commons.math3.linear.RealMatrixFormat.RealMatrixFormat(String,String,String,String,String,String)",
    "snippet": "    public RealMatrixFormat(final String prefix, final String suffix,\n                            final String rowPrefix, final String rowSuffix,\n                            final String rowSeparator, final String columnSeparator) {\n        this(prefix, suffix, rowPrefix, rowSuffix, rowSeparator, columnSeparator,\n                CompositeFormat.getDefaultNumberFormat());\n    }",
    "comment": " Create an instance with custom prefix, suffix and separator. @param prefix prefix to use instead of the default \"{\" @param suffix suffix to use instead of the default \"}\" @param rowPrefix row prefix to use instead of the default \"{\" @param rowSuffix row suffix to use instead of the default \"}\" @param rowSeparator tow separator to use instead of the default \";\" @param columnSeparator column separator to use instead of the default \", \" ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "RealMatrixFormat.RealMatrixFormat",
    "class_name": "org.apache.commons.math3.linear.RealMatrixFormat",
    "signature": "org.apache.commons.math3.linear.RealMatrixFormat.RealMatrixFormat(String,String,String,String,String,String,NumberFormat)",
    "snippet": "    public RealMatrixFormat(final String prefix, final String suffix,\n                            final String rowPrefix, final String rowSuffix,\n                            final String rowSeparator, final String columnSeparator,\n                            final NumberFormat format) {\n        this.prefix            = prefix;\n        this.suffix            = suffix;\n        this.rowPrefix         = rowPrefix;\n        this.rowSuffix         = rowSuffix;\n        this.rowSeparator      = rowSeparator;\n        this.columnSeparator   = columnSeparator;\n        this.format            = format;\n        // disable grouping to prevent parsing problems\n        this.format.setGroupingUsed(false);\n    }",
    "comment": " Create an instance with custom prefix, suffix, separator and format for components. @param prefix prefix to use instead of the default \"{\" @param suffix suffix to use instead of the default \"}\" @param rowPrefix row prefix to use instead of the default \"{\" @param rowSuffix row suffix to use instead of the default \"}\" @param rowSeparator tow separator to use instead of the default \";\" @param columnSeparator column separator to use instead of the default \", \" @param format the custom format for components. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "RealMatrixFormat.getFormat",
    "class_name": "org.apache.commons.math3.linear.RealMatrixFormat",
    "signature": "org.apache.commons.math3.linear.RealMatrixFormat.getFormat()",
    "snippet": "    public NumberFormat getFormat() {\n        return format;\n    }",
    "comment": " Get the components format. @return components format. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "RealMatrixFormat.getInstance",
    "class_name": "org.apache.commons.math3.linear.RealMatrixFormat",
    "signature": "org.apache.commons.math3.linear.RealMatrixFormat.getInstance()",
    "snippet": "    public static RealMatrixFormat getInstance() {\n        return getInstance(Locale.getDefault());\n    }",
    "comment": " Returns the default real vector format for the current locale. @return the default real vector format. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "RealMatrixFormat.getInstance",
    "class_name": "org.apache.commons.math3.linear.RealMatrixFormat",
    "signature": "org.apache.commons.math3.linear.RealMatrixFormat.getInstance(Locale)",
    "snippet": "    public static RealMatrixFormat getInstance(final Locale locale) {\n        return new RealMatrixFormat(CompositeFormat.getDefaultNumberFormat(locale));\n    }",
    "comment": " Returns the default real vector format for the given locale. @param locale the specific locale used by the format. @return the real vector format specific to the given locale. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "BaseMultivariateOptimizer.BaseMultivariateOptimizer",
    "class_name": "org.apache.commons.math3.optim.BaseMultivariateOptimizer",
    "signature": "org.apache.commons.math3.optim.BaseMultivariateOptimizer.BaseMultivariateOptimizer(ConvergenceChecker)",
    "snippet": "    protected BaseMultivariateOptimizer(ConvergenceChecker<PAIR> checker) {\n        super(checker);\n    }",
    "comment": " @param checker Convergence checker. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "BaseOptimizer.BaseOptimizer",
    "class_name": "org.apache.commons.math3.optim.BaseOptimizer",
    "signature": "org.apache.commons.math3.optim.BaseOptimizer.BaseOptimizer(ConvergenceChecker)",
    "snippet": "    protected BaseOptimizer(ConvergenceChecker<PAIR> checker) {\n        this.checker = checker;\n\n        evaluations = new Incrementor(0, new MaxEvalCallback());\n        iterations = new Incrementor(0, new MaxIterCallback());\n    }",
    "comment": " @param checker Convergence checker. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "InitialGuess.InitialGuess",
    "class_name": "org.apache.commons.math3.optim.InitialGuess",
    "signature": "org.apache.commons.math3.optim.InitialGuess.InitialGuess(double[])",
    "snippet": "    public InitialGuess(double[] startPoint) {\n        init = startPoint.clone();\n    }",
    "comment": " @param startPoint Initial guess. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "MaxEval.MaxEval",
    "class_name": "org.apache.commons.math3.optim.MaxEval",
    "signature": "org.apache.commons.math3.optim.MaxEval.MaxEval(int)",
    "snippet": "    public MaxEval(int max) {\n        if (max <= 0) {\n            throw new NotStrictlyPositiveException(max);\n        }\n\n        maxEval = max;\n    }",
    "comment": " @param max Allowed number of evalutations. @throws NotStrictlyPositiveException if {@code max <= 0}. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "JacobianMultivariateVectorOptimizer.JacobianMultivariateVectorOptimizer",
    "class_name": "org.apache.commons.math3.optim.nonlinear.vector.JacobianMultivariateVectorOptimizer",
    "signature": "org.apache.commons.math3.optim.nonlinear.vector.JacobianMultivariateVectorOptimizer.JacobianMultivariateVectorOptimizer(ConvergenceChecker)",
    "snippet": "    protected JacobianMultivariateVectorOptimizer(ConvergenceChecker<PointVectorValuePair> checker) {\n        super(checker);\n    }",
    "comment": " @param checker Convergence checker. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "ModelFunction.ModelFunction",
    "class_name": "org.apache.commons.math3.optim.nonlinear.vector.ModelFunction",
    "signature": "org.apache.commons.math3.optim.nonlinear.vector.ModelFunction.ModelFunction(MultivariateVectorFunction)",
    "snippet": "    public ModelFunction(MultivariateVectorFunction m) {\n        model = m;\n    }",
    "comment": " @param m Model function to be optimized. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "ModelFunctionJacobian.ModelFunctionJacobian",
    "class_name": "org.apache.commons.math3.optim.nonlinear.vector.ModelFunctionJacobian",
    "signature": "org.apache.commons.math3.optim.nonlinear.vector.ModelFunctionJacobian.ModelFunctionJacobian(MultivariateMatrixFunction)",
    "snippet": "    public ModelFunctionJacobian(MultivariateMatrixFunction j) {\n        jacobian = j;\n    }",
    "comment": " @param j Jacobian of the model function to be optimized. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "MultivariateVectorOptimizer.MultivariateVectorOptimizer",
    "class_name": "org.apache.commons.math3.optim.nonlinear.vector.MultivariateVectorOptimizer",
    "signature": "org.apache.commons.math3.optim.nonlinear.vector.MultivariateVectorOptimizer.MultivariateVectorOptimizer(ConvergenceChecker)",
    "snippet": "    protected MultivariateVectorOptimizer(ConvergenceChecker<PointVectorValuePair> checker) {\n        super(checker);\n    }",
    "comment": " @param checker Convergence checker. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "Target.Target",
    "class_name": "org.apache.commons.math3.optim.nonlinear.vector.Target",
    "signature": "org.apache.commons.math3.optim.nonlinear.vector.Target.Target(double[])",
    "snippet": "    public Target(double[] observations) {\n        target = observations.clone();\n    }",
    "comment": " @param observations Target values. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "Weight.Weight",
    "class_name": "org.apache.commons.math3.optim.nonlinear.vector.Weight",
    "signature": "org.apache.commons.math3.optim.nonlinear.vector.Weight.Weight(double[])",
    "snippet": "    public Weight(double[] weight) {\n        final int dim = weight.length;\n        weightMatrix = org.apache.commons.math3.linear.MatrixUtils.createRealMatrix(dim, dim);\n        for (int i = 0; i < dim; i++) {\n            weightMatrix.setEntry(i, i, weight[i]);\n        }\n    }",
    "comment": " Creates a diagonal weight matrix.  @param weight List of the values of the diagonal. ",
    "is_bug": true,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "Weight.getWeight",
    "class_name": "org.apache.commons.math3.optim.nonlinear.vector.Weight",
    "signature": "org.apache.commons.math3.optim.nonlinear.vector.Weight.getWeight()",
    "snippet": "    public RealMatrix getWeight() {\n        return weightMatrix.copy();\n    }",
    "comment": " Gets the initial guess.  @return the initial guess. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "AbstractLeastSquaresOptimizer.AbstractLeastSquaresOptimizer",
    "class_name": "org.apache.commons.math3.optim.nonlinear.vector.jacobian.AbstractLeastSquaresOptimizer",
    "signature": "org.apache.commons.math3.optim.nonlinear.vector.jacobian.AbstractLeastSquaresOptimizer.AbstractLeastSquaresOptimizer(ConvergenceChecker)",
    "snippet": "    protected AbstractLeastSquaresOptimizer(ConvergenceChecker<PointVectorValuePair> checker) {\n        super(checker);\n    }",
    "comment": " @param checker Convergence checker. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "AbstractLeastSquaresOptimizer.optimize",
    "class_name": "org.apache.commons.math3.optim.nonlinear.vector.jacobian.AbstractLeastSquaresOptimizer",
    "signature": "org.apache.commons.math3.optim.nonlinear.vector.jacobian.AbstractLeastSquaresOptimizer.optimize(OptimizationData[])",
    "snippet": "    @Override\n    public PointVectorValuePair optimize(OptimizationData... optData)\n        throws TooManyEvaluationsException {\n        // Retrieve settings.\n        parseOptimizationData(optData);\n        // Set up base class and perform computation.\n        return super.optimize(optData);\n    }",
    "comment": " {@inheritDoc}  @param optData Optimization data. The following data will be looked for: <ul> <li>{@link org.apache.commons.math3.optim.MaxEval}</li> <li>{@link org.apache.commons.math3.optim.InitialGuess}</li> <li>{@link org.apache.commons.math3.optim.SimpleBounds}</li> <li>{@link org.apache.commons.math3.optim.nonlinear.vector.Target}</li> <li>{@link org.apache.commons.math3.optim.nonlinear.vector.Weight}</li> <li>{@link org.apache.commons.math3.optim.nonlinear.vector.ModelFunction}</li> <li>{@link org.apache.commons.math3.optim.nonlinear.vector.ModelFunctionJacobian}</li> </ul> @return {@inheritDoc} @throws TooManyEvaluationsException if the maximal number of evaluations is exceeded. @throws DimensionMismatchException if the initial guess, target, and weight arguments have inconsistent dimensions. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "AbstractLeastSquaresOptimizer.parseOptimizationData",
    "class_name": "org.apache.commons.math3.optim.nonlinear.vector.jacobian.AbstractLeastSquaresOptimizer",
    "signature": "org.apache.commons.math3.optim.nonlinear.vector.jacobian.AbstractLeastSquaresOptimizer.parseOptimizationData(OptimizationData[])",
    "snippet": "    private void parseOptimizationData(OptimizationData... optData) {\n        // The existing values (as set by the previous call) are reused if\n        // not provided in the argument list.\n        for (OptimizationData data : optData) {\n            if (data instanceof Weight) {\n                weightMatrixSqrt = squareRoot(((Weight) data).getWeight());\n                // If more data must be parsed, this statement _must_ be\n                // changed to \"continue\".\n                break;\n            }\n        }\n    }",
    "comment": " Scans the list of (required and optional) optimization data that characterize the problem. If the weight matrix is specified, the {@link #weightMatrixSqrt} field is recomputed.  @param optData Optimization data. The following data will be looked for: <ul> <li>{@link Weight}</li> </ul> ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "LevenbergMarquardtOptimizer.LevenbergMarquardtOptimizer",
    "class_name": "org.apache.commons.math3.optim.nonlinear.vector.jacobian.LevenbergMarquardtOptimizer",
    "signature": "org.apache.commons.math3.optim.nonlinear.vector.jacobian.LevenbergMarquardtOptimizer.LevenbergMarquardtOptimizer()",
    "snippet": "    public LevenbergMarquardtOptimizer() {\n        this(100, 1e-10, 1e-10, 1e-10, Precision.SAFE_MIN);\n    }",
    "comment": " Build an optimizer for least squares problems with default values for all the tuning parameters (see the {@link #LevenbergMarquardtOptimizer(double,double,double,double,double) other contructor}. The default values for the algorithm settings are: <ul> <li>Initial step bound factor: 100</li> <li>Cost relative tolerance: 1e-10</li> <li>Parameters relative tolerance: 1e-10</li> <li>Orthogonality tolerance: 1e-10</li> <li>QR ranking threshold: {@link Precision#SAFE_MIN}</li> </ul> ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "LevenbergMarquardtOptimizer.LevenbergMarquardtOptimizer",
    "class_name": "org.apache.commons.math3.optim.nonlinear.vector.jacobian.LevenbergMarquardtOptimizer",
    "signature": "org.apache.commons.math3.optim.nonlinear.vector.jacobian.LevenbergMarquardtOptimizer.LevenbergMarquardtOptimizer(double,double,double,double,double)",
    "snippet": "    public LevenbergMarquardtOptimizer(double initialStepBoundFactor,\n                                       double costRelativeTolerance,\n                                       double parRelativeTolerance,\n                                       double orthoTolerance,\n                                       double threshold) {\n        super(null); // No custom convergence criterion.\n        this.initialStepBoundFactor = initialStepBoundFactor;\n        this.costRelativeTolerance = costRelativeTolerance;\n        this.parRelativeTolerance = parRelativeTolerance;\n        this.orthoTolerance = orthoTolerance;\n        this.qrRankingThreshold = threshold;\n    }",
    "comment": " The arguments control the behaviour of the default convergence checking procedure. Additional criteria can defined through the setting of a {@link ConvergenceChecker}.  @param initialStepBoundFactor Positive input variable used in determining the initial step bound. This bound is set to the product of initialStepBoundFactor and the euclidean norm of {@code diag * x} if non-zero, or else to {@code initialStepBoundFactor} itself. In most cases factor should lie in the interval {@code (0.1, 100.0)}. {@code 100} is a generally recommended value. @param costRelativeTolerance Desired relative error in the sum of squares. @param parRelativeTolerance Desired relative error in the approximate solution parameters. @param orthoTolerance Desired max cosine on the orthogonality between the function vector and the columns of the Jacobian. @param threshold Desired threshold for QR ranking. If the squared norm of a column vector is smaller or equal to this threshold during QR decomposition, it is considered to be a zero vector and hence the rank of the matrix is reduced. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "CompositeFormat.getDefaultNumberFormat",
    "class_name": "org.apache.commons.math3.util.CompositeFormat",
    "signature": "org.apache.commons.math3.util.CompositeFormat.getDefaultNumberFormat()",
    "snippet": "    public static NumberFormat getDefaultNumberFormat() {\n        return getDefaultNumberFormat(Locale.getDefault());\n    }",
    "comment": " Create a default number format.  The default number format is based on {@link NumberFormat#getInstance()} with the only customizing that the maximum number of fraction digits is set to 10. @return the default number format. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "CompositeFormat.getDefaultNumberFormat",
    "class_name": "org.apache.commons.math3.util.CompositeFormat",
    "signature": "org.apache.commons.math3.util.CompositeFormat.getDefaultNumberFormat(Locale)",
    "snippet": "    public static NumberFormat getDefaultNumberFormat(final Locale locale) {\n        final NumberFormat nf = NumberFormat.getInstance(locale);\n        nf.setMaximumFractionDigits(10);\n        return nf;\n    }",
    "comment": " Create a default number format.  The default number format is based on {@link NumberFormat#getInstance(java.util.Locale)} with the only customizing that the maximum number of fraction digits is set to 10. @param locale the specific locale used by the format. @return the default number format specific to the given locale. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "FastMath.min",
    "class_name": "org.apache.commons.math3.util.FastMath",
    "signature": "org.apache.commons.math3.util.FastMath.min(int,int)",
    "snippet": "    public static int min(final int a, final int b) {\n        return (a <= b) ? a : b;\n    }",
    "comment": "Compute the minimum of two values @param a first value @param b second value @return a if a is lesser or equal to b, b otherwise ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "Incrementor.Incrementor",
    "class_name": "org.apache.commons.math3.util.Incrementor",
    "signature": "org.apache.commons.math3.util.Incrementor.Incrementor(int,MaxCountExceededCallback)",
    "snippet": "    public Incrementor(int max,\n                       MaxCountExceededCallback cb) {\n        if (cb == null){\n            throw new NullArgumentException();\n        }\n        maximalCount = max;\n        maxCountCallback = cb;\n    }",
    "comment": " Defines a maximal count and a callback method to be triggered at counter exhaustion.  @param max Maximal count. @param cb Function to be called when the maximal count has been reached. @throws NullArgumentException if {@code cb} is {@code null} ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "MathUtils.checkNotNull",
    "class_name": "org.apache.commons.math3.util.MathUtils",
    "signature": "org.apache.commons.math3.util.MathUtils.checkNotNull(Object)",
    "snippet": "    public static void checkNotNull(Object o)\n        throws NullArgumentException {\n        if (o == null) {\n            throw new NullArgumentException();\n        }\n    }",
    "comment": " Checks that an object is not null.  @param o Object to be checked. @throws NullArgumentException if {@code o} is {@code null}. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  }
]