[
  {
    "name": "AbstractContinuousDistribution.AbstractContinuousDistribution",
    "class_name": "org.apache.commons.math.distribution.AbstractContinuousDistribution",
    "signature": "org.apache.commons.math.distribution.AbstractContinuousDistribution.AbstractContinuousDistribution()",
    "snippet": "    protected AbstractContinuousDistribution() {\n        super();\n    }",
    "comment": " Default constructor. ",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "AbstractDistribution.AbstractDistribution",
    "class_name": "org.apache.commons.math.distribution.AbstractDistribution",
    "signature": "org.apache.commons.math.distribution.AbstractDistribution.AbstractDistribution()",
    "snippet": "    protected AbstractDistribution() {\n        super();\n    }",
    "comment": " Default constructor. ",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "TDistributionImpl.TDistributionImpl",
    "class_name": "org.apache.commons.math.distribution.TDistributionImpl",
    "signature": "org.apache.commons.math.distribution.TDistributionImpl.TDistributionImpl(double)",
    "snippet": "    public TDistributionImpl(double degreesOfFreedom) {\n        this(degreesOfFreedom, DEFAULT_INVERSE_ABSOLUTE_ACCURACY);\n    }",
    "comment": " Create a t distribution using the given degrees of freedom. @param degreesOfFreedom the degrees of freedom. ",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "TDistributionImpl.TDistributionImpl",
    "class_name": "org.apache.commons.math.distribution.TDistributionImpl",
    "signature": "org.apache.commons.math.distribution.TDistributionImpl.TDistributionImpl(double,double)",
    "snippet": "    public TDistributionImpl(double degreesOfFreedom, double inverseCumAccuracy) {\n        super();\n        setDegreesOfFreedomInternal(degreesOfFreedom);\n        solverAbsoluteAccuracy = inverseCumAccuracy;\n    }",
    "comment": " Create a t distribution using the given degrees of freedom and the specified inverse cumulative probability absolute accuracy.  @param degreesOfFreedom the degrees of freedom. @param inverseCumAccuracy the maximum absolute error in inverse cumulative probability estimates (defaults to {@link #DEFAULT_INVERSE_ABSOLUTE_ACCURACY}) @since 2.1 ",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "TDistributionImpl.cumulativeProbability",
    "class_name": "org.apache.commons.math.distribution.TDistributionImpl",
    "signature": "org.apache.commons.math.distribution.TDistributionImpl.cumulativeProbability(double)",
    "snippet": "    public double cumulativeProbability(double x) throws MathException{\n        double ret;\n        if (x == 0.0) {\n            ret = 0.5;\n        } else {\n            double t =\n                Beta.regularizedBeta(\n                    degreesOfFreedom / (degreesOfFreedom + (x * x)),\n                    0.5 * degreesOfFreedom,\n                    0.5);\n            if (x < 0.0) {\n                ret = 0.5 * t;\n            } else {\n                ret = 1.0 - 0.5 * t;\n            }\n        }\n\n        return ret;\n    }",
    "comment": " For this distribution, X, this method returns P(X &lt; <code>x</code>). @param x the value at which the CDF is evaluated. @return CDF evaluated at <code>x</code>. @throws MathException if the cumulative probability can not be computed due to convergence or other numerical errors. ",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "TDistributionImpl.setDegreesOfFreedom",
    "class_name": "org.apache.commons.math.distribution.TDistributionImpl",
    "signature": "org.apache.commons.math.distribution.TDistributionImpl.setDegreesOfFreedom(double)",
    "snippet": "    @Deprecated\n    public void setDegreesOfFreedom(double degreesOfFreedom) {\n        setDegreesOfFreedomInternal(degreesOfFreedom);\n    }",
    "comment": " Modify the degrees of freedom. @param degreesOfFreedom the new degrees of freedom. @deprecated as of 2.1 (class will become immutable in 3.0) ",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "TDistributionImpl.setDegreesOfFreedomInternal",
    "class_name": "org.apache.commons.math.distribution.TDistributionImpl",
    "signature": "org.apache.commons.math.distribution.TDistributionImpl.setDegreesOfFreedomInternal(double)",
    "snippet": "    private void setDegreesOfFreedomInternal(double newDegreesOfFreedom) {\n        if (newDegreesOfFreedom <= 0.0) {\n            throw MathRuntimeException.createIllegalArgumentException(\n                  \"degrees of freedom must be positive ({0})\",\n                  newDegreesOfFreedom);\n        }\n        this.degreesOfFreedom = newDegreesOfFreedom;\n    }",
    "comment": " Modify the degrees of freedom. @param newDegreesOfFreedom the new degrees of freedom. ",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "AbstractRealMatrix.AbstractRealMatrix",
    "class_name": "org.apache.commons.math.linear.AbstractRealMatrix",
    "signature": "org.apache.commons.math.linear.AbstractRealMatrix.AbstractRealMatrix(int,int)",
    "snippet": "    protected AbstractRealMatrix(final int rowDimension, final int columnDimension)\n        throws IllegalArgumentException {\n        if (rowDimension <= 0 ) {\n            throw MathRuntimeException.createIllegalArgumentException(\n                    \"invalid row dimension {0} (must be positive)\",\n                    rowDimension);\n        }\n        if (columnDimension <= 0) {\n            throw MathRuntimeException.createIllegalArgumentException(\n                    \"invalid column dimension {0} (must be positive)\",\n                    columnDimension);\n        }\n        lu = null;\n    }",
    "comment": " Create a new RealMatrix with the supplied row and column dimensions.  @param rowDimension  the number of rows in the new matrix @param columnDimension  the number of columns in the new matrix @throws IllegalArgumentException if row or column dimension is not positive ",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "BlockRealMatrix.BlockRealMatrix",
    "class_name": "org.apache.commons.math.linear.BlockRealMatrix",
    "signature": "org.apache.commons.math.linear.BlockRealMatrix.BlockRealMatrix(double[][])",
    "snippet": "    public BlockRealMatrix(final double[][] rawData)\n        throws IllegalArgumentException {\n        this(rawData.length, rawData[0].length, toBlocksLayout(rawData), false);\n    }",
    "comment": " Create a new dense matrix copying entries from raw layout data. <p>The input array <em>must</em> already be in raw layout.</p> <p>Calling this constructor is equivalent to call: <pre>matrix = new BlockRealMatrix(rawData.length, rawData[0].length, toBlocksLayout(rawData), false);</pre> </p> @param rawData data for new matrix, in raw layout  @exception IllegalArgumentException if <code>blockData</code> shape is inconsistent with block layout @see #BlockRealMatrix(int, int, double[][], boolean) ",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "BlockRealMatrix.BlockRealMatrix",
    "class_name": "org.apache.commons.math.linear.BlockRealMatrix",
    "signature": "org.apache.commons.math.linear.BlockRealMatrix.BlockRealMatrix(int,int)",
    "snippet": "    public BlockRealMatrix(final int rows, final int columns)\n        throws IllegalArgumentException {\n\n        super(rows, columns);\n        this.rows    = rows;\n        this.columns = columns;\n\n        // number of blocks\n        blockRows    = (rows    + BLOCK_SIZE - 1) / BLOCK_SIZE;\n        blockColumns = (columns + BLOCK_SIZE - 1) / BLOCK_SIZE;\n\n        // allocate storage blocks, taking care of smaller ones at right and bottom\n        blocks = createBlocksLayout(rows, columns);\n\n    }",
    "comment": " Create a new matrix with the supplied row and column dimensions.  @param rows  the number of rows in the new matrix @param columns  the number of columns in the new matrix @throws IllegalArgumentException if row or column dimension is not positive ",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "BlockRealMatrix.BlockRealMatrix",
    "class_name": "org.apache.commons.math.linear.BlockRealMatrix",
    "signature": "org.apache.commons.math.linear.BlockRealMatrix.BlockRealMatrix(int,int,double[][],boolean)",
    "snippet": "    public BlockRealMatrix(final int rows, final int columns,\n                           final double[][] blockData, final boolean copyArray)\n        throws IllegalArgumentException {\n\n        super(rows, columns);\n        this.rows    = rows;\n        this.columns = columns;\n\n        // number of blocks\n        blockRows    = (rows    + BLOCK_SIZE - 1) / BLOCK_SIZE;\n        blockColumns = (columns + BLOCK_SIZE - 1) / BLOCK_SIZE;\n\n        if (copyArray) {\n            // allocate storage blocks, taking care of smaller ones at right and bottom\n            blocks = new double[blockRows * blockColumns][];\n        } else {\n            // reference existing array\n            blocks = blockData;\n        }\n\n        int index = 0;\n        for (int iBlock = 0; iBlock < blockRows; ++iBlock) {\n            final int iHeight = blockHeight(iBlock);\n            for (int jBlock = 0; jBlock < blockColumns; ++jBlock, ++index) {\n                if (blockData[index].length != iHeight * blockWidth(jBlock)) {\n                    throw MathRuntimeException.createIllegalArgumentException(\n                            \"wrong array shape (block length = {0}, expected {1})\",\n                            blockData[index].length, iHeight * blockWidth(jBlock));\n                }\n                if (copyArray) {\n                    blocks[index] = blockData[index].clone();\n                }\n            }\n        }\n\n    }",
    "comment": " Create a new dense matrix copying entries from block layout data. <p>The input array <em>must</em> already be in blocks layout.</p> @param rows  the number of rows in the new matrix @param columns  the number of columns in the new matrix @param blockData data for new matrix @param copyArray if true, the input array will be copied, otherwise it will be referenced  @exception IllegalArgumentException if <code>blockData</code> shape is inconsistent with block layout @see #createBlocksLayout(int, int) @see #toBlocksLayout(double[][]) @see #BlockRealMatrix(double[][]) ",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "BlockRealMatrix.blockHeight",
    "class_name": "org.apache.commons.math.linear.BlockRealMatrix",
    "signature": "org.apache.commons.math.linear.BlockRealMatrix.blockHeight(int)",
    "snippet": "    private int blockHeight(final int blockRow) {\n        return (blockRow == blockRows - 1) ? rows - blockRow * BLOCK_SIZE : BLOCK_SIZE;\n    }",
    "comment": " Get the height of a block. @param blockRow row index (in block sense) of the block @return height (number of rows) of the block ",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "BlockRealMatrix.blockWidth",
    "class_name": "org.apache.commons.math.linear.BlockRealMatrix",
    "signature": "org.apache.commons.math.linear.BlockRealMatrix.blockWidth(int)",
    "snippet": "    private int blockWidth(final int blockColumn) {\n        return (blockColumn == blockColumns - 1) ? columns - blockColumn * BLOCK_SIZE : BLOCK_SIZE;\n    }",
    "comment": " Get the width of a block. @param blockColumn column index (in block sense) of the block @return width (number of columns) of the block ",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "BlockRealMatrix.createBlocksLayout",
    "class_name": "org.apache.commons.math.linear.BlockRealMatrix",
    "signature": "org.apache.commons.math.linear.BlockRealMatrix.createBlocksLayout(int,int)",
    "snippet": "    public static double[][] createBlocksLayout(final int rows, final int columns) {\n\n        final int blockRows    = (rows    + BLOCK_SIZE - 1) / BLOCK_SIZE;\n        final int blockColumns = (columns + BLOCK_SIZE - 1) / BLOCK_SIZE;\n\n        final double[][] blocks = new double[blockRows * blockColumns][];\n        int blockIndex = 0;\n        for (int iBlock = 0; iBlock < blockRows; ++iBlock) {\n            final int pStart  = iBlock * BLOCK_SIZE;\n            final int pEnd    = Math.min(pStart + BLOCK_SIZE, rows);\n            final int iHeight = pEnd - pStart;\n            for (int jBlock = 0; jBlock < blockColumns; ++jBlock) {\n                final int qStart = jBlock * BLOCK_SIZE;\n                final int qEnd   = Math.min(qStart + BLOCK_SIZE, columns);\n                final int jWidth = qEnd - qStart;\n                blocks[blockIndex] = new double[iHeight * jWidth];\n                ++blockIndex;\n            }\n        }\n\n        return blocks;\n\n    }",
    "comment": " Create a data array in blocks layout. <p> This method can be used to create the array argument of the {@link #BlockRealMatrix(int, int, double[][], boolean)} constructor. </p> @param rows  the number of rows in the new matrix @param columns  the number of columns in the new matrix @return a new data array in blocks layout @see #toBlocksLayout(double[][]) @see #BlockRealMatrix(int, int, double[][], boolean) ",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "BlockRealMatrix.getColumn",
    "class_name": "org.apache.commons.math.linear.BlockRealMatrix",
    "signature": "org.apache.commons.math.linear.BlockRealMatrix.getColumn(int)",
    "snippet": "    @Override\n    public double[] getColumn(final int column)\n        throws MatrixIndexException {\n\n        MatrixUtils.checkColumnIndex(this, column);\n        final double[] out = new double[rows];\n\n        // perform copy block-wise, to ensure good cache behavior\n        final int jBlock  = column / BLOCK_SIZE;\n        final int jColumn = column - jBlock * BLOCK_SIZE;\n        final int jWidth  = blockWidth(jBlock);\n        int outIndex      = 0;\n        for (int iBlock = 0; iBlock < blockRows; ++iBlock) {\n            final int iHeight = blockHeight(iBlock);\n            final double[] block = blocks[iBlock * blockColumns + jBlock];\n            for (int i = 0; i < iHeight; ++i) {\n                out[outIndex++] = block[i * jWidth + jColumn];\n            }\n        }\n\n        return out;\n\n    }",
    "comment": "{@inheritDoc} */",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "BlockRealMatrix.getColumnDimension",
    "class_name": "org.apache.commons.math.linear.BlockRealMatrix",
    "signature": "org.apache.commons.math.linear.BlockRealMatrix.getColumnDimension()",
    "snippet": "    @Override\n    public int getColumnDimension() {\n        return columns;\n    }",
    "comment": "{@inheritDoc} */",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "BlockRealMatrix.getEntry",
    "class_name": "org.apache.commons.math.linear.BlockRealMatrix",
    "signature": "org.apache.commons.math.linear.BlockRealMatrix.getEntry(int,int)",
    "snippet": "    @Override\n    public double getEntry(final int row, final int column)\n        throws MatrixIndexException {\n        try {\n            final int iBlock = row    / BLOCK_SIZE;\n            final int jBlock = column / BLOCK_SIZE;\n            final int k      = (row    - iBlock * BLOCK_SIZE) * blockWidth(jBlock) +\n                               (column - jBlock * BLOCK_SIZE);\n            return blocks[iBlock * blockColumns + jBlock][k];\n        } catch (ArrayIndexOutOfBoundsException e) {\n            throw new MatrixIndexException(\n                    \"no entry at indices ({0}, {1}) in a {2}x{3} matrix\",\n                    row, column, getRowDimension(), getColumnDimension());\n        }\n    }",
    "comment": "{@inheritDoc} */",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "BlockRealMatrix.getRowDimension",
    "class_name": "org.apache.commons.math.linear.BlockRealMatrix",
    "signature": "org.apache.commons.math.linear.BlockRealMatrix.getRowDimension()",
    "snippet": "    @Override\n    public int getRowDimension() {\n        return rows;\n    }",
    "comment": "{@inheritDoc} */",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "BlockRealMatrix.setEntry",
    "class_name": "org.apache.commons.math.linear.BlockRealMatrix",
    "signature": "org.apache.commons.math.linear.BlockRealMatrix.setEntry(int,int,double)",
    "snippet": "    @Override\n    public void setEntry(final int row, final int column, final double value)\n        throws MatrixIndexException {\n        try {\n            final int iBlock = row    / BLOCK_SIZE;\n            final int jBlock = column / BLOCK_SIZE;\n            final int k      = (row    - iBlock * BLOCK_SIZE) * blockWidth(jBlock) +\n                               (column - jBlock * BLOCK_SIZE);\n            blocks[iBlock * blockColumns + jBlock][k] = value;\n        } catch (ArrayIndexOutOfBoundsException e) {\n            throw new MatrixIndexException(\n                    \"no entry at indices ({0}, {1}) in a {2}x{3} matrix\",\n                    row, column, getRowDimension(), getColumnDimension());\n        }\n    }",
    "comment": "{@inheritDoc} */",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "BlockRealMatrix.toBlocksLayout",
    "class_name": "org.apache.commons.math.linear.BlockRealMatrix",
    "signature": "org.apache.commons.math.linear.BlockRealMatrix.toBlocksLayout(double[][])",
    "snippet": "    public static double[][] toBlocksLayout(final double[][] rawData)\n        throws IllegalArgumentException {\n\n        final int rows         = rawData.length;\n        final int columns      = rawData[0].length;\n        final int blockRows    = (rows    + BLOCK_SIZE - 1) / BLOCK_SIZE;\n        final int blockColumns = (columns + BLOCK_SIZE - 1) / BLOCK_SIZE;\n\n        // safety checks\n        for (int i = 0; i < rawData.length; ++i) {\n            final int length = rawData[i].length;\n            if (length != columns) {\n                throw MathRuntimeException.createIllegalArgumentException(\n                        \"some rows have length {0} while others have length {1}\",\n                        columns, length);\n            }\n        }\n\n        // convert array\n        final double[][] blocks = new double[blockRows * blockColumns][];\n        int blockIndex = 0;\n        for (int iBlock = 0; iBlock < blockRows; ++iBlock) {\n            final int pStart  = iBlock * BLOCK_SIZE;\n            final int pEnd    = Math.min(pStart + BLOCK_SIZE, rows);\n            final int iHeight = pEnd - pStart;\n            for (int jBlock = 0; jBlock < blockColumns; ++jBlock) {\n                final int qStart = jBlock * BLOCK_SIZE;\n                final int qEnd   = Math.min(qStart + BLOCK_SIZE, columns);\n                final int jWidth = qEnd - qStart;\n\n                // allocate new block\n                final double[] block = new double[iHeight * jWidth];\n                blocks[blockIndex] = block;\n\n                // copy data\n                int index = 0;\n                for (int p = pStart; p < pEnd; ++p) {\n                    System.arraycopy(rawData[p], qStart, block, index, jWidth);\n                    index += jWidth;\n                }\n\n                ++blockIndex;\n\n            }\n        }\n\n        return blocks;\n\n    }",
    "comment": " Convert a data array from raw layout to blocks layout. <p> Raw layout is the straightforward layout where element at row i and column j is in array element <code>rawData[i][j]</code>. Blocks layout is the layout used in {@link BlockRealMatrix} instances, where the matrix is split in square blocks (except at right and bottom side where blocks may be rectangular to fit matrix size) and each block is stored in a flattened one-dimensional array. </p> <p> This method creates an array in blocks layout from an input array in raw layout. It can be used to provide the array argument of the {@link #BlockRealMatrix(int, int, double[][], boolean)} constructor. </p> @param rawData data array in raw layout @return a new data array containing the same entries but in blocks layout @exception IllegalArgumentException if <code>rawData</code> is not rectangular (not all rows have the same length) @see #createBlocksLayout(int, int) @see #BlockRealMatrix(int, int, double[][], boolean) ",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "MatrixUtils.checkColumnIndex",
    "class_name": "org.apache.commons.math.linear.MatrixUtils",
    "signature": "org.apache.commons.math.linear.MatrixUtils.checkColumnIndex(AnyMatrix,int)",
    "snippet": "    public static void checkColumnIndex(final AnyMatrix m, final int column)\n        throws MatrixIndexException {\n        if (column < 0 || column >= m.getColumnDimension()) {\n            throw new MatrixIndexException(\"column index {0} out of allowed range [{1}, {2}]\",\n                                           column, 0, m.getColumnDimension() - 1);\n        }\n    }",
    "comment": " Check if a column index is valid. @param m matrix containing the submatrix @param column column index to check @exception MatrixIndexException if index is not valid ",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "Beta.logBeta",
    "class_name": "org.apache.commons.math.special.Beta",
    "signature": "org.apache.commons.math.special.Beta.logBeta(double,double,double,int)",
    "snippet": "    public static double logBeta(double a, double b, double epsilon,\n        int maxIterations) {\n\n        double ret;\n\n        if (Double.isNaN(a) || Double.isNaN(b) || (a <= 0.0) || (b <= 0.0)) {\n            ret = Double.NaN;\n        } else {\n            ret = Gamma.logGamma(a) + Gamma.logGamma(b) -\n                Gamma.logGamma(a + b);\n        }\n\n        return ret;\n    }",
    "comment": " Returns the natural logarithm of the beta function B(a, b).  The implementation of this method is based on: <ul> <li><a href=\"http://mathworld.wolfram.com/BetaFunction.html\"> Beta Function</a>, equation (1).</li> </ul>  @param a the a parameter. @param b the b parameter. @param epsilon When the absolute value of the nth item in the series is less than epsilon the approximation ceases to calculate further elements in the series. @param maxIterations Maximum number of \"iterations\" to complete. @return log(B(a, b)) ",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "Beta.regularizedBeta",
    "class_name": "org.apache.commons.math.special.Beta",
    "signature": "org.apache.commons.math.special.Beta.regularizedBeta(double,double,double)",
    "snippet": "    public static double regularizedBeta(double x, double a, double b)\n        throws MathException\n    {\n        return regularizedBeta(x, a, b, DEFAULT_EPSILON, Integer.MAX_VALUE);\n    }",
    "comment": " Returns the <a href=\"http://mathworld.wolfram.com/RegularizedBetaFunction.html\"> regularized beta function</a> I(x, a, b).  @param x the value. @param a the a parameter. @param b the b parameter. @return the regularized beta function I(x, a, b) @throws MathException if the algorithm fails to converge. ",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "Beta.regularizedBeta",
    "class_name": "org.apache.commons.math.special.Beta",
    "signature": "org.apache.commons.math.special.Beta.regularizedBeta(double,double,double,double,int)",
    "snippet": "    public static double regularizedBeta(double x, final double a,\n        final double b, double epsilon, int maxIterations) throws MathException\n    {\n        double ret;\n\n        if (Double.isNaN(x) || Double.isNaN(a) || Double.isNaN(b) || (x < 0) ||\n            (x > 1) || (a <= 0.0) || (b <= 0.0))\n        {\n            ret = Double.NaN;\n        } else if (x > (a + 1.0) / (a + b + 2.0)) {\n            ret = 1.0 - regularizedBeta(1.0 - x, b, a, epsilon, maxIterations);\n        } else {\n            ContinuedFraction fraction = new ContinuedFraction() {\n\n                @Override\n                protected double getB(int n, double x) {\n                    double ret;\n                    double m;\n                    if (n % 2 == 0) { // even\n                        m = n / 2.0;\n                        ret = (m * (b - m) * x) /\n                            ((a + (2 * m) - 1) * (a + (2 * m)));\n                    } else {\n                        m = (n - 1.0) / 2.0;\n                        ret = -((a + m) * (a + b + m) * x) /\n                                ((a + (2 * m)) * (a + (2 * m) + 1.0));\n                    }\n                    return ret;\n                }\n\n                @Override\n                protected double getA(int n, double x) {\n                    return 1.0;\n                }\n            };\n            ret = Math.exp((a * Math.log(x)) + (b * Math.log(1.0 - x)) -\n                Math.log(a) - logBeta(a, b, epsilon, maxIterations)) *\n                1.0 / fraction.evaluate(x, epsilon, maxIterations);\n        }\n\n        return ret;\n    }",
    "comment": " Returns the regularized beta function I(x, a, b).  The implementation of this method is based on: <ul> <li> <a href=\"http://mathworld.wolfram.com/RegularizedBetaFunction.html\"> Regularized Beta Function</a>.</li> <li> <a href=\"http://functions.wolfram.com/06.21.10.0001.01\"> Regularized Beta Function</a>.</li> </ul>  @param x the value. @param a the a parameter. @param b the b parameter. @param epsilon When the absolute value of the nth item in the series is less than epsilon the approximation ceases to calculate further elements in the series. @param maxIterations Maximum number of \"iterations\" to complete. @return the regularized beta function I(x, a, b) @throws MathException if the algorithm fails to converge. ",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "Gamma.logGamma",
    "class_name": "org.apache.commons.math.special.Gamma",
    "signature": "org.apache.commons.math.special.Gamma.logGamma(double)",
    "snippet": "    public static double logGamma(double x) {\n        double ret;\n\n        if (Double.isNaN(x) || (x <= 0.0)) {\n            ret = Double.NaN;\n        } else {\n            double g = 607.0 / 128.0;\n\n            double sum = 0.0;\n            for (int i = LANCZOS.length - 1; i > 0; --i) {\n                sum = sum + (LANCZOS[i] / (x + i));\n            }\n            sum = sum + LANCZOS[0];\n\n            double tmp = x + g + .5;\n            ret = ((x + .5) * Math.log(tmp)) - tmp +\n                HALF_LOG_2_PI + Math.log(sum / x);\n        }\n\n        return ret;\n    }",
    "comment": " Returns the natural logarithm of the gamma function &#915;(x).  The implementation of this method is based on: <ul> <li><a href=\"http://mathworld.wolfram.com/GammaFunction.html\"> Gamma Function</a>, equation (28).</li> <li><a href=\"http://mathworld.wolfram.com/LanczosApproximation.html\"> Lanczos Approximation</a>, equations (1) through (5).</li> <li><a href=\"http://my.fit.edu/~gabdo/gamma.txt\">Paul Godfrey, A note on the computation of the convergent Lanczos complex Gamma approximation </a></li> </ul>  @param x the value. @return log(&#915;(x)) ",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "PearsonsCorrelation.PearsonsCorrelation",
    "class_name": "org.apache.commons.math.stat.correlation.PearsonsCorrelation",
    "signature": "org.apache.commons.math.stat.correlation.PearsonsCorrelation.PearsonsCorrelation(RealMatrix)",
    "snippet": "    public PearsonsCorrelation(RealMatrix matrix) {\n        checkSufficientData(matrix);\n        nObs = matrix.getRowDimension();\n        correlationMatrix = computeCorrelationMatrix(matrix);\n    }",
    "comment": " Create a PearsonsCorrelation from a RealMatrix whose columns represent variables to be correlated.  @param matrix matrix with columns representing variables to correlate ",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "PearsonsCorrelation.PearsonsCorrelation",
    "class_name": "org.apache.commons.math.stat.correlation.PearsonsCorrelation",
    "signature": "org.apache.commons.math.stat.correlation.PearsonsCorrelation.PearsonsCorrelation(double[][])",
    "snippet": "    public PearsonsCorrelation(double[][] data) {\n        this(new BlockRealMatrix(data));\n    }",
    "comment": " Create a PearsonsCorrelation from a rectangular array whose columns represent values of variables to be correlated.  @param data rectangular array with columns representing variables @throws IllegalArgumentException if the input data array is not rectangular with at least two rows and two columns. ",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "PearsonsCorrelation.checkSufficientData",
    "class_name": "org.apache.commons.math.stat.correlation.PearsonsCorrelation",
    "signature": "org.apache.commons.math.stat.correlation.PearsonsCorrelation.checkSufficientData(RealMatrix)",
    "snippet": "    private void checkSufficientData(final RealMatrix matrix) {\n        int nRows = matrix.getRowDimension();\n        int nCols = matrix.getColumnDimension();\n        if (nRows < 2 || nCols < 2) {\n            throw MathRuntimeException.createIllegalArgumentException(\n                    \"insufficient data: only {0} rows and {1} columns.\",\n                    nRows, nCols);\n        }\n    }",
    "comment": " Throws IllegalArgumentException of the matrix does not have at least two columns and two rows  @param matrix matrix to check for sufficiency ",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "PearsonsCorrelation.computeCorrelationMatrix",
    "class_name": "org.apache.commons.math.stat.correlation.PearsonsCorrelation",
    "signature": "org.apache.commons.math.stat.correlation.PearsonsCorrelation.computeCorrelationMatrix(RealMatrix)",
    "snippet": "    public RealMatrix computeCorrelationMatrix(RealMatrix matrix) {\n        int nVars = matrix.getColumnDimension();\n        RealMatrix outMatrix = new BlockRealMatrix(nVars, nVars);\n        for (int i = 0; i < nVars; i++) {\n            for (int j = 0; j < i; j++) {\n              double corr = correlation(matrix.getColumn(i), matrix.getColumn(j));\n              outMatrix.setEntry(i, j, corr);\n              outMatrix.setEntry(j, i, corr);\n            }\n            outMatrix.setEntry(i, i, 1d);\n        }\n        return outMatrix;\n    }",
    "comment": " Computes the correlation matrix for the columns of the input matrix.  @param matrix matrix with columns representing variables to correlate @return correlation matrix ",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "PearsonsCorrelation.correlation",
    "class_name": "org.apache.commons.math.stat.correlation.PearsonsCorrelation",
    "signature": "org.apache.commons.math.stat.correlation.PearsonsCorrelation.correlation(double[],double[])",
    "snippet": "    public double correlation(final double[] xArray, final double[] yArray) throws IllegalArgumentException {\n        SimpleRegression regression = new SimpleRegression();\n        if(xArray.length == yArray.length && xArray.length > 1) {\n            for(int i=0; i<xArray.length; i++) {\n                regression.addData(xArray[i], yArray[i]);\n            }\n            return regression.getR();\n        }\n        else {\n            throw MathRuntimeException.createIllegalArgumentException(\n                    \"invalid array dimensions. xArray has size {0}; yArray has {1} elements\",\n                    xArray.length, yArray.length);\n        }\n    }",
    "comment": " Computes the Pearson's product-moment correlation coefficient between the two arrays.  </p>Throws IllegalArgumentException if the arrays do not have the same length or their common length is less than 2</p>  @param xArray first data array @param yArray second data array @return Returns Pearson's correlation coefficient for the two arrays @throws  IllegalArgumentException if the arrays lengths do not match or there is insufficient data ",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "PearsonsCorrelation.getCorrelationPValues",
    "class_name": "org.apache.commons.math.stat.correlation.PearsonsCorrelation",
    "signature": "org.apache.commons.math.stat.correlation.PearsonsCorrelation.getCorrelationPValues()",
    "snippet": "    public RealMatrix getCorrelationPValues() throws MathException {\n        TDistribution tDistribution = new TDistributionImpl(nObs - 2);\n        int nVars = correlationMatrix.getColumnDimension();\n        double[][] out = new double[nVars][nVars];\n        for (int i = 0; i < nVars; i++) {\n            for (int j = 0; j < nVars; j++) {\n                if (i == j) {\n                    out[i][j] = 0d;\n                } else {\n                    double r = correlationMatrix.getEntry(i, j);\n                    double t = Math.abs(r * Math.sqrt((nObs - 2)/(1 - r * r)));\n                    out[i][j] = 2 * (1 - tDistribution.cumulativeProbability(t));\n                }\n            }\n        }\n        return new BlockRealMatrix(out);\n    }",
    "comment": " Returns a matrix of p-values associated with the (two-sided) null hypothesis that the corresponding correlation coefficient is zero. <p><code>getCorrelationPValues().getEntry(i,j)</code> is the probability that a random variable distributed as <code>t<sub>n-2</sub></code> takes a value with absolute value greater than or equal to <br> <code>|r|((n - 2) / (1 - r<sup>2</sup>))<sup>1/2</sup></code></p> <p>The values in the matrix are sometimes referred to as the <i>significance</i> of the corresponding correlation coefficients.</p>  @return matrix of p-values @throws MathException if an error occurs estimating probabilities ",
    "is_bug": true,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "SimpleRegression.SimpleRegression",
    "class_name": "org.apache.commons.math.stat.regression.SimpleRegression",
    "signature": "org.apache.commons.math.stat.regression.SimpleRegression.SimpleRegression()",
    "snippet": "    public SimpleRegression() {\n        this(new TDistributionImpl(1.0));\n    }",
    "comment": " Create an empty SimpleRegression instance ",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "SimpleRegression.SimpleRegression",
    "class_name": "org.apache.commons.math.stat.regression.SimpleRegression",
    "signature": "org.apache.commons.math.stat.regression.SimpleRegression.SimpleRegression(TDistribution)",
    "snippet": "    public SimpleRegression(TDistribution t) {\n        super();\n        setDistribution(t);\n    }",
    "comment": " Create an empty SimpleRegression using the given distribution object to compute inference statistics. @param t the distribution used to compute inference statistics. @since 1.2 ",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "SimpleRegression.addData",
    "class_name": "org.apache.commons.math.stat.regression.SimpleRegression",
    "signature": "org.apache.commons.math.stat.regression.SimpleRegression.addData(double,double)",
    "snippet": "    public void addData(double x, double y) {\n        if (n == 0) {\n            xbar = x;\n            ybar = y;\n        } else {\n            double dx = x - xbar;\n            double dy = y - ybar;\n            sumXX += dx * dx * (double) n / (n + 1d);\n            sumYY += dy * dy * (double) n / (n + 1d);\n            sumXY += dx * dy * (double) n / (n + 1d);\n            xbar += dx / (n + 1.0);\n            ybar += dy / (n + 1.0);\n        }\n        sumX += x;\n        sumY += y;\n        n++;\n\n        if (n > 2) {\n            distribution.setDegreesOfFreedom(n - 2);\n        }\n    }",
    "comment": " Adds the observation (x,y) to the regression data set. <p> Uses updating formulas for means and sums of squares defined in \"Algorithms for Computing the Sample Variance: Analysis and Recommendations\", Chan, T.F., Golub, G.H., and LeVeque, R.J. 1983, American Statistician, vol. 37, pp. 242-247, referenced in Weisberg, S. \"Applied Linear Regression\". 2nd Ed. 1985.</p>   @param x independent variable value @param y dependent variable value ",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "SimpleRegression.getR",
    "class_name": "org.apache.commons.math.stat.regression.SimpleRegression",
    "signature": "org.apache.commons.math.stat.regression.SimpleRegression.getR()",
    "snippet": "    public double getR() {\n        double b1 = getSlope();\n        double result = Math.sqrt(getRSquare());\n        if (b1 < 0) {\n            result = -result;\n        }\n        return result;\n    }",
    "comment": " Returns <a href=\"http://mathworld.wolfram.com/CorrelationCoefficient.html\"> Pearson's product moment correlation coefficient</a>, usually denoted r. <p> <strong>Preconditions</strong>: <ul> <li>At least two observations (with at least two different x values) must have been added before invoking this method. If this method is invoked before a model can be estimated, <code>Double,NaN</code> is returned. </li></ul></p>  @return Pearson's r ",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "SimpleRegression.getRSquare",
    "class_name": "org.apache.commons.math.stat.regression.SimpleRegression",
    "signature": "org.apache.commons.math.stat.regression.SimpleRegression.getRSquare()",
    "snippet": "    public double getRSquare() {\n        double ssto = getTotalSumSquares();\n        return (ssto - getSumSquaredErrors()) / ssto;\n    }",
    "comment": " Returns the <a href=\"http://www.xycoon.com/coefficient1.htm\"> coefficient of determination</a>, usually denoted r-square. <p> <strong>Preconditions</strong>: <ul> <li>At least two observations (with at least two different x values) must have been added before invoking this method. If this method is invoked before a model can be estimated, <code>Double,NaN</code> is returned. </li></ul></p>  @return r-square ",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "SimpleRegression.getSlope",
    "class_name": "org.apache.commons.math.stat.regression.SimpleRegression",
    "signature": "org.apache.commons.math.stat.regression.SimpleRegression.getSlope()",
    "snippet": "    public double getSlope() {\n        if (n < 2) {\n            return Double.NaN; //not enough data\n        }\n        if (Math.abs(sumXX) < 10 * Double.MIN_VALUE) {\n            return Double.NaN; //not enough variation in x\n        }\n        return sumXY / sumXX;\n    }",
    "comment": " Returns the slope of the estimated regression line. <p> The least squares estimate of the slope is computed using the <a href=\"http://www.xycoon.com/estimation4.htm\">normal equations</a>. The slope is sometimes denoted b1.</p> <p> <strong>Preconditions</strong>: <ul> <li>At least two observations (with at least two different x values) must have been added before invoking this method. If this method is invoked before a model can be estimated, <code>Double.NaN</code> is returned. </li></ul></p>  @return the slope of the regression line ",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "SimpleRegression.getSumSquaredErrors",
    "class_name": "org.apache.commons.math.stat.regression.SimpleRegression",
    "signature": "org.apache.commons.math.stat.regression.SimpleRegression.getSumSquaredErrors()",
    "snippet": "    public double getSumSquaredErrors() {\n        return Math.max(0d, sumYY - sumXY * sumXY / sumXX);\n    }",
    "comment": " Returns the <a href=\"http://www.xycoon.com/SumOfSquares.htm\"> sum of squared errors</a> (SSE) associated with the regression model. <p> The sum is computed using the computational formula</p> <p> <code>SSE = SYY - (SXY * SXY / SXX)</code></p> <p> where <code>SYY</code> is the sum of the squared deviations of the y values about their mean, <code>SXX</code> is similarly defined and <code>SXY</code> is the sum of the products of x and y mean deviations. </p><p> The sums are accumulated using the updating algorithm referenced in {@link #addData}.</p> <p> The return value is constrained to be non-negative - i.e., if due to rounding errors the computational formula returns a negative result, 0 is returned.</p> <p> <strong>Preconditions</strong>: <ul> <li>At least two observations (with at least two different x values) must have been added before invoking this method. If this method is invoked before a model can be estimated, <code>Double,NaN</code> is returned. </li></ul></p>  @return sum of squared errors associated with the regression model ",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "SimpleRegression.getTotalSumSquares",
    "class_name": "org.apache.commons.math.stat.regression.SimpleRegression",
    "signature": "org.apache.commons.math.stat.regression.SimpleRegression.getTotalSumSquares()",
    "snippet": "    public double getTotalSumSquares() {\n        if (n < 2) {\n            return Double.NaN;\n        }\n        return sumYY;\n    }",
    "comment": " Returns the sum of squared deviations of the y values about their mean. <p> This is defined as SSTO <a href=\"http://www.xycoon.com/SumOfSquares.htm\">here</a>.</p> <p> If <code>n < 2</code>, this returns <code>Double.NaN</code>.</p>  @return sum of squared deviations of y values ",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "SimpleRegression.setDistribution",
    "class_name": "org.apache.commons.math.stat.regression.SimpleRegression",
    "signature": "org.apache.commons.math.stat.regression.SimpleRegression.setDistribution(TDistribution)",
    "snippet": "    public void setDistribution(TDistribution value) {\n        distribution = value;\n\n        // modify degrees of freedom\n        if (n > 2) {\n            distribution.setDegreesOfFreedom(n - 2);\n        }\n    }",
    "comment": " Modify the distribution used to compute inference statistics. @param value the new distribution @since 1.2 ",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "ContinuedFraction.ContinuedFraction",
    "class_name": "org.apache.commons.math.util.ContinuedFraction",
    "signature": "org.apache.commons.math.util.ContinuedFraction.ContinuedFraction()",
    "snippet": "    protected ContinuedFraction() {\n        super();\n    }",
    "comment": " Default constructor. ",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "ContinuedFraction.evaluate",
    "class_name": "org.apache.commons.math.util.ContinuedFraction",
    "signature": "org.apache.commons.math.util.ContinuedFraction.evaluate(double,double,int)",
    "snippet": "    public double evaluate(double x, double epsilon, int maxIterations)\n        throws MathException\n    {\n        double p0 = 1.0;\n        double p1 = getA(0, x);\n        double q0 = 0.0;\n        double q1 = 1.0;\n        double c = p1 / q1;\n        int n = 0;\n        double relativeError = Double.MAX_VALUE;\n        while (n < maxIterations && relativeError > epsilon) {\n            ++n;\n            double a = getA(n, x);\n            double b = getB(n, x);\n            double p2 = a * p1 + b * p0;\n            double q2 = a * q1 + b * q0;\n            boolean infinite = false;\n            if (Double.isInfinite(p2) || Double.isInfinite(q2)) {\n                /*\n                 * Need to scale. Try successive powers of the larger of a or b\n                 * up to 5th power. Throw ConvergenceException if one or both\n                 * of p2, q2 still overflow.\n                 */\n                double scaleFactor = 1d;\n                double lastScaleFactor = 1d;\n                final int maxPower = 5;\n                final double scale = Math.max(a,b);\n                if (scale <= 0) {  // Can't scale\n                    throw new ConvergenceException(\n                            \"Continued fraction convergents diverged to +/- infinity for value {0}\",\n                             x);\n                }\n                infinite = true;\n                for (int i = 0; i < maxPower; i++) {\n                    lastScaleFactor = scaleFactor;\n                    scaleFactor *= scale;\n                    if (a != 0.0 && a > b) {\n                        p2 = p1 / lastScaleFactor + (b / scaleFactor * p0);\n                        q2 = q1 / lastScaleFactor + (b / scaleFactor * q0);\n                    } else if (b != 0) {\n                        p2 = (a / scaleFactor * p1) + p0 / lastScaleFactor;\n                        q2 = (a / scaleFactor * q1) + q0 / lastScaleFactor;\n                    }\n                    infinite = Double.isInfinite(p2) || Double.isInfinite(q2);\n                    if (!infinite) {\n                        break;\n                    }\n                }\n            }\n\n            if (infinite) {\n               // Scaling failed\n               throw new ConvergenceException(\n                 \"Continued fraction convergents diverged to +/- infinity for value {0}\",\n                  x);\n            }\n\n            double r = p2 / q2;\n\n            if (Double.isNaN(r)) {\n                throw new ConvergenceException(\n                  \"Continued fraction diverged to NaN for value {0}\",\n                  x);\n            }\n            relativeError = Math.abs(r / c - 1.0);\n\n            // prepare for next iteration\n            c = p2 / q2;\n            p0 = p1;\n            p1 = p2;\n            q0 = q1;\n            q1 = q2;\n        }\n\n        if (n >= maxIterations) {\n            throw new MaxIterationsExceededException(maxIterations,\n                \"Continued fraction convergents failed to converge for value {0}\",\n                x);\n        }\n\n        return c;\n    }",
    "comment": " <p> Evaluates the continued fraction at the value x. </p>  <p> The implementation of this method is based on equations 14-17 of: <ul> <li> Eric W. Weisstein. \"Continued Fraction.\" From MathWorld--A Wolfram Web Resource. <a target=\"_blank\" href=\"http://mathworld.wolfram.com/ContinuedFraction.html\"> http://mathworld.wolfram.com/ContinuedFraction.html</a> </li> </ul> The recurrence relationship defined in those equations can result in very large intermediate results which can result in numerical overflow. As a means to combat these overflow conditions, the intermediate results are scaled whenever they threaten to become numerically unstable.</p>  @param x the evaluation point. @param epsilon maximum error allowed. @param maxIterations maximum number of convergents @return the value of the continued fraction evaluated at x. @throws MathException if the algorithm fails to converge. ",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  }
]