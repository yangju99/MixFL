[
  {
    "name": "AbstractMultivariateRealDistribution.AbstractMultivariateRealDistribution",
    "class_name": "org.apache.commons.math3.distribution.AbstractMultivariateRealDistribution",
    "signature": "org.apache.commons.math3.distribution.AbstractMultivariateRealDistribution.AbstractMultivariateRealDistribution(RandomGenerator,int)",
    "snippet": "    protected AbstractMultivariateRealDistribution(RandomGenerator rng,\n                                                   int n) {\n        random = rng;\n        dimension = n;\n    }",
    "comment": " @param rng Random number generator. @param n Number of dimensions. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "AbstractMultivariateRealDistribution.getDimension",
    "class_name": "org.apache.commons.math3.distribution.AbstractMultivariateRealDistribution",
    "signature": "org.apache.commons.math3.distribution.AbstractMultivariateRealDistribution.getDimension()",
    "snippet": "    public int getDimension() {\n        return dimension;\n    }",
    "comment": "{@inheritDoc} */",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "AbstractRealDistribution.AbstractRealDistribution",
    "class_name": "org.apache.commons.math3.distribution.AbstractRealDistribution",
    "signature": "org.apache.commons.math3.distribution.AbstractRealDistribution.AbstractRealDistribution(RandomGenerator)",
    "snippet": "    protected AbstractRealDistribution(RandomGenerator rng) {\n        random = rng;\n    }",
    "comment": " @param rng Random number generator. @since 3.1 ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "MultivariateNormalDistribution.MultivariateNormalDistribution",
    "class_name": "org.apache.commons.math3.distribution.MultivariateNormalDistribution",
    "signature": "org.apache.commons.math3.distribution.MultivariateNormalDistribution.MultivariateNormalDistribution(RandomGenerator,double[],double[][])",
    "snippet": "    public MultivariateNormalDistribution(RandomGenerator rng,\n                                          final double[] means,\n                                          final double[][] covariances)\n            throws SingularMatrixException,\n                   DimensionMismatchException,\n                   NonPositiveDefiniteMatrixException {\n        super(rng, means.length);\n\n        final int dim = means.length;\n\n        if (covariances.length != dim) {\n            throw new DimensionMismatchException(covariances.length, dim);\n        }\n\n        for (int i = 0; i < dim; i++) {\n            if (dim != covariances[i].length) {\n                throw new DimensionMismatchException(covariances[i].length, dim);\n            }\n        }\n\n        this.means = MathArrays.copyOf(means);\n\n        covarianceMatrix = new Array2DRowRealMatrix(covariances);\n\n        // Covariance matrix eigen decomposition.\n        final EigenDecomposition covMatDec = new EigenDecomposition(covarianceMatrix);\n\n        // Compute and store the inverse.\n        covarianceMatrixInverse = covMatDec.getSolver().getInverse();\n        // Compute and store the determinant.\n        covarianceMatrixDeterminant = covMatDec.getDeterminant();\n\n        // Eigenvalues of the covariance matrix.\n        final double[] covMatEigenvalues = covMatDec.getRealEigenvalues();\n\n        for (int i = 0; i < covMatEigenvalues.length; i++) {\n            if (covMatEigenvalues[i] < 0) {\n                throw new NonPositiveDefiniteMatrixException(covMatEigenvalues[i], i, 0);\n            }\n        }\n\n        // Matrix where each column is an eigenvector of the covariance matrix.\n        final Array2DRowRealMatrix covMatEigenvectors = new Array2DRowRealMatrix(dim, dim);\n        for (int v = 0; v < dim; v++) {\n            final double[] evec = covMatDec.getEigenvector(v).toArray();\n            covMatEigenvectors.setColumn(v, evec);\n        }\n\n        final RealMatrix tmpMatrix = covMatEigenvectors.transpose();\n\n        // Scale each eigenvector by the square root of its eigenvalue.\n        for (int row = 0; row < dim; row++) {\n            final double factor = FastMath.sqrt(covMatEigenvalues[row]);\n            for (int col = 0; col < dim; col++) {\n                tmpMatrix.multiplyEntry(row, col, factor);\n            }\n        }\n\n        samplingMatrix = covMatEigenvectors.multiply(tmpMatrix);\n    }",
    "comment": " Creates a multivariate normal distribution with the given mean vector and covariance matrix. <br/> The number of dimensions is equal to the length of the mean vector and to the number of rows and columns of the covariance matrix. It is frequently written as \"p\" in formulae.  @param rng Random Number Generator. @param means Vector of means. @param covariances Covariance matrix. @throws DimensionMismatchException if the arrays length are inconsistent. @throws SingularMatrixException if the eigenvalue decomposition cannot be performed on the provided covariance matrix. @throws NonPositiveDefiniteMatrixException if any of the eigenvalues is negative. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "MultivariateNormalDistribution.MultivariateNormalDistribution",
    "class_name": "org.apache.commons.math3.distribution.MultivariateNormalDistribution",
    "signature": "org.apache.commons.math3.distribution.MultivariateNormalDistribution.MultivariateNormalDistribution(double[],double[][])",
    "snippet": "    public MultivariateNormalDistribution(final double[] means,\n                                          final double[][] covariances)\n        throws SingularMatrixException,\n               DimensionMismatchException,\n               NonPositiveDefiniteMatrixException {\n        this(new Well19937c(), means, covariances);\n    }",
    "comment": " Creates a multivariate normal distribution with the given mean vector and covariance matrix. <br/> The number of dimensions is equal to the length of the mean vector and to the number of rows and columns of the covariance matrix. It is frequently written as \"p\" in formulae.  @param means Vector of means. @param covariances Covariance matrix. @throws DimensionMismatchException if the arrays length are inconsistent. @throws SingularMatrixException if the eigenvalue decomposition cannot be performed on the provided covariance matrix. @throws NonPositiveDefiniteMatrixException if any of the eigenvalues is negative. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "MultivariateNormalDistribution.density",
    "class_name": "org.apache.commons.math3.distribution.MultivariateNormalDistribution",
    "signature": "org.apache.commons.math3.distribution.MultivariateNormalDistribution.density(double[])",
    "snippet": "    public double density(final double[] vals) throws DimensionMismatchException {\n        final int dim = getDimension();\n        if (vals.length != dim) {\n            throw new DimensionMismatchException(vals.length, dim);\n        }\n\n        return FastMath.pow(2 * FastMath.PI, -dim / 2) *\n            FastMath.pow(covarianceMatrixDeterminant, -0.5) *\n            getExponentTerm(vals);\n    }",
    "comment": "{@inheritDoc} */",
    "is_bug": true,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "MultivariateNormalDistribution.getExponentTerm",
    "class_name": "org.apache.commons.math3.distribution.MultivariateNormalDistribution",
    "signature": "org.apache.commons.math3.distribution.MultivariateNormalDistribution.getExponentTerm(double[])",
    "snippet": "    private double getExponentTerm(final double[] values) {\n        final double[] centered = new double[values.length];\n        for (int i = 0; i < centered.length; i++) {\n            centered[i] = values[i] - getMeans()[i];\n        }\n        final double[] preMultiplied = covarianceMatrixInverse.preMultiply(centered);\n        double sum = 0;\n        for (int i = 0; i < preMultiplied.length; i++) {\n            sum += preMultiplied[i] * centered[i];\n        }\n        return FastMath.exp(-0.5 * sum);\n    }",
    "comment": " Computes the term used in the exponent (see definition of the distribution).  @param values Values at which to compute density. @return the multiplication factor of density calculations. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "MultivariateNormalDistribution.getMeans",
    "class_name": "org.apache.commons.math3.distribution.MultivariateNormalDistribution",
    "signature": "org.apache.commons.math3.distribution.MultivariateNormalDistribution.getMeans()",
    "snippet": "    public double[] getMeans() {\n        return MathArrays.copyOf(means);\n    }",
    "comment": " Gets the mean vector.  @return the mean vector. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "NormalDistribution.NormalDistribution",
    "class_name": "org.apache.commons.math3.distribution.NormalDistribution",
    "signature": "org.apache.commons.math3.distribution.NormalDistribution.NormalDistribution(RandomGenerator,double,double,double)",
    "snippet": "    public NormalDistribution(RandomGenerator rng,\n                              double mean,\n                              double sd,\n                              double inverseCumAccuracy)\n        throws NotStrictlyPositiveException {\n        super(rng);\n\n        if (sd <= 0) {\n            throw new NotStrictlyPositiveException(LocalizedFormats.STANDARD_DEVIATION, sd);\n        }\n\n        this.mean = mean;\n        standardDeviation = sd;\n        solverAbsoluteAccuracy = inverseCumAccuracy;\n    }",
    "comment": " Creates a normal distribution.  @param rng Random number generator. @param mean Mean for this distribution. @param sd Standard deviation for this distribution. @param inverseCumAccuracy Inverse cumulative probability accuracy. @throws NotStrictlyPositiveException if {@code sd <= 0}. @since 3.1 ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "NormalDistribution.NormalDistribution",
    "class_name": "org.apache.commons.math3.distribution.NormalDistribution",
    "signature": "org.apache.commons.math3.distribution.NormalDistribution.NormalDistribution(double,double)",
    "snippet": "    public NormalDistribution(double mean, double sd)\n        throws NotStrictlyPositiveException {\n        this(mean, sd, DEFAULT_INVERSE_ABSOLUTE_ACCURACY);\n    }",
    "comment": " Create a normal distribution using the given mean and standard deviation.  @param mean Mean for this distribution. @param sd Standard deviation for this distribution. @throws NotStrictlyPositiveException if {@code sd <= 0}. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "NormalDistribution.NormalDistribution",
    "class_name": "org.apache.commons.math3.distribution.NormalDistribution",
    "signature": "org.apache.commons.math3.distribution.NormalDistribution.NormalDistribution(double,double,double)",
    "snippet": "    public NormalDistribution(double mean, double sd, double inverseCumAccuracy)\n        throws NotStrictlyPositiveException {\n        this(new Well19937c(), mean, sd, inverseCumAccuracy);\n    }",
    "comment": " Create a normal distribution using the given mean, standard deviation and inverse cumulative distribution accuracy.  @param mean Mean for this distribution. @param sd Standard deviation for this distribution. @param inverseCumAccuracy Inverse cumulative probability accuracy. @throws NotStrictlyPositiveException if {@code sd <= 0}. @since 2.1 ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "NormalDistribution.density",
    "class_name": "org.apache.commons.math3.distribution.NormalDistribution",
    "signature": "org.apache.commons.math3.distribution.NormalDistribution.density(double)",
    "snippet": "    public double density(double x) {\n        final double x0 = x - mean;\n        final double x1 = x0 / standardDeviation;\n        return FastMath.exp(-0.5 * x1 * x1) / (standardDeviation * SQRT2PI);\n    }",
    "comment": "{@inheritDoc} */",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "AbstractRealMatrix.AbstractRealMatrix",
    "class_name": "org.apache.commons.math3.linear.AbstractRealMatrix",
    "signature": "org.apache.commons.math3.linear.AbstractRealMatrix.AbstractRealMatrix()",
    "snippet": "    protected AbstractRealMatrix() {}",
    "comment": " Creates a matrix with no data ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "AbstractRealMatrix.AbstractRealMatrix",
    "class_name": "org.apache.commons.math3.linear.AbstractRealMatrix",
    "signature": "org.apache.commons.math3.linear.AbstractRealMatrix.AbstractRealMatrix(int,int)",
    "snippet": "    protected AbstractRealMatrix(final int rowDimension,\n        final int columnDimension)\n        throws NotStrictlyPositiveException {\n        if (rowDimension < 1) {\n            throw new NotStrictlyPositiveException(rowDimension);\n        }\n        if (columnDimension < 1) {\n            throw new NotStrictlyPositiveException(columnDimension);\n        }\n    }",
    "comment": " Create a new RealMatrix with the supplied row and column dimensions.  @param rowDimension  the number of rows in the new matrix @param columnDimension  the number of columns in the new matrix @throws NotStrictlyPositiveException if row or column dimension is not positive ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "AbstractRealMatrix.isSquare",
    "class_name": "org.apache.commons.math3.linear.AbstractRealMatrix",
    "signature": "org.apache.commons.math3.linear.AbstractRealMatrix.isSquare()",
    "snippet": "    public boolean isSquare() {\n        return getColumnDimension() == getRowDimension();\n    }",
    "comment": "{@inheritDoc} */",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "AbstractRealMatrix.multiply",
    "class_name": "org.apache.commons.math3.linear.AbstractRealMatrix",
    "signature": "org.apache.commons.math3.linear.AbstractRealMatrix.multiply(RealMatrix)",
    "snippet": "    public RealMatrix multiply(final RealMatrix m)\n        throws DimensionMismatchException {\n        MatrixUtils.checkMultiplicationCompatible(this, m);\n\n        final int nRows = getRowDimension();\n        final int nCols = m.getColumnDimension();\n        final int nSum  = getColumnDimension();\n        final RealMatrix out = createMatrix(nRows, nCols);\n        for (int row = 0; row < nRows; ++row) {\n            for (int col = 0; col < nCols; ++col) {\n                double sum = 0;\n                for (int i = 0; i < nSum; ++i) {\n                    sum += getEntry(row, i) * m.getEntry(i, col);\n                }\n                out.setEntry(row, col, sum);\n            }\n        }\n\n        return out;\n    }",
    "comment": "{@inheritDoc} */",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "AbstractRealMatrix.setColumn",
    "class_name": "org.apache.commons.math3.linear.AbstractRealMatrix",
    "signature": "org.apache.commons.math3.linear.AbstractRealMatrix.setColumn(int,double[])",
    "snippet": "    public void setColumn(final int column, final double[] array)\n        throws OutOfRangeException, MatrixDimensionMismatchException {\n        MatrixUtils.checkColumnIndex(this, column);\n        final int nRows = getRowDimension();\n        if (array.length != nRows) {\n            throw new MatrixDimensionMismatchException(array.length, 1, nRows, 1);\n        }\n        for (int i = 0; i < nRows; ++i) {\n            setEntry(i, column, array[i]);\n        }\n    }",
    "comment": "{@inheritDoc} */",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "AbstractRealMatrix.transpose",
    "class_name": "org.apache.commons.math3.linear.AbstractRealMatrix",
    "signature": "org.apache.commons.math3.linear.AbstractRealMatrix.transpose()",
    "snippet": "    public RealMatrix transpose() {\n        final int nRows = getRowDimension();\n        final int nCols = getColumnDimension();\n        final RealMatrix out = createMatrix(nCols, nRows);\n        walkInOptimizedOrder(new DefaultRealMatrixPreservingVisitor() {\n\n            /** {@inheritDoc} */\n            @Override\n            public void visit(final int row, final int column, final double value) {\n                out.setEntry(column, row, value);\n            }\n\n        });\n\n        return out;\n    }",
    "comment": "{@inheritDoc} */",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "AbstractRealMatrix.walkInOptimizedOrder",
    "class_name": "org.apache.commons.math3.linear.AbstractRealMatrix",
    "signature": "org.apache.commons.math3.linear.AbstractRealMatrix.walkInOptimizedOrder(RealMatrixPreservingVisitor)",
    "snippet": "    public double walkInOptimizedOrder(final RealMatrixPreservingVisitor visitor) {\n        return walkInRowOrder(visitor);\n    }",
    "comment": "{@inheritDoc} */",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "Array2DRowRealMatrix.Array2DRowRealMatrix",
    "class_name": "org.apache.commons.math3.linear.Array2DRowRealMatrix",
    "signature": "org.apache.commons.math3.linear.Array2DRowRealMatrix.Array2DRowRealMatrix(double[][])",
    "snippet": "    public Array2DRowRealMatrix(final double[][] d)\n        throws DimensionMismatchException, NoDataException, NullArgumentException {\n        copyIn(d);\n    }",
    "comment": " Create a new {@code RealMatrix} using the input array as the underlying data array. <p>The input array is copied, not referenced. This constructor has the same effect as calling {@link #Array2DRowRealMatrix(double[][], boolean)} with the second argument set to {@code true}.</p>  @param d Data for the new matrix. @throws DimensionMismatchException if {@code d} is not rectangular. @throws NoDataException if {@code d} row or colum dimension is zero. @throws NullArgumentException if {@code d} is {@code null}. @see #Array2DRowRealMatrix(double[][], boolean) ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "Array2DRowRealMatrix.Array2DRowRealMatrix",
    "class_name": "org.apache.commons.math3.linear.Array2DRowRealMatrix",
    "signature": "org.apache.commons.math3.linear.Array2DRowRealMatrix.Array2DRowRealMatrix(int,int)",
    "snippet": "    public Array2DRowRealMatrix(final int rowDimension,\n                                final int columnDimension)\n        throws NotStrictlyPositiveException {\n        super(rowDimension, columnDimension);\n        data = new double[rowDimension][columnDimension];\n    }",
    "comment": " Create a new RealMatrix with the supplied row and column dimensions.  @param rowDimension Number of rows in the new matrix. @param columnDimension Number of columns in the new matrix. @throws NotStrictlyPositiveException if the row or column dimension is not positive. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "Array2DRowRealMatrix.copyIn",
    "class_name": "org.apache.commons.math3.linear.Array2DRowRealMatrix",
    "signature": "org.apache.commons.math3.linear.Array2DRowRealMatrix.copyIn(double[][])",
    "snippet": "    private void copyIn(final double[][] in)\n        throws DimensionMismatchException, NoDataException, NullArgumentException {\n        setSubMatrix(in, 0, 0);\n    }",
    "comment": " Replace data with a fresh copy of the input array.  @param in Data to copy. @throws NoDataException if the input array is empty. @throws DimensionMismatchException if the input array is not rectangular. @throws NullArgumentException if the input array is {@code null}. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "Array2DRowRealMatrix.copyOut",
    "class_name": "org.apache.commons.math3.linear.Array2DRowRealMatrix",
    "signature": "org.apache.commons.math3.linear.Array2DRowRealMatrix.copyOut()",
    "snippet": "    private double[][] copyOut() {\n        final int nRows = this.getRowDimension();\n        final double[][] out = new double[nRows][this.getColumnDimension()];\n        // can't copy 2-d array in one shot, otherwise get row references\n        for (int i = 0; i < nRows; i++) {\n            System.arraycopy(data[i], 0, out[i], 0, data[i].length);\n        }\n        return out;\n    }",
    "comment": " Get a fresh copy of the underlying data array.  @return a copy of the underlying data array. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "Array2DRowRealMatrix.createMatrix",
    "class_name": "org.apache.commons.math3.linear.Array2DRowRealMatrix",
    "signature": "org.apache.commons.math3.linear.Array2DRowRealMatrix.createMatrix(int,int)",
    "snippet": "    @Override\n    public RealMatrix createMatrix(final int rowDimension,\n                                   final int columnDimension)\n        throws NotStrictlyPositiveException {\n        return new Array2DRowRealMatrix(rowDimension, columnDimension);\n    }",
    "comment": "{@inheritDoc} */",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "Array2DRowRealMatrix.getColumnDimension",
    "class_name": "org.apache.commons.math3.linear.Array2DRowRealMatrix",
    "signature": "org.apache.commons.math3.linear.Array2DRowRealMatrix.getColumnDimension()",
    "snippet": "    @Override\n    public int getColumnDimension() {\n        return ((data == null) || (data[0] == null)) ? 0 : data[0].length;\n    }",
    "comment": "{@inheritDoc} */",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "Array2DRowRealMatrix.getData",
    "class_name": "org.apache.commons.math3.linear.Array2DRowRealMatrix",
    "signature": "org.apache.commons.math3.linear.Array2DRowRealMatrix.getData()",
    "snippet": "    @Override\n    public double[][] getData() {\n        return copyOut();\n    }",
    "comment": "{@inheritDoc} */",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "Array2DRowRealMatrix.getEntry",
    "class_name": "org.apache.commons.math3.linear.Array2DRowRealMatrix",
    "signature": "org.apache.commons.math3.linear.Array2DRowRealMatrix.getEntry(int,int)",
    "snippet": "    @Override\n    public double getEntry(final int row, final int column)\n        throws OutOfRangeException {\n        MatrixUtils.checkMatrixIndex(this, row, column);\n        return data[row][column];\n    }",
    "comment": "{@inheritDoc} */",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "Array2DRowRealMatrix.getRowDimension",
    "class_name": "org.apache.commons.math3.linear.Array2DRowRealMatrix",
    "signature": "org.apache.commons.math3.linear.Array2DRowRealMatrix.getRowDimension()",
    "snippet": "    @Override\n    public int getRowDimension() {\n        return (data == null) ? 0 : data.length;\n    }",
    "comment": "{@inheritDoc} */",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "Array2DRowRealMatrix.multiplyEntry",
    "class_name": "org.apache.commons.math3.linear.Array2DRowRealMatrix",
    "signature": "org.apache.commons.math3.linear.Array2DRowRealMatrix.multiplyEntry(int,int,double)",
    "snippet": "    @Override\n    public void multiplyEntry(final int row, final int column,\n                              final double factor)\n        throws OutOfRangeException {\n        MatrixUtils.checkMatrixIndex(this, row, column);\n        data[row][column] *= factor;\n    }",
    "comment": "{@inheritDoc} */",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "Array2DRowRealMatrix.preMultiply",
    "class_name": "org.apache.commons.math3.linear.Array2DRowRealMatrix",
    "signature": "org.apache.commons.math3.linear.Array2DRowRealMatrix.preMultiply(double[])",
    "snippet": "    @Override\n    public double[] preMultiply(final double[] v)\n        throws DimensionMismatchException {\n        final int nRows = getRowDimension();\n        final int nCols = getColumnDimension();\n        if (v.length != nRows) {\n            throw new DimensionMismatchException(v.length, nRows);\n        }\n\n        final double[] out = new double[nCols];\n        for (int col = 0; col < nCols; ++col) {\n            double sum = 0;\n            for (int i = 0; i < nRows; ++i) {\n                sum += data[i][col] * v[i];\n            }\n            out[col] = sum;\n        }\n\n        return out;\n\n    }",
    "comment": "{@inheritDoc} */",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "Array2DRowRealMatrix.setEntry",
    "class_name": "org.apache.commons.math3.linear.Array2DRowRealMatrix",
    "signature": "org.apache.commons.math3.linear.Array2DRowRealMatrix.setEntry(int,int,double)",
    "snippet": "    @Override\n    public void setEntry(final int row, final int column, final double value)\n        throws OutOfRangeException {\n        MatrixUtils.checkMatrixIndex(this, row, column);\n        data[row][column] = value;\n    }",
    "comment": "{@inheritDoc} */",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "Array2DRowRealMatrix.setSubMatrix",
    "class_name": "org.apache.commons.math3.linear.Array2DRowRealMatrix",
    "signature": "org.apache.commons.math3.linear.Array2DRowRealMatrix.setSubMatrix(double[][],int,int)",
    "snippet": "    @Override\n    public void setSubMatrix(final double[][] subMatrix, final int row,\n                             final int column)\n        throws NoDataException, OutOfRangeException,\n        DimensionMismatchException, NullArgumentException {\n        if (data == null) {\n            if (row > 0) {\n                throw new MathIllegalStateException(LocalizedFormats.FIRST_ROWS_NOT_INITIALIZED_YET, row);\n            }\n            if (column > 0) {\n                throw new MathIllegalStateException(LocalizedFormats.FIRST_COLUMNS_NOT_INITIALIZED_YET, column);\n            }\n            MathUtils.checkNotNull(subMatrix);\n            final int nRows = subMatrix.length;\n            if (nRows == 0) {\n                throw new NoDataException(LocalizedFormats.AT_LEAST_ONE_ROW);\n            }\n\n            final int nCols = subMatrix[0].length;\n            if (nCols == 0) {\n                throw new NoDataException(LocalizedFormats.AT_LEAST_ONE_COLUMN);\n            }\n            data = new double[subMatrix.length][nCols];\n            for (int i = 0; i < data.length; ++i) {\n                if (subMatrix[i].length != nCols) {\n                    throw new DimensionMismatchException(subMatrix[i].length, nCols);\n                }\n                System.arraycopy(subMatrix[i], 0, data[i + row], column, nCols);\n            }\n        } else {\n            super.setSubMatrix(subMatrix, row, column);\n        }\n\n    }",
    "comment": "{@inheritDoc} */",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "Array2DRowRealMatrix.walkInRowOrder",
    "class_name": "org.apache.commons.math3.linear.Array2DRowRealMatrix",
    "signature": "org.apache.commons.math3.linear.Array2DRowRealMatrix.walkInRowOrder(RealMatrixPreservingVisitor)",
    "snippet": "    @Override\n    public double walkInRowOrder(final RealMatrixPreservingVisitor visitor) {\n        final int rows    = getRowDimension();\n        final int columns = getColumnDimension();\n        visitor.start(rows, columns, 0, rows - 1, 0, columns - 1);\n        for (int i = 0; i < rows; ++i) {\n            final double[] rowI = data[i];\n            for (int j = 0; j < columns; ++j) {\n                visitor.visit(i, j, rowI[j]);\n            }\n        }\n        return visitor.end();\n    }",
    "comment": "{@inheritDoc} */",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "ArrayRealVector.ArrayRealVector",
    "class_name": "org.apache.commons.math3.linear.ArrayRealVector",
    "signature": "org.apache.commons.math3.linear.ArrayRealVector.ArrayRealVector(ArrayRealVector,boolean)",
    "snippet": "    public ArrayRealVector(ArrayRealVector v, boolean deep) {\n        data = deep ? v.data.clone() : v.data;\n    }",
    "comment": " Construct a vector from another vector.  @param v Vector to copy. @param deep If {@code true} perform a deep copy, otherwise perform a shallow copy. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "ArrayRealVector.ArrayRealVector",
    "class_name": "org.apache.commons.math3.linear.ArrayRealVector",
    "signature": "org.apache.commons.math3.linear.ArrayRealVector.ArrayRealVector(double[])",
    "snippet": "    public ArrayRealVector(double[] d) {\n        data = d.clone();\n    }",
    "comment": " Construct a vector from an array, copying the input array.  @param d Array. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "ArrayRealVector.copy",
    "class_name": "org.apache.commons.math3.linear.ArrayRealVector",
    "signature": "org.apache.commons.math3.linear.ArrayRealVector.copy()",
    "snippet": "    @Override\n    public ArrayRealVector copy() {\n        return new ArrayRealVector(this, true);\n    }",
    "comment": "{@inheritDoc} */",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "ArrayRealVector.getDataRef",
    "class_name": "org.apache.commons.math3.linear.ArrayRealVector",
    "signature": "org.apache.commons.math3.linear.ArrayRealVector.getDataRef()",
    "snippet": "    public double[] getDataRef() {\n        return data;\n    }",
    "comment": " Get a reference to the underlying data array. This method does not make a fresh copy of the underlying data.  @return the array of entries. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "ArrayRealVector.toArray",
    "class_name": "org.apache.commons.math3.linear.ArrayRealVector",
    "signature": "org.apache.commons.math3.linear.ArrayRealVector.toArray()",
    "snippet": "    @Override\n    public double[] toArray(){\n        return data.clone();\n    }",
    "comment": "{@inheritDoc} */",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "DefaultRealMatrixPreservingVisitor.end",
    "class_name": "org.apache.commons.math3.linear.DefaultRealMatrixPreservingVisitor",
    "signature": "org.apache.commons.math3.linear.DefaultRealMatrixPreservingVisitor.end()",
    "snippet": "    public double end() {\n        return 0;\n    }",
    "comment": "{@inheritDoc} */",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "DefaultRealMatrixPreservingVisitor.start",
    "class_name": "org.apache.commons.math3.linear.DefaultRealMatrixPreservingVisitor",
    "signature": "org.apache.commons.math3.linear.DefaultRealMatrixPreservingVisitor.start(int,int,int,int,int,int)",
    "snippet": "    public void start(int rows, int columns,\n                      int startRow, int endRow, int startColumn, int endColumn) {\n    }",
    "comment": "{@inheritDoc} */",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "EigenDecomposition.EigenDecomposition",
    "class_name": "org.apache.commons.math3.linear.EigenDecomposition",
    "signature": "org.apache.commons.math3.linear.EigenDecomposition.EigenDecomposition(RealMatrix)",
    "snippet": "    public EigenDecomposition(final RealMatrix matrix)\n        throws MathArithmeticException {\n        final double symTol = 10 * matrix.getRowDimension() * matrix.getColumnDimension() * Precision.EPSILON;\n        isSymmetric = MatrixUtils.isSymmetric(matrix, symTol);\n        if (isSymmetric) {\n            transformToTridiagonal(matrix);\n            findEigenVectors(transformer.getQ().getData());\n        } else {\n            final SchurTransformer t = transformToSchur(matrix);\n            findEigenVectorsFromSchur(t);\n        }\n    }",
    "comment": " Calculates the eigen decomposition of the given real matrix. <p> Supports decomposition of a general matrix since 3.1.  @param matrix Matrix to decompose. @throws MaxCountExceededException if the algorithm fails to converge. @throws MathArithmeticException if the decomposition of a general matrix results in a matrix with zero norm @since 3.1 ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "EigenDecomposition.findEigenVectors",
    "class_name": "org.apache.commons.math3.linear.EigenDecomposition",
    "signature": "org.apache.commons.math3.linear.EigenDecomposition.findEigenVectors(double[][])",
    "snippet": "    private void findEigenVectors(final double[][] householderMatrix) {\n        final double[][]z = householderMatrix.clone();\n        final int n = main.length;\n        realEigenvalues = new double[n];\n        imagEigenvalues = new double[n];\n        final double[] e = new double[n];\n        for (int i = 0; i < n - 1; i++) {\n            realEigenvalues[i] = main[i];\n            e[i] = secondary[i];\n        }\n        realEigenvalues[n - 1] = main[n - 1];\n        e[n - 1] = 0;\n\n        // Determine the largest main and secondary value in absolute term.\n        double maxAbsoluteValue = 0;\n        for (int i = 0; i < n; i++) {\n            if (FastMath.abs(realEigenvalues[i]) > maxAbsoluteValue) {\n                maxAbsoluteValue = FastMath.abs(realEigenvalues[i]);\n            }\n            if (FastMath.abs(e[i]) > maxAbsoluteValue) {\n                maxAbsoluteValue = FastMath.abs(e[i]);\n            }\n        }\n        // Make null any main and secondary value too small to be significant\n        if (maxAbsoluteValue != 0) {\n            for (int i=0; i < n; i++) {\n                if (FastMath.abs(realEigenvalues[i]) <= Precision.EPSILON * maxAbsoluteValue) {\n                    realEigenvalues[i] = 0;\n                }\n                if (FastMath.abs(e[i]) <= Precision.EPSILON * maxAbsoluteValue) {\n                    e[i]=0;\n                }\n            }\n        }\n\n        for (int j = 0; j < n; j++) {\n            int its = 0;\n            int m;\n            do {\n                for (m = j; m < n - 1; m++) {\n                    double delta = FastMath.abs(realEigenvalues[m]) +\n                        FastMath.abs(realEigenvalues[m + 1]);\n                    if (FastMath.abs(e[m]) + delta == delta) {\n                        break;\n                    }\n                }\n                if (m != j) {\n                    if (its == maxIter) {\n                        throw new MaxCountExceededException(LocalizedFormats.CONVERGENCE_FAILED,\n                                                            maxIter);\n                    }\n                    its++;\n                    double q = (realEigenvalues[j + 1] - realEigenvalues[j]) / (2 * e[j]);\n                    double t = FastMath.sqrt(1 + q * q);\n                    if (q < 0.0) {\n                        q = realEigenvalues[m] - realEigenvalues[j] + e[j] / (q - t);\n                    } else {\n                        q = realEigenvalues[m] - realEigenvalues[j] + e[j] / (q + t);\n                    }\n                    double u = 0.0;\n                    double s = 1.0;\n                    double c = 1.0;\n                    int i;\n                    for (i = m - 1; i >= j; i--) {\n                        double p = s * e[i];\n                        double h = c * e[i];\n                        if (FastMath.abs(p) >= FastMath.abs(q)) {\n                            c = q / p;\n                            t = FastMath.sqrt(c * c + 1.0);\n                            e[i + 1] = p * t;\n                            s = 1.0 / t;\n                            c = c * s;\n                        } else {\n                            s = p / q;\n                            t = FastMath.sqrt(s * s + 1.0);\n                            e[i + 1] = q * t;\n                            c = 1.0 / t;\n                            s = s * c;\n                        }\n                        if (e[i + 1] == 0.0) {\n                            realEigenvalues[i + 1] -= u;\n                            e[m] = 0.0;\n                            break;\n                        }\n                        q = realEigenvalues[i + 1] - u;\n                        t = (realEigenvalues[i] - q) * s + 2.0 * c * h;\n                        u = s * t;\n                        realEigenvalues[i + 1] = q + u;\n                        q = c * t - h;\n                        for (int ia = 0; ia < n; ia++) {\n                            p = z[ia][i + 1];\n                            z[ia][i + 1] = s * z[ia][i] + c * p;\n                            z[ia][i] = c * z[ia][i] - s * p;\n                        }\n                    }\n                    if (t == 0.0 && i >= j) {\n                        continue;\n                    }\n                    realEigenvalues[j] -= u;\n                    e[j] = q;\n                    e[m] = 0.0;\n                }\n            } while (m != j);\n        }\n\n        //Sort the eigen values (and vectors) in increase order\n        for (int i = 0; i < n; i++) {\n            int k = i;\n            double p = realEigenvalues[i];\n            for (int j = i + 1; j < n; j++) {\n                if (realEigenvalues[j] > p) {\n                    k = j;\n                    p = realEigenvalues[j];\n                }\n            }\n            if (k != i) {\n                realEigenvalues[k] = realEigenvalues[i];\n                realEigenvalues[i] = p;\n                for (int j = 0; j < n; j++) {\n                    p = z[j][i];\n                    z[j][i] = z[j][k];\n                    z[j][k] = p;\n                }\n            }\n        }\n\n        // Determine the largest eigen value in absolute term.\n        maxAbsoluteValue = 0;\n        for (int i = 0; i < n; i++) {\n            if (FastMath.abs(realEigenvalues[i]) > maxAbsoluteValue) {\n                maxAbsoluteValue=FastMath.abs(realEigenvalues[i]);\n            }\n        }\n        // Make null any eigen value too small to be significant\n        if (maxAbsoluteValue != 0.0) {\n            for (int i=0; i < n; i++) {\n                if (FastMath.abs(realEigenvalues[i]) < Precision.EPSILON * maxAbsoluteValue) {\n                    realEigenvalues[i] = 0;\n                }\n            }\n        }\n        eigenvectors = new ArrayRealVector[n];\n        final double[] tmp = new double[n];\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < n; j++) {\n                tmp[j] = z[j][i];\n            }\n            eigenvectors[i] = new ArrayRealVector(tmp);\n        }\n    }",
    "comment": " Find eigenvalues and eigenvectors (Dubrulle et al., 1971)  @param householderMatrix Householder matrix of the transformation to tridiagonal form. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "EigenDecomposition.getDeterminant",
    "class_name": "org.apache.commons.math3.linear.EigenDecomposition",
    "signature": "org.apache.commons.math3.linear.EigenDecomposition.getDeterminant()",
    "snippet": "    public double getDeterminant() {\n        double determinant = 1;\n        for (double lambda : realEigenvalues) {\n            determinant *= lambda;\n        }\n        return determinant;\n    }",
    "comment": " Computes the determinant of the matrix.  @return the determinant of the matrix. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "EigenDecomposition.getEigenvector",
    "class_name": "org.apache.commons.math3.linear.EigenDecomposition",
    "signature": "org.apache.commons.math3.linear.EigenDecomposition.getEigenvector(int)",
    "snippet": "    public RealVector getEigenvector(final int i) {\n        return eigenvectors[i].copy();\n    }",
    "comment": " Gets a copy of the i<sup>th</sup> eigenvector of the original matrix.  @param i Index of the eigenvector (counting from 0). @return a copy of the i<sup>th</sup> eigenvector of the original matrix. @see #getD() ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "EigenDecomposition.getRealEigenvalues",
    "class_name": "org.apache.commons.math3.linear.EigenDecomposition",
    "signature": "org.apache.commons.math3.linear.EigenDecomposition.getRealEigenvalues()",
    "snippet": "    public double[] getRealEigenvalues() {\n        return realEigenvalues.clone();\n    }",
    "comment": " Gets a copy of the real parts of the eigenvalues of the original matrix.  @return a copy of the real parts of the eigenvalues of the original matrix.  @see #getD() @see #getRealEigenvalue(int) @see #getImagEigenvalues() ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "EigenDecomposition.getSolver",
    "class_name": "org.apache.commons.math3.linear.EigenDecomposition",
    "signature": "org.apache.commons.math3.linear.EigenDecomposition.getSolver()",
    "snippet": "    public DecompositionSolver getSolver() {\n        if (hasComplexEigenvalues()) {\n            throw new MathUnsupportedOperationException();\n        }\n        return new Solver(realEigenvalues, imagEigenvalues, eigenvectors);\n    }",
    "comment": " Gets a solver for finding the A &times; X = B solution in exact linear sense. <p> Since 3.1, eigen decomposition of a general matrix is supported, but the {@link DecompositionSolver} only supports real eigenvalues.  @return a solver @throws MathUnsupportedOperationException if the decomposition resulted in complex eigenvalues ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "EigenDecomposition.hasComplexEigenvalues",
    "class_name": "org.apache.commons.math3.linear.EigenDecomposition",
    "signature": "org.apache.commons.math3.linear.EigenDecomposition.hasComplexEigenvalues()",
    "snippet": "    public boolean hasComplexEigenvalues() {\n        for (int i = 0; i < imagEigenvalues.length; i++) {\n            if (!Precision.equals(imagEigenvalues[i], 0.0, EPSILON)) {\n                return true;\n            }\n        }\n        return false;\n    }",
    "comment": " Returns whether the calculated eigen values are complex or real. <p>The method performs a zero check for each element of the {@link #getImagEigenvalues()} array and returns {@code true} if any element is not equal to zero.  @return {@code true} if the eigen values are complex, {@code false} otherwise @since 3.1 ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "EigenDecomposition.transformToTridiagonal",
    "class_name": "org.apache.commons.math3.linear.EigenDecomposition",
    "signature": "org.apache.commons.math3.linear.EigenDecomposition.transformToTridiagonal(RealMatrix)",
    "snippet": "    private void transformToTridiagonal(final RealMatrix matrix) {\n        // transform the matrix to tridiagonal\n        transformer = new TriDiagonalTransformer(matrix);\n        main = transformer.getMainDiagonalRef();\n        secondary = transformer.getSecondaryDiagonalRef();\n    }",
    "comment": " Transforms the matrix to tridiagonal form.  @param matrix Matrix to transform. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "Solver.getInverse",
    "class_name": "org.apache.commons.math3.linear.EigenDecomposition$Solver",
    "signature": "org.apache.commons.math3.linear.EigenDecomposition$Solver.getInverse()",
    "snippet": "        public RealMatrix getInverse() {\n            if (!isNonSingular()) {\n                throw new SingularMatrixException();\n            }\n\n            final int m = realEigenvalues.length;\n            final double[][] invData = new double[m][m];\n\n            for (int i = 0; i < m; ++i) {\n                final double[] invI = invData[i];\n                for (int j = 0; j < m; ++j) {\n                    double invIJ = 0;\n                    for (int k = 0; k < m; ++k) {\n                        final double[] vK = eigenvectors[k].getDataRef();\n                        invIJ += vK[i] * vK[j] / realEigenvalues[k];\n                    }\n                    invI[j] = invIJ;\n                }\n            }\n            return MatrixUtils.createRealMatrix(invData);\n        }",
    "comment": " Get the inverse of the decomposed matrix.  @return the inverse matrix. @throws SingularMatrixException if the decomposed matrix is singular. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "Solver.isNonSingular",
    "class_name": "org.apache.commons.math3.linear.EigenDecomposition$Solver",
    "signature": "org.apache.commons.math3.linear.EigenDecomposition$Solver.isNonSingular()",
    "snippet": "        public boolean isNonSingular() {\n            for (int i = 0; i < realEigenvalues.length; ++i) {\n                if (realEigenvalues[i] == 0 &&\n                    imagEigenvalues[i] == 0) {\n                    return false;\n                }\n            }\n            return true;\n        }",
    "comment": " Checks whether the decomposed matrix is non-singular.  @return true if the decomposed matrix is non-singular. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "MatrixUtils.checkColumnIndex",
    "class_name": "org.apache.commons.math3.linear.MatrixUtils",
    "signature": "org.apache.commons.math3.linear.MatrixUtils.checkColumnIndex(AnyMatrix,int)",
    "snippet": "    public static void checkColumnIndex(final AnyMatrix m, final int column)\n        throws OutOfRangeException {\n        if (column < 0 || column >= m.getColumnDimension()) {\n            throw new OutOfRangeException(LocalizedFormats.COLUMN_INDEX,\n                                           column, 0, m.getColumnDimension() - 1);\n        }\n    }",
    "comment": " Check if a column index is valid.  @param m Matrix. @param column Column index to check. @throws OutOfRangeException if {@code column} is not a valid index. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "MatrixUtils.checkMatrixIndex",
    "class_name": "org.apache.commons.math3.linear.MatrixUtils",
    "signature": "org.apache.commons.math3.linear.MatrixUtils.checkMatrixIndex(AnyMatrix,int,int)",
    "snippet": "    public static void checkMatrixIndex(final AnyMatrix m,\n                                        final int row, final int column)\n        throws OutOfRangeException {\n        checkRowIndex(m, row);\n        checkColumnIndex(m, column);\n    }",
    "comment": " Check if matrix indices are valid.  @param m Matrix. @param row Row index to check. @param column Column index to check. @throws OutOfRangeException if {@code row} or {@code column} is not a valid index. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "MatrixUtils.checkMultiplicationCompatible",
    "class_name": "org.apache.commons.math3.linear.MatrixUtils",
    "signature": "org.apache.commons.math3.linear.MatrixUtils.checkMultiplicationCompatible(AnyMatrix,AnyMatrix)",
    "snippet": "    public static void checkMultiplicationCompatible(final AnyMatrix left, final AnyMatrix right)\n        throws DimensionMismatchException {\n\n        if (left.getColumnDimension() != right.getRowDimension()) {\n            throw new DimensionMismatchException(left.getColumnDimension(),\n                                                 right.getRowDimension());\n        }\n    }",
    "comment": " Check if matrices are multiplication compatible  @param left Left hand side matrix. @param right Right hand side matrix. @throws DimensionMismatchException if matrices are not multiplication compatible. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "MatrixUtils.checkRowIndex",
    "class_name": "org.apache.commons.math3.linear.MatrixUtils",
    "signature": "org.apache.commons.math3.linear.MatrixUtils.checkRowIndex(AnyMatrix,int)",
    "snippet": "    public static void checkRowIndex(final AnyMatrix m, final int row)\n        throws OutOfRangeException {\n        if (row < 0 ||\n            row >= m.getRowDimension()) {\n            throw new OutOfRangeException(LocalizedFormats.ROW_INDEX,\n                                          row, 0, m.getRowDimension() - 1);\n        }\n    }",
    "comment": " Check if a row index is valid.  @param m Matrix. @param row Row index to check. @throws OutOfRangeException if {@code row} is not a valid index. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "MatrixUtils.createRealMatrix",
    "class_name": "org.apache.commons.math3.linear.MatrixUtils",
    "signature": "org.apache.commons.math3.linear.MatrixUtils.createRealMatrix(double[][])",
    "snippet": "    public static RealMatrix createRealMatrix(double[][] data)\n        throws NullArgumentException, DimensionMismatchException,\n        NoDataException {\n        if (data == null ||\n            data[0] == null) {\n            throw new NullArgumentException();\n        }\n        return (data.length * data[0].length <= 4096) ?\n                new Array2DRowRealMatrix(data) : new BlockRealMatrix(data);\n    }",
    "comment": " Returns a {@link RealMatrix} whose entries are the the values in the the input array. <p>The type of matrix returned depends on the dimension. Below 2<sup>12</sup> elements (i.e. 4096 elements or 64&times;64 for a square matrix) which can be stored in a 32kB array, a {@link Array2DRowRealMatrix} instance is built. Above this threshold a {@link BlockRealMatrix} instance is built.</p> <p>The input array is copied, not referenced.</p>  @param data input array @return  RealMatrix containing the values of the array @throws org.apache.commons.math3.exception.DimensionMismatchException if {@code data} is not rectangular (not all rows have the same length). @throws NoDataException if a row or column is empty. @throws NullArgumentException if either {@code data} or {@code data[0]} is {@code null}. @throws DimensionMismatchException if {@code data} is not rectangular. @see #createRealMatrix(int, int) ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "MatrixUtils.isSymmetric",
    "class_name": "org.apache.commons.math3.linear.MatrixUtils",
    "signature": "org.apache.commons.math3.linear.MatrixUtils.isSymmetric(RealMatrix,double)",
    "snippet": "    public static boolean isSymmetric(RealMatrix matrix,\n                                      double eps) {\n        return isSymmetricInternal(matrix, eps, false);\n    }",
    "comment": " Checks whether a matrix is symmetric.  @param matrix Matrix to check. @param eps Relative tolerance. @return {@code true} if {@code matrix} is symmetric. @since 3.1 ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "MatrixUtils.isSymmetricInternal",
    "class_name": "org.apache.commons.math3.linear.MatrixUtils",
    "signature": "org.apache.commons.math3.linear.MatrixUtils.isSymmetricInternal(RealMatrix,double,boolean)",
    "snippet": "    private static boolean isSymmetricInternal(RealMatrix matrix,\n                                               double relativeTolerance,\n                                               boolean raiseException) {\n        final int rows = matrix.getRowDimension();\n        if (rows != matrix.getColumnDimension()) {\n            if (raiseException) {\n                throw new NonSquareMatrixException(rows, matrix.getColumnDimension());\n            } else {\n                return false;\n            }\n        }\n        for (int i = 0; i < rows; i++) {\n            for (int j = i + 1; j < rows; j++) {\n                final double mij = matrix.getEntry(i, j);\n                final double mji = matrix.getEntry(j, i);\n                if (FastMath.abs(mij - mji) >\n                    FastMath.max(FastMath.abs(mij), FastMath.abs(mji)) * relativeTolerance) {\n                    if (raiseException) {\n                        throw new NonSymmetricMatrixException(i, j, relativeTolerance);\n                    } else {\n                        return false;\n                    }\n                }\n            }\n        }\n        return true;\n    }",
    "comment": " Checks whether a matrix is symmetric, within a given relative tolerance.  @param matrix Matrix to check. @param relativeTolerance Tolerance of the symmetry check. @param raiseException If {@code true}, an exception will be raised if the matrix is not symmetric. @return {@code true} if {@code matrix} is symmetric. @throws NonSquareMatrixException if the matrix is not square. @throws NonSymmetricMatrixException if the matrix is not symmetric. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "RealMatrixFormat.RealMatrixFormat",
    "class_name": "org.apache.commons.math3.linear.RealMatrixFormat",
    "signature": "org.apache.commons.math3.linear.RealMatrixFormat.RealMatrixFormat(NumberFormat)",
    "snippet": "    public RealMatrixFormat(final NumberFormat format) {\n        this(DEFAULT_PREFIX, DEFAULT_SUFFIX, DEFAULT_ROW_PREFIX, DEFAULT_ROW_SUFFIX,\n                DEFAULT_ROW_SEPARATOR, DEFAULT_COLUMN_SEPARATOR, format);\n    }",
    "comment": " Create an instance with a custom number format for components. @param format the custom format for components. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "RealMatrixFormat.RealMatrixFormat",
    "class_name": "org.apache.commons.math3.linear.RealMatrixFormat",
    "signature": "org.apache.commons.math3.linear.RealMatrixFormat.RealMatrixFormat(String,String,String,String,String,String)",
    "snippet": "    public RealMatrixFormat(final String prefix, final String suffix,\n                            final String rowPrefix, final String rowSuffix,\n                            final String rowSeparator, final String columnSeparator) {\n        this(prefix, suffix, rowPrefix, rowSuffix, rowSeparator, columnSeparator,\n                CompositeFormat.getDefaultNumberFormat());\n    }",
    "comment": " Create an instance with custom prefix, suffix and separator. @param prefix prefix to use instead of the default \"{\" @param suffix suffix to use instead of the default \"}\" @param rowPrefix row prefix to use instead of the default \"{\" @param rowSuffix row suffix to use instead of the default \"}\" @param rowSeparator tow separator to use instead of the default \";\" @param columnSeparator column separator to use instead of the default \", \" ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "RealMatrixFormat.RealMatrixFormat",
    "class_name": "org.apache.commons.math3.linear.RealMatrixFormat",
    "signature": "org.apache.commons.math3.linear.RealMatrixFormat.RealMatrixFormat(String,String,String,String,String,String,NumberFormat)",
    "snippet": "    public RealMatrixFormat(final String prefix, final String suffix,\n                            final String rowPrefix, final String rowSuffix,\n                            final String rowSeparator, final String columnSeparator,\n                            final NumberFormat format) {\n        this.prefix            = prefix;\n        this.suffix            = suffix;\n        this.rowPrefix         = rowPrefix;\n        this.rowSuffix         = rowSuffix;\n        this.rowSeparator      = rowSeparator;\n        this.columnSeparator   = columnSeparator;\n        this.format            = format;\n        // disable grouping to prevent parsing problems\n        this.format.setGroupingUsed(false);\n    }",
    "comment": " Create an instance with custom prefix, suffix, separator and format for components. @param prefix prefix to use instead of the default \"{\" @param suffix suffix to use instead of the default \"}\" @param rowPrefix row prefix to use instead of the default \"{\" @param rowSuffix row suffix to use instead of the default \"}\" @param rowSeparator tow separator to use instead of the default \";\" @param columnSeparator column separator to use instead of the default \", \" @param format the custom format for components. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "RealMatrixFormat.getFormat",
    "class_name": "org.apache.commons.math3.linear.RealMatrixFormat",
    "signature": "org.apache.commons.math3.linear.RealMatrixFormat.getFormat()",
    "snippet": "    public NumberFormat getFormat() {\n        return format;\n    }",
    "comment": " Get the components format. @return components format. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "RealMatrixFormat.getInstance",
    "class_name": "org.apache.commons.math3.linear.RealMatrixFormat",
    "signature": "org.apache.commons.math3.linear.RealMatrixFormat.getInstance()",
    "snippet": "    public static RealMatrixFormat getInstance() {\n        return getInstance(Locale.getDefault());\n    }",
    "comment": " Returns the default real vector format for the current locale. @return the default real vector format. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "RealMatrixFormat.getInstance",
    "class_name": "org.apache.commons.math3.linear.RealMatrixFormat",
    "signature": "org.apache.commons.math3.linear.RealMatrixFormat.getInstance(Locale)",
    "snippet": "    public static RealMatrixFormat getInstance(final Locale locale) {\n        return new RealMatrixFormat(CompositeFormat.getDefaultNumberFormat(locale));\n    }",
    "comment": " Returns the default real vector format for the given locale. @param locale the specific locale used by the format. @return the real vector format specific to the given locale. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "RealVectorFormat.RealVectorFormat",
    "class_name": "org.apache.commons.math3.linear.RealVectorFormat",
    "signature": "org.apache.commons.math3.linear.RealVectorFormat.RealVectorFormat(NumberFormat)",
    "snippet": "    public RealVectorFormat(final NumberFormat format) {\n        this(DEFAULT_PREFIX, DEFAULT_SUFFIX, DEFAULT_SEPARATOR, format);\n    }",
    "comment": " Create an instance with a custom number format for components. @param format the custom format for components. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "RealVectorFormat.RealVectorFormat",
    "class_name": "org.apache.commons.math3.linear.RealVectorFormat",
    "signature": "org.apache.commons.math3.linear.RealVectorFormat.RealVectorFormat(String,String,String,NumberFormat)",
    "snippet": "    public RealVectorFormat(final String prefix, final String suffix,\n                            final String separator, final NumberFormat format) {\n        this.prefix      = prefix;\n        this.suffix      = suffix;\n        this.separator   = separator;\n        trimmedPrefix    = prefix.trim();\n        trimmedSuffix    = suffix.trim();\n        trimmedSeparator = separator.trim();\n        this.format      = format;\n    }",
    "comment": " Create an instance with custom prefix, suffix, separator and format for components. @param prefix prefix to use instead of the default \"{\" @param suffix suffix to use instead of the default \"}\" @param separator separator to use instead of the default \"; \" @param format the custom format for components. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "RealVectorFormat.getInstance",
    "class_name": "org.apache.commons.math3.linear.RealVectorFormat",
    "signature": "org.apache.commons.math3.linear.RealVectorFormat.getInstance()",
    "snippet": "    public static RealVectorFormat getInstance() {\n        return getInstance(Locale.getDefault());\n    }",
    "comment": " Returns the default real vector format for the current locale. @return the default real vector format. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "RealVectorFormat.getInstance",
    "class_name": "org.apache.commons.math3.linear.RealVectorFormat",
    "signature": "org.apache.commons.math3.linear.RealVectorFormat.getInstance(Locale)",
    "snippet": "    public static RealVectorFormat getInstance(final Locale locale) {\n        return new RealVectorFormat(CompositeFormat.getDefaultNumberFormat(locale));\n    }",
    "comment": " Returns the default real vector format for the given locale. @param locale the specific locale used by the format. @return the real vector format specific to the given locale. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "TriDiagonalTransformer.TriDiagonalTransformer",
    "class_name": "org.apache.commons.math3.linear.TriDiagonalTransformer",
    "signature": "org.apache.commons.math3.linear.TriDiagonalTransformer.TriDiagonalTransformer(RealMatrix)",
    "snippet": "    public TriDiagonalTransformer(RealMatrix matrix) {\n        if (!matrix.isSquare()) {\n            throw new NonSquareMatrixException(matrix.getRowDimension(),\n                                               matrix.getColumnDimension());\n        }\n\n        final int m = matrix.getRowDimension();\n        householderVectors = matrix.getData();\n        main      = new double[m];\n        secondary = new double[m - 1];\n        cachedQ   = null;\n        cachedQt  = null;\n        cachedT   = null;\n\n        // transform matrix\n        transform();\n    }",
    "comment": " Build the transformation to tridiagonal shape of a symmetrical matrix. <p>The specified matrix is assumed to be symmetrical without any check. Only the upper triangular part of the matrix is used.</p>  @param matrix Symmetrical matrix to transform. @throws NonSquareMatrixException if the matrix is not square. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "TriDiagonalTransformer.getMainDiagonalRef",
    "class_name": "org.apache.commons.math3.linear.TriDiagonalTransformer",
    "signature": "org.apache.commons.math3.linear.TriDiagonalTransformer.getMainDiagonalRef()",
    "snippet": "    double[] getMainDiagonalRef() {\n        return main;\n    }",
    "comment": " Get the main diagonal elements of the matrix T of the transform. <p>Note that since this class is only intended for internal use, it returns directly a reference to its internal arrays, not a copy.</p> @return the main diagonal elements of the T matrix ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "TriDiagonalTransformer.getQ",
    "class_name": "org.apache.commons.math3.linear.TriDiagonalTransformer",
    "signature": "org.apache.commons.math3.linear.TriDiagonalTransformer.getQ()",
    "snippet": "    public RealMatrix getQ() {\n        if (cachedQ == null) {\n            cachedQ = getQT().transpose();\n        }\n        return cachedQ;\n    }",
    "comment": " Returns the matrix Q of the transform. <p>Q is an orthogonal matrix, i.e. its transpose is also its inverse.</p> @return the Q matrix ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "TriDiagonalTransformer.getQT",
    "class_name": "org.apache.commons.math3.linear.TriDiagonalTransformer",
    "signature": "org.apache.commons.math3.linear.TriDiagonalTransformer.getQT()",
    "snippet": "    public RealMatrix getQT() {\n        if (cachedQt == null) {\n            final int m = householderVectors.length;\n            double[][] qta = new double[m][m];\n\n            // build up first part of the matrix by applying Householder transforms\n            for (int k = m - 1; k >= 1; --k) {\n                final double[] hK = householderVectors[k - 1];\n                qta[k][k] = 1;\n                if (hK[k] != 0.0) {\n                    final double inv = 1.0 / (secondary[k - 1] * hK[k]);\n                    double beta = 1.0 / secondary[k - 1];\n                    qta[k][k] = 1 + beta * hK[k];\n                    for (int i = k + 1; i < m; ++i) {\n                        qta[k][i] = beta * hK[i];\n                    }\n                    for (int j = k + 1; j < m; ++j) {\n                        beta = 0;\n                        for (int i = k + 1; i < m; ++i) {\n                            beta += qta[j][i] * hK[i];\n                        }\n                        beta *= inv;\n                        qta[j][k] = beta * hK[k];\n                        for (int i = k + 1; i < m; ++i) {\n                            qta[j][i] += beta * hK[i];\n                        }\n                    }\n                }\n            }\n            qta[0][0] = 1;\n            cachedQt = MatrixUtils.createRealMatrix(qta);\n        }\n\n        // return the cached matrix\n        return cachedQt;\n    }",
    "comment": " Returns the transpose of the matrix Q of the transform. <p>Q is an orthogonal matrix, i.e. its transpose is also its inverse.</p> @return the Q matrix ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "TriDiagonalTransformer.getSecondaryDiagonalRef",
    "class_name": "org.apache.commons.math3.linear.TriDiagonalTransformer",
    "signature": "org.apache.commons.math3.linear.TriDiagonalTransformer.getSecondaryDiagonalRef()",
    "snippet": "    double[] getSecondaryDiagonalRef() {\n        return secondary;\n    }",
    "comment": " Get the secondary diagonal elements of the matrix T of the transform. <p>Note that since this class is only intended for internal use, it returns directly a reference to its internal arrays, not a copy.</p> @return the secondary diagonal elements of the T matrix ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "TriDiagonalTransformer.transform",
    "class_name": "org.apache.commons.math3.linear.TriDiagonalTransformer",
    "signature": "org.apache.commons.math3.linear.TriDiagonalTransformer.transform()",
    "snippet": "    private void transform() {\n        final int m = householderVectors.length;\n        final double[] z = new double[m];\n        for (int k = 0; k < m - 1; k++) {\n\n            //zero-out a row and a column simultaneously\n            final double[] hK = householderVectors[k];\n            main[k] = hK[k];\n            double xNormSqr = 0;\n            for (int j = k + 1; j < m; ++j) {\n                final double c = hK[j];\n                xNormSqr += c * c;\n            }\n            final double a = (hK[k + 1] > 0) ? -FastMath.sqrt(xNormSqr) : FastMath.sqrt(xNormSqr);\n            secondary[k] = a;\n            if (a != 0.0) {\n                // apply Householder transform from left and right simultaneously\n\n                hK[k + 1] -= a;\n                final double beta = -1 / (a * hK[k + 1]);\n\n                // compute a = beta A v, where v is the Householder vector\n                // this loop is written in such a way\n                //   1) only the upper triangular part of the matrix is accessed\n                //   2) access is cache-friendly for a matrix stored in rows\n                Arrays.fill(z, k + 1, m, 0);\n                for (int i = k + 1; i < m; ++i) {\n                    final double[] hI = householderVectors[i];\n                    final double hKI = hK[i];\n                    double zI = hI[i] * hKI;\n                    for (int j = i + 1; j < m; ++j) {\n                        final double hIJ = hI[j];\n                        zI   += hIJ * hK[j];\n                        z[j] += hIJ * hKI;\n                    }\n                    z[i] = beta * (z[i] + zI);\n                }\n\n                // compute gamma = beta vT z / 2\n                double gamma = 0;\n                for (int i = k + 1; i < m; ++i) {\n                    gamma += z[i] * hK[i];\n                }\n                gamma *= beta / 2;\n\n                // compute z = z - gamma v\n                for (int i = k + 1; i < m; ++i) {\n                    z[i] -= gamma * hK[i];\n                }\n\n                // update matrix: A = A - v zT - z vT\n                // only the upper triangular part of the matrix is updated\n                for (int i = k + 1; i < m; ++i) {\n                    final double[] hI = householderVectors[i];\n                    for (int j = i; j < m; ++j) {\n                        hI[j] -= hK[i] * z[j] + z[i] * hK[j];\n                    }\n                }\n            }\n        }\n        main[m - 1] = householderVectors[m - 1][m - 1];\n    }",
    "comment": " Transform original matrix to tridiagonal form. <p>Transformation is done using Householder transforms.</p> ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "AbstractWell.AbstractWell",
    "class_name": "org.apache.commons.math3.random.AbstractWell",
    "signature": "org.apache.commons.math3.random.AbstractWell.AbstractWell(int,int,int,int)",
    "snippet": "    protected AbstractWell(final int k, final int m1, final int m2, final int m3) {\n        this(k, m1, m2, m3, null);\n    }",
    "comment": "Creates a new random number generator. <p>The instance is initialized using the current time plus the system identity hash code of this instance as the seed.</p> @param k number of bits in the pool (not necessarily a multiple of 32) @param m1 first parameter of the algorithm @param m2 second parameter of the algorithm @param m3 third parameter of the algorithm ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "AbstractWell.AbstractWell",
    "class_name": "org.apache.commons.math3.random.AbstractWell",
    "signature": "org.apache.commons.math3.random.AbstractWell.AbstractWell(int,int,int,int,int[])",
    "snippet": "    protected AbstractWell(final int k, final int m1, final int m2, final int m3, final int[] seed) {\n\n        // the bits pool contains k bits, k = r w - p where r is the number\n        // of w bits blocks, w is the block size (always 32 in the original paper)\n        // and p is the number of unused bits in the last block\n        final int w = 32;\n        final int r = (k + w - 1) / w;\n        this.v      = new int[r];\n        this.index  = 0;\n\n        // precompute indirection index tables. These tables are used for optimizing access\n        // they allow saving computations like \"(j + r - 2) % r\" with costly modulo operations\n        iRm1 = new int[r];\n        iRm2 = new int[r];\n        i1   = new int[r];\n        i2   = new int[r];\n        i3   = new int[r];\n        for (int j = 0; j < r; ++j) {\n            iRm1[j] = (j + r - 1) % r;\n            iRm2[j] = (j + r - 2) % r;\n            i1[j]   = (j + m1)    % r;\n            i2[j]   = (j + m2)    % r;\n            i3[j]   = (j + m3)    % r;\n        }\n\n        // initialize the pool content\n        setSeed(seed);\n\n    }",
    "comment": "Creates a new random number generator using an int array seed. @param k number of bits in the pool (not necessarily a multiple of 32) @param m1 first parameter of the algorithm @param m2 second parameter of the algorithm @param m3 third parameter of the algorithm @param seed the initial seed (32 bits integers array), if null the seed of the generator will be related to the current time ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "AbstractWell.setSeed",
    "class_name": "org.apache.commons.math3.random.AbstractWell",
    "signature": "org.apache.commons.math3.random.AbstractWell.setSeed(int[])",
    "snippet": "    @Override\n    public void setSeed(final int[] seed) {\n        if (seed == null) {\n            setSeed(System.currentTimeMillis() + System.identityHashCode(this));\n            return;\n        }\n\n        System.arraycopy(seed, 0, v, 0, Math.min(seed.length, v.length));\n\n        if (seed.length < v.length) {\n            for (int i = seed.length; i < v.length; ++i) {\n                final long l = v[i - seed.length];\n                v[i] = (int) ((1812433253l * (l ^ (l >> 30)) + i) & 0xffffffffL);\n            }\n        }\n\n        index = 0;\n        clear();  // Clear normal deviate cache\n    }",
    "comment": "Reinitialize the generator as if just built with the given int array seed. <p>The state of the generator is exactly the same as a new generator built with the same seed.</p> @param seed the initial seed (32 bits integers array). If null the seed of the generator will be the system time plus the system identity hash code of the instance. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "AbstractWell.setSeed",
    "class_name": "org.apache.commons.math3.random.AbstractWell",
    "signature": "org.apache.commons.math3.random.AbstractWell.setSeed(long)",
    "snippet": "    @Override\n    public void setSeed(final long seed) {\n        setSeed(new int[] { (int) (seed >>> 32), (int) (seed & 0xffffffffl) });\n    }",
    "comment": "Reinitialize the generator as if just built with the given long seed. <p>The state of the generator is exactly the same as a new generator built with the same seed.</p> @param seed the initial seed (64 bits integer) ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "BitsStreamGenerator.BitsStreamGenerator",
    "class_name": "org.apache.commons.math3.random.BitsStreamGenerator",
    "signature": "org.apache.commons.math3.random.BitsStreamGenerator.BitsStreamGenerator()",
    "snippet": "    public BitsStreamGenerator() {\n        nextGaussian = Double.NaN;\n    }",
    "comment": " Creates a new random number generator. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "BitsStreamGenerator.clear",
    "class_name": "org.apache.commons.math3.random.BitsStreamGenerator",
    "signature": "org.apache.commons.math3.random.BitsStreamGenerator.clear()",
    "snippet": "    public void clear() {\n        nextGaussian = Double.NaN;\n    }",
    "comment": " Clears the cache used by the default implementation of {@link #nextGaussian}. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "RandomDataGenerator.RandomDataGenerator",
    "class_name": "org.apache.commons.math3.random.RandomDataGenerator",
    "signature": "org.apache.commons.math3.random.RandomDataGenerator.RandomDataGenerator()",
    "snippet": "    public RandomDataGenerator() {\n    }",
    "comment": " Construct a RandomDataGenerator, using a default random generator as the source of randomness.  <p>The default generator is a {@link Well19937c} seeded with {@code System.currentTimeMillis() + System.identityHashCode(this))}. The generator is initialized and seeded on first use.</p> ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "RandomDataImpl.RandomDataImpl",
    "class_name": "org.apache.commons.math3.random.RandomDataImpl",
    "signature": "org.apache.commons.math3.random.RandomDataImpl.RandomDataImpl()",
    "snippet": "    public RandomDataImpl() {\n        delegate = new RandomDataGenerator();\n    }",
    "comment": " Construct a RandomDataImpl, using a default random generator as the source of randomness.  <p>The default generator is a {@link Well19937c} seeded with {@code System.currentTimeMillis() + System.identityHashCode(this))}. The generator is initialized and seeded on first use.</p> ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "Well19937c.Well19937c",
    "class_name": "org.apache.commons.math3.random.Well19937c",
    "signature": "org.apache.commons.math3.random.Well19937c.Well19937c()",
    "snippet": "    public Well19937c() {\n        super(K, M1, M2, M3);\n    }",
    "comment": "Creates a new random number generator. <p>The instance is initialized using the current time as the seed.</p> ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "CompositeFormat.getDefaultNumberFormat",
    "class_name": "org.apache.commons.math3.util.CompositeFormat",
    "signature": "org.apache.commons.math3.util.CompositeFormat.getDefaultNumberFormat()",
    "snippet": "    public static NumberFormat getDefaultNumberFormat() {\n        return getDefaultNumberFormat(Locale.getDefault());\n    }",
    "comment": " Create a default number format.  The default number format is based on {@link NumberFormat#getInstance()} with the only customizing that the maximum number of fraction digits is set to 10. @return the default number format. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "CompositeFormat.getDefaultNumberFormat",
    "class_name": "org.apache.commons.math3.util.CompositeFormat",
    "signature": "org.apache.commons.math3.util.CompositeFormat.getDefaultNumberFormat(Locale)",
    "snippet": "    public static NumberFormat getDefaultNumberFormat(final Locale locale) {\n        final NumberFormat nf = NumberFormat.getInstance(locale);\n        nf.setMaximumFractionDigits(10);\n        return nf;\n    }",
    "comment": " Create a default number format.  The default number format is based on {@link NumberFormat#getInstance(java.util.Locale)} with the only customizing that the maximum number of fraction digits is set to 10. @param locale the specific locale used by the format. @return the default number format specific to the given locale. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "FastMath.abs",
    "class_name": "org.apache.commons.math3.util.FastMath",
    "signature": "org.apache.commons.math3.util.FastMath.abs(double)",
    "snippet": "    public static double abs(double x) {\n        return (x < 0.0) ? -x : (x == 0.0) ? 0.0 : x; // -0.0 => +0.0\n    }",
    "comment": " Absolute value. @param x number from which absolute value is requested @return abs(x) ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "FastMath.abs",
    "class_name": "org.apache.commons.math3.util.FastMath",
    "signature": "org.apache.commons.math3.util.FastMath.abs(long)",
    "snippet": "    public static long abs(final long x) {\n        return (x < 0l) ? -x : x;\n    }",
    "comment": " Absolute value. @param x number from which absolute value is requested @return abs(x) ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "FastMath.exp",
    "class_name": "org.apache.commons.math3.util.FastMath",
    "signature": "org.apache.commons.math3.util.FastMath.exp(double)",
    "snippet": "    public static double exp(double x) {\n        return exp(x, 0.0, null);\n    }",
    "comment": " Exponential function.  Computes exp(x), function result is nearly rounded.   It will be correctly rounded to the theoretical value for 99.9% of input values, otherwise it will have a 1 UPL error.  Method: Lookup intVal = exp(int(x)) Lookup fracVal = exp(int(x-int(x) / 1024.0) * 1024.0 ); Compute z as the exponential of the remaining bits by a polynomial minus one exp(x) = intVal * fracVal * (1 + z)  Accuracy: Calculation is done with 63 bits of precision, so result should be correctly rounded for 99.9% of input values, with less than 1 ULP error otherwise.  @param x   a double @return double e<sup>x</sup> ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "FastMath.exp",
    "class_name": "org.apache.commons.math3.util.FastMath",
    "signature": "org.apache.commons.math3.util.FastMath.exp(double,double,double[])",
    "snippet": "    private static double exp(double x, double extra, double[] hiPrec) {\n        double intPartA;\n        double intPartB;\n        int intVal;\n\n        /* Lookup exp(floor(x)).\n         * intPartA will have the upper 22 bits, intPartB will have the lower\n         * 52 bits.\n         */\n        if (x < 0.0) {\n            intVal = (int) -x;\n\n            if (intVal > 746) {\n                if (hiPrec != null) {\n                    hiPrec[0] = 0.0;\n                    hiPrec[1] = 0.0;\n                }\n                return 0.0;\n            }\n\n            if (intVal > 709) {\n                /* This will produce a subnormal output */\n                final double result = exp(x+40.19140625, extra, hiPrec) / 285040095144011776.0;\n                if (hiPrec != null) {\n                    hiPrec[0] /= 285040095144011776.0;\n                    hiPrec[1] /= 285040095144011776.0;\n                }\n                return result;\n            }\n\n            if (intVal == 709) {\n                /* exp(1.494140625) is nearly a machine number... */\n                final double result = exp(x+1.494140625, extra, hiPrec) / 4.455505956692756620;\n                if (hiPrec != null) {\n                    hiPrec[0] /= 4.455505956692756620;\n                    hiPrec[1] /= 4.455505956692756620;\n                }\n                return result;\n            }\n\n            intVal++;\n\n            intPartA = ExpIntTable.EXP_INT_TABLE_A[EXP_INT_TABLE_MAX_INDEX-intVal];\n            intPartB = ExpIntTable.EXP_INT_TABLE_B[EXP_INT_TABLE_MAX_INDEX-intVal];\n\n            intVal = -intVal;\n        } else {\n            intVal = (int) x;\n\n            if (intVal > 709) {\n                if (hiPrec != null) {\n                    hiPrec[0] = Double.POSITIVE_INFINITY;\n                    hiPrec[1] = 0.0;\n                }\n                return Double.POSITIVE_INFINITY;\n            }\n\n            intPartA = ExpIntTable.EXP_INT_TABLE_A[EXP_INT_TABLE_MAX_INDEX+intVal];\n            intPartB = ExpIntTable.EXP_INT_TABLE_B[EXP_INT_TABLE_MAX_INDEX+intVal];\n        }\n\n        /* Get the fractional part of x, find the greatest multiple of 2^-10 less than\n         * x and look up the exp function of it.\n         * fracPartA will have the upper 22 bits, fracPartB the lower 52 bits.\n         */\n        final int intFrac = (int) ((x - intVal) * 1024.0);\n        final double fracPartA = ExpFracTable.EXP_FRAC_TABLE_A[intFrac];\n        final double fracPartB = ExpFracTable.EXP_FRAC_TABLE_B[intFrac];\n\n        /* epsilon is the difference in x from the nearest multiple of 2^-10.  It\n         * has a value in the range 0 <= epsilon < 2^-10.\n         * Do the subtraction from x as the last step to avoid possible loss of percison.\n         */\n        final double epsilon = x - (intVal + intFrac / 1024.0);\n\n        /* Compute z = exp(epsilon) - 1.0 via a minimax polynomial.  z has\n       full double precision (52 bits).  Since z < 2^-10, we will have\n       62 bits of precision when combined with the contant 1.  This will be\n       used in the last addition below to get proper rounding. */\n\n        /* Remez generated polynomial.  Converges on the interval [0, 2^-10], error\n       is less than 0.5 ULP */\n        double z = 0.04168701738764507;\n        z = z * epsilon + 0.1666666505023083;\n        z = z * epsilon + 0.5000000000042687;\n        z = z * epsilon + 1.0;\n        z = z * epsilon + -3.940510424527919E-20;\n\n        /* Compute (intPartA+intPartB) * (fracPartA+fracPartB) by binomial\n       expansion.\n       tempA is exact since intPartA and intPartB only have 22 bits each.\n       tempB will have 52 bits of precision.\n         */\n        double tempA = intPartA * fracPartA;\n        double tempB = intPartA * fracPartB + intPartB * fracPartA + intPartB * fracPartB;\n\n        /* Compute the result.  (1+z)(tempA+tempB).  Order of operations is\n       important.  For accuracy add by increasing size.  tempA is exact and\n       much larger than the others.  If there are extra bits specified from the\n       pow() function, use them. */\n        final double tempC = tempB + tempA;\n        final double result;\n        if (extra != 0.0) {\n            result = tempC*extra*z + tempC*extra + tempC*z + tempB + tempA;\n        } else {\n            result = tempC*z + tempB + tempA;\n        }\n\n        if (hiPrec != null) {\n            // If requesting high precision\n            hiPrec[0] = tempA;\n            hiPrec[1] = tempC*extra*z + tempC*extra + tempC*z + tempB;\n        }\n\n        return result;\n    }",
    "comment": " Internal helper method for exponential function. @param x original argument of the exponential function @param extra extra bits of precision on input (To Be Confirmed) @param hiPrec extra bits of precision on output (To Be Confirmed) @return exp(x) ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "FastMath.log",
    "class_name": "org.apache.commons.math3.util.FastMath",
    "signature": "org.apache.commons.math3.util.FastMath.log(double,double[])",
    "snippet": "    private static double log(final double x, final double[] hiPrec) {\n        if (x==0) { // Handle special case of +0/-0\n            return Double.NEGATIVE_INFINITY;\n        }\n        long bits = Double.doubleToLongBits(x);\n\n        /* Handle special cases of negative input, and NaN */\n        if ((bits & 0x8000000000000000L) != 0 || x != x) {\n            if (x != 0.0) {\n                if (hiPrec != null) {\n                    hiPrec[0] = Double.NaN;\n                }\n\n                return Double.NaN;\n            }\n        }\n\n        /* Handle special cases of Positive infinity. */\n        if (x == Double.POSITIVE_INFINITY) {\n            if (hiPrec != null) {\n                hiPrec[0] = Double.POSITIVE_INFINITY;\n            }\n\n            return Double.POSITIVE_INFINITY;\n        }\n\n        /* Extract the exponent */\n        int exp = (int)(bits >> 52)-1023;\n\n        if ((bits & 0x7ff0000000000000L) == 0) {\n            // Subnormal!\n            if (x == 0) {\n                // Zero\n                if (hiPrec != null) {\n                    hiPrec[0] = Double.NEGATIVE_INFINITY;\n                }\n\n                return Double.NEGATIVE_INFINITY;\n            }\n\n            /* Normalize the subnormal number. */\n            bits <<= 1;\n            while ( (bits & 0x0010000000000000L) == 0) {\n                --exp;\n                bits <<= 1;\n            }\n        }\n\n\n        if (exp == -1 || exp == 0) {\n            if (x < 1.01 && x > 0.99 && hiPrec == null) {\n                /* The normal method doesn't work well in the range [0.99, 1.01], so call do a straight\n           polynomial expansion in higer precision. */\n\n               /* Compute x - 1.0 and split it */\n                double xa = x - 1.0;\n                double xb = xa - x + 1.0;\n                double tmp = xa * HEX_40000000;\n                double aa = xa + tmp - tmp;\n                double ab = xa - aa;\n                xa = aa;\n                xb = ab;\n\n                final double[] lnCoef_last = LN_QUICK_COEF[LN_QUICK_COEF.length - 1];\n                double ya = lnCoef_last[0];\n                double yb = lnCoef_last[1];\n\n                for (int i = LN_QUICK_COEF.length - 2; i >= 0; i--) {\n                    /* Multiply a = y * x */\n                    aa = ya * xa;\n                    ab = ya * xb + yb * xa + yb * xb;\n                    /* split, so now y = a */\n                    tmp = aa * HEX_40000000;\n                    ya = aa + tmp - tmp;\n                    yb = aa - ya + ab;\n\n                    /* Add  a = y + lnQuickCoef */\n                    final double[] lnCoef_i = LN_QUICK_COEF[i];\n                    aa = ya + lnCoef_i[0];\n                    ab = yb + lnCoef_i[1];\n                    /* Split y = a */\n                    tmp = aa * HEX_40000000;\n                    ya = aa + tmp - tmp;\n                    yb = aa - ya + ab;\n                }\n\n                /* Multiply a = y * x */\n                aa = ya * xa;\n                ab = ya * xb + yb * xa + yb * xb;\n                /* split, so now y = a */\n                tmp = aa * HEX_40000000;\n                ya = aa + tmp - tmp;\n                yb = aa - ya + ab;\n\n                return ya + yb;\n            }\n        }\n\n        // lnm is a log of a number in the range of 1.0 - 2.0, so 0 <= lnm < ln(2)\n        final double[] lnm = lnMant.LN_MANT[(int)((bits & 0x000ffc0000000000L) >> 42)];\n\n        /*\n    double epsilon = x / Double.longBitsToDouble(bits & 0xfffffc0000000000L);\n\n    epsilon -= 1.0;\n         */\n\n        // y is the most significant 10 bits of the mantissa\n        //double y = Double.longBitsToDouble(bits & 0xfffffc0000000000L);\n        //double epsilon = (x - y) / y;\n        final double epsilon = (bits & 0x3ffffffffffL) / (TWO_POWER_52 + (bits & 0x000ffc0000000000L));\n\n        double lnza = 0.0;\n        double lnzb = 0.0;\n\n        if (hiPrec != null) {\n            /* split epsilon -> x */\n            double tmp = epsilon * HEX_40000000;\n            double aa = epsilon + tmp - tmp;\n            double ab = epsilon - aa;\n            double xa = aa;\n            double xb = ab;\n\n            /* Need a more accurate epsilon, so adjust the division. */\n            final double numer = bits & 0x3ffffffffffL;\n            final double denom = TWO_POWER_52 + (bits & 0x000ffc0000000000L);\n            aa = numer - xa*denom - xb * denom;\n            xb += aa / denom;\n\n            /* Remez polynomial evaluation */\n            final double[] lnCoef_last = LN_HI_PREC_COEF[LN_HI_PREC_COEF.length-1];\n            double ya = lnCoef_last[0];\n            double yb = lnCoef_last[1];\n\n            for (int i = LN_HI_PREC_COEF.length - 2; i >= 0; i--) {\n                /* Multiply a = y * x */\n                aa = ya * xa;\n                ab = ya * xb + yb * xa + yb * xb;\n                /* split, so now y = a */\n                tmp = aa * HEX_40000000;\n                ya = aa + tmp - tmp;\n                yb = aa - ya + ab;\n\n                /* Add  a = y + lnHiPrecCoef */\n                final double[] lnCoef_i = LN_HI_PREC_COEF[i];\n                aa = ya + lnCoef_i[0];\n                ab = yb + lnCoef_i[1];\n                /* Split y = a */\n                tmp = aa * HEX_40000000;\n                ya = aa + tmp - tmp;\n                yb = aa - ya + ab;\n            }\n\n            /* Multiply a = y * x */\n            aa = ya * xa;\n            ab = ya * xb + yb * xa + yb * xb;\n\n            /* split, so now lnz = a */\n            /*\n      tmp = aa * 1073741824.0;\n      lnza = aa + tmp - tmp;\n      lnzb = aa - lnza + ab;\n             */\n            lnza = aa + ab;\n            lnzb = -(lnza - aa - ab);\n        } else {\n            /* High precision not required.  Eval Remez polynomial\n         using standard double precision */\n            lnza = -0.16624882440418567;\n            lnza = lnza * epsilon + 0.19999954120254515;\n            lnza = lnza * epsilon + -0.2499999997677497;\n            lnza = lnza * epsilon + 0.3333333333332802;\n            lnza = lnza * epsilon + -0.5;\n            lnza = lnza * epsilon + 1.0;\n            lnza = lnza * epsilon;\n        }\n\n        /* Relative sizes:\n         * lnzb     [0, 2.33E-10]\n         * lnm[1]   [0, 1.17E-7]\n         * ln2B*exp [0, 1.12E-4]\n         * lnza      [0, 9.7E-4]\n         * lnm[0]   [0, 0.692]\n         * ln2A*exp [0, 709]\n         */\n\n        /* Compute the following sum:\n         * lnzb + lnm[1] + ln2B*exp + lnza + lnm[0] + ln2A*exp;\n         */\n\n        //return lnzb + lnm[1] + ln2B*exp + lnza + lnm[0] + ln2A*exp;\n        double a = LN_2_A*exp;\n        double b = 0.0;\n        double c = a+lnm[0];\n        double d = -(c-a-lnm[0]);\n        a = c;\n        b = b + d;\n\n        c = a + lnza;\n        d = -(c - a - lnza);\n        a = c;\n        b = b + d;\n\n        c = a + LN_2_B*exp;\n        d = -(c - a - LN_2_B*exp);\n        a = c;\n        b = b + d;\n\n        c = a + lnm[1];\n        d = -(c - a - lnm[1]);\n        a = c;\n        b = b + d;\n\n        c = a + lnzb;\n        d = -(c - a - lnzb);\n        a = c;\n        b = b + d;\n\n        if (hiPrec != null) {\n            hiPrec[0] = a;\n            hiPrec[1] = b;\n        }\n\n        return a + b;\n    }",
    "comment": " Internal helper method for natural logarithm function. @param x original argument of the natural logarithm function @param hiPrec extra bits of precision on output (To Be Confirmed) @return log(x) ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "FastMath.min",
    "class_name": "org.apache.commons.math3.util.FastMath",
    "signature": "org.apache.commons.math3.util.FastMath.min(int,int)",
    "snippet": "    public static int min(final int a, final int b) {\n        return (a <= b) ? a : b;\n    }",
    "comment": "Compute the minimum of two values @param a first value @param b second value @return a if a is lesser or equal to b, b otherwise ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "FastMath.pow",
    "class_name": "org.apache.commons.math3.util.FastMath",
    "signature": "org.apache.commons.math3.util.FastMath.pow(double,double)",
    "snippet": "    public static double pow(double x, double y) {\n        final double lns[] = new double[2];\n\n        if (y == 0.0) {\n            return 1.0;\n        }\n\n        if (x != x) { // X is NaN\n            return x;\n        }\n\n\n        if (x == 0) {\n            long bits = Double.doubleToLongBits(x);\n            if ((bits & 0x8000000000000000L) != 0) {\n                // -zero\n                long yi = (long) y;\n\n                if (y < 0 && y == yi && (yi & 1) == 1) {\n                    return Double.NEGATIVE_INFINITY;\n                }\n\n                if (y > 0 && y == yi && (yi & 1) == 1) {\n                    return -0.0;\n                }\n            }\n\n            if (y < 0) {\n                return Double.POSITIVE_INFINITY;\n            }\n            if (y > 0) {\n                return 0.0;\n            }\n\n            return Double.NaN;\n        }\n\n        if (x == Double.POSITIVE_INFINITY) {\n            if (y != y) { // y is NaN\n                return y;\n            }\n            if (y < 0.0) {\n                return 0.0;\n            } else {\n                return Double.POSITIVE_INFINITY;\n            }\n        }\n\n        if (y == Double.POSITIVE_INFINITY) {\n            if (x * x == 1.0) {\n                return Double.NaN;\n            }\n\n            if (x * x > 1.0) {\n                return Double.POSITIVE_INFINITY;\n            } else {\n                return 0.0;\n            }\n        }\n\n        if (x == Double.NEGATIVE_INFINITY) {\n            if (y != y) { // y is NaN\n                return y;\n            }\n\n            if (y < 0) {\n                long yi = (long) y;\n                if (y == yi && (yi & 1) == 1) {\n                    return -0.0;\n                }\n\n                return 0.0;\n            }\n\n            if (y > 0)  {\n                long yi = (long) y;\n                if (y == yi && (yi & 1) == 1) {\n                    return Double.NEGATIVE_INFINITY;\n                }\n\n                return Double.POSITIVE_INFINITY;\n            }\n        }\n\n        if (y == Double.NEGATIVE_INFINITY) {\n\n            if (x * x == 1.0) {\n                return Double.NaN;\n            }\n\n            if (x * x < 1.0) {\n                return Double.POSITIVE_INFINITY;\n            } else {\n                return 0.0;\n            }\n        }\n\n        /* Handle special case x<0 */\n        if (x < 0) {\n            // y is an even integer in this case\n            if (y >= TWO_POWER_53 || y <= -TWO_POWER_53) {\n                return pow(-x, y);\n            }\n\n            if (y == (long) y) {\n                // If y is an integer\n                return ((long)y & 1) == 0 ? pow(-x, y) : -pow(-x, y);\n            } else {\n                return Double.NaN;\n            }\n        }\n\n        /* Split y into ya and yb such that y = ya+yb */\n        double ya;\n        double yb;\n        if (y < 8e298 && y > -8e298) {\n            double tmp1 = y * HEX_40000000;\n            ya = y + tmp1 - tmp1;\n            yb = y - ya;\n        } else {\n            double tmp1 = y * 9.31322574615478515625E-10;\n            double tmp2 = tmp1 * 9.31322574615478515625E-10;\n            ya = (tmp1 + tmp2 - tmp1) * HEX_40000000 * HEX_40000000;\n            yb = y - ya;\n        }\n\n        /* Compute ln(x) */\n        final double lores = log(x, lns);\n        if (Double.isInfinite(lores)){ // don't allow this to be converted to NaN\n            return lores;\n        }\n\n        double lna = lns[0];\n        double lnb = lns[1];\n\n        /* resplit lns */\n        double tmp1 = lna * HEX_40000000;\n        double tmp2 = lna + tmp1 - tmp1;\n        lnb += lna - tmp2;\n        lna = tmp2;\n\n        // y*ln(x) = (aa+ab)\n        final double aa = lna * ya;\n        final double ab = lna * yb + lnb * ya + lnb * yb;\n\n        lna = aa+ab;\n        lnb = -(lna - aa - ab);\n\n        double z = 1.0 / 120.0;\n        z = z * lnb + (1.0 / 24.0);\n        z = z * lnb + (1.0 / 6.0);\n        z = z * lnb + 0.5;\n        z = z * lnb + 1.0;\n        z = z * lnb;\n\n        final double result = exp(lna, z, null);\n        //result = result + result * z;\n        return result;\n    }",
    "comment": " Power function.  Compute x^y.  @param x   a double @param y   a double @return double ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "FastMath.pow",
    "class_name": "org.apache.commons.math3.util.FastMath",
    "signature": "org.apache.commons.math3.util.FastMath.pow(double,int)",
    "snippet": "    public static double pow(double d, int e) {\n\n        if (e == 0) {\n            return 1.0;\n        } else if (e < 0) {\n            e = -e;\n            d = 1.0 / d;\n        }\n\n        // split d as two 26 bits numbers\n        // beware the following expressions must NOT be simplified, they rely on floating point arithmetic properties\n        final int splitFactor = 0x8000001;\n        final double cd       = splitFactor * d;\n        final double d1High   = cd - (cd - d);\n        final double d1Low    = d - d1High;\n\n        // prepare result\n        double resultHigh = 1;\n        double resultLow  = 0;\n\n        // d^(2p)\n        double d2p     = d;\n        double d2pHigh = d1High;\n        double d2pLow  = d1Low;\n\n        while (e != 0) {\n\n            if ((e & 0x1) != 0) {\n                // accurate multiplication result = result * d^(2p) using Veltkamp TwoProduct algorithm\n                // beware the following expressions must NOT be simplified, they rely on floating point arithmetic properties\n                final double tmpHigh = resultHigh * d2p;\n                final double cRH     = splitFactor * resultHigh;\n                final double rHH     = cRH - (cRH - resultHigh);\n                final double rHL     = resultHigh - rHH;\n                final double tmpLow  = rHL * d2pLow - (((tmpHigh - rHH * d2pHigh) - rHL * d2pHigh) - rHH * d2pLow);\n                resultHigh = tmpHigh;\n                resultLow  = resultLow * d2p + tmpLow;\n            }\n\n            // accurate squaring d^(2(p+1)) = d^(2p) * d^(2p) using Veltkamp TwoProduct algorithm\n            // beware the following expressions must NOT be simplified, they rely on floating point arithmetic properties\n            final double tmpHigh = d2pHigh * d2p;\n            final double cD2pH   = splitFactor * d2pHigh;\n            final double d2pHH   = cD2pH - (cD2pH - d2pHigh);\n            final double d2pHL   = d2pHigh - d2pHH;\n            final double tmpLow  = d2pHL * d2pLow - (((tmpHigh - d2pHH * d2pHigh) - d2pHL * d2pHigh) - d2pHH * d2pLow);\n            final double cTmpH   = splitFactor * tmpHigh;\n            d2pHigh = cTmpH - (cTmpH - tmpHigh);\n            d2pLow  = d2pLow * d2p + tmpLow + (tmpHigh - d2pHigh);\n            d2p     = d2pHigh + d2pLow;\n\n            e = e >> 1;\n\n        }\n\n        return resultHigh + resultLow;\n\n    }",
    "comment": " Raise a double to an int power.  @param d Number to raise. @param e Exponent. @return d<sup>e</sup> @since 3.1 ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "FastMath.sqrt",
    "class_name": "org.apache.commons.math3.util.FastMath",
    "signature": "org.apache.commons.math3.util.FastMath.sqrt(double)",
    "snippet": "    public static double sqrt(final double a) {\n        return Math.sqrt(a);\n    }",
    "comment": "Compute the square root of a number. <p><b>Note:</b> this implementation currently delegates to {@link Math#sqrt} @param a number on which evaluation is done @return square root of a ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "FastMathLiteralArrays.loadExpFracA",
    "class_name": "org.apache.commons.math3.util.FastMathLiteralArrays",
    "signature": "org.apache.commons.math3.util.FastMathLiteralArrays.loadExpFracA()",
    "snippet": "    static double[] loadExpFracA() {\n        return EXP_FRAC_A.clone();\n    }",
    "comment": " Load \"EXP_FRAC_A\".  @return a clone of the data array. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "FastMathLiteralArrays.loadExpFracB",
    "class_name": "org.apache.commons.math3.util.FastMathLiteralArrays",
    "signature": "org.apache.commons.math3.util.FastMathLiteralArrays.loadExpFracB()",
    "snippet": "    static double[] loadExpFracB() {\n        return EXP_FRAC_B.clone();\n    }",
    "comment": " Load \"EXP_FRAC_B\".  @return a clone of the data array. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "FastMathLiteralArrays.loadExpIntA",
    "class_name": "org.apache.commons.math3.util.FastMathLiteralArrays",
    "signature": "org.apache.commons.math3.util.FastMathLiteralArrays.loadExpIntA()",
    "snippet": "    static double[] loadExpIntA() {\n        return EXP_INT_A.clone();\n    }",
    "comment": " Load \"EXP_INT_A\".  @return a clone of the data array. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "FastMathLiteralArrays.loadExpIntB",
    "class_name": "org.apache.commons.math3.util.FastMathLiteralArrays",
    "signature": "org.apache.commons.math3.util.FastMathLiteralArrays.loadExpIntB()",
    "snippet": "    static double[] loadExpIntB() {\n        return EXP_INT_B.clone();\n    }",
    "comment": " Load \"EXP_INT_B\".  @return a clone of the data array. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "FastMathLiteralArrays.loadLnMant",
    "class_name": "org.apache.commons.math3.util.FastMathLiteralArrays",
    "signature": "org.apache.commons.math3.util.FastMathLiteralArrays.loadLnMant()",
    "snippet": "    static double[][] loadLnMant() {\n        return LN_MANT.clone();\n    }",
    "comment": " Load \"LN_MANT\".  @return a clone of the data array. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "MathArrays.copyOf",
    "class_name": "org.apache.commons.math3.util.MathArrays",
    "signature": "org.apache.commons.math3.util.MathArrays.copyOf(double[])",
    "snippet": "     public static double[] copyOf(double[] source) {\n         return copyOf(source, source.length);\n     }",
    "comment": " Creates a copy of the {@code source} array.  @param source Array to be copied. @return the copied array. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "MathArrays.copyOf",
    "class_name": "org.apache.commons.math3.util.MathArrays",
    "signature": "org.apache.commons.math3.util.MathArrays.copyOf(double[],int)",
    "snippet": "    public static double[] copyOf(double[] source, int len) {\n         final double[] output = new double[len];\n         System.arraycopy(source, 0, output, 0, FastMath.min(len, source.length));\n         return output;\n     }",
    "comment": " Creates a copy of the {@code source} array.  @param source Array to be copied. @param len Number of entries to copy. If smaller then the source length, the copy will be truncated, if larger it will padded with zeroes. @return the copied array. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "MathUtils.checkNotNull",
    "class_name": "org.apache.commons.math3.util.MathUtils",
    "signature": "org.apache.commons.math3.util.MathUtils.checkNotNull(Object)",
    "snippet": "    public static void checkNotNull(Object o)\n        throws NullArgumentException {\n        if (o == null) {\n            throw new NullArgumentException();\n        }\n    }",
    "comment": " Checks that an object is not null.  @param o Object to be checked. @throws NullArgumentException if {@code o} is {@code null}. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "Precision.equals",
    "class_name": "org.apache.commons.math3.util.Precision",
    "signature": "org.apache.commons.math3.util.Precision.equals(double,double,double)",
    "snippet": "    public static boolean equals(double x, double y, double eps) {\n        return equals(x, y, 1) || FastMath.abs(y - x) <= eps;\n    }",
    "comment": " Returns {@code true} if there is no double value strictly between the arguments or the difference between them is within the range of allowed error (inclusive).  @param x First value. @param y Second value. @param eps Amount of allowed absolute error. @return {@code true} if the values are two adjacent floating point numbers or they are within range of each other. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "Precision.equals",
    "class_name": "org.apache.commons.math3.util.Precision",
    "signature": "org.apache.commons.math3.util.Precision.equals(double,double,int)",
    "snippet": "    public static boolean equals(double x, double y, int maxUlps) {\n        long xInt = Double.doubleToLongBits(x);\n        long yInt = Double.doubleToLongBits(y);\n\n        // Make lexicographically ordered as a two's-complement integer.\n        if (xInt < 0) {\n            xInt = SGN_MASK - xInt;\n        }\n        if (yInt < 0) {\n            yInt = SGN_MASK - yInt;\n        }\n\n        final boolean isEqual = FastMath.abs(xInt - yInt) <= maxUlps;\n\n        return isEqual && !Double.isNaN(x) && !Double.isNaN(y);\n    }",
    "comment": " Returns true if both arguments are equal or within the range of allowed error (inclusive). Two float numbers are considered equal if there are {@code (maxUlps - 1)} (or fewer) floating point numbers between them, i.e. two adjacent floating point numbers are considered equal. Adapted from <a href=\"http://www.cygnus-software.com/papers/comparingfloats/comparingfloats.htm\"> Bruce Dawson</a>  @param x first value @param y second value @param maxUlps {@code (maxUlps - 1)} is the number of floating point values between {@code x} and {@code y}. @return {@code true} if there are fewer than {@code maxUlps} floating point values between {@code x} and {@code y}. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  }
]