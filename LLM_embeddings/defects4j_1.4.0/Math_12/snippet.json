[
  {
    "name": "AbstractRealDistribution.AbstractRealDistribution",
    "class_name": "org.apache.commons.math3.distribution.AbstractRealDistribution",
    "signature": "org.apache.commons.math3.distribution.AbstractRealDistribution.AbstractRealDistribution(RandomGenerator)",
    "snippet": "    protected AbstractRealDistribution(RandomGenerator rng) {\n        random = rng;\n    }",
    "comment": " @param rng Random number generator. @since 3.1 ",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 0
  },
  {
    "name": "AbstractRealDistribution.reseedRandomGenerator",
    "class_name": "org.apache.commons.math3.distribution.AbstractRealDistribution",
    "signature": "org.apache.commons.math3.distribution.AbstractRealDistribution.reseedRandomGenerator(long)",
    "snippet": "    public void reseedRandomGenerator(long seed) {\n        random.setSeed(seed);\n        randomData.reSeed(seed);\n    }",
    "comment": "{@inheritDoc} */",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 0
  },
  {
    "name": "GammaDistribution.GammaDistribution",
    "class_name": "org.apache.commons.math3.distribution.GammaDistribution",
    "signature": "org.apache.commons.math3.distribution.GammaDistribution.GammaDistribution(RandomGenerator,double,double,double)",
    "snippet": "    public GammaDistribution(RandomGenerator rng,\n                             double shape,\n                             double scale,\n                             double inverseCumAccuracy)\n        throws NotStrictlyPositiveException {\n        super(rng);\n\n        if (shape <= 0) {\n            throw new NotStrictlyPositiveException(LocalizedFormats.SHAPE, shape);\n        }\n        if (scale <= 0) {\n            throw new NotStrictlyPositiveException(LocalizedFormats.SCALE, scale);\n        }\n\n        this.shape = shape;\n        this.scale = scale;\n        this.solverAbsoluteAccuracy = inverseCumAccuracy;\n        this.shiftedShape = shape + Gamma.LANCZOS_G + 0.5;\n        final double aux = FastMath.E / (2.0 * FastMath.PI * shiftedShape);\n        this.densityPrefactor2 = shape * FastMath.sqrt(aux) / Gamma.lanczos(shape);\n        this.densityPrefactor1 = this.densityPrefactor2 / scale *\n                FastMath.pow(shiftedShape, -shape) *\n                FastMath.exp(shape + Gamma.LANCZOS_G);\n        this.minY = shape + Gamma.LANCZOS_G - FastMath.log(Double.MAX_VALUE);\n        this.maxLogY = FastMath.log(Double.MAX_VALUE) / (shape - 1.0);\n    }",
    "comment": " Creates a Gamma distribution.  @param rng Random number generator. @param shape the shape parameter @param scale the scale parameter @param inverseCumAccuracy the maximum absolute error in inverse cumulative probability estimates (defaults to {@link #DEFAULT_INVERSE_ABSOLUTE_ACCURACY}). @throws NotStrictlyPositiveException if {@code shape <= 0} or {@code scale <= 0}. @since 3.1 ",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 0
  },
  {
    "name": "GammaDistribution.GammaDistribution",
    "class_name": "org.apache.commons.math3.distribution.GammaDistribution",
    "signature": "org.apache.commons.math3.distribution.GammaDistribution.GammaDistribution(double,double)",
    "snippet": "    public GammaDistribution(double shape, double scale) throws NotStrictlyPositiveException {\n        this(shape, scale, DEFAULT_INVERSE_ABSOLUTE_ACCURACY);\n    }",
    "comment": " Creates a new gamma distribution with specified values of the shape and scale parameters.  @param shape the shape parameter @param scale the scale parameter @throws NotStrictlyPositiveException if {@code shape <= 0} or {@code scale <= 0}. ",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 0
  },
  {
    "name": "GammaDistribution.GammaDistribution",
    "class_name": "org.apache.commons.math3.distribution.GammaDistribution",
    "signature": "org.apache.commons.math3.distribution.GammaDistribution.GammaDistribution(double,double,double)",
    "snippet": "    public GammaDistribution(double shape, double scale, double inverseCumAccuracy)\n        throws NotStrictlyPositiveException {\n        this(new Well19937c(), shape, scale, inverseCumAccuracy);\n    }",
    "comment": " Creates a new gamma distribution with specified values of the shape and scale parameters.  @param shape the shape parameter @param scale the scale parameter @param inverseCumAccuracy the maximum absolute error in inverse cumulative probability estimates (defaults to {@link #DEFAULT_INVERSE_ABSOLUTE_ACCURACY}). @throws NotStrictlyPositiveException if {@code shape <= 0} or {@code scale <= 0}. @since 2.1 ",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 0
  },
  {
    "name": "GammaDistribution.sample",
    "class_name": "org.apache.commons.math3.distribution.GammaDistribution",
    "signature": "org.apache.commons.math3.distribution.GammaDistribution.sample()",
    "snippet": "    @Override\n    public double sample()  {\n        if (shape < 1) {\n            // [1]: p. 228, Algorithm GS\n\n            while (true) {\n                // Step 1:\n                final double u = random.nextDouble();\n                final double bGS = 1 + shape / FastMath.E;\n                final double p = bGS * u;\n\n                if (p <= 1) {\n                    // Step 2:\n\n                    final double x = FastMath.pow(p, 1 / shape);\n                    final double u2 = random.nextDouble();\n\n                    if (u2 > FastMath.exp(-x)) {\n                        // Reject\n                        continue;\n                    } else {\n                        return scale * x;\n                    }\n                } else {\n                    // Step 3:\n\n                    final double x = -1 * FastMath.log((bGS - p) / shape);\n                    final double u2 = random.nextDouble();\n\n                    if (u2 > FastMath.pow(x, shape - 1)) {\n                        // Reject\n                        continue;\n                    } else {\n                        return scale * x;\n                    }\n                }\n            }\n        }\n\n        // Now shape >= 1\n\n        final double d = shape - 0.333333333333333333;\n        final double c = 1 / (3 * FastMath.sqrt(d));\n\n        while (true) {\n            final double x = random.nextGaussian();\n            final double v = (1 + c * x) * (1 + c * x) * (1 + c * x);\n\n            if (v <= 0) {\n                continue;\n            }\n\n            final double x2 = x * x;\n            final double u = random.nextDouble();\n\n            // Squeeze\n            if (u < 1 - 0.0331 * x2 * x2) {\n                return scale * d * v;\n            }\n\n            if (FastMath.log(u) < 0.5 * x2 + d * (1 - v + FastMath.log(v))) {\n                return scale * d * v;\n            }\n        }\n    }",
    "comment": " <p>This implementation uses the following algorithms: </p>  <p>For 0 < shape < 1: <br/> Ahrens, J. H. and Dieter, U., <i>Computer methods for sampling from gamma, beta, Poisson and binomial distributions.</i> Computing, 12, 223-246, 1974.</p>  <p>For shape >= 1: <br/> Marsaglia and Tsang, <i>A Simple Method for Generating Gamma Variables.</i> ACM Transactions on Mathematical Software, Volume 26 Issue 3, September, 2000.</p>  @return random value sampled from the Gamma(shape, scale) distribution ",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 0
  },
  {
    "name": "LogNormalDistribution.LogNormalDistribution",
    "class_name": "org.apache.commons.math3.distribution.LogNormalDistribution",
    "signature": "org.apache.commons.math3.distribution.LogNormalDistribution.LogNormalDistribution(RandomGenerator,double,double,double)",
    "snippet": "    public LogNormalDistribution(RandomGenerator rng,\n                                 double scale,\n                                 double shape,\n                                 double inverseCumAccuracy)\n        throws NotStrictlyPositiveException {\n        super(rng);\n\n        if (shape <= 0) {\n            throw new NotStrictlyPositiveException(LocalizedFormats.SHAPE, shape);\n        }\n\n        this.scale = scale;\n        this.shape = shape;\n        this.solverAbsoluteAccuracy = inverseCumAccuracy;\n    }",
    "comment": " Creates a log-normal distribution.  @param rng Random number generator. @param scale Scale parameter of this distribution. @param shape Shape parameter of this distribution. @param inverseCumAccuracy Inverse cumulative probability accuracy. @throws NotStrictlyPositiveException if {@code shape <= 0}. @since 3.1 ",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 0
  },
  {
    "name": "LogNormalDistribution.LogNormalDistribution",
    "class_name": "org.apache.commons.math3.distribution.LogNormalDistribution",
    "signature": "org.apache.commons.math3.distribution.LogNormalDistribution.LogNormalDistribution(double,double)",
    "snippet": "    public LogNormalDistribution(double scale, double shape)\n        throws NotStrictlyPositiveException {\n        this(scale, shape, DEFAULT_INVERSE_ABSOLUTE_ACCURACY);\n    }",
    "comment": " Create a log-normal distribution using the specified scale and shape.  @param scale the scale parameter of this distribution @param shape the shape parameter of this distribution @throws NotStrictlyPositiveException if {@code shape <= 0}. ",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 0
  },
  {
    "name": "LogNormalDistribution.LogNormalDistribution",
    "class_name": "org.apache.commons.math3.distribution.LogNormalDistribution",
    "signature": "org.apache.commons.math3.distribution.LogNormalDistribution.LogNormalDistribution(double,double,double)",
    "snippet": "    public LogNormalDistribution(double scale, double shape, double inverseCumAccuracy)\n        throws NotStrictlyPositiveException {\n        this(new Well19937c(), scale, shape, inverseCumAccuracy);\n    }",
    "comment": " Create a log-normal distribution using the specified scale, shape and inverse cumulative distribution accuracy.  @param scale the scale parameter of this distribution @param shape the shape parameter of this distribution @param inverseCumAccuracy Inverse cumulative probability accuracy. @throws NotStrictlyPositiveException if {@code shape <= 0}. ",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 0
  },
  {
    "name": "LogNormalDistribution.sample",
    "class_name": "org.apache.commons.math3.distribution.LogNormalDistribution",
    "signature": "org.apache.commons.math3.distribution.LogNormalDistribution.sample()",
    "snippet": "    @Override\n    public double sample()  {\n        final double n = random.nextGaussian();\n        return FastMath.exp(scale + shape * n);\n    }",
    "comment": "{@inheritDoc} */",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 0
  },
  {
    "name": "NormalDistribution.NormalDistribution",
    "class_name": "org.apache.commons.math3.distribution.NormalDistribution",
    "signature": "org.apache.commons.math3.distribution.NormalDistribution.NormalDistribution(RandomGenerator,double,double,double)",
    "snippet": "    public NormalDistribution(RandomGenerator rng,\n                              double mean,\n                              double sd,\n                              double inverseCumAccuracy)\n        throws NotStrictlyPositiveException {\n        super(rng);\n\n        if (sd <= 0) {\n            throw new NotStrictlyPositiveException(LocalizedFormats.STANDARD_DEVIATION, sd);\n        }\n\n        this.mean = mean;\n        standardDeviation = sd;\n        solverAbsoluteAccuracy = inverseCumAccuracy;\n    }",
    "comment": " Creates a normal distribution.  @param rng Random number generator. @param mean Mean for this distribution. @param sd Standard deviation for this distribution. @param inverseCumAccuracy Inverse cumulative probability accuracy. @throws NotStrictlyPositiveException if {@code sd <= 0}. @since 3.1 ",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 0
  },
  {
    "name": "NormalDistribution.NormalDistribution",
    "class_name": "org.apache.commons.math3.distribution.NormalDistribution",
    "signature": "org.apache.commons.math3.distribution.NormalDistribution.NormalDistribution(double,double)",
    "snippet": "    public NormalDistribution(double mean, double sd)\n        throws NotStrictlyPositiveException {\n        this(mean, sd, DEFAULT_INVERSE_ABSOLUTE_ACCURACY);\n    }",
    "comment": " Create a normal distribution using the given mean and standard deviation.  @param mean Mean for this distribution. @param sd Standard deviation for this distribution. @throws NotStrictlyPositiveException if {@code sd <= 0}. ",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 0
  },
  {
    "name": "NormalDistribution.NormalDistribution",
    "class_name": "org.apache.commons.math3.distribution.NormalDistribution",
    "signature": "org.apache.commons.math3.distribution.NormalDistribution.NormalDistribution(double,double,double)",
    "snippet": "    public NormalDistribution(double mean, double sd, double inverseCumAccuracy)\n        throws NotStrictlyPositiveException {\n        this(new Well19937c(), mean, sd, inverseCumAccuracy);\n    }",
    "comment": " Create a normal distribution using the given mean, standard deviation and inverse cumulative distribution accuracy.  @param mean Mean for this distribution. @param sd Standard deviation for this distribution. @param inverseCumAccuracy Inverse cumulative probability accuracy. @throws NotStrictlyPositiveException if {@code sd <= 0}. @since 2.1 ",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 0
  },
  {
    "name": "NormalDistribution.sample",
    "class_name": "org.apache.commons.math3.distribution.NormalDistribution",
    "signature": "org.apache.commons.math3.distribution.NormalDistribution.sample()",
    "snippet": "    @Override\n    public double sample()  {\n        return standardDeviation * random.nextGaussian() + mean;\n    }",
    "comment": "{@inheritDoc} */",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 0
  },
  {
    "name": "AbstractWell.AbstractWell",
    "class_name": "org.apache.commons.math3.random.AbstractWell",
    "signature": "org.apache.commons.math3.random.AbstractWell.AbstractWell(int,int,int,int)",
    "snippet": "    protected AbstractWell(final int k, final int m1, final int m2, final int m3) {\n        this(k, m1, m2, m3, null);\n    }",
    "comment": "Creates a new random number generator. <p>The instance is initialized using the current time plus the system identity hash code of this instance as the seed.</p> @param k number of bits in the pool (not necessarily a multiple of 32) @param m1 first parameter of the algorithm @param m2 second parameter of the algorithm @param m3 third parameter of the algorithm ",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 0
  },
  {
    "name": "AbstractWell.AbstractWell",
    "class_name": "org.apache.commons.math3.random.AbstractWell",
    "signature": "org.apache.commons.math3.random.AbstractWell.AbstractWell(int,int,int,int,int[])",
    "snippet": "    protected AbstractWell(final int k, final int m1, final int m2, final int m3, final int[] seed) {\n\n        // the bits pool contains k bits, k = r w - p where r is the number\n        // of w bits blocks, w is the block size (always 32 in the original paper)\n        // and p is the number of unused bits in the last block\n        final int w = 32;\n        final int r = (k + w - 1) / w;\n        this.v      = new int[r];\n        this.index  = 0;\n\n        // precompute indirection index tables. These tables are used for optimizing access\n        // they allow saving computations like \"(j + r - 2) % r\" with costly modulo operations\n        iRm1 = new int[r];\n        iRm2 = new int[r];\n        i1   = new int[r];\n        i2   = new int[r];\n        i3   = new int[r];\n        for (int j = 0; j < r; ++j) {\n            iRm1[j] = (j + r - 1) % r;\n            iRm2[j] = (j + r - 2) % r;\n            i1[j]   = (j + m1)    % r;\n            i2[j]   = (j + m2)    % r;\n            i3[j]   = (j + m3)    % r;\n        }\n\n        // initialize the pool content\n        setSeed(seed);\n\n    }",
    "comment": "Creates a new random number generator using an int array seed. @param k number of bits in the pool (not necessarily a multiple of 32) @param m1 first parameter of the algorithm @param m2 second parameter of the algorithm @param m3 third parameter of the algorithm @param seed the initial seed (32 bits integers array), if null the seed of the generator will be related to the current time ",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 0
  },
  {
    "name": "AbstractWell.AbstractWell",
    "class_name": "org.apache.commons.math3.random.AbstractWell",
    "signature": "org.apache.commons.math3.random.AbstractWell.AbstractWell(int,int,int,int,long)",
    "snippet": "    protected AbstractWell(final int k, final int m1, final int m2, final int m3, final long seed) {\n        this(k, m1, m2, m3, new int[] { (int) (seed >>> 32), (int) (seed & 0xffffffffl) });\n    }",
    "comment": "Creates a new random number generator using a single long seed. @param k number of bits in the pool (not necessarily a multiple of 32) @param m1 first parameter of the algorithm @param m2 second parameter of the algorithm @param m3 third parameter of the algorithm @param seed the initial seed (64 bits integer) ",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 0
  },
  {
    "name": "AbstractWell.setSeed",
    "class_name": "org.apache.commons.math3.random.AbstractWell",
    "signature": "org.apache.commons.math3.random.AbstractWell.setSeed(int[])",
    "snippet": "    @Override\n    public void setSeed(final int[] seed) {\n        if (seed == null) {\n            setSeed(System.currentTimeMillis() + System.identityHashCode(this));\n            return;\n        }\n\n        System.arraycopy(seed, 0, v, 0, Math.min(seed.length, v.length));\n\n        if (seed.length < v.length) {\n            for (int i = seed.length; i < v.length; ++i) {\n                final long l = v[i - seed.length];\n                v[i] = (int) ((1812433253l * (l ^ (l >> 30)) + i) & 0xffffffffL);\n            }\n        }\n\n        index = 0;\n        clear();  // Clear normal deviate cache\n    }",
    "comment": "Reinitialize the generator as if just built with the given int array seed. <p>The state of the generator is exactly the same as a new generator built with the same seed.</p> @param seed the initial seed (32 bits integers array). If null the seed of the generator will be the system time plus the system identity hash code of the instance. ",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 0
  },
  {
    "name": "AbstractWell.setSeed",
    "class_name": "org.apache.commons.math3.random.AbstractWell",
    "signature": "org.apache.commons.math3.random.AbstractWell.setSeed(long)",
    "snippet": "    @Override\n    public void setSeed(final long seed) {\n        setSeed(new int[] { (int) (seed >>> 32), (int) (seed & 0xffffffffl) });\n    }",
    "comment": "Reinitialize the generator as if just built with the given long seed. <p>The state of the generator is exactly the same as a new generator built with the same seed.</p> @param seed the initial seed (64 bits integer) ",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 0
  },
  {
    "name": "BitsStreamGenerator.BitsStreamGenerator",
    "class_name": "org.apache.commons.math3.random.BitsStreamGenerator",
    "signature": "org.apache.commons.math3.random.BitsStreamGenerator.BitsStreamGenerator()",
    "snippet": "    public BitsStreamGenerator() {\n        nextGaussian = Double.NaN;\n    }",
    "comment": " Creates a new random number generator. ",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 0
  },
  {
    "name": "BitsStreamGenerator.clear",
    "class_name": "org.apache.commons.math3.random.BitsStreamGenerator",
    "signature": "org.apache.commons.math3.random.BitsStreamGenerator.clear()",
    "snippet": "    public void clear() {\n        nextGaussian = Double.NaN;\n    }",
    "comment": " Clears the cache used by the default implementation of {@link #nextGaussian}. ",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 0
  },
  {
    "name": "BitsStreamGenerator.nextDouble",
    "class_name": "org.apache.commons.math3.random.BitsStreamGenerator",
    "signature": "org.apache.commons.math3.random.BitsStreamGenerator.nextDouble()",
    "snippet": "    public double nextDouble() {\n        final long high = ((long) next(26)) << 26;\n        final int  low  = next(26);\n        return (high | low) * 0x1.0p-52d;\n    }",
    "comment": "{@inheritDoc} */",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 0
  },
  {
    "name": "BitsStreamGenerator.nextGaussian",
    "class_name": "org.apache.commons.math3.random.BitsStreamGenerator",
    "signature": "org.apache.commons.math3.random.BitsStreamGenerator.nextGaussian()",
    "snippet": "    public double nextGaussian() {\n\n        final double random;\n        if (Double.isNaN(nextGaussian)) {\n            // generate a new pair of gaussian numbers\n            final double x = nextDouble();\n            final double y = nextDouble();\n            final double alpha = 2 * FastMath.PI * x;\n            final double r      = FastMath.sqrt(-2 * FastMath.log(y));\n            random       = r * FastMath.cos(alpha);\n            nextGaussian = r * FastMath.sin(alpha);\n        } else {\n            // use the second element of the pair already generated\n            random = nextGaussian;\n            nextGaussian = Double.NaN;\n        }\n\n        return random;\n\n    }",
    "comment": "{@inheritDoc} */",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 0
  },
  {
    "name": "RandomDataGenerator.RandomDataGenerator",
    "class_name": "org.apache.commons.math3.random.RandomDataGenerator",
    "signature": "org.apache.commons.math3.random.RandomDataGenerator.RandomDataGenerator()",
    "snippet": "    public RandomDataGenerator() {\n    }",
    "comment": " Construct a RandomDataGenerator, using a default random generator as the source of randomness.  <p>The default generator is a {@link Well19937c} seeded with {@code System.currentTimeMillis() + System.identityHashCode(this))}. The generator is initialized and seeded on first use.</p> ",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 0
  },
  {
    "name": "RandomDataGenerator.getRan",
    "class_name": "org.apache.commons.math3.random.RandomDataGenerator",
    "signature": "org.apache.commons.math3.random.RandomDataGenerator.getRan()",
    "snippet": "    private RandomGenerator getRan() {\n        if (rand == null) {\n            initRan();\n        }\n        return rand;\n    }",
    "comment": " Returns the RandomGenerator used to generate non-secure random data. <p> Creates and initializes a default generator if null. Uses a {@link Well19937c} generator with {@code System.currentTimeMillis() + System.identityHashCode(this))} as the default seed. </p>  @return the Random used to generate random data ",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 0
  },
  {
    "name": "RandomDataGenerator.initRan",
    "class_name": "org.apache.commons.math3.random.RandomDataGenerator",
    "signature": "org.apache.commons.math3.random.RandomDataGenerator.initRan()",
    "snippet": "    private void initRan() {\n        rand = new Well19937c(System.currentTimeMillis() + System.identityHashCode(this));\n    }",
    "comment": " Sets the default generator to a {@link Well19937c} generator seeded with {@code System.currentTimeMillis() + System.identityHashCode(this))}. ",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 0
  },
  {
    "name": "RandomDataGenerator.reSeed",
    "class_name": "org.apache.commons.math3.random.RandomDataGenerator",
    "signature": "org.apache.commons.math3.random.RandomDataGenerator.reSeed(long)",
    "snippet": "    public void reSeed(long seed) {\n       getRan().setSeed(seed);\n    }",
    "comment": " Reseeds the random number generator with the supplied seed. <p> Will create and initialize if null. </p>  @param seed the seed value to use ",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 0
  },
  {
    "name": "RandomDataImpl.RandomDataImpl",
    "class_name": "org.apache.commons.math3.random.RandomDataImpl",
    "signature": "org.apache.commons.math3.random.RandomDataImpl.RandomDataImpl()",
    "snippet": "    public RandomDataImpl() {\n        delegate = new RandomDataGenerator();\n    }",
    "comment": " Construct a RandomDataImpl, using a default random generator as the source of randomness.  <p>The default generator is a {@link Well19937c} seeded with {@code System.currentTimeMillis() + System.identityHashCode(this))}. The generator is initialized and seeded on first use.</p> ",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 0
  },
  {
    "name": "RandomDataImpl.reSeed",
    "class_name": "org.apache.commons.math3.random.RandomDataImpl",
    "signature": "org.apache.commons.math3.random.RandomDataImpl.reSeed(long)",
    "snippet": "    public void reSeed(long seed) {\n        delegate.reSeed(seed);\n    }",
    "comment": " Reseeds the random number generator with the supplied seed. <p> Will create and initialize if null. </p>  @param seed the seed value to use ",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 0
  },
  {
    "name": "Well19937c.Well19937c",
    "class_name": "org.apache.commons.math3.random.Well19937c",
    "signature": "org.apache.commons.math3.random.Well19937c.Well19937c()",
    "snippet": "    public Well19937c() {\n        super(K, M1, M2, M3);\n    }",
    "comment": "Creates a new random number generator. <p>The instance is initialized using the current time as the seed.</p> ",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 0
  },
  {
    "name": "Well19937c.Well19937c",
    "class_name": "org.apache.commons.math3.random.Well19937c",
    "signature": "org.apache.commons.math3.random.Well19937c.Well19937c(long)",
    "snippet": "    public Well19937c(long seed) {\n        super(K, M1, M2, M3, seed);\n    }",
    "comment": "Creates a new random number generator using a single long seed. @param seed the initial seed (64 bits integer) ",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 0
  },
  {
    "name": "Well19937c.next",
    "class_name": "org.apache.commons.math3.random.Well19937c",
    "signature": "org.apache.commons.math3.random.Well19937c.next(int)",
    "snippet": "    @Override\n    protected int next(final int bits) {\n\n        final int indexRm1 = iRm1[index];\n        final int indexRm2 = iRm2[index];\n\n        final int v0       = v[index];\n        final int vM1      = v[i1[index]];\n        final int vM2      = v[i2[index]];\n        final int vM3      = v[i3[index]];\n\n        final int z0 = (0x80000000 & v[indexRm1]) ^ (0x7FFFFFFF & v[indexRm2]);\n        final int z1 = (v0 ^ (v0 << 25))  ^ (vM1 ^ (vM1 >>> 27));\n        final int z2 = (vM2 >>> 9) ^ (vM3 ^ (vM3 >>> 1));\n        final int z3 = z1      ^ z2;\n        int z4 = z0 ^ (z1 ^ (z1 << 9)) ^ (z2 ^ (z2 << 21)) ^ (z3 ^ (z3 >>> 21));\n\n        v[index]     = z3;\n        v[indexRm1]  = z4;\n        v[indexRm2] &= 0x80000000;\n        index        = indexRm1;\n\n\n        // add Matsumoto-Kurita tempering\n        // to get a maximally-equidistributed generator\n        z4 = z4 ^ ((z4 <<  7) & 0xe46e1700);\n        z4 = z4 ^ ((z4 << 15) & 0x9b868000);\n\n        return z4 >>> (32 - bits);\n\n    }",
    "comment": "{@inheritDoc} */",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 0
  },
  {
    "name": "Gamma.lanczos",
    "class_name": "org.apache.commons.math3.special.Gamma",
    "signature": "org.apache.commons.math3.special.Gamma.lanczos(double)",
    "snippet": "    public static double lanczos(final double x) {\n        double sum = 0.0;\n        for (int i = LANCZOS.length - 1; i > 0; --i) {\n            sum = sum + (LANCZOS[i] / (x + i));\n        }\n        return sum + LANCZOS[0];\n    }",
    "comment": " <p> Returns the Lanczos approximation used to compute the gamma function. The Lanczos approximation is related to the Gamma function by the following equation <center> {@code gamma(x) = sqrt(2 * pi) / x * (x + g + 0.5) ^ (x + 0.5) exp(-x - g - 0.5) * lanczos(x)}, </center> where {@code g} is the Lanczos constant. </p>  @param x Argument. @return The Lanczos approximation. @see <a href=\"http://mathworld.wolfram.com/LanczosApproximation.html\">Lanczos Approximation</a> equations (1) through (5), and Paul Godfrey's <a href=\"http://my.fit.edu/~gabdo/gamma.txt\">Note on the computation of the convergent Lanczos complex Gamma approximation</a> @since 3.1 ",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 0
  },
  {
    "name": "FastMath.cos",
    "class_name": "org.apache.commons.math3.util.FastMath",
    "signature": "org.apache.commons.math3.util.FastMath.cos(double)",
    "snippet": "    public static double cos(double x) {\n        int quadrant = 0;\n\n        /* Take absolute value of the input */\n        double xa = x;\n        if (x < 0) {\n            xa = -xa;\n        }\n\n        if (xa != xa || xa == Double.POSITIVE_INFINITY) {\n            return Double.NaN;\n        }\n\n        /* Perform any argument reduction */\n        double xb = 0;\n        if (xa > 3294198.0) {\n            // PI * (2**20)\n            // Argument too big for CodyWaite reduction.  Must use\n            // PayneHanek.\n            double reduceResults[] = new double[3];\n            reducePayneHanek(xa, reduceResults);\n            quadrant = ((int) reduceResults[0]) & 3;\n            xa = reduceResults[1];\n            xb = reduceResults[2];\n        } else if (xa > 1.5707963267948966) {\n            final CodyWaite cw = new CodyWaite(xa);\n            quadrant = cw.getK() & 3;\n            xa = cw.getRemA();\n            xb = cw.getRemB();\n        }\n\n        //if (negative)\n        //  quadrant = (quadrant + 2) % 4;\n\n        switch (quadrant) {\n            case 0:\n                return cosQ(xa, xb);\n            case 1:\n                return -sinQ(xa, xb);\n            case 2:\n                return -cosQ(xa, xb);\n            case 3:\n                return sinQ(xa, xb);\n            default:\n                return Double.NaN;\n        }\n    }",
    "comment": " Cosine function.  @param x Argument. @return cos(x) ",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 0
  },
  {
    "name": "FastMath.cosQ",
    "class_name": "org.apache.commons.math3.util.FastMath",
    "signature": "org.apache.commons.math3.util.FastMath.cosQ(double,double)",
    "snippet": "    private static double cosQ(double xa, double xb) {\n        final double pi2a = 1.5707963267948966;\n        final double pi2b = 6.123233995736766E-17;\n\n        final double a = pi2a - xa;\n        double b = -(a - pi2a + xa);\n        b += pi2b - xb;\n\n        return sinQ(a, b);\n    }",
    "comment": " Compute cosine in the first quadrant by subtracting input from PI/2 and then calling sinQ.  This is more accurate as the input approaches PI/2. @param xa number from which cosine is requested @param xb extra bits for x (may be 0.0) @return cos(xa + xb) ",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 0
  },
  {
    "name": "FastMath.exp",
    "class_name": "org.apache.commons.math3.util.FastMath",
    "signature": "org.apache.commons.math3.util.FastMath.exp(double)",
    "snippet": "    public static double exp(double x) {\n        return exp(x, 0.0, null);\n    }",
    "comment": " Exponential function.  Computes exp(x), function result is nearly rounded.   It will be correctly rounded to the theoretical value for 99.9% of input values, otherwise it will have a 1 UPL error.  Method: Lookup intVal = exp(int(x)) Lookup fracVal = exp(int(x-int(x) / 1024.0) * 1024.0 ); Compute z as the exponential of the remaining bits by a polynomial minus one exp(x) = intVal * fracVal * (1 + z)  Accuracy: Calculation is done with 63 bits of precision, so result should be correctly rounded for 99.9% of input values, with less than 1 ULP error otherwise.  @param x   a double @return double e<sup>x</sup> ",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 0
  },
  {
    "name": "FastMath.exp",
    "class_name": "org.apache.commons.math3.util.FastMath",
    "signature": "org.apache.commons.math3.util.FastMath.exp(double,double,double[])",
    "snippet": "    private static double exp(double x, double extra, double[] hiPrec) {\n        double intPartA;\n        double intPartB;\n        int intVal;\n\n        /* Lookup exp(floor(x)).\n         * intPartA will have the upper 22 bits, intPartB will have the lower\n         * 52 bits.\n         */\n        if (x < 0.0) {\n            intVal = (int) -x;\n\n            if (intVal > 746) {\n                if (hiPrec != null) {\n                    hiPrec[0] = 0.0;\n                    hiPrec[1] = 0.0;\n                }\n                return 0.0;\n            }\n\n            if (intVal > 709) {\n                /* This will produce a subnormal output */\n                final double result = exp(x+40.19140625, extra, hiPrec) / 285040095144011776.0;\n                if (hiPrec != null) {\n                    hiPrec[0] /= 285040095144011776.0;\n                    hiPrec[1] /= 285040095144011776.0;\n                }\n                return result;\n            }\n\n            if (intVal == 709) {\n                /* exp(1.494140625) is nearly a machine number... */\n                final double result = exp(x+1.494140625, extra, hiPrec) / 4.455505956692756620;\n                if (hiPrec != null) {\n                    hiPrec[0] /= 4.455505956692756620;\n                    hiPrec[1] /= 4.455505956692756620;\n                }\n                return result;\n            }\n\n            intVal++;\n\n            intPartA = ExpIntTable.EXP_INT_TABLE_A[EXP_INT_TABLE_MAX_INDEX-intVal];\n            intPartB = ExpIntTable.EXP_INT_TABLE_B[EXP_INT_TABLE_MAX_INDEX-intVal];\n\n            intVal = -intVal;\n        } else {\n            intVal = (int) x;\n\n            if (intVal > 709) {\n                if (hiPrec != null) {\n                    hiPrec[0] = Double.POSITIVE_INFINITY;\n                    hiPrec[1] = 0.0;\n                }\n                return Double.POSITIVE_INFINITY;\n            }\n\n            intPartA = ExpIntTable.EXP_INT_TABLE_A[EXP_INT_TABLE_MAX_INDEX+intVal];\n            intPartB = ExpIntTable.EXP_INT_TABLE_B[EXP_INT_TABLE_MAX_INDEX+intVal];\n        }\n\n        /* Get the fractional part of x, find the greatest multiple of 2^-10 less than\n         * x and look up the exp function of it.\n         * fracPartA will have the upper 22 bits, fracPartB the lower 52 bits.\n         */\n        final int intFrac = (int) ((x - intVal) * 1024.0);\n        final double fracPartA = ExpFracTable.EXP_FRAC_TABLE_A[intFrac];\n        final double fracPartB = ExpFracTable.EXP_FRAC_TABLE_B[intFrac];\n\n        /* epsilon is the difference in x from the nearest multiple of 2^-10.  It\n         * has a value in the range 0 <= epsilon < 2^-10.\n         * Do the subtraction from x as the last step to avoid possible loss of percison.\n         */\n        final double epsilon = x - (intVal + intFrac / 1024.0);\n\n        /* Compute z = exp(epsilon) - 1.0 via a minimax polynomial.  z has\n       full double precision (52 bits).  Since z < 2^-10, we will have\n       62 bits of precision when combined with the contant 1.  This will be\n       used in the last addition below to get proper rounding. */\n\n        /* Remez generated polynomial.  Converges on the interval [0, 2^-10], error\n       is less than 0.5 ULP */\n        double z = 0.04168701738764507;\n        z = z * epsilon + 0.1666666505023083;\n        z = z * epsilon + 0.5000000000042687;\n        z = z * epsilon + 1.0;\n        z = z * epsilon + -3.940510424527919E-20;\n\n        /* Compute (intPartA+intPartB) * (fracPartA+fracPartB) by binomial\n       expansion.\n       tempA is exact since intPartA and intPartB only have 22 bits each.\n       tempB will have 52 bits of precision.\n         */\n        double tempA = intPartA * fracPartA;\n        double tempB = intPartA * fracPartB + intPartB * fracPartA + intPartB * fracPartB;\n\n        /* Compute the result.  (1+z)(tempA+tempB).  Order of operations is\n       important.  For accuracy add by increasing size.  tempA is exact and\n       much larger than the others.  If there are extra bits specified from the\n       pow() function, use them. */\n        final double tempC = tempB + tempA;\n        final double result;\n        if (extra != 0.0) {\n            result = tempC*extra*z + tempC*extra + tempC*z + tempB + tempA;\n        } else {\n            result = tempC*z + tempB + tempA;\n        }\n\n        if (hiPrec != null) {\n            // If requesting high precision\n            hiPrec[0] = tempA;\n            hiPrec[1] = tempC*extra*z + tempC*extra + tempC*z + tempB;\n        }\n\n        return result;\n    }",
    "comment": " Internal helper method for exponential function. @param x original argument of the exponential function @param extra extra bits of precision on input (To Be Confirmed) @param hiPrec extra bits of precision on output (To Be Confirmed) @return exp(x) ",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 0
  },
  {
    "name": "FastMath.log",
    "class_name": "org.apache.commons.math3.util.FastMath",
    "signature": "org.apache.commons.math3.util.FastMath.log(double)",
    "snippet": "    public static double log(final double x) {\n        return log(x, null);\n    }",
    "comment": " Natural logarithm.  @param x   a double @return log(x) ",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 0
  },
  {
    "name": "FastMath.log",
    "class_name": "org.apache.commons.math3.util.FastMath",
    "signature": "org.apache.commons.math3.util.FastMath.log(double,double[])",
    "snippet": "    private static double log(final double x, final double[] hiPrec) {\n        if (x==0) { // Handle special case of +0/-0\n            return Double.NEGATIVE_INFINITY;\n        }\n        long bits = Double.doubleToLongBits(x);\n\n        /* Handle special cases of negative input, and NaN */\n        if ((bits & 0x8000000000000000L) != 0 || x != x) {\n            if (x != 0.0) {\n                if (hiPrec != null) {\n                    hiPrec[0] = Double.NaN;\n                }\n\n                return Double.NaN;\n            }\n        }\n\n        /* Handle special cases of Positive infinity. */\n        if (x == Double.POSITIVE_INFINITY) {\n            if (hiPrec != null) {\n                hiPrec[0] = Double.POSITIVE_INFINITY;\n            }\n\n            return Double.POSITIVE_INFINITY;\n        }\n\n        /* Extract the exponent */\n        int exp = (int)(bits >> 52)-1023;\n\n        if ((bits & 0x7ff0000000000000L) == 0) {\n            // Subnormal!\n            if (x == 0) {\n                // Zero\n                if (hiPrec != null) {\n                    hiPrec[0] = Double.NEGATIVE_INFINITY;\n                }\n\n                return Double.NEGATIVE_INFINITY;\n            }\n\n            /* Normalize the subnormal number. */\n            bits <<= 1;\n            while ( (bits & 0x0010000000000000L) == 0) {\n                --exp;\n                bits <<= 1;\n            }\n        }\n\n\n        if (exp == -1 || exp == 0) {\n            if (x < 1.01 && x > 0.99 && hiPrec == null) {\n                /* The normal method doesn't work well in the range [0.99, 1.01], so call do a straight\n           polynomial expansion in higer precision. */\n\n               /* Compute x - 1.0 and split it */\n                double xa = x - 1.0;\n                double xb = xa - x + 1.0;\n                double tmp = xa * HEX_40000000;\n                double aa = xa + tmp - tmp;\n                double ab = xa - aa;\n                xa = aa;\n                xb = ab;\n\n                final double[] lnCoef_last = LN_QUICK_COEF[LN_QUICK_COEF.length - 1];\n                double ya = lnCoef_last[0];\n                double yb = lnCoef_last[1];\n\n                for (int i = LN_QUICK_COEF.length - 2; i >= 0; i--) {\n                    /* Multiply a = y * x */\n                    aa = ya * xa;\n                    ab = ya * xb + yb * xa + yb * xb;\n                    /* split, so now y = a */\n                    tmp = aa * HEX_40000000;\n                    ya = aa + tmp - tmp;\n                    yb = aa - ya + ab;\n\n                    /* Add  a = y + lnQuickCoef */\n                    final double[] lnCoef_i = LN_QUICK_COEF[i];\n                    aa = ya + lnCoef_i[0];\n                    ab = yb + lnCoef_i[1];\n                    /* Split y = a */\n                    tmp = aa * HEX_40000000;\n                    ya = aa + tmp - tmp;\n                    yb = aa - ya + ab;\n                }\n\n                /* Multiply a = y * x */\n                aa = ya * xa;\n                ab = ya * xb + yb * xa + yb * xb;\n                /* split, so now y = a */\n                tmp = aa * HEX_40000000;\n                ya = aa + tmp - tmp;\n                yb = aa - ya + ab;\n\n                return ya + yb;\n            }\n        }\n\n        // lnm is a log of a number in the range of 1.0 - 2.0, so 0 <= lnm < ln(2)\n        final double[] lnm = lnMant.LN_MANT[(int)((bits & 0x000ffc0000000000L) >> 42)];\n\n        /*\n    double epsilon = x / Double.longBitsToDouble(bits & 0xfffffc0000000000L);\n\n    epsilon -= 1.0;\n         */\n\n        // y is the most significant 10 bits of the mantissa\n        //double y = Double.longBitsToDouble(bits & 0xfffffc0000000000L);\n        //double epsilon = (x - y) / y;\n        final double epsilon = (bits & 0x3ffffffffffL) / (TWO_POWER_52 + (bits & 0x000ffc0000000000L));\n\n        double lnza = 0.0;\n        double lnzb = 0.0;\n\n        if (hiPrec != null) {\n            /* split epsilon -> x */\n            double tmp = epsilon * HEX_40000000;\n            double aa = epsilon + tmp - tmp;\n            double ab = epsilon - aa;\n            double xa = aa;\n            double xb = ab;\n\n            /* Need a more accurate epsilon, so adjust the division. */\n            final double numer = bits & 0x3ffffffffffL;\n            final double denom = TWO_POWER_52 + (bits & 0x000ffc0000000000L);\n            aa = numer - xa*denom - xb * denom;\n            xb += aa / denom;\n\n            /* Remez polynomial evaluation */\n            final double[] lnCoef_last = LN_HI_PREC_COEF[LN_HI_PREC_COEF.length-1];\n            double ya = lnCoef_last[0];\n            double yb = lnCoef_last[1];\n\n            for (int i = LN_HI_PREC_COEF.length - 2; i >= 0; i--) {\n                /* Multiply a = y * x */\n                aa = ya * xa;\n                ab = ya * xb + yb * xa + yb * xb;\n                /* split, so now y = a */\n                tmp = aa * HEX_40000000;\n                ya = aa + tmp - tmp;\n                yb = aa - ya + ab;\n\n                /* Add  a = y + lnHiPrecCoef */\n                final double[] lnCoef_i = LN_HI_PREC_COEF[i];\n                aa = ya + lnCoef_i[0];\n                ab = yb + lnCoef_i[1];\n                /* Split y = a */\n                tmp = aa * HEX_40000000;\n                ya = aa + tmp - tmp;\n                yb = aa - ya + ab;\n            }\n\n            /* Multiply a = y * x */\n            aa = ya * xa;\n            ab = ya * xb + yb * xa + yb * xb;\n\n            /* split, so now lnz = a */\n            /*\n      tmp = aa * 1073741824.0;\n      lnza = aa + tmp - tmp;\n      lnzb = aa - lnza + ab;\n             */\n            lnza = aa + ab;\n            lnzb = -(lnza - aa - ab);\n        } else {\n            /* High precision not required.  Eval Remez polynomial\n         using standard double precision */\n            lnza = -0.16624882440418567;\n            lnza = lnza * epsilon + 0.19999954120254515;\n            lnza = lnza * epsilon + -0.2499999997677497;\n            lnza = lnza * epsilon + 0.3333333333332802;\n            lnza = lnza * epsilon + -0.5;\n            lnza = lnza * epsilon + 1.0;\n            lnza = lnza * epsilon;\n        }\n\n        /* Relative sizes:\n         * lnzb     [0, 2.33E-10]\n         * lnm[1]   [0, 1.17E-7]\n         * ln2B*exp [0, 1.12E-4]\n         * lnza      [0, 9.7E-4]\n         * lnm[0]   [0, 0.692]\n         * ln2A*exp [0, 709]\n         */\n\n        /* Compute the following sum:\n         * lnzb + lnm[1] + ln2B*exp + lnza + lnm[0] + ln2A*exp;\n         */\n\n        //return lnzb + lnm[1] + ln2B*exp + lnza + lnm[0] + ln2A*exp;\n        double a = LN_2_A*exp;\n        double b = 0.0;\n        double c = a+lnm[0];\n        double d = -(c-a-lnm[0]);\n        a = c;\n        b = b + d;\n\n        c = a + lnza;\n        d = -(c - a - lnza);\n        a = c;\n        b = b + d;\n\n        c = a + LN_2_B*exp;\n        d = -(c - a - LN_2_B*exp);\n        a = c;\n        b = b + d;\n\n        c = a + lnm[1];\n        d = -(c - a - lnm[1]);\n        a = c;\n        b = b + d;\n\n        c = a + lnzb;\n        d = -(c - a - lnzb);\n        a = c;\n        b = b + d;\n\n        if (hiPrec != null) {\n            hiPrec[0] = a;\n            hiPrec[1] = b;\n        }\n\n        return a + b;\n    }",
    "comment": " Internal helper method for natural logarithm function. @param x original argument of the natural logarithm function @param hiPrec extra bits of precision on output (To Be Confirmed) @return log(x) ",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 0
  },
  {
    "name": "FastMath.polyCosine",
    "class_name": "org.apache.commons.math3.util.FastMath",
    "signature": "org.apache.commons.math3.util.FastMath.polyCosine(double)",
    "snippet": "    private static double polyCosine(double x) {\n        double x2 = x*x;\n\n        double p = 2.479773539153719E-5;\n        p = p * x2 + -0.0013888888689039883;\n        p = p * x2 + 0.041666666666621166;\n        p = p * x2 + -0.49999999999999994;\n        p *= x2;\n\n        return p;\n    }",
    "comment": " Computes cos(x) - 1, where |x| < 1/16. Use a Remez polynomial approximation. @param x a number smaller than 1/16 @return cos(x) - 1 ",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 0
  },
  {
    "name": "FastMath.polySine",
    "class_name": "org.apache.commons.math3.util.FastMath",
    "signature": "org.apache.commons.math3.util.FastMath.polySine(double)",
    "snippet": "    private static double polySine(final double x)\n    {\n        double x2 = x*x;\n\n        double p = 2.7553817452272217E-6;\n        p = p * x2 + -1.9841269659586505E-4;\n        p = p * x2 + 0.008333333333329196;\n        p = p * x2 + -0.16666666666666666;\n        //p *= x2;\n        //p *= x;\n        p = p * x2 * x;\n\n        return p;\n    }",
    "comment": " Computes sin(x) - x, where |x| < 1/16. Use a Remez polynomial approximation. @param x a number smaller than 1/16 @return sin(x) - x ",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 0
  },
  {
    "name": "FastMath.pow",
    "class_name": "org.apache.commons.math3.util.FastMath",
    "signature": "org.apache.commons.math3.util.FastMath.pow(double,double)",
    "snippet": "    public static double pow(double x, double y) {\n        final double lns[] = new double[2];\n\n        if (y == 0.0) {\n            return 1.0;\n        }\n\n        if (x != x) { // X is NaN\n            return x;\n        }\n\n\n        if (x == 0) {\n            long bits = Double.doubleToLongBits(x);\n            if ((bits & 0x8000000000000000L) != 0) {\n                // -zero\n                long yi = (long) y;\n\n                if (y < 0 && y == yi && (yi & 1) == 1) {\n                    return Double.NEGATIVE_INFINITY;\n                }\n\n                if (y > 0 && y == yi && (yi & 1) == 1) {\n                    return -0.0;\n                }\n            }\n\n            if (y < 0) {\n                return Double.POSITIVE_INFINITY;\n            }\n            if (y > 0) {\n                return 0.0;\n            }\n\n            return Double.NaN;\n        }\n\n        if (x == Double.POSITIVE_INFINITY) {\n            if (y != y) { // y is NaN\n                return y;\n            }\n            if (y < 0.0) {\n                return 0.0;\n            } else {\n                return Double.POSITIVE_INFINITY;\n            }\n        }\n\n        if (y == Double.POSITIVE_INFINITY) {\n            if (x * x == 1.0) {\n                return Double.NaN;\n            }\n\n            if (x * x > 1.0) {\n                return Double.POSITIVE_INFINITY;\n            } else {\n                return 0.0;\n            }\n        }\n\n        if (x == Double.NEGATIVE_INFINITY) {\n            if (y != y) { // y is NaN\n                return y;\n            }\n\n            if (y < 0) {\n                long yi = (long) y;\n                if (y == yi && (yi & 1) == 1) {\n                    return -0.0;\n                }\n\n                return 0.0;\n            }\n\n            if (y > 0)  {\n                long yi = (long) y;\n                if (y == yi && (yi & 1) == 1) {\n                    return Double.NEGATIVE_INFINITY;\n                }\n\n                return Double.POSITIVE_INFINITY;\n            }\n        }\n\n        if (y == Double.NEGATIVE_INFINITY) {\n\n            if (x * x == 1.0) {\n                return Double.NaN;\n            }\n\n            if (x * x < 1.0) {\n                return Double.POSITIVE_INFINITY;\n            } else {\n                return 0.0;\n            }\n        }\n\n        /* Handle special case x<0 */\n        if (x < 0) {\n            // y is an even integer in this case\n            if (y >= TWO_POWER_53 || y <= -TWO_POWER_53) {\n                return pow(-x, y);\n            }\n\n            if (y == (long) y) {\n                // If y is an integer\n                return ((long)y & 1) == 0 ? pow(-x, y) : -pow(-x, y);\n            } else {\n                return Double.NaN;\n            }\n        }\n\n        /* Split y into ya and yb such that y = ya+yb */\n        double ya;\n        double yb;\n        if (y < 8e298 && y > -8e298) {\n            double tmp1 = y * HEX_40000000;\n            ya = y + tmp1 - tmp1;\n            yb = y - ya;\n        } else {\n            double tmp1 = y * 9.31322574615478515625E-10;\n            double tmp2 = tmp1 * 9.31322574615478515625E-10;\n            ya = (tmp1 + tmp2 - tmp1) * HEX_40000000 * HEX_40000000;\n            yb = y - ya;\n        }\n\n        /* Compute ln(x) */\n        final double lores = log(x, lns);\n        if (Double.isInfinite(lores)){ // don't allow this to be converted to NaN\n            return lores;\n        }\n\n        double lna = lns[0];\n        double lnb = lns[1];\n\n        /* resplit lns */\n        double tmp1 = lna * HEX_40000000;\n        double tmp2 = lna + tmp1 - tmp1;\n        lnb += lna - tmp2;\n        lna = tmp2;\n\n        // y*ln(x) = (aa+ab)\n        final double aa = lna * ya;\n        final double ab = lna * yb + lnb * ya + lnb * yb;\n\n        lna = aa+ab;\n        lnb = -(lna - aa - ab);\n\n        double z = 1.0 / 120.0;\n        z = z * lnb + (1.0 / 24.0);\n        z = z * lnb + (1.0 / 6.0);\n        z = z * lnb + 0.5;\n        z = z * lnb + 1.0;\n        z = z * lnb;\n\n        final double result = exp(lna, z, null);\n        //result = result + result * z;\n        return result;\n    }",
    "comment": " Power function.  Compute x^y.  @param x   a double @param y   a double @return double ",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 0
  },
  {
    "name": "FastMath.sin",
    "class_name": "org.apache.commons.math3.util.FastMath",
    "signature": "org.apache.commons.math3.util.FastMath.sin(double)",
    "snippet": "    public static double sin(double x) {\n        boolean negative = false;\n        int quadrant = 0;\n        double xa;\n        double xb = 0.0;\n\n        /* Take absolute value of the input */\n        xa = x;\n        if (x < 0) {\n            negative = true;\n            xa = -xa;\n        }\n\n        /* Check for zero and negative zero */\n        if (xa == 0.0) {\n            long bits = Double.doubleToLongBits(x);\n            if (bits < 0) {\n                return -0.0;\n            }\n            return 0.0;\n        }\n\n        if (xa != xa || xa == Double.POSITIVE_INFINITY) {\n            return Double.NaN;\n        }\n\n        /* Perform any argument reduction */\n        if (xa > 3294198.0) {\n            // PI * (2**20)\n            // Argument too big for CodyWaite reduction.  Must use\n            // PayneHanek.\n            double reduceResults[] = new double[3];\n            reducePayneHanek(xa, reduceResults);\n            quadrant = ((int) reduceResults[0]) & 3;\n            xa = reduceResults[1];\n            xb = reduceResults[2];\n        } else if (xa > 1.5707963267948966) {\n            final CodyWaite cw = new CodyWaite(xa);\n            quadrant = cw.getK() & 3;\n            xa = cw.getRemA();\n            xb = cw.getRemB();\n        }\n\n        if (negative) {\n            quadrant ^= 2;  // Flip bit 1\n        }\n\n        switch (quadrant) {\n            case 0:\n                return sinQ(xa, xb);\n            case 1:\n                return cosQ(xa, xb);\n            case 2:\n                return -sinQ(xa, xb);\n            case 3:\n                return -cosQ(xa, xb);\n            default:\n                return Double.NaN;\n        }\n    }",
    "comment": " Sine function.  @param x Argument. @return sin(x) ",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 0
  },
  {
    "name": "FastMath.sinQ",
    "class_name": "org.apache.commons.math3.util.FastMath",
    "signature": "org.apache.commons.math3.util.FastMath.sinQ(double,double)",
    "snippet": "    private static double sinQ(double xa, double xb) {\n        int idx = (int) ((xa * 8.0) + 0.5);\n        final double epsilon = xa - EIGHTHS[idx]; //idx*0.125;\n\n        // Table lookups\n        final double sintA = SINE_TABLE_A[idx];\n        final double sintB = SINE_TABLE_B[idx];\n        final double costA = COSINE_TABLE_A[idx];\n        final double costB = COSINE_TABLE_B[idx];\n\n        // Polynomial eval of sin(epsilon), cos(epsilon)\n        double sinEpsA = epsilon;\n        double sinEpsB = polySine(epsilon);\n        final double cosEpsA = 1.0;\n        final double cosEpsB = polyCosine(epsilon);\n\n        // Split epsilon   xa + xb = x\n        final double temp = sinEpsA * HEX_40000000;\n        double temp2 = (sinEpsA + temp) - temp;\n        sinEpsB +=  sinEpsA - temp2;\n        sinEpsA = temp2;\n\n        /* Compute sin(x) by angle addition formula */\n        double result;\n\n        /* Compute the following sum:\n         *\n         * result = sintA + costA*sinEpsA + sintA*cosEpsB + costA*sinEpsB +\n         *          sintB + costB*sinEpsA + sintB*cosEpsB + costB*sinEpsB;\n         *\n         * Ranges of elements\n         *\n         * xxxtA   0            PI/2\n         * xxxtB   -1.5e-9      1.5e-9\n         * sinEpsA -0.0625      0.0625\n         * sinEpsB -6e-11       6e-11\n         * cosEpsA  1.0\n         * cosEpsB  0           -0.0625\n         *\n         */\n\n        //result = sintA + costA*sinEpsA + sintA*cosEpsB + costA*sinEpsB +\n        //          sintB + costB*sinEpsA + sintB*cosEpsB + costB*sinEpsB;\n\n        //result = sintA + sintA*cosEpsB + sintB + sintB * cosEpsB;\n        //result += costA*sinEpsA + costA*sinEpsB + costB*sinEpsA + costB * sinEpsB;\n        double a = 0;\n        double b = 0;\n\n        double t = sintA;\n        double c = a + t;\n        double d = -(c - a - t);\n        a = c;\n        b = b + d;\n\n        t = costA * sinEpsA;\n        c = a + t;\n        d = -(c - a - t);\n        a = c;\n        b = b + d;\n\n        b = b + sintA * cosEpsB + costA * sinEpsB;\n        /*\n    t = sintA*cosEpsB;\n    c = a + t;\n    d = -(c - a - t);\n    a = c;\n    b = b + d;\n\n    t = costA*sinEpsB;\n    c = a + t;\n    d = -(c - a - t);\n    a = c;\n    b = b + d;\n         */\n\n        b = b + sintB + costB * sinEpsA + sintB * cosEpsB + costB * sinEpsB;\n        /*\n    t = sintB;\n    c = a + t;\n    d = -(c - a - t);\n    a = c;\n    b = b + d;\n\n    t = costB*sinEpsA;\n    c = a + t;\n    d = -(c - a - t);\n    a = c;\n    b = b + d;\n\n    t = sintB*cosEpsB;\n    c = a + t;\n    d = -(c - a - t);\n    a = c;\n    b = b + d;\n\n    t = costB*sinEpsB;\n    c = a + t;\n    d = -(c - a - t);\n    a = c;\n    b = b + d;\n         */\n\n        if (xb != 0.0) {\n            t = ((costA + costB) * (cosEpsA + cosEpsB) -\n                 (sintA + sintB) * (sinEpsA + sinEpsB)) * xb;  // approximate cosine*xb\n            c = a + t;\n            d = -(c - a - t);\n            a = c;\n            b = b + d;\n        }\n\n        result = a + b;\n\n        return result;\n    }",
    "comment": " Compute sine over the first quadrant (0 < x < pi/2). Use combination of table lookup and rational polynomial expansion. @param xa number from which sine is requested @param xb extra bits for x (may be 0.0) @return sin(xa + xb) ",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 0
  },
  {
    "name": "FastMath.sqrt",
    "class_name": "org.apache.commons.math3.util.FastMath",
    "signature": "org.apache.commons.math3.util.FastMath.sqrt(double)",
    "snippet": "    public static double sqrt(final double a) {\n        return Math.sqrt(a);\n    }",
    "comment": "Compute the square root of a number. <p><b>Note:</b> this implementation currently delegates to {@link Math#sqrt} @param a number on which evaluation is done @return square root of a ",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 0
  },
  {
    "name": "FastMathLiteralArrays.loadExpFracA",
    "class_name": "org.apache.commons.math3.util.FastMathLiteralArrays",
    "signature": "org.apache.commons.math3.util.FastMathLiteralArrays.loadExpFracA()",
    "snippet": "    static double[] loadExpFracA() {\n        return EXP_FRAC_A.clone();\n    }",
    "comment": " Load \"EXP_FRAC_A\".  @return a clone of the data array. ",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 0
  },
  {
    "name": "FastMathLiteralArrays.loadExpFracB",
    "class_name": "org.apache.commons.math3.util.FastMathLiteralArrays",
    "signature": "org.apache.commons.math3.util.FastMathLiteralArrays.loadExpFracB()",
    "snippet": "    static double[] loadExpFracB() {\n        return EXP_FRAC_B.clone();\n    }",
    "comment": " Load \"EXP_FRAC_B\".  @return a clone of the data array. ",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 0
  },
  {
    "name": "FastMathLiteralArrays.loadExpIntA",
    "class_name": "org.apache.commons.math3.util.FastMathLiteralArrays",
    "signature": "org.apache.commons.math3.util.FastMathLiteralArrays.loadExpIntA()",
    "snippet": "    static double[] loadExpIntA() {\n        return EXP_INT_A.clone();\n    }",
    "comment": " Load \"EXP_INT_A\".  @return a clone of the data array. ",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 0
  },
  {
    "name": "FastMathLiteralArrays.loadExpIntB",
    "class_name": "org.apache.commons.math3.util.FastMathLiteralArrays",
    "signature": "org.apache.commons.math3.util.FastMathLiteralArrays.loadExpIntB()",
    "snippet": "    static double[] loadExpIntB() {\n        return EXP_INT_B.clone();\n    }",
    "comment": " Load \"EXP_INT_B\".  @return a clone of the data array. ",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 0
  },
  {
    "name": "FastMathLiteralArrays.loadLnMant",
    "class_name": "org.apache.commons.math3.util.FastMathLiteralArrays",
    "signature": "org.apache.commons.math3.util.FastMathLiteralArrays.loadLnMant()",
    "snippet": "    static double[][] loadLnMant() {\n        return LN_MANT.clone();\n    }",
    "comment": " Load \"LN_MANT\".  @return a clone of the data array. ",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 0
  }
]