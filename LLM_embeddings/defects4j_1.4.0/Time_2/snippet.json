[
  {
    "name": "DateTime.DateTime",
    "class_name": "org.joda.time.DateTime",
    "signature": "org.joda.time.DateTime.DateTime(int,int,int,int,int,int,int,Chronology)",
    "snippet": "    public DateTime(\n            int year,\n            int monthOfYear,\n            int dayOfMonth,\n            int hourOfDay,\n            int minuteOfHour,\n            int secondOfMinute,\n            int millisOfSecond,\n            Chronology chronology) {\n        super(year, monthOfYear, dayOfMonth,\n              hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond, chronology);\n    }",
    "comment": " Constructs an instance from datetime field values using the specified chronology. <p> If the chronology is null, <code>ISOChronology</code> in the default time zone is used.  @param year  the year, valid values defined by the chronology @param monthOfYear  the month of the year, valid values defined by the chronology @param dayOfMonth  the day of the month, valid values defined by the chronology @param hourOfDay  the hour of the day, valid values defined by the chronology @param minuteOfHour  the minute of the hour, valid values defined by the chronology @param secondOfMinute  the second of the minute, valid values defined by the chronology @param millisOfSecond  the millisecond of the second, valid values defined by the chronology @param chronology  the chronology, null means ISOChronology in default zone ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 3
  },
  {
    "name": "DateTime.toDateTime",
    "class_name": "org.joda.time.DateTime",
    "signature": "org.joda.time.DateTime.toDateTime()",
    "snippet": "    public DateTime toDateTime() {\n        return this;\n    }",
    "comment": " Get this object as a DateTime by returning <code>this</code>.  @return <code>this</code> ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 3
  },
  {
    "name": "DateTimeFieldType.DateTimeFieldType",
    "class_name": "org.joda.time.DateTimeFieldType",
    "signature": "org.joda.time.DateTimeFieldType.DateTimeFieldType(String)",
    "snippet": "    protected DateTimeFieldType(String name) {\n        super();\n        iName = name;\n    }",
    "comment": " Constructor.  @param name  the name to use ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 3
  },
  {
    "name": "DateTimeFieldType.centuryOfEra",
    "class_name": "org.joda.time.DateTimeFieldType",
    "signature": "org.joda.time.DateTimeFieldType.centuryOfEra()",
    "snippet": "    public static DateTimeFieldType centuryOfEra() {\n        return CENTURY_OF_ERA_TYPE;\n    }",
    "comment": " Get the century of era field type.  @return the DateTimeFieldType constant ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 3
  },
  {
    "name": "DateTimeFieldType.clockhourOfDay",
    "class_name": "org.joda.time.DateTimeFieldType",
    "signature": "org.joda.time.DateTimeFieldType.clockhourOfDay()",
    "snippet": "    public static DateTimeFieldType clockhourOfDay() {\n        return CLOCKHOUR_OF_DAY_TYPE;\n    }",
    "comment": " Get the hour of day (offset to 1-24) field type.  @return the DateTimeFieldType constant ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 3
  },
  {
    "name": "DateTimeFieldType.clockhourOfHalfday",
    "class_name": "org.joda.time.DateTimeFieldType",
    "signature": "org.joda.time.DateTimeFieldType.clockhourOfHalfday()",
    "snippet": "    public static DateTimeFieldType clockhourOfHalfday() {\n        return CLOCKHOUR_OF_HALFDAY_TYPE;\n    }",
    "comment": " Get the hour of am/pm (offset to 1-12) field type.  @return the DateTimeFieldType constant ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 3
  },
  {
    "name": "DateTimeFieldType.dayOfMonth",
    "class_name": "org.joda.time.DateTimeFieldType",
    "signature": "org.joda.time.DateTimeFieldType.dayOfMonth()",
    "snippet": "    public static DateTimeFieldType dayOfMonth() {\n        return DAY_OF_MONTH_TYPE;\n    }",
    "comment": " Get the day of month field type.  @return the DateTimeFieldType constant ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 3
  },
  {
    "name": "DateTimeFieldType.dayOfWeek",
    "class_name": "org.joda.time.DateTimeFieldType",
    "signature": "org.joda.time.DateTimeFieldType.dayOfWeek()",
    "snippet": "    public static DateTimeFieldType dayOfWeek() {\n        return DAY_OF_WEEK_TYPE;\n    }",
    "comment": " Get the day of week field type.  @return the DateTimeFieldType constant ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 3
  },
  {
    "name": "DateTimeFieldType.dayOfYear",
    "class_name": "org.joda.time.DateTimeFieldType",
    "signature": "org.joda.time.DateTimeFieldType.dayOfYear()",
    "snippet": "    public static DateTimeFieldType dayOfYear() {\n        return DAY_OF_YEAR_TYPE;\n    }",
    "comment": " Get the day of year field type.  @return the DateTimeFieldType constant ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 3
  },
  {
    "name": "DateTimeFieldType.era",
    "class_name": "org.joda.time.DateTimeFieldType",
    "signature": "org.joda.time.DateTimeFieldType.era()",
    "snippet": "    public static DateTimeFieldType era() {\n        return ERA_TYPE;\n    }",
    "comment": " Get the era field type.  @return the DateTimeFieldType constant ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 3
  },
  {
    "name": "DateTimeFieldType.getName",
    "class_name": "org.joda.time.DateTimeFieldType",
    "signature": "org.joda.time.DateTimeFieldType.getName()",
    "snippet": "    public String getName() {\n        return iName;\n    }",
    "comment": " Get the name of the field. <p> By convention, names follow a pattern of \"dddOfRrr\", where \"ddd\" represents the (singular) duration unit field name and \"Rrr\" represents the (singular) duration range field name. If the range field is not applicable, then the name of the field is simply the (singular) duration field name.  @return field name ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 3
  },
  {
    "name": "DateTimeFieldType.halfdayOfDay",
    "class_name": "org.joda.time.DateTimeFieldType",
    "signature": "org.joda.time.DateTimeFieldType.halfdayOfDay()",
    "snippet": "    public static DateTimeFieldType halfdayOfDay() {\n        return HALFDAY_OF_DAY_TYPE;\n    }",
    "comment": " Get the AM(0) PM(1) field type.  @return the DateTimeFieldType constant ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 3
  },
  {
    "name": "DateTimeFieldType.hourOfDay",
    "class_name": "org.joda.time.DateTimeFieldType",
    "signature": "org.joda.time.DateTimeFieldType.hourOfDay()",
    "snippet": "    public static DateTimeFieldType hourOfDay() {\n        return HOUR_OF_DAY_TYPE;\n    }",
    "comment": " Get the hour of day (0-23) field type.  @return the DateTimeFieldType constant ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 3
  },
  {
    "name": "DateTimeFieldType.hourOfHalfday",
    "class_name": "org.joda.time.DateTimeFieldType",
    "signature": "org.joda.time.DateTimeFieldType.hourOfHalfday()",
    "snippet": "    public static DateTimeFieldType hourOfHalfday() {\n        return HOUR_OF_HALFDAY_TYPE;\n    }",
    "comment": " Get the hour of am/pm (0-11) field type.  @return the DateTimeFieldType constant ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 3
  },
  {
    "name": "DateTimeFieldType.millisOfDay",
    "class_name": "org.joda.time.DateTimeFieldType",
    "signature": "org.joda.time.DateTimeFieldType.millisOfDay()",
    "snippet": "    public static DateTimeFieldType millisOfDay() {\n        return MILLIS_OF_DAY_TYPE;\n    }",
    "comment": " Get the millis of day field type.  @return the DateTimeFieldType constant ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 3
  },
  {
    "name": "DateTimeFieldType.millisOfSecond",
    "class_name": "org.joda.time.DateTimeFieldType",
    "signature": "org.joda.time.DateTimeFieldType.millisOfSecond()",
    "snippet": "    public static DateTimeFieldType millisOfSecond() {\n        return MILLIS_OF_SECOND_TYPE;\n    }",
    "comment": " Get the millis of second field type.  @return the DateTimeFieldType constant ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 3
  },
  {
    "name": "DateTimeFieldType.minuteOfDay",
    "class_name": "org.joda.time.DateTimeFieldType",
    "signature": "org.joda.time.DateTimeFieldType.minuteOfDay()",
    "snippet": "    public static DateTimeFieldType minuteOfDay() {\n        return MINUTE_OF_DAY_TYPE;\n    }",
    "comment": " Get the minute of day field type.  @return the DateTimeFieldType constant ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 3
  },
  {
    "name": "DateTimeFieldType.minuteOfHour",
    "class_name": "org.joda.time.DateTimeFieldType",
    "signature": "org.joda.time.DateTimeFieldType.minuteOfHour()",
    "snippet": "    public static DateTimeFieldType minuteOfHour() {\n        return MINUTE_OF_HOUR_TYPE;\n    }",
    "comment": " Get the minute of hour field type.  @return the DateTimeFieldType constant ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 3
  },
  {
    "name": "DateTimeFieldType.monthOfYear",
    "class_name": "org.joda.time.DateTimeFieldType",
    "signature": "org.joda.time.DateTimeFieldType.monthOfYear()",
    "snippet": "    public static DateTimeFieldType monthOfYear() {\n        return MONTH_OF_YEAR_TYPE;\n    }",
    "comment": " Get the month of year field type.  @return the DateTimeFieldType constant ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 3
  },
  {
    "name": "DateTimeFieldType.secondOfDay",
    "class_name": "org.joda.time.DateTimeFieldType",
    "signature": "org.joda.time.DateTimeFieldType.secondOfDay()",
    "snippet": "    public static DateTimeFieldType secondOfDay() {\n        return SECOND_OF_DAY_TYPE;\n    }",
    "comment": " Get the second of day field type.  @return the DateTimeFieldType constant ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 3
  },
  {
    "name": "DateTimeFieldType.secondOfMinute",
    "class_name": "org.joda.time.DateTimeFieldType",
    "signature": "org.joda.time.DateTimeFieldType.secondOfMinute()",
    "snippet": "    public static DateTimeFieldType secondOfMinute() {\n        return SECOND_OF_MINUTE_TYPE;\n    }",
    "comment": " Get the second of minute field type.  @return the DateTimeFieldType constant ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 3
  },
  {
    "name": "DateTimeFieldType.weekOfWeekyear",
    "class_name": "org.joda.time.DateTimeFieldType",
    "signature": "org.joda.time.DateTimeFieldType.weekOfWeekyear()",
    "snippet": "    public static DateTimeFieldType weekOfWeekyear() {\n        return WEEK_OF_WEEKYEAR_TYPE;\n    }",
    "comment": " Get the week of a week based year field type.  @return the DateTimeFieldType constant ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 3
  },
  {
    "name": "DateTimeFieldType.weekyear",
    "class_name": "org.joda.time.DateTimeFieldType",
    "signature": "org.joda.time.DateTimeFieldType.weekyear()",
    "snippet": "    public static DateTimeFieldType weekyear() {\n        return WEEKYEAR_TYPE;\n    }",
    "comment": " Get the year of a week based year field type.  @return the DateTimeFieldType constant ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 3
  },
  {
    "name": "DateTimeFieldType.weekyearOfCentury",
    "class_name": "org.joda.time.DateTimeFieldType",
    "signature": "org.joda.time.DateTimeFieldType.weekyearOfCentury()",
    "snippet": "    public static DateTimeFieldType weekyearOfCentury() {\n        return WEEKYEAR_OF_CENTURY_TYPE;\n    }",
    "comment": " Get the year of a week based year within a century field type.  @return the DateTimeFieldType constant ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 3
  },
  {
    "name": "DateTimeFieldType.year",
    "class_name": "org.joda.time.DateTimeFieldType",
    "signature": "org.joda.time.DateTimeFieldType.year()",
    "snippet": "    public static DateTimeFieldType year() {\n        return YEAR_TYPE;\n    }",
    "comment": " Get the year field type.  @return the DateTimeFieldType constant ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 3
  },
  {
    "name": "DateTimeFieldType.yearOfCentury",
    "class_name": "org.joda.time.DateTimeFieldType",
    "signature": "org.joda.time.DateTimeFieldType.yearOfCentury()",
    "snippet": "    public static DateTimeFieldType yearOfCentury() {\n        return YEAR_OF_CENTURY_TYPE;\n    }",
    "comment": " Get the year of century field type.  @return the DateTimeFieldType constant ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 3
  },
  {
    "name": "DateTimeFieldType.yearOfEra",
    "class_name": "org.joda.time.DateTimeFieldType",
    "signature": "org.joda.time.DateTimeFieldType.yearOfEra()",
    "snippet": "    public static DateTimeFieldType yearOfEra() {\n        return YEAR_OF_ERA_TYPE;\n    }",
    "comment": " Get the year of era field type.  @return the DateTimeFieldType constant ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 3
  },
  {
    "name": "StandardDateTimeFieldType.getDurationType",
    "class_name": "org.joda.time.DateTimeFieldType$StandardDateTimeFieldType",
    "signature": "org.joda.time.DateTimeFieldType$StandardDateTimeFieldType.getDurationType()",
    "snippet": "        public DurationFieldType getDurationType() {\n            return iUnitType;\n        }",
    "comment": "@inheritdoc */",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 3
  },
  {
    "name": "StandardDateTimeFieldType.getField",
    "class_name": "org.joda.time.DateTimeFieldType$StandardDateTimeFieldType",
    "signature": "org.joda.time.DateTimeFieldType$StandardDateTimeFieldType.getField(Chronology)",
    "snippet": "        public DateTimeField getField(Chronology chronology) {\n            chronology = DateTimeUtils.getChronology(chronology);\n\n            switch (iOrdinal) {\n                case ERA:\n                    return chronology.era();\n                case YEAR_OF_ERA:\n                    return chronology.yearOfEra();\n                case CENTURY_OF_ERA:\n                    return chronology.centuryOfEra();\n                case YEAR_OF_CENTURY:\n                    return chronology.yearOfCentury();\n                case YEAR:\n                    return chronology.year();\n                case DAY_OF_YEAR:\n                    return chronology.dayOfYear();\n                case MONTH_OF_YEAR:\n                    return chronology.monthOfYear();\n                case DAY_OF_MONTH:\n                    return chronology.dayOfMonth();\n                case WEEKYEAR_OF_CENTURY:\n                    return chronology.weekyearOfCentury();\n                case WEEKYEAR:\n                    return chronology.weekyear();\n                case WEEK_OF_WEEKYEAR:\n                    return chronology.weekOfWeekyear();\n                case DAY_OF_WEEK:\n                    return chronology.dayOfWeek();\n                case HALFDAY_OF_DAY:\n                    return chronology.halfdayOfDay();\n                case HOUR_OF_HALFDAY:\n                    return chronology.hourOfHalfday();\n                case CLOCKHOUR_OF_HALFDAY:\n                    return chronology.clockhourOfHalfday();\n                case CLOCKHOUR_OF_DAY:\n                    return chronology.clockhourOfDay();\n                case HOUR_OF_DAY:\n                    return chronology.hourOfDay();\n                case MINUTE_OF_DAY:\n                    return chronology.minuteOfDay();\n                case MINUTE_OF_HOUR:\n                    return chronology.minuteOfHour();\n                case SECOND_OF_DAY:\n                    return chronology.secondOfDay();\n                case SECOND_OF_MINUTE:\n                    return chronology.secondOfMinute();\n                case MILLIS_OF_DAY:\n                    return chronology.millisOfDay();\n                case MILLIS_OF_SECOND:\n                    return chronology.millisOfSecond();\n                default:\n                    // Shouldn't happen.\n                    throw new InternalError();\n            }\n        }",
    "comment": "@inheritdoc */",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 3
  },
  {
    "name": "StandardDateTimeFieldType.getRangeDurationType",
    "class_name": "org.joda.time.DateTimeFieldType$StandardDateTimeFieldType",
    "signature": "org.joda.time.DateTimeFieldType$StandardDateTimeFieldType.getRangeDurationType()",
    "snippet": "        public DurationFieldType getRangeDurationType() {\n            return iRangeType;\n        }",
    "comment": "@inheritdoc */",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 3
  },
  {
    "name": "DateTimeUtils.checkPermission",
    "class_name": "org.joda.time.DateTimeUtils",
    "signature": "org.joda.time.DateTimeUtils.checkPermission()",
    "snippet": "    private static void checkPermission() throws SecurityException {\n        SecurityManager sm = System.getSecurityManager();\n        if (sm != null) {\n            sm.checkPermission(new JodaTimePermission(\"CurrentTime.setProvider\"));\n        }\n    }",
    "comment": " Checks whether the provider may be changed using permission 'CurrentTime.setProvider'.  @throws SecurityException if the provider may not be changed ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 3
  },
  {
    "name": "DateTimeUtils.getChronology",
    "class_name": "org.joda.time.DateTimeUtils",
    "signature": "org.joda.time.DateTimeUtils.getChronology(Chronology)",
    "snippet": "    public static final Chronology getChronology(Chronology chrono) {\n        if (chrono == null) {\n            return ISOChronology.getInstance();\n        }\n        return chrono;\n    }",
    "comment": " Gets the chronology handling null. <p> If the chronology is <code>null</code>, {@link ISOChronology#getInstance()} will be returned. Otherwise, the chronology is returned.  @param chrono  the chronology to use, null means ISO in the default zone @return the chronology, never null ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 3
  },
  {
    "name": "DateTimeUtils.getZone",
    "class_name": "org.joda.time.DateTimeUtils",
    "signature": "org.joda.time.DateTimeUtils.getZone(DateTimeZone)",
    "snippet": "    public static final DateTimeZone getZone(DateTimeZone zone) {\n        if (zone == null) {\n            return DateTimeZone.getDefault();\n        }\n        return zone;\n    }",
    "comment": " Gets the zone handling null. <p> If the zone is <code>null</code>, {@link DateTimeZone#getDefault()} will be returned. Otherwise, the zone specified is returned.  @param zone  the time zone to use, null means the default zone @return the time zone, never null ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 3
  },
  {
    "name": "DateTimeUtils.put",
    "class_name": "org.joda.time.DateTimeUtils",
    "signature": "org.joda.time.DateTimeUtils.put(Map,String,String)",
    "snippet": "    private static void put(Map<String, DateTimeZone> map, String name, String id) {\n        try {\n            map.put(name, DateTimeZone.forID(id));\n        } catch (RuntimeException ex) {\n            // ignore\n        }\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 3
  },
  {
    "name": "DateTimeUtils.setCurrentMillisFixed",
    "class_name": "org.joda.time.DateTimeUtils",
    "signature": "org.joda.time.DateTimeUtils.setCurrentMillisFixed(long)",
    "snippet": "    public static final void setCurrentMillisFixed(long fixedMillis) throws SecurityException {\n        checkPermission();\n        cMillisProvider = new FixedMillisProvider(fixedMillis);\n    }",
    "comment": " Sets the current time to return a fixed millisecond time. <p> This method changes the behaviour of {@link #currentTimeMillis()}. Whenever the current time is queried, the same millisecond time will be returned.  @param fixedMillis  the fixed millisecond time to use @throws SecurityException if the application does not have sufficient security rights ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 3
  },
  {
    "name": "DateTimeUtils.setCurrentMillisSystem",
    "class_name": "org.joda.time.DateTimeUtils",
    "signature": "org.joda.time.DateTimeUtils.setCurrentMillisSystem()",
    "snippet": "    public static final void setCurrentMillisSystem() throws SecurityException {\n        checkPermission();\n        cMillisProvider = SYSTEM_MILLIS_PROVIDER;\n    }",
    "comment": " Resets the current time to return the system time. <p> This method changes the behaviour of {@link #currentTimeMillis()}. Whenever the current time is queried, {@link System#currentTimeMillis()} is used.  @throws SecurityException if the application does not have sufficient security rights ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 3
  },
  {
    "name": "DateTimeZone.DateTimeZone",
    "class_name": "org.joda.time.DateTimeZone",
    "signature": "org.joda.time.DateTimeZone.DateTimeZone(String)",
    "snippet": "    protected DateTimeZone(String id) {\n        if (id == null) {\n            throw new IllegalArgumentException(\"Id must not be null\");\n        }\n        iID = id;\n    }",
    "comment": " Constructor.  @param id  the id to use @throws IllegalArgumentException if the id is null ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 3
  },
  {
    "name": "DateTimeZone.convertLocalToUTC",
    "class_name": "org.joda.time.DateTimeZone",
    "signature": "org.joda.time.DateTimeZone.convertLocalToUTC(long,boolean)",
    "snippet": "    public long convertLocalToUTC(long instantLocal, boolean strict) {\n        // get the offset at instantLocal (first estimate)\n        int offsetLocal = getOffset(instantLocal);\n        // adjust instantLocal using the estimate and recalc the offset\n        int offset = getOffset(instantLocal - offsetLocal);\n        // if the offsets differ, we must be near a DST boundary\n        if (offsetLocal != offset) {\n            // if strict then always check if in DST gap\n            // otherwise only check if zone in Western hemisphere (as the\n            // value of offset is already correct for Eastern hemisphere)\n            if (strict || offsetLocal < 0) {\n                // determine if we are in the DST gap\n                long nextLocal = nextTransition(instantLocal - offsetLocal);\n                if (nextLocal == (instantLocal - offsetLocal)) {\n                    nextLocal = Long.MAX_VALUE;\n                }\n                long nextAdjusted = nextTransition(instantLocal - offset);\n                if (nextAdjusted == (instantLocal - offset)) {\n                    nextAdjusted = Long.MAX_VALUE;\n                }\n                if (nextLocal != nextAdjusted) {\n                    // yes we are in the DST gap\n                    if (strict) {\n                        // DST gap is not acceptable\n                        throw new IllegalInstantException(instantLocal, getID());\n                    } else {\n                        // DST gap is acceptable, but for the Western hemisphere\n                        // the offset is wrong and will result in local times\n                        // before the cutover so use the offsetLocal instead\n                        offset = offsetLocal;\n                    }\n                }\n            }\n        }\n        // check for overflow\n        long instantUTC = instantLocal - offset;\n        // If there is a sign change, but the two values have different signs...\n        if ((instantLocal ^ instantUTC) < 0 && (instantLocal ^ offset) < 0) {\n            throw new ArithmeticException(\"Subtracting time zone offset caused overflow\");\n        }\n        return instantUTC;\n    }",
    "comment": " Converts a local instant to a standard UTC instant with the same local time. This conversion is used after performing a calculation where the calculation was done using a simple local zone.  @param instantLocal  the local instant to convert to UTC @param strict  whether the conversion should reject non-existent local times @return the UTC instant with the same local time,  @throws ArithmeticException if the result overflows a long @throws IllegalInstantException if the zone has no equivalent local time @since 1.5 ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 3
  },
  {
    "name": "DateTimeZone.convertLocalToUTC",
    "class_name": "org.joda.time.DateTimeZone",
    "signature": "org.joda.time.DateTimeZone.convertLocalToUTC(long,boolean,long)",
    "snippet": "    public long convertLocalToUTC(long instantLocal, boolean strict, long originalInstantUTC) {\n        int offsetOriginal = getOffset(originalInstantUTC);\n        long instantUTC = instantLocal - offsetOriginal;\n        int offsetLocalFromOriginal = getOffset(instantUTC);\n        if (offsetLocalFromOriginal == offsetOriginal) {\n            return instantUTC;\n        }\n        return convertLocalToUTC(instantLocal, strict);\n    }",
    "comment": " Converts a local instant to a standard UTC instant with the same local time attempting to use the same offset as the original. <p> This conversion is used after performing a calculation where the calculation was done using a simple local zone. Whenever possible, the same offset as the original offset will be used. This is most significant during a daylight savings overlap.  @param instantLocal  the local instant to convert to UTC @param strict  whether the conversion should reject non-existent local times @param originalInstantUTC  the original instant that the calculation is based on @return the UTC instant with the same local time,  @throws ArithmeticException if the result overflows a long @throws IllegalArgumentException if the zone has no equivalent local time @since 2.0 ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 3
  },
  {
    "name": "DateTimeZone.convertUTCToLocal",
    "class_name": "org.joda.time.DateTimeZone",
    "signature": "org.joda.time.DateTimeZone.convertUTCToLocal(long)",
    "snippet": "    public long convertUTCToLocal(long instantUTC) {\n        int offset = getOffset(instantUTC);\n        long instantLocal = instantUTC + offset;\n        // If there is a sign change, but the two values have the same sign...\n        if ((instantUTC ^ instantLocal) < 0 && (instantUTC ^ offset) >= 0) {\n            throw new ArithmeticException(\"Adding time zone offset caused overflow\");\n        }\n        return instantLocal;\n    }",
    "comment": " Converts a standard UTC instant to a local instant with the same local time. This conversion is used before performing a calculation so that the calculation can be done using a simple local zone.  @param instantUTC  the UTC instant to convert to local @return the local instant with the same local time @throws ArithmeticException if the result overflows a long @since 1.5 ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 3
  },
  {
    "name": "DateTimeZone.forID",
    "class_name": "org.joda.time.DateTimeZone",
    "signature": "org.joda.time.DateTimeZone.forID(String)",
    "snippet": "    @FromString\n    public static DateTimeZone forID(String id) {\n        if (id == null) {\n            return getDefault();\n        }\n        if (id.equals(\"UTC\")) {\n            return DateTimeZone.UTC;\n        }\n        DateTimeZone zone = cProvider.getZone(id);\n        if (zone != null) {\n            return zone;\n        }\n        if (id.startsWith(\"+\") || id.startsWith(\"-\")) {\n            int offset = parseOffset(id);\n            if (offset == 0L) {\n                return DateTimeZone.UTC;\n            } else {\n                id = printOffset(offset);\n                return fixedOffsetZone(id, offset);\n            }\n        }\n        throw new IllegalArgumentException(\"The datetime zone id '\" + id + \"' is not recognised\");\n    }",
    "comment": " Gets a time zone instance for the specified time zone id. <p> The time zone id may be one of those returned by getAvailableIDs. Short ids, as accepted by {@link java.util.TimeZone}, are not accepted. All IDs must be specified in the long format. The exception is UTC, which is an acceptable id. <p> Alternatively a locale independent, fixed offset, datetime zone can be specified. The form <code>[+-]hh:mm</code> can be used.  @param id  the ID of the datetime zone, null means default @return the DateTimeZone object for the ID @throws IllegalArgumentException if the ID is not recognised ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 3
  },
  {
    "name": "DateTimeZone.forTimeZone",
    "class_name": "org.joda.time.DateTimeZone",
    "signature": "org.joda.time.DateTimeZone.forTimeZone(TimeZone)",
    "snippet": "    public static DateTimeZone forTimeZone(TimeZone zone) {\n        if (zone == null) {\n            return getDefault();\n        }\n        final String id = zone.getID();\n        if (id.equals(\"UTC\")) {\n            return DateTimeZone.UTC;\n        }\n\n        // Convert from old alias before consulting provider since they may differ.\n        DateTimeZone dtz = null;\n        String convId = getConvertedId(id);\n        if (convId != null) {\n            dtz = cProvider.getZone(convId);\n        }\n        if (dtz == null) {\n            dtz = cProvider.getZone(id);\n        }\n        if (dtz != null) {\n            return dtz;\n        }\n\n        // Support GMT+/-hh:mm formats\n        if (convId == null) {\n            convId = zone.getID();\n            if (convId.startsWith(\"GMT+\") || convId.startsWith(\"GMT-\")) {\n                convId = convId.substring(3);\n                int offset = parseOffset(convId);\n                if (offset == 0L) {\n                    return DateTimeZone.UTC;\n                } else {\n                    convId = printOffset(offset);\n                    return fixedOffsetZone(convId, offset);\n                }\n            }\n        }\n        throw new IllegalArgumentException(\"The datetime zone id '\" + id + \"' is not recognised\");\n    }",
    "comment": " Gets a time zone instance for a JDK TimeZone. <p> DateTimeZone only accepts a subset of the IDs from TimeZone. The excluded IDs are the short three letter form (except UTC). This  method will attempt to convert between time zones created using the short IDs and the full version. <p> This method is not designed to parse time zones with rules created by applications using <code>SimpleTimeZone</code> directly.  @param zone  the zone to convert, null means default @return the DateTimeZone object for the zone @throws IllegalArgumentException if the zone is not recognised ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 3
  },
  {
    "name": "DateTimeZone.getConvertedId",
    "class_name": "org.joda.time.DateTimeZone",
    "signature": "org.joda.time.DateTimeZone.getConvertedId(String)",
    "snippet": "    private static synchronized String getConvertedId(String id) {\n        Map<String, String> map = cZoneIdConversion;\n        if (map == null) {\n            // Backwards compatibility with TimeZone.\n            map = new HashMap<String, String>();\n            map.put(\"GMT\", \"UTC\");\n            map.put(\"WET\", \"WET\");\n            map.put(\"CET\", \"CET\");\n            map.put(\"MET\", \"CET\");\n            map.put(\"ECT\", \"CET\");\n            map.put(\"EET\", \"EET\");\n            map.put(\"MIT\", \"Pacific/Apia\");\n            map.put(\"HST\", \"Pacific/Honolulu\");  // JDK 1.1 compatible\n            map.put(\"AST\", \"America/Anchorage\");\n            map.put(\"PST\", \"America/Los_Angeles\");\n            map.put(\"MST\", \"America/Denver\");  // JDK 1.1 compatible\n            map.put(\"PNT\", \"America/Phoenix\");\n            map.put(\"CST\", \"America/Chicago\");\n            map.put(\"EST\", \"America/New_York\");  // JDK 1.1 compatible\n            map.put(\"IET\", \"America/Indiana/Indianapolis\");\n            map.put(\"PRT\", \"America/Puerto_Rico\");\n            map.put(\"CNT\", \"America/St_Johns\");\n            map.put(\"AGT\", \"America/Argentina/Buenos_Aires\");\n            map.put(\"BET\", \"America/Sao_Paulo\");\n            map.put(\"ART\", \"Africa/Cairo\");\n            map.put(\"CAT\", \"Africa/Harare\");\n            map.put(\"EAT\", \"Africa/Addis_Ababa\");\n            map.put(\"NET\", \"Asia/Yerevan\");\n            map.put(\"PLT\", \"Asia/Karachi\");\n            map.put(\"IST\", \"Asia/Kolkata\");\n            map.put(\"BST\", \"Asia/Dhaka\");\n            map.put(\"VST\", \"Asia/Ho_Chi_Minh\");\n            map.put(\"CTT\", \"Asia/Shanghai\");\n            map.put(\"JST\", \"Asia/Tokyo\");\n            map.put(\"ACT\", \"Australia/Darwin\");\n            map.put(\"AET\", \"Australia/Sydney\");\n            map.put(\"SST\", \"Pacific/Guadalcanal\");\n            map.put(\"NST\", \"Pacific/Auckland\");\n            cZoneIdConversion = map;\n        }\n        return map.get(id);\n    }",
    "comment": " Converts an old style id to a new style id.  @param id  the old style id @return the new style id, null if not found ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 3
  },
  {
    "name": "DateTimeZone.getDefault",
    "class_name": "org.joda.time.DateTimeZone",
    "signature": "org.joda.time.DateTimeZone.getDefault()",
    "snippet": "    public static DateTimeZone getDefault() {\n        DateTimeZone zone = cDefault;\n        if (zone == null) {\n            synchronized(DateTimeZone.class) {\n                zone = cDefault;\n                if (zone == null) {\n                    DateTimeZone temp = null;\n                    try {\n                        try {\n                            String id = System.getProperty(\"user.timezone\");\n                            if (id != null) {  // null check avoids stack overflow\n                                temp = forID(id);\n                            }\n                        } catch (RuntimeException ex) {\n                            // ignored\n                        }\n                        if (temp == null) {\n                            temp = forTimeZone(TimeZone.getDefault());\n                        }\n                    } catch (IllegalArgumentException ex) {\n                        // ignored\n                    }\n                    if (temp == null) {\n                        temp = UTC;\n                    }\n                    cDefault = zone = temp;\n                }\n            }\n        }\n        return zone;\n    }",
    "comment": " Gets the default time zone. <p> The default time zone is derived from the system property {@code user.timezone}. If that is {@code null} or is not a valid identifier, then the value of the JDK {@code TimeZone} default is converted. If that fails, {@code UTC} is used. <p> NOTE: If the {@code java.util.TimeZone} default is updated <i>after</i> calling this method, then the change will not be picked up here.  @return the default datetime zone object ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 3
  },
  {
    "name": "DateTimeZone.getDefaultNameProvider",
    "class_name": "org.joda.time.DateTimeZone",
    "signature": "org.joda.time.DateTimeZone.getDefaultNameProvider()",
    "snippet": "    private static NameProvider getDefaultNameProvider() {\n        NameProvider nameProvider = null;\n        try {\n            String providerClass = System.getProperty(\"org.joda.time.DateTimeZone.NameProvider\");\n            if (providerClass != null) {\n                try {\n                    nameProvider = (NameProvider) Class.forName(providerClass).newInstance();\n                } catch (Exception ex) {\n                    throw new RuntimeException(ex);\n                }\n            }\n        } catch (SecurityException ex) {\n            // ignore\n        }\n\n        if (nameProvider == null) {\n            nameProvider = new DefaultNameProvider();\n        }\n\n        return nameProvider;\n    }",
    "comment": " Gets the default name provider. <p> Tries the system property <code>org.joda.time.DateTimeZone.NameProvider</code>. Then uses <code>DefaultNameProvider</code>.  @return the default name provider ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 3
  },
  {
    "name": "DateTimeZone.getDefaultProvider",
    "class_name": "org.joda.time.DateTimeZone",
    "signature": "org.joda.time.DateTimeZone.getDefaultProvider()",
    "snippet": "    private static Provider getDefaultProvider() {\n        Provider provider = null;\n\n        try {\n            String providerClass = System.getProperty(\"org.joda.time.DateTimeZone.Provider\");\n            if (providerClass != null) {\n                try {\n                    provider = (Provider) Class.forName(providerClass).newInstance();\n                } catch (Exception ex) {\n                    throw new RuntimeException(ex);\n                }\n            }\n        } catch (SecurityException ex) {\n            // ignored\n        }\n\n        if (provider == null) {\n            try {\n                provider = new ZoneInfoProvider(\"org/joda/time/tz/data\");\n            } catch (Exception ex) {\n                ex.printStackTrace();\n            }\n        }\n\n        if (provider == null) {\n            provider = new UTCProvider();\n        }\n\n        return provider;\n    }",
    "comment": " Gets the default zone provider. <p> Tries the system property <code>org.joda.time.DateTimeZone.Provider</code>. Then tries a <code>ZoneInfoProvider</code> using the data in <code>org/joda/time/tz/data</code>. Then uses <code>UTCProvider</code>.  @return the default name provider ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 3
  },
  {
    "name": "DateTimeZone.getID",
    "class_name": "org.joda.time.DateTimeZone",
    "signature": "org.joda.time.DateTimeZone.getID()",
    "snippet": "    @ToString\n    public final String getID() {\n        return iID;\n    }",
    "comment": " Gets the ID of this datetime zone.  @return the ID of this datetime zone ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 3
  },
  {
    "name": "DateTimeZone.getMillisKeepLocal",
    "class_name": "org.joda.time.DateTimeZone",
    "signature": "org.joda.time.DateTimeZone.getMillisKeepLocal(DateTimeZone,long)",
    "snippet": "    public long getMillisKeepLocal(DateTimeZone newZone, long oldInstant) {\n        if (newZone == null) {\n            newZone = DateTimeZone.getDefault();\n        }\n        if (newZone == this) {\n            return oldInstant;\n        }\n        long instantLocal = convertUTCToLocal(oldInstant);\n        return newZone.convertLocalToUTC(instantLocal, false, oldInstant);\n    }",
    "comment": " Gets the millisecond instant in another zone keeping the same local time. <p> The conversion is performed by converting the specified UTC millis to local millis in this zone, then converting back to UTC millis in the new zone.  @param newZone  the new zone, null means default @param oldInstant  the UTC millisecond instant to convert @return the UTC millisecond instant with the same local time in the new zone ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 3
  },
  {
    "name": "DateTimeZone.hashCode",
    "class_name": "org.joda.time.DateTimeZone",
    "signature": "org.joda.time.DateTimeZone.hashCode()",
    "snippet": "    public int hashCode() {\n        return 57 + getID().hashCode();\n    }",
    "comment": " Gets a hash code compatable with equals.  @return suitable hashcode ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 3
  },
  {
    "name": "DateTimeZone.setDefault",
    "class_name": "org.joda.time.DateTimeZone",
    "signature": "org.joda.time.DateTimeZone.setDefault(DateTimeZone)",
    "snippet": "    public static void setDefault(DateTimeZone zone) throws SecurityException {\n        SecurityManager sm = System.getSecurityManager();\n        if (sm != null) {\n            sm.checkPermission(new JodaTimePermission(\"DateTimeZone.setDefault\"));\n        }\n        if (zone == null) {\n            throw new IllegalArgumentException(\"The datetime zone must not be null\");\n        }\n        synchronized(DateTimeZone.class) {\n            cDefault = zone;\n        }\n    }",
    "comment": " Sets the default time zone. <p> NOTE: Calling this method does <i>not</i> set the {@code java.util.TimeZone} default.  @param zone  the default datetime zone object, must not be null @throws IllegalArgumentException if the zone is null @throws SecurityException if the application has insufficient security rights ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 3
  },
  {
    "name": "DateTimeZone.setNameProvider0",
    "class_name": "org.joda.time.DateTimeZone",
    "signature": "org.joda.time.DateTimeZone.setNameProvider0(NameProvider)",
    "snippet": "    private static void setNameProvider0(NameProvider nameProvider) {\n        if (nameProvider == null) {\n            nameProvider = getDefaultNameProvider();\n        }\n        cNameProvider = nameProvider;\n    }",
    "comment": " Sets the name provider factory without performing the security check.  @param nameProvider  provider to use, or null for default @throws IllegalArgumentException if the provider is invalid ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 3
  },
  {
    "name": "DateTimeZone.setProvider0",
    "class_name": "org.joda.time.DateTimeZone",
    "signature": "org.joda.time.DateTimeZone.setProvider0(Provider)",
    "snippet": "    private static void setProvider0(Provider provider) {\n        if (provider == null) {\n            provider = getDefaultProvider();\n        }\n        Set<String> ids = provider.getAvailableIDs();\n        if (ids == null || ids.size() == 0) {\n            throw new IllegalArgumentException\n                (\"The provider doesn't have any available ids\");\n        }\n        if (!ids.contains(\"UTC\")) {\n            throw new IllegalArgumentException(\"The provider doesn't support UTC\");\n        }\n        if (!UTC.equals(provider.getZone(\"UTC\"))) {\n            throw new IllegalArgumentException(\"Invalid UTC zone provided\");\n        }\n        cProvider = provider;\n        cAvailableIDs = ids;\n    }",
    "comment": " Sets the zone provider factory without performing the security check.  @param provider  provider to use, or null for default @throws IllegalArgumentException if the provider is invalid ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 3
  },
  {
    "name": "DurationFieldType.DurationFieldType",
    "class_name": "org.joda.time.DurationFieldType",
    "signature": "org.joda.time.DurationFieldType.DurationFieldType(String)",
    "snippet": "    protected DurationFieldType(String name) {\n        super();\n        iName = name;\n    }",
    "comment": " Constructor.  @param name  the name to use, which by convention, are plural. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 3
  },
  {
    "name": "DurationFieldType.centuries",
    "class_name": "org.joda.time.DurationFieldType",
    "signature": "org.joda.time.DurationFieldType.centuries()",
    "snippet": "    public static DurationFieldType centuries() {\n        return CENTURIES_TYPE;\n    }",
    "comment": " Get the centuries field type.  @return the DateTimeFieldType constant ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 3
  },
  {
    "name": "DurationFieldType.days",
    "class_name": "org.joda.time.DurationFieldType",
    "signature": "org.joda.time.DurationFieldType.days()",
    "snippet": "    public static DurationFieldType days() {\n        return DAYS_TYPE;\n    }",
    "comment": " Get the days field type.  @return the DateTimeFieldType constant ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 3
  },
  {
    "name": "DurationFieldType.eras",
    "class_name": "org.joda.time.DurationFieldType",
    "signature": "org.joda.time.DurationFieldType.eras()",
    "snippet": "    public static DurationFieldType eras() {\n        return ERAS_TYPE;\n    }",
    "comment": " Get the eras field type.  @return the DateTimeFieldType constant ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 3
  },
  {
    "name": "DurationFieldType.halfdays",
    "class_name": "org.joda.time.DurationFieldType",
    "signature": "org.joda.time.DurationFieldType.halfdays()",
    "snippet": "    public static DurationFieldType halfdays() {\n        return HALFDAYS_TYPE;\n    }",
    "comment": " Get the halfdays field type.  @return the DateTimeFieldType constant ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 3
  },
  {
    "name": "DurationFieldType.hours",
    "class_name": "org.joda.time.DurationFieldType",
    "signature": "org.joda.time.DurationFieldType.hours()",
    "snippet": "    public static DurationFieldType hours() {\n        return HOURS_TYPE;\n    }",
    "comment": " Get the hours field type.  @return the DateTimeFieldType constant ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 3
  },
  {
    "name": "DurationFieldType.millis",
    "class_name": "org.joda.time.DurationFieldType",
    "signature": "org.joda.time.DurationFieldType.millis()",
    "snippet": "    public static DurationFieldType millis() {\n        return MILLIS_TYPE;\n    }",
    "comment": " Get the millis field type.  @return the DateTimeFieldType constant ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 3
  },
  {
    "name": "DurationFieldType.minutes",
    "class_name": "org.joda.time.DurationFieldType",
    "signature": "org.joda.time.DurationFieldType.minutes()",
    "snippet": "    public static DurationFieldType minutes() {\n        return MINUTES_TYPE;\n    }",
    "comment": " Get the minutes field type.  @return the DateTimeFieldType constant ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 3
  },
  {
    "name": "DurationFieldType.months",
    "class_name": "org.joda.time.DurationFieldType",
    "signature": "org.joda.time.DurationFieldType.months()",
    "snippet": "    public static DurationFieldType months() {\n        return MONTHS_TYPE;\n    }",
    "comment": " Get the months field type.  @return the DateTimeFieldType constant ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 3
  },
  {
    "name": "DurationFieldType.seconds",
    "class_name": "org.joda.time.DurationFieldType",
    "signature": "org.joda.time.DurationFieldType.seconds()",
    "snippet": "    public static DurationFieldType seconds() {\n        return SECONDS_TYPE;\n    }",
    "comment": " Get the seconds field type.  @return the DateTimeFieldType constant ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 3
  },
  {
    "name": "DurationFieldType.weeks",
    "class_name": "org.joda.time.DurationFieldType",
    "signature": "org.joda.time.DurationFieldType.weeks()",
    "snippet": "    public static DurationFieldType weeks() {\n        return WEEKS_TYPE;\n    }",
    "comment": " Get the weeks field type.  @return the DateTimeFieldType constant ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 3
  },
  {
    "name": "DurationFieldType.weekyears",
    "class_name": "org.joda.time.DurationFieldType",
    "signature": "org.joda.time.DurationFieldType.weekyears()",
    "snippet": "    public static DurationFieldType weekyears() {\n        return WEEKYEARS_TYPE;\n    }",
    "comment": " Get the weekyears field type.  @return the DateTimeFieldType constant ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 3
  },
  {
    "name": "DurationFieldType.years",
    "class_name": "org.joda.time.DurationFieldType",
    "signature": "org.joda.time.DurationFieldType.years()",
    "snippet": "    public static DurationFieldType years() {\n        return YEARS_TYPE;\n    }",
    "comment": " Get the years field type.  @return the DateTimeFieldType constant ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 3
  },
  {
    "name": "StandardDurationFieldType.getField",
    "class_name": "org.joda.time.DurationFieldType$StandardDurationFieldType",
    "signature": "org.joda.time.DurationFieldType$StandardDurationFieldType.getField(Chronology)",
    "snippet": "        public DurationField getField(Chronology chronology) {\n            chronology = DateTimeUtils.getChronology(chronology);\n            \n            switch (iOrdinal) {\n                case ERAS:\n                    return chronology.eras();\n                case CENTURIES:\n                    return chronology.centuries();\n                case WEEKYEARS:\n                    return chronology.weekyears();\n                case YEARS:\n                    return chronology.years();\n                case MONTHS:\n                    return chronology.months();\n                case WEEKS:\n                    return chronology.weeks();\n                case DAYS:\n                    return chronology.days();\n                case HALFDAYS:\n                    return chronology.halfdays();\n                case HOURS:\n                    return chronology.hours();\n                case MINUTES:\n                    return chronology.minutes();\n                case SECONDS:\n                    return chronology.seconds();\n                case MILLIS:\n                    return chronology.millis();\n                default:\n                    // Shouldn't happen.\n                    throw new InternalError();\n            }\n        }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 3
  },
  {
    "name": "StandardDurationFieldType.hashCode",
    "class_name": "org.joda.time.DurationFieldType$StandardDurationFieldType",
    "signature": "org.joda.time.DurationFieldType$StandardDurationFieldType.hashCode()",
    "snippet": "        @Override\n        public int hashCode() {\n            return (1 << iOrdinal);\n        }",
    "comment": "@inheritdoc */",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 3
  },
  {
    "name": "Instant.Instant",
    "class_name": "org.joda.time.Instant",
    "signature": "org.joda.time.Instant.Instant(long)",
    "snippet": "    public Instant(long instant) {\n        super();\n        iMillis = instant;\n    }",
    "comment": " Constructs an instance set to the milliseconds from 1970-01-01T00:00:00Z.  @param instant  the milliseconds from 1970-01-01T00:00:00Z ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 3
  },
  {
    "name": "Instant.getMillis",
    "class_name": "org.joda.time.Instant",
    "signature": "org.joda.time.Instant.getMillis()",
    "snippet": "    public long getMillis() {\n        return iMillis;\n    }",
    "comment": " Gets the milliseconds of the instant.  @return the number of milliseconds since 1970-01-01T00:00:00Z ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 3
  },
  {
    "name": "Instant.toInstant",
    "class_name": "org.joda.time.Instant",
    "signature": "org.joda.time.Instant.toInstant()",
    "snippet": "    public Instant toInstant() {\n        return this;\n    }",
    "comment": " Get this object as an Instant by returning <code>this</code>.  @return <code>this</code> ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 3
  },
  {
    "name": "LocalDate.LocalDate",
    "class_name": "org.joda.time.LocalDate",
    "signature": "org.joda.time.LocalDate.LocalDate(long,Chronology)",
    "snippet": "    public LocalDate(long instant, Chronology chronology) {\n        chronology = DateTimeUtils.getChronology(chronology);\n        \n        long localMillis = chronology.getZone().getMillisKeepLocal(DateTimeZone.UTC, instant);\n        chronology = chronology.withUTC();\n        iLocalMillis = chronology.dayOfMonth().roundFloor(localMillis);\n        iChronology = chronology;\n    }",
    "comment": " Constructs an instance set to the local time defined by the specified instant evaluated using the specified chronology. <p> If the chronology is null, ISO chronology in the default zone is used. Once the constructor is completed, the zone is no longer used.  @param instant  the milliseconds from 1970-01-01T00:00:00Z @param chronology  the chronology, null means ISOChronology in default zone ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 3
  },
  {
    "name": "LocalDate.getChronology",
    "class_name": "org.joda.time.LocalDate",
    "signature": "org.joda.time.LocalDate.getChronology()",
    "snippet": "    public Chronology getChronology() {\n        return iChronology;\n    }",
    "comment": " Gets the chronology of the date.  @return the Chronology that the date is using ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 3
  },
  {
    "name": "LocalDate.getLocalMillis",
    "class_name": "org.joda.time.LocalDate",
    "signature": "org.joda.time.LocalDate.getLocalMillis()",
    "snippet": "    protected long getLocalMillis() {\n        return iLocalMillis;\n    }",
    "comment": " Gets the local milliseconds from the Java epoch of 1970-01-01T00:00:00 (not fixed to any specific time zone).  @return the number of milliseconds since 1970-01-01T00:00:00 @since 1.5 (previously private) ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 3
  },
  {
    "name": "LocalDate.getYear",
    "class_name": "org.joda.time.LocalDate",
    "signature": "org.joda.time.LocalDate.getYear()",
    "snippet": "    public int getYear() {\n        return getChronology().year().get(getLocalMillis());\n    }",
    "comment": " Get the year field value.  @return the year ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 3
  },
  {
    "name": "Partial.Partial",
    "class_name": "org.joda.time.Partial",
    "signature": "org.joda.time.Partial.Partial(DateTimeFieldType,int)",
    "snippet": "    public Partial(DateTimeFieldType type, int value) {\n        this(type, value, null);\n    }",
    "comment": " Constructs a Partial with the specified field and value. <p> The constructor uses the default ISO chronology.  @param type  the single type to create the partial from, not null @param value  the value to store @throws IllegalArgumentException if the type or value is invalid ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 3
  },
  {
    "name": "Partial.Partial",
    "class_name": "org.joda.time.Partial",
    "signature": "org.joda.time.Partial.Partial(DateTimeFieldType,int,Chronology)",
    "snippet": "    public Partial(DateTimeFieldType type, int value, Chronology chronology) {\n        super();\n        chronology = DateTimeUtils.getChronology(chronology).withUTC();\n        iChronology = chronology;\n        if (type == null) {\n            throw new IllegalArgumentException(\"The field type must not be null\");\n        }\n        iTypes = new DateTimeFieldType[] {type};\n        iValues = new int[] {value};\n        chronology.validate(this, iValues);\n    }",
    "comment": " Constructs a Partial with the specified field and value. <p> The constructor uses the specified chronology.  @param type  the single type to create the partial from, not null @param value  the value to store @param chronology  the chronology, null means ISO @throws IllegalArgumentException if the type or value is invalid ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 3
  },
  {
    "name": "Partial.Partial",
    "class_name": "org.joda.time.Partial",
    "signature": "org.joda.time.Partial.Partial(DateTimeFieldType[],int[],Chronology)",
    "snippet": "    public Partial(DateTimeFieldType[] types, int[] values, Chronology chronology) {\n        super();\n        chronology = DateTimeUtils.getChronology(chronology).withUTC();\n        iChronology = chronology;\n        if (types == null) {\n            throw new IllegalArgumentException(\"Types array must not be null\");\n        }\n        if (values == null) {\n            throw new IllegalArgumentException(\"Values array must not be null\");\n        }\n        if (values.length != types.length) {\n            throw new IllegalArgumentException(\"Values array must be the same length as the types array\");\n        }\n        if (types.length == 0) {\n            iTypes = types;\n            iValues = values;\n            return;\n        }\n        for (int i = 0; i < types.length; i++) {\n            if (types[i] == null) {\n                throw new IllegalArgumentException(\"Types array must not contain null: index \" + i);\n            }\n        }\n        DurationField lastUnitField = null;\n        for (int i = 0; i < types.length; i++) {\n            DateTimeFieldType loopType = types[i];\n            DurationField loopUnitField = loopType.getDurationType().getField(iChronology);\n            if (i > 0) {\n                int compare = lastUnitField.compareTo(loopUnitField);\n                if (compare < 0 || (compare != 0 && loopUnitField.isSupported() == false)) {\n                    throw new IllegalArgumentException(\"Types array must be in order largest-smallest: \" +\n                            types[i - 1].getName() + \" < \" + loopType.getName());\n                } else if (compare == 0) {\n                    if (types[i - 1].getRangeDurationType() == null) {\n                        if (loopType.getRangeDurationType() == null) {\n                            throw new IllegalArgumentException(\"Types array must not contain duplicate: \" +\n                                            types[i - 1].getName() + \" and \" + loopType.getName());\n                        }\n                    } else {\n                        if (loopType.getRangeDurationType() == null) {\n                            throw new IllegalArgumentException(\"Types array must be in order largest-smallest: \" +\n                                    types[i - 1].getName() + \" < \" + loopType.getName());\n                        }\n                        DurationField lastRangeField = types[i - 1].getRangeDurationType().getField(iChronology);\n                        DurationField loopRangeField = loopType.getRangeDurationType().getField(iChronology);\n                        if (lastRangeField.compareTo(loopRangeField) < 0) {\n                            throw new IllegalArgumentException(\"Types array must be in order largest-smallest: \" +\n                                    types[i - 1].getName() + \" < \" + loopType.getName());\n                        }\n                        if (lastRangeField.compareTo(loopRangeField) == 0) {\n                            throw new IllegalArgumentException(\"Types array must not contain duplicate: \" +\n                                            types[i - 1].getName() + \" and \" + loopType.getName());\n                        }\n                    }\n                }\n            }\n            lastUnitField = loopUnitField;\n        }\n        \n        iTypes = (DateTimeFieldType[]) types.clone();\n        chronology.validate(this, values);\n        iValues = (int[]) values.clone();\n    }",
    "comment": " Constructs a Partial with the specified fields and values. The fields must be specified in the order largest to smallest. <p> The constructor uses the specified chronology.  @param types  the types to create the partial from, not null @param values  the values to store, not null @param chronology  the chronology, null means ISO @throws IllegalArgumentException if the types or values are invalid ",
    "is_bug": true,
    "failing_test_cases": 1,
    "buggy_methods": 3
  },
  {
    "name": "Partial.getChronology",
    "class_name": "org.joda.time.Partial",
    "signature": "org.joda.time.Partial.getChronology()",
    "snippet": "    public Chronology getChronology() {\n        return iChronology;\n    }",
    "comment": " Gets the chronology of the partial which is never null. <p> The {@link Chronology} is the calculation engine behind the partial and provides conversion and validation of the fields in a particular calendar system.  @return the chronology, never null ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 3
  },
  {
    "name": "Partial.getField",
    "class_name": "org.joda.time.Partial",
    "signature": "org.joda.time.Partial.getField(int,Chronology)",
    "snippet": "    protected DateTimeField getField(int index, Chronology chrono) {\n        return iTypes[index].getField(chrono);\n    }",
    "comment": " Gets the field for a specific index in the chronology specified.  @param index  the index to retrieve @param chrono  the chronology to use @return the field @throws IndexOutOfBoundsException if the index is invalid ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 3
  },
  {
    "name": "Partial.getFieldType",
    "class_name": "org.joda.time.Partial",
    "signature": "org.joda.time.Partial.getFieldType(int)",
    "snippet": "    public DateTimeFieldType getFieldType(int index) {\n        return iTypes[index];\n    }",
    "comment": " Gets the field type at the specified index.  @param index  the index to retrieve @return the field at the specified index @throws IndexOutOfBoundsException if the index is invalid ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 3
  },
  {
    "name": "Partial.size",
    "class_name": "org.joda.time.Partial",
    "signature": "org.joda.time.Partial.size()",
    "snippet": "    public int size() {\n        return iTypes.length;\n    }",
    "comment": " Gets the number of fields in this partial.  @return the field count ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 3
  },
  {
    "name": "Partial.with",
    "class_name": "org.joda.time.Partial",
    "signature": "org.joda.time.Partial.with(DateTimeFieldType,int)",
    "snippet": "    public Partial with(DateTimeFieldType fieldType, int value) {\n        if (fieldType == null) {\n            throw new IllegalArgumentException(\"The field type must not be null\");\n        }\n        int index = indexOf(fieldType);\n        if (index == -1) {\n            DateTimeFieldType[] newTypes = new DateTimeFieldType[iTypes.length + 1];\n            int[] newValues = new int[newTypes.length];\n            \n            // find correct insertion point to keep largest-smallest order\n            int i = 0;\n            DurationField unitField = fieldType.getDurationType().getField(iChronology);\n            if (unitField.isSupported()) {\n                for (; i < iTypes.length; i++) {\n                    DateTimeFieldType loopType = iTypes[i];\n                    DurationField loopUnitField = loopType.getDurationType().getField(iChronology);\n                    if (loopUnitField.isSupported()) {\n                        int compare = unitField.compareTo(loopUnitField);\n                        if (compare > 0) {\n                            break;\n                        } else if (compare == 0) {\n                            DurationField rangeField = fieldType.getRangeDurationType().getField(iChronology);\n                            DurationField loopRangeField = loopType.getRangeDurationType().getField(iChronology);\n                            if (rangeField.compareTo(loopRangeField) > 0) {\n                                break;\n                            }\n                        }\n                    }\n                }\n            }\n            System.arraycopy(iTypes, 0, newTypes, 0, i);\n            System.arraycopy(iValues, 0, newValues, 0, i);\n            newTypes[i] = fieldType;\n            newValues[i] = value;\n            System.arraycopy(iTypes, i, newTypes, i + 1, newTypes.length - i - 1);\n            System.arraycopy(iValues, i, newValues, i + 1, newValues.length - i - 1);\n            // use public constructor to ensure full validation\n            // this isn't overly efficient, but is safe\n            Partial newPartial = new Partial(newTypes, newValues, iChronology);\n            iChronology.validate(newPartial, newValues);\n            return newPartial;\n        }\n        if (value == getValue(index)) {\n            return this;\n        }\n        int[] newValues = getValues();\n        newValues = getField(index).set(this, index, newValues, value);\n        return new Partial(this, newValues);\n    }",
    "comment": " Gets a copy of this date with the specified field set to a new value. <p> If this partial did not previously support the field, the new one will. Contrast this behaviour with {@link #withField(DateTimeFieldType, int)}. <p> For example, if the field type is <code>dayOfMonth</code> then the day would be changed/added in the returned instance.  @param fieldType  the field type to set, not null @param value  the value to set @return a copy of this instance with the field set @throws IllegalArgumentException if the value is null or invalid ",
    "is_bug": true,
    "failing_test_cases": 1,
    "buggy_methods": 3
  },
  {
    "name": "AbstractDateTime.AbstractDateTime",
    "class_name": "org.joda.time.base.AbstractDateTime",
    "signature": "org.joda.time.base.AbstractDateTime.AbstractDateTime()",
    "snippet": "    protected AbstractDateTime() {\n        super();\n    }",
    "comment": " Constructor. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 3
  },
  {
    "name": "AbstractInstant.AbstractInstant",
    "class_name": "org.joda.time.base.AbstractInstant",
    "signature": "org.joda.time.base.AbstractInstant.AbstractInstant()",
    "snippet": "    protected AbstractInstant() {\n        super();\n    }",
    "comment": " Constructor. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 3
  },
  {
    "name": "AbstractInstant.equals",
    "class_name": "org.joda.time.base.AbstractInstant",
    "signature": "org.joda.time.base.AbstractInstant.equals(Object)",
    "snippet": "    public boolean equals(Object readableInstant) {\n        // must be to fulfil ReadableInstant contract\n        if (this == readableInstant) {\n            return true;\n        }\n        if (readableInstant instanceof ReadableInstant == false) {\n            return false;\n        }\n        ReadableInstant otherInstant = (ReadableInstant) readableInstant;\n        return\n            getMillis() == otherInstant.getMillis() &&\n            FieldUtils.equals(getChronology(), otherInstant.getChronology());\n    }",
    "comment": " Compares this object with the specified object for equality based on the millisecond instant, chronology and time zone. <p> Two objects which represent the same instant in time, but are in different time zones (based on time zone id), will be considered to be different. Only two objects with the same {@link DateTimeZone}, {@link Chronology} and instant are equal. <p> See {@link #isEqual(ReadableInstant)} for an equals method that ignores the Chronology and time zone. <p> All ReadableInstant instances are accepted.  @param readableInstant  a readable instant to check against @return true if millisecond and chronology are equal, false if not or the instant is null or of an incorrect type ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 3
  },
  {
    "name": "AbstractPartial.AbstractPartial",
    "class_name": "org.joda.time.base.AbstractPartial",
    "signature": "org.joda.time.base.AbstractPartial.AbstractPartial()",
    "snippet": "    protected AbstractPartial() {\n        super();\n    }",
    "comment": " Constructor. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 3
  },
  {
    "name": "AbstractPartial.getField",
    "class_name": "org.joda.time.base.AbstractPartial",
    "signature": "org.joda.time.base.AbstractPartial.getField(int)",
    "snippet": "    public DateTimeField getField(int index) {\n        return getField(index, getChronology());\n    }",
    "comment": " Gets the field at the specifed index.  @param index  the index @return the field @throws IndexOutOfBoundsException if the index is invalid ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 3
  },
  {
    "name": "AbstractPartial.indexOf",
    "class_name": "org.joda.time.base.AbstractPartial",
    "signature": "org.joda.time.base.AbstractPartial.indexOf(DateTimeFieldType)",
    "snippet": "    public int indexOf(DateTimeFieldType type) {\n        for (int i = 0, isize = size(); i < isize; i++) {\n            if (getFieldType(i) == type) {\n                return i;\n            }\n        }\n        return -1;\n    }",
    "comment": " Gets the index of the specified field, or -1 if the field is unsupported.  @param type  the type to check, may be null which returns -1 @return the index of the field, -1 if unsupported ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 3
  },
  {
    "name": "BaseDateTime.BaseDateTime",
    "class_name": "org.joda.time.base.BaseDateTime",
    "signature": "org.joda.time.base.BaseDateTime.BaseDateTime(int,int,int,int,int,int,int,Chronology)",
    "snippet": "    public BaseDateTime(\n            int year,\n            int monthOfYear,\n            int dayOfMonth,\n            int hourOfDay,\n            int minuteOfHour,\n            int secondOfMinute,\n            int millisOfSecond,\n            Chronology chronology) {\n        super();\n        iChronology = checkChronology(chronology);\n        long instant = iChronology.getDateTimeMillis(year, monthOfYear, dayOfMonth,\n            hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond);\n        iMillis = checkInstant(instant, iChronology);\n    }",
    "comment": " Constructs an instance from datetime field values using the specified chronology. <p> If the chronology is null, <code>ISOChronology</code> in the default time zone is used.  @param year  the year @param monthOfYear  the month of the year @param dayOfMonth  the day of the month @param hourOfDay  the hour of the day @param minuteOfHour  the minute of the hour @param secondOfMinute  the second of the minute @param millisOfSecond  the millisecond of the second @param chronology  the chronology, null means ISOChronology in default zone ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 3
  },
  {
    "name": "BaseDateTime.checkChronology",
    "class_name": "org.joda.time.base.BaseDateTime",
    "signature": "org.joda.time.base.BaseDateTime.checkChronology(Chronology)",
    "snippet": "    protected Chronology checkChronology(Chronology chronology) {\n        return DateTimeUtils.getChronology(chronology);\n    }",
    "comment": " Checks the specified chronology before storing it, potentially altering it. This method must not access any instance variables. <p> This implementation converts nulls to ISOChronology in the default zone.  @param chronology  the chronology to use, may be null @return the chronology to store in this datetime, not null ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 3
  },
  {
    "name": "BaseDateTime.checkInstant",
    "class_name": "org.joda.time.base.BaseDateTime",
    "signature": "org.joda.time.base.BaseDateTime.checkInstant(long,Chronology)",
    "snippet": "    protected long checkInstant(long instant, Chronology chronology) {\n        return instant;\n    }",
    "comment": " Checks the specified instant before storing it, potentially altering it. This method must not access any instance variables. <p> This implementation simply returns the instant.  @param instant  the milliseconds from 1970-01-01T00:00:00Z to round @param chronology  the chronology to use, not null @return the instant to store in this datetime ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 3
  },
  {
    "name": "BaseLocal.BaseLocal",
    "class_name": "org.joda.time.base.BaseLocal",
    "signature": "org.joda.time.base.BaseLocal.BaseLocal()",
    "snippet": "    protected BaseLocal() {\n        super();\n    }",
    "comment": " Constructs a partial with the current time, using ISOChronology in the default zone to extract the fields. <p> The constructor uses the default time zone, resulting in the local time being initialised. Once the constructor is complete, all further calculations are performed without reference to a timezone (by switching to UTC). ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 3
  },
  {
    "name": "AssembledChronology.AssembledChronology",
    "class_name": "org.joda.time.chrono.AssembledChronology",
    "signature": "org.joda.time.chrono.AssembledChronology.AssembledChronology(Chronology,Object)",
    "snippet": "    protected AssembledChronology(Chronology base, Object param) {\n        iBase = base;\n        iParam = param;\n        setFields();\n    }",
    "comment": " Constructor calls the assemble method, enabling subclasses to define its supported fields. If a base chronology is supplied, the field set initially contains references to each base chronology field. <p> Other methods in this class will delegate to the base chronology, if it can be determined that the base chronology will produce the same results as AbstractChronology.  @param base optional base chronology to copy initial fields from @param param optional param object avalable for assemble method ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 3
  },
  {
    "name": "AssembledChronology.centuries",
    "class_name": "org.joda.time.chrono.AssembledChronology",
    "signature": "org.joda.time.chrono.AssembledChronology.centuries()",
    "snippet": "    public final DurationField centuries() {\n        return iCenturies;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 3
  },
  {
    "name": "AssembledChronology.centuryOfEra",
    "class_name": "org.joda.time.chrono.AssembledChronology",
    "signature": "org.joda.time.chrono.AssembledChronology.centuryOfEra()",
    "snippet": "    public final DateTimeField centuryOfEra() {\n        return iCenturyOfEra;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 3
  },
  {
    "name": "AssembledChronology.clockhourOfDay",
    "class_name": "org.joda.time.chrono.AssembledChronology",
    "signature": "org.joda.time.chrono.AssembledChronology.clockhourOfDay()",
    "snippet": "    public final DateTimeField clockhourOfDay() {\n        return iClockhourOfDay;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 3
  },
  {
    "name": "AssembledChronology.clockhourOfHalfday",
    "class_name": "org.joda.time.chrono.AssembledChronology",
    "signature": "org.joda.time.chrono.AssembledChronology.clockhourOfHalfday()",
    "snippet": "    public final DateTimeField clockhourOfHalfday() {\n        return iClockhourOfHalfday;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 3
  },
  {
    "name": "AssembledChronology.dayOfMonth",
    "class_name": "org.joda.time.chrono.AssembledChronology",
    "signature": "org.joda.time.chrono.AssembledChronology.dayOfMonth()",
    "snippet": "    public final DateTimeField dayOfMonth() {\n        return iDayOfMonth;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 3
  },
  {
    "name": "AssembledChronology.dayOfWeek",
    "class_name": "org.joda.time.chrono.AssembledChronology",
    "signature": "org.joda.time.chrono.AssembledChronology.dayOfWeek()",
    "snippet": "    public final DateTimeField dayOfWeek() {\n        return iDayOfWeek;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 3
  },
  {
    "name": "AssembledChronology.dayOfYear",
    "class_name": "org.joda.time.chrono.AssembledChronology",
    "signature": "org.joda.time.chrono.AssembledChronology.dayOfYear()",
    "snippet": "    public final DateTimeField dayOfYear() {\n        return iDayOfYear;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 3
  },
  {
    "name": "AssembledChronology.days",
    "class_name": "org.joda.time.chrono.AssembledChronology",
    "signature": "org.joda.time.chrono.AssembledChronology.days()",
    "snippet": "    public final DurationField days() {\n        return iDays;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 3
  },
  {
    "name": "AssembledChronology.era",
    "class_name": "org.joda.time.chrono.AssembledChronology",
    "signature": "org.joda.time.chrono.AssembledChronology.era()",
    "snippet": "    public final DateTimeField era() {\n        return iEra;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 3
  },
  {
    "name": "AssembledChronology.eras",
    "class_name": "org.joda.time.chrono.AssembledChronology",
    "signature": "org.joda.time.chrono.AssembledChronology.eras()",
    "snippet": "    public final DurationField eras() {\n        return iEras;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 3
  },
  {
    "name": "AssembledChronology.getBase",
    "class_name": "org.joda.time.chrono.AssembledChronology",
    "signature": "org.joda.time.chrono.AssembledChronology.getBase()",
    "snippet": "    protected final Chronology getBase() {\n        return iBase;\n    }",
    "comment": " Returns the same base chronology as passed into the constructor. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 3
  },
  {
    "name": "AssembledChronology.getDateTimeMillis",
    "class_name": "org.joda.time.chrono.AssembledChronology",
    "signature": "org.joda.time.chrono.AssembledChronology.getDateTimeMillis(int,int,int,int,int,int,int)",
    "snippet": "    public long getDateTimeMillis(int year, int monthOfYear, int dayOfMonth,\n                                  int hourOfDay, int minuteOfHour,\n                                  int secondOfMinute, int millisOfSecond)\n        throws IllegalArgumentException\n    {\n        Chronology base;\n        if ((base = iBase) != null && (iBaseFlags & 5) == 5) {\n            // Only call specialized implementation if applicable fields are the same.\n            return base.getDateTimeMillis(year, monthOfYear, dayOfMonth,\n                                          hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond);\n        }\n        return super.getDateTimeMillis(year, monthOfYear, dayOfMonth,\n                                       hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond);\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 3
  },
  {
    "name": "AssembledChronology.getParam",
    "class_name": "org.joda.time.chrono.AssembledChronology",
    "signature": "org.joda.time.chrono.AssembledChronology.getParam()",
    "snippet": "    protected final Object getParam() {\n        return iParam;\n    }",
    "comment": " Returns the same param object as passed into the constructor. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 3
  },
  {
    "name": "AssembledChronology.halfdayOfDay",
    "class_name": "org.joda.time.chrono.AssembledChronology",
    "signature": "org.joda.time.chrono.AssembledChronology.halfdayOfDay()",
    "snippet": "    public final DateTimeField halfdayOfDay() {\n        return iHalfdayOfDay;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 3
  },
  {
    "name": "AssembledChronology.halfdays",
    "class_name": "org.joda.time.chrono.AssembledChronology",
    "signature": "org.joda.time.chrono.AssembledChronology.halfdays()",
    "snippet": "    public final DurationField halfdays() {\n        return iHalfdays;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 3
  },
  {
    "name": "AssembledChronology.hourOfDay",
    "class_name": "org.joda.time.chrono.AssembledChronology",
    "signature": "org.joda.time.chrono.AssembledChronology.hourOfDay()",
    "snippet": "    public final DateTimeField hourOfDay() {\n        return iHourOfDay;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 3
  },
  {
    "name": "AssembledChronology.hourOfHalfday",
    "class_name": "org.joda.time.chrono.AssembledChronology",
    "signature": "org.joda.time.chrono.AssembledChronology.hourOfHalfday()",
    "snippet": "    public final DateTimeField hourOfHalfday() {\n        return iHourOfHalfday;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 3
  },
  {
    "name": "AssembledChronology.hours",
    "class_name": "org.joda.time.chrono.AssembledChronology",
    "signature": "org.joda.time.chrono.AssembledChronology.hours()",
    "snippet": "    public final DurationField hours() {\n        return iHours;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 3
  },
  {
    "name": "AssembledChronology.millis",
    "class_name": "org.joda.time.chrono.AssembledChronology",
    "signature": "org.joda.time.chrono.AssembledChronology.millis()",
    "snippet": "    public final DurationField millis() {\n        return iMillis;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 3
  },
  {
    "name": "AssembledChronology.millisOfDay",
    "class_name": "org.joda.time.chrono.AssembledChronology",
    "signature": "org.joda.time.chrono.AssembledChronology.millisOfDay()",
    "snippet": "    public final DateTimeField millisOfDay() {\n        return iMillisOfDay;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 3
  },
  {
    "name": "AssembledChronology.millisOfSecond",
    "class_name": "org.joda.time.chrono.AssembledChronology",
    "signature": "org.joda.time.chrono.AssembledChronology.millisOfSecond()",
    "snippet": "    public final DateTimeField millisOfSecond() {\n        return iMillisOfSecond;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 3
  },
  {
    "name": "AssembledChronology.minuteOfDay",
    "class_name": "org.joda.time.chrono.AssembledChronology",
    "signature": "org.joda.time.chrono.AssembledChronology.minuteOfDay()",
    "snippet": "    public final DateTimeField minuteOfDay() {\n        return iMinuteOfDay;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 3
  },
  {
    "name": "AssembledChronology.minuteOfHour",
    "class_name": "org.joda.time.chrono.AssembledChronology",
    "signature": "org.joda.time.chrono.AssembledChronology.minuteOfHour()",
    "snippet": "    public final DateTimeField minuteOfHour() {\n        return iMinuteOfHour;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 3
  },
  {
    "name": "AssembledChronology.minutes",
    "class_name": "org.joda.time.chrono.AssembledChronology",
    "signature": "org.joda.time.chrono.AssembledChronology.minutes()",
    "snippet": "    public final DurationField minutes() {\n        return iMinutes;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 3
  },
  {
    "name": "AssembledChronology.monthOfYear",
    "class_name": "org.joda.time.chrono.AssembledChronology",
    "signature": "org.joda.time.chrono.AssembledChronology.monthOfYear()",
    "snippet": "    public final DateTimeField monthOfYear() {\n        return iMonthOfYear;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 3
  },
  {
    "name": "AssembledChronology.months",
    "class_name": "org.joda.time.chrono.AssembledChronology",
    "signature": "org.joda.time.chrono.AssembledChronology.months()",
    "snippet": "    public final DurationField months() {\n        return iMonths;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 3
  },
  {
    "name": "AssembledChronology.secondOfDay",
    "class_name": "org.joda.time.chrono.AssembledChronology",
    "signature": "org.joda.time.chrono.AssembledChronology.secondOfDay()",
    "snippet": "    public final DateTimeField secondOfDay() {\n        return iSecondOfDay;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 3
  },
  {
    "name": "AssembledChronology.secondOfMinute",
    "class_name": "org.joda.time.chrono.AssembledChronology",
    "signature": "org.joda.time.chrono.AssembledChronology.secondOfMinute()",
    "snippet": "    public final DateTimeField secondOfMinute() {\n        return iSecondOfMinute;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 3
  },
  {
    "name": "AssembledChronology.seconds",
    "class_name": "org.joda.time.chrono.AssembledChronology",
    "signature": "org.joda.time.chrono.AssembledChronology.seconds()",
    "snippet": "    public final DurationField seconds() {\n        return iSeconds;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 3
  },
  {
    "name": "AssembledChronology.setFields",
    "class_name": "org.joda.time.chrono.AssembledChronology",
    "signature": "org.joda.time.chrono.AssembledChronology.setFields()",
    "snippet": "    private void setFields() {\n        Fields fields = new Fields();\n        if (iBase != null) {\n            fields.copyFieldsFrom(iBase);\n        }\n        assemble(fields);\n\n        {\n            DurationField f;\n            iMillis    = (f = fields.millis)    != null ? f : super.millis();\n            iSeconds   = (f = fields.seconds)   != null ? f : super.seconds();\n            iMinutes   = (f = fields.minutes)   != null ? f : super.minutes();\n            iHours     = (f = fields.hours)     != null ? f : super.hours();\n            iHalfdays  = (f = fields.halfdays)  != null ? f : super.halfdays();\n            iDays      = (f = fields.days)      != null ? f : super.days();\n            iWeeks     = (f = fields.weeks)     != null ? f : super.weeks();\n            iWeekyears = (f = fields.weekyears) != null ? f : super.weekyears();\n            iMonths    = (f = fields.months)    != null ? f : super.months();\n            iYears     = (f = fields.years)     != null ? f : super.years();\n            iCenturies = (f = fields.centuries) != null ? f : super.centuries();\n            iEras      = (f = fields.eras)      != null ? f : super.eras();\n        }\n\n        {\n            DateTimeField f;\n            iMillisOfSecond     = (f = fields.millisOfSecond)     != null ? f : super.millisOfSecond();\n            iMillisOfDay        = (f = fields.millisOfDay)        != null ? f : super.millisOfDay();\n            iSecondOfMinute     = (f = fields.secondOfMinute)     != null ? f : super.secondOfMinute();\n            iSecondOfDay        = (f = fields.secondOfDay)        != null ? f : super.secondOfDay();\n            iMinuteOfHour       = (f = fields.minuteOfHour)       != null ? f : super.minuteOfHour();\n            iMinuteOfDay        = (f = fields.minuteOfDay)        != null ? f : super.minuteOfDay();\n            iHourOfDay          = (f = fields.hourOfDay)          != null ? f : super.hourOfDay();\n            iClockhourOfDay     = (f = fields.clockhourOfDay)     != null ? f : super.clockhourOfDay();\n            iHourOfHalfday      = (f = fields.hourOfHalfday)      != null ? f : super.hourOfHalfday();\n            iClockhourOfHalfday = (f = fields.clockhourOfHalfday) != null ? f : super.clockhourOfHalfday();\n            iHalfdayOfDay       = (f = fields.halfdayOfDay)       != null ? f : super.halfdayOfDay();\n            iDayOfWeek          = (f = fields.dayOfWeek)          != null ? f : super.dayOfWeek();\n            iDayOfMonth         = (f = fields.dayOfMonth)         != null ? f : super.dayOfMonth();\n            iDayOfYear          = (f = fields.dayOfYear)          != null ? f : super.dayOfYear();\n            iWeekOfWeekyear     = (f = fields.weekOfWeekyear)     != null ? f : super.weekOfWeekyear();\n            iWeekyear           = (f = fields.weekyear)           != null ? f : super.weekyear();\n            iWeekyearOfCentury  = (f = fields.weekyearOfCentury)  != null ? f : super.weekyearOfCentury();\n            iMonthOfYear        = (f = fields.monthOfYear)        != null ? f : super.monthOfYear();\n            iYear               = (f = fields.year)               != null ? f : super.year();\n            iYearOfEra          = (f = fields.yearOfEra)          != null ? f : super.yearOfEra();\n            iYearOfCentury      = (f = fields.yearOfCentury)      != null ? f : super.yearOfCentury();\n            iCenturyOfEra       = (f = fields.centuryOfEra)       != null ? f : super.centuryOfEra();\n            iEra                = (f = fields.era)                != null ? f : super.era();\n        }\n\n        int flags;\n        if (iBase == null) {\n            flags = 0;\n        } else {\n            flags = \n                ((iHourOfDay      == iBase.hourOfDay()      &&\n                  iMinuteOfHour   == iBase.minuteOfHour()   &&\n                  iSecondOfMinute == iBase.secondOfMinute() &&\n                  iMillisOfSecond == iBase.millisOfSecond()   ) ? 1 : 0) |\n\n                ((iMillisOfDay == iBase.millisOfDay()) ? 2 : 0) |\n\n                ((iYear        == iBase.year()        &&\n                  iMonthOfYear == iBase.monthOfYear() &&\n                  iDayOfMonth  == iBase.dayOfMonth()    ) ? 4 : 0);\n        }\n\n        iBaseFlags = flags;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 3
  },
  {
    "name": "AssembledChronology.weekOfWeekyear",
    "class_name": "org.joda.time.chrono.AssembledChronology",
    "signature": "org.joda.time.chrono.AssembledChronology.weekOfWeekyear()",
    "snippet": "    public final DateTimeField weekOfWeekyear() {\n        return iWeekOfWeekyear;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 3
  },
  {
    "name": "AssembledChronology.weeks",
    "class_name": "org.joda.time.chrono.AssembledChronology",
    "signature": "org.joda.time.chrono.AssembledChronology.weeks()",
    "snippet": "    public final DurationField weeks() {\n        return iWeeks;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 3
  },
  {
    "name": "AssembledChronology.weekyear",
    "class_name": "org.joda.time.chrono.AssembledChronology",
    "signature": "org.joda.time.chrono.AssembledChronology.weekyear()",
    "snippet": "    public final DateTimeField weekyear() {\n        return iWeekyear;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 3
  },
  {
    "name": "AssembledChronology.weekyearOfCentury",
    "class_name": "org.joda.time.chrono.AssembledChronology",
    "signature": "org.joda.time.chrono.AssembledChronology.weekyearOfCentury()",
    "snippet": "    public final DateTimeField weekyearOfCentury() {\n        return iWeekyearOfCentury;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 3
  },
  {
    "name": "AssembledChronology.weekyears",
    "class_name": "org.joda.time.chrono.AssembledChronology",
    "signature": "org.joda.time.chrono.AssembledChronology.weekyears()",
    "snippet": "    public final DurationField weekyears() {\n        return iWeekyears;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 3
  },
  {
    "name": "AssembledChronology.year",
    "class_name": "org.joda.time.chrono.AssembledChronology",
    "signature": "org.joda.time.chrono.AssembledChronology.year()",
    "snippet": "    public final DateTimeField year() {\n        return iYear;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 3
  },
  {
    "name": "AssembledChronology.yearOfCentury",
    "class_name": "org.joda.time.chrono.AssembledChronology",
    "signature": "org.joda.time.chrono.AssembledChronology.yearOfCentury()",
    "snippet": "    public final DateTimeField yearOfCentury() {\n        return iYearOfCentury;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 3
  },
  {
    "name": "AssembledChronology.yearOfEra",
    "class_name": "org.joda.time.chrono.AssembledChronology",
    "signature": "org.joda.time.chrono.AssembledChronology.yearOfEra()",
    "snippet": "    public final DateTimeField yearOfEra() {\n        return iYearOfEra;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 3
  },
  {
    "name": "AssembledChronology.years",
    "class_name": "org.joda.time.chrono.AssembledChronology",
    "signature": "org.joda.time.chrono.AssembledChronology.years()",
    "snippet": "    public final DurationField years() {\n        return iYears;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 3
  },
  {
    "name": "Fields.copyFieldsFrom",
    "class_name": "org.joda.time.chrono.AssembledChronology$Fields",
    "signature": "org.joda.time.chrono.AssembledChronology$Fields.copyFieldsFrom(Chronology)",
    "snippet": "        public void copyFieldsFrom(Chronology chrono) {\n            {\n                DurationField f;\n                if (isSupported(f = chrono.millis())) {\n                    millis = f;\n                }\n                if (isSupported(f = chrono.seconds())) {\n                    seconds = f;\n                }\n                if (isSupported(f = chrono.minutes())) {\n                    minutes = f;\n                }\n                if (isSupported(f = chrono.hours())) {\n                    hours = f;\n                }\n                if (isSupported(f = chrono.halfdays())) {\n                    halfdays = f;\n                }\n                if (isSupported(f = chrono.days())) {\n                    days = f;\n                }\n                if (isSupported(f = chrono.weeks())) {\n                    weeks = f;\n                }\n                if (isSupported(f = chrono.weekyears())) {\n                    weekyears = f;\n                }\n                if (isSupported(f = chrono.months())) {\n                    months = f;\n                }\n                if (isSupported(f = chrono.years())) {\n                    years = f;\n                }\n                if (isSupported(f = chrono.centuries())) {\n                    centuries = f;\n                }\n                if (isSupported(f = chrono.eras())) {\n                    eras = f;\n                }\n            }\n\n            {\n                DateTimeField f;\n                if (isSupported(f = chrono.millisOfSecond())) {\n                    millisOfSecond = f;\n                }\n                if (isSupported(f = chrono.millisOfDay())) {\n                    millisOfDay = f;\n                }\n                if (isSupported(f = chrono.secondOfMinute())) {\n                    secondOfMinute = f;\n                }\n                if (isSupported(f = chrono.secondOfDay())) {\n                    secondOfDay = f;\n                }\n                if (isSupported(f = chrono.minuteOfHour())) {\n                    minuteOfHour = f;\n                }\n                if (isSupported(f = chrono.minuteOfDay())) {\n                    minuteOfDay = f;\n                }\n                if (isSupported(f = chrono.hourOfDay())) {\n                    hourOfDay = f;\n                }\n                if (isSupported(f = chrono.clockhourOfDay())) {\n                    clockhourOfDay = f;\n                }\n                if (isSupported(f = chrono.hourOfHalfday())) {\n                    hourOfHalfday = f;\n                }\n                if (isSupported(f = chrono.clockhourOfHalfday())) {\n                    clockhourOfHalfday = f;\n                }\n                if (isSupported(f = chrono.halfdayOfDay())) {\n                    halfdayOfDay = f;\n                }\n                if (isSupported(f = chrono.dayOfWeek())) {\n                    dayOfWeek = f;\n                }\n                if (isSupported(f = chrono.dayOfMonth())) {\n                    dayOfMonth = f;\n                }\n                if (isSupported(f = chrono.dayOfYear())) {\n                    dayOfYear = f;\n                }\n                if (isSupported(f = chrono.weekOfWeekyear())) {\n                    weekOfWeekyear = f;\n                }\n                if (isSupported(f = chrono.weekyear())) {\n                    weekyear = f;\n                }\n                if (isSupported(f = chrono.weekyearOfCentury())) {\n                    weekyearOfCentury = f;\n                }\n                if (isSupported(f = chrono.monthOfYear())) {\n                    monthOfYear = f;\n                }\n                if (isSupported(f = chrono.year())) {\n                    year = f;\n                }\n                if (isSupported(f = chrono.yearOfEra())) {\n                    yearOfEra = f;\n                }\n                if (isSupported(f = chrono.yearOfCentury())) {\n                    yearOfCentury = f;\n                }\n                if (isSupported(f = chrono.centuryOfEra())) {\n                    centuryOfEra = f;\n                }\n                if (isSupported(f = chrono.era())) {\n                    era = f;\n                }\n            }\n        }",
    "comment": " Copy the supported fields from a chronology into this container. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 3
  },
  {
    "name": "Fields.isSupported",
    "class_name": "org.joda.time.chrono.AssembledChronology$Fields",
    "signature": "org.joda.time.chrono.AssembledChronology$Fields.isSupported(DateTimeField)",
    "snippet": "        private static boolean isSupported(DateTimeField field) {\n            return field == null ? false : field.isSupported();\n        }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 3
  },
  {
    "name": "Fields.isSupported",
    "class_name": "org.joda.time.chrono.AssembledChronology$Fields",
    "signature": "org.joda.time.chrono.AssembledChronology$Fields.isSupported(DurationField)",
    "snippet": "        private static boolean isSupported(DurationField field) {\n            return field == null ? false : field.isSupported();\n        }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 3
  },
  {
    "name": "BaseChronology.BaseChronology",
    "class_name": "org.joda.time.chrono.BaseChronology",
    "signature": "org.joda.time.chrono.BaseChronology.BaseChronology()",
    "snippet": "    protected BaseChronology() {\n        super();\n    }",
    "comment": " Restricted constructor. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 3
  },
  {
    "name": "BaseChronology.eras",
    "class_name": "org.joda.time.chrono.BaseChronology",
    "signature": "org.joda.time.chrono.BaseChronology.eras()",
    "snippet": "    public DurationField eras() {\n        return UnsupportedDurationField.getInstance(DurationFieldType.eras());\n    }",
    "comment": " Get the eras duration field for this chronology.  @return DurationField or UnsupportedDurationField if unsupported ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 3
  },
  {
    "name": "BaseChronology.getDateTimeMillis",
    "class_name": "org.joda.time.chrono.BaseChronology",
    "signature": "org.joda.time.chrono.BaseChronology.getDateTimeMillis(int,int,int,int,int,int,int)",
    "snippet": "    public long getDateTimeMillis(int year, int monthOfYear, int dayOfMonth,\n                                  int hourOfDay, int minuteOfHour,\n                                  int secondOfMinute, int millisOfSecond)\n        throws IllegalArgumentException\n    {\n        long instant = year().set(0, year);\n        instant = monthOfYear().set(instant, monthOfYear);\n        instant = dayOfMonth().set(instant, dayOfMonth);\n        instant = hourOfDay().set(instant, hourOfDay);\n        instant = minuteOfHour().set(instant, minuteOfHour);\n        instant = secondOfMinute().set(instant, secondOfMinute);\n        return millisOfSecond().set(instant, millisOfSecond);\n    }",
    "comment": " Returns a datetime millisecond instant, formed from the given year, month, day, hour, minute, second, and millisecond values. The set of given values must refer to a valid datetime, or else an IllegalArgumentException is thrown. <p> The default implementation calls upon separate DateTimeFields to determine the result. Subclasses are encouraged to provide a more efficient implementation.  @param year year to use @param monthOfYear month to use @param dayOfMonth day of month to use @param hourOfDay hour to use @param minuteOfHour minute to use @param secondOfMinute second to use @param millisOfSecond millisecond to use @return millisecond instant from 1970-01-01T00:00:00Z ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 3
  },
  {
    "name": "BaseChronology.validate",
    "class_name": "org.joda.time.chrono.BaseChronology",
    "signature": "org.joda.time.chrono.BaseChronology.validate(ReadablePartial,int[])",
    "snippet": "    public void validate(ReadablePartial partial, int[] values) {\n        // check values in standard range, catching really stupid cases like -1\n        // this means that the second check will not hit trouble\n        int size = partial.size();\n        for (int i = 0; i < size; i++) {\n            int value = values[i];\n            DateTimeField field = partial.getField(i);\n            if (value < field.getMinimumValue()) {\n                throw new IllegalFieldValueException\n                    (field.getType(), Integer.valueOf(value),\n                     Integer.valueOf(field.getMinimumValue()), null);\n            }\n            if (value > field.getMaximumValue()) {\n                throw new IllegalFieldValueException\n                    (field.getType(), Integer.valueOf(value),\n                     null, Integer.valueOf(field.getMaximumValue()));\n            }\n        }\n        // check values in specific range, catching really odd cases like 30th Feb\n        for (int i = 0; i < size; i++) {\n            int value = values[i];\n            DateTimeField field = partial.getField(i);\n            if (value < field.getMinimumValue(partial, values)) {\n                throw new IllegalFieldValueException\n                    (field.getType(), Integer.valueOf(value),\n                     Integer.valueOf(field.getMinimumValue(partial, values)), null);\n            }\n            if (value > field.getMaximumValue(partial, values)) {\n                throw new IllegalFieldValueException\n                    (field.getType(), Integer.valueOf(value),\n                     null, Integer.valueOf(field.getMaximumValue(partial, values)));\n            }\n        }\n    }",
    "comment": " Validates whether the fields stored in a partial instant are valid. <p> This implementation uses {@link DateTimeField#getMinimumValue(ReadablePartial, int[])} and {@link DateTimeField#getMaximumValue(ReadablePartial, int[])}.  @param partial  the partial instant to validate @param values  the values to validate, not null unless the partial is empty @throws IllegalArgumentException if the instant is invalid ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 3
  },
  {
    "name": "BasicChronology.BasicChronology",
    "class_name": "org.joda.time.chrono.BasicChronology",
    "signature": "org.joda.time.chrono.BasicChronology.BasicChronology(Chronology,Object,int)",
    "snippet": "    BasicChronology(Chronology base, Object param, int minDaysInFirstWeek) {\n        super(base, param);\n\n        if (minDaysInFirstWeek < 1 || minDaysInFirstWeek > 7) {\n            throw new IllegalArgumentException\n                (\"Invalid min days in first week: \" + minDaysInFirstWeek);\n        }\n\n        iMinDaysInFirstWeek = minDaysInFirstWeek;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 3
  },
  {
    "name": "BasicChronology.assemble",
    "class_name": "org.joda.time.chrono.BasicChronology",
    "signature": "org.joda.time.chrono.BasicChronology.assemble(Fields)",
    "snippet": "    protected void assemble(Fields fields) {\n        // First copy fields that are the same for all Gregorian and Julian\n        // chronologies.\n\n        fields.millis = cMillisField;\n        fields.seconds = cSecondsField;\n        fields.minutes = cMinutesField;\n        fields.hours = cHoursField;\n        fields.halfdays = cHalfdaysField;\n        fields.days = cDaysField;\n        fields.weeks = cWeeksField;\n\n        fields.millisOfSecond = cMillisOfSecondField;\n        fields.millisOfDay = cMillisOfDayField;\n        fields.secondOfMinute = cSecondOfMinuteField;\n        fields.secondOfDay = cSecondOfDayField;\n        fields.minuteOfHour = cMinuteOfHourField;\n        fields.minuteOfDay = cMinuteOfDayField;\n        fields.hourOfDay = cHourOfDayField;\n        fields.hourOfHalfday = cHourOfHalfdayField;\n        fields.clockhourOfDay = cClockhourOfDayField;\n        fields.clockhourOfHalfday = cClockhourOfHalfdayField;\n        fields.halfdayOfDay = cHalfdayOfDayField;\n\n        // Now create fields that have unique behavior for Gregorian and Julian\n        // chronologies.\n\n        fields.year = new BasicYearDateTimeField(this);\n        fields.yearOfEra = new GJYearOfEraDateTimeField(fields.year, this);\n\n        // Define one-based centuryOfEra and yearOfCentury.\n        DateTimeField field = new OffsetDateTimeField(\n            fields.yearOfEra, 99);\n        fields.centuryOfEra = new DividedDateTimeField(\n            field, DateTimeFieldType.centuryOfEra(), 100);\n        fields.centuries = fields.centuryOfEra.getDurationField();\n        \n        field = new RemainderDateTimeField(\n            (DividedDateTimeField) fields.centuryOfEra);\n        fields.yearOfCentury = new OffsetDateTimeField(\n            field, DateTimeFieldType.yearOfCentury(), 1);\n\n        fields.era = new GJEraDateTimeField(this);\n        fields.dayOfWeek = new GJDayOfWeekDateTimeField(this, fields.days);\n        fields.dayOfMonth = new BasicDayOfMonthDateTimeField(this, fields.days);\n        fields.dayOfYear = new BasicDayOfYearDateTimeField(this, fields.days);\n        fields.monthOfYear = new GJMonthOfYearDateTimeField(this);\n        fields.weekyear = new BasicWeekyearDateTimeField(this);\n        fields.weekOfWeekyear = new BasicWeekOfWeekyearDateTimeField(this, fields.weeks);\n        \n        field = new RemainderDateTimeField(\n            fields.weekyear, fields.centuries, DateTimeFieldType.weekyearOfCentury(), 100);\n        fields.weekyearOfCentury = new OffsetDateTimeField(\n            field, DateTimeFieldType.weekyearOfCentury(), 1);\n        \n        // The remaining (imprecise) durations are available from the newly\n        // created datetime fields.\n        fields.years = fields.year.getDurationField();\n        fields.months = fields.monthOfYear.getDurationField();\n        fields.weekyears = fields.weekyear.getDurationField();\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 3
  },
  {
    "name": "BasicChronology.getDateMidnightMillis",
    "class_name": "org.joda.time.chrono.BasicChronology",
    "signature": "org.joda.time.chrono.BasicChronology.getDateMidnightMillis(int,int,int)",
    "snippet": "    long getDateMidnightMillis(int year, int monthOfYear, int dayOfMonth) {\n        FieldUtils.verifyValueBounds(DateTimeFieldType.year(), year, getMinYear(), getMaxYear());\n        FieldUtils.verifyValueBounds(DateTimeFieldType.monthOfYear(), monthOfYear, 1, getMaxMonth(year));\n        FieldUtils.verifyValueBounds(DateTimeFieldType.dayOfMonth(), dayOfMonth, 1, getDaysInYearMonth(year, monthOfYear));\n        return getYearMonthDayMillis(year, monthOfYear, dayOfMonth);\n    }",
    "comment": " Gets the milliseconds for a date at midnight.  @param year  the year @param monthOfYear  the month @param dayOfMonth  the day @return the milliseconds ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 3
  },
  {
    "name": "BasicChronology.getDateTimeMillis",
    "class_name": "org.joda.time.chrono.BasicChronology",
    "signature": "org.joda.time.chrono.BasicChronology.getDateTimeMillis(int,int,int,int)",
    "snippet": "    public long getDateTimeMillis(\n            int year, int monthOfYear, int dayOfMonth, int millisOfDay)\n            throws IllegalArgumentException {\n        Chronology base;\n        if ((base = getBase()) != null) {\n            return base.getDateTimeMillis(year, monthOfYear, dayOfMonth, millisOfDay);\n        }\n\n        FieldUtils.verifyValueBounds\n            (DateTimeFieldType.millisOfDay(), millisOfDay, 0, DateTimeConstants.MILLIS_PER_DAY - 1);\n        return getDateMidnightMillis(year, monthOfYear, dayOfMonth) + millisOfDay;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 3
  },
  {
    "name": "BasicChronology.getDateTimeMillis",
    "class_name": "org.joda.time.chrono.BasicChronology",
    "signature": "org.joda.time.chrono.BasicChronology.getDateTimeMillis(int,int,int,int,int,int,int)",
    "snippet": "    public long getDateTimeMillis(\n            int year, int monthOfYear, int dayOfMonth,\n            int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond)\n            throws IllegalArgumentException {\n        Chronology base;\n        if ((base = getBase()) != null) {\n            return base.getDateTimeMillis(year, monthOfYear, dayOfMonth,\n                                          hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond);\n        }\n\n        FieldUtils.verifyValueBounds(DateTimeFieldType.hourOfDay(), hourOfDay, 0, 23);\n        FieldUtils.verifyValueBounds(DateTimeFieldType.minuteOfHour(), minuteOfHour, 0, 59);\n        FieldUtils.verifyValueBounds(DateTimeFieldType.secondOfMinute(), secondOfMinute, 0, 59);\n        FieldUtils.verifyValueBounds(DateTimeFieldType.millisOfSecond(), millisOfSecond, 0, 999);\n\n        return getDateMidnightMillis(year, monthOfYear, dayOfMonth)\n            + hourOfDay * DateTimeConstants.MILLIS_PER_HOUR\n            + minuteOfHour * DateTimeConstants.MILLIS_PER_MINUTE\n            + secondOfMinute * DateTimeConstants.MILLIS_PER_SECOND\n            + millisOfSecond;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 3
  },
  {
    "name": "BasicChronology.getDayOfMonth",
    "class_name": "org.joda.time.chrono.BasicChronology",
    "signature": "org.joda.time.chrono.BasicChronology.getDayOfMonth(long)",
    "snippet": "    int getDayOfMonth(long millis) {\n        int year = getYear(millis);\n        int month = getMonthOfYear(millis, year);\n        return getDayOfMonth(millis, year, month);\n    }",
    "comment": " @param millis from 1970-01-01T00:00:00Z ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 3
  },
  {
    "name": "BasicChronology.getDayOfMonth",
    "class_name": "org.joda.time.chrono.BasicChronology",
    "signature": "org.joda.time.chrono.BasicChronology.getDayOfMonth(long,int)",
    "snippet": "    int getDayOfMonth(long millis, int year) {\n        int month = getMonthOfYear(millis, year);\n        return getDayOfMonth(millis, year, month);\n    }",
    "comment": " @param millis from 1970-01-01T00:00:00Z @param year precalculated year of millis ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 3
  },
  {
    "name": "BasicChronology.getDayOfMonth",
    "class_name": "org.joda.time.chrono.BasicChronology",
    "signature": "org.joda.time.chrono.BasicChronology.getDayOfMonth(long,int,int)",
    "snippet": "    int getDayOfMonth(long millis, int year, int month) {\n        long dateMillis = getYearMillis(year);\n        dateMillis += getTotalMillisByYearMonth(year, month);\n        return (int) ((millis - dateMillis) / DateTimeConstants.MILLIS_PER_DAY) + 1;\n    }",
    "comment": " @param millis from 1970-01-01T00:00:00Z @param year precalculated year of millis @param month precalculated month of millis ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 3
  },
  {
    "name": "BasicChronology.getDayOfWeek",
    "class_name": "org.joda.time.chrono.BasicChronology",
    "signature": "org.joda.time.chrono.BasicChronology.getDayOfWeek(long)",
    "snippet": "    int getDayOfWeek(long instant) {\n        // 1970-01-01 is day of week 4, Thursday.\n\n        long daysSince19700101;\n        if (instant >= 0) {\n            daysSince19700101 = instant / DateTimeConstants.MILLIS_PER_DAY;\n        } else {\n            daysSince19700101 = (instant - (DateTimeConstants.MILLIS_PER_DAY - 1))\n                / DateTimeConstants.MILLIS_PER_DAY;\n            if (daysSince19700101 < -3) {\n                return 7 + (int) ((daysSince19700101 + 4) % 7);\n            }\n        }\n\n        return 1 + (int) ((daysSince19700101 + 3) % 7);\n    }",
    "comment": " @param instant millis from 1970-01-01T00:00:00Z ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 3
  },
  {
    "name": "BasicChronology.getDayOfYear",
    "class_name": "org.joda.time.chrono.BasicChronology",
    "signature": "org.joda.time.chrono.BasicChronology.getDayOfYear(long,int)",
    "snippet": "    int getDayOfYear(long instant, int year) {\n        long yearStart = getYearMillis(year);\n        return (int) ((instant - yearStart) / DateTimeConstants.MILLIS_PER_DAY) + 1;\n    }",
    "comment": " @param instant millis from 1970-01-01T00:00:00Z @param year precalculated year of millis ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 3
  },
  {
    "name": "BasicChronology.getFirstWeekOfYearMillis",
    "class_name": "org.joda.time.chrono.BasicChronology",
    "signature": "org.joda.time.chrono.BasicChronology.getFirstWeekOfYearMillis(int)",
    "snippet": "    long getFirstWeekOfYearMillis(int year) {\n        long jan1millis = getYearMillis(year);\n        int jan1dayOfWeek = getDayOfWeek(jan1millis);\n        \n        if (jan1dayOfWeek > (8 - iMinDaysInFirstWeek)) {\n            // First week is end of previous year because it doesn't have enough days.\n            return jan1millis + (8 - jan1dayOfWeek)\n                * (long)DateTimeConstants.MILLIS_PER_DAY;\n        } else {\n            // First week is start of this year because it has enough days.\n            return jan1millis - (jan1dayOfWeek - 1)\n                * (long)DateTimeConstants.MILLIS_PER_DAY;\n        }\n    }",
    "comment": " Get the millis for the first week of a year.  @param year  the year to use @return millis ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 3
  },
  {
    "name": "BasicChronology.getMaxMonth",
    "class_name": "org.joda.time.chrono.BasicChronology",
    "signature": "org.joda.time.chrono.BasicChronology.getMaxMonth()",
    "snippet": "    int getMaxMonth() {\n        return 12;\n    }",
    "comment": " Gets the maximum number of months.  @return 12 ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 3
  },
  {
    "name": "BasicChronology.getMaxMonth",
    "class_name": "org.joda.time.chrono.BasicChronology",
    "signature": "org.joda.time.chrono.BasicChronology.getMaxMonth(int)",
    "snippet": "    int getMaxMonth(int year) {\n        return getMaxMonth();\n    }",
    "comment": " Gets the maximum month for the specified year. This implementation calls getMaxMonth().  @param year  the year @return the maximum month value ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 3
  },
  {
    "name": "BasicChronology.getMillisOfDay",
    "class_name": "org.joda.time.chrono.BasicChronology",
    "signature": "org.joda.time.chrono.BasicChronology.getMillisOfDay(long)",
    "snippet": "    int getMillisOfDay(long instant) {\n        if (instant >= 0) {\n            return (int) (instant % DateTimeConstants.MILLIS_PER_DAY);\n        } else {\n            return (DateTimeConstants.MILLIS_PER_DAY - 1)\n                + (int) ((instant + 1) % DateTimeConstants.MILLIS_PER_DAY);\n        }\n    }",
    "comment": " @param instant millis from 1970-01-01T00:00:00Z ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 3
  },
  {
    "name": "BasicChronology.getMinimumDaysInFirstWeek",
    "class_name": "org.joda.time.chrono.BasicChronology",
    "signature": "org.joda.time.chrono.BasicChronology.getMinimumDaysInFirstWeek()",
    "snippet": "    public int getMinimumDaysInFirstWeek() {\n        return iMinDaysInFirstWeek;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 3
  },
  {
    "name": "BasicChronology.getMonthOfYear",
    "class_name": "org.joda.time.chrono.BasicChronology",
    "signature": "org.joda.time.chrono.BasicChronology.getMonthOfYear(long)",
    "snippet": "    int getMonthOfYear(long millis) {\n        return getMonthOfYear(millis, getYear(millis));\n    }",
    "comment": " @param millis from 1970-01-01T00:00:00Z ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 3
  },
  {
    "name": "BasicChronology.getWeekOfWeekyear",
    "class_name": "org.joda.time.chrono.BasicChronology",
    "signature": "org.joda.time.chrono.BasicChronology.getWeekOfWeekyear(long)",
    "snippet": "    int getWeekOfWeekyear(long instant) {\n        return getWeekOfWeekyear(instant, getYear(instant));\n    }",
    "comment": " @param instant millis from 1970-01-01T00:00:00Z ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 3
  },
  {
    "name": "BasicChronology.getWeekOfWeekyear",
    "class_name": "org.joda.time.chrono.BasicChronology",
    "signature": "org.joda.time.chrono.BasicChronology.getWeekOfWeekyear(long,int)",
    "snippet": "    int getWeekOfWeekyear(long instant, int year) {\n        long firstWeekMillis1 = getFirstWeekOfYearMillis(year);\n        if (instant < firstWeekMillis1) {\n            return getWeeksInYear(year - 1);\n        }\n        long firstWeekMillis2 = getFirstWeekOfYearMillis(year + 1);\n        if (instant >= firstWeekMillis2) {\n            return 1;\n        }\n        return (int) ((instant - firstWeekMillis1) / DateTimeConstants.MILLIS_PER_WEEK) + 1;\n    }",
    "comment": " @param instant millis from 1970-01-01T00:00:00Z @param year precalculated year of millis ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 3
  },
  {
    "name": "BasicChronology.getWeeksInYear",
    "class_name": "org.joda.time.chrono.BasicChronology",
    "signature": "org.joda.time.chrono.BasicChronology.getWeeksInYear(int)",
    "snippet": "    int getWeeksInYear(int year) {\n        long firstWeekMillis1 = getFirstWeekOfYearMillis(year);\n        long firstWeekMillis2 = getFirstWeekOfYearMillis(year + 1);\n        return (int) ((firstWeekMillis2 - firstWeekMillis1) / DateTimeConstants.MILLIS_PER_WEEK);\n    }",
    "comment": " Get the number of weeks in the year.  @param year  the year to use @return number of weeks in the year ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 3
  },
  {
    "name": "BasicChronology.getWeekyear",
    "class_name": "org.joda.time.chrono.BasicChronology",
    "signature": "org.joda.time.chrono.BasicChronology.getWeekyear(long)",
    "snippet": "    int getWeekyear(long instant) {\n        int year = getYear(instant);\n        int week = getWeekOfWeekyear(instant, year);\n        if (week == 1) {\n            return getYear(instant + DateTimeConstants.MILLIS_PER_WEEK);\n        } else if (week > 51) {\n            return getYear(instant - (2 * DateTimeConstants.MILLIS_PER_WEEK));\n        } else {\n            return year;\n        }\n    }",
    "comment": " @param instant millis from 1970-01-01T00:00:00Z ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 3
  },
  {
    "name": "BasicChronology.getYear",
    "class_name": "org.joda.time.chrono.BasicChronology",
    "signature": "org.joda.time.chrono.BasicChronology.getYear(long)",
    "snippet": "    int getYear(long instant) {\n        // Get an initial estimate of the year, and the millis value that\n        // represents the start of that year. Then verify estimate and fix if\n        // necessary.\n\n        // Initial estimate uses values divided by two to avoid overflow.\n        long unitMillis = getAverageMillisPerYearDividedByTwo();\n        long i2 = (instant >> 1) + getApproxMillisAtEpochDividedByTwo();\n        if (i2 < 0) {\n            i2 = i2 - unitMillis + 1;\n        }\n        int year = (int) (i2 / unitMillis);\n\n        long yearStart = getYearMillis(year);\n        long diff = instant - yearStart;\n\n        if (diff < 0) {\n            year--;\n        } else if (diff >= DateTimeConstants.MILLIS_PER_DAY * 365L) {\n            // One year may need to be added to fix estimate.\n            long oneYear;\n            if (isLeapYear(year)) {\n                oneYear = DateTimeConstants.MILLIS_PER_DAY * 366L;\n            } else {\n                oneYear = DateTimeConstants.MILLIS_PER_DAY * 365L;\n            }\n\n            yearStart += oneYear;\n\n            if (yearStart <= instant) {\n                // Didn't go too far, so actually add one year.\n                year++;\n            }\n        }\n\n        return year;\n    }",
    "comment": " @param instant millis from 1970-01-01T00:00:00Z ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 3
  },
  {
    "name": "BasicChronology.getYearInfo",
    "class_name": "org.joda.time.chrono.BasicChronology",
    "signature": "org.joda.time.chrono.BasicChronology.getYearInfo(int)",
    "snippet": "    private YearInfo getYearInfo(int year) {\n        YearInfo info = iYearInfoCache[year & CACHE_MASK];\n        if (info == null || info.iYear != year) {\n            info = new YearInfo(year, calculateFirstDayOfYearMillis(year));\n            iYearInfoCache[year & CACHE_MASK] = info;\n        }\n        return info;\n    }",
    "comment": "Although accessed by multiple threads, this method doesn't need to be synchronized.",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 3
  },
  {
    "name": "BasicChronology.getYearMillis",
    "class_name": "org.joda.time.chrono.BasicChronology",
    "signature": "org.joda.time.chrono.BasicChronology.getYearMillis(int)",
    "snippet": "    long getYearMillis(int year) {\n        return getYearInfo(year).iFirstDayMillis;\n    }",
    "comment": " Get the milliseconds for the start of a year.  @param year The year to use. @return millis from 1970-01-01T00:00:00Z ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 3
  },
  {
    "name": "BasicChronology.getYearMonthDayMillis",
    "class_name": "org.joda.time.chrono.BasicChronology",
    "signature": "org.joda.time.chrono.BasicChronology.getYearMonthDayMillis(int,int,int)",
    "snippet": "    long getYearMonthDayMillis(int year, int month, int dayOfMonth) {\n        long millis = getYearMillis(year);\n        millis += getTotalMillisByYearMonth(year, month);\n        return millis + (dayOfMonth - 1) * (long)DateTimeConstants.MILLIS_PER_DAY;\n    }",
    "comment": " Get the milliseconds for a particular date.  @param year The year to use. @param month The month to use @param dayOfMonth The day of the month to use @return millis from 1970-01-01T00:00:00Z ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 3
  },
  {
    "name": "BasicChronology.getZone",
    "class_name": "org.joda.time.chrono.BasicChronology",
    "signature": "org.joda.time.chrono.BasicChronology.getZone()",
    "snippet": "    public DateTimeZone getZone() {\n        Chronology base;\n        if ((base = getBase()) != null) {\n            return base.getZone();\n        }\n        return DateTimeZone.UTC;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 3
  },
  {
    "name": "BasicDayOfMonthDateTimeField.BasicDayOfMonthDateTimeField",
    "class_name": "org.joda.time.chrono.BasicDayOfMonthDateTimeField",
    "signature": "org.joda.time.chrono.BasicDayOfMonthDateTimeField.BasicDayOfMonthDateTimeField(BasicChronology,DurationField)",
    "snippet": "    BasicDayOfMonthDateTimeField(BasicChronology chronology, DurationField days) {\n        super(DateTimeFieldType.dayOfMonth(), days);\n        iChronology = chronology;\n    }",
    "comment": " Restricted constructor. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 3
  },
  {
    "name": "BasicDayOfMonthDateTimeField.get",
    "class_name": "org.joda.time.chrono.BasicDayOfMonthDateTimeField",
    "signature": "org.joda.time.chrono.BasicDayOfMonthDateTimeField.get(long)",
    "snippet": "    public int get(long instant) {\n        return iChronology.getDayOfMonth(instant);\n    }",
    "comment": "-----------------------------------------------------------------------",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 3
  },
  {
    "name": "BasicDayOfMonthDateTimeField.getMaximumValueForSet",
    "class_name": "org.joda.time.chrono.BasicDayOfMonthDateTimeField",
    "signature": "org.joda.time.chrono.BasicDayOfMonthDateTimeField.getMaximumValueForSet(long,int)",
    "snippet": "    protected int getMaximumValueForSet(long instant, int value) {\n        return iChronology.getDaysInMonthMaxForSet(instant, value);\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 3
  },
  {
    "name": "BasicDayOfMonthDateTimeField.getMinimumValue",
    "class_name": "org.joda.time.chrono.BasicDayOfMonthDateTimeField",
    "signature": "org.joda.time.chrono.BasicDayOfMonthDateTimeField.getMinimumValue()",
    "snippet": "    public int getMinimumValue() {\n        return 1;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 3
  },
  {
    "name": "BasicDayOfMonthDateTimeField.getRangeDurationField",
    "class_name": "org.joda.time.chrono.BasicDayOfMonthDateTimeField",
    "signature": "org.joda.time.chrono.BasicDayOfMonthDateTimeField.getRangeDurationField()",
    "snippet": "    public DurationField getRangeDurationField() {\n        return iChronology.months();\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 3
  },
  {
    "name": "BasicDayOfYearDateTimeField.BasicDayOfYearDateTimeField",
    "class_name": "org.joda.time.chrono.BasicDayOfYearDateTimeField",
    "signature": "org.joda.time.chrono.BasicDayOfYearDateTimeField.BasicDayOfYearDateTimeField(BasicChronology,DurationField)",
    "snippet": "    BasicDayOfYearDateTimeField(BasicChronology chronology, DurationField days) {\n        super(DateTimeFieldType.dayOfYear(), days);\n        iChronology = chronology;\n    }",
    "comment": " Restricted constructor ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 3
  },
  {
    "name": "BasicDayOfYearDateTimeField.getRangeDurationField",
    "class_name": "org.joda.time.chrono.BasicDayOfYearDateTimeField",
    "signature": "org.joda.time.chrono.BasicDayOfYearDateTimeField.getRangeDurationField()",
    "snippet": "    public DurationField getRangeDurationField() {\n        return iChronology.years();\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 3
  },
  {
    "name": "BasicFixedMonthChronology.BasicFixedMonthChronology",
    "class_name": "org.joda.time.chrono.BasicFixedMonthChronology",
    "signature": "org.joda.time.chrono.BasicFixedMonthChronology.BasicFixedMonthChronology(Chronology,Object,int)",
    "snippet": "    BasicFixedMonthChronology(Chronology base, Object param, int minDaysInFirstWeek) {\n        super(base, param, minDaysInFirstWeek);\n    }",
    "comment": " Restricted constructor.  @param base  the base chronology @param param  the init parameter @param minDaysInFirstWeek  the minimum days in the first week ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 3
  },
  {
    "name": "BasicFixedMonthChronology.getAverageMillisPerMonth",
    "class_name": "org.joda.time.chrono.BasicFixedMonthChronology",
    "signature": "org.joda.time.chrono.BasicFixedMonthChronology.getAverageMillisPerMonth()",
    "snippet": "    long getAverageMillisPerMonth() {\n        return MILLIS_PER_MONTH;\n    }",
    "comment": "-----------------------------------------------------------------------",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 3
  },
  {
    "name": "BasicFixedMonthChronology.getAverageMillisPerYear",
    "class_name": "org.joda.time.chrono.BasicFixedMonthChronology",
    "signature": "org.joda.time.chrono.BasicFixedMonthChronology.getAverageMillisPerYear()",
    "snippet": "    long getAverageMillisPerYear() {\n        return MILLIS_PER_YEAR;\n    }",
    "comment": "-----------------------------------------------------------------------",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 3
  },
  {
    "name": "BasicFixedMonthChronology.getDaysInYearMonth",
    "class_name": "org.joda.time.chrono.BasicFixedMonthChronology",
    "signature": "org.joda.time.chrono.BasicFixedMonthChronology.getDaysInYearMonth(int,int)",
    "snippet": "    int getDaysInYearMonth(int year, int month) {\n        return (month != 13) ? MONTH_LENGTH : (isLeapYear(year) ? 6 : 5);\n    }",
    "comment": "-----------------------------------------------------------------------",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 3
  },
  {
    "name": "BasicFixedMonthChronology.getMaxMonth",
    "class_name": "org.joda.time.chrono.BasicFixedMonthChronology",
    "signature": "org.joda.time.chrono.BasicFixedMonthChronology.getMaxMonth()",
    "snippet": "    int getMaxMonth() {\n        return 13;\n    }",
    "comment": "-----------------------------------------------------------------------",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 3
  },
  {
    "name": "BasicFixedMonthChronology.getTotalMillisByYearMonth",
    "class_name": "org.joda.time.chrono.BasicFixedMonthChronology",
    "signature": "org.joda.time.chrono.BasicFixedMonthChronology.getTotalMillisByYearMonth(int,int)",
    "snippet": "    long getTotalMillisByYearMonth(int year, int month) {\n        return ((month - 1) * MILLIS_PER_MONTH);\n    }",
    "comment": "-----------------------------------------------------------------------",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 3
  },
  {
    "name": "BasicGJChronology.BasicGJChronology",
    "class_name": "org.joda.time.chrono.BasicGJChronology",
    "signature": "org.joda.time.chrono.BasicGJChronology.BasicGJChronology(Chronology,Object,int)",
    "snippet": "    BasicGJChronology(Chronology base, Object param, int minDaysInFirstWeek) {\n        super(base, param, minDaysInFirstWeek);\n    }",
    "comment": " Constructor. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 3
  },
  {
    "name": "BasicGJChronology.getDaysInMonthMaxForSet",
    "class_name": "org.joda.time.chrono.BasicGJChronology",
    "signature": "org.joda.time.chrono.BasicGJChronology.getDaysInMonthMaxForSet(long,int)",
    "snippet": "    int getDaysInMonthMaxForSet(long instant, int value) {\n        return ((value > 28 || value < 1) ? getDaysInMonthMax(instant) : 28);\n    }",
    "comment": "-----------------------------------------------------------------------",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 3
  },
  {
    "name": "BasicGJChronology.getDaysInYearMonth",
    "class_name": "org.joda.time.chrono.BasicGJChronology",
    "signature": "org.joda.time.chrono.BasicGJChronology.getDaysInYearMonth(int,int)",
    "snippet": "    int getDaysInYearMonth(int year, int month) {\n        if (isLeapYear(year)) {\n            return MAX_DAYS_PER_MONTH_ARRAY[month - 1];\n        } else {\n            return MIN_DAYS_PER_MONTH_ARRAY[month - 1];\n        }\n    }",
    "comment": " Gets the number of days in the specified month and year.  @param year  the year @param month  the month @return the number of days ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 3
  },
  {
    "name": "BasicGJChronology.getMonthOfYear",
    "class_name": "org.joda.time.chrono.BasicGJChronology",
    "signature": "org.joda.time.chrono.BasicGJChronology.getMonthOfYear(long,int)",
    "snippet": "    int getMonthOfYear(long millis, int year) {\n        // Perform a binary search to get the month. To make it go even faster,\n        // compare using ints instead of longs. The number of milliseconds per\n        // year exceeds the limit of a 32-bit int's capacity, so divide by\n        // 1024. No precision is lost (except time of day) since the number of\n        // milliseconds per day contains 1024 as a factor. After the division,\n        // the instant isn't measured in milliseconds, but in units of\n        // (128/125)seconds.\n\n        int i = (int)((millis - getYearMillis(year)) >> 10);\n\n        // There are 86400000 milliseconds per day, but divided by 1024 is\n        // 84375. There are 84375 (128/125)seconds per day.\n\n        return\n            (isLeapYear(year))\n            ? ((i < 182 * 84375)\n               ? ((i < 91 * 84375)\n                  ? ((i < 31 * 84375) ? 1 : (i < 60 * 84375) ? 2 : 3)\n                  : ((i < 121 * 84375) ? 4 : (i < 152 * 84375) ? 5 : 6))\n               : ((i < 274 * 84375)\n                  ? ((i < 213 * 84375) ? 7 : (i < 244 * 84375) ? 8 : 9)\n                  : ((i < 305 * 84375) ? 10 : (i < 335 * 84375) ? 11 : 12)))\n            : ((i < 181 * 84375)\n               ? ((i < 90 * 84375)\n                  ? ((i < 31 * 84375) ? 1 : (i < 59 * 84375) ? 2 : 3)\n                  : ((i < 120 * 84375) ? 4 : (i < 151 * 84375) ? 5 : 6))\n               : ((i < 273 * 84375)\n                  ? ((i < 212 * 84375) ? 7 : (i < 243 * 84375) ? 8 : 9)\n                  : ((i < 304 * 84375) ? 10 : (i < 334 * 84375) ? 11 : 12)));\n    }",
    "comment": "-----------------------------------------------------------------------",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 3
  },
  {
    "name": "BasicGJChronology.getTotalMillisByYearMonth",
    "class_name": "org.joda.time.chrono.BasicGJChronology",
    "signature": "org.joda.time.chrono.BasicGJChronology.getTotalMillisByYearMonth(int,int)",
    "snippet": "    long getTotalMillisByYearMonth(int year, int month) {\n        if (isLeapYear(year)) {\n            return MAX_TOTAL_MILLIS_BY_MONTH_ARRAY[month - 1];\n        } else {\n            return MIN_TOTAL_MILLIS_BY_MONTH_ARRAY[month - 1];\n        }\n    }",
    "comment": "-----------------------------------------------------------------------",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 3
  },
  {
    "name": "BasicGJChronology.setYear",
    "class_name": "org.joda.time.chrono.BasicGJChronology",
    "signature": "org.joda.time.chrono.BasicGJChronology.setYear(long,int)",
    "snippet": "    long setYear(long instant, int year) {\n        int thisYear = getYear(instant);\n        int dayOfYear = getDayOfYear(instant, thisYear);\n        int millisOfDay = getMillisOfDay(instant);\n\n        if (dayOfYear > (31 + 28)) { // after Feb 28\n            if (isLeapYear(thisYear)) {\n                // Current date is Feb 29 or later.\n                if (!isLeapYear(year)) {\n                    // Moving to a non-leap year, Feb 29 does not exist.\n                    dayOfYear--;\n                }\n            } else {\n                // Current date is Mar 01 or later.\n                if (isLeapYear(year)) {\n                    // Moving to a leap year, account for Feb 29.\n                    dayOfYear++;\n                }\n            }\n        }\n\n        instant = getYearMonthDayMillis(year, 1, dayOfYear);\n        instant += millisOfDay;\n\n        return instant;\n    }",
    "comment": "-----------------------------------------------------------------------",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 3
  },
  {
    "name": "BasicMonthOfYearDateTimeField.BasicMonthOfYearDateTimeField",
    "class_name": "org.joda.time.chrono.BasicMonthOfYearDateTimeField",
    "signature": "org.joda.time.chrono.BasicMonthOfYearDateTimeField.BasicMonthOfYearDateTimeField(BasicChronology,int)",
    "snippet": "    BasicMonthOfYearDateTimeField(BasicChronology chronology, int leapMonth) {\n        super(DateTimeFieldType.monthOfYear(), chronology.getAverageMillisPerMonth());\n        iChronology = chronology;\n        iMax = iChronology.getMaxMonth();\n        iLeapMonth = leapMonth;\n    }",
    "comment": " Restricted constructor.  @param leapMonth the month of year that leaps ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 3
  },
  {
    "name": "BasicMonthOfYearDateTimeField.get",
    "class_name": "org.joda.time.chrono.BasicMonthOfYearDateTimeField",
    "signature": "org.joda.time.chrono.BasicMonthOfYearDateTimeField.get(long)",
    "snippet": "    public int get(long instant) {\n        return iChronology.getMonthOfYear(instant);\n    }",
    "comment": " Get the Month component of the specified time instant.  @see org.joda.time.DateTimeField#get(long) @see org.joda.time.ReadableDateTime#getMonthOfYear() @param instant  the time instant in millis to query. @return the month extracted from the input. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 3
  },
  {
    "name": "BasicMonthOfYearDateTimeField.getLeapDurationField",
    "class_name": "org.joda.time.chrono.BasicMonthOfYearDateTimeField",
    "signature": "org.joda.time.chrono.BasicMonthOfYearDateTimeField.getLeapDurationField()",
    "snippet": "    public DurationField getLeapDurationField() {\n        return iChronology.days();\n    }",
    "comment": "-----------------------------------------------------------------------",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 3
  },
  {
    "name": "BasicMonthOfYearDateTimeField.getRangeDurationField",
    "class_name": "org.joda.time.chrono.BasicMonthOfYearDateTimeField",
    "signature": "org.joda.time.chrono.BasicMonthOfYearDateTimeField.getRangeDurationField()",
    "snippet": "    public DurationField getRangeDurationField() {\n        return iChronology.years();\n    }",
    "comment": "-----------------------------------------------------------------------",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 3
  },
  {
    "name": "BasicMonthOfYearDateTimeField.set",
    "class_name": "org.joda.time.chrono.BasicMonthOfYearDateTimeField",
    "signature": "org.joda.time.chrono.BasicMonthOfYearDateTimeField.set(long,int)",
    "snippet": "    public long set(long instant, int month) {\n        FieldUtils.verifyValueBounds(this, month, MIN, iMax);\n        //\n        int thisYear = iChronology.getYear(instant);\n        //\n        int thisDom = iChronology.getDayOfMonth(instant, thisYear);\n        int maxDom = iChronology.getDaysInYearMonth(thisYear, month);\n        if (thisDom > maxDom) {\n            // Quietly force DOM to nearest sane value.\n            thisDom = maxDom;\n        }\n        // Return newly calculated millis value\n        return iChronology.getYearMonthDayMillis(thisYear, month, thisDom) +\n            iChronology.getMillisOfDay(instant);\n    }",
    "comment": " Set the Month component of the specified time instant.<p> If the new month has less total days than the specified day of the month, this value is coerced to the nearest sane value. e.g.<p> 07-31 to month 6 = 06-30<p> 03-31 to month 2 = 02-28 or 02-29 depending<p>  @param instant  the time instant in millis to update. @param month  the month (1,12) to update the time to. @return the updated time instant. @throws IllegalArgumentException  if month is invalid ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 3
  },
  {
    "name": "BasicSingleEraDateTimeField.BasicSingleEraDateTimeField",
    "class_name": "org.joda.time.chrono.BasicSingleEraDateTimeField",
    "signature": "org.joda.time.chrono.BasicSingleEraDateTimeField.BasicSingleEraDateTimeField(String)",
    "snippet": "    BasicSingleEraDateTimeField(String text) {\n        super(DateTimeFieldType.era());\n        iEraText = text;\n    }",
    "comment": " Restricted constructor. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 3
  },
  {
    "name": "BasicSingleEraDateTimeField.getDurationField",
    "class_name": "org.joda.time.chrono.BasicSingleEraDateTimeField",
    "signature": "org.joda.time.chrono.BasicSingleEraDateTimeField.getDurationField()",
    "snippet": "    public DurationField getDurationField() {\n        return UnsupportedDurationField.getInstance(DurationFieldType.eras());\n    }",
    "comment": "@inheritDoc */",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 3
  },
  {
    "name": "BasicSingleEraDateTimeField.getRangeDurationField",
    "class_name": "org.joda.time.chrono.BasicSingleEraDateTimeField",
    "signature": "org.joda.time.chrono.BasicSingleEraDateTimeField.getRangeDurationField()",
    "snippet": "    public DurationField getRangeDurationField() {\n        return null;\n    }",
    "comment": "@inheritDoc */",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 3
  },
  {
    "name": "BasicWeekOfWeekyearDateTimeField.BasicWeekOfWeekyearDateTimeField",
    "class_name": "org.joda.time.chrono.BasicWeekOfWeekyearDateTimeField",
    "signature": "org.joda.time.chrono.BasicWeekOfWeekyearDateTimeField.BasicWeekOfWeekyearDateTimeField(BasicChronology,DurationField)",
    "snippet": "    BasicWeekOfWeekyearDateTimeField(BasicChronology chronology, DurationField weeks) {\n        super(DateTimeFieldType.weekOfWeekyear(), weeks);\n        iChronology = chronology;\n    }",
    "comment": " Restricted constructor ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 3
  },
  {
    "name": "BasicWeekOfWeekyearDateTimeField.getRangeDurationField",
    "class_name": "org.joda.time.chrono.BasicWeekOfWeekyearDateTimeField",
    "signature": "org.joda.time.chrono.BasicWeekOfWeekyearDateTimeField.getRangeDurationField()",
    "snippet": "    public DurationField getRangeDurationField() {\n        return iChronology.weekyears();\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 3
  },
  {
    "name": "BasicWeekOfWeekyearDateTimeField.roundFloor",
    "class_name": "org.joda.time.chrono.BasicWeekOfWeekyearDateTimeField",
    "signature": "org.joda.time.chrono.BasicWeekOfWeekyearDateTimeField.roundFloor(long)",
    "snippet": "    public long roundFloor(long instant) {\n        return super.roundFloor(instant + 3 * DateTimeConstants.MILLIS_PER_DAY)\n            - 3 * DateTimeConstants.MILLIS_PER_DAY;\n    }",
    "comment": "apply a corrective alignment since weeks begin on day of week 1, Monday.",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 3
  },
  {
    "name": "BasicWeekyearDateTimeField.BasicWeekyearDateTimeField",
    "class_name": "org.joda.time.chrono.BasicWeekyearDateTimeField",
    "signature": "org.joda.time.chrono.BasicWeekyearDateTimeField.BasicWeekyearDateTimeField(BasicChronology)",
    "snippet": "    BasicWeekyearDateTimeField(BasicChronology chronology) {\n        super(DateTimeFieldType.weekyear(), chronology.getAverageMillisPerYear());\n        iChronology = chronology;\n    }",
    "comment": " Restricted constructor ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 3
  },
  {
    "name": "BasicWeekyearDateTimeField.add",
    "class_name": "org.joda.time.chrono.BasicWeekyearDateTimeField",
    "signature": "org.joda.time.chrono.BasicWeekyearDateTimeField.add(long,int)",
    "snippet": "    public long add(long instant, int years) {\n        if (years == 0) {\n            return instant;\n        }\n        return set(instant, get(instant) + years);\n    }",
    "comment": " Add the specified years to the specified time instant.  @see org.joda.time.DateTimeField#add @param instant  the time instant in millis to update. @param years  the years to add (can be negative). @return the updated time instant. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 3
  },
  {
    "name": "BasicWeekyearDateTimeField.get",
    "class_name": "org.joda.time.chrono.BasicWeekyearDateTimeField",
    "signature": "org.joda.time.chrono.BasicWeekyearDateTimeField.get(long)",
    "snippet": "    public int get(long instant) {\n        return iChronology.getWeekyear(instant);\n    }",
    "comment": " Get the Year of a week based year component of the specified time instant.  @see org.joda.time.DateTimeField#get @param instant  the time instant in millis to query. @return the year extracted from the input. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 3
  },
  {
    "name": "BasicWeekyearDateTimeField.getLeapDurationField",
    "class_name": "org.joda.time.chrono.BasicWeekyearDateTimeField",
    "signature": "org.joda.time.chrono.BasicWeekyearDateTimeField.getLeapDurationField()",
    "snippet": "    public DurationField getLeapDurationField() {\n        return iChronology.weeks();\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 3
  },
  {
    "name": "BasicWeekyearDateTimeField.getMaximumValue",
    "class_name": "org.joda.time.chrono.BasicWeekyearDateTimeField",
    "signature": "org.joda.time.chrono.BasicWeekyearDateTimeField.getMaximumValue()",
    "snippet": "    public int getMaximumValue() {\n        return iChronology.getMaxYear();\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 3
  },
  {
    "name": "BasicWeekyearDateTimeField.getMinimumValue",
    "class_name": "org.joda.time.chrono.BasicWeekyearDateTimeField",
    "signature": "org.joda.time.chrono.BasicWeekyearDateTimeField.getMinimumValue()",
    "snippet": "    public int getMinimumValue() {\n        return iChronology.getMinYear();\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 3
  },
  {
    "name": "BasicWeekyearDateTimeField.getRangeDurationField",
    "class_name": "org.joda.time.chrono.BasicWeekyearDateTimeField",
    "signature": "org.joda.time.chrono.BasicWeekyearDateTimeField.getRangeDurationField()",
    "snippet": "    public DurationField getRangeDurationField() {\n        return null;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 3
  },
  {
    "name": "BasicWeekyearDateTimeField.roundFloor",
    "class_name": "org.joda.time.chrono.BasicWeekyearDateTimeField",
    "signature": "org.joda.time.chrono.BasicWeekyearDateTimeField.roundFloor(long)",
    "snippet": "    public long roundFloor(long instant) {\n        // Note: This works fine, but it ideally shouldn't invoke other\n        // fields from within a field.\n        instant = iChronology.weekOfWeekyear().roundFloor(instant);\n        int wow = iChronology.getWeekOfWeekyear(instant);\n        if (wow > 1) {\n            instant -= ((long) DateTimeConstants.MILLIS_PER_WEEK) * (wow - 1);\n        }\n        return instant;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 3
  },
  {
    "name": "BasicWeekyearDateTimeField.set",
    "class_name": "org.joda.time.chrono.BasicWeekyearDateTimeField",
    "signature": "org.joda.time.chrono.BasicWeekyearDateTimeField.set(long,int)",
    "snippet": "    public long set(long instant, int year) {\n        FieldUtils.verifyValueBounds(this, Math.abs(year),\n                                     iChronology.getMinYear(), iChronology.getMaxYear());\n        //\n        // Do nothing if no real change is requested.\n        //\n        int thisWeekyear = get( instant );\n        if ( thisWeekyear == year ) {\n            return instant;\n        }\n        //\n        // Calculate the DayOfWeek (to be preserved).\n        //\n        int thisDow = iChronology.getDayOfWeek(instant);\n        //\n        // Calculate the maximum weeks in the target year.\n        //\n        int weeksInFromYear = iChronology.getWeeksInYear( thisWeekyear );\n        int weeksInToYear = iChronology.getWeeksInYear( year );\n        int maxOutWeeks = (weeksInToYear < weeksInFromYear) ?\n            weeksInToYear : weeksInFromYear;\n        //\n        // Get the current week of the year. This will be preserved in\n        // the output unless it is greater than the maximum possible\n        // for the target weekyear.  In that case it is adjusted\n        // to the maximum possible.\n        //\n        int setToWeek = iChronology.getWeekOfWeekyear(instant);\n        if ( setToWeek > maxOutWeeks ) {\n            setToWeek = maxOutWeeks;\n        }\n        //\n        // Get a wroking copy of the current date-time.\n        // This can be a convenience for debugging.\n        //\n        long workInstant = instant; // Get a copy\n        //\n        // Attempt to get close to the proper weekyear.\n        // Note - we cannot currently call ourself, so we just call\n        // set for the year.  This at least gets us close.\n        //\n        workInstant = iChronology.setYear( workInstant, year );\n        //\n        // Calculate the weekyear number for the get close to value\n        // (which might not be equal to the year just set).\n        //\n        int workWoyYear = get( workInstant );\n\n        //\n        // At most we are off by one year, which can be \"fixed\" by\n        // adding/subtracting a week.\n        //\n        if ( workWoyYear < year ) {\n            workInstant += DateTimeConstants.MILLIS_PER_WEEK;\n        } else if ( workWoyYear > year ) {\n            workInstant -= DateTimeConstants.MILLIS_PER_WEEK;\n        }\n        //\n        // Set the proper week in the current weekyear.\n        //\n\n        // BEGIN: possible set WeekOfWeekyear logic.\n        int currentWoyWeek = iChronology.getWeekOfWeekyear(workInstant);\n        // No range check required (we already know it is OK).\n        workInstant = workInstant + (setToWeek - currentWoyWeek)\n            * (long)DateTimeConstants.MILLIS_PER_WEEK;\n        // END: possible set WeekOfWeekyear logic.\n\n        //\n        // Reset DayOfWeek to previous value.\n        //\n        // Note: This works fine, but it ideally shouldn't invoke other\n        // fields from within a field.\n        workInstant = iChronology.dayOfWeek().set( workInstant, thisDow );\n        //\n        // Return result.\n        //\n        return workInstant;\n    }",
    "comment": " Set the Year of a week based year component of the specified time instant.  @see org.joda.time.DateTimeField#set @param instant  the time instant in millis to update. @param year  the year (-9999,9999) to set the date to. @return the updated DateTime. @throws IllegalArgumentException  if year is invalid. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 3
  },
  {
    "name": "BasicYearDateTimeField.BasicYearDateTimeField",
    "class_name": "org.joda.time.chrono.BasicYearDateTimeField",
    "signature": "org.joda.time.chrono.BasicYearDateTimeField.BasicYearDateTimeField(BasicChronology)",
    "snippet": "    BasicYearDateTimeField(BasicChronology chronology) {\n        super(DateTimeFieldType.year(), chronology.getAverageMillisPerYear());\n        iChronology = chronology;\n    }",
    "comment": " Restricted constructor.  @param chronology  the chronology this field belogs to ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 3
  },
  {
    "name": "BasicYearDateTimeField.get",
    "class_name": "org.joda.time.chrono.BasicYearDateTimeField",
    "signature": "org.joda.time.chrono.BasicYearDateTimeField.get(long)",
    "snippet": "    public int get(long instant) {\n        return iChronology.getYear(instant);\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 3
  },
  {
    "name": "BasicYearDateTimeField.getLeapDurationField",
    "class_name": "org.joda.time.chrono.BasicYearDateTimeField",
    "signature": "org.joda.time.chrono.BasicYearDateTimeField.getLeapDurationField()",
    "snippet": "    public DurationField getLeapDurationField() {\n        return iChronology.days();\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 3
  },
  {
    "name": "BasicYearDateTimeField.getMaximumValue",
    "class_name": "org.joda.time.chrono.BasicYearDateTimeField",
    "signature": "org.joda.time.chrono.BasicYearDateTimeField.getMaximumValue()",
    "snippet": "    public int getMaximumValue() {\n        return iChronology.getMaxYear();\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 3
  },
  {
    "name": "BasicYearDateTimeField.getMinimumValue",
    "class_name": "org.joda.time.chrono.BasicYearDateTimeField",
    "signature": "org.joda.time.chrono.BasicYearDateTimeField.getMinimumValue()",
    "snippet": "    public int getMinimumValue() {\n        return iChronology.getMinYear();\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 3
  },
  {
    "name": "BasicYearDateTimeField.getRangeDurationField",
    "class_name": "org.joda.time.chrono.BasicYearDateTimeField",
    "signature": "org.joda.time.chrono.BasicYearDateTimeField.getRangeDurationField()",
    "snippet": "    public DurationField getRangeDurationField() {\n        return null;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 3
  },
  {
    "name": "BasicYearDateTimeField.roundCeiling",
    "class_name": "org.joda.time.chrono.BasicYearDateTimeField",
    "signature": "org.joda.time.chrono.BasicYearDateTimeField.roundCeiling(long)",
    "snippet": "    public long roundCeiling(long instant) {\n        int year = get(instant);\n        long yearStartMillis = iChronology.getYearMillis(year);\n        if (instant != yearStartMillis) {\n            // Bump up to start of next year.\n            instant = iChronology.getYearMillis(year + 1);\n        }\n        return instant;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 3
  },
  {
    "name": "BasicYearDateTimeField.set",
    "class_name": "org.joda.time.chrono.BasicYearDateTimeField",
    "signature": "org.joda.time.chrono.BasicYearDateTimeField.set(long,int)",
    "snippet": "    public long set(long instant, int year) {\n        FieldUtils.verifyValueBounds\n            (this, year, iChronology.getMinYear(), iChronology.getMaxYear());\n        return iChronology.setYear(instant, year);\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 3
  },
  {
    "name": "BuddhistChronology.assemble",
    "class_name": "org.joda.time.chrono.BuddhistChronology",
    "signature": "org.joda.time.chrono.BuddhistChronology.assemble(Fields)",
    "snippet": "    protected void assemble(Fields fields) {\n        if (getParam() == null) {\n            // force init as used below\n            fields.eras = UnsupportedDurationField.getInstance(DurationFieldType.eras());\n            \n            // julian chrono removed zero, but we need to put it back\n            DateTimeField field = fields.year;\n            fields.year = new OffsetDateTimeField(\n                    new SkipUndoDateTimeField(this, field), BUDDHIST_OFFSET);\n            \n            // one era, so yearOfEra is the same\n            field = fields.yearOfEra;\n            fields.yearOfEra = new DelegatedDateTimeField(\n                fields.year, fields.eras, DateTimeFieldType.yearOfEra());\n            \n            // julian chrono removed zero, but we need to put it back\n            field = fields.weekyear;\n            fields.weekyear = new OffsetDateTimeField(\n                    new SkipUndoDateTimeField(this, field), BUDDHIST_OFFSET);\n            \n            field = new OffsetDateTimeField(fields.yearOfEra, 99);\n            fields.centuryOfEra = new DividedDateTimeField(\n                field, fields.eras, DateTimeFieldType.centuryOfEra(), 100);\n            fields.centuries = fields.centuryOfEra.getDurationField();\n            \n            field = new RemainderDateTimeField(\n                (DividedDateTimeField) fields.centuryOfEra);\n            fields.yearOfCentury = new OffsetDateTimeField(\n                field, DateTimeFieldType.yearOfCentury(), 1);\n            \n            field = new RemainderDateTimeField(\n                fields.weekyear, fields.centuries, DateTimeFieldType.weekyearOfCentury(), 100);\n            fields.weekyearOfCentury = new OffsetDateTimeField(\n                field, DateTimeFieldType.weekyearOfCentury(), 1);\n            \n            fields.era = ERA_FIELD;\n        }\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 3
  },
  {
    "name": "BuddhistChronology.getInstance",
    "class_name": "org.joda.time.chrono.BuddhistChronology",
    "signature": "org.joda.time.chrono.BuddhistChronology.getInstance(DateTimeZone)",
    "snippet": "    public static synchronized BuddhistChronology getInstance(DateTimeZone zone) {\n        if (zone == null) {\n            zone = DateTimeZone.getDefault();\n        }\n        BuddhistChronology chrono;\n        synchronized (cCache) {\n            chrono = cCache.get(zone);\n            if (chrono == null) {\n                // First create without a lower limit.\n                chrono = new BuddhistChronology(GJChronology.getInstance(zone, null), null);\n                // Impose lower limit and make another BuddhistChronology.\n                DateTime lowerLimit = new DateTime(1, 1, 1, 0, 0, 0, 0, chrono);\n                chrono = new BuddhistChronology(LimitChronology.getInstance(chrono, lowerLimit, null), \"\");\n                cCache.put(zone, chrono);\n            }\n        }\n        return chrono;\n    }",
    "comment": " Standard instance of a Buddhist Chronology, that matches Sun's BuddhistCalendar class. This means that it follows the GregorianJulian calendar rules with a cutover date.  @param zone  the time zone to use, null is default ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 3
  },
  {
    "name": "BuddhistChronology.getInstanceUTC",
    "class_name": "org.joda.time.chrono.BuddhistChronology",
    "signature": "org.joda.time.chrono.BuddhistChronology.getInstanceUTC()",
    "snippet": "    public static BuddhistChronology getInstanceUTC() {\n        return INSTANCE_UTC;\n    }",
    "comment": " Standard instance of a Buddhist Chronology, that matches Sun's BuddhistCalendar class. This means that it follows the GregorianJulian calendar rules with a cutover date. <p> The time zone of the returned instance is UTC. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 3
  },
  {
    "name": "CopticChronology.CopticChronology",
    "class_name": "org.joda.time.chrono.CopticChronology",
    "signature": "org.joda.time.chrono.CopticChronology.CopticChronology(Chronology,Object,int)",
    "snippet": "    CopticChronology(Chronology base, Object param, int minDaysInFirstWeek) {\n        super(base, param, minDaysInFirstWeek);\n    }",
    "comment": " Restricted constructor. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 3
  },
  {
    "name": "CopticChronology.assemble",
    "class_name": "org.joda.time.chrono.CopticChronology",
    "signature": "org.joda.time.chrono.CopticChronology.assemble(Fields)",
    "snippet": "    protected void assemble(Fields fields) {\n        if (getBase() == null) {\n            super.assemble(fields);\n\n            // Coptic, like Julian, has no year zero.\n            fields.year = new SkipDateTimeField(this, fields.year);\n            fields.weekyear = new SkipDateTimeField(this, fields.weekyear);\n            \n            fields.era = ERA_FIELD;\n            fields.monthOfYear = new BasicMonthOfYearDateTimeField(this, 13);\n            fields.months = fields.monthOfYear.getDurationField();\n        }\n    }",
    "comment": "-----------------------------------------------------------------------",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 3
  },
  {
    "name": "CopticChronology.calculateFirstDayOfYearMillis",
    "class_name": "org.joda.time.chrono.CopticChronology",
    "signature": "org.joda.time.chrono.CopticChronology.calculateFirstDayOfYearMillis(int)",
    "snippet": "    long calculateFirstDayOfYearMillis(int year) {\n        // Java epoch is 1970-01-01 Gregorian which is 1686-04-23 Coptic.\n        // Calculate relative to the nearest leap year and account for the\n        // difference later.\n\n        int relativeYear = year - 1687;\n        int leapYears;\n        if (relativeYear <= 0) {\n            // Add 3 before shifting right since /4 and >>2 behave differently\n            // on negative numbers.\n            leapYears = (relativeYear + 3) >> 2;\n        } else {\n            leapYears = relativeYear >> 2;\n            // For post 1687 an adjustment is needed as jan1st is before leap day\n            if (!isLeapYear(year)) {\n                leapYears++;\n            }\n        }\n        \n        long millis = (relativeYear * 365L + leapYears)\n            * (long)DateTimeConstants.MILLIS_PER_DAY;\n\n        // Adjust to account for difference between 1687-01-01 and 1686-04-23.\n\n        return millis + (365L - 112) * DateTimeConstants.MILLIS_PER_DAY;\n    }",
    "comment": "-----------------------------------------------------------------------",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 3
  },
  {
    "name": "CopticChronology.getInstance",
    "class_name": "org.joda.time.chrono.CopticChronology",
    "signature": "org.joda.time.chrono.CopticChronology.getInstance(DateTimeZone)",
    "snippet": "    public static CopticChronology getInstance(DateTimeZone zone) {\n        return getInstance(zone, 4);\n    }",
    "comment": " Gets an instance of the CopticChronology in the given time zone.  @param zone  the time zone to get the chronology in, null is default @return a chronology in the specified time zone ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 3
  },
  {
    "name": "CopticChronology.getInstance",
    "class_name": "org.joda.time.chrono.CopticChronology",
    "signature": "org.joda.time.chrono.CopticChronology.getInstance(DateTimeZone,int)",
    "snippet": "    public static CopticChronology getInstance(DateTimeZone zone, int minDaysInFirstWeek) {\n        if (zone == null) {\n            zone = DateTimeZone.getDefault();\n        }\n        CopticChronology chrono;\n        synchronized (cCache) {\n            CopticChronology[] chronos = cCache.get(zone);\n            if (chronos == null) {\n                chronos = new CopticChronology[7];\n                cCache.put(zone, chronos);\n            }\n            try {\n                chrono = chronos[minDaysInFirstWeek - 1];\n            } catch (ArrayIndexOutOfBoundsException e) {\n                throw new IllegalArgumentException\n                    (\"Invalid min days in first week: \" + minDaysInFirstWeek);\n            }\n            if (chrono == null) {\n                if (zone == DateTimeZone.UTC) {\n                    // First create without a lower limit.\n                    chrono = new CopticChronology(null, null, minDaysInFirstWeek);\n                    // Impose lower limit and make another CopticChronology.\n                    DateTime lowerLimit = new DateTime(1, 1, 1, 0, 0, 0, 0, chrono);\n                    chrono = new CopticChronology\n                        (LimitChronology.getInstance(chrono, lowerLimit, null),\n                         null, minDaysInFirstWeek);\n                } else {\n                    chrono = getInstance(DateTimeZone.UTC, minDaysInFirstWeek);\n                    chrono = new CopticChronology\n                        (ZonedChronology.getInstance(chrono, zone), null, minDaysInFirstWeek);\n                }\n                chronos[minDaysInFirstWeek - 1] = chrono;\n            }\n        }\n        return chrono;\n    }",
    "comment": " Gets an instance of the CopticChronology in the given time zone.  @param zone  the time zone to get the chronology in, null is default @param minDaysInFirstWeek  minimum number of days in first week of the year; default is 4 @return a chronology in the specified time zone ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 3
  },
  {
    "name": "CopticChronology.getInstanceUTC",
    "class_name": "org.joda.time.chrono.CopticChronology",
    "signature": "org.joda.time.chrono.CopticChronology.getInstanceUTC()",
    "snippet": "    public static CopticChronology getInstanceUTC() {\n        return INSTANCE_UTC;\n    }",
    "comment": " Gets an instance of the CopticChronology. The time zone of the returned instance is UTC.  @return a singleton UTC instance of the chronology ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 3
  },
  {
    "name": "CopticChronology.getMaxYear",
    "class_name": "org.joda.time.chrono.CopticChronology",
    "signature": "org.joda.time.chrono.CopticChronology.getMaxYear()",
    "snippet": "    int getMaxYear() {\n        return MAX_YEAR;\n    }",
    "comment": "-----------------------------------------------------------------------",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 3
  },
  {
    "name": "CopticChronology.getMinYear",
    "class_name": "org.joda.time.chrono.CopticChronology",
    "signature": "org.joda.time.chrono.CopticChronology.getMinYear()",
    "snippet": "    int getMinYear() {\n        return MIN_YEAR;\n    }",
    "comment": "-----------------------------------------------------------------------",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 3
  },
  {
    "name": "CopticChronology.withUTC",
    "class_name": "org.joda.time.chrono.CopticChronology",
    "signature": "org.joda.time.chrono.CopticChronology.withUTC()",
    "snippet": "    public Chronology withUTC() {\n        return INSTANCE_UTC;\n    }",
    "comment": " Gets the Chronology in the UTC time zone.  @return the chronology in UTC ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 3
  },
  {
    "name": "GJChronology.assemble",
    "class_name": "org.joda.time.chrono.GJChronology",
    "signature": "org.joda.time.chrono.GJChronology.assemble(Fields)",
    "snippet": "    protected void assemble(Fields fields) {\n        Object[] params = (Object[])getParam();\n\n        JulianChronology julian = (JulianChronology)params[0];\n        GregorianChronology gregorian = (GregorianChronology)params[1];\n        Instant cutoverInstant = (Instant)params[2];\n        iCutoverMillis = cutoverInstant.getMillis();\n\n        iJulianChronology = julian;\n        iGregorianChronology = gregorian;\n        iCutoverInstant = cutoverInstant;\n\n        if (getBase() != null) {\n            return;\n        }\n\n        if (julian.getMinimumDaysInFirstWeek() != gregorian.getMinimumDaysInFirstWeek()) {\n            throw new IllegalArgumentException();\n        }\n\n        // Compute difference between the chronologies at the cutover instant\n        iGapDuration = iCutoverMillis - julianToGregorianByYear(iCutoverMillis);\n\n        // Begin field definitions.\n\n        // First just copy all the Gregorian fields and then override those\n        // that need special attention.\n        fields.copyFieldsFrom(gregorian);\n        \n        // Assuming cutover is at midnight, all time of day fields can be\n        // gregorian since they are unaffected by cutover.\n\n        // Verify assumption.\n        if (gregorian.millisOfDay().get(iCutoverMillis) == 0) {\n            // Cutover is sometime in the day, so cutover fields are required\n            // for time of day.\n\n            fields.millisOfSecond = new CutoverField(julian.millisOfSecond(), fields.millisOfSecond, iCutoverMillis);\n            fields.millisOfDay = new CutoverField(julian.millisOfDay(), fields.millisOfDay, iCutoverMillis);\n            fields.secondOfMinute = new CutoverField(julian.secondOfMinute(), fields.secondOfMinute, iCutoverMillis);\n            fields.secondOfDay = new CutoverField(julian.secondOfDay(), fields.secondOfDay, iCutoverMillis);\n            fields.minuteOfHour = new CutoverField(julian.minuteOfHour(), fields.minuteOfHour, iCutoverMillis);\n            fields.minuteOfDay = new CutoverField(julian.minuteOfDay(), fields.minuteOfDay, iCutoverMillis);\n            fields.hourOfDay = new CutoverField(julian.hourOfDay(), fields.hourOfDay, iCutoverMillis);\n            fields.hourOfHalfday = new CutoverField(julian.hourOfHalfday(), fields.hourOfHalfday, iCutoverMillis);\n            fields.clockhourOfDay = new CutoverField(julian.clockhourOfDay(), fields.clockhourOfDay, iCutoverMillis);\n            fields.clockhourOfHalfday = new CutoverField(julian.clockhourOfHalfday(),\n                                                         fields.clockhourOfHalfday, iCutoverMillis);\n            fields.halfdayOfDay = new CutoverField(julian.halfdayOfDay(), fields.halfdayOfDay, iCutoverMillis);\n        }\n\n        // These fields just require basic cutover support.\n        {\n            fields.era = new CutoverField(julian.era(), fields.era, iCutoverMillis);\n        }\n\n        // These fields are special because they have imprecise durations. The\n        // family of addition methods need special attention. Override affected\n        // duration fields as well.\n        {\n            fields.year = new ImpreciseCutoverField(\n                julian.year(), fields.year, iCutoverMillis);\n            fields.years = fields.year.getDurationField();\n            fields.yearOfEra = new ImpreciseCutoverField(\n                julian.yearOfEra(), fields.yearOfEra, fields.years, iCutoverMillis);\n            \n            fields.centuryOfEra = new ImpreciseCutoverField(\n                julian.centuryOfEra(), fields.centuryOfEra, iCutoverMillis);\n            fields.centuries = fields.centuryOfEra.getDurationField();\n            \n            fields.yearOfCentury = new ImpreciseCutoverField(\n                julian.yearOfCentury(), fields.yearOfCentury, fields.years, fields.centuries, iCutoverMillis);\n            \n            fields.monthOfYear = new ImpreciseCutoverField(\n                julian.monthOfYear(), fields.monthOfYear, null, fields.years, iCutoverMillis);\n            fields.months = fields.monthOfYear.getDurationField();\n            \n            fields.weekyear = new ImpreciseCutoverField(\n                julian.weekyear(), fields.weekyear, null, iCutoverMillis, true);\n            fields.weekyears = fields.weekyear.getDurationField();\n            fields.weekyearOfCentury = new ImpreciseCutoverField(\n                julian.weekyearOfCentury(), fields.weekyearOfCentury, fields.weekyears, fields.centuries, iCutoverMillis);\n        }\n\n        // DayOfYear and weekOfWeekyear require special handling since cutover\n        // year has fewer days and weeks. Extend the cutover to the start of\n        // the next year or weekyear. This keeps the sequence unbroken during\n        // the cutover year.\n\n        {\n            long cutover = gregorian.year().roundCeiling(iCutoverMillis);\n            fields.dayOfYear = new CutoverField(\n                julian.dayOfYear(), fields.dayOfYear, fields.years, cutover, false);\n        }\n\n        {\n            long cutover = gregorian.weekyear().roundCeiling(iCutoverMillis);\n            fields.weekOfWeekyear = new CutoverField(\n                julian.weekOfWeekyear(), fields.weekOfWeekyear, fields.weekyears, cutover, true);\n        }\n\n        // These fields require basic cutover support, except they must link to\n        // imprecise durations.\n        {\n            CutoverField cf = new CutoverField\n                (julian.dayOfMonth(), fields.dayOfMonth, iCutoverMillis);\n            cf.iRangeDurationField = fields.months;\n            fields.dayOfMonth = cf;\n        }\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 3
  },
  {
    "name": "GJChronology.convertByYear",
    "class_name": "org.joda.time.chrono.GJChronology",
    "signature": "org.joda.time.chrono.GJChronology.convertByYear(long,Chronology,Chronology)",
    "snippet": "    private static long convertByYear(long instant, Chronology from, Chronology to) {\n        return to.getDateTimeMillis\n            (from.year().get(instant),\n             from.monthOfYear().get(instant),\n             from.dayOfMonth().get(instant),\n             from.millisOfDay().get(instant));\n    }",
    "comment": " Convert a datetime from one chronology to another. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 3
  },
  {
    "name": "GJChronology.getGregorianCutover",
    "class_name": "org.joda.time.chrono.GJChronology",
    "signature": "org.joda.time.chrono.GJChronology.getGregorianCutover()",
    "snippet": "    public Instant getGregorianCutover() {\n        return iCutoverInstant;\n    }",
    "comment": " Gets the cutover instant between Gregorian and Julian chronologies. @return the cutover instant ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 3
  },
  {
    "name": "GJChronology.getInstance",
    "class_name": "org.joda.time.chrono.GJChronology",
    "signature": "org.joda.time.chrono.GJChronology.getInstance(DateTimeZone,ReadableInstant)",
    "snippet": "    public static GJChronology getInstance(\n            DateTimeZone zone,\n            ReadableInstant gregorianCutover) {\n        \n        return getInstance(zone, gregorianCutover, 4);\n    }",
    "comment": " Factory method returns instances of the GJ cutover chronology. Any cutover date may be specified.  <p>The first day of the week is designated to be {@link org.joda.time.DateTimeConstants#MONDAY Monday}, and the minimum days in the first week of the year is 4.  @param zone  the time zone to use, null is default @param gregorianCutover  the cutover to use, null means default ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 3
  },
  {
    "name": "GJChronology.getInstance",
    "class_name": "org.joda.time.chrono.GJChronology",
    "signature": "org.joda.time.chrono.GJChronology.getInstance(DateTimeZone,ReadableInstant,int)",
    "snippet": "    public static synchronized GJChronology getInstance(\n            DateTimeZone zone,\n            ReadableInstant gregorianCutover,\n            int minDaysInFirstWeek) {\n        \n        zone = DateTimeUtils.getZone(zone);\n        Instant cutoverInstant;\n        if (gregorianCutover == null) {\n            cutoverInstant = DEFAULT_CUTOVER;\n        } else {\n            cutoverInstant = gregorianCutover.toInstant();\n            LocalDate cutoverDate = new LocalDate(cutoverInstant.getMillis(), GregorianChronology.getInstance(zone));\n            if (cutoverDate.getYear() <= 0) {\n                throw new IllegalArgumentException(\"Cutover too early. Must be on or after 0001-01-01.\");\n            }\n        }\n\n        GJChronology chrono;\n        synchronized (cCache) {\n            ArrayList<GJChronology> chronos = cCache.get(zone);\n            if (chronos == null) {\n                chronos = new ArrayList<GJChronology>(2);\n                cCache.put(zone, chronos);\n            } else {\n                for (int i = chronos.size(); --i >= 0;) {\n                    chrono = chronos.get(i);\n                    if (minDaysInFirstWeek == chrono.getMinimumDaysInFirstWeek() &&\n                        cutoverInstant.equals(chrono.getGregorianCutover())) {\n                        \n                        return chrono;\n                    }\n                }\n            }\n            if (zone == DateTimeZone.UTC) {\n                chrono = new GJChronology\n                    (JulianChronology.getInstance(zone, minDaysInFirstWeek),\n                     GregorianChronology.getInstance(zone, minDaysInFirstWeek),\n                     cutoverInstant);\n            } else {\n                chrono = getInstance(DateTimeZone.UTC, cutoverInstant, minDaysInFirstWeek);\n                chrono = new GJChronology\n                    (ZonedChronology.getInstance(chrono, zone),\n                     chrono.iJulianChronology,\n                     chrono.iGregorianChronology,\n                     chrono.iCutoverInstant);\n            }\n            chronos.add(chrono);\n        }\n        return chrono;\n    }",
    "comment": " Factory method returns instances of the GJ cutover chronology. Any cutover date may be specified.  @param zone  the time zone to use, null is default @param gregorianCutover  the cutover to use, null means default @param minDaysInFirstWeek  minimum number of days in first week of the year; default is 4 ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 3
  },
  {
    "name": "GJChronology.getMinimumDaysInFirstWeek",
    "class_name": "org.joda.time.chrono.GJChronology",
    "signature": "org.joda.time.chrono.GJChronology.getMinimumDaysInFirstWeek()",
    "snippet": "    public int getMinimumDaysInFirstWeek() {\n        return iGregorianChronology.getMinimumDaysInFirstWeek();\n    }",
    "comment": " Gets the minimum days needed for a week to be the first week in a year.  @return the minimum days ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 3
  },
  {
    "name": "GJChronology.getZone",
    "class_name": "org.joda.time.chrono.GJChronology",
    "signature": "org.joda.time.chrono.GJChronology.getZone()",
    "snippet": "    public DateTimeZone getZone() {\n        Chronology base;\n        if ((base = getBase()) != null) {\n            return base.getZone();\n        }\n        return DateTimeZone.UTC;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 3
  },
  {
    "name": "GJChronology.gregorianToJulianByYear",
    "class_name": "org.joda.time.chrono.GJChronology",
    "signature": "org.joda.time.chrono.GJChronology.gregorianToJulianByYear(long)",
    "snippet": "    long gregorianToJulianByYear(long instant) {\n        return convertByYear(instant, iGregorianChronology, iJulianChronology);\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 3
  },
  {
    "name": "GJChronology.julianToGregorianByYear",
    "class_name": "org.joda.time.chrono.GJChronology",
    "signature": "org.joda.time.chrono.GJChronology.julianToGregorianByYear(long)",
    "snippet": "    long julianToGregorianByYear(long instant) {\n        return convertByYear(instant, iJulianChronology, iGregorianChronology);\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 3
  },
  {
    "name": "GJChronology.withUTC",
    "class_name": "org.joda.time.chrono.GJChronology",
    "signature": "org.joda.time.chrono.GJChronology.withUTC()",
    "snippet": "    public Chronology withUTC() {\n        return withZone(DateTimeZone.UTC);\n    }",
    "comment": " Gets the Chronology in the UTC time zone.  @return the chronology in UTC ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 3
  },
  {
    "name": "GJChronology.withZone",
    "class_name": "org.joda.time.chrono.GJChronology",
    "signature": "org.joda.time.chrono.GJChronology.withZone(DateTimeZone)",
    "snippet": "    public Chronology withZone(DateTimeZone zone) {\n        if (zone == null) {\n            zone = DateTimeZone.getDefault();\n        }\n        if (zone == getZone()) {\n            return this;\n        }\n        return getInstance(zone, iCutoverInstant, getMinimumDaysInFirstWeek());\n    }",
    "comment": " Gets the Chronology in a specific time zone.  @param zone  the zone to get the chronology in, null is default @return the chronology ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 3
  },
  {
    "name": "CutoverField.get",
    "class_name": "org.joda.time.chrono.GJChronology$CutoverField",
    "signature": "org.joda.time.chrono.GJChronology$CutoverField.get(long)",
    "snippet": "        public int get(long instant) {\n            if (instant >= iCutover) {\n                return iGregorianField.get(instant);\n            } else {\n                return iJulianField.get(instant);\n            }\n        }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 3
  },
  {
    "name": "CutoverField.getDurationField",
    "class_name": "org.joda.time.chrono.GJChronology$CutoverField",
    "signature": "org.joda.time.chrono.GJChronology$CutoverField.getDurationField()",
    "snippet": "        public DurationField getDurationField() {\n            return iDurationField;\n        }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 3
  },
  {
    "name": "CutoverField.getLeapDurationField",
    "class_name": "org.joda.time.chrono.GJChronology$CutoverField",
    "signature": "org.joda.time.chrono.GJChronology$CutoverField.getLeapDurationField()",
    "snippet": "        public DurationField getLeapDurationField() {\n            return iGregorianField.getLeapDurationField();\n        }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 3
  },
  {
    "name": "CutoverField.getMaximumValue",
    "class_name": "org.joda.time.chrono.GJChronology$CutoverField",
    "signature": "org.joda.time.chrono.GJChronology$CutoverField.getMaximumValue()",
    "snippet": "        public int getMaximumValue() {\n            // For all precise fields, the Julian and Gregorian limits are\n            // identical.\n            return iGregorianField.getMaximumValue();\n        }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 3
  },
  {
    "name": "CutoverField.getMinimumValue",
    "class_name": "org.joda.time.chrono.GJChronology$CutoverField",
    "signature": "org.joda.time.chrono.GJChronology$CutoverField.getMinimumValue()",
    "snippet": "        public int getMinimumValue() {\n            // For all precise fields, the Julian and Gregorian limits are\n            // identical. Choose Julian to tighten up the year limits.\n            return iJulianField.getMinimumValue();\n        }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 3
  },
  {
    "name": "CutoverField.getRangeDurationField",
    "class_name": "org.joda.time.chrono.GJChronology$CutoverField",
    "signature": "org.joda.time.chrono.GJChronology$CutoverField.getRangeDurationField()",
    "snippet": "        public DurationField getRangeDurationField() {\n            return iRangeDurationField;\n        }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 3
  },
  {
    "name": "CutoverField.gregorianToJulian",
    "class_name": "org.joda.time.chrono.GJChronology$CutoverField",
    "signature": "org.joda.time.chrono.GJChronology$CutoverField.gregorianToJulian(long)",
    "snippet": "        protected long gregorianToJulian(long instant) {\n            if (iConvertByWeekyear) {\n                return gregorianToJulianByWeekyear(instant);\n            } else {\n                return gregorianToJulianByYear(instant);\n            }\n        }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 3
  },
  {
    "name": "CutoverField.set",
    "class_name": "org.joda.time.chrono.GJChronology$CutoverField",
    "signature": "org.joda.time.chrono.GJChronology$CutoverField.set(long,int)",
    "snippet": "        public long set(long instant, int value) {\n            if (instant >= iCutover) {\n                instant = iGregorianField.set(instant, value);\n                if (instant < iCutover) {\n                    // Only adjust if gap fully crossed.\n                    if (instant + iGapDuration < iCutover) {\n                        instant = gregorianToJulian(instant);\n                    }\n                    // Verify that new value stuck.\n                    if (get(instant) != value) {\n                        throw new IllegalFieldValueException\n                            (iGregorianField.getType(), Integer.valueOf(value), null, null);\n                    }\n                }\n            } else {\n                instant = iJulianField.set(instant, value);\n                if (instant >= iCutover) {\n                    // Only adjust if gap fully crossed.\n                    if (instant - iGapDuration >= iCutover) {\n                        instant = julianToGregorian(instant);\n                    }\n                    // Verify that new value stuck.\n                    if (get(instant) != value) {\n                       throw new IllegalFieldValueException\n                            (iJulianField.getType(), Integer.valueOf(value), null, null);\n                    }\n                }\n            }\n            return instant;\n        }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 3
  },
  {
    "name": "GJDayOfWeekDateTimeField.GJDayOfWeekDateTimeField",
    "class_name": "org.joda.time.chrono.GJDayOfWeekDateTimeField",
    "signature": "org.joda.time.chrono.GJDayOfWeekDateTimeField.GJDayOfWeekDateTimeField(BasicChronology,DurationField)",
    "snippet": "    GJDayOfWeekDateTimeField(BasicChronology chronology, DurationField days) {\n        super(DateTimeFieldType.dayOfWeek(), days);\n        iChronology = chronology;\n    }",
    "comment": " Restricted constructor. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 3
  },
  {
    "name": "GJDayOfWeekDateTimeField.get",
    "class_name": "org.joda.time.chrono.GJDayOfWeekDateTimeField",
    "signature": "org.joda.time.chrono.GJDayOfWeekDateTimeField.get(long)",
    "snippet": "    public int get(long instant) {\n        return iChronology.getDayOfWeek(instant);\n    }",
    "comment": " Get the value of the specified time instant.  @param instant  the time instant in millis to query @return the day of the week extracted from the input ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 3
  },
  {
    "name": "GJDayOfWeekDateTimeField.getMaximumValue",
    "class_name": "org.joda.time.chrono.GJDayOfWeekDateTimeField",
    "signature": "org.joda.time.chrono.GJDayOfWeekDateTimeField.getMaximumValue()",
    "snippet": "    public int getMaximumValue() {\n        return DateTimeConstants.SUNDAY;\n    }",
    "comment": " Get the maximum value that this field can have.  @return the field's maximum value ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 3
  },
  {
    "name": "GJDayOfWeekDateTimeField.getMinimumValue",
    "class_name": "org.joda.time.chrono.GJDayOfWeekDateTimeField",
    "signature": "org.joda.time.chrono.GJDayOfWeekDateTimeField.getMinimumValue()",
    "snippet": "    public int getMinimumValue() {\n        return DateTimeConstants.MONDAY;\n    }",
    "comment": " Get the minimum value that this field can have.  @return the field's minimum value ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 3
  },
  {
    "name": "GJDayOfWeekDateTimeField.getRangeDurationField",
    "class_name": "org.joda.time.chrono.GJDayOfWeekDateTimeField",
    "signature": "org.joda.time.chrono.GJDayOfWeekDateTimeField.getRangeDurationField()",
    "snippet": "    public DurationField getRangeDurationField() {\n        return iChronology.weeks();\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 3
  },
  {
    "name": "GJEraDateTimeField.GJEraDateTimeField",
    "class_name": "org.joda.time.chrono.GJEraDateTimeField",
    "signature": "org.joda.time.chrono.GJEraDateTimeField.GJEraDateTimeField(BasicChronology)",
    "snippet": "    GJEraDateTimeField(BasicChronology chronology) {\n        super(DateTimeFieldType.era());\n        iChronology = chronology;\n    }",
    "comment": " Restricted constructor ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 3
  },
  {
    "name": "GJEraDateTimeField.getDurationField",
    "class_name": "org.joda.time.chrono.GJEraDateTimeField",
    "signature": "org.joda.time.chrono.GJEraDateTimeField.getDurationField()",
    "snippet": "    public DurationField getDurationField() {\n        return UnsupportedDurationField.getInstance(DurationFieldType.eras());\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 3
  },
  {
    "name": "GJEraDateTimeField.getRangeDurationField",
    "class_name": "org.joda.time.chrono.GJEraDateTimeField",
    "signature": "org.joda.time.chrono.GJEraDateTimeField.getRangeDurationField()",
    "snippet": "    public DurationField getRangeDurationField() {\n        return null;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 3
  },
  {
    "name": "GJMonthOfYearDateTimeField.GJMonthOfYearDateTimeField",
    "class_name": "org.joda.time.chrono.GJMonthOfYearDateTimeField",
    "signature": "org.joda.time.chrono.GJMonthOfYearDateTimeField.GJMonthOfYearDateTimeField(BasicChronology)",
    "snippet": "    GJMonthOfYearDateTimeField(BasicChronology chronology) {\n        super(chronology, 2);\n    }",
    "comment": " Restricted constructor ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 3
  },
  {
    "name": "GJYearOfEraDateTimeField.GJYearOfEraDateTimeField",
    "class_name": "org.joda.time.chrono.GJYearOfEraDateTimeField",
    "signature": "org.joda.time.chrono.GJYearOfEraDateTimeField.GJYearOfEraDateTimeField(DateTimeField,BasicChronology)",
    "snippet": "    GJYearOfEraDateTimeField(DateTimeField yearField, BasicChronology chronology) {\n        super(yearField, DateTimeFieldType.yearOfEra());\n        iChronology = chronology;\n    }",
    "comment": " Restricted constructor. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 3
  },
  {
    "name": "GJYearOfEraDateTimeField.getMaximumValue",
    "class_name": "org.joda.time.chrono.GJYearOfEraDateTimeField",
    "signature": "org.joda.time.chrono.GJYearOfEraDateTimeField.getMaximumValue()",
    "snippet": "    public int getMaximumValue() {\n        return getWrappedField().getMaximumValue();\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 3
  },
  {
    "name": "GJYearOfEraDateTimeField.getMinimumValue",
    "class_name": "org.joda.time.chrono.GJYearOfEraDateTimeField",
    "signature": "org.joda.time.chrono.GJYearOfEraDateTimeField.getMinimumValue()",
    "snippet": "    public int getMinimumValue() {\n        return 1;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 3
  },
  {
    "name": "GJYearOfEraDateTimeField.getRangeDurationField",
    "class_name": "org.joda.time.chrono.GJYearOfEraDateTimeField",
    "signature": "org.joda.time.chrono.GJYearOfEraDateTimeField.getRangeDurationField()",
    "snippet": "    @Override\n    public DurationField getRangeDurationField() {\n        return iChronology.eras();\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 3
  },
  {
    "name": "GregorianChronology.assemble",
    "class_name": "org.joda.time.chrono.GregorianChronology",
    "signature": "org.joda.time.chrono.GregorianChronology.assemble(Fields)",
    "snippet": "    protected void assemble(Fields fields) {\n        if (getBase() == null) {\n            super.assemble(fields);\n        }\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 3
  },
  {
    "name": "GregorianChronology.calculateFirstDayOfYearMillis",
    "class_name": "org.joda.time.chrono.GregorianChronology",
    "signature": "org.joda.time.chrono.GregorianChronology.calculateFirstDayOfYearMillis(int)",
    "snippet": "    long calculateFirstDayOfYearMillis(int year) {\n        // Initial value is just temporary.\n        int leapYears = year / 100;\n        if (year < 0) {\n            // Add 3 before shifting right since /4 and >>2 behave differently\n            // on negative numbers. When the expression is written as\n            // (year / 4) - (year / 100) + (year / 400),\n            // it works for both positive and negative values, except this optimization\n            // eliminates two divisions.\n            leapYears = ((year + 3) >> 2) - leapYears + ((leapYears + 3) >> 2) - 1;\n        } else {\n            leapYears = (year >> 2) - leapYears + (leapYears >> 2);\n            if (isLeapYear(year)) {\n                leapYears--;\n            }\n        }\n\n        return (year * 365L + (leapYears - DAYS_0000_TO_1970)) * DateTimeConstants.MILLIS_PER_DAY;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 3
  },
  {
    "name": "GregorianChronology.getApproxMillisAtEpochDividedByTwo",
    "class_name": "org.joda.time.chrono.GregorianChronology",
    "signature": "org.joda.time.chrono.GregorianChronology.getApproxMillisAtEpochDividedByTwo()",
    "snippet": "    long getApproxMillisAtEpochDividedByTwo() {\n        return (1970L * MILLIS_PER_YEAR) / 2;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 3
  },
  {
    "name": "GregorianChronology.getAverageMillisPerMonth",
    "class_name": "org.joda.time.chrono.GregorianChronology",
    "signature": "org.joda.time.chrono.GregorianChronology.getAverageMillisPerMonth()",
    "snippet": "    long getAverageMillisPerMonth() {\n        return MILLIS_PER_MONTH;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 3
  },
  {
    "name": "GregorianChronology.getAverageMillisPerYear",
    "class_name": "org.joda.time.chrono.GregorianChronology",
    "signature": "org.joda.time.chrono.GregorianChronology.getAverageMillisPerYear()",
    "snippet": "    long getAverageMillisPerYear() {\n        return MILLIS_PER_YEAR;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 3
  },
  {
    "name": "GregorianChronology.getAverageMillisPerYearDividedByTwo",
    "class_name": "org.joda.time.chrono.GregorianChronology",
    "signature": "org.joda.time.chrono.GregorianChronology.getAverageMillisPerYearDividedByTwo()",
    "snippet": "    long getAverageMillisPerYearDividedByTwo() {\n        return MILLIS_PER_YEAR / 2;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 3
  },
  {
    "name": "GregorianChronology.getInstance",
    "class_name": "org.joda.time.chrono.GregorianChronology",
    "signature": "org.joda.time.chrono.GregorianChronology.getInstance(DateTimeZone)",
    "snippet": "    public static GregorianChronology getInstance(DateTimeZone zone) {\n        return getInstance(zone, 4);\n    }",
    "comment": " Gets an instance of the GregorianChronology in the given time zone.  @param zone  the time zone to get the chronology in, null is default @return a chronology in the specified time zone ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 3
  },
  {
    "name": "GregorianChronology.getInstance",
    "class_name": "org.joda.time.chrono.GregorianChronology",
    "signature": "org.joda.time.chrono.GregorianChronology.getInstance(DateTimeZone,int)",
    "snippet": "    public static GregorianChronology getInstance(DateTimeZone zone, int minDaysInFirstWeek) {\n        if (zone == null) {\n            zone = DateTimeZone.getDefault();\n        }\n        GregorianChronology chrono;\n        synchronized (cCache) {\n            GregorianChronology[] chronos = cCache.get(zone);\n            if (chronos == null) {\n                chronos = new GregorianChronology[7];\n                cCache.put(zone, chronos);\n            }\n            try {\n                chrono = chronos[minDaysInFirstWeek - 1];\n            } catch (ArrayIndexOutOfBoundsException e) {\n                throw new IllegalArgumentException\n                    (\"Invalid min days in first week: \" + minDaysInFirstWeek);\n            }\n            if (chrono == null) {\n                if (zone == DateTimeZone.UTC) {\n                    chrono = new GregorianChronology(null, null, minDaysInFirstWeek);\n                } else {\n                    chrono = getInstance(DateTimeZone.UTC, minDaysInFirstWeek);\n                    chrono = new GregorianChronology\n                        (ZonedChronology.getInstance(chrono, zone), null, minDaysInFirstWeek);\n                }\n                chronos[minDaysInFirstWeek - 1] = chrono;\n            }\n        }\n        return chrono;\n    }",
    "comment": " Gets an instance of the GregorianChronology in the given time zone.  @param zone  the time zone to get the chronology in, null is default @param minDaysInFirstWeek  minimum number of days in first week of the year; default is 4 @return a chronology in the specified time zone ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 3
  },
  {
    "name": "GregorianChronology.getInstanceUTC",
    "class_name": "org.joda.time.chrono.GregorianChronology",
    "signature": "org.joda.time.chrono.GregorianChronology.getInstanceUTC()",
    "snippet": "    public static GregorianChronology getInstanceUTC() {\n        return INSTANCE_UTC;\n    }",
    "comment": " Gets an instance of the GregorianChronology. The time zone of the returned instance is UTC.  @return a singleton UTC instance of the chronology ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 3
  },
  {
    "name": "GregorianChronology.getMaxYear",
    "class_name": "org.joda.time.chrono.GregorianChronology",
    "signature": "org.joda.time.chrono.GregorianChronology.getMaxYear()",
    "snippet": "    int getMaxYear() {\n        return MAX_YEAR;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 3
  },
  {
    "name": "GregorianChronology.getMinYear",
    "class_name": "org.joda.time.chrono.GregorianChronology",
    "signature": "org.joda.time.chrono.GregorianChronology.getMinYear()",
    "snippet": "    int getMinYear() {\n        return MIN_YEAR;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 3
  },
  {
    "name": "GregorianChronology.isLeapYear",
    "class_name": "org.joda.time.chrono.GregorianChronology",
    "signature": "org.joda.time.chrono.GregorianChronology.isLeapYear(int)",
    "snippet": "    boolean isLeapYear(int year) {\n        return ((year & 3) == 0) && ((year % 100) != 0 || (year % 400) == 0);\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 3
  },
  {
    "name": "GregorianChronology.withUTC",
    "class_name": "org.joda.time.chrono.GregorianChronology",
    "signature": "org.joda.time.chrono.GregorianChronology.withUTC()",
    "snippet": "    public Chronology withUTC() {\n        return INSTANCE_UTC;\n    }",
    "comment": " Gets the Chronology in the UTC time zone.  @return the chronology in UTC ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 3
  },
  {
    "name": "ISOChronology.assemble",
    "class_name": "org.joda.time.chrono.ISOChronology",
    "signature": "org.joda.time.chrono.ISOChronology.assemble(Fields)",
    "snippet": "    protected void assemble(Fields fields) {\n        if (getBase().getZone() == DateTimeZone.UTC) {\n            // Use zero based century and year of century.\n            fields.centuryOfEra = new DividedDateTimeField(\n                ISOYearOfEraDateTimeField.INSTANCE, DateTimeFieldType.centuryOfEra(), 100);\n            fields.centuries = fields.centuryOfEra.getDurationField();\n            \n            fields.yearOfCentury = new RemainderDateTimeField(\n                (DividedDateTimeField) fields.centuryOfEra, DateTimeFieldType.yearOfCentury());\n            fields.weekyearOfCentury = new RemainderDateTimeField(\n                (DividedDateTimeField) fields.centuryOfEra, fields.weekyears, DateTimeFieldType.weekyearOfCentury());\n        }\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 3
  },
  {
    "name": "ISOChronology.getInstance",
    "class_name": "org.joda.time.chrono.ISOChronology",
    "signature": "org.joda.time.chrono.ISOChronology.getInstance()",
    "snippet": "    public static ISOChronology getInstance() {\n        return getInstance(DateTimeZone.getDefault());\n    }",
    "comment": " Gets an instance of the ISOChronology in the default time zone.  @return a chronology in the default time zone ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 3
  },
  {
    "name": "ISOChronology.getInstance",
    "class_name": "org.joda.time.chrono.ISOChronology",
    "signature": "org.joda.time.chrono.ISOChronology.getInstance(DateTimeZone)",
    "snippet": "    public static ISOChronology getInstance(DateTimeZone zone) {\n        if (zone == null) {\n            zone = DateTimeZone.getDefault();\n        }\n        int index = System.identityHashCode(zone) & (FAST_CACHE_SIZE - 1);\n        ISOChronology chrono = cFastCache[index];\n        if (chrono != null && chrono.getZone() == zone) {\n            return chrono;\n        }\n        synchronized (cCache) {\n            chrono = cCache.get(zone);\n            if (chrono == null) {\n                chrono = new ISOChronology(ZonedChronology.getInstance(INSTANCE_UTC, zone));\n                cCache.put(zone, chrono);\n            }\n        }\n        cFastCache[index] = chrono;\n        return chrono;\n    }",
    "comment": " Gets an instance of the ISOChronology in the given time zone.  @param zone  the time zone to get the chronology in, null is default @return a chronology in the specified time zone ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 3
  },
  {
    "name": "ISOChronology.getInstanceUTC",
    "class_name": "org.joda.time.chrono.ISOChronology",
    "signature": "org.joda.time.chrono.ISOChronology.getInstanceUTC()",
    "snippet": "    public static ISOChronology getInstanceUTC() {\n        return INSTANCE_UTC;\n    }",
    "comment": " Gets an instance of the ISOChronology. The time zone of the returned instance is UTC.  @return a singleton UTC instance of the chronology ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 3
  },
  {
    "name": "ISOChronology.withUTC",
    "class_name": "org.joda.time.chrono.ISOChronology",
    "signature": "org.joda.time.chrono.ISOChronology.withUTC()",
    "snippet": "    public Chronology withUTC() {\n        return INSTANCE_UTC;\n    }",
    "comment": " Gets the Chronology in the UTC time zone.  @return the chronology in UTC ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 3
  },
  {
    "name": "ISOYearOfEraDateTimeField.getMaximumValue",
    "class_name": "org.joda.time.chrono.ISOYearOfEraDateTimeField",
    "signature": "org.joda.time.chrono.ISOYearOfEraDateTimeField.getMaximumValue()",
    "snippet": "    public int getMaximumValue() {\n        return getWrappedField().getMaximumValue();\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 3
  },
  {
    "name": "ISOYearOfEraDateTimeField.getMinimumValue",
    "class_name": "org.joda.time.chrono.ISOYearOfEraDateTimeField",
    "signature": "org.joda.time.chrono.ISOYearOfEraDateTimeField.getMinimumValue()",
    "snippet": "    public int getMinimumValue() {\n        return 0;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 3
  },
  {
    "name": "ISOYearOfEraDateTimeField.getRangeDurationField",
    "class_name": "org.joda.time.chrono.ISOYearOfEraDateTimeField",
    "signature": "org.joda.time.chrono.ISOYearOfEraDateTimeField.getRangeDurationField()",
    "snippet": "    @Override\n    public DurationField getRangeDurationField() {\n        return GregorianChronology.getInstanceUTC().eras();\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 3
  },
  {
    "name": "JulianChronology.JulianChronology",
    "class_name": "org.joda.time.chrono.JulianChronology",
    "signature": "org.joda.time.chrono.JulianChronology.JulianChronology(Chronology,Object,int)",
    "snippet": "    JulianChronology(Chronology base, Object param, int minDaysInFirstWeek) {\n        super(base, param, minDaysInFirstWeek);\n    }",
    "comment": " Restricted constructor ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 3
  },
  {
    "name": "JulianChronology.adjustYearForSet",
    "class_name": "org.joda.time.chrono.JulianChronology",
    "signature": "org.joda.time.chrono.JulianChronology.adjustYearForSet(int)",
    "snippet": "    static int adjustYearForSet(int year) {\n        if (year <= 0) {\n            if (year == 0) {\n                throw new IllegalFieldValueException\n                    (DateTimeFieldType.year(), Integer.valueOf(year), null, null);\n            }\n            year++;\n        }\n        return year;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 3
  },
  {
    "name": "JulianChronology.assemble",
    "class_name": "org.joda.time.chrono.JulianChronology",
    "signature": "org.joda.time.chrono.JulianChronology.assemble(Fields)",
    "snippet": "    protected void assemble(Fields fields) {\n        if (getBase() == null) {\n            super.assemble(fields);\n            // Julian chronology has no year zero.\n            fields.year = new SkipDateTimeField(this, fields.year);\n            fields.weekyear = new SkipDateTimeField(this, fields.weekyear);\n        }\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 3
  },
  {
    "name": "JulianChronology.calculateFirstDayOfYearMillis",
    "class_name": "org.joda.time.chrono.JulianChronology",
    "signature": "org.joda.time.chrono.JulianChronology.calculateFirstDayOfYearMillis(int)",
    "snippet": "    long calculateFirstDayOfYearMillis(int year) {\n        // Java epoch is 1970-01-01 Gregorian which is 1969-12-19 Julian.\n        // Calculate relative to the nearest leap year and account for the\n        // difference later.\n\n        int relativeYear = year - 1968;\n        int leapYears;\n        if (relativeYear <= 0) {\n            // Add 3 before shifting right since /4 and >>2 behave differently\n            // on negative numbers.\n            leapYears = (relativeYear + 3) >> 2;\n        } else {\n            leapYears = relativeYear >> 2;\n            // For post 1968 an adjustment is needed as jan1st is before leap day\n            if (!isLeapYear(year)) {\n                leapYears++;\n            }\n        }\n        \n        long millis = (relativeYear * 365L + leapYears) * (long)DateTimeConstants.MILLIS_PER_DAY;\n\n        // Adjust to account for difference between 1968-01-01 and 1969-12-19.\n\n        return millis - (366L + 352) * DateTimeConstants.MILLIS_PER_DAY;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 3
  },
  {
    "name": "JulianChronology.getApproxMillisAtEpochDividedByTwo",
    "class_name": "org.joda.time.chrono.JulianChronology",
    "signature": "org.joda.time.chrono.JulianChronology.getApproxMillisAtEpochDividedByTwo()",
    "snippet": "    long getApproxMillisAtEpochDividedByTwo() {\n        return (1969L * MILLIS_PER_YEAR + 352L * DateTimeConstants.MILLIS_PER_DAY) / 2;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 3
  },
  {
    "name": "JulianChronology.getAverageMillisPerMonth",
    "class_name": "org.joda.time.chrono.JulianChronology",
    "signature": "org.joda.time.chrono.JulianChronology.getAverageMillisPerMonth()",
    "snippet": "    long getAverageMillisPerMonth() {\n        return MILLIS_PER_MONTH;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 3
  },
  {
    "name": "JulianChronology.getAverageMillisPerYear",
    "class_name": "org.joda.time.chrono.JulianChronology",
    "signature": "org.joda.time.chrono.JulianChronology.getAverageMillisPerYear()",
    "snippet": "    long getAverageMillisPerYear() {\n        return MILLIS_PER_YEAR;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 3
  },
  {
    "name": "JulianChronology.getAverageMillisPerYearDividedByTwo",
    "class_name": "org.joda.time.chrono.JulianChronology",
    "signature": "org.joda.time.chrono.JulianChronology.getAverageMillisPerYearDividedByTwo()",
    "snippet": "    long getAverageMillisPerYearDividedByTwo() {\n        return MILLIS_PER_YEAR / 2;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 3
  },
  {
    "name": "JulianChronology.getDateMidnightMillis",
    "class_name": "org.joda.time.chrono.JulianChronology",
    "signature": "org.joda.time.chrono.JulianChronology.getDateMidnightMillis(int,int,int)",
    "snippet": "    long getDateMidnightMillis(int year, int monthOfYear, int dayOfMonth)\n        throws IllegalArgumentException\n    {\n        return super.getDateMidnightMillis(adjustYearForSet(year), monthOfYear, dayOfMonth);\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 3
  },
  {
    "name": "JulianChronology.getInstance",
    "class_name": "org.joda.time.chrono.JulianChronology",
    "signature": "org.joda.time.chrono.JulianChronology.getInstance(DateTimeZone)",
    "snippet": "    public static JulianChronology getInstance(DateTimeZone zone) {\n        return getInstance(zone, 4);\n    }",
    "comment": " Gets an instance of the JulianChronology in the given time zone.  @param zone  the time zone to get the chronology in, null is default @return a chronology in the specified time zone ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 3
  },
  {
    "name": "JulianChronology.getInstance",
    "class_name": "org.joda.time.chrono.JulianChronology",
    "signature": "org.joda.time.chrono.JulianChronology.getInstance(DateTimeZone,int)",
    "snippet": "    public static JulianChronology getInstance(DateTimeZone zone, int minDaysInFirstWeek) {\n        if (zone == null) {\n            zone = DateTimeZone.getDefault();\n        }\n        JulianChronology chrono;\n        synchronized (cCache) {\n            JulianChronology[] chronos = cCache.get(zone);\n            if (chronos == null) {\n                chronos = new JulianChronology[7];\n                cCache.put(zone, chronos);\n            }\n            try {\n                chrono = chronos[minDaysInFirstWeek - 1];\n            } catch (ArrayIndexOutOfBoundsException e) {\n                throw new IllegalArgumentException\n                    (\"Invalid min days in first week: \" + minDaysInFirstWeek);\n            }\n            if (chrono == null) {\n                if (zone == DateTimeZone.UTC) {\n                    chrono = new JulianChronology(null, null, minDaysInFirstWeek);\n                } else {\n                    chrono = getInstance(DateTimeZone.UTC, minDaysInFirstWeek);\n                    chrono = new JulianChronology\n                        (ZonedChronology.getInstance(chrono, zone), null, minDaysInFirstWeek);\n                }\n                chronos[minDaysInFirstWeek - 1] = chrono;\n            }\n        }\n        return chrono;\n    }",
    "comment": " Gets an instance of the JulianChronology in the given time zone.  @param zone  the time zone to get the chronology in, null is default @param minDaysInFirstWeek  minimum number of days in first week of the year; default is 4 @return a chronology in the specified time zone ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 3
  },
  {
    "name": "JulianChronology.getMaxYear",
    "class_name": "org.joda.time.chrono.JulianChronology",
    "signature": "org.joda.time.chrono.JulianChronology.getMaxYear()",
    "snippet": "    int getMaxYear() {\n        return MAX_YEAR;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 3
  },
  {
    "name": "JulianChronology.getMinYear",
    "class_name": "org.joda.time.chrono.JulianChronology",
    "signature": "org.joda.time.chrono.JulianChronology.getMinYear()",
    "snippet": "    int getMinYear() {\n        return MIN_YEAR;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 3
  },
  {
    "name": "JulianChronology.isLeapYear",
    "class_name": "org.joda.time.chrono.JulianChronology",
    "signature": "org.joda.time.chrono.JulianChronology.isLeapYear(int)",
    "snippet": "    boolean isLeapYear(int year) {\n        return (year & 3) == 0;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 3
  },
  {
    "name": "LimitChronology.assemble",
    "class_name": "org.joda.time.chrono.LimitChronology",
    "signature": "org.joda.time.chrono.LimitChronology.assemble(Fields)",
    "snippet": "    protected void assemble(Fields fields) {\n        // Keep a local cache of converted fields so as not to create redundant\n        // objects.\n        HashMap<Object, Object> converted = new HashMap<Object, Object>();\n\n        // Convert duration fields...\n\n        fields.eras = convertField(fields.eras, converted);\n        fields.centuries = convertField(fields.centuries, converted);\n        fields.years = convertField(fields.years, converted);\n        fields.months = convertField(fields.months, converted);\n        fields.weekyears = convertField(fields.weekyears, converted);\n        fields.weeks = convertField(fields.weeks, converted);\n        fields.days = convertField(fields.days, converted);\n\n        fields.halfdays = convertField(fields.halfdays, converted);\n        fields.hours = convertField(fields.hours, converted);\n        fields.minutes = convertField(fields.minutes, converted);\n        fields.seconds = convertField(fields.seconds, converted);\n        fields.millis = convertField(fields.millis, converted);\n\n        // Convert datetime fields...\n\n        fields.year = convertField(fields.year, converted);\n        fields.yearOfEra = convertField(fields.yearOfEra, converted);\n        fields.yearOfCentury = convertField(fields.yearOfCentury, converted);\n        fields.centuryOfEra = convertField(fields.centuryOfEra, converted);\n        fields.era = convertField(fields.era, converted);\n        fields.dayOfWeek = convertField(fields.dayOfWeek, converted);\n        fields.dayOfMonth = convertField(fields.dayOfMonth, converted);\n        fields.dayOfYear = convertField(fields.dayOfYear, converted);\n        fields.monthOfYear = convertField(fields.monthOfYear, converted);\n        fields.weekOfWeekyear = convertField(fields.weekOfWeekyear, converted);\n        fields.weekyear = convertField(fields.weekyear, converted);\n        fields.weekyearOfCentury = convertField(fields.weekyearOfCentury, converted);\n\n        fields.millisOfSecond = convertField(fields.millisOfSecond, converted);\n        fields.millisOfDay = convertField(fields.millisOfDay, converted);\n        fields.secondOfMinute = convertField(fields.secondOfMinute, converted);\n        fields.secondOfDay = convertField(fields.secondOfDay, converted);\n        fields.minuteOfHour = convertField(fields.minuteOfHour, converted);\n        fields.minuteOfDay = convertField(fields.minuteOfDay, converted);\n        fields.hourOfDay = convertField(fields.hourOfDay, converted);\n        fields.hourOfHalfday = convertField(fields.hourOfHalfday, converted);\n        fields.clockhourOfDay = convertField(fields.clockhourOfDay, converted);\n        fields.clockhourOfHalfday = convertField(fields.clockhourOfHalfday, converted);\n        fields.halfdayOfDay = convertField(fields.halfdayOfDay, converted);\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 3
  },
  {
    "name": "LimitChronology.convertField",
    "class_name": "org.joda.time.chrono.LimitChronology",
    "signature": "org.joda.time.chrono.LimitChronology.convertField(DateTimeField,HashMap)",
    "snippet": "    private DateTimeField convertField(DateTimeField field, HashMap<Object, Object> converted) {\n        if (field == null || !field.isSupported()) {\n            return field;\n        }\n        if (converted.containsKey(field)) {\n            return (DateTimeField)converted.get(field);\n        }\n        LimitDateTimeField limitField =\n            new LimitDateTimeField(field,\n                                   convertField(field.getDurationField(), converted),\n                                   convertField(field.getRangeDurationField(), converted),\n                                   convertField(field.getLeapDurationField(), converted));\n        converted.put(field, limitField);\n        return limitField;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 3
  },
  {
    "name": "LimitChronology.convertField",
    "class_name": "org.joda.time.chrono.LimitChronology",
    "signature": "org.joda.time.chrono.LimitChronology.convertField(DurationField,HashMap)",
    "snippet": "    private DurationField convertField(DurationField field, HashMap<Object, Object> converted) {\n        if (field == null || !field.isSupported()) {\n            return field;\n        }\n        if (converted.containsKey(field)) {\n            return (DurationField)converted.get(field);\n        }\n        LimitDurationField limitField = new LimitDurationField(field);\n        converted.put(field, limitField);\n        return limitField;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 3
  },
  {
    "name": "LimitChronology.getInstance",
    "class_name": "org.joda.time.chrono.LimitChronology",
    "signature": "org.joda.time.chrono.LimitChronology.getInstance(Chronology,ReadableDateTime,ReadableDateTime)",
    "snippet": "    public static LimitChronology getInstance(Chronology base,\n                                              ReadableDateTime lowerLimit,\n                                              ReadableDateTime upperLimit) {\n        if (base == null) {\n            throw new IllegalArgumentException(\"Must supply a chronology\");\n        }\n\n        lowerLimit = lowerLimit == null ? null : lowerLimit.toDateTime();\n        upperLimit = upperLimit == null ? null : upperLimit.toDateTime();\n\n        if (lowerLimit != null && upperLimit != null) {\n            if (!lowerLimit.isBefore(upperLimit)) {\n                throw new IllegalArgumentException\n                    (\"The lower limit must be come before than the upper limit\");\n            }\n        }\n\n        return new LimitChronology(base, (DateTime)lowerLimit, (DateTime)upperLimit);\n    }",
    "comment": " Wraps another chronology, with datetime limits. When withUTC or withZone is called, the returned LimitChronology instance has the same limits, except they are time zone adjusted.  @param base  base chronology to wrap @param lowerLimit  inclusive lower limit, or null if none @param upperLimit  exclusive upper limit, or null if none @throws IllegalArgumentException if chronology is null or limits are invalid ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 3
  },
  {
    "name": "LimitDateTimeField.getDurationField",
    "class_name": "org.joda.time.chrono.LimitChronology$LimitDateTimeField",
    "signature": "org.joda.time.chrono.LimitChronology$LimitDateTimeField.getDurationField()",
    "snippet": "        public final DurationField getDurationField() {\n            return iDurationField;\n        }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 3
  },
  {
    "name": "LimitDateTimeField.getLeapDurationField",
    "class_name": "org.joda.time.chrono.LimitChronology$LimitDateTimeField",
    "signature": "org.joda.time.chrono.LimitChronology$LimitDateTimeField.getLeapDurationField()",
    "snippet": "        public final DurationField getLeapDurationField() {\n            return iLeapDurationField;\n        }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 3
  },
  {
    "name": "LimitDateTimeField.getRangeDurationField",
    "class_name": "org.joda.time.chrono.LimitChronology$LimitDateTimeField",
    "signature": "org.joda.time.chrono.LimitChronology$LimitDateTimeField.getRangeDurationField()",
    "snippet": "        public final DurationField getRangeDurationField() {\n            return iRangeDurationField;\n        }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 3
  },
  {
    "name": "ZonedChronology.assemble",
    "class_name": "org.joda.time.chrono.ZonedChronology",
    "signature": "org.joda.time.chrono.ZonedChronology.assemble(Fields)",
    "snippet": "    protected void assemble(Fields fields) {\n        // Keep a local cache of converted fields so as not to create redundant\n        // objects.\n        HashMap<Object, Object> converted = new HashMap<Object, Object>();\n\n        // Convert duration fields...\n\n        fields.eras = convertField(fields.eras, converted);\n        fields.centuries = convertField(fields.centuries, converted);\n        fields.years = convertField(fields.years, converted);\n        fields.months = convertField(fields.months, converted);\n        fields.weekyears = convertField(fields.weekyears, converted);\n        fields.weeks = convertField(fields.weeks, converted);\n        fields.days = convertField(fields.days, converted);\n\n        fields.halfdays = convertField(fields.halfdays, converted);\n        fields.hours = convertField(fields.hours, converted);\n        fields.minutes = convertField(fields.minutes, converted);\n        fields.seconds = convertField(fields.seconds, converted);\n        fields.millis = convertField(fields.millis, converted);\n\n        // Convert datetime fields...\n\n        fields.year = convertField(fields.year, converted);\n        fields.yearOfEra = convertField(fields.yearOfEra, converted);\n        fields.yearOfCentury = convertField(fields.yearOfCentury, converted);\n        fields.centuryOfEra = convertField(fields.centuryOfEra, converted);\n        fields.era = convertField(fields.era, converted);\n        fields.dayOfWeek = convertField(fields.dayOfWeek, converted);\n        fields.dayOfMonth = convertField(fields.dayOfMonth, converted);\n        fields.dayOfYear = convertField(fields.dayOfYear, converted);\n        fields.monthOfYear = convertField(fields.monthOfYear, converted);\n        fields.weekOfWeekyear = convertField(fields.weekOfWeekyear, converted);\n        fields.weekyear = convertField(fields.weekyear, converted);\n        fields.weekyearOfCentury = convertField(fields.weekyearOfCentury, converted);\n\n        fields.millisOfSecond = convertField(fields.millisOfSecond, converted);\n        fields.millisOfDay = convertField(fields.millisOfDay, converted);\n        fields.secondOfMinute = convertField(fields.secondOfMinute, converted);\n        fields.secondOfDay = convertField(fields.secondOfDay, converted);\n        fields.minuteOfHour = convertField(fields.minuteOfHour, converted);\n        fields.minuteOfDay = convertField(fields.minuteOfDay, converted);\n        fields.hourOfDay = convertField(fields.hourOfDay, converted);\n        fields.hourOfHalfday = convertField(fields.hourOfHalfday, converted);\n        fields.clockhourOfDay = convertField(fields.clockhourOfDay, converted);\n        fields.clockhourOfHalfday = convertField(fields.clockhourOfHalfday, converted);\n        fields.halfdayOfDay = convertField(fields.halfdayOfDay, converted);\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 3
  },
  {
    "name": "ZonedChronology.convertField",
    "class_name": "org.joda.time.chrono.ZonedChronology",
    "signature": "org.joda.time.chrono.ZonedChronology.convertField(DateTimeField,HashMap)",
    "snippet": "    private DateTimeField convertField(DateTimeField field, HashMap<Object, Object> converted) {\n        if (field == null || !field.isSupported()) {\n            return field;\n        }\n        if (converted.containsKey(field)) {\n            return (DateTimeField)converted.get(field);\n        }\n        ZonedDateTimeField zonedField =\n            new ZonedDateTimeField(field, getZone(),\n                                   convertField(field.getDurationField(), converted),\n                                   convertField(field.getRangeDurationField(), converted),\n                                   convertField(field.getLeapDurationField(), converted));\n        converted.put(field, zonedField);\n        return zonedField;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 3
  },
  {
    "name": "ZonedChronology.convertField",
    "class_name": "org.joda.time.chrono.ZonedChronology",
    "signature": "org.joda.time.chrono.ZonedChronology.convertField(DurationField,HashMap)",
    "snippet": "    private DurationField convertField(DurationField field, HashMap<Object, Object> converted) {\n        if (field == null || !field.isSupported()) {\n            return field;\n        }\n        if (converted.containsKey(field)) {\n            return (DurationField)converted.get(field);\n        }\n        ZonedDurationField zonedField = new ZonedDurationField(field, getZone());\n        converted.put(field, zonedField);\n        return zonedField;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 3
  },
  {
    "name": "ZonedChronology.getInstance",
    "class_name": "org.joda.time.chrono.ZonedChronology",
    "signature": "org.joda.time.chrono.ZonedChronology.getInstance(Chronology,DateTimeZone)",
    "snippet": "    public static ZonedChronology getInstance(Chronology base, DateTimeZone zone) {\n        if (base == null) {\n            throw new IllegalArgumentException(\"Must supply a chronology\");\n        }\n        base = base.withUTC();\n        if (base == null) {\n            throw new IllegalArgumentException(\"UTC chronology must not be null\");\n        }\n        if (zone == null) {\n            throw new IllegalArgumentException(\"DateTimeZone must not be null\");\n        }\n        return new ZonedChronology(base, zone);\n    }",
    "comment": " Create a ZonedChronology for any chronology, overriding any time zone it may already have.  @param base base chronology to wrap @param zone the time zone @throws IllegalArgumentException if chronology or time zone is null ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 3
  },
  {
    "name": "ZonedChronology.getZone",
    "class_name": "org.joda.time.chrono.ZonedChronology",
    "signature": "org.joda.time.chrono.ZonedChronology.getZone()",
    "snippet": "    public DateTimeZone getZone() {\n        return (DateTimeZone)getParam();\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 3
  },
  {
    "name": "ZonedChronology.useTimeArithmetic",
    "class_name": "org.joda.time.chrono.ZonedChronology",
    "signature": "org.joda.time.chrono.ZonedChronology.useTimeArithmetic(DurationField)",
    "snippet": "    static boolean useTimeArithmetic(DurationField field) {\n        // Use time of day arithmetic rules for unit durations less than\n        // typical time zone offsets.\n        return field != null && field.getUnitMillis() < DateTimeConstants.MILLIS_PER_HOUR * 12;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 3
  },
  {
    "name": "ZonedDateTimeField.get",
    "class_name": "org.joda.time.chrono.ZonedChronology$ZonedDateTimeField",
    "signature": "org.joda.time.chrono.ZonedChronology$ZonedDateTimeField.get(long)",
    "snippet": "        public int get(long instant) {\n            long localInstant = iZone.convertUTCToLocal(instant);\n            return iField.get(localInstant);\n        }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 3
  },
  {
    "name": "ZonedDateTimeField.getDurationField",
    "class_name": "org.joda.time.chrono.ZonedChronology$ZonedDateTimeField",
    "signature": "org.joda.time.chrono.ZonedChronology$ZonedDateTimeField.getDurationField()",
    "snippet": "        public final DurationField getDurationField() {\n            return iDurationField;\n        }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 3
  },
  {
    "name": "ZonedDateTimeField.getLeapDurationField",
    "class_name": "org.joda.time.chrono.ZonedChronology$ZonedDateTimeField",
    "signature": "org.joda.time.chrono.ZonedChronology$ZonedDateTimeField.getLeapDurationField()",
    "snippet": "        public final DurationField getLeapDurationField() {\n            return iLeapDurationField;\n        }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 3
  },
  {
    "name": "ZonedDateTimeField.getMaximumValue",
    "class_name": "org.joda.time.chrono.ZonedChronology$ZonedDateTimeField",
    "signature": "org.joda.time.chrono.ZonedChronology$ZonedDateTimeField.getMaximumValue()",
    "snippet": "        public int getMaximumValue() {\n            return iField.getMaximumValue();\n        }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 3
  },
  {
    "name": "ZonedDateTimeField.getMinimumValue",
    "class_name": "org.joda.time.chrono.ZonedChronology$ZonedDateTimeField",
    "signature": "org.joda.time.chrono.ZonedChronology$ZonedDateTimeField.getMinimumValue()",
    "snippet": "        public int getMinimumValue() {\n            return iField.getMinimumValue();\n        }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 3
  },
  {
    "name": "ZonedDateTimeField.getRangeDurationField",
    "class_name": "org.joda.time.chrono.ZonedChronology$ZonedDateTimeField",
    "signature": "org.joda.time.chrono.ZonedChronology$ZonedDateTimeField.getRangeDurationField()",
    "snippet": "        public final DurationField getRangeDurationField() {\n            return iRangeDurationField;\n        }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 3
  },
  {
    "name": "ZonedDateTimeField.hashCode",
    "class_name": "org.joda.time.chrono.ZonedChronology$ZonedDateTimeField",
    "signature": "org.joda.time.chrono.ZonedChronology$ZonedDateTimeField.hashCode()",
    "snippet": "        @Override\n        public int hashCode() {\n            return iField.hashCode() ^ iZone.hashCode();\n        }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 3
  },
  {
    "name": "ZonedDateTimeField.set",
    "class_name": "org.joda.time.chrono.ZonedChronology$ZonedDateTimeField",
    "signature": "org.joda.time.chrono.ZonedChronology$ZonedDateTimeField.set(long,int)",
    "snippet": "        public long set(long instant, int value) {\n            long localInstant = iZone.convertUTCToLocal(instant);\n            localInstant = iField.set(localInstant, value);\n            long result = iZone.convertLocalToUTC(localInstant, false, instant);\n            if (get(result) != value) {\n                IllegalInstantException cause = new IllegalInstantException(localInstant,  iZone.getID());\n                IllegalFieldValueException ex = new IllegalFieldValueException(iField.getType(), Integer.valueOf(value), cause.getMessage());\n                ex.initCause(cause);\n                throw ex;\n            }\n            return result;\n        }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 3
  },
  {
    "name": "ZonedDurationField.getUnitMillis",
    "class_name": "org.joda.time.chrono.ZonedChronology$ZonedDurationField",
    "signature": "org.joda.time.chrono.ZonedChronology$ZonedDurationField.getUnitMillis()",
    "snippet": "        public long getUnitMillis() {\n            return iField.getUnitMillis();\n        }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 3
  },
  {
    "name": "ZonedDurationField.hashCode",
    "class_name": "org.joda.time.chrono.ZonedChronology$ZonedDurationField",
    "signature": "org.joda.time.chrono.ZonedChronology$ZonedDurationField.hashCode()",
    "snippet": "        @Override\n        public int hashCode() {\n            return iField.hashCode() ^ iZone.hashCode();\n        }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 3
  },
  {
    "name": "BaseDateTimeField.BaseDateTimeField",
    "class_name": "org.joda.time.field.BaseDateTimeField",
    "signature": "org.joda.time.field.BaseDateTimeField.BaseDateTimeField(DateTimeFieldType)",
    "snippet": "    protected BaseDateTimeField(DateTimeFieldType type) {\n        super();\n        if (type == null) {\n            throw new IllegalArgumentException(\"The type must not be null\");\n        }\n        iType = type;\n    }",
    "comment": " Constructor. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 3
  },
  {
    "name": "BaseDateTimeField.getLeapDurationField",
    "class_name": "org.joda.time.field.BaseDateTimeField",
    "signature": "org.joda.time.field.BaseDateTimeField.getLeapDurationField()",
    "snippet": "    public DurationField getLeapDurationField() {\n        return null;\n    }",
    "comment": " If this field were to leap, then it would be in units described by the returned duration. If this field doesn't ever leap, null is returned. <p> This implementation returns null. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 3
  },
  {
    "name": "BaseDateTimeField.getMaximumValue",
    "class_name": "org.joda.time.field.BaseDateTimeField",
    "signature": "org.joda.time.field.BaseDateTimeField.getMaximumValue(ReadablePartial)",
    "snippet": "    public int getMaximumValue(ReadablePartial instant) {\n        return getMaximumValue();\n    }",
    "comment": " Get the maximum value for this field evaluated at the specified instant. <p> This implementation returns the same as {@link #getMaximumValue()}.  @param instant  the partial instant to query @return the maximum value for this field, in the units of the field ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 3
  },
  {
    "name": "BaseDateTimeField.getMaximumValue",
    "class_name": "org.joda.time.field.BaseDateTimeField",
    "signature": "org.joda.time.field.BaseDateTimeField.getMaximumValue(ReadablePartial,int[])",
    "snippet": "    public int getMaximumValue(ReadablePartial instant, int[] values) {\n        return getMaximumValue(instant);\n    }",
    "comment": " Get the maximum value for this field using the partial instant and the specified values. <p> This implementation returns the same as {@link #getMaximumValue(ReadablePartial)}.  @param instant  the partial instant to query @param values  the values to use @return the maximum value for this field, in the units of the field ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 3
  },
  {
    "name": "BaseDateTimeField.getMaximumValue",
    "class_name": "org.joda.time.field.BaseDateTimeField",
    "signature": "org.joda.time.field.BaseDateTimeField.getMaximumValue(long)",
    "snippet": "    public int getMaximumValue(long instant) {\n        return getMaximumValue();\n    }",
    "comment": " Get the maximum value for this field evaluated at the specified time. <p> This implementation returns the same as {@link #getMaximumValue()}.  @param instant  the milliseconds from 1970-01-01T00:00:00Z to query @return the maximum value for this field, in the units of the field ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 3
  },
  {
    "name": "BaseDateTimeField.getMinimumValue",
    "class_name": "org.joda.time.field.BaseDateTimeField",
    "signature": "org.joda.time.field.BaseDateTimeField.getMinimumValue(ReadablePartial)",
    "snippet": "    public int getMinimumValue(ReadablePartial instant) {\n        return getMinimumValue();\n    }",
    "comment": " Get the minimum value for this field evaluated at the specified instant. <p> This implementation returns the same as {@link #getMinimumValue()}.  @param instant  the partial instant to query @return the minimum value for this field, in the units of the field ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 3
  },
  {
    "name": "BaseDateTimeField.getMinimumValue",
    "class_name": "org.joda.time.field.BaseDateTimeField",
    "signature": "org.joda.time.field.BaseDateTimeField.getMinimumValue(ReadablePartial,int[])",
    "snippet": "    public int getMinimumValue(ReadablePartial instant, int[] values) {\n        return getMinimumValue(instant);\n    }",
    "comment": " Get the minimum value for this field using the partial instant and the specified values. <p> This implementation returns the same as {@link #getMinimumValue(ReadablePartial)}.  @param instant  the partial instant to query @param values  the values to use @return the minimum value for this field, in the units of the field ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 3
  },
  {
    "name": "BaseDateTimeField.getType",
    "class_name": "org.joda.time.field.BaseDateTimeField",
    "signature": "org.joda.time.field.BaseDateTimeField.getType()",
    "snippet": "    public final DateTimeFieldType getType() {\n        return iType;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 3
  },
  {
    "name": "BaseDateTimeField.isSupported",
    "class_name": "org.joda.time.field.BaseDateTimeField",
    "signature": "org.joda.time.field.BaseDateTimeField.isSupported()",
    "snippet": "    public final boolean isSupported() {\n        return true;\n    }",
    "comment": " @return true always ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 3
  },
  {
    "name": "BaseDateTimeField.roundCeiling",
    "class_name": "org.joda.time.field.BaseDateTimeField",
    "signature": "org.joda.time.field.BaseDateTimeField.roundCeiling(long)",
    "snippet": "    public long roundCeiling(long instant) {\n        long newInstant = roundFloor(instant);\n        if (newInstant != instant) {\n            instant = add(newInstant, 1);\n        }\n        return instant;\n    }",
    "comment": " Round to the highest whole unit of this field. The value of this field and all fields of a higher magnitude may be incremented in order to achieve this result. The fractional millis that cannot be expressed in whole increments of this field are set to minimum. <p> For example, a datetime of 2002-11-02T23:34:56.789, rounded to the highest whole hour is 2002-11-03T00:00:00.000. <p> The default implementation calls roundFloor, and if the instant is modified as a result, adds one field unit. Subclasses are encouraged to provide a more efficient implementation.  @param instant  the milliseconds from 1970-01-01T00:00:00Z to round @return rounded milliseconds ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 3
  },
  {
    "name": "BaseDurationField.BaseDurationField",
    "class_name": "org.joda.time.field.BaseDurationField",
    "signature": "org.joda.time.field.BaseDurationField.BaseDurationField(DurationFieldType)",
    "snippet": "    protected BaseDurationField(DurationFieldType type) {\n        super();\n        if (type == null) {\n            throw new IllegalArgumentException(\"The type must not be null\");\n        }\n        iType = type;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 3
  },
  {
    "name": "BaseDurationField.getType",
    "class_name": "org.joda.time.field.BaseDurationField",
    "signature": "org.joda.time.field.BaseDurationField.getType()",
    "snippet": "    public final DurationFieldType getType() {\n        return iType;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 3
  },
  {
    "name": "BaseDurationField.isSupported",
    "class_name": "org.joda.time.field.BaseDurationField",
    "signature": "org.joda.time.field.BaseDurationField.isSupported()",
    "snippet": "    public final boolean isSupported() {\n        return true;\n    }",
    "comment": " @return true always ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 3
  },
  {
    "name": "DecoratedDateTimeField.DecoratedDateTimeField",
    "class_name": "org.joda.time.field.DecoratedDateTimeField",
    "signature": "org.joda.time.field.DecoratedDateTimeField.DecoratedDateTimeField(DateTimeField,DateTimeFieldType)",
    "snippet": "    protected DecoratedDateTimeField(DateTimeField field, DateTimeFieldType type) {\n        super(type);\n        if (field == null) {\n            throw new IllegalArgumentException(\"The field must not be null\");\n        }\n        if (!field.isSupported()) {\n            throw new IllegalArgumentException(\"The field must be supported\");\n        }\n        iField = field;\n    }",
    "comment": " Constructor.  @param field  the field being decorated @param type  allow type to be overridden ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 3
  },
  {
    "name": "DecoratedDateTimeField.getDurationField",
    "class_name": "org.joda.time.field.DecoratedDateTimeField",
    "signature": "org.joda.time.field.DecoratedDateTimeField.getDurationField()",
    "snippet": "    public DurationField getDurationField() {\n        return iField.getDurationField();\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 3
  },
  {
    "name": "DecoratedDateTimeField.getRangeDurationField",
    "class_name": "org.joda.time.field.DecoratedDateTimeField",
    "signature": "org.joda.time.field.DecoratedDateTimeField.getRangeDurationField()",
    "snippet": "    public DurationField getRangeDurationField() {\n        return iField.getRangeDurationField();\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 3
  },
  {
    "name": "DecoratedDateTimeField.getWrappedField",
    "class_name": "org.joda.time.field.DecoratedDateTimeField",
    "signature": "org.joda.time.field.DecoratedDateTimeField.getWrappedField()",
    "snippet": "    public final DateTimeField getWrappedField() {\n        return iField;\n    }",
    "comment": " Gets the wrapped date time field.  @return the wrapped DateTimeField ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 3
  },
  {
    "name": "DecoratedDateTimeField.set",
    "class_name": "org.joda.time.field.DecoratedDateTimeField",
    "signature": "org.joda.time.field.DecoratedDateTimeField.set(long,int)",
    "snippet": "    public long set(long instant, int value) {\n        return iField.set(instant, value);\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 3
  },
  {
    "name": "DecoratedDurationField.DecoratedDurationField",
    "class_name": "org.joda.time.field.DecoratedDurationField",
    "signature": "org.joda.time.field.DecoratedDurationField.DecoratedDurationField(DurationField,DurationFieldType)",
    "snippet": "    public DecoratedDurationField(DurationField field, DurationFieldType type) {\n        super(type);\n        if (field == null) {\n            throw new IllegalArgumentException(\"The field must not be null\");\n        }\n        if (!field.isSupported()) {\n            throw new IllegalArgumentException(\"The field must be supported\");\n        }\n        iField = field;\n    }",
    "comment": " Constructor.  @param field  the base field @param type  the type to actually use ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 3
  },
  {
    "name": "DecoratedDurationField.getUnitMillis",
    "class_name": "org.joda.time.field.DecoratedDurationField",
    "signature": "org.joda.time.field.DecoratedDurationField.getUnitMillis()",
    "snippet": "    public long getUnitMillis() {\n        return iField.getUnitMillis();\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 3
  },
  {
    "name": "DecoratedDurationField.getWrappedField",
    "class_name": "org.joda.time.field.DecoratedDurationField",
    "signature": "org.joda.time.field.DecoratedDurationField.getWrappedField()",
    "snippet": "    public final DurationField getWrappedField() {\n        return iField;\n    }",
    "comment": " Gets the wrapped duration field.  @return the wrapped DurationField ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 3
  },
  {
    "name": "DelegatedDateTimeField.DelegatedDateTimeField",
    "class_name": "org.joda.time.field.DelegatedDateTimeField",
    "signature": "org.joda.time.field.DelegatedDateTimeField.DelegatedDateTimeField(DateTimeField)",
    "snippet": "    public DelegatedDateTimeField(DateTimeField field) {\n        this(field, null);\n    }",
    "comment": " Constructor.  @param field  the field being decorated ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 3
  },
  {
    "name": "DelegatedDateTimeField.DelegatedDateTimeField",
    "class_name": "org.joda.time.field.DelegatedDateTimeField",
    "signature": "org.joda.time.field.DelegatedDateTimeField.DelegatedDateTimeField(DateTimeField,DateTimeFieldType)",
    "snippet": "    public DelegatedDateTimeField(DateTimeField field, DateTimeFieldType type) {\n        this(field, null, type);\n    }",
    "comment": " Constructor.  @param field  the field being decorated @param type  the field type override ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 3
  },
  {
    "name": "DelegatedDateTimeField.DelegatedDateTimeField",
    "class_name": "org.joda.time.field.DelegatedDateTimeField",
    "signature": "org.joda.time.field.DelegatedDateTimeField.DelegatedDateTimeField(DateTimeField,DurationField,DateTimeFieldType)",
    "snippet": "    public DelegatedDateTimeField(DateTimeField field, DurationField rangeField, DateTimeFieldType type) {\n        super();\n        if (field == null) {\n            throw new IllegalArgumentException(\"The field must not be null\");\n        }\n        iField = field;\n        iRangeDurationField = rangeField;\n        iType = (type == null ? field.getType() : type);\n    }",
    "comment": " Constructor.  @param field  the field being decorated @param rangeField  the range field, null to derive @param type  the field type override ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 3
  },
  {
    "name": "DelegatedDateTimeField.get",
    "class_name": "org.joda.time.field.DelegatedDateTimeField",
    "signature": "org.joda.time.field.DelegatedDateTimeField.get(long)",
    "snippet": "    public int get(long instant) {\n        return iField.get(instant);\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 3
  },
  {
    "name": "DelegatedDateTimeField.getDurationField",
    "class_name": "org.joda.time.field.DelegatedDateTimeField",
    "signature": "org.joda.time.field.DelegatedDateTimeField.getDurationField()",
    "snippet": "    public DurationField getDurationField() {\n        return iField.getDurationField();\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 3
  },
  {
    "name": "DelegatedDateTimeField.getLeapDurationField",
    "class_name": "org.joda.time.field.DelegatedDateTimeField",
    "signature": "org.joda.time.field.DelegatedDateTimeField.getLeapDurationField()",
    "snippet": "    public DurationField getLeapDurationField() {\n        return iField.getLeapDurationField();\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 3
  },
  {
    "name": "DelegatedDateTimeField.getMaximumValue",
    "class_name": "org.joda.time.field.DelegatedDateTimeField",
    "signature": "org.joda.time.field.DelegatedDateTimeField.getMaximumValue()",
    "snippet": "    public int getMaximumValue() {\n        return iField.getMaximumValue();\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 3
  },
  {
    "name": "DelegatedDateTimeField.getMinimumValue",
    "class_name": "org.joda.time.field.DelegatedDateTimeField",
    "signature": "org.joda.time.field.DelegatedDateTimeField.getMinimumValue()",
    "snippet": "    public int getMinimumValue() {\n        return iField.getMinimumValue();\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 3
  },
  {
    "name": "DelegatedDateTimeField.getRangeDurationField",
    "class_name": "org.joda.time.field.DelegatedDateTimeField",
    "signature": "org.joda.time.field.DelegatedDateTimeField.getRangeDurationField()",
    "snippet": "    public DurationField getRangeDurationField() {\n        if (iRangeDurationField != null) {\n            return iRangeDurationField;\n        }\n        return iField.getRangeDurationField();\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 3
  },
  {
    "name": "DelegatedDateTimeField.getType",
    "class_name": "org.joda.time.field.DelegatedDateTimeField",
    "signature": "org.joda.time.field.DelegatedDateTimeField.getType()",
    "snippet": "    public DateTimeFieldType getType() {\n        return iType;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 3
  },
  {
    "name": "DelegatedDateTimeField.isSupported",
    "class_name": "org.joda.time.field.DelegatedDateTimeField",
    "signature": "org.joda.time.field.DelegatedDateTimeField.isSupported()",
    "snippet": "    public boolean isSupported() {\n        return iField.isSupported();\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 3
  },
  {
    "name": "DelegatedDateTimeField.set",
    "class_name": "org.joda.time.field.DelegatedDateTimeField",
    "signature": "org.joda.time.field.DelegatedDateTimeField.set(long,int)",
    "snippet": "    public long set(long instant, int value) {\n        return iField.set(instant, value);\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 3
  },
  {
    "name": "DividedDateTimeField.DividedDateTimeField",
    "class_name": "org.joda.time.field.DividedDateTimeField",
    "signature": "org.joda.time.field.DividedDateTimeField.DividedDateTimeField(DateTimeField,DateTimeFieldType,int)",
    "snippet": "    public DividedDateTimeField(DateTimeField field,\n                                DateTimeFieldType type, int divisor) {\n        this(field, field.getRangeDurationField(), type, divisor);\n    }",
    "comment": " Constructor.  @param field  the field to wrap, like \"year()\". @param type  the field type this field will actually use @param divisor  divisor, such as 100 years in a century @throws IllegalArgumentException if divisor is less than two ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 3
  },
  {
    "name": "DividedDateTimeField.DividedDateTimeField",
    "class_name": "org.joda.time.field.DividedDateTimeField",
    "signature": "org.joda.time.field.DividedDateTimeField.DividedDateTimeField(DateTimeField,DurationField,DateTimeFieldType,int)",
    "snippet": "    public DividedDateTimeField(DateTimeField field, DurationField rangeField,\n                                DateTimeFieldType type, int divisor) {\n        super(field, type);\n        if (divisor < 2) {\n            throw new IllegalArgumentException(\"The divisor must be at least 2\");\n        }\n        DurationField unitField = field.getDurationField();\n        if (unitField == null) {\n            iDurationField = null;\n        } else {\n            iDurationField = new ScaledDurationField(\n                unitField, type.getDurationType(), divisor);\n        }\n        iRangeDurationField = rangeField;\n        iDivisor = divisor;\n        int i = field.getMinimumValue();\n        int min = (i >= 0) ? i / divisor : ((i + 1) / divisor - 1);\n        int j = field.getMaximumValue();\n        int max = (j >= 0) ? j / divisor : ((j + 1) / divisor - 1);\n        iMin = min;\n        iMax = max;\n    }",
    "comment": " Constructor.  @param field  the field to wrap, like \"year()\". @param rangeField  the range field, null to derive @param type  the field type this field will actually use @param divisor  divisor, such as 100 years in a century @throws IllegalArgumentException if divisor is less than two ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 3
  },
  {
    "name": "DividedDateTimeField.getDurationField",
    "class_name": "org.joda.time.field.DividedDateTimeField",
    "signature": "org.joda.time.field.DividedDateTimeField.getDurationField()",
    "snippet": "    public DurationField getDurationField() {\n        return iDurationField;\n    }",
    "comment": " Returns a scaled version of the wrapped field's unit duration field. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 3
  },
  {
    "name": "DividedDateTimeField.getRangeDurationField",
    "class_name": "org.joda.time.field.DividedDateTimeField",
    "signature": "org.joda.time.field.DividedDateTimeField.getRangeDurationField()",
    "snippet": "    @Override\n    public DurationField getRangeDurationField() {\n        if (iRangeDurationField != null) {\n            return iRangeDurationField;\n        }\n        return super.getRangeDurationField();\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 3
  },
  {
    "name": "FieldUtils.verifyValueBounds",
    "class_name": "org.joda.time.field.FieldUtils",
    "signature": "org.joda.time.field.FieldUtils.verifyValueBounds(DateTimeField,int,int,int)",
    "snippet": "    public static void verifyValueBounds(DateTimeField field, \n                                         int value, int lowerBound, int upperBound) {\n        if ((value < lowerBound) || (value > upperBound)) {\n            throw new IllegalFieldValueException\n                (field.getType(), Integer.valueOf(value),\n                 Integer.valueOf(lowerBound), Integer.valueOf(upperBound));\n        }\n    }",
    "comment": " Verify that input values are within specified bounds.  @param value  the value to check @param lowerBound  the lower bound allowed for value @param upperBound  the upper bound allowed for value @throws IllegalFieldValueException if value is not in the specified bounds ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 3
  },
  {
    "name": "FieldUtils.verifyValueBounds",
    "class_name": "org.joda.time.field.FieldUtils",
    "signature": "org.joda.time.field.FieldUtils.verifyValueBounds(DateTimeFieldType,int,int,int)",
    "snippet": "    public static void verifyValueBounds(DateTimeFieldType fieldType, \n                                         int value, int lowerBound, int upperBound) {\n        if ((value < lowerBound) || (value > upperBound)) {\n            throw new IllegalFieldValueException\n                (fieldType, Integer.valueOf(value),\n                 Integer.valueOf(lowerBound), Integer.valueOf(upperBound));\n        }\n    }",
    "comment": " Verify that input values are within specified bounds.  @param value  the value to check @param lowerBound  the lower bound allowed for value @param upperBound  the upper bound allowed for value @throws IllegalFieldValueException if value is not in the specified bounds @since 1.1 ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 3
  },
  {
    "name": "ImpreciseDateTimeField.ImpreciseDateTimeField",
    "class_name": "org.joda.time.field.ImpreciseDateTimeField",
    "signature": "org.joda.time.field.ImpreciseDateTimeField.ImpreciseDateTimeField(DateTimeFieldType,long)",
    "snippet": "    public ImpreciseDateTimeField(DateTimeFieldType type, long unitMillis) {\n        super(type);\n        iUnitMillis = unitMillis;\n        iDurationField = new LinkedDurationField(type.getDurationType());\n    }",
    "comment": " Constructor.  @param type  the field type @param unitMillis  the average duration unit milliseconds ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 3
  },
  {
    "name": "ImpreciseDateTimeField.getDurationField",
    "class_name": "org.joda.time.field.ImpreciseDateTimeField",
    "signature": "org.joda.time.field.ImpreciseDateTimeField.getDurationField()",
    "snippet": "    public final DurationField getDurationField() {\n        return iDurationField;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 3
  },
  {
    "name": "LinkedDurationField.getUnitMillis",
    "class_name": "org.joda.time.field.ImpreciseDateTimeField$LinkedDurationField",
    "signature": "org.joda.time.field.ImpreciseDateTimeField$LinkedDurationField.getUnitMillis()",
    "snippet": "        public long getUnitMillis() {\n            return iUnitMillis;\n        }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 3
  },
  {
    "name": "MillisDurationField.getType",
    "class_name": "org.joda.time.field.MillisDurationField",
    "signature": "org.joda.time.field.MillisDurationField.getType()",
    "snippet": "    public DurationFieldType getType() {\n        return DurationFieldType.millis();\n    }",
    "comment": "------------------------------------------------------------------------",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 3
  },
  {
    "name": "MillisDurationField.getUnitMillis",
    "class_name": "org.joda.time.field.MillisDurationField",
    "signature": "org.joda.time.field.MillisDurationField.getUnitMillis()",
    "snippet": "    public final long getUnitMillis() {\n        return 1;\n    }",
    "comment": " Returns the amount of milliseconds per unit value of this field.  @return one always ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 3
  },
  {
    "name": "MillisDurationField.hashCode",
    "class_name": "org.joda.time.field.MillisDurationField",
    "signature": "org.joda.time.field.MillisDurationField.hashCode()",
    "snippet": "    public int hashCode() {\n        return (int) getUnitMillis();\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 3
  },
  {
    "name": "MillisDurationField.isPrecise",
    "class_name": "org.joda.time.field.MillisDurationField",
    "signature": "org.joda.time.field.MillisDurationField.isPrecise()",
    "snippet": "    public final boolean isPrecise() {\n        return true;\n    }",
    "comment": " Returns true as this field is precise.  @return true always ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 3
  },
  {
    "name": "MillisDurationField.isSupported",
    "class_name": "org.joda.time.field.MillisDurationField",
    "signature": "org.joda.time.field.MillisDurationField.isSupported()",
    "snippet": "    public boolean isSupported() {\n        return true;\n    }",
    "comment": " Returns true as this field is supported.  @return true always ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 3
  },
  {
    "name": "OffsetDateTimeField.OffsetDateTimeField",
    "class_name": "org.joda.time.field.OffsetDateTimeField",
    "signature": "org.joda.time.field.OffsetDateTimeField.OffsetDateTimeField(DateTimeField,DateTimeFieldType,int)",
    "snippet": "    public OffsetDateTimeField(DateTimeField field, DateTimeFieldType type, int offset) {\n        this(field, type, offset, Integer.MIN_VALUE, Integer.MAX_VALUE);\n    }",
    "comment": " Constructor.  @param field  the field to wrap, like \"year()\". @param type  the field type this field actually uses @param offset  offset to add to field values @throws IllegalArgumentException if offset is zero ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 3
  },
  {
    "name": "OffsetDateTimeField.OffsetDateTimeField",
    "class_name": "org.joda.time.field.OffsetDateTimeField",
    "signature": "org.joda.time.field.OffsetDateTimeField.OffsetDateTimeField(DateTimeField,DateTimeFieldType,int,int,int)",
    "snippet": "    public OffsetDateTimeField(DateTimeField field, DateTimeFieldType type, int offset,\n                               int minValue, int maxValue) {\n        super(field, type);\n                \n        if (offset == 0) {\n            throw new IllegalArgumentException(\"The offset cannot be zero\");\n        }\n\n        iOffset = offset;\n\n        if (minValue < (field.getMinimumValue() + offset)) {\n            iMin = field.getMinimumValue() + offset;\n        } else {\n            iMin = minValue;\n        }\n        if (maxValue > (field.getMaximumValue() + offset)) {\n            iMax = field.getMaximumValue() + offset;\n        } else {\n            iMax = maxValue;\n        }\n    }",
    "comment": " Constructor.  @param field  the field to wrap, like \"year()\". @param type  the field type this field actually uses @param offset  offset to add to field values @param minValue  minimum allowed value @param maxValue  maximum allowed value @throws IllegalArgumentException if offset is zero ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 3
  },
  {
    "name": "OffsetDateTimeField.OffsetDateTimeField",
    "class_name": "org.joda.time.field.OffsetDateTimeField",
    "signature": "org.joda.time.field.OffsetDateTimeField.OffsetDateTimeField(DateTimeField,int)",
    "snippet": "    public OffsetDateTimeField(DateTimeField field, int offset) {\n        this(field, (field == null ? null : field.getType()), offset, Integer.MIN_VALUE, Integer.MAX_VALUE);\n    }",
    "comment": " Constructor.  @param field  the field to wrap, like \"year()\". @param offset  offset to add to field values @throws IllegalArgumentException if offset is zero ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 3
  },
  {
    "name": "OffsetDateTimeField.getLeapDurationField",
    "class_name": "org.joda.time.field.OffsetDateTimeField",
    "signature": "org.joda.time.field.OffsetDateTimeField.getLeapDurationField()",
    "snippet": "    public DurationField getLeapDurationField() {\n        return getWrappedField().getLeapDurationField();\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 3
  },
  {
    "name": "OffsetDateTimeField.getMaximumValue",
    "class_name": "org.joda.time.field.OffsetDateTimeField",
    "signature": "org.joda.time.field.OffsetDateTimeField.getMaximumValue()",
    "snippet": "    public int getMaximumValue() {\n        return iMax;\n    }",
    "comment": " Get the maximum value for the field.  @return the maximum value ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 3
  },
  {
    "name": "OffsetDateTimeField.getMinimumValue",
    "class_name": "org.joda.time.field.OffsetDateTimeField",
    "signature": "org.joda.time.field.OffsetDateTimeField.getMinimumValue()",
    "snippet": "    public int getMinimumValue() {\n        return iMin;\n    }",
    "comment": " Get the minimum value for the field.  @return the minimum value ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 3
  },
  {
    "name": "OffsetDateTimeField.set",
    "class_name": "org.joda.time.field.OffsetDateTimeField",
    "signature": "org.joda.time.field.OffsetDateTimeField.set(long,int)",
    "snippet": "    public long set(long instant, int value) {\n        FieldUtils.verifyValueBounds(this, value, iMin, iMax);\n        return super.set(instant, value - iOffset);\n    }",
    "comment": " Set the specified amount of offset units to the specified time instant.  @param instant  the time instant in millis to update. @param value  value of units to set. @return the updated time instant. @throws IllegalArgumentException if value is too large or too small. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 3
  },
  {
    "name": "PreciseDateTimeField.PreciseDateTimeField",
    "class_name": "org.joda.time.field.PreciseDateTimeField",
    "signature": "org.joda.time.field.PreciseDateTimeField.PreciseDateTimeField(DateTimeFieldType,DurationField,DurationField)",
    "snippet": "    public PreciseDateTimeField(DateTimeFieldType type,\n                                DurationField unit, DurationField range) {\n        super(type, unit);\n\n        if (!range.isPrecise()) {\n            throw new IllegalArgumentException(\"Range duration field must be precise\");\n        }\n\n        long rangeMillis = range.getUnitMillis();\n        iRange = (int)(rangeMillis / getUnitMillis());\n        if (iRange < 2) {\n            throw new IllegalArgumentException(\"The effective range must be at least 2\");\n        }\n\n        iRangeField = range;\n    }",
    "comment": " Constructor.  @param type  the field type this field uses @param unit  precise unit duration, like \"seconds()\". @param range precise range duration, preferably a multiple of the unit, like \"minutes()\". @throws IllegalArgumentException if either duration field is imprecise @throws IllegalArgumentException if unit milliseconds is less than one or effective value range is less than two. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 3
  },
  {
    "name": "PreciseDateTimeField.get",
    "class_name": "org.joda.time.field.PreciseDateTimeField",
    "signature": "org.joda.time.field.PreciseDateTimeField.get(long)",
    "snippet": "    public int get(long instant) {\n        if (instant >= 0) {\n            return (int) ((instant / getUnitMillis()) % iRange);\n        } else {\n            return iRange - 1 + (int) (((instant + 1) / getUnitMillis()) % iRange);\n        }\n    }",
    "comment": " Get the amount of fractional units from the specified time instant.  @param instant  the milliseconds from 1970-01-01T00:00:00Z to query @return the amount of fractional units extracted from the input. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 3
  },
  {
    "name": "PreciseDateTimeField.getMaximumValue",
    "class_name": "org.joda.time.field.PreciseDateTimeField",
    "signature": "org.joda.time.field.PreciseDateTimeField.getMaximumValue()",
    "snippet": "    public int getMaximumValue() {\n        return iRange - 1;\n    }",
    "comment": " Get the maximum value for the field.  @return the maximum value ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 3
  },
  {
    "name": "PreciseDateTimeField.getRangeDurationField",
    "class_name": "org.joda.time.field.PreciseDateTimeField",
    "signature": "org.joda.time.field.PreciseDateTimeField.getRangeDurationField()",
    "snippet": "    public DurationField getRangeDurationField() {\n        return iRangeField;\n    }",
    "comment": " Returns the range duration of this field. For example, if this field represents \"minute of hour\", then the range duration field is an hours.  @return the range duration of this field, or null if field has no range ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 3
  },
  {
    "name": "PreciseDateTimeField.set",
    "class_name": "org.joda.time.field.PreciseDateTimeField",
    "signature": "org.joda.time.field.PreciseDateTimeField.set(long,int)",
    "snippet": "    public long set(long instant, int value) {\n        FieldUtils.verifyValueBounds(this, value, getMinimumValue(), getMaximumValue());\n        return instant + (value - get(instant)) * iUnitMillis;\n    }",
    "comment": " Set the specified amount of units to the specified time instant.  @param instant  the milliseconds from 1970-01-01T00:00:00Z to set in @param value  value of units to set. @return the updated time instant. @throws IllegalArgumentException if value is too large or too small. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 3
  },
  {
    "name": "PreciseDurationDateTimeField.PreciseDurationDateTimeField",
    "class_name": "org.joda.time.field.PreciseDurationDateTimeField",
    "signature": "org.joda.time.field.PreciseDurationDateTimeField.PreciseDurationDateTimeField(DateTimeFieldType,DurationField)",
    "snippet": "    public PreciseDurationDateTimeField(DateTimeFieldType type, DurationField unit) {\n        super(type);\n\n        if (!unit.isPrecise()) {\n            throw new IllegalArgumentException(\"Unit duration field must be precise\");\n        }\n\n        iUnitMillis = unit.getUnitMillis();\n        if (iUnitMillis < 1) {\n            throw new IllegalArgumentException(\"The unit milliseconds must be at least 1\");\n        }\n\n        iUnitField = unit;\n    }",
    "comment": " Constructor.  @param type  the field type @param unit  precise unit duration, like \"days()\". @throws IllegalArgumentException if duration field is imprecise @throws IllegalArgumentException if unit milliseconds is less than one ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 3
  },
  {
    "name": "PreciseDurationDateTimeField.getDurationField",
    "class_name": "org.joda.time.field.PreciseDurationDateTimeField",
    "signature": "org.joda.time.field.PreciseDurationDateTimeField.getDurationField()",
    "snippet": "    public DurationField getDurationField() {\n        return iUnitField;\n    }",
    "comment": " Returns the duration per unit value of this field. For example, if this field represents \"minute of hour\", then the duration field is minutes.  @return the duration of this field, or UnsupportedDurationField if field has no duration ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 3
  },
  {
    "name": "PreciseDurationDateTimeField.getMaximumValueForSet",
    "class_name": "org.joda.time.field.PreciseDurationDateTimeField",
    "signature": "org.joda.time.field.PreciseDurationDateTimeField.getMaximumValueForSet(long,int)",
    "snippet": "    protected int getMaximumValueForSet(long instant, int value) {\n        return getMaximumValue(instant);\n    }",
    "comment": " Called by the set method to get the maximum allowed value. By default, returns getMaximumValue(instant). Override to provide a faster implementation. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 3
  },
  {
    "name": "PreciseDurationDateTimeField.getMinimumValue",
    "class_name": "org.joda.time.field.PreciseDurationDateTimeField",
    "signature": "org.joda.time.field.PreciseDurationDateTimeField.getMinimumValue()",
    "snippet": "    public int getMinimumValue() {\n        return 0;\n    }",
    "comment": " Get the minimum value for the field.  @return the minimum value ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 3
  },
  {
    "name": "PreciseDurationDateTimeField.getUnitMillis",
    "class_name": "org.joda.time.field.PreciseDurationDateTimeField",
    "signature": "org.joda.time.field.PreciseDurationDateTimeField.getUnitMillis()",
    "snippet": "    public final long getUnitMillis() {\n        return iUnitMillis;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 3
  },
  {
    "name": "PreciseDurationDateTimeField.roundFloor",
    "class_name": "org.joda.time.field.PreciseDurationDateTimeField",
    "signature": "org.joda.time.field.PreciseDurationDateTimeField.roundFloor(long)",
    "snippet": "    public long roundFloor(long instant) {\n        if (instant >= 0) {\n            return instant - instant % iUnitMillis;\n        } else {\n            instant += 1;\n            return instant - instant % iUnitMillis - iUnitMillis;\n        }\n    }",
    "comment": " This method assumes that this field is properly rounded on 1970-01-01T00:00:00. If the rounding alignment differs, override this method as follows: <pre> return super.roundFloor(instant + ALIGNMENT_MILLIS) - ALIGNMENT_MILLIS; </pre> ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 3
  },
  {
    "name": "PreciseDurationDateTimeField.set",
    "class_name": "org.joda.time.field.PreciseDurationDateTimeField",
    "signature": "org.joda.time.field.PreciseDurationDateTimeField.set(long,int)",
    "snippet": "    public long set(long instant, int value) {\n        FieldUtils.verifyValueBounds(this, value, getMinimumValue(),\n                                     getMaximumValueForSet(instant, value));\n        return instant + (value - get(instant)) * iUnitMillis;\n    }",
    "comment": " Set the specified amount of units to the specified time instant.  @param instant  the milliseconds from 1970-01-01T00:00:00Z to set in @param value  value of units to set. @return the updated time instant. @throws IllegalArgumentException if value is too large or too small. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 3
  },
  {
    "name": "PreciseDurationField.PreciseDurationField",
    "class_name": "org.joda.time.field.PreciseDurationField",
    "signature": "org.joda.time.field.PreciseDurationField.PreciseDurationField(DurationFieldType,long)",
    "snippet": "    public PreciseDurationField(DurationFieldType type, long unitMillis) {\n        super(type);\n        iUnitMillis = unitMillis;\n    }",
    "comment": " Constructor.  @param type  the field type @param unitMillis  the unit milliseconds ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 3
  },
  {
    "name": "PreciseDurationField.getUnitMillis",
    "class_name": "org.joda.time.field.PreciseDurationField",
    "signature": "org.joda.time.field.PreciseDurationField.getUnitMillis()",
    "snippet": "    public final long getUnitMillis() {\n        return iUnitMillis;\n    }",
    "comment": " Returns the amount of milliseconds per unit value of this field.  @return the unit size of this field, in milliseconds ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 3
  },
  {
    "name": "PreciseDurationField.hashCode",
    "class_name": "org.joda.time.field.PreciseDurationField",
    "signature": "org.joda.time.field.PreciseDurationField.hashCode()",
    "snippet": "    public int hashCode() {\n        long millis = iUnitMillis;\n        int hash = (int) (millis ^ (millis >>> 32));\n        hash += getType().hashCode();\n        return hash;\n    }",
    "comment": " Gets a hash code for this instance.  @return a suitable hashcode ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 3
  },
  {
    "name": "PreciseDurationField.isPrecise",
    "class_name": "org.joda.time.field.PreciseDurationField",
    "signature": "org.joda.time.field.PreciseDurationField.isPrecise()",
    "snippet": "    public final boolean isPrecise() {\n        return true;\n    }",
    "comment": " This field is precise.  @return true always ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 3
  },
  {
    "name": "RemainderDateTimeField.RemainderDateTimeField",
    "class_name": "org.joda.time.field.RemainderDateTimeField",
    "signature": "org.joda.time.field.RemainderDateTimeField.RemainderDateTimeField(DateTimeField,DurationField,DateTimeFieldType,int)",
    "snippet": "    public RemainderDateTimeField(DateTimeField field, DurationField rangeField,\n                                  DateTimeFieldType type, int divisor) {\n        super(field, type);\n        if (divisor < 2) {\n            throw new IllegalArgumentException(\"The divisor must be at least 2\");\n        }\n        iRangeField = rangeField;\n        iDurationField = field.getDurationField();\n        iDivisor = divisor;\n    }",
    "comment": " Constructor.  @param field  the field to wrap, like \"year()\". @param rangeField  the range field @param type  the field type this field actually uses @param divisor  divisor, such as 100 years in a century @throws IllegalArgumentException if divisor is less than two ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 3
  },
  {
    "name": "RemainderDateTimeField.RemainderDateTimeField",
    "class_name": "org.joda.time.field.RemainderDateTimeField",
    "signature": "org.joda.time.field.RemainderDateTimeField.RemainderDateTimeField(DividedDateTimeField)",
    "snippet": "    public RemainderDateTimeField(DividedDateTimeField dividedField) {\n        this(dividedField, dividedField.getType());\n    }",
    "comment": " Construct a RemainderDateTimeField that compliments the given DividedDateTimeField.  @param dividedField  complimentary divided field, like \"century()\". ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 3
  },
  {
    "name": "RemainderDateTimeField.RemainderDateTimeField",
    "class_name": "org.joda.time.field.RemainderDateTimeField",
    "signature": "org.joda.time.field.RemainderDateTimeField.RemainderDateTimeField(DividedDateTimeField,DateTimeFieldType)",
    "snippet": "    public RemainderDateTimeField(DividedDateTimeField dividedField, DateTimeFieldType type) {\n        this(dividedField, dividedField.getWrappedField().getDurationField(), type);\n    }",
    "comment": " Construct a RemainderDateTimeField that compliments the given DividedDateTimeField.  @param dividedField  complimentary divided field, like \"century()\". @param type  the field type this field actually uses ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 3
  },
  {
    "name": "RemainderDateTimeField.RemainderDateTimeField",
    "class_name": "org.joda.time.field.RemainderDateTimeField",
    "signature": "org.joda.time.field.RemainderDateTimeField.RemainderDateTimeField(DividedDateTimeField,DurationField,DateTimeFieldType)",
    "snippet": "    public RemainderDateTimeField(DividedDateTimeField dividedField, DurationField durationField, DateTimeFieldType type) {\n        super(dividedField.getWrappedField(), type);\n        iDivisor = dividedField.iDivisor;\n        iDurationField = durationField;\n        iRangeField = dividedField.iDurationField;\n    }",
    "comment": " Construct a RemainderDateTimeField that compliments the given DividedDateTimeField. This constructor allows the duration field to be set.  @param dividedField  complimentary divided field, like \"century()\". @param durationField  the duration field @param type  the field type this field actually uses ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 3
  },
  {
    "name": "RemainderDateTimeField.getDurationField",
    "class_name": "org.joda.time.field.RemainderDateTimeField",
    "signature": "org.joda.time.field.RemainderDateTimeField.getDurationField()",
    "snippet": "    @Override\n    public DurationField getDurationField() {\n        return iDurationField;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 3
  },
  {
    "name": "RemainderDateTimeField.getMaximumValue",
    "class_name": "org.joda.time.field.RemainderDateTimeField",
    "signature": "org.joda.time.field.RemainderDateTimeField.getMaximumValue()",
    "snippet": "    public int getMaximumValue() {\n        return iDivisor - 1;\n    }",
    "comment": " Get the maximum value for the field, which is always one less than the divisor.  @return the maximum value ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 3
  },
  {
    "name": "RemainderDateTimeField.getMinimumValue",
    "class_name": "org.joda.time.field.RemainderDateTimeField",
    "signature": "org.joda.time.field.RemainderDateTimeField.getMinimumValue()",
    "snippet": "    public int getMinimumValue() {\n        return 0;\n    }",
    "comment": " Get the minimum value for the field, which is always zero.  @return the minimum value of zero. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 3
  },
  {
    "name": "RemainderDateTimeField.getRangeDurationField",
    "class_name": "org.joda.time.field.RemainderDateTimeField",
    "signature": "org.joda.time.field.RemainderDateTimeField.getRangeDurationField()",
    "snippet": "    public DurationField getRangeDurationField() {\n        return iRangeField;\n    }",
    "comment": " Returns a scaled version of the wrapped field's unit duration field. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 3
  },
  {
    "name": "ScaledDurationField.ScaledDurationField",
    "class_name": "org.joda.time.field.ScaledDurationField",
    "signature": "org.joda.time.field.ScaledDurationField.ScaledDurationField(DurationField,DurationFieldType,int)",
    "snippet": "    public ScaledDurationField(DurationField field, DurationFieldType type, int scalar) {\n        super(field, type);\n        if (scalar == 0 || scalar == 1) {\n            throw new IllegalArgumentException(\"The scalar must not be 0 or 1\");\n        }\n        iScalar = scalar;\n    }",
    "comment": " Constructor  @param field  the field to wrap, like \"year()\". @param type  the type this field will actually use @param scalar  scalar, such as 100 years in a century @throws IllegalArgumentException if scalar is zero or one. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 3
  },
  {
    "name": "ScaledDurationField.getUnitMillis",
    "class_name": "org.joda.time.field.ScaledDurationField",
    "signature": "org.joda.time.field.ScaledDurationField.getUnitMillis()",
    "snippet": "    public long getUnitMillis() {\n        return getWrappedField().getUnitMillis() * iScalar;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 3
  },
  {
    "name": "ScaledDurationField.hashCode",
    "class_name": "org.joda.time.field.ScaledDurationField",
    "signature": "org.joda.time.field.ScaledDurationField.hashCode()",
    "snippet": "    public int hashCode() {\n        long scalar = iScalar;\n        int hash = (int) (scalar ^ (scalar >>> 32));\n        hash += getType().hashCode();\n        hash += getWrappedField().hashCode();\n        return hash;\n    }",
    "comment": " Gets a hash code for this instance.  @return a suitable hashcode ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 3
  },
  {
    "name": "SkipDateTimeField.SkipDateTimeField",
    "class_name": "org.joda.time.field.SkipDateTimeField",
    "signature": "org.joda.time.field.SkipDateTimeField.SkipDateTimeField(Chronology,DateTimeField)",
    "snippet": "    public SkipDateTimeField(Chronology chronology, DateTimeField field) {\n        this(chronology, field, 0);\n    }",
    "comment": " Constructor that skips zero.  @param chronology  the chronoogy to use @param field  the field to skip zero on ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 3
  },
  {
    "name": "SkipDateTimeField.SkipDateTimeField",
    "class_name": "org.joda.time.field.SkipDateTimeField",
    "signature": "org.joda.time.field.SkipDateTimeField.SkipDateTimeField(Chronology,DateTimeField,int)",
    "snippet": "    public SkipDateTimeField(Chronology chronology, DateTimeField field, int skip) {\n        super(field);\n        iChronology = chronology;\n        int min = super.getMinimumValue();\n        if (min < skip) {\n            iMinValue = min - 1;\n        } else if (min == skip) {\n            iMinValue = skip + 1;\n        } else {\n            iMinValue = min;\n        }\n        iSkip = skip;\n    }",
    "comment": " Constructor.  @param chronology  the chronoogy to use @param field  the field to skip zero on @param skip  the value to skip ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 3
  },
  {
    "name": "SkipDateTimeField.get",
    "class_name": "org.joda.time.field.SkipDateTimeField",
    "signature": "org.joda.time.field.SkipDateTimeField.get(long)",
    "snippet": "    public int get(long millis) {\n        int value = super.get(millis);\n        if (value <= iSkip) {\n            value--;\n        }\n        return value;\n    }",
    "comment": "-----------------------------------------------------------------------",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 3
  },
  {
    "name": "SkipDateTimeField.getMinimumValue",
    "class_name": "org.joda.time.field.SkipDateTimeField",
    "signature": "org.joda.time.field.SkipDateTimeField.getMinimumValue()",
    "snippet": "    public int getMinimumValue() {\n        return iMinValue;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 3
  },
  {
    "name": "SkipUndoDateTimeField.SkipUndoDateTimeField",
    "class_name": "org.joda.time.field.SkipUndoDateTimeField",
    "signature": "org.joda.time.field.SkipUndoDateTimeField.SkipUndoDateTimeField(Chronology,DateTimeField)",
    "snippet": "    public SkipUndoDateTimeField(Chronology chronology, DateTimeField field) {\n        this(chronology, field, 0);\n    }",
    "comment": " Constructor that reinserts zero.  @param chronology  the chronoogy to use @param field  the field to skip zero on ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 3
  },
  {
    "name": "SkipUndoDateTimeField.SkipUndoDateTimeField",
    "class_name": "org.joda.time.field.SkipUndoDateTimeField",
    "signature": "org.joda.time.field.SkipUndoDateTimeField.SkipUndoDateTimeField(Chronology,DateTimeField,int)",
    "snippet": "    public SkipUndoDateTimeField(Chronology chronology, DateTimeField field, int skip) {\n        super(field);\n        iChronology = chronology;\n        int min = super.getMinimumValue();\n        if (min < skip) {\n            iMinValue = min + 1;\n        } else if (min == skip + 1) {\n            iMinValue = skip;\n        } else {\n            iMinValue = min;\n        }\n        iSkip = skip;\n    }",
    "comment": " Constructor.  @param chronology  the chronoogy to use @param field  the field to skip zero on @param skip  the value to skip ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 3
  },
  {
    "name": "SkipUndoDateTimeField.getMinimumValue",
    "class_name": "org.joda.time.field.SkipUndoDateTimeField",
    "signature": "org.joda.time.field.SkipUndoDateTimeField.getMinimumValue()",
    "snippet": "    public int getMinimumValue() {\n        return iMinValue;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 3
  },
  {
    "name": "SkipUndoDateTimeField.set",
    "class_name": "org.joda.time.field.SkipUndoDateTimeField",
    "signature": "org.joda.time.field.SkipUndoDateTimeField.set(long,int)",
    "snippet": "    public long set(long millis, int value) {\n        FieldUtils.verifyValueBounds(this, value, iMinValue, getMaximumValue());\n        if (value <= iSkip) {\n            value--;\n        }\n        return super.set(millis, value);\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 3
  },
  {
    "name": "UnsupportedDurationField.compareTo",
    "class_name": "org.joda.time.field.UnsupportedDurationField",
    "signature": "org.joda.time.field.UnsupportedDurationField.compareTo(DurationField)",
    "snippet": "    public int compareTo(DurationField durationField) {\n        return 0;\n    }",
    "comment": " Always returns zero, indicating that sort order is not relevent.  @return zero always ",
    "is_bug": true,
    "failing_test_cases": 1,
    "buggy_methods": 3
  },
  {
    "name": "UnsupportedDurationField.getInstance",
    "class_name": "org.joda.time.field.UnsupportedDurationField",
    "signature": "org.joda.time.field.UnsupportedDurationField.getInstance(DurationFieldType)",
    "snippet": "    public static synchronized UnsupportedDurationField getInstance(DurationFieldType type) {\n        UnsupportedDurationField field;\n        if (cCache == null) {\n            cCache = new HashMap<DurationFieldType, UnsupportedDurationField>(7);\n            field = null;\n        } else {\n            field = cCache.get(type);\n        }\n        if (field == null) {\n            field = new UnsupportedDurationField(type);\n            cCache.put(type, field);\n        }\n        return field;\n    }",
    "comment": " Gets an instance of UnsupportedDurationField for a specific named field. The returned instance is cached.  @param type  the type to obtain @return the instance ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 3
  },
  {
    "name": "UnsupportedDurationField.getUnitMillis",
    "class_name": "org.joda.time.field.UnsupportedDurationField",
    "signature": "org.joda.time.field.UnsupportedDurationField.getUnitMillis()",
    "snippet": "    public long getUnitMillis() {\n        return 0;\n    }",
    "comment": " Always returns zero.  @return zero always ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 3
  },
  {
    "name": "UnsupportedDurationField.isSupported",
    "class_name": "org.joda.time.field.UnsupportedDurationField",
    "signature": "org.joda.time.field.UnsupportedDurationField.isSupported()",
    "snippet": "    public boolean isSupported() {\n        return false;\n    }",
    "comment": " This field is not supported.  @return false always ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 3
  },
  {
    "name": "ZeroIsMaxDateTimeField.ZeroIsMaxDateTimeField",
    "class_name": "org.joda.time.field.ZeroIsMaxDateTimeField",
    "signature": "org.joda.time.field.ZeroIsMaxDateTimeField.ZeroIsMaxDateTimeField(DateTimeField,DateTimeFieldType)",
    "snippet": "    public ZeroIsMaxDateTimeField(DateTimeField field, DateTimeFieldType type) {\n        super(field, type);\n        if (field.getMinimumValue() != 0) {\n            throw new IllegalArgumentException(\"Wrapped field's minumum value must be zero\");\n        }\n    }",
    "comment": " Constructor.  @param field  the base field @param type  the field type this field will actually use @throws IllegalArgumentException if wrapped field's minimum value is not zero ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 3
  },
  {
    "name": "ZeroIsMaxDateTimeField.getLeapDurationField",
    "class_name": "org.joda.time.field.ZeroIsMaxDateTimeField",
    "signature": "org.joda.time.field.ZeroIsMaxDateTimeField.getLeapDurationField()",
    "snippet": "    public DurationField getLeapDurationField() {\n        return getWrappedField().getLeapDurationField();\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 3
  },
  {
    "name": "CachedDateTimeZone.createInfo",
    "class_name": "org.joda.time.tz.CachedDateTimeZone",
    "signature": "org.joda.time.tz.CachedDateTimeZone.createInfo(long)",
    "snippet": "    private Info createInfo(long millis) {\n        long periodStart = millis & (0xffffffffL << 32);\n        Info info = new Info(iZone, periodStart);\n        \n        long end = periodStart | 0xffffffffL;\n        Info chain = info;\n        while (true) {\n            long next = iZone.nextTransition(periodStart);\n            if (next == periodStart || next > end) {\n                break;\n            }\n            periodStart = next;\n            chain = (chain.iNextInfo = new Info(iZone, periodStart));\n        }\n\n        return info;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 3
  },
  {
    "name": "CachedDateTimeZone.forZone",
    "class_name": "org.joda.time.tz.CachedDateTimeZone",
    "signature": "org.joda.time.tz.CachedDateTimeZone.forZone(DateTimeZone)",
    "snippet": "    public static CachedDateTimeZone forZone(DateTimeZone zone) {\n        if (zone instanceof CachedDateTimeZone) {\n            return (CachedDateTimeZone)zone;\n        }\n        return new CachedDateTimeZone(zone);\n    }",
    "comment": " Returns a new CachedDateTimeZone unless given zone is already cached. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 3
  },
  {
    "name": "CachedDateTimeZone.getInfo",
    "class_name": "org.joda.time.tz.CachedDateTimeZone",
    "signature": "org.joda.time.tz.CachedDateTimeZone.getInfo(long)",
    "snippet": "    private Info getInfo(long millis) {\n        int period = (int)(millis >> 32);\n        Info[] cache = iInfoCache;\n        int index = period & cInfoCacheMask;\n        Info info = cache[index];\n        if (info == null || (int)((info.iPeriodStart >> 32)) != period) {\n            info = createInfo(millis);\n            cache[index] = info;\n        }\n        return info;\n    }",
    "comment": "synchronized.",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 3
  },
  {
    "name": "CachedDateTimeZone.getOffset",
    "class_name": "org.joda.time.tz.CachedDateTimeZone",
    "signature": "org.joda.time.tz.CachedDateTimeZone.getOffset(long)",
    "snippet": "    public int getOffset(long instant) {\n        return getInfo(instant).getOffset(instant);\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 3
  },
  {
    "name": "CachedDateTimeZone.hashCode",
    "class_name": "org.joda.time.tz.CachedDateTimeZone",
    "signature": "org.joda.time.tz.CachedDateTimeZone.hashCode()",
    "snippet": "    public int hashCode() {\n        return iZone.hashCode();\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 3
  },
  {
    "name": "Info.getOffset",
    "class_name": "org.joda.time.tz.CachedDateTimeZone$Info",
    "signature": "org.joda.time.tz.CachedDateTimeZone$Info.getOffset(long)",
    "snippet": "        public int getOffset(long millis) {\n            if (iNextInfo == null || millis < iNextInfo.iPeriodStart) {\n                if (iOffset == Integer.MIN_VALUE) {\n                    iOffset = iZoneRef.getOffset(iPeriodStart);\n                }\n                return iOffset;\n            }\n            return iNextInfo.getOffset(millis);\n        }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 3
  },
  {
    "name": "DateTimeZoneBuilder.readFrom",
    "class_name": "org.joda.time.tz.DateTimeZoneBuilder",
    "signature": "org.joda.time.tz.DateTimeZoneBuilder.readFrom(DataInput,String)",
    "snippet": "    public static DateTimeZone readFrom(DataInput in, String id) throws IOException {\n        switch (in.readUnsignedByte()) {\n        case 'F':\n            DateTimeZone fixed = new FixedDateTimeZone\n                (id, in.readUTF(), (int)readMillis(in), (int)readMillis(in));\n            if (fixed.equals(DateTimeZone.UTC)) {\n                fixed = DateTimeZone.UTC;\n            }\n            return fixed;\n        case 'C':\n            return CachedDateTimeZone.forZone(PrecalculatedZone.readFrom(in, id));\n        case 'P':\n            return PrecalculatedZone.readFrom(in, id);\n        default:\n            throw new IOException(\"Invalid encoding\");\n        }\n    }",
    "comment": " Decodes a built DateTimeZone from the given stream, as encoded by writeTo.  @param in input stream to read encoded DateTimeZone from. @param id time zone id to assign ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 3
  },
  {
    "name": "DateTimeZoneBuilder.readFrom",
    "class_name": "org.joda.time.tz.DateTimeZoneBuilder",
    "signature": "org.joda.time.tz.DateTimeZoneBuilder.readFrom(InputStream,String)",
    "snippet": "    public static DateTimeZone readFrom(InputStream in, String id) throws IOException {\n        if (in instanceof DataInput) {\n            return readFrom((DataInput)in, id);\n        } else {\n            return readFrom((DataInput)new DataInputStream(in), id);\n        }\n    }",
    "comment": " Decodes a built DateTimeZone from the given stream, as encoded by writeTo.  @param in input stream to read encoded DateTimeZone from. @param id time zone id to assign ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 3
  },
  {
    "name": "DateTimeZoneBuilder.readMillis",
    "class_name": "org.joda.time.tz.DateTimeZoneBuilder",
    "signature": "org.joda.time.tz.DateTimeZoneBuilder.readMillis(DataInput)",
    "snippet": "    static long readMillis(DataInput in) throws IOException {\n        int v = in.readUnsignedByte();\n        switch (v >> 6) {\n        case 0: default:\n            // Form 00 (6 bits effective precision)\n            v = (v << (32 - 6)) >> (32 - 6);\n            return v * (30 * 60000L);\n\n        case 1:\n            // Form 01 (30 bits effective precision)\n            v = (v << (32 - 6)) >> (32 - 30);\n            v |= (in.readUnsignedByte()) << 16;\n            v |= (in.readUnsignedByte()) << 8;\n            v |= (in.readUnsignedByte());\n            return v * 60000L;\n\n        case 2:\n            // Form 10 (38 bits effective precision)\n            long w = (((long)v) << (64 - 6)) >> (64 - 38);\n            w |= (in.readUnsignedByte()) << 24;\n            w |= (in.readUnsignedByte()) << 16;\n            w |= (in.readUnsignedByte()) << 8;\n            w |= (in.readUnsignedByte());\n            return w * 1000L;\n\n        case 3:\n            // Form 11 (64-bits effective precision)\n            return in.readLong();\n        }\n    }",
    "comment": " Reads encoding generated by writeMillis. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 3
  },
  {
    "name": "DSTZone.readFrom",
    "class_name": "org.joda.time.tz.DateTimeZoneBuilder$DSTZone",
    "signature": "org.joda.time.tz.DateTimeZoneBuilder$DSTZone.readFrom(DataInput,String)",
    "snippet": "        static DSTZone readFrom(DataInput in, String id) throws IOException {\n            return new DSTZone(id, (int)readMillis(in), \n                               Recurrence.readFrom(in), Recurrence.readFrom(in));\n        }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 3
  },
  {
    "name": "OfYear.readFrom",
    "class_name": "org.joda.time.tz.DateTimeZoneBuilder$OfYear",
    "signature": "org.joda.time.tz.DateTimeZoneBuilder$OfYear.readFrom(DataInput)",
    "snippet": "        static OfYear readFrom(DataInput in) throws IOException {\n            return new OfYear((char)in.readUnsignedByte(),\n                              (int)in.readUnsignedByte(),\n                              (int)in.readByte(),\n                              (int)in.readUnsignedByte(),\n                              in.readBoolean(),\n                              (int)readMillis(in));\n        }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 3
  },
  {
    "name": "PrecalculatedZone.getOffset",
    "class_name": "org.joda.time.tz.DateTimeZoneBuilder$PrecalculatedZone",
    "signature": "org.joda.time.tz.DateTimeZoneBuilder$PrecalculatedZone.getOffset(long)",
    "snippet": "        public int getOffset(long instant) {\n            long[] transitions = iTransitions;\n            int i = Arrays.binarySearch(transitions, instant);\n            if (i >= 0) {\n                return iWallOffsets[i];\n            }\n            i = ~i;\n            if (i < transitions.length) {\n                if (i > 0) {\n                    return iWallOffsets[i - 1];\n                }\n                return 0;\n            }\n            if (iTailZone == null) {\n                return iWallOffsets[i - 1];\n            }\n            return iTailZone.getOffset(instant);\n        }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 3
  },
  {
    "name": "PrecalculatedZone.nextTransition",
    "class_name": "org.joda.time.tz.DateTimeZoneBuilder$PrecalculatedZone",
    "signature": "org.joda.time.tz.DateTimeZoneBuilder$PrecalculatedZone.nextTransition(long)",
    "snippet": "        public long nextTransition(long instant) {\n            long[] transitions = iTransitions;\n            int i = Arrays.binarySearch(transitions, instant);\n            i = (i >= 0) ? (i + 1) : ~i;\n            if (i < transitions.length) {\n                return transitions[i];\n            }\n            if (iTailZone == null) {\n                return instant;\n            }\n            long end = transitions[transitions.length - 1];\n            if (instant < end) {\n                instant = end;\n            }\n            return iTailZone.nextTransition(instant);\n        }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 3
  },
  {
    "name": "PrecalculatedZone.readFrom",
    "class_name": "org.joda.time.tz.DateTimeZoneBuilder$PrecalculatedZone",
    "signature": "org.joda.time.tz.DateTimeZoneBuilder$PrecalculatedZone.readFrom(DataInput,String)",
    "snippet": "        static PrecalculatedZone readFrom(DataInput in, String id) throws IOException {\n            // Read string pool.\n            int poolSize = in.readUnsignedShort();\n            String[] pool = new String[poolSize];\n            for (int i=0; i<poolSize; i++) {\n                pool[i] = in.readUTF();\n            }\n\n            int size = in.readInt();\n            long[] transitions = new long[size];\n            int[] wallOffsets = new int[size];\n            int[] standardOffsets = new int[size];\n            String[] nameKeys = new String[size];\n            \n            for (int i=0; i<size; i++) {\n                transitions[i] = readMillis(in);\n                wallOffsets[i] = (int)readMillis(in);\n                standardOffsets[i] = (int)readMillis(in);\n                try {\n                    int index;\n                    if (poolSize < 256) {\n                        index = in.readUnsignedByte();\n                    } else {\n                        index = in.readUnsignedShort();\n                    }\n                    nameKeys[i] = pool[index];\n                } catch (ArrayIndexOutOfBoundsException e) {\n                    throw new IOException(\"Invalid encoding\");\n                }\n            }\n\n            DSTZone tailZone = null;\n            if (in.readBoolean()) {\n                tailZone = DSTZone.readFrom(in, id);\n            }\n\n            return new PrecalculatedZone\n                (id, transitions, wallOffsets, standardOffsets, nameKeys, tailZone);\n        }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 3
  },
  {
    "name": "Recurrence.readFrom",
    "class_name": "org.joda.time.tz.DateTimeZoneBuilder$Recurrence",
    "signature": "org.joda.time.tz.DateTimeZoneBuilder$Recurrence.readFrom(DataInput)",
    "snippet": "        static Recurrence readFrom(DataInput in) throws IOException {\n            return new Recurrence(OfYear.readFrom(in), in.readUTF(), (int)readMillis(in));\n        }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 3
  },
  {
    "name": "DefaultNameProvider.DefaultNameProvider",
    "class_name": "org.joda.time.tz.DefaultNameProvider",
    "signature": "org.joda.time.tz.DefaultNameProvider.DefaultNameProvider()",
    "snippet": "    public DefaultNameProvider() {\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 3
  },
  {
    "name": "DefaultNameProvider.createCache",
    "class_name": "org.joda.time.tz.DefaultNameProvider",
    "signature": "org.joda.time.tz.DefaultNameProvider.createCache()",
    "snippet": "    private HashMap createCache() {\n        return new HashMap(7);\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 3
  },
  {
    "name": "FixedDateTimeZone.FixedDateTimeZone",
    "class_name": "org.joda.time.tz.FixedDateTimeZone",
    "signature": "org.joda.time.tz.FixedDateTimeZone.FixedDateTimeZone(String,String,int,int)",
    "snippet": "    public FixedDateTimeZone(String id, String nameKey,\n                             int wallOffset, int standardOffset) {\n        super(id);\n        iNameKey = nameKey;\n        iWallOffset = wallOffset;\n        iStandardOffset = standardOffset;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 3
  },
  {
    "name": "FixedDateTimeZone.equals",
    "class_name": "org.joda.time.tz.FixedDateTimeZone",
    "signature": "org.joda.time.tz.FixedDateTimeZone.equals(Object)",
    "snippet": "    public boolean equals(Object obj) {\n        if (this == obj) {\n            return true;\n        }\n        if (obj instanceof FixedDateTimeZone) {\n            FixedDateTimeZone other = (FixedDateTimeZone) obj;\n            return\n                getID().equals(other.getID()) &&\n                iStandardOffset == other.iStandardOffset &&\n                iWallOffset == other.iWallOffset;\n        }\n        return false;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 3
  },
  {
    "name": "FixedDateTimeZone.hashCode",
    "class_name": "org.joda.time.tz.FixedDateTimeZone",
    "signature": "org.joda.time.tz.FixedDateTimeZone.hashCode()",
    "snippet": "    public int hashCode() {\n        return getID().hashCode() + 37 * iStandardOffset + 31 * iWallOffset;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 3
  },
  {
    "name": "ZoneInfoProvider.ZoneInfoProvider",
    "class_name": "org.joda.time.tz.ZoneInfoProvider",
    "signature": "org.joda.time.tz.ZoneInfoProvider.ZoneInfoProvider(String)",
    "snippet": "    public ZoneInfoProvider(String resourcePath) throws IOException {\n        this(resourcePath, null, false);\n    }",
    "comment": " ZoneInfoProvider searches the given ClassLoader resource path for compiled data files. Resources are loaded from the ClassLoader that loaded this class.  @throws IOException if directory or map file cannot be read ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 3
  },
  {
    "name": "ZoneInfoProvider.getAvailableIDs",
    "class_name": "org.joda.time.tz.ZoneInfoProvider",
    "signature": "org.joda.time.tz.ZoneInfoProvider.getAvailableIDs()",
    "snippet": "    public Set<String> getAvailableIDs() {\n        // Return a copy of the keys rather than an umodifiable collection.\n        // This prevents ConcurrentModificationExceptions from being thrown by\n        // some JVMs if zones are opened while this set is iterated over.\n        return new TreeSet<String>(iZoneInfoMap.keySet());\n    }",
    "comment": " Gets a list of all the available zone ids.  @return the zone ids ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 3
  },
  {
    "name": "ZoneInfoProvider.getZone",
    "class_name": "org.joda.time.tz.ZoneInfoProvider",
    "signature": "org.joda.time.tz.ZoneInfoProvider.getZone(String)",
    "snippet": "    public DateTimeZone getZone(String id) {\n        if (id == null) {\n            return null;\n        }\n\n        Object obj = iZoneInfoMap.get(id);\n        if (obj == null) {\n            return null;\n        }\n\n        if (id.equals(obj)) {\n            // Load zone data for the first time.\n            return loadZoneData(id);\n        }\n\n        if (obj instanceof SoftReference<?>) {\n            @SuppressWarnings(\"unchecked\")\n            SoftReference<DateTimeZone> ref = (SoftReference<DateTimeZone>) obj;\n            DateTimeZone tz = ref.get();\n            if (tz != null) {\n                return tz;\n            }\n            // Reference cleared; load data again.\n            return loadZoneData(id);\n        }\n\n        // If this point is reached, mapping must link to another.\n        return getZone((String)obj);\n    }",
    "comment": " If an error is thrown while loading zone data, the exception is logged to system error and null is returned for this and all future requests.  @param id  the id to load @return the loaded zone ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 3
  },
  {
    "name": "ZoneInfoProvider.loadZoneData",
    "class_name": "org.joda.time.tz.ZoneInfoProvider",
    "signature": "org.joda.time.tz.ZoneInfoProvider.loadZoneData(String)",
    "snippet": "    private DateTimeZone loadZoneData(String id) {\n        InputStream in = null;\n        try {\n            in = openResource(id);\n            DateTimeZone tz = DateTimeZoneBuilder.readFrom(in, id);\n            iZoneInfoMap.put(id, new SoftReference<DateTimeZone>(tz));\n            return tz;\n        } catch (IOException ex) {\n            uncaughtException(ex);\n            iZoneInfoMap.remove(id);\n            return null;\n        } finally {\n            try {\n                if (in != null) {\n                    in.close();\n                }\n            } catch (IOException ex) {\n            }\n        }\n    }",
    "comment": " Loads the time zone data for one id.  @param id  the id to load @return the zone ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 3
  },
  {
    "name": "ZoneInfoProvider.loadZoneInfoMap",
    "class_name": "org.joda.time.tz.ZoneInfoProvider",
    "signature": "org.joda.time.tz.ZoneInfoProvider.loadZoneInfoMap(InputStream)",
    "snippet": "    private static Map<String, Object> loadZoneInfoMap(InputStream in) throws IOException {\n        Map<String, Object> map = new ConcurrentHashMap<String, Object>();\n        DataInputStream din = new DataInputStream(in);\n        try {\n            readZoneInfoMap(din, map);\n        } finally {\n            try {\n                din.close();\n            } catch (IOException ex) {\n            }\n        }\n        map.put(\"UTC\", new SoftReference<DateTimeZone>(DateTimeZone.UTC));\n        return map;\n    }",
    "comment": " Loads the zone info map.  @param in  the input stream @return the map ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 3
  },
  {
    "name": "ZoneInfoProvider.openResource",
    "class_name": "org.joda.time.tz.ZoneInfoProvider",
    "signature": "org.joda.time.tz.ZoneInfoProvider.openResource(String)",
    "snippet": "    @SuppressWarnings(\"resource\")\n    private InputStream openResource(String name) throws IOException {\n        InputStream in;\n        if (iFileDir != null) {\n            in = new FileInputStream(new File(iFileDir, name));\n        } else {\n            String path = iResourcePath.concat(name);\n            if (iLoader != null) {\n                in = iLoader.getResourceAsStream(path);\n            } else {\n                in = ClassLoader.getSystemResourceAsStream(path);\n            }\n            if (in == null) {\n                StringBuilder buf = new StringBuilder(40)\n                    .append(\"Resource not found: \\\"\")\n                    .append(path)\n                    .append(\"\\\" ClassLoader: \")\n                    .append(iLoader != null ? iLoader.toString() : \"system\");\n                throw new IOException(buf.toString());\n            }\n        }\n        return in;\n    }",
    "comment": " Opens a resource from file or classpath.  @param name  the name to open @return the input stream @throws IOException if an error occurs ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 3
  },
  {
    "name": "ZoneInfoProvider.readZoneInfoMap",
    "class_name": "org.joda.time.tz.ZoneInfoProvider",
    "signature": "org.joda.time.tz.ZoneInfoProvider.readZoneInfoMap(DataInputStream,Map)",
    "snippet": "    private static void readZoneInfoMap(DataInputStream din, Map<String, Object> zimap) throws IOException {\n        // Read the string pool.\n        int size = din.readUnsignedShort();\n        String[] pool = new String[size];\n        for (int i=0; i<size; i++) {\n            pool[i] = din.readUTF().intern();\n        }\n\n        // Read the mappings.\n        size = din.readUnsignedShort();\n        for (int i=0; i<size; i++) {\n            try {\n                zimap.put(pool[din.readUnsignedShort()], pool[din.readUnsignedShort()]);\n            } catch (ArrayIndexOutOfBoundsException ex) {\n                throw new IOException(\"Corrupt zone info map\");\n            }\n        }\n    }",
    "comment": " Reads the zone info map from file.  @param din  the input stream @param zimap  gets filled with string id to string id mappings ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 3
  }
]