[
  {
    "name": "DateTimeFieldType.DateTimeFieldType",
    "class_name": "org.joda.time.DateTimeFieldType",
    "signature": "org.joda.time.DateTimeFieldType.DateTimeFieldType(String)",
    "snippet": "    protected DateTimeFieldType(String name) {\n        super();\n        iName = name;\n    }",
    "comment": " Constructor.  @param name  the name to use ",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 1
  },
  {
    "name": "DateTimeFieldType.centuryOfEra",
    "class_name": "org.joda.time.DateTimeFieldType",
    "signature": "org.joda.time.DateTimeFieldType.centuryOfEra()",
    "snippet": "    public static DateTimeFieldType centuryOfEra() {\n        return CENTURY_OF_ERA_TYPE;\n    }",
    "comment": " Get the century of era field type.  @return the DateTimeFieldType constant ",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 1
  },
  {
    "name": "DateTimeFieldType.clockhourOfDay",
    "class_name": "org.joda.time.DateTimeFieldType",
    "signature": "org.joda.time.DateTimeFieldType.clockhourOfDay()",
    "snippet": "    public static DateTimeFieldType clockhourOfDay() {\n        return CLOCKHOUR_OF_DAY_TYPE;\n    }",
    "comment": " Get the hour of day (offset to 1-24) field type.  @return the DateTimeFieldType constant ",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 1
  },
  {
    "name": "DateTimeFieldType.clockhourOfHalfday",
    "class_name": "org.joda.time.DateTimeFieldType",
    "signature": "org.joda.time.DateTimeFieldType.clockhourOfHalfday()",
    "snippet": "    public static DateTimeFieldType clockhourOfHalfday() {\n        return CLOCKHOUR_OF_HALFDAY_TYPE;\n    }",
    "comment": " Get the hour of am/pm (offset to 1-12) field type.  @return the DateTimeFieldType constant ",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 1
  },
  {
    "name": "DateTimeFieldType.dayOfMonth",
    "class_name": "org.joda.time.DateTimeFieldType",
    "signature": "org.joda.time.DateTimeFieldType.dayOfMonth()",
    "snippet": "    public static DateTimeFieldType dayOfMonth() {\n        return DAY_OF_MONTH_TYPE;\n    }",
    "comment": " Get the day of month field type.  @return the DateTimeFieldType constant ",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 1
  },
  {
    "name": "DateTimeFieldType.dayOfWeek",
    "class_name": "org.joda.time.DateTimeFieldType",
    "signature": "org.joda.time.DateTimeFieldType.dayOfWeek()",
    "snippet": "    public static DateTimeFieldType dayOfWeek() {\n        return DAY_OF_WEEK_TYPE;\n    }",
    "comment": " Get the day of week field type.  @return the DateTimeFieldType constant ",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 1
  },
  {
    "name": "DateTimeFieldType.dayOfYear",
    "class_name": "org.joda.time.DateTimeFieldType",
    "signature": "org.joda.time.DateTimeFieldType.dayOfYear()",
    "snippet": "    public static DateTimeFieldType dayOfYear() {\n        return DAY_OF_YEAR_TYPE;\n    }",
    "comment": " Get the day of year field type.  @return the DateTimeFieldType constant ",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 1
  },
  {
    "name": "DateTimeFieldType.era",
    "class_name": "org.joda.time.DateTimeFieldType",
    "signature": "org.joda.time.DateTimeFieldType.era()",
    "snippet": "    public static DateTimeFieldType era() {\n        return ERA_TYPE;\n    }",
    "comment": " Get the era field type.  @return the DateTimeFieldType constant ",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 1
  },
  {
    "name": "DateTimeFieldType.halfdayOfDay",
    "class_name": "org.joda.time.DateTimeFieldType",
    "signature": "org.joda.time.DateTimeFieldType.halfdayOfDay()",
    "snippet": "    public static DateTimeFieldType halfdayOfDay() {\n        return HALFDAY_OF_DAY_TYPE;\n    }",
    "comment": " Get the AM(0) PM(1) field type.  @return the DateTimeFieldType constant ",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 1
  },
  {
    "name": "DateTimeFieldType.hourOfDay",
    "class_name": "org.joda.time.DateTimeFieldType",
    "signature": "org.joda.time.DateTimeFieldType.hourOfDay()",
    "snippet": "    public static DateTimeFieldType hourOfDay() {\n        return HOUR_OF_DAY_TYPE;\n    }",
    "comment": " Get the hour of day (0-23) field type.  @return the DateTimeFieldType constant ",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 1
  },
  {
    "name": "DateTimeFieldType.hourOfHalfday",
    "class_name": "org.joda.time.DateTimeFieldType",
    "signature": "org.joda.time.DateTimeFieldType.hourOfHalfday()",
    "snippet": "    public static DateTimeFieldType hourOfHalfday() {\n        return HOUR_OF_HALFDAY_TYPE;\n    }",
    "comment": " Get the hour of am/pm (0-11) field type.  @return the DateTimeFieldType constant ",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 1
  },
  {
    "name": "DateTimeFieldType.millisOfDay",
    "class_name": "org.joda.time.DateTimeFieldType",
    "signature": "org.joda.time.DateTimeFieldType.millisOfDay()",
    "snippet": "    public static DateTimeFieldType millisOfDay() {\n        return MILLIS_OF_DAY_TYPE;\n    }",
    "comment": " Get the millis of day field type.  @return the DateTimeFieldType constant ",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 1
  },
  {
    "name": "DateTimeFieldType.millisOfSecond",
    "class_name": "org.joda.time.DateTimeFieldType",
    "signature": "org.joda.time.DateTimeFieldType.millisOfSecond()",
    "snippet": "    public static DateTimeFieldType millisOfSecond() {\n        return MILLIS_OF_SECOND_TYPE;\n    }",
    "comment": " Get the millis of second field type.  @return the DateTimeFieldType constant ",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 1
  },
  {
    "name": "DateTimeFieldType.minuteOfDay",
    "class_name": "org.joda.time.DateTimeFieldType",
    "signature": "org.joda.time.DateTimeFieldType.minuteOfDay()",
    "snippet": "    public static DateTimeFieldType minuteOfDay() {\n        return MINUTE_OF_DAY_TYPE;\n    }",
    "comment": " Get the minute of day field type.  @return the DateTimeFieldType constant ",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 1
  },
  {
    "name": "DateTimeFieldType.minuteOfHour",
    "class_name": "org.joda.time.DateTimeFieldType",
    "signature": "org.joda.time.DateTimeFieldType.minuteOfHour()",
    "snippet": "    public static DateTimeFieldType minuteOfHour() {\n        return MINUTE_OF_HOUR_TYPE;\n    }",
    "comment": " Get the minute of hour field type.  @return the DateTimeFieldType constant ",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 1
  },
  {
    "name": "DateTimeFieldType.monthOfYear",
    "class_name": "org.joda.time.DateTimeFieldType",
    "signature": "org.joda.time.DateTimeFieldType.monthOfYear()",
    "snippet": "    public static DateTimeFieldType monthOfYear() {\n        return MONTH_OF_YEAR_TYPE;\n    }",
    "comment": " Get the month of year field type.  @return the DateTimeFieldType constant ",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 1
  },
  {
    "name": "DateTimeFieldType.secondOfDay",
    "class_name": "org.joda.time.DateTimeFieldType",
    "signature": "org.joda.time.DateTimeFieldType.secondOfDay()",
    "snippet": "    public static DateTimeFieldType secondOfDay() {\n        return SECOND_OF_DAY_TYPE;\n    }",
    "comment": " Get the second of day field type.  @return the DateTimeFieldType constant ",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 1
  },
  {
    "name": "DateTimeFieldType.secondOfMinute",
    "class_name": "org.joda.time.DateTimeFieldType",
    "signature": "org.joda.time.DateTimeFieldType.secondOfMinute()",
    "snippet": "    public static DateTimeFieldType secondOfMinute() {\n        return SECOND_OF_MINUTE_TYPE;\n    }",
    "comment": " Get the second of minute field type.  @return the DateTimeFieldType constant ",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 1
  },
  {
    "name": "DateTimeFieldType.weekOfWeekyear",
    "class_name": "org.joda.time.DateTimeFieldType",
    "signature": "org.joda.time.DateTimeFieldType.weekOfWeekyear()",
    "snippet": "    public static DateTimeFieldType weekOfWeekyear() {\n        return WEEK_OF_WEEKYEAR_TYPE;\n    }",
    "comment": " Get the week of a week based year field type.  @return the DateTimeFieldType constant ",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 1
  },
  {
    "name": "DateTimeFieldType.weekyear",
    "class_name": "org.joda.time.DateTimeFieldType",
    "signature": "org.joda.time.DateTimeFieldType.weekyear()",
    "snippet": "    public static DateTimeFieldType weekyear() {\n        return WEEKYEAR_TYPE;\n    }",
    "comment": " Get the year of a week based year field type.  @return the DateTimeFieldType constant ",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 1
  },
  {
    "name": "DateTimeFieldType.weekyearOfCentury",
    "class_name": "org.joda.time.DateTimeFieldType",
    "signature": "org.joda.time.DateTimeFieldType.weekyearOfCentury()",
    "snippet": "    public static DateTimeFieldType weekyearOfCentury() {\n        return WEEKYEAR_OF_CENTURY_TYPE;\n    }",
    "comment": " Get the year of a week based year within a century field type.  @return the DateTimeFieldType constant ",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 1
  },
  {
    "name": "DateTimeFieldType.year",
    "class_name": "org.joda.time.DateTimeFieldType",
    "signature": "org.joda.time.DateTimeFieldType.year()",
    "snippet": "    public static DateTimeFieldType year() {\n        return YEAR_TYPE;\n    }",
    "comment": " Get the year field type.  @return the DateTimeFieldType constant ",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 1
  },
  {
    "name": "DateTimeFieldType.yearOfCentury",
    "class_name": "org.joda.time.DateTimeFieldType",
    "signature": "org.joda.time.DateTimeFieldType.yearOfCentury()",
    "snippet": "    public static DateTimeFieldType yearOfCentury() {\n        return YEAR_OF_CENTURY_TYPE;\n    }",
    "comment": " Get the year of century field type.  @return the DateTimeFieldType constant ",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 1
  },
  {
    "name": "DateTimeFieldType.yearOfEra",
    "class_name": "org.joda.time.DateTimeFieldType",
    "signature": "org.joda.time.DateTimeFieldType.yearOfEra()",
    "snippet": "    public static DateTimeFieldType yearOfEra() {\n        return YEAR_OF_ERA_TYPE;\n    }",
    "comment": " Get the year of era field type.  @return the DateTimeFieldType constant ",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 1
  },
  {
    "name": "StandardDateTimeFieldType.getDurationType",
    "class_name": "org.joda.time.DateTimeFieldType$StandardDateTimeFieldType",
    "signature": "org.joda.time.DateTimeFieldType$StandardDateTimeFieldType.getDurationType()",
    "snippet": "        public DurationFieldType getDurationType() {\n            return iUnitType;\n        }",
    "comment": "@inheritdoc */",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 1
  },
  {
    "name": "StandardDateTimeFieldType.getRangeDurationType",
    "class_name": "org.joda.time.DateTimeFieldType$StandardDateTimeFieldType",
    "signature": "org.joda.time.DateTimeFieldType$StandardDateTimeFieldType.getRangeDurationType()",
    "snippet": "        public DurationFieldType getRangeDurationType() {\n            return iRangeType;\n        }",
    "comment": "@inheritdoc */",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 1
  },
  {
    "name": "DateTimeUtils.checkPermission",
    "class_name": "org.joda.time.DateTimeUtils",
    "signature": "org.joda.time.DateTimeUtils.checkPermission()",
    "snippet": "    private static void checkPermission() throws SecurityException {\n        SecurityManager sm = System.getSecurityManager();\n        if (sm != null) {\n            sm.checkPermission(new JodaTimePermission(\"CurrentTime.setProvider\"));\n        }\n    }",
    "comment": " Checks whether the provider may be changed using permission 'CurrentTime.setProvider'.  @throws SecurityException if the provider may not be changed ",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 1
  },
  {
    "name": "DateTimeUtils.getChronology",
    "class_name": "org.joda.time.DateTimeUtils",
    "signature": "org.joda.time.DateTimeUtils.getChronology(Chronology)",
    "snippet": "    public static final Chronology getChronology(Chronology chrono) {\n        if (chrono == null) {\n            return ISOChronology.getInstance();\n        }\n        return chrono;\n    }",
    "comment": " Gets the chronology handling null. <p> If the chronology is <code>null</code>, {@link ISOChronology#getInstance()} will be returned. Otherwise, the chronology is returned.  @param chrono  the chronology to use, null means ISO in the default zone @return the chronology, never null ",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 1
  },
  {
    "name": "DateTimeUtils.getPeriodType",
    "class_name": "org.joda.time.DateTimeUtils",
    "signature": "org.joda.time.DateTimeUtils.getPeriodType(PeriodType)",
    "snippet": "    public static final PeriodType getPeriodType(PeriodType type) {\n        if (type == null) {\n            return PeriodType.standard();\n        }\n        return type;\n    }",
    "comment": " Gets the period type handling null. <p> If the zone is <code>null</code>, {@link PeriodType#standard()} will be returned. Otherwise, the type specified is returned.  @param type  the time zone to use, null means the standard type @return the type to use, never null ",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 1
  },
  {
    "name": "DateTimeUtils.put",
    "class_name": "org.joda.time.DateTimeUtils",
    "signature": "org.joda.time.DateTimeUtils.put(Map,String,String)",
    "snippet": "    private static void put(Map<String, DateTimeZone> map, String name, String id) {\n        try {\n            map.put(name, DateTimeZone.forID(id));\n        } catch (RuntimeException ex) {\n            // ignore\n        }\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 1
  },
  {
    "name": "DateTimeUtils.setCurrentMillisFixed",
    "class_name": "org.joda.time.DateTimeUtils",
    "signature": "org.joda.time.DateTimeUtils.setCurrentMillisFixed(long)",
    "snippet": "    public static final void setCurrentMillisFixed(long fixedMillis) throws SecurityException {\n        checkPermission();\n        cMillisProvider = new FixedMillisProvider(fixedMillis);\n    }",
    "comment": " Sets the current time to return a fixed millisecond time. <p> This method changes the behaviour of {@link #currentTimeMillis()}. Whenever the current time is queried, the same millisecond time will be returned.  @param fixedMillis  the fixed millisecond time to use @throws SecurityException if the application does not have sufficient security rights ",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 1
  },
  {
    "name": "DateTimeUtils.setCurrentMillisSystem",
    "class_name": "org.joda.time.DateTimeUtils",
    "signature": "org.joda.time.DateTimeUtils.setCurrentMillisSystem()",
    "snippet": "    public static final void setCurrentMillisSystem() throws SecurityException {\n        checkPermission();\n        cMillisProvider = SYSTEM_MILLIS_PROVIDER;\n    }",
    "comment": " Resets the current time to return the system time. <p> This method changes the behaviour of {@link #currentTimeMillis()}. Whenever the current time is queried, {@link System#currentTimeMillis()} is used.  @throws SecurityException if the application does not have sufficient security rights ",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 1
  },
  {
    "name": "DateTimeZone.DateTimeZone",
    "class_name": "org.joda.time.DateTimeZone",
    "signature": "org.joda.time.DateTimeZone.DateTimeZone(String)",
    "snippet": "    protected DateTimeZone(String id) {\n        if (id == null) {\n            throw new IllegalArgumentException(\"Id must not be null\");\n        }\n        iID = id;\n    }",
    "comment": " Constructor.  @param id  the id to use @throws IllegalArgumentException if the id is null ",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 1
  },
  {
    "name": "DateTimeZone.forID",
    "class_name": "org.joda.time.DateTimeZone",
    "signature": "org.joda.time.DateTimeZone.forID(String)",
    "snippet": "    @FromString\n    public static DateTimeZone forID(String id) {\n        if (id == null) {\n            return getDefault();\n        }\n        if (id.equals(\"UTC\")) {\n            return DateTimeZone.UTC;\n        }\n        DateTimeZone zone = cProvider.getZone(id);\n        if (zone != null) {\n            return zone;\n        }\n        if (id.startsWith(\"+\") || id.startsWith(\"-\")) {\n            int offset = parseOffset(id);\n            if (offset == 0L) {\n                return DateTimeZone.UTC;\n            } else {\n                id = printOffset(offset);\n                return fixedOffsetZone(id, offset);\n            }\n        }\n        throw new IllegalArgumentException(\"The datetime zone id '\" + id + \"' is not recognised\");\n    }",
    "comment": " Gets a time zone instance for the specified time zone id. <p> The time zone id may be one of those returned by getAvailableIDs. Short ids, as accepted by {@link java.util.TimeZone}, are not accepted. All IDs must be specified in the long format. The exception is UTC, which is an acceptable id. <p> Alternatively a locale independent, fixed offset, datetime zone can be specified. The form <code>[+-]hh:mm</code> can be used.  @param id  the ID of the datetime zone, null means default @return the DateTimeZone object for the ID @throws IllegalArgumentException if the ID is not recognised ",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 1
  },
  {
    "name": "DateTimeZone.forTimeZone",
    "class_name": "org.joda.time.DateTimeZone",
    "signature": "org.joda.time.DateTimeZone.forTimeZone(TimeZone)",
    "snippet": "    public static DateTimeZone forTimeZone(TimeZone zone) {\n        if (zone == null) {\n            return getDefault();\n        }\n        final String id = zone.getID();\n        if (id.equals(\"UTC\")) {\n            return DateTimeZone.UTC;\n        }\n\n        // Convert from old alias before consulting provider since they may differ.\n        DateTimeZone dtz = null;\n        String convId = getConvertedId(id);\n        if (convId != null) {\n            dtz = cProvider.getZone(convId);\n        }\n        if (dtz == null) {\n            dtz = cProvider.getZone(id);\n        }\n        if (dtz != null) {\n            return dtz;\n        }\n\n        // Support GMT+/-hh:mm formats\n        if (convId == null) {\n            convId = zone.getID();\n            if (convId.startsWith(\"GMT+\") || convId.startsWith(\"GMT-\")) {\n                convId = convId.substring(3);\n                int offset = parseOffset(convId);\n                if (offset == 0L) {\n                    return DateTimeZone.UTC;\n                } else {\n                    convId = printOffset(offset);\n                    return fixedOffsetZone(convId, offset);\n                }\n            }\n        }\n        throw new IllegalArgumentException(\"The datetime zone id '\" + id + \"' is not recognised\");\n    }",
    "comment": " Gets a time zone instance for a JDK TimeZone. <p> DateTimeZone only accepts a subset of the IDs from TimeZone. The excluded IDs are the short three letter form (except UTC). This  method will attempt to convert between time zones created using the short IDs and the full version. <p> This method is not designed to parse time zones with rules created by applications using <code>SimpleTimeZone</code> directly.  @param zone  the zone to convert, null means default @return the DateTimeZone object for the zone @throws IllegalArgumentException if the zone is not recognised ",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 1
  },
  {
    "name": "DateTimeZone.getConvertedId",
    "class_name": "org.joda.time.DateTimeZone",
    "signature": "org.joda.time.DateTimeZone.getConvertedId(String)",
    "snippet": "    private static synchronized String getConvertedId(String id) {\n        Map<String, String> map = cZoneIdConversion;\n        if (map == null) {\n            // Backwards compatibility with TimeZone.\n            map = new HashMap<String, String>();\n            map.put(\"GMT\", \"UTC\");\n            map.put(\"WET\", \"WET\");\n            map.put(\"CET\", \"CET\");\n            map.put(\"MET\", \"CET\");\n            map.put(\"ECT\", \"CET\");\n            map.put(\"EET\", \"EET\");\n            map.put(\"MIT\", \"Pacific/Apia\");\n            map.put(\"HST\", \"Pacific/Honolulu\");  // JDK 1.1 compatible\n            map.put(\"AST\", \"America/Anchorage\");\n            map.put(\"PST\", \"America/Los_Angeles\");\n            map.put(\"MST\", \"America/Denver\");  // JDK 1.1 compatible\n            map.put(\"PNT\", \"America/Phoenix\");\n            map.put(\"CST\", \"America/Chicago\");\n            map.put(\"EST\", \"America/New_York\");  // JDK 1.1 compatible\n            map.put(\"IET\", \"America/Indiana/Indianapolis\");\n            map.put(\"PRT\", \"America/Puerto_Rico\");\n            map.put(\"CNT\", \"America/St_Johns\");\n            map.put(\"AGT\", \"America/Argentina/Buenos_Aires\");\n            map.put(\"BET\", \"America/Sao_Paulo\");\n            map.put(\"ART\", \"Africa/Cairo\");\n            map.put(\"CAT\", \"Africa/Harare\");\n            map.put(\"EAT\", \"Africa/Addis_Ababa\");\n            map.put(\"NET\", \"Asia/Yerevan\");\n            map.put(\"PLT\", \"Asia/Karachi\");\n            map.put(\"IST\", \"Asia/Kolkata\");\n            map.put(\"BST\", \"Asia/Dhaka\");\n            map.put(\"VST\", \"Asia/Ho_Chi_Minh\");\n            map.put(\"CTT\", \"Asia/Shanghai\");\n            map.put(\"JST\", \"Asia/Tokyo\");\n            map.put(\"ACT\", \"Australia/Darwin\");\n            map.put(\"AET\", \"Australia/Sydney\");\n            map.put(\"SST\", \"Pacific/Guadalcanal\");\n            map.put(\"NST\", \"Pacific/Auckland\");\n            cZoneIdConversion = map;\n        }\n        return map.get(id);\n    }",
    "comment": " Converts an old style id to a new style id.  @param id  the old style id @return the new style id, null if not found ",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 1
  },
  {
    "name": "DateTimeZone.getDefault",
    "class_name": "org.joda.time.DateTimeZone",
    "signature": "org.joda.time.DateTimeZone.getDefault()",
    "snippet": "    public static DateTimeZone getDefault() {\n        DateTimeZone zone = cDefault;\n        if (zone == null) {\n            synchronized(DateTimeZone.class) {\n                zone = cDefault;\n                if (zone == null) {\n                    DateTimeZone temp = null;\n                    try {\n                        try {\n                            String id = System.getProperty(\"user.timezone\");\n                            if (id != null) {  // null check avoids stack overflow\n                                temp = forID(id);\n                            }\n                        } catch (RuntimeException ex) {\n                            // ignored\n                        }\n                        if (temp == null) {\n                            temp = forTimeZone(TimeZone.getDefault());\n                        }\n                    } catch (IllegalArgumentException ex) {\n                        // ignored\n                    }\n                    if (temp == null) {\n                        temp = UTC;\n                    }\n                    cDefault = zone = temp;\n                }\n            }\n        }\n        return zone;\n    }",
    "comment": " Gets the default time zone. <p> The default time zone is derived from the system property {@code user.timezone}. If that is {@code null} or is not a valid identifier, then the value of the JDK {@code TimeZone} default is converted. If that fails, {@code UTC} is used. <p> NOTE: If the {@code java.util.TimeZone} default is updated <i>after</i> calling this method, then the change will not be picked up here.  @return the default datetime zone object ",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 1
  },
  {
    "name": "DateTimeZone.getDefaultNameProvider",
    "class_name": "org.joda.time.DateTimeZone",
    "signature": "org.joda.time.DateTimeZone.getDefaultNameProvider()",
    "snippet": "    private static NameProvider getDefaultNameProvider() {\n        NameProvider nameProvider = null;\n        try {\n            String providerClass = System.getProperty(\"org.joda.time.DateTimeZone.NameProvider\");\n            if (providerClass != null) {\n                try {\n                    nameProvider = (NameProvider) Class.forName(providerClass).newInstance();\n                } catch (Exception ex) {\n                    throw new RuntimeException(ex);\n                }\n            }\n        } catch (SecurityException ex) {\n            // ignore\n        }\n\n        if (nameProvider == null) {\n            nameProvider = new DefaultNameProvider();\n        }\n\n        return nameProvider;\n    }",
    "comment": " Gets the default name provider. <p> Tries the system property <code>org.joda.time.DateTimeZone.NameProvider</code>. Then uses <code>DefaultNameProvider</code>.  @return the default name provider ",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 1
  },
  {
    "name": "DateTimeZone.getDefaultProvider",
    "class_name": "org.joda.time.DateTimeZone",
    "signature": "org.joda.time.DateTimeZone.getDefaultProvider()",
    "snippet": "    private static Provider getDefaultProvider() {\n        Provider provider = null;\n\n        try {\n            String providerClass = System.getProperty(\"org.joda.time.DateTimeZone.Provider\");\n            if (providerClass != null) {\n                try {\n                    provider = (Provider) Class.forName(providerClass).newInstance();\n                } catch (Exception ex) {\n                    throw new RuntimeException(ex);\n                }\n            }\n        } catch (SecurityException ex) {\n            // ignored\n        }\n\n        if (provider == null) {\n            try {\n                provider = new ZoneInfoProvider(\"org/joda/time/tz/data\");\n            } catch (Exception ex) {\n                ex.printStackTrace();\n            }\n        }\n\n        if (provider == null) {\n            provider = new UTCProvider();\n        }\n\n        return provider;\n    }",
    "comment": " Gets the default zone provider. <p> Tries the system property <code>org.joda.time.DateTimeZone.Provider</code>. Then tries a <code>ZoneInfoProvider</code> using the data in <code>org/joda/time/tz/data</code>. Then uses <code>UTCProvider</code>.  @return the default name provider ",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 1
  },
  {
    "name": "DateTimeZone.getID",
    "class_name": "org.joda.time.DateTimeZone",
    "signature": "org.joda.time.DateTimeZone.getID()",
    "snippet": "    @ToString\n    public final String getID() {\n        return iID;\n    }",
    "comment": " Gets the ID of this datetime zone.  @return the ID of this datetime zone ",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 1
  },
  {
    "name": "DateTimeZone.hashCode",
    "class_name": "org.joda.time.DateTimeZone",
    "signature": "org.joda.time.DateTimeZone.hashCode()",
    "snippet": "    public int hashCode() {\n        return 57 + getID().hashCode();\n    }",
    "comment": " Gets a hash code compatable with equals.  @return suitable hashcode ",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 1
  },
  {
    "name": "DateTimeZone.setDefault",
    "class_name": "org.joda.time.DateTimeZone",
    "signature": "org.joda.time.DateTimeZone.setDefault(DateTimeZone)",
    "snippet": "    public static void setDefault(DateTimeZone zone) throws SecurityException {\n        SecurityManager sm = System.getSecurityManager();\n        if (sm != null) {\n            sm.checkPermission(new JodaTimePermission(\"DateTimeZone.setDefault\"));\n        }\n        if (zone == null) {\n            throw new IllegalArgumentException(\"The datetime zone must not be null\");\n        }\n        synchronized(DateTimeZone.class) {\n            cDefault = zone;\n        }\n    }",
    "comment": " Sets the default time zone. <p> NOTE: Calling this method does <i>not</i> set the {@code java.util.TimeZone} default.  @param zone  the default datetime zone object, must not be null @throws IllegalArgumentException if the zone is null @throws SecurityException if the application has insufficient security rights ",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 1
  },
  {
    "name": "DateTimeZone.setNameProvider0",
    "class_name": "org.joda.time.DateTimeZone",
    "signature": "org.joda.time.DateTimeZone.setNameProvider0(NameProvider)",
    "snippet": "    private static void setNameProvider0(NameProvider nameProvider) {\n        if (nameProvider == null) {\n            nameProvider = getDefaultNameProvider();\n        }\n        cNameProvider = nameProvider;\n    }",
    "comment": " Sets the name provider factory without performing the security check.  @param nameProvider  provider to use, or null for default @throws IllegalArgumentException if the provider is invalid ",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 1
  },
  {
    "name": "DateTimeZone.setProvider0",
    "class_name": "org.joda.time.DateTimeZone",
    "signature": "org.joda.time.DateTimeZone.setProvider0(Provider)",
    "snippet": "    private static void setProvider0(Provider provider) {\n        if (provider == null) {\n            provider = getDefaultProvider();\n        }\n        Set<String> ids = provider.getAvailableIDs();\n        if (ids == null || ids.size() == 0) {\n            throw new IllegalArgumentException\n                (\"The provider doesn't have any available ids\");\n        }\n        if (!ids.contains(\"UTC\")) {\n            throw new IllegalArgumentException(\"The provider doesn't support UTC\");\n        }\n        if (!UTC.equals(provider.getZone(\"UTC\"))) {\n            throw new IllegalArgumentException(\"Invalid UTC zone provided\");\n        }\n        cProvider = provider;\n        cAvailableIDs = ids;\n    }",
    "comment": " Sets the zone provider factory without performing the security check.  @param provider  provider to use, or null for default @throws IllegalArgumentException if the provider is invalid ",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 1
  },
  {
    "name": "DurationFieldType.DurationFieldType",
    "class_name": "org.joda.time.DurationFieldType",
    "signature": "org.joda.time.DurationFieldType.DurationFieldType(String)",
    "snippet": "    protected DurationFieldType(String name) {\n        super();\n        iName = name;\n    }",
    "comment": " Constructor.  @param name  the name to use, which by convention, are plural. ",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 1
  },
  {
    "name": "DurationFieldType.centuries",
    "class_name": "org.joda.time.DurationFieldType",
    "signature": "org.joda.time.DurationFieldType.centuries()",
    "snippet": "    public static DurationFieldType centuries() {\n        return CENTURIES_TYPE;\n    }",
    "comment": " Get the centuries field type.  @return the DateTimeFieldType constant ",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 1
  },
  {
    "name": "DurationFieldType.days",
    "class_name": "org.joda.time.DurationFieldType",
    "signature": "org.joda.time.DurationFieldType.days()",
    "snippet": "    public static DurationFieldType days() {\n        return DAYS_TYPE;\n    }",
    "comment": " Get the days field type.  @return the DateTimeFieldType constant ",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 1
  },
  {
    "name": "DurationFieldType.eras",
    "class_name": "org.joda.time.DurationFieldType",
    "signature": "org.joda.time.DurationFieldType.eras()",
    "snippet": "    public static DurationFieldType eras() {\n        return ERAS_TYPE;\n    }",
    "comment": " Get the eras field type.  @return the DateTimeFieldType constant ",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 1
  },
  {
    "name": "DurationFieldType.halfdays",
    "class_name": "org.joda.time.DurationFieldType",
    "signature": "org.joda.time.DurationFieldType.halfdays()",
    "snippet": "    public static DurationFieldType halfdays() {\n        return HALFDAYS_TYPE;\n    }",
    "comment": " Get the halfdays field type.  @return the DateTimeFieldType constant ",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 1
  },
  {
    "name": "DurationFieldType.hours",
    "class_name": "org.joda.time.DurationFieldType",
    "signature": "org.joda.time.DurationFieldType.hours()",
    "snippet": "    public static DurationFieldType hours() {\n        return HOURS_TYPE;\n    }",
    "comment": " Get the hours field type.  @return the DateTimeFieldType constant ",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 1
  },
  {
    "name": "DurationFieldType.millis",
    "class_name": "org.joda.time.DurationFieldType",
    "signature": "org.joda.time.DurationFieldType.millis()",
    "snippet": "    public static DurationFieldType millis() {\n        return MILLIS_TYPE;\n    }",
    "comment": " Get the millis field type.  @return the DateTimeFieldType constant ",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 1
  },
  {
    "name": "DurationFieldType.minutes",
    "class_name": "org.joda.time.DurationFieldType",
    "signature": "org.joda.time.DurationFieldType.minutes()",
    "snippet": "    public static DurationFieldType minutes() {\n        return MINUTES_TYPE;\n    }",
    "comment": " Get the minutes field type.  @return the DateTimeFieldType constant ",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 1
  },
  {
    "name": "DurationFieldType.months",
    "class_name": "org.joda.time.DurationFieldType",
    "signature": "org.joda.time.DurationFieldType.months()",
    "snippet": "    public static DurationFieldType months() {\n        return MONTHS_TYPE;\n    }",
    "comment": " Get the months field type.  @return the DateTimeFieldType constant ",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 1
  },
  {
    "name": "DurationFieldType.seconds",
    "class_name": "org.joda.time.DurationFieldType",
    "signature": "org.joda.time.DurationFieldType.seconds()",
    "snippet": "    public static DurationFieldType seconds() {\n        return SECONDS_TYPE;\n    }",
    "comment": " Get the seconds field type.  @return the DateTimeFieldType constant ",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 1
  },
  {
    "name": "DurationFieldType.weeks",
    "class_name": "org.joda.time.DurationFieldType",
    "signature": "org.joda.time.DurationFieldType.weeks()",
    "snippet": "    public static DurationFieldType weeks() {\n        return WEEKS_TYPE;\n    }",
    "comment": " Get the weeks field type.  @return the DateTimeFieldType constant ",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 1
  },
  {
    "name": "DurationFieldType.weekyears",
    "class_name": "org.joda.time.DurationFieldType",
    "signature": "org.joda.time.DurationFieldType.weekyears()",
    "snippet": "    public static DurationFieldType weekyears() {\n        return WEEKYEARS_TYPE;\n    }",
    "comment": " Get the weekyears field type.  @return the DateTimeFieldType constant ",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 1
  },
  {
    "name": "DurationFieldType.years",
    "class_name": "org.joda.time.DurationFieldType",
    "signature": "org.joda.time.DurationFieldType.years()",
    "snippet": "    public static DurationFieldType years() {\n        return YEARS_TYPE;\n    }",
    "comment": " Get the years field type.  @return the DateTimeFieldType constant ",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 1
  },
  {
    "name": "StandardDurationFieldType.equals",
    "class_name": "org.joda.time.DurationFieldType$StandardDurationFieldType",
    "signature": "org.joda.time.DurationFieldType$StandardDurationFieldType.equals(Object)",
    "snippet": "        @Override\n        public boolean equals(Object obj) {\n            if (this == obj) {\n                return true;\n            }\n            if (obj instanceof StandardDurationFieldType) {\n                return iOrdinal == ((StandardDurationFieldType) obj).iOrdinal;\n            }\n            return false;\n        }",
    "comment": "@inheritdoc */",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 1
  },
  {
    "name": "StandardDurationFieldType.getField",
    "class_name": "org.joda.time.DurationFieldType$StandardDurationFieldType",
    "signature": "org.joda.time.DurationFieldType$StandardDurationFieldType.getField(Chronology)",
    "snippet": "        public DurationField getField(Chronology chronology) {\n            chronology = DateTimeUtils.getChronology(chronology);\n            \n            switch (iOrdinal) {\n                case ERAS:\n                    return chronology.eras();\n                case CENTURIES:\n                    return chronology.centuries();\n                case WEEKYEARS:\n                    return chronology.weekyears();\n                case YEARS:\n                    return chronology.years();\n                case MONTHS:\n                    return chronology.months();\n                case WEEKS:\n                    return chronology.weeks();\n                case DAYS:\n                    return chronology.days();\n                case HALFDAYS:\n                    return chronology.halfdays();\n                case HOURS:\n                    return chronology.hours();\n                case MINUTES:\n                    return chronology.minutes();\n                case SECONDS:\n                    return chronology.seconds();\n                case MILLIS:\n                    return chronology.millis();\n                default:\n                    // Shouldn't happen.\n                    throw new InternalError();\n            }\n        }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 1
  },
  {
    "name": "StandardDurationFieldType.hashCode",
    "class_name": "org.joda.time.DurationFieldType$StandardDurationFieldType",
    "signature": "org.joda.time.DurationFieldType$StandardDurationFieldType.hashCode()",
    "snippet": "        @Override\n        public int hashCode() {\n            return (1 << iOrdinal);\n        }",
    "comment": "@inheritdoc */",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 1
  },
  {
    "name": "Period.Period",
    "class_name": "org.joda.time.Period",
    "signature": "org.joda.time.Period.Period()",
    "snippet": "    public Period() {\n        super(0L, null, null);\n    }",
    "comment": " Creates a new empty period with the standard set of fields. <p> One way to initialise a period is as follows: <pre> Period = new Period().withYears(6).withMonths(3).withSeconds(23); </pre> Bear in mind that this creates four period instances in total, three of which are immediately discarded. The alterative is more efficient, but less readable: <pre> Period = new Period(6, 3, 0, 0, 0, 0, 23, 0); </pre> The following is also slightly less wasteful: <pre> Period = Period.years(6).withMonths(3).withSeconds(23); </pre> ",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 1
  },
  {
    "name": "Period.Period",
    "class_name": "org.joda.time.Period",
    "signature": "org.joda.time.Period.Period(int,int,int,int,int,int,int,int)",
    "snippet": "    public Period(int years, int months, int weeks, int days,\n                  int hours, int minutes, int seconds, int millis) {\n        super(years, months, weeks, days, hours, minutes, seconds, millis, PeriodType.standard());\n    }",
    "comment": " Create a period from a set of field values using the standard set of fields.  @param years  amount of years in this period @param months  amount of months in this period @param weeks  amount of weeks in this period @param days  amount of days in this period @param hours  amount of hours in this period @param minutes  amount of minutes in this period @param seconds  amount of seconds in this period @param millis  amount of milliseconds in this period ",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 1
  },
  {
    "name": "Period.Period",
    "class_name": "org.joda.time.Period",
    "signature": "org.joda.time.Period.Period(long,PeriodType,Chronology)",
    "snippet": "    public Period(long duration, PeriodType type, Chronology chronology) {\n        super(duration, type, chronology);\n    }",
    "comment": " Creates a period from the given millisecond duration. <p> Only precise fields in the period type will be used. Imprecise fields will not be populated. <p> If the duration is small then this method will perform as you might expect and split the fields evenly. <p> If the duration is large then all the remaining duration will be stored in the largest available precise field. For details as to which fields are precise, review the period type javadoc.  @param duration  the duration, in milliseconds @param type  which set of fields this period supports, null means standard @param chronology  the chronology to use to split the duration, null means ISO default ",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 1
  },
  {
    "name": "Period.getDays",
    "class_name": "org.joda.time.Period",
    "signature": "org.joda.time.Period.getDays()",
    "snippet": "    public int getDays() {\n        return getPeriodType().getIndexedField(this, PeriodType.DAY_INDEX);\n    }",
    "comment": " Gets the days field part of the period.  @return the number of days in the period, zero if unsupported ",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 1
  },
  {
    "name": "Period.getHours",
    "class_name": "org.joda.time.Period",
    "signature": "org.joda.time.Period.getHours()",
    "snippet": "    public int getHours() {\n        return getPeriodType().getIndexedField(this, PeriodType.HOUR_INDEX);\n    }",
    "comment": " Gets the hours field part of the period.  @return the number of hours in the period, zero if unsupported ",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 1
  },
  {
    "name": "Period.getMillis",
    "class_name": "org.joda.time.Period",
    "signature": "org.joda.time.Period.getMillis()",
    "snippet": "    public int getMillis() {\n        return getPeriodType().getIndexedField(this, PeriodType.MILLI_INDEX);\n    }",
    "comment": " Gets the millis field part of the period.  @return the number of millis in the period, zero if unsupported ",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 1
  },
  {
    "name": "Period.getMinutes",
    "class_name": "org.joda.time.Period",
    "signature": "org.joda.time.Period.getMinutes()",
    "snippet": "    public int getMinutes() {\n        return getPeriodType().getIndexedField(this, PeriodType.MINUTE_INDEX);\n    }",
    "comment": " Gets the minutes field part of the period.  @return the number of minutes in the period, zero if unsupported ",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 1
  },
  {
    "name": "Period.getMonths",
    "class_name": "org.joda.time.Period",
    "signature": "org.joda.time.Period.getMonths()",
    "snippet": "    public int getMonths() {\n        return getPeriodType().getIndexedField(this, PeriodType.MONTH_INDEX);\n    }",
    "comment": " Gets the months field part of the period.  @return the number of months in the period, zero if unsupported ",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 1
  },
  {
    "name": "Period.getSeconds",
    "class_name": "org.joda.time.Period",
    "signature": "org.joda.time.Period.getSeconds()",
    "snippet": "    public int getSeconds() {\n        return getPeriodType().getIndexedField(this, PeriodType.SECOND_INDEX);\n    }",
    "comment": " Gets the seconds field part of the period.  @return the number of seconds in the period, zero if unsupported ",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 1
  },
  {
    "name": "Period.getWeeks",
    "class_name": "org.joda.time.Period",
    "signature": "org.joda.time.Period.getWeeks()",
    "snippet": "    public int getWeeks() {\n        return getPeriodType().getIndexedField(this, PeriodType.WEEK_INDEX);\n    }",
    "comment": " Gets the weeks field part of the period.  @return the number of weeks in the period, zero if unsupported ",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 1
  },
  {
    "name": "Period.getYears",
    "class_name": "org.joda.time.Period",
    "signature": "org.joda.time.Period.getYears()",
    "snippet": "    public int getYears() {\n        return getPeriodType().getIndexedField(this, PeriodType.YEAR_INDEX);\n    }",
    "comment": " Gets the years field part of the period.  @return the number of years in the period, zero if unsupported ",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 1
  },
  {
    "name": "Period.normalizedStandard",
    "class_name": "org.joda.time.Period",
    "signature": "org.joda.time.Period.normalizedStandard(PeriodType)",
    "snippet": "    public Period normalizedStandard(PeriodType type) {\n        type = DateTimeUtils.getPeriodType(type);\n        long millis = getMillis();  // no overflow can happen, even with Integer.MAX_VALUEs\n        millis += (((long) getSeconds()) * ((long) DateTimeConstants.MILLIS_PER_SECOND));\n        millis += (((long) getMinutes()) * ((long) DateTimeConstants.MILLIS_PER_MINUTE));\n        millis += (((long) getHours()) * ((long) DateTimeConstants.MILLIS_PER_HOUR));\n        millis += (((long) getDays()) * ((long) DateTimeConstants.MILLIS_PER_DAY));\n        millis += (((long) getWeeks()) * ((long) DateTimeConstants.MILLIS_PER_WEEK));\n        Period result = new Period(millis, type, ISOChronology.getInstanceUTC());\n        int years = getYears();\n        int months = getMonths();\n        if (years != 0 || months != 0) {\n            years = FieldUtils.safeAdd(years, months / 12);\n            months = months % 12;\n            if (years != 0) {\n                result = result.withYears(years);\n            }\n            if (months != 0) {\n                result = result.withMonths(months);\n            }\n        }\n        return result;\n    }",
    "comment": " Normalizes this period using standard rules, assuming a 12 month year, 7 day week, 24 hour day, 60 minute hour and 60 second minute, providing control over how the result is split into fields. <p> This method allows you to normalize a period. However to achieve this it makes the assumption that all years are 12 months, all weeks are 7 days, all days are 24 hours, all hours are 60 minutes and all minutes are 60 seconds. This is not true when daylight savings time is considered, and may also not be true for some chronologies. However, it is included as it is a useful operation for many applications and business rules. <p> If the period contains years or months, then the months will be normalized to be between 0 and 11. The days field and below will be normalized as necessary, however this will not overflow into the months field. Thus a period of 1 year 15 months will normalize to 2 years 3 months. But a period of 1 month 40 days will remain as 1 month 40 days. <p> The PeriodType parameter controls how the result is created. It allows you to omit certain fields from the result if desired. For example, you may not want the result to include weeks, in which case you pass in <code>PeriodType.yearMonthDayTime()</code>.  @param type  the period type of the new period, null means standard type @return a normalized period equivalent to this period @throws ArithmeticException if any field is too large to be represented @throws UnsupportedOperationException if this period contains non-zero years or months but the specified period type does not support them @since 1.5 ",
    "is_bug": true,
    "failing_test_cases": 3,
    "buggy_methods": 1
  },
  {
    "name": "Period.withYears",
    "class_name": "org.joda.time.Period",
    "signature": "org.joda.time.Period.withYears(int)",
    "snippet": "    public Period withYears(int years) {\n        int[] values = getValues();  // cloned\n        getPeriodType().setIndexedField(this, PeriodType.YEAR_INDEX, values, years);\n        return new Period(values, getPeriodType());\n    }",
    "comment": " Returns a new period with the specified number of years. <p> This period instance is immutable and unaffected by this method call.  @param years  the amount of years to add, may be negative @return the new period with the increased years @throws UnsupportedOperationException if the field is not supported ",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 1
  },
  {
    "name": "PeriodType.PeriodType",
    "class_name": "org.joda.time.PeriodType",
    "signature": "org.joda.time.PeriodType.PeriodType(String,DurationFieldType[],int[])",
    "snippet": "    protected PeriodType(String name, DurationFieldType[] types, int[] indices) {\n        super();\n        iName = name;\n        iTypes = types;\n        iIndices = indices;\n    }",
    "comment": " Constructor.  @param name  the name @param types  the types @param indices  the indices ",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 1
  },
  {
    "name": "PeriodType.dayTime",
    "class_name": "org.joda.time.PeriodType",
    "signature": "org.joda.time.PeriodType.dayTime()",
    "snippet": "    public static PeriodType dayTime() {\n        PeriodType type = cDTime;\n        if (type == null) {\n            type = new PeriodType(\n                \"DayTime\",\n                new DurationFieldType[] {\n                    DurationFieldType.days(),\n                    DurationFieldType.hours(), DurationFieldType.minutes(),\n                    DurationFieldType.seconds(), DurationFieldType.millis(),\n                },\n                new int[] { -1, -1, -1, 0, 1, 2, 3, 4, }\n            );\n            cDTime = type;\n        }\n        return type;\n    }",
    "comment": " Gets a type that defines all standard fields from days downwards. <ul> <li>days <li>hours <li>minutes <li>seconds <li>milliseconds </ul>  @return the period type ",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 1
  },
  {
    "name": "PeriodType.days",
    "class_name": "org.joda.time.PeriodType",
    "signature": "org.joda.time.PeriodType.days()",
    "snippet": "    public static PeriodType days() {\n        PeriodType type = cDays;\n        if (type == null) {\n            type = new PeriodType(\n                \"Days\",\n                new DurationFieldType[] { DurationFieldType.days() },\n                new int[] { -1, -1, -1, 0, -1, -1, -1, -1, }\n            );\n            cDays = type;\n        }\n        return type;\n    }",
    "comment": " Gets a type that defines just the days field.  @return the period type ",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 1
  },
  {
    "name": "PeriodType.forFields",
    "class_name": "org.joda.time.PeriodType",
    "signature": "org.joda.time.PeriodType.forFields(DurationFieldType[])",
    "snippet": "    public static synchronized PeriodType forFields(DurationFieldType[] types) {\n        if (types == null || types.length == 0) {\n            throw new IllegalArgumentException(\"Types array must not be null or empty\");\n        }\n        for (int i = 0; i < types.length; i++) {\n            if (types[i] == null) {\n                throw new IllegalArgumentException(\"Types array must not contain null\");\n            }\n        }\n        Map<PeriodType, Object> cache = cTypes;\n        if (cache.isEmpty()) {\n            cache.put(standard(), standard());\n            cache.put(yearMonthDayTime(), yearMonthDayTime());\n            cache.put(yearMonthDay(), yearMonthDay());\n            cache.put(yearWeekDayTime(), yearWeekDayTime());\n            cache.put(yearWeekDay(), yearWeekDay());\n            cache.put(yearDayTime(), yearDayTime());\n            cache.put(yearDay(), yearDay());\n            cache.put(dayTime(), dayTime());\n            cache.put(time(), time());\n            cache.put(years(), years());\n            cache.put(months(), months());\n            cache.put(weeks(), weeks());\n            cache.put(days(), days());\n            cache.put(hours(), hours());\n            cache.put(minutes(), minutes());\n            cache.put(seconds(), seconds());\n            cache.put(millis(), millis());\n        }\n        PeriodType inPartType = new PeriodType(null, types, null);\n        Object cached = cache.get(inPartType);\n        if (cached instanceof PeriodType) {\n            return (PeriodType) cached;\n        }\n        if (cached != null) {\n            throw new IllegalArgumentException(\"PeriodType does not support fields: \" + cached);\n        }\n        PeriodType type = standard();\n        List<DurationFieldType> list = new ArrayList<DurationFieldType>(Arrays.asList(types));\n        if (list.remove(DurationFieldType.years()) == false) {\n            type = type.withYearsRemoved();\n        }\n        if (list.remove(DurationFieldType.months()) == false) {\n            type = type.withMonthsRemoved();\n        }\n        if (list.remove(DurationFieldType.weeks()) == false) {\n            type = type.withWeeksRemoved();\n        }\n        if (list.remove(DurationFieldType.days()) == false) {\n            type = type.withDaysRemoved();\n        }\n        if (list.remove(DurationFieldType.hours()) == false) {\n            type = type.withHoursRemoved();\n        }\n        if (list.remove(DurationFieldType.minutes()) == false) {\n            type = type.withMinutesRemoved();\n        }\n        if (list.remove(DurationFieldType.seconds()) == false) {\n            type = type.withSecondsRemoved();\n        }\n        if (list.remove(DurationFieldType.millis()) == false) {\n            type = type.withMillisRemoved();\n        }\n        if (list.size() > 0) {\n            cache.put(inPartType, list);\n            throw new IllegalArgumentException(\"PeriodType does not support fields: \" + list);\n        }\n        // recheck cache in case initial array order was wrong\n        PeriodType checkPartType = new PeriodType(null, type.iTypes, null);\n        PeriodType checkedType = (PeriodType) cache.get(checkPartType);\n        if (checkedType != null) {\n            cache.put(checkPartType, checkedType);\n            return checkedType;\n        }\n        cache.put(checkPartType, type);\n        return type;\n    }",
    "comment": " Gets a period type that contains the duration types of the array. <p> Only the 8 standard duration field types are supported.  @param types  the types to include in the array. @return the period type @since 1.1 ",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 1
  },
  {
    "name": "PeriodType.getFieldType",
    "class_name": "org.joda.time.PeriodType",
    "signature": "org.joda.time.PeriodType.getFieldType(int)",
    "snippet": "    public DurationFieldType getFieldType(int index) {\n        return iTypes[index];\n    }",
    "comment": " Gets the field type by index.  @param index  the index to retrieve @return the field type @throws IndexOutOfBoundsException if the index is invalid ",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 1
  },
  {
    "name": "PeriodType.getIndexedField",
    "class_name": "org.joda.time.PeriodType",
    "signature": "org.joda.time.PeriodType.getIndexedField(ReadablePeriod,int)",
    "snippet": "    int getIndexedField(ReadablePeriod period, int index) {\n        int realIndex = iIndices[index];\n        return (realIndex == -1 ? 0 : period.getValue(realIndex));\n    }",
    "comment": " Gets the indexed field part of the period.  @param period  the period to query @param index  the index to use @return the value of the field, zero if unsupported ",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 1
  },
  {
    "name": "PeriodType.getName",
    "class_name": "org.joda.time.PeriodType",
    "signature": "org.joda.time.PeriodType.getName()",
    "snippet": "    public String getName() {\n        return iName;\n    }",
    "comment": " Gets the name of the period type.  @return the name ",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 1
  },
  {
    "name": "PeriodType.hashCode",
    "class_name": "org.joda.time.PeriodType",
    "signature": "org.joda.time.PeriodType.hashCode()",
    "snippet": "    public int hashCode() {\n        int hash = 0;\n        for (int i = 0; i < iTypes.length; i++) {\n            hash += iTypes[i].hashCode();\n        }\n        return hash;\n    }",
    "comment": " Returns a hashcode based on the field types.  @return a suitable hashcode ",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 1
  },
  {
    "name": "PeriodType.hours",
    "class_name": "org.joda.time.PeriodType",
    "signature": "org.joda.time.PeriodType.hours()",
    "snippet": "    public static PeriodType hours() {\n        PeriodType type = cHours;\n        if (type == null) {\n            type = new PeriodType(\n                \"Hours\",\n                new DurationFieldType[] { DurationFieldType.hours() },\n                new int[] { -1, -1, -1, -1, 0, -1, -1, -1, }\n            );\n            cHours = type;\n        }\n        return type;\n    }",
    "comment": " Gets a type that defines just the hours field.  @return the period type ",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 1
  },
  {
    "name": "PeriodType.indexOf",
    "class_name": "org.joda.time.PeriodType",
    "signature": "org.joda.time.PeriodType.indexOf(DurationFieldType)",
    "snippet": "    public int indexOf(DurationFieldType type) {\n        for (int i = 0, isize = size(); i < isize; i++) {\n            if (iTypes[i] == type) {\n                return i;\n            }\n        }\n        return -1;\n    }",
    "comment": " Gets the index of the field in this period.  @param type  the type to check, may be null which returns -1 @return the index of -1 if not supported ",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 1
  },
  {
    "name": "PeriodType.millis",
    "class_name": "org.joda.time.PeriodType",
    "signature": "org.joda.time.PeriodType.millis()",
    "snippet": "    public static PeriodType millis() {\n        PeriodType type = cMillis;\n        if (type == null) {\n            type = new PeriodType(\n                \"Millis\",\n                new DurationFieldType[] { DurationFieldType.millis() },\n                new int[] { -1, -1, -1, -1, -1, -1, -1, 0, }\n            );\n            cMillis = type;\n        }\n        return type;\n    }",
    "comment": " Gets a type that defines just the millis field.  @return the period type ",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 1
  },
  {
    "name": "PeriodType.minutes",
    "class_name": "org.joda.time.PeriodType",
    "signature": "org.joda.time.PeriodType.minutes()",
    "snippet": "    public static PeriodType minutes() {\n        PeriodType type = cMinutes;\n        if (type == null) {\n            type = new PeriodType(\n                \"Minutes\",\n                new DurationFieldType[] { DurationFieldType.minutes() },\n                new int[] { -1, -1, -1, -1, -1, 0, -1, -1, }\n            );\n            cMinutes = type;\n        }\n        return type;\n    }",
    "comment": " Gets a type that defines just the minutes field.  @return the period type ",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 1
  },
  {
    "name": "PeriodType.months",
    "class_name": "org.joda.time.PeriodType",
    "signature": "org.joda.time.PeriodType.months()",
    "snippet": "    public static PeriodType months() {\n        PeriodType type = cMonths;\n        if (type == null) {\n            type = new PeriodType(\n                \"Months\",\n                new DurationFieldType[] { DurationFieldType.months() },\n                new int[] { -1, 0, -1, -1, -1, -1, -1, -1, }\n            );\n            cMonths = type;\n        }\n        return type;\n    }",
    "comment": " Gets a type that defines just the months field.  @return the period type ",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 1
  },
  {
    "name": "PeriodType.seconds",
    "class_name": "org.joda.time.PeriodType",
    "signature": "org.joda.time.PeriodType.seconds()",
    "snippet": "    public static PeriodType seconds() {\n        PeriodType type = cSeconds;\n        if (type == null) {\n            type = new PeriodType(\n                \"Seconds\",\n                new DurationFieldType[] { DurationFieldType.seconds() },\n                new int[] { -1, -1, -1, -1, -1, -1, 0, -1, }\n            );\n            cSeconds = type;\n        }\n        return type;\n    }",
    "comment": " Gets a type that defines just the seconds field.  @return the period type ",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 1
  },
  {
    "name": "PeriodType.setIndexedField",
    "class_name": "org.joda.time.PeriodType",
    "signature": "org.joda.time.PeriodType.setIndexedField(ReadablePeriod,int,int[],int)",
    "snippet": "    boolean setIndexedField(ReadablePeriod period, int index, int[] values, int newValue) {\n        int realIndex = iIndices[index];\n        if (realIndex == -1) {\n            throw new UnsupportedOperationException(\"Field is not supported\");\n        }\n        values[realIndex] = newValue;\n        return true;\n    }",
    "comment": " Sets the indexed field part of the period.  @param period  the period to query @param index  the index to use @param values  the array to populate @param newValue  the value to set @throws UnsupportedOperationException if not supported ",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 1
  },
  {
    "name": "PeriodType.size",
    "class_name": "org.joda.time.PeriodType",
    "signature": "org.joda.time.PeriodType.size()",
    "snippet": "    public int size() {\n        return iTypes.length;\n    }",
    "comment": " Gets the number of fields in the period type.  @return the number of fields ",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 1
  },
  {
    "name": "PeriodType.standard",
    "class_name": "org.joda.time.PeriodType",
    "signature": "org.joda.time.PeriodType.standard()",
    "snippet": "    public static PeriodType standard() {\n        PeriodType type = cStandard;\n        if (type == null) {\n            type = new PeriodType(\n                \"Standard\",\n                new DurationFieldType[] {\n                    DurationFieldType.years(), DurationFieldType.months(),\n                    DurationFieldType.weeks(), DurationFieldType.days(),\n                    DurationFieldType.hours(), DurationFieldType.minutes(),\n                    DurationFieldType.seconds(), DurationFieldType.millis(),\n                },\n                new int[] { 0, 1, 2, 3, 4, 5, 6, 7, }\n            );\n            cStandard = type;\n        }\n        return type;\n    }",
    "comment": " Gets a type that defines all standard fields. <ul> <li>years <li>months <li>weeks <li>days <li>hours <li>minutes <li>seconds <li>milliseconds </ul>  @return the period type ",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 1
  },
  {
    "name": "PeriodType.time",
    "class_name": "org.joda.time.PeriodType",
    "signature": "org.joda.time.PeriodType.time()",
    "snippet": "    public static PeriodType time() {\n        PeriodType type = cTime;\n        if (type == null) {\n            type = new PeriodType(\n                \"Time\",\n                new DurationFieldType[] {\n                    DurationFieldType.hours(), DurationFieldType.minutes(),\n                    DurationFieldType.seconds(), DurationFieldType.millis(),\n                },\n                new int[] { -1, -1, -1, -1, 0, 1, 2, 3, }\n            );\n            cTime = type;\n        }\n        return type;\n    }",
    "comment": " Gets a type that defines all standard time fields. <ul> <li>hours <li>minutes <li>seconds <li>milliseconds </ul>  @return the period type ",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 1
  },
  {
    "name": "PeriodType.weeks",
    "class_name": "org.joda.time.PeriodType",
    "signature": "org.joda.time.PeriodType.weeks()",
    "snippet": "    public static PeriodType weeks() {\n        PeriodType type = cWeeks;\n        if (type == null) {\n            type = new PeriodType(\n                \"Weeks\",\n                new DurationFieldType[] { DurationFieldType.weeks() },\n                new int[] { -1, -1, 0, -1, -1, -1, -1, -1, }\n            );\n            cWeeks = type;\n        }\n        return type;\n    }",
    "comment": " Gets a type that defines just the weeks field.  @return the period type ",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 1
  },
  {
    "name": "PeriodType.withFieldRemoved",
    "class_name": "org.joda.time.PeriodType",
    "signature": "org.joda.time.PeriodType.withFieldRemoved(int,String)",
    "snippet": "    private PeriodType withFieldRemoved(int indicesIndex, String name) {\n        int fieldIndex = iIndices[indicesIndex];\n        if (fieldIndex == -1) {\n            return this;\n        }\n        \n        DurationFieldType[] types = new DurationFieldType[size() - 1];\n        for (int i = 0; i < iTypes.length; i++) {\n            if (i < fieldIndex) {\n                types[i] = iTypes[i];\n            } else if (i > fieldIndex) {\n                types[i - 1] = iTypes[i];\n            }\n        }\n        \n        int[] indices = new int[8];\n        for (int i = 0; i < indices.length; i++) {\n            if (i < indicesIndex) {\n                indices[i] = iIndices[i];\n            } else if (i > indicesIndex) {\n                indices[i] = (iIndices[i] == -1 ? -1 : iIndices[i] - 1);\n            } else {\n                indices[i] = -1;\n            }\n        }\n        return new PeriodType(getName() + name, types, indices);\n    }",
    "comment": " Removes the field specified by indices index.  @param indicesIndex  the index to remove @param name  the name addition @return the new type ",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 1
  },
  {
    "name": "PeriodType.withHoursRemoved",
    "class_name": "org.joda.time.PeriodType",
    "signature": "org.joda.time.PeriodType.withHoursRemoved()",
    "snippet": "    public PeriodType withHoursRemoved() {\n        return withFieldRemoved(4, \"NoHours\");\n    }",
    "comment": " Returns a version of this PeriodType instance that does not support hours.  @return a new period type that supports the original set of fields except hours ",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 1
  },
  {
    "name": "PeriodType.withMillisRemoved",
    "class_name": "org.joda.time.PeriodType",
    "signature": "org.joda.time.PeriodType.withMillisRemoved()",
    "snippet": "    public PeriodType withMillisRemoved() {\n        return withFieldRemoved(7, \"NoMillis\");\n    }",
    "comment": " Returns a version of this PeriodType instance that does not support milliseconds.  @return a new period type that supports the original set of fields except milliseconds ",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 1
  },
  {
    "name": "PeriodType.withMinutesRemoved",
    "class_name": "org.joda.time.PeriodType",
    "signature": "org.joda.time.PeriodType.withMinutesRemoved()",
    "snippet": "    public PeriodType withMinutesRemoved() {\n        return withFieldRemoved(5, \"NoMinutes\");\n    }",
    "comment": " Returns a version of this PeriodType instance that does not support minutes.  @return a new period type that supports the original set of fields except minutes ",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 1
  },
  {
    "name": "PeriodType.withSecondsRemoved",
    "class_name": "org.joda.time.PeriodType",
    "signature": "org.joda.time.PeriodType.withSecondsRemoved()",
    "snippet": "    public PeriodType withSecondsRemoved() {\n        return withFieldRemoved(6, \"NoSeconds\");\n    }",
    "comment": " Returns a version of this PeriodType instance that does not support seconds.  @return a new period type that supports the original set of fields except seconds ",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 1
  },
  {
    "name": "PeriodType.withYearsRemoved",
    "class_name": "org.joda.time.PeriodType",
    "signature": "org.joda.time.PeriodType.withYearsRemoved()",
    "snippet": "    public PeriodType withYearsRemoved() {\n        return withFieldRemoved(0, \"NoYears\");\n    }",
    "comment": " Returns a version of this PeriodType instance that does not support years.  @return a new period type that supports the original set of fields except years ",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 1
  },
  {
    "name": "PeriodType.yearDay",
    "class_name": "org.joda.time.PeriodType",
    "signature": "org.joda.time.PeriodType.yearDay()",
    "snippet": "    public static PeriodType yearDay() {\n        PeriodType type = cYD;\n        if (type == null) {\n            type = new PeriodType(\n                \"YearDay\",\n                new DurationFieldType[] {\n                    DurationFieldType.years(), DurationFieldType.days(),\n                },\n                new int[] { 0, -1, -1, 1, -1, -1, -1, -1, }\n            );\n            cYD = type;\n        }\n        return type;\n    }",
    "comment": " Gets a type that defines the year and day fields. <ul> <li>years <li>days </ul>  @return the period type @since 1.1 ",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 1
  },
  {
    "name": "PeriodType.yearDayTime",
    "class_name": "org.joda.time.PeriodType",
    "signature": "org.joda.time.PeriodType.yearDayTime()",
    "snippet": "    public static PeriodType yearDayTime() {\n        PeriodType type = cYDTime;\n        if (type == null) {\n            type = new PeriodType(\n                \"YearDayTime\",\n                new DurationFieldType[] {\n                    DurationFieldType.years(), DurationFieldType.days(),\n                    DurationFieldType.hours(), DurationFieldType.minutes(),\n                    DurationFieldType.seconds(), DurationFieldType.millis(),\n                },\n                new int[] { 0, -1, -1, 1, 2, 3, 4, 5, }\n            );\n            cYDTime = type;\n        }\n        return type;\n    }",
    "comment": " Gets a type that defines all standard fields except months and weeks. <ul> <li>years <li>days <li>hours <li>minutes <li>seconds <li>milliseconds </ul>  @return the period type ",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 1
  },
  {
    "name": "PeriodType.yearMonthDay",
    "class_name": "org.joda.time.PeriodType",
    "signature": "org.joda.time.PeriodType.yearMonthDay()",
    "snippet": "    public static PeriodType yearMonthDay() {\n        PeriodType type = cYMD;\n        if (type == null) {\n            type = new PeriodType(\n                \"YearMonthDay\",\n                new DurationFieldType[] {\n                    DurationFieldType.years(), DurationFieldType.months(),\n                    DurationFieldType.days(),\n                },\n                new int[] { 0, 1, -1, 2, -1, -1, -1, -1, }\n            );\n            cYMD = type;\n        }\n        return type;\n    }",
    "comment": " Gets a type that defines the year, month and day fields. <ul> <li>years <li>months <li>days </ul>  @return the period type @since 1.1 ",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 1
  },
  {
    "name": "PeriodType.yearMonthDayTime",
    "class_name": "org.joda.time.PeriodType",
    "signature": "org.joda.time.PeriodType.yearMonthDayTime()",
    "snippet": "    public static PeriodType yearMonthDayTime() {\n        PeriodType type = cYMDTime;\n        if (type == null) {\n            type = new PeriodType(\n                \"YearMonthDayTime\",\n                new DurationFieldType[] {\n                    DurationFieldType.years(), DurationFieldType.months(),\n                    DurationFieldType.days(),\n                    DurationFieldType.hours(), DurationFieldType.minutes(),\n                    DurationFieldType.seconds(), DurationFieldType.millis(),\n                },\n                new int[] { 0, 1, -1, 2, 3, 4, 5, 6, }\n            );\n            cYMDTime = type;\n        }\n        return type;\n    }",
    "comment": " Gets a type that defines all standard fields except weeks. <ul> <li>years <li>months <li>days <li>hours <li>minutes <li>seconds <li>milliseconds </ul>  @return the period type ",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 1
  },
  {
    "name": "PeriodType.yearWeekDay",
    "class_name": "org.joda.time.PeriodType",
    "signature": "org.joda.time.PeriodType.yearWeekDay()",
    "snippet": "    public static PeriodType yearWeekDay() {\n        PeriodType type = cYWD;\n        if (type == null) {\n            type = new PeriodType(\n                \"YearWeekDay\",\n                new DurationFieldType[] {\n                    DurationFieldType.years(),\n                    DurationFieldType.weeks(), DurationFieldType.days(),\n                },\n                new int[] { 0, -1, 1, 2, -1, -1, -1, -1, }\n            );\n            cYWD = type;\n        }\n        return type;\n    }",
    "comment": " Gets a type that defines year, week and day fields. <ul> <li>years <li>weeks <li>days </ul>  @return the period type @since 1.1 ",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 1
  },
  {
    "name": "PeriodType.yearWeekDayTime",
    "class_name": "org.joda.time.PeriodType",
    "signature": "org.joda.time.PeriodType.yearWeekDayTime()",
    "snippet": "    public static PeriodType yearWeekDayTime() {\n        PeriodType type = cYWDTime;\n        if (type == null) {\n            type = new PeriodType(\n                \"YearWeekDayTime\",\n                new DurationFieldType[] {\n                    DurationFieldType.years(),\n                    DurationFieldType.weeks(), DurationFieldType.days(),\n                    DurationFieldType.hours(), DurationFieldType.minutes(),\n                    DurationFieldType.seconds(), DurationFieldType.millis(),\n                },\n                new int[] { 0, -1, 1, 2, 3, 4, 5, 6, }\n            );\n            cYWDTime = type;\n        }\n        return type;\n    }",
    "comment": " Gets a type that defines all standard fields except months. <ul> <li>years <li>weeks <li>days <li>hours <li>minutes <li>seconds <li>milliseconds </ul>  @return the period type ",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 1
  },
  {
    "name": "PeriodType.years",
    "class_name": "org.joda.time.PeriodType",
    "signature": "org.joda.time.PeriodType.years()",
    "snippet": "    public static PeriodType years() {\n        PeriodType type = cYears;\n        if (type == null) {\n            type = new PeriodType(\n                \"Years\",\n                new DurationFieldType[] { DurationFieldType.years() },\n                new int[] { 0, -1, -1, -1, -1, -1, -1, -1, }\n            );\n            cYears = type;\n        }\n        return type;\n    }",
    "comment": " Gets a type that defines just the years field.  @return the period type ",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 1
  },
  {
    "name": "AbstractPeriod.AbstractPeriod",
    "class_name": "org.joda.time.base.AbstractPeriod",
    "signature": "org.joda.time.base.AbstractPeriod.AbstractPeriod()",
    "snippet": "    protected AbstractPeriod() {\n        super();\n    }",
    "comment": " Constructor. ",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 1
  },
  {
    "name": "AbstractPeriod.getFieldType",
    "class_name": "org.joda.time.base.AbstractPeriod",
    "signature": "org.joda.time.base.AbstractPeriod.getFieldType(int)",
    "snippet": "    public DurationFieldType getFieldType(int index) {\n        return getPeriodType().getFieldType(index);\n    }",
    "comment": " Gets the field type at the specified index.  @param index  the index to retrieve @return the field at the specified index @throws IndexOutOfBoundsException if the index is invalid @since 2.0 (previously on BasePeriod) ",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 1
  },
  {
    "name": "AbstractPeriod.getValues",
    "class_name": "org.joda.time.base.AbstractPeriod",
    "signature": "org.joda.time.base.AbstractPeriod.getValues()",
    "snippet": "    public int[] getValues() {\n        int[] result = new int[size()];\n        for (int i = 0; i < result.length; i++) {\n            result[i] = getValue(i);\n        }\n        return result;\n    }",
    "comment": " Gets an array of the value of each of the fields that this period supports. <p> The fields are returned largest to smallest, for example Hours, Minutes, Seconds. Each value corresponds to the same array index as <code>getFields()</code>  @return the current values of each field in an array that may be altered, largest to smallest ",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 1
  },
  {
    "name": "AbstractPeriod.indexOf",
    "class_name": "org.joda.time.base.AbstractPeriod",
    "signature": "org.joda.time.base.AbstractPeriod.indexOf(DurationFieldType)",
    "snippet": "    public int indexOf(DurationFieldType type) {\n        return getPeriodType().indexOf(type);\n    }",
    "comment": " Gets the index of the field in this period.  @param type  the type to check, may be null which returns -1 @return the index of -1 if not supported ",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 1
  },
  {
    "name": "AbstractPeriod.size",
    "class_name": "org.joda.time.base.AbstractPeriod",
    "signature": "org.joda.time.base.AbstractPeriod.size()",
    "snippet": "    public int size() {\n        return getPeriodType().size();\n    }",
    "comment": " Gets the number of fields that this period supports.  @return the number of fields supported @since 2.0 (previously on BasePeriod) ",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 1
  },
  {
    "name": "BasePeriod.BasePeriod",
    "class_name": "org.joda.time.base.BasePeriod",
    "signature": "org.joda.time.base.BasePeriod.BasePeriod(int,int,int,int,int,int,int,int,PeriodType)",
    "snippet": "    protected BasePeriod(int years, int months, int weeks, int days,\n                         int hours, int minutes, int seconds, int millis,\n                         PeriodType type) {\n        super();\n        type = checkPeriodType(type);\n        iType = type;\n        iValues = setPeriodInternal(years, months, weeks, days, hours, minutes, seconds, millis); // internal method\n    }",
    "comment": " Creates a period from a set of field values.  @param years  amount of years in this period, which must be zero if unsupported @param months  amount of months in this period, which must be zero if unsupported @param weeks  amount of weeks in this period, which must be zero if unsupported @param days  amount of days in this period, which must be zero if unsupported @param hours  amount of hours in this period, which must be zero if unsupported @param minutes  amount of minutes in this period, which must be zero if unsupported @param seconds  amount of seconds in this period, which must be zero if unsupported @param millis  amount of milliseconds in this period, which must be zero if unsupported @param type  which set of fields this period supports @throws IllegalArgumentException if period type is invalid @throws IllegalArgumentException if an unsupported field's value is non-zero ",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 1
  },
  {
    "name": "BasePeriod.BasePeriod",
    "class_name": "org.joda.time.base.BasePeriod",
    "signature": "org.joda.time.base.BasePeriod.BasePeriod(long,PeriodType,Chronology)",
    "snippet": "    protected BasePeriod(long duration, PeriodType type, Chronology chrono) {\n        super();\n        type = checkPeriodType(type);\n        chrono = DateTimeUtils.getChronology(chrono);\n        iType = type;\n        iValues = chrono.get(this, duration);\n    }",
    "comment": " Creates a period from the given millisecond duration, which is only really suitable for durations less than one day. <p> Only fields that are precise will be used. Thus the largest precise field may have a large value.  @param duration  the duration, in milliseconds @param type  which set of fields this period supports, null means standard @param chrono  the chronology to use, null means ISO default @throws IllegalArgumentException if period type is invalid ",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 1
  },
  {
    "name": "BasePeriod.checkAndUpdate",
    "class_name": "org.joda.time.base.BasePeriod",
    "signature": "org.joda.time.base.BasePeriod.checkAndUpdate(DurationFieldType,int[],int)",
    "snippet": "    private void checkAndUpdate(DurationFieldType type, int[] values, int newValue) {\n        int index = indexOf(type);\n        if (index == -1) {\n            if (newValue != 0) {\n                throw new IllegalArgumentException(\n                    \"Period does not support field '\" + type.getName() + \"'\");\n            }\n        } else {\n            values[index] = newValue;\n        }\n    }",
    "comment": " Checks whether a field type is supported, and if so adds the new value to the relevant index in the specified array.  @param type  the field type @param values  the array to update @param newValue  the new value to store if successful ",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 1
  },
  {
    "name": "BasePeriod.checkPeriodType",
    "class_name": "org.joda.time.base.BasePeriod",
    "signature": "org.joda.time.base.BasePeriod.checkPeriodType(PeriodType)",
    "snippet": "    protected PeriodType checkPeriodType(PeriodType type) {\n        return DateTimeUtils.getPeriodType(type);\n    }",
    "comment": " Validates a period type, converting nulls to a default value and checking the type is suitable for this instance.  @param type  the type to check, may be null @return the validated type to use, not null @throws IllegalArgumentException if the period type is invalid ",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 1
  },
  {
    "name": "BasePeriod.getPeriodType",
    "class_name": "org.joda.time.base.BasePeriod",
    "signature": "org.joda.time.base.BasePeriod.getPeriodType()",
    "snippet": "    public PeriodType getPeriodType() {\n        return iType;\n    }",
    "comment": " Gets the period type.  @return the period type ",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 1
  },
  {
    "name": "BasePeriod.getValue",
    "class_name": "org.joda.time.base.BasePeriod",
    "signature": "org.joda.time.base.BasePeriod.getValue(int)",
    "snippet": "    public int getValue(int index) {\n        return iValues[index];\n    }",
    "comment": " Gets the value at the specified index.  @param index  the index to retrieve @return the value of the field at the specified index @throws IndexOutOfBoundsException if the index is invalid ",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 1
  },
  {
    "name": "BasePeriod.setPeriodInternal",
    "class_name": "org.joda.time.base.BasePeriod",
    "signature": "org.joda.time.base.BasePeriod.setPeriodInternal(int,int,int,int,int,int,int,int)",
    "snippet": "    private int[] setPeriodInternal(int years, int months, int weeks, int days,\n                                   int hours, int minutes, int seconds, int millis) {\n        int[] newValues = new int[size()];\n        checkAndUpdate(DurationFieldType.years(), newValues, years);\n        checkAndUpdate(DurationFieldType.months(), newValues, months);\n        checkAndUpdate(DurationFieldType.weeks(), newValues, weeks);\n        checkAndUpdate(DurationFieldType.days(), newValues, days);\n        checkAndUpdate(DurationFieldType.hours(), newValues, hours);\n        checkAndUpdate(DurationFieldType.minutes(), newValues, minutes);\n        checkAndUpdate(DurationFieldType.seconds(), newValues, seconds);\n        checkAndUpdate(DurationFieldType.millis(), newValues, millis);\n        return newValues;\n    }",
    "comment": " Private method called from constructor. ",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 1
  },
  {
    "name": "AssembledChronology.AssembledChronology",
    "class_name": "org.joda.time.chrono.AssembledChronology",
    "signature": "org.joda.time.chrono.AssembledChronology.AssembledChronology(Chronology,Object)",
    "snippet": "    protected AssembledChronology(Chronology base, Object param) {\n        iBase = base;\n        iParam = param;\n        setFields();\n    }",
    "comment": " Constructor calls the assemble method, enabling subclasses to define its supported fields. If a base chronology is supplied, the field set initially contains references to each base chronology field. <p> Other methods in this class will delegate to the base chronology, if it can be determined that the base chronology will produce the same results as AbstractChronology.  @param base optional base chronology to copy initial fields from @param param optional param object avalable for assemble method ",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 1
  },
  {
    "name": "AssembledChronology.centuries",
    "class_name": "org.joda.time.chrono.AssembledChronology",
    "signature": "org.joda.time.chrono.AssembledChronology.centuries()",
    "snippet": "    public final DurationField centuries() {\n        return iCenturies;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 1
  },
  {
    "name": "AssembledChronology.centuryOfEra",
    "class_name": "org.joda.time.chrono.AssembledChronology",
    "signature": "org.joda.time.chrono.AssembledChronology.centuryOfEra()",
    "snippet": "    public final DateTimeField centuryOfEra() {\n        return iCenturyOfEra;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 1
  },
  {
    "name": "AssembledChronology.clockhourOfDay",
    "class_name": "org.joda.time.chrono.AssembledChronology",
    "signature": "org.joda.time.chrono.AssembledChronology.clockhourOfDay()",
    "snippet": "    public final DateTimeField clockhourOfDay() {\n        return iClockhourOfDay;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 1
  },
  {
    "name": "AssembledChronology.clockhourOfHalfday",
    "class_name": "org.joda.time.chrono.AssembledChronology",
    "signature": "org.joda.time.chrono.AssembledChronology.clockhourOfHalfday()",
    "snippet": "    public final DateTimeField clockhourOfHalfday() {\n        return iClockhourOfHalfday;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 1
  },
  {
    "name": "AssembledChronology.dayOfMonth",
    "class_name": "org.joda.time.chrono.AssembledChronology",
    "signature": "org.joda.time.chrono.AssembledChronology.dayOfMonth()",
    "snippet": "    public final DateTimeField dayOfMonth() {\n        return iDayOfMonth;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 1
  },
  {
    "name": "AssembledChronology.dayOfWeek",
    "class_name": "org.joda.time.chrono.AssembledChronology",
    "signature": "org.joda.time.chrono.AssembledChronology.dayOfWeek()",
    "snippet": "    public final DateTimeField dayOfWeek() {\n        return iDayOfWeek;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 1
  },
  {
    "name": "AssembledChronology.dayOfYear",
    "class_name": "org.joda.time.chrono.AssembledChronology",
    "signature": "org.joda.time.chrono.AssembledChronology.dayOfYear()",
    "snippet": "    public final DateTimeField dayOfYear() {\n        return iDayOfYear;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 1
  },
  {
    "name": "AssembledChronology.days",
    "class_name": "org.joda.time.chrono.AssembledChronology",
    "signature": "org.joda.time.chrono.AssembledChronology.days()",
    "snippet": "    public final DurationField days() {\n        return iDays;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 1
  },
  {
    "name": "AssembledChronology.era",
    "class_name": "org.joda.time.chrono.AssembledChronology",
    "signature": "org.joda.time.chrono.AssembledChronology.era()",
    "snippet": "    public final DateTimeField era() {\n        return iEra;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 1
  },
  {
    "name": "AssembledChronology.eras",
    "class_name": "org.joda.time.chrono.AssembledChronology",
    "signature": "org.joda.time.chrono.AssembledChronology.eras()",
    "snippet": "    public final DurationField eras() {\n        return iEras;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 1
  },
  {
    "name": "AssembledChronology.getBase",
    "class_name": "org.joda.time.chrono.AssembledChronology",
    "signature": "org.joda.time.chrono.AssembledChronology.getBase()",
    "snippet": "    protected final Chronology getBase() {\n        return iBase;\n    }",
    "comment": " Returns the same base chronology as passed into the constructor. ",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 1
  },
  {
    "name": "AssembledChronology.getParam",
    "class_name": "org.joda.time.chrono.AssembledChronology",
    "signature": "org.joda.time.chrono.AssembledChronology.getParam()",
    "snippet": "    protected final Object getParam() {\n        return iParam;\n    }",
    "comment": " Returns the same param object as passed into the constructor. ",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 1
  },
  {
    "name": "AssembledChronology.halfdayOfDay",
    "class_name": "org.joda.time.chrono.AssembledChronology",
    "signature": "org.joda.time.chrono.AssembledChronology.halfdayOfDay()",
    "snippet": "    public final DateTimeField halfdayOfDay() {\n        return iHalfdayOfDay;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 1
  },
  {
    "name": "AssembledChronology.halfdays",
    "class_name": "org.joda.time.chrono.AssembledChronology",
    "signature": "org.joda.time.chrono.AssembledChronology.halfdays()",
    "snippet": "    public final DurationField halfdays() {\n        return iHalfdays;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 1
  },
  {
    "name": "AssembledChronology.hourOfDay",
    "class_name": "org.joda.time.chrono.AssembledChronology",
    "signature": "org.joda.time.chrono.AssembledChronology.hourOfDay()",
    "snippet": "    public final DateTimeField hourOfDay() {\n        return iHourOfDay;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 1
  },
  {
    "name": "AssembledChronology.hourOfHalfday",
    "class_name": "org.joda.time.chrono.AssembledChronology",
    "signature": "org.joda.time.chrono.AssembledChronology.hourOfHalfday()",
    "snippet": "    public final DateTimeField hourOfHalfday() {\n        return iHourOfHalfday;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 1
  },
  {
    "name": "AssembledChronology.hours",
    "class_name": "org.joda.time.chrono.AssembledChronology",
    "signature": "org.joda.time.chrono.AssembledChronology.hours()",
    "snippet": "    public final DurationField hours() {\n        return iHours;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 1
  },
  {
    "name": "AssembledChronology.millis",
    "class_name": "org.joda.time.chrono.AssembledChronology",
    "signature": "org.joda.time.chrono.AssembledChronology.millis()",
    "snippet": "    public final DurationField millis() {\n        return iMillis;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 1
  },
  {
    "name": "AssembledChronology.millisOfDay",
    "class_name": "org.joda.time.chrono.AssembledChronology",
    "signature": "org.joda.time.chrono.AssembledChronology.millisOfDay()",
    "snippet": "    public final DateTimeField millisOfDay() {\n        return iMillisOfDay;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 1
  },
  {
    "name": "AssembledChronology.millisOfSecond",
    "class_name": "org.joda.time.chrono.AssembledChronology",
    "signature": "org.joda.time.chrono.AssembledChronology.millisOfSecond()",
    "snippet": "    public final DateTimeField millisOfSecond() {\n        return iMillisOfSecond;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 1
  },
  {
    "name": "AssembledChronology.minuteOfDay",
    "class_name": "org.joda.time.chrono.AssembledChronology",
    "signature": "org.joda.time.chrono.AssembledChronology.minuteOfDay()",
    "snippet": "    public final DateTimeField minuteOfDay() {\n        return iMinuteOfDay;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 1
  },
  {
    "name": "AssembledChronology.minuteOfHour",
    "class_name": "org.joda.time.chrono.AssembledChronology",
    "signature": "org.joda.time.chrono.AssembledChronology.minuteOfHour()",
    "snippet": "    public final DateTimeField minuteOfHour() {\n        return iMinuteOfHour;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 1
  },
  {
    "name": "AssembledChronology.minutes",
    "class_name": "org.joda.time.chrono.AssembledChronology",
    "signature": "org.joda.time.chrono.AssembledChronology.minutes()",
    "snippet": "    public final DurationField minutes() {\n        return iMinutes;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 1
  },
  {
    "name": "AssembledChronology.monthOfYear",
    "class_name": "org.joda.time.chrono.AssembledChronology",
    "signature": "org.joda.time.chrono.AssembledChronology.monthOfYear()",
    "snippet": "    public final DateTimeField monthOfYear() {\n        return iMonthOfYear;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 1
  },
  {
    "name": "AssembledChronology.months",
    "class_name": "org.joda.time.chrono.AssembledChronology",
    "signature": "org.joda.time.chrono.AssembledChronology.months()",
    "snippet": "    public final DurationField months() {\n        return iMonths;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 1
  },
  {
    "name": "AssembledChronology.secondOfDay",
    "class_name": "org.joda.time.chrono.AssembledChronology",
    "signature": "org.joda.time.chrono.AssembledChronology.secondOfDay()",
    "snippet": "    public final DateTimeField secondOfDay() {\n        return iSecondOfDay;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 1
  },
  {
    "name": "AssembledChronology.secondOfMinute",
    "class_name": "org.joda.time.chrono.AssembledChronology",
    "signature": "org.joda.time.chrono.AssembledChronology.secondOfMinute()",
    "snippet": "    public final DateTimeField secondOfMinute() {\n        return iSecondOfMinute;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 1
  },
  {
    "name": "AssembledChronology.seconds",
    "class_name": "org.joda.time.chrono.AssembledChronology",
    "signature": "org.joda.time.chrono.AssembledChronology.seconds()",
    "snippet": "    public final DurationField seconds() {\n        return iSeconds;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 1
  },
  {
    "name": "AssembledChronology.setFields",
    "class_name": "org.joda.time.chrono.AssembledChronology",
    "signature": "org.joda.time.chrono.AssembledChronology.setFields()",
    "snippet": "    private void setFields() {\n        Fields fields = new Fields();\n        if (iBase != null) {\n            fields.copyFieldsFrom(iBase);\n        }\n        assemble(fields);\n\n        {\n            DurationField f;\n            iMillis    = (f = fields.millis)    != null ? f : super.millis();\n            iSeconds   = (f = fields.seconds)   != null ? f : super.seconds();\n            iMinutes   = (f = fields.minutes)   != null ? f : super.minutes();\n            iHours     = (f = fields.hours)     != null ? f : super.hours();\n            iHalfdays  = (f = fields.halfdays)  != null ? f : super.halfdays();\n            iDays      = (f = fields.days)      != null ? f : super.days();\n            iWeeks     = (f = fields.weeks)     != null ? f : super.weeks();\n            iWeekyears = (f = fields.weekyears) != null ? f : super.weekyears();\n            iMonths    = (f = fields.months)    != null ? f : super.months();\n            iYears     = (f = fields.years)     != null ? f : super.years();\n            iCenturies = (f = fields.centuries) != null ? f : super.centuries();\n            iEras      = (f = fields.eras)      != null ? f : super.eras();\n        }\n\n        {\n            DateTimeField f;\n            iMillisOfSecond     = (f = fields.millisOfSecond)     != null ? f : super.millisOfSecond();\n            iMillisOfDay        = (f = fields.millisOfDay)        != null ? f : super.millisOfDay();\n            iSecondOfMinute     = (f = fields.secondOfMinute)     != null ? f : super.secondOfMinute();\n            iSecondOfDay        = (f = fields.secondOfDay)        != null ? f : super.secondOfDay();\n            iMinuteOfHour       = (f = fields.minuteOfHour)       != null ? f : super.minuteOfHour();\n            iMinuteOfDay        = (f = fields.minuteOfDay)        != null ? f : super.minuteOfDay();\n            iHourOfDay          = (f = fields.hourOfDay)          != null ? f : super.hourOfDay();\n            iClockhourOfDay     = (f = fields.clockhourOfDay)     != null ? f : super.clockhourOfDay();\n            iHourOfHalfday      = (f = fields.hourOfHalfday)      != null ? f : super.hourOfHalfday();\n            iClockhourOfHalfday = (f = fields.clockhourOfHalfday) != null ? f : super.clockhourOfHalfday();\n            iHalfdayOfDay       = (f = fields.halfdayOfDay)       != null ? f : super.halfdayOfDay();\n            iDayOfWeek          = (f = fields.dayOfWeek)          != null ? f : super.dayOfWeek();\n            iDayOfMonth         = (f = fields.dayOfMonth)         != null ? f : super.dayOfMonth();\n            iDayOfYear          = (f = fields.dayOfYear)          != null ? f : super.dayOfYear();\n            iWeekOfWeekyear     = (f = fields.weekOfWeekyear)     != null ? f : super.weekOfWeekyear();\n            iWeekyear           = (f = fields.weekyear)           != null ? f : super.weekyear();\n            iWeekyearOfCentury  = (f = fields.weekyearOfCentury)  != null ? f : super.weekyearOfCentury();\n            iMonthOfYear        = (f = fields.monthOfYear)        != null ? f : super.monthOfYear();\n            iYear               = (f = fields.year)               != null ? f : super.year();\n            iYearOfEra          = (f = fields.yearOfEra)          != null ? f : super.yearOfEra();\n            iYearOfCentury      = (f = fields.yearOfCentury)      != null ? f : super.yearOfCentury();\n            iCenturyOfEra       = (f = fields.centuryOfEra)       != null ? f : super.centuryOfEra();\n            iEra                = (f = fields.era)                != null ? f : super.era();\n        }\n\n        int flags;\n        if (iBase == null) {\n            flags = 0;\n        } else {\n            flags = \n                ((iHourOfDay      == iBase.hourOfDay()      &&\n                  iMinuteOfHour   == iBase.minuteOfHour()   &&\n                  iSecondOfMinute == iBase.secondOfMinute() &&\n                  iMillisOfSecond == iBase.millisOfSecond()   ) ? 1 : 0) |\n\n                ((iMillisOfDay == iBase.millisOfDay()) ? 2 : 0) |\n\n                ((iYear        == iBase.year()        &&\n                  iMonthOfYear == iBase.monthOfYear() &&\n                  iDayOfMonth  == iBase.dayOfMonth()    ) ? 4 : 0);\n        }\n\n        iBaseFlags = flags;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 1
  },
  {
    "name": "AssembledChronology.weekOfWeekyear",
    "class_name": "org.joda.time.chrono.AssembledChronology",
    "signature": "org.joda.time.chrono.AssembledChronology.weekOfWeekyear()",
    "snippet": "    public final DateTimeField weekOfWeekyear() {\n        return iWeekOfWeekyear;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 1
  },
  {
    "name": "AssembledChronology.weeks",
    "class_name": "org.joda.time.chrono.AssembledChronology",
    "signature": "org.joda.time.chrono.AssembledChronology.weeks()",
    "snippet": "    public final DurationField weeks() {\n        return iWeeks;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 1
  },
  {
    "name": "AssembledChronology.weekyear",
    "class_name": "org.joda.time.chrono.AssembledChronology",
    "signature": "org.joda.time.chrono.AssembledChronology.weekyear()",
    "snippet": "    public final DateTimeField weekyear() {\n        return iWeekyear;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 1
  },
  {
    "name": "AssembledChronology.weekyearOfCentury",
    "class_name": "org.joda.time.chrono.AssembledChronology",
    "signature": "org.joda.time.chrono.AssembledChronology.weekyearOfCentury()",
    "snippet": "    public final DateTimeField weekyearOfCentury() {\n        return iWeekyearOfCentury;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 1
  },
  {
    "name": "AssembledChronology.weekyears",
    "class_name": "org.joda.time.chrono.AssembledChronology",
    "signature": "org.joda.time.chrono.AssembledChronology.weekyears()",
    "snippet": "    public final DurationField weekyears() {\n        return iWeekyears;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 1
  },
  {
    "name": "AssembledChronology.year",
    "class_name": "org.joda.time.chrono.AssembledChronology",
    "signature": "org.joda.time.chrono.AssembledChronology.year()",
    "snippet": "    public final DateTimeField year() {\n        return iYear;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 1
  },
  {
    "name": "AssembledChronology.yearOfCentury",
    "class_name": "org.joda.time.chrono.AssembledChronology",
    "signature": "org.joda.time.chrono.AssembledChronology.yearOfCentury()",
    "snippet": "    public final DateTimeField yearOfCentury() {\n        return iYearOfCentury;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 1
  },
  {
    "name": "AssembledChronology.yearOfEra",
    "class_name": "org.joda.time.chrono.AssembledChronology",
    "signature": "org.joda.time.chrono.AssembledChronology.yearOfEra()",
    "snippet": "    public final DateTimeField yearOfEra() {\n        return iYearOfEra;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 1
  },
  {
    "name": "AssembledChronology.years",
    "class_name": "org.joda.time.chrono.AssembledChronology",
    "signature": "org.joda.time.chrono.AssembledChronology.years()",
    "snippet": "    public final DurationField years() {\n        return iYears;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 1
  },
  {
    "name": "Fields.copyFieldsFrom",
    "class_name": "org.joda.time.chrono.AssembledChronology$Fields",
    "signature": "org.joda.time.chrono.AssembledChronology$Fields.copyFieldsFrom(Chronology)",
    "snippet": "        public void copyFieldsFrom(Chronology chrono) {\n            {\n                DurationField f;\n                if (isSupported(f = chrono.millis())) {\n                    millis = f;\n                }\n                if (isSupported(f = chrono.seconds())) {\n                    seconds = f;\n                }\n                if (isSupported(f = chrono.minutes())) {\n                    minutes = f;\n                }\n                if (isSupported(f = chrono.hours())) {\n                    hours = f;\n                }\n                if (isSupported(f = chrono.halfdays())) {\n                    halfdays = f;\n                }\n                if (isSupported(f = chrono.days())) {\n                    days = f;\n                }\n                if (isSupported(f = chrono.weeks())) {\n                    weeks = f;\n                }\n                if (isSupported(f = chrono.weekyears())) {\n                    weekyears = f;\n                }\n                if (isSupported(f = chrono.months())) {\n                    months = f;\n                }\n                if (isSupported(f = chrono.years())) {\n                    years = f;\n                }\n                if (isSupported(f = chrono.centuries())) {\n                    centuries = f;\n                }\n                if (isSupported(f = chrono.eras())) {\n                    eras = f;\n                }\n            }\n\n            {\n                DateTimeField f;\n                if (isSupported(f = chrono.millisOfSecond())) {\n                    millisOfSecond = f;\n                }\n                if (isSupported(f = chrono.millisOfDay())) {\n                    millisOfDay = f;\n                }\n                if (isSupported(f = chrono.secondOfMinute())) {\n                    secondOfMinute = f;\n                }\n                if (isSupported(f = chrono.secondOfDay())) {\n                    secondOfDay = f;\n                }\n                if (isSupported(f = chrono.minuteOfHour())) {\n                    minuteOfHour = f;\n                }\n                if (isSupported(f = chrono.minuteOfDay())) {\n                    minuteOfDay = f;\n                }\n                if (isSupported(f = chrono.hourOfDay())) {\n                    hourOfDay = f;\n                }\n                if (isSupported(f = chrono.clockhourOfDay())) {\n                    clockhourOfDay = f;\n                }\n                if (isSupported(f = chrono.hourOfHalfday())) {\n                    hourOfHalfday = f;\n                }\n                if (isSupported(f = chrono.clockhourOfHalfday())) {\n                    clockhourOfHalfday = f;\n                }\n                if (isSupported(f = chrono.halfdayOfDay())) {\n                    halfdayOfDay = f;\n                }\n                if (isSupported(f = chrono.dayOfWeek())) {\n                    dayOfWeek = f;\n                }\n                if (isSupported(f = chrono.dayOfMonth())) {\n                    dayOfMonth = f;\n                }\n                if (isSupported(f = chrono.dayOfYear())) {\n                    dayOfYear = f;\n                }\n                if (isSupported(f = chrono.weekOfWeekyear())) {\n                    weekOfWeekyear = f;\n                }\n                if (isSupported(f = chrono.weekyear())) {\n                    weekyear = f;\n                }\n                if (isSupported(f = chrono.weekyearOfCentury())) {\n                    weekyearOfCentury = f;\n                }\n                if (isSupported(f = chrono.monthOfYear())) {\n                    monthOfYear = f;\n                }\n                if (isSupported(f = chrono.year())) {\n                    year = f;\n                }\n                if (isSupported(f = chrono.yearOfEra())) {\n                    yearOfEra = f;\n                }\n                if (isSupported(f = chrono.yearOfCentury())) {\n                    yearOfCentury = f;\n                }\n                if (isSupported(f = chrono.centuryOfEra())) {\n                    centuryOfEra = f;\n                }\n                if (isSupported(f = chrono.era())) {\n                    era = f;\n                }\n            }\n        }",
    "comment": " Copy the supported fields from a chronology into this container. ",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 1
  },
  {
    "name": "Fields.isSupported",
    "class_name": "org.joda.time.chrono.AssembledChronology$Fields",
    "signature": "org.joda.time.chrono.AssembledChronology$Fields.isSupported(DateTimeField)",
    "snippet": "        private static boolean isSupported(DateTimeField field) {\n            return field == null ? false : field.isSupported();\n        }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 1
  },
  {
    "name": "Fields.isSupported",
    "class_name": "org.joda.time.chrono.AssembledChronology$Fields",
    "signature": "org.joda.time.chrono.AssembledChronology$Fields.isSupported(DurationField)",
    "snippet": "        private static boolean isSupported(DurationField field) {\n            return field == null ? false : field.isSupported();\n        }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 1
  },
  {
    "name": "BaseChronology.BaseChronology",
    "class_name": "org.joda.time.chrono.BaseChronology",
    "signature": "org.joda.time.chrono.BaseChronology.BaseChronology()",
    "snippet": "    protected BaseChronology() {\n        super();\n    }",
    "comment": " Restricted constructor. ",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 1
  },
  {
    "name": "BaseChronology.eras",
    "class_name": "org.joda.time.chrono.BaseChronology",
    "signature": "org.joda.time.chrono.BaseChronology.eras()",
    "snippet": "    public DurationField eras() {\n        return UnsupportedDurationField.getInstance(DurationFieldType.eras());\n    }",
    "comment": " Get the eras duration field for this chronology.  @return DurationField or UnsupportedDurationField if unsupported ",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 1
  },
  {
    "name": "BaseChronology.get",
    "class_name": "org.joda.time.chrono.BaseChronology",
    "signature": "org.joda.time.chrono.BaseChronology.get(ReadablePeriod,long)",
    "snippet": "    public int[] get(ReadablePeriod period, long duration) {\n        int size = period.size();\n        int[] values = new int[size];\n        if (duration != 0) {\n            long current = 0;\n            for (int i = 0; i < size; i++) {\n                DurationField field = period.getFieldType(i).getField(this);\n                if (field.isPrecise()) {\n                    int value = field.getDifference(duration, current);\n                    current = field.add(current, value);\n                    values[i] = value;\n                }\n            }\n        }\n        return values;\n    }",
    "comment": " Gets the values of a period from an interval.  @param period  the period instant to use @param duration  the duration to query @return the values of the period extracted from the duration ",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 1
  },
  {
    "name": "BasicChronology.BasicChronology",
    "class_name": "org.joda.time.chrono.BasicChronology",
    "signature": "org.joda.time.chrono.BasicChronology.BasicChronology(Chronology,Object,int)",
    "snippet": "    BasicChronology(Chronology base, Object param, int minDaysInFirstWeek) {\n        super(base, param);\n\n        if (minDaysInFirstWeek < 1 || minDaysInFirstWeek > 7) {\n            throw new IllegalArgumentException\n                (\"Invalid min days in first week: \" + minDaysInFirstWeek);\n        }\n\n        iMinDaysInFirstWeek = minDaysInFirstWeek;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 1
  },
  {
    "name": "BasicChronology.assemble",
    "class_name": "org.joda.time.chrono.BasicChronology",
    "signature": "org.joda.time.chrono.BasicChronology.assemble(Fields)",
    "snippet": "    protected void assemble(Fields fields) {\n        // First copy fields that are the same for all Gregorian and Julian\n        // chronologies.\n\n        fields.millis = cMillisField;\n        fields.seconds = cSecondsField;\n        fields.minutes = cMinutesField;\n        fields.hours = cHoursField;\n        fields.halfdays = cHalfdaysField;\n        fields.days = cDaysField;\n        fields.weeks = cWeeksField;\n\n        fields.millisOfSecond = cMillisOfSecondField;\n        fields.millisOfDay = cMillisOfDayField;\n        fields.secondOfMinute = cSecondOfMinuteField;\n        fields.secondOfDay = cSecondOfDayField;\n        fields.minuteOfHour = cMinuteOfHourField;\n        fields.minuteOfDay = cMinuteOfDayField;\n        fields.hourOfDay = cHourOfDayField;\n        fields.hourOfHalfday = cHourOfHalfdayField;\n        fields.clockhourOfDay = cClockhourOfDayField;\n        fields.clockhourOfHalfday = cClockhourOfHalfdayField;\n        fields.halfdayOfDay = cHalfdayOfDayField;\n\n        // Now create fields that have unique behavior for Gregorian and Julian\n        // chronologies.\n\n        fields.year = new BasicYearDateTimeField(this);\n        fields.yearOfEra = new GJYearOfEraDateTimeField(fields.year, this);\n\n        // Define one-based centuryOfEra and yearOfCentury.\n        DateTimeField field = new OffsetDateTimeField(\n            fields.yearOfEra, 99);\n        fields.centuryOfEra = new DividedDateTimeField(\n            field, DateTimeFieldType.centuryOfEra(), 100);\n        \n        field = new RemainderDateTimeField(\n            (DividedDateTimeField) fields.centuryOfEra);\n        fields.yearOfCentury = new OffsetDateTimeField(\n            field, DateTimeFieldType.yearOfCentury(), 1);\n\n        fields.era = new GJEraDateTimeField(this);\n        fields.dayOfWeek = new GJDayOfWeekDateTimeField(this, fields.days);\n        fields.dayOfMonth = new BasicDayOfMonthDateTimeField(this, fields.days);\n        fields.dayOfYear = new BasicDayOfYearDateTimeField(this, fields.days);\n        fields.monthOfYear = new GJMonthOfYearDateTimeField(this);\n        fields.weekyear = new BasicWeekyearDateTimeField(this);\n        fields.weekOfWeekyear = new BasicWeekOfWeekyearDateTimeField(this, fields.weeks);\n        \n        field = new RemainderDateTimeField(\n            fields.weekyear, DateTimeFieldType.weekyearOfCentury(), 100);\n        fields.weekyearOfCentury = new OffsetDateTimeField(\n            field, DateTimeFieldType.weekyearOfCentury(), 1);\n        \n        // The remaining (imprecise) durations are available from the newly\n        // created datetime fields.\n\n        fields.years = fields.year.getDurationField();\n        fields.centuries = fields.centuryOfEra.getDurationField();\n        fields.months = fields.monthOfYear.getDurationField();\n        fields.weekyears = fields.weekyear.getDurationField();\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 1
  },
  {
    "name": "BasicChronology.getMaxMonth",
    "class_name": "org.joda.time.chrono.BasicChronology",
    "signature": "org.joda.time.chrono.BasicChronology.getMaxMonth()",
    "snippet": "    int getMaxMonth() {\n        return 12;\n    }",
    "comment": " Gets the maximum number of months.  @return 12 ",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 1
  },
  {
    "name": "BasicChronology.getZone",
    "class_name": "org.joda.time.chrono.BasicChronology",
    "signature": "org.joda.time.chrono.BasicChronology.getZone()",
    "snippet": "    public DateTimeZone getZone() {\n        Chronology base;\n        if ((base = getBase()) != null) {\n            return base.getZone();\n        }\n        return DateTimeZone.UTC;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 1
  },
  {
    "name": "BasicDayOfMonthDateTimeField.BasicDayOfMonthDateTimeField",
    "class_name": "org.joda.time.chrono.BasicDayOfMonthDateTimeField",
    "signature": "org.joda.time.chrono.BasicDayOfMonthDateTimeField.BasicDayOfMonthDateTimeField(BasicChronology,DurationField)",
    "snippet": "    BasicDayOfMonthDateTimeField(BasicChronology chronology, DurationField days) {\n        super(DateTimeFieldType.dayOfMonth(), days);\n        iChronology = chronology;\n    }",
    "comment": " Restricted constructor. ",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 1
  },
  {
    "name": "BasicDayOfMonthDateTimeField.getRangeDurationField",
    "class_name": "org.joda.time.chrono.BasicDayOfMonthDateTimeField",
    "signature": "org.joda.time.chrono.BasicDayOfMonthDateTimeField.getRangeDurationField()",
    "snippet": "    public DurationField getRangeDurationField() {\n        return iChronology.months();\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 1
  },
  {
    "name": "BasicDayOfYearDateTimeField.BasicDayOfYearDateTimeField",
    "class_name": "org.joda.time.chrono.BasicDayOfYearDateTimeField",
    "signature": "org.joda.time.chrono.BasicDayOfYearDateTimeField.BasicDayOfYearDateTimeField(BasicChronology,DurationField)",
    "snippet": "    BasicDayOfYearDateTimeField(BasicChronology chronology, DurationField days) {\n        super(DateTimeFieldType.dayOfYear(), days);\n        iChronology = chronology;\n    }",
    "comment": " Restricted constructor ",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 1
  },
  {
    "name": "BasicDayOfYearDateTimeField.getRangeDurationField",
    "class_name": "org.joda.time.chrono.BasicDayOfYearDateTimeField",
    "signature": "org.joda.time.chrono.BasicDayOfYearDateTimeField.getRangeDurationField()",
    "snippet": "    public DurationField getRangeDurationField() {\n        return iChronology.years();\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 1
  },
  {
    "name": "BasicGJChronology.BasicGJChronology",
    "class_name": "org.joda.time.chrono.BasicGJChronology",
    "signature": "org.joda.time.chrono.BasicGJChronology.BasicGJChronology(Chronology,Object,int)",
    "snippet": "    BasicGJChronology(Chronology base, Object param, int minDaysInFirstWeek) {\n        super(base, param, minDaysInFirstWeek);\n    }",
    "comment": " Constructor. ",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 1
  },
  {
    "name": "BasicMonthOfYearDateTimeField.BasicMonthOfYearDateTimeField",
    "class_name": "org.joda.time.chrono.BasicMonthOfYearDateTimeField",
    "signature": "org.joda.time.chrono.BasicMonthOfYearDateTimeField.BasicMonthOfYearDateTimeField(BasicChronology,int)",
    "snippet": "    BasicMonthOfYearDateTimeField(BasicChronology chronology, int leapMonth) {\n        super(DateTimeFieldType.monthOfYear(), chronology.getAverageMillisPerMonth());\n        iChronology = chronology;\n        iMax = iChronology.getMaxMonth();\n        iLeapMonth = leapMonth;\n    }",
    "comment": " Restricted constructor.  @param leapMonth the month of year that leaps ",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 1
  },
  {
    "name": "BasicMonthOfYearDateTimeField.getLeapDurationField",
    "class_name": "org.joda.time.chrono.BasicMonthOfYearDateTimeField",
    "signature": "org.joda.time.chrono.BasicMonthOfYearDateTimeField.getLeapDurationField()",
    "snippet": "    public DurationField getLeapDurationField() {\n        return iChronology.days();\n    }",
    "comment": "-----------------------------------------------------------------------",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 1
  },
  {
    "name": "BasicMonthOfYearDateTimeField.getRangeDurationField",
    "class_name": "org.joda.time.chrono.BasicMonthOfYearDateTimeField",
    "signature": "org.joda.time.chrono.BasicMonthOfYearDateTimeField.getRangeDurationField()",
    "snippet": "    public DurationField getRangeDurationField() {\n        return iChronology.years();\n    }",
    "comment": "-----------------------------------------------------------------------",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 1
  },
  {
    "name": "BasicWeekOfWeekyearDateTimeField.BasicWeekOfWeekyearDateTimeField",
    "class_name": "org.joda.time.chrono.BasicWeekOfWeekyearDateTimeField",
    "signature": "org.joda.time.chrono.BasicWeekOfWeekyearDateTimeField.BasicWeekOfWeekyearDateTimeField(BasicChronology,DurationField)",
    "snippet": "    BasicWeekOfWeekyearDateTimeField(BasicChronology chronology, DurationField weeks) {\n        super(DateTimeFieldType.weekOfWeekyear(), weeks);\n        iChronology = chronology;\n    }",
    "comment": " Restricted constructor ",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 1
  },
  {
    "name": "BasicWeekOfWeekyearDateTimeField.getRangeDurationField",
    "class_name": "org.joda.time.chrono.BasicWeekOfWeekyearDateTimeField",
    "signature": "org.joda.time.chrono.BasicWeekOfWeekyearDateTimeField.getRangeDurationField()",
    "snippet": "    public DurationField getRangeDurationField() {\n        return iChronology.weekyears();\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 1
  },
  {
    "name": "BasicWeekyearDateTimeField.BasicWeekyearDateTimeField",
    "class_name": "org.joda.time.chrono.BasicWeekyearDateTimeField",
    "signature": "org.joda.time.chrono.BasicWeekyearDateTimeField.BasicWeekyearDateTimeField(BasicChronology)",
    "snippet": "    BasicWeekyearDateTimeField(BasicChronology chronology) {\n        super(DateTimeFieldType.weekyear(), chronology.getAverageMillisPerYear());\n        iChronology = chronology;\n    }",
    "comment": " Restricted constructor ",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 1
  },
  {
    "name": "BasicWeekyearDateTimeField.getLeapDurationField",
    "class_name": "org.joda.time.chrono.BasicWeekyearDateTimeField",
    "signature": "org.joda.time.chrono.BasicWeekyearDateTimeField.getLeapDurationField()",
    "snippet": "    public DurationField getLeapDurationField() {\n        return iChronology.weeks();\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 1
  },
  {
    "name": "BasicWeekyearDateTimeField.getRangeDurationField",
    "class_name": "org.joda.time.chrono.BasicWeekyearDateTimeField",
    "signature": "org.joda.time.chrono.BasicWeekyearDateTimeField.getRangeDurationField()",
    "snippet": "    public DurationField getRangeDurationField() {\n        return null;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 1
  },
  {
    "name": "BasicYearDateTimeField.BasicYearDateTimeField",
    "class_name": "org.joda.time.chrono.BasicYearDateTimeField",
    "signature": "org.joda.time.chrono.BasicYearDateTimeField.BasicYearDateTimeField(BasicChronology)",
    "snippet": "    BasicYearDateTimeField(BasicChronology chronology) {\n        super(DateTimeFieldType.year(), chronology.getAverageMillisPerYear());\n        iChronology = chronology;\n    }",
    "comment": " Restricted constructor.  @param chronology  the chronology this field belogs to ",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 1
  },
  {
    "name": "BasicYearDateTimeField.getLeapDurationField",
    "class_name": "org.joda.time.chrono.BasicYearDateTimeField",
    "signature": "org.joda.time.chrono.BasicYearDateTimeField.getLeapDurationField()",
    "snippet": "    public DurationField getLeapDurationField() {\n        return iChronology.days();\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 1
  },
  {
    "name": "BasicYearDateTimeField.getMaximumValue",
    "class_name": "org.joda.time.chrono.BasicYearDateTimeField",
    "signature": "org.joda.time.chrono.BasicYearDateTimeField.getMaximumValue()",
    "snippet": "    public int getMaximumValue() {\n        return iChronology.getMaxYear();\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 1
  },
  {
    "name": "BasicYearDateTimeField.getRangeDurationField",
    "class_name": "org.joda.time.chrono.BasicYearDateTimeField",
    "signature": "org.joda.time.chrono.BasicYearDateTimeField.getRangeDurationField()",
    "snippet": "    public DurationField getRangeDurationField() {\n        return null;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 1
  },
  {
    "name": "GJDayOfWeekDateTimeField.GJDayOfWeekDateTimeField",
    "class_name": "org.joda.time.chrono.GJDayOfWeekDateTimeField",
    "signature": "org.joda.time.chrono.GJDayOfWeekDateTimeField.GJDayOfWeekDateTimeField(BasicChronology,DurationField)",
    "snippet": "    GJDayOfWeekDateTimeField(BasicChronology chronology, DurationField days) {\n        super(DateTimeFieldType.dayOfWeek(), days);\n        iChronology = chronology;\n    }",
    "comment": " Restricted constructor. ",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 1
  },
  {
    "name": "GJDayOfWeekDateTimeField.getRangeDurationField",
    "class_name": "org.joda.time.chrono.GJDayOfWeekDateTimeField",
    "signature": "org.joda.time.chrono.GJDayOfWeekDateTimeField.getRangeDurationField()",
    "snippet": "    public DurationField getRangeDurationField() {\n        return iChronology.weeks();\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 1
  },
  {
    "name": "GJEraDateTimeField.GJEraDateTimeField",
    "class_name": "org.joda.time.chrono.GJEraDateTimeField",
    "signature": "org.joda.time.chrono.GJEraDateTimeField.GJEraDateTimeField(BasicChronology)",
    "snippet": "    GJEraDateTimeField(BasicChronology chronology) {\n        super(DateTimeFieldType.era());\n        iChronology = chronology;\n    }",
    "comment": " Restricted constructor ",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 1
  },
  {
    "name": "GJEraDateTimeField.getDurationField",
    "class_name": "org.joda.time.chrono.GJEraDateTimeField",
    "signature": "org.joda.time.chrono.GJEraDateTimeField.getDurationField()",
    "snippet": "    public DurationField getDurationField() {\n        return UnsupportedDurationField.getInstance(DurationFieldType.eras());\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 1
  },
  {
    "name": "GJEraDateTimeField.getRangeDurationField",
    "class_name": "org.joda.time.chrono.GJEraDateTimeField",
    "signature": "org.joda.time.chrono.GJEraDateTimeField.getRangeDurationField()",
    "snippet": "    public DurationField getRangeDurationField() {\n        return null;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 1
  },
  {
    "name": "GJMonthOfYearDateTimeField.GJMonthOfYearDateTimeField",
    "class_name": "org.joda.time.chrono.GJMonthOfYearDateTimeField",
    "signature": "org.joda.time.chrono.GJMonthOfYearDateTimeField.GJMonthOfYearDateTimeField(BasicChronology)",
    "snippet": "    GJMonthOfYearDateTimeField(BasicChronology chronology) {\n        super(chronology, 2);\n    }",
    "comment": " Restricted constructor ",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 1
  },
  {
    "name": "GJYearOfEraDateTimeField.GJYearOfEraDateTimeField",
    "class_name": "org.joda.time.chrono.GJYearOfEraDateTimeField",
    "signature": "org.joda.time.chrono.GJYearOfEraDateTimeField.GJYearOfEraDateTimeField(DateTimeField,BasicChronology)",
    "snippet": "    GJYearOfEraDateTimeField(DateTimeField yearField, BasicChronology chronology) {\n        super(yearField, DateTimeFieldType.yearOfEra());\n        iChronology = chronology;\n    }",
    "comment": " Restricted constructor. ",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 1
  },
  {
    "name": "GJYearOfEraDateTimeField.getMaximumValue",
    "class_name": "org.joda.time.chrono.GJYearOfEraDateTimeField",
    "signature": "org.joda.time.chrono.GJYearOfEraDateTimeField.getMaximumValue()",
    "snippet": "    public int getMaximumValue() {\n        return getWrappedField().getMaximumValue();\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 1
  },
  {
    "name": "GJYearOfEraDateTimeField.getMinimumValue",
    "class_name": "org.joda.time.chrono.GJYearOfEraDateTimeField",
    "signature": "org.joda.time.chrono.GJYearOfEraDateTimeField.getMinimumValue()",
    "snippet": "    public int getMinimumValue() {\n        return 1;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 1
  },
  {
    "name": "GregorianChronology.assemble",
    "class_name": "org.joda.time.chrono.GregorianChronology",
    "signature": "org.joda.time.chrono.GregorianChronology.assemble(Fields)",
    "snippet": "    protected void assemble(Fields fields) {\n        if (getBase() == null) {\n            super.assemble(fields);\n        }\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 1
  },
  {
    "name": "GregorianChronology.getAverageMillisPerMonth",
    "class_name": "org.joda.time.chrono.GregorianChronology",
    "signature": "org.joda.time.chrono.GregorianChronology.getAverageMillisPerMonth()",
    "snippet": "    long getAverageMillisPerMonth() {\n        return MILLIS_PER_MONTH;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 1
  },
  {
    "name": "GregorianChronology.getAverageMillisPerYear",
    "class_name": "org.joda.time.chrono.GregorianChronology",
    "signature": "org.joda.time.chrono.GregorianChronology.getAverageMillisPerYear()",
    "snippet": "    long getAverageMillisPerYear() {\n        return MILLIS_PER_YEAR;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 1
  },
  {
    "name": "GregorianChronology.getInstance",
    "class_name": "org.joda.time.chrono.GregorianChronology",
    "signature": "org.joda.time.chrono.GregorianChronology.getInstance(DateTimeZone)",
    "snippet": "    public static GregorianChronology getInstance(DateTimeZone zone) {\n        return getInstance(zone, 4);\n    }",
    "comment": " Gets an instance of the GregorianChronology in the given time zone.  @param zone  the time zone to get the chronology in, null is default @return a chronology in the specified time zone ",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 1
  },
  {
    "name": "GregorianChronology.getInstance",
    "class_name": "org.joda.time.chrono.GregorianChronology",
    "signature": "org.joda.time.chrono.GregorianChronology.getInstance(DateTimeZone,int)",
    "snippet": "    public static GregorianChronology getInstance(DateTimeZone zone, int minDaysInFirstWeek) {\n        if (zone == null) {\n            zone = DateTimeZone.getDefault();\n        }\n        GregorianChronology chrono;\n        synchronized (cCache) {\n            GregorianChronology[] chronos = cCache.get(zone);\n            if (chronos == null) {\n                chronos = new GregorianChronology[7];\n                cCache.put(zone, chronos);\n            }\n            try {\n                chrono = chronos[minDaysInFirstWeek - 1];\n            } catch (ArrayIndexOutOfBoundsException e) {\n                throw new IllegalArgumentException\n                    (\"Invalid min days in first week: \" + minDaysInFirstWeek);\n            }\n            if (chrono == null) {\n                if (zone == DateTimeZone.UTC) {\n                    chrono = new GregorianChronology(null, null, minDaysInFirstWeek);\n                } else {\n                    chrono = getInstance(DateTimeZone.UTC, minDaysInFirstWeek);\n                    chrono = new GregorianChronology\n                        (ZonedChronology.getInstance(chrono, zone), null, minDaysInFirstWeek);\n                }\n                chronos[minDaysInFirstWeek - 1] = chrono;\n            }\n        }\n        return chrono;\n    }",
    "comment": " Gets an instance of the GregorianChronology in the given time zone.  @param zone  the time zone to get the chronology in, null is default @param minDaysInFirstWeek  minimum number of days in first week of the year; default is 4 @return a chronology in the specified time zone ",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 1
  },
  {
    "name": "GregorianChronology.getInstanceUTC",
    "class_name": "org.joda.time.chrono.GregorianChronology",
    "signature": "org.joda.time.chrono.GregorianChronology.getInstanceUTC()",
    "snippet": "    public static GregorianChronology getInstanceUTC() {\n        return INSTANCE_UTC;\n    }",
    "comment": " Gets an instance of the GregorianChronology. The time zone of the returned instance is UTC.  @return a singleton UTC instance of the chronology ",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 1
  },
  {
    "name": "GregorianChronology.getMaxYear",
    "class_name": "org.joda.time.chrono.GregorianChronology",
    "signature": "org.joda.time.chrono.GregorianChronology.getMaxYear()",
    "snippet": "    int getMaxYear() {\n        return MAX_YEAR;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 1
  },
  {
    "name": "ISOChronology.assemble",
    "class_name": "org.joda.time.chrono.ISOChronology",
    "signature": "org.joda.time.chrono.ISOChronology.assemble(Fields)",
    "snippet": "    protected void assemble(Fields fields) {\n        if (getBase().getZone() == DateTimeZone.UTC) {\n            // Use zero based century and year of century.\n            fields.centuryOfEra = new DividedDateTimeField(\n                ISOYearOfEraDateTimeField.INSTANCE, DateTimeFieldType.centuryOfEra(), 100);\n            fields.yearOfCentury = new RemainderDateTimeField(\n                (DividedDateTimeField) fields.centuryOfEra, DateTimeFieldType.yearOfCentury());\n            fields.weekyearOfCentury = new RemainderDateTimeField(\n                (DividedDateTimeField) fields.centuryOfEra, DateTimeFieldType.weekyearOfCentury());\n\n            fields.centuries = fields.centuryOfEra.getDurationField();\n        }\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 1
  },
  {
    "name": "ISOChronology.getInstance",
    "class_name": "org.joda.time.chrono.ISOChronology",
    "signature": "org.joda.time.chrono.ISOChronology.getInstance()",
    "snippet": "    public static ISOChronology getInstance() {\n        return getInstance(DateTimeZone.getDefault());\n    }",
    "comment": " Gets an instance of the ISOChronology in the default time zone.  @return a chronology in the default time zone ",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 1
  },
  {
    "name": "ISOChronology.getInstance",
    "class_name": "org.joda.time.chrono.ISOChronology",
    "signature": "org.joda.time.chrono.ISOChronology.getInstance(DateTimeZone)",
    "snippet": "    public static ISOChronology getInstance(DateTimeZone zone) {\n        if (zone == null) {\n            zone = DateTimeZone.getDefault();\n        }\n        int index = System.identityHashCode(zone) & (FAST_CACHE_SIZE - 1);\n        ISOChronology chrono = cFastCache[index];\n        if (chrono != null && chrono.getZone() == zone) {\n            return chrono;\n        }\n        synchronized (cCache) {\n            chrono = cCache.get(zone);\n            if (chrono == null) {\n                chrono = new ISOChronology(ZonedChronology.getInstance(INSTANCE_UTC, zone));\n                cCache.put(zone, chrono);\n            }\n        }\n        cFastCache[index] = chrono;\n        return chrono;\n    }",
    "comment": " Gets an instance of the ISOChronology in the given time zone.  @param zone  the time zone to get the chronology in, null is default @return a chronology in the specified time zone ",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 1
  },
  {
    "name": "ISOChronology.getInstanceUTC",
    "class_name": "org.joda.time.chrono.ISOChronology",
    "signature": "org.joda.time.chrono.ISOChronology.getInstanceUTC()",
    "snippet": "    public static ISOChronology getInstanceUTC() {\n        return INSTANCE_UTC;\n    }",
    "comment": " Gets an instance of the ISOChronology. The time zone of the returned instance is UTC.  @return a singleton UTC instance of the chronology ",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 1
  },
  {
    "name": "ISOChronology.withUTC",
    "class_name": "org.joda.time.chrono.ISOChronology",
    "signature": "org.joda.time.chrono.ISOChronology.withUTC()",
    "snippet": "    public Chronology withUTC() {\n        return INSTANCE_UTC;\n    }",
    "comment": " Gets the Chronology in the UTC time zone.  @return the chronology in UTC ",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 1
  },
  {
    "name": "ISOYearOfEraDateTimeField.getMaximumValue",
    "class_name": "org.joda.time.chrono.ISOYearOfEraDateTimeField",
    "signature": "org.joda.time.chrono.ISOYearOfEraDateTimeField.getMaximumValue()",
    "snippet": "    public int getMaximumValue() {\n        return getWrappedField().getMaximumValue();\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 1
  },
  {
    "name": "ISOYearOfEraDateTimeField.getMinimumValue",
    "class_name": "org.joda.time.chrono.ISOYearOfEraDateTimeField",
    "signature": "org.joda.time.chrono.ISOYearOfEraDateTimeField.getMinimumValue()",
    "snippet": "    public int getMinimumValue() {\n        return 0;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 1
  },
  {
    "name": "ZonedChronology.assemble",
    "class_name": "org.joda.time.chrono.ZonedChronology",
    "signature": "org.joda.time.chrono.ZonedChronology.assemble(Fields)",
    "snippet": "    protected void assemble(Fields fields) {\n        // Keep a local cache of converted fields so as not to create redundant\n        // objects.\n        HashMap<Object, Object> converted = new HashMap<Object, Object>();\n\n        // Convert duration fields...\n\n        fields.eras = convertField(fields.eras, converted);\n        fields.centuries = convertField(fields.centuries, converted);\n        fields.years = convertField(fields.years, converted);\n        fields.months = convertField(fields.months, converted);\n        fields.weekyears = convertField(fields.weekyears, converted);\n        fields.weeks = convertField(fields.weeks, converted);\n        fields.days = convertField(fields.days, converted);\n\n        fields.halfdays = convertField(fields.halfdays, converted);\n        fields.hours = convertField(fields.hours, converted);\n        fields.minutes = convertField(fields.minutes, converted);\n        fields.seconds = convertField(fields.seconds, converted);\n        fields.millis = convertField(fields.millis, converted);\n\n        // Convert datetime fields...\n\n        fields.year = convertField(fields.year, converted);\n        fields.yearOfEra = convertField(fields.yearOfEra, converted);\n        fields.yearOfCentury = convertField(fields.yearOfCentury, converted);\n        fields.centuryOfEra = convertField(fields.centuryOfEra, converted);\n        fields.era = convertField(fields.era, converted);\n        fields.dayOfWeek = convertField(fields.dayOfWeek, converted);\n        fields.dayOfMonth = convertField(fields.dayOfMonth, converted);\n        fields.dayOfYear = convertField(fields.dayOfYear, converted);\n        fields.monthOfYear = convertField(fields.monthOfYear, converted);\n        fields.weekOfWeekyear = convertField(fields.weekOfWeekyear, converted);\n        fields.weekyear = convertField(fields.weekyear, converted);\n        fields.weekyearOfCentury = convertField(fields.weekyearOfCentury, converted);\n\n        fields.millisOfSecond = convertField(fields.millisOfSecond, converted);\n        fields.millisOfDay = convertField(fields.millisOfDay, converted);\n        fields.secondOfMinute = convertField(fields.secondOfMinute, converted);\n        fields.secondOfDay = convertField(fields.secondOfDay, converted);\n        fields.minuteOfHour = convertField(fields.minuteOfHour, converted);\n        fields.minuteOfDay = convertField(fields.minuteOfDay, converted);\n        fields.hourOfDay = convertField(fields.hourOfDay, converted);\n        fields.hourOfHalfday = convertField(fields.hourOfHalfday, converted);\n        fields.clockhourOfDay = convertField(fields.clockhourOfDay, converted);\n        fields.clockhourOfHalfday = convertField(fields.clockhourOfHalfday, converted);\n        fields.halfdayOfDay = convertField(fields.halfdayOfDay, converted);\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 1
  },
  {
    "name": "ZonedChronology.convertField",
    "class_name": "org.joda.time.chrono.ZonedChronology",
    "signature": "org.joda.time.chrono.ZonedChronology.convertField(DateTimeField,HashMap)",
    "snippet": "    private DateTimeField convertField(DateTimeField field, HashMap<Object, Object> converted) {\n        if (field == null || !field.isSupported()) {\n            return field;\n        }\n        if (converted.containsKey(field)) {\n            return (DateTimeField)converted.get(field);\n        }\n        ZonedDateTimeField zonedField =\n            new ZonedDateTimeField(field, getZone(),\n                                   convertField(field.getDurationField(), converted),\n                                   convertField(field.getRangeDurationField(), converted),\n                                   convertField(field.getLeapDurationField(), converted));\n        converted.put(field, zonedField);\n        return zonedField;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 1
  },
  {
    "name": "ZonedChronology.convertField",
    "class_name": "org.joda.time.chrono.ZonedChronology",
    "signature": "org.joda.time.chrono.ZonedChronology.convertField(DurationField,HashMap)",
    "snippet": "    private DurationField convertField(DurationField field, HashMap<Object, Object> converted) {\n        if (field == null || !field.isSupported()) {\n            return field;\n        }\n        if (converted.containsKey(field)) {\n            return (DurationField)converted.get(field);\n        }\n        ZonedDurationField zonedField = new ZonedDurationField(field, getZone());\n        converted.put(field, zonedField);\n        return zonedField;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 1
  },
  {
    "name": "ZonedChronology.getInstance",
    "class_name": "org.joda.time.chrono.ZonedChronology",
    "signature": "org.joda.time.chrono.ZonedChronology.getInstance(Chronology,DateTimeZone)",
    "snippet": "    public static ZonedChronology getInstance(Chronology base, DateTimeZone zone) {\n        if (base == null) {\n            throw new IllegalArgumentException(\"Must supply a chronology\");\n        }\n        base = base.withUTC();\n        if (base == null) {\n            throw new IllegalArgumentException(\"UTC chronology must not be null\");\n        }\n        if (zone == null) {\n            throw new IllegalArgumentException(\"DateTimeZone must not be null\");\n        }\n        return new ZonedChronology(base, zone);\n    }",
    "comment": " Create a ZonedChronology for any chronology, overriding any time zone it may already have.  @param base base chronology to wrap @param zone the time zone @throws IllegalArgumentException if chronology or time zone is null ",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 1
  },
  {
    "name": "ZonedChronology.getZone",
    "class_name": "org.joda.time.chrono.ZonedChronology",
    "signature": "org.joda.time.chrono.ZonedChronology.getZone()",
    "snippet": "    public DateTimeZone getZone() {\n        return (DateTimeZone)getParam();\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 1
  },
  {
    "name": "ZonedChronology.useTimeArithmetic",
    "class_name": "org.joda.time.chrono.ZonedChronology",
    "signature": "org.joda.time.chrono.ZonedChronology.useTimeArithmetic(DurationField)",
    "snippet": "    static boolean useTimeArithmetic(DurationField field) {\n        // Use time of day arithmetic rules for unit durations less than\n        // typical time zone offsets.\n        return field != null && field.getUnitMillis() < DateTimeConstants.MILLIS_PER_HOUR * 12;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 1
  },
  {
    "name": "ZonedDurationField.getUnitMillis",
    "class_name": "org.joda.time.chrono.ZonedChronology$ZonedDurationField",
    "signature": "org.joda.time.chrono.ZonedChronology$ZonedDurationField.getUnitMillis()",
    "snippet": "        public long getUnitMillis() {\n            return iField.getUnitMillis();\n        }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 1
  },
  {
    "name": "BaseDateTimeField.BaseDateTimeField",
    "class_name": "org.joda.time.field.BaseDateTimeField",
    "signature": "org.joda.time.field.BaseDateTimeField.BaseDateTimeField(DateTimeFieldType)",
    "snippet": "    protected BaseDateTimeField(DateTimeFieldType type) {\n        super();\n        if (type == null) {\n            throw new IllegalArgumentException(\"The type must not be null\");\n        }\n        iType = type;\n    }",
    "comment": " Constructor. ",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 1
  },
  {
    "name": "BaseDateTimeField.getLeapDurationField",
    "class_name": "org.joda.time.field.BaseDateTimeField",
    "signature": "org.joda.time.field.BaseDateTimeField.getLeapDurationField()",
    "snippet": "    public DurationField getLeapDurationField() {\n        return null;\n    }",
    "comment": " If this field were to leap, then it would be in units described by the returned duration. If this field doesn't ever leap, null is returned. <p> This implementation returns null. ",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 1
  },
  {
    "name": "BaseDateTimeField.getType",
    "class_name": "org.joda.time.field.BaseDateTimeField",
    "signature": "org.joda.time.field.BaseDateTimeField.getType()",
    "snippet": "    public final DateTimeFieldType getType() {\n        return iType;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 1
  },
  {
    "name": "BaseDateTimeField.isSupported",
    "class_name": "org.joda.time.field.BaseDateTimeField",
    "signature": "org.joda.time.field.BaseDateTimeField.isSupported()",
    "snippet": "    public final boolean isSupported() {\n        return true;\n    }",
    "comment": " @return true always ",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 1
  },
  {
    "name": "BaseDurationField.BaseDurationField",
    "class_name": "org.joda.time.field.BaseDurationField",
    "signature": "org.joda.time.field.BaseDurationField.BaseDurationField(DurationFieldType)",
    "snippet": "    protected BaseDurationField(DurationFieldType type) {\n        super();\n        if (type == null) {\n            throw new IllegalArgumentException(\"The type must not be null\");\n        }\n        iType = type;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 1
  },
  {
    "name": "BaseDurationField.getDifference",
    "class_name": "org.joda.time.field.BaseDurationField",
    "signature": "org.joda.time.field.BaseDurationField.getDifference(long,long)",
    "snippet": "    public int getDifference(long minuendInstant, long subtrahendInstant) {\n        return FieldUtils.safeToInt(getDifferenceAsLong(minuendInstant, subtrahendInstant));\n    }",
    "comment": "------------------------------------------------------------------------",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 1
  },
  {
    "name": "BaseDurationField.getType",
    "class_name": "org.joda.time.field.BaseDurationField",
    "signature": "org.joda.time.field.BaseDurationField.getType()",
    "snippet": "    public final DurationFieldType getType() {\n        return iType;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 1
  },
  {
    "name": "BaseDurationField.isSupported",
    "class_name": "org.joda.time.field.BaseDurationField",
    "signature": "org.joda.time.field.BaseDurationField.isSupported()",
    "snippet": "    public final boolean isSupported() {\n        return true;\n    }",
    "comment": " @return true always ",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 1
  },
  {
    "name": "DecoratedDateTimeField.DecoratedDateTimeField",
    "class_name": "org.joda.time.field.DecoratedDateTimeField",
    "signature": "org.joda.time.field.DecoratedDateTimeField.DecoratedDateTimeField(DateTimeField,DateTimeFieldType)",
    "snippet": "    protected DecoratedDateTimeField(DateTimeField field, DateTimeFieldType type) {\n        super(type);\n        if (field == null) {\n            throw new IllegalArgumentException(\"The field must not be null\");\n        }\n        if (!field.isSupported()) {\n            throw new IllegalArgumentException(\"The field must be supported\");\n        }\n        iField = field;\n    }",
    "comment": " Constructor.  @param field  the field being decorated @param type  allow type to be overridden ",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 1
  },
  {
    "name": "DecoratedDateTimeField.getDurationField",
    "class_name": "org.joda.time.field.DecoratedDateTimeField",
    "signature": "org.joda.time.field.DecoratedDateTimeField.getDurationField()",
    "snippet": "    public DurationField getDurationField() {\n        return iField.getDurationField();\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 1
  },
  {
    "name": "DecoratedDateTimeField.getRangeDurationField",
    "class_name": "org.joda.time.field.DecoratedDateTimeField",
    "signature": "org.joda.time.field.DecoratedDateTimeField.getRangeDurationField()",
    "snippet": "    public DurationField getRangeDurationField() {\n        return iField.getRangeDurationField();\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 1
  },
  {
    "name": "DecoratedDateTimeField.getWrappedField",
    "class_name": "org.joda.time.field.DecoratedDateTimeField",
    "signature": "org.joda.time.field.DecoratedDateTimeField.getWrappedField()",
    "snippet": "    public final DateTimeField getWrappedField() {\n        return iField;\n    }",
    "comment": " Gets the wrapped date time field.  @return the wrapped DateTimeField ",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 1
  },
  {
    "name": "DecoratedDurationField.DecoratedDurationField",
    "class_name": "org.joda.time.field.DecoratedDurationField",
    "signature": "org.joda.time.field.DecoratedDurationField.DecoratedDurationField(DurationField,DurationFieldType)",
    "snippet": "    public DecoratedDurationField(DurationField field, DurationFieldType type) {\n        super(type);\n        if (field == null) {\n            throw new IllegalArgumentException(\"The field must not be null\");\n        }\n        if (!field.isSupported()) {\n            throw new IllegalArgumentException(\"The field must be supported\");\n        }\n        iField = field;\n    }",
    "comment": " Constructor.  @param field  the base field @param type  the type to actually use ",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 1
  },
  {
    "name": "DecoratedDurationField.getWrappedField",
    "class_name": "org.joda.time.field.DecoratedDurationField",
    "signature": "org.joda.time.field.DecoratedDurationField.getWrappedField()",
    "snippet": "    public final DurationField getWrappedField() {\n        return iField;\n    }",
    "comment": " Gets the wrapped duration field.  @return the wrapped DurationField ",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 1
  },
  {
    "name": "DividedDateTimeField.DividedDateTimeField",
    "class_name": "org.joda.time.field.DividedDateTimeField",
    "signature": "org.joda.time.field.DividedDateTimeField.DividedDateTimeField(DateTimeField,DateTimeFieldType,int)",
    "snippet": "    public DividedDateTimeField(DateTimeField field,\n                                DateTimeFieldType type, int divisor) {\n        super(field, type);\n                \n        if (divisor < 2) {\n            throw new IllegalArgumentException(\"The divisor must be at least 2\");\n        }\n\n        DurationField unitField = field.getDurationField();\n        if (unitField == null) {\n            iDurationField = null;\n        } else {\n            iDurationField = new ScaledDurationField(\n                unitField, type.getDurationType(), divisor);\n        }\n\n        iDivisor = divisor;\n\n        int i = field.getMinimumValue();\n        int min = (i >= 0) ? i / divisor : ((i + 1) / divisor - 1);\n\n        int j = field.getMaximumValue();\n        int max = (j >= 0) ? j / divisor : ((j + 1) / divisor - 1);\n\n        iMin = min;\n        iMax = max;\n    }",
    "comment": " Constructor.  @param field  the field to wrap, like \"year()\". @param type  the field type this field will actually use @param divisor  divisor, such as 100 years in a century @throws IllegalArgumentException if divisor is less than two ",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 1
  },
  {
    "name": "DividedDateTimeField.getDurationField",
    "class_name": "org.joda.time.field.DividedDateTimeField",
    "signature": "org.joda.time.field.DividedDateTimeField.getDurationField()",
    "snippet": "    public DurationField getDurationField() {\n        return iDurationField;\n    }",
    "comment": " Returns a scaled version of the wrapped field's unit duration field. ",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 1
  },
  {
    "name": "FieldUtils.safeAdd",
    "class_name": "org.joda.time.field.FieldUtils",
    "signature": "org.joda.time.field.FieldUtils.safeAdd(int,int)",
    "snippet": "    public static int safeAdd(int val1, int val2) {\n        int sum = val1 + val2;\n        // If there is a sign change, but the two values have the same sign...\n        if ((val1 ^ sum) < 0 && (val1 ^ val2) >= 0) {\n            throw new ArithmeticException\n                (\"The calculation caused an overflow: \" + val1 + \" + \" + val2);\n        }\n        return sum;\n    }",
    "comment": " Add two values throwing an exception if overflow occurs.  @param val1  the first value @param val2  the second value @return the new total @throws ArithmeticException if the value is too big or too small ",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 1
  },
  {
    "name": "FieldUtils.safeAdd",
    "class_name": "org.joda.time.field.FieldUtils",
    "signature": "org.joda.time.field.FieldUtils.safeAdd(long,long)",
    "snippet": "    public static long safeAdd(long val1, long val2) {\n        long sum = val1 + val2;\n        // If there is a sign change, but the two values have the same sign...\n        if ((val1 ^ sum) < 0 && (val1 ^ val2) >= 0) {\n            throw new ArithmeticException\n                (\"The calculation caused an overflow: \" + val1 + \" + \" + val2);\n        }\n        return sum;\n    }",
    "comment": " Add two values throwing an exception if overflow occurs.  @param val1  the first value @param val2  the second value @return the new total @throws ArithmeticException if the value is too big or too small ",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 1
  },
  {
    "name": "FieldUtils.safeSubtract",
    "class_name": "org.joda.time.field.FieldUtils",
    "signature": "org.joda.time.field.FieldUtils.safeSubtract(long,long)",
    "snippet": "    public static long safeSubtract(long val1, long val2) {\n        long diff = val1 - val2;\n        // If there is a sign change, but the two values have different signs...\n        if ((val1 ^ diff) < 0 && (val1 ^ val2) < 0) {\n            throw new ArithmeticException\n                (\"The calculation caused an overflow: \" + val1 + \" - \" + val2);\n        }\n        return diff;\n    }",
    "comment": " Subtracts two values throwing an exception if overflow occurs.  @param val1  the first value, to be taken away from @param val2  the second value, the amount to take away @return the new total @throws ArithmeticException if the value is too big or too small ",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 1
  },
  {
    "name": "FieldUtils.safeToInt",
    "class_name": "org.joda.time.field.FieldUtils",
    "signature": "org.joda.time.field.FieldUtils.safeToInt(long)",
    "snippet": "    public static int safeToInt(long value) {\n        if (Integer.MIN_VALUE <= value && value <= Integer.MAX_VALUE) {\n            return (int) value;\n        }\n        throw new ArithmeticException(\"Value cannot fit in an int: \" + value);\n    }",
    "comment": " Casts to an int throwing an exception if overflow occurs.  @param value  the value @return the value as an int @throws ArithmeticException if the value is too big or too small ",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 1
  },
  {
    "name": "ImpreciseDateTimeField.ImpreciseDateTimeField",
    "class_name": "org.joda.time.field.ImpreciseDateTimeField",
    "signature": "org.joda.time.field.ImpreciseDateTimeField.ImpreciseDateTimeField(DateTimeFieldType,long)",
    "snippet": "    public ImpreciseDateTimeField(DateTimeFieldType type, long unitMillis) {\n        super(type);\n        iUnitMillis = unitMillis;\n        iDurationField = new LinkedDurationField(type.getDurationType());\n    }",
    "comment": " Constructor.  @param type  the field type @param unitMillis  the average duration unit milliseconds ",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 1
  },
  {
    "name": "ImpreciseDateTimeField.getDurationField",
    "class_name": "org.joda.time.field.ImpreciseDateTimeField",
    "signature": "org.joda.time.field.ImpreciseDateTimeField.getDurationField()",
    "snippet": "    public final DurationField getDurationField() {\n        return iDurationField;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 1
  },
  {
    "name": "LinkedDurationField.getUnitMillis",
    "class_name": "org.joda.time.field.ImpreciseDateTimeField$LinkedDurationField",
    "signature": "org.joda.time.field.ImpreciseDateTimeField$LinkedDurationField.getUnitMillis()",
    "snippet": "        public long getUnitMillis() {\n            return iUnitMillis;\n        }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 1
  },
  {
    "name": "LinkedDurationField.isPrecise",
    "class_name": "org.joda.time.field.ImpreciseDateTimeField$LinkedDurationField",
    "signature": "org.joda.time.field.ImpreciseDateTimeField$LinkedDurationField.isPrecise()",
    "snippet": "        public boolean isPrecise() {\n            return false;\n        }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 1
  },
  {
    "name": "MillisDurationField.getType",
    "class_name": "org.joda.time.field.MillisDurationField",
    "signature": "org.joda.time.field.MillisDurationField.getType()",
    "snippet": "    public DurationFieldType getType() {\n        return DurationFieldType.millis();\n    }",
    "comment": "------------------------------------------------------------------------",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 1
  },
  {
    "name": "MillisDurationField.getUnitMillis",
    "class_name": "org.joda.time.field.MillisDurationField",
    "signature": "org.joda.time.field.MillisDurationField.getUnitMillis()",
    "snippet": "    public final long getUnitMillis() {\n        return 1;\n    }",
    "comment": " Returns the amount of milliseconds per unit value of this field.  @return one always ",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 1
  },
  {
    "name": "MillisDurationField.hashCode",
    "class_name": "org.joda.time.field.MillisDurationField",
    "signature": "org.joda.time.field.MillisDurationField.hashCode()",
    "snippet": "    public int hashCode() {\n        return (int) getUnitMillis();\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 1
  },
  {
    "name": "MillisDurationField.isPrecise",
    "class_name": "org.joda.time.field.MillisDurationField",
    "signature": "org.joda.time.field.MillisDurationField.isPrecise()",
    "snippet": "    public final boolean isPrecise() {\n        return true;\n    }",
    "comment": " Returns true as this field is precise.  @return true always ",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 1
  },
  {
    "name": "MillisDurationField.isSupported",
    "class_name": "org.joda.time.field.MillisDurationField",
    "signature": "org.joda.time.field.MillisDurationField.isSupported()",
    "snippet": "    public boolean isSupported() {\n        return true;\n    }",
    "comment": " Returns true as this field is supported.  @return true always ",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 1
  },
  {
    "name": "OffsetDateTimeField.OffsetDateTimeField",
    "class_name": "org.joda.time.field.OffsetDateTimeField",
    "signature": "org.joda.time.field.OffsetDateTimeField.OffsetDateTimeField(DateTimeField,DateTimeFieldType,int)",
    "snippet": "    public OffsetDateTimeField(DateTimeField field, DateTimeFieldType type, int offset) {\n        this(field, type, offset, Integer.MIN_VALUE, Integer.MAX_VALUE);\n    }",
    "comment": " Constructor.  @param field  the field to wrap, like \"year()\". @param type  the field type this field actually uses @param offset  offset to add to field values @throws IllegalArgumentException if offset is zero ",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 1
  },
  {
    "name": "OffsetDateTimeField.OffsetDateTimeField",
    "class_name": "org.joda.time.field.OffsetDateTimeField",
    "signature": "org.joda.time.field.OffsetDateTimeField.OffsetDateTimeField(DateTimeField,DateTimeFieldType,int,int,int)",
    "snippet": "    public OffsetDateTimeField(DateTimeField field, DateTimeFieldType type, int offset,\n                               int minValue, int maxValue) {\n        super(field, type);\n                \n        if (offset == 0) {\n            throw new IllegalArgumentException(\"The offset cannot be zero\");\n        }\n\n        iOffset = offset;\n\n        if (minValue < (field.getMinimumValue() + offset)) {\n            iMin = field.getMinimumValue() + offset;\n        } else {\n            iMin = minValue;\n        }\n        if (maxValue > (field.getMaximumValue() + offset)) {\n            iMax = field.getMaximumValue() + offset;\n        } else {\n            iMax = maxValue;\n        }\n    }",
    "comment": " Constructor.  @param field  the field to wrap, like \"year()\". @param type  the field type this field actually uses @param offset  offset to add to field values @param minValue  minimum allowed value @param maxValue  maximum allowed value @throws IllegalArgumentException if offset is zero ",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 1
  },
  {
    "name": "OffsetDateTimeField.OffsetDateTimeField",
    "class_name": "org.joda.time.field.OffsetDateTimeField",
    "signature": "org.joda.time.field.OffsetDateTimeField.OffsetDateTimeField(DateTimeField,int)",
    "snippet": "    public OffsetDateTimeField(DateTimeField field, int offset) {\n        this(field, (field == null ? null : field.getType()), offset, Integer.MIN_VALUE, Integer.MAX_VALUE);\n    }",
    "comment": " Constructor.  @param field  the field to wrap, like \"year()\". @param offset  offset to add to field values @throws IllegalArgumentException if offset is zero ",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 1
  },
  {
    "name": "OffsetDateTimeField.getMaximumValue",
    "class_name": "org.joda.time.field.OffsetDateTimeField",
    "signature": "org.joda.time.field.OffsetDateTimeField.getMaximumValue()",
    "snippet": "    public int getMaximumValue() {\n        return iMax;\n    }",
    "comment": " Get the maximum value for the field.  @return the maximum value ",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 1
  },
  {
    "name": "OffsetDateTimeField.getMinimumValue",
    "class_name": "org.joda.time.field.OffsetDateTimeField",
    "signature": "org.joda.time.field.OffsetDateTimeField.getMinimumValue()",
    "snippet": "    public int getMinimumValue() {\n        return iMin;\n    }",
    "comment": " Get the minimum value for the field.  @return the minimum value ",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 1
  },
  {
    "name": "PreciseDateTimeField.PreciseDateTimeField",
    "class_name": "org.joda.time.field.PreciseDateTimeField",
    "signature": "org.joda.time.field.PreciseDateTimeField.PreciseDateTimeField(DateTimeFieldType,DurationField,DurationField)",
    "snippet": "    public PreciseDateTimeField(DateTimeFieldType type,\n                                DurationField unit, DurationField range) {\n        super(type, unit);\n\n        if (!range.isPrecise()) {\n            throw new IllegalArgumentException(\"Range duration field must be precise\");\n        }\n\n        long rangeMillis = range.getUnitMillis();\n        iRange = (int)(rangeMillis / getUnitMillis());\n        if (iRange < 2) {\n            throw new IllegalArgumentException(\"The effective range must be at least 2\");\n        }\n\n        iRangeField = range;\n    }",
    "comment": " Constructor.  @param type  the field type this field uses @param unit  precise unit duration, like \"seconds()\". @param range precise range duration, preferably a multiple of the unit, like \"minutes()\". @throws IllegalArgumentException if either duration field is imprecise @throws IllegalArgumentException if unit milliseconds is less than one or effective value range is less than two. ",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 1
  },
  {
    "name": "PreciseDateTimeField.getRangeDurationField",
    "class_name": "org.joda.time.field.PreciseDateTimeField",
    "signature": "org.joda.time.field.PreciseDateTimeField.getRangeDurationField()",
    "snippet": "    public DurationField getRangeDurationField() {\n        return iRangeField;\n    }",
    "comment": " Returns the range duration of this field. For example, if this field represents \"minute of hour\", then the range duration field is an hours.  @return the range duration of this field, or null if field has no range ",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 1
  },
  {
    "name": "PreciseDurationDateTimeField.PreciseDurationDateTimeField",
    "class_name": "org.joda.time.field.PreciseDurationDateTimeField",
    "signature": "org.joda.time.field.PreciseDurationDateTimeField.PreciseDurationDateTimeField(DateTimeFieldType,DurationField)",
    "snippet": "    public PreciseDurationDateTimeField(DateTimeFieldType type, DurationField unit) {\n        super(type);\n\n        if (!unit.isPrecise()) {\n            throw new IllegalArgumentException(\"Unit duration field must be precise\");\n        }\n\n        iUnitMillis = unit.getUnitMillis();\n        if (iUnitMillis < 1) {\n            throw new IllegalArgumentException(\"The unit milliseconds must be at least 1\");\n        }\n\n        iUnitField = unit;\n    }",
    "comment": " Constructor.  @param type  the field type @param unit  precise unit duration, like \"days()\". @throws IllegalArgumentException if duration field is imprecise @throws IllegalArgumentException if unit milliseconds is less than one ",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 1
  },
  {
    "name": "PreciseDurationDateTimeField.getDurationField",
    "class_name": "org.joda.time.field.PreciseDurationDateTimeField",
    "signature": "org.joda.time.field.PreciseDurationDateTimeField.getDurationField()",
    "snippet": "    public DurationField getDurationField() {\n        return iUnitField;\n    }",
    "comment": " Returns the duration per unit value of this field. For example, if this field represents \"minute of hour\", then the duration field is minutes.  @return the duration of this field, or UnsupportedDurationField if field has no duration ",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 1
  },
  {
    "name": "PreciseDurationDateTimeField.getMinimumValue",
    "class_name": "org.joda.time.field.PreciseDurationDateTimeField",
    "signature": "org.joda.time.field.PreciseDurationDateTimeField.getMinimumValue()",
    "snippet": "    public int getMinimumValue() {\n        return 0;\n    }",
    "comment": " Get the minimum value for the field.  @return the minimum value ",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 1
  },
  {
    "name": "PreciseDurationDateTimeField.getUnitMillis",
    "class_name": "org.joda.time.field.PreciseDurationDateTimeField",
    "signature": "org.joda.time.field.PreciseDurationDateTimeField.getUnitMillis()",
    "snippet": "    public final long getUnitMillis() {\n        return iUnitMillis;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 1
  },
  {
    "name": "PreciseDurationField.PreciseDurationField",
    "class_name": "org.joda.time.field.PreciseDurationField",
    "signature": "org.joda.time.field.PreciseDurationField.PreciseDurationField(DurationFieldType,long)",
    "snippet": "    public PreciseDurationField(DurationFieldType type, long unitMillis) {\n        super(type);\n        iUnitMillis = unitMillis;\n    }",
    "comment": " Constructor.  @param type  the field type @param unitMillis  the unit milliseconds ",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 1
  },
  {
    "name": "PreciseDurationField.add",
    "class_name": "org.joda.time.field.PreciseDurationField",
    "signature": "org.joda.time.field.PreciseDurationField.add(long,int)",
    "snippet": "    public long add(long instant, int value) {\n        long addition = value * iUnitMillis;  // safe\n        return FieldUtils.safeAdd(instant, addition);\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 1
  },
  {
    "name": "PreciseDurationField.getDifferenceAsLong",
    "class_name": "org.joda.time.field.PreciseDurationField",
    "signature": "org.joda.time.field.PreciseDurationField.getDifferenceAsLong(long,long)",
    "snippet": "    public long getDifferenceAsLong(long minuendInstant, long subtrahendInstant) {\n        long difference = FieldUtils.safeSubtract(minuendInstant, subtrahendInstant);\n        return difference / iUnitMillis;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 1
  },
  {
    "name": "PreciseDurationField.getUnitMillis",
    "class_name": "org.joda.time.field.PreciseDurationField",
    "signature": "org.joda.time.field.PreciseDurationField.getUnitMillis()",
    "snippet": "    public final long getUnitMillis() {\n        return iUnitMillis;\n    }",
    "comment": " Returns the amount of milliseconds per unit value of this field.  @return the unit size of this field, in milliseconds ",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 1
  },
  {
    "name": "PreciseDurationField.hashCode",
    "class_name": "org.joda.time.field.PreciseDurationField",
    "signature": "org.joda.time.field.PreciseDurationField.hashCode()",
    "snippet": "    public int hashCode() {\n        long millis = iUnitMillis;\n        int hash = (int) (millis ^ (millis >>> 32));\n        hash += getType().hashCode();\n        return hash;\n    }",
    "comment": " Gets a hash code for this instance.  @return a suitable hashcode ",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 1
  },
  {
    "name": "PreciseDurationField.isPrecise",
    "class_name": "org.joda.time.field.PreciseDurationField",
    "signature": "org.joda.time.field.PreciseDurationField.isPrecise()",
    "snippet": "    public final boolean isPrecise() {\n        return true;\n    }",
    "comment": " This field is precise.  @return true always ",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 1
  },
  {
    "name": "RemainderDateTimeField.RemainderDateTimeField",
    "class_name": "org.joda.time.field.RemainderDateTimeField",
    "signature": "org.joda.time.field.RemainderDateTimeField.RemainderDateTimeField(DateTimeField,DateTimeFieldType,int)",
    "snippet": "    public RemainderDateTimeField(DateTimeField field,\n                                  DateTimeFieldType type, int divisor) {\n        super(field, type);\n\n        if (divisor < 2) {\n            throw new IllegalArgumentException(\"The divisor must be at least 2\");\n        }\n\n        DurationField rangeField = field.getDurationField();\n        if (rangeField == null) {\n            iRangeField = null;\n        } else {\n            iRangeField = new ScaledDurationField(\n                rangeField, type.getRangeDurationType(), divisor);\n        }\n\n        iDivisor = divisor;\n    }",
    "comment": " Constructor.  @param field  the field to wrap, like \"year()\". @param type  the field type this field actually uses @param divisor  divisor, such as 100 years in a century @throws IllegalArgumentException if divisor is less than two ",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 1
  },
  {
    "name": "RemainderDateTimeField.RemainderDateTimeField",
    "class_name": "org.joda.time.field.RemainderDateTimeField",
    "signature": "org.joda.time.field.RemainderDateTimeField.RemainderDateTimeField(DividedDateTimeField)",
    "snippet": "    public RemainderDateTimeField(DividedDateTimeField dividedField) {\n        this(dividedField, dividedField.getType());\n    }",
    "comment": " Construct a RemainderDateTimeField that compliments the given DividedDateTimeField.  @param dividedField  complimentary divided field, like \"century()\". ",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 1
  },
  {
    "name": "RemainderDateTimeField.RemainderDateTimeField",
    "class_name": "org.joda.time.field.RemainderDateTimeField",
    "signature": "org.joda.time.field.RemainderDateTimeField.RemainderDateTimeField(DividedDateTimeField,DateTimeFieldType)",
    "snippet": "    public RemainderDateTimeField(DividedDateTimeField dividedField, DateTimeFieldType type) {\n        super(dividedField.getWrappedField(), type);\n        iDivisor = dividedField.iDivisor;\n        iRangeField = dividedField.iDurationField;\n    }",
    "comment": " Construct a RemainderDateTimeField that compliments the given DividedDateTimeField.  @param dividedField  complimentary divided field, like \"century()\". @param type  the field type this field actually uses ",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 1
  },
  {
    "name": "RemainderDateTimeField.getMaximumValue",
    "class_name": "org.joda.time.field.RemainderDateTimeField",
    "signature": "org.joda.time.field.RemainderDateTimeField.getMaximumValue()",
    "snippet": "    public int getMaximumValue() {\n        return iDivisor - 1;\n    }",
    "comment": " Get the maximum value for the field, which is always one less than the divisor.  @return the maximum value ",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 1
  },
  {
    "name": "RemainderDateTimeField.getMinimumValue",
    "class_name": "org.joda.time.field.RemainderDateTimeField",
    "signature": "org.joda.time.field.RemainderDateTimeField.getMinimumValue()",
    "snippet": "    public int getMinimumValue() {\n        return 0;\n    }",
    "comment": " Get the minimum value for the field, which is always zero.  @return the minimum value of zero. ",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 1
  },
  {
    "name": "RemainderDateTimeField.getRangeDurationField",
    "class_name": "org.joda.time.field.RemainderDateTimeField",
    "signature": "org.joda.time.field.RemainderDateTimeField.getRangeDurationField()",
    "snippet": "    public DurationField getRangeDurationField() {\n        return iRangeField;\n    }",
    "comment": " Returns a scaled version of the wrapped field's unit duration field. ",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 1
  },
  {
    "name": "ScaledDurationField.ScaledDurationField",
    "class_name": "org.joda.time.field.ScaledDurationField",
    "signature": "org.joda.time.field.ScaledDurationField.ScaledDurationField(DurationField,DurationFieldType,int)",
    "snippet": "    public ScaledDurationField(DurationField field, DurationFieldType type, int scalar) {\n        super(field, type);\n        if (scalar == 0 || scalar == 1) {\n            throw new IllegalArgumentException(\"The scalar must not be 0 or 1\");\n        }\n        iScalar = scalar;\n    }",
    "comment": " Constructor  @param field  the field to wrap, like \"year()\". @param type  the type this field will actually use @param scalar  scalar, such as 100 years in a century @throws IllegalArgumentException if scalar is zero or one. ",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 1
  },
  {
    "name": "ScaledDurationField.getUnitMillis",
    "class_name": "org.joda.time.field.ScaledDurationField",
    "signature": "org.joda.time.field.ScaledDurationField.getUnitMillis()",
    "snippet": "    public long getUnitMillis() {\n        return getWrappedField().getUnitMillis() * iScalar;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 1
  },
  {
    "name": "ScaledDurationField.hashCode",
    "class_name": "org.joda.time.field.ScaledDurationField",
    "signature": "org.joda.time.field.ScaledDurationField.hashCode()",
    "snippet": "    public int hashCode() {\n        long scalar = iScalar;\n        int hash = (int) (scalar ^ (scalar >>> 32));\n        hash += getType().hashCode();\n        hash += getWrappedField().hashCode();\n        return hash;\n    }",
    "comment": " Gets a hash code for this instance.  @return a suitable hashcode ",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 1
  },
  {
    "name": "UnsupportedDurationField.getInstance",
    "class_name": "org.joda.time.field.UnsupportedDurationField",
    "signature": "org.joda.time.field.UnsupportedDurationField.getInstance(DurationFieldType)",
    "snippet": "    public static synchronized UnsupportedDurationField getInstance(DurationFieldType type) {\n        UnsupportedDurationField field;\n        if (cCache == null) {\n            cCache = new HashMap<DurationFieldType, UnsupportedDurationField>(7);\n            field = null;\n        } else {\n            field = cCache.get(type);\n        }\n        if (field == null) {\n            field = new UnsupportedDurationField(type);\n            cCache.put(type, field);\n        }\n        return field;\n    }",
    "comment": " Gets an instance of UnsupportedDurationField for a specific named field. The returned instance is cached.  @param type  the type to obtain @return the instance ",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 1
  },
  {
    "name": "UnsupportedDurationField.getUnitMillis",
    "class_name": "org.joda.time.field.UnsupportedDurationField",
    "signature": "org.joda.time.field.UnsupportedDurationField.getUnitMillis()",
    "snippet": "    public long getUnitMillis() {\n        return 0;\n    }",
    "comment": " Always returns zero.  @return zero always ",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 1
  },
  {
    "name": "UnsupportedDurationField.isSupported",
    "class_name": "org.joda.time.field.UnsupportedDurationField",
    "signature": "org.joda.time.field.UnsupportedDurationField.isSupported()",
    "snippet": "    public boolean isSupported() {\n        return false;\n    }",
    "comment": " This field is not supported.  @return false always ",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 1
  },
  {
    "name": "ZeroIsMaxDateTimeField.ZeroIsMaxDateTimeField",
    "class_name": "org.joda.time.field.ZeroIsMaxDateTimeField",
    "signature": "org.joda.time.field.ZeroIsMaxDateTimeField.ZeroIsMaxDateTimeField(DateTimeField,DateTimeFieldType)",
    "snippet": "    public ZeroIsMaxDateTimeField(DateTimeField field, DateTimeFieldType type) {\n        super(field, type);\n        if (field.getMinimumValue() != 0) {\n            throw new IllegalArgumentException(\"Wrapped field's minumum value must be zero\");\n        }\n    }",
    "comment": " Constructor.  @param field  the base field @param type  the field type this field will actually use @throws IllegalArgumentException if wrapped field's minimum value is not zero ",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 1
  },
  {
    "name": "ZeroIsMaxDateTimeField.getLeapDurationField",
    "class_name": "org.joda.time.field.ZeroIsMaxDateTimeField",
    "signature": "org.joda.time.field.ZeroIsMaxDateTimeField.getLeapDurationField()",
    "snippet": "    public DurationField getLeapDurationField() {\n        return getWrappedField().getLeapDurationField();\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 1
  },
  {
    "name": "CachedDateTimeZone.forZone",
    "class_name": "org.joda.time.tz.CachedDateTimeZone",
    "signature": "org.joda.time.tz.CachedDateTimeZone.forZone(DateTimeZone)",
    "snippet": "    public static CachedDateTimeZone forZone(DateTimeZone zone) {\n        if (zone instanceof CachedDateTimeZone) {\n            return (CachedDateTimeZone)zone;\n        }\n        return new CachedDateTimeZone(zone);\n    }",
    "comment": " Returns a new CachedDateTimeZone unless given zone is already cached. ",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 1
  },
  {
    "name": "CachedDateTimeZone.hashCode",
    "class_name": "org.joda.time.tz.CachedDateTimeZone",
    "signature": "org.joda.time.tz.CachedDateTimeZone.hashCode()",
    "snippet": "    public int hashCode() {\n        return iZone.hashCode();\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 1
  },
  {
    "name": "DateTimeZoneBuilder.readFrom",
    "class_name": "org.joda.time.tz.DateTimeZoneBuilder",
    "signature": "org.joda.time.tz.DateTimeZoneBuilder.readFrom(DataInput,String)",
    "snippet": "    public static DateTimeZone readFrom(DataInput in, String id) throws IOException {\n        switch (in.readUnsignedByte()) {\n        case 'F':\n            DateTimeZone fixed = new FixedDateTimeZone\n                (id, in.readUTF(), (int)readMillis(in), (int)readMillis(in));\n            if (fixed.equals(DateTimeZone.UTC)) {\n                fixed = DateTimeZone.UTC;\n            }\n            return fixed;\n        case 'C':\n            return CachedDateTimeZone.forZone(PrecalculatedZone.readFrom(in, id));\n        case 'P':\n            return PrecalculatedZone.readFrom(in, id);\n        default:\n            throw new IOException(\"Invalid encoding\");\n        }\n    }",
    "comment": " Decodes a built DateTimeZone from the given stream, as encoded by writeTo.  @param in input stream to read encoded DateTimeZone from. @param id time zone id to assign ",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 1
  },
  {
    "name": "DateTimeZoneBuilder.readFrom",
    "class_name": "org.joda.time.tz.DateTimeZoneBuilder",
    "signature": "org.joda.time.tz.DateTimeZoneBuilder.readFrom(InputStream,String)",
    "snippet": "    public static DateTimeZone readFrom(InputStream in, String id) throws IOException {\n        if (in instanceof DataInput) {\n            return readFrom((DataInput)in, id);\n        } else {\n            return readFrom((DataInput)new DataInputStream(in), id);\n        }\n    }",
    "comment": " Decodes a built DateTimeZone from the given stream, as encoded by writeTo.  @param in input stream to read encoded DateTimeZone from. @param id time zone id to assign ",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 1
  },
  {
    "name": "DateTimeZoneBuilder.readMillis",
    "class_name": "org.joda.time.tz.DateTimeZoneBuilder",
    "signature": "org.joda.time.tz.DateTimeZoneBuilder.readMillis(DataInput)",
    "snippet": "    static long readMillis(DataInput in) throws IOException {\n        int v = in.readUnsignedByte();\n        switch (v >> 6) {\n        case 0: default:\n            // Form 00 (6 bits effective precision)\n            v = (v << (32 - 6)) >> (32 - 6);\n            return v * (30 * 60000L);\n\n        case 1:\n            // Form 01 (30 bits effective precision)\n            v = (v << (32 - 6)) >> (32 - 30);\n            v |= (in.readUnsignedByte()) << 16;\n            v |= (in.readUnsignedByte()) << 8;\n            v |= (in.readUnsignedByte());\n            return v * 60000L;\n\n        case 2:\n            // Form 10 (38 bits effective precision)\n            long w = (((long)v) << (64 - 6)) >> (64 - 38);\n            w |= (in.readUnsignedByte()) << 24;\n            w |= (in.readUnsignedByte()) << 16;\n            w |= (in.readUnsignedByte()) << 8;\n            w |= (in.readUnsignedByte());\n            return w * 1000L;\n\n        case 3:\n            // Form 11 (64 bits effective precision)\n            return in.readLong();\n        }\n    }",
    "comment": " Reads encoding generated by writeMillis. ",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 1
  },
  {
    "name": "DSTZone.readFrom",
    "class_name": "org.joda.time.tz.DateTimeZoneBuilder$DSTZone",
    "signature": "org.joda.time.tz.DateTimeZoneBuilder$DSTZone.readFrom(DataInput,String)",
    "snippet": "        static DSTZone readFrom(DataInput in, String id) throws IOException {\n            return new DSTZone(id, (int)readMillis(in), \n                               Recurrence.readFrom(in), Recurrence.readFrom(in));\n        }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 1
  },
  {
    "name": "OfYear.readFrom",
    "class_name": "org.joda.time.tz.DateTimeZoneBuilder$OfYear",
    "signature": "org.joda.time.tz.DateTimeZoneBuilder$OfYear.readFrom(DataInput)",
    "snippet": "        static OfYear readFrom(DataInput in) throws IOException {\n            return new OfYear((char)in.readUnsignedByte(),\n                              (int)in.readUnsignedByte(),\n                              (int)in.readByte(),\n                              (int)in.readUnsignedByte(),\n                              in.readBoolean(),\n                              (int)readMillis(in));\n        }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 1
  },
  {
    "name": "PrecalculatedZone.readFrom",
    "class_name": "org.joda.time.tz.DateTimeZoneBuilder$PrecalculatedZone",
    "signature": "org.joda.time.tz.DateTimeZoneBuilder$PrecalculatedZone.readFrom(DataInput,String)",
    "snippet": "        static PrecalculatedZone readFrom(DataInput in, String id) throws IOException {\n            // Read string pool.\n            int poolSize = in.readUnsignedShort();\n            String[] pool = new String[poolSize];\n            for (int i=0; i<poolSize; i++) {\n                pool[i] = in.readUTF();\n            }\n\n            int size = in.readInt();\n            long[] transitions = new long[size];\n            int[] wallOffsets = new int[size];\n            int[] standardOffsets = new int[size];\n            String[] nameKeys = new String[size];\n            \n            for (int i=0; i<size; i++) {\n                transitions[i] = readMillis(in);\n                wallOffsets[i] = (int)readMillis(in);\n                standardOffsets[i] = (int)readMillis(in);\n                try {\n                    int index;\n                    if (poolSize < 256) {\n                        index = in.readUnsignedByte();\n                    } else {\n                        index = in.readUnsignedShort();\n                    }\n                    nameKeys[i] = pool[index];\n                } catch (ArrayIndexOutOfBoundsException e) {\n                    throw new IOException(\"Invalid encoding\");\n                }\n            }\n\n            DSTZone tailZone = null;\n            if (in.readBoolean()) {\n                tailZone = DSTZone.readFrom(in, id);\n            }\n\n            return new PrecalculatedZone\n                (id, transitions, wallOffsets, standardOffsets, nameKeys, tailZone);\n        }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 1
  },
  {
    "name": "Recurrence.readFrom",
    "class_name": "org.joda.time.tz.DateTimeZoneBuilder$Recurrence",
    "signature": "org.joda.time.tz.DateTimeZoneBuilder$Recurrence.readFrom(DataInput)",
    "snippet": "        static Recurrence readFrom(DataInput in) throws IOException {\n            return new Recurrence(OfYear.readFrom(in), in.readUTF(), (int)readMillis(in));\n        }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 1
  },
  {
    "name": "DefaultNameProvider.DefaultNameProvider",
    "class_name": "org.joda.time.tz.DefaultNameProvider",
    "signature": "org.joda.time.tz.DefaultNameProvider.DefaultNameProvider()",
    "snippet": "    public DefaultNameProvider() {\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 1
  },
  {
    "name": "DefaultNameProvider.createCache",
    "class_name": "org.joda.time.tz.DefaultNameProvider",
    "signature": "org.joda.time.tz.DefaultNameProvider.createCache()",
    "snippet": "    private HashMap createCache() {\n        return new HashMap(7);\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 1
  },
  {
    "name": "FixedDateTimeZone.FixedDateTimeZone",
    "class_name": "org.joda.time.tz.FixedDateTimeZone",
    "signature": "org.joda.time.tz.FixedDateTimeZone.FixedDateTimeZone(String,String,int,int)",
    "snippet": "    public FixedDateTimeZone(String id, String nameKey,\n                             int wallOffset, int standardOffset) {\n        super(id);\n        iNameKey = nameKey;\n        iWallOffset = wallOffset;\n        iStandardOffset = standardOffset;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 1
  },
  {
    "name": "FixedDateTimeZone.equals",
    "class_name": "org.joda.time.tz.FixedDateTimeZone",
    "signature": "org.joda.time.tz.FixedDateTimeZone.equals(Object)",
    "snippet": "    public boolean equals(Object obj) {\n        if (this == obj) {\n            return true;\n        }\n        if (obj instanceof FixedDateTimeZone) {\n            FixedDateTimeZone other = (FixedDateTimeZone) obj;\n            return\n                getID().equals(other.getID()) &&\n                iStandardOffset == other.iStandardOffset &&\n                iWallOffset == other.iWallOffset;\n        }\n        return false;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 1
  },
  {
    "name": "FixedDateTimeZone.hashCode",
    "class_name": "org.joda.time.tz.FixedDateTimeZone",
    "signature": "org.joda.time.tz.FixedDateTimeZone.hashCode()",
    "snippet": "    public int hashCode() {\n        return getID().hashCode() + 37 * iStandardOffset + 31 * iWallOffset;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 1
  },
  {
    "name": "ZoneInfoProvider.ZoneInfoProvider",
    "class_name": "org.joda.time.tz.ZoneInfoProvider",
    "signature": "org.joda.time.tz.ZoneInfoProvider.ZoneInfoProvider(String)",
    "snippet": "    public ZoneInfoProvider(String resourcePath) throws IOException {\n        this(resourcePath, null, false);\n    }",
    "comment": " ZoneInfoProvider searches the given ClassLoader resource path for compiled data files. Resources are loaded from the ClassLoader that loaded this class.  @throws IOException if directory or map file cannot be read ",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 1
  },
  {
    "name": "ZoneInfoProvider.getAvailableIDs",
    "class_name": "org.joda.time.tz.ZoneInfoProvider",
    "signature": "org.joda.time.tz.ZoneInfoProvider.getAvailableIDs()",
    "snippet": "    public Set<String> getAvailableIDs() {\n        // Return a copy of the keys rather than an umodifiable collection.\n        // This prevents ConcurrentModificationExceptions from being thrown by\n        // some JVMs if zones are opened while this set is iterated over.\n        return new TreeSet<String>(iZoneInfoMap.keySet());\n    }",
    "comment": " Gets a list of all the available zone ids.  @return the zone ids ",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 1
  },
  {
    "name": "ZoneInfoProvider.getZone",
    "class_name": "org.joda.time.tz.ZoneInfoProvider",
    "signature": "org.joda.time.tz.ZoneInfoProvider.getZone(String)",
    "snippet": "    public DateTimeZone getZone(String id) {\n        if (id == null) {\n            return null;\n        }\n\n        Object obj = iZoneInfoMap.get(id);\n        if (obj == null) {\n            return null;\n        }\n\n        if (id.equals(obj)) {\n            // Load zone data for the first time.\n            return loadZoneData(id);\n        }\n\n        if (obj instanceof SoftReference<?>) {\n            @SuppressWarnings(\"unchecked\")\n            SoftReference<DateTimeZone> ref = (SoftReference<DateTimeZone>) obj;\n            DateTimeZone tz = ref.get();\n            if (tz != null) {\n                return tz;\n            }\n            // Reference cleared; load data again.\n            return loadZoneData(id);\n        }\n\n        // If this point is reached, mapping must link to another.\n        return getZone((String)obj);\n    }",
    "comment": " If an error is thrown while loading zone data, the exception is logged to system error and null is returned for this and all future requests.  @param id  the id to load @return the loaded zone ",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 1
  },
  {
    "name": "ZoneInfoProvider.loadZoneData",
    "class_name": "org.joda.time.tz.ZoneInfoProvider",
    "signature": "org.joda.time.tz.ZoneInfoProvider.loadZoneData(String)",
    "snippet": "    private DateTimeZone loadZoneData(String id) {\n        InputStream in = null;\n        try {\n            in = openResource(id);\n            DateTimeZone tz = DateTimeZoneBuilder.readFrom(in, id);\n            iZoneInfoMap.put(id, new SoftReference<DateTimeZone>(tz));\n            return tz;\n        } catch (IOException ex) {\n            uncaughtException(ex);\n            iZoneInfoMap.remove(id);\n            return null;\n        } finally {\n            try {\n                if (in != null) {\n                    in.close();\n                }\n            } catch (IOException ex) {\n            }\n        }\n    }",
    "comment": " Loads the time zone data for one id.  @param id  the id to load @return the zone ",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 1
  },
  {
    "name": "ZoneInfoProvider.loadZoneInfoMap",
    "class_name": "org.joda.time.tz.ZoneInfoProvider",
    "signature": "org.joda.time.tz.ZoneInfoProvider.loadZoneInfoMap(InputStream)",
    "snippet": "    private static Map<String, Object> loadZoneInfoMap(InputStream in) throws IOException {\n        Map<String, Object> map = new ConcurrentHashMap<String, Object>();\n        DataInputStream din = new DataInputStream(in);\n        try {\n            readZoneInfoMap(din, map);\n        } finally {\n            try {\n                din.close();\n            } catch (IOException ex) {\n            }\n        }\n        map.put(\"UTC\", new SoftReference<DateTimeZone>(DateTimeZone.UTC));\n        return map;\n    }",
    "comment": " Loads the zone info map.  @param in  the input stream @return the map ",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 1
  },
  {
    "name": "ZoneInfoProvider.openResource",
    "class_name": "org.joda.time.tz.ZoneInfoProvider",
    "signature": "org.joda.time.tz.ZoneInfoProvider.openResource(String)",
    "snippet": "    @SuppressWarnings(\"resource\")\n    private InputStream openResource(String name) throws IOException {\n        InputStream in;\n        if (iFileDir != null) {\n            in = new FileInputStream(new File(iFileDir, name));\n        } else {\n            String path = iResourcePath.concat(name);\n            if (iLoader != null) {\n                in = iLoader.getResourceAsStream(path);\n            } else {\n                in = ClassLoader.getSystemResourceAsStream(path);\n            }\n            if (in == null) {\n                StringBuilder buf = new StringBuilder(40)\n                    .append(\"Resource not found: \\\"\")\n                    .append(path)\n                    .append(\"\\\" ClassLoader: \")\n                    .append(iLoader != null ? iLoader.toString() : \"system\");\n                throw new IOException(buf.toString());\n            }\n        }\n        return in;\n    }",
    "comment": " Opens a resource from file or classpath.  @param name  the name to open @return the input stream @throws IOException if an error occurs ",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 1
  },
  {
    "name": "ZoneInfoProvider.readZoneInfoMap",
    "class_name": "org.joda.time.tz.ZoneInfoProvider",
    "signature": "org.joda.time.tz.ZoneInfoProvider.readZoneInfoMap(DataInputStream,Map)",
    "snippet": "    private static void readZoneInfoMap(DataInputStream din, Map<String, Object> zimap) throws IOException {\n        // Read the string pool.\n        int size = din.readUnsignedShort();\n        String[] pool = new String[size];\n        for (int i=0; i<size; i++) {\n            pool[i] = din.readUTF().intern();\n        }\n\n        // Read the mappings.\n        size = din.readUnsignedShort();\n        for (int i=0; i<size; i++) {\n            try {\n                zimap.put(pool[din.readUnsignedShort()], pool[din.readUnsignedShort()]);\n            } catch (ArrayIndexOutOfBoundsException ex) {\n                throw new IOException(\"Corrupt zone info map\");\n            }\n        }\n    }",
    "comment": " Reads the zone info map from file.  @param din  the input stream @param zimap  gets filled with string id to string id mappings ",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 1
  }
]