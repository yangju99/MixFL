[
  {
    "name": "AbstractMessageFormatter.AbstractMessageFormatter",
    "class_name": "com.google.javascript.jscomp.AbstractMessageFormatter",
    "signature": "com.google.javascript.jscomp.AbstractMessageFormatter.AbstractMessageFormatter(SourceExcerptProvider)",
    "snippet": "  public AbstractMessageFormatter(SourceExcerptProvider source) {\n    this.source = source;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "AbstractMessageFormatter.setColorize",
    "class_name": "com.google.javascript.jscomp.AbstractMessageFormatter",
    "signature": "com.google.javascript.jscomp.AbstractMessageFormatter.setColorize(boolean)",
    "snippet": "  public void setColorize(boolean colorize) {\n    this.colorize = colorize;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "BasicErrorManager.getErrorCount",
    "class_name": "com.google.javascript.jscomp.BasicErrorManager",
    "signature": "com.google.javascript.jscomp.BasicErrorManager.getErrorCount()",
    "snippet": "  @Override\n  public int getErrorCount() {\n    return errorCount;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "CheckLevel.isOn",
    "class_name": "com.google.javascript.jscomp.CheckLevel",
    "signature": "com.google.javascript.jscomp.CheckLevel.isOn()",
    "snippet": "  boolean isOn() {\n    return this != OFF;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "RecentChange.hasCodeChanged",
    "class_name": "com.google.javascript.jscomp.CodeChangeHandler$RecentChange",
    "signature": "com.google.javascript.jscomp.CodeChangeHandler$RecentChange.hasCodeChanged()",
    "snippet": "    boolean hasCodeChanged() {\n      return hasChanged;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "Compiler.Compiler",
    "class_name": "com.google.javascript.jscomp.Compiler",
    "signature": "com.google.javascript.jscomp.Compiler.Compiler()",
    "snippet": "  public Compiler() {\n    this((PrintStream) null);\n  }",
    "comment": " Creates a Compiler that reports errors and warnings to its logger. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "Compiler.Compiler",
    "class_name": "com.google.javascript.jscomp.Compiler",
    "signature": "com.google.javascript.jscomp.Compiler.Compiler(PrintStream)",
    "snippet": "  public Compiler(PrintStream stream) {\n    addChangeHandler(recentChange);\n    outStream = stream;\n  }",
    "comment": " Creates n Compiler that reports errors and warnings to an output stream. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "Compiler.acceptConstKeyword",
    "class_name": "com.google.javascript.jscomp.Compiler",
    "signature": "com.google.javascript.jscomp.Compiler.acceptConstKeyword()",
    "snippet": "  @Override\n  public boolean acceptConstKeyword() {\n    return options.acceptConstKeyword;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "Compiler.addChangeHandler",
    "class_name": "com.google.javascript.jscomp.Compiler",
    "signature": "com.google.javascript.jscomp.Compiler.addChangeHandler(CodeChangeHandler)",
    "snippet": "  @Override\n  void addChangeHandler(CodeChangeHandler handler) {\n    codeChangeHandlers.add(handler);\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "Compiler.createMessageFormatter",
    "class_name": "com.google.javascript.jscomp.Compiler",
    "signature": "com.google.javascript.jscomp.Compiler.createMessageFormatter()",
    "snippet": "  private MessageFormatter createMessageFormatter() {\n    boolean colorize = options.shouldColorizeErrorOutput();\n    return options.errorFormat.toFormatter(this, colorize);\n  }",
    "comment": " Creates a message formatter instance corresponding to the value of {@link CompilerOptions}. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "Compiler.getCodingConvention",
    "class_name": "com.google.javascript.jscomp.Compiler",
    "signature": "com.google.javascript.jscomp.Compiler.getCodingConvention()",
    "snippet": "  @Override\n  public CodingConvention getCodingConvention() {\n    CodingConvention convention = options.getCodingConvention();\n    convention = convention != null ? convention : defaultCodingConvention;\n    return convention;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "Compiler.getDefaultErrorReporter",
    "class_name": "com.google.javascript.jscomp.Compiler",
    "signature": "com.google.javascript.jscomp.Compiler.getDefaultErrorReporter()",
    "snippet": "  @Override\n  ErrorReporter getDefaultErrorReporter() {\n    return defaultErrorReporter;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "Compiler.getDiagnosticGroups",
    "class_name": "com.google.javascript.jscomp.Compiler",
    "signature": "com.google.javascript.jscomp.Compiler.getDiagnosticGroups()",
    "snippet": "  protected DiagnosticGroups getDiagnosticGroups() {\n    return new DiagnosticGroups();\n  }",
    "comment": " The warning classes that are available from the command-line, and are suppressable by the {@code @suppress} annotation. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "Compiler.getErrorCount",
    "class_name": "com.google.javascript.jscomp.Compiler",
    "signature": "com.google.javascript.jscomp.Compiler.getErrorCount()",
    "snippet": "  public int getErrorCount() {\n    return errorManager.getErrorCount();\n  }",
    "comment": " Gets the number of errors. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "Compiler.getInput",
    "class_name": "com.google.javascript.jscomp.Compiler",
    "signature": "com.google.javascript.jscomp.Compiler.getInput(InputId)",
    "snippet": "  @Override\n  public CompilerInput getInput(InputId id) {\n    return inputsById.get(id);\n  }",
    "comment": "interface, and which ones should always be injected.",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "Compiler.getParserConfig",
    "class_name": "com.google.javascript.jscomp.Compiler",
    "signature": "com.google.javascript.jscomp.Compiler.getParserConfig()",
    "snippet": "  @Override\n  Config getParserConfig() {\n    if (parserConfig == null) {\n      Config.LanguageMode mode;\n      switch (options.getLanguageIn()) {\n        case ECMASCRIPT3:\n          mode = Config.LanguageMode.ECMASCRIPT3;\n          break;\n        case ECMASCRIPT5:\n          mode = Config.LanguageMode.ECMASCRIPT5;\n          break;\n        case ECMASCRIPT5_STRICT:\n          mode = Config.LanguageMode.ECMASCRIPT5_STRICT;\n          break;\n        default:\n          throw new IllegalStateException(\"unexpected language mode\");\n      }\n\n      parserConfig = ParserRunner.createConfig(\n        isIdeMode(),\n        mode,\n        acceptConstKeyword(),\n        options.extraAnnotationNames);\n    }\n    return parserConfig;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "Compiler.getTypeRegistry",
    "class_name": "com.google.javascript.jscomp.Compiler",
    "signature": "com.google.javascript.jscomp.Compiler.getTypeRegistry()",
    "snippet": "  @Override\n  public JSTypeRegistry getTypeRegistry() {\n    if (typeRegistry == null) {\n      typeRegistry = new JSTypeRegistry(oldErrorReporter, options.looseTypes);\n    }\n    return typeRegistry;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "Compiler.hasHaltingErrors",
    "class_name": "com.google.javascript.jscomp.Compiler",
    "signature": "com.google.javascript.jscomp.Compiler.hasHaltingErrors()",
    "snippet": "  @Override\n  boolean hasHaltingErrors() {\n    return !isIdeMode() && getErrorCount() > 0;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "Compiler.initCompilerOptionsIfTesting",
    "class_name": "com.google.javascript.jscomp.Compiler",
    "signature": "com.google.javascript.jscomp.Compiler.initCompilerOptionsIfTesting()",
    "snippet": "  void initCompilerOptionsIfTesting() {\n    if (options == null) {\n      // initialization for tests that don't initialize the compiler\n      // by the normal mechanisms.\n      initOptions(new CompilerOptions());\n    }\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "Compiler.initOptions",
    "class_name": "com.google.javascript.jscomp.Compiler",
    "signature": "com.google.javascript.jscomp.Compiler.initOptions(CompilerOptions)",
    "snippet": "  public void initOptions(CompilerOptions options) {\n    this.options = options;\n    if (errorManager == null) {\n      if (outStream == null) {\n        setErrorManager(\n            new LoggerErrorManager(createMessageFormatter(), logger));\n      } else {\n        PrintStreamErrorManager printer =\n            new PrintStreamErrorManager(createMessageFormatter(), outStream);\n        printer.setSummaryDetailLevel(options.summaryDetailLevel);\n        setErrorManager(printer);\n      }\n    }\n\n    // DiagnosticGroups override the plain checkTypes option.\n    if (options.enables(DiagnosticGroups.CHECK_TYPES)) {\n      options.checkTypes = true;\n    } else if (options.disables(DiagnosticGroups.CHECK_TYPES)) {\n      options.checkTypes = false;\n    } else if (!options.checkTypes) {\n      // If DiagnosticGroups did not override the plain checkTypes\n      // option, and checkTypes is enabled, then turn off the\n      // parser type warnings.\n      options.setWarningLevel(\n          DiagnosticGroup.forType(\n              RhinoErrorReporter.TYPE_PARSE_ERROR),\n          CheckLevel.OFF);\n    }\n\n    if (options.checkGlobalThisLevel.isOn() &&\n        !options.disables(DiagnosticGroups.GLOBAL_THIS)) {\n      options.setWarningLevel(\n          DiagnosticGroups.GLOBAL_THIS,\n          options.checkGlobalThisLevel);\n    }\n\n    if (options.getLanguageIn() == LanguageMode.ECMASCRIPT5_STRICT) {\n      options.setWarningLevel(\n          DiagnosticGroups.ES5_STRICT,\n          CheckLevel.ERROR);\n    }\n\n    // Initialize the warnings guard.\n    List<WarningsGuard> guards = Lists.newArrayList();\n    guards.add(\n        new SuppressDocWarningsGuard(\n            getDiagnosticGroups().getRegisteredGroups()));\n    guards.add(options.getWarningsGuard());\n\n    ComposeWarningsGuard composedGuards = new ComposeWarningsGuard(guards);\n\n    // All passes must run the variable check. This synthesizes\n    // variables later so that the compiler doesn't crash. It also\n    // checks the externs file for validity. If you don't want to warn\n    // about missing variable declarations, we shut that specific\n    // error off.\n    if (!options.checkSymbols &&\n        !composedGuards.enables(DiagnosticGroups.CHECK_VARIABLES)) {\n      composedGuards.addGuard(new DiagnosticGroupWarningsGuard(\n          DiagnosticGroups.CHECK_VARIABLES, CheckLevel.OFF));\n    }\n\n    this.warningsGuard = composedGuards;\n  }",
    "comment": " Initialize the compiler options. Only necessary if you're not doing a normal compile() job. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "Compiler.isIdeMode",
    "class_name": "com.google.javascript.jscomp.Compiler",
    "signature": "com.google.javascript.jscomp.Compiler.isIdeMode()",
    "snippet": "  @Override\n  public boolean isIdeMode() {\n    return options.ideMode;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "Compiler.newTracer",
    "class_name": "com.google.javascript.jscomp.Compiler",
    "signature": "com.google.javascript.jscomp.Compiler.newTracer(String)",
    "snippet": "  Tracer newTracer(String passName) {\n    String comment = passName\n        + (recentChange.hasCodeChanged() ? \" on recently changed AST\" : \"\");\n    if (options.tracer.isOn()) {\n      tracker.recordPassStart(passName);\n    }\n    return new Tracer(\"Compiler\", comment);\n  }",
    "comment": " Returns a new tracer for the given pass name. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "Compiler.parseTestCode",
    "class_name": "com.google.javascript.jscomp.Compiler",
    "signature": "com.google.javascript.jscomp.Compiler.parseTestCode(String)",
    "snippet": "  @Override\n  Node parseTestCode(String js) {\n    initCompilerOptionsIfTesting();\n    CompilerInput input = new CompilerInput(\n        JSSourceFile.fromCode(\" [testcode] \", js));\n    if (inputsById == null) {\n      inputsById = Maps.newHashMap();\n    }\n    inputsById.put(input.getInputId(), input);\n    return input.getAstRoot(this);\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "Compiler.prepareAst",
    "class_name": "com.google.javascript.jscomp.Compiler",
    "signature": "com.google.javascript.jscomp.Compiler.prepareAst(Node)",
    "snippet": "  @Override\n  void prepareAst(Node root) {\n    Tracer tracer = newTracer(\"prepareAst\");\n    CompilerPass pass = new PrepareAst(this);\n    pass.process(null, root);\n    stopTracer(tracer, \"prepareAst\");\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "Compiler.setErrorManager",
    "class_name": "com.google.javascript.jscomp.Compiler",
    "signature": "com.google.javascript.jscomp.Compiler.setErrorManager(ErrorManager)",
    "snippet": "  public void setErrorManager(ErrorManager errorManager) {\n    Preconditions.checkNotNull(\n        errorManager, \"the error manager cannot be null\");\n    this.errorManager = errorManager;\n  }",
    "comment": " Sets the error manager.  @param errorManager the error manager, it cannot be {@code null} ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "Compiler.stopTracer",
    "class_name": "com.google.javascript.jscomp.Compiler",
    "signature": "com.google.javascript.jscomp.Compiler.stopTracer(Tracer,String)",
    "snippet": "  void stopTracer(Tracer t, String passName) {\n    long result = t.stop();\n    if (options.tracer.isOn()) {\n      tracker.recordPassStop(passName, result);\n    }\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "CompilerInput.CompilerInput",
    "class_name": "com.google.javascript.jscomp.CompilerInput",
    "signature": "com.google.javascript.jscomp.CompilerInput.CompilerInput(JSSourceFile)",
    "snippet": "  public CompilerInput(JSSourceFile file) {\n    this(file, false);\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "CompilerInput.CompilerInput",
    "class_name": "com.google.javascript.jscomp.CompilerInput",
    "signature": "com.google.javascript.jscomp.CompilerInput.CompilerInput(JSSourceFile,boolean)",
    "snippet": "  public CompilerInput(JSSourceFile file, boolean isExtern) {\n    this(new JsAst(file), isExtern);\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "CompilerInput.CompilerInput",
    "class_name": "com.google.javascript.jscomp.CompilerInput",
    "signature": "com.google.javascript.jscomp.CompilerInput.CompilerInput(SourceAst,InputId,boolean)",
    "snippet": "  public CompilerInput(SourceAst ast, InputId inputId, boolean isExtern) {\n    this.ast = ast;\n    this.id = inputId;\n\n    // TODO(nicksantos): Add a precondition check here. People are passing\n    // in null, but they should not be.\n    if (ast != null && ast.getSourceFile() != null) {\n      ast.getSourceFile().setIsExtern(isExtern);\n    }\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "CompilerInput.CompilerInput",
    "class_name": "com.google.javascript.jscomp.CompilerInput",
    "signature": "com.google.javascript.jscomp.CompilerInput.CompilerInput(SourceAst,boolean)",
    "snippet": "  public CompilerInput(SourceAst ast, boolean isExtern) {\n    this(ast, ast.getInputId(), isExtern);\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "CompilerInput.getAstRoot",
    "class_name": "com.google.javascript.jscomp.CompilerInput",
    "signature": "com.google.javascript.jscomp.CompilerInput.getAstRoot(AbstractCompiler)",
    "snippet": "  @Override\n  public Node getAstRoot(AbstractCompiler compiler) {\n    Node root = ast.getAstRoot(compiler);\n    // The root maybe null if the AST can not be created.\n    if (root != null) {\n      Preconditions.checkState(root.getType() == Token.SCRIPT);\n      Preconditions.checkNotNull(root.getInputId());\n    }\n    return root;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "CompilerInput.getInputId",
    "class_name": "com.google.javascript.jscomp.CompilerInput",
    "signature": "com.google.javascript.jscomp.CompilerInput.getInputId()",
    "snippet": "  @Override\n  public InputId getInputId() {\n    return id;\n  }",
    "comment": "Returns a name for this input. Must be unique across all inputs. */",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "CompilerOptions.CompilerOptions",
    "class_name": "com.google.javascript.jscomp.CompilerOptions",
    "signature": "com.google.javascript.jscomp.CompilerOptions.CompilerOptions()",
    "snippet": "  public CompilerOptions() {\n    // Accepted language\n    languageIn = LanguageMode.ECMASCRIPT3;\n\n    // Language variation\n    acceptConstKeyword = false;\n\n    // Checks\n    skipAllPasses = false;\n    nameAnonymousFunctionsOnly = false;\n    devMode = DevMode.OFF;\n    checkSymbols = false;\n    checkShadowVars = CheckLevel.OFF;\n    aggressiveVarCheck = CheckLevel.OFF;\n    checkFunctions = CheckLevel.OFF;\n    checkMethods = CheckLevel.OFF;\n    checkDuplicateMessages = false;\n    allowLegacyJsMessages = false;\n    strictMessageReplacement = false;\n    checkSuspiciousCode = false;\n    checkControlStructures = false;\n    checkTypes = false;\n    tightenTypes = false;\n    inferTypesInGlobalScope = false;\n    checkTypedPropertyCalls = false;\n    reportMissingOverride = CheckLevel.OFF;\n    reportUnknownTypes = CheckLevel.OFF;\n    checkRequires = CheckLevel.OFF;\n    checkProvides = CheckLevel.OFF;\n    checkGlobalNamesLevel = CheckLevel.OFF;\n    brokenClosureRequiresLevel = CheckLevel.ERROR;\n    checkGlobalThisLevel = CheckLevel.OFF;\n    checkUnreachableCode = CheckLevel.OFF;\n    checkMissingReturn = CheckLevel.OFF;\n    checkMissingGetCssNameLevel = CheckLevel.OFF;\n    checkMissingGetCssNameBlacklist = null;\n    checkCaja = false;\n    computeFunctionSideEffects = false;\n    chainCalls = false;\n    extraAnnotationNames = null;\n\n    // Optimizations\n    foldConstants = false;\n    coalesceVariableNames = false;\n    deadAssignmentElimination = false;\n    inlineConstantVars = false;\n    inlineFunctions = false;\n    inlineLocalFunctions = false;\n    assumeStrictThis = false;\n    crossModuleCodeMotion = false;\n    crossModuleMethodMotion = false;\n    inlineGetters = false;\n    inlineVariables = false;\n    inlineLocalVariables = false;\n    smartNameRemoval = false;\n    removeDeadCode = false;\n    extractPrototypeMemberDeclarations = false;\n    removeUnusedPrototypeProperties = false;\n    removeUnusedPrototypePropertiesInExterns = false;\n    removeUnusedVars = false;\n    removeUnusedLocalVars = false;\n    aliasExternals = false;\n    collapseVariableDeclarations = false;\n    groupVariableDeclarations = false;\n    collapseAnonymousFunctions = false;\n    aliasableStrings = Collections.emptySet();\n    aliasStringsBlacklist = \"\";\n    aliasAllStrings = false;\n    outputJsStringUsage = false;\n    convertToDottedProperties = false;\n    rewriteFunctionExpressions = false;\n    optimizeParameters = false;\n    optimizeReturns = false;\n\n    // Renaming\n    variableRenaming = VariableRenamingPolicy.OFF;\n    propertyRenaming = PropertyRenamingPolicy.OFF;\n    propertyAffinity = false;\n    labelRenaming = false;\n    generatePseudoNames = false;\n    shadowVariables = false;\n    renamePrefix = null;\n    aliasKeywords = false;\n    collapseProperties = false;\n    collapsePropertiesOnExternTypes = false;\n    collapseObjectLiterals = false;\n    devirtualizePrototypeMethods = false;\n    disambiguateProperties = false;\n    ambiguateProperties = false;\n    anonymousFunctionNaming = AnonymousFunctionNamingPolicy.OFF;\n    exportTestFunctions = false;\n\n    // Alterations\n    runtimeTypeCheck = false;\n    runtimeTypeCheckLogFunction = null;\n    instrumentForCoverage = false;\n    instrumentForCoverageOnly = false;\n    ignoreCajaProperties = false;\n    syntheticBlockStartMarker = null;\n    syntheticBlockEndMarker = null;\n    locale = null;\n    markAsCompiled = false;\n    removeTryCatchFinally = false;\n    closurePass = false;\n    rewriteNewDateGoogNow = true;\n    removeAbstractMethods = true;\n    removeClosureAsserts = false;\n    stripTypes = Collections.emptySet();\n    stripNameSuffixes = Collections.emptySet();\n    stripNamePrefixes = Collections.emptySet();\n    stripTypePrefixes = Collections.emptySet();\n    customPasses = null;\n    markNoSideEffectCalls = false;\n    defineReplacements = Maps.newHashMap();\n    tweakProcessing = TweakProcessing.OFF;\n    tweakReplacements = Maps.newHashMap();\n    moveFunctionDeclarations = false;\n    instrumentationTemplate = null;\n    appNameStr = \"\";\n    recordFunctionInformation = false;\n    generateExports = false;\n    cssRenamingMap = null;\n    processObjectPropertyString = false;\n    idGenerators = Collections.emptySet();\n    replaceStringsFunctionDescriptions = Collections.emptyList();\n    replaceStringsPlaceholderToken = \"\";\n    replaceStringsReservedStrings = Collections.emptySet();\n\n    // Output\n    printInputDelimiter = false;\n    prettyPrint = false;\n    lineBreak = false;\n    reportPath = null;\n    tracer = TracerMode.OFF;\n    colorizeErrorOutput = false;\n    errorFormat = ErrorFormat.SINGLELINE;\n    debugFunctionSideEffectsPath = null;\n    jsOutputFile = \"\";\n    externExports = false;\n    nameReferenceReportPath = null;\n    nameReferenceGraphPath = null;\n\n    // Debugging\n    aliasHandler = NULL_ALIAS_TRANSFORMATION_HANDLER;\n\n    operaCompoundAssignFix = true;\n  }",
    "comment": " Initializes compiler options. All options are disabled by default.  Command-line frontends to the compiler should set these properties like a builder. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "CompilerOptions.addWarningsGuard",
    "class_name": "com.google.javascript.jscomp.CompilerOptions",
    "signature": "com.google.javascript.jscomp.CompilerOptions.addWarningsGuard(WarningsGuard)",
    "snippet": "  public void addWarningsGuard(WarningsGuard guard) {\n    warningsGuard.addGuard(guard);\n  }",
    "comment": " Add a guard to the set of warnings guards. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "CompilerOptions.disables",
    "class_name": "com.google.javascript.jscomp.CompilerOptions",
    "signature": "com.google.javascript.jscomp.CompilerOptions.disables(DiagnosticGroup)",
    "snippet": "  boolean disables(DiagnosticGroup type) {\n    return warningsGuard.disables(type);\n  }",
    "comment": " Whether the warnings guard in this Options object disables the given group of warnings. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "CompilerOptions.enables",
    "class_name": "com.google.javascript.jscomp.CompilerOptions",
    "signature": "com.google.javascript.jscomp.CompilerOptions.enables(DiagnosticGroup)",
    "snippet": "  boolean enables(DiagnosticGroup type) {\n    return warningsGuard.enables(type);\n  }",
    "comment": " Whether the warnings guard in this Options object enables the given group of warnings. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "CompilerOptions.getCodingConvention",
    "class_name": "com.google.javascript.jscomp.CompilerOptions",
    "signature": "com.google.javascript.jscomp.CompilerOptions.getCodingConvention()",
    "snippet": "  public CodingConvention getCodingConvention() {\n    return codingConvention;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "CompilerOptions.getLanguageIn",
    "class_name": "com.google.javascript.jscomp.CompilerOptions",
    "signature": "com.google.javascript.jscomp.CompilerOptions.getLanguageIn()",
    "snippet": "  public LanguageMode getLanguageIn() {\n    return languageIn;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "CompilerOptions.getWarningsGuard",
    "class_name": "com.google.javascript.jscomp.CompilerOptions",
    "signature": "com.google.javascript.jscomp.CompilerOptions.getWarningsGuard()",
    "snippet": "  WarningsGuard getWarningsGuard() {\n    return warningsGuard;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "CompilerOptions.setCodingConvention",
    "class_name": "com.google.javascript.jscomp.CompilerOptions",
    "signature": "com.google.javascript.jscomp.CompilerOptions.setCodingConvention(CodingConvention)",
    "snippet": "  public void setCodingConvention(CodingConvention codingConvention) {\n    this.codingConvention = codingConvention;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "CompilerOptions.setWarningLevel",
    "class_name": "com.google.javascript.jscomp.CompilerOptions",
    "signature": "com.google.javascript.jscomp.CompilerOptions.setWarningLevel(DiagnosticGroup,CheckLevel)",
    "snippet": "  public void setWarningLevel(DiagnosticGroup type, CheckLevel level) {\n    addWarningsGuard(new DiagnosticGroupWarningsGuard(type, level));\n  }",
    "comment": " Configure the given type of warning to the given level. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "CompilerOptions.shouldColorizeErrorOutput",
    "class_name": "com.google.javascript.jscomp.CompilerOptions",
    "signature": "com.google.javascript.jscomp.CompilerOptions.shouldColorizeErrorOutput()",
    "snippet": "  public boolean shouldColorizeErrorOutput() {\n    return colorizeErrorOutput;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "TracerMode.isOn",
    "class_name": "com.google.javascript.jscomp.CompilerOptions$TracerMode",
    "signature": "com.google.javascript.jscomp.CompilerOptions$TracerMode.isOn()",
    "snippet": "    boolean isOn() {\n      return this != OFF;\n    }",
    "comment": "Collect no timing and size metrics.",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "ComposeWarningsGuard.ComposeWarningsGuard",
    "class_name": "com.google.javascript.jscomp.ComposeWarningsGuard",
    "signature": "com.google.javascript.jscomp.ComposeWarningsGuard.ComposeWarningsGuard(List)",
    "snippet": "  public ComposeWarningsGuard(List<WarningsGuard> guards) {\n    addGuards(guards);\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "ComposeWarningsGuard.ComposeWarningsGuard",
    "class_name": "com.google.javascript.jscomp.ComposeWarningsGuard",
    "signature": "com.google.javascript.jscomp.ComposeWarningsGuard.ComposeWarningsGuard(WarningsGuard[])",
    "snippet": "  public ComposeWarningsGuard(WarningsGuard... guards) {\n    this(Lists.newArrayList(guards));\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "ComposeWarningsGuard.addGuard",
    "class_name": "com.google.javascript.jscomp.ComposeWarningsGuard",
    "signature": "com.google.javascript.jscomp.ComposeWarningsGuard.addGuard(WarningsGuard)",
    "snippet": "  void addGuard(WarningsGuard guard) {\n    if (guard instanceof ComposeWarningsGuard) {\n      // Reverse the guards, so that they have the same order in the result.\n      addGuards(((ComposeWarningsGuard) guard).guards.descendingSet());\n    } else {\n      numberOfAdds++;\n      orderOfAddition.put(guard, numberOfAdds);\n      guards.remove(guard);\n      guards.add(guard);\n    }\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "ComposeWarningsGuard.addGuards",
    "class_name": "com.google.javascript.jscomp.ComposeWarningsGuard",
    "signature": "com.google.javascript.jscomp.ComposeWarningsGuard.addGuards(Iterable)",
    "snippet": "  private void addGuards(Iterable<WarningsGuard> guards) {\n    for (WarningsGuard guard : guards) {\n      addGuard(guard);\n    }\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "ComposeWarningsGuard.disables",
    "class_name": "com.google.javascript.jscomp.ComposeWarningsGuard",
    "signature": "com.google.javascript.jscomp.ComposeWarningsGuard.disables(DiagnosticGroup)",
    "snippet": "  @Override\n  public boolean disables(DiagnosticGroup group) {\n    nextSingleton:\n    for (DiagnosticType type : group.getTypes()) {\n      DiagnosticGroup singleton = DiagnosticGroup.forType(type);\n\n      for (WarningsGuard guard : guards) {\n        if (guard.disables(singleton)) {\n          continue nextSingleton;\n        } else if (guard.enables(singleton)) {\n          return false;\n        }\n      }\n\n      return false;\n    }\n\n    return true;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "ComposeWarningsGuard.enables",
    "class_name": "com.google.javascript.jscomp.ComposeWarningsGuard",
    "signature": "com.google.javascript.jscomp.ComposeWarningsGuard.enables(DiagnosticGroup)",
    "snippet": "  @Override\n  public boolean enables(DiagnosticGroup group) {\n    for (WarningsGuard guard : guards) {\n      if (guard.enables(group)) {\n        return true;\n      } else if (guard.disables(group)) {\n        return false;\n      }\n    }\n\n    return false;\n  }",
    "comment": " Determines whether this guard will \"elevate\" the status of any disabled diagnostic type in the group to a warning or an error. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "GuardComparator.compare",
    "class_name": "com.google.javascript.jscomp.ComposeWarningsGuard$GuardComparator",
    "signature": "com.google.javascript.jscomp.ComposeWarningsGuard$GuardComparator.compare(WarningsGuard,WarningsGuard)",
    "snippet": "    @Override\n    public int compare(WarningsGuard a, WarningsGuard b) {\n      int priorityDiff = a.getPriority() - b.getPriority();\n      if (priorityDiff != 0) {\n        return priorityDiff;\n      }\n\n      // If the warnings guards have the same priority, the one that\n      // was added last wins.\n      return orderOfAddition.get(b).intValue() -\n          orderOfAddition.get(a).intValue();\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "ControlFlowAnalysis.ControlFlowAnalysis",
    "class_name": "com.google.javascript.jscomp.ControlFlowAnalysis",
    "signature": "com.google.javascript.jscomp.ControlFlowAnalysis.ControlFlowAnalysis(AbstractCompiler,boolean,boolean)",
    "snippet": "  ControlFlowAnalysis(AbstractCompiler compiler,\n      boolean shouldTraverseFunctions, boolean edgeAnnotations) {\n    this.compiler = compiler;\n    this.shouldTraverseFunctions = shouldTraverseFunctions;\n    this.edgeAnnotations = edgeAnnotations;\n  }",
    "comment": " Constructor.  @param compiler Compiler instance. @param shouldTraverseFunctions Whether functions should be traversed (true by default). @param edgeAnnotations Whether to allow edge annotations. By default, only node annotations are allowed. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "ControlFlowAnalysis.computeFallThrough",
    "class_name": "com.google.javascript.jscomp.ControlFlowAnalysis",
    "signature": "com.google.javascript.jscomp.ControlFlowAnalysis.computeFallThrough(Node)",
    "snippet": "  static Node computeFallThrough(Node n) {\n    switch (n.getType()) {\n      case Token.DO:\n        return computeFallThrough(n.getFirstChild());\n      case Token.FOR:\n        if (NodeUtil.isForIn(n)) {\n          return n;\n        }\n        return computeFallThrough(n.getFirstChild());\n      case Token.LABEL:\n        return computeFallThrough(n.getLastChild());\n      default:\n        return n;\n    }\n  }",
    "comment": " Computes the destination node of n when we want to fallthough into the subtree of n. We don't always create a CFG edge into n itself because of DOs and FORs. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "ControlFlowAnalysis.computeFollowNode",
    "class_name": "com.google.javascript.jscomp.ControlFlowAnalysis",
    "signature": "com.google.javascript.jscomp.ControlFlowAnalysis.computeFollowNode(Node,ControlFlowAnalysis)",
    "snippet": "  static Node computeFollowNode(Node node, ControlFlowAnalysis cfa) {\n    return computeFollowNode(node, node, cfa);\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "ControlFlowAnalysis.computeFollowNode",
    "class_name": "com.google.javascript.jscomp.ControlFlowAnalysis",
    "signature": "com.google.javascript.jscomp.ControlFlowAnalysis.computeFollowNode(Node,Node,ControlFlowAnalysis)",
    "snippet": "  private static Node computeFollowNode(\n      Node fromNode, Node node, ControlFlowAnalysis cfa) {\n    /*\n     * This is the case where:\n     *\n     * 1. Parent is null implies that we are transferring control to the end of\n     * the script.\n     *\n     * 2. Parent is a function implies that we are transferring control back to\n     * the caller of the function.\n     *\n     * 3. If the node is a return statement, we should also transfer control\n     * back to the caller of the function.\n     *\n     * 4. If the node is root then we have reached the end of what we have been\n     * asked to traverse.\n     *\n     * In all cases we should transfer control to a \"symbolic return\" node.\n     * This will make life easier for DFAs.\n     */\n    Node parent = node.getParent();\n    if (parent == null || parent.getType() == Token.FUNCTION ||\n        (cfa != null && node == cfa.root)) {\n      return null;\n    }\n\n    // If we are just before a IF/WHILE/DO/FOR:\n    switch (parent.getType()) {\n      // The follow() of any of the path from IF would be what follows IF.\n      case Token.IF:\n        return computeFollowNode(fromNode, parent, cfa);\n      case Token.CASE:\n      case Token.DEFAULT:\n        // After the body of a CASE, the control goes to the body of the next\n        // case, without having to go to the case condition.\n        if (parent.getNext() != null) {\n          if (parent.getNext().getType() == Token.CASE) {\n            return parent.getNext().getFirstChild().getNext();\n          } else if (parent.getNext().getType() == Token.DEFAULT) {\n            return parent.getNext().getFirstChild();\n          } else {\n            Preconditions.checkState(false, \"Not reachable\");\n          }\n        } else {\n          return computeFollowNode(fromNode, parent, cfa);\n        }\n        break;\n      case Token.FOR:\n        if (NodeUtil.isForIn(parent)) {\n          return parent;\n        } else {\n          return parent.getFirstChild().getNext().getNext();\n        }\n      case Token.WHILE:\n      case Token.DO:\n        return parent;\n      case Token.TRY:\n        // If we are coming out of the TRY block...\n        if (parent.getFirstChild() == node) {\n          if (NodeUtil.hasFinally(parent)) { // and have FINALLY block.\n            return computeFallThrough(parent.getLastChild());\n          } else { // and have no FINALLY.\n            return computeFollowNode(fromNode, parent, cfa);\n          }\n        // CATCH block.\n        } else if (NodeUtil.getCatchBlock(parent) == node){\n          if (NodeUtil.hasFinally(parent)) { // and have FINALLY block.\n            return computeFallThrough(node.getNext());\n          } else {\n            return computeFollowNode(fromNode, parent, cfa);\n          }\n        // If we are coming out of the FINALLY block...\n        } else if (parent.getLastChild() == node){\n          if (cfa != null) {\n            for (Node finallyNode : cfa.finallyMap.get(parent)) {\n              cfa.createEdge(fromNode, Branch.UNCOND, finallyNode);\n            }\n          }\n          return computeFollowNode(fromNode, parent, cfa);\n        }\n    }\n\n    // Now that we are done with the special cases follow should be its\n    // immediate sibling, unless its sibling is a function\n    Node nextSibling = node.getNext();\n\n    // Skip function declarations because control doesn't get pass into it.\n    while (nextSibling != null && nextSibling.getType() == Token.FUNCTION) {\n      nextSibling = nextSibling.getNext();\n    }\n\n    if (nextSibling != null) {\n      return computeFallThrough(nextSibling);\n    } else {\n      // If there are no more siblings, control is transfered up the AST.\n      return computeFollowNode(fromNode, parent, cfa);\n    }\n  }",
    "comment": " Computes the follow() node of a given node and its parent. There is a side effect when calling this function. If this function computed an edge that exists a FINALLY, it'll attempt to connect the fromNode to the outer FINALLY according to the finallyMap.  @param fromNode The original source node since {@code node} is changed during recursion. @param node The node that follow() should compute. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "ControlFlowAnalysis.connectToPossibleExceptionHandler",
    "class_name": "com.google.javascript.jscomp.ControlFlowAnalysis",
    "signature": "com.google.javascript.jscomp.ControlFlowAnalysis.connectToPossibleExceptionHandler(Node,Node)",
    "snippet": "  private void connectToPossibleExceptionHandler(Node cfgNode, Node target) {\n    if (mayThrowException(target) && !exceptionHandler.isEmpty()) {\n      Node lastJump = cfgNode;\n      for (Node handler : exceptionHandler) {\n        if (NodeUtil.isFunction(handler)) {\n          return;\n        }\n        Preconditions.checkState(handler.getType() == Token.TRY);\n        Node catchBlock = NodeUtil.getCatchBlock(handler);\n\n        if (!NodeUtil.hasCatchHandler(catchBlock)) { // No catch but a FINALLY.\n          if (lastJump == cfgNode) {\n            createEdge(cfgNode, Branch.ON_EX, handler.getLastChild());\n          } else {\n            finallyMap.put(lastJump, handler.getLastChild());\n          }\n        } else { // Has a catch.\n          if (lastJump == cfgNode) {\n            createEdge(cfgNode, Branch.ON_EX, catchBlock);\n            return;\n          } else {\n            finallyMap.put(lastJump, catchBlock);\n          }\n        }\n        lastJump = handler;\n      }\n    }\n  }",
    "comment": " Connects cfgNode to the proper CATCH block if target subtree might throw an exception. If there are FINALLY blocks reached before a CATCH, it will make the corresponding entry in finallyMap. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "ControlFlowAnalysis.createEdge",
    "class_name": "com.google.javascript.jscomp.ControlFlowAnalysis",
    "signature": "com.google.javascript.jscomp.ControlFlowAnalysis.createEdge(Node,Branch,Node)",
    "snippet": "  private void createEdge(Node fromNode, ControlFlowGraph.Branch branch,\n      Node toNode) {\n    cfg.createNode(fromNode);\n    cfg.createNode(toNode);\n    cfg.connectIfNotFound(fromNode, branch, toNode);\n  }",
    "comment": " Connects the two nodes in the control flow graph.  @param fromNode Source. @param toNode Destination. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "ControlFlowAnalysis.getCfg",
    "class_name": "com.google.javascript.jscomp.ControlFlowAnalysis",
    "signature": "com.google.javascript.jscomp.ControlFlowAnalysis.getCfg()",
    "snippet": "  ControlFlowGraph<Node> getCfg() {\n    return cfg;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "ControlFlowAnalysis.handleFor",
    "class_name": "com.google.javascript.jscomp.ControlFlowAnalysis",
    "signature": "com.google.javascript.jscomp.ControlFlowAnalysis.handleFor(Node)",
    "snippet": "  private void handleFor(Node forNode) {\n    if (forNode.getChildCount() == 4) {\n      // We have for (init; cond; iter) { body }\n      Node init = forNode.getFirstChild();\n      Node cond = init.getNext();\n      Node iter = cond.getNext();\n      Node body = iter.getNext();\n      // After initialization, we transfer to the FOR which is in charge of\n      // checking the condition (for the first time).\n      createEdge(init, Branch.UNCOND, forNode);\n      // The edge that transfer control to the beginning of the loop body.\n      createEdge(forNode, Branch.ON_TRUE, computeFallThrough(body));\n      // The edge to end of the loop.\n      createEdge(forNode, Branch.ON_FALSE,\n          computeFollowNode(forNode, this));\n      // The end of the body will have a unconditional branch to our iter\n      // (handled by calling computeFollowNode of the last instruction of the\n      // body. Our iter will jump to the forNode again to another condition\n      // check.\n      createEdge(iter, Branch.UNCOND, forNode);\n      connectToPossibleExceptionHandler(init, init);\n      connectToPossibleExceptionHandler(forNode, cond);\n      connectToPossibleExceptionHandler(iter, iter);\n    } else {\n      // We have for (item in collection) { body }\n      Node item = forNode.getFirstChild();\n      Node collection = item.getNext();\n      Node body = collection.getNext();\n      // The edge that transfer control to the beginning of the loop body.\n      createEdge(forNode, Branch.ON_TRUE, computeFallThrough(body));\n      // The edge to end of the loop.\n      createEdge(forNode, Branch.ON_FALSE,\n          computeFollowNode(forNode, this));\n      connectToPossibleExceptionHandler(forNode, collection);\n    }\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "ControlFlowAnalysis.handleFunction",
    "class_name": "com.google.javascript.jscomp.ControlFlowAnalysis",
    "signature": "com.google.javascript.jscomp.ControlFlowAnalysis.handleFunction(Node)",
    "snippet": "  private void handleFunction(Node node) {\n    // A block transfer control to its first child if it is not empty.\n    Preconditions.checkState(node.getChildCount() >= 3);\n    createEdge(node, Branch.UNCOND,\n        computeFallThrough(node.getFirstChild().getNext().getNext()));\n    Preconditions.checkState(exceptionHandler.peek() == node);\n    exceptionHandler.pop();\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "ControlFlowAnalysis.handleStmt",
    "class_name": "com.google.javascript.jscomp.ControlFlowAnalysis",
    "signature": "com.google.javascript.jscomp.ControlFlowAnalysis.handleStmt(Node)",
    "snippet": "  private void handleStmt(Node node) {\n    // Simply transfer to the next line.\n    createEdge(node, Branch.UNCOND, computeFollowNode(node, this));\n    connectToPossibleExceptionHandler(node, node);\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "ControlFlowAnalysis.handleStmtList",
    "class_name": "com.google.javascript.jscomp.ControlFlowAnalysis",
    "signature": "com.google.javascript.jscomp.ControlFlowAnalysis.handleStmtList(Node)",
    "snippet": "  private void handleStmtList(Node node) {\n    Node parent = node.getParent();\n    // Special case, don't add a block of empty CATCH block to the graph.\n    if (node.getType() == Token.BLOCK && parent != null &&\n        parent.getType() == Token.TRY &&\n        NodeUtil.getCatchBlock(parent) == node &&\n        !NodeUtil.hasCatchHandler(node)) {\n      return;\n    }\n\n    // A block transfer control to its first child if it is not empty.\n    Node child = node.getFirstChild();\n\n    // Function declarations are skipped since control doesn't go into that\n    // function (unless it is called)\n    while (child != null && child.getType() == Token.FUNCTION) {\n      child = child.getNext();\n    }\n\n    if (child != null) {\n      createEdge(node, Branch.UNCOND, computeFallThrough(child));\n    } else {\n      createEdge(node, Branch.UNCOND, computeFollowNode(node, this));\n    }\n\n    // Synthetic blocks\n    if (parent != null) {\n      switch (parent.getType()) {\n        case Token.DEFAULT:\n        case Token.CASE:\n        case Token.TRY:\n          break;\n        default:\n          if (node.getType() == Token.BLOCK && node.isSyntheticBlock()) {\n            createEdge(node, Branch.SYN_BLOCK, computeFollowNode(node, this));\n          }\n          break;\n      }\n    }\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "ControlFlowAnalysis.mayThrowException",
    "class_name": "com.google.javascript.jscomp.ControlFlowAnalysis",
    "signature": "com.google.javascript.jscomp.ControlFlowAnalysis.mayThrowException(Node)",
    "snippet": "  public static boolean mayThrowException(Node n) {\n    switch (n.getType()) {\n      case Token.CALL:\n      case Token.GETPROP:\n      case Token.GETELEM:\n      case Token.THROW:\n      case Token.NEW:\n      case Token.ASSIGN:\n      case Token.INC:\n      case Token.DEC:\n      case Token.INSTANCEOF:\n        return true;\n      case Token.FUNCTION:\n        return false;\n    }\n    for (Node c = n.getFirstChild(); c != null; c = c.getNext()) {\n      if (!ControlFlowGraph.isEnteringNewCfgNode(c) && mayThrowException(c)) {\n        return true;\n      }\n    }\n    return false;\n  }",
    "comment": " Determines if the subtree might throw an exception. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "ControlFlowAnalysis.prioritizeFromEntryNode",
    "class_name": "com.google.javascript.jscomp.ControlFlowAnalysis",
    "signature": "com.google.javascript.jscomp.ControlFlowAnalysis.prioritizeFromEntryNode(DiGraphNode)",
    "snippet": "  private void prioritizeFromEntryNode(DiGraphNode<Node, Branch> entry) {\n    PriorityQueue<DiGraphNode<Node, Branch>> worklist =\n        new PriorityQueue<DiGraphNode<Node, Branch>>(10, priorityComparator);\n    worklist.add(entry);\n\n    while (!worklist.isEmpty()) {\n      DiGraphNode<Node, Branch> current = worklist.remove();\n      if (nodePriorities.containsKey(current)) {\n        continue;\n      }\n\n      nodePriorities.put(current, ++priorityCounter);\n\n      List<DiGraphNode<Node, Branch>> successors =\n          cfg.getDirectedSuccNodes(current);\n      for (DiGraphNode<Node, Branch> candidate : successors) {\n        worklist.add(candidate);\n      }\n    }\n  }",
    "comment": " Given an entry node, find all the nodes reachable from that node and prioritize them. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "ControlFlowAnalysis.process",
    "class_name": "com.google.javascript.jscomp.ControlFlowAnalysis",
    "signature": "com.google.javascript.jscomp.ControlFlowAnalysis.process(Node,Node)",
    "snippet": "  @Override\n  public void process(Node externs, Node root) {\n    this.root = root;\n    astPositionCounter = 0;\n    astPosition = Maps.newHashMap();\n    nodePriorities = Maps.newHashMap();\n    cfg = new AstControlFlowGraph(computeFallThrough(root), nodePriorities,\n                                  edgeAnnotations);\n    NodeTraversal.traverse(compiler, root, this);\n    astPosition.put(null, ++astPositionCounter); // the implicit return is last.\n\n    // Now, generate the priority of nodes by doing a depth-first\n    // search on the CFG.\n    priorityCounter = 0;\n    DiGraphNode<Node, Branch> entry = cfg.getEntry();\n    prioritizeFromEntryNode(entry);\n\n    if (shouldTraverseFunctions) {\n      // If we're traversing inner functions, we need to rank the\n      // priority of them too.\n      for (DiGraphNode<Node, Branch> candidate : cfg.getDirectedGraphNodes()) {\n        Node value = candidate.getValue();\n        if (value != null && value.getType() == Token.FUNCTION) {\n          Preconditions.checkState(\n              !nodePriorities.containsKey(candidate) || candidate == entry);\n          prioritizeFromEntryNode(candidate);\n        }\n      }\n    }\n\n    // At this point, all reachable nodes have been given a priority, but\n    // unreachable nodes have not been given a priority. Put them last.\n    // Presumably, it doesn't really matter what priority they get, since\n    // this shouldn't happen in real code.\n    for (DiGraphNode<Node, Branch> candidate : cfg.getDirectedGraphNodes()) {\n      if (!nodePriorities.containsKey(candidate)) {\n        nodePriorities.put(candidate, ++priorityCounter);\n      }\n    }\n\n    // Again, the implicit return node is always last.\n    nodePriorities.put(cfg.getImplicitReturn(), ++priorityCounter);\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "ControlFlowAnalysis.shouldTraverse",
    "class_name": "com.google.javascript.jscomp.ControlFlowAnalysis",
    "signature": "com.google.javascript.jscomp.ControlFlowAnalysis.shouldTraverse(NodeTraversal,Node,Node)",
    "snippet": "  @Override\n  public boolean shouldTraverse(\n      NodeTraversal nodeTraversal, Node n, Node parent) {\n    astPosition.put(n, astPositionCounter++);\n\n    switch (n.getType()) {\n      case Token.FUNCTION:\n        if (shouldTraverseFunctions || n == cfg.getEntry().getValue()) {\n          exceptionHandler.push(n);\n          return true;\n        }\n        return false;\n      case Token.TRY:\n        exceptionHandler.push(n);\n        return true;\n    }\n\n    /*\n     * We are going to stop the traversal depending on what the node's parent\n     * is.\n     *\n     * We are only interested in adding edges between nodes that change control\n     * flow. The most obvious ones are loops and IF-ELSE's. A statement\n     * transfers control to its next sibling.\n     *\n     * In case of an expression tree, there is no control flow within the tree\n     * even when there are short circuited operators and conditionals. When we\n     * are doing data flow analysis, we will simply synthesize lattices up the\n     * expression tree by finding the meet at each expression node.\n     *\n     * For example: within a Token.SWITCH, the expression in question does not\n     * change the control flow and need not to be considered.\n     */\n    if (parent != null) {\n      switch (parent.getType()) {\n        case Token.FOR:\n          // Only traverse the body of the for loop.\n          return n == parent.getLastChild();\n\n        // Skip the conditions.\n        case Token.IF:\n        case Token.WHILE:\n        case Token.WITH:\n          return n != parent.getFirstChild();\n        case Token.DO:\n          return n != parent.getFirstChild().getNext();\n        // Only traverse the body of the cases\n        case Token.SWITCH:\n        case Token.CASE:\n        case Token.CATCH:\n        case Token.LABEL:\n          return n != parent.getFirstChild();\n        case Token.FUNCTION:\n          return n == parent.getFirstChild().getNext().getNext();\n        case Token.CONTINUE:\n        case Token.BREAK:\n        case Token.EXPR_RESULT:\n        case Token.VAR:\n        case Token.RETURN:\n        case Token.THROW:\n          return false;\n        case Token.TRY:\n          /* Just before we are about to visit the second child of the TRY node,\n           * we know that we will be visiting either the CATCH or the FINALLY.\n           * In other words, we know that the post order traversal of the TRY\n           * block has been finished, no more exceptions can be caught by the\n           * handler at this TRY block and should be taken out of the stack.\n           */\n          if (n == parent.getFirstChild().getNext()) {\n            Preconditions.checkState(exceptionHandler.peek() == parent);\n            exceptionHandler.pop();\n          }\n      }\n    }\n    return true;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "ControlFlowAnalysis.visit",
    "class_name": "com.google.javascript.jscomp.ControlFlowAnalysis",
    "signature": "com.google.javascript.jscomp.ControlFlowAnalysis.visit(NodeTraversal,Node,Node)",
    "snippet": "  @Override\n  public void visit(NodeTraversal t, Node n, Node parent) {\n    switch (n.getType()) {\n      case Token.IF:\n        handleIf(n);\n        return;\n      case Token.WHILE:\n        handleWhile(n);\n        return;\n      case Token.DO:\n        handleDo(n);\n        return;\n      case Token.FOR:\n        handleFor(n);\n        return;\n      case Token.SWITCH:\n        handleSwitch(n);\n        return;\n      case Token.CASE:\n        handleCase(n);\n        return;\n      case Token.DEFAULT:\n        handleDefault(n);\n        return;\n      case Token.BLOCK:\n      case Token.SCRIPT:\n        handleStmtList(n);\n        return;\n      case Token.FUNCTION:\n        handleFunction(n);\n        return;\n      case Token.EXPR_RESULT:\n        handleExpr(n);\n        return;\n      case Token.THROW:\n        handleThrow(n);\n        return;\n      case Token.TRY:\n        handleTry(n);\n        return;\n      case Token.CATCH:\n        handleCatch(n);\n        return;\n      case Token.BREAK:\n        handleBreak(n);\n        return;\n      case Token.CONTINUE:\n        handleContinue(n);\n        return;\n      case Token.RETURN:\n        handleReturn(n);\n        return;\n      case Token.WITH:\n        handleWith(n);\n        return;\n      case Token.LABEL:\n        return;\n      default:\n        handleStmt(n);\n        return;\n    }\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "AstControlFlowGraph.getOptionalNodeComparator",
    "class_name": "com.google.javascript.jscomp.ControlFlowAnalysis$AstControlFlowGraph",
    "signature": "com.google.javascript.jscomp.ControlFlowAnalysis$AstControlFlowGraph.getOptionalNodeComparator(boolean)",
    "snippet": "    @Override\n    /**\n     * Returns a node comparator based on the pre-order traversal of the AST.\n     * @param isForward x 'before' y in the pre-order traversal implies\n     * x 'less than' y (if true) and x 'greater than' y (if false).\n     */\n    public Comparator<DiGraphNode<Node, Branch>> getOptionalNodeComparator(\n        boolean isForward) {\n      if (isForward) {\n        return new Comparator<DiGraphNode<Node, Branch>>() {\n          @Override\n          public int compare(\n              DiGraphNode<Node, Branch> n1, DiGraphNode<Node, Branch> n2) {\n            return getPosition(n1) - getPosition(n2);\n          }\n        };\n      } else {\n        return new Comparator<DiGraphNode<Node, Branch>>() {\n          @Override\n          public int compare(\n              DiGraphNode<Node, Branch> n1, DiGraphNode<Node, Branch> n2) {\n            return getPosition(n2) - getPosition(n1);\n          }\n        };\n      }\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "AstControlFlowGraph.getPosition",
    "class_name": "com.google.javascript.jscomp.ControlFlowAnalysis$AstControlFlowGraph",
    "signature": "com.google.javascript.jscomp.ControlFlowAnalysis$AstControlFlowGraph.getPosition(DiGraphNode)",
    "snippet": "    private int getPosition(DiGraphNode<Node, Branch> n) {\n      Integer priority = priorities.get(n);\n      Preconditions.checkNotNull(priority);\n      return priority;\n    }",
    "comment": " Gets the pre-order traversal position of the given node. @return An arbitrary counter used for comparing positions. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "ControlFlowGraph.ControlFlowGraph",
    "class_name": "com.google.javascript.jscomp.ControlFlowGraph",
    "signature": "com.google.javascript.jscomp.ControlFlowGraph.ControlFlowGraph(N,boolean,boolean)",
    "snippet": "  ControlFlowGraph(\n      N entry, boolean nodeAnnotations, boolean edgeAnnotations) {\n    super(nodeAnnotations, edgeAnnotations);\n    implicitReturn = createDirectedGraphNode(null);\n    this.entry = createDirectedGraphNode(entry);\n  }",
    "comment": " Constructor. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "ControlFlowGraph.getEntry",
    "class_name": "com.google.javascript.jscomp.ControlFlowGraph",
    "signature": "com.google.javascript.jscomp.ControlFlowGraph.getEntry()",
    "snippet": "  public DiGraphNode<N, ControlFlowGraph.Branch> getEntry() {\n    return entry;\n  }",
    "comment": " Gets the entry point of the control flow graph. In general, this should be the beginning of the global script or beginning of a function.  @return The entry point. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "ControlFlowGraph.getImplicitReturn",
    "class_name": "com.google.javascript.jscomp.ControlFlowGraph",
    "signature": "com.google.javascript.jscomp.ControlFlowGraph.getImplicitReturn()",
    "snippet": "  public DiGraphNode<N, ControlFlowGraph.Branch> getImplicitReturn() {\n    return implicitReturn;\n  }",
    "comment": " Gets the implicit return node.  @return Return node. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "ControlFlowGraph.isEnteringNewCfgNode",
    "class_name": "com.google.javascript.jscomp.ControlFlowGraph",
    "signature": "com.google.javascript.jscomp.ControlFlowGraph.isEnteringNewCfgNode(Node)",
    "snippet": "  public static boolean isEnteringNewCfgNode(Node n) {\n    Node parent = n.getParent();\n    switch (parent.getType()) {\n      case Token.BLOCK:\n      case Token.SCRIPT:\n      case Token.TRY:\n      case Token.FINALLY:\n        return true;\n      case Token.FUNCTION:\n        // A function node represents the start of a function where the name\n        // is bleed into the local scope and parameters has been assigned\n        // to the formal argument names. The node includes the name of the\n        // function and the LP list since we assume the whole set up process\n        // is atomic without change in control flow. The next change of\n        // control is going into the function's body represent by the second\n        // child.\n        return n != parent.getFirstChild().getNext();\n      case Token.WHILE:\n      case Token.DO:\n      case Token.IF:\n        // Theses control structure is represented by its node that holds the\n        // condition. Each of them is a branch node based on its condition.\n        return NodeUtil.getConditionExpression(parent) != n;\n\n      case Token.FOR:\n        // The FOR(;;) node differs from other control structure in that\n        // it has a initialization and a increment statement. Those\n        // two statements have its corresponding CFG nodes to represent them.\n        // The FOR node represents the condition check for each iteration.\n        // That way the following:\n        // for(var x = 0; x < 10; x++) { } has a graph that is isomorphic to\n        // var x = 0; while(x<10) {  x++; }\n        if (NodeUtil.isForIn(parent)) {\n          return n == parent.getLastChild();\n        } else {\n          return NodeUtil.getConditionExpression(parent) != n;\n        }\n      case Token.SWITCH:\n      case Token.CASE:\n      case Token.CATCH:\n      case Token.WITH:\n        return n != parent.getFirstChild();\n      default:\n        return false;\n    }\n  }",
    "comment": " @return True if n should be represented by a new CFG node in the control flow graph. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "DataFlowAnalysis.DataFlowAnalysis",
    "class_name": "com.google.javascript.jscomp.DataFlowAnalysis",
    "signature": "com.google.javascript.jscomp.DataFlowAnalysis.DataFlowAnalysis(ControlFlowGraph,JoinOp)",
    "snippet": "  DataFlowAnalysis(ControlFlowGraph<N> targetCfg, JoinOp<L> joinOp) {\n    this.cfg = targetCfg;\n    this.joinOp = joinOp;\n    Comparator<DiGraphNode<N, Branch>> nodeComparator =\n      cfg.getOptionalNodeComparator(isForward());\n    if (nodeComparator != null) {\n      this.orderedWorkSet = Sets.newTreeSet(nodeComparator);\n    } else {\n      this.orderedWorkSet = Sets.newLinkedHashSet();\n    }\n  }",
    "comment": " Constructs a data flow analysis.  <p>Typical usage <pre> DataFlowAnalysis dfa = ... dfa.analyze(); </pre>  {@link #analyze()} annotates the result to the control flow graph by means of {@link DiGraphNode#setAnnotation} without any modification of the graph itself. Additional calls to {@link #analyze()} recomputes the analysis which can be useful if the control flow graph has been modified.  @param targetCfg The control flow graph object that this object performs on. Modification of the graph requires a separate call to {@link #analyze()}.  @see #analyze() ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "DataFlowAnalysis.analyze",
    "class_name": "com.google.javascript.jscomp.DataFlowAnalysis",
    "signature": "com.google.javascript.jscomp.DataFlowAnalysis.analyze()",
    "snippet": "  final void analyze() {\n    analyze(MAX_STEPS);\n  }",
    "comment": " Finds a fixed-point solution using at most {@link #MAX_STEPS} iterations.  @see #analyze(int) ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "DataFlowAnalysis.analyze",
    "class_name": "com.google.javascript.jscomp.DataFlowAnalysis",
    "signature": "com.google.javascript.jscomp.DataFlowAnalysis.analyze(int)",
    "snippet": "  final void analyze(int maxSteps) {\n    initialize();\n    int step = 0;\n    while (!orderedWorkSet.isEmpty()) {\n      if (step > maxSteps) {\n        throw new MaxIterationsExceededException(\n          \"Analysis did not terminate after \" + maxSteps + \" iterations\");\n      }\n      DiGraphNode<N, Branch> curNode = orderedWorkSet.iterator().next();\n      orderedWorkSet.remove(curNode);\n      joinInputs(curNode);\n      if (flow(curNode)) {\n        // If there is a change in the current node, we want to grab the list\n        // of nodes that this node affects.\n        List<DiGraphNode<N, Branch>> nextNodes = isForward() ?\n            cfg.getDirectedSuccNodes(curNode) :\n            cfg.getDirectedPredNodes(curNode);\n        for (DiGraphNode<N, Branch> nextNode : nextNodes) {\n          if (nextNode != cfg.getImplicitReturn()) {\n            orderedWorkSet.add(nextNode);\n          }\n        }\n      }\n      step++;\n    }\n    if (isForward()) {\n      joinInputs(getCfg().getImplicitReturn());\n    }\n  }",
    "comment": " Finds a fixed-point solution. The function has the side effect of replacing the existing node annotations with the computed solutions using {@link com.google.javascript.jscomp.graph.GraphNode#setAnnotation(Annotation)}.  <p>Initially, each node's input and output flow state contains the value given by {@link #createInitialEstimateLattice()} (with the exception of the entry node of the graph which takes on the {@link #createEntryLattice()} value. Each node will use the output state of its predecessor and compute a output state according to the instruction. At that time, any nodes that depends on the node's newly modified output value will need to recompute their output state again. Each step will perform a computation at one node until no extra computation will modify any existing output state anymore.  @param maxSteps Max number of iterations before the method stops and throw a {@link MaxIterationsExceededException}. This will prevent the analysis from going into a infinite loop. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "DataFlowAnalysis.computeEscaped",
    "class_name": "com.google.javascript.jscomp.DataFlowAnalysis",
    "signature": "com.google.javascript.jscomp.DataFlowAnalysis.computeEscaped(Scope,Set,AbstractCompiler)",
    "snippet": "  static void computeEscaped(final Scope jsScope, final Set<Var> escaped,\n      AbstractCompiler compiler) {\n    // TODO(user): Very good place to store this information somewhere.\n    AbstractPostOrderCallback finder = new AbstractPostOrderCallback() {\n      @Override\n      public void visit(NodeTraversal t, Node n, Node parent) {\n        if (jsScope == t.getScope() || !NodeUtil.isName(n)\n            || NodeUtil.isFunction(parent)) {\n          return;\n        }\n        String name = n.getString();\n        Var var = t.getScope().getVar(name);\n        if (var != null && var.scope == jsScope) {\n          escaped.add(jsScope.getVar(name));\n        }\n      }\n    };\n\n    NodeTraversal t = new NodeTraversal(compiler, finder);\n    t.traverseAtScope(jsScope);\n\n    // 1: Remove the exception name in CATCH which technically isn't local to\n    //    begin with.\n    for (Iterator<Var> i = jsScope.getVars(); i.hasNext();) {\n      Var var = i.next();\n      if (var.getParentNode().getType() == Token.CATCH ||\n          compiler.getCodingConvention().isExported(var.getName())) {\n        escaped.add(var);\n      }\n    }\n  }",
    "comment": " Compute set of escaped variables. When a variable is escaped in a dataflow analysis, it can be reference outside of the code that we are analyzing. A variable is escaped if any of the following is true:  <p><ol> <li>It is defined as the exception name in CATCH clause so it became a variable local not to our definition of scope.</li> <li>Exported variables as they can be needed after the script terminates. </li> <li>Names of named functions because in javascript, <i>function foo(){}</i> does not kill <i>foo</i> in the dataflow.</li> ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "DataFlowAnalysis.flow",
    "class_name": "com.google.javascript.jscomp.DataFlowAnalysis",
    "signature": "com.google.javascript.jscomp.DataFlowAnalysis.flow(DiGraphNode)",
    "snippet": "  protected boolean flow(DiGraphNode<N, Branch> node) {\n    FlowState<L> state = node.getAnnotation();\n    if (isForward()) {\n      L outBefore = state.out;\n      state.out = flowThrough(node.getValue(), state.in);\n      return !outBefore.equals(state.out);\n    } else {\n      L inBefore = state.in;\n      state.in = flowThrough(node.getValue(), state.out);\n      return !inBefore.equals(state.in);\n    }\n  }",
    "comment": " Performs a single flow through a node.  @return {@code true} if the flow state differs from the previous state. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "DataFlowAnalysis.getCfg",
    "class_name": "com.google.javascript.jscomp.DataFlowAnalysis",
    "signature": "com.google.javascript.jscomp.DataFlowAnalysis.getCfg()",
    "snippet": "  final ControlFlowGraph<N> getCfg() {\n    return cfg;\n  }",
    "comment": " Returns the control flow graph that this analysis was performed on. Modifications can be done on this graph, however, the only time that the annotations are correct is after {@link #analyze()} is called and before the graph has been modified. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "DataFlowAnalysis.initialize",
    "class_name": "com.google.javascript.jscomp.DataFlowAnalysis",
    "signature": "com.google.javascript.jscomp.DataFlowAnalysis.initialize()",
    "snippet": "  protected void initialize() {\n    // TODO(user): Calling clear doesn't deallocate the memory in a\n    // LinkedHashSet. Consider creating a new work set if we plan to repeatedly\n    // call analyze.\n    orderedWorkSet.clear();\n    for (DiGraphNode<N, Branch> node : cfg.getDirectedGraphNodes()) {\n      node.setAnnotation(new FlowState<L>(createInitialEstimateLattice(),\n          createInitialEstimateLattice()));\n      if (node != cfg.getImplicitReturn()) {\n        orderedWorkSet.add(node);\n      }\n    }\n  }",
    "comment": " Initializes the work list and the control flow graph. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "DataFlowAnalysis.joinInputs",
    "class_name": "com.google.javascript.jscomp.DataFlowAnalysis",
    "signature": "com.google.javascript.jscomp.DataFlowAnalysis.joinInputs(DiGraphNode)",
    "snippet": "  protected void joinInputs(DiGraphNode<N, Branch> node) {\n    FlowState<L> state = node.getAnnotation();\n    if (isForward()) {\n      if (cfg.getEntry() == node) {\n        state.setIn(createEntryLattice());\n      } else {\n        List<DiGraphNode<N, Branch>> inNodes = cfg.getDirectedPredNodes(node);\n        if (inNodes.size() == 1) {\n          FlowState<L> inNodeState = inNodes.get(0).getAnnotation();\n          state.setIn(inNodeState.getOut());\n        } else if (inNodes.size() > 1) {\n          List<L> values = new ArrayList<L>(inNodes.size());\n          for (DiGraphNode<N, Branch> currentNode : inNodes) {\n            FlowState<L> currentNodeState = currentNode.getAnnotation();\n            values.add(currentNodeState.getOut());\n          }\n          state.setIn(joinOp.apply(values));\n        }\n      }\n    } else {\n      List<DiGraphNode<N, Branch>> inNodes = cfg.getDirectedSuccNodes(node);\n      if (inNodes.size() == 1) {\n        DiGraphNode<N, Branch> inNode = inNodes.get(0);\n        if (inNode == cfg.getImplicitReturn()) {\n          state.setOut(createEntryLattice());\n        } else {\n          FlowState<L> inNodeState = inNode.getAnnotation();\n          state.setOut(inNodeState.getIn());\n        }\n      } else if (inNodes.size() > 1) {\n        List<L> values = new ArrayList<L>(inNodes.size());\n        for (DiGraphNode<N, Branch> currentNode : inNodes) {\n          FlowState<L> currentNodeState = currentNode.getAnnotation();\n          values.add(currentNodeState.getIn());\n        }\n        state.setOut(joinOp.apply(values));\n      }\n    }\n  }",
    "comment": " Computes the new flow state at a given node's entry by merging the output (input) lattice of the node's predecessor (successor).  @param node Node to compute new join. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "FlowState.getIn",
    "class_name": "com.google.javascript.jscomp.DataFlowAnalysis$FlowState",
    "signature": "com.google.javascript.jscomp.DataFlowAnalysis$FlowState.getIn()",
    "snippet": "    L getIn() {\n      return in;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "FlowState.setOut",
    "class_name": "com.google.javascript.jscomp.DataFlowAnalysis$FlowState",
    "signature": "com.google.javascript.jscomp.DataFlowAnalysis$FlowState.setOut(L)",
    "snippet": "    void setOut(L out) {\n      Preconditions.checkNotNull(out);\n      this.out = out;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "DefaultCodingConvention.isExported",
    "class_name": "com.google.javascript.jscomp.DefaultCodingConvention",
    "signature": "com.google.javascript.jscomp.DefaultCodingConvention.isExported(String)",
    "snippet": "  @Override\n  public boolean isExported(String name) {\n    return isExported(name, false) || isExported(name, true);\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "DefaultCodingConvention.isExported",
    "class_name": "com.google.javascript.jscomp.DefaultCodingConvention",
    "signature": "com.google.javascript.jscomp.DefaultCodingConvention.isExported(String,boolean)",
    "snippet": "  @Override\n  public boolean isExported(String name, boolean local) {\n    return local && name.startsWith(\"$super\");\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "DiagnosticGroup.DiagnosticGroup",
    "class_name": "com.google.javascript.jscomp.DiagnosticGroup",
    "signature": "com.google.javascript.jscomp.DiagnosticGroup.DiagnosticGroup(DiagnosticType[])",
    "snippet": "  public DiagnosticGroup(DiagnosticType ...types) {\n    this(null, types);\n  }",
    "comment": " Create a group that matches all errors of the given types. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "DiagnosticGroup.DiagnosticGroup",
    "class_name": "com.google.javascript.jscomp.DiagnosticGroup",
    "signature": "com.google.javascript.jscomp.DiagnosticGroup.DiagnosticGroup(String,DiagnosticGroup[])",
    "snippet": "  public DiagnosticGroup(String name, DiagnosticGroup ...groups) {\n    Set<DiagnosticType> set = Sets.newHashSet();\n\n    for (DiagnosticGroup group : groups) {\n      set.addAll(group.types);\n    }\n\n    this.name = name;\n    this.types = ImmutableSet.copyOf(set);\n  }",
    "comment": " Create a composite group. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "DiagnosticGroup.DiagnosticGroup",
    "class_name": "com.google.javascript.jscomp.DiagnosticGroup",
    "signature": "com.google.javascript.jscomp.DiagnosticGroup.DiagnosticGroup(String,DiagnosticType[])",
    "snippet": "  DiagnosticGroup(String name, DiagnosticType ...types) {\n    this.name = name;\n    this.types = ImmutableSet.copyOf(Arrays.asList(types));\n  }",
    "comment": " Create a group that matches all errors of the given types. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "DiagnosticGroup.forType",
    "class_name": "com.google.javascript.jscomp.DiagnosticGroup",
    "signature": "com.google.javascript.jscomp.DiagnosticGroup.forType(DiagnosticType)",
    "snippet": "  static DiagnosticGroup forType(DiagnosticType type) {\n    if (!singletons.containsKey(type)) {\n      singletons.put(type, new DiagnosticGroup(type));\n    }\n    return singletons.get(type);\n  }",
    "comment": "Create a diagnostic group that matches only the given type. */",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "DiagnosticGroup.getTypes",
    "class_name": "com.google.javascript.jscomp.DiagnosticGroup",
    "signature": "com.google.javascript.jscomp.DiagnosticGroup.getTypes()",
    "snippet": "  Collection<DiagnosticType> getTypes() {\n    return types;\n  }",
    "comment": " Returns an iterator over all the types in this group. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "DiagnosticGroup.isSubGroup",
    "class_name": "com.google.javascript.jscomp.DiagnosticGroup",
    "signature": "com.google.javascript.jscomp.DiagnosticGroup.isSubGroup(DiagnosticGroup)",
    "snippet": "  boolean isSubGroup(DiagnosticGroup group) {\n    for (DiagnosticType type : group.types) {\n      if (!matches(type)) {\n        return false;\n      }\n    }\n    return true;\n  }",
    "comment": " Returns whether all of the types in the given group are in this group. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "DiagnosticGroup.matches",
    "class_name": "com.google.javascript.jscomp.DiagnosticGroup",
    "signature": "com.google.javascript.jscomp.DiagnosticGroup.matches(DiagnosticType)",
    "snippet": "  public boolean matches(DiagnosticType type) {\n    return types.contains(type);\n  }",
    "comment": " Returns whether the given type matches a type in this group. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "DiagnosticGroupWarningsGuard.DiagnosticGroupWarningsGuard",
    "class_name": "com.google.javascript.jscomp.DiagnosticGroupWarningsGuard",
    "signature": "com.google.javascript.jscomp.DiagnosticGroupWarningsGuard.DiagnosticGroupWarningsGuard(DiagnosticGroup,CheckLevel)",
    "snippet": "  public DiagnosticGroupWarningsGuard(\n      DiagnosticGroup group, CheckLevel level) {\n    this.group = group;\n    this.level = level;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "DiagnosticGroupWarningsGuard.disables",
    "class_name": "com.google.javascript.jscomp.DiagnosticGroupWarningsGuard",
    "signature": "com.google.javascript.jscomp.DiagnosticGroupWarningsGuard.disables(DiagnosticGroup)",
    "snippet": "  @Override\n  public boolean disables(DiagnosticGroup otherGroup) {\n    return !level.isOn() && group.isSubGroup(otherGroup);\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "DiagnosticGroupWarningsGuard.enables",
    "class_name": "com.google.javascript.jscomp.DiagnosticGroupWarningsGuard",
    "signature": "com.google.javascript.jscomp.DiagnosticGroupWarningsGuard.enables(DiagnosticGroup)",
    "snippet": "  @Override\n  public boolean enables(DiagnosticGroup otherGroup) {\n    if (level.isOn()) {\n      for (DiagnosticType type : otherGroup.getTypes()) {\n        if (group.matches(type)) {\n          return true;\n        }\n      }\n    }\n\n    return false;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "DiagnosticGroups.DiagnosticGroups",
    "class_name": "com.google.javascript.jscomp.DiagnosticGroups",
    "signature": "com.google.javascript.jscomp.DiagnosticGroups.DiagnosticGroups()",
    "snippet": "  public DiagnosticGroups() {}",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "DiagnosticGroups.getRegisteredGroups",
    "class_name": "com.google.javascript.jscomp.DiagnosticGroups",
    "signature": "com.google.javascript.jscomp.DiagnosticGroups.getRegisteredGroups()",
    "snippet": "  protected Map<String, DiagnosticGroup> getRegisteredGroups() {\n    return ImmutableMap.copyOf(groupsByName);\n  }",
    "comment": "Get the registered diagnostic groups, indexed by name. */",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "DiagnosticGroups.registerGroup",
    "class_name": "com.google.javascript.jscomp.DiagnosticGroups",
    "signature": "com.google.javascript.jscomp.DiagnosticGroups.registerGroup(String,DiagnosticGroup[])",
    "snippet": "  static DiagnosticGroup registerGroup(String name,\n      DiagnosticGroup ... groups) {\n    DiagnosticGroup group = new DiagnosticGroup(name, groups);\n    groupsByName.put(name, group);\n    return group;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "DiagnosticGroups.registerGroup",
    "class_name": "com.google.javascript.jscomp.DiagnosticGroups",
    "signature": "com.google.javascript.jscomp.DiagnosticGroups.registerGroup(String,DiagnosticType[])",
    "snippet": "  static DiagnosticGroup registerGroup(String name,\n      DiagnosticType ... types) {\n    DiagnosticGroup group = new DiagnosticGroup(name, types);\n    groupsByName.put(name, group);\n    return group;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "DiagnosticType.disabled",
    "class_name": "com.google.javascript.jscomp.DiagnosticType",
    "signature": "com.google.javascript.jscomp.DiagnosticType.disabled(String,String)",
    "snippet": "  public static DiagnosticType disabled(String name,\n      String descriptionFormat) {\n    return make(name, CheckLevel.OFF, descriptionFormat);\n  }",
    "comment": " Create a DiagnosticType at level CheckLevel.OFF  @param name An identifier @param descriptionFormat A format string @return A new DiagnosticType ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "DiagnosticType.equals",
    "class_name": "com.google.javascript.jscomp.DiagnosticType",
    "signature": "com.google.javascript.jscomp.DiagnosticType.equals(Object)",
    "snippet": "  @Override\n  public boolean equals(Object type) {\n    return type instanceof DiagnosticType &&\n        ((DiagnosticType) type).key.equals(key);\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "DiagnosticType.error",
    "class_name": "com.google.javascript.jscomp.DiagnosticType",
    "signature": "com.google.javascript.jscomp.DiagnosticType.error(String,String)",
    "snippet": "  public static DiagnosticType error(String name, String descriptionFormat) {\n    return make(name, CheckLevel.ERROR, descriptionFormat);\n  }",
    "comment": " Create a DiagnosticType at level CheckLevel.ERROR  @param name An identifier @param descriptionFormat A format string @return A new DiagnosticType ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "DiagnosticType.hashCode",
    "class_name": "com.google.javascript.jscomp.DiagnosticType",
    "signature": "com.google.javascript.jscomp.DiagnosticType.hashCode()",
    "snippet": "  @Override\n  public int hashCode() {\n    return key.hashCode();\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "DiagnosticType.make",
    "class_name": "com.google.javascript.jscomp.DiagnosticType",
    "signature": "com.google.javascript.jscomp.DiagnosticType.make(String,CheckLevel,String)",
    "snippet": "  public static DiagnosticType make(String name, CheckLevel level,\n                                    String descriptionFormat) {\n    return\n        new DiagnosticType(name, level, new MessageFormat(descriptionFormat));\n  }",
    "comment": " Create a DiagnosticType at a given CheckLevel.  @param name An identifier @param level Either CheckLevel.ERROR or CheckLevel.WARNING @param descriptionFormat A format string @return A new DiagnosticType ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "DiagnosticType.warning",
    "class_name": "com.google.javascript.jscomp.DiagnosticType",
    "signature": "com.google.javascript.jscomp.DiagnosticType.warning(String,String)",
    "snippet": "  public static DiagnosticType warning(String name, String descriptionFormat) {\n    return make(name, CheckLevel.WARNING, descriptionFormat);\n  }",
    "comment": " Create a DiagnosticType at level CheckLevel.WARNING  @param name An identifier @param descriptionFormat A format string @return A new DiagnosticType ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "GoogleCodingConvention.isExported",
    "class_name": "com.google.javascript.jscomp.GoogleCodingConvention",
    "signature": "com.google.javascript.jscomp.GoogleCodingConvention.isExported(String,boolean)",
    "snippet": "  @Override\n  public boolean isExported(String name, boolean local) {\n    return super.isExported(name, local) ||\n        (!local && name.startsWith(\"_\"));\n  }",
    "comment": " {@inheritDoc}  <p>In Google code, any global name starting with an underscore is considered exported. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "GoogleCodingConvention.isOptionalParameter",
    "class_name": "com.google.javascript.jscomp.GoogleCodingConvention",
    "signature": "com.google.javascript.jscomp.GoogleCodingConvention.isOptionalParameter(Node)",
    "snippet": "  @Override\n  public boolean isOptionalParameter(Node parameter) {\n    return parameter.getString().startsWith(OPTIONAL_ARG_PREFIX);\n  }",
    "comment": " {@inheritDoc}  <p>In Google code, parameter names beginning with {@code opt_} are treated as optional arguments. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "GoogleCodingConvention.isVarArgsParameter",
    "class_name": "com.google.javascript.jscomp.GoogleCodingConvention",
    "signature": "com.google.javascript.jscomp.GoogleCodingConvention.isVarArgsParameter(Node)",
    "snippet": "  @Override\n  public boolean isVarArgsParameter(Node parameter) {\n    return VAR_ARGS_NAME.equals(parameter.getString());\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "JSSourceFile.fromCode",
    "class_name": "com.google.javascript.jscomp.JSSourceFile",
    "signature": "com.google.javascript.jscomp.JSSourceFile.fromCode(String,String)",
    "snippet": "  public static JSSourceFile fromCode(String fileName, String code) {\n    return new JSSourceFile(SourceFile.fromCode(fileName, code));\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "JSSourceFile.getCode",
    "class_name": "com.google.javascript.jscomp.JSSourceFile",
    "signature": "com.google.javascript.jscomp.JSSourceFile.getCode()",
    "snippet": "  @Override\n  public String getCode() throws IOException {\n    return referenced.getCode();\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "JsAst.JsAst",
    "class_name": "com.google.javascript.jscomp.JsAst",
    "signature": "com.google.javascript.jscomp.JsAst.JsAst(SourceFile)",
    "snippet": "  public JsAst(SourceFile sourceFile) {\n    this.inputId = new InputId(sourceFile.getName());\n    this.sourceFile = sourceFile;\n    this.fileName = sourceFile.getName();\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "JsAst.getAstRoot",
    "class_name": "com.google.javascript.jscomp.JsAst",
    "signature": "com.google.javascript.jscomp.JsAst.getAstRoot(AbstractCompiler)",
    "snippet": "  @Override\n  public Node getAstRoot(AbstractCompiler compiler) {\n    if (root == null) {\n      parse(compiler);\n      root.setInputId(inputId);\n    }\n    return root;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "JsAst.getInputId",
    "class_name": "com.google.javascript.jscomp.JsAst",
    "signature": "com.google.javascript.jscomp.JsAst.getInputId()",
    "snippet": "  @Override\n  public InputId getInputId() {\n    return inputId;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "JsAst.getSourceFile",
    "class_name": "com.google.javascript.jscomp.JsAst",
    "signature": "com.google.javascript.jscomp.JsAst.getSourceFile()",
    "snippet": "  @Override\n  public SourceFile getSourceFile() {\n    return sourceFile;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "JsAst.parse",
    "class_name": "com.google.javascript.jscomp.JsAst",
    "signature": "com.google.javascript.jscomp.JsAst.parse(AbstractCompiler)",
    "snippet": "  private void parse(AbstractCompiler compiler) {\n    try {\n      logger_.fine(\"Parsing: \" + sourceFile.getName());\n      root = ParserRunner.parse(sourceFile, sourceFile.getCode(),\n          compiler.getParserConfig(),\n          compiler.getDefaultErrorReporter(),\n          logger_);\n    } catch (IOException e) {\n      compiler.report(\n          JSError.make(AbstractCompiler.READ_ERROR, sourceFile.getName()));\n    }\n\n    if (root == null || compiler.hasHaltingErrors()) {\n      // There was a parse error or IOException, so use a dummy block.\n      root = new Node(Token.SCRIPT);\n    } else {\n      compiler.prepareAst(root);\n    }\n\n    // Set the source name so that the compiler passes can track\n    // the source file and module.\n    root.setStaticSourceFile(sourceFile);\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "LightweightMessageFormatter.LightweightMessageFormatter",
    "class_name": "com.google.javascript.jscomp.LightweightMessageFormatter",
    "signature": "com.google.javascript.jscomp.LightweightMessageFormatter.LightweightMessageFormatter(SourceExcerptProvider)",
    "snippet": "  public LightweightMessageFormatter(SourceExcerptProvider source) {\n    this(source, LINE);\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "LightweightMessageFormatter.LightweightMessageFormatter",
    "class_name": "com.google.javascript.jscomp.LightweightMessageFormatter",
    "signature": "com.google.javascript.jscomp.LightweightMessageFormatter.LightweightMessageFormatter(SourceExcerptProvider,SourceExcerpt)",
    "snippet": "  public LightweightMessageFormatter(SourceExcerptProvider source,\n      SourceExcerpt excerpt) {\n    super(source);\n    Preconditions.checkNotNull(source);\n    this.excerpt = excerpt;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "LiveVariablesAnalysis.LiveVariablesAnalysis",
    "class_name": "com.google.javascript.jscomp.LiveVariablesAnalysis",
    "signature": "com.google.javascript.jscomp.LiveVariablesAnalysis.LiveVariablesAnalysis(ControlFlowGraph,Scope,AbstractCompiler)",
    "snippet": "  LiveVariablesAnalysis(ControlFlowGraph<Node> cfg, Scope jsScope,\n      AbstractCompiler compiler) {\n    super(cfg, new LiveVariableJoinOp());\n    this.jsScope = jsScope;\n    this.escaped = Sets.newHashSet();\n    computeEscaped(jsScope, escaped, compiler);\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "LiveVariablesAnalysis.addToSetIfLocal",
    "class_name": "com.google.javascript.jscomp.LiveVariablesAnalysis",
    "signature": "com.google.javascript.jscomp.LiveVariablesAnalysis.addToSetIfLocal(Node,BitSet)",
    "snippet": "  private void addToSetIfLocal(Node node, BitSet set) {\n    Preconditions.checkState(NodeUtil.isName(node));\n    String name = node.getString();\n    if (!jsScope.isDeclared(name, false)) {\n      return;\n    }\n    Var var = jsScope.getVar(name);\n    if (!escaped.contains(var)) {\n      set.set(var.index);\n    }\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "LiveVariablesAnalysis.computeGenKill",
    "class_name": "com.google.javascript.jscomp.LiveVariablesAnalysis",
    "signature": "com.google.javascript.jscomp.LiveVariablesAnalysis.computeGenKill(Node,BitSet,BitSet,boolean)",
    "snippet": "  private void computeGenKill(Node n, BitSet gen, BitSet kill,\n      boolean conditional) {\n\n    switch (n.getType()) {\n      case Token.SCRIPT:\n      case Token.BLOCK:\n      case Token.FUNCTION:\n        return;\n\n      case Token.WHILE:\n      case Token.DO:\n      case Token.IF:\n        computeGenKill(NodeUtil.getConditionExpression(n), gen, kill,\n            conditional);\n        return;\n\n      case Token.FOR:\n        if (!NodeUtil.isForIn(n)) {\n          computeGenKill(NodeUtil.getConditionExpression(n), gen, kill,\n              conditional);\n        } else {\n          // for(x in y) {...}\n          Node lhs = n.getFirstChild();\n          Node rhs = lhs.getNext();\n          if (NodeUtil.isVar(lhs)) {\n            // for(var x in y) {...}\n            lhs = lhs.getLastChild();\n          }\n            addToSetIfLocal(lhs, kill);\n            addToSetIfLocal(lhs, gen);\n          computeGenKill(rhs, gen, kill, conditional);\n        }\n        return;\n\n      case Token.VAR:\n        for (Node c = n.getFirstChild(); c != null; c = c.getNext()) {\n          if (c.hasChildren()) {\n            computeGenKill(c.getFirstChild(), gen, kill, conditional);\n            if (!conditional) {\n              addToSetIfLocal(c, kill);\n            }\n          }\n        }\n        return;\n\n      case Token.AND:\n      case Token.OR:\n        computeGenKill(n.getFirstChild(), gen, kill, conditional);\n        // May short circuit.\n        computeGenKill(n.getLastChild(), gen, kill, true);\n        return;\n\n      case Token.HOOK:\n        computeGenKill(n.getFirstChild(), gen, kill, conditional);\n        // Assume both sides are conditional.\n        computeGenKill(n.getFirstChild().getNext(), gen, kill, true);\n        computeGenKill(n.getLastChild(), gen, kill, true);\n        return;\n\n      case Token.NAME:\n        if (isArgumentsName(n)) {\n          markAllParametersEscaped();\n        } else {\n          addToSetIfLocal(n, gen);\n        }\n        return;\n\n      default:\n        if (NodeUtil.isAssignmentOp(n) && NodeUtil.isName(n.getFirstChild())) {\n          Node lhs = n.getFirstChild();\n          if (!conditional) {\n            addToSetIfLocal(lhs, kill);\n          }\n          if (!NodeUtil.isAssign(n)) {\n            // assignments such as a += 1 reads a.\n            addToSetIfLocal(lhs, gen);\n          }\n          computeGenKill(lhs.getNext(), gen, kill, conditional);\n        } else {\n          for (Node c = n.getFirstChild(); c != null; c = c.getNext()) {\n            computeGenKill(c, gen, kill, conditional);\n          }\n        }\n        return;\n    }\n  }",
    "comment": " Computes the GEN and KILL set.  @param n Root node. @param gen Local variables that are live because of the instruction at {@code n} will be added to this set. @param kill Local variables that are killed because of the instruction at {@code n} will be added to this set. @param conditional {@code true} if any assignments encountered are conditionally executed. These assignments might not kill a variable. ",
    "is_bug": true,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "LiveVariablesAnalysis.createInitialEstimateLattice",
    "class_name": "com.google.javascript.jscomp.LiveVariablesAnalysis",
    "signature": "com.google.javascript.jscomp.LiveVariablesAnalysis.createInitialEstimateLattice()",
    "snippet": "  @Override\n  LiveVariableLattice createInitialEstimateLattice() {\n    return new LiveVariableLattice(jsScope.getVarCount());\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "LiveVariablesAnalysis.flowThrough",
    "class_name": "com.google.javascript.jscomp.LiveVariablesAnalysis",
    "signature": "com.google.javascript.jscomp.LiveVariablesAnalysis.flowThrough(Node,LiveVariableLattice)",
    "snippet": "  @Override\n  LiveVariableLattice flowThrough(Node node, LiveVariableLattice input) {\n    final BitSet gen = new BitSet(input.liveSet.size());\n    final BitSet kill = new BitSet(input.liveSet.size());\n\n    // Make kills conditional if the node can end abruptly by an exception.\n    boolean conditional = false;\n    List<DiGraphEdge<Node, Branch>> edgeList = getCfg().getOutEdges(node);\n    for (DiGraphEdge<Node, Branch> edge : edgeList) {\n      if (Branch.ON_EX.equals(edge.getValue())) {\n        conditional = true;\n      }\n    }\n    computeGenKill(node, gen, kill, conditional);\n    LiveVariableLattice result = new LiveVariableLattice(input);\n    // L_in = L_out - Kill + Gen\n    result.liveSet.andNot(kill);\n    result.liveSet.or(gen);\n    return result;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "LiveVariablesAnalysis.isForward",
    "class_name": "com.google.javascript.jscomp.LiveVariablesAnalysis",
    "signature": "com.google.javascript.jscomp.LiveVariablesAnalysis.isForward()",
    "snippet": "  @Override\n  boolean isForward() {\n    return false;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "LiveVariableJoinOp.apply",
    "class_name": "com.google.javascript.jscomp.LiveVariablesAnalysis$LiveVariableJoinOp",
    "signature": "com.google.javascript.jscomp.LiveVariablesAnalysis$LiveVariableJoinOp.apply(List)",
    "snippet": "    @Override\n    public LiveVariableLattice apply(List<LiveVariableLattice> in) {\n      LiveVariableLattice result = new LiveVariableLattice(in.get(0));\n      for (int i = 1; i < in.size(); i++) {\n        result.liveSet.or(in.get(i).liveSet);\n      }\n      return result;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "LiveVariableLattice.equals",
    "class_name": "com.google.javascript.jscomp.LiveVariablesAnalysis$LiveVariableLattice",
    "signature": "com.google.javascript.jscomp.LiveVariablesAnalysis$LiveVariableLattice.equals(Object)",
    "snippet": "    @Override\n    public boolean equals(Object other) {\n      Preconditions.checkNotNull(other);\n      return (other instanceof LiveVariableLattice) &&\n          this.liveSet.equals(((LiveVariableLattice) other).liveSet);\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "LoggerErrorManager.LoggerErrorManager",
    "class_name": "com.google.javascript.jscomp.LoggerErrorManager",
    "signature": "com.google.javascript.jscomp.LoggerErrorManager.LoggerErrorManager(MessageFormatter,Logger)",
    "snippet": "  public LoggerErrorManager(MessageFormatter formatter, Logger logger) {\n    this.formatter = formatter;\n    this.logger = logger;\n  }",
    "comment": " Creates an instance. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "NodeTraversal.NodeTraversal",
    "class_name": "com.google.javascript.jscomp.NodeTraversal",
    "signature": "com.google.javascript.jscomp.NodeTraversal.NodeTraversal(AbstractCompiler,Callback)",
    "snippet": "  public NodeTraversal(AbstractCompiler compiler, Callback cb) {\n    this(compiler, cb, new SyntacticScopeCreator(compiler));\n  }",
    "comment": " Creates a node traversal using the specified callback interface. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "NodeTraversal.NodeTraversal",
    "class_name": "com.google.javascript.jscomp.NodeTraversal",
    "signature": "com.google.javascript.jscomp.NodeTraversal.NodeTraversal(AbstractCompiler,Callback,ScopeCreator)",
    "snippet": "  public NodeTraversal(AbstractCompiler compiler, Callback cb,\n      ScopeCreator scopeCreator) {\n    this.callback = cb;\n    if (cb instanceof ScopedCallback) {\n      this.scopeCallback = (ScopedCallback) cb;\n    }\n    this.compiler = compiler;\n    this.inputId = null;\n    this.sourceName = \"\";\n    this.scopeCreator = scopeCreator;\n  }",
    "comment": " Creates a node traversal using the specified callback interface and the scope creator. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "NodeTraversal.getScope",
    "class_name": "com.google.javascript.jscomp.NodeTraversal",
    "signature": "com.google.javascript.jscomp.NodeTraversal.getScope()",
    "snippet": "  public Scope getScope() {\n    Scope scope = scopes.isEmpty() ? null : scopes.peek();\n    if (scopeRoots.isEmpty()) {\n      return scope;\n    }\n\n    Iterator<Node> it = scopeRoots.descendingIterator();\n    while (it.hasNext()) {\n      scope = scopeCreator.createScope(it.next(), scope);\n      scopes.push(scope);\n    }\n    scopeRoots.clear();\n\n    return scope;\n  }",
    "comment": "Gets the current scope. */",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "NodeTraversal.getSourceName",
    "class_name": "com.google.javascript.jscomp.NodeTraversal",
    "signature": "com.google.javascript.jscomp.NodeTraversal.getSourceName(Node)",
    "snippet": "  private static String getSourceName(Node n) {\n    String name = n.getSourceFileName();\n    return name == null ? \"\" : name;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "NodeTraversal.popScope",
    "class_name": "com.google.javascript.jscomp.NodeTraversal",
    "signature": "com.google.javascript.jscomp.NodeTraversal.popScope()",
    "snippet": "  private void popScope() {\n    if (scopeCallback != null) {\n      scopeCallback.exitScope(this);\n    }\n    if (scopeRoots.isEmpty()) {\n      scopes.pop();\n    } else {\n      scopeRoots.pop();\n    }\n    cfgs.pop();\n  }",
    "comment": "Pops back to the previous scope (e.g. when leaving a function). */",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "NodeTraversal.pushScope",
    "class_name": "com.google.javascript.jscomp.NodeTraversal",
    "signature": "com.google.javascript.jscomp.NodeTraversal.pushScope(Node)",
    "snippet": "  private void pushScope(Node node) {\n    Preconditions.checkState(curNode != null);\n    scopeRoots.push(node);\n    cfgs.push(null);\n    if (scopeCallback != null) {\n      scopeCallback.enterScope(this);\n    }\n  }",
    "comment": "Creates a new scope (e.g. when entering a function). */",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "NodeTraversal.pushScope",
    "class_name": "com.google.javascript.jscomp.NodeTraversal",
    "signature": "com.google.javascript.jscomp.NodeTraversal.pushScope(Scope)",
    "snippet": "  private void pushScope(Scope s) {\n    Preconditions.checkState(curNode != null);\n    scopes.push(s);\n    cfgs.push(null);\n    if (scopeCallback != null) {\n      scopeCallback.enterScope(this);\n    }\n  }",
    "comment": "Creates a new scope (e.g. when entering a function). */",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "NodeTraversal.traverse",
    "class_name": "com.google.javascript.jscomp.NodeTraversal",
    "signature": "com.google.javascript.jscomp.NodeTraversal.traverse(AbstractCompiler,Node,Callback)",
    "snippet": "  public static void traverse(\n      AbstractCompiler compiler, Node root, Callback cb) {\n    NodeTraversal t = new NodeTraversal(compiler, cb);\n    t.traverse(root);\n  }",
    "comment": " Traverses a node recursively. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "NodeTraversal.traverse",
    "class_name": "com.google.javascript.jscomp.NodeTraversal",
    "signature": "com.google.javascript.jscomp.NodeTraversal.traverse(Node)",
    "snippet": "  public void traverse(Node root) {\n    try {\n      inputId = NodeUtil.getInputId(root);\n      sourceName = \"\";\n      curNode = root;\n      pushScope(root);\n      traverseBranch(root, null);\n      popScope();\n    } catch (Exception unexpectedException) {\n      throwUnexpectedException(unexpectedException);\n    }\n  }",
    "comment": " Traverses a parse tree recursively. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "NodeTraversal.traverseAtScope",
    "class_name": "com.google.javascript.jscomp.NodeTraversal",
    "signature": "com.google.javascript.jscomp.NodeTraversal.traverseAtScope(Scope)",
    "snippet": "  void traverseAtScope(Scope s) {\n    Node n = s.getRootNode();\n    if (n.getType() == Token.FUNCTION) {\n      // We need to do some extra magic to make sure that the scope doesn't\n      // get re-created when we dive into the function.\n      if (inputId == null) {\n        inputId = NodeUtil.getInputId(n);\n      }\n      sourceName = getSourceName(n);\n      curNode = n;\n      pushScope(s);\n\n      Node args = n.getFirstChild().getNext();\n      Node body = args.getNext();\n      traverseBranch(args, n);\n      traverseBranch(body, n);\n\n      popScope();\n    } else {\n      traverseWithScope(n, s);\n    }\n  }",
    "comment": " Traverses a parse tree recursively with a scope, starting at that scope's root. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "NodeTraversal.traverseBranch",
    "class_name": "com.google.javascript.jscomp.NodeTraversal",
    "signature": "com.google.javascript.jscomp.NodeTraversal.traverseBranch(Node,Node)",
    "snippet": "  @SuppressWarnings(\"fallthrough\")\n  private void traverseBranch(Node n, Node parent) {\n    int type = n.getType();\n    if (type == Token.SCRIPT) {\n      inputId = n.getInputId();\n      sourceName = getSourceName(n);\n    }\n\n    curNode = n;\n    if (!callback.shouldTraverse(this, n, parent)) return;\n\n    switch (type) {\n      case Token.FUNCTION:\n        traverseFunction(n, parent);\n        break;\n\n      default:\n        for (Node child = n.getFirstChild(); child != null; ) {\n          // child could be replaced, in which case our child node\n          // would no longer point to the true next\n          Node next = child.getNext();\n          traverseBranch(child, n);\n          child = next;\n        }\n        break;\n    }\n\n    curNode = n;\n    callback.visit(this, n, parent);\n  }",
    "comment": " Traverses a branch. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "NodeTraversal.traverseFunction",
    "class_name": "com.google.javascript.jscomp.NodeTraversal",
    "signature": "com.google.javascript.jscomp.NodeTraversal.traverseFunction(Node,Node)",
    "snippet": "  private void traverseFunction(Node n, Node parent) {\n    Preconditions.checkState(n.getChildCount() == 3);\n    Preconditions.checkState(n.getType() == Token.FUNCTION);\n\n    final Node fnName = n.getFirstChild();\n\n    boolean isFunctionExpression = (parent != null)\n        && NodeUtil.isFunctionExpression(n);\n\n    if (!isFunctionExpression) {\n      // Functions declarations are in the scope containing the declaration.\n      traverseBranch(fnName, n);\n    }\n\n    curNode = n;\n    pushScope(n);\n\n    if (isFunctionExpression) {\n      // Function expression names are only accessible within the function\n      // scope.\n      traverseBranch(fnName, n);\n    }\n\n    final Node args = fnName.getNext();\n    final Node body = args.getNext();\n\n    // Args\n    traverseBranch(args, n);\n\n    // Body\n    Preconditions.checkState(body.getNext() == null &&\n            body.getType() == Token.BLOCK);\n    traverseBranch(body, n);\n\n    popScope();\n  }",
    "comment": " Traverses a function. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "AbstractPostOrderCallback.shouldTraverse",
    "class_name": "com.google.javascript.jscomp.NodeTraversal$AbstractPostOrderCallback",
    "signature": "com.google.javascript.jscomp.NodeTraversal$AbstractPostOrderCallback.shouldTraverse(NodeTraversal,Node,Node)",
    "snippet": "    @Override\n    public final boolean shouldTraverse(NodeTraversal nodeTraversal, Node n,\n        Node parent) {\n      return true;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "NodeUtil.getFunctionJSDocInfo",
    "class_name": "com.google.javascript.jscomp.NodeUtil",
    "signature": "com.google.javascript.jscomp.NodeUtil.getFunctionJSDocInfo(Node)",
    "snippet": "  public static JSDocInfo getFunctionJSDocInfo(Node n) {\n    Preconditions.checkState(n.getType() == Token.FUNCTION);\n    JSDocInfo fnInfo = n.getJSDocInfo();\n    if (fnInfo == null && NodeUtil.isFunctionExpression(n)) {\n      // Look for the info on other nodes.\n      Node parent = n.getParent();\n      if (parent.getType() == Token.ASSIGN) {\n        // on ASSIGNs\n        fnInfo = parent.getJSDocInfo();\n      } else if (parent.getType() == Token.NAME) {\n        // on var NAME = function() { ... };\n        fnInfo = parent.getParent().getJSDocInfo();\n      }\n    }\n    return fnInfo;\n  }",
    "comment": " Get the JSDocInfo for a function. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "NodeUtil.getInfoForNameNode",
    "class_name": "com.google.javascript.jscomp.NodeUtil",
    "signature": "com.google.javascript.jscomp.NodeUtil.getInfoForNameNode(Node)",
    "snippet": "  static JSDocInfo getInfoForNameNode(Node nameNode) {\n    JSDocInfo info = null;\n    Node parent = null;\n    if (nameNode != null) {\n      info = nameNode.getJSDocInfo();\n      parent = nameNode.getParent();\n    }\n\n    if (info == null && parent != null &&\n        ((parent.getType() == Token.VAR && parent.hasOneChild()) ||\n          parent.getType() == Token.FUNCTION)) {\n      info = parent.getJSDocInfo();\n    }\n    return info;\n  }",
    "comment": " @param nameNode A name node @return The JSDocInfo for the name node ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "NodeUtil.getInputId",
    "class_name": "com.google.javascript.jscomp.NodeUtil",
    "signature": "com.google.javascript.jscomp.NodeUtil.getInputId(Node)",
    "snippet": "  public static InputId getInputId(Node n) {\n    while (n != null && n.getType() != Token.SCRIPT) {\n      n = n.getParent();\n    }\n\n    return (n != null && n.getType() == Token.SCRIPT) ? n.getInputId() : null;\n  }",
    "comment": " @param n The node. @return The InputId property on the node or its ancestors. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "NodeUtil.isControlStructure",
    "class_name": "com.google.javascript.jscomp.NodeUtil",
    "signature": "com.google.javascript.jscomp.NodeUtil.isControlStructure(Node)",
    "snippet": "  static boolean isControlStructure(Node n) {\n    switch (n.getType()) {\n      case Token.FOR:\n      case Token.DO:\n      case Token.WHILE:\n      case Token.WITH:\n      case Token.IF:\n      case Token.LABEL:\n      case Token.TRY:\n      case Token.CATCH:\n      case Token.SWITCH:\n      case Token.CASE:\n      case Token.DEFAULT:\n        return true;\n      default:\n        return false;\n    }\n  }",
    "comment": " Determines whether the given node is a FOR, DO, WHILE, WITH, or IF node. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "NodeUtil.isForIn",
    "class_name": "com.google.javascript.jscomp.NodeUtil",
    "signature": "com.google.javascript.jscomp.NodeUtil.isForIn(Node)",
    "snippet": "  static boolean isForIn(Node n) {\n    return n.getType() == Token.FOR\n        && n.getChildCount() == 3;\n  }",
    "comment": " @return Whether the node represents a FOR-IN loop. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "NodeUtil.isFunctionExpression",
    "class_name": "com.google.javascript.jscomp.NodeUtil",
    "signature": "com.google.javascript.jscomp.NodeUtil.isFunctionExpression(Node)",
    "snippet": "  static boolean isFunctionExpression(Node n) {\n    return n.getType() == Token.FUNCTION && !isStatement(n);\n  }",
    "comment": " Is a FUNCTION node an function expression? An function expression is one that has either no name or a name that is not added to the current scope.  <p>Some examples of function expressions: <pre> (function () {}) (function f() {})() [ function f() {} ] var f = function f() {}; for (function f() {};;) {} </pre>  <p>Some examples of functions that are <em>not</em> expressions: <pre> function f() {} if (x); else function f() {} for (;;) { function f() {} } </pre>  @param n A node @return Whether n is an function used within an expression. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "NodeUtil.isName",
    "class_name": "com.google.javascript.jscomp.NodeUtil",
    "signature": "com.google.javascript.jscomp.NodeUtil.isName(Node)",
    "snippet": "  static boolean isName(Node n) {\n    return n.getType() == Token.NAME;\n  }",
    "comment": " Is this a NAME node? ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "NodeUtil.isStatement",
    "class_name": "com.google.javascript.jscomp.NodeUtil",
    "signature": "com.google.javascript.jscomp.NodeUtil.isStatement(Node)",
    "snippet": "  static boolean isStatement(Node n) {\n    return isStatementParent(n.getParent());\n  }",
    "comment": " @return Whether the node is used as a statement. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "NodeUtil.isStatementBlock",
    "class_name": "com.google.javascript.jscomp.NodeUtil",
    "signature": "com.google.javascript.jscomp.NodeUtil.isStatementBlock(Node)",
    "snippet": "  static boolean isStatementBlock(Node n) {\n    return n.getType() == Token.SCRIPT || n.getType() == Token.BLOCK;\n  }",
    "comment": " @return Whether the node is of a type that contain other statements. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "NodeUtil.isStatementParent",
    "class_name": "com.google.javascript.jscomp.NodeUtil",
    "signature": "com.google.javascript.jscomp.NodeUtil.isStatementParent(Node)",
    "snippet": "  static boolean isStatementParent(Node parent) {\n    // It is not possible to determine definitely if a node is a statement\n    // or not if it is not part of the AST.  A FUNCTION node can be\n    // either part of an expression or a statement.\n    Preconditions.checkState(parent != null);\n    switch (parent.getType()) {\n      case Token.SCRIPT:\n      case Token.BLOCK:\n      case Token.LABEL:\n        return true;\n      default:\n        return false;\n    }\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "NodeUtil.isVar",
    "class_name": "com.google.javascript.jscomp.NodeUtil",
    "signature": "com.google.javascript.jscomp.NodeUtil.isVar(Node)",
    "snippet": "  static boolean isVar(Node n) {\n    return n.getType() == Token.VAR;\n  }",
    "comment": " Is this a VAR node? ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "PassFactory.PassFactory",
    "class_name": "com.google.javascript.jscomp.PassFactory",
    "signature": "com.google.javascript.jscomp.PassFactory.PassFactory(String,boolean)",
    "snippet": "  protected PassFactory(String name, boolean isOneTimePass) {\n    this.name = name;\n    this.isOneTimePass = isOneTimePass;\n  }",
    "comment": " @param name The name of the pass that this factory creates. @param isOneTimePass If true, the pass produced by this factory can only be run once. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "PrepareAst.PrepareAst",
    "class_name": "com.google.javascript.jscomp.PrepareAst",
    "signature": "com.google.javascript.jscomp.PrepareAst.PrepareAst(AbstractCompiler)",
    "snippet": "  PrepareAst(AbstractCompiler compiler) {\n    this(compiler, false);\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "PrepareAst.PrepareAst",
    "class_name": "com.google.javascript.jscomp.PrepareAst",
    "signature": "com.google.javascript.jscomp.PrepareAst.PrepareAst(AbstractCompiler,boolean)",
    "snippet": "  PrepareAst(AbstractCompiler compiler, boolean checkOnly) {\n    this.compiler = compiler;\n    this.checkOnly = checkOnly;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "PrepareAst.process",
    "class_name": "com.google.javascript.jscomp.PrepareAst",
    "signature": "com.google.javascript.jscomp.PrepareAst.process(Node,Node)",
    "snippet": "  @Override\n  public void process(Node externs, Node root) {\n    if (checkOnly) {\n      normalizeNodeTypes(root);\n    } else {\n      // Don't perform \"PrepareAnnotations\" when doing checks as\n      // they currently aren't valid during sanity checks.  In particular,\n      // they DIRECT_EVAL shouldn't be applied after inlining has been\n      // performed.\n      if (externs != null) {\n        NodeTraversal.traverse(\n            compiler, externs, new PrepareAnnotations(compiler));\n      }\n      if (root != null) {\n        NodeTraversal.traverse(\n            compiler, root, new PrepareAnnotations(compiler));\n      }\n    }\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "PrepareAnnotations.annotateDispatchers",
    "class_name": "com.google.javascript.jscomp.PrepareAst$PrepareAnnotations",
    "signature": "com.google.javascript.jscomp.PrepareAst$PrepareAnnotations.annotateDispatchers(Node,Node)",
    "snippet": "    private void annotateDispatchers(Node n, Node parent) {\n      Preconditions.checkState(n.getType() == Token.FUNCTION);\n      if (parent.getJSDocInfo() != null\n          && parent.getJSDocInfo().isJavaDispatch()) {\n        if (parent.getType() == Token.ASSIGN) {\n          Preconditions.checkState(parent.getLastChild() == n);\n          n.putBooleanProp(Node.IS_DISPATCHER, true);\n        }\n      }\n    }",
    "comment": " Translate dispatcher info into the property expected node. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "PrepareAnnotations.annotateFunctions",
    "class_name": "com.google.javascript.jscomp.PrepareAst$PrepareAnnotations",
    "signature": "com.google.javascript.jscomp.PrepareAst$PrepareAnnotations.annotateFunctions(Node,Node)",
    "snippet": "    private void annotateFunctions(Node n, Node parent) {\n      JSDocInfo fnInfo = NodeUtil.getFunctionJSDocInfo(n);\n\n      // Compute which function parameters are optional and\n      // which are var_args.\n      Node args = n.getFirstChild().getNext();\n      for (Node arg = args.getFirstChild();\n           arg != null;\n           arg = arg.getNext()) {\n        String argName = arg.getString();\n        JSTypeExpression typeExpr = fnInfo == null ?\n            null : fnInfo.getParameterType(argName);\n\n        if (convention.isOptionalParameter(arg) ||\n            typeExpr != null && typeExpr.isOptionalArg()) {\n          arg.putBooleanProp(Node.IS_OPTIONAL_PARAM, true);\n        }\n        if (convention.isVarArgsParameter(arg) ||\n            typeExpr != null && typeExpr.isVarArgs()) {\n          arg.putBooleanProp(Node.IS_VAR_ARGS_PARAM, true);\n        }\n      }\n    }",
    "comment": " Annotate optional and var_arg function parameters. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "PrepareAnnotations.shouldTraverse",
    "class_name": "com.google.javascript.jscomp.PrepareAst$PrepareAnnotations",
    "signature": "com.google.javascript.jscomp.PrepareAst$PrepareAnnotations.shouldTraverse(NodeTraversal,Node,Node)",
    "snippet": "    @Override\n    public boolean shouldTraverse(NodeTraversal t, Node n, Node parent) {\n      if (n.getType() == Token.OBJECTLIT) {\n        normalizeObjectLiteralAnnotations(n);\n      }\n      return true;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "PrepareAnnotations.visit",
    "class_name": "com.google.javascript.jscomp.PrepareAst$PrepareAnnotations",
    "signature": "com.google.javascript.jscomp.PrepareAst$PrepareAnnotations.visit(NodeTraversal,Node,Node)",
    "snippet": "    @Override\n    public void visit(NodeTraversal t, Node n, Node parent) {\n      switch (n.getType()) {\n        case Token.CALL:\n          annotateCalls(n);\n          break;\n\n        case Token.FUNCTION:\n          annotateFunctions(n, parent);\n          annotateDispatchers(n, parent);\n          break;\n      }\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "TweakFunction.getName",
    "class_name": "com.google.javascript.jscomp.ProcessTweaks$TweakFunction",
    "signature": "com.google.javascript.jscomp.ProcessTweaks$TweakFunction.getName()",
    "snippet": "    String getName() {\n      return name;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "RhinoErrorReporter.forNewRhino",
    "class_name": "com.google.javascript.jscomp.RhinoErrorReporter",
    "signature": "com.google.javascript.jscomp.RhinoErrorReporter.forNewRhino(AbstractCompiler)",
    "snippet": "  public static com.google.javascript.jscomp.mozilla.rhino.ErrorReporter\n      forNewRhino(AbstractCompiler compiler) {\n    return new NewRhinoErrorReporter(compiler);\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "RhinoErrorReporter.forOldRhino",
    "class_name": "com.google.javascript.jscomp.RhinoErrorReporter",
    "signature": "com.google.javascript.jscomp.RhinoErrorReporter.forOldRhino(AbstractCompiler)",
    "snippet": "  public static ErrorReporter forOldRhino(AbstractCompiler compiler) {\n    return new OldRhinoErrorReporter(compiler);\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "RhinoErrorReporter.replacePlaceHolders",
    "class_name": "com.google.javascript.jscomp.RhinoErrorReporter",
    "signature": "com.google.javascript.jscomp.RhinoErrorReporter.replacePlaceHolders(String)",
    "snippet": "  private Pattern replacePlaceHolders(String s) {\n    s = Pattern.quote(s);\n    return Pattern.compile(s.replaceAll(\"\\\\{\\\\d+\\\\}\", \"\\\\\\\\E.*\\\\\\\\Q\"));\n  }",
    "comment": " For each message such as \"Not a good use of {0}\", replace the place holder {0} with a wild card that matches all possible strings. Also put the any non-place-holder in quotes for regex matching later. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "Scope.Scope",
    "class_name": "com.google.javascript.jscomp.Scope",
    "signature": "com.google.javascript.jscomp.Scope.Scope(Node,AbstractCompiler)",
    "snippet": "  Scope(Node rootNode, AbstractCompiler compiler) {\n    this.parent = null;\n    this.rootNode = rootNode;\n    thisType = compiler.getTypeRegistry().getNativeObjectType(GLOBAL_THIS);\n    this.isBottom = false;\n    this.depth = 0;\n  }",
    "comment": " Creates a global Scope. @param rootNode  Typically the global BLOCK node. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "Scope.Scope",
    "class_name": "com.google.javascript.jscomp.Scope",
    "signature": "com.google.javascript.jscomp.Scope.Scope(Scope,Node)",
    "snippet": "  Scope(Scope parent, Node rootNode) {\n    Preconditions.checkNotNull(parent);\n    Preconditions.checkArgument(rootNode != parent.rootNode);\n\n    this.parent = parent;\n    this.rootNode = rootNode;\n    JSType nodeType = rootNode.getJSType();\n    if (nodeType != null && nodeType instanceof FunctionType) {\n      thisType = ((FunctionType) nodeType).getTypeOfThis();\n    } else {\n      thisType = parent.thisType;\n    }\n    this.isBottom = false;\n    this.depth = parent.depth + 1;\n  }",
    "comment": " Creates a Scope given the parent Scope and the root node of the scope. @param parent  The parent Scope. Cannot be null. @param rootNode  Typically the FUNCTION node. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "Scope.declare",
    "class_name": "com.google.javascript.jscomp.Scope",
    "signature": "com.google.javascript.jscomp.Scope.declare(String,Node,JSType,CompilerInput)",
    "snippet": "  Var declare(String name, Node nameNode, JSType type, CompilerInput input) {\n    return declare(name, nameNode, type, input, true);\n  }",
    "comment": " Declares a variable whose type is inferred.  @param name name of the variable @param nameNode the NAME node declaring the variable @param type the variable's type @param input the input in which this variable is defined. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "Scope.declare",
    "class_name": "com.google.javascript.jscomp.Scope",
    "signature": "com.google.javascript.jscomp.Scope.declare(String,Node,JSType,CompilerInput,boolean)",
    "snippet": "  Var declare(String name, Node nameNode,\n      JSType type, CompilerInput input, boolean inferred) {\n    Preconditions.checkState(name != null && name.length() > 0);\n\n    // Make sure that it's declared only once\n    Preconditions.checkState(vars.get(name) == null);\n\n    // native variables do not have a name node.\n    // TODO(user): make Var abstract and have NativeVar, NormalVar.\n    JSDocInfo info = NodeUtil.getInfoForNameNode(nameNode);\n\n    Var var = new Var(inferred, name, nameNode, type, this, vars.size(), input,\n        info != null && info.isDefine(), info);\n\n    vars.put(name, var);\n    return var;\n  }",
    "comment": " Declares a variable.  @param name name of the variable @param nameNode the NAME node declaring the variable @param type the variable's type @param input the input in which this variable is defined. @param inferred Whether this variable's type is inferred (as opposed to declared). ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "Scope.getRootNode",
    "class_name": "com.google.javascript.jscomp.Scope",
    "signature": "com.google.javascript.jscomp.Scope.getRootNode()",
    "snippet": "  @Override\n  public Node getRootNode() {\n    return rootNode;\n  }",
    "comment": " Gets the container node of the scope. This is typically the FUNCTION node or the global BLOCK/SCRIPT node. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "Scope.getVarCount",
    "class_name": "com.google.javascript.jscomp.Scope",
    "signature": "com.google.javascript.jscomp.Scope.getVarCount()",
    "snippet": "  public int getVarCount() {\n    return vars.size();\n  }",
    "comment": " Returns number of variables in this scope ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "Scope.getVars",
    "class_name": "com.google.javascript.jscomp.Scope",
    "signature": "com.google.javascript.jscomp.Scope.getVars()",
    "snippet": "  public Iterator<Var> getVars() {\n    return vars.values().iterator();\n  }",
    "comment": " Return an iterator over all of the variables declared in this scope. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "Scope.isDeclared",
    "class_name": "com.google.javascript.jscomp.Scope",
    "signature": "com.google.javascript.jscomp.Scope.isDeclared(String,boolean)",
    "snippet": "  public boolean isDeclared(String name, boolean recurse) {\n    Scope scope = this;\n    if (scope.vars.containsKey(name))\n      return true;\n\n    if (scope.parent != null && recurse) {\n      return scope.parent.isDeclared(name, recurse);\n    }\n    return false;\n  }",
    "comment": " Returns true if a variable is declared. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "Scope.isGlobal",
    "class_name": "com.google.javascript.jscomp.Scope",
    "signature": "com.google.javascript.jscomp.Scope.isGlobal()",
    "snippet": "  public boolean isGlobal() {\n    return parent == null;\n  }",
    "comment": " Returns whether this is the global scope. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "Scope.isLocal",
    "class_name": "com.google.javascript.jscomp.Scope",
    "signature": "com.google.javascript.jscomp.Scope.isLocal()",
    "snippet": "  public boolean isLocal() {\n    return !isGlobal();\n  }",
    "comment": " Returns whether this is a local scope (i.e. not the global scope). ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "Var.getName",
    "class_name": "com.google.javascript.jscomp.Scope$Var",
    "signature": "com.google.javascript.jscomp.Scope$Var.getName()",
    "snippet": "    @Override\n    public String getName() {\n      return name;\n    }",
    "comment": " Gets the name of the variable. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "Var.getParentNode",
    "class_name": "com.google.javascript.jscomp.Scope$Var",
    "signature": "com.google.javascript.jscomp.Scope$Var.getParentNode()",
    "snippet": "    public Node getParentNode() {\n      return nameNode == null ? null : nameNode.getParent();\n    }",
    "comment": " Gets the parent of the name node. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "SourceFile.SourceFile",
    "class_name": "com.google.javascript.jscomp.SourceFile",
    "signature": "com.google.javascript.jscomp.SourceFile.SourceFile(String)",
    "snippet": "  public SourceFile(String fileName) {\n    if (fileName == null || fileName.isEmpty()) {\n      throw new IllegalArgumentException(\"a source must have a name\");\n    }\n    this.fileName = fileName;\n    // Starting point: offset 0 is at line 1.\n    this.lastOffset = 0;\n    this.lastLine = 1;\n  }",
    "comment": " Construct a new abstract source file.  @param fileName The file name of the source file. It does not necessarily need to correspond to a real path. But it should be unique. Will appear in warning messages emitted by the compiler. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "SourceFile.fromCode",
    "class_name": "com.google.javascript.jscomp.SourceFile",
    "signature": "com.google.javascript.jscomp.SourceFile.fromCode(String,String)",
    "snippet": "  public static SourceFile fromCode(String fileName, String code) {\n    return new Preloaded(fileName, code);\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "SourceFile.getCode",
    "class_name": "com.google.javascript.jscomp.SourceFile",
    "signature": "com.google.javascript.jscomp.SourceFile.getCode()",
    "snippet": "  public String getCode() throws IOException {\n    return code;\n  }",
    "comment": " Gets all the code in this source file. @throws IOException ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "SourceFile.getName",
    "class_name": "com.google.javascript.jscomp.SourceFile",
    "signature": "com.google.javascript.jscomp.SourceFile.getName()",
    "snippet": "  @Override\n  public String getName() {\n    return fileName;\n  }",
    "comment": "Returns a unique name for the source file. */",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "SourceFile.setCode",
    "class_name": "com.google.javascript.jscomp.SourceFile",
    "signature": "com.google.javascript.jscomp.SourceFile.setCode(String)",
    "snippet": "  private void setCode(String sourceCode) {\n    code = sourceCode;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "SourceFile.setIsExtern",
    "class_name": "com.google.javascript.jscomp.SourceFile",
    "signature": "com.google.javascript.jscomp.SourceFile.setIsExtern(boolean)",
    "snippet": "  void setIsExtern(boolean newVal) {\n    isExternFile = newVal;\n  }",
    "comment": "Sets that this is an extern. */",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "SourceFile.setOriginalPath",
    "class_name": "com.google.javascript.jscomp.SourceFile",
    "signature": "com.google.javascript.jscomp.SourceFile.setOriginalPath(String)",
    "snippet": "  public void setOriginalPath(String originalPath) {\n    this.originalPath = originalPath;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "SuppressDocWarningsGuard.SuppressDocWarningsGuard",
    "class_name": "com.google.javascript.jscomp.SuppressDocWarningsGuard",
    "signature": "com.google.javascript.jscomp.SuppressDocWarningsGuard.SuppressDocWarningsGuard(Map)",
    "snippet": "  SuppressDocWarningsGuard(Map<String, DiagnosticGroup> suppressableGroups) {\n    for (Map.Entry<String, DiagnosticGroup> entry :\n             suppressableGroups.entrySet()) {\n      suppressors.put(\n          entry.getKey(),\n          new DiagnosticGroupWarningsGuard(\n              entry.getValue(),\n              CheckLevel.OFF));\n    }\n  }",
    "comment": " The suppressable groups, indexed by name. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "SuppressDocWarningsGuard.getPriority",
    "class_name": "com.google.javascript.jscomp.SuppressDocWarningsGuard",
    "signature": "com.google.javascript.jscomp.SuppressDocWarningsGuard.getPriority()",
    "snippet": "  @Override\n  public int getPriority() {\n    // Happens after path-based filtering, but before other times\n    // of filtering.\n    return WarningsGuard.Priority.SUPPRESS_DOC.value;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "SyntacticScopeCreator.SyntacticScopeCreator",
    "class_name": "com.google.javascript.jscomp.SyntacticScopeCreator",
    "signature": "com.google.javascript.jscomp.SyntacticScopeCreator.SyntacticScopeCreator(AbstractCompiler)",
    "snippet": "  SyntacticScopeCreator(AbstractCompiler compiler) {\n    this.compiler = compiler;\n    this.redeclarationHandler = new DefaultRedeclarationHandler();\n  }",
    "comment": " Creates a ScopeCreator. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "SyntacticScopeCreator.createScope",
    "class_name": "com.google.javascript.jscomp.SyntacticScopeCreator",
    "signature": "com.google.javascript.jscomp.SyntacticScopeCreator.createScope(Node,Scope)",
    "snippet": "  @Override\n  public Scope createScope(Node n, Scope parent) {\n    inputId = null;\n    if (parent == null) {\n      scope = new Scope(n, compiler);\n    } else {\n      scope = new Scope(parent, n);\n    }\n\n    scanRoot(n, parent);\n\n    inputId = null;\n    Scope returnedScope = scope;\n    scope = null;\n    return returnedScope;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "SyntacticScopeCreator.declareVar",
    "class_name": "com.google.javascript.jscomp.SyntacticScopeCreator",
    "signature": "com.google.javascript.jscomp.SyntacticScopeCreator.declareVar(Node)",
    "snippet": "  private void declareVar(Node n) {\n    Preconditions.checkState(n.getType() == Token.NAME);\n\n    CompilerInput input = compiler.getInput(inputId);\n    String name = n.getString();\n    if (scope.isDeclared(name, false)\n        || (scope.isLocal() && name.equals(ARGUMENTS))) {\n      redeclarationHandler.onRedeclaration(\n          scope, name, n, input);\n    } else {\n      scope.declare(name, n, null, input);\n    }\n  }",
    "comment": " Declares a variable.  @param n The node corresponding to the variable name. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "SyntacticScopeCreator.scanRoot",
    "class_name": "com.google.javascript.jscomp.SyntacticScopeCreator",
    "signature": "com.google.javascript.jscomp.SyntacticScopeCreator.scanRoot(Node,Scope)",
    "snippet": "  private void scanRoot(Node n, Scope parent) {\n    if (n.getType() == Token.FUNCTION) {\n      if (inputId == null) {\n        inputId = NodeUtil.getInputId(n);\n        // TODO(johnlenz): inputId maybe null if the FUNCTION node is detached\n        // from the AST.\n        // Is it meaningful to build a scope for detached FUNCTION node?\n      }\n\n      final Node fnNameNode = n.getFirstChild();\n      final Node args = fnNameNode.getNext();\n      final Node body = args.getNext();\n\n      // Bleed the function name into the scope, if it hasn't\n      // been declared in the outer scope.\n      String fnName = fnNameNode.getString();\n      if (!fnName.isEmpty() && NodeUtil.isFunctionExpression(n)) {\n        declareVar(fnNameNode);\n      }\n\n      // Args: Declare function variables\n      Preconditions.checkState(args.getType() == Token.LP);\n      for (Node a = args.getFirstChild(); a != null;\n           a = a.getNext()) {\n        Preconditions.checkState(a.getType() == Token.NAME);\n        declareVar(a);\n      }\n\n      // Body\n      scanVars(body, n);\n    } else {\n      // It's the global block\n      Preconditions.checkState(scope.getParent() == null);\n      scanVars(n, null);\n    }\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "SyntacticScopeCreator.scanVars",
    "class_name": "com.google.javascript.jscomp.SyntacticScopeCreator",
    "signature": "com.google.javascript.jscomp.SyntacticScopeCreator.scanVars(Node,Node)",
    "snippet": "  private void scanVars(Node n, Node parent) {\n    switch (n.getType()) {\n      case Token.VAR:\n        // Declare all variables. e.g. var x = 1, y, z;\n        for (Node child = n.getFirstChild();\n             child != null;) {\n          Node next = child.getNext();\n          declareVar(child);\n          child = next;\n        }\n        return;\n\n      case Token.FUNCTION:\n        if (NodeUtil.isFunctionExpression(n)) {\n          return;\n        }\n\n        String fnName = n.getFirstChild().getString();\n        if (fnName.isEmpty()) {\n          // This is invalid, but allow it so the checks can catch it.\n          return;\n        }\n        declareVar(n.getFirstChild());\n        return;   // should not examine function's children\n\n      case Token.CATCH:\n        Preconditions.checkState(n.getChildCount() == 2);\n        Preconditions.checkState(n.getFirstChild().getType() == Token.NAME);\n        // the first child is the catch var and the third child\n        // is the code block\n\n        final Node var = n.getFirstChild();\n        final Node block = var.getNext();\n\n        declareVar(var);\n        scanVars(block, n);\n        return;  // only one child to scan\n\n      case Token.SCRIPT:\n        inputId = n.getInputId();\n        Preconditions.checkNotNull(inputId);\n        break;\n    }\n\n    // Variables can only occur in statement-level nodes, so\n    // we only need to traverse children in a couple special cases.\n    if (NodeUtil.isControlStructure(n) || NodeUtil.isStatementBlock(n)) {\n      for (Node child = n.getFirstChild();\n           child != null;) {\n        Node next = child.getNext();\n        scanVars(child, n);\n        child = next;\n      }\n    }\n  }",
    "comment": " Scans and gather variables declarations under a Node ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "Tracer.Tracer",
    "class_name": "com.google.javascript.jscomp.Tracer",
    "signature": "com.google.javascript.jscomp.Tracer.Tracer(String,String)",
    "snippet": "  Tracer(@Nullable String type, @Nullable String comment) {\n    this.type = type;\n    this.comment = comment == null ? \"\" : comment;\n    startTimeMs = clock.currentTimeMillis();\n    startThread = Thread.currentThread();\n    if (!extraTracingStatistics.isEmpty()) {\n      int size = extraTracingStatistics.size();\n      extraTracingValues = new long[size];\n      int i = 0;\n      for (TracingStatistic tracingStatistic : extraTracingStatistics) {\n        extraTracingValues[i] = tracingStatistic.start(startThread);\n        i++;\n      }\n    }\n\n    ThreadTrace trace = getThreadTrace();\n\n    // Do nothing if the current thread trace wasn't initialized.\n    if (!trace.isInitialized()) {\n      return;\n    }\n\n    // Check if we are creating too many Tracers.\n    if (trace.events.size() >= MAX_TRACE_SIZE) {\n      logger.log(Level.WARNING,\n                  \"Giant thread trace. Too many Tracers created. \"\n                    + \"Clearing to avoid memory leak.\",\n                  new Throwable(trace.toString()));\n      trace.truncateEvents();\n    }\n\n    // Check if we forgot to close the Tracers.\n    if (trace.outstandingEvents.size() >= MAX_TRACE_SIZE) {\n      logger.log(Level.WARNING,\n                  \"Too many outstanding Tracers. Tracer.stop() is missing \"\n                    + \"or Tracer.stop() is not wrapped in a \"\n                    + \"try/finally block. \"\n                    + \"Clearing to avoid memory leak.\",\n                  new Throwable(trace.toString()));\n      trace.truncateOutstandingEvents();\n    }\n\n    trace.startEvent(this);\n  }",
    "comment": " Create and start a tracer. Both type and comment may be null. See class comment for usage.  @param type The type for totalling @param comment Comment about this tracer ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "Tracer.getThreadTrace",
    "class_name": "com.google.javascript.jscomp.Tracer",
    "signature": "com.google.javascript.jscomp.Tracer.getThreadTrace()",
    "snippet": "  static ThreadTrace getThreadTrace() {\n    ThreadTrace t = traces.get();\n    if (t == null) {\n      t = new ThreadTrace();\n      t.prettyPrint = defaultPrettyPrint;\n      traces.set(t);\n    }\n    return t;\n  }",
    "comment": " Get the ThreadTrace for the current thread, creating one if necessary. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "Tracer.stop",
    "class_name": "com.google.javascript.jscomp.Tracer",
    "signature": "com.google.javascript.jscomp.Tracer.stop()",
    "snippet": "  long stop() {\n    return stop(-1);\n  }",
    "comment": "Stop the trace using the default silence_threshold  @return  The time that this trace actually ran. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "Tracer.stop",
    "class_name": "com.google.javascript.jscomp.Tracer",
    "signature": "com.google.javascript.jscomp.Tracer.stop(int)",
    "snippet": "  long stop(int silence_threshold) {\n    Preconditions.checkState(Thread.currentThread() == startThread);\n\n    ThreadTrace trace = getThreadTrace();\n    // Do nothing if the thread trace was not initialized.\n    if (!trace.isInitialized()) {\n      return 0;\n    }\n\n    stopTimeMs = clock.currentTimeMillis();\n    if (extraTracingValues != null) {\n      // We use extraTracingValues.length rather than\n      // extraTracingStatistics.size() because a new statistic may\n      // have been added\n      for (int i = 0; i < extraTracingValues.length; i++) {\n        long value = extraTracingStatistics.get(i).stop(startThread);\n        extraTracingValues[i] = value - extraTracingValues[i];\n      }\n    }\n\n    // Do nothing if the thread trace was not initialized.\n    if (!trace.isInitialized()) {\n      return 0;\n    }\n\n    trace.endEvent(this, silence_threshold);\n    return stopTimeMs - startTimeMs;\n  }",
    "comment": " Stop the trace. This may only be done once and must be done from the same thread that started it. @param silence_threshold Traces for time less than silence_threshold ms will be left out of the trace report. A value of -1 indicates that the current ThreadTrace silence_threshold should be used. @return The time that this trace actually ran ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "ThreadTrace.isInitialized",
    "class_name": "com.google.javascript.jscomp.Tracer$ThreadTrace",
    "signature": "com.google.javascript.jscomp.Tracer$ThreadTrace.isInitialized()",
    "snippet": "    boolean isInitialized() {\n      return isInitialized;\n    }",
    "comment": "Is initialized? */",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "WarningsGuard.disables",
    "class_name": "com.google.javascript.jscomp.WarningsGuard",
    "signature": "com.google.javascript.jscomp.WarningsGuard.disables(DiagnosticGroup)",
    "snippet": "  protected boolean disables(DiagnosticGroup group) {\n    return false;\n  }",
    "comment": " Returns whether all warnings in the given diagnostic group will be filtered out. Used to determine which passes to skip.  @param group A group of DiagnosticTypes. @return Whether all warnings of these types are disabled by this guard. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "WarningsGuard.enables",
    "class_name": "com.google.javascript.jscomp.WarningsGuard",
    "signature": "com.google.javascript.jscomp.WarningsGuard.enables(DiagnosticGroup)",
    "snippet": "  protected boolean enables(DiagnosticGroup group) {\n    return false;\n  }",
    "comment": " Returns whether any of the warnings in the given diagnostic group will be upgraded to a warning or error.  @param group A group of DiagnosticTypes. @return Whether any warnings of these types are enabled by this guard. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "WarningsGuard.getPriority",
    "class_name": "com.google.javascript.jscomp.WarningsGuard",
    "signature": "com.google.javascript.jscomp.WarningsGuard.getPriority()",
    "snippet": "  protected int getPriority() {\n    return Priority.DEFAULT.value;\n  }",
    "comment": " The priority in which warnings guards are applied. Lower means the guard will be applied sooner. Expressed on a scale of 1 to 100. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "DiGraph.isConnected",
    "class_name": "com.google.javascript.jscomp.graph.DiGraph",
    "signature": "com.google.javascript.jscomp.graph.DiGraph.isConnected(N,E,N)",
    "snippet": "  @Override\n  public boolean isConnected(N n1, E e, N n2) {\n    return isConnectedInDirection(n1, e, n2) ||\n        isConnectedInDirection(n2, e, n1);\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "Graph.connectIfNotFound",
    "class_name": "com.google.javascript.jscomp.graph.Graph",
    "signature": "com.google.javascript.jscomp.graph.Graph.connectIfNotFound(N,E,N)",
    "snippet": "  public final void connectIfNotFound(N n1, E edge, N n2) {\n    if (!isConnected(n1, edge, n2)) {\n      connect(n1, edge, n2);\n    }\n  }",
    "comment": " Connects two nodes in the graph with an edge if such edge does not already exists between the nodes.  @param n1 First node. @param edge The edge. @param n2 Second node. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "Graph.getNodeOrFail",
    "class_name": "com.google.javascript.jscomp.graph.Graph",
    "signature": "com.google.javascript.jscomp.graph.Graph.getNodeOrFail(N)",
    "snippet": "  @SuppressWarnings(\"unchecked\")\n  <T extends GraphNode<N, E>> T getNodeOrFail(N val) {\n    T node = (T) getNode(val);\n    if (node == null) {\n      throw new IllegalArgumentException(val + \" does not exist in graph\");\n    }\n    return node;\n  }",
    "comment": " Gets the node of the specified type, or throws an IllegalArgumentException. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "LinkedDirectedGraph.LinkedDirectedGraph",
    "class_name": "com.google.javascript.jscomp.graph.LinkedDirectedGraph",
    "signature": "com.google.javascript.jscomp.graph.LinkedDirectedGraph.LinkedDirectedGraph(boolean,boolean)",
    "snippet": "  protected LinkedDirectedGraph(\n      boolean useNodeAnnotations, boolean useEdgeAnnotations) {\n    this.useNodeAnnotations = useNodeAnnotations;\n    this.useEdgeAnnotations = useEdgeAnnotations;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "LinkedDirectedGraph.connect",
    "class_name": "com.google.javascript.jscomp.graph.LinkedDirectedGraph",
    "signature": "com.google.javascript.jscomp.graph.LinkedDirectedGraph.connect(N,E,N)",
    "snippet": "  @Override\n  public void connect(N srcValue, E edgeValue, N destValue) {\n    LinkedDirectedGraphNode<N, E> src = getNodeOrFail(srcValue);\n    LinkedDirectedGraphNode<N, E> dest = getNodeOrFail(destValue);\n    LinkedDirectedGraphEdge<N, E> edge =\n        useEdgeAnnotations ?\n        new AnnotatedLinkedDirectedGraphEdge<N, E>(src, edgeValue, dest) :\n        new LinkedDirectedGraphEdge<N, E>(src, edgeValue, dest);\n    src.getOutEdges().add(edge);\n    dest.getInEdges().add(edge);\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "LinkedDirectedGraph.createDirectedGraphNode",
    "class_name": "com.google.javascript.jscomp.graph.LinkedDirectedGraph",
    "signature": "com.google.javascript.jscomp.graph.LinkedDirectedGraph.createDirectedGraphNode(N)",
    "snippet": "  @Override\n  public DiGraphNode<N, E> createDirectedGraphNode(N nodeValue) {\n    LinkedDirectedGraphNode<N, E> node = nodes.get(nodeValue);\n    if (node == null) {\n      node = useNodeAnnotations ?\n          new AnnotatedLinkedDirectedGraphNode<N, E>(nodeValue) :\n          new LinkedDirectedGraphNode<N, E>(nodeValue);\n      nodes.put(nodeValue, node);\n    }\n    return node;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "LinkedDirectedGraph.createNode",
    "class_name": "com.google.javascript.jscomp.graph.LinkedDirectedGraph",
    "signature": "com.google.javascript.jscomp.graph.LinkedDirectedGraph.createNode(N)",
    "snippet": "  @Override\n  public GraphNode<N, E> createNode(N value) {\n    return createDirectedGraphNode(value);\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "LinkedDirectedGraph.getDirectedGraphNode",
    "class_name": "com.google.javascript.jscomp.graph.LinkedDirectedGraph",
    "signature": "com.google.javascript.jscomp.graph.LinkedDirectedGraph.getDirectedGraphNode(N)",
    "snippet": "  @Override\n  public DiGraphNode<N, E> getDirectedGraphNode(N nodeValue) {\n    return nodes.get(nodeValue);\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "LinkedDirectedGraph.getDirectedGraphNodes",
    "class_name": "com.google.javascript.jscomp.graph.LinkedDirectedGraph",
    "signature": "com.google.javascript.jscomp.graph.LinkedDirectedGraph.getDirectedGraphNodes()",
    "snippet": "  @Override\n  public Iterable<DiGraphNode<N, E>> getDirectedGraphNodes() {\n    return Collections.<DiGraphNode<N, E>>unmodifiableCollection(\n        nodes.values());\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "LinkedDirectedGraph.getDirectedSuccNodes",
    "class_name": "com.google.javascript.jscomp.graph.LinkedDirectedGraph",
    "signature": "com.google.javascript.jscomp.graph.LinkedDirectedGraph.getDirectedSuccNodes(DiGraphNode)",
    "snippet": "  @Override\n  public List<DiGraphNode<N, E>> getDirectedSuccNodes(\n      DiGraphNode<N, E> dNode) {\n    if (dNode == null) {\n      throw new IllegalArgumentException(dNode + \" is null\");\n    }\n    List<DiGraphNode<N, E>> nodeList = Lists.newArrayList();\n    for (DiGraphEdge<N, E> edge : dNode.getOutEdges()) {\n      nodeList.add(edge.getDestination());\n    }\n    return nodeList;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "LinkedDirectedGraph.getNode",
    "class_name": "com.google.javascript.jscomp.graph.LinkedDirectedGraph",
    "signature": "com.google.javascript.jscomp.graph.LinkedDirectedGraph.getNode(N)",
    "snippet": "  @Override\n  public GraphNode<N, E> getNode(N nodeValue) {\n    return getDirectedGraphNode(nodeValue);\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "LinkedDirectedGraph.getOutEdges",
    "class_name": "com.google.javascript.jscomp.graph.LinkedDirectedGraph",
    "signature": "com.google.javascript.jscomp.graph.LinkedDirectedGraph.getOutEdges(N)",
    "snippet": "  @Override\n  public List<DiGraphEdge<N, E>> getOutEdges(N nodeValue) {\n    LinkedDirectedGraphNode<N, E> node = getNodeOrFail(nodeValue);\n    return Collections.<DiGraphEdge<N, E>>unmodifiableList(node.getOutEdges());\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "LinkedDirectedGraph.isConnectedInDirection",
    "class_name": "com.google.javascript.jscomp.graph.LinkedDirectedGraph",
    "signature": "com.google.javascript.jscomp.graph.LinkedDirectedGraph.isConnectedInDirection(N,E,N)",
    "snippet": "  @Override\n  public boolean isConnectedInDirection(N n1, E edgeValue, N n2) {\n    return isConnectedInDirection(n1, Predicates.equalTo(edgeValue), n2);\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "LinkedDirectedGraph.isConnectedInDirection",
    "class_name": "com.google.javascript.jscomp.graph.LinkedDirectedGraph",
    "signature": "com.google.javascript.jscomp.graph.LinkedDirectedGraph.isConnectedInDirection(N,Predicate,N)",
    "snippet": "  private boolean isConnectedInDirection(N n1, Predicate<E> edgeMatcher, N n2) {\n    // Verify the nodes.\n    DiGraphNode<N, E> dNode1 = getNodeOrFail(n1);\n    DiGraphNode<N, E> dNode2 = getNodeOrFail(n2);\n    for (DiGraphEdge<N, E> outEdge : dNode1.getOutEdges()) {\n      if (outEdge.getDestination() == dNode2 &&\n          edgeMatcher.apply(outEdge.getValue())) {\n        return true;\n      }\n    }\n\n    return false;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "AnnotatedLinkedDirectedGraphNode.getAnnotation",
    "class_name": "com.google.javascript.jscomp.graph.LinkedDirectedGraph$AnnotatedLinkedDirectedGraphNode",
    "signature": "com.google.javascript.jscomp.graph.LinkedDirectedGraph$AnnotatedLinkedDirectedGraphNode.getAnnotation()",
    "snippet": "    @SuppressWarnings(\"unchecked\")\n    @Override\n    public <A extends Annotation> A getAnnotation() {\n      return (A) annotation;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "AnnotatedLinkedDirectedGraphNode.setAnnotation",
    "class_name": "com.google.javascript.jscomp.graph.LinkedDirectedGraph$AnnotatedLinkedDirectedGraphNode",
    "signature": "com.google.javascript.jscomp.graph.LinkedDirectedGraph$AnnotatedLinkedDirectedGraphNode.setAnnotation(Annotation)",
    "snippet": "    @Override\n    public void setAnnotation(Annotation data) {\n      annotation = data;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "LinkedDirectedGraphEdge.getDestination",
    "class_name": "com.google.javascript.jscomp.graph.LinkedDirectedGraph$LinkedDirectedGraphEdge",
    "signature": "com.google.javascript.jscomp.graph.LinkedDirectedGraph$LinkedDirectedGraphEdge.getDestination()",
    "snippet": "    @Override\n    public DiGraphNode<N, E> getDestination() {\n      return destNode;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "LinkedDirectedGraphEdge.getValue",
    "class_name": "com.google.javascript.jscomp.graph.LinkedDirectedGraph$LinkedDirectedGraphEdge",
    "signature": "com.google.javascript.jscomp.graph.LinkedDirectedGraph$LinkedDirectedGraphEdge.getValue()",
    "snippet": "    @Override\n    public E getValue() {\n      return value;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "LinkedDirectedGraphNode.getInEdges",
    "class_name": "com.google.javascript.jscomp.graph.LinkedDirectedGraph$LinkedDirectedGraphNode",
    "signature": "com.google.javascript.jscomp.graph.LinkedDirectedGraph$LinkedDirectedGraphNode.getInEdges()",
    "snippet": "    @Override\n    public List<DiGraphEdge<N, E>> getInEdges() {\n      return inEdgeList;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "LinkedDirectedGraphNode.getOutEdges",
    "class_name": "com.google.javascript.jscomp.graph.LinkedDirectedGraph$LinkedDirectedGraphNode",
    "signature": "com.google.javascript.jscomp.graph.LinkedDirectedGraph$LinkedDirectedGraphNode.getOutEdges()",
    "snippet": "    @Override\n    public List<DiGraphEdge<N, E>> getOutEdges() {\n      return outEdgeList;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "LinkedDirectedGraphNode.getValue",
    "class_name": "com.google.javascript.jscomp.graph.LinkedDirectedGraph$LinkedDirectedGraphNode",
    "signature": "com.google.javascript.jscomp.graph.LinkedDirectedGraph$LinkedDirectedGraphNode.getValue()",
    "snippet": "    @Override\n    public N getValue() {\n      return value;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "Config.Config",
    "class_name": "com.google.javascript.jscomp.parsing.Config",
    "signature": "com.google.javascript.jscomp.parsing.Config.Config(Set,Set,boolean,LanguageMode,boolean)",
    "snippet": "  Config(Set<String> annotationWhitelist, Set<String> suppressionNames,\n      boolean isIdeMode, LanguageMode languageMode,\n      boolean acceptConstKeyword) {\n    this.annotationNames = buildAnnotationNames(annotationWhitelist);\n    this.parseJsDocDocumentation = isIdeMode;\n    this.suppressionNames = suppressionNames;\n    this.isIdeMode = isIdeMode;\n    this.languageMode = languageMode;\n    this.acceptConstKeyword = acceptConstKeyword;\n  }",
    "comment": " Annotation names. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "Config.buildAnnotationNames",
    "class_name": "com.google.javascript.jscomp.parsing.Config",
    "signature": "com.google.javascript.jscomp.parsing.Config.buildAnnotationNames(Set)",
    "snippet": "  private static Map<String, Annotation> buildAnnotationNames(\n      Set<String> annotationWhitelist) {\n    ImmutableMap.Builder<String, Annotation> annotationBuilder =\n        ImmutableMap.builder();\n    annotationBuilder.putAll(Annotation.recognizedAnnotations);\n    for (String unrecognizedAnnotation : annotationWhitelist) {\n      if (!Annotation.recognizedAnnotations.containsKey(\n              unrecognizedAnnotation)) {\n        annotationBuilder.put(\n            unrecognizedAnnotation, Annotation.NOT_IMPLEMENTED);\n      }\n    }\n    return annotationBuilder.build();\n  }",
    "comment": " Create the annotation names from the user-specified annotation whitelist. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "IRFactory.createTemplateNode",
    "class_name": "com.google.javascript.jscomp.parsing.IRFactory",
    "signature": "com.google.javascript.jscomp.parsing.IRFactory.createTemplateNode()",
    "snippet": "  private Node createTemplateNode() {\n    // The Node type choice is arbitrary.\n    Node templateNode = new Node(Token.SCRIPT);\n    templateNode.setStaticSourceFile(sourceFile);\n    return templateNode;\n  }",
    "comment": "This reduces the cost of these properties to O(nodes) to O(files).",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "IRFactory.handleJsDoc",
    "class_name": "com.google.javascript.jscomp.parsing.IRFactory",
    "signature": "com.google.javascript.jscomp.parsing.IRFactory.handleJsDoc(AstNode,Node)",
    "snippet": "  private JSDocInfo handleJsDoc(AstNode node, Node irNode) {\n    Comment comment = node.getJsDocNode();\n    if (comment != null) {\n      JsDocInfoParser jsDocParser = createJsDocInfoParser(comment, irNode);\n      comment.setParsed(true);\n      if (!handlePossibleFileOverviewJsDoc(jsDocParser)) {\n        return jsDocParser.retrieveAndResetParsedJSDocInfo();\n      }\n    }\n    return null;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "IRFactory.justTransform",
    "class_name": "com.google.javascript.jscomp.parsing.IRFactory",
    "signature": "com.google.javascript.jscomp.parsing.IRFactory.justTransform(AstNode)",
    "snippet": "  private Node justTransform(AstNode node) {\n    return transformDispatcher.process(node);\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "IRFactory.maybeSetLengthFrom",
    "class_name": "com.google.javascript.jscomp.parsing.IRFactory",
    "signature": "com.google.javascript.jscomp.parsing.IRFactory.maybeSetLengthFrom(Node,AstNode)",
    "snippet": "  private void maybeSetLengthFrom(Node node, AstNode source) {\n    if (config.isIdeMode) {\n      node.setLength(source.getLength());\n    }\n  }",
    "comment": "Set the length on the node if we're in IDE mode.",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "IRFactory.newNode",
    "class_name": "com.google.javascript.jscomp.parsing.IRFactory",
    "signature": "com.google.javascript.jscomp.parsing.IRFactory.newNode(int)",
    "snippet": "  private Node newNode(int type) {\n    return new Node(type).clonePropsFrom(templateNode);\n  }",
    "comment": "Simple helper to create nodes and set the initial node properties.",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "IRFactory.newNode",
    "class_name": "com.google.javascript.jscomp.parsing.IRFactory",
    "signature": "com.google.javascript.jscomp.parsing.IRFactory.newNode(int,Node,Node)",
    "snippet": "  private Node newNode(int type, Node child1, Node child2) {\n    return new Node(type, child1, child2).clonePropsFrom(templateNode);\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "IRFactory.newNode",
    "class_name": "com.google.javascript.jscomp.parsing.IRFactory",
    "signature": "com.google.javascript.jscomp.parsing.IRFactory.newNode(int,Node,Node,Node)",
    "snippet": "  private Node newNode(int type, Node child1, Node child2, Node child3) {\n    return new Node(type, child1, child2, child3).clonePropsFrom(templateNode);\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "IRFactory.newNumberNode",
    "class_name": "com.google.javascript.jscomp.parsing.IRFactory",
    "signature": "com.google.javascript.jscomp.parsing.IRFactory.newNumberNode(Double)",
    "snippet": "  private Node newNumberNode(Double value) {\n    return Node.newNumber(value).clonePropsFrom(templateNode);\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "IRFactory.newStringNode",
    "class_name": "com.google.javascript.jscomp.parsing.IRFactory",
    "signature": "com.google.javascript.jscomp.parsing.IRFactory.newStringNode(int,String)",
    "snippet": "  private Node newStringNode(int type, String value) {\n    return Node.newString(type, value).clonePropsFrom(templateNode);\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "IRFactory.position2charno",
    "class_name": "com.google.javascript.jscomp.parsing.IRFactory",
    "signature": "com.google.javascript.jscomp.parsing.IRFactory.position2charno(int)",
    "snippet": "  private int position2charno(int position) {\n    int lineIndex = sourceString.lastIndexOf('\\n', position);\n    if (lineIndex == -1) {\n      return position;\n    } else {\n      // Subtract one for initial position being 0.\n      return position - lineIndex - 1;\n    }\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "IRFactory.setFileOverviewJsDoc",
    "class_name": "com.google.javascript.jscomp.parsing.IRFactory",
    "signature": "com.google.javascript.jscomp.parsing.IRFactory.setFileOverviewJsDoc(Node)",
    "snippet": "  private void setFileOverviewJsDoc(Node irNode) {\n    // Only after we've seen all @fileoverview entries, attach the\n    // last one to the root node, and copy the found license strings\n    // to that node.\n    irNode.setJSDocInfo(rootNodeJsDocHolder.getJSDocInfo());\n    if (fileOverviewInfo != null) {\n      if ((irNode.getJSDocInfo() != null) &&\n          (irNode.getJSDocInfo().getLicense() != null)) {\n        fileOverviewInfo.setLicense(irNode.getJSDocInfo().getLicense());\n      }\n      irNode.setJSDocInfo(fileOverviewInfo);\n    }\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "IRFactory.setSourceInfo",
    "class_name": "com.google.javascript.jscomp.parsing.IRFactory",
    "signature": "com.google.javascript.jscomp.parsing.IRFactory.setSourceInfo(Node,AstNode)",
    "snippet": "  private void setSourceInfo(Node irNode, AstNode node) {\n    // If we have a named function, set the position to that of the name.\n    if (irNode.getType() == Token.FUNCTION &&\n        irNode.getFirstChild().getLineno() != -1) {\n      irNode.setLineno(irNode.getFirstChild().getLineno());\n      irNode.setCharno(irNode.getFirstChild().getCharno());\n      maybeSetLengthFrom(irNode, node);\n    } else {\n      if (irNode.getLineno() == -1) {\n        // If we didn't already set the line, then set it now.  This avoids\n        // cases like ParenthesizedExpression where we just return a previous\n        // node, but don't want the new node to get its parent's line number.\n        int lineno = node.getLineno();\n        irNode.setLineno(lineno);\n        int charno = position2charno(node.getAbsolutePosition());\n        irNode.setCharno(charno);\n        maybeSetLengthFrom(irNode, node);\n      }\n    }\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "IRFactory.transform",
    "class_name": "com.google.javascript.jscomp.parsing.IRFactory",
    "signature": "com.google.javascript.jscomp.parsing.IRFactory.transform(AstNode)",
    "snippet": "  private Node transform(AstNode node) {\n    Node irNode = justTransform(node);\n    JSDocInfo jsDocInfo = handleJsDoc(node, irNode);\n    if (jsDocInfo != null) {\n      irNode.setJSDocInfo(jsDocInfo);\n    }\n    setSourceInfo(irNode, node);\n    return irNode;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "IRFactory.transformBlock",
    "class_name": "com.google.javascript.jscomp.parsing.IRFactory",
    "signature": "com.google.javascript.jscomp.parsing.IRFactory.transformBlock(AstNode)",
    "snippet": "  private Node transformBlock(AstNode node) {\n    Node irNode = transform(node);\n    if (irNode.getType() != Token.BLOCK) {\n      if (irNode.getType() == Token.EMPTY) {\n        irNode.setType(Token.BLOCK);\n        irNode.setWasEmptyNode(true);\n      } else {\n        Node newBlock = newNode(Token.BLOCK, irNode);\n        newBlock.setLineno(irNode.getLineno());\n        newBlock.setCharno(irNode.getCharno());\n        maybeSetLengthFrom(newBlock, node);\n        irNode = newBlock;\n      }\n    }\n    return irNode;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "IRFactory.transformTokenType",
    "class_name": "com.google.javascript.jscomp.parsing.IRFactory",
    "signature": "com.google.javascript.jscomp.parsing.IRFactory.transformTokenType(int)",
    "snippet": "  private static int transformTokenType(int token) {\n    switch (token) {\n      case com.google.javascript.jscomp.mozilla.rhino.Token.RETURN:\n        return Token.RETURN;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.BITOR:\n        return Token.BITOR;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.BITXOR:\n        return Token.BITXOR;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.BITAND:\n        return Token.BITAND;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.EQ:\n        return Token.EQ;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.NE:\n        return Token.NE;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.LT:\n        return Token.LT;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.LE:\n        return Token.LE;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.GT:\n        return Token.GT;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.GE:\n        return Token.GE;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.LSH:\n        return Token.LSH;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.RSH:\n        return Token.RSH;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.URSH:\n        return Token.URSH;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.ADD:\n        return Token.ADD;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.SUB:\n        return Token.SUB;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.MUL:\n        return Token.MUL;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.DIV:\n        return Token.DIV;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.MOD:\n        return Token.MOD;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.NOT:\n        return Token.NOT;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.BITNOT:\n        return Token.BITNOT;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.POS:\n        return Token.POS;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.NEG:\n        return Token.NEG;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.NEW:\n        return Token.NEW;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.DELPROP:\n        return Token.DELPROP;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.TYPEOF:\n        return Token.TYPEOF;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.GETPROP:\n        return Token.GETPROP;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.SETPROP:\n        return Token.SETPROP;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.GETELEM:\n        return Token.GETELEM;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.SETELEM:\n        return Token.SETELEM;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.CALL:\n        return Token.CALL;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.NAME:\n        return Token.NAME;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.NUMBER:\n        return Token.NUMBER;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.STRING:\n        return Token.STRING;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.NULL:\n        return Token.NULL;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.THIS:\n        return Token.THIS;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.FALSE:\n        return Token.FALSE;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.TRUE:\n        return Token.TRUE;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.SHEQ:\n        return Token.SHEQ;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.SHNE:\n        return Token.SHNE;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.REGEXP:\n        return Token.REGEXP;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.THROW:\n        return Token.THROW;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.IN:\n        return Token.IN;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.INSTANCEOF:\n        return Token.INSTANCEOF;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.ARRAYLIT:\n        return Token.ARRAYLIT;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.OBJECTLIT:\n        return Token.OBJECTLIT;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.TRY:\n        return Token.TRY;\n      // The LP represents a parameter list\n      case com.google.javascript.jscomp.mozilla.rhino.Token.LP:\n        return Token.LP;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.COMMA:\n        return Token.COMMA;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.ASSIGN:\n        return Token.ASSIGN;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.ASSIGN_BITOR:\n        return Token.ASSIGN_BITOR;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.ASSIGN_BITXOR:\n        return Token.ASSIGN_BITXOR;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.ASSIGN_BITAND:\n        return Token.ASSIGN_BITAND;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.ASSIGN_LSH:\n        return Token.ASSIGN_LSH;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.ASSIGN_RSH:\n        return Token.ASSIGN_RSH;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.ASSIGN_URSH:\n        return Token.ASSIGN_URSH;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.ASSIGN_ADD:\n        return Token.ASSIGN_ADD;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.ASSIGN_SUB:\n        return Token.ASSIGN_SUB;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.ASSIGN_MUL:\n        return Token.ASSIGN_MUL;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.ASSIGN_DIV:\n        return Token.ASSIGN_DIV;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.ASSIGN_MOD:\n        return Token.ASSIGN_MOD;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.HOOK:\n        return Token.HOOK;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.COLON:\n        return Token.COLON;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.OR:\n        return Token.OR;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.AND:\n        return Token.AND;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.INC:\n        return Token.INC;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.DEC:\n        return Token.DEC;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.FUNCTION:\n        return Token.FUNCTION;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.IF:\n        return Token.IF;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.ELSE:\n        return Token.ELSE;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.SWITCH:\n        return Token.SWITCH;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.CASE:\n        return Token.CASE;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.DEFAULT:\n        return Token.DEFAULT;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.WHILE:\n        return Token.WHILE;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.DO:\n        return Token.DO;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.FOR:\n        return Token.FOR;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.BREAK:\n        return Token.BREAK;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.CONTINUE:\n        return Token.CONTINUE;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.VAR:\n        return Token.VAR;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.WITH:\n        return Token.WITH;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.CATCH:\n        return Token.CATCH;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.FINALLY:\n        return Token.FINALLY;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.VOID:\n        return Token.VOID;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.EMPTY:\n        return Token.EMPTY;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.BLOCK:\n        return Token.BLOCK;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.LABEL:\n        return Token.LABEL;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.EXPR_VOID:\n      case com.google.javascript.jscomp.mozilla.rhino.Token.EXPR_RESULT:\n        return Token.EXPR_RESULT;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.SCRIPT:\n        return Token.SCRIPT;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.GET:\n        return Token.GET;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.SET:\n        return Token.SET;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.CONST:\n        return Token.CONST;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.DEBUGGER:\n        return Token.DEBUGGER;\n    }\n\n    // Token without name\n    throw new IllegalStateException(String.valueOf(token));\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "IRFactory.transformTree",
    "class_name": "com.google.javascript.jscomp.parsing.IRFactory",
    "signature": "com.google.javascript.jscomp.parsing.IRFactory.transformTree(AstRoot,StaticSourceFile,String,Config,ErrorReporter)",
    "snippet": "  public static Node transformTree(AstRoot node,\n                                   StaticSourceFile sourceFile,\n                                   String sourceString,\n                                   Config config,\n                                   ErrorReporter errorReporter) {\n    IRFactory irFactory = new IRFactory(sourceString, sourceFile,\n        config, errorReporter);\n    Node irNode = irFactory.transform(node);\n\n    if (node.getComments() != null) {\n      for (Comment comment : node.getComments()) {\n        if (comment.getCommentType() == CommentType.JSDOC &&\n            !comment.isParsed()) {\n          irFactory.handlePossibleFileOverviewJsDoc(comment, irNode);\n        } else if (comment.getCommentType() == CommentType.BLOCK) {\n          irFactory.handleBlockComment(comment);\n        }\n      }\n    }\n\n    irFactory.setFileOverviewJsDoc(irNode);\n\n    return irNode;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "TransformDispatcher.isDirective",
    "class_name": "com.google.javascript.jscomp.parsing.IRFactory$TransformDispatcher",
    "signature": "com.google.javascript.jscomp.parsing.IRFactory$TransformDispatcher.isDirective(Node)",
    "snippet": "    private boolean isDirective(Node n) {\n      if (n == null) return false;\n\n      int nType = n.getType();\n      return (nType == Token.EXPR_RESULT || nType == Token.EXPR_VOID) &&\n          n.getFirstChild().getType() == Token.STRING &&\n          ALLOWED_DIRECTIVES.contains(n.getFirstChild().getString());\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "TransformDispatcher.isReservedKeyword",
    "class_name": "com.google.javascript.jscomp.parsing.IRFactory$TransformDispatcher",
    "signature": "com.google.javascript.jscomp.parsing.IRFactory$TransformDispatcher.isReservedKeyword(String)",
    "snippet": "    private boolean isReservedKeyword(String identifier) {\n      return reservedKeywords != null && reservedKeywords.contains(identifier);\n    }",
    "comment": " @return Whether the ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "TransformDispatcher.parseDirectives",
    "class_name": "com.google.javascript.jscomp.parsing.IRFactory$TransformDispatcher",
    "signature": "com.google.javascript.jscomp.parsing.IRFactory$TransformDispatcher.parseDirectives(Node)",
    "snippet": "    private void parseDirectives(Node node) {\n      // Remove all the directives, and encode them in the AST.\n      Set<String> directives = null;\n      while (isDirective(node.getFirstChild())) {\n        String directive = node.removeFirstChild().getFirstChild().getString();\n        if (directives == null) {\n          directives = Sets.newHashSet(directive);\n        } else {\n          directives.add(directive);\n        }\n      }\n\n      if (directives != null) {\n        node.setDirectives(directives);\n      }\n    }",
    "comment": " Parse the directives, encode them in the AST, and remove their nodes.  For information on ES5 directives, see section 14.1 of Ecma-262, Edition 5.  It would be nice if Rhino would eventually take care of this for us, but right now their directive-processing is a one-off. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "TransformDispatcher.processArrayLiteral",
    "class_name": "com.google.javascript.jscomp.parsing.IRFactory$TransformDispatcher",
    "signature": "com.google.javascript.jscomp.parsing.IRFactory$TransformDispatcher.processArrayLiteral(ArrayLiteral)",
    "snippet": "    @Override\n    Node processArrayLiteral(ArrayLiteral literalNode) {\n      if (literalNode.isDestructuring()) {\n        reportDestructuringAssign(literalNode);\n      }\n\n      Node node = newNode(Token.ARRAYLIT);\n      for (AstNode child : literalNode.getElements()) {\n        Node c = transform(child);\n        node.addChildToBack(c);\n      }\n      return node;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "TransformDispatcher.processAstRoot",
    "class_name": "com.google.javascript.jscomp.parsing.IRFactory$TransformDispatcher",
    "signature": "com.google.javascript.jscomp.parsing.IRFactory$TransformDispatcher.processAstRoot(AstRoot)",
    "snippet": "    @Override\n    Node processAstRoot(AstRoot rootNode) {\n      Node node = newNode(Token.SCRIPT);\n      for (com.google.javascript.jscomp.mozilla.rhino.Node child : rootNode) {\n        node.addChildToBack(transform((AstNode)child));\n      }\n      parseDirectives(node);\n      return node;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "TransformDispatcher.processBlock",
    "class_name": "com.google.javascript.jscomp.parsing.IRFactory$TransformDispatcher",
    "signature": "com.google.javascript.jscomp.parsing.IRFactory$TransformDispatcher.processBlock(Block)",
    "snippet": "    @Override\n    Node processBlock(Block blockNode) {\n      return processGeneric(blockNode);\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "TransformDispatcher.processElementGet",
    "class_name": "com.google.javascript.jscomp.parsing.IRFactory$TransformDispatcher",
    "signature": "com.google.javascript.jscomp.parsing.IRFactory$TransformDispatcher.processElementGet(ElementGet)",
    "snippet": "    @Override\n    Node processElementGet(ElementGet getNode) {\n      return newNode(\n          Token.GETELEM,\n          transform(getNode.getTarget()),\n          transform(getNode.getElement()));\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "TransformDispatcher.processForInLoop",
    "class_name": "com.google.javascript.jscomp.parsing.IRFactory$TransformDispatcher",
    "signature": "com.google.javascript.jscomp.parsing.IRFactory$TransformDispatcher.processForInLoop(ForInLoop)",
    "snippet": "    @Override\n    Node processForInLoop(ForInLoop loopNode) {\n      return newNode(\n          Token.FOR,\n          transform(loopNode.getIterator()),\n          transform(loopNode.getIteratedObject()),\n          transformBlock(loopNode.getBody()));\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "TransformDispatcher.processFunctionNode",
    "class_name": "com.google.javascript.jscomp.parsing.IRFactory$TransformDispatcher",
    "signature": "com.google.javascript.jscomp.parsing.IRFactory$TransformDispatcher.processFunctionNode(FunctionNode)",
    "snippet": "    @Override\n    Node processFunctionNode(FunctionNode functionNode) {\n      Name name = functionNode.getFunctionName();\n      Boolean isUnnamedFunction = false;\n      if (name == null) {\n        int functionType = functionNode.getFunctionType();\n        if (functionType != FunctionNode.FUNCTION_EXPRESSION) {\n          errorReporter.error(\n            \"unnamed function statement\",\n            sourceName,\n            functionNode.getLineno(), \"\", 0);\n        }\n        name = new Name();\n        name.setIdentifier(\"\");\n        isUnnamedFunction = true;\n      }\n      Node node = newNode(Token.FUNCTION);\n      Node newName = transform(name);\n      if (isUnnamedFunction) {\n        // Old Rhino tagged the empty name node with the line number of the\n        // declaration.\n        newName.setLineno(functionNode.getLineno());\n        // TODO(bowdidge) Mark line number of paren correctly.\n        // Same problem as below - the left paren might not be on the\n        // same line as the function keyword.\n        int lpColumn = functionNode.getAbsolutePosition() +\n            functionNode.getLp();\n        newName.setCharno(position2charno(lpColumn));\n        maybeSetLengthFrom(newName, name);\n      }\n\n      node.addChildToBack(newName);\n      Node lp = newNode(Token.LP);\n      // The left paren's complicated because it's not represented by an\n      // AstNode, so there's nothing that has the actual line number that it\n      // appeared on.  We know the paren has to appear on the same line as the\n      // function name (or else a semicolon will be inserted.)  If there's no\n      // function name, assume the paren was on the same line as the function.\n      // TODO(bowdidge): Mark line number of paren correctly.\n      Name fnName = functionNode.getFunctionName();\n      if (fnName != null) {\n        lp.setLineno(fnName.getLineno());\n      } else {\n        lp.setLineno(functionNode.getLineno());\n      }\n      int lparenCharno = functionNode.getLp() +\n          functionNode.getAbsolutePosition();\n\n      lp.setCharno(position2charno(lparenCharno));\n      for (AstNode param : functionNode.getParams()) {\n        lp.addChildToBack(transform(param));\n      }\n      node.addChildToBack(lp);\n\n      Node bodyNode = transform(functionNode.getBody());\n      parseDirectives(bodyNode);\n      node.addChildToBack(bodyNode);\n     return node;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "TransformDispatcher.processGeneric",
    "class_name": "com.google.javascript.jscomp.parsing.IRFactory$TransformDispatcher",
    "signature": "com.google.javascript.jscomp.parsing.IRFactory$TransformDispatcher.processGeneric(Node)",
    "snippet": "    private Node processGeneric(\n        com.google.javascript.jscomp.mozilla.rhino.Node n) {\n      Node node = newNode(transformTokenType(n.getType()));\n      for (com.google.javascript.jscomp.mozilla.rhino.Node child : n) {\n        node.addChildToBack(transform((AstNode)child));\n      }\n      return node;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "TransformDispatcher.processLabel",
    "class_name": "com.google.javascript.jscomp.parsing.IRFactory$TransformDispatcher",
    "signature": "com.google.javascript.jscomp.parsing.IRFactory$TransformDispatcher.processLabel(Label)",
    "snippet": "    @Override\n    Node processLabel(Label labelNode) {\n      return newStringNode(Token.LABEL_NAME, labelNode.getName());\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "TransformDispatcher.processLabeledStatement",
    "class_name": "com.google.javascript.jscomp.parsing.IRFactory$TransformDispatcher",
    "signature": "com.google.javascript.jscomp.parsing.IRFactory$TransformDispatcher.processLabeledStatement(LabeledStatement)",
    "snippet": "    @Override\n    Node processLabeledStatement(LabeledStatement statementNode) {\n      Node node = newNode(Token.LABEL);\n      Node prev = null;\n      Node cur = node;\n      for (Label label : statementNode.getLabels()) {\n        if (prev != null) {\n          prev.addChildToBack(cur);\n        }\n        cur.addChildToBack(transform(label));\n\n        cur.setLineno(label.getLineno());\n        maybeSetLengthFrom(cur, label);\n\n        int clauseAbsolutePosition =\n            position2charno(label.getAbsolutePosition());\n        cur.setCharno(clauseAbsolutePosition);\n\n        prev = cur;\n        cur = newNode(Token.LABEL);\n      }\n      prev.addChildToBack(transform(statementNode.getStatement()));\n      return node;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "TransformDispatcher.processName",
    "class_name": "com.google.javascript.jscomp.parsing.IRFactory$TransformDispatcher",
    "signature": "com.google.javascript.jscomp.parsing.IRFactory$TransformDispatcher.processName(Name)",
    "snippet": "    @Override\n    Node processName(Name nameNode) {\n      return processName(nameNode, false);\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "TransformDispatcher.processName",
    "class_name": "com.google.javascript.jscomp.parsing.IRFactory$TransformDispatcher",
    "signature": "com.google.javascript.jscomp.parsing.IRFactory$TransformDispatcher.processName(Name,boolean)",
    "snippet": "    Node processName(Name nameNode, boolean asString) {\n      if (asString) {\n        return newStringNode(Token.STRING, nameNode.getIdentifier());\n      } else {\n        if (isReservedKeyword(nameNode.getIdentifier())) {\n          errorReporter.error(\n            \"identifier is a reserved word\",\n            sourceName,\n            nameNode.getLineno(), \"\", 0);\n        }\n        return newStringNode(Token.NAME, nameNode.getIdentifier());\n      }\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "TransformDispatcher.processNumberLiteral",
    "class_name": "com.google.javascript.jscomp.parsing.IRFactory$TransformDispatcher",
    "signature": "com.google.javascript.jscomp.parsing.IRFactory$TransformDispatcher.processNumberLiteral(NumberLiteral)",
    "snippet": "    @Override\n    Node processNumberLiteral(NumberLiteral literalNode) {\n      return newNumberNode(literalNode.getNumber());\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "TransformDispatcher.processScope",
    "class_name": "com.google.javascript.jscomp.parsing.IRFactory$TransformDispatcher",
    "signature": "com.google.javascript.jscomp.parsing.IRFactory$TransformDispatcher.processScope(Scope)",
    "snippet": "    @Override\n    Node processScope(Scope scopeNode) {\n      return processGeneric(scopeNode);\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "TransformDispatcher.processVariableDeclaration",
    "class_name": "com.google.javascript.jscomp.parsing.IRFactory$TransformDispatcher",
    "signature": "com.google.javascript.jscomp.parsing.IRFactory$TransformDispatcher.processVariableDeclaration(VariableDeclaration)",
    "snippet": "    @Override\n    Node processVariableDeclaration(VariableDeclaration declarationNode) {\n      if (!config.acceptConstKeyword && declarationNode.getType() ==\n          com.google.javascript.jscomp.mozilla.rhino.Token.CONST) {\n        processIllegalToken(declarationNode);\n      }\n\n      Node node = newNode(Token.VAR);\n      for (VariableInitializer child : declarationNode.getVariables()) {\n        node.addChildToBack(transform(child));\n      }\n      return node;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "TransformDispatcher.processVariableInitializer",
    "class_name": "com.google.javascript.jscomp.parsing.IRFactory$TransformDispatcher",
    "signature": "com.google.javascript.jscomp.parsing.IRFactory$TransformDispatcher.processVariableInitializer(VariableInitializer)",
    "snippet": "    @Override\n    Node processVariableInitializer(VariableInitializer initializerNode) {\n      Node node = transform(initializerNode.getTarget());\n      if (initializerNode.getInitializer() != null) {\n        node.addChildToBack(transform(initializerNode.getInitializer()));\n        node.setLineno(node.getLineno());\n        maybeSetLengthFrom(node, initializerNode);\n      }\n      return node;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "ParserRunner.createConfig",
    "class_name": "com.google.javascript.jscomp.parsing.ParserRunner",
    "signature": "com.google.javascript.jscomp.parsing.ParserRunner.createConfig(boolean,LanguageMode,boolean,Set)",
    "snippet": "  public static Config createConfig(boolean isIdeMode,\n                                    LanguageMode languageMode,\n                                    boolean acceptConstKeyword,\n                                    Set<String> extraAnnotationNames) {\n    initResourceConfig();\n    Set<String> effectiveAnnotationNames;\n    if (extraAnnotationNames == null) {\n      effectiveAnnotationNames = annotationNames;\n    } else {\n      effectiveAnnotationNames = new HashSet<String>(annotationNames);\n      effectiveAnnotationNames.addAll(extraAnnotationNames);\n    }\n    return new Config(effectiveAnnotationNames, suppressionNames,\n        isIdeMode, languageMode, acceptConstKeyword);\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "ParserRunner.extractList",
    "class_name": "com.google.javascript.jscomp.parsing.ParserRunner",
    "signature": "com.google.javascript.jscomp.parsing.ParserRunner.extractList(String)",
    "snippet": "  private static Set<String> extractList(String configProp) {\n    String[] names = configProp.split(\",\");\n    Set<String> trimmedNames = Sets.newHashSet();\n    for (String name : names) {\n      trimmedNames.add(name.trim());\n    }\n    return ImmutableSet.copyOf(trimmedNames);\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "ParserRunner.initResourceConfig",
    "class_name": "com.google.javascript.jscomp.parsing.ParserRunner",
    "signature": "com.google.javascript.jscomp.parsing.ParserRunner.initResourceConfig()",
    "snippet": "  private static synchronized void initResourceConfig() {\n    if (annotationNames != null) {\n      return;\n    }\n\n    ResourceBundle config = ResourceBundle.getBundle(configResource);\n    annotationNames = extractList(config.getString(\"jsdoc.annotations\"));\n    suppressionNames = extractList(config.getString(\"jsdoc.suppressions\"));\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "ParserRunner.parse",
    "class_name": "com.google.javascript.jscomp.parsing.ParserRunner",
    "signature": "com.google.javascript.jscomp.parsing.ParserRunner.parse(StaticSourceFile,String,Config,ErrorReporter,Logger)",
    "snippet": "  public static Node parse(StaticSourceFile sourceFile,\n                           String sourceString,\n                           Config config,\n                           ErrorReporter errorReporter,\n                           Logger logger) throws IOException {\n    Context cx = Context.enter();\n    cx.setErrorReporter(errorReporter);\n    cx.setLanguageVersion(Context.VERSION_1_5);\n    CompilerEnvirons compilerEnv = new CompilerEnvirons();\n    compilerEnv.initFromContext(cx);\n    compilerEnv.setRecordingComments(true);\n    compilerEnv.setRecordingLocalJsDocComments(true);\n    // ES5 specifically allows trailing commas\n    compilerEnv.setWarnTrailingComma(\n        config.languageMode == LanguageMode.ECMASCRIPT3);\n\n    if (config.isIdeMode || config.languageMode != LanguageMode.ECMASCRIPT3) {\n      // Do our own identifier check for ECMASCRIPT 5\n      compilerEnv.setReservedKeywordAsIdentifier(true);\n      compilerEnv.setAllowKeywordAsObjectPropertyName(true);\n    }\n\n    if (config.isIdeMode) {\n      compilerEnv.setAllowMemberExprAsFunctionName(true);\n    }\n\n    Parser p = new Parser(compilerEnv, errorReporter);\n    AstRoot astRoot = null;\n    try {\n      astRoot = p.parse(sourceString, sourceFile.getName(), 1);\n    } catch (EvaluatorException e) {\n      logger.info(\n          \"Error parsing \" + sourceFile.getName() + \": \" + e.getMessage());\n    } finally {\n      Context.exit();\n    }\n    Node root = null;\n    if (astRoot != null) {\n      root = IRFactory.transformTree(\n          astRoot, sourceFile, sourceString, config, errorReporter);\n      root.setIsSyntheticBlock(true);\n    }\n    return root;\n  }",
    "comment": " Parses the JavaScript text given by a reader.  @param sourceString Source code from the file. @param errorReporter An error. @param logger A logger. @return The AST of the given text. @throws IOException ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "TypeSafeDispatcher.process",
    "class_name": "com.google.javascript.jscomp.parsing.TypeSafeDispatcher",
    "signature": "com.google.javascript.jscomp.parsing.TypeSafeDispatcher.process(AstNode)",
    "snippet": "  public T process(AstNode node) {\n    switch (node.getType()) {\n      case Token.ADD:\n      case Token.AND:\n      case Token.BITAND:\n      case Token.BITOR:\n      case Token.BITXOR:\n      case Token.COMMA:\n      case Token.DIV:\n      case Token.EQ:\n      case Token.GE:\n      case Token.GT:\n      case Token.IN:\n      case Token.INSTANCEOF:\n      case Token.LE:\n      case Token.LSH:\n      case Token.LT:\n      case Token.MOD:\n      case Token.MUL:\n      case Token.NE:\n      case Token.OR:\n      case Token.RSH:\n      case Token.SHEQ:\n      case Token.SHNE:\n      case Token.SUB:\n      case Token.URSH:\n        return processInfixExpression((InfixExpression) node);\n      case Token.ARRAYLIT:\n        return processArrayLiteral((ArrayLiteral) node);\n      case Token.ASSIGN:\n      case Token.ASSIGN_ADD:\n      case Token.ASSIGN_BITAND:\n      case Token.ASSIGN_BITOR:\n      case Token.ASSIGN_BITXOR:\n      case Token.ASSIGN_DIV:\n      case Token.ASSIGN_LSH:\n      case Token.ASSIGN_MOD:\n      case Token.ASSIGN_MUL:\n      case Token.ASSIGN_RSH:\n      case Token.ASSIGN_SUB:\n      case Token.ASSIGN_URSH:\n        return processAssignment((Assignment) node);\n      case Token.BITNOT:\n      case Token.DEC:\n      case Token.DELPROP:\n      case Token.INC:\n      case Token.NEG:\n      case Token.NOT:\n      case Token.POS:\n      case Token.TYPEOF:\n      case Token.VOID:\n        return processUnaryExpression((UnaryExpression) node);\n      case Token.BLOCK:\n        if (node instanceof Block) {\n          return processBlock((Block) node);\n        } else  if (node instanceof Scope) {\n          return processScope((Scope) node);\n        } else {\n          throw new IllegalStateException(\"Unexpected node type.  class: \" +\n                                          node.getClass() +\n                                          \" type: \" +\n                                          Token.typeToName(node.getType()));\n        }\n      case Token.BREAK:\n        return processBreakStatement((BreakStatement) node);\n      case Token.CALL:\n        return processFunctionCall((FunctionCall) node);\n      case Token.CASE:\n      case Token.DEFAULT:\n        return processSwitchCase((SwitchCase) node);\n      case Token.CATCH:\n      case Token.FINALLY:\n        return processCatchClause((CatchClause) node);\n      case Token.COLON:\n        return processObjectProperty((ObjectProperty) node);\n      case Token.CONTINUE:\n        return processContinueStatement((ContinueStatement) node);\n      case Token.DO:\n        return processDoLoop((DoLoop) node);\n      case Token.EMPTY:\n        return processEmptyExpression((EmptyExpression) node);\n      case Token.EXPR_RESULT:\n      case Token.EXPR_VOID:\n        if (node instanceof ExpressionStatement) {\n          return processExpressionStatement((ExpressionStatement) node);\n        } else  if (node instanceof LabeledStatement) {\n          return processLabeledStatement((LabeledStatement) node);\n        } else {\n          throw new IllegalStateException(\"Unexpected node type.  class: \" +\n                                          node.getClass() +\n                                          \" type: \" +\n                                          Token.typeToName(node.getType()));\n        }\n      case Token.DEBUGGER:\n      case Token.FALSE:\n      case Token.NULL:\n      case Token.THIS:\n      case Token.TRUE:\n        return processKeywordLiteral((KeywordLiteral) node);\n      case Token.FOR:\n        if (node instanceof ForInLoop) {\n          return processForInLoop((ForInLoop) node);\n        } else  if (node instanceof ForLoop) {\n          return processForLoop((ForLoop) node);\n        } else {\n          throw new IllegalStateException(\"Unexpected node type.  class: \" +\n                                          node.getClass() +\n                                          \" type: \" +\n                                          Token.typeToName(node.getType()));\n        }\n      case Token.FUNCTION:\n        return processFunctionNode((FunctionNode) node);\n      case Token.GETELEM:\n        return processElementGet((ElementGet) node);\n      case Token.GETPROP:\n        return processPropertyGet((PropertyGet) node);\n      case Token.HOOK:\n        return processConditionalExpression((ConditionalExpression) node);\n      case Token.IF:\n        return processIfStatement((IfStatement) node);\n      case Token.LABEL:\n        return processLabel((Label) node);\n      case Token.LP:\n        return processParenthesizedExpression((ParenthesizedExpression) node);\n      case Token.NAME:\n        return processName((Name) node);\n      case Token.NEW:\n        return processNewExpression((NewExpression) node);\n      case Token.NUMBER:\n        return processNumberLiteral((NumberLiteral) node);\n      case Token.OBJECTLIT:\n        return processObjectLiteral((ObjectLiteral) node);\n      case Token.REGEXP:\n        return processRegExpLiteral((RegExpLiteral) node);\n      case Token.RETURN:\n        return processReturnStatement((ReturnStatement) node);\n      case Token.SCRIPT:\n        return processAstRoot((AstRoot) node);\n      case Token.STRING:\n        return processStringLiteral((StringLiteral) node);\n      case Token.SWITCH:\n        return processSwitchStatement((SwitchStatement) node);\n      case Token.THROW:\n        return processThrowStatement((ThrowStatement) node);\n      case Token.TRY:\n        return processTryStatement((TryStatement) node);\n      case Token.CONST:\n      case Token.VAR:\n        if (node instanceof VariableDeclaration) {\n          return processVariableDeclaration((VariableDeclaration) node);\n        } else  if (node instanceof VariableInitializer) {\n          return processVariableInitializer((VariableInitializer) node);\n        } else {\n          throw new IllegalStateException(\"Unexpected node type.  class: \" +\n                                          node.getClass() +\n                                          \" type: \" +\n                                          Token.typeToName(node.getType()));\n        }\n      case Token.WHILE:\n        return processWhileLoop((WhileLoop) node);\n      case Token.WITH:\n        return processWithStatement((WithStatement) node);\n    }\n    return processIllegalToken(node);\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "Context.getCurrentContext",
    "class_name": "com.google.javascript.rhino.Context",
    "signature": "com.google.javascript.rhino.Context.getCurrentContext()",
    "snippet": "    public static Context getCurrentContext() {\n        return threadContexts.get();\n    }",
    "comment": " Get the current Context.  The current Context is per-thread; this method looks up the Context associated with the current thread. <p>  @return the Context associated with the current thread, or null if no context is associated with the current thread. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "InputId.InputId",
    "class_name": "com.google.javascript.rhino.InputId",
    "signature": "com.google.javascript.rhino.InputId.InputId(String)",
    "snippet": "  public InputId(String id) {\n    this.id = id;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "InputId.hashCode",
    "class_name": "com.google.javascript.rhino.InputId",
    "signature": "com.google.javascript.rhino.InputId.hashCode()",
    "snippet": "  @Override\n  public int hashCode() {\n    return id.hashCode();\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "Node.Node",
    "class_name": "com.google.javascript.rhino.Node",
    "signature": "com.google.javascript.rhino.Node.Node(int)",
    "snippet": "  public Node(int nodeType) {\n    type = nodeType;\n    parent = null;\n    sourcePosition = -1;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "Node.Node",
    "class_name": "com.google.javascript.rhino.Node",
    "signature": "com.google.javascript.rhino.Node.Node(int,Node)",
    "snippet": "  public Node(int nodeType, Node child) {\n    Preconditions.checkArgument(child.parent == null,\n        \"new child has existing parent\");\n    Preconditions.checkArgument(child.next == null,\n        \"new child has existing sibling\");\n\n    type = nodeType;\n    parent = null;\n    first = last = child;\n    child.next = null;\n    child.parent = this;\n    sourcePosition = -1;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "Node.Node",
    "class_name": "com.google.javascript.rhino.Node",
    "signature": "com.google.javascript.rhino.Node.Node(int,Node,Node)",
    "snippet": "  public Node(int nodeType, Node left, Node right) {\n    Preconditions.checkArgument(left.parent == null,\n        \"first new child has existing parent\");\n    Preconditions.checkArgument(left.next == null,\n        \"first new child has existing sibling\");\n    Preconditions.checkArgument(right.parent == null,\n        \"second new child has existing parent\");\n    Preconditions.checkArgument(right.next == null,\n        \"second new child has existing sibling\");\n    type = nodeType;\n    parent = null;\n    first = left;\n    last = right;\n    left.next = right;\n    left.parent = this;\n    right.next = null;\n    right.parent = this;\n    sourcePosition = -1;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "Node.Node",
    "class_name": "com.google.javascript.rhino.Node",
    "signature": "com.google.javascript.rhino.Node.Node(int,Node,Node,Node)",
    "snippet": "  public Node(int nodeType, Node left, Node mid, Node right) {\n    Preconditions.checkArgument(left.parent == null);\n    Preconditions.checkArgument(left.next == null);\n    Preconditions.checkArgument(mid.parent == null);\n    Preconditions.checkArgument(mid.next == null);\n    Preconditions.checkArgument(right.parent == null);\n    Preconditions.checkArgument(right.next == null);\n    type = nodeType;\n    parent = null;\n    first = left;\n    last = right;\n    left.next = mid;\n    left.parent = this;\n    mid.next = right;\n    mid.parent = this;\n    right.next = null;\n    right.parent = this;\n    sourcePosition = -1;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "Node.addChildToBack",
    "class_name": "com.google.javascript.rhino.Node",
    "signature": "com.google.javascript.rhino.Node.addChildToBack(Node)",
    "snippet": "  public void addChildToBack(Node child) {\n    Preconditions.checkArgument(child.parent == null);\n    Preconditions.checkArgument(child.next == null);\n    child.parent = this;\n    child.next = null;\n    if (last == null) {\n      first = last = child;\n      return;\n    }\n    last.next = child;\n    last = child;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "Node.clonePropsFrom",
    "class_name": "com.google.javascript.rhino.Node",
    "signature": "com.google.javascript.rhino.Node.clonePropsFrom(Node)",
    "snippet": "  public Node clonePropsFrom(Node other) {\n    Preconditions.checkState(this.propListHead == null,\n        \"Node has existing properties.\");\n    this.propListHead = other.propListHead;\n    return this;\n  }",
    "comment": " Clone the properties from the provided node without copying the property object.  The recieving node may not have any existing properties. @param other The node to clone properties from. @return this node. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "Node.createProp",
    "class_name": "com.google.javascript.rhino.Node",
    "signature": "com.google.javascript.rhino.Node.createProp(int,Object,PropListItem)",
    "snippet": "  PropListItem createProp(int propType, Object value, PropListItem next) {\n    return new ObjectPropListItem(propType, value, next);\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "Node.createProp",
    "class_name": "com.google.javascript.rhino.Node",
    "signature": "com.google.javascript.rhino.Node.createProp(int,int,PropListItem)",
    "snippet": "  PropListItem createProp(int propType, int value, PropListItem next) {\n    return new IntPropListItem(propType, value, next);\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "Node.extractCharno",
    "class_name": "com.google.javascript.rhino.Node",
    "signature": "com.google.javascript.rhino.Node.extractCharno(int)",
    "snippet": "  protected static int extractCharno(int lineCharNo) {\n    if (lineCharNo == -1) {\n      return -1;\n    } else {\n      return lineCharNo & COLUMN_MASK;\n    }\n  }",
    "comment": " Extracts the character number and character number from a merged line char number (see {@link #mergeLineCharNo(int, int)}). ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "Node.extractLineno",
    "class_name": "com.google.javascript.rhino.Node",
    "signature": "com.google.javascript.rhino.Node.extractLineno(int)",
    "snippet": "  protected static int extractLineno(int lineCharNo) {\n    if (lineCharNo == -1) {\n      return -1;\n    } else {\n      return lineCharNo >>> COLUMN_BITS;\n    }\n  }",
    "comment": " Extracts the line number and character number from a merged line char number (see {@link #mergeLineCharNo(int, int)}). ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "Node.getBooleanProp",
    "class_name": "com.google.javascript.rhino.Node",
    "signature": "com.google.javascript.rhino.Node.getBooleanProp(int)",
    "snippet": "  public boolean getBooleanProp(int propType) {\n    return getIntProp(propType) != 0;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "Node.getCharno",
    "class_name": "com.google.javascript.rhino.Node",
    "signature": "com.google.javascript.rhino.Node.getCharno()",
    "snippet": "  public int getCharno() {\n    return extractCharno(sourcePosition);\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "Node.getChildBefore",
    "class_name": "com.google.javascript.rhino.Node",
    "signature": "com.google.javascript.rhino.Node.getChildBefore(Node)",
    "snippet": "  public Node getChildBefore(Node child) {\n    if (child == first) {\n      return null;\n    }\n    Node n = first;\n    while (n.next != child) {\n      n = n.next;\n      if (n == null) {\n        throw new RuntimeException(\"node is not a child\");\n      }\n    }\n    return n;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "Node.getChildCount",
    "class_name": "com.google.javascript.rhino.Node",
    "signature": "com.google.javascript.rhino.Node.getChildCount()",
    "snippet": "  public int getChildCount() {\n    int c = 0;\n    for (Node n = first; n != null; n = n.next)\n      c++;\n\n    return c;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "Node.getFirstChild",
    "class_name": "com.google.javascript.rhino.Node",
    "signature": "com.google.javascript.rhino.Node.getFirstChild()",
    "snippet": "  public Node getFirstChild() {\n    return first;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "Node.getInputId",
    "class_name": "com.google.javascript.rhino.Node",
    "signature": "com.google.javascript.rhino.Node.getInputId()",
    "snippet": "  public InputId getInputId() {\n    return ((InputId) this.getProp(INPUT_ID));\n  }",
    "comment": " @return The Id of the CompilerInput associated with this Node. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "Node.getIntProp",
    "class_name": "com.google.javascript.rhino.Node",
    "signature": "com.google.javascript.rhino.Node.getIntProp(int)",
    "snippet": "  public int getIntProp(int propType) {\n    PropListItem item = lookupProperty(propType);\n    if (item == null) {\n      return 0;\n    }\n    return item.getIntValue();\n  }",
    "comment": " Returns the integer value for the property, or 0 if the property is not defined. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "Node.getJSDocInfo",
    "class_name": "com.google.javascript.rhino.Node",
    "signature": "com.google.javascript.rhino.Node.getJSDocInfo()",
    "snippet": "  public JSDocInfo getJSDocInfo() {\n    return (JSDocInfo) getProp(JSDOC_INFO_PROP);\n  }",
    "comment": " Get the {@link JSDocInfo} attached to this node. @return the information or {@code null} if no JSDoc is attached to this node ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "Node.getJSType",
    "class_name": "com.google.javascript.rhino.Node",
    "signature": "com.google.javascript.rhino.Node.getJSType()",
    "snippet": "  public JSType getJSType() {\n      return jsType;\n  }",
    "comment": "Custom annotations",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "Node.getJsDocBuilderForNode",
    "class_name": "com.google.javascript.rhino.Node",
    "signature": "com.google.javascript.rhino.Node.getJsDocBuilderForNode()",
    "snippet": "  public FileLevelJsDocBuilder getJsDocBuilderForNode() {\n    return new FileLevelJsDocBuilder();\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "Node.getLastChild",
    "class_name": "com.google.javascript.rhino.Node",
    "signature": "com.google.javascript.rhino.Node.getLastChild()",
    "snippet": "  public Node getLastChild() {\n    return last;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "Node.getLineno",
    "class_name": "com.google.javascript.rhino.Node",
    "signature": "com.google.javascript.rhino.Node.getLineno()",
    "snippet": "  public int getLineno() {\n    return extractLineno(sourcePosition);\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "Node.getNext",
    "class_name": "com.google.javascript.rhino.Node",
    "signature": "com.google.javascript.rhino.Node.getNext()",
    "snippet": "  public Node getNext() {\n    return next;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "Node.getParent",
    "class_name": "com.google.javascript.rhino.Node",
    "signature": "com.google.javascript.rhino.Node.getParent()",
    "snippet": "  public Node getParent() {\n    return parent;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "Node.getProp",
    "class_name": "com.google.javascript.rhino.Node",
    "signature": "com.google.javascript.rhino.Node.getProp(int)",
    "snippet": "  public Object getProp(int propType) {\n    if (propType == SOURCENAME_PROP) {\n      return getSourceFileName();\n    }\n\n    PropListItem item = lookupProperty(propType);\n    if (item == null) {\n      return null;\n    }\n    return item.getObjectValue();\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "Node.getSourceFileName",
    "class_name": "com.google.javascript.rhino.Node",
    "signature": "com.google.javascript.rhino.Node.getSourceFileName()",
    "snippet": "  public String getSourceFileName() {\n    StaticSourceFile file = getStaticSourceFile();\n    return file == null ? null : file.getName();\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "Node.getStaticSourceFile",
    "class_name": "com.google.javascript.rhino.Node",
    "signature": "com.google.javascript.rhino.Node.getStaticSourceFile()",
    "snippet": "  public StaticSourceFile getStaticSourceFile() {\n    return ((StaticSourceFile) this.getProp(STATIC_SOURCE_FILE));\n  }",
    "comment": "Returns the source file associated with this input. May be null */",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "Node.getType",
    "class_name": "com.google.javascript.rhino.Node",
    "signature": "com.google.javascript.rhino.Node.getType()",
    "snippet": "  public int getType() {\n    return type;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "Node.hasOneChild",
    "class_name": "com.google.javascript.rhino.Node",
    "signature": "com.google.javascript.rhino.Node.hasOneChild()",
    "snippet": "  public boolean hasOneChild() {\n    return first != null && first == last;\n  }",
    "comment": " Check for one child more efficiently than by iterating over all the children as is done with Node.getChildCount().  @return Whether the node has exactly one child. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "Node.isSyntheticBlock",
    "class_name": "com.google.javascript.rhino.Node",
    "signature": "com.google.javascript.rhino.Node.isSyntheticBlock()",
    "snippet": "  public boolean isSyntheticBlock() {\n    return getBooleanProp(SYNTHETIC_BLOCK_PROP);\n  }",
    "comment": " Returns whether this is a synthetic block that should not be considered a real source block. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "Node.lookupProperty",
    "class_name": "com.google.javascript.rhino.Node",
    "signature": "com.google.javascript.rhino.Node.lookupProperty(int)",
    "snippet": "  @VisibleForTesting\n  PropListItem lookupProperty(int propType) {\n    PropListItem x = propListHead;\n    while (x != null && propType != x.getType()) {\n      x = x.getNext();\n    }\n    return x;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "Node.mergeLineCharNo",
    "class_name": "com.google.javascript.rhino.Node",
    "signature": "com.google.javascript.rhino.Node.mergeLineCharNo(int,int)",
    "snippet": "  protected static int mergeLineCharNo(int lineno, int charno) {\n    if (lineno < 0 || charno < 0) {\n      return -1;\n    } else if ((charno & ~COLUMN_MASK) != 0) {\n      return lineno << COLUMN_BITS | COLUMN_MASK;\n    } else {\n      return lineno << COLUMN_BITS | (charno & COLUMN_MASK);\n    }\n  }",
    "comment": " Merges the line number and character number in one integer. The Character number takes the first 12 bits and the line number takes the rest. If the character number is greater than <code>2<sup>12</sup>-1</code> it is adjusted to <code>2<sup>12</sup>-1</code>. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "Node.newNumber",
    "class_name": "com.google.javascript.rhino.Node",
    "signature": "com.google.javascript.rhino.Node.newNumber(double)",
    "snippet": "  public static Node newNumber(double number) {\n    return new NumberNode(number);\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "Node.newString",
    "class_name": "com.google.javascript.rhino.Node",
    "signature": "com.google.javascript.rhino.Node.newString(int,String)",
    "snippet": "  public static Node newString(int type, String str) {\n    return new StringNode(type, str);\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "Node.putBooleanProp",
    "class_name": "com.google.javascript.rhino.Node",
    "signature": "com.google.javascript.rhino.Node.putBooleanProp(int,boolean)",
    "snippet": "  public void putBooleanProp(int propType, boolean value) {\n    putIntProp(propType, value ? 1 : 0);\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "Node.putIntProp",
    "class_name": "com.google.javascript.rhino.Node",
    "signature": "com.google.javascript.rhino.Node.putIntProp(int,int)",
    "snippet": "  public void putIntProp(int propType, int value) {\n    removeProp(propType);\n    if (value != 0) {\n      propListHead = createProp(propType, value, propListHead);\n    }\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "Node.putProp",
    "class_name": "com.google.javascript.rhino.Node",
    "signature": "com.google.javascript.rhino.Node.putProp(int,Object)",
    "snippet": "  public void putProp(int propType, Object value) {\n    if (propType == SOURCENAME_PROP) {\n      putProp(\n          STATIC_SOURCE_FILE, new SimpleSourceFile((String) value, false));\n      return;\n    }\n\n    removeProp(propType);\n    if (value != null) {\n      propListHead = createProp(propType, value, propListHead);\n    }\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "Node.removeChild",
    "class_name": "com.google.javascript.rhino.Node",
    "signature": "com.google.javascript.rhino.Node.removeChild(Node)",
    "snippet": "  public void removeChild(Node child) {\n    Node prev = getChildBefore(child);\n    if (prev == null)\n        first = first.next;\n    else\n        prev.next = child.next;\n    if (child == last) last = prev;\n    child.next = null;\n    child.parent = null;\n  }",
    "comment": " Detach a child from its parent and siblings. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "Node.removeFirstChild",
    "class_name": "com.google.javascript.rhino.Node",
    "signature": "com.google.javascript.rhino.Node.removeFirstChild()",
    "snippet": "  public Node removeFirstChild() {\n    Node child = first;\n    if (child != null) {\n      removeChild(child);\n    }\n    return child;\n  }",
    "comment": " Removes the first child of Node. Equivalent to: node.removeChild(node.getFirstChild());  @return The removed Node. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "Node.removeProp",
    "class_name": "com.google.javascript.rhino.Node",
    "signature": "com.google.javascript.rhino.Node.removeProp(PropListItem,int)",
    "snippet": "  private PropListItem removeProp(PropListItem item, int propType) {\n    if (item == null) {\n      return null;\n    } else if (item.getType() == propType) {\n      return item.getNext();\n    } else {\n      PropListItem result = removeProp(item.getNext(), propType);\n      if (result != item.getNext()) {\n        return item.chain(result);\n      } else {\n        return item;\n      }\n    }\n  }",
    "comment": " @param item The item to inspect @param propType The property to look for @return The replacement list if the property was removed, or 'item' otherwise. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "Node.removeProp",
    "class_name": "com.google.javascript.rhino.Node",
    "signature": "com.google.javascript.rhino.Node.removeProp(int)",
    "snippet": "  public void removeProp(int propType) {\n    PropListItem result = removeProp(propListHead, propType);\n    if (result != propListHead) {\n      propListHead = result;\n    }\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "Node.setCharno",
    "class_name": "com.google.javascript.rhino.Node",
    "signature": "com.google.javascript.rhino.Node.setCharno(int)",
    "snippet": "  public void setCharno(int charno) {\n      sourcePosition = mergeLineCharNo(getLineno(), charno);\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "Node.setInputId",
    "class_name": "com.google.javascript.rhino.Node",
    "signature": "com.google.javascript.rhino.Node.setInputId(InputId)",
    "snippet": "  public void setInputId(InputId inputId) {\n    this.putProp(INPUT_ID, inputId);\n  }",
    "comment": " @param inputId ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "Node.setIsSyntheticBlock",
    "class_name": "com.google.javascript.rhino.Node",
    "signature": "com.google.javascript.rhino.Node.setIsSyntheticBlock(boolean)",
    "snippet": "  public void setIsSyntheticBlock(boolean val) {\n    putBooleanProp(SYNTHETIC_BLOCK_PROP, val);\n  }",
    "comment": " Sets whether this is a synthetic block that should not be considered a real source block. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "Node.setJSDocInfo",
    "class_name": "com.google.javascript.rhino.Node",
    "signature": "com.google.javascript.rhino.Node.setJSDocInfo(JSDocInfo)",
    "snippet": "  public void setJSDocInfo(JSDocInfo info) {\n      putProp(JSDOC_INFO_PROP, info);\n  }",
    "comment": " Sets the {@link JSDocInfo} attached to this node. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "Node.setJSType",
    "class_name": "com.google.javascript.rhino.Node",
    "signature": "com.google.javascript.rhino.Node.setJSType(JSType)",
    "snippet": "  public void setJSType(JSType jsType) {\n      this.jsType = jsType;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "Node.setLineno",
    "class_name": "com.google.javascript.rhino.Node",
    "signature": "com.google.javascript.rhino.Node.setLineno(int)",
    "snippet": "  public void setLineno(int lineno) {\n      int charno = getCharno();\n      if (charno == -1) {\n        charno = 0;\n      }\n      sourcePosition = mergeLineCharNo(lineno, charno);\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "Node.setOptionalArg",
    "class_name": "com.google.javascript.rhino.Node",
    "signature": "com.google.javascript.rhino.Node.setOptionalArg(boolean)",
    "snippet": "  public void setOptionalArg(boolean optionalArg) {\n    putBooleanProp(OPT_ARG_NAME, optionalArg);\n  }",
    "comment": " Sets whether this node is an optional argument node. This method is meaningful only on {@link Token#NAME} nodes used to define a {@link Token#FUNCTION}'s argument list. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "Node.setStaticSourceFile",
    "class_name": "com.google.javascript.rhino.Node",
    "signature": "com.google.javascript.rhino.Node.setStaticSourceFile(StaticSourceFile)",
    "snippet": "  public void setStaticSourceFile(StaticSourceFile file) {\n    this.putProp(STATIC_SOURCE_FILE, file);\n  }",
    "comment": "Source position management",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "Node.setVarArgs",
    "class_name": "com.google.javascript.rhino.Node",
    "signature": "com.google.javascript.rhino.Node.setVarArgs(boolean)",
    "snippet": "  public void setVarArgs(boolean varArgs) {\n    putBooleanProp(VAR_ARGS_NAME, varArgs);\n  }",
    "comment": " Sets whether this node is a variable length argument node. This method is meaningful only on {@link Token#NAME} nodes used to define a {@link Token#FUNCTION}'s argument list. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "AbstractPropListItem.getNext",
    "class_name": "com.google.javascript.rhino.Node$AbstractPropListItem",
    "signature": "com.google.javascript.rhino.Node$AbstractPropListItem.getNext()",
    "snippet": "    @Override\n    public PropListItem getNext() {\n      return next;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "AbstractPropListItem.getType",
    "class_name": "com.google.javascript.rhino.Node$AbstractPropListItem",
    "signature": "com.google.javascript.rhino.Node$AbstractPropListItem.getType()",
    "snippet": "    @Override\n    public int getType() {\n      return propType;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "IntPropListItem.chain",
    "class_name": "com.google.javascript.rhino.Node$IntPropListItem",
    "signature": "com.google.javascript.rhino.Node$IntPropListItem.chain(PropListItem)",
    "snippet": "    @Override\n    public PropListItem chain(PropListItem next) {\n      return new IntPropListItem(getType(), intValue, next);\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "ObjectPropListItem.getObjectValue",
    "class_name": "com.google.javascript.rhino.Node$ObjectPropListItem",
    "signature": "com.google.javascript.rhino.Node$ObjectPropListItem.getObjectValue()",
    "snippet": "    @Override\n    public Object getObjectValue() {\n      return objectValue;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "StringNode.getString",
    "class_name": "com.google.javascript.rhino.Node$StringNode",
    "signature": "com.google.javascript.rhino.Node$StringNode.getString()",
    "snippet": "    @Override\n    public String getString() {\n      return this.str;\n    }",
    "comment": " returns the string content. @return non null. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "ScriptRuntime.getMessage",
    "class_name": "com.google.javascript.rhino.ScriptRuntime",
    "signature": "com.google.javascript.rhino.ScriptRuntime.getMessage(String,Object[])",
    "snippet": "    public static String getMessage(String messageId, Object[] arguments)\n    {\n        final String defaultResource\n            = \"rhino_ast.java.com.google.javascript.rhino.Messages\";\n\n        Context cx = Context.getCurrentContext();\n        Locale locale = cx != null ? cx.getLocale() : Locale.getDefault();\n\n        // ResourceBundle does cacheing.\n        ResourceBundle rb = ResourceBundle.getBundle(defaultResource, locale);\n\n        String formatString;\n        try {\n            formatString = rb.getString(messageId);\n        } catch (java.util.MissingResourceException mre) {\n            throw new RuntimeException\n                (\"no message resource found for message property \"+ messageId);\n        }\n\n        /*\n         * It's OK to format the string, even if 'arguments' is null;\n         * we need to format it anyway, to make double ''s collapse to\n         * single 's.\n         */\n        // TODO: MessageFormat is not available on pJava\n        MessageFormat formatter = new MessageFormat(formatString);\n        return formatter.format(arguments);\n    }",
    "comment": "OPT there's a noticable delay for the first error!  Maybe it'd make sense to use a ListResourceBundle instead of a properties file to avoid (synchronized) text parsing. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "ScriptRuntime.getMessage0",
    "class_name": "com.google.javascript.rhino.ScriptRuntime",
    "signature": "com.google.javascript.rhino.ScriptRuntime.getMessage0(String)",
    "snippet": "    public static String getMessage0(String messageId)\n    {\n        return getMessage(messageId, null);\n    }",
    "comment": "------------------",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "AllType.AllType",
    "class_name": "com.google.javascript.rhino.jstype.AllType",
    "signature": "com.google.javascript.rhino.jstype.AllType.AllType(JSTypeRegistry)",
    "snippet": "  AllType(JSTypeRegistry registry) {\n    super(registry);\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "AllType.isAllType",
    "class_name": "com.google.javascript.rhino.jstype.AllType",
    "signature": "com.google.javascript.rhino.jstype.AllType.isAllType()",
    "snippet": "  @Override\n  public boolean isAllType() {\n    return true;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "ArrowType.ArrowType",
    "class_name": "com.google.javascript.rhino.jstype.ArrowType",
    "signature": "com.google.javascript.rhino.jstype.ArrowType.ArrowType(JSTypeRegistry,Node,JSType)",
    "snippet": "  ArrowType(JSTypeRegistry registry, Node parameters,\n      JSType returnType) {\n    this(registry, parameters, returnType, false);\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "ArrowType.ArrowType",
    "class_name": "com.google.javascript.rhino.jstype.ArrowType",
    "signature": "com.google.javascript.rhino.jstype.ArrowType.ArrowType(JSTypeRegistry,Node,JSType,boolean)",
    "snippet": "  ArrowType(JSTypeRegistry registry, Node parameters,\n      JSType returnType, boolean returnTypeInferred) {\n    super(registry);\n\n    this.parameters = parameters == null ?\n        registry.createParametersWithVarArgs(getNativeType(UNKNOWN_TYPE)) :\n        parameters;\n    this.returnType = returnType == null ?\n        getNativeType(UNKNOWN_TYPE) : returnType;\n    this.returnTypeInferred = returnTypeInferred;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "BooleanType.BooleanType",
    "class_name": "com.google.javascript.rhino.jstype.BooleanType",
    "signature": "com.google.javascript.rhino.jstype.BooleanType.BooleanType(JSTypeRegistry)",
    "snippet": "  BooleanType(JSTypeRegistry registry) {\n    super(registry);\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "BooleanType.getDisplayName",
    "class_name": "com.google.javascript.rhino.jstype.BooleanType",
    "signature": "com.google.javascript.rhino.jstype.BooleanType.getDisplayName()",
    "snippet": "  @Override\n  public String getDisplayName() {\n    return \"boolean\";\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "BooleanType.toString",
    "class_name": "com.google.javascript.rhino.jstype.BooleanType",
    "signature": "com.google.javascript.rhino.jstype.BooleanType.toString()",
    "snippet": "  @Override\n  public String toString() {\n    return getDisplayName();\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "ErrorFunctionType.ErrorFunctionType",
    "class_name": "com.google.javascript.rhino.jstype.ErrorFunctionType",
    "signature": "com.google.javascript.rhino.jstype.ErrorFunctionType.ErrorFunctionType(JSTypeRegistry,String)",
    "snippet": "  ErrorFunctionType(JSTypeRegistry registry, String name) {\n    super(\n        registry, name, null,\n        registry.createArrowType(\n            registry.createOptionalParameters(\n                registry.getNativeType(ALL_TYPE),\n                registry.getNativeType(ALL_TYPE),\n                registry.getNativeType(ALL_TYPE)),\n            null),\n        null, null, true, true);\n\n    // NOTE(nicksantos): Errors have the weird behavior in that they can\n    // be called as functions, and they will return instances of themselves.\n    // Error('x') instanceof Error => true\n    //\n    // In user-defined types, we would deal with this case by creating\n    // a NamedType with the name \"Error\" and then resolve it later.\n    //\n    // For native types, we don't really want the native types to\n    // depend on type-resolution. So we just set the return type manually\n    // at the end of construction.\n    //\n    // There's similar logic in JSTypeRegistry for Array and RegExp.\n    getInternalArrowType().returnType = getInstanceType();\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "FunctionBuilder.FunctionBuilder",
    "class_name": "com.google.javascript.rhino.jstype.FunctionBuilder",
    "signature": "com.google.javascript.rhino.jstype.FunctionBuilder.FunctionBuilder(JSTypeRegistry)",
    "snippet": "  public FunctionBuilder(JSTypeRegistry registry) {\n    this.registry = registry;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "FunctionBuilder.build",
    "class_name": "com.google.javascript.rhino.jstype.FunctionBuilder",
    "signature": "com.google.javascript.rhino.jstype.FunctionBuilder.build()",
    "snippet": "  public FunctionType build() {\n    return new FunctionType(registry, name, sourceNode,\n        new ArrowType(registry, parametersNode, returnType, inferredReturnType),\n        typeOfThis, templateTypeName, isConstructor, isNativeType);\n  }",
    "comment": "Construct a new function type. */",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "FunctionBuilder.withParamsNode",
    "class_name": "com.google.javascript.rhino.jstype.FunctionBuilder",
    "signature": "com.google.javascript.rhino.jstype.FunctionBuilder.withParamsNode(Node)",
    "snippet": "  public FunctionBuilder withParamsNode(Node parametersNode) {\n    this.parametersNode = parametersNode;\n    return this;\n  }",
    "comment": " Set the parameters of the function type with a specially-formatted node. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "FunctionBuilder.withReturnType",
    "class_name": "com.google.javascript.rhino.jstype.FunctionBuilder",
    "signature": "com.google.javascript.rhino.jstype.FunctionBuilder.withReturnType(JSType)",
    "snippet": "  public FunctionBuilder withReturnType(JSType returnType) {\n    this.returnType = returnType;\n    return this;\n  }",
    "comment": "Set the return type. */",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "FunctionParamBuilder.FunctionParamBuilder",
    "class_name": "com.google.javascript.rhino.jstype.FunctionParamBuilder",
    "signature": "com.google.javascript.rhino.jstype.FunctionParamBuilder.FunctionParamBuilder(JSTypeRegistry)",
    "snippet": "  public FunctionParamBuilder(JSTypeRegistry registry) {\n    this.registry = registry;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "FunctionParamBuilder.addOptionalParams",
    "class_name": "com.google.javascript.rhino.jstype.FunctionParamBuilder",
    "signature": "com.google.javascript.rhino.jstype.FunctionParamBuilder.addOptionalParams(JSType[])",
    "snippet": "  public boolean addOptionalParams(JSType ...types) {\n    if (hasVarArgs()) {\n      return false;\n    }\n\n    for (JSType type : types) {\n      newParameter(registry.createOptionalType(type)).setOptionalArg(true);\n    }\n    return true;\n  }",
    "comment": " Add optional parameters of the given type to the end of the param list. @param types Types for each optional parameter. The builder will make them undefineable. @return False if this is called after var args are added. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "FunctionParamBuilder.addRequiredParams",
    "class_name": "com.google.javascript.rhino.jstype.FunctionParamBuilder",
    "signature": "com.google.javascript.rhino.jstype.FunctionParamBuilder.addRequiredParams(JSType[])",
    "snippet": "  public boolean addRequiredParams(JSType ...types) {\n    if (hasOptionalOrVarArgs()) {\n      return false;\n    }\n\n    for (JSType type : types) {\n      newParameter(type);\n    }\n    return true;\n  }",
    "comment": " Add parameters of the given type to the end of the param list. @return False if this is called after optional params are added. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "FunctionParamBuilder.addVarArgs",
    "class_name": "com.google.javascript.rhino.jstype.FunctionParamBuilder",
    "signature": "com.google.javascript.rhino.jstype.FunctionParamBuilder.addVarArgs(JSType)",
    "snippet": "  public boolean addVarArgs(JSType type) {\n    if (hasVarArgs()) {\n      return false;\n    }\n\n    // There are two types of variable argument functions:\n    // 1) Programmer-defined var args\n    // 2) Native bottom types that can accept any argument.\n    // For the first one, \"undefined\" is a valid value for all arguments.\n    // For the second, we do not want to cast it up to undefined.\n    if (!type.isEmptyType()) {\n      type = registry.createOptionalType(type);\n    }\n    newParameter(type).setVarArgs(true);\n    return true;\n  }",
    "comment": " Add variable arguments to the end of the parameter list. @return False if this is called after var args are added. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "FunctionParamBuilder.build",
    "class_name": "com.google.javascript.rhino.jstype.FunctionParamBuilder",
    "signature": "com.google.javascript.rhino.jstype.FunctionParamBuilder.build()",
    "snippet": "  public Node build() {\n    return root;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "FunctionParamBuilder.hasOptionalOrVarArgs",
    "class_name": "com.google.javascript.rhino.jstype.FunctionParamBuilder",
    "signature": "com.google.javascript.rhino.jstype.FunctionParamBuilder.hasOptionalOrVarArgs()",
    "snippet": "  private boolean hasOptionalOrVarArgs() {\n    Node lastChild = root.getLastChild();\n    return lastChild != null &&\n        (lastChild.isOptionalArg() || lastChild.isVarArgs());\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "FunctionParamBuilder.hasVarArgs",
    "class_name": "com.google.javascript.rhino.jstype.FunctionParamBuilder",
    "signature": "com.google.javascript.rhino.jstype.FunctionParamBuilder.hasVarArgs()",
    "snippet": "  public boolean hasVarArgs() {\n    Node lastChild = root.getLastChild();\n    return lastChild != null && lastChild.isVarArgs();\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "FunctionParamBuilder.newParameter",
    "class_name": "com.google.javascript.rhino.jstype.FunctionParamBuilder",
    "signature": "com.google.javascript.rhino.jstype.FunctionParamBuilder.newParameter(JSType)",
    "snippet": "  private Node newParameter(JSType type) {\n    Node paramNode = Node.newString(Token.NAME, \"\");\n    paramNode.setJSType(type);\n    root.addChildToBack(paramNode);\n    return paramNode;\n  }",
    "comment": "Add a parameter to the list with the given type.",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "FunctionPrototypeType.FunctionPrototypeType",
    "class_name": "com.google.javascript.rhino.jstype.FunctionPrototypeType",
    "signature": "com.google.javascript.rhino.jstype.FunctionPrototypeType.FunctionPrototypeType(JSTypeRegistry,FunctionType,ObjectType)",
    "snippet": "  FunctionPrototypeType(JSTypeRegistry registry, FunctionType ownerFunction,\n      ObjectType implicitPrototype) {\n    this(registry, ownerFunction, implicitPrototype, false);\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "FunctionPrototypeType.FunctionPrototypeType",
    "class_name": "com.google.javascript.rhino.jstype.FunctionPrototypeType",
    "signature": "com.google.javascript.rhino.jstype.FunctionPrototypeType.FunctionPrototypeType(JSTypeRegistry,FunctionType,ObjectType,boolean)",
    "snippet": "  FunctionPrototypeType(JSTypeRegistry registry, FunctionType ownerFunction,\n      ObjectType implicitPrototype, boolean isNative) {\n    super(registry, null /* has no class name */, implicitPrototype,\n        isNative);\n    this.ownerFunction = ownerFunction;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "FunctionPrototypeType.getCtorExtendedInterfaces",
    "class_name": "com.google.javascript.rhino.jstype.FunctionPrototypeType",
    "signature": "com.google.javascript.rhino.jstype.FunctionPrototypeType.getCtorExtendedInterfaces()",
    "snippet": "  @Override\n  public Iterable<ObjectType> getCtorExtendedInterfaces() {\n    if (getOwnerFunction() != null) {\n      return getOwnerFunction().getExtendedInterfaces();\n    } else {\n      return ImmutableSet.of();\n    }\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "FunctionPrototypeType.getOwnerFunction",
    "class_name": "com.google.javascript.rhino.jstype.FunctionPrototypeType",
    "signature": "com.google.javascript.rhino.jstype.FunctionPrototypeType.getOwnerFunction()",
    "snippet": "  public FunctionType getOwnerFunction() {\n    return ownerFunction;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "FunctionType.FunctionType",
    "class_name": "com.google.javascript.rhino.jstype.FunctionType",
    "signature": "com.google.javascript.rhino.jstype.FunctionType.FunctionType(JSTypeRegistry,String,Node,ArrowType,ObjectType,String,boolean,boolean)",
    "snippet": "  FunctionType(JSTypeRegistry registry, String name, Node source,\n      ArrowType arrowType, ObjectType typeOfThis,\n      String templateTypeName,  boolean isConstructor, boolean nativeType) {\n    super(registry, name,\n        registry.getNativeObjectType(JSTypeNative.FUNCTION_INSTANCE_TYPE),\n        nativeType);\n    Preconditions.checkArgument(source == null ||\n        Token.FUNCTION == source.getType());\n    Preconditions.checkNotNull(arrowType);\n    this.source = source;\n    this.kind = isConstructor ? Kind.CONSTRUCTOR : Kind.ORDINARY;\n    if (isConstructor) {\n      this.typeOfThis = typeOfThis != null ?\n          typeOfThis : new InstanceObjectType(registry, this, nativeType);\n    } else {\n      this.typeOfThis = typeOfThis != null ?\n          typeOfThis :\n          registry.getNativeObjectType(JSTypeNative.UNKNOWN_TYPE);\n    }\n    this.call = arrowType;\n    this.templateTypeName = templateTypeName;\n  }",
    "comment": "Creates an instance for a function that might be a constructor. */",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "FunctionType.addSubType",
    "class_name": "com.google.javascript.rhino.jstype.FunctionType",
    "signature": "com.google.javascript.rhino.jstype.FunctionType.addSubType(FunctionType)",
    "snippet": "  private void addSubType(FunctionType subType) {\n    if (subTypes == null) {\n      subTypes = Lists.newArrayList();\n    }\n    subTypes.add(subType);\n  }",
    "comment": "Adds a type to the list of subtypes for this type. */",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "FunctionType.clearCachedValues",
    "class_name": "com.google.javascript.rhino.jstype.FunctionType",
    "signature": "com.google.javascript.rhino.jstype.FunctionType.clearCachedValues()",
    "snippet": "  @Override\n  public void clearCachedValues() {\n    super.clearCachedValues();\n\n    if (subTypes != null) {\n      for (FunctionType subType : subTypes) {\n        subType.clearCachedValues();\n      }\n    }\n\n    if (!isNativeObjectType()) {\n      if (hasInstanceType()) {\n        getInstanceType().clearCachedValues();\n      }\n\n      if (prototype != null) {\n        prototype.clearCachedValues();\n      }\n    }\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "FunctionType.defineProperty",
    "class_name": "com.google.javascript.rhino.jstype.FunctionType",
    "signature": "com.google.javascript.rhino.jstype.FunctionType.defineProperty(String,JSType,boolean,Node)",
    "snippet": "  @Override\n  boolean defineProperty(String name, JSType type,\n      boolean inferred, Node propertyNode) {\n    if (\"prototype\".equals(name)) {\n      ObjectType objType = type.toObjectType();\n      if (objType != null) {\n        if (objType.isEquivalentTo(prototype)) {\n          return true;\n        }\n        return setPrototype(\n            new FunctionPrototypeType(\n                registry, this, objType, isNativeObjectType()));\n      } else {\n        return false;\n      }\n    }\n    return super.defineProperty(name, type, inferred, propertyNode);\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "FunctionType.getExtendedInterfaces",
    "class_name": "com.google.javascript.rhino.jstype.FunctionType",
    "signature": "com.google.javascript.rhino.jstype.FunctionType.getExtendedInterfaces()",
    "snippet": "  public Iterable<ObjectType> getExtendedInterfaces() {\n    return extendedInterfaces;\n  }",
    "comment": "Returns interfaces directly extended by an interface */",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "FunctionType.getInstanceType",
    "class_name": "com.google.javascript.rhino.jstype.FunctionType",
    "signature": "com.google.javascript.rhino.jstype.FunctionType.getInstanceType()",
    "snippet": "  public ObjectType getInstanceType() {\n    Preconditions.checkState(hasInstanceType());\n    return typeOfThis;\n  }",
    "comment": " Gets the type of instance of this function. @throws IllegalStateException if this function is not a constructor (see {@link #isConstructor()}). ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "FunctionType.getInternalArrowType",
    "class_name": "com.google.javascript.rhino.jstype.FunctionType",
    "signature": "com.google.javascript.rhino.jstype.FunctionType.getInternalArrowType()",
    "snippet": "  ArrowType getInternalArrowType() {\n    return call;\n  }",
    "comment": "Gets the internal arrow type. For use by subclasses only. */",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "FunctionType.getPrototype",
    "class_name": "com.google.javascript.rhino.jstype.FunctionType",
    "signature": "com.google.javascript.rhino.jstype.FunctionType.getPrototype()",
    "snippet": "  public FunctionPrototypeType getPrototype() {\n    // lazy initialization of the prototype field\n    if (prototype == null) {\n      setPrototype(new FunctionPrototypeType(registry, this, null));\n    }\n    return prototype;\n  }",
    "comment": " Gets the {@code prototype} property of this function type. This is equivalent to {@code (ObjectType) getPropertyType(\"prototype\")}. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "FunctionType.getSuperClassConstructor",
    "class_name": "com.google.javascript.rhino.jstype.FunctionType",
    "signature": "com.google.javascript.rhino.jstype.FunctionType.getSuperClassConstructor()",
    "snippet": "  public FunctionType getSuperClassConstructor() {\n    Preconditions.checkArgument(isConstructor() || isInterface());\n    ObjectType maybeSuperInstanceType = getPrototype().getImplicitPrototype();\n    if (maybeSuperInstanceType == null) {\n      return null;\n    }\n    return maybeSuperInstanceType.getConstructor();\n  }",
    "comment": " Given a constructor or an interface type, get its superclass constructor or {@code null} if none exists. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "FunctionType.hasCachedValues",
    "class_name": "com.google.javascript.rhino.jstype.FunctionType",
    "signature": "com.google.javascript.rhino.jstype.FunctionType.hasCachedValues()",
    "snippet": "  @Override\n  public boolean hasCachedValues() {\n    return prototype != null || super.hasCachedValues();\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "FunctionType.hasInstanceType",
    "class_name": "com.google.javascript.rhino.jstype.FunctionType",
    "signature": "com.google.javascript.rhino.jstype.FunctionType.hasInstanceType()",
    "snippet": "  public boolean hasInstanceType() {\n    return isConstructor() || isInterface();\n  }",
    "comment": " Returns whether this function type has an instance type. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "FunctionType.isConstructor",
    "class_name": "com.google.javascript.rhino.jstype.FunctionType",
    "signature": "com.google.javascript.rhino.jstype.FunctionType.isConstructor()",
    "snippet": "  @Override\n  public boolean isConstructor() {\n    return kind == Kind.CONSTRUCTOR;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "FunctionType.isEquivalentTo",
    "class_name": "com.google.javascript.rhino.jstype.FunctionType",
    "signature": "com.google.javascript.rhino.jstype.FunctionType.isEquivalentTo(JSType)",
    "snippet": "  @Override\n  public boolean isEquivalentTo(JSType otherType) {\n    if (!(otherType instanceof FunctionType)) {\n      return false;\n    }\n    FunctionType that = (FunctionType) otherType;\n    if (!that.isFunctionType()) {\n      return false;\n    }\n    if (this.isConstructor()) {\n      if (that.isConstructor()) {\n        return this == that;\n      }\n      return false;\n    }\n    if (this.isInterface()) {\n      if (that.isInterface()) {\n        return this.getReferenceName().equals(that.getReferenceName());\n      }\n      return false;\n    }\n    if (that.isInterface()) {\n      return false;\n    }\n    return this.typeOfThis.isEquivalentTo(that.typeOfThis) &&\n        this.call.isEquivalentTo(that.call);\n  }",
    "comment": " Two function types are equal if their signatures match. Since they don't have signatures, two interfaces are equal if their names match. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "FunctionType.isFunctionType",
    "class_name": "com.google.javascript.rhino.jstype.FunctionType",
    "signature": "com.google.javascript.rhino.jstype.FunctionType.isFunctionType()",
    "snippet": "  @Override\n  public boolean isFunctionType() {\n    return true;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "FunctionType.isInterface",
    "class_name": "com.google.javascript.rhino.jstype.FunctionType",
    "signature": "com.google.javascript.rhino.jstype.FunctionType.isInterface()",
    "snippet": "  @Override\n  public boolean isInterface() {\n    return kind == Kind.INTERFACE;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "FunctionType.isSubtype",
    "class_name": "com.google.javascript.rhino.jstype.FunctionType",
    "signature": "com.google.javascript.rhino.jstype.FunctionType.isSubtype(JSType)",
    "snippet": "  @Override\n  public boolean isSubtype(JSType that) {\n    if (JSType.isSubtype(this, that)) {\n      return true;\n    }\n\n    if (that.isFunctionType()) {\n      if (((FunctionType) that).isInterface()) {\n        // Any function can be assigned to an interface function.\n        return true;\n      }\n      if (this.isInterface()) {\n        // An interface function cannot be assigned to anything.\n        return false;\n      }\n      // If functionA is a subtype of functionB, then their \"this\" types\n      // should be contravariant. However, this causes problems because\n      // of the way we enforce overrides. Because function(this:SubFoo)\n      // is not a subtype of function(this:Foo), our override check treats\n      // this as an error. It also screws up out standard method\n      // for aliasing constructors. Let's punt on all this for now.\n      // TODO(nicksantos): fix this.\n      FunctionType other = (FunctionType) that;\n      boolean treatThisTypesAsCovariant =\n        // If either one of these is a ctor, skip 'this' checking.\n        this.isConstructor() || other.isConstructor() ||\n\n        // An interface 'this'-type is non-restrictive.\n        // In practical terms, if C implements I, and I has a method m,\n        // then any m doesn't necessarily have to C#m's 'this'\n        // type doesn't need to match I.\n        (other.typeOfThis.getConstructor() != null &&\n             other.typeOfThis.getConstructor().isInterface()) ||\n\n        // If one of the 'this' types is covariant of the other,\n        // then we'll treat them as covariant (see comment above).\n        other.typeOfThis.isSubtype(this.typeOfThis) ||\n        this.typeOfThis.isSubtype(other.typeOfThis);\n      return treatThisTypesAsCovariant && this.call.isSubtype(other.call);\n    }\n\n    return getNativeType(JSTypeNative.FUNCTION_PROTOTYPE).isSubtype(that);\n  }",
    "comment": " A function is a subtype of another if their call methods are related via subtyping and {@code this} is a subtype of {@code that} with regard to the prototype chain. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "FunctionType.setInstanceType",
    "class_name": "com.google.javascript.rhino.jstype.FunctionType",
    "signature": "com.google.javascript.rhino.jstype.FunctionType.setInstanceType(ObjectType)",
    "snippet": "  void setInstanceType(ObjectType instanceType) {\n    typeOfThis = instanceType;\n  }",
    "comment": " Sets the instance type. This should only be used for special native types. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "FunctionType.setPrototype",
    "class_name": "com.google.javascript.rhino.jstype.FunctionType",
    "signature": "com.google.javascript.rhino.jstype.FunctionType.setPrototype(FunctionPrototypeType)",
    "snippet": "  public boolean setPrototype(FunctionPrototypeType prototype) {\n    if (prototype == null) {\n      return false;\n    }\n    // getInstanceType fails if the function is not a constructor\n    if (isConstructor() && prototype == getInstanceType()) {\n      return false;\n    }\n\n    boolean replacedPrototype = prototype != null;\n    this.prototype = prototype;\n\n    if (isConstructor() || isInterface()) {\n      FunctionType superClass = getSuperClassConstructor();\n      if (superClass != null) {\n        superClass.addSubType(this);\n      }\n\n      if (isInterface()) {\n        for (ObjectType interfaceType : getExtendedInterfaces()) {\n          if (interfaceType.getConstructor() != null) {\n            interfaceType.getConstructor().addSubType(this);\n          }\n        }\n      }\n    }\n\n    if (replacedPrototype) {\n      clearCachedValues();\n    }\n\n    return true;\n  }",
    "comment": " Sets the prototype. @param prototype the prototype. If this value is {@code null} it will silently be discarded. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "FunctionType.setPrototypeBasedOn",
    "class_name": "com.google.javascript.rhino.jstype.FunctionType",
    "signature": "com.google.javascript.rhino.jstype.FunctionType.setPrototypeBasedOn(ObjectType)",
    "snippet": "  public void setPrototypeBasedOn(ObjectType baseType) {\n    if (prototype == null) {\n      setPrototype(\n          new FunctionPrototypeType(\n              registry, this, baseType, isNativeObjectType()));\n    } else {\n      prototype.setImplicitPrototype(baseType);\n    }\n  }",
    "comment": " Sets the prototype, creating the prototype object from the given base type. @param baseType The base type. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "InstanceObjectType.InstanceObjectType",
    "class_name": "com.google.javascript.rhino.jstype.InstanceObjectType",
    "signature": "com.google.javascript.rhino.jstype.InstanceObjectType.InstanceObjectType(JSTypeRegistry,FunctionType,boolean)",
    "snippet": "  InstanceObjectType(JSTypeRegistry registry, FunctionType constructor,\n                     boolean isNativeType) {\n    super(registry, null, null, isNativeType);\n    Preconditions.checkNotNull(constructor);\n    this.constructor = constructor;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "InstanceObjectType.getConstructor",
    "class_name": "com.google.javascript.rhino.jstype.InstanceObjectType",
    "signature": "com.google.javascript.rhino.jstype.InstanceObjectType.getConstructor()",
    "snippet": "  @Override\n  public FunctionType getConstructor() {\n    return constructor;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "InstanceObjectType.getCtorExtendedInterfaces",
    "class_name": "com.google.javascript.rhino.jstype.InstanceObjectType",
    "signature": "com.google.javascript.rhino.jstype.InstanceObjectType.getCtorExtendedInterfaces()",
    "snippet": "  @Override\n  public Iterable<ObjectType> getCtorExtendedInterfaces() {\n    return getConstructor().getExtendedInterfaces();\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "InstanceObjectType.getImplicitPrototype",
    "class_name": "com.google.javascript.rhino.jstype.InstanceObjectType",
    "signature": "com.google.javascript.rhino.jstype.InstanceObjectType.getImplicitPrototype()",
    "snippet": "  @Override\n  public ObjectType getImplicitPrototype() {\n    return getConstructor().getPrototype();\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "InstanceObjectType.getReferenceName",
    "class_name": "com.google.javascript.rhino.jstype.InstanceObjectType",
    "signature": "com.google.javascript.rhino.jstype.InstanceObjectType.getReferenceName()",
    "snippet": "  @Override\n  public String getReferenceName() {\n    return getConstructor().getReferenceName();\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "InstanceObjectType.hasReferenceName",
    "class_name": "com.google.javascript.rhino.jstype.InstanceObjectType",
    "signature": "com.google.javascript.rhino.jstype.InstanceObjectType.hasReferenceName()",
    "snippet": "  @Override\n  public boolean hasReferenceName() {\n    return getConstructor().hasReferenceName();\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "InstanceObjectType.hashCode",
    "class_name": "com.google.javascript.rhino.jstype.InstanceObjectType",
    "signature": "com.google.javascript.rhino.jstype.InstanceObjectType.hashCode()",
    "snippet": "  @Override\n  public int hashCode() {\n    if (hasReferenceName()) {\n      return getReferenceName().hashCode();\n    } else {\n      return super.hashCode();\n    }\n  }",
    "comment": " If this is equal to a NamedType object, its hashCode must be equal to the hashCode of the NamedType object. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "InstanceObjectType.isEquivalentTo",
    "class_name": "com.google.javascript.rhino.jstype.InstanceObjectType",
    "signature": "com.google.javascript.rhino.jstype.InstanceObjectType.isEquivalentTo(JSType)",
    "snippet": "  @Override\n  public boolean isEquivalentTo(JSType that) {\n    if (this == that) {\n      return true;\n    } else if (this.isNominalType()) {\n      ObjectType thatObj = ObjectType.cast(that);\n      if (thatObj != null && thatObj.isNominalType()) {\n        return getReferenceName().equals(thatObj.getReferenceName());\n      }\n    }\n    return false;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "InstanceObjectType.isNominalType",
    "class_name": "com.google.javascript.rhino.jstype.InstanceObjectType",
    "signature": "com.google.javascript.rhino.jstype.InstanceObjectType.isNominalType()",
    "snippet": "  @Override\n  public boolean isNominalType() {\n    return hasReferenceName();\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "InstanceObjectType.toString",
    "class_name": "com.google.javascript.rhino.jstype.InstanceObjectType",
    "signature": "com.google.javascript.rhino.jstype.InstanceObjectType.toString()",
    "snippet": "  @Override\n  public String toString() {\n    if (constructor.hasReferenceName()) {\n      return constructor.getReferenceName();\n    } else {\n      return super.toString();\n    }\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "JSType.JSType",
    "class_name": "com.google.javascript.rhino.jstype.JSType",
    "signature": "com.google.javascript.rhino.jstype.JSType.JSType(JSTypeRegistry)",
    "snippet": "  JSType(JSTypeRegistry registry) {\n    this.registry = registry;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "JSType.getNativeType",
    "class_name": "com.google.javascript.rhino.jstype.JSType",
    "signature": "com.google.javascript.rhino.jstype.JSType.getNativeType(JSTypeNative)",
    "snippet": "  JSType getNativeType(JSTypeNative typeId) {\n    return registry.getNativeType(typeId);\n  }",
    "comment": " Utility method for less verbose code. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "JSType.hashCode",
    "class_name": "com.google.javascript.rhino.jstype.JSType",
    "signature": "com.google.javascript.rhino.jstype.JSType.hashCode()",
    "snippet": "  @Override\n  public int hashCode() {\n    return System.identityHashCode(this);\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "JSType.isAllType",
    "class_name": "com.google.javascript.rhino.jstype.JSType",
    "signature": "com.google.javascript.rhino.jstype.JSType.isAllType()",
    "snippet": "  public boolean isAllType() {\n    return false;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "JSType.isEmptyType",
    "class_name": "com.google.javascript.rhino.jstype.JSType",
    "signature": "com.google.javascript.rhino.jstype.JSType.isEmptyType()",
    "snippet": "  public final boolean isEmptyType() {\n    return isNoType() || isNoObjectType() || isNoResolvedType() ||\n        (registry.getNativeFunctionType(\n             JSTypeNative.LEAST_FUNCTION_TYPE) == this);\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "JSType.isEquivalentTo",
    "class_name": "com.google.javascript.rhino.jstype.JSType",
    "signature": "com.google.javascript.rhino.jstype.JSType.isEquivalentTo(JSType)",
    "snippet": "  public boolean isEquivalentTo(JSType jsType) {\n    if (jsType instanceof ProxyObjectType) {\n      return jsType.isEquivalentTo(this);\n    }\n    // Relies on the fact that for the base {@link JSType}, only one\n    // instance of each sub-type will ever be created in a given registry, so\n    // there is no need to verify members. If the object pointers are not\n    // identical, then the type member must be different.\n    return this == jsType;\n  }",
    "comment": " Checks if two types are equivalent. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "JSType.isNoObjectType",
    "class_name": "com.google.javascript.rhino.jstype.JSType",
    "signature": "com.google.javascript.rhino.jstype.JSType.isNoObjectType()",
    "snippet": "  public boolean isNoObjectType() {\n    return false;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "JSType.isNoResolvedType",
    "class_name": "com.google.javascript.rhino.jstype.JSType",
    "signature": "com.google.javascript.rhino.jstype.JSType.isNoResolvedType()",
    "snippet": "  public boolean isNoResolvedType() {\n    return false;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "JSType.isNoType",
    "class_name": "com.google.javascript.rhino.jstype.JSType",
    "signature": "com.google.javascript.rhino.jstype.JSType.isNoType()",
    "snippet": "  public boolean isNoType() {\n    return false;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "JSType.isSubtype",
    "class_name": "com.google.javascript.rhino.jstype.JSType",
    "signature": "com.google.javascript.rhino.jstype.JSType.isSubtype(JSType,JSType)",
    "snippet": "  static boolean isSubtype(JSType thisType, JSType thatType) {\n    // unknown\n    if (thatType.isUnknownType()) {\n      return true;\n    }\n    // equality\n    if (thisType.isEquivalentTo(thatType)) {\n      return true;\n    }\n    // all type\n    if (thatType.isAllType()) {\n      return true;\n    }\n    // unions\n    if (thatType instanceof UnionType) {\n      UnionType union = (UnionType)thatType;\n      for (JSType element : union.alternates) {\n        if (thisType.isSubtype(element)) {\n          return true;\n        }\n      }\n    }\n    // named types\n    if (thatType instanceof NamedType) {\n      return thisType.isSubtype(((NamedType)thatType).getReferencedType());\n    }\n    return false;\n  }",
    "comment": " A generic implementation meant to be used as a helper for common subtyping cases. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "JSType.isUnknownType",
    "class_name": "com.google.javascript.rhino.jstype.JSType",
    "signature": "com.google.javascript.rhino.jstype.JSType.isUnknownType()",
    "snippet": "  public boolean isUnknownType() {\n    return false;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "JSType.toObjectType",
    "class_name": "com.google.javascript.rhino.jstype.JSType",
    "signature": "com.google.javascript.rhino.jstype.JSType.toObjectType()",
    "snippet": "  public ObjectType toObjectType() {\n    return this instanceof ObjectType ? (ObjectType) this : null;\n  }",
    "comment": " Casts this to an ObjectType, or returns null if this is not an ObjectType.  Does not change the underlying JS type. If you want to simulate JS autoboxing or dereferencing, you should use autoboxesTo() or dereference(). Those methods may change the underlying JS type. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "JSTypeRegistry.JSTypeRegistry",
    "class_name": "com.google.javascript.rhino.jstype.JSTypeRegistry",
    "signature": "com.google.javascript.rhino.jstype.JSTypeRegistry.JSTypeRegistry(ErrorReporter,boolean)",
    "snippet": "  public JSTypeRegistry(\n      ErrorReporter reporter, boolean tolerateUndefinedValues) {\n    this.reporter = reporter;\n    nativeTypes = new JSType[JSTypeNative.values().length];\n    namesToTypes = new HashMap<String, JSType>();\n    resetForTypeCheck();\n    this.tolerateUndefinedValues = tolerateUndefinedValues;\n  }",
    "comment": " Constructs a new type registry populated with the built-in types. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "JSTypeRegistry.addReferenceTypeIndexedByProperty",
    "class_name": "com.google.javascript.rhino.jstype.JSTypeRegistry",
    "signature": "com.google.javascript.rhino.jstype.JSTypeRegistry.addReferenceTypeIndexedByProperty(String,JSType)",
    "snippet": "  private void addReferenceTypeIndexedByProperty(\n      String propertyName, JSType type) {\n    if (type instanceof ObjectType && ((ObjectType) type).hasReferenceName()) {\n      Map<String, ObjectType> typeSet =\n          eachRefTypeIndexedByProperty.get(propertyName);\n      if (typeSet == null) {\n        typeSet = Maps.newHashMap();\n        eachRefTypeIndexedByProperty.put(propertyName, typeSet);\n      }\n      ObjectType objType = (ObjectType) type;\n      typeSet.put(objType.getReferenceName(), objType);\n    } else if (type instanceof NamedType) {\n      addReferenceTypeIndexedByProperty(\n          propertyName, ((NamedType) type).getReferencedType());\n    } else if (type instanceof UnionType) {\n      for (JSType alternate : ((UnionType) type).getAlternates()) {\n        addReferenceTypeIndexedByProperty(propertyName, alternate);\n      }\n    }\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "JSTypeRegistry.createArrowType",
    "class_name": "com.google.javascript.rhino.jstype.JSTypeRegistry",
    "signature": "com.google.javascript.rhino.jstype.JSTypeRegistry.createArrowType(Node)",
    "snippet": "  ArrowType createArrowType(Node parametersNode) {\n    return new ArrowType(this, parametersNode, null);\n  }",
    "comment": " Creates an arrow type with an unknown return type.  @param parametersNode the parameters' types, formatted as a Node with param names and optionality info. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "JSTypeRegistry.createArrowType",
    "class_name": "com.google.javascript.rhino.jstype.JSTypeRegistry",
    "signature": "com.google.javascript.rhino.jstype.JSTypeRegistry.createArrowType(Node,JSType)",
    "snippet": "  ArrowType createArrowType(Node parametersNode, JSType returnType) {\n    return new ArrowType(this, parametersNode, returnType);\n  }",
    "comment": " Creates an arrow type, an abstract representation of the parameters and return value of a function.  @param parametersNode the parameters' types, formatted as a Node with param names and optionality info. @param returnType the function's return type ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "JSTypeRegistry.createFunctionType",
    "class_name": "com.google.javascript.rhino.jstype.JSTypeRegistry",
    "signature": "com.google.javascript.rhino.jstype.JSTypeRegistry.createFunctionType(JSType,Node)",
    "snippet": "  public FunctionType createFunctionType(\n      JSType returnType, Node parameters) {\n    return new FunctionBuilder(this)\n        .withParamsNode(parameters)\n        .withReturnType(returnType)\n        .build();\n  }",
    "comment": " @param parameters the function's parameters or {@code null} to indicate that the parameter types are unknown. @param returnType the function's return type or {@code null} to indicate that the return type is unknown. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "JSTypeRegistry.createFunctionType",
    "class_name": "com.google.javascript.rhino.jstype.JSTypeRegistry",
    "signature": "com.google.javascript.rhino.jstype.JSTypeRegistry.createFunctionType(JSType,boolean,JSType[])",
    "snippet": "  public FunctionType createFunctionType(JSType returnType,\n      boolean lastVarArgs, JSType... parameterTypes) {\n    if (lastVarArgs) {\n      return createFunctionTypeWithVarArgs(returnType, parameterTypes);\n    } else {\n      return createFunctionType(returnType, parameterTypes);\n    }\n  }",
    "comment": " Creates a function type. @param returnType the function's return type @param lastVarArgs whether the last parameter type should be considered as an extensible var_args parameter @param parameterTypes the parameters' types ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "JSTypeRegistry.createFunctionTypeWithVarArgs",
    "class_name": "com.google.javascript.rhino.jstype.JSTypeRegistry",
    "signature": "com.google.javascript.rhino.jstype.JSTypeRegistry.createFunctionTypeWithVarArgs(JSType,JSType[])",
    "snippet": "  public FunctionType createFunctionTypeWithVarArgs(\n      JSType returnType, JSType... parameterTypes) {\n    return createFunctionType(\n        returnType, createParametersWithVarArgs(parameterTypes));\n  }",
    "comment": " Creates a function type. The last parameter type of the function is considered a variable length argument.  @param returnType the function's return type @param parameterTypes the parameters' types ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "JSTypeRegistry.createOptionalParameters",
    "class_name": "com.google.javascript.rhino.jstype.JSTypeRegistry",
    "signature": "com.google.javascript.rhino.jstype.JSTypeRegistry.createOptionalParameters(JSType[])",
    "snippet": "  public Node createOptionalParameters(JSType... parameterTypes) {\n    FunctionParamBuilder builder = new FunctionParamBuilder(this);\n    builder.addOptionalParams(parameterTypes);\n    return builder.build();\n  }",
    "comment": " Creates a tree hierarchy representing a typed parameter list in which every parameter is optional. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "JSTypeRegistry.createOptionalType",
    "class_name": "com.google.javascript.rhino.jstype.JSTypeRegistry",
    "signature": "com.google.javascript.rhino.jstype.JSTypeRegistry.createOptionalType(JSType)",
    "snippet": "  public JSType createOptionalType(JSType type) {\n    if (type instanceof UnknownType || type.isAllType()) {\n      return type;\n    } else {\n      return createUnionType(type, getNativeType(JSTypeNative.VOID_TYPE));\n    }\n  }",
    "comment": " Creates a type representing optional values of the given type. @return the union of the type and the void type ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "JSTypeRegistry.createParameters",
    "class_name": "com.google.javascript.rhino.jstype.JSTypeRegistry",
    "signature": "com.google.javascript.rhino.jstype.JSTypeRegistry.createParameters(boolean,JSType[])",
    "snippet": "  private Node createParameters(boolean lastVarArgs, JSType... parameterTypes) {\n    FunctionParamBuilder builder = new FunctionParamBuilder(this);\n    int max = parameterTypes.length - 1;\n    for (int i = 0; i <= max; i++) {\n      if (lastVarArgs && i == max) {\n        builder.addVarArgs(parameterTypes[i]);\n      } else {\n        builder.addRequiredParams(parameterTypes[i]);\n      }\n    }\n    return builder.build();\n  }",
    "comment": " Creates a tree hierarchy representing a typed argument list.  @param lastVarArgs whether the last type should considered as a variable length argument. @param parameterTypes the parameter types. The last element of this array is considered a variable length argument is {@code lastVarArgs} is {@code true}. @return a tree hierarchy representing a typed argument list ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "JSTypeRegistry.createParametersWithVarArgs",
    "class_name": "com.google.javascript.rhino.jstype.JSTypeRegistry",
    "signature": "com.google.javascript.rhino.jstype.JSTypeRegistry.createParametersWithVarArgs(JSType[])",
    "snippet": "  public Node createParametersWithVarArgs(JSType... parameterTypes) {\n    return createParameters(true, parameterTypes);\n  }",
    "comment": " Creates a tree hierarchy representing a typed argument list. The last parameter type is considered a variable length argument.  @param parameterTypes the parameter types. The last element of this array is considered a variable length argument. @return a tree hierarchy representing a typed argument list. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "JSTypeRegistry.createUnionType",
    "class_name": "com.google.javascript.rhino.jstype.JSTypeRegistry",
    "signature": "com.google.javascript.rhino.jstype.JSTypeRegistry.createUnionType(JSType[])",
    "snippet": "  public JSType createUnionType(JSType... variants) {\n    UnionTypeBuilder builder = new UnionTypeBuilder(this);\n    for (JSType type : variants) {\n      builder.addAlternate(type);\n    }\n    return builder.build();\n  }",
    "comment": " Creates a union type whose variants are the arguments. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "JSTypeRegistry.getNativeFunctionType",
    "class_name": "com.google.javascript.rhino.jstype.JSTypeRegistry",
    "signature": "com.google.javascript.rhino.jstype.JSTypeRegistry.getNativeFunctionType(JSTypeNative)",
    "snippet": "  public FunctionType getNativeFunctionType(JSTypeNative typeId) {\n    return (FunctionType) getNativeType(typeId);\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "JSTypeRegistry.getNativeObjectType",
    "class_name": "com.google.javascript.rhino.jstype.JSTypeRegistry",
    "signature": "com.google.javascript.rhino.jstype.JSTypeRegistry.getNativeObjectType(JSTypeNative)",
    "snippet": "  public ObjectType getNativeObjectType(JSTypeNative typeId) {\n    return (ObjectType) getNativeType(typeId);\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "JSTypeRegistry.getNativeType",
    "class_name": "com.google.javascript.rhino.jstype.JSTypeRegistry",
    "signature": "com.google.javascript.rhino.jstype.JSTypeRegistry.getNativeType(JSTypeNative)",
    "snippet": "  public JSType getNativeType(JSTypeNative typeId) {\n    return nativeTypes[typeId.ordinal()];\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "JSTypeRegistry.initializeBuiltInTypes",
    "class_name": "com.google.javascript.rhino.jstype.JSTypeRegistry",
    "signature": "com.google.javascript.rhino.jstype.JSTypeRegistry.initializeBuiltInTypes()",
    "snippet": "  private void initializeBuiltInTypes() {\n    // These locals shouldn't be all caps.\n    BooleanType BOOLEAN_TYPE = new BooleanType(this);\n    registerNativeType(JSTypeNative.BOOLEAN_TYPE, BOOLEAN_TYPE);\n\n    NullType NULL_TYPE = new NullType(this);\n    registerNativeType(JSTypeNative.NULL_TYPE, NULL_TYPE);\n\n    NumberType NUMBER_TYPE = new NumberType(this);\n    registerNativeType(JSTypeNative.NUMBER_TYPE, NUMBER_TYPE);\n\n    StringType STRING_TYPE = new StringType(this);\n    registerNativeType(JSTypeNative.STRING_TYPE, STRING_TYPE);\n\n    UnknownType UNKNOWN_TYPE = new UnknownType(this, false);\n    registerNativeType(JSTypeNative.UNKNOWN_TYPE, UNKNOWN_TYPE);\n    registerNativeType(\n        JSTypeNative.CHECKED_UNKNOWN_TYPE, new UnknownType(this, true));\n\n    VoidType VOID_TYPE = new VoidType(this);\n    registerNativeType(JSTypeNative.VOID_TYPE, VOID_TYPE);\n\n    AllType ALL_TYPE = new AllType(this);\n    registerNativeType(JSTypeNative.ALL_TYPE, ALL_TYPE);\n\n    // Top Level Prototype (the One)\n    // The initializations of TOP_LEVEL_PROTOTYPE and OBJECT_FUNCTION_TYPE\n    // use each other's results, so at least one of them will get null\n    // instead of an actual type; however, this seems to be benign.\n    ObjectType TOP_LEVEL_PROTOTYPE =\n        new FunctionPrototypeType(this, null, null, true);\n    registerNativeType(JSTypeNative.TOP_LEVEL_PROTOTYPE, TOP_LEVEL_PROTOTYPE);\n\n    // Object\n    FunctionType OBJECT_FUNCTION_TYPE =\n        new FunctionType(this, \"Object\", null,\n            createArrowType(createOptionalParameters(ALL_TYPE), UNKNOWN_TYPE),\n            null, null, true, true);\n    OBJECT_FUNCTION_TYPE.defineDeclaredProperty(\n        \"prototype\", TOP_LEVEL_PROTOTYPE, null);\n    registerNativeType(JSTypeNative.OBJECT_FUNCTION_TYPE, OBJECT_FUNCTION_TYPE);\n\n    ObjectType OBJECT_PROTOTYPE = OBJECT_FUNCTION_TYPE.getPrototype();\n    registerNativeType(JSTypeNative.OBJECT_PROTOTYPE, OBJECT_PROTOTYPE);\n\n    ObjectType OBJECT_TYPE = OBJECT_FUNCTION_TYPE.getInstanceType();\n    registerNativeType(JSTypeNative.OBJECT_TYPE, OBJECT_TYPE);\n\n    // Function\n    FunctionType FUNCTION_FUNCTION_TYPE =\n        new FunctionType(this, \"Function\", null,\n            createArrowType(\n                createParametersWithVarArgs(ALL_TYPE), UNKNOWN_TYPE),\n            null, null, true, true);\n    FUNCTION_FUNCTION_TYPE.setPrototypeBasedOn(OBJECT_TYPE);\n    registerNativeType(\n        JSTypeNative.FUNCTION_FUNCTION_TYPE, FUNCTION_FUNCTION_TYPE);\n\n    ObjectType FUNCTION_PROTOTYPE = FUNCTION_FUNCTION_TYPE.getPrototype();\n    registerNativeType(JSTypeNative.FUNCTION_PROTOTYPE, FUNCTION_PROTOTYPE);\n\n    NoType NO_TYPE = new NoType(this);\n    registerNativeType(JSTypeNative.NO_TYPE, NO_TYPE);\n\n    NoObjectType NO_OBJECT_TYPE = new NoObjectType(this);\n    registerNativeType(JSTypeNative.NO_OBJECT_TYPE, NO_OBJECT_TYPE);\n\n    NoObjectType NO_RESOLVED_TYPE = new NoResolvedType(this);\n    registerNativeType(JSTypeNative.NO_RESOLVED_TYPE, NO_RESOLVED_TYPE);\n\n    // Array\n    FunctionType ARRAY_FUNCTION_TYPE =\n      new FunctionType(this, \"Array\", null,\n          createArrowType(createParametersWithVarArgs(ALL_TYPE), null),\n          null, null, true, true);\n    ARRAY_FUNCTION_TYPE.getInternalArrowType().returnType =\n        ARRAY_FUNCTION_TYPE.getInstanceType();\n\n    ObjectType arrayPrototype = ARRAY_FUNCTION_TYPE.getPrototype();\n    registerNativeType(JSTypeNative.ARRAY_FUNCTION_TYPE, ARRAY_FUNCTION_TYPE);\n\n    ObjectType ARRAY_TYPE = ARRAY_FUNCTION_TYPE.getInstanceType();\n    registerNativeType(JSTypeNative.ARRAY_TYPE, ARRAY_TYPE);\n\n    // Boolean\n    FunctionType BOOLEAN_OBJECT_FUNCTION_TYPE =\n        new FunctionType(this, \"Boolean\", null,\n            createArrowType(createParameters(false, ALL_TYPE), BOOLEAN_TYPE),\n            null, null, true, true);\n    ObjectType booleanPrototype = BOOLEAN_OBJECT_FUNCTION_TYPE.getPrototype();\n    registerNativeType(\n        JSTypeNative.BOOLEAN_OBJECT_FUNCTION_TYPE,\n        BOOLEAN_OBJECT_FUNCTION_TYPE);\n\n    ObjectType BOOLEAN_OBJECT_TYPE =\n        BOOLEAN_OBJECT_FUNCTION_TYPE.getInstanceType();\n    registerNativeType(JSTypeNative.BOOLEAN_OBJECT_TYPE, BOOLEAN_OBJECT_TYPE);\n\n    // Date\n    FunctionType DATE_FUNCTION_TYPE =\n      new FunctionType(this, \"Date\", null,\n          createArrowType(\n              createOptionalParameters(UNKNOWN_TYPE, UNKNOWN_TYPE, UNKNOWN_TYPE,\n                  UNKNOWN_TYPE, UNKNOWN_TYPE, UNKNOWN_TYPE, UNKNOWN_TYPE),\n              STRING_TYPE),\n          null, null, true, true);\n    ObjectType datePrototype = DATE_FUNCTION_TYPE.getPrototype();\n    registerNativeType(JSTypeNative.DATE_FUNCTION_TYPE, DATE_FUNCTION_TYPE);\n\n    ObjectType DATE_TYPE = DATE_FUNCTION_TYPE.getInstanceType();\n    registerNativeType(JSTypeNative.DATE_TYPE, DATE_TYPE);\n\n    // Error\n    FunctionType ERROR_FUNCTION_TYPE = new ErrorFunctionType(this, \"Error\");\n    registerNativeType(JSTypeNative.ERROR_FUNCTION_TYPE, ERROR_FUNCTION_TYPE);\n\n    ObjectType ERROR_TYPE = ERROR_FUNCTION_TYPE.getInstanceType();\n    registerNativeType(JSTypeNative.ERROR_TYPE, ERROR_TYPE);\n\n    // EvalError\n    FunctionType EVAL_ERROR_FUNCTION_TYPE =\n        new ErrorFunctionType(this, \"EvalError\");\n    EVAL_ERROR_FUNCTION_TYPE.setPrototypeBasedOn(ERROR_TYPE);\n    registerNativeType(\n        JSTypeNative.EVAL_ERROR_FUNCTION_TYPE, EVAL_ERROR_FUNCTION_TYPE);\n\n    ObjectType EVAL_ERROR_TYPE = EVAL_ERROR_FUNCTION_TYPE.getInstanceType();\n    registerNativeType(JSTypeNative.EVAL_ERROR_TYPE, EVAL_ERROR_TYPE);\n\n    // RangeError\n    FunctionType RANGE_ERROR_FUNCTION_TYPE =\n        new ErrorFunctionType(this, \"RangeError\");\n    RANGE_ERROR_FUNCTION_TYPE.setPrototypeBasedOn(ERROR_TYPE);\n    registerNativeType(\n        JSTypeNative.RANGE_ERROR_FUNCTION_TYPE, RANGE_ERROR_FUNCTION_TYPE);\n\n    ObjectType RANGE_ERROR_TYPE = RANGE_ERROR_FUNCTION_TYPE.getInstanceType();\n    registerNativeType(JSTypeNative.RANGE_ERROR_TYPE, RANGE_ERROR_TYPE);\n\n    // ReferenceError\n    FunctionType REFERENCE_ERROR_FUNCTION_TYPE =\n        new ErrorFunctionType(this, \"ReferenceError\");\n    REFERENCE_ERROR_FUNCTION_TYPE.setPrototypeBasedOn(ERROR_TYPE);\n    registerNativeType(\n        JSTypeNative.REFERENCE_ERROR_FUNCTION_TYPE,\n        REFERENCE_ERROR_FUNCTION_TYPE);\n\n    ObjectType REFERENCE_ERROR_TYPE =\n        REFERENCE_ERROR_FUNCTION_TYPE.getInstanceType();\n    registerNativeType(JSTypeNative.REFERENCE_ERROR_TYPE, REFERENCE_ERROR_TYPE);\n\n    // SyntaxError\n    FunctionType SYNTAX_ERROR_FUNCTION_TYPE =\n        new ErrorFunctionType(this, \"SyntaxError\");\n    SYNTAX_ERROR_FUNCTION_TYPE.setPrototypeBasedOn(ERROR_TYPE);\n    registerNativeType(\n        JSTypeNative.SYNTAX_ERROR_FUNCTION_TYPE, SYNTAX_ERROR_FUNCTION_TYPE);\n\n    ObjectType SYNTAX_ERROR_TYPE = SYNTAX_ERROR_FUNCTION_TYPE.getInstanceType();\n    registerNativeType(JSTypeNative.SYNTAX_ERROR_TYPE, SYNTAX_ERROR_TYPE);\n\n    // TypeError\n    FunctionType TYPE_ERROR_FUNCTION_TYPE =\n        new ErrorFunctionType(this, \"TypeError\");\n    TYPE_ERROR_FUNCTION_TYPE.setPrototypeBasedOn(ERROR_TYPE);\n    registerNativeType(\n        JSTypeNative.TYPE_ERROR_FUNCTION_TYPE, TYPE_ERROR_FUNCTION_TYPE);\n\n    ObjectType TYPE_ERROR_TYPE = TYPE_ERROR_FUNCTION_TYPE.getInstanceType();\n    registerNativeType(JSTypeNative.TYPE_ERROR_TYPE, TYPE_ERROR_TYPE);\n\n    // URIError\n    FunctionType URI_ERROR_FUNCTION_TYPE =\n        new ErrorFunctionType(this, \"URIError\");\n    URI_ERROR_FUNCTION_TYPE.setPrototypeBasedOn(ERROR_TYPE);\n    registerNativeType(\n        JSTypeNative.URI_ERROR_FUNCTION_TYPE, URI_ERROR_FUNCTION_TYPE);\n\n    ObjectType URI_ERROR_TYPE = URI_ERROR_FUNCTION_TYPE.getInstanceType();\n    registerNativeType(JSTypeNative.URI_ERROR_TYPE, URI_ERROR_TYPE);\n\n    // Number\n    FunctionType NUMBER_OBJECT_FUNCTION_TYPE =\n        new FunctionType(this, \"Number\", null,\n            createArrowType(createParameters(false, ALL_TYPE), NUMBER_TYPE),\n            null, null, true, true);\n    ObjectType numberPrototype = NUMBER_OBJECT_FUNCTION_TYPE.getPrototype();\n    registerNativeType(\n        JSTypeNative.NUMBER_OBJECT_FUNCTION_TYPE, NUMBER_OBJECT_FUNCTION_TYPE);\n\n    ObjectType NUMBER_OBJECT_TYPE =\n        NUMBER_OBJECT_FUNCTION_TYPE.getInstanceType();\n    registerNativeType(JSTypeNative.NUMBER_OBJECT_TYPE, NUMBER_OBJECT_TYPE);\n\n    // RegExp\n    FunctionType REGEXP_FUNCTION_TYPE =\n      new FunctionType(this, \"RegExp\", null,\n          createArrowType(createOptionalParameters(ALL_TYPE, ALL_TYPE)),\n          null, null, true, true);\n    REGEXP_FUNCTION_TYPE.getInternalArrowType().returnType =\n        REGEXP_FUNCTION_TYPE.getInstanceType();\n\n    ObjectType regexpPrototype = REGEXP_FUNCTION_TYPE.getPrototype();\n    registerNativeType(JSTypeNative.REGEXP_FUNCTION_TYPE, REGEXP_FUNCTION_TYPE);\n\n    ObjectType REGEXP_TYPE = REGEXP_FUNCTION_TYPE.getInstanceType();\n    registerNativeType(JSTypeNative.REGEXP_TYPE, REGEXP_TYPE);\n\n    // String\n    FunctionType STRING_OBJECT_FUNCTION_TYPE =\n        new FunctionType(this, \"String\", null,\n            createArrowType(createParameters(false, ALL_TYPE), STRING_TYPE),\n            null, null, true, true);\n    ObjectType stringPrototype = STRING_OBJECT_FUNCTION_TYPE.getPrototype();\n    registerNativeType(\n        JSTypeNative.STRING_OBJECT_FUNCTION_TYPE, STRING_OBJECT_FUNCTION_TYPE);\n\n    ObjectType STRING_OBJECT_TYPE =\n        STRING_OBJECT_FUNCTION_TYPE.getInstanceType();\n    registerNativeType(\n        JSTypeNative.STRING_OBJECT_TYPE, STRING_OBJECT_TYPE);\n\n    // (Object,string,number)\n    JSType OBJECT_NUMBER_STRING =\n        createUnionType(OBJECT_TYPE, NUMBER_TYPE, STRING_TYPE);\n    registerNativeType(JSTypeNative.OBJECT_NUMBER_STRING, OBJECT_NUMBER_STRING);\n\n    // (Object,string,number,boolean)\n    JSType OBJECT_NUMBER_STRING_BOOLEAN =\n        createUnionType(OBJECT_TYPE, NUMBER_TYPE, STRING_TYPE, BOOLEAN_TYPE);\n    registerNativeType(JSTypeNative.OBJECT_NUMBER_STRING_BOOLEAN,\n        OBJECT_NUMBER_STRING_BOOLEAN);\n\n    // (string,number,boolean)\n    JSType NUMBER_STRING_BOOLEAN =\n        createUnionType(NUMBER_TYPE, STRING_TYPE, BOOLEAN_TYPE);\n    registerNativeType(JSTypeNative.NUMBER_STRING_BOOLEAN,\n        NUMBER_STRING_BOOLEAN);\n\n    // (string,number)\n    JSType NUMBER_STRING = createUnionType(NUMBER_TYPE, STRING_TYPE);\n    registerNativeType(JSTypeNative.NUMBER_STRING, NUMBER_STRING);\n\n    // Native object properties are filled in by externs...\n\n    // (String, string)\n    JSType STRING_VALUE_OR_OBJECT_TYPE =\n        createUnionType(STRING_OBJECT_TYPE, STRING_TYPE);\n    registerNativeType(\n        JSTypeNative.STRING_VALUE_OR_OBJECT_TYPE, STRING_VALUE_OR_OBJECT_TYPE);\n\n    // (Number, number)\n    JSType NUMBER_VALUE_OR_OBJECT_TYPE =\n        createUnionType(NUMBER_OBJECT_TYPE, NUMBER_TYPE);\n    registerNativeType(\n        JSTypeNative.NUMBER_VALUE_OR_OBJECT_TYPE, NUMBER_VALUE_OR_OBJECT_TYPE);\n\n    // unknown function type, i.e. (?...) -> ?\n    FunctionType U2U_FUNCTION_TYPE =\n        createFunctionType(UNKNOWN_TYPE, true, UNKNOWN_TYPE);\n    registerNativeType(JSTypeNative.U2U_FUNCTION_TYPE, U2U_FUNCTION_TYPE);\n\n    // unknown constructor type, i.e. (?...) -> ? with the NoObject type\n    // as instance type\n    FunctionType U2U_CONSTRUCTOR_TYPE =\n        // This is equivalent to\n        // createConstructorType(UNKNOWN_TYPE, true, UNKNOWN_TYPE), but,\n        // in addition, overrides getInstanceType() to return the NoObject type\n        // instead of a new anonymous object.\n        new FunctionType(this, \"Function\", null,\n            createArrowType(\n                createParametersWithVarArgs(UNKNOWN_TYPE),\n                UNKNOWN_TYPE),\n            NO_OBJECT_TYPE, null, true, true) {\n          private static final long serialVersionUID = 1L;\n\n          @Override public FunctionType getConstructor() {\n            return registry.getNativeFunctionType(\n                JSTypeNative.FUNCTION_FUNCTION_TYPE);\n          }\n        };\n\n    // The U2U_CONSTRUCTOR is weird, because it's the supertype of its\n    // own constructor.\n    registerNativeType(JSTypeNative.U2U_CONSTRUCTOR_TYPE, U2U_CONSTRUCTOR_TYPE);\n    registerNativeType(\n        JSTypeNative.FUNCTION_INSTANCE_TYPE, U2U_CONSTRUCTOR_TYPE);\n\n    FUNCTION_FUNCTION_TYPE.setInstanceType(U2U_CONSTRUCTOR_TYPE);\n    U2U_CONSTRUCTOR_TYPE.setImplicitPrototype(FUNCTION_PROTOTYPE);\n\n    // least function type, i.e. (All...) -> NoType\n    FunctionType LEAST_FUNCTION_TYPE =\n        createFunctionType(NO_TYPE, true, ALL_TYPE);\n    registerNativeType(JSTypeNative.LEAST_FUNCTION_TYPE, LEAST_FUNCTION_TYPE);\n\n    // the 'this' object in the global scope\n    FunctionType GLOBAL_THIS_CTOR =\n        new FunctionType(this, \"global this\", null,\n            createArrowType(createParameters(false, ALL_TYPE), NUMBER_TYPE),\n            null, null, true, true);\n    ObjectType GLOBAL_THIS = GLOBAL_THIS_CTOR.getInstanceType();\n    registerNativeType(JSTypeNative.GLOBAL_THIS, GLOBAL_THIS);\n\n    // greatest function type, i.e. (NoType...) -> All\n    FunctionType GREATEST_FUNCTION_TYPE =\n      createFunctionType(ALL_TYPE, true, NO_TYPE);\n    registerNativeType(JSTypeNative.GREATEST_FUNCTION_TYPE,\n        GREATEST_FUNCTION_TYPE);\n\n    // Register the prototype property. See the comments below in\n    // registerPropertyOnType about the bootstrapping process.\n    registerPropertyOnType(\"prototype\", OBJECT_FUNCTION_TYPE);\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "JSTypeRegistry.initializeRegistry",
    "class_name": "com.google.javascript.rhino.jstype.JSTypeRegistry",
    "signature": "com.google.javascript.rhino.jstype.JSTypeRegistry.initializeRegistry()",
    "snippet": "  private void initializeRegistry() {\n    register(getNativeType(JSTypeNative.ARRAY_TYPE));\n    register(getNativeType(JSTypeNative.BOOLEAN_OBJECT_TYPE));\n    register(getNativeType(JSTypeNative.BOOLEAN_TYPE));\n    register(getNativeType(JSTypeNative.DATE_TYPE));\n    register(getNativeType(JSTypeNative.NULL_TYPE));\n    register(getNativeType(JSTypeNative.NULL_TYPE), \"Null\");\n    register(getNativeType(JSTypeNative.NUMBER_OBJECT_TYPE));\n    register(getNativeType(JSTypeNative.NUMBER_TYPE));\n    register(getNativeType(JSTypeNative.OBJECT_TYPE));\n    register(getNativeType(JSTypeNative.ERROR_TYPE));\n    register(getNativeType(JSTypeNative.URI_ERROR_TYPE));\n    register(getNativeType(JSTypeNative.EVAL_ERROR_TYPE));\n    register(getNativeType(JSTypeNative.TYPE_ERROR_TYPE));\n    register(getNativeType(JSTypeNative.RANGE_ERROR_TYPE));\n    register(getNativeType(JSTypeNative.REFERENCE_ERROR_TYPE));\n    register(getNativeType(JSTypeNative.SYNTAX_ERROR_TYPE));\n    register(getNativeType(JSTypeNative.REGEXP_TYPE));\n    register(getNativeType(JSTypeNative.STRING_OBJECT_TYPE));\n    register(getNativeType(JSTypeNative.STRING_TYPE));\n    register(getNativeType(JSTypeNative.VOID_TYPE));\n    register(getNativeType(JSTypeNative.VOID_TYPE), \"Undefined\");\n    register(getNativeType(JSTypeNative.VOID_TYPE), \"void\");\n    register(getNativeType(JSTypeNative.FUNCTION_INSTANCE_TYPE), \"Function\");\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "JSTypeRegistry.register",
    "class_name": "com.google.javascript.rhino.jstype.JSTypeRegistry",
    "signature": "com.google.javascript.rhino.jstype.JSTypeRegistry.register(JSType)",
    "snippet": "  private void register(JSType type) {\n    register(type, type.toString());\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "JSTypeRegistry.register",
    "class_name": "com.google.javascript.rhino.jstype.JSTypeRegistry",
    "signature": "com.google.javascript.rhino.jstype.JSTypeRegistry.register(JSType,String)",
    "snippet": "  private void register(JSType type, String name) {\n    namesToTypes.put(name, type);\n\n    // Add all the namespaces in which this name lives.\n    while (name.indexOf('.') > 0) {\n      name = name.substring(0, name.lastIndexOf('.'));\n      namespaces.add(name);\n    }\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "JSTypeRegistry.registerNativeType",
    "class_name": "com.google.javascript.rhino.jstype.JSTypeRegistry",
    "signature": "com.google.javascript.rhino.jstype.JSTypeRegistry.registerNativeType(JSTypeNative,JSType)",
    "snippet": "  private void registerNativeType(JSTypeNative typeId, JSType type) {\n    nativeTypes[typeId.ordinal()] = type;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "JSTypeRegistry.registerPropertyOnType",
    "class_name": "com.google.javascript.rhino.jstype.JSTypeRegistry",
    "signature": "com.google.javascript.rhino.jstype.JSTypeRegistry.registerPropertyOnType(String,JSType)",
    "snippet": "  public void registerPropertyOnType(String propertyName, JSType type) {\n    UnionTypeBuilder typeSet = typesIndexedByProperty.get(propertyName);\n    if (typeSet == null) {\n      typeSet = new UnionTypeBuilder(this, PROPERTY_CHECKING_UNION_SIZE);\n      typesIndexedByProperty.put(propertyName, typeSet);\n    }\n\n    typeSet.addAlternate(type);\n    addReferenceTypeIndexedByProperty(propertyName, type);\n\n    // Clear cached values that depend on typesIndexedByProperty.\n    greatestSubtypeByProperty.remove(propertyName);\n  }",
    "comment": " Tells the type system that {@code owner} may have a property named {@code propertyName}. This allows the registry to keep track of what types a property is defined upon.  This is NOT the same as saying that {@code owner} must have a property named type. ObjectType#hasProperty attempts to minimize false positives (\"if we're not sure, then don't type check this property\"). The type registry, on the other hand, should attempt to minimize false negatives (\"if this property is assigned anywhere in the program, it must show up in the type registry\"). ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "JSTypeRegistry.resetForTypeCheck",
    "class_name": "com.google.javascript.rhino.jstype.JSTypeRegistry",
    "signature": "com.google.javascript.rhino.jstype.JSTypeRegistry.resetForTypeCheck()",
    "snippet": "  public void resetForTypeCheck() {\n    typesIndexedByProperty.clear();\n    eachRefTypeIndexedByProperty.clear();\n    initializeBuiltInTypes();\n    namesToTypes.clear();\n    namespaces.clear();\n    initializeRegistry();\n  }",
    "comment": " Reset to run the TypeCheck pass. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "NoObjectType.NoObjectType",
    "class_name": "com.google.javascript.rhino.jstype.NoObjectType",
    "signature": "com.google.javascript.rhino.jstype.NoObjectType.NoObjectType(JSTypeRegistry)",
    "snippet": "  NoObjectType(JSTypeRegistry registry) {\n    super(registry, null, null,\n          registry.createArrowType(null, null),\n          null, null, true, true);\n    getInternalArrowType().returnType = this;\n    this.setInstanceType(this);\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "NoResolvedType.NoResolvedType",
    "class_name": "com.google.javascript.rhino.jstype.NoResolvedType",
    "signature": "com.google.javascript.rhino.jstype.NoResolvedType.NoResolvedType(JSTypeRegistry)",
    "snippet": "  NoResolvedType(JSTypeRegistry registry) {\n    super(registry);\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "NoType.NoType",
    "class_name": "com.google.javascript.rhino.jstype.NoType",
    "signature": "com.google.javascript.rhino.jstype.NoType.NoType(JSTypeRegistry)",
    "snippet": "  NoType(JSTypeRegistry registry) {\n    super(registry);\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "NoType.isNoType",
    "class_name": "com.google.javascript.rhino.jstype.NoType",
    "signature": "com.google.javascript.rhino.jstype.NoType.isNoType()",
    "snippet": "  @Override\n  public boolean isNoType() {\n    return true;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "NullType.NullType",
    "class_name": "com.google.javascript.rhino.jstype.NullType",
    "signature": "com.google.javascript.rhino.jstype.NullType.NullType(JSTypeRegistry)",
    "snippet": "  NullType(JSTypeRegistry registry) {\n    super(registry);\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "NullType.getDisplayName",
    "class_name": "com.google.javascript.rhino.jstype.NullType",
    "signature": "com.google.javascript.rhino.jstype.NullType.getDisplayName()",
    "snippet": "  @Override\n  public String getDisplayName() {\n    return \"null\";\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "NullType.toString",
    "class_name": "com.google.javascript.rhino.jstype.NullType",
    "signature": "com.google.javascript.rhino.jstype.NullType.toString()",
    "snippet": "  @Override\n  public String toString() {\n    return getDisplayName();\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "NumberType.NumberType",
    "class_name": "com.google.javascript.rhino.jstype.NumberType",
    "signature": "com.google.javascript.rhino.jstype.NumberType.NumberType(JSTypeRegistry)",
    "snippet": "  NumberType(JSTypeRegistry registry) {\n    super(registry);\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "NumberType.getDisplayName",
    "class_name": "com.google.javascript.rhino.jstype.NumberType",
    "signature": "com.google.javascript.rhino.jstype.NumberType.getDisplayName()",
    "snippet": "  @Override\n  public String getDisplayName() {\n    return \"number\";\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "NumberType.toString",
    "class_name": "com.google.javascript.rhino.jstype.NumberType",
    "signature": "com.google.javascript.rhino.jstype.NumberType.toString()",
    "snippet": "  @Override\n  public String toString() {\n    return getDisplayName();\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "ObjectType.ObjectType",
    "class_name": "com.google.javascript.rhino.jstype.ObjectType",
    "signature": "com.google.javascript.rhino.jstype.ObjectType.ObjectType(JSTypeRegistry)",
    "snippet": "  ObjectType(JSTypeRegistry registry) {\n    super(registry);\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "ObjectType.cast",
    "class_name": "com.google.javascript.rhino.jstype.ObjectType",
    "signature": "com.google.javascript.rhino.jstype.ObjectType.cast(JSType)",
    "snippet": "  public static ObjectType cast(JSType type) {\n    return type == null ? null : type.toObjectType();\n  }",
    "comment": " A null-safe version of JSType#toObjectType. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "ObjectType.clearCachedValues",
    "class_name": "com.google.javascript.rhino.jstype.ObjectType",
    "signature": "com.google.javascript.rhino.jstype.ObjectType.clearCachedValues()",
    "snippet": "  public void clearCachedValues() {\n    unknown = true;\n  }",
    "comment": " Clear cached values. Should be called before making changes to a prototype that may have been changed since creation. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "ObjectType.createDelegateSuffix",
    "class_name": "com.google.javascript.rhino.jstype.ObjectType",
    "signature": "com.google.javascript.rhino.jstype.ObjectType.createDelegateSuffix(String)",
    "snippet": "  public static String createDelegateSuffix(String suffix) {\n    return \"(\" + suffix + \")\";\n  }",
    "comment": " Creates a suffix for a proxy delegate. @see #getNormalizedReferenceName ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "ObjectType.defineDeclaredProperty",
    "class_name": "com.google.javascript.rhino.jstype.ObjectType",
    "signature": "com.google.javascript.rhino.jstype.ObjectType.defineDeclaredProperty(String,JSType,Node)",
    "snippet": "  public final boolean defineDeclaredProperty(String propertyName,\n      JSType type, Node propertyNode) {\n    boolean result = defineProperty(propertyName, type, false,\n        propertyNode);\n\n    // All property definitions go through this method\n    // or defineDeclaredProperty. Because the properties defined an an\n    // object can affect subtyping, it's slightly more efficient\n    // to register this after defining the property.\n    registry.registerPropertyOnType(propertyName, this);\n\n    return result;\n  }",
    "comment": " Defines a property whose type is synthesized (i.e. not inferred). @param propertyName the property's name @param type the type @param propertyNode the node corresponding to the declaration of property which might later be accessed using {@code getPropertyNode}. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "ObjectType.getCtorExtendedInterfaces",
    "class_name": "com.google.javascript.rhino.jstype.ObjectType",
    "signature": "com.google.javascript.rhino.jstype.ObjectType.getCtorExtendedInterfaces()",
    "snippet": "  public Iterable<ObjectType> getCtorExtendedInterfaces() {\n    return ImmutableSet.of();\n  }",
    "comment": " Gets the interfaces extended by the interface associated with this type. Intended to be overriden by subclasses. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "ObjectType.hasCachedValues",
    "class_name": "com.google.javascript.rhino.jstype.ObjectType",
    "signature": "com.google.javascript.rhino.jstype.ObjectType.hasCachedValues()",
    "snippet": "  public boolean hasCachedValues() {\n    return !unknown;\n  }",
    "comment": " Returns true if any cached valeus have been set for this type.  If true, then the prototype chain should not be changed, as it might invalidate the cached values. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "ObjectType.isImplicitPrototype",
    "class_name": "com.google.javascript.rhino.jstype.ObjectType",
    "signature": "com.google.javascript.rhino.jstype.ObjectType.isImplicitPrototype(ObjectType)",
    "snippet": "  final boolean isImplicitPrototype(ObjectType prototype) {\n    for (ObjectType current = this;\n         current != null;\n         current = current.getImplicitPrototype()) {\n      if (current.isEquivalentTo(prototype)) {\n        return true;\n      }\n    }\n    return false;\n  }",
    "comment": " Checks that the prototype is an implicit prototype of this object. Since each object has an implicit prototype, an implicit prototype's implicit prototype is also this implicit prototype's.  @param prototype any prototype based object  @return {@code true} if {@code prototype} is {@code equal} to any object in this object's implicit prototype chain. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "ObjectType.isUnknownType",
    "class_name": "com.google.javascript.rhino.jstype.ObjectType",
    "signature": "com.google.javascript.rhino.jstype.ObjectType.isUnknownType()",
    "snippet": "  @Override\n  public boolean isUnknownType() {\n    // If the object is unknown now, check the supertype again,\n    // because it might have been resolved since the last check.\n    if (unknown) {\n      ObjectType implicitProto = getImplicitPrototype();\n      if (implicitProto == null ||\n          implicitProto.isNativeObjectType()) {\n        unknown = false;\n        for (ObjectType interfaceType : getCtorExtendedInterfaces()) {\n          if (interfaceType.isUnknownType()) {\n            unknown = true;\n            break;\n          }\n        }\n      } else {\n        unknown = implicitProto.isUnknownType();\n      }\n    }\n    return unknown;\n  }",
    "comment": " We treat this as the unknown type if any of its implicit prototype properties is unknown. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "PrototypeObjectType.PrototypeObjectType",
    "class_name": "com.google.javascript.rhino.jstype.PrototypeObjectType",
    "signature": "com.google.javascript.rhino.jstype.PrototypeObjectType.PrototypeObjectType(JSTypeRegistry,String,ObjectType,boolean)",
    "snippet": "  PrototypeObjectType(JSTypeRegistry registry, String className,\n      ObjectType implicitPrototype, boolean nativeType) {\n    super(registry);\n    this.properties = Maps.newTreeMap();\n    this.className = className;\n    this.nativeType = nativeType;\n    if (nativeType || implicitPrototype != null) {\n      setImplicitPrototype(implicitPrototype);\n    } else {\n      setImplicitPrototype(\n          registry.getNativeObjectType(JSTypeNative.OBJECT_TYPE));\n    }\n  }",
    "comment": " Creates an object type, allowing specification of the implicit prototype when creating native objects. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "PrototypeObjectType.getConstructor",
    "class_name": "com.google.javascript.rhino.jstype.PrototypeObjectType",
    "signature": "com.google.javascript.rhino.jstype.PrototypeObjectType.getConstructor()",
    "snippet": "  @Override\n  public FunctionType getConstructor() {\n    return null;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "PrototypeObjectType.getImplicitPrototype",
    "class_name": "com.google.javascript.rhino.jstype.PrototypeObjectType",
    "signature": "com.google.javascript.rhino.jstype.PrototypeObjectType.getImplicitPrototype()",
    "snippet": "  @Override\n  public ObjectType getImplicitPrototype() {\n    return implicitPrototypeFallback;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "PrototypeObjectType.getReferenceName",
    "class_name": "com.google.javascript.rhino.jstype.PrototypeObjectType",
    "signature": "com.google.javascript.rhino.jstype.PrototypeObjectType.getReferenceName()",
    "snippet": "  @Override\n  public String getReferenceName() {\n    if (className != null) {\n      return className;\n    } else {\n      return null;\n    }\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "PrototypeObjectType.hasCachedValues",
    "class_name": "com.google.javascript.rhino.jstype.PrototypeObjectType",
    "signature": "com.google.javascript.rhino.jstype.PrototypeObjectType.hasCachedValues()",
    "snippet": "  @Override\n  public boolean hasCachedValues() {\n    return super.hasCachedValues();\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "PrototypeObjectType.hasReferenceName",
    "class_name": "com.google.javascript.rhino.jstype.PrototypeObjectType",
    "signature": "com.google.javascript.rhino.jstype.PrototypeObjectType.hasReferenceName()",
    "snippet": "  @Override\n  public boolean hasReferenceName() {\n    return className != null;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "PrototypeObjectType.implicitPrototypeChainIsUnknown",
    "class_name": "com.google.javascript.rhino.jstype.PrototypeObjectType",
    "signature": "com.google.javascript.rhino.jstype.PrototypeObjectType.implicitPrototypeChainIsUnknown()",
    "snippet": "  private boolean implicitPrototypeChainIsUnknown() {\n    ObjectType p = getImplicitPrototype();\n    while (p != null) {\n      if (p.isUnknownType()) {\n        return true;\n      }\n      p = p.getImplicitPrototype();\n    }\n    return false;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "PrototypeObjectType.isNativeObjectType",
    "class_name": "com.google.javascript.rhino.jstype.PrototypeObjectType",
    "signature": "com.google.javascript.rhino.jstype.PrototypeObjectType.isNativeObjectType()",
    "snippet": "  @Override\n  public boolean isNativeObjectType() {\n    return nativeType;\n  }",
    "comment": "Whether this is a built-in object. */",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "PrototypeObjectType.isSubtype",
    "class_name": "com.google.javascript.rhino.jstype.PrototypeObjectType",
    "signature": "com.google.javascript.rhino.jstype.PrototypeObjectType.isSubtype(JSType)",
    "snippet": "  @Override\n  public boolean isSubtype(JSType that) {\n    if (JSType.isSubtype(this, that)) {\n      return true;\n    }\n\n    // Union types\n    if (that instanceof UnionType) {\n      // The static {@code JSType.isSubtype} check already decomposed\n      // union types, so we don't need to check those again.\n      return false;\n    }\n\n    // record types\n    if (that instanceof RecordType) {\n      return RecordType.isSubtype(this, (RecordType) that);\n    }\n\n    // Interfaces\n    // Find all the interfaces implemented by this class and compare each one\n    // to the interface instance.\n    ObjectType thatObj = that.toObjectType();\n    ObjectType thatCtor = thatObj == null ? null : thatObj.getConstructor();\n    if (thatCtor != null && thatCtor.isInterface()) {\n      Iterable<ObjectType> thisInterfaces = getCtorImplementedInterfaces();\n      for (ObjectType thisInterface : thisInterfaces) {\n        if (thisInterface.isSubtype(that)) {\n          return true;\n        }\n      }\n    }\n\n    if (getConstructor() != null && getConstructor().isInterface()) {\n      for (ObjectType thisInterface : getCtorExtendedInterfaces()) {\n        if (thisInterface.isSubtype(that)) {\n          return true;\n        }\n      }\n    }\n\n    // other prototype based objects\n    if (isUnknownType() || implicitPrototypeChainIsUnknown()) {\n      // If unsure, say 'yes', to avoid spurious warnings.\n      // TODO(user): resolve the prototype chain completely in all cases,\n      // to avoid guessing.\n      return true;\n    }\n    return this.isImplicitPrototype(thatObj);\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "PrototypeObjectType.setImplicitPrototype",
    "class_name": "com.google.javascript.rhino.jstype.PrototypeObjectType",
    "signature": "com.google.javascript.rhino.jstype.PrototypeObjectType.setImplicitPrototype(ObjectType)",
    "snippet": "  final void setImplicitPrototype(ObjectType implicitPrototype) {\n    checkState(!hasCachedValues());\n    this.implicitPrototypeFallback = implicitPrototype;\n  }",
    "comment": " This should only be reset on the FunctionPrototypeType, only to fix an incorrectly established prototype chain due to the user having a mismatch in super class declaration, and only before properties on that type are processed. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "StringType.StringType",
    "class_name": "com.google.javascript.rhino.jstype.StringType",
    "signature": "com.google.javascript.rhino.jstype.StringType.StringType(JSTypeRegistry)",
    "snippet": "  StringType(JSTypeRegistry registry) {\n    super(registry);\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "StringType.getDisplayName",
    "class_name": "com.google.javascript.rhino.jstype.StringType",
    "signature": "com.google.javascript.rhino.jstype.StringType.getDisplayName()",
    "snippet": "  @Override\n  public String getDisplayName() {\n    return \"string\";\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "StringType.toString",
    "class_name": "com.google.javascript.rhino.jstype.StringType",
    "signature": "com.google.javascript.rhino.jstype.StringType.toString()",
    "snippet": "  @Override\n  public String toString() {\n    return getDisplayName();\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "UnionType.UnionType",
    "class_name": "com.google.javascript.rhino.jstype.UnionType",
    "signature": "com.google.javascript.rhino.jstype.UnionType.UnionType(JSTypeRegistry,Collection)",
    "snippet": "  UnionType(JSTypeRegistry registry, Collection<JSType> alternates) {\n    super(registry);\n    this.alternates = alternates;\n    this.hashcode = this.alternates.hashCode();\n  }",
    "comment": " Creates a union type.  @param alternates the alternates of the union ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "UnionTypeBuilder.UnionTypeBuilder",
    "class_name": "com.google.javascript.rhino.jstype.UnionTypeBuilder",
    "signature": "com.google.javascript.rhino.jstype.UnionTypeBuilder.UnionTypeBuilder(JSTypeRegistry)",
    "snippet": "  UnionTypeBuilder(JSTypeRegistry registry) {\n    this(registry, DEFAULT_MAX_UNION_SIZE);\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "UnionTypeBuilder.UnionTypeBuilder",
    "class_name": "com.google.javascript.rhino.jstype.UnionTypeBuilder",
    "signature": "com.google.javascript.rhino.jstype.UnionTypeBuilder.UnionTypeBuilder(JSTypeRegistry,int)",
    "snippet": "  UnionTypeBuilder(JSTypeRegistry registry, int maxUnionSize) {\n    this.registry = registry;\n    this.maxUnionSize = maxUnionSize;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "UnionTypeBuilder.addAlternate",
    "class_name": "com.google.javascript.rhino.jstype.UnionTypeBuilder",
    "signature": "com.google.javascript.rhino.jstype.UnionTypeBuilder.addAlternate(JSType)",
    "snippet": "  UnionTypeBuilder addAlternate(JSType alternate) {\n    // build() returns the bottom type by default, so we can\n    // just bail out early here.\n    if (alternate.isNoType()) {\n      return this;\n    }\n\n    isAllType = isAllType || alternate.isAllType();\n\n    boolean isAlternateUnknown = alternate instanceof UnknownType;\n    isNativeUnknownType = isNativeUnknownType || isAlternateUnknown;\n    if (isAlternateUnknown) {\n      areAllUnknownsChecked = areAllUnknownsChecked &&\n          alternate.isCheckedUnknownType();\n    }\n    if (!isAllType && !isNativeUnknownType) {\n      if (alternate instanceof UnionType) {\n        UnionType union = (UnionType) alternate;\n        for (JSType unionAlt : union.getAlternates()) {\n          addAlternate(unionAlt);\n        }\n      } else {\n        if (alternates.size() > maxUnionSize) {\n          return this;\n        }\n\n        // Look through the alternates we've got so far,\n        // and check if any of them are duplicates of\n        // one another.\n        Iterator<JSType> it = alternates.iterator();\n        while (it.hasNext()) {\n          JSType current = it.next();\n\n          // Unknown and NoResolved types may just be names that haven't\n          // been resolved yet. So keep these in the union, and just use\n          // equality checking for simple de-duping.\n          if (alternate.isUnknownType() ||\n              current.isUnknownType() ||\n              alternate.isNoResolvedType() ||\n              current.isNoResolvedType()) {\n            if (alternate.isEquivalentTo(current)) {\n              // Alternate is unnecessary.\n              return this;\n            }\n          } else {\n            if (alternate.isSubtype(current)) {\n              // Alternate is unnecessary.\n              return this;\n            } else if (current.isSubtype(alternate)) {\n              // Alternate makes current obsolete\n              it.remove();\n            }\n          }\n        }\n        alternates.add(alternate);\n        result = null; // invalidate the memoized result\n      }\n    } else {\n      result = null;\n    }\n    return this;\n  }",
    "comment": " Adds an alternate to the union type under construction. Returns this for easy chaining. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "UnionTypeBuilder.build",
    "class_name": "com.google.javascript.rhino.jstype.UnionTypeBuilder",
    "signature": "com.google.javascript.rhino.jstype.UnionTypeBuilder.build()",
    "snippet": "  JSType build() {\n    if (result == null) {\n      result = reduceAlternatesWithoutUnion();\n      if (result == null) {\n        result = new UnionType(registry, getAlternateListCopy());\n      }\n    }\n    return result;\n  }",
    "comment": " Creates a union. @return A UnionType if it has two or more alternates, the only alternate if it has one and otherwise {@code NO_TYPE}. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "UnionTypeBuilder.getAlternateListCopy",
    "class_name": "com.google.javascript.rhino.jstype.UnionTypeBuilder",
    "signature": "com.google.javascript.rhino.jstype.UnionTypeBuilder.getAlternateListCopy()",
    "snippet": "  private Collection<JSType> getAlternateListCopy() {\n    return ImmutableList.copyOf(alternates);\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "UnionTypeBuilder.reduceAlternatesWithoutUnion",
    "class_name": "com.google.javascript.rhino.jstype.UnionTypeBuilder",
    "signature": "com.google.javascript.rhino.jstype.UnionTypeBuilder.reduceAlternatesWithoutUnion()",
    "snippet": "  private JSType reduceAlternatesWithoutUnion() {\n    if (isAllType) {\n      return registry.getNativeType(ALL_TYPE);\n    } else if (isNativeUnknownType) {\n      if (areAllUnknownsChecked) {\n        return registry.getNativeType(CHECKED_UNKNOWN_TYPE);\n      } else {\n        return registry.getNativeType(UNKNOWN_TYPE);\n      }\n    } else {\n      int size = alternates.size();\n      if (size > maxUnionSize) {\n        return registry.getNativeType(UNKNOWN_TYPE);\n      } else if (size > 1) {\n        return null;\n      } else if (size == 1) {\n        return alternates.iterator().next();\n      } else {\n        return registry.getNativeType(NO_TYPE);\n      }\n    }\n  }",
    "comment": " Reduce the alternates into a non-union type. If the alternates can't be accurately represented with a non-union type, return null. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "UnknownType.UnknownType",
    "class_name": "com.google.javascript.rhino.jstype.UnknownType",
    "signature": "com.google.javascript.rhino.jstype.UnknownType.UnknownType(JSTypeRegistry,boolean)",
    "snippet": "  UnknownType(JSTypeRegistry registry, boolean isChecked) {\n    super(registry);\n    this.isChecked = isChecked;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "ValueType.ValueType",
    "class_name": "com.google.javascript.rhino.jstype.ValueType",
    "signature": "com.google.javascript.rhino.jstype.ValueType.ValueType(JSTypeRegistry)",
    "snippet": "  ValueType(JSTypeRegistry registry) {\n    super(registry);\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "ValueType.isSubtype",
    "class_name": "com.google.javascript.rhino.jstype.ValueType",
    "signature": "com.google.javascript.rhino.jstype.ValueType.isSubtype(JSType)",
    "snippet": "  @Override\n  public boolean isSubtype(JSType that) {\n    return JSType.isSubtype(this, that);\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "VoidType.VoidType",
    "class_name": "com.google.javascript.rhino.jstype.VoidType",
    "signature": "com.google.javascript.rhino.jstype.VoidType.VoidType(JSTypeRegistry)",
    "snippet": "  VoidType(JSTypeRegistry registry) {\n    super(registry);\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "VoidType.getDisplayName",
    "class_name": "com.google.javascript.rhino.jstype.VoidType",
    "signature": "com.google.javascript.rhino.jstype.VoidType.getDisplayName()",
    "snippet": "  @Override\n  public String getDisplayName() {\n    return \"undefined\";\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "VoidType.toString",
    "class_name": "com.google.javascript.rhino.jstype.VoidType",
    "signature": "com.google.javascript.rhino.jstype.VoidType.toString()",
    "snippet": "  @Override\n  public String toString() {\n    return getDisplayName();\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  }
]