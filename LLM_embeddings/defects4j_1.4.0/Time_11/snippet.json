[
  {
    "name": "DateTimeFieldType.DateTimeFieldType",
    "class_name": "org.joda.time.DateTimeFieldType",
    "signature": "org.joda.time.DateTimeFieldType.DateTimeFieldType(String)",
    "snippet": "    protected DateTimeFieldType(String name) {\n        super();\n        iName = name;\n    }",
    "comment": " Constructor.  @param name  the name to use ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 0
  },
  {
    "name": "DateTimeFieldType.centuryOfEra",
    "class_name": "org.joda.time.DateTimeFieldType",
    "signature": "org.joda.time.DateTimeFieldType.centuryOfEra()",
    "snippet": "    public static DateTimeFieldType centuryOfEra() {\n        return CENTURY_OF_ERA_TYPE;\n    }",
    "comment": " Get the century of era field type.  @return the DateTimeFieldType constant ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 0
  },
  {
    "name": "DateTimeFieldType.clockhourOfDay",
    "class_name": "org.joda.time.DateTimeFieldType",
    "signature": "org.joda.time.DateTimeFieldType.clockhourOfDay()",
    "snippet": "    public static DateTimeFieldType clockhourOfDay() {\n        return CLOCKHOUR_OF_DAY_TYPE;\n    }",
    "comment": " Get the hour of day (offset to 1-24) field type.  @return the DateTimeFieldType constant ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 0
  },
  {
    "name": "DateTimeFieldType.clockhourOfHalfday",
    "class_name": "org.joda.time.DateTimeFieldType",
    "signature": "org.joda.time.DateTimeFieldType.clockhourOfHalfday()",
    "snippet": "    public static DateTimeFieldType clockhourOfHalfday() {\n        return CLOCKHOUR_OF_HALFDAY_TYPE;\n    }",
    "comment": " Get the hour of am/pm (offset to 1-12) field type.  @return the DateTimeFieldType constant ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 0
  },
  {
    "name": "DateTimeFieldType.dayOfMonth",
    "class_name": "org.joda.time.DateTimeFieldType",
    "signature": "org.joda.time.DateTimeFieldType.dayOfMonth()",
    "snippet": "    public static DateTimeFieldType dayOfMonth() {\n        return DAY_OF_MONTH_TYPE;\n    }",
    "comment": " Get the day of month field type.  @return the DateTimeFieldType constant ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 0
  },
  {
    "name": "DateTimeFieldType.dayOfWeek",
    "class_name": "org.joda.time.DateTimeFieldType",
    "signature": "org.joda.time.DateTimeFieldType.dayOfWeek()",
    "snippet": "    public static DateTimeFieldType dayOfWeek() {\n        return DAY_OF_WEEK_TYPE;\n    }",
    "comment": " Get the day of week field type.  @return the DateTimeFieldType constant ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 0
  },
  {
    "name": "DateTimeFieldType.dayOfYear",
    "class_name": "org.joda.time.DateTimeFieldType",
    "signature": "org.joda.time.DateTimeFieldType.dayOfYear()",
    "snippet": "    public static DateTimeFieldType dayOfYear() {\n        return DAY_OF_YEAR_TYPE;\n    }",
    "comment": " Get the day of year field type.  @return the DateTimeFieldType constant ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 0
  },
  {
    "name": "DateTimeFieldType.era",
    "class_name": "org.joda.time.DateTimeFieldType",
    "signature": "org.joda.time.DateTimeFieldType.era()",
    "snippet": "    public static DateTimeFieldType era() {\n        return ERA_TYPE;\n    }",
    "comment": " Get the era field type.  @return the DateTimeFieldType constant ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 0
  },
  {
    "name": "DateTimeFieldType.halfdayOfDay",
    "class_name": "org.joda.time.DateTimeFieldType",
    "signature": "org.joda.time.DateTimeFieldType.halfdayOfDay()",
    "snippet": "    public static DateTimeFieldType halfdayOfDay() {\n        return HALFDAY_OF_DAY_TYPE;\n    }",
    "comment": " Get the AM(0) PM(1) field type.  @return the DateTimeFieldType constant ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 0
  },
  {
    "name": "DateTimeFieldType.hourOfDay",
    "class_name": "org.joda.time.DateTimeFieldType",
    "signature": "org.joda.time.DateTimeFieldType.hourOfDay()",
    "snippet": "    public static DateTimeFieldType hourOfDay() {\n        return HOUR_OF_DAY_TYPE;\n    }",
    "comment": " Get the hour of day (0-23) field type.  @return the DateTimeFieldType constant ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 0
  },
  {
    "name": "DateTimeFieldType.hourOfHalfday",
    "class_name": "org.joda.time.DateTimeFieldType",
    "signature": "org.joda.time.DateTimeFieldType.hourOfHalfday()",
    "snippet": "    public static DateTimeFieldType hourOfHalfday() {\n        return HOUR_OF_HALFDAY_TYPE;\n    }",
    "comment": " Get the hour of am/pm (0-11) field type.  @return the DateTimeFieldType constant ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 0
  },
  {
    "name": "DateTimeFieldType.millisOfDay",
    "class_name": "org.joda.time.DateTimeFieldType",
    "signature": "org.joda.time.DateTimeFieldType.millisOfDay()",
    "snippet": "    public static DateTimeFieldType millisOfDay() {\n        return MILLIS_OF_DAY_TYPE;\n    }",
    "comment": " Get the millis of day field type.  @return the DateTimeFieldType constant ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 0
  },
  {
    "name": "DateTimeFieldType.millisOfSecond",
    "class_name": "org.joda.time.DateTimeFieldType",
    "signature": "org.joda.time.DateTimeFieldType.millisOfSecond()",
    "snippet": "    public static DateTimeFieldType millisOfSecond() {\n        return MILLIS_OF_SECOND_TYPE;\n    }",
    "comment": " Get the millis of second field type.  @return the DateTimeFieldType constant ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 0
  },
  {
    "name": "DateTimeFieldType.minuteOfDay",
    "class_name": "org.joda.time.DateTimeFieldType",
    "signature": "org.joda.time.DateTimeFieldType.minuteOfDay()",
    "snippet": "    public static DateTimeFieldType minuteOfDay() {\n        return MINUTE_OF_DAY_TYPE;\n    }",
    "comment": " Get the minute of day field type.  @return the DateTimeFieldType constant ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 0
  },
  {
    "name": "DateTimeFieldType.minuteOfHour",
    "class_name": "org.joda.time.DateTimeFieldType",
    "signature": "org.joda.time.DateTimeFieldType.minuteOfHour()",
    "snippet": "    public static DateTimeFieldType minuteOfHour() {\n        return MINUTE_OF_HOUR_TYPE;\n    }",
    "comment": " Get the minute of hour field type.  @return the DateTimeFieldType constant ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 0
  },
  {
    "name": "DateTimeFieldType.monthOfYear",
    "class_name": "org.joda.time.DateTimeFieldType",
    "signature": "org.joda.time.DateTimeFieldType.monthOfYear()",
    "snippet": "    public static DateTimeFieldType monthOfYear() {\n        return MONTH_OF_YEAR_TYPE;\n    }",
    "comment": " Get the month of year field type.  @return the DateTimeFieldType constant ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 0
  },
  {
    "name": "DateTimeFieldType.secondOfDay",
    "class_name": "org.joda.time.DateTimeFieldType",
    "signature": "org.joda.time.DateTimeFieldType.secondOfDay()",
    "snippet": "    public static DateTimeFieldType secondOfDay() {\n        return SECOND_OF_DAY_TYPE;\n    }",
    "comment": " Get the second of day field type.  @return the DateTimeFieldType constant ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 0
  },
  {
    "name": "DateTimeFieldType.secondOfMinute",
    "class_name": "org.joda.time.DateTimeFieldType",
    "signature": "org.joda.time.DateTimeFieldType.secondOfMinute()",
    "snippet": "    public static DateTimeFieldType secondOfMinute() {\n        return SECOND_OF_MINUTE_TYPE;\n    }",
    "comment": " Get the second of minute field type.  @return the DateTimeFieldType constant ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 0
  },
  {
    "name": "DateTimeFieldType.weekOfWeekyear",
    "class_name": "org.joda.time.DateTimeFieldType",
    "signature": "org.joda.time.DateTimeFieldType.weekOfWeekyear()",
    "snippet": "    public static DateTimeFieldType weekOfWeekyear() {\n        return WEEK_OF_WEEKYEAR_TYPE;\n    }",
    "comment": " Get the week of a week based year field type.  @return the DateTimeFieldType constant ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 0
  },
  {
    "name": "DateTimeFieldType.weekyear",
    "class_name": "org.joda.time.DateTimeFieldType",
    "signature": "org.joda.time.DateTimeFieldType.weekyear()",
    "snippet": "    public static DateTimeFieldType weekyear() {\n        return WEEKYEAR_TYPE;\n    }",
    "comment": " Get the year of a week based year field type.  @return the DateTimeFieldType constant ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 0
  },
  {
    "name": "DateTimeFieldType.weekyearOfCentury",
    "class_name": "org.joda.time.DateTimeFieldType",
    "signature": "org.joda.time.DateTimeFieldType.weekyearOfCentury()",
    "snippet": "    public static DateTimeFieldType weekyearOfCentury() {\n        return WEEKYEAR_OF_CENTURY_TYPE;\n    }",
    "comment": " Get the year of a week based year within a century field type.  @return the DateTimeFieldType constant ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 0
  },
  {
    "name": "DateTimeFieldType.year",
    "class_name": "org.joda.time.DateTimeFieldType",
    "signature": "org.joda.time.DateTimeFieldType.year()",
    "snippet": "    public static DateTimeFieldType year() {\n        return YEAR_TYPE;\n    }",
    "comment": " Get the year field type.  @return the DateTimeFieldType constant ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 0
  },
  {
    "name": "DateTimeFieldType.yearOfCentury",
    "class_name": "org.joda.time.DateTimeFieldType",
    "signature": "org.joda.time.DateTimeFieldType.yearOfCentury()",
    "snippet": "    public static DateTimeFieldType yearOfCentury() {\n        return YEAR_OF_CENTURY_TYPE;\n    }",
    "comment": " Get the year of century field type.  @return the DateTimeFieldType constant ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 0
  },
  {
    "name": "DateTimeFieldType.yearOfEra",
    "class_name": "org.joda.time.DateTimeFieldType",
    "signature": "org.joda.time.DateTimeFieldType.yearOfEra()",
    "snippet": "    public static DateTimeFieldType yearOfEra() {\n        return YEAR_OF_ERA_TYPE;\n    }",
    "comment": " Get the year of era field type.  @return the DateTimeFieldType constant ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 0
  },
  {
    "name": "StandardDateTimeFieldType.getDurationType",
    "class_name": "org.joda.time.DateTimeFieldType$StandardDateTimeFieldType",
    "signature": "org.joda.time.DateTimeFieldType$StandardDateTimeFieldType.getDurationType()",
    "snippet": "        public DurationFieldType getDurationType() {\n            return iUnitType;\n        }",
    "comment": "@inheritdoc */",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 0
  },
  {
    "name": "StandardDateTimeFieldType.getRangeDurationType",
    "class_name": "org.joda.time.DateTimeFieldType$StandardDateTimeFieldType",
    "signature": "org.joda.time.DateTimeFieldType$StandardDateTimeFieldType.getRangeDurationType()",
    "snippet": "        public DurationFieldType getRangeDurationType() {\n            return iRangeType;\n        }",
    "comment": "@inheritdoc */",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 0
  },
  {
    "name": "DateTimeUtils.currentTimeMillis",
    "class_name": "org.joda.time.DateTimeUtils",
    "signature": "org.joda.time.DateTimeUtils.currentTimeMillis()",
    "snippet": "    public static final long currentTimeMillis() {\n        return cMillisProvider.getMillis();\n    }",
    "comment": " Gets the current time in milliseconds. <p> By default this returns <code>System.currentTimeMillis()</code>. This may be changed using other methods in this class.  @return the current time in milliseconds from 1970-01-01T00:00:00Z ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 0
  },
  {
    "name": "DateTimeUtils.getChronology",
    "class_name": "org.joda.time.DateTimeUtils",
    "signature": "org.joda.time.DateTimeUtils.getChronology(Chronology)",
    "snippet": "    public static final Chronology getChronology(Chronology chrono) {\n        if (chrono == null) {\n            return ISOChronology.getInstance();\n        }\n        return chrono;\n    }",
    "comment": " Gets the chronology handling null. <p> If the chronology is <code>null</code>, {@link ISOChronology#getInstance()} will be returned. Otherwise, the chronology is returned.  @param chrono  the chronology to use, null means ISO in the default zone @return the chronology, never null ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 0
  },
  {
    "name": "DateTimeUtils.getPeriodType",
    "class_name": "org.joda.time.DateTimeUtils",
    "signature": "org.joda.time.DateTimeUtils.getPeriodType(PeriodType)",
    "snippet": "    public static final PeriodType getPeriodType(PeriodType type) {\n        if (type == null) {\n            return PeriodType.standard();\n        }\n        return type;\n    }",
    "comment": " Gets the period type handling null. <p> If the zone is <code>null</code>, {@link PeriodType#standard()} will be returned. Otherwise, the type specified is returned.  @param type  the time zone to use, null means the standard type @return the type to use, never null ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 0
  },
  {
    "name": "DateTimeUtils.put",
    "class_name": "org.joda.time.DateTimeUtils",
    "signature": "org.joda.time.DateTimeUtils.put(Map,String,String)",
    "snippet": "    private static void put(Map<String, DateTimeZone> map, String name, String id) {\n        try {\n            map.put(name, DateTimeZone.forID(id));\n        } catch (RuntimeException ex) {\n            // ignore\n        }\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 0
  },
  {
    "name": "SystemMillisProvider.getMillis",
    "class_name": "org.joda.time.DateTimeUtils$SystemMillisProvider",
    "signature": "org.joda.time.DateTimeUtils$SystemMillisProvider.getMillis()",
    "snippet": "        public long getMillis() {\n            return System.currentTimeMillis();\n        }",
    "comment": " Gets the current time. @return the current time in millis ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 0
  },
  {
    "name": "DateTimeZone.DateTimeZone",
    "class_name": "org.joda.time.DateTimeZone",
    "signature": "org.joda.time.DateTimeZone.DateTimeZone(String)",
    "snippet": "    protected DateTimeZone(String id) {\n        if (id == null) {\n            throw new IllegalArgumentException(\"Id must not be null\");\n        }\n        iID = id;\n    }",
    "comment": " Constructor.  @param id  the id to use @throws IllegalArgumentException if the id is null ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 0
  },
  {
    "name": "DateTimeZone.forID",
    "class_name": "org.joda.time.DateTimeZone",
    "signature": "org.joda.time.DateTimeZone.forID(String)",
    "snippet": "    @FromString\n    public static DateTimeZone forID(String id) {\n        if (id == null) {\n            return getDefault();\n        }\n        if (id.equals(\"UTC\")) {\n            return DateTimeZone.UTC;\n        }\n        DateTimeZone zone = cProvider.getZone(id);\n        if (zone != null) {\n            return zone;\n        }\n        if (id.startsWith(\"+\") || id.startsWith(\"-\")) {\n            int offset = parseOffset(id);\n            if (offset == 0L) {\n                return DateTimeZone.UTC;\n            } else {\n                id = printOffset(offset);\n                return fixedOffsetZone(id, offset);\n            }\n        }\n        throw new IllegalArgumentException(\"The datetime zone id '\" + id + \"' is not recognised\");\n    }",
    "comment": " Gets a time zone instance for the specified time zone id. <p> The time zone id may be one of those returned by getAvailableIDs. Short ids, as accepted by {@link java.util.TimeZone}, are not accepted. All IDs must be specified in the long format. The exception is UTC, which is an acceptable id. <p> Alternatively a locale independent, fixed offset, datetime zone can be specified. The form <code>[+-]hh:mm</code> can be used.  @param id  the ID of the datetime zone, null means default @return the DateTimeZone object for the ID @throws IllegalArgumentException if the ID is not recognised ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 0
  },
  {
    "name": "DateTimeZone.forTimeZone",
    "class_name": "org.joda.time.DateTimeZone",
    "signature": "org.joda.time.DateTimeZone.forTimeZone(TimeZone)",
    "snippet": "    public static DateTimeZone forTimeZone(TimeZone zone) {\n        if (zone == null) {\n            return getDefault();\n        }\n        final String id = zone.getID();\n        if (id.equals(\"UTC\")) {\n            return DateTimeZone.UTC;\n        }\n\n        // Convert from old alias before consulting provider since they may differ.\n        DateTimeZone dtz = null;\n        String convId = getConvertedId(id);\n        if (convId != null) {\n            dtz = cProvider.getZone(convId);\n        }\n        if (dtz == null) {\n            dtz = cProvider.getZone(id);\n        }\n        if (dtz != null) {\n            return dtz;\n        }\n\n        // Support GMT+/-hh:mm formats\n        if (convId == null) {\n            convId = zone.getID();\n            if (convId.startsWith(\"GMT+\") || convId.startsWith(\"GMT-\")) {\n                convId = convId.substring(3);\n                int offset = parseOffset(convId);\n                if (offset == 0L) {\n                    return DateTimeZone.UTC;\n                } else {\n                    convId = printOffset(offset);\n                    return fixedOffsetZone(convId, offset);\n                }\n            }\n        }\n        throw new IllegalArgumentException(\"The datetime zone id '\" + id + \"' is not recognised\");\n    }",
    "comment": " Gets a time zone instance for a JDK TimeZone. <p> DateTimeZone only accepts a subset of the IDs from TimeZone. The excluded IDs are the short three letter form (except UTC). This  method will attempt to convert between time zones created using the short IDs and the full version. <p> This method is not designed to parse time zones with rules created by applications using <code>SimpleTimeZone</code> directly.  @param zone  the zone to convert, null means default @return the DateTimeZone object for the zone @throws IllegalArgumentException if the zone is not recognised ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 0
  },
  {
    "name": "DateTimeZone.getConvertedId",
    "class_name": "org.joda.time.DateTimeZone",
    "signature": "org.joda.time.DateTimeZone.getConvertedId(String)",
    "snippet": "    private static synchronized String getConvertedId(String id) {\n        Map<String, String> map = cZoneIdConversion;\n        if (map == null) {\n            // Backwards compatibility with TimeZone.\n            map = new HashMap<String, String>();\n            map.put(\"GMT\", \"UTC\");\n            map.put(\"WET\", \"WET\");\n            map.put(\"CET\", \"CET\");\n            map.put(\"MET\", \"CET\");\n            map.put(\"ECT\", \"CET\");\n            map.put(\"EET\", \"EET\");\n            map.put(\"MIT\", \"Pacific/Apia\");\n            map.put(\"HST\", \"Pacific/Honolulu\");  // JDK 1.1 compatible\n            map.put(\"AST\", \"America/Anchorage\");\n            map.put(\"PST\", \"America/Los_Angeles\");\n            map.put(\"MST\", \"America/Denver\");  // JDK 1.1 compatible\n            map.put(\"PNT\", \"America/Phoenix\");\n            map.put(\"CST\", \"America/Chicago\");\n            map.put(\"EST\", \"America/New_York\");  // JDK 1.1 compatible\n            map.put(\"IET\", \"America/Indiana/Indianapolis\");\n            map.put(\"PRT\", \"America/Puerto_Rico\");\n            map.put(\"CNT\", \"America/St_Johns\");\n            map.put(\"AGT\", \"America/Argentina/Buenos_Aires\");\n            map.put(\"BET\", \"America/Sao_Paulo\");\n            map.put(\"ART\", \"Africa/Cairo\");\n            map.put(\"CAT\", \"Africa/Harare\");\n            map.put(\"EAT\", \"Africa/Addis_Ababa\");\n            map.put(\"NET\", \"Asia/Yerevan\");\n            map.put(\"PLT\", \"Asia/Karachi\");\n            map.put(\"IST\", \"Asia/Kolkata\");\n            map.put(\"BST\", \"Asia/Dhaka\");\n            map.put(\"VST\", \"Asia/Ho_Chi_Minh\");\n            map.put(\"CTT\", \"Asia/Shanghai\");\n            map.put(\"JST\", \"Asia/Tokyo\");\n            map.put(\"ACT\", \"Australia/Darwin\");\n            map.put(\"AET\", \"Australia/Sydney\");\n            map.put(\"SST\", \"Pacific/Guadalcanal\");\n            map.put(\"NST\", \"Pacific/Auckland\");\n            cZoneIdConversion = map;\n        }\n        return map.get(id);\n    }",
    "comment": " Converts an old style id to a new style id.  @param id  the old style id @return the new style id, null if not found ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 0
  },
  {
    "name": "DateTimeZone.getDefault",
    "class_name": "org.joda.time.DateTimeZone",
    "signature": "org.joda.time.DateTimeZone.getDefault()",
    "snippet": "    public static DateTimeZone getDefault() {\n        DateTimeZone zone = cDefault;\n        if (zone == null) {\n            synchronized(DateTimeZone.class) {\n                zone = cDefault;\n                if (zone == null) {\n                    DateTimeZone temp = null;\n                    try {\n                        try {\n                            String id = System.getProperty(\"user.timezone\");\n                            if (id != null) {  // null check avoids stack overflow\n                                temp = forID(id);\n                            }\n                        } catch (RuntimeException ex) {\n                            // ignored\n                        }\n                        if (temp == null) {\n                            temp = forTimeZone(TimeZone.getDefault());\n                        }\n                    } catch (IllegalArgumentException ex) {\n                        // ignored\n                    }\n                    if (temp == null) {\n                        temp = UTC;\n                    }\n                    cDefault = zone = temp;\n                }\n            }\n        }\n        return zone;\n    }",
    "comment": " Gets the default time zone. <p> The default time zone is derived from the system property {@code user.timezone}. If that is {@code null} or is not a valid identifier, then the value of the JDK {@code TimeZone} default is converted. If that fails, {@code UTC} is used. <p> NOTE: If the {@code java.util.TimeZone} default is updated <i>after</i> calling this method, then the change will not be picked up here.  @return the default datetime zone object ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 0
  },
  {
    "name": "DateTimeZone.getDefaultNameProvider",
    "class_name": "org.joda.time.DateTimeZone",
    "signature": "org.joda.time.DateTimeZone.getDefaultNameProvider()",
    "snippet": "    private static NameProvider getDefaultNameProvider() {\n        NameProvider nameProvider = null;\n        try {\n            String providerClass = System.getProperty(\"org.joda.time.DateTimeZone.NameProvider\");\n            if (providerClass != null) {\n                try {\n                    nameProvider = (NameProvider) Class.forName(providerClass).newInstance();\n                } catch (Exception ex) {\n                    Thread thread = Thread.currentThread();\n                    thread.getThreadGroup().uncaughtException(thread, ex);\n                }\n            }\n        } catch (SecurityException ex) {\n            // ignore\n        }\n\n        if (nameProvider == null) {\n            nameProvider = new DefaultNameProvider();\n        }\n\n        return nameProvider;\n    }",
    "comment": " Gets the default name provider. <p> Tries the system property <code>org.joda.time.DateTimeZone.NameProvider</code>. Then uses <code>DefaultNameProvider</code>.  @return the default name provider ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 0
  },
  {
    "name": "DateTimeZone.getDefaultProvider",
    "class_name": "org.joda.time.DateTimeZone",
    "signature": "org.joda.time.DateTimeZone.getDefaultProvider()",
    "snippet": "    private static Provider getDefaultProvider() {\n        Provider provider = null;\n\n        try {\n            String providerClass =\n                System.getProperty(\"org.joda.time.DateTimeZone.Provider\");\n            if (providerClass != null) {\n                try {\n                    provider = (Provider) Class.forName(providerClass).newInstance();\n                } catch (Exception ex) {\n                    Thread thread = Thread.currentThread();\n                    thread.getThreadGroup().uncaughtException(thread, ex);\n                }\n            }\n        } catch (SecurityException ex) {\n            // ignored\n        }\n\n        if (provider == null) {\n            try {\n                provider = new ZoneInfoProvider(\"org/joda/time/tz/data\");\n            } catch (Exception ex) {\n                Thread thread = Thread.currentThread();\n                thread.getThreadGroup().uncaughtException(thread, ex);\n            }\n        }\n\n        if (provider == null) {\n            provider = new UTCProvider();\n        }\n\n        return provider;\n    }",
    "comment": " Gets the default zone provider. <p> Tries the system property <code>org.joda.time.DateTimeZone.Provider</code>. Then tries a <code>ZoneInfoProvider</code> using the data in <code>org/joda/time/tz/data</code>. Then uses <code>UTCProvider</code>.  @return the default name provider ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 0
  },
  {
    "name": "DateTimeZone.getID",
    "class_name": "org.joda.time.DateTimeZone",
    "signature": "org.joda.time.DateTimeZone.getID()",
    "snippet": "    @ToString\n    public final String getID() {\n        return iID;\n    }",
    "comment": " Gets the ID of this datetime zone.  @return the ID of this datetime zone ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 0
  },
  {
    "name": "DateTimeZone.setDefault",
    "class_name": "org.joda.time.DateTimeZone",
    "signature": "org.joda.time.DateTimeZone.setDefault(DateTimeZone)",
    "snippet": "    public static void setDefault(DateTimeZone zone) throws SecurityException {\n        SecurityManager sm = System.getSecurityManager();\n        if (sm != null) {\n            sm.checkPermission(new JodaTimePermission(\"DateTimeZone.setDefault\"));\n        }\n        if (zone == null) {\n            throw new IllegalArgumentException(\"The datetime zone must not be null\");\n        }\n        synchronized(DateTimeZone.class) {\n            cDefault = zone;\n        }\n    }",
    "comment": " Sets the default time zone. <p> NOTE: Calling this method does <i>not</i> set the {@code java.util.TimeZone} default.  @param zone  the default datetime zone object, must not be null @throws IllegalArgumentException if the zone is null @throws SecurityException if the application has insufficient security rights ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 0
  },
  {
    "name": "DateTimeZone.setNameProvider0",
    "class_name": "org.joda.time.DateTimeZone",
    "signature": "org.joda.time.DateTimeZone.setNameProvider0(NameProvider)",
    "snippet": "    private static void setNameProvider0(NameProvider nameProvider) {\n        if (nameProvider == null) {\n            nameProvider = getDefaultNameProvider();\n        }\n        cNameProvider = nameProvider;\n    }",
    "comment": " Sets the name provider factory without performing the security check.  @param nameProvider  provider to use, or null for default @throws IllegalArgumentException if the provider is invalid ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 0
  },
  {
    "name": "DateTimeZone.setProvider0",
    "class_name": "org.joda.time.DateTimeZone",
    "signature": "org.joda.time.DateTimeZone.setProvider0(Provider)",
    "snippet": "    private static void setProvider0(Provider provider) {\n        if (provider == null) {\n            provider = getDefaultProvider();\n        }\n        Set<String> ids = provider.getAvailableIDs();\n        if (ids == null || ids.size() == 0) {\n            throw new IllegalArgumentException\n                (\"The provider doesn't have any available ids\");\n        }\n        if (!ids.contains(\"UTC\")) {\n            throw new IllegalArgumentException(\"The provider doesn't support UTC\");\n        }\n        if (!UTC.equals(provider.getZone(\"UTC\"))) {\n            throw new IllegalArgumentException(\"Invalid UTC zone provided\");\n        }\n        cProvider = provider;\n        cAvailableIDs = ids;\n    }",
    "comment": " Sets the zone provider factory without performing the security check.  @param provider  provider to use, or null for default @throws IllegalArgumentException if the provider is invalid ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 0
  },
  {
    "name": "DurationFieldType.DurationFieldType",
    "class_name": "org.joda.time.DurationFieldType",
    "signature": "org.joda.time.DurationFieldType.DurationFieldType(String)",
    "snippet": "    protected DurationFieldType(String name) {\n        super();\n        iName = name;\n    }",
    "comment": " Constructor.  @param name  the name to use, which by convention, are plural. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 0
  },
  {
    "name": "DurationFieldType.centuries",
    "class_name": "org.joda.time.DurationFieldType",
    "signature": "org.joda.time.DurationFieldType.centuries()",
    "snippet": "    public static DurationFieldType centuries() {\n        return CENTURIES_TYPE;\n    }",
    "comment": " Get the centuries field type.  @return the DateTimeFieldType constant ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 0
  },
  {
    "name": "DurationFieldType.days",
    "class_name": "org.joda.time.DurationFieldType",
    "signature": "org.joda.time.DurationFieldType.days()",
    "snippet": "    public static DurationFieldType days() {\n        return DAYS_TYPE;\n    }",
    "comment": " Get the days field type.  @return the DateTimeFieldType constant ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 0
  },
  {
    "name": "DurationFieldType.eras",
    "class_name": "org.joda.time.DurationFieldType",
    "signature": "org.joda.time.DurationFieldType.eras()",
    "snippet": "    public static DurationFieldType eras() {\n        return ERAS_TYPE;\n    }",
    "comment": " Get the eras field type.  @return the DateTimeFieldType constant ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 0
  },
  {
    "name": "DurationFieldType.halfdays",
    "class_name": "org.joda.time.DurationFieldType",
    "signature": "org.joda.time.DurationFieldType.halfdays()",
    "snippet": "    public static DurationFieldType halfdays() {\n        return HALFDAYS_TYPE;\n    }",
    "comment": " Get the halfdays field type.  @return the DateTimeFieldType constant ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 0
  },
  {
    "name": "DurationFieldType.hours",
    "class_name": "org.joda.time.DurationFieldType",
    "signature": "org.joda.time.DurationFieldType.hours()",
    "snippet": "    public static DurationFieldType hours() {\n        return HOURS_TYPE;\n    }",
    "comment": " Get the hours field type.  @return the DateTimeFieldType constant ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 0
  },
  {
    "name": "DurationFieldType.millis",
    "class_name": "org.joda.time.DurationFieldType",
    "signature": "org.joda.time.DurationFieldType.millis()",
    "snippet": "    public static DurationFieldType millis() {\n        return MILLIS_TYPE;\n    }",
    "comment": " Get the millis field type.  @return the DateTimeFieldType constant ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 0
  },
  {
    "name": "DurationFieldType.minutes",
    "class_name": "org.joda.time.DurationFieldType",
    "signature": "org.joda.time.DurationFieldType.minutes()",
    "snippet": "    public static DurationFieldType minutes() {\n        return MINUTES_TYPE;\n    }",
    "comment": " Get the minutes field type.  @return the DateTimeFieldType constant ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 0
  },
  {
    "name": "DurationFieldType.months",
    "class_name": "org.joda.time.DurationFieldType",
    "signature": "org.joda.time.DurationFieldType.months()",
    "snippet": "    public static DurationFieldType months() {\n        return MONTHS_TYPE;\n    }",
    "comment": " Get the months field type.  @return the DateTimeFieldType constant ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 0
  },
  {
    "name": "DurationFieldType.seconds",
    "class_name": "org.joda.time.DurationFieldType",
    "signature": "org.joda.time.DurationFieldType.seconds()",
    "snippet": "    public static DurationFieldType seconds() {\n        return SECONDS_TYPE;\n    }",
    "comment": " Get the seconds field type.  @return the DateTimeFieldType constant ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 0
  },
  {
    "name": "DurationFieldType.weeks",
    "class_name": "org.joda.time.DurationFieldType",
    "signature": "org.joda.time.DurationFieldType.weeks()",
    "snippet": "    public static DurationFieldType weeks() {\n        return WEEKS_TYPE;\n    }",
    "comment": " Get the weeks field type.  @return the DateTimeFieldType constant ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 0
  },
  {
    "name": "DurationFieldType.weekyears",
    "class_name": "org.joda.time.DurationFieldType",
    "signature": "org.joda.time.DurationFieldType.weekyears()",
    "snippet": "    public static DurationFieldType weekyears() {\n        return WEEKYEARS_TYPE;\n    }",
    "comment": " Get the weekyears field type.  @return the DateTimeFieldType constant ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 0
  },
  {
    "name": "DurationFieldType.years",
    "class_name": "org.joda.time.DurationFieldType",
    "signature": "org.joda.time.DurationFieldType.years()",
    "snippet": "    public static DurationFieldType years() {\n        return YEARS_TYPE;\n    }",
    "comment": " Get the years field type.  @return the DateTimeFieldType constant ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 0
  },
  {
    "name": "StandardDurationFieldType.getField",
    "class_name": "org.joda.time.DurationFieldType$StandardDurationFieldType",
    "signature": "org.joda.time.DurationFieldType$StandardDurationFieldType.getField(Chronology)",
    "snippet": "        public DurationField getField(Chronology chronology) {\n            chronology = DateTimeUtils.getChronology(chronology);\n            \n            switch (iOrdinal) {\n                case ERAS:\n                    return chronology.eras();\n                case CENTURIES:\n                    return chronology.centuries();\n                case WEEKYEARS:\n                    return chronology.weekyears();\n                case YEARS:\n                    return chronology.years();\n                case MONTHS:\n                    return chronology.months();\n                case WEEKS:\n                    return chronology.weeks();\n                case DAYS:\n                    return chronology.days();\n                case HALFDAYS:\n                    return chronology.halfdays();\n                case HOURS:\n                    return chronology.hours();\n                case MINUTES:\n                    return chronology.minutes();\n                case SECONDS:\n                    return chronology.seconds();\n                case MILLIS:\n                    return chronology.millis();\n                default:\n                    // Shouldn't happen.\n                    throw new InternalError();\n            }\n        }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 0
  },
  {
    "name": "StandardDurationFieldType.hashCode",
    "class_name": "org.joda.time.DurationFieldType$StandardDurationFieldType",
    "signature": "org.joda.time.DurationFieldType$StandardDurationFieldType.hashCode()",
    "snippet": "        @Override\n        public int hashCode() {\n            return (1 << iOrdinal);\n        }",
    "comment": "@inheritdoc */",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 0
  },
  {
    "name": "Period.Period",
    "class_name": "org.joda.time.Period",
    "signature": "org.joda.time.Period.Period()",
    "snippet": "    public Period() {\n        super(0L, null, null);\n    }",
    "comment": " Creates a new empty period with the standard set of fields. <p> One way to initialise a period is as follows: <pre> Period = new Period().withYears(6).withMonths(3).withSeconds(23); </pre> Bear in mind that this creates four period instances in total, three of which are immediately discarded. The alterative is more efficient, but less readable: <pre> Period = new Period(6, 3, 0, 0, 0, 0, 23, 0); </pre> The following is also slightly less wasteful: <pre> Period = Period.years(6).withMonths(3).withSeconds(23); </pre> ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 0
  },
  {
    "name": "Period.Period",
    "class_name": "org.joda.time.Period",
    "signature": "org.joda.time.Period.Period(long,long,PeriodType,Chronology)",
    "snippet": "    public Period(long startInstant, long endInstant, PeriodType type, Chronology chrono) {\n        super(startInstant, endInstant, type, chrono);\n    }",
    "comment": " Creates a period from the given interval endpoints.  @param startInstant  interval start, in milliseconds @param endInstant  interval end, in milliseconds @param type  which set of fields this period supports, null means standard @param chrono  the chronology to use, null means ISO in default zone ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 0
  },
  {
    "name": "Period.getMonths",
    "class_name": "org.joda.time.Period",
    "signature": "org.joda.time.Period.getMonths()",
    "snippet": "    public int getMonths() {\n        return getPeriodType().getIndexedField(this, PeriodType.MONTH_INDEX);\n    }",
    "comment": " Gets the months field part of the period.  @return the number of months in the period, zero if unsupported ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 0
  },
  {
    "name": "Period.getYears",
    "class_name": "org.joda.time.Period",
    "signature": "org.joda.time.Period.getYears()",
    "snippet": "    public int getYears() {\n        return getPeriodType().getIndexedField(this, PeriodType.YEAR_INDEX);\n    }",
    "comment": " Gets the years field part of the period.  @return the number of years in the period, zero if unsupported ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 0
  },
  {
    "name": "PeriodType.PeriodType",
    "class_name": "org.joda.time.PeriodType",
    "signature": "org.joda.time.PeriodType.PeriodType(String,DurationFieldType[],int[])",
    "snippet": "    protected PeriodType(String name, DurationFieldType[] types, int[] indices) {\n        super();\n        iName = name;\n        iTypes = types;\n        iIndices = indices;\n    }",
    "comment": " Constructor.  @param name  the name @param types  the types @param indices  the indices ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 0
  },
  {
    "name": "PeriodType.getFieldType",
    "class_name": "org.joda.time.PeriodType",
    "signature": "org.joda.time.PeriodType.getFieldType(int)",
    "snippet": "    public DurationFieldType getFieldType(int index) {\n        return iTypes[index];\n    }",
    "comment": " Gets the field type by index.  @param index  the index to retrieve @return the field type @throws IndexOutOfBoundsException if the index is invalid ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 0
  },
  {
    "name": "PeriodType.getIndexedField",
    "class_name": "org.joda.time.PeriodType",
    "signature": "org.joda.time.PeriodType.getIndexedField(ReadablePeriod,int)",
    "snippet": "    int getIndexedField(ReadablePeriod period, int index) {\n        int realIndex = iIndices[index];\n        return (realIndex == -1 ? 0 : period.getValue(realIndex));\n    }",
    "comment": " Gets the indexed field part of the period.  @param period  the period to query @param index  the index to use @return the value of the field, zero if unsupported ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 0
  },
  {
    "name": "PeriodType.size",
    "class_name": "org.joda.time.PeriodType",
    "signature": "org.joda.time.PeriodType.size()",
    "snippet": "    public int size() {\n        return iTypes.length;\n    }",
    "comment": " Gets the number of fields in the period type.  @return the number of fields ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 0
  },
  {
    "name": "PeriodType.standard",
    "class_name": "org.joda.time.PeriodType",
    "signature": "org.joda.time.PeriodType.standard()",
    "snippet": "    public static PeriodType standard() {\n        PeriodType type = cStandard;\n        if (type == null) {\n            type = new PeriodType(\n                \"Standard\",\n                new DurationFieldType[] {\n                    DurationFieldType.years(), DurationFieldType.months(),\n                    DurationFieldType.weeks(), DurationFieldType.days(),\n                    DurationFieldType.hours(), DurationFieldType.minutes(),\n                    DurationFieldType.seconds(), DurationFieldType.millis(),\n                },\n                new int[] { 0, 1, 2, 3, 4, 5, 6, 7, }\n            );\n            cStandard = type;\n        }\n        return type;\n    }",
    "comment": " Gets a type that defines all standard fields. <ul> <li>years <li>months <li>weeks <li>days <li>hours <li>minutes <li>seconds <li>milliseconds </ul>  @return the period type ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 0
  },
  {
    "name": "PeriodType.yearMonthDay",
    "class_name": "org.joda.time.PeriodType",
    "signature": "org.joda.time.PeriodType.yearMonthDay()",
    "snippet": "    public static PeriodType yearMonthDay() {\n        PeriodType type = cYMD;\n        if (type == null) {\n            type = new PeriodType(\n                \"YearMonthDay\",\n                new DurationFieldType[] {\n                    DurationFieldType.years(), DurationFieldType.months(),\n                    DurationFieldType.days(),\n                },\n                new int[] { 0, 1, -1, 2, -1, -1, -1, -1, }\n            );\n            cYMD = type;\n        }\n        return type;\n    }",
    "comment": " Gets a type that defines the year, month and day fields. <ul> <li>years <li>months <li>days </ul>  @return the period type @since 1.1 ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 0
  },
  {
    "name": "AbstractPeriod.AbstractPeriod",
    "class_name": "org.joda.time.base.AbstractPeriod",
    "signature": "org.joda.time.base.AbstractPeriod.AbstractPeriod()",
    "snippet": "    protected AbstractPeriod() {\n        super();\n    }",
    "comment": " Constructor. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 0
  },
  {
    "name": "AbstractPeriod.getFieldType",
    "class_name": "org.joda.time.base.AbstractPeriod",
    "signature": "org.joda.time.base.AbstractPeriod.getFieldType(int)",
    "snippet": "    public DurationFieldType getFieldType(int index) {\n        return getPeriodType().getFieldType(index);\n    }",
    "comment": " Gets the field type at the specified index.  @param index  the index to retrieve @return the field at the specified index @throws IndexOutOfBoundsException if the index is invalid @since 2.0 (previously on BasePeriod) ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 0
  },
  {
    "name": "AbstractPeriod.size",
    "class_name": "org.joda.time.base.AbstractPeriod",
    "signature": "org.joda.time.base.AbstractPeriod.size()",
    "snippet": "    public int size() {\n        return getPeriodType().size();\n    }",
    "comment": " Gets the number of fields that this period supports.  @return the number of fields supported @since 2.0 (previously on BasePeriod) ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 0
  },
  {
    "name": "BasePeriod.BasePeriod",
    "class_name": "org.joda.time.base.BasePeriod",
    "signature": "org.joda.time.base.BasePeriod.BasePeriod(long,PeriodType,Chronology)",
    "snippet": "    protected BasePeriod(long duration, PeriodType type, Chronology chrono) {\n        super();\n        type = checkPeriodType(type);\n        chrono = DateTimeUtils.getChronology(chrono);\n        iType = type;\n        iValues = chrono.get(this, duration);\n    }",
    "comment": " Creates a period from the given millisecond duration, which is only really suitable for durations less than one day. <p> Only fields that are precise will be used. Thus the largest precise field may have a large value.  @param duration  the duration, in milliseconds @param type  which set of fields this period supports, null means standard @param chrono  the chronology to use, null means ISO default @throws IllegalArgumentException if period type is invalid ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 0
  },
  {
    "name": "BasePeriod.BasePeriod",
    "class_name": "org.joda.time.base.BasePeriod",
    "signature": "org.joda.time.base.BasePeriod.BasePeriod(long,long,PeriodType,Chronology)",
    "snippet": "    protected BasePeriod(long startInstant, long endInstant, PeriodType type, Chronology chrono) {\n        super();\n        type = checkPeriodType(type);\n        chrono = DateTimeUtils.getChronology(chrono);\n        iType = type;\n        iValues = chrono.get(this, startInstant, endInstant);\n    }",
    "comment": " Creates a period from the given interval endpoints.  @param startInstant  interval start, in milliseconds @param endInstant  interval end, in milliseconds @param type  which set of fields this period supports, null means standard @param chrono  the chronology to use, null means ISO default @throws IllegalArgumentException if period type is invalid ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 0
  },
  {
    "name": "BasePeriod.checkPeriodType",
    "class_name": "org.joda.time.base.BasePeriod",
    "signature": "org.joda.time.base.BasePeriod.checkPeriodType(PeriodType)",
    "snippet": "    protected PeriodType checkPeriodType(PeriodType type) {\n        return DateTimeUtils.getPeriodType(type);\n    }",
    "comment": " Validates a period type, converting nulls to a default value and checking the type is suitable for this instance.  @param type  the type to check, may be null @return the validated type to use, not null @throws IllegalArgumentException if the period type is invalid ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 0
  },
  {
    "name": "BasePeriod.getPeriodType",
    "class_name": "org.joda.time.base.BasePeriod",
    "signature": "org.joda.time.base.BasePeriod.getPeriodType()",
    "snippet": "    public PeriodType getPeriodType() {\n        return iType;\n    }",
    "comment": " Gets the period type.  @return the period type ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 0
  },
  {
    "name": "BasePeriod.getValue",
    "class_name": "org.joda.time.base.BasePeriod",
    "signature": "org.joda.time.base.BasePeriod.getValue(int)",
    "snippet": "    public int getValue(int index) {\n        return iValues[index];\n    }",
    "comment": " Gets the value at the specified index.  @param index  the index to retrieve @return the value of the field at the specified index @throws IndexOutOfBoundsException if the index is invalid ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 0
  },
  {
    "name": "AssembledChronology.AssembledChronology",
    "class_name": "org.joda.time.chrono.AssembledChronology",
    "signature": "org.joda.time.chrono.AssembledChronology.AssembledChronology(Chronology,Object)",
    "snippet": "    protected AssembledChronology(Chronology base, Object param) {\n        iBase = base;\n        iParam = param;\n        setFields();\n    }",
    "comment": " Constructor calls the assemble method, enabling subclasses to define its supported fields. If a base chronology is supplied, the field set initially contains references to each base chronology field. <p> Other methods in this class will delegate to the base chronology, if it can be determined that the base chronology will produce the same results as AbstractChronology.  @param base optional base chronology to copy initial fields from @param param optional param object avalable for assemble method ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 0
  },
  {
    "name": "AssembledChronology.centuries",
    "class_name": "org.joda.time.chrono.AssembledChronology",
    "signature": "org.joda.time.chrono.AssembledChronology.centuries()",
    "snippet": "    public final DurationField centuries() {\n        return iCenturies;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 0
  },
  {
    "name": "AssembledChronology.centuryOfEra",
    "class_name": "org.joda.time.chrono.AssembledChronology",
    "signature": "org.joda.time.chrono.AssembledChronology.centuryOfEra()",
    "snippet": "    public final DateTimeField centuryOfEra() {\n        return iCenturyOfEra;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 0
  },
  {
    "name": "AssembledChronology.clockhourOfDay",
    "class_name": "org.joda.time.chrono.AssembledChronology",
    "signature": "org.joda.time.chrono.AssembledChronology.clockhourOfDay()",
    "snippet": "    public final DateTimeField clockhourOfDay() {\n        return iClockhourOfDay;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 0
  },
  {
    "name": "AssembledChronology.clockhourOfHalfday",
    "class_name": "org.joda.time.chrono.AssembledChronology",
    "signature": "org.joda.time.chrono.AssembledChronology.clockhourOfHalfday()",
    "snippet": "    public final DateTimeField clockhourOfHalfday() {\n        return iClockhourOfHalfday;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 0
  },
  {
    "name": "AssembledChronology.dayOfMonth",
    "class_name": "org.joda.time.chrono.AssembledChronology",
    "signature": "org.joda.time.chrono.AssembledChronology.dayOfMonth()",
    "snippet": "    public final DateTimeField dayOfMonth() {\n        return iDayOfMonth;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 0
  },
  {
    "name": "AssembledChronology.dayOfWeek",
    "class_name": "org.joda.time.chrono.AssembledChronology",
    "signature": "org.joda.time.chrono.AssembledChronology.dayOfWeek()",
    "snippet": "    public final DateTimeField dayOfWeek() {\n        return iDayOfWeek;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 0
  },
  {
    "name": "AssembledChronology.dayOfYear",
    "class_name": "org.joda.time.chrono.AssembledChronology",
    "signature": "org.joda.time.chrono.AssembledChronology.dayOfYear()",
    "snippet": "    public final DateTimeField dayOfYear() {\n        return iDayOfYear;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 0
  },
  {
    "name": "AssembledChronology.days",
    "class_name": "org.joda.time.chrono.AssembledChronology",
    "signature": "org.joda.time.chrono.AssembledChronology.days()",
    "snippet": "    public final DurationField days() {\n        return iDays;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 0
  },
  {
    "name": "AssembledChronology.era",
    "class_name": "org.joda.time.chrono.AssembledChronology",
    "signature": "org.joda.time.chrono.AssembledChronology.era()",
    "snippet": "    public final DateTimeField era() {\n        return iEra;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 0
  },
  {
    "name": "AssembledChronology.eras",
    "class_name": "org.joda.time.chrono.AssembledChronology",
    "signature": "org.joda.time.chrono.AssembledChronology.eras()",
    "snippet": "    public final DurationField eras() {\n        return iEras;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 0
  },
  {
    "name": "AssembledChronology.getBase",
    "class_name": "org.joda.time.chrono.AssembledChronology",
    "signature": "org.joda.time.chrono.AssembledChronology.getBase()",
    "snippet": "    protected final Chronology getBase() {\n        return iBase;\n    }",
    "comment": " Returns the same base chronology as passed into the constructor. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 0
  },
  {
    "name": "AssembledChronology.halfdayOfDay",
    "class_name": "org.joda.time.chrono.AssembledChronology",
    "signature": "org.joda.time.chrono.AssembledChronology.halfdayOfDay()",
    "snippet": "    public final DateTimeField halfdayOfDay() {\n        return iHalfdayOfDay;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 0
  },
  {
    "name": "AssembledChronology.halfdays",
    "class_name": "org.joda.time.chrono.AssembledChronology",
    "signature": "org.joda.time.chrono.AssembledChronology.halfdays()",
    "snippet": "    public final DurationField halfdays() {\n        return iHalfdays;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 0
  },
  {
    "name": "AssembledChronology.hourOfDay",
    "class_name": "org.joda.time.chrono.AssembledChronology",
    "signature": "org.joda.time.chrono.AssembledChronology.hourOfDay()",
    "snippet": "    public final DateTimeField hourOfDay() {\n        return iHourOfDay;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 0
  },
  {
    "name": "AssembledChronology.hourOfHalfday",
    "class_name": "org.joda.time.chrono.AssembledChronology",
    "signature": "org.joda.time.chrono.AssembledChronology.hourOfHalfday()",
    "snippet": "    public final DateTimeField hourOfHalfday() {\n        return iHourOfHalfday;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 0
  },
  {
    "name": "AssembledChronology.hours",
    "class_name": "org.joda.time.chrono.AssembledChronology",
    "signature": "org.joda.time.chrono.AssembledChronology.hours()",
    "snippet": "    public final DurationField hours() {\n        return iHours;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 0
  },
  {
    "name": "AssembledChronology.millis",
    "class_name": "org.joda.time.chrono.AssembledChronology",
    "signature": "org.joda.time.chrono.AssembledChronology.millis()",
    "snippet": "    public final DurationField millis() {\n        return iMillis;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 0
  },
  {
    "name": "AssembledChronology.millisOfDay",
    "class_name": "org.joda.time.chrono.AssembledChronology",
    "signature": "org.joda.time.chrono.AssembledChronology.millisOfDay()",
    "snippet": "    public final DateTimeField millisOfDay() {\n        return iMillisOfDay;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 0
  },
  {
    "name": "AssembledChronology.millisOfSecond",
    "class_name": "org.joda.time.chrono.AssembledChronology",
    "signature": "org.joda.time.chrono.AssembledChronology.millisOfSecond()",
    "snippet": "    public final DateTimeField millisOfSecond() {\n        return iMillisOfSecond;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 0
  },
  {
    "name": "AssembledChronology.minuteOfDay",
    "class_name": "org.joda.time.chrono.AssembledChronology",
    "signature": "org.joda.time.chrono.AssembledChronology.minuteOfDay()",
    "snippet": "    public final DateTimeField minuteOfDay() {\n        return iMinuteOfDay;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 0
  },
  {
    "name": "AssembledChronology.minuteOfHour",
    "class_name": "org.joda.time.chrono.AssembledChronology",
    "signature": "org.joda.time.chrono.AssembledChronology.minuteOfHour()",
    "snippet": "    public final DateTimeField minuteOfHour() {\n        return iMinuteOfHour;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 0
  },
  {
    "name": "AssembledChronology.minutes",
    "class_name": "org.joda.time.chrono.AssembledChronology",
    "signature": "org.joda.time.chrono.AssembledChronology.minutes()",
    "snippet": "    public final DurationField minutes() {\n        return iMinutes;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 0
  },
  {
    "name": "AssembledChronology.monthOfYear",
    "class_name": "org.joda.time.chrono.AssembledChronology",
    "signature": "org.joda.time.chrono.AssembledChronology.monthOfYear()",
    "snippet": "    public final DateTimeField monthOfYear() {\n        return iMonthOfYear;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 0
  },
  {
    "name": "AssembledChronology.months",
    "class_name": "org.joda.time.chrono.AssembledChronology",
    "signature": "org.joda.time.chrono.AssembledChronology.months()",
    "snippet": "    public final DurationField months() {\n        return iMonths;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 0
  },
  {
    "name": "AssembledChronology.secondOfDay",
    "class_name": "org.joda.time.chrono.AssembledChronology",
    "signature": "org.joda.time.chrono.AssembledChronology.secondOfDay()",
    "snippet": "    public final DateTimeField secondOfDay() {\n        return iSecondOfDay;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 0
  },
  {
    "name": "AssembledChronology.secondOfMinute",
    "class_name": "org.joda.time.chrono.AssembledChronology",
    "signature": "org.joda.time.chrono.AssembledChronology.secondOfMinute()",
    "snippet": "    public final DateTimeField secondOfMinute() {\n        return iSecondOfMinute;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 0
  },
  {
    "name": "AssembledChronology.seconds",
    "class_name": "org.joda.time.chrono.AssembledChronology",
    "signature": "org.joda.time.chrono.AssembledChronology.seconds()",
    "snippet": "    public final DurationField seconds() {\n        return iSeconds;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 0
  },
  {
    "name": "AssembledChronology.setFields",
    "class_name": "org.joda.time.chrono.AssembledChronology",
    "signature": "org.joda.time.chrono.AssembledChronology.setFields()",
    "snippet": "    private void setFields() {\n        Fields fields = new Fields();\n        if (iBase != null) {\n            fields.copyFieldsFrom(iBase);\n        }\n        assemble(fields);\n\n        {\n            DurationField f;\n            iMillis    = (f = fields.millis)    != null ? f : super.millis();\n            iSeconds   = (f = fields.seconds)   != null ? f : super.seconds();\n            iMinutes   = (f = fields.minutes)   != null ? f : super.minutes();\n            iHours     = (f = fields.hours)     != null ? f : super.hours();\n            iHalfdays  = (f = fields.halfdays)  != null ? f : super.halfdays();\n            iDays      = (f = fields.days)      != null ? f : super.days();\n            iWeeks     = (f = fields.weeks)     != null ? f : super.weeks();\n            iWeekyears = (f = fields.weekyears) != null ? f : super.weekyears();\n            iMonths    = (f = fields.months)    != null ? f : super.months();\n            iYears     = (f = fields.years)     != null ? f : super.years();\n            iCenturies = (f = fields.centuries) != null ? f : super.centuries();\n            iEras      = (f = fields.eras)      != null ? f : super.eras();\n        }\n\n        {\n            DateTimeField f;\n            iMillisOfSecond     = (f = fields.millisOfSecond)     != null ? f : super.millisOfSecond();\n            iMillisOfDay        = (f = fields.millisOfDay)        != null ? f : super.millisOfDay();\n            iSecondOfMinute     = (f = fields.secondOfMinute)     != null ? f : super.secondOfMinute();\n            iSecondOfDay        = (f = fields.secondOfDay)        != null ? f : super.secondOfDay();\n            iMinuteOfHour       = (f = fields.minuteOfHour)       != null ? f : super.minuteOfHour();\n            iMinuteOfDay        = (f = fields.minuteOfDay)        != null ? f : super.minuteOfDay();\n            iHourOfDay          = (f = fields.hourOfDay)          != null ? f : super.hourOfDay();\n            iClockhourOfDay     = (f = fields.clockhourOfDay)     != null ? f : super.clockhourOfDay();\n            iHourOfHalfday      = (f = fields.hourOfHalfday)      != null ? f : super.hourOfHalfday();\n            iClockhourOfHalfday = (f = fields.clockhourOfHalfday) != null ? f : super.clockhourOfHalfday();\n            iHalfdayOfDay       = (f = fields.halfdayOfDay)       != null ? f : super.halfdayOfDay();\n            iDayOfWeek          = (f = fields.dayOfWeek)          != null ? f : super.dayOfWeek();\n            iDayOfMonth         = (f = fields.dayOfMonth)         != null ? f : super.dayOfMonth();\n            iDayOfYear          = (f = fields.dayOfYear)          != null ? f : super.dayOfYear();\n            iWeekOfWeekyear     = (f = fields.weekOfWeekyear)     != null ? f : super.weekOfWeekyear();\n            iWeekyear           = (f = fields.weekyear)           != null ? f : super.weekyear();\n            iWeekyearOfCentury  = (f = fields.weekyearOfCentury)  != null ? f : super.weekyearOfCentury();\n            iMonthOfYear        = (f = fields.monthOfYear)        != null ? f : super.monthOfYear();\n            iYear               = (f = fields.year)               != null ? f : super.year();\n            iYearOfEra          = (f = fields.yearOfEra)          != null ? f : super.yearOfEra();\n            iYearOfCentury      = (f = fields.yearOfCentury)      != null ? f : super.yearOfCentury();\n            iCenturyOfEra       = (f = fields.centuryOfEra)       != null ? f : super.centuryOfEra();\n            iEra                = (f = fields.era)                != null ? f : super.era();\n        }\n\n        int flags;\n        if (iBase == null) {\n            flags = 0;\n        } else {\n            flags = \n                ((iHourOfDay      == iBase.hourOfDay()      &&\n                  iMinuteOfHour   == iBase.minuteOfHour()   &&\n                  iSecondOfMinute == iBase.secondOfMinute() &&\n                  iMillisOfSecond == iBase.millisOfSecond()   ) ? 1 : 0) |\n\n                ((iMillisOfDay == iBase.millisOfDay()) ? 2 : 0) |\n\n                ((iYear        == iBase.year()        &&\n                  iMonthOfYear == iBase.monthOfYear() &&\n                  iDayOfMonth  == iBase.dayOfMonth()    ) ? 4 : 0);\n        }\n\n        iBaseFlags = flags;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 0
  },
  {
    "name": "AssembledChronology.weekOfWeekyear",
    "class_name": "org.joda.time.chrono.AssembledChronology",
    "signature": "org.joda.time.chrono.AssembledChronology.weekOfWeekyear()",
    "snippet": "    public final DateTimeField weekOfWeekyear() {\n        return iWeekOfWeekyear;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 0
  },
  {
    "name": "AssembledChronology.weeks",
    "class_name": "org.joda.time.chrono.AssembledChronology",
    "signature": "org.joda.time.chrono.AssembledChronology.weeks()",
    "snippet": "    public final DurationField weeks() {\n        return iWeeks;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 0
  },
  {
    "name": "AssembledChronology.weekyear",
    "class_name": "org.joda.time.chrono.AssembledChronology",
    "signature": "org.joda.time.chrono.AssembledChronology.weekyear()",
    "snippet": "    public final DateTimeField weekyear() {\n        return iWeekyear;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 0
  },
  {
    "name": "AssembledChronology.weekyearOfCentury",
    "class_name": "org.joda.time.chrono.AssembledChronology",
    "signature": "org.joda.time.chrono.AssembledChronology.weekyearOfCentury()",
    "snippet": "    public final DateTimeField weekyearOfCentury() {\n        return iWeekyearOfCentury;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 0
  },
  {
    "name": "AssembledChronology.weekyears",
    "class_name": "org.joda.time.chrono.AssembledChronology",
    "signature": "org.joda.time.chrono.AssembledChronology.weekyears()",
    "snippet": "    public final DurationField weekyears() {\n        return iWeekyears;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 0
  },
  {
    "name": "AssembledChronology.year",
    "class_name": "org.joda.time.chrono.AssembledChronology",
    "signature": "org.joda.time.chrono.AssembledChronology.year()",
    "snippet": "    public final DateTimeField year() {\n        return iYear;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 0
  },
  {
    "name": "AssembledChronology.yearOfCentury",
    "class_name": "org.joda.time.chrono.AssembledChronology",
    "signature": "org.joda.time.chrono.AssembledChronology.yearOfCentury()",
    "snippet": "    public final DateTimeField yearOfCentury() {\n        return iYearOfCentury;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 0
  },
  {
    "name": "AssembledChronology.yearOfEra",
    "class_name": "org.joda.time.chrono.AssembledChronology",
    "signature": "org.joda.time.chrono.AssembledChronology.yearOfEra()",
    "snippet": "    public final DateTimeField yearOfEra() {\n        return iYearOfEra;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 0
  },
  {
    "name": "AssembledChronology.years",
    "class_name": "org.joda.time.chrono.AssembledChronology",
    "signature": "org.joda.time.chrono.AssembledChronology.years()",
    "snippet": "    public final DurationField years() {\n        return iYears;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 0
  },
  {
    "name": "Fields.copyFieldsFrom",
    "class_name": "org.joda.time.chrono.AssembledChronology$Fields",
    "signature": "org.joda.time.chrono.AssembledChronology$Fields.copyFieldsFrom(Chronology)",
    "snippet": "        public void copyFieldsFrom(Chronology chrono) {\n            {\n                DurationField f;\n                if (isSupported(f = chrono.millis())) {\n                    millis = f;\n                }\n                if (isSupported(f = chrono.seconds())) {\n                    seconds = f;\n                }\n                if (isSupported(f = chrono.minutes())) {\n                    minutes = f;\n                }\n                if (isSupported(f = chrono.hours())) {\n                    hours = f;\n                }\n                if (isSupported(f = chrono.halfdays())) {\n                    halfdays = f;\n                }\n                if (isSupported(f = chrono.days())) {\n                    days = f;\n                }\n                if (isSupported(f = chrono.weeks())) {\n                    weeks = f;\n                }\n                if (isSupported(f = chrono.weekyears())) {\n                    weekyears = f;\n                }\n                if (isSupported(f = chrono.months())) {\n                    months = f;\n                }\n                if (isSupported(f = chrono.years())) {\n                    years = f;\n                }\n                if (isSupported(f = chrono.centuries())) {\n                    centuries = f;\n                }\n                if (isSupported(f = chrono.eras())) {\n                    eras = f;\n                }\n            }\n\n            {\n                DateTimeField f;\n                if (isSupported(f = chrono.millisOfSecond())) {\n                    millisOfSecond = f;\n                }\n                if (isSupported(f = chrono.millisOfDay())) {\n                    millisOfDay = f;\n                }\n                if (isSupported(f = chrono.secondOfMinute())) {\n                    secondOfMinute = f;\n                }\n                if (isSupported(f = chrono.secondOfDay())) {\n                    secondOfDay = f;\n                }\n                if (isSupported(f = chrono.minuteOfHour())) {\n                    minuteOfHour = f;\n                }\n                if (isSupported(f = chrono.minuteOfDay())) {\n                    minuteOfDay = f;\n                }\n                if (isSupported(f = chrono.hourOfDay())) {\n                    hourOfDay = f;\n                }\n                if (isSupported(f = chrono.clockhourOfDay())) {\n                    clockhourOfDay = f;\n                }\n                if (isSupported(f = chrono.hourOfHalfday())) {\n                    hourOfHalfday = f;\n                }\n                if (isSupported(f = chrono.clockhourOfHalfday())) {\n                    clockhourOfHalfday = f;\n                }\n                if (isSupported(f = chrono.halfdayOfDay())) {\n                    halfdayOfDay = f;\n                }\n                if (isSupported(f = chrono.dayOfWeek())) {\n                    dayOfWeek = f;\n                }\n                if (isSupported(f = chrono.dayOfMonth())) {\n                    dayOfMonth = f;\n                }\n                if (isSupported(f = chrono.dayOfYear())) {\n                    dayOfYear = f;\n                }\n                if (isSupported(f = chrono.weekOfWeekyear())) {\n                    weekOfWeekyear = f;\n                }\n                if (isSupported(f = chrono.weekyear())) {\n                    weekyear = f;\n                }\n                if (isSupported(f = chrono.weekyearOfCentury())) {\n                    weekyearOfCentury = f;\n                }\n                if (isSupported(f = chrono.monthOfYear())) {\n                    monthOfYear = f;\n                }\n                if (isSupported(f = chrono.year())) {\n                    year = f;\n                }\n                if (isSupported(f = chrono.yearOfEra())) {\n                    yearOfEra = f;\n                }\n                if (isSupported(f = chrono.yearOfCentury())) {\n                    yearOfCentury = f;\n                }\n                if (isSupported(f = chrono.centuryOfEra())) {\n                    centuryOfEra = f;\n                }\n                if (isSupported(f = chrono.era())) {\n                    era = f;\n                }\n            }\n        }",
    "comment": " Copy the supported fields from a chronology into this container. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 0
  },
  {
    "name": "Fields.isSupported",
    "class_name": "org.joda.time.chrono.AssembledChronology$Fields",
    "signature": "org.joda.time.chrono.AssembledChronology$Fields.isSupported(DateTimeField)",
    "snippet": "        private static boolean isSupported(DateTimeField field) {\n            return field == null ? false : field.isSupported();\n        }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 0
  },
  {
    "name": "Fields.isSupported",
    "class_name": "org.joda.time.chrono.AssembledChronology$Fields",
    "signature": "org.joda.time.chrono.AssembledChronology$Fields.isSupported(DurationField)",
    "snippet": "        private static boolean isSupported(DurationField field) {\n            return field == null ? false : field.isSupported();\n        }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 0
  },
  {
    "name": "BaseChronology.BaseChronology",
    "class_name": "org.joda.time.chrono.BaseChronology",
    "signature": "org.joda.time.chrono.BaseChronology.BaseChronology()",
    "snippet": "    protected BaseChronology() {\n        super();\n    }",
    "comment": " Restricted constructor. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 0
  },
  {
    "name": "BaseChronology.eras",
    "class_name": "org.joda.time.chrono.BaseChronology",
    "signature": "org.joda.time.chrono.BaseChronology.eras()",
    "snippet": "    public DurationField eras() {\n        return UnsupportedDurationField.getInstance(DurationFieldType.eras());\n    }",
    "comment": " Get the eras duration field for this chronology.  @return DurationField or UnsupportedDurationField if unsupported ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 0
  },
  {
    "name": "BaseChronology.get",
    "class_name": "org.joda.time.chrono.BaseChronology",
    "signature": "org.joda.time.chrono.BaseChronology.get(ReadablePeriod,long)",
    "snippet": "    public int[] get(ReadablePeriod period, long duration) {\n        int size = period.size();\n        int[] values = new int[size];\n        if (duration != 0) {\n            long current = 0;\n            for (int i = 0; i < size; i++) {\n                DurationField field = period.getFieldType(i).getField(this);\n                if (field.isPrecise()) {\n                    int value = field.getDifference(duration, current);\n                    current = field.add(current, value);\n                    values[i] = value;\n                }\n            }\n        }\n        return values;\n    }",
    "comment": " Gets the values of a period from an interval.  @param period  the period instant to use @param duration  the duration to query @return the values of the period extracted from the duration ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 0
  },
  {
    "name": "BaseChronology.get",
    "class_name": "org.joda.time.chrono.BaseChronology",
    "signature": "org.joda.time.chrono.BaseChronology.get(ReadablePeriod,long,long)",
    "snippet": "    public int[] get(ReadablePeriod period, long startInstant, long endInstant) {\n        int size = period.size();\n        int[] values = new int[size];\n        if (startInstant != endInstant) {\n            for (int i = 0; i < size; i++) {\n                DurationField field = period.getFieldType(i).getField(this);\n                int value = field.getDifference(endInstant, startInstant);\n                startInstant = field.add(startInstant, value);\n                values[i] = value;\n            }\n        }\n        return values;\n    }",
    "comment": " Gets the values of a period from an interval.  @param period  the period instant to use @param startInstant  the start instant of an interval to query @param endInstant  the start instant of an interval to query @return the values of the period extracted from the interval ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 0
  },
  {
    "name": "BasicChronology.BasicChronology",
    "class_name": "org.joda.time.chrono.BasicChronology",
    "signature": "org.joda.time.chrono.BasicChronology.BasicChronology(Chronology,Object,int)",
    "snippet": "    BasicChronology(Chronology base, Object param, int minDaysInFirstWeek) {\n        super(base, param);\n\n        if (minDaysInFirstWeek < 1 || minDaysInFirstWeek > 7) {\n            throw new IllegalArgumentException\n                (\"Invalid min days in first week: \" + minDaysInFirstWeek);\n        }\n\n        iMinDaysInFirstWeek = minDaysInFirstWeek;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 0
  },
  {
    "name": "BasicChronology.assemble",
    "class_name": "org.joda.time.chrono.BasicChronology",
    "signature": "org.joda.time.chrono.BasicChronology.assemble(Fields)",
    "snippet": "    protected void assemble(Fields fields) {\n        // First copy fields that are the same for all Gregorian and Julian\n        // chronologies.\n\n        fields.millis = cMillisField;\n        fields.seconds = cSecondsField;\n        fields.minutes = cMinutesField;\n        fields.hours = cHoursField;\n        fields.halfdays = cHalfdaysField;\n        fields.days = cDaysField;\n        fields.weeks = cWeeksField;\n\n        fields.millisOfSecond = cMillisOfSecondField;\n        fields.millisOfDay = cMillisOfDayField;\n        fields.secondOfMinute = cSecondOfMinuteField;\n        fields.secondOfDay = cSecondOfDayField;\n        fields.minuteOfHour = cMinuteOfHourField;\n        fields.minuteOfDay = cMinuteOfDayField;\n        fields.hourOfDay = cHourOfDayField;\n        fields.hourOfHalfday = cHourOfHalfdayField;\n        fields.clockhourOfDay = cClockhourOfDayField;\n        fields.clockhourOfHalfday = cClockhourOfHalfdayField;\n        fields.halfdayOfDay = cHalfdayOfDayField;\n\n        // Now create fields that have unique behavior for Gregorian and Julian\n        // chronologies.\n\n        fields.year = new BasicYearDateTimeField(this);\n        fields.yearOfEra = new GJYearOfEraDateTimeField(fields.year, this);\n\n        // Define one-based centuryOfEra and yearOfCentury.\n        DateTimeField field = new OffsetDateTimeField(\n            fields.yearOfEra, 99);\n        fields.centuryOfEra = new DividedDateTimeField(\n            field, DateTimeFieldType.centuryOfEra(), 100);\n        \n        field = new RemainderDateTimeField(\n            (DividedDateTimeField) fields.centuryOfEra);\n        fields.yearOfCentury = new OffsetDateTimeField(\n            field, DateTimeFieldType.yearOfCentury(), 1);\n\n        fields.era = new GJEraDateTimeField(this);\n        fields.dayOfWeek = new GJDayOfWeekDateTimeField(this, fields.days);\n        fields.dayOfMonth = new BasicDayOfMonthDateTimeField(this, fields.days);\n        fields.dayOfYear = new BasicDayOfYearDateTimeField(this, fields.days);\n        fields.monthOfYear = new GJMonthOfYearDateTimeField(this);\n        fields.weekyear = new BasicWeekyearDateTimeField(this);\n        fields.weekOfWeekyear = new BasicWeekOfWeekyearDateTimeField(this, fields.weeks);\n        \n        field = new RemainderDateTimeField(\n            fields.weekyear, DateTimeFieldType.weekyearOfCentury(), 100);\n        fields.weekyearOfCentury = new OffsetDateTimeField(\n            field, DateTimeFieldType.weekyearOfCentury(), 1);\n        \n        // The remaining (imprecise) durations are available from the newly\n        // created datetime fields.\n\n        fields.years = fields.year.getDurationField();\n        fields.centuries = fields.centuryOfEra.getDurationField();\n        fields.months = fields.monthOfYear.getDurationField();\n        fields.weekyears = fields.weekyear.getDurationField();\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 0
  },
  {
    "name": "BasicChronology.getDayOfMonth",
    "class_name": "org.joda.time.chrono.BasicChronology",
    "signature": "org.joda.time.chrono.BasicChronology.getDayOfMonth(long)",
    "snippet": "    int getDayOfMonth(long millis) {\n        int year = getYear(millis);\n        int month = getMonthOfYear(millis, year);\n        return getDayOfMonth(millis, year, month);\n    }",
    "comment": " @param millis from 1970-01-01T00:00:00Z ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 0
  },
  {
    "name": "BasicChronology.getDayOfMonth",
    "class_name": "org.joda.time.chrono.BasicChronology",
    "signature": "org.joda.time.chrono.BasicChronology.getDayOfMonth(long,int)",
    "snippet": "    int getDayOfMonth(long millis, int year) {\n        int month = getMonthOfYear(millis, year);\n        return getDayOfMonth(millis, year, month);\n    }",
    "comment": " @param millis from 1970-01-01T00:00:00Z @param year precalculated year of millis ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 0
  },
  {
    "name": "BasicChronology.getDayOfMonth",
    "class_name": "org.joda.time.chrono.BasicChronology",
    "signature": "org.joda.time.chrono.BasicChronology.getDayOfMonth(long,int,int)",
    "snippet": "    int getDayOfMonth(long millis, int year, int month) {\n        long dateMillis = getYearMillis(year);\n        dateMillis += getTotalMillisByYearMonth(year, month);\n        return (int) ((millis - dateMillis) / DateTimeConstants.MILLIS_PER_DAY) + 1;\n    }",
    "comment": " @param millis from 1970-01-01T00:00:00Z @param year precalculated year of millis @param month precalculated month of millis ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 0
  },
  {
    "name": "BasicChronology.getDayOfWeek",
    "class_name": "org.joda.time.chrono.BasicChronology",
    "signature": "org.joda.time.chrono.BasicChronology.getDayOfWeek(long)",
    "snippet": "    int getDayOfWeek(long instant) {\n        // 1970-01-01 is day of week 4, Thursday.\n\n        long daysSince19700101;\n        if (instant >= 0) {\n            daysSince19700101 = instant / DateTimeConstants.MILLIS_PER_DAY;\n        } else {\n            daysSince19700101 = (instant - (DateTimeConstants.MILLIS_PER_DAY - 1))\n                / DateTimeConstants.MILLIS_PER_DAY;\n            if (daysSince19700101 < -3) {\n                return 7 + (int) ((daysSince19700101 + 4) % 7);\n            }\n        }\n\n        return 1 + (int) ((daysSince19700101 + 3) % 7);\n    }",
    "comment": " @param instant millis from 1970-01-01T00:00:00Z ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 0
  },
  {
    "name": "BasicChronology.getDayOfYear",
    "class_name": "org.joda.time.chrono.BasicChronology",
    "signature": "org.joda.time.chrono.BasicChronology.getDayOfYear(long,int)",
    "snippet": "    int getDayOfYear(long instant, int year) {\n        long yearStart = getYearMillis(year);\n        return (int) ((instant - yearStart) / DateTimeConstants.MILLIS_PER_DAY) + 1;\n    }",
    "comment": " @param instant millis from 1970-01-01T00:00:00Z @param year precalculated year of millis ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 0
  },
  {
    "name": "BasicChronology.getMaxMonth",
    "class_name": "org.joda.time.chrono.BasicChronology",
    "signature": "org.joda.time.chrono.BasicChronology.getMaxMonth()",
    "snippet": "    int getMaxMonth() {\n        return 12;\n    }",
    "comment": " Gets the maximum number of months.  @return 12 ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 0
  },
  {
    "name": "BasicChronology.getMillisOfDay",
    "class_name": "org.joda.time.chrono.BasicChronology",
    "signature": "org.joda.time.chrono.BasicChronology.getMillisOfDay(long)",
    "snippet": "    int getMillisOfDay(long instant) {\n        if (instant >= 0) {\n            return (int) (instant % DateTimeConstants.MILLIS_PER_DAY);\n        } else {\n            return (DateTimeConstants.MILLIS_PER_DAY - 1)\n                + (int) ((instant + 1) % DateTimeConstants.MILLIS_PER_DAY);\n        }\n    }",
    "comment": " @param instant millis from 1970-01-01T00:00:00Z ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 0
  },
  {
    "name": "BasicChronology.getYear",
    "class_name": "org.joda.time.chrono.BasicChronology",
    "signature": "org.joda.time.chrono.BasicChronology.getYear(long)",
    "snippet": "    int getYear(long instant) {\n        // Get an initial estimate of the year, and the millis value that\n        // represents the start of that year. Then verify estimate and fix if\n        // necessary.\n\n        // Initial estimate uses values divided by two to avoid overflow.\n        long unitMillis = getAverageMillisPerYearDividedByTwo();\n        long i2 = (instant >> 1) + getApproxMillisAtEpochDividedByTwo();\n        if (i2 < 0) {\n            i2 = i2 - unitMillis + 1;\n        }\n        int year = (int) (i2 / unitMillis);\n\n        long yearStart = getYearMillis(year);\n        long diff = instant - yearStart;\n\n        if (diff < 0) {\n            year--;\n        } else if (diff >= DateTimeConstants.MILLIS_PER_DAY * 365L) {\n            // One year may need to be added to fix estimate.\n            long oneYear;\n            if (isLeapYear(year)) {\n                oneYear = DateTimeConstants.MILLIS_PER_DAY * 366L;\n            } else {\n                oneYear = DateTimeConstants.MILLIS_PER_DAY * 365L;\n            }\n\n            yearStart += oneYear;\n\n            if (yearStart <= instant) {\n                // Didn't go too far, so actually add one year.\n                year++;\n            }\n        }\n\n        return year;\n    }",
    "comment": " @param instant millis from 1970-01-01T00:00:00Z ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 0
  },
  {
    "name": "BasicChronology.getYearInfo",
    "class_name": "org.joda.time.chrono.BasicChronology",
    "signature": "org.joda.time.chrono.BasicChronology.getYearInfo(int)",
    "snippet": "    private YearInfo getYearInfo(int year) {\n        YearInfo info = iYearInfoCache[year & CACHE_MASK];\n        if (info == null || info.iYear != year) {\n            info = new YearInfo(year, calculateFirstDayOfYearMillis(year));\n            iYearInfoCache[year & CACHE_MASK] = info;\n        }\n        return info;\n    }",
    "comment": "Although accessed by multiple threads, this method doesn't need to be synchronized.",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 0
  },
  {
    "name": "BasicChronology.getYearMillis",
    "class_name": "org.joda.time.chrono.BasicChronology",
    "signature": "org.joda.time.chrono.BasicChronology.getYearMillis(int)",
    "snippet": "    long getYearMillis(int year) {\n        return getYearInfo(year).iFirstDayMillis;\n    }",
    "comment": " Get the milliseconds for the start of a year.  @param year The year to use. @return millis from 1970-01-01T00:00:00Z ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 0
  },
  {
    "name": "BasicChronology.getYearMonthDayMillis",
    "class_name": "org.joda.time.chrono.BasicChronology",
    "signature": "org.joda.time.chrono.BasicChronology.getYearMonthDayMillis(int,int,int)",
    "snippet": "    long getYearMonthDayMillis(int year, int month, int dayOfMonth) {\n        long millis = getYearMillis(year);\n        millis += getTotalMillisByYearMonth(year, month);\n        return millis + (dayOfMonth - 1) * (long)DateTimeConstants.MILLIS_PER_DAY;\n    }",
    "comment": " Get the milliseconds for a particular date.  @param year The year to use. @param month The month to use @param dayOfMonth The day of the month to use @return millis from 1970-01-01T00:00:00Z ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 0
  },
  {
    "name": "BasicChronology.getYearMonthMillis",
    "class_name": "org.joda.time.chrono.BasicChronology",
    "signature": "org.joda.time.chrono.BasicChronology.getYearMonthMillis(int,int)",
    "snippet": "    long getYearMonthMillis(int year, int month) {\n        long millis = getYearMillis(year);\n        millis += getTotalMillisByYearMonth(year, month);\n        return millis;\n    }",
    "comment": " Get the milliseconds for the start of a month.  @param year The year to use. @param month The month to use @return millis from 1970-01-01T00:00:00Z ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 0
  },
  {
    "name": "BasicChronology.getZone",
    "class_name": "org.joda.time.chrono.BasicChronology",
    "signature": "org.joda.time.chrono.BasicChronology.getZone()",
    "snippet": "    public DateTimeZone getZone() {\n        Chronology base;\n        if ((base = getBase()) != null) {\n            return base.getZone();\n        }\n        return DateTimeZone.UTC;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 0
  },
  {
    "name": "BasicDayOfMonthDateTimeField.BasicDayOfMonthDateTimeField",
    "class_name": "org.joda.time.chrono.BasicDayOfMonthDateTimeField",
    "signature": "org.joda.time.chrono.BasicDayOfMonthDateTimeField.BasicDayOfMonthDateTimeField(BasicChronology,DurationField)",
    "snippet": "    BasicDayOfMonthDateTimeField(BasicChronology chronology, DurationField days) {\n        super(DateTimeFieldType.dayOfMonth(), days);\n        iChronology = chronology;\n    }",
    "comment": " Restricted constructor. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 0
  },
  {
    "name": "BasicDayOfMonthDateTimeField.get",
    "class_name": "org.joda.time.chrono.BasicDayOfMonthDateTimeField",
    "signature": "org.joda.time.chrono.BasicDayOfMonthDateTimeField.get(long)",
    "snippet": "    public int get(long instant) {\n        return iChronology.getDayOfMonth(instant);\n    }",
    "comment": "-----------------------------------------------------------------------",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 0
  },
  {
    "name": "BasicDayOfMonthDateTimeField.getMaximumValueForSet",
    "class_name": "org.joda.time.chrono.BasicDayOfMonthDateTimeField",
    "signature": "org.joda.time.chrono.BasicDayOfMonthDateTimeField.getMaximumValueForSet(long,int)",
    "snippet": "    protected int getMaximumValueForSet(long instant, int value) {\n        return iChronology.getDaysInMonthMaxForSet(instant, value);\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 0
  },
  {
    "name": "BasicDayOfMonthDateTimeField.getMinimumValue",
    "class_name": "org.joda.time.chrono.BasicDayOfMonthDateTimeField",
    "signature": "org.joda.time.chrono.BasicDayOfMonthDateTimeField.getMinimumValue()",
    "snippet": "    public int getMinimumValue() {\n        return 1;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 0
  },
  {
    "name": "BasicDayOfYearDateTimeField.BasicDayOfYearDateTimeField",
    "class_name": "org.joda.time.chrono.BasicDayOfYearDateTimeField",
    "signature": "org.joda.time.chrono.BasicDayOfYearDateTimeField.BasicDayOfYearDateTimeField(BasicChronology,DurationField)",
    "snippet": "    BasicDayOfYearDateTimeField(BasicChronology chronology, DurationField days) {\n        super(DateTimeFieldType.dayOfYear(), days);\n        iChronology = chronology;\n    }",
    "comment": " Restricted constructor ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 0
  },
  {
    "name": "BasicGJChronology.BasicGJChronology",
    "class_name": "org.joda.time.chrono.BasicGJChronology",
    "signature": "org.joda.time.chrono.BasicGJChronology.BasicGJChronology(Chronology,Object,int)",
    "snippet": "    BasicGJChronology(Chronology base, Object param, int minDaysInFirstWeek) {\n        super(base, param, minDaysInFirstWeek);\n    }",
    "comment": " Constructor. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 0
  },
  {
    "name": "BasicGJChronology.getDaysInMonthMaxForSet",
    "class_name": "org.joda.time.chrono.BasicGJChronology",
    "signature": "org.joda.time.chrono.BasicGJChronology.getDaysInMonthMaxForSet(long,int)",
    "snippet": "    int getDaysInMonthMaxForSet(long instant, int value) {\n        return ((value > 28 || value < 1) ? getDaysInMonthMax(instant) : 28);\n    }",
    "comment": "-----------------------------------------------------------------------",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 0
  },
  {
    "name": "BasicGJChronology.getDaysInYearMonth",
    "class_name": "org.joda.time.chrono.BasicGJChronology",
    "signature": "org.joda.time.chrono.BasicGJChronology.getDaysInYearMonth(int,int)",
    "snippet": "    int getDaysInYearMonth(int year, int month) {\n        if (isLeapYear(year)) {\n            return MAX_DAYS_PER_MONTH_ARRAY[month - 1];\n        } else {\n            return MIN_DAYS_PER_MONTH_ARRAY[month - 1];\n        }\n    }",
    "comment": " Gets the number of days in the specified month and year.  @param year  the year @param month  the month @return the number of days ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 0
  },
  {
    "name": "BasicGJChronology.getMonthOfYear",
    "class_name": "org.joda.time.chrono.BasicGJChronology",
    "signature": "org.joda.time.chrono.BasicGJChronology.getMonthOfYear(long,int)",
    "snippet": "    int getMonthOfYear(long millis, int year) {\n        // Perform a binary search to get the month. To make it go even faster,\n        // compare using ints instead of longs. The number of milliseconds per\n        // year exceeds the limit of a 32-bit int's capacity, so divide by\n        // 1024. No precision is lost (except time of day) since the number of\n        // milliseconds per day contains 1024 as a factor. After the division,\n        // the instant isn't measured in milliseconds, but in units of\n        // (128/125)seconds.\n\n        int i = (int)((millis - getYearMillis(year)) >> 10);\n\n        // There are 86400000 milliseconds per day, but divided by 1024 is\n        // 84375. There are 84375 (128/125)seconds per day.\n\n        return\n            (isLeapYear(year))\n            ? ((i < 182 * 84375)\n               ? ((i < 91 * 84375)\n                  ? ((i < 31 * 84375) ? 1 : (i < 60 * 84375) ? 2 : 3)\n                  : ((i < 121 * 84375) ? 4 : (i < 152 * 84375) ? 5 : 6))\n               : ((i < 274 * 84375)\n                  ? ((i < 213 * 84375) ? 7 : (i < 244 * 84375) ? 8 : 9)\n                  : ((i < 305 * 84375) ? 10 : (i < 335 * 84375) ? 11 : 12)))\n            : ((i < 181 * 84375)\n               ? ((i < 90 * 84375)\n                  ? ((i < 31 * 84375) ? 1 : (i < 59 * 84375) ? 2 : 3)\n                  : ((i < 120 * 84375) ? 4 : (i < 151 * 84375) ? 5 : 6))\n               : ((i < 273 * 84375)\n                  ? ((i < 212 * 84375) ? 7 : (i < 243 * 84375) ? 8 : 9)\n                  : ((i < 304 * 84375) ? 10 : (i < 334 * 84375) ? 11 : 12)));\n    }",
    "comment": "-----------------------------------------------------------------------",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 0
  },
  {
    "name": "BasicGJChronology.getTotalMillisByYearMonth",
    "class_name": "org.joda.time.chrono.BasicGJChronology",
    "signature": "org.joda.time.chrono.BasicGJChronology.getTotalMillisByYearMonth(int,int)",
    "snippet": "    long getTotalMillisByYearMonth(int year, int month) {\n        if (isLeapYear(year)) {\n            return MAX_TOTAL_MILLIS_BY_MONTH_ARRAY[month - 1];\n        } else {\n            return MIN_TOTAL_MILLIS_BY_MONTH_ARRAY[month - 1];\n        }\n    }",
    "comment": "-----------------------------------------------------------------------",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 0
  },
  {
    "name": "BasicGJChronology.getYearDifference",
    "class_name": "org.joda.time.chrono.BasicGJChronology",
    "signature": "org.joda.time.chrono.BasicGJChronology.getYearDifference(long,long)",
    "snippet": "    long getYearDifference(long minuendInstant, long subtrahendInstant) {\n        int minuendYear = getYear(minuendInstant);\n        int subtrahendYear = getYear(subtrahendInstant);\n    \n        // Inlined remainder method to avoid duplicate calls to get.\n        long minuendRem = minuendInstant - getYearMillis(minuendYear);\n        long subtrahendRem = subtrahendInstant - getYearMillis(subtrahendYear);\n    \n        // Balance leap year differences on remainders.\n        if (subtrahendRem >= FEB_29) {\n            if (isLeapYear(subtrahendYear)) {\n                if (!isLeapYear(minuendYear)) {\n                    subtrahendRem -= DateTimeConstants.MILLIS_PER_DAY;\n                }\n            } else if (minuendRem >= FEB_29 && isLeapYear(minuendYear)) {\n                minuendRem -= DateTimeConstants.MILLIS_PER_DAY;\n            }\n        }\n    \n        int difference = minuendYear - subtrahendYear;\n        if (minuendRem < subtrahendRem) {\n            difference--;\n        }\n        return difference;\n    }",
    "comment": "-----------------------------------------------------------------------",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 0
  },
  {
    "name": "BasicGJChronology.setYear",
    "class_name": "org.joda.time.chrono.BasicGJChronology",
    "signature": "org.joda.time.chrono.BasicGJChronology.setYear(long,int)",
    "snippet": "    long setYear(long instant, int year) {\n        int thisYear = getYear(instant);\n        int dayOfYear = getDayOfYear(instant, thisYear);\n        int millisOfDay = getMillisOfDay(instant);\n\n        if (dayOfYear > (31 + 28)) { // after Feb 28\n            if (isLeapYear(thisYear)) {\n                // Current date is Feb 29 or later.\n                if (!isLeapYear(year)) {\n                    // Moving to a non-leap year, Feb 29 does not exist.\n                    dayOfYear--;\n                }\n            } else {\n                // Current date is Mar 01 or later.\n                if (isLeapYear(year)) {\n                    // Moving to a leap year, account for Feb 29.\n                    dayOfYear++;\n                }\n            }\n        }\n\n        instant = getYearMonthDayMillis(year, 1, dayOfYear);\n        instant += millisOfDay;\n\n        return instant;\n    }",
    "comment": "-----------------------------------------------------------------------",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 0
  },
  {
    "name": "BasicMonthOfYearDateTimeField.BasicMonthOfYearDateTimeField",
    "class_name": "org.joda.time.chrono.BasicMonthOfYearDateTimeField",
    "signature": "org.joda.time.chrono.BasicMonthOfYearDateTimeField.BasicMonthOfYearDateTimeField(BasicChronology,int)",
    "snippet": "    BasicMonthOfYearDateTimeField(BasicChronology chronology, int leapMonth) {\n        super(DateTimeFieldType.monthOfYear(), chronology.getAverageMillisPerMonth());\n        iChronology = chronology;\n        iMax = iChronology.getMaxMonth();\n        iLeapMonth = leapMonth;\n    }",
    "comment": " Restricted constructor.  @param leapMonth the month of year that leaps ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 0
  },
  {
    "name": "BasicMonthOfYearDateTimeField.add",
    "class_name": "org.joda.time.chrono.BasicMonthOfYearDateTimeField",
    "signature": "org.joda.time.chrono.BasicMonthOfYearDateTimeField.add(long,int)",
    "snippet": "    public long add(long instant, int months) {\n        if (months == 0) {\n            return instant; // the easy case\n        }\n        //\n        // Save time part first.\n        //\n        long timePart = iChronology.getMillisOfDay(instant);\n        //\n        //\n        // Get this year and month.\n        //\n        int thisYear = iChronology.getYear(instant);\n        int thisMonth = iChronology.getMonthOfYear(instant, thisYear);\n        // ----------------------------------------------------------\n        //\n        // Do not refactor without careful consideration.\n        // Order of calculation is important.\n        //\n        int yearToUse;\n        // Initially, monthToUse is zero-based\n        int monthToUse = thisMonth - 1 + months;\n        if (monthToUse >= 0) {\n            yearToUse = thisYear + (monthToUse / iMax);\n            monthToUse = (monthToUse % iMax) + 1;\n        } else {\n            yearToUse = thisYear + (monthToUse / iMax) - 1;\n            monthToUse = Math.abs(monthToUse);\n            int remMonthToUse = monthToUse % iMax;\n            // Take care of the boundary condition\n            if (remMonthToUse == 0) {\n                remMonthToUse = iMax;\n            }\n            monthToUse = iMax - remMonthToUse + 1;\n            // Take care of the boundary condition\n            if (monthToUse == 1) {\n                yearToUse += 1;\n            }\n        }\n        // End of do not refactor.\n        // ----------------------------------------------------------\n\n        //\n        // Quietly force DOM to nearest sane value.\n        //\n        int dayToUse = iChronology.getDayOfMonth(instant, thisYear, thisMonth);\n        int maxDay = iChronology.getDaysInYearMonth(yearToUse, monthToUse);\n        if (dayToUse > maxDay) {\n            dayToUse = maxDay;\n        }\n        //\n        // get proper date part, and return result\n        //\n        long datePart =\n            iChronology.getYearMonthDayMillis(yearToUse, monthToUse, dayToUse);\n        return datePart + timePart;\n    }",
    "comment": " Add the specified month to the specified time instant. The amount added may be negative.<p> If the new month has less total days than the specified day of the month, this value is coerced to the nearest sane value. e.g.<p> 07-31 - (1 month) = 06-30<p> 03-31 - (1 month) = 02-28 or 02-29 depending<p>  @see org.joda.time.DateTimeField#add @see org.joda.time.ReadWritableDateTime#addMonths(int) @param instant  the time instant in millis to update. @param months  the months to add (can be negative). @return the updated time instant. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 0
  },
  {
    "name": "BasicMonthOfYearDateTimeField.getDifferenceAsLong",
    "class_name": "org.joda.time.chrono.BasicMonthOfYearDateTimeField",
    "signature": "org.joda.time.chrono.BasicMonthOfYearDateTimeField.getDifferenceAsLong(long,long)",
    "snippet": "    public long getDifferenceAsLong(long minuendInstant, long subtrahendInstant) {\n        if (minuendInstant < subtrahendInstant) {\n            return -getDifference(subtrahendInstant, minuendInstant);\n        }\n\n        int minuendYear = iChronology.getYear(minuendInstant);\n        int minuendMonth = iChronology.getMonthOfYear(minuendInstant, minuendYear);\n        int subtrahendYear = iChronology.getYear(subtrahendInstant);\n        int subtrahendMonth = iChronology.getMonthOfYear(subtrahendInstant, subtrahendYear);\n\n        long difference = (minuendYear - subtrahendYear) * ((long) iMax) + minuendMonth - subtrahendMonth;\n\n        // Before adjusting for remainder, account for special case of add\n        // where the day-of-month is forced to the nearest sane value.\n        int minuendDom = iChronology.getDayOfMonth\n            (minuendInstant, minuendYear, minuendMonth);\n        if (minuendDom == iChronology.getDaysInYearMonth(minuendYear, minuendMonth)) {\n            // Last day of the minuend month...\n            int subtrahendDom = iChronology.getDayOfMonth\n                (subtrahendInstant, subtrahendYear, subtrahendMonth);\n            if (subtrahendDom > minuendDom) {\n                // ...and day of subtrahend month is larger.\n                // Note: This works fine, but it ideally shouldn't invoke other\n                // fields from within a field.\n                subtrahendInstant = iChronology.dayOfMonth().set(subtrahendInstant, minuendDom);\n            }\n        }\n\n        // Inlined remainder method to avoid duplicate calls.\n        long minuendRem = minuendInstant\n            - iChronology.getYearMonthMillis(minuendYear, minuendMonth);\n        long subtrahendRem = subtrahendInstant\n            - iChronology.getYearMonthMillis(subtrahendYear, subtrahendMonth);\n\n        if (minuendRem < subtrahendRem) {\n            difference--;\n        }\n\n        return difference;\n    }",
    "comment": "-----------------------------------------------------------------------",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 0
  },
  {
    "name": "BasicMonthOfYearDateTimeField.set",
    "class_name": "org.joda.time.chrono.BasicMonthOfYearDateTimeField",
    "signature": "org.joda.time.chrono.BasicMonthOfYearDateTimeField.set(long,int)",
    "snippet": "    public long set(long instant, int month) {\n        FieldUtils.verifyValueBounds(this, month, MIN, iMax);\n        //\n        int thisYear = iChronology.getYear(instant);\n        //\n        int thisDom = iChronology.getDayOfMonth(instant, thisYear);\n        int maxDom = iChronology.getDaysInYearMonth(thisYear, month);\n        if (thisDom > maxDom) {\n            // Quietly force DOM to nearest sane value.\n            thisDom = maxDom;\n        }\n        // Return newly calculated millis value\n        return iChronology.getYearMonthDayMillis(thisYear, month, thisDom) +\n            iChronology.getMillisOfDay(instant);\n    }",
    "comment": " Set the Month component of the specified time instant.<p> If the new month has less total days than the specified day of the month, this value is coerced to the nearest sane value. e.g.<p> 07-31 to month 6 = 06-30<p> 03-31 to month 2 = 02-28 or 02-29 depending<p>  @param instant  the time instant in millis to update. @param month  the month (1,12) to update the time to. @return the updated time instant. @throws IllegalArgumentException  if month is invalid ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 0
  },
  {
    "name": "BasicWeekOfWeekyearDateTimeField.BasicWeekOfWeekyearDateTimeField",
    "class_name": "org.joda.time.chrono.BasicWeekOfWeekyearDateTimeField",
    "signature": "org.joda.time.chrono.BasicWeekOfWeekyearDateTimeField.BasicWeekOfWeekyearDateTimeField(BasicChronology,DurationField)",
    "snippet": "    BasicWeekOfWeekyearDateTimeField(BasicChronology chronology, DurationField weeks) {\n        super(DateTimeFieldType.weekOfWeekyear(), weeks);\n        iChronology = chronology;\n    }",
    "comment": " Restricted constructor ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 0
  },
  {
    "name": "BasicWeekyearDateTimeField.BasicWeekyearDateTimeField",
    "class_name": "org.joda.time.chrono.BasicWeekyearDateTimeField",
    "signature": "org.joda.time.chrono.BasicWeekyearDateTimeField.BasicWeekyearDateTimeField(BasicChronology)",
    "snippet": "    BasicWeekyearDateTimeField(BasicChronology chronology) {\n        super(DateTimeFieldType.weekyear(), chronology.getAverageMillisPerYear());\n        iChronology = chronology;\n    }",
    "comment": " Restricted constructor ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 0
  },
  {
    "name": "BasicYearDateTimeField.BasicYearDateTimeField",
    "class_name": "org.joda.time.chrono.BasicYearDateTimeField",
    "signature": "org.joda.time.chrono.BasicYearDateTimeField.BasicYearDateTimeField(BasicChronology)",
    "snippet": "    BasicYearDateTimeField(BasicChronology chronology) {\n        super(DateTimeFieldType.year(), chronology.getAverageMillisPerYear());\n        iChronology = chronology;\n    }",
    "comment": " Restricted constructor.  @param chronology  the chronology this field belogs to ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 0
  },
  {
    "name": "BasicYearDateTimeField.add",
    "class_name": "org.joda.time.chrono.BasicYearDateTimeField",
    "signature": "org.joda.time.chrono.BasicYearDateTimeField.add(long,int)",
    "snippet": "    public long add(long instant, int years) {\n        if (years == 0) {\n            return instant;\n        }\n        int thisYear = get(instant);\n        int newYear = FieldUtils.safeAdd(thisYear, years);\n        return set(instant, newYear);\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 0
  },
  {
    "name": "BasicYearDateTimeField.get",
    "class_name": "org.joda.time.chrono.BasicYearDateTimeField",
    "signature": "org.joda.time.chrono.BasicYearDateTimeField.get(long)",
    "snippet": "    public int get(long instant) {\n        return iChronology.getYear(instant);\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 0
  },
  {
    "name": "BasicYearDateTimeField.getDifferenceAsLong",
    "class_name": "org.joda.time.chrono.BasicYearDateTimeField",
    "signature": "org.joda.time.chrono.BasicYearDateTimeField.getDifferenceAsLong(long,long)",
    "snippet": "    public long getDifferenceAsLong(long minuendInstant, long subtrahendInstant) {\n        if (minuendInstant < subtrahendInstant) {\n            return -iChronology.getYearDifference(subtrahendInstant, minuendInstant);\n        }\n        return iChronology.getYearDifference(minuendInstant, subtrahendInstant);\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 0
  },
  {
    "name": "BasicYearDateTimeField.getMaximumValue",
    "class_name": "org.joda.time.chrono.BasicYearDateTimeField",
    "signature": "org.joda.time.chrono.BasicYearDateTimeField.getMaximumValue()",
    "snippet": "    public int getMaximumValue() {\n        return iChronology.getMaxYear();\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 0
  },
  {
    "name": "BasicYearDateTimeField.set",
    "class_name": "org.joda.time.chrono.BasicYearDateTimeField",
    "signature": "org.joda.time.chrono.BasicYearDateTimeField.set(long,int)",
    "snippet": "    public long set(long instant, int year) {\n        FieldUtils.verifyValueBounds\n            (this, year, iChronology.getMinYear(), iChronology.getMaxYear());\n        return iChronology.setYear(instant, year);\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 0
  },
  {
    "name": "GJDayOfWeekDateTimeField.GJDayOfWeekDateTimeField",
    "class_name": "org.joda.time.chrono.GJDayOfWeekDateTimeField",
    "signature": "org.joda.time.chrono.GJDayOfWeekDateTimeField.GJDayOfWeekDateTimeField(BasicChronology,DurationField)",
    "snippet": "    GJDayOfWeekDateTimeField(BasicChronology chronology, DurationField days) {\n        super(DateTimeFieldType.dayOfWeek(), days);\n        iChronology = chronology;\n    }",
    "comment": " Restricted constructor. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 0
  },
  {
    "name": "GJDayOfWeekDateTimeField.get",
    "class_name": "org.joda.time.chrono.GJDayOfWeekDateTimeField",
    "signature": "org.joda.time.chrono.GJDayOfWeekDateTimeField.get(long)",
    "snippet": "    public int get(long instant) {\n        return iChronology.getDayOfWeek(instant);\n    }",
    "comment": " Get the value of the specified time instant.  @param instant  the time instant in millis to query @return the day of the week extracted from the input ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 0
  },
  {
    "name": "GJEraDateTimeField.GJEraDateTimeField",
    "class_name": "org.joda.time.chrono.GJEraDateTimeField",
    "signature": "org.joda.time.chrono.GJEraDateTimeField.GJEraDateTimeField(BasicChronology)",
    "snippet": "    GJEraDateTimeField(BasicChronology chronology) {\n        super(DateTimeFieldType.era());\n        iChronology = chronology;\n    }",
    "comment": " Restricted constructor ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 0
  },
  {
    "name": "GJMonthOfYearDateTimeField.GJMonthOfYearDateTimeField",
    "class_name": "org.joda.time.chrono.GJMonthOfYearDateTimeField",
    "signature": "org.joda.time.chrono.GJMonthOfYearDateTimeField.GJMonthOfYearDateTimeField(BasicChronology)",
    "snippet": "    GJMonthOfYearDateTimeField(BasicChronology chronology) {\n        super(chronology, 2);\n    }",
    "comment": " Restricted constructor ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 0
  },
  {
    "name": "GJYearOfEraDateTimeField.GJYearOfEraDateTimeField",
    "class_name": "org.joda.time.chrono.GJYearOfEraDateTimeField",
    "signature": "org.joda.time.chrono.GJYearOfEraDateTimeField.GJYearOfEraDateTimeField(DateTimeField,BasicChronology)",
    "snippet": "    GJYearOfEraDateTimeField(DateTimeField yearField, BasicChronology chronology) {\n        super(yearField, DateTimeFieldType.yearOfEra());\n        iChronology = chronology;\n    }",
    "comment": " Restricted constructor. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 0
  },
  {
    "name": "GJYearOfEraDateTimeField.getMaximumValue",
    "class_name": "org.joda.time.chrono.GJYearOfEraDateTimeField",
    "signature": "org.joda.time.chrono.GJYearOfEraDateTimeField.getMaximumValue()",
    "snippet": "    public int getMaximumValue() {\n        return getWrappedField().getMaximumValue();\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 0
  },
  {
    "name": "GJYearOfEraDateTimeField.getMinimumValue",
    "class_name": "org.joda.time.chrono.GJYearOfEraDateTimeField",
    "signature": "org.joda.time.chrono.GJYearOfEraDateTimeField.getMinimumValue()",
    "snippet": "    public int getMinimumValue() {\n        return 1;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 0
  },
  {
    "name": "ISOChronology.assemble",
    "class_name": "org.joda.time.chrono.ISOChronology",
    "signature": "org.joda.time.chrono.ISOChronology.assemble(Fields)",
    "snippet": "    protected void assemble(Fields fields) {\n        if (getBase().getZone() == DateTimeZone.UTC) {\n            // Use zero based century and year of century.\n            fields.centuryOfEra = new DividedDateTimeField(\n                ISOYearOfEraDateTimeField.INSTANCE, DateTimeFieldType.centuryOfEra(), 100);\n            fields.yearOfCentury = new RemainderDateTimeField(\n                (DividedDateTimeField) fields.centuryOfEra, DateTimeFieldType.yearOfCentury());\n            fields.weekyearOfCentury = new RemainderDateTimeField(\n                (DividedDateTimeField) fields.centuryOfEra, DateTimeFieldType.weekyearOfCentury());\n\n            fields.centuries = fields.centuryOfEra.getDurationField();\n        }\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 0
  },
  {
    "name": "ISOChronology.getInstance",
    "class_name": "org.joda.time.chrono.ISOChronology",
    "signature": "org.joda.time.chrono.ISOChronology.getInstance()",
    "snippet": "    public static ISOChronology getInstance() {\n        return getInstance(DateTimeZone.getDefault());\n    }",
    "comment": " Gets an instance of the ISOChronology in the default time zone.  @return a chronology in the default time zone ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 0
  },
  {
    "name": "ISOChronology.getInstance",
    "class_name": "org.joda.time.chrono.ISOChronology",
    "signature": "org.joda.time.chrono.ISOChronology.getInstance(DateTimeZone)",
    "snippet": "    public static ISOChronology getInstance(DateTimeZone zone) {\n        if (zone == null) {\n            zone = DateTimeZone.getDefault();\n        }\n        int index = System.identityHashCode(zone) & (FAST_CACHE_SIZE - 1);\n        ISOChronology chrono = cFastCache[index];\n        if (chrono != null && chrono.getZone() == zone) {\n            return chrono;\n        }\n        synchronized (cCache) {\n            chrono = cCache.get(zone);\n            if (chrono == null) {\n                chrono = new ISOChronology(ZonedChronology.getInstance(INSTANCE_UTC, zone));\n                cCache.put(zone, chrono);\n            }\n        }\n        cFastCache[index] = chrono;\n        return chrono;\n    }",
    "comment": " Gets an instance of the ISOChronology in the given time zone.  @param zone  the time zone to get the chronology in, null is default @return a chronology in the specified time zone ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 0
  },
  {
    "name": "ISOChronology.getInstanceUTC",
    "class_name": "org.joda.time.chrono.ISOChronology",
    "signature": "org.joda.time.chrono.ISOChronology.getInstanceUTC()",
    "snippet": "    public static ISOChronology getInstanceUTC() {\n        return INSTANCE_UTC;\n    }",
    "comment": " Gets an instance of the ISOChronology. The time zone of the returned instance is UTC.  @return a singleton UTC instance of the chronology ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 0
  },
  {
    "name": "ISOYearOfEraDateTimeField.getMaximumValue",
    "class_name": "org.joda.time.chrono.ISOYearOfEraDateTimeField",
    "signature": "org.joda.time.chrono.ISOYearOfEraDateTimeField.getMaximumValue()",
    "snippet": "    public int getMaximumValue() {\n        return getWrappedField().getMaximumValue();\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 0
  },
  {
    "name": "ISOYearOfEraDateTimeField.getMinimumValue",
    "class_name": "org.joda.time.chrono.ISOYearOfEraDateTimeField",
    "signature": "org.joda.time.chrono.ISOYearOfEraDateTimeField.getMinimumValue()",
    "snippet": "    public int getMinimumValue() {\n        return 0;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 0
  },
  {
    "name": "BaseDateTimeField.BaseDateTimeField",
    "class_name": "org.joda.time.field.BaseDateTimeField",
    "signature": "org.joda.time.field.BaseDateTimeField.BaseDateTimeField(DateTimeFieldType)",
    "snippet": "    protected BaseDateTimeField(DateTimeFieldType type) {\n        super();\n        if (type == null) {\n            throw new IllegalArgumentException(\"The type must not be null\");\n        }\n        iType = type;\n    }",
    "comment": " Constructor. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 0
  },
  {
    "name": "BaseDateTimeField.add",
    "class_name": "org.joda.time.field.BaseDateTimeField",
    "signature": "org.joda.time.field.BaseDateTimeField.add(long,int)",
    "snippet": "    public long add(long instant, int value) {\n        return getDurationField().add(instant, value);\n    }",
    "comment": " Adds a value (which may be negative) to the instant value, overflowing into larger fields if necessary. <p> The value will be added to this field. If the value is too large to be added solely to this field, larger fields will increase as required. Smaller fields should be unaffected, except where the result would be an invalid value for a smaller field. In this case the smaller field is adjusted to be in range. <p> For example, in the ISO chronology:<br> 2000-08-20 add six months is 2001-02-20<br> 2000-08-20 add twenty months is 2002-04-20<br> 2000-08-20 add minus nine months is 1999-11-20<br> 2001-01-31 add one month  is 2001-02-28<br> 2001-01-31 add two months is 2001-03-31<br>  @param instant  the milliseconds from 1970-01-01T00:00:00Z to add to @param value  the value to add, in the units of the field @return the updated milliseconds ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 0
  },
  {
    "name": "BaseDateTimeField.getType",
    "class_name": "org.joda.time.field.BaseDateTimeField",
    "signature": "org.joda.time.field.BaseDateTimeField.getType()",
    "snippet": "    public final DateTimeFieldType getType() {\n        return iType;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 0
  },
  {
    "name": "BaseDateTimeField.isSupported",
    "class_name": "org.joda.time.field.BaseDateTimeField",
    "signature": "org.joda.time.field.BaseDateTimeField.isSupported()",
    "snippet": "    public final boolean isSupported() {\n        return true;\n    }",
    "comment": " @return true always ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 0
  },
  {
    "name": "BaseDurationField.BaseDurationField",
    "class_name": "org.joda.time.field.BaseDurationField",
    "signature": "org.joda.time.field.BaseDurationField.BaseDurationField(DurationFieldType)",
    "snippet": "    protected BaseDurationField(DurationFieldType type) {\n        super();\n        if (type == null) {\n            throw new IllegalArgumentException(\"The type must not be null\");\n        }\n        iType = type;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 0
  },
  {
    "name": "BaseDurationField.getDifference",
    "class_name": "org.joda.time.field.BaseDurationField",
    "signature": "org.joda.time.field.BaseDurationField.getDifference(long,long)",
    "snippet": "    public int getDifference(long minuendInstant, long subtrahendInstant) {\n        return FieldUtils.safeToInt(getDifferenceAsLong(minuendInstant, subtrahendInstant));\n    }",
    "comment": "------------------------------------------------------------------------",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 0
  },
  {
    "name": "BaseDurationField.isSupported",
    "class_name": "org.joda.time.field.BaseDurationField",
    "signature": "org.joda.time.field.BaseDurationField.isSupported()",
    "snippet": "    public final boolean isSupported() {\n        return true;\n    }",
    "comment": " @return true always ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 0
  },
  {
    "name": "DecoratedDateTimeField.DecoratedDateTimeField",
    "class_name": "org.joda.time.field.DecoratedDateTimeField",
    "signature": "org.joda.time.field.DecoratedDateTimeField.DecoratedDateTimeField(DateTimeField,DateTimeFieldType)",
    "snippet": "    protected DecoratedDateTimeField(DateTimeField field, DateTimeFieldType type) {\n        super(type);\n        if (field == null) {\n            throw new IllegalArgumentException(\"The field must not be null\");\n        }\n        if (!field.isSupported()) {\n            throw new IllegalArgumentException(\"The field must be supported\");\n        }\n        iField = field;\n    }",
    "comment": " Constructor.  @param field  the field being decorated @param type  allow type to be overridden ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 0
  },
  {
    "name": "DecoratedDateTimeField.getDurationField",
    "class_name": "org.joda.time.field.DecoratedDateTimeField",
    "signature": "org.joda.time.field.DecoratedDateTimeField.getDurationField()",
    "snippet": "    public DurationField getDurationField() {\n        return iField.getDurationField();\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 0
  },
  {
    "name": "DecoratedDateTimeField.getWrappedField",
    "class_name": "org.joda.time.field.DecoratedDateTimeField",
    "signature": "org.joda.time.field.DecoratedDateTimeField.getWrappedField()",
    "snippet": "    public final DateTimeField getWrappedField() {\n        return iField;\n    }",
    "comment": " Gets the wrapped date time field.  @return the wrapped DateTimeField ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 0
  },
  {
    "name": "DecoratedDurationField.DecoratedDurationField",
    "class_name": "org.joda.time.field.DecoratedDurationField",
    "signature": "org.joda.time.field.DecoratedDurationField.DecoratedDurationField(DurationField,DurationFieldType)",
    "snippet": "    public DecoratedDurationField(DurationField field, DurationFieldType type) {\n        super(type);\n        if (field == null) {\n            throw new IllegalArgumentException(\"The field must not be null\");\n        }\n        if (!field.isSupported()) {\n            throw new IllegalArgumentException(\"The field must be supported\");\n        }\n        iField = field;\n    }",
    "comment": " Constructor.  @param field  the base field @param type  the type to actually use ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 0
  },
  {
    "name": "DividedDateTimeField.DividedDateTimeField",
    "class_name": "org.joda.time.field.DividedDateTimeField",
    "signature": "org.joda.time.field.DividedDateTimeField.DividedDateTimeField(DateTimeField,DateTimeFieldType,int)",
    "snippet": "    public DividedDateTimeField(DateTimeField field,\n                                DateTimeFieldType type, int divisor) {\n        super(field, type);\n                \n        if (divisor < 2) {\n            throw new IllegalArgumentException(\"The divisor must be at least 2\");\n        }\n\n        DurationField unitField = field.getDurationField();\n        if (unitField == null) {\n            iDurationField = null;\n        } else {\n            iDurationField = new ScaledDurationField(\n                unitField, type.getDurationType(), divisor);\n        }\n\n        iDivisor = divisor;\n\n        int i = field.getMinimumValue();\n        int min = (i >= 0) ? i / divisor : ((i + 1) / divisor - 1);\n\n        int j = field.getMaximumValue();\n        int max = (j >= 0) ? j / divisor : ((j + 1) / divisor - 1);\n\n        iMin = min;\n        iMax = max;\n    }",
    "comment": " Constructor.  @param field  the field to wrap, like \"year()\". @param type  the field type this field will actually use @param divisor  divisor, such as 100 years in a century @throws IllegalArgumentException if divisor is less than two ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 0
  },
  {
    "name": "DividedDateTimeField.getDurationField",
    "class_name": "org.joda.time.field.DividedDateTimeField",
    "signature": "org.joda.time.field.DividedDateTimeField.getDurationField()",
    "snippet": "    public DurationField getDurationField() {\n        return iDurationField;\n    }",
    "comment": " Returns a scaled version of the wrapped field's unit duration field. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 0
  },
  {
    "name": "FieldUtils.safeAdd",
    "class_name": "org.joda.time.field.FieldUtils",
    "signature": "org.joda.time.field.FieldUtils.safeAdd(int,int)",
    "snippet": "    public static int safeAdd(int val1, int val2) {\n        int sum = val1 + val2;\n        // If there is a sign change, but the two values have the same sign...\n        if ((val1 ^ sum) < 0 && (val1 ^ val2) >= 0) {\n            throw new ArithmeticException\n                (\"The calculation caused an overflow: \" + val1 + \" + \" + val2);\n        }\n        return sum;\n    }",
    "comment": " Add two values throwing an exception if overflow occurs.  @param val1  the first value @param val2  the second value @return the new total @throws ArithmeticException if the value is too big or too small ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 0
  },
  {
    "name": "FieldUtils.safeAdd",
    "class_name": "org.joda.time.field.FieldUtils",
    "signature": "org.joda.time.field.FieldUtils.safeAdd(long,long)",
    "snippet": "    public static long safeAdd(long val1, long val2) {\n        long sum = val1 + val2;\n        // If there is a sign change, but the two values have the same sign...\n        if ((val1 ^ sum) < 0 && (val1 ^ val2) >= 0) {\n            throw new ArithmeticException\n                (\"The calculation caused an overflow: \" + val1 + \" + \" + val2);\n        }\n        return sum;\n    }",
    "comment": " Add two values throwing an exception if overflow occurs.  @param val1  the first value @param val2  the second value @return the new total @throws ArithmeticException if the value is too big or too small ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 0
  },
  {
    "name": "FieldUtils.safeSubtract",
    "class_name": "org.joda.time.field.FieldUtils",
    "signature": "org.joda.time.field.FieldUtils.safeSubtract(long,long)",
    "snippet": "    public static long safeSubtract(long val1, long val2) {\n        long diff = val1 - val2;\n        // If there is a sign change, but the two values have different signs...\n        if ((val1 ^ diff) < 0 && (val1 ^ val2) < 0) {\n            throw new ArithmeticException\n                (\"The calculation caused an overflow: \" + val1 + \" - \" + val2);\n        }\n        return diff;\n    }",
    "comment": " Subtracts two values throwing an exception if overflow occurs.  @param val1  the first value, to be taken away from @param val2  the second value, the amount to take away @return the new total @throws ArithmeticException if the value is too big or too small ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 0
  },
  {
    "name": "FieldUtils.safeToInt",
    "class_name": "org.joda.time.field.FieldUtils",
    "signature": "org.joda.time.field.FieldUtils.safeToInt(long)",
    "snippet": "    public static int safeToInt(long value) {\n        if (Integer.MIN_VALUE <= value && value <= Integer.MAX_VALUE) {\n            return (int) value;\n        }\n        throw new ArithmeticException(\"Value cannot fit in an int: \" + value);\n    }",
    "comment": " Casts to an int throwing an exception if overflow occurs.  @param value  the value @return the value as an int @throws ArithmeticException if the value is too big or too small ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 0
  },
  {
    "name": "FieldUtils.verifyValueBounds",
    "class_name": "org.joda.time.field.FieldUtils",
    "signature": "org.joda.time.field.FieldUtils.verifyValueBounds(DateTimeField,int,int,int)",
    "snippet": "    public static void verifyValueBounds(DateTimeField field, \n                                         int value, int lowerBound, int upperBound) {\n        if ((value < lowerBound) || (value > upperBound)) {\n            throw new IllegalFieldValueException\n                (field.getType(), Integer.valueOf(value),\n                 Integer.valueOf(lowerBound), Integer.valueOf(upperBound));\n        }\n    }",
    "comment": " Verify that input values are within specified bounds.  @param value  the value to check @param lowerBound  the lower bound allowed for value @param upperBound  the upper bound allowed for value @throws IllegalFieldValueException if value is not in the specified bounds ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 0
  },
  {
    "name": "ImpreciseDateTimeField.ImpreciseDateTimeField",
    "class_name": "org.joda.time.field.ImpreciseDateTimeField",
    "signature": "org.joda.time.field.ImpreciseDateTimeField.ImpreciseDateTimeField(DateTimeFieldType,long)",
    "snippet": "    public ImpreciseDateTimeField(DateTimeFieldType type, long unitMillis) {\n        super(type);\n        iUnitMillis = unitMillis;\n        iDurationField = new LinkedDurationField(type.getDurationType());\n    }",
    "comment": " Constructor.  @param type  the field type @param unitMillis  the average duration unit milliseconds ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 0
  },
  {
    "name": "ImpreciseDateTimeField.getDifference",
    "class_name": "org.joda.time.field.ImpreciseDateTimeField",
    "signature": "org.joda.time.field.ImpreciseDateTimeField.getDifference(long,long)",
    "snippet": "    public int getDifference(long minuendInstant, long subtrahendInstant) {\n        return FieldUtils.safeToInt(getDifferenceAsLong(minuendInstant, subtrahendInstant));\n    }",
    "comment": " Computes the difference between two instants, as measured in the units of this field. Any fractional units are dropped from the result. Calling getDifference reverses the effect of calling add. In the following code:  <pre> long instant = ... int v = ... int age = getDifference(add(instant, v), instant); </pre>  The value 'age' is the same as the value 'v'. <p> The default implementation call getDifferenceAsLong and converts the return value to an int.  @param minuendInstant the milliseconds from 1970-01-01T00:00:00Z to subtract from @param subtrahendInstant the milliseconds from 1970-01-01T00:00:00Z to subtract off the minuend @return the difference in the units of this field ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 0
  },
  {
    "name": "ImpreciseDateTimeField.getDurationField",
    "class_name": "org.joda.time.field.ImpreciseDateTimeField",
    "signature": "org.joda.time.field.ImpreciseDateTimeField.getDurationField()",
    "snippet": "    public final DurationField getDurationField() {\n        return iDurationField;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 0
  },
  {
    "name": "LinkedDurationField.add",
    "class_name": "org.joda.time.field.ImpreciseDateTimeField$LinkedDurationField",
    "signature": "org.joda.time.field.ImpreciseDateTimeField$LinkedDurationField.add(long,int)",
    "snippet": "        public long add(long instant, int value) {\n            return ImpreciseDateTimeField.this.add(instant, value);\n        }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 0
  },
  {
    "name": "LinkedDurationField.getDifference",
    "class_name": "org.joda.time.field.ImpreciseDateTimeField$LinkedDurationField",
    "signature": "org.joda.time.field.ImpreciseDateTimeField$LinkedDurationField.getDifference(long,long)",
    "snippet": "        public int getDifference(long minuendInstant, long subtrahendInstant) {\n            return ImpreciseDateTimeField.this\n                .getDifference(minuendInstant, subtrahendInstant);\n        }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 0
  },
  {
    "name": "MillisDurationField.add",
    "class_name": "org.joda.time.field.MillisDurationField",
    "signature": "org.joda.time.field.MillisDurationField.add(long,int)",
    "snippet": "    public long add(long instant, int value) {\n        return FieldUtils.safeAdd(instant, value);\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 0
  },
  {
    "name": "MillisDurationField.getUnitMillis",
    "class_name": "org.joda.time.field.MillisDurationField",
    "signature": "org.joda.time.field.MillisDurationField.getUnitMillis()",
    "snippet": "    public final long getUnitMillis() {\n        return 1;\n    }",
    "comment": " Returns the amount of milliseconds per unit value of this field.  @return one always ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 0
  },
  {
    "name": "MillisDurationField.isPrecise",
    "class_name": "org.joda.time.field.MillisDurationField",
    "signature": "org.joda.time.field.MillisDurationField.isPrecise()",
    "snippet": "    public final boolean isPrecise() {\n        return true;\n    }",
    "comment": " Returns true as this field is precise.  @return true always ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 0
  },
  {
    "name": "MillisDurationField.isSupported",
    "class_name": "org.joda.time.field.MillisDurationField",
    "signature": "org.joda.time.field.MillisDurationField.isSupported()",
    "snippet": "    public boolean isSupported() {\n        return true;\n    }",
    "comment": " Returns true as this field is supported.  @return true always ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 0
  },
  {
    "name": "OffsetDateTimeField.OffsetDateTimeField",
    "class_name": "org.joda.time.field.OffsetDateTimeField",
    "signature": "org.joda.time.field.OffsetDateTimeField.OffsetDateTimeField(DateTimeField,DateTimeFieldType,int)",
    "snippet": "    public OffsetDateTimeField(DateTimeField field, DateTimeFieldType type, int offset) {\n        this(field, type, offset, Integer.MIN_VALUE, Integer.MAX_VALUE);\n    }",
    "comment": " Constructor.  @param field  the field to wrap, like \"year()\". @param type  the field type this field actually uses @param offset  offset to add to field values @throws IllegalArgumentException if offset is zero ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 0
  },
  {
    "name": "OffsetDateTimeField.OffsetDateTimeField",
    "class_name": "org.joda.time.field.OffsetDateTimeField",
    "signature": "org.joda.time.field.OffsetDateTimeField.OffsetDateTimeField(DateTimeField,DateTimeFieldType,int,int,int)",
    "snippet": "    public OffsetDateTimeField(DateTimeField field, DateTimeFieldType type, int offset,\n                               int minValue, int maxValue) {\n        super(field, type);\n                \n        if (offset == 0) {\n            throw new IllegalArgumentException(\"The offset cannot be zero\");\n        }\n\n        iOffset = offset;\n\n        if (minValue < (field.getMinimumValue() + offset)) {\n            iMin = field.getMinimumValue() + offset;\n        } else {\n            iMin = minValue;\n        }\n        if (maxValue > (field.getMaximumValue() + offset)) {\n            iMax = field.getMaximumValue() + offset;\n        } else {\n            iMax = maxValue;\n        }\n    }",
    "comment": " Constructor.  @param field  the field to wrap, like \"year()\". @param type  the field type this field actually uses @param offset  offset to add to field values @param minValue  minimum allowed value @param maxValue  maximum allowed value @throws IllegalArgumentException if offset is zero ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 0
  },
  {
    "name": "OffsetDateTimeField.OffsetDateTimeField",
    "class_name": "org.joda.time.field.OffsetDateTimeField",
    "signature": "org.joda.time.field.OffsetDateTimeField.OffsetDateTimeField(DateTimeField,int)",
    "snippet": "    public OffsetDateTimeField(DateTimeField field, int offset) {\n        this(field, (field == null ? null : field.getType()), offset, Integer.MIN_VALUE, Integer.MAX_VALUE);\n    }",
    "comment": " Constructor.  @param field  the field to wrap, like \"year()\". @param offset  offset to add to field values @throws IllegalArgumentException if offset is zero ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 0
  },
  {
    "name": "OffsetDateTimeField.getMaximumValue",
    "class_name": "org.joda.time.field.OffsetDateTimeField",
    "signature": "org.joda.time.field.OffsetDateTimeField.getMaximumValue()",
    "snippet": "    public int getMaximumValue() {\n        return iMax;\n    }",
    "comment": " Get the maximum value for the field.  @return the maximum value ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 0
  },
  {
    "name": "OffsetDateTimeField.getMinimumValue",
    "class_name": "org.joda.time.field.OffsetDateTimeField",
    "signature": "org.joda.time.field.OffsetDateTimeField.getMinimumValue()",
    "snippet": "    public int getMinimumValue() {\n        return iMin;\n    }",
    "comment": " Get the minimum value for the field.  @return the minimum value ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 0
  },
  {
    "name": "PreciseDateTimeField.PreciseDateTimeField",
    "class_name": "org.joda.time.field.PreciseDateTimeField",
    "signature": "org.joda.time.field.PreciseDateTimeField.PreciseDateTimeField(DateTimeFieldType,DurationField,DurationField)",
    "snippet": "    public PreciseDateTimeField(DateTimeFieldType type,\n                                DurationField unit, DurationField range) {\n        super(type, unit);\n\n        if (!range.isPrecise()) {\n            throw new IllegalArgumentException(\"Range duration field must be precise\");\n        }\n\n        long rangeMillis = range.getUnitMillis();\n        iRange = (int)(rangeMillis / getUnitMillis());\n        if (iRange < 2) {\n            throw new IllegalArgumentException(\"The effective range must be at least 2\");\n        }\n\n        iRangeField = range;\n    }",
    "comment": " Constructor.  @param type  the field type this field uses @param unit  precise unit duration, like \"seconds()\". @param range precise range duration, preferably a multiple of the unit, like \"minutes()\". @throws IllegalArgumentException if either duration field is imprecise @throws IllegalArgumentException if unit milliseconds is less than one or effective value range is less than two. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 0
  },
  {
    "name": "PreciseDateTimeField.get",
    "class_name": "org.joda.time.field.PreciseDateTimeField",
    "signature": "org.joda.time.field.PreciseDateTimeField.get(long)",
    "snippet": "    public int get(long instant) {\n        if (instant >= 0) {\n            return (int) ((instant / getUnitMillis()) % iRange);\n        } else {\n            return iRange - 1 + (int) (((instant + 1) / getUnitMillis()) % iRange);\n        }\n    }",
    "comment": " Get the amount of fractional units from the specified time instant.  @param instant  the milliseconds from 1970-01-01T00:00:00Z to query @return the amount of fractional units extracted from the input. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 0
  },
  {
    "name": "PreciseDateTimeField.getMaximumValue",
    "class_name": "org.joda.time.field.PreciseDateTimeField",
    "signature": "org.joda.time.field.PreciseDateTimeField.getMaximumValue()",
    "snippet": "    public int getMaximumValue() {\n        return iRange - 1;\n    }",
    "comment": " Get the maximum value for the field.  @return the maximum value ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 0
  },
  {
    "name": "PreciseDateTimeField.set",
    "class_name": "org.joda.time.field.PreciseDateTimeField",
    "signature": "org.joda.time.field.PreciseDateTimeField.set(long,int)",
    "snippet": "    public long set(long instant, int value) {\n        FieldUtils.verifyValueBounds(this, value, getMinimumValue(), getMaximumValue());\n        return instant + (value - get(instant)) * iUnitMillis;\n    }",
    "comment": " Set the specified amount of units to the specified time instant.  @param instant  the milliseconds from 1970-01-01T00:00:00Z to set in @param value  value of units to set. @return the updated time instant. @throws IllegalArgumentException if value is too large or too small. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 0
  },
  {
    "name": "PreciseDurationDateTimeField.PreciseDurationDateTimeField",
    "class_name": "org.joda.time.field.PreciseDurationDateTimeField",
    "signature": "org.joda.time.field.PreciseDurationDateTimeField.PreciseDurationDateTimeField(DateTimeFieldType,DurationField)",
    "snippet": "    public PreciseDurationDateTimeField(DateTimeFieldType type, DurationField unit) {\n        super(type);\n\n        if (!unit.isPrecise()) {\n            throw new IllegalArgumentException(\"Unit duration field must be precise\");\n        }\n\n        iUnitMillis = unit.getUnitMillis();\n        if (iUnitMillis < 1) {\n            throw new IllegalArgumentException(\"The unit milliseconds must be at least 1\");\n        }\n\n        iUnitField = unit;\n    }",
    "comment": " Constructor.  @param type  the field type @param unit  precise unit duration, like \"days()\". @throws IllegalArgumentException if duration field is imprecise @throws IllegalArgumentException if unit milliseconds is less than one ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 0
  },
  {
    "name": "PreciseDurationDateTimeField.getDurationField",
    "class_name": "org.joda.time.field.PreciseDurationDateTimeField",
    "signature": "org.joda.time.field.PreciseDurationDateTimeField.getDurationField()",
    "snippet": "    public DurationField getDurationField() {\n        return iUnitField;\n    }",
    "comment": " Returns the duration per unit value of this field. For example, if this field represents \"minute of hour\", then the duration field is minutes.  @return the duration of this field, or UnsupportedDurationField if field has no duration ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 0
  },
  {
    "name": "PreciseDurationDateTimeField.getMinimumValue",
    "class_name": "org.joda.time.field.PreciseDurationDateTimeField",
    "signature": "org.joda.time.field.PreciseDurationDateTimeField.getMinimumValue()",
    "snippet": "    public int getMinimumValue() {\n        return 0;\n    }",
    "comment": " Get the minimum value for the field.  @return the minimum value ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 0
  },
  {
    "name": "PreciseDurationDateTimeField.getUnitMillis",
    "class_name": "org.joda.time.field.PreciseDurationDateTimeField",
    "signature": "org.joda.time.field.PreciseDurationDateTimeField.getUnitMillis()",
    "snippet": "    public final long getUnitMillis() {\n        return iUnitMillis;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 0
  },
  {
    "name": "PreciseDurationDateTimeField.set",
    "class_name": "org.joda.time.field.PreciseDurationDateTimeField",
    "signature": "org.joda.time.field.PreciseDurationDateTimeField.set(long,int)",
    "snippet": "    public long set(long instant, int value) {\n        FieldUtils.verifyValueBounds(this, value, getMinimumValue(),\n                                     getMaximumValueForSet(instant, value));\n        return instant + (value - get(instant)) * iUnitMillis;\n    }",
    "comment": " Set the specified amount of units to the specified time instant.  @param instant  the milliseconds from 1970-01-01T00:00:00Z to set in @param value  value of units to set. @return the updated time instant. @throws IllegalArgumentException if value is too large or too small. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 0
  },
  {
    "name": "PreciseDurationField.PreciseDurationField",
    "class_name": "org.joda.time.field.PreciseDurationField",
    "signature": "org.joda.time.field.PreciseDurationField.PreciseDurationField(DurationFieldType,long)",
    "snippet": "    public PreciseDurationField(DurationFieldType type, long unitMillis) {\n        super(type);\n        iUnitMillis = unitMillis;\n    }",
    "comment": " Constructor.  @param type  the field type @param unitMillis  the unit milliseconds ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 0
  },
  {
    "name": "PreciseDurationField.add",
    "class_name": "org.joda.time.field.PreciseDurationField",
    "signature": "org.joda.time.field.PreciseDurationField.add(long,int)",
    "snippet": "    public long add(long instant, int value) {\n        long addition = value * iUnitMillis;  // safe\n        return FieldUtils.safeAdd(instant, addition);\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 0
  },
  {
    "name": "PreciseDurationField.getDifferenceAsLong",
    "class_name": "org.joda.time.field.PreciseDurationField",
    "signature": "org.joda.time.field.PreciseDurationField.getDifferenceAsLong(long,long)",
    "snippet": "    public long getDifferenceAsLong(long minuendInstant, long subtrahendInstant) {\n        long difference = FieldUtils.safeSubtract(minuendInstant, subtrahendInstant);\n        return difference / iUnitMillis;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 0
  },
  {
    "name": "PreciseDurationField.getUnitMillis",
    "class_name": "org.joda.time.field.PreciseDurationField",
    "signature": "org.joda.time.field.PreciseDurationField.getUnitMillis()",
    "snippet": "    public final long getUnitMillis() {\n        return iUnitMillis;\n    }",
    "comment": " Returns the amount of milliseconds per unit value of this field.  @return the unit size of this field, in milliseconds ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 0
  },
  {
    "name": "PreciseDurationField.isPrecise",
    "class_name": "org.joda.time.field.PreciseDurationField",
    "signature": "org.joda.time.field.PreciseDurationField.isPrecise()",
    "snippet": "    public final boolean isPrecise() {\n        return true;\n    }",
    "comment": " This field is precise.  @return true always ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 0
  },
  {
    "name": "RemainderDateTimeField.RemainderDateTimeField",
    "class_name": "org.joda.time.field.RemainderDateTimeField",
    "signature": "org.joda.time.field.RemainderDateTimeField.RemainderDateTimeField(DateTimeField,DateTimeFieldType,int)",
    "snippet": "    public RemainderDateTimeField(DateTimeField field,\n                                  DateTimeFieldType type, int divisor) {\n        super(field, type);\n\n        if (divisor < 2) {\n            throw new IllegalArgumentException(\"The divisor must be at least 2\");\n        }\n\n        DurationField rangeField = field.getDurationField();\n        if (rangeField == null) {\n            iRangeField = null;\n        } else {\n            iRangeField = new ScaledDurationField(\n                rangeField, type.getRangeDurationType(), divisor);\n        }\n\n        iDivisor = divisor;\n    }",
    "comment": " Constructor.  @param field  the field to wrap, like \"year()\". @param type  the field type this field actually uses @param divisor  divisor, such as 100 years in a century @throws IllegalArgumentException if divisor is less than two ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 0
  },
  {
    "name": "RemainderDateTimeField.RemainderDateTimeField",
    "class_name": "org.joda.time.field.RemainderDateTimeField",
    "signature": "org.joda.time.field.RemainderDateTimeField.RemainderDateTimeField(DividedDateTimeField)",
    "snippet": "    public RemainderDateTimeField(DividedDateTimeField dividedField) {\n        this(dividedField, dividedField.getType());\n    }",
    "comment": " Construct a RemainderDateTimeField that compliments the given DividedDateTimeField.  @param dividedField  complimentary divided field, like \"century()\". ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 0
  },
  {
    "name": "RemainderDateTimeField.RemainderDateTimeField",
    "class_name": "org.joda.time.field.RemainderDateTimeField",
    "signature": "org.joda.time.field.RemainderDateTimeField.RemainderDateTimeField(DividedDateTimeField,DateTimeFieldType)",
    "snippet": "    public RemainderDateTimeField(DividedDateTimeField dividedField, DateTimeFieldType type) {\n        super(dividedField.getWrappedField(), type);\n        iDivisor = dividedField.iDivisor;\n        iRangeField = dividedField.iDurationField;\n    }",
    "comment": " Construct a RemainderDateTimeField that compliments the given DividedDateTimeField.  @param dividedField  complimentary divided field, like \"century()\". @param type  the field type this field actually uses ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 0
  },
  {
    "name": "RemainderDateTimeField.getMaximumValue",
    "class_name": "org.joda.time.field.RemainderDateTimeField",
    "signature": "org.joda.time.field.RemainderDateTimeField.getMaximumValue()",
    "snippet": "    public int getMaximumValue() {\n        return iDivisor - 1;\n    }",
    "comment": " Get the maximum value for the field, which is always one less than the divisor.  @return the maximum value ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 0
  },
  {
    "name": "RemainderDateTimeField.getMinimumValue",
    "class_name": "org.joda.time.field.RemainderDateTimeField",
    "signature": "org.joda.time.field.RemainderDateTimeField.getMinimumValue()",
    "snippet": "    public int getMinimumValue() {\n        return 0;\n    }",
    "comment": " Get the minimum value for the field, which is always zero.  @return the minimum value of zero. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 0
  },
  {
    "name": "ScaledDurationField.ScaledDurationField",
    "class_name": "org.joda.time.field.ScaledDurationField",
    "signature": "org.joda.time.field.ScaledDurationField.ScaledDurationField(DurationField,DurationFieldType,int)",
    "snippet": "    public ScaledDurationField(DurationField field, DurationFieldType type, int scalar) {\n        super(field, type);\n        if (scalar == 0 || scalar == 1) {\n            throw new IllegalArgumentException(\"The scalar must not be 0 or 1\");\n        }\n        iScalar = scalar;\n    }",
    "comment": " Constructor  @param field  the field to wrap, like \"year()\". @param type  the type this field will actually use @param scalar  scalar, such as 100 years in a century @throws IllegalArgumentException if scalar is zero or one. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 0
  },
  {
    "name": "UnsupportedDurationField.getInstance",
    "class_name": "org.joda.time.field.UnsupportedDurationField",
    "signature": "org.joda.time.field.UnsupportedDurationField.getInstance(DurationFieldType)",
    "snippet": "    public static synchronized UnsupportedDurationField getInstance(DurationFieldType type) {\n        UnsupportedDurationField field;\n        if (cCache == null) {\n            cCache = new HashMap<DurationFieldType, UnsupportedDurationField>(7);\n            field = null;\n        } else {\n            field = cCache.get(type);\n        }\n        if (field == null) {\n            field = new UnsupportedDurationField(type);\n            cCache.put(type, field);\n        }\n        return field;\n    }",
    "comment": " Gets an instance of UnsupportedDurationField for a specific named field. The returned instance is cached.  @param type  the type to obtain @return the instance ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 0
  },
  {
    "name": "UnsupportedDurationField.isSupported",
    "class_name": "org.joda.time.field.UnsupportedDurationField",
    "signature": "org.joda.time.field.UnsupportedDurationField.isSupported()",
    "snippet": "    public boolean isSupported() {\n        return false;\n    }",
    "comment": " This field is not supported.  @return false always ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 0
  },
  {
    "name": "ZeroIsMaxDateTimeField.ZeroIsMaxDateTimeField",
    "class_name": "org.joda.time.field.ZeroIsMaxDateTimeField",
    "signature": "org.joda.time.field.ZeroIsMaxDateTimeField.ZeroIsMaxDateTimeField(DateTimeField,DateTimeFieldType)",
    "snippet": "    public ZeroIsMaxDateTimeField(DateTimeField field, DateTimeFieldType type) {\n        super(field, type);\n        if (field.getMinimumValue() != 0) {\n            throw new IllegalArgumentException(\"Wrapped field's minumum value must be zero\");\n        }\n    }",
    "comment": " Constructor.  @param field  the base field @param type  the field type this field will actually use @throws IllegalArgumentException if wrapped field's minimum value is not zero ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 0
  },
  {
    "name": "CachedDateTimeZone.forZone",
    "class_name": "org.joda.time.tz.CachedDateTimeZone",
    "signature": "org.joda.time.tz.CachedDateTimeZone.forZone(DateTimeZone)",
    "snippet": "    public static CachedDateTimeZone forZone(DateTimeZone zone) {\n        if (zone instanceof CachedDateTimeZone) {\n            return (CachedDateTimeZone)zone;\n        }\n        return new CachedDateTimeZone(zone);\n    }",
    "comment": " Returns a new CachedDateTimeZone unless given zone is already cached. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 0
  },
  {
    "name": "DateTimeZoneBuilder.DateTimeZoneBuilder",
    "class_name": "org.joda.time.tz.DateTimeZoneBuilder",
    "signature": "org.joda.time.tz.DateTimeZoneBuilder.DateTimeZoneBuilder()",
    "snippet": "    public DateTimeZoneBuilder() {\n        iRuleSets = new ArrayList<RuleSet>(10);\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 0
  },
  {
    "name": "DateTimeZoneBuilder.addCutover",
    "class_name": "org.joda.time.tz.DateTimeZoneBuilder",
    "signature": "org.joda.time.tz.DateTimeZoneBuilder.addCutover(int,char,int,int,int,boolean,int)",
    "snippet": "    public DateTimeZoneBuilder addCutover(int year,\n                                          char mode,\n                                          int monthOfYear,\n                                          int dayOfMonth,\n                                          int dayOfWeek,\n                                          boolean advanceDayOfWeek,\n                                          int millisOfDay)\n    {\n        if (iRuleSets.size() > 0) {\n            OfYear ofYear = new OfYear\n                (mode, monthOfYear, dayOfMonth, dayOfWeek, advanceDayOfWeek, millisOfDay);\n            RuleSet lastRuleSet = iRuleSets.get(iRuleSets.size() - 1);\n            lastRuleSet.setUpperLimit(year, ofYear);\n        }\n        iRuleSets.add(new RuleSet());\n        return this;\n    }",
    "comment": " Adds a cutover for added rules. The standard offset at the cutover defaults to 0. Call setStandardOffset afterwards to change it.  @param year  the year of cutover @param mode 'u' - cutover is measured against UTC, 'w' - against wall offset, 's' - against standard offset @param monthOfYear  the month from 1 (January) to 12 (December) @param dayOfMonth  if negative, set to ((last day of month) - ~dayOfMonth). For example, if -1, set to last day of month @param dayOfWeek  from 1 (Monday) to 7 (Sunday), if 0 then ignore @param advanceDayOfWeek  if dayOfMonth does not fall on dayOfWeek, advance to dayOfWeek when true, retreat when false. @param millisOfDay  additional precision for specifying time of day of cutover ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 0
  },
  {
    "name": "DateTimeZoneBuilder.addRecurringSavings",
    "class_name": "org.joda.time.tz.DateTimeZoneBuilder",
    "signature": "org.joda.time.tz.DateTimeZoneBuilder.addRecurringSavings(String,int,int,int,char,int,int,int,boolean,int)",
    "snippet": "    public DateTimeZoneBuilder addRecurringSavings(String nameKey, int saveMillis,\n                                                   int fromYear, int toYear,\n                                                   char mode,\n                                                   int monthOfYear,\n                                                   int dayOfMonth,\n                                                   int dayOfWeek,\n                                                   boolean advanceDayOfWeek,\n                                                   int millisOfDay)\n    {\n        if (fromYear <= toYear) {\n            OfYear ofYear = new OfYear\n                (mode, monthOfYear, dayOfMonth, dayOfWeek, advanceDayOfWeek, millisOfDay);\n            Recurrence recurrence = new Recurrence(ofYear, nameKey, saveMillis);\n            Rule rule = new Rule(recurrence, fromYear, toYear);\n            getLastRuleSet().addRule(rule);\n        }\n        return this;\n    }",
    "comment": " Add a recurring daylight saving time rule.  @param nameKey  the name key of new rule @param saveMillis  the milliseconds to add to standard offset @param fromYear  the first year that rule is in effect, MIN_VALUE indicates beginning of time @param toYear  the last year (inclusive) that rule is in effect, MAX_VALUE indicates end of time @param mode  'u' - transitions are calculated against UTC, 'w' - transitions are calculated against wall offset, 's' - transitions are calculated against standard offset @param monthOfYear  the month from 1 (January) to 12 (December) @param dayOfMonth  if negative, set to ((last day of month) - ~dayOfMonth). For example, if -1, set to last day of month @param dayOfWeek  from 1 (Monday) to 7 (Sunday), if 0 then ignore @param advanceDayOfWeek  if dayOfMonth does not fall on dayOfWeek, advance to dayOfWeek when true, retreat when false. @param millisOfDay  additional precision for specifying time of day of transitions ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 0
  },
  {
    "name": "DateTimeZoneBuilder.addTransition",
    "class_name": "org.joda.time.tz.DateTimeZoneBuilder",
    "signature": "org.joda.time.tz.DateTimeZoneBuilder.addTransition(ArrayList,Transition)",
    "snippet": "    private boolean addTransition(ArrayList<Transition> transitions, Transition tr) {\n        int size = transitions.size();\n        if (size == 0) {\n            transitions.add(tr);\n            return true;\n        }\n\n        Transition last = transitions.get(size - 1);\n        if (!tr.isTransitionFrom(last)) {\n            return false;\n        }\n\n        // If local time of new transition is same as last local time, just\n        // replace last transition with new one.\n        int offsetForLast = 0;\n        if (size >= 2) {\n            offsetForLast = transitions.get(size - 2).getWallOffset();\n        }\n        int offsetForNew = last.getWallOffset();\n\n        long lastLocal = last.getMillis() + offsetForLast;\n        long newLocal = tr.getMillis() + offsetForNew;\n\n        if (newLocal != lastLocal) {\n            transitions.add(tr);\n            return true;\n        }\n\n        transitions.remove(size - 1);\n        return addTransition(transitions, tr);\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 0
  },
  {
    "name": "DateTimeZoneBuilder.getLastRuleSet",
    "class_name": "org.joda.time.tz.DateTimeZoneBuilder",
    "signature": "org.joda.time.tz.DateTimeZoneBuilder.getLastRuleSet()",
    "snippet": "    private RuleSet getLastRuleSet() {\n        if (iRuleSets.size() == 0) {\n            addCutover(Integer.MIN_VALUE, 'w', 1, 1, 0, false, 0);\n        }\n        return iRuleSets.get(iRuleSets.size() - 1);\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 0
  },
  {
    "name": "DateTimeZoneBuilder.readFrom",
    "class_name": "org.joda.time.tz.DateTimeZoneBuilder",
    "signature": "org.joda.time.tz.DateTimeZoneBuilder.readFrom(DataInput,String)",
    "snippet": "    public static DateTimeZone readFrom(DataInput in, String id) throws IOException {\n        switch (in.readUnsignedByte()) {\n        case 'F':\n            DateTimeZone fixed = new FixedDateTimeZone\n                (id, in.readUTF(), (int)readMillis(in), (int)readMillis(in));\n            if (fixed.equals(DateTimeZone.UTC)) {\n                fixed = DateTimeZone.UTC;\n            }\n            return fixed;\n        case 'C':\n            return CachedDateTimeZone.forZone(PrecalculatedZone.readFrom(in, id));\n        case 'P':\n            return PrecalculatedZone.readFrom(in, id);\n        default:\n            throw new IOException(\"Invalid encoding\");\n        }\n    }",
    "comment": " Decodes a built DateTimeZone from the given stream, as encoded by writeTo.  @param in input stream to read encoded DateTimeZone from. @param id time zone id to assign ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 0
  },
  {
    "name": "DateTimeZoneBuilder.readFrom",
    "class_name": "org.joda.time.tz.DateTimeZoneBuilder",
    "signature": "org.joda.time.tz.DateTimeZoneBuilder.readFrom(InputStream,String)",
    "snippet": "    public static DateTimeZone readFrom(InputStream in, String id) throws IOException {\n        if (in instanceof DataInput) {\n            return readFrom((DataInput)in, id);\n        } else {\n            return readFrom((DataInput)new DataInputStream(in), id);\n        }\n    }",
    "comment": " Decodes a built DateTimeZone from the given stream, as encoded by writeTo.  @param in input stream to read encoded DateTimeZone from. @param id time zone id to assign ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 0
  },
  {
    "name": "DateTimeZoneBuilder.readMillis",
    "class_name": "org.joda.time.tz.DateTimeZoneBuilder",
    "signature": "org.joda.time.tz.DateTimeZoneBuilder.readMillis(DataInput)",
    "snippet": "    static long readMillis(DataInput in) throws IOException {\n        int v = in.readUnsignedByte();\n        switch (v >> 6) {\n        case 0: default:\n            // Form 00 (6 bits effective precision)\n            v = (v << (32 - 6)) >> (32 - 6);\n            return v * (30 * 60000L);\n\n        case 1:\n            // Form 01 (30 bits effective precision)\n            v = (v << (32 - 6)) >> (32 - 30);\n            v |= (in.readUnsignedByte()) << 16;\n            v |= (in.readUnsignedByte()) << 8;\n            v |= (in.readUnsignedByte());\n            return v * 60000L;\n\n        case 2:\n            // Form 10 (38 bits effective precision)\n            long w = (((long)v) << (64 - 6)) >> (64 - 38);\n            w |= (in.readUnsignedByte()) << 24;\n            w |= (in.readUnsignedByte()) << 16;\n            w |= (in.readUnsignedByte()) << 8;\n            w |= (in.readUnsignedByte());\n            return w * 1000L;\n\n        case 3:\n            // Form 11 (64 bits effective precision)\n            return in.readLong();\n        }\n    }",
    "comment": " Reads encoding generated by writeMillis. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 0
  },
  {
    "name": "DateTimeZoneBuilder.setStandardOffset",
    "class_name": "org.joda.time.tz.DateTimeZoneBuilder",
    "signature": "org.joda.time.tz.DateTimeZoneBuilder.setStandardOffset(int)",
    "snippet": "    public DateTimeZoneBuilder setStandardOffset(int standardOffset) {\n        getLastRuleSet().setStandardOffset(standardOffset);\n        return this;\n    }",
    "comment": " Sets the standard offset to use for newly added rules until the next cutover is added. @param standardOffset  the standard offset in millis ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 0
  },
  {
    "name": "DateTimeZoneBuilder.toDateTimeZone",
    "class_name": "org.joda.time.tz.DateTimeZoneBuilder",
    "signature": "org.joda.time.tz.DateTimeZoneBuilder.toDateTimeZone(String,boolean)",
    "snippet": "    public DateTimeZone toDateTimeZone(String id, boolean outputID) {\n        if (id == null) {\n            throw new IllegalArgumentException();\n        }\n\n        // Discover where all the transitions occur and store the results in\n        // these lists.\n        ArrayList<Transition> transitions = new ArrayList<Transition>();\n\n        // Tail zone picks up remaining transitions in the form of an endless\n        // DST cycle.\n        DSTZone tailZone = null;\n\n        long millis = Long.MIN_VALUE;\n        int saveMillis = 0;\n            \n        int ruleSetCount = iRuleSets.size();\n        for (int i=0; i<ruleSetCount; i++) {\n            RuleSet rs = iRuleSets.get(i);\n            Transition next = rs.firstTransition(millis);\n            if (next == null) {\n                continue;\n            }\n            addTransition(transitions, next);\n            millis = next.getMillis();\n            saveMillis = next.getSaveMillis();\n\n            // Copy it since we're going to destroy it.\n            rs = new RuleSet(rs);\n\n            while ((next = rs.nextTransition(millis, saveMillis)) != null) {\n                if (addTransition(transitions, next)) {\n                    if (tailZone != null) {\n                        // Got the extra transition before DSTZone.\n                        break;\n                    }\n                }\n                millis = next.getMillis();\n                saveMillis = next.getSaveMillis();\n                if (tailZone == null && i == ruleSetCount - 1) {\n                    tailZone = rs.buildTailZone(id);\n                    // If tailZone is not null, don't break out of main loop until\n                    // at least one more transition is calculated. This ensures a\n                    // correct 'seam' to the DSTZone.\n                }\n            }\n\n            millis = rs.getUpperLimit(saveMillis);\n        }\n\n        // Check if a simpler zone implementation can be returned.\n        if (transitions.size() == 0) {\n            if (tailZone != null) {\n                // This shouldn't happen, but handle just in case.\n                return tailZone;\n            }\n            return buildFixedZone(id, \"UTC\", 0, 0);\n        }\n        if (transitions.size() == 1 && tailZone == null) {\n            Transition tr = transitions.get(0);\n            return buildFixedZone(id, tr.getNameKey(),\n                                  tr.getWallOffset(), tr.getStandardOffset());\n        }\n\n        PrecalculatedZone zone = PrecalculatedZone.create(id, outputID, transitions, tailZone);\n        if (zone.isCachable()) {\n            return CachedDateTimeZone.forZone(zone);\n        }\n        return zone;\n    }",
    "comment": " Processes all the rules and builds a DateTimeZone.  @param id  time zone id to assign @param outputID  true if the zone id should be output ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 0
  },
  {
    "name": "DSTZone.readFrom",
    "class_name": "org.joda.time.tz.DateTimeZoneBuilder$DSTZone",
    "signature": "org.joda.time.tz.DateTimeZoneBuilder$DSTZone.readFrom(DataInput,String)",
    "snippet": "        static DSTZone readFrom(DataInput in, String id) throws IOException {\n            return new DSTZone(id, (int)readMillis(in), \n                               Recurrence.readFrom(in), Recurrence.readFrom(in));\n        }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 0
  },
  {
    "name": "OfYear.next",
    "class_name": "org.joda.time.tz.DateTimeZoneBuilder$OfYear",
    "signature": "org.joda.time.tz.DateTimeZoneBuilder$OfYear.next(long,int,int)",
    "snippet": "        public long next(long instant, int standardOffset, int saveMillis) {\n            int offset;\n            if (iMode == 'w') {\n                offset = standardOffset + saveMillis;\n            } else if (iMode == 's') {\n                offset = standardOffset;\n            } else {\n                offset = 0;\n            }\n\n            // Convert from UTC to local time.\n            instant += offset;\n\n            Chronology chrono = ISOChronology.getInstanceUTC();\n            long next = chrono.monthOfYear().set(instant, iMonthOfYear);\n            // Be lenient with millisOfDay.\n            next = chrono.millisOfDay().set(next, 0);\n            next = chrono.millisOfDay().add(next, iMillisOfDay);\n            next = setDayOfMonthNext(chrono, next);\n\n            if (iDayOfWeek == 0) {\n                if (next <= instant) {\n                    next = chrono.year().add(next, 1);\n                    next = setDayOfMonthNext(chrono, next);\n                }\n            } else {\n                next = setDayOfWeek(chrono, next);\n                if (next <= instant) {\n                    next = chrono.year().add(next, 1);\n                    next = chrono.monthOfYear().set(next, iMonthOfYear);\n                    next = setDayOfMonthNext(chrono, next);\n                    next = setDayOfWeek(chrono, next);\n                }\n            }\n\n            // Convert from local time to UTC.\n            return next - offset;\n        }",
    "comment": " @param standardOffset standard offset just before next recurrence ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 0
  },
  {
    "name": "OfYear.readFrom",
    "class_name": "org.joda.time.tz.DateTimeZoneBuilder$OfYear",
    "signature": "org.joda.time.tz.DateTimeZoneBuilder$OfYear.readFrom(DataInput)",
    "snippet": "        static OfYear readFrom(DataInput in) throws IOException {\n            return new OfYear((char)in.readUnsignedByte(),\n                              (int)in.readUnsignedByte(),\n                              (int)in.readByte(),\n                              (int)in.readUnsignedByte(),\n                              in.readBoolean(),\n                              (int)readMillis(in));\n        }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 0
  },
  {
    "name": "OfYear.setDayOfMonth",
    "class_name": "org.joda.time.tz.DateTimeZoneBuilder$OfYear",
    "signature": "org.joda.time.tz.DateTimeZoneBuilder$OfYear.setDayOfMonth(Chronology,long)",
    "snippet": "        private long setDayOfMonth(Chronology chrono, long instant) {\n            if (iDayOfMonth >= 0) {\n                instant = chrono.dayOfMonth().set(instant, iDayOfMonth);\n            } else {\n                instant = chrono.dayOfMonth().set(instant, 1);\n                instant = chrono.monthOfYear().add(instant, 1);\n                instant = chrono.dayOfMonth().add(instant, iDayOfMonth);\n            }\n            return instant;\n        }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 0
  },
  {
    "name": "OfYear.setDayOfMonthNext",
    "class_name": "org.joda.time.tz.DateTimeZoneBuilder$OfYear",
    "signature": "org.joda.time.tz.DateTimeZoneBuilder$OfYear.setDayOfMonthNext(Chronology,long)",
    "snippet": "        private long setDayOfMonthNext(Chronology chrono, long next) {\n            try {\n                next = setDayOfMonth(chrono, next);\n            } catch (IllegalArgumentException e) {\n                if (iMonthOfYear == 2 && iDayOfMonth == 29) {\n                    while (chrono.year().isLeap(next) == false) {\n                        next = chrono.year().add(next, 1);\n                    }\n                    next = setDayOfMonth(chrono, next);\n                } else {\n                    throw e;\n                }\n            }\n            return next;\n        }",
    "comment": " If month-day is 02-29 and year isn't leap, advances to next leap year. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 0
  },
  {
    "name": "OfYear.setDayOfWeek",
    "class_name": "org.joda.time.tz.DateTimeZoneBuilder$OfYear",
    "signature": "org.joda.time.tz.DateTimeZoneBuilder$OfYear.setDayOfWeek(Chronology,long)",
    "snippet": "        private long setDayOfWeek(Chronology chrono, long instant) {\n            int dayOfWeek = chrono.dayOfWeek().get(instant);\n            int daysToAdd = iDayOfWeek - dayOfWeek;\n            if (daysToAdd != 0) {\n                if (iAdvance) {\n                    if (daysToAdd < 0) {\n                        daysToAdd += 7;\n                    }\n                } else {\n                    if (daysToAdd > 0) {\n                        daysToAdd -= 7;\n                    }\n                }\n                instant = chrono.dayOfWeek().add(instant, daysToAdd);\n            }\n            return instant;\n        }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 0
  },
  {
    "name": "PrecalculatedZone.create",
    "class_name": "org.joda.time.tz.DateTimeZoneBuilder$PrecalculatedZone",
    "signature": "org.joda.time.tz.DateTimeZoneBuilder$PrecalculatedZone.create(String,boolean,ArrayList,DSTZone)",
    "snippet": "        static PrecalculatedZone create(String id, boolean outputID, ArrayList<Transition> transitions,\n                                        DSTZone tailZone) {\n            int size = transitions.size();\n            if (size == 0) {\n                throw new IllegalArgumentException();\n            }\n\n            long[] trans = new long[size];\n            int[] wallOffsets = new int[size];\n            int[] standardOffsets = new int[size];\n            String[] nameKeys = new String[size];\n\n            Transition last = null;\n            for (int i=0; i<size; i++) {\n                Transition tr = transitions.get(i);\n\n                if (!tr.isTransitionFrom(last)) {\n                    throw new IllegalArgumentException(id);\n                }\n\n                trans[i] = tr.getMillis();\n                wallOffsets[i] = tr.getWallOffset();\n                standardOffsets[i] = tr.getStandardOffset();\n                nameKeys[i] = tr.getNameKey();\n\n                last = tr;\n            }\n\n            // Some timezones (Australia) have the same name key for\n            // summer and winter which messes everything up. Fix it here.\n            String[] zoneNameData = new String[5];\n            String[][] zoneStrings = new DateFormatSymbols(Locale.ENGLISH).getZoneStrings();\n            for (int j = 0; j < zoneStrings.length; j++) {\n                String[] set = zoneStrings[j];\n                if (set != null && set.length == 5 && id.equals(set[0])) {\n                    zoneNameData = set;\n                }\n            }\n\n            Chronology chrono = ISOChronology.getInstanceUTC();\n\n            for (int i = 0; i < nameKeys.length - 1; i++) {\n                String curNameKey = nameKeys[i];\n                String nextNameKey = nameKeys[i + 1];\n                long curOffset = wallOffsets[i];\n                long nextOffset = wallOffsets[i + 1];\n                long curStdOffset = standardOffsets[i];\n                long nextStdOffset = standardOffsets[i + 1];\n                Period p = new Period(trans[i], trans[i + 1], PeriodType.yearMonthDay(), chrono);\n                if (curOffset != nextOffset &&\n                        curStdOffset == nextStdOffset &&\n                        curNameKey.equals(nextNameKey) &&\n                        p.getYears() == 0 && p.getMonths() > 4 && p.getMonths() < 8 &&\n                        curNameKey.equals(zoneNameData[2]) &&\n                        curNameKey.equals(zoneNameData[4])) {\n                    \n                    if (ZoneInfoCompiler.verbose()) {\n                        System.out.println(\"Fixing duplicate name key - \" + nextNameKey);\n                        System.out.println(\"     - \" + new DateTime(trans[i], chrono) +\n                                           \" - \" + new DateTime(trans[i + 1], chrono));\n                    }\n                    if (curOffset > nextOffset) {\n                        nameKeys[i] = (curNameKey + \"-Summer\").intern();\n                    } else if (curOffset < nextOffset) {\n                        nameKeys[i + 1] = (nextNameKey + \"-Summer\").intern();\n                        i++;\n                    }\n                }\n            }\n\n            if (tailZone != null) {\n                if (tailZone.iStartRecurrence.getNameKey()\n                    .equals(tailZone.iEndRecurrence.getNameKey())) {\n                    if (ZoneInfoCompiler.verbose()) {\n                        System.out.println(\"Fixing duplicate recurrent name key - \" +\n                                           tailZone.iStartRecurrence.getNameKey());\n                    }\n                    if (tailZone.iStartRecurrence.getSaveMillis() > 0) {\n                        tailZone = new DSTZone(\n                            tailZone.getID(),\n                            tailZone.iStandardOffset,\n                            tailZone.iStartRecurrence.renameAppend(\"-Summer\"),\n                            tailZone.iEndRecurrence);\n                    } else {\n                        tailZone = new DSTZone(\n                            tailZone.getID(),\n                            tailZone.iStandardOffset,\n                            tailZone.iStartRecurrence,\n                            tailZone.iEndRecurrence.renameAppend(\"-Summer\"));\n                    }\n                }\n            }\n            \n            return new PrecalculatedZone\n                ((outputID ? id : \"\"), trans, wallOffsets, standardOffsets, nameKeys, tailZone);\n        }",
    "comment": " Factory to create instance from builder.  @param id  the zone id @param outputID  true if the zone id should be output @param transitions  the list of Transition objects @param tailZone  optional zone for getting info beyond precalculated tables ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 0
  },
  {
    "name": "PrecalculatedZone.isCachable",
    "class_name": "org.joda.time.tz.DateTimeZoneBuilder$PrecalculatedZone",
    "signature": "org.joda.time.tz.DateTimeZoneBuilder$PrecalculatedZone.isCachable()",
    "snippet": "        public boolean isCachable() {\n            if (iTailZone != null) {\n                return true;\n            }\n            long[] transitions = iTransitions;\n            if (transitions.length <= 1) {\n                return false;\n            }\n\n            // Add up all the distances between transitions that are less than\n            // about two years.\n            double distances = 0;\n            int count = 0;\n\n            for (int i=1; i<transitions.length; i++) {\n                long diff = transitions[i] - transitions[i - 1];\n                if (diff < ((366L + 365) * 24 * 60 * 60 * 1000)) {\n                    distances += (double)diff;\n                    count++;\n                }\n            }\n\n            if (count > 0) {\n                double avg = distances / count;\n                avg /= 24 * 60 * 60 * 1000;\n                if (avg >= 25) {\n                    // Only bother caching if average distance between\n                    // transitions is at least 25 days. Why 25?\n                    // CachedDateTimeZone is more efficient if the distance\n                    // between transitions is large. With an average of 25, it\n                    // will on average perform about 2 tests per cache\n                    // hit. (49.7 / 25) is approximately 2.\n                    return true;\n                }\n            }\n\n            return false;\n        }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 0
  },
  {
    "name": "PrecalculatedZone.readFrom",
    "class_name": "org.joda.time.tz.DateTimeZoneBuilder$PrecalculatedZone",
    "signature": "org.joda.time.tz.DateTimeZoneBuilder$PrecalculatedZone.readFrom(DataInput,String)",
    "snippet": "        static PrecalculatedZone readFrom(DataInput in, String id) throws IOException {\n            // Read string pool.\n            int poolSize = in.readUnsignedShort();\n            String[] pool = new String[poolSize];\n            for (int i=0; i<poolSize; i++) {\n                pool[i] = in.readUTF();\n            }\n\n            int size = in.readInt();\n            long[] transitions = new long[size];\n            int[] wallOffsets = new int[size];\n            int[] standardOffsets = new int[size];\n            String[] nameKeys = new String[size];\n            \n            for (int i=0; i<size; i++) {\n                transitions[i] = readMillis(in);\n                wallOffsets[i] = (int)readMillis(in);\n                standardOffsets[i] = (int)readMillis(in);\n                try {\n                    int index;\n                    if (poolSize < 256) {\n                        index = in.readUnsignedByte();\n                    } else {\n                        index = in.readUnsignedShort();\n                    }\n                    nameKeys[i] = pool[index];\n                } catch (ArrayIndexOutOfBoundsException e) {\n                    throw new IOException(\"Invalid encoding\");\n                }\n            }\n\n            DSTZone tailZone = null;\n            if (in.readBoolean()) {\n                tailZone = DSTZone.readFrom(in, id);\n            }\n\n            return new PrecalculatedZone\n                (id, transitions, wallOffsets, standardOffsets, nameKeys, tailZone);\n        }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 0
  },
  {
    "name": "Recurrence.getNameKey",
    "class_name": "org.joda.time.tz.DateTimeZoneBuilder$Recurrence",
    "signature": "org.joda.time.tz.DateTimeZoneBuilder$Recurrence.getNameKey()",
    "snippet": "        public String getNameKey() {\n            return iNameKey;\n        }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 0
  },
  {
    "name": "Recurrence.getSaveMillis",
    "class_name": "org.joda.time.tz.DateTimeZoneBuilder$Recurrence",
    "signature": "org.joda.time.tz.DateTimeZoneBuilder$Recurrence.getSaveMillis()",
    "snippet": "        public int getSaveMillis() {\n            return iSaveMillis;\n        }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 0
  },
  {
    "name": "Recurrence.next",
    "class_name": "org.joda.time.tz.DateTimeZoneBuilder$Recurrence",
    "signature": "org.joda.time.tz.DateTimeZoneBuilder$Recurrence.next(long,int,int)",
    "snippet": "        public long next(long instant, int standardOffset, int saveMillis) {\n            return iOfYear.next(instant, standardOffset, saveMillis);\n        }",
    "comment": " @param standardOffset standard offset just before next recurrence ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 0
  },
  {
    "name": "Recurrence.readFrom",
    "class_name": "org.joda.time.tz.DateTimeZoneBuilder$Recurrence",
    "signature": "org.joda.time.tz.DateTimeZoneBuilder$Recurrence.readFrom(DataInput)",
    "snippet": "        static Recurrence readFrom(DataInput in) throws IOException {\n            return new Recurrence(OfYear.readFrom(in), in.readUTF(), (int)readMillis(in));\n        }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 0
  },
  {
    "name": "Recurrence.rename",
    "class_name": "org.joda.time.tz.DateTimeZoneBuilder$Recurrence",
    "signature": "org.joda.time.tz.DateTimeZoneBuilder$Recurrence.rename(String)",
    "snippet": "        Recurrence rename(String nameKey) {\n            return new Recurrence(iOfYear, nameKey, iSaveMillis);\n        }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 0
  },
  {
    "name": "Recurrence.renameAppend",
    "class_name": "org.joda.time.tz.DateTimeZoneBuilder$Recurrence",
    "signature": "org.joda.time.tz.DateTimeZoneBuilder$Recurrence.renameAppend(String)",
    "snippet": "        Recurrence renameAppend(String appendNameKey) {\n            return rename((iNameKey + appendNameKey).intern());\n        }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 0
  },
  {
    "name": "Rule.getNameKey",
    "class_name": "org.joda.time.tz.DateTimeZoneBuilder$Rule",
    "signature": "org.joda.time.tz.DateTimeZoneBuilder$Rule.getNameKey()",
    "snippet": "        public String getNameKey() {\n            return iRecurrence.getNameKey();\n        }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 0
  },
  {
    "name": "Rule.getSaveMillis",
    "class_name": "org.joda.time.tz.DateTimeZoneBuilder$Rule",
    "signature": "org.joda.time.tz.DateTimeZoneBuilder$Rule.getSaveMillis()",
    "snippet": "        public int getSaveMillis() {\n            return iRecurrence.getSaveMillis();\n        }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 0
  },
  {
    "name": "Rule.getToYear",
    "class_name": "org.joda.time.tz.DateTimeZoneBuilder$Rule",
    "signature": "org.joda.time.tz.DateTimeZoneBuilder$Rule.getToYear()",
    "snippet": "        public int getToYear() {\n            return iToYear;\n        }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 0
  },
  {
    "name": "Rule.next",
    "class_name": "org.joda.time.tz.DateTimeZoneBuilder$Rule",
    "signature": "org.joda.time.tz.DateTimeZoneBuilder$Rule.next(long,int,int)",
    "snippet": "        public long next(final long instant, int standardOffset, int saveMillis) {\n            Chronology chrono = ISOChronology.getInstanceUTC();\n\n            final int wallOffset = standardOffset + saveMillis;\n            long testInstant = instant;\n\n            int year;\n            if (instant == Long.MIN_VALUE) {\n                year = Integer.MIN_VALUE;\n            } else {\n                year = chrono.year().get(instant + wallOffset);\n            }\n\n            if (year < iFromYear) {\n                // First advance instant to start of from year.\n                testInstant = chrono.year().set(0, iFromYear) - wallOffset;\n                // Back off one millisecond to account for next recurrence\n                // being exactly at the beginning of the year.\n                testInstant -= 1;\n            }\n\n            long next = iRecurrence.next(testInstant, standardOffset, saveMillis);\n\n            if (next > instant) {\n                year = chrono.year().get(next + wallOffset);\n                if (year > iToYear) {\n                    // Out of range, return original value.\n                    next = instant;\n                }\n            }\n\n            return next;\n        }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 0
  },
  {
    "name": "RuleSet.addRule",
    "class_name": "org.joda.time.tz.DateTimeZoneBuilder$RuleSet",
    "signature": "org.joda.time.tz.DateTimeZoneBuilder$RuleSet.addRule(Rule)",
    "snippet": "        public void addRule(Rule rule) {\n            if (!iRules.contains(rule)) {\n                iRules.add(rule);\n            }\n        }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 0
  },
  {
    "name": "RuleSet.buildTailZone",
    "class_name": "org.joda.time.tz.DateTimeZoneBuilder$RuleSet",
    "signature": "org.joda.time.tz.DateTimeZoneBuilder$RuleSet.buildTailZone(String)",
    "snippet": "        public DSTZone buildTailZone(String id) {\n            if (iRules.size() == 2) {\n                Rule startRule = iRules.get(0);\n                Rule endRule = iRules.get(1);\n                if (startRule.getToYear() == Integer.MAX_VALUE &&\n                    endRule.getToYear() == Integer.MAX_VALUE) {\n\n                    // With exactly two infinitely recurring rules left, a\n                    // simple DSTZone can be formed.\n\n                    // The order of rules can come in any order, and it doesn't\n                    // really matter which rule was chosen the 'start' and\n                    // which is chosen the 'end'. DSTZone works properly either\n                    // way.\n                    return new DSTZone(id, iStandardOffset,\n                                       startRule.iRecurrence, endRule.iRecurrence);\n                }\n            }\n            return null;\n        }",
    "comment": " Returns null if none can be built. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 0
  },
  {
    "name": "RuleSet.firstTransition",
    "class_name": "org.joda.time.tz.DateTimeZoneBuilder$RuleSet",
    "signature": "org.joda.time.tz.DateTimeZoneBuilder$RuleSet.firstTransition(long)",
    "snippet": "        public Transition firstTransition(final long firstMillis) {\n            if (iInitialNameKey != null) {\n                // Initial zone info explicitly set, so don't search the rules.\n                return new Transition(firstMillis, iInitialNameKey,\n                                      iStandardOffset + iInitialSaveMillis, iStandardOffset);\n            }\n\n            // Make a copy before we destroy the rules.\n            ArrayList<Rule> copy = new ArrayList<Rule>(iRules);\n\n            // Iterate through all the transitions until firstMillis is\n            // reached. Use the name key and savings for whatever rule reaches\n            // the limit.\n\n            long millis = Long.MIN_VALUE;\n            int saveMillis = 0;\n            Transition first = null;\n\n            Transition next;\n            while ((next = nextTransition(millis, saveMillis)) != null) {\n                millis = next.getMillis();\n\n                if (millis == firstMillis) {\n                    first = new Transition(firstMillis, next);\n                    break;\n                }\n\n                if (millis > firstMillis) {\n                    if (first == null) {\n                        // Find first rule without savings. This way a more\n                        // accurate nameKey is found even though no rule\n                        // extends to the RuleSet's lower limit.\n                        for (Rule rule : copy) {\n                            if (rule.getSaveMillis() == 0) {\n                                first = new Transition(firstMillis, rule, iStandardOffset);\n                                break;\n                            }\n                        }\n                    }\n                    if (first == null) {\n                        // Found no rule without savings. Create a transition\n                        // with no savings anyhow, and use the best available\n                        // name key.\n                        first = new Transition(firstMillis, next.getNameKey(),\n                                               iStandardOffset, iStandardOffset);\n                    }\n                    break;\n                }\n                \n                // Set first to the best transition found so far, but next\n                // iteration may find something closer to lower limit.\n                first = new Transition(firstMillis, next);\n\n                saveMillis = next.getSaveMillis();\n            }\n\n            iRules = copy;\n            return first;\n        }",
    "comment": " Returns a transition at firstMillis with the first name key and offsets for this rule set. This method may return null.  @param firstMillis millis of first transition ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 0
  },
  {
    "name": "RuleSet.getUpperLimit",
    "class_name": "org.joda.time.tz.DateTimeZoneBuilder$RuleSet",
    "signature": "org.joda.time.tz.DateTimeZoneBuilder$RuleSet.getUpperLimit(int)",
    "snippet": "        public long getUpperLimit(int saveMillis) {\n            if (iUpperYear == Integer.MAX_VALUE) {\n                return Long.MAX_VALUE;\n            }\n            return iUpperOfYear.setInstant(iUpperYear, iStandardOffset, saveMillis);\n        }",
    "comment": " @param saveMillis savings before upper limit ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 0
  },
  {
    "name": "RuleSet.nextTransition",
    "class_name": "org.joda.time.tz.DateTimeZoneBuilder$RuleSet",
    "signature": "org.joda.time.tz.DateTimeZoneBuilder$RuleSet.nextTransition(long,int)",
    "snippet": "        public Transition nextTransition(final long instant, final int saveMillis) {\n            Chronology chrono = ISOChronology.getInstanceUTC();\n\n            // Find next matching rule.\n            Rule nextRule = null;\n            long nextMillis = Long.MAX_VALUE;\n            \n            Iterator<Rule> it = iRules.iterator();\n            while (it.hasNext()) {\n                Rule rule = it.next();\n                long next = rule.next(instant, iStandardOffset, saveMillis);\n                if (next <= instant) {\n                    it.remove();\n                    continue;\n                }\n                // Even if next is same as previous next, choose the rule\n                // in order for more recently added rules to override.\n                if (next <= nextMillis) {\n                    // Found a better match.\n                    nextRule = rule;\n                    nextMillis = next;\n                }\n            }\n            \n            if (nextRule == null) {\n                return null;\n            }\n            \n            // Stop precalculating if year reaches some arbitrary limit.\n            if (chrono.year().get(nextMillis) >= YEAR_LIMIT) {\n                return null;\n            }\n            \n            // Check if upper limit reached or passed.\n            if (iUpperYear < Integer.MAX_VALUE) {\n                long upperMillis =\n                    iUpperOfYear.setInstant(iUpperYear, iStandardOffset, saveMillis);\n                if (nextMillis >= upperMillis) {\n                    // At or after upper limit.\n                    return null;\n                }\n            }\n            \n            return new Transition(nextMillis, nextRule, iStandardOffset);\n        }",
    "comment": " Returns null if RuleSet is exhausted or upper limit reached. Calling this method will throw away rules as they each become exhausted. Copy the RuleSet before using it to compute transitions.  Returned transition may be a duplicate from previous transition. Caller must call isTransitionFrom to filter out duplicates.  @param saveMillis savings before next transition ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 0
  },
  {
    "name": "RuleSet.setStandardOffset",
    "class_name": "org.joda.time.tz.DateTimeZoneBuilder$RuleSet",
    "signature": "org.joda.time.tz.DateTimeZoneBuilder$RuleSet.setStandardOffset(int)",
    "snippet": "        public void setStandardOffset(int standardOffset) {\n            iStandardOffset = standardOffset;\n        }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 0
  },
  {
    "name": "Transition.getMillis",
    "class_name": "org.joda.time.tz.DateTimeZoneBuilder$Transition",
    "signature": "org.joda.time.tz.DateTimeZoneBuilder$Transition.getMillis()",
    "snippet": "        public long getMillis() {\n            return iMillis;\n        }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 0
  },
  {
    "name": "Transition.getNameKey",
    "class_name": "org.joda.time.tz.DateTimeZoneBuilder$Transition",
    "signature": "org.joda.time.tz.DateTimeZoneBuilder$Transition.getNameKey()",
    "snippet": "        public String getNameKey() {\n            return iNameKey;\n        }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 0
  },
  {
    "name": "Transition.getSaveMillis",
    "class_name": "org.joda.time.tz.DateTimeZoneBuilder$Transition",
    "signature": "org.joda.time.tz.DateTimeZoneBuilder$Transition.getSaveMillis()",
    "snippet": "        public int getSaveMillis() {\n            return iWallOffset - iStandardOffset;\n        }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 0
  },
  {
    "name": "Transition.getStandardOffset",
    "class_name": "org.joda.time.tz.DateTimeZoneBuilder$Transition",
    "signature": "org.joda.time.tz.DateTimeZoneBuilder$Transition.getStandardOffset()",
    "snippet": "        public int getStandardOffset() {\n            return iStandardOffset;\n        }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 0
  },
  {
    "name": "Transition.getWallOffset",
    "class_name": "org.joda.time.tz.DateTimeZoneBuilder$Transition",
    "signature": "org.joda.time.tz.DateTimeZoneBuilder$Transition.getWallOffset()",
    "snippet": "        public int getWallOffset() {\n            return iWallOffset;\n        }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 0
  },
  {
    "name": "Transition.isTransitionFrom",
    "class_name": "org.joda.time.tz.DateTimeZoneBuilder$Transition",
    "signature": "org.joda.time.tz.DateTimeZoneBuilder$Transition.isTransitionFrom(Transition)",
    "snippet": "        public boolean isTransitionFrom(Transition other) {\n            if (other == null) {\n                return true;\n            }\n            return iMillis > other.iMillis &&\n                (iWallOffset != other.iWallOffset ||\n                 //iStandardOffset != other.iStandardOffset ||\n                 !(iNameKey.equals(other.iNameKey)));\n        }",
    "comment": " There must be a change in the millis, wall offsets or name keys. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 0
  },
  {
    "name": "DefaultNameProvider.DefaultNameProvider",
    "class_name": "org.joda.time.tz.DefaultNameProvider",
    "signature": "org.joda.time.tz.DefaultNameProvider.DefaultNameProvider()",
    "snippet": "    public DefaultNameProvider() {\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 0
  },
  {
    "name": "DefaultNameProvider.createCache",
    "class_name": "org.joda.time.tz.DefaultNameProvider",
    "signature": "org.joda.time.tz.DefaultNameProvider.createCache()",
    "snippet": "    private HashMap createCache() {\n        return new HashMap(7);\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 0
  },
  {
    "name": "FixedDateTimeZone.FixedDateTimeZone",
    "class_name": "org.joda.time.tz.FixedDateTimeZone",
    "signature": "org.joda.time.tz.FixedDateTimeZone.FixedDateTimeZone(String,String,int,int)",
    "snippet": "    public FixedDateTimeZone(String id, String nameKey,\n                             int wallOffset, int standardOffset) {\n        super(id);\n        iNameKey = nameKey;\n        iWallOffset = wallOffset;\n        iStandardOffset = standardOffset;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 0
  },
  {
    "name": "FixedDateTimeZone.equals",
    "class_name": "org.joda.time.tz.FixedDateTimeZone",
    "signature": "org.joda.time.tz.FixedDateTimeZone.equals(Object)",
    "snippet": "    public boolean equals(Object obj) {\n        if (this == obj) {\n            return true;\n        }\n        if (obj instanceof FixedDateTimeZone) {\n            FixedDateTimeZone other = (FixedDateTimeZone) obj;\n            return\n                getID().equals(other.getID()) &&\n                iStandardOffset == other.iStandardOffset &&\n                iWallOffset == other.iWallOffset;\n        }\n        return false;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 0
  },
  {
    "name": "FixedDateTimeZone.hashCode",
    "class_name": "org.joda.time.tz.FixedDateTimeZone",
    "signature": "org.joda.time.tz.FixedDateTimeZone.hashCode()",
    "snippet": "    public int hashCode() {\n        return getID().hashCode() + 37 * iStandardOffset + 31 * iWallOffset;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 0
  },
  {
    "name": "ZoneInfoCompiler.verbose",
    "class_name": "org.joda.time.tz.ZoneInfoCompiler",
    "signature": "org.joda.time.tz.ZoneInfoCompiler.verbose()",
    "snippet": "    public static boolean verbose() {\n        return cVerbose.get();\n    }",
    "comment": " Gets a flag indicating that verbose logging is required. @return true to log verbosely ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 0
  },
  {
    "name": "ZoneInfoProvider.ZoneInfoProvider",
    "class_name": "org.joda.time.tz.ZoneInfoProvider",
    "signature": "org.joda.time.tz.ZoneInfoProvider.ZoneInfoProvider(String)",
    "snippet": "    public ZoneInfoProvider(String resourcePath) throws IOException {\n        this(resourcePath, null, false);\n    }",
    "comment": " ZoneInfoProvider searches the given ClassLoader resource path for compiled data files. Resources are loaded from the ClassLoader that loaded this class.  @throws IOException if directory or map file cannot be read ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 0
  },
  {
    "name": "ZoneInfoProvider.getAvailableIDs",
    "class_name": "org.joda.time.tz.ZoneInfoProvider",
    "signature": "org.joda.time.tz.ZoneInfoProvider.getAvailableIDs()",
    "snippet": "    public Set<String> getAvailableIDs() {\n        // Return a copy of the keys rather than an umodifiable collection.\n        // This prevents ConcurrentModificationExceptions from being thrown by\n        // some JVMs if zones are opened while this set is iterated over.\n        return new TreeSet<String>(iZoneInfoMap.keySet());\n    }",
    "comment": " Gets a list of all the available zone ids.  @return the zone ids ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 0
  },
  {
    "name": "ZoneInfoProvider.getZone",
    "class_name": "org.joda.time.tz.ZoneInfoProvider",
    "signature": "org.joda.time.tz.ZoneInfoProvider.getZone(String)",
    "snippet": "    public DateTimeZone getZone(String id) {\n        if (id == null) {\n            return null;\n        }\n\n        Object obj = iZoneInfoMap.get(id);\n        if (obj == null) {\n            return null;\n        }\n\n        if (id.equals(obj)) {\n            // Load zone data for the first time.\n            return loadZoneData(id);\n        }\n\n        if (obj instanceof SoftReference<?>) {\n            @SuppressWarnings(\"unchecked\")\n            SoftReference<DateTimeZone> ref = (SoftReference<DateTimeZone>) obj;\n            DateTimeZone tz = ref.get();\n            if (tz != null) {\n                return tz;\n            }\n            // Reference cleared; load data again.\n            return loadZoneData(id);\n        }\n\n        // If this point is reached, mapping must link to another.\n        return getZone((String)obj);\n    }",
    "comment": " If an error is thrown while loading zone data, uncaughtException is called to log the error and null is returned for this and all future requests.  @param id  the id to load @return the loaded zone ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 0
  },
  {
    "name": "ZoneInfoProvider.loadZoneData",
    "class_name": "org.joda.time.tz.ZoneInfoProvider",
    "signature": "org.joda.time.tz.ZoneInfoProvider.loadZoneData(String)",
    "snippet": "    private DateTimeZone loadZoneData(String id) {\n        InputStream in = null;\n        try {\n            in = openResource(id);\n            DateTimeZone tz = DateTimeZoneBuilder.readFrom(in, id);\n            iZoneInfoMap.put(id, new SoftReference<DateTimeZone>(tz));\n            return tz;\n        } catch (IOException ex) {\n            uncaughtException(ex);\n            iZoneInfoMap.remove(id);\n            return null;\n        } finally {\n            try {\n                if (in != null) {\n                    in.close();\n                }\n            } catch (IOException ex) {\n            }\n        }\n    }",
    "comment": " Loads the time zone data for one id.  @param id  the id to load @return the zone ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 0
  },
  {
    "name": "ZoneInfoProvider.loadZoneInfoMap",
    "class_name": "org.joda.time.tz.ZoneInfoProvider",
    "signature": "org.joda.time.tz.ZoneInfoProvider.loadZoneInfoMap(InputStream)",
    "snippet": "    private static Map<String, Object> loadZoneInfoMap(InputStream in) throws IOException {\n        Map<String, Object> map = new ConcurrentHashMap<String, Object>();\n        DataInputStream din = new DataInputStream(in);\n        try {\n            readZoneInfoMap(din, map);\n        } finally {\n            try {\n                din.close();\n            } catch (IOException ex) {\n            }\n        }\n        map.put(\"UTC\", new SoftReference<DateTimeZone>(DateTimeZone.UTC));\n        return map;\n    }",
    "comment": " Loads the zone info map.  @param in  the input stream @return the map ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 0
  },
  {
    "name": "ZoneInfoProvider.openResource",
    "class_name": "org.joda.time.tz.ZoneInfoProvider",
    "signature": "org.joda.time.tz.ZoneInfoProvider.openResource(String)",
    "snippet": "    private InputStream openResource(String name) throws IOException {\n        InputStream in;\n        if (iFileDir != null) {\n            in = new FileInputStream(new File(iFileDir, name));\n        } else {\n            String path = iResourcePath.concat(name);\n            if (iLoader != null) {\n                in = iLoader.getResourceAsStream(path);\n            } else {\n                in = ClassLoader.getSystemResourceAsStream(path);\n            }\n            if (in == null) {\n                StringBuilder buf = new StringBuilder(40)\n                    .append(\"Resource not found: \\\"\")\n                    .append(path)\n                    .append(\"\\\" ClassLoader: \")\n                    .append(iLoader != null ? iLoader.toString() : \"system\");\n                throw new IOException(buf.toString());\n            }\n        }\n        return in;\n    }",
    "comment": " Opens a resource from file or classpath.  @param name  the name to open @return the input stream @throws IOException if an error occurs ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 0
  },
  {
    "name": "ZoneInfoProvider.readZoneInfoMap",
    "class_name": "org.joda.time.tz.ZoneInfoProvider",
    "signature": "org.joda.time.tz.ZoneInfoProvider.readZoneInfoMap(DataInputStream,Map)",
    "snippet": "    private static void readZoneInfoMap(DataInputStream din, Map<String, Object> zimap) throws IOException {\n        // Read the string pool.\n        int size = din.readUnsignedShort();\n        String[] pool = new String[size];\n        for (int i=0; i<size; i++) {\n            pool[i] = din.readUTF().intern();\n        }\n\n        // Read the mappings.\n        size = din.readUnsignedShort();\n        for (int i=0; i<size; i++) {\n            try {\n                zimap.put(pool[din.readUnsignedShort()], pool[din.readUnsignedShort()]);\n            } catch (ArrayIndexOutOfBoundsException ex) {\n                throw new IOException(\"Corrupt zone info map\");\n            }\n        }\n    }",
    "comment": " Reads the zone info map from file.  @param din  the input stream @param zimap  gets filled with string id to string id mappings ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 0
  }
]