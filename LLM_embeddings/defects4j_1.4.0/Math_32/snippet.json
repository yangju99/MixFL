[
  {
    "name": "Interval.Interval",
    "class_name": "org.apache.commons.math3.geometry.euclidean.oned.Interval",
    "signature": "org.apache.commons.math3.geometry.euclidean.oned.Interval.Interval(double,double)",
    "snippet": "    public Interval(final double lower, final double upper) {\n        this.lower = lower;\n        this.upper = upper;\n    }",
    "comment": "Simple constructor. @param lower lower bound of the interval @param upper upper bound of the interval ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "Interval.getLength",
    "class_name": "org.apache.commons.math3.geometry.euclidean.oned.Interval",
    "signature": "org.apache.commons.math3.geometry.euclidean.oned.Interval.getLength()",
    "snippet": "    public double getLength() {\n        return upper - lower;\n    }",
    "comment": "Get the length of the interval. @return length of the interval ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "Interval.getLower",
    "class_name": "org.apache.commons.math3.geometry.euclidean.oned.Interval",
    "signature": "org.apache.commons.math3.geometry.euclidean.oned.Interval.getLower()",
    "snippet": "    public double getLower() {\n        return lower;\n    }",
    "comment": "Get the lower bound of the interval. @return lower bound of the interval ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "Interval.getMidPoint",
    "class_name": "org.apache.commons.math3.geometry.euclidean.oned.Interval",
    "signature": "org.apache.commons.math3.geometry.euclidean.oned.Interval.getMidPoint()",
    "snippet": "    public double getMidPoint() {\n        return 0.5 * (lower + upper);\n    }",
    "comment": "Get the midpoint of the interval. @return midpoint of the interval ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "Interval.getUpper",
    "class_name": "org.apache.commons.math3.geometry.euclidean.oned.Interval",
    "signature": "org.apache.commons.math3.geometry.euclidean.oned.Interval.getUpper()",
    "snippet": "    public double getUpper() {\n        return upper;\n    }",
    "comment": "Get the upper bound of the interval. @return upper bound of the interval ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "IntervalsSet.IntervalsSet",
    "class_name": "org.apache.commons.math3.geometry.euclidean.oned.IntervalsSet",
    "signature": "org.apache.commons.math3.geometry.euclidean.oned.IntervalsSet.IntervalsSet()",
    "snippet": "    public IntervalsSet() {\n        super();\n    }",
    "comment": "Build an intervals set representing the whole real line. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "IntervalsSet.IntervalsSet",
    "class_name": "org.apache.commons.math3.geometry.euclidean.oned.IntervalsSet",
    "signature": "org.apache.commons.math3.geometry.euclidean.oned.IntervalsSet.IntervalsSet(BSPTree)",
    "snippet": "    public IntervalsSet(final BSPTree<Euclidean1D> tree) {\n        super(tree);\n    }",
    "comment": "Build an intervals set from an inside/outside BSP tree. <p>The leaf nodes of the BSP tree <em>must</em> have a {@code Boolean} attribute representing the inside status of the corresponding cell (true for inside cells, false for outside cells). In order to avoid building too many small objects, it is recommended to use the predefined constants {@code Boolean.TRUE} and {@code Boolean.FALSE}</p> @param tree inside/outside BSP tree representing the intervals set ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "IntervalsSet.IntervalsSet",
    "class_name": "org.apache.commons.math3.geometry.euclidean.oned.IntervalsSet",
    "signature": "org.apache.commons.math3.geometry.euclidean.oned.IntervalsSet.IntervalsSet(double,double)",
    "snippet": "    public IntervalsSet(final double lower, final double upper) {\n        super(buildTree(lower, upper));\n    }",
    "comment": "Build an intervals set corresponding to a single interval. @param lower lower bound of the interval, must be lesser or equal to {@code upper} (may be {@code Double.NEGATIVE_INFINITY}) @param upper upper bound of the interval, must be greater or equal to {@code lower} (may be {@code Double.POSITIVE_INFINITY}) ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "IntervalsSet.asList",
    "class_name": "org.apache.commons.math3.geometry.euclidean.oned.IntervalsSet",
    "signature": "org.apache.commons.math3.geometry.euclidean.oned.IntervalsSet.asList()",
    "snippet": "    public List<Interval> asList() {\n        final List<Interval> list = new ArrayList<Interval>();\n        recurseList(getTree(false), list,\n                    Double.NEGATIVE_INFINITY, Double.POSITIVE_INFINITY);\n        return list;\n    }",
    "comment": "Build an ordered list of intervals representing the instance. <p>This method builds this intervals set as an ordered list of {@link Interval Interval} elements. If the intervals set has no lower limit, the first interval will have its low bound equal to {@code Double.NEGATIVE_INFINITY}. If the intervals set has no upper limit, the last interval will have its upper bound equal to {@code Double.POSITIVE_INFINITY}. An empty tree will build an empty list while a tree representing the whole real line will build a one element list with both bounds beeing infinite.</p> @return a new ordered list containing {@link Interval Interval} elements ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "IntervalsSet.buildNew",
    "class_name": "org.apache.commons.math3.geometry.euclidean.oned.IntervalsSet",
    "signature": "org.apache.commons.math3.geometry.euclidean.oned.IntervalsSet.buildNew(BSPTree)",
    "snippet": "    @Override\n    public IntervalsSet buildNew(final BSPTree<Euclidean1D> tree) {\n        return new IntervalsSet(tree);\n    }",
    "comment": "{@inheritDoc} */",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "IntervalsSet.buildTree",
    "class_name": "org.apache.commons.math3.geometry.euclidean.oned.IntervalsSet",
    "signature": "org.apache.commons.math3.geometry.euclidean.oned.IntervalsSet.buildTree(double,double)",
    "snippet": "    private static BSPTree<Euclidean1D> buildTree(final double lower, final double upper) {\n        if (Double.isInfinite(lower) && (lower < 0)) {\n            if (Double.isInfinite(upper) && (upper > 0)) {\n                // the tree must cover the whole real line\n                return new BSPTree<Euclidean1D>(Boolean.TRUE);\n            }\n            // the tree must be open on the negative infinity side\n            final SubHyperplane<Euclidean1D> upperCut =\n                new OrientedPoint(new Vector1D(upper), true).wholeHyperplane();\n            return new BSPTree<Euclidean1D>(upperCut,\n                               new BSPTree<Euclidean1D>(Boolean.FALSE),\n                               new BSPTree<Euclidean1D>(Boolean.TRUE),\n                               null);\n        }\n        final SubHyperplane<Euclidean1D> lowerCut =\n            new OrientedPoint(new Vector1D(lower), false).wholeHyperplane();\n        if (Double.isInfinite(upper) && (upper > 0)) {\n            // the tree must be open on the positive infinity side\n            return new BSPTree<Euclidean1D>(lowerCut,\n                                            new BSPTree<Euclidean1D>(Boolean.FALSE),\n                                            new BSPTree<Euclidean1D>(Boolean.TRUE),\n                                            null);\n        }\n\n        // the tree must be bounded on the two sides\n        final SubHyperplane<Euclidean1D> upperCut =\n            new OrientedPoint(new Vector1D(upper), true).wholeHyperplane();\n        return new BSPTree<Euclidean1D>(lowerCut,\n                                        new BSPTree<Euclidean1D>(Boolean.FALSE),\n                                        new BSPTree<Euclidean1D>(upperCut,\n                                                                 new BSPTree<Euclidean1D>(Boolean.FALSE),\n                                                                 new BSPTree<Euclidean1D>(Boolean.TRUE),\n                                                                 null),\n                                        null);\n\n    }",
    "comment": "Build an inside/outside tree representing a single interval. @param lower lower bound of the interval, must be lesser or equal to {@code upper} (may be {@code Double.NEGATIVE_INFINITY}) @param upper upper bound of the interval, must be greater or equal to {@code lower} (may be {@code Double.POSITIVE_INFINITY}) @return the built tree ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "IntervalsSet.computeGeometricalProperties",
    "class_name": "org.apache.commons.math3.geometry.euclidean.oned.IntervalsSet",
    "signature": "org.apache.commons.math3.geometry.euclidean.oned.IntervalsSet.computeGeometricalProperties()",
    "snippet": "    @Override\n    protected void computeGeometricalProperties() {\n        if (getTree(false).getCut() == null) {\n            setBarycenter(Vector1D.NaN);\n            setSize(((Boolean) getTree(false).getAttribute()) ? Double.POSITIVE_INFINITY : 0);\n        } else {\n            double size = 0.0;\n            double sum = 0.0;\n            for (final Interval interval : asList()) {\n                size += interval.getLength();\n                sum  += interval.getLength() * interval.getMidPoint();\n            }\n            setSize(size);\n            if (Double.isInfinite(size)) {\n                setBarycenter(Vector1D.NaN);\n            } else if (size >= Precision.SAFE_MIN) {\n                setBarycenter(new Vector1D(sum / size));\n            } else {\n                setBarycenter(((OrientedPoint) getTree(false).getCut().getHyperplane()).getLocation());\n            }\n        }\n    }",
    "comment": "{@inheritDoc} */",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "IntervalsSet.recurseList",
    "class_name": "org.apache.commons.math3.geometry.euclidean.oned.IntervalsSet",
    "signature": "org.apache.commons.math3.geometry.euclidean.oned.IntervalsSet.recurseList(BSPTree,List,double,double)",
    "snippet": "    private void recurseList(final BSPTree<Euclidean1D> node,\n                             final List<Interval> list,\n                             final double lower, final double upper) {\n\n        if (node.getCut() == null) {\n            if ((Boolean) node.getAttribute()) {\n                // this leaf cell is an inside cell: an interval\n                list.add(new Interval(lower, upper));\n            }\n        } else {\n            final OrientedPoint op  = (OrientedPoint) node.getCut().getHyperplane();\n            final Vector1D       loc = op.getLocation();\n            double              x   = loc.getX();\n\n            // make sure we explore the tree in increasing order\n            final BSPTree<Euclidean1D> low  =\n                op.isDirect() ? node.getMinus() : node.getPlus();\n            final BSPTree<Euclidean1D> high =\n                op.isDirect() ? node.getPlus()  : node.getMinus();\n\n            recurseList(low, list, lower, x);\n            if ((checkPoint(low,  loc) == Location.INSIDE) &&\n                (checkPoint(high, loc) == Location.INSIDE)) {\n                // merge the last interval added and the first one of the high sub-tree\n                x = list.remove(list.size() - 1).getLower();\n            }\n            recurseList(high, list, x, upper);\n\n        }\n\n    }",
    "comment": "Update an intervals list. @param node current node @param list list to update @param lower lower bound of the current convex cell @param upper upper bound of the current convex cell ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "OrientedPoint.OrientedPoint",
    "class_name": "org.apache.commons.math3.geometry.euclidean.oned.OrientedPoint",
    "signature": "org.apache.commons.math3.geometry.euclidean.oned.OrientedPoint.OrientedPoint(Vector1D,boolean)",
    "snippet": "    public OrientedPoint(final Vector1D location, final boolean direct) {\n        this.location = location;\n        this.direct   = direct;\n    }",
    "comment": "Simple constructor. @param location location of the hyperplane @param direct if true, the plus side of the hyperplane is towards abscissas greater than {@code location} ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "OrientedPoint.getLocation",
    "class_name": "org.apache.commons.math3.geometry.euclidean.oned.OrientedPoint",
    "signature": "org.apache.commons.math3.geometry.euclidean.oned.OrientedPoint.getLocation()",
    "snippet": "    public Vector1D getLocation() {\n        return location;\n    }",
    "comment": "Get the hyperplane location on the real line. @return the hyperplane location ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "OrientedPoint.getOffset",
    "class_name": "org.apache.commons.math3.geometry.euclidean.oned.OrientedPoint",
    "signature": "org.apache.commons.math3.geometry.euclidean.oned.OrientedPoint.getOffset(Vector)",
    "snippet": "    public double getOffset(final Vector<Euclidean1D> point) {\n        final double delta = ((Vector1D) point).getX() - location.getX();\n        return direct ? delta : -delta;\n    }",
    "comment": "{@inheritDoc} */",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "OrientedPoint.isDirect",
    "class_name": "org.apache.commons.math3.geometry.euclidean.oned.OrientedPoint",
    "signature": "org.apache.commons.math3.geometry.euclidean.oned.OrientedPoint.isDirect()",
    "snippet": "    public boolean isDirect() {\n        return direct;\n    }",
    "comment": "Check if the hyperplane orientation is direct. @return true if the plus side of the hyperplane is towards abscissae greater than hyperplane location ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "OrientedPoint.sameOrientationAs",
    "class_name": "org.apache.commons.math3.geometry.euclidean.oned.OrientedPoint",
    "signature": "org.apache.commons.math3.geometry.euclidean.oned.OrientedPoint.sameOrientationAs(Hyperplane)",
    "snippet": "    public boolean sameOrientationAs(final Hyperplane<Euclidean1D> other) {\n        return !(direct ^ ((OrientedPoint) other).direct);\n    }",
    "comment": "{@inheritDoc} */",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "OrientedPoint.wholeHyperplane",
    "class_name": "org.apache.commons.math3.geometry.euclidean.oned.OrientedPoint",
    "signature": "org.apache.commons.math3.geometry.euclidean.oned.OrientedPoint.wholeHyperplane()",
    "snippet": "    public SubOrientedPoint wholeHyperplane() {\n        return new SubOrientedPoint(this, null);\n    }",
    "comment": "Build a region covering the whole hyperplane. <p>Since this class represent zero dimension spaces which does not have lower dimension sub-spaces, this method returns a dummy implementation of a {@link org.apache.commons.math3.geometry.partitioning.SubHyperplane SubHyperplane}. This implementation is only used to allow the {@link org.apache.commons.math3.geometry.partitioning.SubHyperplane SubHyperplane} class implementation to work properly, it should <em>not</em> be used otherwise.</p> @return a dummy sub hyperplane ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "SubOrientedPoint.SubOrientedPoint",
    "class_name": "org.apache.commons.math3.geometry.euclidean.oned.SubOrientedPoint",
    "signature": "org.apache.commons.math3.geometry.euclidean.oned.SubOrientedPoint.SubOrientedPoint(Hyperplane,Region)",
    "snippet": "    public SubOrientedPoint(final Hyperplane<Euclidean1D> hyperplane,\n                            final Region<Euclidean1D> remainingRegion) {\n        super(hyperplane, remainingRegion);\n    }",
    "comment": "Simple constructor. @param hyperplane underlying hyperplane @param remainingRegion remaining region of the hyperplane ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "SubOrientedPoint.buildNew",
    "class_name": "org.apache.commons.math3.geometry.euclidean.oned.SubOrientedPoint",
    "signature": "org.apache.commons.math3.geometry.euclidean.oned.SubOrientedPoint.buildNew(Hyperplane,Region)",
    "snippet": "    @Override\n    protected AbstractSubHyperplane<Euclidean1D, Euclidean1D> buildNew(final Hyperplane<Euclidean1D> hyperplane,\n                                                                       final Region<Euclidean1D> remainingRegion) {\n        return new SubOrientedPoint(hyperplane, remainingRegion);\n    }",
    "comment": "{@inheritDoc} */",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "SubOrientedPoint.side",
    "class_name": "org.apache.commons.math3.geometry.euclidean.oned.SubOrientedPoint",
    "signature": "org.apache.commons.math3.geometry.euclidean.oned.SubOrientedPoint.side(Hyperplane)",
    "snippet": "    @Override\n    public Side side(final Hyperplane<Euclidean1D> hyperplane) {\n        final double global = hyperplane.getOffset(((OrientedPoint) getHyperplane()).getLocation());\n        return (global < -1.0e-10) ? Side.MINUS : ((global > 1.0e-10) ? Side.PLUS : Side.HYPER);\n    }",
    "comment": "{@inheritDoc} */",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "SubOrientedPoint.split",
    "class_name": "org.apache.commons.math3.geometry.euclidean.oned.SubOrientedPoint",
    "signature": "org.apache.commons.math3.geometry.euclidean.oned.SubOrientedPoint.split(Hyperplane)",
    "snippet": "    @Override\n    public SplitSubHyperplane<Euclidean1D> split(final Hyperplane<Euclidean1D> hyperplane) {\n        final double global = hyperplane.getOffset(((OrientedPoint) getHyperplane()).getLocation());\n        return (global < -1.0e-10) ?\n                                    new SplitSubHyperplane<Euclidean1D>(null, this) :\n                                        new SplitSubHyperplane<Euclidean1D>(this, null);\n    }",
    "comment": "{@inheritDoc} */",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "Vector1D.Vector1D",
    "class_name": "org.apache.commons.math3.geometry.euclidean.oned.Vector1D",
    "signature": "org.apache.commons.math3.geometry.euclidean.oned.Vector1D.Vector1D(double)",
    "snippet": "    public Vector1D(double x) {\n        this.x = x;\n    }",
    "comment": "Simple constructor. Build a vector from its coordinates @param x abscissa @see #getX() ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "Vector1D.getX",
    "class_name": "org.apache.commons.math3.geometry.euclidean.oned.Vector1D",
    "signature": "org.apache.commons.math3.geometry.euclidean.oned.Vector1D.getX()",
    "snippet": "    public double getX() {\n        return x;\n    }",
    "comment": "Get the abscissa of the vector. @return abscissa of the vector @see #Vector1D(double) ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "Line.Line",
    "class_name": "org.apache.commons.math3.geometry.euclidean.threed.Line",
    "signature": "org.apache.commons.math3.geometry.euclidean.threed.Line.Line(Vector3D,Vector3D)",
    "snippet": "    public Line(final Vector3D p1, final Vector3D p2) {\n        reset(p1, p2);\n    }",
    "comment": "Build a line from two points. @param p1 first point belonging to the line (this can be any point) @param p2 second point belonging to the line (this can be any point, different from p1) @exception MathIllegalArgumentException if the points are equal ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "Line.getDirection",
    "class_name": "org.apache.commons.math3.geometry.euclidean.threed.Line",
    "signature": "org.apache.commons.math3.geometry.euclidean.threed.Line.getDirection()",
    "snippet": "    public Vector3D getDirection() {\n        return direction;\n    }",
    "comment": "Get the normalized direction vector. @return normalized direction vector ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "Line.pointAt",
    "class_name": "org.apache.commons.math3.geometry.euclidean.threed.Line",
    "signature": "org.apache.commons.math3.geometry.euclidean.threed.Line.pointAt(double)",
    "snippet": "    public Vector3D pointAt(final double abscissa) {\n        return new Vector3D(1.0, zero, abscissa, direction);\n    }",
    "comment": "Get one point from the line. @param abscissa desired abscissa for the point @return one point belonging to the line, at specified abscissa ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "Line.reset",
    "class_name": "org.apache.commons.math3.geometry.euclidean.threed.Line",
    "signature": "org.apache.commons.math3.geometry.euclidean.threed.Line.reset(Vector3D,Vector3D)",
    "snippet": "    public void reset(final Vector3D p1, final Vector3D p2) {\n        final Vector3D delta = p2.subtract(p1);\n        final double norm2 = delta.getNormSq();\n        if (norm2 == 0.0) {\n            throw new MathIllegalArgumentException(LocalizedFormats.ZERO_NORM);\n        }\n        this.direction = new Vector3D(1.0 / FastMath.sqrt(norm2), delta);\n        zero = new Vector3D(1.0, p1, -p1.dotProduct(delta) / norm2, delta);\n    }",
    "comment": "Reset the instance as if built from two points. @param p1 first point belonging to the line (this can be any point) @param p2 second point belonging to the line (this can be any point, different from p1) @exception MathIllegalArgumentException if the points are equal ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "Line.toSpace",
    "class_name": "org.apache.commons.math3.geometry.euclidean.threed.Line",
    "signature": "org.apache.commons.math3.geometry.euclidean.threed.Line.toSpace(Vector)",
    "snippet": "    public Vector3D toSpace(final Vector<Euclidean1D> point) {\n        return pointAt(((Vector1D) point).getX());\n    }",
    "comment": "{@inheritDoc} @see #pointAt(double) ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "Plane.Plane",
    "class_name": "org.apache.commons.math3.geometry.euclidean.threed.Plane",
    "signature": "org.apache.commons.math3.geometry.euclidean.threed.Plane.Plane(Plane)",
    "snippet": "    public Plane(final Plane plane) {\n        originOffset = plane.originOffset;\n        origin = plane.origin;\n        u      = plane.u;\n        v      = plane.v;\n        w      = plane.w;\n    }",
    "comment": "Copy constructor. <p>The instance created is completely independant of the original one. A deep copy is used, none of the underlying object are shared.</p> @param plane plane to copy ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "Plane.Plane",
    "class_name": "org.apache.commons.math3.geometry.euclidean.threed.Plane",
    "signature": "org.apache.commons.math3.geometry.euclidean.threed.Plane.Plane(Vector3D)",
    "snippet": "    public Plane(final Vector3D normal) {\n        setNormal(normal);\n        originOffset = 0;\n        setFrame();\n    }",
    "comment": "Build a plane normal to a given direction and containing the origin. @param normal normal direction to the plane @exception MathArithmeticException if the normal norm is too small ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "Plane.Plane",
    "class_name": "org.apache.commons.math3.geometry.euclidean.threed.Plane",
    "signature": "org.apache.commons.math3.geometry.euclidean.threed.Plane.Plane(Vector3D,Vector3D)",
    "snippet": "    public Plane(final Vector3D p, final Vector3D normal) {\n        setNormal(normal);\n        originOffset = -p.dotProduct(w);\n        setFrame();\n    }",
    "comment": "Build a plane from a point and a normal. @param p point belonging to the plane @param normal normal direction to the plane @exception MathArithmeticException if the normal norm is too small ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "Plane.Plane",
    "class_name": "org.apache.commons.math3.geometry.euclidean.threed.Plane",
    "signature": "org.apache.commons.math3.geometry.euclidean.threed.Plane.Plane(Vector3D,Vector3D,Vector3D)",
    "snippet": "    public Plane(final Vector3D p1, final Vector3D p2, final Vector3D p3) {\n        this(p1, p2.subtract(p1).crossProduct(p3.subtract(p1)));\n    }",
    "comment": "Build a plane from three points. <p>The plane is oriented in the direction of {@code (p2-p1) ^ (p3-p1)}</p> @param p1 first point belonging to the plane @param p2 second point belonging to the plane @param p3 third point belonging to the plane @exception MathArithmeticException if the points do not constitute a plane ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "Plane.copySelf",
    "class_name": "org.apache.commons.math3.geometry.euclidean.threed.Plane",
    "signature": "org.apache.commons.math3.geometry.euclidean.threed.Plane.copySelf()",
    "snippet": "    public Plane copySelf() {\n        return new Plane(this);\n    }",
    "comment": "Copy the instance. <p>The instance created is completely independant of the original one. A deep copy is used, none of the underlying objects are shared (except for immutable objects).</p> @return a new hyperplane, copy of the instance ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "Plane.getNormal",
    "class_name": "org.apache.commons.math3.geometry.euclidean.threed.Plane",
    "signature": "org.apache.commons.math3.geometry.euclidean.threed.Plane.getNormal()",
    "snippet": "    public Vector3D getNormal() {\n        return w;\n    }",
    "comment": "Get the normalized normal vector. <p>The frame defined by ({@link #getU getU}, {@link #getV getV}, {@link #getNormal getNormal}) is a rigth-handed orthonormalized frame).</p> @return normalized normal vector @see #getU @see #getV ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "Plane.getOffset",
    "class_name": "org.apache.commons.math3.geometry.euclidean.threed.Plane",
    "signature": "org.apache.commons.math3.geometry.euclidean.threed.Plane.getOffset(Plane)",
    "snippet": "    public double getOffset(final Plane plane) {\n        return originOffset + (sameOrientationAs(plane) ? -plane.originOffset : plane.originOffset);\n    }",
    "comment": "Get the offset (oriented distance) of a parallel plane. <p>This method should be called only for parallel planes otherwise the result is not meaningful.</p> <p>The offset is 0 if both planes are the same, it is positive if the plane is on the plus side of the instance and negative if it is on the minus side, according to its natural orientation.</p> @param plane plane to check @return offset of the plane ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "Plane.intersection",
    "class_name": "org.apache.commons.math3.geometry.euclidean.threed.Plane",
    "signature": "org.apache.commons.math3.geometry.euclidean.threed.Plane.intersection(Plane)",
    "snippet": "    public Line intersection(final Plane other) {\n        final Vector3D direction = Vector3D.crossProduct(w, other.w);\n        if (direction.getNorm() < 1.0e-10) {\n            return null;\n        }\n        final Vector3D point = intersection(this, other, new Plane(direction));\n        return new Line(point, point.add(direction));\n    }",
    "comment": "Build the line shared by the instance and another plane. @param other other plane @return line at the intersection of the instance and the other plane (really a {@link Line Line} instance) ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "Plane.intersection",
    "class_name": "org.apache.commons.math3.geometry.euclidean.threed.Plane",
    "signature": "org.apache.commons.math3.geometry.euclidean.threed.Plane.intersection(Plane,Plane,Plane)",
    "snippet": "    public static Vector3D intersection(final Plane plane1, final Plane plane2, final Plane plane3) {\n\n        // coefficients of the three planes linear equations\n        final double a1 = plane1.w.getX();\n        final double b1 = plane1.w.getY();\n        final double c1 = plane1.w.getZ();\n        final double d1 = plane1.originOffset;\n\n        final double a2 = plane2.w.getX();\n        final double b2 = plane2.w.getY();\n        final double c2 = plane2.w.getZ();\n        final double d2 = plane2.originOffset;\n\n        final double a3 = plane3.w.getX();\n        final double b3 = plane3.w.getY();\n        final double c3 = plane3.w.getZ();\n        final double d3 = plane3.originOffset;\n\n        // direct Cramer resolution of the linear system\n        // (this is still feasible for a 3x3 system)\n        final double a23         = b2 * c3 - b3 * c2;\n        final double b23         = c2 * a3 - c3 * a2;\n        final double c23         = a2 * b3 - a3 * b2;\n        final double determinant = a1 * a23 + b1 * b23 + c1 * c23;\n        if (FastMath.abs(determinant) < 1.0e-10) {\n            return null;\n        }\n\n        final double r = 1.0 / determinant;\n        return new Vector3D(\n                            (-a23 * d1 - (c1 * b3 - c3 * b1) * d2 - (c2 * b1 - c1 * b2) * d3) * r,\n                            (-b23 * d1 - (c3 * a1 - c1 * a3) * d2 - (c1 * a2 - c2 * a1) * d3) * r,\n                            (-c23 * d1 - (b1 * a3 - b3 * a1) * d2 - (b2 * a1 - b1 * a2) * d3) * r);\n\n    }",
    "comment": "Get the intersection point of three planes. @param plane1 first plane1 @param plane2 second plane2 @param plane3 third plane2 @return intersection point of three planes, null if some planes are parallel ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "Plane.sameOrientationAs",
    "class_name": "org.apache.commons.math3.geometry.euclidean.threed.Plane",
    "signature": "org.apache.commons.math3.geometry.euclidean.threed.Plane.sameOrientationAs(Hyperplane)",
    "snippet": "    public boolean sameOrientationAs(final Hyperplane<Euclidean3D> other) {\n        return (((Plane) other).w).dotProduct(w) > 0.0;\n    }",
    "comment": "Check if the instance has the same orientation as another hyperplane. @param other other hyperplane to check against the instance @return true if the instance and the other hyperplane have the same orientation ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "Plane.setFrame",
    "class_name": "org.apache.commons.math3.geometry.euclidean.threed.Plane",
    "signature": "org.apache.commons.math3.geometry.euclidean.threed.Plane.setFrame()",
    "snippet": "    private void setFrame() {\n        origin = new Vector3D(-originOffset, w);\n        u = w.orthogonal();\n        v = Vector3D.crossProduct(w, u);\n    }",
    "comment": "Reset the plane frame. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "Plane.setNormal",
    "class_name": "org.apache.commons.math3.geometry.euclidean.threed.Plane",
    "signature": "org.apache.commons.math3.geometry.euclidean.threed.Plane.setNormal(Vector3D)",
    "snippet": "    private void setNormal(final Vector3D normal) {\n        final double norm = normal.getNorm();\n        if (norm < 1.0e-10) {\n            throw new MathArithmeticException(LocalizedFormats.ZERO_NORM);\n        }\n        w = new Vector3D(1.0 / norm, normal);\n    }",
    "comment": "Set the normal vactor. @param normal normal direction to the plane (will be copied) @exception MathArithmeticException if the normal norm is too small ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "Plane.toSpace",
    "class_name": "org.apache.commons.math3.geometry.euclidean.threed.Plane",
    "signature": "org.apache.commons.math3.geometry.euclidean.threed.Plane.toSpace(Vector)",
    "snippet": "    public Vector3D toSpace(final Vector<Euclidean2D> point) {\n        final Vector2D p2D = (Vector2D) point;\n        return new Vector3D(p2D.getX(), u, p2D.getY(), v, -originOffset, w);\n    }",
    "comment": "Transform an in-plane point into a 3D space point. @param point in-plane point (must be a {@link org.apache.commons.math3.geometry.euclidean.twod.Vector2D Vector2D} instance) @return 3D space point (really a {@link Vector3D Vector3D} instance) @see #toSubSpace ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "Plane.toSubSpace",
    "class_name": "org.apache.commons.math3.geometry.euclidean.threed.Plane",
    "signature": "org.apache.commons.math3.geometry.euclidean.threed.Plane.toSubSpace(Vector)",
    "snippet": "    public Vector2D toSubSpace(final Vector<Euclidean3D> point) {\n        return new Vector2D(point.dotProduct(u), point.dotProduct(v));\n    }",
    "comment": "Transform a 3D space point into an in-plane point. @param point point of the space (must be a {@link Vector3D Vector3D} instance) @return in-plane point (really a {@link org.apache.commons.math3.geometry.euclidean.twod.Vector2D Vector2D} instance) @see #toSpace ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "Plane.wholeHyperplane",
    "class_name": "org.apache.commons.math3.geometry.euclidean.threed.Plane",
    "signature": "org.apache.commons.math3.geometry.euclidean.threed.Plane.wholeHyperplane()",
    "snippet": "    public SubPlane wholeHyperplane() {\n        return new SubPlane(this, new PolygonsSet());\n    }",
    "comment": "Build a region covering the whole hyperplane. @return a region covering the whole hyperplane ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "PolyhedronsSet.PolyhedronsSet",
    "class_name": "org.apache.commons.math3.geometry.euclidean.threed.PolyhedronsSet",
    "signature": "org.apache.commons.math3.geometry.euclidean.threed.PolyhedronsSet.PolyhedronsSet(Collection)",
    "snippet": "    public PolyhedronsSet(final Collection<SubHyperplane<Euclidean3D>> boundary) {\n        super(boundary);\n    }",
    "comment": "Build a polyhedrons set from a Boundary REPresentation (B-rep). <p>The boundary is provided as a collection of {@link SubHyperplane sub-hyperplanes}. Each sub-hyperplane has the interior part of the region on its minus side and the exterior on its plus side.</p> <p>The boundary elements can be in any order, and can form several non-connected sets (like for example polyhedrons with holes or a set of disjoint polyhedrons considered as a whole). In fact, the elements do not even need to be connected together (their topological connections are not used here). However, if the boundary does not really separate an inside open from an outside open (open having here its topological meaning), then subsequent calls to the {@link Region#checkPoint(Vector) checkPoint} method will not be meaningful anymore.</p> <p>If the boundary is empty, the region will represent the whole space.</p> @param boundary collection of boundary elements, as a collection of {@link SubHyperplane SubHyperplane} objects ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "PolyhedronsSet.computeGeometricalProperties",
    "class_name": "org.apache.commons.math3.geometry.euclidean.threed.PolyhedronsSet",
    "signature": "org.apache.commons.math3.geometry.euclidean.threed.PolyhedronsSet.computeGeometricalProperties()",
    "snippet": "    @Override\n    protected void computeGeometricalProperties() {\n\n        // compute the contribution of all boundary facets\n        getTree(true).visit(new FacetsContributionVisitor());\n\n        if (getSize() < 0) {\n            // the polyhedrons set as a finite outside\n            // surrounded by an infinite inside\n            setSize(Double.POSITIVE_INFINITY);\n            setBarycenter(Vector3D.NaN);\n        } else {\n            // the polyhedrons set is finite, apply the remaining scaling factors\n            setSize(getSize() / 3.0);\n            setBarycenter(new Vector3D(1.0 / (4 * getSize()), (Vector3D) getBarycenter()));\n        }\n\n    }",
    "comment": "{@inheritDoc} */",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "FacetsContributionVisitor.addContribution",
    "class_name": "org.apache.commons.math3.geometry.euclidean.threed.PolyhedronsSet$FacetsContributionVisitor",
    "signature": "org.apache.commons.math3.geometry.euclidean.threed.PolyhedronsSet$FacetsContributionVisitor.addContribution(SubHyperplane,boolean)",
    "snippet": "        private void addContribution(final SubHyperplane<Euclidean3D> facet, final boolean reversed) {\n\n            final Region<Euclidean2D> polygon = ((SubPlane) facet).getRemainingRegion();\n            final double area    = polygon.getSize();\n\n            if (Double.isInfinite(area)) {\n                setSize(Double.POSITIVE_INFINITY);\n                setBarycenter(Vector3D.NaN);\n            } else {\n\n                final Plane    plane  = (Plane) facet.getHyperplane();\n                final Vector3D facetB = plane.toSpace(polygon.getBarycenter());\n                double   scaled = area * facetB.dotProduct(plane.getNormal());\n                if (reversed) {\n                    scaled = -scaled;\n                }\n\n                setSize(getSize() + scaled);\n                setBarycenter(new Vector3D(1.0, (Vector3D) getBarycenter(), scaled, facetB));\n\n            }\n\n        }",
    "comment": "Add he contribution of a boundary facet. @param facet boundary facet @param reversed if true, the facet has the inside on its plus side ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "FacetsContributionVisitor.visitInternalNode",
    "class_name": "org.apache.commons.math3.geometry.euclidean.threed.PolyhedronsSet$FacetsContributionVisitor",
    "signature": "org.apache.commons.math3.geometry.euclidean.threed.PolyhedronsSet$FacetsContributionVisitor.visitInternalNode(BSPTree)",
    "snippet": "        public void visitInternalNode(final BSPTree<Euclidean3D> node) {\n            @SuppressWarnings(\"unchecked\")\n            final BoundaryAttribute<Euclidean3D> attribute =\n                (BoundaryAttribute<Euclidean3D>) node.getAttribute();\n            if (attribute.getPlusOutside() != null) {\n                addContribution(attribute.getPlusOutside(), false);\n            }\n            if (attribute.getPlusInside() != null) {\n                addContribution(attribute.getPlusInside(), true);\n            }\n        }",
    "comment": "{@inheritDoc} */",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "FacetsContributionVisitor.visitLeafNode",
    "class_name": "org.apache.commons.math3.geometry.euclidean.threed.PolyhedronsSet$FacetsContributionVisitor",
    "signature": "org.apache.commons.math3.geometry.euclidean.threed.PolyhedronsSet$FacetsContributionVisitor.visitLeafNode(BSPTree)",
    "snippet": "        public void visitLeafNode(final BSPTree<Euclidean3D> node) {\n        }",
    "comment": "{@inheritDoc} */",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "FacetsContributionVisitor.visitOrder",
    "class_name": "org.apache.commons.math3.geometry.euclidean.threed.PolyhedronsSet$FacetsContributionVisitor",
    "signature": "org.apache.commons.math3.geometry.euclidean.threed.PolyhedronsSet$FacetsContributionVisitor.visitOrder(BSPTree)",
    "snippet": "        public Order visitOrder(final BSPTree<Euclidean3D> node) {\n            return Order.MINUS_SUB_PLUS;\n        }",
    "comment": "{@inheritDoc} */",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "SubPlane.SubPlane",
    "class_name": "org.apache.commons.math3.geometry.euclidean.threed.SubPlane",
    "signature": "org.apache.commons.math3.geometry.euclidean.threed.SubPlane.SubPlane(Hyperplane,Region)",
    "snippet": "    public SubPlane(final Hyperplane<Euclidean3D> hyperplane,\n                    final Region<Euclidean2D> remainingRegion) {\n        super(hyperplane, remainingRegion);\n    }",
    "comment": "Simple constructor. @param hyperplane underlying hyperplane @param remainingRegion remaining region of the hyperplane ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "SubPlane.buildNew",
    "class_name": "org.apache.commons.math3.geometry.euclidean.threed.SubPlane",
    "signature": "org.apache.commons.math3.geometry.euclidean.threed.SubPlane.buildNew(Hyperplane,Region)",
    "snippet": "    @Override\n    protected AbstractSubHyperplane<Euclidean3D, Euclidean2D> buildNew(final Hyperplane<Euclidean3D> hyperplane,\n                                                                       final Region<Euclidean2D> remainingRegion) {\n        return new SubPlane(hyperplane, remainingRegion);\n    }",
    "comment": "{@inheritDoc} */",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "SubPlane.side",
    "class_name": "org.apache.commons.math3.geometry.euclidean.threed.SubPlane",
    "signature": "org.apache.commons.math3.geometry.euclidean.threed.SubPlane.side(Hyperplane)",
    "snippet": "    @Override\n    public Side side(Hyperplane<Euclidean3D> hyperplane) {\n\n        final Plane otherPlane = (Plane) hyperplane;\n        final Plane thisPlane  = (Plane) getHyperplane();\n        final Line  inter      = otherPlane.intersection(thisPlane);\n\n        if (inter == null) {\n            // the hyperplanes are parallel,\n            // any point can be used to check their relative position\n            final double global = otherPlane.getOffset(thisPlane);\n            return (global < -1.0e-10) ? Side.MINUS : ((global > 1.0e-10) ? Side.PLUS : Side.HYPER);\n        }\n\n        // create a 2D line in the otherPlane canonical 2D frame such that:\n        //   - the line is the crossing line of the two planes in 3D\n        //   - the line splits the otherPlane in two half planes with an\n        //     orientation consistent with the orientation of the instance\n        //     (i.e. the 3D half space on the plus side (resp. minus side)\n        //      of the instance contains the 2D half plane on the plus side\n        //      (resp. minus side) of the 2D line\n        Vector2D p = thisPlane.toSubSpace(inter.toSpace(Vector1D.ZERO));\n        Vector2D q = thisPlane.toSubSpace(inter.toSpace(Vector1D.ONE));\n        Vector3D crossP = Vector3D.crossProduct(inter.getDirection(), thisPlane.getNormal());\n        if (crossP.dotProduct(otherPlane.getNormal()) < 0) {\n            final Vector2D tmp = p;\n            p           = q;\n            q           = tmp;\n        }\n        final org.apache.commons.math3.geometry.euclidean.twod.Line line2D =\n            new org.apache.commons.math3.geometry.euclidean.twod.Line(p, q);\n\n        // check the side on the 2D plane\n        return getRemainingRegion().side(line2D);\n\n    }",
    "comment": "{@inheritDoc} */",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "SubPlane.split",
    "class_name": "org.apache.commons.math3.geometry.euclidean.threed.SubPlane",
    "signature": "org.apache.commons.math3.geometry.euclidean.threed.SubPlane.split(Hyperplane)",
    "snippet": "    @Override\n    public SplitSubHyperplane<Euclidean3D> split(Hyperplane<Euclidean3D> hyperplane) {\n\n        final Plane otherPlane = (Plane) hyperplane;\n        final Plane thisPlane  = (Plane) getHyperplane();\n        final Line  inter      = otherPlane.intersection(thisPlane);\n\n        if (inter == null) {\n            // the hyperplanes are parallel\n            final double global = otherPlane.getOffset(thisPlane);\n            return (global < -1.0e-10) ?\n                   new SplitSubHyperplane<Euclidean3D>(null, this) :\n                   new SplitSubHyperplane<Euclidean3D>(this, null);\n        }\n\n        // the hyperplanes do intersect\n        Vector2D p = thisPlane.toSubSpace(inter.toSpace(Vector1D.ZERO));\n        Vector2D q = thisPlane.toSubSpace(inter.toSpace(Vector1D.ONE));\n        Vector3D crossP = Vector3D.crossProduct(inter.getDirection(), thisPlane.getNormal());\n        if (crossP.dotProduct(otherPlane.getNormal()) < 0) {\n            final Vector2D tmp = p;\n            p           = q;\n            q           = tmp;\n        }\n        final SubHyperplane<Euclidean2D> l2DMinus =\n            new org.apache.commons.math3.geometry.euclidean.twod.Line(p, q).wholeHyperplane();\n        final SubHyperplane<Euclidean2D> l2DPlus =\n            new org.apache.commons.math3.geometry.euclidean.twod.Line(q, p).wholeHyperplane();\n\n        final BSPTree<Euclidean2D> splitTree = getRemainingRegion().getTree(false).split(l2DMinus);\n        final BSPTree<Euclidean2D> plusTree  = getRemainingRegion().isEmpty(splitTree.getPlus()) ?\n                                               new BSPTree<Euclidean2D>(Boolean.FALSE) :\n                                               new BSPTree<Euclidean2D>(l2DPlus, new BSPTree<Euclidean2D>(Boolean.FALSE),\n                                                                        splitTree.getPlus(), null);\n\n        final BSPTree<Euclidean2D> minusTree = getRemainingRegion().isEmpty(splitTree.getMinus()) ?\n                                               new BSPTree<Euclidean2D>(Boolean.FALSE) :\n                                                   new BSPTree<Euclidean2D>(l2DMinus, new BSPTree<Euclidean2D>(Boolean.FALSE),\n                                                                            splitTree.getMinus(), null);\n\n        return new SplitSubHyperplane<Euclidean3D>(new SubPlane(thisPlane.copySelf(), new PolygonsSet(plusTree)),\n                                                   new SubPlane(thisPlane.copySelf(), new PolygonsSet(minusTree)));\n\n    }",
    "comment": "Split the instance in two parts by an hyperplane. @param hyperplane splitting hyperplane @return an object containing both the part of the instance on the plus side of the instance and the part of the instance on the minus side of the instance ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "Vector3D.Vector3D",
    "class_name": "org.apache.commons.math3.geometry.euclidean.threed.Vector3D",
    "signature": "org.apache.commons.math3.geometry.euclidean.threed.Vector3D.Vector3D(double,Vector3D)",
    "snippet": "    public Vector3D(double a, Vector3D u) {\n        this.x = a * u.x;\n        this.y = a * u.y;\n        this.z = a * u.z;\n    }",
    "comment": "Multiplicative constructor Build a vector from another one and a scale factor. The vector built will be a * u @param a scale factor @param u base (unscaled) vector ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "Vector3D.Vector3D",
    "class_name": "org.apache.commons.math3.geometry.euclidean.threed.Vector3D",
    "signature": "org.apache.commons.math3.geometry.euclidean.threed.Vector3D.Vector3D(double,Vector3D,double,Vector3D)",
    "snippet": "    public Vector3D(double a1, Vector3D u1, double a2, Vector3D u2) {\n        this.x = MathArrays.linearCombination(a1, u1.x, a2, u2.x);\n        this.y = MathArrays.linearCombination(a1, u1.y, a2, u2.y);\n        this.z = MathArrays.linearCombination(a1, u1.z, a2, u2.z);\n    }",
    "comment": "Linear constructor Build a vector from two other ones and corresponding scale factors. The vector built will be a1 * u1 + a2 * u2 @param a1 first scale factor @param u1 first base (unscaled) vector @param a2 second scale factor @param u2 second base (unscaled) vector ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "Vector3D.Vector3D",
    "class_name": "org.apache.commons.math3.geometry.euclidean.threed.Vector3D",
    "signature": "org.apache.commons.math3.geometry.euclidean.threed.Vector3D.Vector3D(double,Vector3D,double,Vector3D,double,Vector3D)",
    "snippet": "    public Vector3D(double a1, Vector3D u1, double a2, Vector3D u2,\n                    double a3, Vector3D u3) {\n        this.x = MathArrays.linearCombination(a1, u1.x, a2, u2.x, a3, u3.x);\n        this.y = MathArrays.linearCombination(a1, u1.y, a2, u2.y, a3, u3.y);\n        this.z = MathArrays.linearCombination(a1, u1.z, a2, u2.z, a3, u3.z);\n    }",
    "comment": "Linear constructor Build a vector from three other ones and corresponding scale factors. The vector built will be a1 * u1 + a2 * u2 + a3 * u3 @param a1 first scale factor @param u1 first base (unscaled) vector @param a2 second scale factor @param u2 second base (unscaled) vector @param a3 third scale factor @param u3 third base (unscaled) vector ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "Vector3D.Vector3D",
    "class_name": "org.apache.commons.math3.geometry.euclidean.threed.Vector3D",
    "signature": "org.apache.commons.math3.geometry.euclidean.threed.Vector3D.Vector3D(double,double,double)",
    "snippet": "    public Vector3D(double x, double y, double z) {\n        this.x = x;\n        this.y = y;\n        this.z = z;\n    }",
    "comment": "Simple constructor. Build a vector from its coordinates @param x abscissa @param y ordinate @param z height @see #getX() @see #getY() @see #getZ() ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "Vector3D.add",
    "class_name": "org.apache.commons.math3.geometry.euclidean.threed.Vector3D",
    "signature": "org.apache.commons.math3.geometry.euclidean.threed.Vector3D.add(Vector)",
    "snippet": "    public Vector3D add(final Vector<Euclidean3D> v) {\n        final Vector3D v3 = (Vector3D) v;\n        return new Vector3D(x + v3.x, y + v3.y, z + v3.z);\n    }",
    "comment": "{@inheritDoc} */",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "Vector3D.crossProduct",
    "class_name": "org.apache.commons.math3.geometry.euclidean.threed.Vector3D",
    "signature": "org.apache.commons.math3.geometry.euclidean.threed.Vector3D.crossProduct(Vector)",
    "snippet": "    public Vector3D crossProduct(final Vector<Euclidean3D> v) {\n        final Vector3D v3 = (Vector3D) v;\n        return new Vector3D(MathArrays.linearCombination(y, v3.z, -z, v3.y),\n                            MathArrays.linearCombination(z, v3.x, -x, v3.z),\n                            MathArrays.linearCombination(x, v3.y, -y, v3.x));\n    }",
    "comment": "Compute the cross-product of the instance with another vector. @param v other vector @return the cross product this ^ v as a new Vector3D ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "Vector3D.crossProduct",
    "class_name": "org.apache.commons.math3.geometry.euclidean.threed.Vector3D",
    "signature": "org.apache.commons.math3.geometry.euclidean.threed.Vector3D.crossProduct(Vector3D,Vector3D)",
    "snippet": "    public static Vector3D crossProduct(final Vector3D v1, final Vector3D v2) {\n        return v1.crossProduct(v2);\n    }",
    "comment": "Compute the cross-product of two vectors. @param v1 first vector @param v2 second vector @return the cross product v1 ^ v2 as a new Vector ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "Vector3D.dotProduct",
    "class_name": "org.apache.commons.math3.geometry.euclidean.threed.Vector3D",
    "signature": "org.apache.commons.math3.geometry.euclidean.threed.Vector3D.dotProduct(Vector)",
    "snippet": "    public double dotProduct(final Vector<Euclidean3D> v) {\n        final Vector3D v3 = (Vector3D) v;\n        return MathArrays.linearCombination(x, v3.x, y, v3.y, z, v3.z);\n    }",
    "comment": "{@inheritDoc} <p> The implementation uses specific multiplication and addition algorithms to preserve accuracy and reduce cancellation effects. It should be very accurate even for nearly orthogonal vectors. </p> @see MathArrays#linearCombination(double, double, double, double, double, double) ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "Vector3D.getNorm",
    "class_name": "org.apache.commons.math3.geometry.euclidean.threed.Vector3D",
    "signature": "org.apache.commons.math3.geometry.euclidean.threed.Vector3D.getNorm()",
    "snippet": "    public double getNorm() {\n        // there are no cancellation problems here, so we use the straightforward formula\n        return FastMath.sqrt (x * x + y * y + z * z);\n    }",
    "comment": "{@inheritDoc} */",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "Vector3D.getNormSq",
    "class_name": "org.apache.commons.math3.geometry.euclidean.threed.Vector3D",
    "signature": "org.apache.commons.math3.geometry.euclidean.threed.Vector3D.getNormSq()",
    "snippet": "    public double getNormSq() {\n        // there are no cancellation problems here, so we use the straightforward formula\n        return x * x + y * y + z * z;\n    }",
    "comment": "{@inheritDoc} */",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "Vector3D.getX",
    "class_name": "org.apache.commons.math3.geometry.euclidean.threed.Vector3D",
    "signature": "org.apache.commons.math3.geometry.euclidean.threed.Vector3D.getX()",
    "snippet": "    public double getX() {\n        return x;\n    }",
    "comment": "Get the abscissa of the vector. @return abscissa of the vector @see #Vector3D(double, double, double) ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "Vector3D.getY",
    "class_name": "org.apache.commons.math3.geometry.euclidean.threed.Vector3D",
    "signature": "org.apache.commons.math3.geometry.euclidean.threed.Vector3D.getY()",
    "snippet": "    public double getY() {\n        return y;\n    }",
    "comment": "Get the ordinate of the vector. @return ordinate of the vector @see #Vector3D(double, double, double) ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "Vector3D.getZ",
    "class_name": "org.apache.commons.math3.geometry.euclidean.threed.Vector3D",
    "signature": "org.apache.commons.math3.geometry.euclidean.threed.Vector3D.getZ()",
    "snippet": "    public double getZ() {\n        return z;\n    }",
    "comment": "Get the height of the vector. @return height of the vector @see #Vector3D(double, double, double) ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "Vector3D.orthogonal",
    "class_name": "org.apache.commons.math3.geometry.euclidean.threed.Vector3D",
    "signature": "org.apache.commons.math3.geometry.euclidean.threed.Vector3D.orthogonal()",
    "snippet": "    public Vector3D orthogonal() {\n\n        double threshold = 0.6 * getNorm();\n        if (threshold == 0) {\n            throw new MathArithmeticException(LocalizedFormats.ZERO_NORM);\n        }\n\n        if ((x >= -threshold) && (x <= threshold)) {\n            double inverse  = 1 / FastMath.sqrt(y * y + z * z);\n            return new Vector3D(0, inverse * z, -inverse * y);\n        } else if ((y >= -threshold) && (y <= threshold)) {\n            double inverse  = 1 / FastMath.sqrt(x * x + z * z);\n            return new Vector3D(-inverse * z, 0, inverse * x);\n        }\n        double inverse  = 1 / FastMath.sqrt(x * x + y * y);\n        return new Vector3D(inverse * y, -inverse * x, 0);\n\n    }",
    "comment": "Get a vector orthogonal to the instance. <p>There are an infinite number of normalized vectors orthogonal to the instance. This method picks up one of them almost arbitrarily. It is useful when one needs to compute a reference frame with one of the axes in a predefined direction. The following example shows how to build a frame having the k axis aligned with the known vector u : <pre><code> Vector3D k = u.normalize(); Vector3D i = k.orthogonal(); Vector3D j = Vector3D.crossProduct(k, i); </code></pre></p> @return a new normalized vector orthogonal to the instance @exception MathArithmeticException if the norm of the instance is null ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "Vector3D.subtract",
    "class_name": "org.apache.commons.math3.geometry.euclidean.threed.Vector3D",
    "signature": "org.apache.commons.math3.geometry.euclidean.threed.Vector3D.subtract(Vector)",
    "snippet": "    public Vector3D subtract(final Vector<Euclidean3D> v) {\n        final Vector3D v3 = (Vector3D) v;\n        return new Vector3D(x - v3.x, y - v3.y, z - v3.z);\n    }",
    "comment": "{@inheritDoc} */",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "Line.Line",
    "class_name": "org.apache.commons.math3.geometry.euclidean.twod.Line",
    "signature": "org.apache.commons.math3.geometry.euclidean.twod.Line.Line(Line)",
    "snippet": "    public Line(final Line line) {\n        angle        = MathUtils.normalizeAngle(line.angle, FastMath.PI);\n        cos          = FastMath.cos(angle);\n        sin          = FastMath.sin(angle);\n        originOffset = line.originOffset;\n    }",
    "comment": "Copy constructor. <p>The created instance is completely independent from the original instance, it is a deep copy.</p> @param line line to copy ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "Line.Line",
    "class_name": "org.apache.commons.math3.geometry.euclidean.twod.Line",
    "signature": "org.apache.commons.math3.geometry.euclidean.twod.Line.Line(Vector2D,Vector2D)",
    "snippet": "    public Line(final Vector2D p1, final Vector2D p2) {\n        reset(p1, p2);\n    }",
    "comment": "Build a line from two points. <p>The line is oriented from p1 to p2</p> @param p1 first point @param p2 second point ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "Line.copySelf",
    "class_name": "org.apache.commons.math3.geometry.euclidean.twod.Line",
    "signature": "org.apache.commons.math3.geometry.euclidean.twod.Line.copySelf()",
    "snippet": "    public Line copySelf() {\n        return new Line(this);\n    }",
    "comment": "{@inheritDoc} */",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "Line.getAngle",
    "class_name": "org.apache.commons.math3.geometry.euclidean.twod.Line",
    "signature": "org.apache.commons.math3.geometry.euclidean.twod.Line.getAngle()",
    "snippet": "    public double getAngle() {\n        return MathUtils.normalizeAngle(angle, FastMath.PI);\n    }",
    "comment": "Get the angle of the line. @return the angle of the line with respect to the abscissa axis ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "Line.getOffset",
    "class_name": "org.apache.commons.math3.geometry.euclidean.twod.Line",
    "signature": "org.apache.commons.math3.geometry.euclidean.twod.Line.getOffset(Line)",
    "snippet": "    public double getOffset(final Line line) {\n        return originOffset +\n               ((cos * line.cos + sin * line.sin > 0) ? -line.originOffset : line.originOffset);\n    }",
    "comment": "Get the offset (oriented distance) of a parallel line. <p>This method should be called only for parallel lines otherwise the result is not meaningful.</p> <p>The offset is 0 if both lines are the same, it is positive if the line is on the right side of the instance and negative if it is on the left side, according to its natural orientation.</p> @param line line to check @return offset of the line ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "Line.intersection",
    "class_name": "org.apache.commons.math3.geometry.euclidean.twod.Line",
    "signature": "org.apache.commons.math3.geometry.euclidean.twod.Line.intersection(Line)",
    "snippet": "    public Vector2D intersection(final Line other) {\n        final double d = sin * other.cos - other.sin * cos;\n        if (FastMath.abs(d) < 1.0e-10) {\n            return null;\n        }\n        return new Vector2D((cos * other.originOffset - other.cos * originOffset) / d,\n                            (sin * other.originOffset - other.sin * originOffset) / d);\n    }",
    "comment": "Get the intersection point of the instance and another line. @param other other line @return intersection point of the instance and the other line or null if there are no intersection points ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "Line.reset",
    "class_name": "org.apache.commons.math3.geometry.euclidean.twod.Line",
    "signature": "org.apache.commons.math3.geometry.euclidean.twod.Line.reset(Vector2D,Vector2D)",
    "snippet": "    public void reset(final Vector2D p1, final Vector2D p2) {\n        final double dx = p2.getX() - p1.getX();\n        final double dy = p2.getY() - p1.getY();\n        final double d = FastMath.hypot(dx, dy);\n        if (d == 0.0) {\n            angle        = 0.0;\n            cos          = 1.0;\n            sin          = 0.0;\n            originOffset = p1.getY();\n        } else {\n            angle        = FastMath.PI + FastMath.atan2(-dy, -dx);\n            cos          = FastMath.cos(angle);\n            sin          = FastMath.sin(angle);\n            originOffset = (p2.getX() * p1.getY() - p1.getX() * p2.getY()) / d;\n        }\n    }",
    "comment": "Reset the instance as if built from two points. <p>The line is oriented from p1 to p2</p> @param p1 first point @param p2 second point ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "Line.sameOrientationAs",
    "class_name": "org.apache.commons.math3.geometry.euclidean.twod.Line",
    "signature": "org.apache.commons.math3.geometry.euclidean.twod.Line.sameOrientationAs(Hyperplane)",
    "snippet": "    public boolean sameOrientationAs(final Hyperplane<Euclidean2D> other) {\n        final Line otherL = (Line) other;\n        return (sin * otherL.sin + cos * otherL.cos) >= 0.0;\n    }",
    "comment": "{@inheritDoc} */",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "Line.toSpace",
    "class_name": "org.apache.commons.math3.geometry.euclidean.twod.Line",
    "signature": "org.apache.commons.math3.geometry.euclidean.twod.Line.toSpace(Vector)",
    "snippet": "    public Vector2D toSpace(final Vector<Euclidean1D> point) {\n        final double abscissa = ((Vector1D) point).getX();\n        return new Vector2D(abscissa * cos - originOffset * sin,\n                            abscissa * sin + originOffset * cos);\n    }",
    "comment": "{@inheritDoc} */",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "Line.toSubSpace",
    "class_name": "org.apache.commons.math3.geometry.euclidean.twod.Line",
    "signature": "org.apache.commons.math3.geometry.euclidean.twod.Line.toSubSpace(Vector)",
    "snippet": "    public Vector1D toSubSpace(final Vector<Euclidean2D> point) {\n        Vector2D p2 = (Vector2D) point;\n        return new Vector1D(cos * p2.getX() + sin * p2.getY());\n    }",
    "comment": "{@inheritDoc} */",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "Line.wholeHyperplane",
    "class_name": "org.apache.commons.math3.geometry.euclidean.twod.Line",
    "signature": "org.apache.commons.math3.geometry.euclidean.twod.Line.wholeHyperplane()",
    "snippet": "    public SubLine wholeHyperplane() {\n        return new SubLine(this, new IntervalsSet());\n    }",
    "comment": "{@inheritDoc} */",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "PolygonsSet.PolygonsSet",
    "class_name": "org.apache.commons.math3.geometry.euclidean.twod.PolygonsSet",
    "signature": "org.apache.commons.math3.geometry.euclidean.twod.PolygonsSet.PolygonsSet()",
    "snippet": "    public PolygonsSet() {\n        super();\n    }",
    "comment": "Build a polygons set representing the whole real line. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "PolygonsSet.PolygonsSet",
    "class_name": "org.apache.commons.math3.geometry.euclidean.twod.PolygonsSet",
    "signature": "org.apache.commons.math3.geometry.euclidean.twod.PolygonsSet.PolygonsSet(BSPTree)",
    "snippet": "    public PolygonsSet(final BSPTree<Euclidean2D> tree) {\n        super(tree);\n    }",
    "comment": "Build a polygons set from a BSP tree. <p>The leaf nodes of the BSP tree <em>must</em> have a {@code Boolean} attribute representing the inside status of the corresponding cell (true for inside cells, false for outside cells). In order to avoid building too many small objects, it is recommended to use the predefined constants {@code Boolean.TRUE} and {@code Boolean.FALSE}</p> @param tree inside/outside BSP tree representing the region ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "PolygonsSet.PolygonsSet",
    "class_name": "org.apache.commons.math3.geometry.euclidean.twod.PolygonsSet",
    "signature": "org.apache.commons.math3.geometry.euclidean.twod.PolygonsSet.PolygonsSet(Collection)",
    "snippet": "    public PolygonsSet(final Collection<SubHyperplane<Euclidean2D>> boundary) {\n        super(boundary);\n    }",
    "comment": "Build a polygons set from a Boundary REPresentation (B-rep). <p>The boundary is provided as a collection of {@link SubHyperplane sub-hyperplanes}. Each sub-hyperplane has the interior part of the region on its minus side and the exterior on its plus side.</p> <p>The boundary elements can be in any order, and can form several non-connected sets (like for example polygons with holes or a set of disjoint polyhedrons considered as a whole). In fact, the elements do not even need to be connected together (their topological connections are not used here). However, if the boundary does not really separate an inside open from an outside open (open having here its topological meaning), then subsequent calls to the {@link org.apache.commons.math3.geometry.partitioning.Region#checkPoint(org.apache.commons.math3.geometry.Vector) checkPoint} method will not be meaningful anymore.</p> <p>If the boundary is empty, the region will represent the whole space.</p> @param boundary collection of boundary elements, as a collection of {@link SubHyperplane SubHyperplane} objects ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "PolygonsSet.buildNew",
    "class_name": "org.apache.commons.math3.geometry.euclidean.twod.PolygonsSet",
    "signature": "org.apache.commons.math3.geometry.euclidean.twod.PolygonsSet.buildNew(BSPTree)",
    "snippet": "    @Override\n    public PolygonsSet buildNew(final BSPTree<Euclidean2D> tree) {\n        return new PolygonsSet(tree);\n    }",
    "comment": "{@inheritDoc} */",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "PolygonsSet.computeGeometricalProperties",
    "class_name": "org.apache.commons.math3.geometry.euclidean.twod.PolygonsSet",
    "signature": "org.apache.commons.math3.geometry.euclidean.twod.PolygonsSet.computeGeometricalProperties()",
    "snippet": "    @Override\n    protected void computeGeometricalProperties() {\n\n        final Vector2D[][] v = getVertices();\n\n        if (v.length == 0) {\n            final BSPTree<Euclidean2D> tree = getTree(false);\n            if ((Boolean) tree.getAttribute()) {\n                // the instance covers the whole space\n                setSize(Double.POSITIVE_INFINITY);\n                setBarycenter(Vector2D.NaN);\n            } else {\n                setSize(0);\n                setBarycenter(new Vector2D(0, 0));\n            }\n        } else if (v[0][0] == null) {\n            // there is at least one open-loop: the polygon is infinite\n            setSize(Double.POSITIVE_INFINITY);\n            setBarycenter(Vector2D.NaN);\n        } else {\n            // all loops are closed, we compute some integrals around the shape\n\n            double sum  = 0;\n            double sumX = 0;\n            double sumY = 0;\n\n            for (Vector2D[] loop : v) {\n                double x1 = loop[loop.length - 1].getX();\n                double y1 = loop[loop.length - 1].getY();\n                for (final Vector2D point : loop) {\n                    final double x0 = x1;\n                    final double y0 = y1;\n                    x1 = point.getX();\n                    y1 = point.getY();\n                    final double factor = x0 * y1 - y0 * x1;\n                    sum  += factor;\n                    sumX += factor * (x0 + x1);\n                    sumY += factor * (y0 + y1);\n                }\n            }\n\n            if (sum < 0) {\n                // the polygon as a finite outside surrounded by an infinite inside\n                setSize(Double.POSITIVE_INFINITY);\n                setBarycenter(Vector2D.NaN);\n            } else {\n                setSize(sum / 2);\n                setBarycenter(new Vector2D(sumX / (3 * sum), sumY / (3 * sum)));\n            }\n\n        }\n\n    }",
    "comment": "{@inheritDoc} */",
    "is_bug": true,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "PolygonsSet.followLoop",
    "class_name": "org.apache.commons.math3.geometry.euclidean.twod.PolygonsSet",
    "signature": "org.apache.commons.math3.geometry.euclidean.twod.PolygonsSet.followLoop(Node,AVLTree)",
    "snippet": "    private List<ComparableSegment> followLoop(final AVLTree<ComparableSegment>.Node node,\n                                               final AVLTree<ComparableSegment> sorted) {\n\n        final ArrayList<ComparableSegment> loop = new ArrayList<ComparableSegment>();\n        ComparableSegment segment = node.getElement();\n        loop.add(segment);\n        final Vector2D globalStart = segment.getStart();\n        Vector2D end = segment.getEnd();\n        node.delete();\n\n        // is this an open or a closed loop ?\n        final boolean open = segment.getStart() == null;\n\n        while ((end != null) && (open || (globalStart.distance(end) > 1.0e-10))) {\n\n            // search the sub-hyperplane starting where the previous one ended\n            AVLTree<ComparableSegment>.Node selectedNode = null;\n            ComparableSegment       selectedSegment  = null;\n            double                  selectedDistance = Double.POSITIVE_INFINITY;\n            final ComparableSegment lowerLeft        = new ComparableSegment(end, -1.0e-10, -1.0e-10);\n            final ComparableSegment upperRight       = new ComparableSegment(end, +1.0e-10, +1.0e-10);\n            for (AVLTree<ComparableSegment>.Node n = sorted.getNotSmaller(lowerLeft);\n                 (n != null) && (n.getElement().compareTo(upperRight) <= 0);\n                 n = n.getNext()) {\n                segment = n.getElement();\n                final double distance = end.distance(segment.getStart());\n                if (distance < selectedDistance) {\n                    selectedNode     = n;\n                    selectedSegment  = segment;\n                    selectedDistance = distance;\n                }\n            }\n\n            if (selectedDistance > 1.0e-10) {\n                // this is a degenerated loop, it probably comes from a very\n                // tiny region with some segments smaller than the threshold, we\n                // simply ignore it\n                return null;\n            }\n\n            end = selectedSegment.getEnd();\n            loop.add(selectedSegment);\n            selectedNode.delete();\n\n        }\n\n        if ((loop.size() == 2) && !open) {\n            // this is a degenerated infinitely thin loop, we simply ignore it\n            return null;\n        }\n\n        if ((end == null) && !open) {\n            throw new MathInternalError();\n        }\n\n        return loop;\n\n    }",
    "comment": "Follow a boundary loop. @param node node containing the segment starting the loop @param sorted set of segments belonging to the boundary, sorted by start points (contains {@code node}) @return a list of connected sub-hyperplanes starting at {@code node} ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "PolygonsSet.getVertices",
    "class_name": "org.apache.commons.math3.geometry.euclidean.twod.PolygonsSet",
    "signature": "org.apache.commons.math3.geometry.euclidean.twod.PolygonsSet.getVertices()",
    "snippet": "    public Vector2D[][] getVertices() {\n        if (vertices == null) {\n            if (getTree(false).getCut() == null) {\n                vertices = new Vector2D[0][];\n            } else {\n\n                // sort the segments according to their start point\n                final SegmentsBuilder visitor = new SegmentsBuilder();\n                getTree(true).visit(visitor);\n                final AVLTree<ComparableSegment> sorted = visitor.getSorted();\n\n                // identify the loops, starting from the open ones\n                // (their start segments are naturally at the sorted set beginning)\n                final ArrayList<List<ComparableSegment>> loops = new ArrayList<List<ComparableSegment>>();\n                while (!sorted.isEmpty()) {\n                    final AVLTree<ComparableSegment>.Node node = sorted.getSmallest();\n                    final List<ComparableSegment> loop = followLoop(node, sorted);\n                    if (loop != null) {\n                        loops.add(loop);\n                    }\n                }\n\n                // tranform the loops in an array of arrays of points\n                vertices = new Vector2D[loops.size()][];\n                int i = 0;\n\n                for (final List<ComparableSegment> loop : loops) {\n                    if (loop.size() < 2) {\n                        // single infinite line\n                        final Line line = loop.get(0).getLine();\n                        vertices[i++] = new Vector2D[] {\n                            null,\n                            line.toSpace(new Vector1D(-Float.MAX_VALUE)),\n                            line.toSpace(new Vector1D(+Float.MAX_VALUE))\n                        };\n                    } else if (loop.get(0).getStart() == null) {\n                        // open loop with at least one real point\n                        final Vector2D[] array = new Vector2D[loop.size() + 2];\n                        int j = 0;\n                        for (Segment segment : loop) {\n\n                            if (j == 0) {\n                                // null point and first dummy point\n                                double x = segment.getLine().toSubSpace(segment.getEnd()).getX();\n                                x -= FastMath.max(1.0, FastMath.abs(x / 2));\n                                array[j++] = null;\n                                array[j++] = segment.getLine().toSpace(new Vector1D(x));\n                            }\n\n                            if (j < (array.length - 1)) {\n                                // current point\n                                array[j++] = segment.getEnd();\n                            }\n\n                            if (j == (array.length - 1)) {\n                                // last dummy point\n                                double x = segment.getLine().toSubSpace(segment.getStart()).getX();\n                                x += FastMath.max(1.0, FastMath.abs(x / 2));\n                                array[j++] = segment.getLine().toSpace(new Vector1D(x));\n                            }\n\n                        }\n                        vertices[i++] = array;\n                    } else {\n                        final Vector2D[] array = new Vector2D[loop.size()];\n                        int j = 0;\n                        for (Segment segment : loop) {\n                            array[j++] = segment.getStart();\n                        }\n                        vertices[i++] = array;\n                    }\n                }\n\n            }\n        }\n\n        return vertices.clone();\n\n    }",
    "comment": "Get the vertices of the polygon. <p>The polygon boundary can be represented as an array of loops, each loop being itself an array of vertices.</p> <p>In order to identify open loops which start and end by infinite edges, the open loops arrays start with a null point. In this case, the first non null point and the last point of the array do not represent real vertices, they are dummy points intended only to get the direction of the first and last edge. An open loop consisting of a single infinite line will therefore be represented by a three elements array with one null point followed by two dummy points. The open loops are always the first ones in the loops array.</p> <p>If the polygon has no boundary at all, a zero length loop array will be returned.</p> <p>All line segments in the various loops have the inside of the region on their left side and the outside on their right side when moving in the underlying line direction. This means that closed loops surrounding finite areas obey the direct trigonometric orientation.</p> @return vertices of the polygon, organized as oriented boundary loops with the open loops first (the returned value is guaranteed to be non-null) ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "ComparableSegment.compareTo",
    "class_name": "org.apache.commons.math3.geometry.euclidean.twod.PolygonsSet$ComparableSegment",
    "signature": "org.apache.commons.math3.geometry.euclidean.twod.PolygonsSet$ComparableSegment.compareTo(ComparableSegment)",
    "snippet": "        public int compareTo(final ComparableSegment o) {\n            return sortingKey.compareTo(o.sortingKey);\n        }",
    "comment": "{@inheritDoc} */",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "SegmentsBuilder.addContribution",
    "class_name": "org.apache.commons.math3.geometry.euclidean.twod.PolygonsSet$SegmentsBuilder",
    "signature": "org.apache.commons.math3.geometry.euclidean.twod.PolygonsSet$SegmentsBuilder.addContribution(SubHyperplane,boolean)",
    "snippet": "        private void addContribution(final SubHyperplane<Euclidean2D> sub, final boolean reversed) {\n            @SuppressWarnings(\"unchecked\")\n            final AbstractSubHyperplane<Euclidean2D, Euclidean1D> absSub =\n                (AbstractSubHyperplane<Euclidean2D, Euclidean1D>) sub;\n            final Line line      = (Line) sub.getHyperplane();\n            final List<Interval> intervals = ((IntervalsSet) absSub.getRemainingRegion()).asList();\n            for (final Interval i : intervals) {\n                final Vector2D start = Double.isInfinite(i.getLower()) ?\n                                      null : (Vector2D) line.toSpace(new Vector1D(i.getLower()));\n                final Vector2D end   = Double.isInfinite(i.getUpper()) ?\n                                      null : (Vector2D) line.toSpace(new Vector1D(i.getUpper()));\n                if (reversed) {\n                    sorted.insert(new ComparableSegment(end, start, line.getReverse()));\n                } else {\n                    sorted.insert(new ComparableSegment(start, end, line));\n                }\n            }\n        }",
    "comment": "Add he contribution of a boundary facet. @param sub boundary facet @param reversed if true, the facet has the inside on its plus side ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "SegmentsBuilder.getSorted",
    "class_name": "org.apache.commons.math3.geometry.euclidean.twod.PolygonsSet$SegmentsBuilder",
    "signature": "org.apache.commons.math3.geometry.euclidean.twod.PolygonsSet$SegmentsBuilder.getSorted()",
    "snippet": "        public AVLTree<ComparableSegment> getSorted() {\n            return sorted;\n        }",
    "comment": "Get the sorted segments. @return sorted segments ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "SegmentsBuilder.visitInternalNode",
    "class_name": "org.apache.commons.math3.geometry.euclidean.twod.PolygonsSet$SegmentsBuilder",
    "signature": "org.apache.commons.math3.geometry.euclidean.twod.PolygonsSet$SegmentsBuilder.visitInternalNode(BSPTree)",
    "snippet": "        public void visitInternalNode(final BSPTree<Euclidean2D> node) {\n            @SuppressWarnings(\"unchecked\")\n            final BoundaryAttribute<Euclidean2D> attribute = (BoundaryAttribute<Euclidean2D>) node.getAttribute();\n            if (attribute.getPlusOutside() != null) {\n                addContribution(attribute.getPlusOutside(), false);\n            }\n            if (attribute.getPlusInside() != null) {\n                addContribution(attribute.getPlusInside(), true);\n            }\n        }",
    "comment": "{@inheritDoc} */",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "SegmentsBuilder.visitLeafNode",
    "class_name": "org.apache.commons.math3.geometry.euclidean.twod.PolygonsSet$SegmentsBuilder",
    "signature": "org.apache.commons.math3.geometry.euclidean.twod.PolygonsSet$SegmentsBuilder.visitLeafNode(BSPTree)",
    "snippet": "        public void visitLeafNode(final BSPTree<Euclidean2D> node) {\n        }",
    "comment": "{@inheritDoc} */",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "SegmentsBuilder.visitOrder",
    "class_name": "org.apache.commons.math3.geometry.euclidean.twod.PolygonsSet$SegmentsBuilder",
    "signature": "org.apache.commons.math3.geometry.euclidean.twod.PolygonsSet$SegmentsBuilder.visitOrder(BSPTree)",
    "snippet": "        public Order visitOrder(final BSPTree<Euclidean2D> node) {\n            return Order.MINUS_SUB_PLUS;\n        }",
    "comment": "{@inheritDoc} */",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "Segment.Segment",
    "class_name": "org.apache.commons.math3.geometry.euclidean.twod.Segment",
    "signature": "org.apache.commons.math3.geometry.euclidean.twod.Segment.Segment(Vector2D,Vector2D,Line)",
    "snippet": "    public Segment(final Vector2D start, final Vector2D end, final Line line) {\n        this.start  = start;\n        this.end    = end;\n        this.line   = line;\n    }",
    "comment": "Build a segment. @param start start point of the segment @param end end point of the segment @param line line containing the segment ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "Segment.getEnd",
    "class_name": "org.apache.commons.math3.geometry.euclidean.twod.Segment",
    "signature": "org.apache.commons.math3.geometry.euclidean.twod.Segment.getEnd()",
    "snippet": "    public Vector2D getEnd() {\n        return end;\n    }",
    "comment": "Get the end point of the segment. @return end point of the segment ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "Segment.getStart",
    "class_name": "org.apache.commons.math3.geometry.euclidean.twod.Segment",
    "signature": "org.apache.commons.math3.geometry.euclidean.twod.Segment.getStart()",
    "snippet": "    public Vector2D getStart() {\n        return start;\n    }",
    "comment": "Get the start point of the segment. @return start point of the segment ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "SubLine.SubLine",
    "class_name": "org.apache.commons.math3.geometry.euclidean.twod.SubLine",
    "signature": "org.apache.commons.math3.geometry.euclidean.twod.SubLine.SubLine(Hyperplane,Region)",
    "snippet": "    public SubLine(final Hyperplane<Euclidean2D> hyperplane,\n                   final Region<Euclidean1D> remainingRegion) {\n        super(hyperplane, remainingRegion);\n    }",
    "comment": "Simple constructor. @param hyperplane underlying hyperplane @param remainingRegion remaining region of the hyperplane ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "SubLine.SubLine",
    "class_name": "org.apache.commons.math3.geometry.euclidean.twod.SubLine",
    "signature": "org.apache.commons.math3.geometry.euclidean.twod.SubLine.SubLine(Vector2D,Vector2D)",
    "snippet": "    public SubLine(final Vector2D start, final Vector2D end) {\n        super(new Line(start, end), buildIntervalSet(start, end));\n    }",
    "comment": "Create a sub-line from two endpoints. @param start start point @param end end point ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "SubLine.buildIntervalSet",
    "class_name": "org.apache.commons.math3.geometry.euclidean.twod.SubLine",
    "signature": "org.apache.commons.math3.geometry.euclidean.twod.SubLine.buildIntervalSet(Vector2D,Vector2D)",
    "snippet": "    private static IntervalsSet buildIntervalSet(final Vector2D start, final Vector2D end) {\n        final Line line = new Line(start, end);\n        return new IntervalsSet(line.toSubSpace(start).getX(),\n                                line.toSubSpace(end).getX());\n    }",
    "comment": "Build an interval set from two points. @param start start point @param end end point @return an interval set ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "SubLine.buildNew",
    "class_name": "org.apache.commons.math3.geometry.euclidean.twod.SubLine",
    "signature": "org.apache.commons.math3.geometry.euclidean.twod.SubLine.buildNew(Hyperplane,Region)",
    "snippet": "    @Override\n    protected AbstractSubHyperplane<Euclidean2D, Euclidean1D> buildNew(final Hyperplane<Euclidean2D> hyperplane,\n                                                                       final Region<Euclidean1D> remainingRegion) {\n        return new SubLine(hyperplane, remainingRegion);\n    }",
    "comment": "{@inheritDoc} */",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "SubLine.side",
    "class_name": "org.apache.commons.math3.geometry.euclidean.twod.SubLine",
    "signature": "org.apache.commons.math3.geometry.euclidean.twod.SubLine.side(Hyperplane)",
    "snippet": "    @Override\n    public Side side(final Hyperplane<Euclidean2D> hyperplane) {\n\n        final Line    thisLine  = (Line) getHyperplane();\n        final Line    otherLine = (Line) hyperplane;\n        final Vector2D crossing  = thisLine.intersection(otherLine);\n\n        if (crossing == null) {\n            // the lines are parallel,\n            final double global = otherLine.getOffset(thisLine);\n            return (global < -1.0e-10) ? Side.MINUS : ((global > 1.0e-10) ? Side.PLUS : Side.HYPER);\n        }\n\n        // the lines do intersect\n        final boolean direct = FastMath.sin(thisLine.getAngle() - otherLine.getAngle()) < 0;\n        final Vector1D x = thisLine.toSubSpace(crossing);\n        return getRemainingRegion().side(new OrientedPoint(x, direct));\n\n    }",
    "comment": "{@inheritDoc} */",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "SubLine.split",
    "class_name": "org.apache.commons.math3.geometry.euclidean.twod.SubLine",
    "signature": "org.apache.commons.math3.geometry.euclidean.twod.SubLine.split(Hyperplane)",
    "snippet": "    @Override\n    public SplitSubHyperplane<Euclidean2D> split(final Hyperplane<Euclidean2D> hyperplane) {\n\n        final Line    thisLine  = (Line) getHyperplane();\n        final Line    otherLine = (Line) hyperplane;\n        final Vector2D crossing  = thisLine.intersection(otherLine);\n\n        if (crossing == null) {\n            // the lines are parallel\n            final double global = otherLine.getOffset(thisLine);\n            return (global < -1.0e-10) ?\n                   new SplitSubHyperplane<Euclidean2D>(null, this) :\n                   new SplitSubHyperplane<Euclidean2D>(this, null);\n        }\n\n        // the lines do intersect\n        final boolean direct = FastMath.sin(thisLine.getAngle() - otherLine.getAngle()) < 0;\n        final Vector1D x      = thisLine.toSubSpace(crossing);\n        final SubHyperplane<Euclidean1D> subPlus  = new OrientedPoint(x, !direct).wholeHyperplane();\n        final SubHyperplane<Euclidean1D> subMinus = new OrientedPoint(x,  direct).wholeHyperplane();\n\n        final BSPTree<Euclidean1D> splitTree = getRemainingRegion().getTree(false).split(subMinus);\n        final BSPTree<Euclidean1D> plusTree  = getRemainingRegion().isEmpty(splitTree.getPlus()) ?\n                                               new BSPTree<Euclidean1D>(Boolean.FALSE) :\n                                               new BSPTree<Euclidean1D>(subPlus, new BSPTree<Euclidean1D>(Boolean.FALSE),\n                                                                        splitTree.getPlus(), null);\n        final BSPTree<Euclidean1D> minusTree = getRemainingRegion().isEmpty(splitTree.getMinus()) ?\n                                               new BSPTree<Euclidean1D>(Boolean.FALSE) :\n                                               new BSPTree<Euclidean1D>(subMinus, new BSPTree<Euclidean1D>(Boolean.FALSE),\n                                                                        splitTree.getMinus(), null);\n\n        return new SplitSubHyperplane<Euclidean2D>(new SubLine(thisLine.copySelf(), new IntervalsSet(plusTree)),\n                                                   new SubLine(thisLine.copySelf(), new IntervalsSet(minusTree)));\n\n    }",
    "comment": "{@inheritDoc} */",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "Vector2D.Vector2D",
    "class_name": "org.apache.commons.math3.geometry.euclidean.twod.Vector2D",
    "signature": "org.apache.commons.math3.geometry.euclidean.twod.Vector2D.Vector2D(double,double)",
    "snippet": "    public Vector2D(double x, double y) {\n        this.x = x;\n        this.y = y;\n    }",
    "comment": "Simple constructor. Build a vector from its coordinates @param x abscissa @param y ordinate @see #getX() @see #getY() ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "Vector2D.distance",
    "class_name": "org.apache.commons.math3.geometry.euclidean.twod.Vector2D",
    "signature": "org.apache.commons.math3.geometry.euclidean.twod.Vector2D.distance(Vector)",
    "snippet": "    public double distance(Vector<Euclidean2D> p) {\n        Vector2D p3 = (Vector2D) p;\n        final double dx = p3.x - x;\n        final double dy = p3.y - y;\n        return FastMath.sqrt(dx * dx + dy * dy);\n    }",
    "comment": "{@inheritDoc} */",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "Vector2D.getX",
    "class_name": "org.apache.commons.math3.geometry.euclidean.twod.Vector2D",
    "signature": "org.apache.commons.math3.geometry.euclidean.twod.Vector2D.getX()",
    "snippet": "    public double getX() {\n        return x;\n    }",
    "comment": "Get the abscissa of the vector. @return abscissa of the vector @see #Vector2D(double, double) ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "Vector2D.getY",
    "class_name": "org.apache.commons.math3.geometry.euclidean.twod.Vector2D",
    "signature": "org.apache.commons.math3.geometry.euclidean.twod.Vector2D.getY()",
    "snippet": "    public double getY() {\n        return y;\n    }",
    "comment": "Get the ordinate of the vector. @return ordinate of the vector @see #Vector2D(double, double) ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "AbstractRegion.AbstractRegion",
    "class_name": "org.apache.commons.math3.geometry.partitioning.AbstractRegion",
    "signature": "org.apache.commons.math3.geometry.partitioning.AbstractRegion.AbstractRegion()",
    "snippet": "    protected AbstractRegion() {\n        tree = new BSPTree<S>(Boolean.TRUE);\n    }",
    "comment": "Build a region representing the whole space. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "AbstractRegion.AbstractRegion",
    "class_name": "org.apache.commons.math3.geometry.partitioning.AbstractRegion",
    "signature": "org.apache.commons.math3.geometry.partitioning.AbstractRegion.AbstractRegion(BSPTree)",
    "snippet": "    protected AbstractRegion(final BSPTree<S> tree) {\n        this.tree = tree;\n    }",
    "comment": "Build a region from an inside/outside BSP tree. <p>The leaf nodes of the BSP tree <em>must</em> have a {@code Boolean} attribute representing the inside status of the corresponding cell (true for inside cells, false for outside cells). In order to avoid building too many small objects, it is recommended to use the predefined constants {@code Boolean.TRUE} and {@code Boolean.FALSE}. The tree also <em>must</em> have either null internal nodes or internal nodes representing the boundary as specified in the {@link #getTree getTree} method).</p> @param tree inside/outside BSP tree representing the region ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "AbstractRegion.AbstractRegion",
    "class_name": "org.apache.commons.math3.geometry.partitioning.AbstractRegion",
    "signature": "org.apache.commons.math3.geometry.partitioning.AbstractRegion.AbstractRegion(Collection)",
    "snippet": "    protected AbstractRegion(final Collection<SubHyperplane<S>> boundary) {\n\n        if (boundary.size() == 0) {\n\n            // the tree represents the whole space\n            tree = new BSPTree<S>(Boolean.TRUE);\n\n        } else {\n\n            // sort the boundary elements in decreasing size order\n            // (we don't want equal size elements to be removed, so\n            // we use a trick to fool the TreeSet)\n            final TreeSet<SubHyperplane<S>> ordered = new TreeSet<SubHyperplane<S>>(new Comparator<SubHyperplane<S>>() {\n                public int compare(final SubHyperplane<S> o1, final SubHyperplane<S> o2) {\n                    final double size1 = o1.getSize();\n                    final double size2 = o2.getSize();\n                    return (size2 < size1) ? -1 : ((o1 == o2) ? 0 : +1);\n                }\n            });\n            ordered.addAll(boundary);\n\n            // build the tree top-down\n            tree = new BSPTree<S>();\n            insertCuts(tree, ordered);\n\n            // set up the inside/outside flags\n            tree.visit(new BSPTreeVisitor<S>() {\n\n                /** {@inheritDoc} */\n                public Order visitOrder(final BSPTree<S> node) {\n                    return Order.PLUS_SUB_MINUS;\n                }\n\n                /** {@inheritDoc} */\n                public void visitInternalNode(final BSPTree<S> node) {\n                }\n\n                /** {@inheritDoc} */\n                public void visitLeafNode(final BSPTree<S> node) {\n                    node.setAttribute((node == node.getParent().getPlus()) ?\n                                                                            Boolean.FALSE : Boolean.TRUE);\n                }\n            });\n\n        }\n\n    }",
    "comment": "Build a Region from a Boundary REPresentation (B-rep). <p>The boundary is provided as a collection of {@link SubHyperplane sub-hyperplanes}. Each sub-hyperplane has the interior part of the region on its minus side and the exterior on its plus side.</p> <p>The boundary elements can be in any order, and can form several non-connected sets (like for example polygons with holes or a set of disjoints polyhedrons considered as a whole). In fact, the elements do not even need to be connected together (their topological connections are not used here). However, if the boundary does not really separate an inside open from an outside open (open having here its topological meaning), then subsequent calls to the {@link #checkPoint(Vector) checkPoint} method will not be meaningful anymore.</p> <p>If the boundary is empty, the region will represent the whole space.</p> @param boundary collection of boundary elements, as a collection of {@link SubHyperplane SubHyperplane} objects ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "AbstractRegion.characterize",
    "class_name": "org.apache.commons.math3.geometry.partitioning.AbstractRegion",
    "signature": "org.apache.commons.math3.geometry.partitioning.AbstractRegion.characterize(BSPTree,SubHyperplane,Characterization)",
    "snippet": "    private void characterize(final BSPTree<S> node, final SubHyperplane<S> sub,\n                              final Characterization<S> characterization) {\n        if (node.getCut() == null) {\n            // we have reached a leaf node\n            final boolean inside = (Boolean) node.getAttribute();\n            characterization.add(sub, inside);\n        } else {\n            final Hyperplane<S> hyperplane = node.getCut().getHyperplane();\n            switch (sub.side(hyperplane)) {\n            case PLUS:\n                characterize(node.getPlus(), sub, characterization);\n                break;\n            case MINUS:\n                characterize(node.getMinus(), sub, characterization);\n                break;\n            case BOTH:\n                final SubHyperplane.SplitSubHyperplane<S> split = sub.split(hyperplane);\n                characterize(node.getPlus(),  split.getPlus(),  characterization);\n                characterize(node.getMinus(), split.getMinus(), characterization);\n                break;\n            default:\n                // this should not happen\n                throw new MathInternalError();\n            }\n        }\n    }",
    "comment": "Filter the parts of an hyperplane belonging to the boundary. <p>The filtering consist in splitting the specified sub-hyperplane into several parts lying in inside and outside cells of the tree. The principle is to call this method twice for each cut sub-hyperplane in the tree, once one the plus node and once on the minus node. The parts that have the same flag (inside/inside or outside/outside) do not belong to the boundary while parts that have different flags (inside/outside or outside/inside) do belong to the boundary.</p> @param node current BSP tree node @param sub sub-hyperplane to characterize @param characterization placeholder where to put the characterized parts ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "AbstractRegion.checkPoint",
    "class_name": "org.apache.commons.math3.geometry.partitioning.AbstractRegion",
    "signature": "org.apache.commons.math3.geometry.partitioning.AbstractRegion.checkPoint(BSPTree,Vector)",
    "snippet": "    protected Location checkPoint(final BSPTree<S> node, final Vector<S> point) {\n        final BSPTree<S> cell = node.getCell(point);\n        if (cell.getCut() == null) {\n            // the point is in the interior of a cell, just check the attribute\n            return ((Boolean) cell.getAttribute()) ? Location.INSIDE : Location.OUTSIDE;\n        }\n\n        // the point is on a cut-sub-hyperplane, is it on a boundary ?\n        final Location minusCode = checkPoint(cell.getMinus(), point);\n        final Location plusCode  = checkPoint(cell.getPlus(),  point);\n        return (minusCode == plusCode) ? minusCode : Location.BOUNDARY;\n\n    }",
    "comment": "Check a point with respect to the region starting at a given node. @param node root node of the region @param point point to check @return a code representing the point status: either {@link Region.Location#INSIDE INSIDE}, {@link Region.Location#OUTSIDE OUTSIDE} or {@link Region.Location#BOUNDARY BOUNDARY} ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "AbstractRegion.getBarycenter",
    "class_name": "org.apache.commons.math3.geometry.partitioning.AbstractRegion",
    "signature": "org.apache.commons.math3.geometry.partitioning.AbstractRegion.getBarycenter()",
    "snippet": "    public Vector<S> getBarycenter() {\n        if (barycenter == null) {\n            computeGeometricalProperties();\n        }\n        return barycenter;\n    }",
    "comment": "{@inheritDoc} */",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "AbstractRegion.getSize",
    "class_name": "org.apache.commons.math3.geometry.partitioning.AbstractRegion",
    "signature": "org.apache.commons.math3.geometry.partitioning.AbstractRegion.getSize()",
    "snippet": "    public double getSize() {\n        if (barycenter == null) {\n            computeGeometricalProperties();\n        }\n        return size;\n    }",
    "comment": "{@inheritDoc} */",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "AbstractRegion.getTree",
    "class_name": "org.apache.commons.math3.geometry.partitioning.AbstractRegion",
    "signature": "org.apache.commons.math3.geometry.partitioning.AbstractRegion.getTree(boolean)",
    "snippet": "    public BSPTree<S> getTree(final boolean includeBoundaryAttributes) {\n        if (includeBoundaryAttributes && (tree.getCut() != null) && (tree.getAttribute() == null)) {\n            // we need to compute the boundary attributes\n            recurseBuildBoundary(tree);\n        }\n        return tree;\n    }",
    "comment": "{@inheritDoc} */",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "AbstractRegion.insertCuts",
    "class_name": "org.apache.commons.math3.geometry.partitioning.AbstractRegion",
    "signature": "org.apache.commons.math3.geometry.partitioning.AbstractRegion.insertCuts(BSPTree,Collection)",
    "snippet": "    private void insertCuts(final BSPTree<S> node, final Collection<SubHyperplane<S>> boundary) {\n\n        final Iterator<SubHyperplane<S>> iterator = boundary.iterator();\n\n        // build the current level\n        Hyperplane<S> inserted = null;\n        while ((inserted == null) && iterator.hasNext()) {\n            inserted = iterator.next().getHyperplane();\n            if (!node.insertCut(inserted.copySelf())) {\n                inserted = null;\n            }\n        }\n\n        if (!iterator.hasNext()) {\n            return;\n        }\n\n        // distribute the remaining edges in the two sub-trees\n        final ArrayList<SubHyperplane<S>> plusList  = new ArrayList<SubHyperplane<S>>();\n        final ArrayList<SubHyperplane<S>> minusList = new ArrayList<SubHyperplane<S>>();\n        while (iterator.hasNext()) {\n            final SubHyperplane<S> other = iterator.next();\n            switch (other.side(inserted)) {\n            case PLUS:\n                plusList.add(other);\n                break;\n            case MINUS:\n                minusList.add(other);\n                break;\n            case BOTH:\n                final SubHyperplane.SplitSubHyperplane<S> split = other.split(inserted);\n                plusList.add(split.getPlus());\n                minusList.add(split.getMinus());\n                break;\n            default:\n                // ignore the sub-hyperplanes belonging to the cut hyperplane\n            }\n        }\n\n        // recurse through lower levels\n        insertCuts(node.getPlus(),  plusList);\n        insertCuts(node.getMinus(), minusList);\n\n    }",
    "comment": "Recursively build a tree by inserting cut sub-hyperplanes. @param node current tree node (it is a leaf node at the beginning of the call) @param boundary collection of edges belonging to the cell defined by the node ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "AbstractRegion.isEmpty",
    "class_name": "org.apache.commons.math3.geometry.partitioning.AbstractRegion",
    "signature": "org.apache.commons.math3.geometry.partitioning.AbstractRegion.isEmpty()",
    "snippet": "    public boolean isEmpty() {\n        return isEmpty(tree);\n    }",
    "comment": "{@inheritDoc} */",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "AbstractRegion.isEmpty",
    "class_name": "org.apache.commons.math3.geometry.partitioning.AbstractRegion",
    "signature": "org.apache.commons.math3.geometry.partitioning.AbstractRegion.isEmpty(BSPTree)",
    "snippet": "    public boolean isEmpty(final BSPTree<S> node) {\n\n        // we use a recursive function rather than the BSPTreeVisitor\n        // interface because we can stop visiting the tree as soon as we\n        // have found an inside cell\n\n        if (node.getCut() == null) {\n            // if we find an inside node, the region is not empty\n            return !((Boolean) node.getAttribute());\n        }\n\n        // check both sides of the sub-tree\n        return isEmpty(node.getMinus()) && isEmpty(node.getPlus());\n\n    }",
    "comment": "{@inheritDoc} */",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "AbstractRegion.recurseBuildBoundary",
    "class_name": "org.apache.commons.math3.geometry.partitioning.AbstractRegion",
    "signature": "org.apache.commons.math3.geometry.partitioning.AbstractRegion.recurseBuildBoundary(BSPTree)",
    "snippet": "    private void recurseBuildBoundary(final BSPTree<S> node) {\n        if (node.getCut() != null) {\n\n            SubHyperplane<S> plusOutside = null;\n            SubHyperplane<S> plusInside  = null;\n\n            // characterize the cut sub-hyperplane,\n            // first with respect to the plus sub-tree\n            final Characterization<S> plusChar = new Characterization<S>();\n            characterize(node.getPlus(), node.getCut().copySelf(), plusChar);\n\n            if (plusChar.hasOut()) {\n                // plusChar.getOut() corresponds to a subset of the cut\n                // sub-hyperplane known to have outside cells on its plus\n                // side, we want to check if parts of this subset do have\n                // inside cells on their minus side\n                final Characterization<S> minusChar = new Characterization<S>();\n                characterize(node.getMinus(), plusChar.getOut(), minusChar);\n                if (minusChar.hasIn()) {\n                    plusOutside = minusChar.getIn();\n                }\n            }\n\n            if (plusChar.hasIn()) {\n                // plusChar.getIn() corresponds to a subset of the cut\n                // sub-hyperplane known to have inside cells on its plus\n                // side, we want to check if parts of this subset do have\n                // outside cells on their minus side\n                final Characterization<S> minusChar = new Characterization<S>();\n                characterize(node.getMinus(), plusChar.getIn(), minusChar);\n                if (minusChar.hasOut()) {\n                    plusInside = minusChar.getOut();\n                }\n            }\n\n            node.setAttribute(new BoundaryAttribute<S>(plusOutside, plusInside));\n            recurseBuildBoundary(node.getPlus());\n            recurseBuildBoundary(node.getMinus());\n\n        }\n    }",
    "comment": "Recursively build the boundary shell tree. @param node current node in the inout tree ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "AbstractRegion.recurseSides",
    "class_name": "org.apache.commons.math3.geometry.partitioning.AbstractRegion",
    "signature": "org.apache.commons.math3.geometry.partitioning.AbstractRegion.recurseSides(BSPTree,SubHyperplane,Sides)",
    "snippet": "    private void recurseSides(final BSPTree<S> node, final SubHyperplane<S> sub, final Sides sides) {\n\n        if (node.getCut() == null) {\n            if ((Boolean) node.getAttribute()) {\n                // this is an inside cell expanding across the hyperplane\n                sides.rememberPlusFound();\n                sides.rememberMinusFound();\n            }\n            return;\n        }\n\n        final Hyperplane<S> hyperplane = node.getCut().getHyperplane();\n        switch (sub.side(hyperplane)) {\n        case PLUS :\n            // the sub-hyperplane is entirely in the plus sub-tree\n            if (node.getCut().side(sub.getHyperplane()) == Side.PLUS) {\n                if (!isEmpty(node.getMinus())) {\n                    sides.rememberPlusFound();\n                }\n            } else {\n                if (!isEmpty(node.getMinus())) {\n                    sides.rememberMinusFound();\n                }\n            }\n            if (!(sides.plusFound() && sides.minusFound())) {\n                recurseSides(node.getPlus(), sub, sides);\n            }\n            break;\n        case MINUS :\n            // the sub-hyperplane is entirely in the minus sub-tree\n            if (node.getCut().side(sub.getHyperplane()) == Side.PLUS) {\n                if (!isEmpty(node.getPlus())) {\n                    sides.rememberPlusFound();\n                }\n            } else {\n                if (!isEmpty(node.getPlus())) {\n                    sides.rememberMinusFound();\n                }\n            }\n            if (!(sides.plusFound() && sides.minusFound())) {\n                recurseSides(node.getMinus(), sub, sides);\n            }\n            break;\n        case BOTH :\n            // the sub-hyperplane extends in both sub-trees\n            final SubHyperplane.SplitSubHyperplane<S> split = sub.split(hyperplane);\n\n            // explore first the plus sub-tree\n            recurseSides(node.getPlus(), split.getPlus(), sides);\n\n            // if needed, explore the minus sub-tree\n            if (!(sides.plusFound() && sides.minusFound())) {\n                recurseSides(node.getMinus(), split.getMinus(), sides);\n            }\n            break;\n        default :\n            // the sub-hyperplane and the cut sub-hyperplane share the same hyperplane\n            if (node.getCut().getHyperplane().sameOrientationAs(sub.getHyperplane())) {\n                if ((node.getPlus().getCut() != null) || ((Boolean) node.getPlus().getAttribute())) {\n                    sides.rememberPlusFound();\n                }\n                if ((node.getMinus().getCut() != null) || ((Boolean) node.getMinus().getAttribute())) {\n                    sides.rememberMinusFound();\n                }\n            } else {\n                if ((node.getPlus().getCut() != null) || ((Boolean) node.getPlus().getAttribute())) {\n                    sides.rememberMinusFound();\n                }\n                if ((node.getMinus().getCut() != null) || ((Boolean) node.getMinus().getAttribute())) {\n                    sides.rememberPlusFound();\n                }\n            }\n        }\n\n    }",
    "comment": "Search recursively for inside leaf nodes on each side of the given hyperplane.  <p>The algorithm used here is directly derived from the one described in section III (<i>Binary Partitioning of a BSP Tree</i>) of the Bruce Naylor, John Amanatides and William Thibault paper <a href=\"http://www.cs.yorku.ca/~amana/research/bsptSetOp.pdf\">Merging BSP Trees Yields Polyhedral Set Operations</a> Proc. Siggraph '90, Computer Graphics 24(4), August 1990, pp 115-124, published by the Association for Computing Machinery (ACM)..</p>  @param node current BSP tree node @param sub sub-hyperplane @param sides object holding the sides found ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "AbstractRegion.setBarycenter",
    "class_name": "org.apache.commons.math3.geometry.partitioning.AbstractRegion",
    "signature": "org.apache.commons.math3.geometry.partitioning.AbstractRegion.setBarycenter(Vector)",
    "snippet": "    protected void setBarycenter(final Vector<S> barycenter) {\n        this.barycenter = barycenter;\n    }",
    "comment": "Set the barycenter of the instance. @param barycenter barycenter of the instance ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "AbstractRegion.setSize",
    "class_name": "org.apache.commons.math3.geometry.partitioning.AbstractRegion",
    "signature": "org.apache.commons.math3.geometry.partitioning.AbstractRegion.setSize(double)",
    "snippet": "    protected void setSize(final double size) {\n        this.size = size;\n    }",
    "comment": "Set the size of the instance. @param size size of the instance ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "AbstractRegion.side",
    "class_name": "org.apache.commons.math3.geometry.partitioning.AbstractRegion",
    "signature": "org.apache.commons.math3.geometry.partitioning.AbstractRegion.side(Hyperplane)",
    "snippet": "    public Side side(final Hyperplane<S> hyperplane) {\n        final Sides sides = new Sides();\n        recurseSides(tree, hyperplane.wholeHyperplane(), sides);\n        return sides.plusFound() ?\n              (sides.minusFound() ? Side.BOTH  : Side.PLUS) :\n              (sides.minusFound() ? Side.MINUS : Side.HYPER);\n    }",
    "comment": "{@inheritDoc} */",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "Sides.minusFound",
    "class_name": "org.apache.commons.math3.geometry.partitioning.AbstractRegion$Sides",
    "signature": "org.apache.commons.math3.geometry.partitioning.AbstractRegion$Sides.minusFound()",
    "snippet": "        public boolean minusFound() {\n            return minusFound;\n        }",
    "comment": "Check if inside leaf nodes have been found on the minus side. @return true if inside leaf nodes have been found on the minus side ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "Sides.plusFound",
    "class_name": "org.apache.commons.math3.geometry.partitioning.AbstractRegion$Sides",
    "signature": "org.apache.commons.math3.geometry.partitioning.AbstractRegion$Sides.plusFound()",
    "snippet": "        public boolean plusFound() {\n            return plusFound;\n        }",
    "comment": "Check if inside leaf nodes have been found on the plus side. @return true if inside leaf nodes have been found on the plus side ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "Sides.rememberMinusFound",
    "class_name": "org.apache.commons.math3.geometry.partitioning.AbstractRegion$Sides",
    "signature": "org.apache.commons.math3.geometry.partitioning.AbstractRegion$Sides.rememberMinusFound()",
    "snippet": "        public void rememberMinusFound() {\n            minusFound = true;\n        }",
    "comment": "Remember the fact that inside leaf nodes have been found on the minus side. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "Sides.rememberPlusFound",
    "class_name": "org.apache.commons.math3.geometry.partitioning.AbstractRegion$Sides",
    "signature": "org.apache.commons.math3.geometry.partitioning.AbstractRegion$Sides.rememberPlusFound()",
    "snippet": "        public void rememberPlusFound() {\n            plusFound = true;\n        }",
    "comment": "Remember the fact that inside leaf nodes have been found on the plus side. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "AbstractSubHyperplane.AbstractSubHyperplane",
    "class_name": "org.apache.commons.math3.geometry.partitioning.AbstractSubHyperplane",
    "signature": "org.apache.commons.math3.geometry.partitioning.AbstractSubHyperplane.AbstractSubHyperplane(Hyperplane,Region)",
    "snippet": "    protected AbstractSubHyperplane(final Hyperplane<S> hyperplane,\n                                    final Region<T> remainingRegion) {\n        this.hyperplane      = hyperplane;\n        this.remainingRegion = remainingRegion;\n    }",
    "comment": "Build a sub-hyperplane from an hyperplane and a region. @param hyperplane underlying hyperplane @param remainingRegion remaining region of the hyperplane ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "AbstractSubHyperplane.copySelf",
    "class_name": "org.apache.commons.math3.geometry.partitioning.AbstractSubHyperplane",
    "signature": "org.apache.commons.math3.geometry.partitioning.AbstractSubHyperplane.copySelf()",
    "snippet": "    public AbstractSubHyperplane<S, T> copySelf() {\n        return buildNew(hyperplane, remainingRegion);\n    }",
    "comment": "{@inheritDoc} */",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "AbstractSubHyperplane.getHyperplane",
    "class_name": "org.apache.commons.math3.geometry.partitioning.AbstractSubHyperplane",
    "signature": "org.apache.commons.math3.geometry.partitioning.AbstractSubHyperplane.getHyperplane()",
    "snippet": "    public Hyperplane<S> getHyperplane() {\n        return hyperplane;\n    }",
    "comment": "Get the underlying hyperplane. @return underlying hyperplane ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "AbstractSubHyperplane.getRemainingRegion",
    "class_name": "org.apache.commons.math3.geometry.partitioning.AbstractSubHyperplane",
    "signature": "org.apache.commons.math3.geometry.partitioning.AbstractSubHyperplane.getRemainingRegion()",
    "snippet": "    public Region<T> getRemainingRegion() {\n        return remainingRegion;\n    }",
    "comment": "Get the remaining region of the hyperplane. <p>The returned region is expressed in the canonical hyperplane frame and has the hyperplane dimension. For example a chopped hyperplane in the 3D euclidean is a 2D plane and the corresponding region is a convex 2D polygon.</p> @return remaining region of the hyperplane ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "AbstractSubHyperplane.getSize",
    "class_name": "org.apache.commons.math3.geometry.partitioning.AbstractSubHyperplane",
    "signature": "org.apache.commons.math3.geometry.partitioning.AbstractSubHyperplane.getSize()",
    "snippet": "    public double getSize() {\n        return remainingRegion.getSize();\n    }",
    "comment": "{@inheritDoc} */",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "AbstractSubHyperplane.isEmpty",
    "class_name": "org.apache.commons.math3.geometry.partitioning.AbstractSubHyperplane",
    "signature": "org.apache.commons.math3.geometry.partitioning.AbstractSubHyperplane.isEmpty()",
    "snippet": "    public boolean isEmpty() {\n        return remainingRegion.isEmpty();\n    }",
    "comment": "{@inheritDoc} */",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "AbstractSubHyperplane.reunite",
    "class_name": "org.apache.commons.math3.geometry.partitioning.AbstractSubHyperplane",
    "signature": "org.apache.commons.math3.geometry.partitioning.AbstractSubHyperplane.reunite(SubHyperplane)",
    "snippet": "    public AbstractSubHyperplane<S, T> reunite(final SubHyperplane<S> other) {\n        @SuppressWarnings(\"unchecked\")\n        AbstractSubHyperplane<S, T> o = (AbstractSubHyperplane<S, T>) other;\n        return buildNew(hyperplane,\n                        new RegionFactory<T>().union(remainingRegion, o.remainingRegion));\n    }",
    "comment": "{@inheritDoc} */",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "BSPTree.BSPTree",
    "class_name": "org.apache.commons.math3.geometry.partitioning.BSPTree",
    "signature": "org.apache.commons.math3.geometry.partitioning.BSPTree.BSPTree()",
    "snippet": "    public BSPTree() {\n        cut       = null;\n        plus      = null;\n        minus     = null;\n        parent    = null;\n        attribute = null;\n    }",
    "comment": "Build a tree having only one root cell representing the whole space. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "BSPTree.BSPTree",
    "class_name": "org.apache.commons.math3.geometry.partitioning.BSPTree",
    "signature": "org.apache.commons.math3.geometry.partitioning.BSPTree.BSPTree(Object)",
    "snippet": "    public BSPTree(final Object attribute) {\n        cut    = null;\n        plus   = null;\n        minus  = null;\n        parent = null;\n        this.attribute = attribute;\n    }",
    "comment": "Build a tree having only one root cell representing the whole space. @param attribute attribute of the tree (may be null) ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "BSPTree.BSPTree",
    "class_name": "org.apache.commons.math3.geometry.partitioning.BSPTree",
    "signature": "org.apache.commons.math3.geometry.partitioning.BSPTree.BSPTree(SubHyperplane,BSPTree,BSPTree,Object)",
    "snippet": "    public BSPTree(final SubHyperplane<S> cut, final BSPTree<S> plus, final BSPTree<S> minus,\n                   final Object attribute) {\n        this.cut       = cut;\n        this.plus      = plus;\n        this.minus     = minus;\n        this.parent    = null;\n        this.attribute = attribute;\n        plus.parent    = this;\n        minus.parent   = this;\n    }",
    "comment": "Build a BSPTree from its underlying elements. <p>This method does <em>not</em> perform any verification on consistency of its arguments, it should therefore be used only when then caller knows what it is doing.</p> <p>This method is mainly useful kto build trees bottom-up. Building trees top-down is realized with the help of method {@link #insertCut insertCut}.</p> @param cut cut sub-hyperplane for the tree @param plus plus side sub-tree @param minus minus side sub-tree @param attribute attribute associated with the node (may be null) @see #insertCut ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "BSPTree.chopOffMinus",
    "class_name": "org.apache.commons.math3.geometry.partitioning.BSPTree",
    "signature": "org.apache.commons.math3.geometry.partitioning.BSPTree.chopOffMinus(Hyperplane)",
    "snippet": "    private void chopOffMinus(final Hyperplane<S> hyperplane) {\n        if (cut != null) {\n            cut = cut.split(hyperplane).getPlus();\n            plus.chopOffMinus(hyperplane);\n            minus.chopOffMinus(hyperplane);\n        }\n    }",
    "comment": "Chop off parts of the tree. <p>The instance is modified in place, all the parts that are on the minus side of the chopping hyperplane are discarded, only the parts on the plus side remain.</p> @param hyperplane chopping hyperplane ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "BSPTree.chopOffPlus",
    "class_name": "org.apache.commons.math3.geometry.partitioning.BSPTree",
    "signature": "org.apache.commons.math3.geometry.partitioning.BSPTree.chopOffPlus(Hyperplane)",
    "snippet": "    private void chopOffPlus(final Hyperplane<S> hyperplane) {\n        if (cut != null) {\n            cut = cut.split(hyperplane).getMinus();\n            plus.chopOffPlus(hyperplane);\n            minus.chopOffPlus(hyperplane);\n        }\n    }",
    "comment": "Chop off parts of the tree. <p>The instance is modified in place, all the parts that are on the plus side of the chopping hyperplane are discarded, only the parts on the minus side remain.</p> @param hyperplane chopping hyperplane ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "BSPTree.condense",
    "class_name": "org.apache.commons.math3.geometry.partitioning.BSPTree",
    "signature": "org.apache.commons.math3.geometry.partitioning.BSPTree.condense()",
    "snippet": "    private void condense() {\n        if ((cut != null) && (plus.cut == null) && (minus.cut == null) &&\n            (((plus.attribute == null) && (minus.attribute == null)) ||\n             ((plus.attribute != null) && plus.attribute.equals(minus.attribute)))) {\n            attribute = (plus.attribute == null) ? minus.attribute : plus.attribute;\n            cut       = null;\n            plus      = null;\n            minus     = null;\n        }\n    }",
    "comment": "Perform condensation on a tree. <p>The condensation operation is not recursive, it must be called explicitely from leaves to root.</p> ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "BSPTree.copySelf",
    "class_name": "org.apache.commons.math3.geometry.partitioning.BSPTree",
    "signature": "org.apache.commons.math3.geometry.partitioning.BSPTree.copySelf()",
    "snippet": "    public BSPTree<S> copySelf() {\n\n        if (cut == null) {\n            return new BSPTree<S>(attribute);\n        }\n\n        return new BSPTree<S>(cut.copySelf(), plus.copySelf(), minus.copySelf(),\n                           attribute);\n\n    }",
    "comment": "Copy the instance. <p>The instance created is completely independant of the original one. A deep copy is used, none of the underlying objects are shared (except for the nodes attributes and immutable objects).</p> @return a new tree, copy of the instance ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "BSPTree.fitToCell",
    "class_name": "org.apache.commons.math3.geometry.partitioning.BSPTree",
    "signature": "org.apache.commons.math3.geometry.partitioning.BSPTree.fitToCell(SubHyperplane)",
    "snippet": "    private SubHyperplane<S> fitToCell(final SubHyperplane<S> sub) {\n        SubHyperplane<S> s = sub;\n        for (BSPTree<S> tree = this; tree.parent != null; tree = tree.parent) {\n            if (tree == tree.parent.plus) {\n                s = s.split(tree.parent.cut.getHyperplane()).getPlus();\n            } else {\n                s = s.split(tree.parent.cut.getHyperplane()).getMinus();\n            }\n        }\n        return s;\n    }",
    "comment": "Fit a sub-hyperplane inside the cell defined by the instance. <p>Fitting is done by chopping off the parts of the sub-hyperplane that lie outside of the cell using the cut-hyperplanes of the parent nodes of the instance.</p> @param sub sub-hyperplane to fit @return a new sub-hyperplane, gueranteed to have no part outside of the instance cell ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "BSPTree.getAttribute",
    "class_name": "org.apache.commons.math3.geometry.partitioning.BSPTree",
    "signature": "org.apache.commons.math3.geometry.partitioning.BSPTree.getAttribute()",
    "snippet": "    public Object getAttribute() {\n        return attribute;\n    }",
    "comment": "Get the attribute associated with the instance. @return attribute associated with the node or null if no attribute has been explicitly set using the {@link #setAttribute setAttribute} method @see #setAttribute ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "BSPTree.getCell",
    "class_name": "org.apache.commons.math3.geometry.partitioning.BSPTree",
    "signature": "org.apache.commons.math3.geometry.partitioning.BSPTree.getCell(Vector)",
    "snippet": "    public BSPTree<S> getCell(final Vector<S> point) {\n\n        if (cut == null) {\n            return this;\n        }\n\n        // position of the point with respect to the cut hyperplane\n        final double offset = cut.getHyperplane().getOffset(point);\n\n        if (FastMath.abs(offset) < 1.0e-10) {\n            return this;\n        } else if (offset <= 0) {\n            // point is on the minus side of the cut hyperplane\n            return minus.getCell(point);\n        } else {\n            // point is on the plus side of the cut hyperplane\n            return plus.getCell(point);\n        }\n\n    }",
    "comment": "Get the cell to which a point belongs. <p>If the returned cell is a leaf node the points belongs to the interior of the node, if the cell is an internal node the points belongs to the node cut sub-hyperplane.</p> @param point point to check @return the tree cell to which the point belongs (can be ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "BSPTree.getCut",
    "class_name": "org.apache.commons.math3.geometry.partitioning.BSPTree",
    "signature": "org.apache.commons.math3.geometry.partitioning.BSPTree.getCut()",
    "snippet": "    public SubHyperplane<S> getCut() {\n        return cut;\n    }",
    "comment": "Get the cut sub-hyperplane. @return cut sub-hyperplane, null if this is a leaf tree ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "BSPTree.getMinus",
    "class_name": "org.apache.commons.math3.geometry.partitioning.BSPTree",
    "signature": "org.apache.commons.math3.geometry.partitioning.BSPTree.getMinus()",
    "snippet": "    public BSPTree<S> getMinus() {\n        return minus;\n    }",
    "comment": "Get the tree on the minus side of the cut hyperplane. @return tree on the minus side of the cut hyperplane, null if this is a leaf tree ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "BSPTree.getParent",
    "class_name": "org.apache.commons.math3.geometry.partitioning.BSPTree",
    "signature": "org.apache.commons.math3.geometry.partitioning.BSPTree.getParent()",
    "snippet": "    public BSPTree<S> getParent() {\n        return parent;\n    }",
    "comment": "Get the parent node. @return parent node, null if the node has no parents ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "BSPTree.getPlus",
    "class_name": "org.apache.commons.math3.geometry.partitioning.BSPTree",
    "signature": "org.apache.commons.math3.geometry.partitioning.BSPTree.getPlus()",
    "snippet": "    public BSPTree<S> getPlus() {\n        return plus;\n    }",
    "comment": "Get the tree on the plus side of the cut hyperplane. @return tree on the plus side of the cut hyperplane, null if this is a leaf tree ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "BSPTree.insertCut",
    "class_name": "org.apache.commons.math3.geometry.partitioning.BSPTree",
    "signature": "org.apache.commons.math3.geometry.partitioning.BSPTree.insertCut(Hyperplane)",
    "snippet": "    public boolean insertCut(final Hyperplane<S> hyperplane) {\n\n        if (cut != null) {\n            plus.parent  = null;\n            minus.parent = null;\n        }\n\n        final SubHyperplane<S> chopped = fitToCell(hyperplane.wholeHyperplane());\n        if (chopped.isEmpty()) {\n            cut          = null;\n            plus         = null;\n            minus        = null;\n            return false;\n        }\n\n        cut          = chopped;\n        plus         = new BSPTree<S>();\n        plus.parent  = this;\n        minus        = new BSPTree<S>();\n        minus.parent = this;\n        return true;\n\n    }",
    "comment": "Insert a cut sub-hyperplane in a node. <p>The sub-tree starting at this node will be completely overwritten. The new cut sub-hyperplane will be built from the intersection of the provided hyperplane with the cell. If the hyperplane does intersect the cell, the cell will have two children cells with {@code null} attributes on each side of the inserted cut sub-hyperplane. If the hyperplane does not intersect the cell then <em>no</em> cut hyperplane will be inserted and the cell will be changed to a leaf cell. The attribute of the node is never changed.</p> <p>This method is mainly useful when called on leaf nodes (i.e. nodes for which {@link #getCut getCut} returns {@code null}), in this case it provides a way to build a tree top-down (whereas the {@link #BSPTree(SubHyperplane, BSPTree, BSPTree, Object) 4 arguments constructor} is devoted to build trees bottom-up).</p> @param hyperplane hyperplane to insert, it will be chopped in order to fit in the cell defined by the parent nodes of the instance @return true if a cut sub-hyperplane has been inserted (i.e. if the cell now has two leaf child nodes) @see #BSPTree(SubHyperplane, BSPTree, BSPTree, Object) ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "BSPTree.insertInTree",
    "class_name": "org.apache.commons.math3.geometry.partitioning.BSPTree",
    "signature": "org.apache.commons.math3.geometry.partitioning.BSPTree.insertInTree(BSPTree,boolean)",
    "snippet": "    public void insertInTree(final BSPTree<S> parentTree, final boolean isPlusChild) {\n\n        // set up parent/child links\n        parent = parentTree;\n        if (parentTree != null) {\n            if (isPlusChild) {\n                parentTree.plus = this;\n            } else {\n                parentTree.minus = this;\n            }\n        }\n\n        // make sure the inserted tree lies in the cell defined by its parent nodes\n        if (cut != null) {\n\n            // explore the parent nodes from here towards tree root\n            for (BSPTree<S> tree = this; tree.parent != null; tree = tree.parent) {\n\n                // this is an hyperplane of some parent node\n                final Hyperplane<S> hyperplane = tree.parent.cut.getHyperplane();\n\n                // chop off the parts of the inserted tree that extend\n                // on the wrong side of this parent hyperplane\n                if (tree == tree.parent.plus) {\n                    cut = cut.split(hyperplane).getPlus();\n                    plus.chopOffMinus(hyperplane);\n                    minus.chopOffMinus(hyperplane);\n                } else {\n                    cut = cut.split(hyperplane).getMinus();\n                    plus.chopOffPlus(hyperplane);\n                    minus.chopOffPlus(hyperplane);\n                }\n\n            }\n\n            // since we may have drop some parts of the inserted tree,\n            // perform a condensation pass to keep the tree structure simple\n            condense();\n\n        }\n\n    }",
    "comment": "Insert the instance into another tree. <p>The instance itself is modified so its former parent should not be used anymore.</p> @param parentTree parent tree to connect to (may be null) @param isPlusChild if true and if parentTree is not null, the resulting tree should be the plus child of its parent, ignored if parentTree is null @see LeafMerger ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "BSPTree.merge",
    "class_name": "org.apache.commons.math3.geometry.partitioning.BSPTree",
    "signature": "org.apache.commons.math3.geometry.partitioning.BSPTree.merge(BSPTree,LeafMerger)",
    "snippet": "    public BSPTree<S> merge(final BSPTree<S> tree, final LeafMerger<S> leafMerger) {\n        return merge(tree, leafMerger, null, false);\n    }",
    "comment": "Merge a BSP tree with the instance. <p>All trees are modified (parts of them are reused in the new tree), it is the responsibility of the caller to ensure a copy has been done before if any of the former tree should be preserved, <em>no</em> such copy is done here!</p> <p>The algorithm used here is directly derived from the one described in the Naylor, Amanatides and Thibault paper (section III, Binary Partitioning of a BSP Tree).</p> @param tree other tree to merge with the instance (will be <em>unusable</em> after the operation, as well as the instance itself) @param leafMerger object implementing the final merging phase (this is where the semantic of the operation occurs, generally depending on the attribute of the leaf node) @return a new tree, result of <code>instance &lt;op&gt; tree</code>, this value can be ignored if parentTree is not null since all connections have already been established ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "BSPTree.merge",
    "class_name": "org.apache.commons.math3.geometry.partitioning.BSPTree",
    "signature": "org.apache.commons.math3.geometry.partitioning.BSPTree.merge(BSPTree,LeafMerger,BSPTree,boolean)",
    "snippet": "    private BSPTree<S> merge(final BSPTree<S> tree, final LeafMerger<S> leafMerger,\n                             final BSPTree<S> parentTree, final boolean isPlusChild) {\n        if (cut == null) {\n            // cell/tree operation\n            return leafMerger.merge(this, tree, parentTree, isPlusChild, true);\n        } else if (tree.cut == null) {\n            // tree/cell operation\n            return leafMerger.merge(tree, this, parentTree, isPlusChild, false);\n        } else {\n            // tree/tree operation\n            final BSPTree<S> merged = tree.split(cut);\n            if (parentTree != null) {\n                merged.parent = parentTree;\n                if (isPlusChild) {\n                    parentTree.plus = merged;\n                } else {\n                    parentTree.minus = merged;\n                }\n            }\n\n            // merging phase\n            plus.merge(merged.plus, leafMerger, merged, true);\n            minus.merge(merged.minus, leafMerger, merged, false);\n            merged.condense();\n            if (merged.cut != null) {\n                merged.cut =\n                    merged.fitToCell(merged.cut.getHyperplane().wholeHyperplane());\n            }\n\n            return merged;\n\n        }\n    }",
    "comment": "Merge a BSP tree with the instance. @param tree other tree to merge with the instance (will be <em>unusable</em> after the operation, as well as the instance itself) @param leafMerger object implementing the final merging phase (this is where the semantic of the operation occurs, generally depending on the attribute of the leaf node) @param parentTree parent tree to connect to (may be null) @param isPlusChild if true and if parentTree is not null, the resulting tree should be the plus child of its parent, ignored if parentTree is null @return a new tree, result of <code>instance &lt;op&gt; tree</code>, this value can be ignored if parentTree is not null since all connections have already been established ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "BSPTree.setAttribute",
    "class_name": "org.apache.commons.math3.geometry.partitioning.BSPTree",
    "signature": "org.apache.commons.math3.geometry.partitioning.BSPTree.setAttribute(Object)",
    "snippet": "    public void setAttribute(final Object attribute) {\n        this.attribute = attribute;\n    }",
    "comment": "Associate an attribute with the instance. @param attribute attribute to associate with the node @see #getAttribute ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "BSPTree.split",
    "class_name": "org.apache.commons.math3.geometry.partitioning.BSPTree",
    "signature": "org.apache.commons.math3.geometry.partitioning.BSPTree.split(SubHyperplane)",
    "snippet": "    public BSPTree<S> split(final SubHyperplane<S> sub) {\n\n        if (cut == null) {\n            return new BSPTree<S>(sub, copySelf(),\n                    new BSPTree<S>(attribute), null);\n        }\n\n        final Hyperplane<S> cHyperplane = cut.getHyperplane();\n        final Hyperplane<S> sHyperplane = sub.getHyperplane();\n        switch (sub.side(cHyperplane)) {\n        case PLUS :\n        { // the partitioning sub-hyperplane is entirely in the plus sub-tree\n            final BSPTree<S> split = plus.split(sub);\n            if (cut.side(sHyperplane) == Side.PLUS) {\n                split.plus =\n                    new BSPTree<S>(cut.copySelf(), split.plus, minus.copySelf(), attribute);\n                split.plus.condense();\n                split.plus.parent = split;\n            } else {\n                split.minus =\n                    new BSPTree<S>(cut.copySelf(), split.minus, minus.copySelf(), attribute);\n                split.minus.condense();\n                split.minus.parent = split;\n            }\n            return split;\n        }\n        case MINUS :\n        { // the partitioning sub-hyperplane is entirely in the minus sub-tree\n            final BSPTree<S> split = minus.split(sub);\n            if (cut.side(sHyperplane) == Side.PLUS) {\n                split.plus =\n                    new BSPTree<S>(cut.copySelf(), plus.copySelf(), split.plus, attribute);\n                split.plus.condense();\n                split.plus.parent = split;\n            } else {\n                split.minus =\n                    new BSPTree<S>(cut.copySelf(), plus.copySelf(), split.minus, attribute);\n                split.minus.condense();\n                split.minus.parent = split;\n            }\n            return split;\n        }\n        case BOTH :\n        {\n            final SubHyperplane.SplitSubHyperplane<S> cutParts = cut.split(sHyperplane);\n            final SubHyperplane.SplitSubHyperplane<S> subParts = sub.split(cHyperplane);\n            final BSPTree<S> split =\n                new BSPTree<S>(sub, plus.split(subParts.getPlus()), minus.split(subParts.getMinus()),\n                               null);\n            split.plus.cut          = cutParts.getPlus();\n            split.minus.cut         = cutParts.getMinus();\n            final BSPTree<S> tmp    = split.plus.minus;\n            split.plus.minus        = split.minus.plus;\n            split.plus.minus.parent = split.plus;\n            split.minus.plus        = tmp;\n            split.minus.plus.parent = split.minus;\n            split.plus.condense();\n            split.minus.condense();\n            return split;\n        }\n        default :\n            return cHyperplane.sameOrientationAs(sHyperplane) ?\n                   new BSPTree<S>(sub, plus.copySelf(),  minus.copySelf(), attribute) :\n                   new BSPTree<S>(sub, minus.copySelf(), plus.copySelf(),  attribute);\n        }\n\n    }",
    "comment": "Split a BSP tree by an external sub-hyperplane. <p>Split a tree in two halves, on each side of the sub-hyperplane. The instance is not modified.</p> <p>The tree returned is not upward-consistent: despite all of its sub-trees cut sub-hyperplanes (including its own cut sub-hyperplane) are bounded to the current cell, it is <em>not</em> attached to any parent tree yet. This tree is intended to be later inserted into an higher level tree.</p> <p>The algorithm used here is the one given in Naylor, Amanatides and Thibault paper (section III, Binary Partitioning of a BSP Tree).</p> @param sub partitioning sub-hyperplane, must be already clipped to the convex region represented by the instance, will be used as the cut sub-hyperplane of the returned tree @return a tree having the specified sub-hyperplane as its cut sub-hyperplane, the two parts of the split instance as its two sub-trees and a null parent ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "BSPTree.visit",
    "class_name": "org.apache.commons.math3.geometry.partitioning.BSPTree",
    "signature": "org.apache.commons.math3.geometry.partitioning.BSPTree.visit(BSPTreeVisitor)",
    "snippet": "    public void visit(final BSPTreeVisitor<S> visitor) {\n        if (cut == null) {\n            visitor.visitLeafNode(this);\n        } else {\n            switch (visitor.visitOrder(this)) {\n            case PLUS_MINUS_SUB:\n                plus.visit(visitor);\n                minus.visit(visitor);\n                visitor.visitInternalNode(this);\n                break;\n            case PLUS_SUB_MINUS:\n                plus.visit(visitor);\n                visitor.visitInternalNode(this);\n                minus.visit(visitor);\n                break;\n            case MINUS_PLUS_SUB:\n                minus.visit(visitor);\n                plus.visit(visitor);\n                visitor.visitInternalNode(this);\n                break;\n            case MINUS_SUB_PLUS:\n                minus.visit(visitor);\n                visitor.visitInternalNode(this);\n                plus.visit(visitor);\n                break;\n            case SUB_PLUS_MINUS:\n                visitor.visitInternalNode(this);\n                plus.visit(visitor);\n                minus.visit(visitor);\n                break;\n            case SUB_MINUS_PLUS:\n                visitor.visitInternalNode(this);\n                minus.visit(visitor);\n                plus.visit(visitor);\n                break;\n            default:\n                throw new MathInternalError();\n            }\n\n        }\n    }",
    "comment": "Visit the BSP tree nodes. @param visitor object visiting the tree nodes ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "BoundaryAttribute.BoundaryAttribute",
    "class_name": "org.apache.commons.math3.geometry.partitioning.BoundaryAttribute",
    "signature": "org.apache.commons.math3.geometry.partitioning.BoundaryAttribute.BoundaryAttribute(SubHyperplane,SubHyperplane)",
    "snippet": "    public BoundaryAttribute(final SubHyperplane<S> plusOutside,\n                             final SubHyperplane<S> plusInside) {\n        this.plusOutside = plusOutside;\n        this.plusInside  = plusInside;\n    }",
    "comment": "Simple constructor. @param plusOutside part of the node cut sub-hyperplane that belongs to the boundary and has the outside of the region on the plus side of its underlying hyperplane (may be null) @param plusInside part of the node cut sub-hyperplane that belongs to the boundary and has the inside of the region on the plus side of its underlying hyperplane (may be null) ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "BoundaryAttribute.getPlusInside",
    "class_name": "org.apache.commons.math3.geometry.partitioning.BoundaryAttribute",
    "signature": "org.apache.commons.math3.geometry.partitioning.BoundaryAttribute.getPlusInside()",
    "snippet": "    public SubHyperplane<S> getPlusInside() {\n        return plusInside;\n    }",
    "comment": "Get the part of the node cut sub-hyperplane that belongs to the boundary and has the inside of the region on the plus side of its underlying hyperplane. @return part of the node cut sub-hyperplane that belongs to the boundary and has the inside of the region on the plus side of its underlying hyperplane ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "BoundaryAttribute.getPlusOutside",
    "class_name": "org.apache.commons.math3.geometry.partitioning.BoundaryAttribute",
    "signature": "org.apache.commons.math3.geometry.partitioning.BoundaryAttribute.getPlusOutside()",
    "snippet": "    public SubHyperplane<S> getPlusOutside() {\n        return plusOutside;\n    }",
    "comment": "Get the part of the node cut sub-hyperplane that belongs to the boundary and has the outside of the region on the plus side of its underlying hyperplane. @return part of the node cut sub-hyperplane that belongs to the boundary and has the outside of the region on the plus side of its underlying hyperplane ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "Characterization.Characterization",
    "class_name": "org.apache.commons.math3.geometry.partitioning.Characterization",
    "signature": "org.apache.commons.math3.geometry.partitioning.Characterization.Characterization()",
    "snippet": "    public Characterization() {\n        in  = null;\n        out = null;\n    }",
    "comment": "Create an empty characterization of a sub-hyperplane. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "Characterization.add",
    "class_name": "org.apache.commons.math3.geometry.partitioning.Characterization",
    "signature": "org.apache.commons.math3.geometry.partitioning.Characterization.add(SubHyperplane,boolean)",
    "snippet": "    public void add(final SubHyperplane<S> sub, final boolean inside) {\n        if (inside) {\n            if (in == null) {\n                in = sub;\n            } else {\n                in = in.reunite(sub);\n            }\n        } else {\n            if (out == null) {\n                out = sub;\n            } else {\n                out = out.reunite(sub);\n            }\n        }\n    }",
    "comment": "Add a part of the sub-hyperplane known to have inside or outside cell on the tested side. @param sub part of the sub-hyperplane to add @param inside if true, the part added as an inside cell on the tested side, otherwise it has an outside cell on the tested side ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "Characterization.getIn",
    "class_name": "org.apache.commons.math3.geometry.partitioning.Characterization",
    "signature": "org.apache.commons.math3.geometry.partitioning.Characterization.getIn()",
    "snippet": "    public SubHyperplane<S> getIn() {\n        return in;\n    }",
    "comment": "Get the parts of the sub-hyperplane that have inside cells on the tested side. @return parts of the sub-hyperplane that have inside cells on the tested side ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "Characterization.getOut",
    "class_name": "org.apache.commons.math3.geometry.partitioning.Characterization",
    "signature": "org.apache.commons.math3.geometry.partitioning.Characterization.getOut()",
    "snippet": "    public SubHyperplane<S> getOut() {\n        return out;\n    }",
    "comment": "Get the parts of the sub-hyperplane that have outside cells on the tested side. @return parts of the sub-hyperplane that have outside cells on the tested side ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "Characterization.hasIn",
    "class_name": "org.apache.commons.math3.geometry.partitioning.Characterization",
    "signature": "org.apache.commons.math3.geometry.partitioning.Characterization.hasIn()",
    "snippet": "    public boolean hasIn() {\n        return (in != null) && (!in.isEmpty());\n    }",
    "comment": "Check if the sub-hyperplane that have inside cells on the tested side. @return true if the sub-hyperplane that have inside cells on the tested side ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "Characterization.hasOut",
    "class_name": "org.apache.commons.math3.geometry.partitioning.Characterization",
    "signature": "org.apache.commons.math3.geometry.partitioning.Characterization.hasOut()",
    "snippet": "    public boolean hasOut() {\n        return (out != null) && (!out.isEmpty());\n    }",
    "comment": "Check if the sub-hyperplane that have outside cells on the tested side. @return true if the sub-hyperplane that have outside cells on the tested side ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "RegionFactory.RegionFactory",
    "class_name": "org.apache.commons.math3.geometry.partitioning.RegionFactory",
    "signature": "org.apache.commons.math3.geometry.partitioning.RegionFactory.RegionFactory()",
    "snippet": "    public RegionFactory() {\n        nodeCleaner = new NodesCleaner();\n    }",
    "comment": "Simple constructor. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "RegionFactory.union",
    "class_name": "org.apache.commons.math3.geometry.partitioning.RegionFactory",
    "signature": "org.apache.commons.math3.geometry.partitioning.RegionFactory.union(Region,Region)",
    "snippet": "    public Region<S> union(final Region<S> region1, final Region<S> region2) {\n        final BSPTree<S> tree =\n            region1.getTree(false).merge(region2.getTree(false), new UnionMerger());\n        tree.visit(nodeCleaner);\n        return region1.buildNew(tree);\n    }",
    "comment": "Compute the union of two regions. @param region1 first region (will be unusable after the operation as parts of it will be reused in the new region) @param region2 second region (will be unusable after the operation as parts of it will be reused in the new region) @return a new region, result of {@code region1 union region2} ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "NodesCleaner.visitInternalNode",
    "class_name": "org.apache.commons.math3.geometry.partitioning.RegionFactory$NodesCleaner",
    "signature": "org.apache.commons.math3.geometry.partitioning.RegionFactory$NodesCleaner.visitInternalNode(BSPTree)",
    "snippet": "        public void visitInternalNode(final BSPTree<S> node) {\n            node.setAttribute(null);\n        }",
    "comment": "{@inheritDoc} */",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "NodesCleaner.visitLeafNode",
    "class_name": "org.apache.commons.math3.geometry.partitioning.RegionFactory$NodesCleaner",
    "signature": "org.apache.commons.math3.geometry.partitioning.RegionFactory$NodesCleaner.visitLeafNode(BSPTree)",
    "snippet": "        public void visitLeafNode(final BSPTree<S> node) {\n        }",
    "comment": "{@inheritDoc} */",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "NodesCleaner.visitOrder",
    "class_name": "org.apache.commons.math3.geometry.partitioning.RegionFactory$NodesCleaner",
    "signature": "org.apache.commons.math3.geometry.partitioning.RegionFactory$NodesCleaner.visitOrder(BSPTree)",
    "snippet": "        public Order visitOrder(final BSPTree<S> node) {\n            return Order.PLUS_SUB_MINUS;\n        }",
    "comment": "{@inheritDoc} */",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "UnionMerger.merge",
    "class_name": "org.apache.commons.math3.geometry.partitioning.RegionFactory$UnionMerger",
    "signature": "org.apache.commons.math3.geometry.partitioning.RegionFactory$UnionMerger.merge(BSPTree,BSPTree,BSPTree,boolean,boolean)",
    "snippet": "        public BSPTree<S> merge(final BSPTree<S> leaf, final BSPTree<S> tree,\n                                final BSPTree<S> parentTree,\n                                final boolean isPlusChild, final boolean leafFromInstance) {\n            if ((Boolean) leaf.getAttribute()) {\n                // the leaf node represents an inside cell\n                leaf.insertInTree(parentTree, isPlusChild);\n                return leaf;\n            }\n            // the leaf node represents an outside cell\n            tree.insertInTree(parentTree, isPlusChild);\n            return tree;\n        }",
    "comment": "{@inheritDoc} */",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "SplitSubHyperplane.getMinus",
    "class_name": "org.apache.commons.math3.geometry.partitioning.SubHyperplane$SplitSubHyperplane",
    "signature": "org.apache.commons.math3.geometry.partitioning.SubHyperplane$SplitSubHyperplane.getMinus()",
    "snippet": "        public SubHyperplane<U> getMinus() {\n            return minus;\n        }",
    "comment": "Get the part of the sub-hyperplane on the minus side of the splitting hyperplane. @return part of the sub-hyperplane on the minus side of the splitting hyperplane ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "SplitSubHyperplane.getPlus",
    "class_name": "org.apache.commons.math3.geometry.partitioning.SubHyperplane$SplitSubHyperplane",
    "signature": "org.apache.commons.math3.geometry.partitioning.SubHyperplane$SplitSubHyperplane.getPlus()",
    "snippet": "        public SubHyperplane<U> getPlus() {\n            return plus;\n        }",
    "comment": "Get the part of the sub-hyperplane on the plus side of the splitting hyperplane. @return part of the sub-hyperplane on the plus side of the splitting hyperplane ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "AVLTree.AVLTree",
    "class_name": "org.apache.commons.math3.geometry.partitioning.utilities.AVLTree",
    "signature": "org.apache.commons.math3.geometry.partitioning.utilities.AVLTree.AVLTree()",
    "snippet": "    public AVLTree() {\n        top = null;\n    }",
    "comment": "Build an empty tree. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "AVLTree.getSmallest",
    "class_name": "org.apache.commons.math3.geometry.partitioning.utilities.AVLTree",
    "signature": "org.apache.commons.math3.geometry.partitioning.utilities.AVLTree.getSmallest()",
    "snippet": "    public Node getSmallest() {\n        return (top == null) ? null : top.getSmallest();\n    }",
    "comment": "Get the node whose element is the smallest one in the tree. @return the tree node containing the smallest element in the tree or null if the tree is empty @see #getLargest @see #getNotSmaller @see #getNotLarger @see Node#getPrevious @see Node#getNext ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "AVLTree.isEmpty",
    "class_name": "org.apache.commons.math3.geometry.partitioning.utilities.AVLTree",
    "signature": "org.apache.commons.math3.geometry.partitioning.utilities.AVLTree.isEmpty()",
    "snippet": "    public boolean isEmpty() {\n        return top == null;\n    }",
    "comment": "Check if the tree is empty. @return true if the tree is empty ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "Node.delete",
    "class_name": "org.apache.commons.math3.geometry.partitioning.utilities.AVLTree$Node",
    "signature": "org.apache.commons.math3.geometry.partitioning.utilities.AVLTree$Node.delete()",
    "snippet": "        public void delete() {\n            if ((parent == null) && (left == null) && (right == null)) {\n                // this was the last node, the tree is now empty\n                element = null;\n                top     = null;\n            } else {\n\n                Node node;\n                Node child;\n                boolean leftShrunk;\n                if ((left == null) && (right == null)) {\n                    node       = this;\n                    element    = null;\n                    leftShrunk = node == node.parent.left;\n                    child      = null;\n                } else {\n                    node       = (left != null) ? left.getLargest() : right.getSmallest();\n                    element    = node.element;\n                    leftShrunk = node == node.parent.left;\n                    child      = (node.left != null) ? node.left : node.right;\n                }\n\n                node = node.parent;\n                if (leftShrunk) {\n                    node.left = child;\n                } else {\n                    node.right = child;\n                }\n                if (child != null) {\n                    child.parent = node;\n                }\n\n                while (leftShrunk ? node.rebalanceLeftShrunk() : node.rebalanceRightShrunk()) {\n                    if (node.parent == null) {\n                        return;\n                    }\n                    leftShrunk = node == node.parent.left;\n                    node = node.parent;\n                }\n\n            }\n        }",
    "comment": "Delete the node from the tree. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "Node.getElement",
    "class_name": "org.apache.commons.math3.geometry.partitioning.utilities.AVLTree$Node",
    "signature": "org.apache.commons.math3.geometry.partitioning.utilities.AVLTree$Node.getElement()",
    "snippet": "        public T getElement() {\n            return element;\n        }",
    "comment": "Get the contained element. @return element contained in the node ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "Node.getLargest",
    "class_name": "org.apache.commons.math3.geometry.partitioning.utilities.AVLTree$Node",
    "signature": "org.apache.commons.math3.geometry.partitioning.utilities.AVLTree$Node.getLargest()",
    "snippet": "        Node getLargest() {\n            Node node = this;\n            while (node.right != null) {\n                node = node.right;\n            }\n            return node;\n        }",
    "comment": "Get the node whose element is the largest one in the tree rooted at this node. @return the tree node containing the largest element in the tree rooted at this node or null if the tree is empty @see #getSmallest ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "Node.getNext",
    "class_name": "org.apache.commons.math3.geometry.partitioning.utilities.AVLTree$Node",
    "signature": "org.apache.commons.math3.geometry.partitioning.utilities.AVLTree$Node.getNext()",
    "snippet": "        public Node getNext() {\n\n            if (right != null) {\n                final Node node = right.getSmallest();\n                if (node != null) {\n                    return node;\n                }\n            }\n\n            for (Node node = this; node.parent != null; node = node.parent) {\n                if (node != node.parent.right) {\n                    return node.parent;\n                }\n            }\n\n            return null;\n\n        }",
    "comment": "Get the node containing the next larger or equal element. @return node containing the next larger or equal element (in which case the node is guaranteed not to be empty) or null if there is no larger or equal element in the tree @see #getPrevious ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "Node.getSmallest",
    "class_name": "org.apache.commons.math3.geometry.partitioning.utilities.AVLTree$Node",
    "signature": "org.apache.commons.math3.geometry.partitioning.utilities.AVLTree$Node.getSmallest()",
    "snippet": "        Node getSmallest() {\n            Node node = this;\n            while (node.left != null) {\n                node = node.left;\n            }\n            return node;\n        }",
    "comment": "Get the node whose element is the smallest one in the tree rooted at this node. @return the tree node containing the smallest element in the tree rooted at this node or null if the tree is empty @see #getLargest ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "Node.rebalanceLeftGrown",
    "class_name": "org.apache.commons.math3.geometry.partitioning.utilities.AVLTree$Node",
    "signature": "org.apache.commons.math3.geometry.partitioning.utilities.AVLTree$Node.rebalanceLeftGrown()",
    "snippet": "        private boolean rebalanceLeftGrown() {\n            switch (skew) {\n            case LEFT_HIGH:\n                if (left.skew == Skew.LEFT_HIGH) {\n                    rotateCW();\n                    skew       = Skew.BALANCED;\n                    right.skew = Skew.BALANCED;\n                } else {\n                    final Skew s = left.right.skew;\n                    left.rotateCCW();\n                    rotateCW();\n                    switch(s) {\n                    case LEFT_HIGH:\n                        left.skew  = Skew.BALANCED;\n                        right.skew = Skew.RIGHT_HIGH;\n                        break;\n                    case RIGHT_HIGH:\n                        left.skew  = Skew.LEFT_HIGH;\n                        right.skew = Skew.BALANCED;\n                        break;\n                    default:\n                        left.skew  = Skew.BALANCED;\n                        right.skew = Skew.BALANCED;\n                    }\n                    skew = Skew.BALANCED;\n                }\n                return false;\n            case RIGHT_HIGH:\n                skew = Skew.BALANCED;\n                return false;\n            default:\n                skew = Skew.LEFT_HIGH;\n                return true;\n            }\n        }",
    "comment": "Re-balance the instance as left sub-tree has grown. @return true if the parent tree should be reSkew.BALANCED too ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "Node.rebalanceLeftShrunk",
    "class_name": "org.apache.commons.math3.geometry.partitioning.utilities.AVLTree$Node",
    "signature": "org.apache.commons.math3.geometry.partitioning.utilities.AVLTree$Node.rebalanceLeftShrunk()",
    "snippet": "        private boolean rebalanceLeftShrunk() {\n            switch (skew) {\n            case LEFT_HIGH:\n                skew = Skew.BALANCED;\n                return true;\n            case RIGHT_HIGH:\n                if (right.skew == Skew.RIGHT_HIGH) {\n                    rotateCCW();\n                    skew      = Skew.BALANCED;\n                    left.skew = Skew.BALANCED;\n                    return true;\n                } else if (right.skew == Skew.BALANCED) {\n                    rotateCCW();\n                    skew      = Skew.LEFT_HIGH;\n                    left.skew = Skew.RIGHT_HIGH;\n                    return false;\n                } else {\n                    final Skew s = right.left.skew;\n                    right.rotateCW();\n                    rotateCCW();\n                    switch (s) {\n                    case LEFT_HIGH:\n                        left.skew  = Skew.BALANCED;\n                        right.skew = Skew.RIGHT_HIGH;\n                        break;\n                    case RIGHT_HIGH:\n                        left.skew  = Skew.LEFT_HIGH;\n                        right.skew = Skew.BALANCED;\n                        break;\n                    default:\n                        left.skew  = Skew.BALANCED;\n                        right.skew = Skew.BALANCED;\n                    }\n                    skew = Skew.BALANCED;\n                    return true;\n                }\n            default:\n                skew = Skew.RIGHT_HIGH;\n                return false;\n            }\n        }",
    "comment": "Re-balance the instance as left sub-tree has shrunk. @return true if the parent tree should be reSkew.BALANCED too ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "Node.rebalanceRightGrown",
    "class_name": "org.apache.commons.math3.geometry.partitioning.utilities.AVLTree$Node",
    "signature": "org.apache.commons.math3.geometry.partitioning.utilities.AVLTree$Node.rebalanceRightGrown()",
    "snippet": "        private boolean rebalanceRightGrown() {\n            switch (skew) {\n            case LEFT_HIGH:\n                skew = Skew.BALANCED;\n                return false;\n            case RIGHT_HIGH:\n                if (right.skew == Skew.RIGHT_HIGH) {\n                    rotateCCW();\n                    skew      = Skew.BALANCED;\n                    left.skew = Skew.BALANCED;\n                } else {\n                    final Skew s = right.left.skew;\n                    right.rotateCW();\n                    rotateCCW();\n                    switch (s) {\n                    case LEFT_HIGH:\n                        left.skew  = Skew.BALANCED;\n                        right.skew = Skew.RIGHT_HIGH;\n                        break;\n                    case RIGHT_HIGH:\n                        left.skew  = Skew.LEFT_HIGH;\n                        right.skew = Skew.BALANCED;\n                        break;\n                    default:\n                        left.skew  = Skew.BALANCED;\n                        right.skew = Skew.BALANCED;\n                    }\n                    skew = Skew.BALANCED;\n                }\n                return false;\n            default:\n                skew = Skew.RIGHT_HIGH;\n                return true;\n            }\n        }",
    "comment": "Re-balance the instance as right sub-tree has grown. @return true if the parent tree should be reSkew.BALANCED too ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "Node.rebalanceRightShrunk",
    "class_name": "org.apache.commons.math3.geometry.partitioning.utilities.AVLTree$Node",
    "signature": "org.apache.commons.math3.geometry.partitioning.utilities.AVLTree$Node.rebalanceRightShrunk()",
    "snippet": "        private boolean rebalanceRightShrunk() {\n            switch (skew) {\n            case RIGHT_HIGH:\n                skew = Skew.BALANCED;\n                return true;\n            case LEFT_HIGH:\n                if (left.skew == Skew.LEFT_HIGH) {\n                    rotateCW();\n                    skew       = Skew.BALANCED;\n                    right.skew = Skew.BALANCED;\n                    return true;\n                } else if (left.skew == Skew.BALANCED) {\n                    rotateCW();\n                    skew       = Skew.RIGHT_HIGH;\n                    right.skew = Skew.LEFT_HIGH;\n                    return false;\n                } else {\n                    final Skew s = left.right.skew;\n                    left.rotateCCW();\n                    rotateCW();\n                    switch (s) {\n                    case LEFT_HIGH:\n                        left.skew  = Skew.BALANCED;\n                        right.skew = Skew.RIGHT_HIGH;\n                        break;\n                    case RIGHT_HIGH:\n                        left.skew  = Skew.LEFT_HIGH;\n                        right.skew = Skew.BALANCED;\n                        break;\n                    default:\n                        left.skew  = Skew.BALANCED;\n                        right.skew = Skew.BALANCED;\n                    }\n                    skew = Skew.BALANCED;\n                    return true;\n                }\n            default:\n                skew = Skew.LEFT_HIGH;\n                return false;\n            }\n        }",
    "comment": "Re-balance the instance as right sub-tree has shrunk. @return true if the parent tree should be reSkew.BALANCED too ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "Node.rotateCCW",
    "class_name": "org.apache.commons.math3.geometry.partitioning.utilities.AVLTree$Node",
    "signature": "org.apache.commons.math3.geometry.partitioning.utilities.AVLTree$Node.rotateCCW()",
    "snippet": "        private void rotateCCW() {\n\n            final T tmpElt        = element;\n            element               = right.element;\n            right.element         = tmpElt;\n\n            final Node tmpNode    = right;\n            right                 = tmpNode.right;\n            tmpNode.right         = tmpNode.left;\n            tmpNode.left          = left;\n            left                  = tmpNode;\n\n            if (right != null) {\n                right.parent = this;\n            }\n            if (left.left != null) {\n                left.left.parent = left;\n            }\n\n        }",
    "comment": "Perform a counter-clockwise rotation rooted at the instance. <p>The skew factor are not updated by this method, they <em>must</em> be updated by the caller</p> ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "Node.rotateCW",
    "class_name": "org.apache.commons.math3.geometry.partitioning.utilities.AVLTree$Node",
    "signature": "org.apache.commons.math3.geometry.partitioning.utilities.AVLTree$Node.rotateCW()",
    "snippet": "        private void rotateCW() {\n\n            final T tmpElt       = element;\n            element              = left.element;\n            left.element         = tmpElt;\n\n            final Node tmpNode   = left;\n            left                 = tmpNode.left;\n            tmpNode.left         = tmpNode.right;\n            tmpNode.right        = right;\n            right                = tmpNode;\n\n            if (left != null) {\n                left.parent = this;\n            }\n            if (right.right != null) {\n                right.right.parent = right;\n            }\n\n        }",
    "comment": "Perform a clockwise rotation rooted at the instance. <p>The skew factor are not updated by this method, they <em>must</em> be updated by the caller</p> ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "OrderedTuple.OrderedTuple",
    "class_name": "org.apache.commons.math3.geometry.partitioning.utilities.OrderedTuple",
    "signature": "org.apache.commons.math3.geometry.partitioning.utilities.OrderedTuple.OrderedTuple(double[])",
    "snippet": "    public OrderedTuple(final double ... components) {\n        this.components = components.clone();\n        int msb = Integer.MIN_VALUE;\n        lsb     = Integer.MAX_VALUE;\n        posInf  = false;\n        negInf  = false;\n        nan     = false;\n        for (int i = 0; i < components.length; ++i) {\n            if (Double.isInfinite(components[i])) {\n                if (components[i] < 0) {\n                    negInf = true;\n                } else {\n                    posInf = true;\n                }\n            } else if (Double.isNaN(components[i])) {\n                nan = true;\n            } else {\n                final long b = Double.doubleToLongBits(components[i]);\n                final long m = mantissa(b);\n                if (m != 0) {\n                    final int e = exponent(b);\n                    msb = FastMath.max(msb, e + computeMSB(m));\n                    lsb = FastMath.min(lsb, e + computeLSB(m));\n                }\n            }\n        }\n\n        if (posInf && negInf) {\n            // instance cannot be sorted logically\n            posInf = false;\n            negInf = false;\n            nan    = true;\n        }\n\n        if (lsb <= msb) {\n            // encode the T-upple with the specified offset\n            encode(msb + 16);\n        } else {\n            encoding = new long[] {\n                0x0L\n            };\n        }\n\n    }",
    "comment": "Build an ordered T-uple from its components. @param components double components of the T-uple ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "OrderedTuple.compareTo",
    "class_name": "org.apache.commons.math3.geometry.partitioning.utilities.OrderedTuple",
    "signature": "org.apache.commons.math3.geometry.partitioning.utilities.OrderedTuple.compareTo(OrderedTuple)",
    "snippet": "    public int compareTo(final OrderedTuple ot) {\n        if (components.length == ot.components.length) {\n            if (nan) {\n                return +1;\n            } else if (ot.nan) {\n                return -1;\n            } else if (negInf || ot.posInf) {\n                return -1;\n            } else if (posInf || ot.negInf) {\n                return +1;\n            } else {\n\n                if (offset < ot.offset) {\n                    encode(ot.offset);\n                } else if (offset > ot.offset) {\n                    ot.encode(offset);\n                }\n\n                final int limit = FastMath.min(encoding.length, ot.encoding.length);\n                for (int i = 0; i < limit; ++i) {\n                    if (encoding[i] < ot.encoding[i]) {\n                        return -1;\n                    } else if (encoding[i] > ot.encoding[i]) {\n                        return +1;\n                    }\n                }\n\n                if (encoding.length < ot.encoding.length) {\n                    return -1;\n                } else if (encoding.length > ot.encoding.length) {\n                    return +1;\n                } else {\n                    return 0;\n                }\n\n            }\n        }\n\n        return components.length - ot.components.length;\n\n    }",
    "comment": "Compares this ordered T-uple with the specified object.  <p>The ordering method is detailed in the general description of the class. Its main property is to be consistent with distance: geometrically close T-uples stay close to each other when stored in a sorted collection using this comparison method.</p>  <p>T-uples with negative infinite, positive infinite are sorted logically.</p>  <p>Some arbitrary choices have been made to handle specific cases. The rationale for these choices is to keep <em>normal</em> and consistent T-uples together.</p> <ul> <li>instances with different dimensions are sorted according to their dimension regardless of their components values</li> <li>instances with {@code Double.NaN} components are sorted after all other ones (evan after instances with positive infinite components</li> <li>instances with both positive and negative infinite components are considered as if they had {@code Double.NaN} components</li> </ul>  @param ot T-uple to compare instance with @return a negative integer if the instance is less than the object, zero if they are equal, or a positive integer if the instance is greater than the object  ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "OrderedTuple.computeLSB",
    "class_name": "org.apache.commons.math3.geometry.partitioning.utilities.OrderedTuple",
    "signature": "org.apache.commons.math3.geometry.partitioning.utilities.OrderedTuple.computeLSB(long)",
    "snippet": "    private static int computeLSB(final long l) {\n\n        long ll = l;\n        long mask  = 0xffffffff00000000L;\n        int  scale = 32;\n        int  lsb   = 0;\n\n        while (scale != 0) {\n            if ((ll & mask) == ll) {\n                lsb |= scale;\n                ll = ll >> scale;\n            }\n            scale = scale >> 1;\n            mask  = mask >> scale;\n        }\n\n        return lsb;\n\n    }",
    "comment": "Compute the least significant bit of a long. @param l long from which the least significant bit is requested @return scale of the least significant bit of {@code l}, or 63 if {@code l} is zero @see #computeMSB ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "OrderedTuple.computeMSB",
    "class_name": "org.apache.commons.math3.geometry.partitioning.utilities.OrderedTuple",
    "signature": "org.apache.commons.math3.geometry.partitioning.utilities.OrderedTuple.computeMSB(long)",
    "snippet": "    private static int computeMSB(final long l) {\n\n        long ll = l;\n        long mask  = 0xffffffffL;\n        int  scale = 32;\n        int  msb   = 0;\n\n        while (scale != 0) {\n            if ((ll & mask) != ll) {\n                msb |= scale;\n                ll = ll >> scale;\n            }\n            scale = scale >> 1;\n            mask  = mask >> scale;\n        }\n\n        return msb;\n\n    }",
    "comment": "Compute the most significant bit of a long. @param l long from which the most significant bit is requested @return scale of the most significant bit of {@code l}, or 0 if {@code l} is zero @see #computeLSB ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "OrderedTuple.encode",
    "class_name": "org.apache.commons.math3.geometry.partitioning.utilities.OrderedTuple",
    "signature": "org.apache.commons.math3.geometry.partitioning.utilities.OrderedTuple.encode(int)",
    "snippet": "    private void encode(final int minOffset) {\n\n        // choose an offset with some margins\n        offset  = minOffset + 31;\n        offset -= offset % 32;\n\n        if ((encoding != null) && (encoding.length == 1) && (encoding[0] == 0x0L)) {\n            // the components are all zeroes\n            return;\n        }\n\n        // allocate an integer array to encode the components (we use only\n        // 63 bits per element because there is no unsigned long in Java)\n        final int neededBits  = offset + 1 - lsb;\n        final int neededLongs = (neededBits + 62) / 63;\n        encoding = new long[components.length * neededLongs];\n\n        // mix the bits from all components\n        int  eIndex = 0;\n        int  shift  = 62;\n        long word   = 0x0L;\n        for (int k = offset; eIndex < encoding.length; --k) {\n            for (int vIndex = 0; vIndex < components.length; ++vIndex) {\n                if (getBit(vIndex, k) != 0) {\n                    word |= 0x1L << shift;\n                }\n                if (shift-- == 0) {\n                    encoding[eIndex++] = word;\n                    word  = 0x0L;\n                    shift = 62;\n                }\n            }\n        }\n\n    }",
    "comment": "Encode the T-uple with a given offset. @param minOffset minimal scale of the offset to add to all components (must be greater than the MSBs of all components) ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "OrderedTuple.exponent",
    "class_name": "org.apache.commons.math3.geometry.partitioning.utilities.OrderedTuple",
    "signature": "org.apache.commons.math3.geometry.partitioning.utilities.OrderedTuple.exponent(long)",
    "snippet": "    private static int exponent(final long bits) {\n        return ((int) ((bits & EXPONENT_MASK) >> 52)) - 1075;\n    }",
    "comment": "Extract the exponent from the bits of a double. @param bits binary representation of the double @return exponent ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "OrderedTuple.getBit",
    "class_name": "org.apache.commons.math3.geometry.partitioning.utilities.OrderedTuple",
    "signature": "org.apache.commons.math3.geometry.partitioning.utilities.OrderedTuple.getBit(int,int)",
    "snippet": "    private int getBit(final int i, final int k) {\n        final long bits = Double.doubleToLongBits(components[i]);\n        final int e = exponent(bits);\n        if ((k < e) || (k > offset)) {\n            return 0;\n        } else if (k == offset) {\n            return (sign(bits) == 0L) ? 1 : 0;\n        } else if (k > (e + 52)) {\n            return (sign(bits) == 0L) ? 0 : 1;\n        } else {\n            final long m = (sign(bits) == 0L) ? mantissa(bits) : -mantissa(bits);\n            return (int) ((m >> (k - e)) & 0x1L);\n        }\n    }",
    "comment": "Get a bit from the mantissa of a double. @param i index of the component @param k scale of the requested bit @return the specified bit (either 0 or 1), after the offset has been added to the double ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "OrderedTuple.mantissa",
    "class_name": "org.apache.commons.math3.geometry.partitioning.utilities.OrderedTuple",
    "signature": "org.apache.commons.math3.geometry.partitioning.utilities.OrderedTuple.mantissa(long)",
    "snippet": "    private static long mantissa(final long bits) {\n        return ((bits & EXPONENT_MASK) == 0) ?\n               ((bits & MANTISSA_MASK) << 1) :          // subnormal number\n               (IMPLICIT_ONE | (bits & MANTISSA_MASK)); // normal number\n    }",
    "comment": "Extract the mantissa from the bits of a double. @param bits binary representation of the double @return mantissa ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "OrderedTuple.sign",
    "class_name": "org.apache.commons.math3.geometry.partitioning.utilities.OrderedTuple",
    "signature": "org.apache.commons.math3.geometry.partitioning.utilities.OrderedTuple.sign(long)",
    "snippet": "    private static long sign(final long bits) {\n        return bits & SIGN_MASK;\n    }",
    "comment": "Extract the sign from the bits of a double. @param bits binary representation of the double @return sign bit (zero if positive, non zero if negative) ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "FastMath.abs",
    "class_name": "org.apache.commons.math3.util.FastMath",
    "signature": "org.apache.commons.math3.util.FastMath.abs(double)",
    "snippet": "    public static double abs(double x) {\n        return (x < 0.0) ? -x : (x == 0.0) ? 0.0 : x; // -0.0 => +0.0\n    }",
    "comment": " Absolute value. @param x number from which absolute value is requested @return abs(x) ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "FastMath.atan",
    "class_name": "org.apache.commons.math3.util.FastMath",
    "signature": "org.apache.commons.math3.util.FastMath.atan(double,double,boolean)",
    "snippet": "    private static double atan(double xa, double xb, boolean leftPlane) {\n        boolean negate = false;\n        int idx;\n\n        if (xa == 0.0) { // Matches +/- 0.0; return correct sign\n            return leftPlane ? copySign(Math.PI, xa) : xa;\n        }\n\n        if (xa < 0) {\n            // negative\n            xa = -xa;\n            xb = -xb;\n            negate = true;\n        }\n\n        if (xa > 1.633123935319537E16) { // Very large input\n            return (negate ^ leftPlane) ? (-Math.PI * F_1_2) : (Math.PI * F_1_2);\n        }\n\n        /* Estimate the closest tabulated arctan value, compute eps = xa-tangentTable */\n        if (xa < 1) {\n            idx = (int) (((-1.7168146928204136 * xa * xa + 8.0) * xa) + 0.5);\n        } else {\n            final double oneOverXa = 1 / xa;\n            idx = (int) (-((-1.7168146928204136 * oneOverXa * oneOverXa + 8.0) * oneOverXa) + 13.07);\n        }\n        double epsA = xa - TANGENT_TABLE_A[idx];\n        double epsB = -(epsA - xa + TANGENT_TABLE_A[idx]);\n        epsB += xb - TANGENT_TABLE_B[idx];\n\n        double temp = epsA + epsB;\n        epsB = -(temp - epsA - epsB);\n        epsA = temp;\n\n        /* Compute eps = eps / (1.0 + xa*tangent) */\n        temp = xa * HEX_40000000;\n        double ya = xa + temp - temp;\n        double yb = xb + xa - ya;\n        xa = ya;\n        xb += yb;\n\n        //if (idx > 8 || idx == 0)\n        if (idx == 0) {\n            /* If the slope of the arctan is gentle enough (< 0.45), this approximation will suffice */\n            //double denom = 1.0 / (1.0 + xa*tangentTableA[idx] + xb*tangentTableA[idx] + xa*tangentTableB[idx] + xb*tangentTableB[idx]);\n            final double denom = 1d / (1d + (xa + xb) * (TANGENT_TABLE_A[idx] + TANGENT_TABLE_B[idx]));\n            //double denom = 1.0 / (1.0 + xa*tangentTableA[idx]);\n            ya = epsA * denom;\n            yb = epsB * denom;\n        } else {\n            double temp2 = xa * TANGENT_TABLE_A[idx];\n            double za = 1d + temp2;\n            double zb = -(za - 1d - temp2);\n            temp2 = xb * TANGENT_TABLE_A[idx] + xa * TANGENT_TABLE_B[idx];\n            temp = za + temp2;\n            zb += -(temp - za - temp2);\n            za = temp;\n\n            zb += xb * TANGENT_TABLE_B[idx];\n            ya = epsA / za;\n\n            temp = ya * HEX_40000000;\n            final double yaa = (ya + temp) - temp;\n            final double yab = ya - yaa;\n\n            temp = za * HEX_40000000;\n            final double zaa = (za + temp) - temp;\n            final double zab = za - zaa;\n\n            /* Correct for rounding in division */\n            yb = (epsA - yaa * zaa - yaa * zab - yab * zaa - yab * zab) / za;\n\n            yb += -epsA * zb / za / za;\n            yb += epsB / za;\n        }\n\n\n        epsA = ya;\n        epsB = yb;\n\n        /* Evaluate polynomial */\n        final double epsA2 = epsA * epsA;\n\n        /*\n    yb = -0.09001346640161823;\n    yb = yb * epsA2 + 0.11110718400605211;\n    yb = yb * epsA2 + -0.1428571349122913;\n    yb = yb * epsA2 + 0.19999999999273194;\n    yb = yb * epsA2 + -0.33333333333333093;\n    yb = yb * epsA2 * epsA;\n         */\n\n        yb = 0.07490822288864472;\n        yb = yb * epsA2 + -0.09088450866185192;\n        yb = yb * epsA2 + 0.11111095942313305;\n        yb = yb * epsA2 + -0.1428571423679182;\n        yb = yb * epsA2 + 0.19999999999923582;\n        yb = yb * epsA2 + -0.33333333333333287;\n        yb = yb * epsA2 * epsA;\n\n\n        ya = epsA;\n\n        temp = ya + yb;\n        yb = -(temp - ya - yb);\n        ya = temp;\n\n        /* Add in effect of epsB.   atan'(x) = 1/(1+x^2) */\n        yb += epsB / (1d + epsA * epsA);\n\n        //result = yb + eighths[idx] + ya;\n        double za = EIGHTHS[idx] + ya;\n        double zb = -(za - EIGHTHS[idx] - ya);\n        temp = za + yb;\n        zb += -(temp - za - yb);\n        za = temp;\n\n        double result = za + zb;\n        double resultb = -(result - za - zb);\n\n        if (leftPlane) {\n            // Result is in the left plane\n            final double pia = 1.5707963267948966 * 2;\n            final double pib = 6.123233995736766E-17 * 2;\n\n            za = pia - result;\n            zb = -(za - pia + result);\n            zb += pib - resultb;\n\n            result = za + zb;\n            resultb = -(result - za - zb);\n        }\n\n\n        if (negate ^ leftPlane) {\n            result = -result;\n        }\n\n        return result;\n    }",
    "comment": "Internal helper function to compute arctangent. @param xa number from which arctangent is requested @param xb extra bits for x (may be 0.0) @param leftPlane if true, result angle must be put in the left half plane @return atan(xa + xb) (or angle shifted by {@code PI} if leftPlane is true) ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "FastMath.atan2",
    "class_name": "org.apache.commons.math3.util.FastMath",
    "signature": "org.apache.commons.math3.util.FastMath.atan2(double,double)",
    "snippet": "    public static double atan2(double y, double x) {\n        if (x != x || y != y) {\n            return Double.NaN;\n        }\n\n        if (y == 0) {\n            final double result = x * y;\n            final double invx = 1d / x;\n            final double invy = 1d / y;\n\n            if (invx == 0) { // X is infinite\n                if (x > 0) {\n                    return y; // return +/- 0.0\n                } else {\n                    return copySign(Math.PI, y);\n                }\n            }\n\n            if (x < 0 || invx < 0) {\n                if (y < 0 || invy < 0) {\n                    return -Math.PI;\n                } else {\n                    return Math.PI;\n                }\n            } else {\n                return result;\n            }\n        }\n\n        // y cannot now be zero\n\n        if (y == Double.POSITIVE_INFINITY) {\n            if (x == Double.POSITIVE_INFINITY) {\n                return Math.PI * F_1_4;\n            }\n\n            if (x == Double.NEGATIVE_INFINITY) {\n                return Math.PI * F_3_4;\n            }\n\n            return Math.PI * F_1_2;\n        }\n\n        if (y == Double.NEGATIVE_INFINITY) {\n            if (x == Double.POSITIVE_INFINITY) {\n                return -Math.PI * F_1_4;\n            }\n\n            if (x == Double.NEGATIVE_INFINITY) {\n                return -Math.PI * F_3_4;\n            }\n\n            return -Math.PI * F_1_2;\n        }\n\n        if (x == Double.POSITIVE_INFINITY) {\n            if (y > 0 || 1 / y > 0) {\n                return 0d;\n            }\n\n            if (y < 0 || 1 / y < 0) {\n                return -0d;\n            }\n        }\n\n        if (x == Double.NEGATIVE_INFINITY)\n        {\n            if (y > 0.0 || 1 / y > 0.0) {\n                return Math.PI;\n            }\n\n            if (y < 0 || 1 / y < 0) {\n                return -Math.PI;\n            }\n        }\n\n        // Neither y nor x can be infinite or NAN here\n\n        if (x == 0) {\n            if (y > 0 || 1 / y > 0) {\n                return Math.PI * F_1_2;\n            }\n\n            if (y < 0 || 1 / y < 0) {\n                return -Math.PI * F_1_2;\n            }\n        }\n\n        // Compute ratio r = y/x\n        final double r = y / x;\n        if (Double.isInfinite(r)) { // bypass calculations that can create NaN\n            return atan(r, 0, x < 0);\n        }\n\n        double ra = doubleHighPart(r);\n        double rb = r - ra;\n\n        // Split x\n        final double xa = doubleHighPart(x);\n        final double xb = x - xa;\n\n        rb += (y - ra * xa - ra * xb - rb * xa - rb * xb) / x;\n\n        final double temp = ra + rb;\n        rb = -(temp - ra - rb);\n        ra = temp;\n\n        if (ra == 0) { // Fix up the sign so atan works correctly\n            ra = copySign(0d, y);\n        }\n\n        // Call atan\n        final double result = atan(ra, rb, x < 0);\n\n        return result;\n    }",
    "comment": " Two arguments arctangent function @param y ordinate @param x abscissa @return phase angle of point (x,y) between {@code -PI} and {@code PI} ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "FastMath.cos",
    "class_name": "org.apache.commons.math3.util.FastMath",
    "signature": "org.apache.commons.math3.util.FastMath.cos(double)",
    "snippet": "    public static double cos(double x) {\n        int quadrant = 0;\n\n        /* Take absolute value of the input */\n        double xa = x;\n        if (x < 0) {\n            xa = -xa;\n        }\n\n        if (xa != xa || xa == Double.POSITIVE_INFINITY) {\n            return Double.NaN;\n        }\n\n        /* Perform any argument reduction */\n        double xb = 0;\n        if (xa > 3294198.0) {\n            // PI * (2**20)\n            // Argument too big for CodyWaite reduction.  Must use\n            // PayneHanek.\n            double reduceResults[] = new double[3];\n            reducePayneHanek(xa, reduceResults);\n            quadrant = ((int) reduceResults[0]) & 3;\n            xa = reduceResults[1];\n            xb = reduceResults[2];\n        } else if (xa > 1.5707963267948966) {\n            /* Inline the Cody/Waite reduction for performance */\n\n            // Estimate k\n            //k = (int)(xa / 1.5707963267948966);\n            int k = (int)(xa * 0.6366197723675814);\n\n            // Compute remainder\n            double remA;\n            double remB;\n            while (true) {\n                double a = -k * 1.570796251296997;\n                remA = xa + a;\n                remB = -(remA - xa - a);\n\n                a = -k * 7.549789948768648E-8;\n                double b = remA;\n                remA = a + b;\n                remB += -(remA - b - a);\n\n                a = -k * 6.123233995736766E-17;\n                b = remA;\n                remA = a + b;\n                remB += -(remA - b - a);\n\n                if (remA > 0.0) {\n                    break;\n                }\n\n                // Remainder is negative, so decrement k and try again.\n                // This should only happen if the input is very close\n                // to an even multiple of pi/2\n                k--;\n            }\n            quadrant = k & 3;\n            xa = remA;\n            xb = remB;\n        }\n\n        //if (negative)\n        //  quadrant = (quadrant + 2) % 4;\n\n        switch (quadrant) {\n            case 0:\n                return cosQ(xa, xb);\n            case 1:\n                return -sinQ(xa, xb);\n            case 2:\n                return -cosQ(xa, xb);\n            case 3:\n                return sinQ(xa, xb);\n            default:\n                return Double.NaN;\n        }\n    }",
    "comment": " Cosine function @param x a number @return cos(x) ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "FastMath.cosQ",
    "class_name": "org.apache.commons.math3.util.FastMath",
    "signature": "org.apache.commons.math3.util.FastMath.cosQ(double,double)",
    "snippet": "    private static double cosQ(double xa, double xb) {\n        final double pi2a = 1.5707963267948966;\n        final double pi2b = 6.123233995736766E-17;\n\n        final double a = pi2a - xa;\n        double b = -(a - pi2a + xa);\n        b += pi2b - xb;\n\n        return sinQ(a, b);\n    }",
    "comment": " Compute cosine in the first quadrant by subtracting input from PI/2 and then calling sinQ.  This is more accurate as the input approaches PI/2. @param xa number from which cosine is requested @param xb extra bits for x (may be 0.0) @return cos(xa + xb) ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "FastMath.doubleHighPart",
    "class_name": "org.apache.commons.math3.util.FastMath",
    "signature": "org.apache.commons.math3.util.FastMath.doubleHighPart(double)",
    "snippet": "    private static double doubleHighPart(double d) {\n        if (d > -Precision.SAFE_MIN && d < Precision.SAFE_MIN){\n            return d; // These are un-normalised - don't try to convert\n        }\n        long xl = Double.doubleToLongBits(d);\n        xl = xl & MASK_30BITS; // Drop low order bits\n        return Double.longBitsToDouble(xl);\n    }",
    "comment": " Get the high order bits from the mantissa. Equivalent to adding and subtracting HEX_40000 but also works for very large numbers  @param d the value to split @return the high order part of the mantissa ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "FastMath.floor",
    "class_name": "org.apache.commons.math3.util.FastMath",
    "signature": "org.apache.commons.math3.util.FastMath.floor(double)",
    "snippet": "    public static double floor(double x) {\n        long y;\n\n        if (x != x) { // NaN\n            return x;\n        }\n\n        if (x >= TWO_POWER_52 || x <= -TWO_POWER_52) {\n            return x;\n        }\n\n        y = (long) x;\n        if (x < 0 && y != x) {\n            y--;\n        }\n\n        if (y == 0) {\n            return x*y;\n        }\n\n        return y;\n    }",
    "comment": "Get the largest whole number smaller than x. @param x number from which floor is requested @return a double number f such that f is an integer f <= x < f + 1.0 ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "FastMath.getExponent",
    "class_name": "org.apache.commons.math3.util.FastMath",
    "signature": "org.apache.commons.math3.util.FastMath.getExponent(double)",
    "snippet": "    public static int getExponent(final double d) {\n        return (int) ((Double.doubleToLongBits(d) >>> 52) & 0x7ff) - 1023;\n    }",
    "comment": " Return the exponent of a double number, removing the bias. <p> For double numbers of the form 2<sup>x</sup>, the unbiased exponent is exactly x. </p> @param d number from which exponent is requested @return exponent for d in IEEE754 representation, without bias ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "FastMath.hypot",
    "class_name": "org.apache.commons.math3.util.FastMath",
    "signature": "org.apache.commons.math3.util.FastMath.hypot(double,double)",
    "snippet": "    public static double hypot(final double x, final double y) {\n        if (Double.isInfinite(x) || Double.isInfinite(y)) {\n            return Double.POSITIVE_INFINITY;\n        } else if (Double.isNaN(x) || Double.isNaN(y)) {\n            return Double.NaN;\n        } else {\n\n            final int expX = getExponent(x);\n            final int expY = getExponent(y);\n            if (expX > expY + 27) {\n                // y is neglectible with respect to x\n                return abs(x);\n            } else if (expY > expX + 27) {\n                // x is neglectible with respect to y\n                return abs(y);\n            } else {\n\n                // find an intermediate scale to avoid both overflow and underflow\n                final int middleExp = (expX + expY) / 2;\n\n                // scale parameters without losing precision\n                final double scaledX = scalb(x, -middleExp);\n                final double scaledY = scalb(y, -middleExp);\n\n                // compute scaled hypotenuse\n                final double scaledH = sqrt(scaledX * scaledX + scaledY * scaledY);\n\n                // remove scaling\n                return scalb(scaledH, middleExp);\n\n            }\n\n        }\n    }",
    "comment": " Returns the hypotenuse of a triangle with sides {@code x} and {@code y} - sqrt(<i>x</i><sup>2</sup>&nbsp;+<i>y</i><sup>2</sup>)<br/> avoiding intermediate overflow or underflow.  <ul> <li> If either argument is infinite, then the result is positive infinity.</li> <li> else, if either argument is NaN then the result is NaN.</li> </ul>  @param x a value @param y a value @return sqrt(<i>x</i><sup>2</sup>&nbsp;+<i>y</i><sup>2</sup>) ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "FastMath.max",
    "class_name": "org.apache.commons.math3.util.FastMath",
    "signature": "org.apache.commons.math3.util.FastMath.max(int,int)",
    "snippet": "    public static int max(final int a, final int b) {\n        return (a <= b) ? b : a;\n    }",
    "comment": "Compute the maximum of two values @param a first value @param b second value @return b if a is lesser or equal to b, a otherwise ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "FastMath.min",
    "class_name": "org.apache.commons.math3.util.FastMath",
    "signature": "org.apache.commons.math3.util.FastMath.min(int,int)",
    "snippet": "    public static int min(final int a, final int b) {\n        return (a <= b) ? a : b;\n    }",
    "comment": "Compute the minimum of two values @param a first value @param b second value @return a if a is lesser or equal to b, b otherwise ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "FastMath.polyCosine",
    "class_name": "org.apache.commons.math3.util.FastMath",
    "signature": "org.apache.commons.math3.util.FastMath.polyCosine(double)",
    "snippet": "    private static double polyCosine(double x) {\n        double x2 = x*x;\n\n        double p = 2.479773539153719E-5;\n        p = p * x2 + -0.0013888888689039883;\n        p = p * x2 + 0.041666666666621166;\n        p = p * x2 + -0.49999999999999994;\n        p *= x2;\n\n        return p;\n    }",
    "comment": " Computes cos(x) - 1, where |x| < 1/16. Use a Remez polynomial approximation. @param x a number smaller than 1/16 @return cos(x) - 1 ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "FastMath.polySine",
    "class_name": "org.apache.commons.math3.util.FastMath",
    "signature": "org.apache.commons.math3.util.FastMath.polySine(double)",
    "snippet": "    private static double polySine(final double x)\n    {\n        double x2 = x*x;\n\n        double p = 2.7553817452272217E-6;\n        p = p * x2 + -1.9841269659586505E-4;\n        p = p * x2 + 0.008333333333329196;\n        p = p * x2 + -0.16666666666666666;\n        //p *= x2;\n        //p *= x;\n        p = p * x2 * x;\n\n        return p;\n    }",
    "comment": " Computes sin(x) - x, where |x| < 1/16. Use a Remez polynomial approximation. @param x a number smaller than 1/16 @return sin(x) - x ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "FastMath.scalb",
    "class_name": "org.apache.commons.math3.util.FastMath",
    "signature": "org.apache.commons.math3.util.FastMath.scalb(double,int)",
    "snippet": "    public static double scalb(final double d, final int n) {\n\n        // first simple and fast handling when 2^n can be represented using normal numbers\n        if ((n > -1023) && (n < 1024)) {\n            return d * Double.longBitsToDouble(((long) (n + 1023)) << 52);\n        }\n\n        // handle special cases\n        if (Double.isNaN(d) || Double.isInfinite(d) || (d == 0)) {\n            return d;\n        }\n        if (n < -2098) {\n            return (d > 0) ? 0.0 : -0.0;\n        }\n        if (n > 2097) {\n            return (d > 0) ? Double.POSITIVE_INFINITY : Double.NEGATIVE_INFINITY;\n        }\n\n        // decompose d\n        final long bits = Double.doubleToLongBits(d);\n        final long sign = bits & 0x8000000000000000L;\n        int  exponent   = ((int) (bits >>> 52)) & 0x7ff;\n        long mantissa   = bits & 0x000fffffffffffffL;\n\n        // compute scaled exponent\n        int scaledExponent = exponent + n;\n\n        if (n < 0) {\n            // we are really in the case n <= -1023\n            if (scaledExponent > 0) {\n                // both the input and the result are normal numbers, we only adjust the exponent\n                return Double.longBitsToDouble(sign | (((long) scaledExponent) << 52) | mantissa);\n            } else if (scaledExponent > -53) {\n                // the input is a normal number and the result is a subnormal number\n\n                // recover the hidden mantissa bit\n                mantissa = mantissa | (1L << 52);\n\n                // scales down complete mantissa, hence losing least significant bits\n                final long mostSignificantLostBit = mantissa & (1L << (-scaledExponent));\n                mantissa = mantissa >>> (1 - scaledExponent);\n                if (mostSignificantLostBit != 0) {\n                    // we need to add 1 bit to round up the result\n                    mantissa++;\n                }\n                return Double.longBitsToDouble(sign | mantissa);\n\n            } else {\n                // no need to compute the mantissa, the number scales down to 0\n                return (sign == 0L) ? 0.0 : -0.0;\n            }\n        } else {\n            // we are really in the case n >= 1024\n            if (exponent == 0) {\n\n                // the input number is subnormal, normalize it\n                while ((mantissa >>> 52) != 1) {\n                    mantissa = mantissa << 1;\n                    --scaledExponent;\n                }\n                ++scaledExponent;\n                mantissa = mantissa & 0x000fffffffffffffL;\n\n                if (scaledExponent < 2047) {\n                    return Double.longBitsToDouble(sign | (((long) scaledExponent) << 52) | mantissa);\n                } else {\n                    return (sign == 0L) ? Double.POSITIVE_INFINITY : Double.NEGATIVE_INFINITY;\n                }\n\n            } else if (scaledExponent < 2047) {\n                return Double.longBitsToDouble(sign | (((long) scaledExponent) << 52) | mantissa);\n            } else {\n                return (sign == 0L) ? Double.POSITIVE_INFINITY : Double.NEGATIVE_INFINITY;\n            }\n        }\n\n    }",
    "comment": " Multiply a double number by a power of 2. @param d number to multiply @param n power of 2 @return d &times; 2<sup>n</sup> ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "FastMath.sin",
    "class_name": "org.apache.commons.math3.util.FastMath",
    "signature": "org.apache.commons.math3.util.FastMath.sin(double)",
    "snippet": "    public static double sin(double x) {\n        boolean negative = false;\n        int quadrant = 0;\n        double xa;\n        double xb = 0.0;\n\n        /* Take absolute value of the input */\n        xa = x;\n        if (x < 0) {\n            negative = true;\n            xa = -xa;\n        }\n\n        /* Check for zero and negative zero */\n        if (xa == 0.0) {\n            long bits = Double.doubleToLongBits(x);\n            if (bits < 0) {\n                return -0.0;\n            }\n            return 0.0;\n        }\n\n        if (xa != xa || xa == Double.POSITIVE_INFINITY) {\n            return Double.NaN;\n        }\n\n        /* Perform any argument reduction */\n        if (xa > 3294198.0) {\n            // PI * (2**20)\n            // Argument too big for CodyWaite reduction.  Must use\n            // PayneHanek.\n            double reduceResults[] = new double[3];\n            reducePayneHanek(xa, reduceResults);\n            quadrant = ((int) reduceResults[0]) & 3;\n            xa = reduceResults[1];\n            xb = reduceResults[2];\n        } else if (xa > 1.5707963267948966) {\n            /* Inline the Cody/Waite reduction for performance */\n\n            // Estimate k\n            //k = (int)(xa / 1.5707963267948966);\n            int k = (int)(xa * 0.6366197723675814);\n\n            // Compute remainder\n            double remA;\n            double remB;\n            while (true) {\n                double a = -k * 1.570796251296997;\n                remA = xa + a;\n                remB = -(remA - xa - a);\n\n                a = -k * 7.549789948768648E-8;\n                double b = remA;\n                remA = a + b;\n                remB += -(remA - b - a);\n\n                a = -k * 6.123233995736766E-17;\n                b = remA;\n                remA = a + b;\n                remB += -(remA - b - a);\n\n                if (remA > 0.0) {\n                    break;\n                }\n\n                // Remainder is negative, so decrement k and try again.\n                // This should only happen if the input is very close\n                // to an even multiple of pi/2\n                k--;\n            }\n            quadrant = k & 3;\n            xa = remA;\n            xb = remB;\n        }\n\n        if (negative) {\n            quadrant ^= 2;  // Flip bit 1\n        }\n\n        switch (quadrant) {\n            case 0:\n                return sinQ(xa, xb);\n            case 1:\n                return cosQ(xa, xb);\n            case 2:\n                return -sinQ(xa, xb);\n            case 3:\n                return -cosQ(xa, xb);\n            default:\n                return Double.NaN;\n        }\n    }",
    "comment": " Sine function. @param x a number @return sin(x) ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "FastMath.sinQ",
    "class_name": "org.apache.commons.math3.util.FastMath",
    "signature": "org.apache.commons.math3.util.FastMath.sinQ(double,double)",
    "snippet": "    private static double sinQ(double xa, double xb) {\n        int idx = (int) ((xa * 8.0) + 0.5);\n        final double epsilon = xa - EIGHTHS[idx]; //idx*0.125;\n\n        // Table lookups\n        final double sintA = SINE_TABLE_A[idx];\n        final double sintB = SINE_TABLE_B[idx];\n        final double costA = COSINE_TABLE_A[idx];\n        final double costB = COSINE_TABLE_B[idx];\n\n        // Polynomial eval of sin(epsilon), cos(epsilon)\n        double sinEpsA = epsilon;\n        double sinEpsB = polySine(epsilon);\n        final double cosEpsA = 1.0;\n        final double cosEpsB = polyCosine(epsilon);\n\n        // Split epsilon   xa + xb = x\n        final double temp = sinEpsA * HEX_40000000;\n        double temp2 = (sinEpsA + temp) - temp;\n        sinEpsB +=  sinEpsA - temp2;\n        sinEpsA = temp2;\n\n        /* Compute sin(x) by angle addition formula */\n        double result;\n\n        /* Compute the following sum:\n         *\n         * result = sintA + costA*sinEpsA + sintA*cosEpsB + costA*sinEpsB +\n         *          sintB + costB*sinEpsA + sintB*cosEpsB + costB*sinEpsB;\n         *\n         * Ranges of elements\n         *\n         * xxxtA   0            PI/2\n         * xxxtB   -1.5e-9      1.5e-9\n         * sinEpsA -0.0625      0.0625\n         * sinEpsB -6e-11       6e-11\n         * cosEpsA  1.0\n         * cosEpsB  0           -0.0625\n         *\n         */\n\n        //result = sintA + costA*sinEpsA + sintA*cosEpsB + costA*sinEpsB +\n        //          sintB + costB*sinEpsA + sintB*cosEpsB + costB*sinEpsB;\n\n        //result = sintA + sintA*cosEpsB + sintB + sintB * cosEpsB;\n        //result += costA*sinEpsA + costA*sinEpsB + costB*sinEpsA + costB * sinEpsB;\n        double a = 0;\n        double b = 0;\n\n        double t = sintA;\n        double c = a + t;\n        double d = -(c - a - t);\n        a = c;\n        b = b + d;\n\n        t = costA * sinEpsA;\n        c = a + t;\n        d = -(c - a - t);\n        a = c;\n        b = b + d;\n\n        b = b + sintA * cosEpsB + costA * sinEpsB;\n        /*\n    t = sintA*cosEpsB;\n    c = a + t;\n    d = -(c - a - t);\n    a = c;\n    b = b + d;\n\n    t = costA*sinEpsB;\n    c = a + t;\n    d = -(c - a - t);\n    a = c;\n    b = b + d;\n         */\n\n        b = b + sintB + costB * sinEpsA + sintB * cosEpsB + costB * sinEpsB;\n        /*\n    t = sintB;\n    c = a + t;\n    d = -(c - a - t);\n    a = c;\n    b = b + d;\n\n    t = costB*sinEpsA;\n    c = a + t;\n    d = -(c - a - t);\n    a = c;\n    b = b + d;\n\n    t = sintB*cosEpsB;\n    c = a + t;\n    d = -(c - a - t);\n    a = c;\n    b = b + d;\n\n    t = costB*sinEpsB;\n    c = a + t;\n    d = -(c - a - t);\n    a = c;\n    b = b + d;\n         */\n\n        if (xb != 0.0) {\n            t = ((costA + costB) * (cosEpsA + cosEpsB) -\n                 (sintA + sintB) * (sinEpsA + sinEpsB)) * xb;  // approximate cosine*xb\n            c = a + t;\n            d = -(c - a - t);\n            a = c;\n            b = b + d;\n        }\n\n        result = a + b;\n\n        return result;\n    }",
    "comment": " Compute sine over the first quadrant (0 < x < pi/2). Use combination of table lookup and rational polynomial expansion. @param xa number from which sine is requested @param xb extra bits for x (may be 0.0) @return sin(xa + xb) ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "FastMath.sqrt",
    "class_name": "org.apache.commons.math3.util.FastMath",
    "signature": "org.apache.commons.math3.util.FastMath.sqrt(double)",
    "snippet": "    public static double sqrt(final double a) {\n        return Math.sqrt(a);\n    }",
    "comment": "Compute the square root of a number. <p><b>Note:</b> this implementation currently delegates to {@link Math#sqrt} @param a number on which evaluation is done @return square root of a ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "MathArrays.linearCombination",
    "class_name": "org.apache.commons.math3.util.MathArrays",
    "signature": "org.apache.commons.math3.util.MathArrays.linearCombination(double,double,double,double)",
    "snippet": "    public static double linearCombination(final double a1, final double b1,\n                                           final double a2, final double b2) {\n\n        // the code below is split in many additions/subtractions that may\n        // appear redundant. However, they should NOT be simplified, as they\n        // use IEEE754 floating point arithmetic rounding properties.\n        // as an example, the expression \"ca1 - (ca1 - a1)\" is NOT the same as \"a1\"\n        // The variable naming conventions are that xyzHigh contains the most significant\n        // bits of xyz and xyzLow contains its least significant bits. So theoretically\n        // xyz is the sum xyzHigh + xyzLow, but in many cases below, this sum cannot\n        // be represented in only one double precision number so we preserve two numbers\n        // to hold it as long as we can, combining the high and low order bits together\n        // only at the end, after cancellation may have occurred on high order bits\n\n        // split a1 and b1 as two 26 bits numbers\n        final double ca1        = SPLIT_FACTOR * a1;\n        final double a1High     = ca1 - (ca1 - a1);\n        final double a1Low      = a1 - a1High;\n        final double cb1        = SPLIT_FACTOR * b1;\n        final double b1High     = cb1 - (cb1 - b1);\n        final double b1Low      = b1 - b1High;\n\n        // accurate multiplication a1 * b1\n        final double prod1High  = a1 * b1;\n        final double prod1Low   = a1Low * b1Low - (((prod1High - a1High * b1High) - a1Low * b1High) - a1High * b1Low);\n\n        // split a2 and b2 as two 26 bits numbers\n        final double ca2        = SPLIT_FACTOR * a2;\n        final double a2High     = ca2 - (ca2 - a2);\n        final double a2Low      = a2 - a2High;\n        final double cb2        = SPLIT_FACTOR * b2;\n        final double b2High     = cb2 - (cb2 - b2);\n        final double b2Low      = b2 - b2High;\n\n        // accurate multiplication a2 * b2\n        final double prod2High  = a2 * b2;\n        final double prod2Low   = a2Low * b2Low - (((prod2High - a2High * b2High) - a2Low * b2High) - a2High * b2Low);\n\n        // accurate addition a1 * b1 + a2 * b2\n        final double s12High    = prod1High + prod2High;\n        final double s12Prime   = s12High - prod2High;\n        final double s12Low     = (prod2High - (s12High - s12Prime)) + (prod1High - s12Prime);\n\n        // final rounding, s12 may have suffered many cancellations, we try\n        // to recover some bits from the extra words we have saved up to now\n        double result = s12High + (prod1Low + prod2Low + s12Low);\n\n        if (Double.isNaN(result)) {\n            // either we have split infinite numbers or some coefficients were NaNs,\n            // just rely on the naive implementation and let IEEE754 handle this\n            result = a1 * b1 + a2 * b2;\n        }\n\n        return result;\n    }",
    "comment": " Compute a linear combination accurately. <p> This method computes a<sub>1</sub>&times;b<sub>1</sub> + a<sub>2</sub>&times;b<sub>2</sub> to high accuracy. It does so by using specific multiplication and addition algorithms to preserve accuracy and reduce cancellation effects. It is based on the 2005 paper <a href=\"http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.2.1547\"> Accurate Sum and Dot Product</a> by Takeshi Ogita, Siegfried M. Rump, and Shin'ichi Oishi published in SIAM J. Sci. Comput. </p> @param a1 first factor of the first term @param b1 second factor of the first term @param a2 first factor of the second term @param b2 second factor of the second term @return a<sub>1</sub>&times;b<sub>1</sub> + a<sub>2</sub>&times;b<sub>2</sub> @see #linearCombination(double, double, double, double, double, double) @see #linearCombination(double, double, double, double, double, double, double, double) ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "MathArrays.linearCombination",
    "class_name": "org.apache.commons.math3.util.MathArrays",
    "signature": "org.apache.commons.math3.util.MathArrays.linearCombination(double,double,double,double,double,double)",
    "snippet": "    public static double linearCombination(final double a1, final double b1,\n                                           final double a2, final double b2,\n                                           final double a3, final double b3) {\n\n        // the code below is split in many additions/subtractions that may\n        // appear redundant. However, they should NOT be simplified, as they\n        // do use IEEE754 floating point arithmetic rounding properties.\n        // as an example, the expression \"ca1 - (ca1 - a1)\" is NOT the same as \"a1\"\n        // The variables naming conventions are that xyzHigh contains the most significant\n        // bits of xyz and xyzLow contains its least significant bits. So theoretically\n        // xyz is the sum xyzHigh + xyzLow, but in many cases below, this sum cannot\n        // be represented in only one double precision number so we preserve two numbers\n        // to hold it as long as we can, combining the high and low order bits together\n        // only at the end, after cancellation may have occurred on high order bits\n\n        // split a1 and b1 as two 26 bits numbers\n        final double ca1        = SPLIT_FACTOR * a1;\n        final double a1High     = ca1 - (ca1 - a1);\n        final double a1Low      = a1 - a1High;\n        final double cb1        = SPLIT_FACTOR * b1;\n        final double b1High     = cb1 - (cb1 - b1);\n        final double b1Low      = b1 - b1High;\n\n        // accurate multiplication a1 * b1\n        final double prod1High  = a1 * b1;\n        final double prod1Low   = a1Low * b1Low - (((prod1High - a1High * b1High) - a1Low * b1High) - a1High * b1Low);\n\n        // split a2 and b2 as two 26 bits numbers\n        final double ca2        = SPLIT_FACTOR * a2;\n        final double a2High     = ca2 - (ca2 - a2);\n        final double a2Low      = a2 - a2High;\n        final double cb2        = SPLIT_FACTOR * b2;\n        final double b2High     = cb2 - (cb2 - b2);\n        final double b2Low      = b2 - b2High;\n\n        // accurate multiplication a2 * b2\n        final double prod2High  = a2 * b2;\n        final double prod2Low   = a2Low * b2Low - (((prod2High - a2High * b2High) - a2Low * b2High) - a2High * b2Low);\n\n        // split a3 and b3 as two 26 bits numbers\n        final double ca3        = SPLIT_FACTOR * a3;\n        final double a3High     = ca3 - (ca3 - a3);\n        final double a3Low      = a3 - a3High;\n        final double cb3        = SPLIT_FACTOR * b3;\n        final double b3High     = cb3 - (cb3 - b3);\n        final double b3Low      = b3 - b3High;\n\n        // accurate multiplication a3 * b3\n        final double prod3High  = a3 * b3;\n        final double prod3Low   = a3Low * b3Low - (((prod3High - a3High * b3High) - a3Low * b3High) - a3High * b3Low);\n\n        // accurate addition a1 * b1 + a2 * b2\n        final double s12High    = prod1High + prod2High;\n        final double s12Prime   = s12High - prod2High;\n        final double s12Low     = (prod2High - (s12High - s12Prime)) + (prod1High - s12Prime);\n\n        // accurate addition a1 * b1 + a2 * b2 + a3 * b3\n        final double s123High   = s12High + prod3High;\n        final double s123Prime  = s123High - prod3High;\n        final double s123Low    = (prod3High - (s123High - s123Prime)) + (s12High - s123Prime);\n\n        // final rounding, s123 may have suffered many cancellations, we try\n        // to recover some bits from the extra words we have saved up to now\n        double result = s123High + (prod1Low + prod2Low + prod3Low + s12Low + s123Low);\n\n        if (Double.isNaN(result)) {\n            // either we have split infinite numbers or some coefficients were NaNs,\n            // just rely on the naive implementation and let IEEE754 handle this\n            result = a1 * b1 + a2 * b2 + a3 * b3;\n        }\n\n        return result;\n    }",
    "comment": " Compute a linear combination accurately. <p> This method computes a<sub>1</sub>&times;b<sub>1</sub> + a<sub>2</sub>&times;b<sub>2</sub> + a<sub>3</sub>&times;b<sub>3</sub> to high accuracy. It does so by using specific multiplication and addition algorithms to preserve accuracy and reduce cancellation effects. It is based on the 2005 paper <a href=\"http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.2.1547\"> Accurate Sum and Dot Product</a> by Takeshi Ogita, Siegfried M. Rump, and Shin'ichi Oishi published in SIAM J. Sci. Comput. </p> @param a1 first factor of the first term @param b1 second factor of the first term @param a2 first factor of the second term @param b2 second factor of the second term @param a3 first factor of the third term @param b3 second factor of the third term @return a<sub>1</sub>&times;b<sub>1</sub> + a<sub>2</sub>&times;b<sub>2</sub> + a<sub>3</sub>&times;b<sub>3</sub> @see #linearCombination(double, double, double, double) @see #linearCombination(double, double, double, double, double, double, double, double) ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "MathUtils.normalizeAngle",
    "class_name": "org.apache.commons.math3.util.MathUtils",
    "signature": "org.apache.commons.math3.util.MathUtils.normalizeAngle(double,double)",
    "snippet": "     public static double normalizeAngle(double a, double center) {\n         return a - TWO_PI * FastMath.floor((a + FastMath.PI - center) / TWO_PI);\n     }",
    "comment": " Normalize an angle in a 2&pi wide interval around a center value. <p>This method has three main uses:</p> <ul> <li>normalize an angle between 0 and 2&pi;:<br/> {@code a = MathUtils.normalizeAngle(a, FastMath.PI);}</li> <li>normalize an angle between -&pi; and +&pi;<br/> {@code a = MathUtils.normalizeAngle(a, 0.0);}</li> <li>compute the angle between two defining angular positions:<br> {@code angle = MathUtils.normalizeAngle(end, start) - start;}</li> </ul> <p>Note that due to numerical accuracy and since &pi; cannot be represented exactly, the result interval is <em>closed</em>, it cannot be half-closed as would be more satisfactory in a purely mathematical view.</p> @param a angle to normalize @param center center of the desired 2&pi; interval for the result @return a-2k&pi; with integer k and center-&pi; &lt;= a-2k&pi; &lt;= center+&pi; @since 1.2 ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  }
]