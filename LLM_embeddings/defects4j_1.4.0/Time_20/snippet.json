[
  {
    "name": "DateTime.DateTime",
    "class_name": "org.joda.time.DateTime",
    "signature": "org.joda.time.DateTime.DateTime(int,int,int,int,int,int,DateTimeZone)",
    "snippet": "    public DateTime(\n            int year,\n            int monthOfYear,\n            int dayOfMonth,\n            int hourOfDay,\n            int minuteOfHour,\n            int secondOfMinute,\n            DateTimeZone zone) {\n        super(year, monthOfYear, dayOfMonth,\n              hourOfDay, minuteOfHour, secondOfMinute, 0, zone);\n    }",
    "comment": " Constructs an instance from datetime field values using <code>ISOChronology</code> in the specified time zone. <p> If the specified time zone is null, the default zone is used.  @param year  the year @param monthOfYear  the month of the year @param dayOfMonth  the day of the month @param hourOfDay  the hour of the day @param minuteOfHour  the minute of the hour @param secondOfMinute  the second of the minute @param zone  the time zone, null means default time zone @since 2.0 ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "DateTimeFieldType.DateTimeFieldType",
    "class_name": "org.joda.time.DateTimeFieldType",
    "signature": "org.joda.time.DateTimeFieldType.DateTimeFieldType(String)",
    "snippet": "    protected DateTimeFieldType(String name) {\n        super();\n        iName = name;\n    }",
    "comment": " Constructor.  @param name  the name to use ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "DateTimeFieldType.centuryOfEra",
    "class_name": "org.joda.time.DateTimeFieldType",
    "signature": "org.joda.time.DateTimeFieldType.centuryOfEra()",
    "snippet": "    public static DateTimeFieldType centuryOfEra() {\n        return CENTURY_OF_ERA_TYPE;\n    }",
    "comment": " Get the century of era field type.  @return the DateTimeFieldType constant ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "DateTimeFieldType.clockhourOfDay",
    "class_name": "org.joda.time.DateTimeFieldType",
    "signature": "org.joda.time.DateTimeFieldType.clockhourOfDay()",
    "snippet": "    public static DateTimeFieldType clockhourOfDay() {\n        return CLOCKHOUR_OF_DAY_TYPE;\n    }",
    "comment": " Get the hour of day (offset to 1-24) field type.  @return the DateTimeFieldType constant ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "DateTimeFieldType.clockhourOfHalfday",
    "class_name": "org.joda.time.DateTimeFieldType",
    "signature": "org.joda.time.DateTimeFieldType.clockhourOfHalfday()",
    "snippet": "    public static DateTimeFieldType clockhourOfHalfday() {\n        return CLOCKHOUR_OF_HALFDAY_TYPE;\n    }",
    "comment": " Get the hour of am/pm (offset to 1-12) field type.  @return the DateTimeFieldType constant ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "DateTimeFieldType.dayOfMonth",
    "class_name": "org.joda.time.DateTimeFieldType",
    "signature": "org.joda.time.DateTimeFieldType.dayOfMonth()",
    "snippet": "    public static DateTimeFieldType dayOfMonth() {\n        return DAY_OF_MONTH_TYPE;\n    }",
    "comment": " Get the day of month field type.  @return the DateTimeFieldType constant ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "DateTimeFieldType.dayOfWeek",
    "class_name": "org.joda.time.DateTimeFieldType",
    "signature": "org.joda.time.DateTimeFieldType.dayOfWeek()",
    "snippet": "    public static DateTimeFieldType dayOfWeek() {\n        return DAY_OF_WEEK_TYPE;\n    }",
    "comment": " Get the day of week field type.  @return the DateTimeFieldType constant ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "DateTimeFieldType.dayOfYear",
    "class_name": "org.joda.time.DateTimeFieldType",
    "signature": "org.joda.time.DateTimeFieldType.dayOfYear()",
    "snippet": "    public static DateTimeFieldType dayOfYear() {\n        return DAY_OF_YEAR_TYPE;\n    }",
    "comment": " Get the day of year field type.  @return the DateTimeFieldType constant ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "DateTimeFieldType.era",
    "class_name": "org.joda.time.DateTimeFieldType",
    "signature": "org.joda.time.DateTimeFieldType.era()",
    "snippet": "    public static DateTimeFieldType era() {\n        return ERA_TYPE;\n    }",
    "comment": " Get the era field type.  @return the DateTimeFieldType constant ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "DateTimeFieldType.halfdayOfDay",
    "class_name": "org.joda.time.DateTimeFieldType",
    "signature": "org.joda.time.DateTimeFieldType.halfdayOfDay()",
    "snippet": "    public static DateTimeFieldType halfdayOfDay() {\n        return HALFDAY_OF_DAY_TYPE;\n    }",
    "comment": " Get the AM(0) PM(1) field type.  @return the DateTimeFieldType constant ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "DateTimeFieldType.hourOfDay",
    "class_name": "org.joda.time.DateTimeFieldType",
    "signature": "org.joda.time.DateTimeFieldType.hourOfDay()",
    "snippet": "    public static DateTimeFieldType hourOfDay() {\n        return HOUR_OF_DAY_TYPE;\n    }",
    "comment": " Get the hour of day (0-23) field type.  @return the DateTimeFieldType constant ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "DateTimeFieldType.hourOfHalfday",
    "class_name": "org.joda.time.DateTimeFieldType",
    "signature": "org.joda.time.DateTimeFieldType.hourOfHalfday()",
    "snippet": "    public static DateTimeFieldType hourOfHalfday() {\n        return HOUR_OF_HALFDAY_TYPE;\n    }",
    "comment": " Get the hour of am/pm (0-11) field type.  @return the DateTimeFieldType constant ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "DateTimeFieldType.millisOfDay",
    "class_name": "org.joda.time.DateTimeFieldType",
    "signature": "org.joda.time.DateTimeFieldType.millisOfDay()",
    "snippet": "    public static DateTimeFieldType millisOfDay() {\n        return MILLIS_OF_DAY_TYPE;\n    }",
    "comment": " Get the millis of day field type.  @return the DateTimeFieldType constant ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "DateTimeFieldType.millisOfSecond",
    "class_name": "org.joda.time.DateTimeFieldType",
    "signature": "org.joda.time.DateTimeFieldType.millisOfSecond()",
    "snippet": "    public static DateTimeFieldType millisOfSecond() {\n        return MILLIS_OF_SECOND_TYPE;\n    }",
    "comment": " Get the millis of second field type.  @return the DateTimeFieldType constant ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "DateTimeFieldType.minuteOfDay",
    "class_name": "org.joda.time.DateTimeFieldType",
    "signature": "org.joda.time.DateTimeFieldType.minuteOfDay()",
    "snippet": "    public static DateTimeFieldType minuteOfDay() {\n        return MINUTE_OF_DAY_TYPE;\n    }",
    "comment": " Get the minute of day field type.  @return the DateTimeFieldType constant ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "DateTimeFieldType.minuteOfHour",
    "class_name": "org.joda.time.DateTimeFieldType",
    "signature": "org.joda.time.DateTimeFieldType.minuteOfHour()",
    "snippet": "    public static DateTimeFieldType minuteOfHour() {\n        return MINUTE_OF_HOUR_TYPE;\n    }",
    "comment": " Get the minute of hour field type.  @return the DateTimeFieldType constant ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "DateTimeFieldType.monthOfYear",
    "class_name": "org.joda.time.DateTimeFieldType",
    "signature": "org.joda.time.DateTimeFieldType.monthOfYear()",
    "snippet": "    public static DateTimeFieldType monthOfYear() {\n        return MONTH_OF_YEAR_TYPE;\n    }",
    "comment": " Get the month of year field type.  @return the DateTimeFieldType constant ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "DateTimeFieldType.secondOfDay",
    "class_name": "org.joda.time.DateTimeFieldType",
    "signature": "org.joda.time.DateTimeFieldType.secondOfDay()",
    "snippet": "    public static DateTimeFieldType secondOfDay() {\n        return SECOND_OF_DAY_TYPE;\n    }",
    "comment": " Get the second of day field type.  @return the DateTimeFieldType constant ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "DateTimeFieldType.secondOfMinute",
    "class_name": "org.joda.time.DateTimeFieldType",
    "signature": "org.joda.time.DateTimeFieldType.secondOfMinute()",
    "snippet": "    public static DateTimeFieldType secondOfMinute() {\n        return SECOND_OF_MINUTE_TYPE;\n    }",
    "comment": " Get the second of minute field type.  @return the DateTimeFieldType constant ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "DateTimeFieldType.weekOfWeekyear",
    "class_name": "org.joda.time.DateTimeFieldType",
    "signature": "org.joda.time.DateTimeFieldType.weekOfWeekyear()",
    "snippet": "    public static DateTimeFieldType weekOfWeekyear() {\n        return WEEK_OF_WEEKYEAR_TYPE;\n    }",
    "comment": " Get the week of a week based year field type.  @return the DateTimeFieldType constant ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "DateTimeFieldType.weekyear",
    "class_name": "org.joda.time.DateTimeFieldType",
    "signature": "org.joda.time.DateTimeFieldType.weekyear()",
    "snippet": "    public static DateTimeFieldType weekyear() {\n        return WEEKYEAR_TYPE;\n    }",
    "comment": " Get the year of a week based year field type.  @return the DateTimeFieldType constant ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "DateTimeFieldType.weekyearOfCentury",
    "class_name": "org.joda.time.DateTimeFieldType",
    "signature": "org.joda.time.DateTimeFieldType.weekyearOfCentury()",
    "snippet": "    public static DateTimeFieldType weekyearOfCentury() {\n        return WEEKYEAR_OF_CENTURY_TYPE;\n    }",
    "comment": " Get the year of a week based year within a century field type.  @return the DateTimeFieldType constant ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "DateTimeFieldType.year",
    "class_name": "org.joda.time.DateTimeFieldType",
    "signature": "org.joda.time.DateTimeFieldType.year()",
    "snippet": "    public static DateTimeFieldType year() {\n        return YEAR_TYPE;\n    }",
    "comment": " Get the year field type.  @return the DateTimeFieldType constant ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "DateTimeFieldType.yearOfCentury",
    "class_name": "org.joda.time.DateTimeFieldType",
    "signature": "org.joda.time.DateTimeFieldType.yearOfCentury()",
    "snippet": "    public static DateTimeFieldType yearOfCentury() {\n        return YEAR_OF_CENTURY_TYPE;\n    }",
    "comment": " Get the year of century field type.  @return the DateTimeFieldType constant ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "DateTimeFieldType.yearOfEra",
    "class_name": "org.joda.time.DateTimeFieldType",
    "signature": "org.joda.time.DateTimeFieldType.yearOfEra()",
    "snippet": "    public static DateTimeFieldType yearOfEra() {\n        return YEAR_OF_ERA_TYPE;\n    }",
    "comment": " Get the year of era field type.  @return the DateTimeFieldType constant ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "StandardDateTimeFieldType.getDurationType",
    "class_name": "org.joda.time.DateTimeFieldType$StandardDateTimeFieldType",
    "signature": "org.joda.time.DateTimeFieldType$StandardDateTimeFieldType.getDurationType()",
    "snippet": "        public DurationFieldType getDurationType() {\n            return iUnitType;\n        }",
    "comment": "@inheritdoc */",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "StandardDateTimeFieldType.getField",
    "class_name": "org.joda.time.DateTimeFieldType$StandardDateTimeFieldType",
    "signature": "org.joda.time.DateTimeFieldType$StandardDateTimeFieldType.getField(Chronology)",
    "snippet": "        public DateTimeField getField(Chronology chronology) {\n            chronology = DateTimeUtils.getChronology(chronology);\n\n            switch (iOrdinal) {\n                case ERA:\n                    return chronology.era();\n                case YEAR_OF_ERA:\n                    return chronology.yearOfEra();\n                case CENTURY_OF_ERA:\n                    return chronology.centuryOfEra();\n                case YEAR_OF_CENTURY:\n                    return chronology.yearOfCentury();\n                case YEAR:\n                    return chronology.year();\n                case DAY_OF_YEAR:\n                    return chronology.dayOfYear();\n                case MONTH_OF_YEAR:\n                    return chronology.monthOfYear();\n                case DAY_OF_MONTH:\n                    return chronology.dayOfMonth();\n                case WEEKYEAR_OF_CENTURY:\n                    return chronology.weekyearOfCentury();\n                case WEEKYEAR:\n                    return chronology.weekyear();\n                case WEEK_OF_WEEKYEAR:\n                    return chronology.weekOfWeekyear();\n                case DAY_OF_WEEK:\n                    return chronology.dayOfWeek();\n                case HALFDAY_OF_DAY:\n                    return chronology.halfdayOfDay();\n                case HOUR_OF_HALFDAY:\n                    return chronology.hourOfHalfday();\n                case CLOCKHOUR_OF_HALFDAY:\n                    return chronology.clockhourOfHalfday();\n                case CLOCKHOUR_OF_DAY:\n                    return chronology.clockhourOfDay();\n                case HOUR_OF_DAY:\n                    return chronology.hourOfDay();\n                case MINUTE_OF_DAY:\n                    return chronology.minuteOfDay();\n                case MINUTE_OF_HOUR:\n                    return chronology.minuteOfHour();\n                case SECOND_OF_DAY:\n                    return chronology.secondOfDay();\n                case SECOND_OF_MINUTE:\n                    return chronology.secondOfMinute();\n                case MILLIS_OF_DAY:\n                    return chronology.millisOfDay();\n                case MILLIS_OF_SECOND:\n                    return chronology.millisOfSecond();\n                default:\n                    // Shouldn't happen.\n                    throw new InternalError();\n            }\n        }",
    "comment": "@inheritdoc */",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "StandardDateTimeFieldType.getRangeDurationType",
    "class_name": "org.joda.time.DateTimeFieldType$StandardDateTimeFieldType",
    "signature": "org.joda.time.DateTimeFieldType$StandardDateTimeFieldType.getRangeDurationType()",
    "snippet": "        public DurationFieldType getRangeDurationType() {\n            return iRangeType;\n        }",
    "comment": "@inheritdoc */",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "DateTimeUtils.getChronology",
    "class_name": "org.joda.time.DateTimeUtils",
    "signature": "org.joda.time.DateTimeUtils.getChronology(Chronology)",
    "snippet": "    public static final Chronology getChronology(Chronology chrono) {\n        if (chrono == null) {\n            return ISOChronology.getInstance();\n        }\n        return chrono;\n    }",
    "comment": " Gets the chronology handling null. <p> If the chronology is <code>null</code>, {@link ISOChronology#getInstance()} will be returned. Otherwise, the chronology is returned.  @param chrono  the chronology to use, null means ISO in the default zone @return the chronology, never null ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "DateTimeUtils.getInstantChronology",
    "class_name": "org.joda.time.DateTimeUtils",
    "signature": "org.joda.time.DateTimeUtils.getInstantChronology(ReadableInstant)",
    "snippet": "    public static final Chronology getInstantChronology(ReadableInstant instant) {\n        if (instant == null) {\n            return ISOChronology.getInstance();\n        }\n        Chronology chrono = instant.getChronology();\n        if (chrono == null) {\n            return ISOChronology.getInstance();\n        }\n        return chrono;\n    }",
    "comment": " Gets the chronology from the specified instant object handling null. <p> If the instant object is <code>null</code>, or the instant's chronology is <code>null</code>, {@link ISOChronology#getInstance()} will be returned. Otherwise, the chronology from the object is returned.  @param instant  the instant to examine, null means ISO in the default zone @return the chronology, never null ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "DateTimeUtils.getInstantMillis",
    "class_name": "org.joda.time.DateTimeUtils",
    "signature": "org.joda.time.DateTimeUtils.getInstantMillis(ReadableInstant)",
    "snippet": "    public static final long getInstantMillis(ReadableInstant instant) {\n        if (instant == null) {\n            return DateTimeUtils.currentTimeMillis();\n        }\n        return instant.getMillis();\n    }",
    "comment": " Gets the millisecond instant from the specified instant object handling null. <p> If the instant object is <code>null</code>, the {@link #currentTimeMillis()} will be returned. Otherwise, the millis from the object are returned.  @param instant  the instant to examine, null means now @return the time in milliseconds from 1970-01-01T00:00:00Z ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "DateTimeZone.DateTimeZone",
    "class_name": "org.joda.time.DateTimeZone",
    "signature": "org.joda.time.DateTimeZone.DateTimeZone(String)",
    "snippet": "    protected DateTimeZone(String id) {\n        if (id == null) {\n            throw new IllegalArgumentException(\"Id must not be null\");\n        }\n        iID = id;\n    }",
    "comment": " Constructor.  @param id  the id to use @throws IllegalArgumentException if the id is null ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "DateTimeZone.forID",
    "class_name": "org.joda.time.DateTimeZone",
    "signature": "org.joda.time.DateTimeZone.forID(String)",
    "snippet": "    @FromString\n    public static DateTimeZone forID(String id) {\n        if (id == null) {\n            return getDefault();\n        }\n        if (id.equals(\"UTC\")) {\n            return DateTimeZone.UTC;\n        }\n        DateTimeZone zone = cProvider.getZone(id);\n        if (zone != null) {\n            return zone;\n        }\n        if (id.startsWith(\"+\") || id.startsWith(\"-\")) {\n            int offset = parseOffset(id);\n            if (offset == 0L) {\n                return DateTimeZone.UTC;\n            } else {\n                id = printOffset(offset);\n                return fixedOffsetZone(id, offset);\n            }\n        }\n        throw new IllegalArgumentException(\"The datetime zone id '\" + id + \"' is not recognised\");\n    }",
    "comment": " Gets a time zone instance for the specified time zone id. <p> The time zone id may be one of those returned by getAvailableIDs. Short ids, as accepted by {@link java.util.TimeZone}, are not accepted. All IDs must be specified in the long format. The exception is UTC, which is an acceptable id. <p> Alternatively a locale independent, fixed offset, datetime zone can be specified. The form <code>[+-]hh:mm</code> can be used.  @param id  the ID of the datetime zone, null means default @return the DateTimeZone object for the ID @throws IllegalArgumentException if the ID is not recognised ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "DateTimeZone.forTimeZone",
    "class_name": "org.joda.time.DateTimeZone",
    "signature": "org.joda.time.DateTimeZone.forTimeZone(TimeZone)",
    "snippet": "    public static DateTimeZone forTimeZone(TimeZone zone) {\n        if (zone == null) {\n            return getDefault();\n        }\n        final String id = zone.getID();\n        if (id.equals(\"UTC\")) {\n            return DateTimeZone.UTC;\n        }\n\n        // Convert from old alias before consulting provider since they may differ.\n        DateTimeZone dtz = null;\n        String convId = getConvertedId(id);\n        if (convId != null) {\n            dtz = cProvider.getZone(convId);\n        }\n        if (dtz == null) {\n            dtz = cProvider.getZone(id);\n        }\n        if (dtz != null) {\n            return dtz;\n        }\n\n        // Support GMT+/-hh:mm formats\n        if (convId == null) {\n            convId = zone.getDisplayName();\n            if (convId.startsWith(\"GMT+\") || convId.startsWith(\"GMT-\")) {\n                convId = convId.substring(3);\n                int offset = parseOffset(convId);\n                if (offset == 0L) {\n                    return DateTimeZone.UTC;\n                } else {\n                    convId = printOffset(offset);\n                    return fixedOffsetZone(convId, offset);\n                }\n            }\n        }\n        throw new IllegalArgumentException(\"The datetime zone id '\" + id + \"' is not recognised\");\n    }",
    "comment": " Gets a time zone instance for a JDK TimeZone. <p> DateTimeZone only accepts a subset of the IDs from TimeZone. The excluded IDs are the short three letter form (except UTC). This  method will attempt to convert between time zones created using the short IDs and the full version. <p> This method is not designed to parse time zones with rules created by applications using <code>SimpleTimeZone</code> directly.  @param zone  the zone to convert, null means default @return the DateTimeZone object for the zone @throws IllegalArgumentException if the zone is not recognised ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "DateTimeZone.getAvailableIDs",
    "class_name": "org.joda.time.DateTimeZone",
    "signature": "org.joda.time.DateTimeZone.getAvailableIDs()",
    "snippet": "    public static Set<String> getAvailableIDs() {\n        return cAvailableIDs;\n    }",
    "comment": " Gets all the available IDs supported.  @return an unmodifiable Set of String IDs ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "DateTimeZone.getConvertedId",
    "class_name": "org.joda.time.DateTimeZone",
    "signature": "org.joda.time.DateTimeZone.getConvertedId(String)",
    "snippet": "    private static synchronized String getConvertedId(String id) {\n        Map<String, String> map = cZoneIdConversion;\n        if (map == null) {\n            // Backwards compatibility with TimeZone.\n            map = new HashMap<String, String>();\n            map.put(\"GMT\", \"UTC\");\n            map.put(\"WET\", \"WET\");\n            map.put(\"CET\", \"CET\");\n            map.put(\"MET\", \"CET\");\n            map.put(\"ECT\", \"CET\");\n            map.put(\"EET\", \"EET\");\n            map.put(\"MIT\", \"Pacific/Apia\");\n            map.put(\"HST\", \"Pacific/Honolulu\");  // JDK 1.1 compatible\n            map.put(\"AST\", \"America/Anchorage\");\n            map.put(\"PST\", \"America/Los_Angeles\");\n            map.put(\"MST\", \"America/Denver\");  // JDK 1.1 compatible\n            map.put(\"PNT\", \"America/Phoenix\");\n            map.put(\"CST\", \"America/Chicago\");\n            map.put(\"EST\", \"America/New_York\");  // JDK 1.1 compatible\n            map.put(\"IET\", \"America/Indiana/Indianapolis\");\n            map.put(\"PRT\", \"America/Puerto_Rico\");\n            map.put(\"CNT\", \"America/St_Johns\");\n            map.put(\"AGT\", \"America/Argentina/Buenos_Aires\");\n            map.put(\"BET\", \"America/Sao_Paulo\");\n            map.put(\"ART\", \"Africa/Cairo\");\n            map.put(\"CAT\", \"Africa/Harare\");\n            map.put(\"EAT\", \"Africa/Addis_Ababa\");\n            map.put(\"NET\", \"Asia/Yerevan\");\n            map.put(\"PLT\", \"Asia/Karachi\");\n            map.put(\"IST\", \"Asia/Kolkata\");\n            map.put(\"BST\", \"Asia/Dhaka\");\n            map.put(\"VST\", \"Asia/Ho_Chi_Minh\");\n            map.put(\"CTT\", \"Asia/Shanghai\");\n            map.put(\"JST\", \"Asia/Tokyo\");\n            map.put(\"ACT\", \"Australia/Darwin\");\n            map.put(\"AET\", \"Australia/Sydney\");\n            map.put(\"SST\", \"Pacific/Guadalcanal\");\n            map.put(\"NST\", \"Pacific/Auckland\");\n            cZoneIdConversion = map;\n        }\n        return map.get(id);\n    }",
    "comment": " Converts an old style id to a new style id.  @param id  the old style id @return the new style id, null if not found ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "DateTimeZone.getDefault",
    "class_name": "org.joda.time.DateTimeZone",
    "signature": "org.joda.time.DateTimeZone.getDefault()",
    "snippet": "    public static DateTimeZone getDefault() {\n        DateTimeZone zone = cDefault;\n        if (zone == null) {\n            synchronized(DateTimeZone.class) {\n                zone = cDefault;\n                if (zone == null) {\n                    DateTimeZone temp = null;\n                    try {\n                        try {\n                            String id = System.getProperty(\"user.timezone\");\n                            if (id != null) {  // null check avoids stack overflow\n                                temp = forID(id);\n                            }\n                        } catch (RuntimeException ex) {\n                            // ignored\n                        }\n                        if (temp == null) {\n                            temp = forTimeZone(TimeZone.getDefault());\n                        }\n                    } catch (IllegalArgumentException ex) {\n                        // ignored\n                    }\n                    if (temp == null) {\n                        temp = UTC;\n                    }\n                    cDefault = zone = temp;\n                }\n            }\n        }\n        return zone;\n    }",
    "comment": " Gets the default time zone. <p> The default time zone is derived from the system property {@code user.timezone}. If that is {@code null} or is not a valid identifier, then the value of the JDK {@code TimeZone} default is converted. If that fails, {@code UTC} is used. <p> NOTE: If the {@code java.util.TimeZone} default is updated <i>after</i> calling this method, then the change will not be picked up here.  @return the default datetime zone object ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "DateTimeZone.getDefaultNameProvider",
    "class_name": "org.joda.time.DateTimeZone",
    "signature": "org.joda.time.DateTimeZone.getDefaultNameProvider()",
    "snippet": "    private static NameProvider getDefaultNameProvider() {\n        NameProvider nameProvider = null;\n        try {\n            String providerClass = System.getProperty(\"org.joda.time.DateTimeZone.NameProvider\");\n            if (providerClass != null) {\n                try {\n                    nameProvider = (NameProvider) Class.forName(providerClass).newInstance();\n                } catch (Exception ex) {\n                    Thread thread = Thread.currentThread();\n                    thread.getThreadGroup().uncaughtException(thread, ex);\n                }\n            }\n        } catch (SecurityException ex) {\n            // ignore\n        }\n\n        if (nameProvider == null) {\n            nameProvider = new DefaultNameProvider();\n        }\n\n        return nameProvider;\n    }",
    "comment": " Gets the default name provider. <p> Tries the system property <code>org.joda.time.DateTimeZone.NameProvider</code>. Then uses <code>DefaultNameProvider</code>.  @return the default name provider ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "DateTimeZone.getDefaultProvider",
    "class_name": "org.joda.time.DateTimeZone",
    "signature": "org.joda.time.DateTimeZone.getDefaultProvider()",
    "snippet": "    private static Provider getDefaultProvider() {\n        Provider provider = null;\n\n        try {\n            String providerClass =\n                System.getProperty(\"org.joda.time.DateTimeZone.Provider\");\n            if (providerClass != null) {\n                try {\n                    provider = (Provider) Class.forName(providerClass).newInstance();\n                } catch (Exception ex) {\n                    Thread thread = Thread.currentThread();\n                    thread.getThreadGroup().uncaughtException(thread, ex);\n                }\n            }\n        } catch (SecurityException ex) {\n            // ignored\n        }\n\n        if (provider == null) {\n            try {\n                provider = new ZoneInfoProvider(\"org/joda/time/tz/data\");\n            } catch (Exception ex) {\n                Thread thread = Thread.currentThread();\n                thread.getThreadGroup().uncaughtException(thread, ex);\n            }\n        }\n\n        if (provider == null) {\n            provider = new UTCProvider();\n        }\n\n        return provider;\n    }",
    "comment": " Gets the default zone provider. <p> Tries the system property <code>org.joda.time.DateTimeZone.Provider</code>. Then tries a <code>ZoneInfoProvider</code> using the data in <code>org/joda/time/tz/data</code>. Then uses <code>UTCProvider</code>.  @return the default name provider ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "DateTimeZone.getID",
    "class_name": "org.joda.time.DateTimeZone",
    "signature": "org.joda.time.DateTimeZone.getID()",
    "snippet": "    @ToString\n    public final String getID() {\n        return iID;\n    }",
    "comment": " Gets the ID of this datetime zone.  @return the ID of this datetime zone ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "DateTimeZone.getOffsetFromLocal",
    "class_name": "org.joda.time.DateTimeZone",
    "signature": "org.joda.time.DateTimeZone.getOffsetFromLocal(long)",
    "snippet": "    public int getOffsetFromLocal(long instantLocal) {\n        // get the offset at instantLocal (first estimate)\n        final int offsetLocal = getOffset(instantLocal);\n        // adjust instantLocal using the estimate and recalc the offset\n        final long instantAdjusted = instantLocal - offsetLocal;\n        final int offsetAdjusted = getOffset(instantAdjusted);\n        // if the offsets differ, we must be near a DST boundary\n        if (offsetLocal != offsetAdjusted) {\n            // we need to ensure that time is always after the DST gap\n            // this happens naturally for positive offsets, but not for negative\n            if ((offsetLocal - offsetAdjusted) < 0) {\n                // if we just return offsetAdjusted then the time is pushed\n                // back before the transition, whereas it should be\n                // on or after the transition\n                long nextLocal = nextTransition(instantAdjusted);\n                long nextAdjusted = nextTransition(instantLocal - offsetAdjusted);\n                if (nextLocal != nextAdjusted) {\n                    return offsetLocal;\n                }\n            }\n        } else if (offsetLocal > 0) {\n            long prev = previousTransition(instantAdjusted);\n            if (prev < instantAdjusted) {\n                int offsetPrev = getOffset(prev);\n                int diff = offsetPrev - offsetLocal;\n                if (instantAdjusted - prev <= diff) {\n                    return offsetPrev;\n                }\n            }\n        }\n        return offsetAdjusted;\n    }",
    "comment": " Gets the millisecond offset to subtract from local time to get UTC time. This offset can be used to undo adding the offset obtained by getOffset.  <pre> millisLocal == millisUTC   + getOffset(millisUTC) millisUTC   == millisLocal - getOffsetFromLocal(millisLocal) </pre>  NOTE: After calculating millisLocal, some error may be introduced. At offset transitions (due to DST or other historical changes), ranges of local times may map to different UTC times. <p> This method will return an offset suitable for calculating an instant after any DST gap. For example, consider a zone with a cutover from 01:00 to 01:59:<br /> Input: 00:00  Output: 00:00<br /> Input: 00:30  Output: 00:30<br /> Input: 01:00  Output: 02:00<br /> Input: 01:30  Output: 02:30<br /> Input: 02:00  Output: 02:00<br /> Input: 02:30  Output: 02:30<br /> <p> During a DST overlap (where the local time is ambiguous) this method will return the earlier instant. The combination of these two rules is to always favour daylight (summer) time over standard (winter) time. <p> NOTE: Prior to v2.0, the DST overlap behaviour was not defined and varied by hemisphere. Prior to v1.5, the DST gap behaviour was also not defined.  @param instantLocal  the millisecond instant, relative to this time zone, to get the offset for @return the millisecond offset to subtract from local time to get UTC time ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "DateTimeZone.hashCode",
    "class_name": "org.joda.time.DateTimeZone",
    "signature": "org.joda.time.DateTimeZone.hashCode()",
    "snippet": "    public int hashCode() {\n        return 57 + getID().hashCode();\n    }",
    "comment": " Gets a hash code compatable with equals.  @return suitable hashcode ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "DateTimeZone.setNameProvider0",
    "class_name": "org.joda.time.DateTimeZone",
    "signature": "org.joda.time.DateTimeZone.setNameProvider0(NameProvider)",
    "snippet": "    private static void setNameProvider0(NameProvider nameProvider) {\n        if (nameProvider == null) {\n            nameProvider = getDefaultNameProvider();\n        }\n        cNameProvider = nameProvider;\n    }",
    "comment": " Sets the name provider factory without performing the security check.  @param nameProvider  provider to use, or null for default @throws IllegalArgumentException if the provider is invalid ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "DateTimeZone.setProvider0",
    "class_name": "org.joda.time.DateTimeZone",
    "signature": "org.joda.time.DateTimeZone.setProvider0(Provider)",
    "snippet": "    private static void setProvider0(Provider provider) {\n        if (provider == null) {\n            provider = getDefaultProvider();\n        }\n        Set<String> ids = provider.getAvailableIDs();\n        if (ids == null || ids.size() == 0) {\n            throw new IllegalArgumentException\n                (\"The provider doesn't have any available ids\");\n        }\n        if (!ids.contains(\"UTC\")) {\n            throw new IllegalArgumentException(\"The provider doesn't support UTC\");\n        }\n        if (!UTC.equals(provider.getZone(\"UTC\"))) {\n            throw new IllegalArgumentException(\"Invalid UTC zone provided\");\n        }\n        cProvider = provider;\n        cAvailableIDs = ids;\n    }",
    "comment": " Sets the zone provider factory without performing the security check.  @param provider  provider to use, or null for default @throws IllegalArgumentException if the provider is invalid ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "DurationFieldType.DurationFieldType",
    "class_name": "org.joda.time.DurationFieldType",
    "signature": "org.joda.time.DurationFieldType.DurationFieldType(String)",
    "snippet": "    protected DurationFieldType(String name) {\n        super();\n        iName = name;\n    }",
    "comment": " Constructor.  @param name  the name to use, which by convention, are plural. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "DurationFieldType.centuries",
    "class_name": "org.joda.time.DurationFieldType",
    "signature": "org.joda.time.DurationFieldType.centuries()",
    "snippet": "    public static DurationFieldType centuries() {\n        return CENTURIES_TYPE;\n    }",
    "comment": " Get the centuries field type.  @return the DateTimeFieldType constant ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "DurationFieldType.days",
    "class_name": "org.joda.time.DurationFieldType",
    "signature": "org.joda.time.DurationFieldType.days()",
    "snippet": "    public static DurationFieldType days() {\n        return DAYS_TYPE;\n    }",
    "comment": " Get the days field type.  @return the DateTimeFieldType constant ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "DurationFieldType.eras",
    "class_name": "org.joda.time.DurationFieldType",
    "signature": "org.joda.time.DurationFieldType.eras()",
    "snippet": "    public static DurationFieldType eras() {\n        return ERAS_TYPE;\n    }",
    "comment": " Get the eras field type.  @return the DateTimeFieldType constant ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "DurationFieldType.halfdays",
    "class_name": "org.joda.time.DurationFieldType",
    "signature": "org.joda.time.DurationFieldType.halfdays()",
    "snippet": "    public static DurationFieldType halfdays() {\n        return HALFDAYS_TYPE;\n    }",
    "comment": " Get the halfdays field type.  @return the DateTimeFieldType constant ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "DurationFieldType.hours",
    "class_name": "org.joda.time.DurationFieldType",
    "signature": "org.joda.time.DurationFieldType.hours()",
    "snippet": "    public static DurationFieldType hours() {\n        return HOURS_TYPE;\n    }",
    "comment": " Get the hours field type.  @return the DateTimeFieldType constant ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "DurationFieldType.millis",
    "class_name": "org.joda.time.DurationFieldType",
    "signature": "org.joda.time.DurationFieldType.millis()",
    "snippet": "    public static DurationFieldType millis() {\n        return MILLIS_TYPE;\n    }",
    "comment": " Get the millis field type.  @return the DateTimeFieldType constant ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "DurationFieldType.minutes",
    "class_name": "org.joda.time.DurationFieldType",
    "signature": "org.joda.time.DurationFieldType.minutes()",
    "snippet": "    public static DurationFieldType minutes() {\n        return MINUTES_TYPE;\n    }",
    "comment": " Get the minutes field type.  @return the DateTimeFieldType constant ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "DurationFieldType.months",
    "class_name": "org.joda.time.DurationFieldType",
    "signature": "org.joda.time.DurationFieldType.months()",
    "snippet": "    public static DurationFieldType months() {\n        return MONTHS_TYPE;\n    }",
    "comment": " Get the months field type.  @return the DateTimeFieldType constant ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "DurationFieldType.seconds",
    "class_name": "org.joda.time.DurationFieldType",
    "signature": "org.joda.time.DurationFieldType.seconds()",
    "snippet": "    public static DurationFieldType seconds() {\n        return SECONDS_TYPE;\n    }",
    "comment": " Get the seconds field type.  @return the DateTimeFieldType constant ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "DurationFieldType.weeks",
    "class_name": "org.joda.time.DurationFieldType",
    "signature": "org.joda.time.DurationFieldType.weeks()",
    "snippet": "    public static DurationFieldType weeks() {\n        return WEEKS_TYPE;\n    }",
    "comment": " Get the weeks field type.  @return the DateTimeFieldType constant ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "DurationFieldType.weekyears",
    "class_name": "org.joda.time.DurationFieldType",
    "signature": "org.joda.time.DurationFieldType.weekyears()",
    "snippet": "    public static DurationFieldType weekyears() {\n        return WEEKYEARS_TYPE;\n    }",
    "comment": " Get the weekyears field type.  @return the DateTimeFieldType constant ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "DurationFieldType.years",
    "class_name": "org.joda.time.DurationFieldType",
    "signature": "org.joda.time.DurationFieldType.years()",
    "snippet": "    public static DurationFieldType years() {\n        return YEARS_TYPE;\n    }",
    "comment": " Get the years field type.  @return the DateTimeFieldType constant ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "AbstractDateTime.AbstractDateTime",
    "class_name": "org.joda.time.base.AbstractDateTime",
    "signature": "org.joda.time.base.AbstractDateTime.AbstractDateTime()",
    "snippet": "    protected AbstractDateTime() {\n        super();\n    }",
    "comment": " Constructor. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "AbstractInstant.AbstractInstant",
    "class_name": "org.joda.time.base.AbstractInstant",
    "signature": "org.joda.time.base.AbstractInstant.AbstractInstant()",
    "snippet": "    protected AbstractInstant() {\n        super();\n    }",
    "comment": " Constructor. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "BaseDateTime.BaseDateTime",
    "class_name": "org.joda.time.base.BaseDateTime",
    "signature": "org.joda.time.base.BaseDateTime.BaseDateTime(int,int,int,int,int,int,int,Chronology)",
    "snippet": "    public BaseDateTime(\n            int year,\n            int monthOfYear,\n            int dayOfMonth,\n            int hourOfDay,\n            int minuteOfHour,\n            int secondOfMinute,\n            int millisOfSecond,\n            Chronology chronology) {\n        super();\n        iChronology = checkChronology(chronology);\n        long instant = iChronology.getDateTimeMillis(year, monthOfYear, dayOfMonth,\n            hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond);\n        iMillis = checkInstant(instant, iChronology);\n    }",
    "comment": " Constructs an instance from datetime field values using the specified chronology. <p> If the chronology is null, <code>ISOChronology</code> in the default time zone is used.  @param year  the year @param monthOfYear  the month of the year @param dayOfMonth  the day of the month @param hourOfDay  the hour of the day @param minuteOfHour  the minute of the hour @param secondOfMinute  the second of the minute @param millisOfSecond  the millisecond of the second @param chronology  the chronology, null means ISOChronology in default zone ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "BaseDateTime.BaseDateTime",
    "class_name": "org.joda.time.base.BaseDateTime",
    "signature": "org.joda.time.base.BaseDateTime.BaseDateTime(int,int,int,int,int,int,int,DateTimeZone)",
    "snippet": "    public BaseDateTime(\n            int year,\n            int monthOfYear,\n            int dayOfMonth,\n            int hourOfDay,\n            int minuteOfHour,\n            int secondOfMinute,\n            int millisOfSecond,\n            DateTimeZone zone) {\n        this(year, monthOfYear, dayOfMonth, hourOfDay,\n            minuteOfHour, secondOfMinute, millisOfSecond, ISOChronology.getInstance(zone));\n    }",
    "comment": " Constructs an instance from datetime field values using <code>ISOChronology</code> in the specified time zone. <p> If the specified time zone is null, the default zone is used.  @param year  the year @param monthOfYear  the month of the year @param dayOfMonth  the day of the month @param hourOfDay  the hour of the day @param minuteOfHour  the minute of the hour @param secondOfMinute  the second of the minute @param millisOfSecond  the millisecond of the second @param zone  the time zone, null means default time zone ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "BaseDateTime.checkChronology",
    "class_name": "org.joda.time.base.BaseDateTime",
    "signature": "org.joda.time.base.BaseDateTime.checkChronology(Chronology)",
    "snippet": "    protected Chronology checkChronology(Chronology chronology) {\n        return DateTimeUtils.getChronology(chronology);\n    }",
    "comment": " Checks the specified chronology before storing it, potentially altering it. This method must not access any instance variables. <p> This implementation converts nulls to ISOChronology in the default zone.  @param chronology  the chronology to use, may be null @return the chronology to store in this datetime, not null ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "BaseDateTime.checkInstant",
    "class_name": "org.joda.time.base.BaseDateTime",
    "signature": "org.joda.time.base.BaseDateTime.checkInstant(long,Chronology)",
    "snippet": "    protected long checkInstant(long instant, Chronology chronology) {\n        return instant;\n    }",
    "comment": " Checks the specified instant before storing it, potentially altering it. This method must not access any instance variables. <p> This implementation simply returns the instant.  @param instant  the milliseconds from 1970-01-01T00:00:00Z to round @param chronology  the chronology to use, not null @return the instant to store in this datetime ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "BaseDateTime.getChronology",
    "class_name": "org.joda.time.base.BaseDateTime",
    "signature": "org.joda.time.base.BaseDateTime.getChronology()",
    "snippet": "    public Chronology getChronology() {\n        return iChronology;\n    }",
    "comment": " Gets the chronology of the datetime.  @return the Chronology that the datetime is using ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "BaseDateTime.getMillis",
    "class_name": "org.joda.time.base.BaseDateTime",
    "signature": "org.joda.time.base.BaseDateTime.getMillis()",
    "snippet": "    public long getMillis() {\n        return iMillis;\n    }",
    "comment": " Gets the milliseconds of the datetime instant from the Java epoch of 1970-01-01T00:00:00Z.  @return the number of milliseconds since 1970-01-01T00:00:00Z ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "AssembledChronology.AssembledChronology",
    "class_name": "org.joda.time.chrono.AssembledChronology",
    "signature": "org.joda.time.chrono.AssembledChronology.AssembledChronology(Chronology,Object)",
    "snippet": "    protected AssembledChronology(Chronology base, Object param) {\n        iBase = base;\n        iParam = param;\n        setFields();\n    }",
    "comment": " Constructor calls the assemble method, enabling subclasses to define its supported fields. If a base chronology is supplied, the field set initially contains references to each base chronology field. <p> Other methods in this class will delegate to the base chronology, if it can be determined that the base chronology will produce the same results as AbstractChronology.  @param base optional base chronology to copy initial fields from @param param optional param object avalable for assemble method ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "AssembledChronology.centuries",
    "class_name": "org.joda.time.chrono.AssembledChronology",
    "signature": "org.joda.time.chrono.AssembledChronology.centuries()",
    "snippet": "    public final DurationField centuries() {\n        return iCenturies;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "AssembledChronology.centuryOfEra",
    "class_name": "org.joda.time.chrono.AssembledChronology",
    "signature": "org.joda.time.chrono.AssembledChronology.centuryOfEra()",
    "snippet": "    public final DateTimeField centuryOfEra() {\n        return iCenturyOfEra;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "AssembledChronology.clockhourOfDay",
    "class_name": "org.joda.time.chrono.AssembledChronology",
    "signature": "org.joda.time.chrono.AssembledChronology.clockhourOfDay()",
    "snippet": "    public final DateTimeField clockhourOfDay() {\n        return iClockhourOfDay;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "AssembledChronology.clockhourOfHalfday",
    "class_name": "org.joda.time.chrono.AssembledChronology",
    "signature": "org.joda.time.chrono.AssembledChronology.clockhourOfHalfday()",
    "snippet": "    public final DateTimeField clockhourOfHalfday() {\n        return iClockhourOfHalfday;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "AssembledChronology.dayOfMonth",
    "class_name": "org.joda.time.chrono.AssembledChronology",
    "signature": "org.joda.time.chrono.AssembledChronology.dayOfMonth()",
    "snippet": "    public final DateTimeField dayOfMonth() {\n        return iDayOfMonth;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "AssembledChronology.dayOfWeek",
    "class_name": "org.joda.time.chrono.AssembledChronology",
    "signature": "org.joda.time.chrono.AssembledChronology.dayOfWeek()",
    "snippet": "    public final DateTimeField dayOfWeek() {\n        return iDayOfWeek;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "AssembledChronology.dayOfYear",
    "class_name": "org.joda.time.chrono.AssembledChronology",
    "signature": "org.joda.time.chrono.AssembledChronology.dayOfYear()",
    "snippet": "    public final DateTimeField dayOfYear() {\n        return iDayOfYear;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "AssembledChronology.days",
    "class_name": "org.joda.time.chrono.AssembledChronology",
    "signature": "org.joda.time.chrono.AssembledChronology.days()",
    "snippet": "    public final DurationField days() {\n        return iDays;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "AssembledChronology.era",
    "class_name": "org.joda.time.chrono.AssembledChronology",
    "signature": "org.joda.time.chrono.AssembledChronology.era()",
    "snippet": "    public final DateTimeField era() {\n        return iEra;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "AssembledChronology.eras",
    "class_name": "org.joda.time.chrono.AssembledChronology",
    "signature": "org.joda.time.chrono.AssembledChronology.eras()",
    "snippet": "    public final DurationField eras() {\n        return iEras;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "AssembledChronology.getBase",
    "class_name": "org.joda.time.chrono.AssembledChronology",
    "signature": "org.joda.time.chrono.AssembledChronology.getBase()",
    "snippet": "    protected final Chronology getBase() {\n        return iBase;\n    }",
    "comment": " Returns the same base chronology as passed into the constructor. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "AssembledChronology.getDateTimeMillis",
    "class_name": "org.joda.time.chrono.AssembledChronology",
    "signature": "org.joda.time.chrono.AssembledChronology.getDateTimeMillis(int,int,int,int,int,int,int)",
    "snippet": "    public long getDateTimeMillis(int year, int monthOfYear, int dayOfMonth,\n                                  int hourOfDay, int minuteOfHour,\n                                  int secondOfMinute, int millisOfSecond)\n        throws IllegalArgumentException\n    {\n        Chronology base;\n        if ((base = iBase) != null && (iBaseFlags & 5) == 5) {\n            // Only call specialized implementation if applicable fields are the same.\n            return base.getDateTimeMillis(year, monthOfYear, dayOfMonth,\n                                          hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond);\n        }\n        return super.getDateTimeMillis(year, monthOfYear, dayOfMonth,\n                                       hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond);\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "AssembledChronology.getParam",
    "class_name": "org.joda.time.chrono.AssembledChronology",
    "signature": "org.joda.time.chrono.AssembledChronology.getParam()",
    "snippet": "    protected final Object getParam() {\n        return iParam;\n    }",
    "comment": " Returns the same param object as passed into the constructor. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "AssembledChronology.getZone",
    "class_name": "org.joda.time.chrono.AssembledChronology",
    "signature": "org.joda.time.chrono.AssembledChronology.getZone()",
    "snippet": "    public DateTimeZone getZone() {\n        Chronology base;\n        if ((base = iBase) != null) {\n            return base.getZone();\n        }\n        return null;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "AssembledChronology.halfdayOfDay",
    "class_name": "org.joda.time.chrono.AssembledChronology",
    "signature": "org.joda.time.chrono.AssembledChronology.halfdayOfDay()",
    "snippet": "    public final DateTimeField halfdayOfDay() {\n        return iHalfdayOfDay;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "AssembledChronology.halfdays",
    "class_name": "org.joda.time.chrono.AssembledChronology",
    "signature": "org.joda.time.chrono.AssembledChronology.halfdays()",
    "snippet": "    public final DurationField halfdays() {\n        return iHalfdays;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "AssembledChronology.hourOfDay",
    "class_name": "org.joda.time.chrono.AssembledChronology",
    "signature": "org.joda.time.chrono.AssembledChronology.hourOfDay()",
    "snippet": "    public final DateTimeField hourOfDay() {\n        return iHourOfDay;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "AssembledChronology.hourOfHalfday",
    "class_name": "org.joda.time.chrono.AssembledChronology",
    "signature": "org.joda.time.chrono.AssembledChronology.hourOfHalfday()",
    "snippet": "    public final DateTimeField hourOfHalfday() {\n        return iHourOfHalfday;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "AssembledChronology.hours",
    "class_name": "org.joda.time.chrono.AssembledChronology",
    "signature": "org.joda.time.chrono.AssembledChronology.hours()",
    "snippet": "    public final DurationField hours() {\n        return iHours;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "AssembledChronology.millis",
    "class_name": "org.joda.time.chrono.AssembledChronology",
    "signature": "org.joda.time.chrono.AssembledChronology.millis()",
    "snippet": "    public final DurationField millis() {\n        return iMillis;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "AssembledChronology.millisOfDay",
    "class_name": "org.joda.time.chrono.AssembledChronology",
    "signature": "org.joda.time.chrono.AssembledChronology.millisOfDay()",
    "snippet": "    public final DateTimeField millisOfDay() {\n        return iMillisOfDay;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "AssembledChronology.millisOfSecond",
    "class_name": "org.joda.time.chrono.AssembledChronology",
    "signature": "org.joda.time.chrono.AssembledChronology.millisOfSecond()",
    "snippet": "    public final DateTimeField millisOfSecond() {\n        return iMillisOfSecond;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "AssembledChronology.minuteOfDay",
    "class_name": "org.joda.time.chrono.AssembledChronology",
    "signature": "org.joda.time.chrono.AssembledChronology.minuteOfDay()",
    "snippet": "    public final DateTimeField minuteOfDay() {\n        return iMinuteOfDay;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "AssembledChronology.minuteOfHour",
    "class_name": "org.joda.time.chrono.AssembledChronology",
    "signature": "org.joda.time.chrono.AssembledChronology.minuteOfHour()",
    "snippet": "    public final DateTimeField minuteOfHour() {\n        return iMinuteOfHour;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "AssembledChronology.minutes",
    "class_name": "org.joda.time.chrono.AssembledChronology",
    "signature": "org.joda.time.chrono.AssembledChronology.minutes()",
    "snippet": "    public final DurationField minutes() {\n        return iMinutes;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "AssembledChronology.monthOfYear",
    "class_name": "org.joda.time.chrono.AssembledChronology",
    "signature": "org.joda.time.chrono.AssembledChronology.monthOfYear()",
    "snippet": "    public final DateTimeField monthOfYear() {\n        return iMonthOfYear;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "AssembledChronology.months",
    "class_name": "org.joda.time.chrono.AssembledChronology",
    "signature": "org.joda.time.chrono.AssembledChronology.months()",
    "snippet": "    public final DurationField months() {\n        return iMonths;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "AssembledChronology.secondOfDay",
    "class_name": "org.joda.time.chrono.AssembledChronology",
    "signature": "org.joda.time.chrono.AssembledChronology.secondOfDay()",
    "snippet": "    public final DateTimeField secondOfDay() {\n        return iSecondOfDay;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "AssembledChronology.secondOfMinute",
    "class_name": "org.joda.time.chrono.AssembledChronology",
    "signature": "org.joda.time.chrono.AssembledChronology.secondOfMinute()",
    "snippet": "    public final DateTimeField secondOfMinute() {\n        return iSecondOfMinute;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "AssembledChronology.seconds",
    "class_name": "org.joda.time.chrono.AssembledChronology",
    "signature": "org.joda.time.chrono.AssembledChronology.seconds()",
    "snippet": "    public final DurationField seconds() {\n        return iSeconds;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "AssembledChronology.setFields",
    "class_name": "org.joda.time.chrono.AssembledChronology",
    "signature": "org.joda.time.chrono.AssembledChronology.setFields()",
    "snippet": "    private void setFields() {\n        Fields fields = new Fields();\n        if (iBase != null) {\n            fields.copyFieldsFrom(iBase);\n        }\n        assemble(fields);\n\n        {\n            DurationField f;\n            iMillis    = (f = fields.millis)    != null ? f : super.millis();\n            iSeconds   = (f = fields.seconds)   != null ? f : super.seconds();\n            iMinutes   = (f = fields.minutes)   != null ? f : super.minutes();\n            iHours     = (f = fields.hours)     != null ? f : super.hours();\n            iHalfdays  = (f = fields.halfdays)  != null ? f : super.halfdays();\n            iDays      = (f = fields.days)      != null ? f : super.days();\n            iWeeks     = (f = fields.weeks)     != null ? f : super.weeks();\n            iWeekyears = (f = fields.weekyears) != null ? f : super.weekyears();\n            iMonths    = (f = fields.months)    != null ? f : super.months();\n            iYears     = (f = fields.years)     != null ? f : super.years();\n            iCenturies = (f = fields.centuries) != null ? f : super.centuries();\n            iEras      = (f = fields.eras)      != null ? f : super.eras();\n        }\n\n        {\n            DateTimeField f;\n            iMillisOfSecond     = (f = fields.millisOfSecond)     != null ? f : super.millisOfSecond();\n            iMillisOfDay        = (f = fields.millisOfDay)        != null ? f : super.millisOfDay();\n            iSecondOfMinute     = (f = fields.secondOfMinute)     != null ? f : super.secondOfMinute();\n            iSecondOfDay        = (f = fields.secondOfDay)        != null ? f : super.secondOfDay();\n            iMinuteOfHour       = (f = fields.minuteOfHour)       != null ? f : super.minuteOfHour();\n            iMinuteOfDay        = (f = fields.minuteOfDay)        != null ? f : super.minuteOfDay();\n            iHourOfDay          = (f = fields.hourOfDay)          != null ? f : super.hourOfDay();\n            iClockhourOfDay     = (f = fields.clockhourOfDay)     != null ? f : super.clockhourOfDay();\n            iHourOfHalfday      = (f = fields.hourOfHalfday)      != null ? f : super.hourOfHalfday();\n            iClockhourOfHalfday = (f = fields.clockhourOfHalfday) != null ? f : super.clockhourOfHalfday();\n            iHalfdayOfDay       = (f = fields.halfdayOfDay)       != null ? f : super.halfdayOfDay();\n            iDayOfWeek          = (f = fields.dayOfWeek)          != null ? f : super.dayOfWeek();\n            iDayOfMonth         = (f = fields.dayOfMonth)         != null ? f : super.dayOfMonth();\n            iDayOfYear          = (f = fields.dayOfYear)          != null ? f : super.dayOfYear();\n            iWeekOfWeekyear     = (f = fields.weekOfWeekyear)     != null ? f : super.weekOfWeekyear();\n            iWeekyear           = (f = fields.weekyear)           != null ? f : super.weekyear();\n            iWeekyearOfCentury  = (f = fields.weekyearOfCentury)  != null ? f : super.weekyearOfCentury();\n            iMonthOfYear        = (f = fields.monthOfYear)        != null ? f : super.monthOfYear();\n            iYear               = (f = fields.year)               != null ? f : super.year();\n            iYearOfEra          = (f = fields.yearOfEra)          != null ? f : super.yearOfEra();\n            iYearOfCentury      = (f = fields.yearOfCentury)      != null ? f : super.yearOfCentury();\n            iCenturyOfEra       = (f = fields.centuryOfEra)       != null ? f : super.centuryOfEra();\n            iEra                = (f = fields.era)                != null ? f : super.era();\n        }\n\n        int flags;\n        if (iBase == null) {\n            flags = 0;\n        } else {\n            flags = \n                ((iHourOfDay      == iBase.hourOfDay()      &&\n                  iMinuteOfHour   == iBase.minuteOfHour()   &&\n                  iSecondOfMinute == iBase.secondOfMinute() &&\n                  iMillisOfSecond == iBase.millisOfSecond()   ) ? 1 : 0) |\n\n                ((iMillisOfDay == iBase.millisOfDay()) ? 2 : 0) |\n\n                ((iYear        == iBase.year()        &&\n                  iMonthOfYear == iBase.monthOfYear() &&\n                  iDayOfMonth  == iBase.dayOfMonth()    ) ? 4 : 0);\n        }\n\n        iBaseFlags = flags;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "AssembledChronology.weekOfWeekyear",
    "class_name": "org.joda.time.chrono.AssembledChronology",
    "signature": "org.joda.time.chrono.AssembledChronology.weekOfWeekyear()",
    "snippet": "    public final DateTimeField weekOfWeekyear() {\n        return iWeekOfWeekyear;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "AssembledChronology.weeks",
    "class_name": "org.joda.time.chrono.AssembledChronology",
    "signature": "org.joda.time.chrono.AssembledChronology.weeks()",
    "snippet": "    public final DurationField weeks() {\n        return iWeeks;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "AssembledChronology.weekyear",
    "class_name": "org.joda.time.chrono.AssembledChronology",
    "signature": "org.joda.time.chrono.AssembledChronology.weekyear()",
    "snippet": "    public final DateTimeField weekyear() {\n        return iWeekyear;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "AssembledChronology.weekyearOfCentury",
    "class_name": "org.joda.time.chrono.AssembledChronology",
    "signature": "org.joda.time.chrono.AssembledChronology.weekyearOfCentury()",
    "snippet": "    public final DateTimeField weekyearOfCentury() {\n        return iWeekyearOfCentury;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "AssembledChronology.weekyears",
    "class_name": "org.joda.time.chrono.AssembledChronology",
    "signature": "org.joda.time.chrono.AssembledChronology.weekyears()",
    "snippet": "    public final DurationField weekyears() {\n        return iWeekyears;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "AssembledChronology.year",
    "class_name": "org.joda.time.chrono.AssembledChronology",
    "signature": "org.joda.time.chrono.AssembledChronology.year()",
    "snippet": "    public final DateTimeField year() {\n        return iYear;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "AssembledChronology.yearOfCentury",
    "class_name": "org.joda.time.chrono.AssembledChronology",
    "signature": "org.joda.time.chrono.AssembledChronology.yearOfCentury()",
    "snippet": "    public final DateTimeField yearOfCentury() {\n        return iYearOfCentury;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "AssembledChronology.yearOfEra",
    "class_name": "org.joda.time.chrono.AssembledChronology",
    "signature": "org.joda.time.chrono.AssembledChronology.yearOfEra()",
    "snippet": "    public final DateTimeField yearOfEra() {\n        return iYearOfEra;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "AssembledChronology.years",
    "class_name": "org.joda.time.chrono.AssembledChronology",
    "signature": "org.joda.time.chrono.AssembledChronology.years()",
    "snippet": "    public final DurationField years() {\n        return iYears;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "Fields.copyFieldsFrom",
    "class_name": "org.joda.time.chrono.AssembledChronology$Fields",
    "signature": "org.joda.time.chrono.AssembledChronology$Fields.copyFieldsFrom(Chronology)",
    "snippet": "        public void copyFieldsFrom(Chronology chrono) {\n            {\n                DurationField f;\n                if (isSupported(f = chrono.millis())) {\n                    millis = f;\n                }\n                if (isSupported(f = chrono.seconds())) {\n                    seconds = f;\n                }\n                if (isSupported(f = chrono.minutes())) {\n                    minutes = f;\n                }\n                if (isSupported(f = chrono.hours())) {\n                    hours = f;\n                }\n                if (isSupported(f = chrono.halfdays())) {\n                    halfdays = f;\n                }\n                if (isSupported(f = chrono.days())) {\n                    days = f;\n                }\n                if (isSupported(f = chrono.weeks())) {\n                    weeks = f;\n                }\n                if (isSupported(f = chrono.weekyears())) {\n                    weekyears = f;\n                }\n                if (isSupported(f = chrono.months())) {\n                    months = f;\n                }\n                if (isSupported(f = chrono.years())) {\n                    years = f;\n                }\n                if (isSupported(f = chrono.centuries())) {\n                    centuries = f;\n                }\n                if (isSupported(f = chrono.eras())) {\n                    eras = f;\n                }\n            }\n\n            {\n                DateTimeField f;\n                if (isSupported(f = chrono.millisOfSecond())) {\n                    millisOfSecond = f;\n                }\n                if (isSupported(f = chrono.millisOfDay())) {\n                    millisOfDay = f;\n                }\n                if (isSupported(f = chrono.secondOfMinute())) {\n                    secondOfMinute = f;\n                }\n                if (isSupported(f = chrono.secondOfDay())) {\n                    secondOfDay = f;\n                }\n                if (isSupported(f = chrono.minuteOfHour())) {\n                    minuteOfHour = f;\n                }\n                if (isSupported(f = chrono.minuteOfDay())) {\n                    minuteOfDay = f;\n                }\n                if (isSupported(f = chrono.hourOfDay())) {\n                    hourOfDay = f;\n                }\n                if (isSupported(f = chrono.clockhourOfDay())) {\n                    clockhourOfDay = f;\n                }\n                if (isSupported(f = chrono.hourOfHalfday())) {\n                    hourOfHalfday = f;\n                }\n                if (isSupported(f = chrono.clockhourOfHalfday())) {\n                    clockhourOfHalfday = f;\n                }\n                if (isSupported(f = chrono.halfdayOfDay())) {\n                    halfdayOfDay = f;\n                }\n                if (isSupported(f = chrono.dayOfWeek())) {\n                    dayOfWeek = f;\n                }\n                if (isSupported(f = chrono.dayOfMonth())) {\n                    dayOfMonth = f;\n                }\n                if (isSupported(f = chrono.dayOfYear())) {\n                    dayOfYear = f;\n                }\n                if (isSupported(f = chrono.weekOfWeekyear())) {\n                    weekOfWeekyear = f;\n                }\n                if (isSupported(f = chrono.weekyear())) {\n                    weekyear = f;\n                }\n                if (isSupported(f = chrono.weekyearOfCentury())) {\n                    weekyearOfCentury = f;\n                }\n                if (isSupported(f = chrono.monthOfYear())) {\n                    monthOfYear = f;\n                }\n                if (isSupported(f = chrono.year())) {\n                    year = f;\n                }\n                if (isSupported(f = chrono.yearOfEra())) {\n                    yearOfEra = f;\n                }\n                if (isSupported(f = chrono.yearOfCentury())) {\n                    yearOfCentury = f;\n                }\n                if (isSupported(f = chrono.centuryOfEra())) {\n                    centuryOfEra = f;\n                }\n                if (isSupported(f = chrono.era())) {\n                    era = f;\n                }\n            }\n        }",
    "comment": " Copy the supported fields from a chronology into this container. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "Fields.isSupported",
    "class_name": "org.joda.time.chrono.AssembledChronology$Fields",
    "signature": "org.joda.time.chrono.AssembledChronology$Fields.isSupported(DateTimeField)",
    "snippet": "        private static boolean isSupported(DateTimeField field) {\n            return field == null ? false : field.isSupported();\n        }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "Fields.isSupported",
    "class_name": "org.joda.time.chrono.AssembledChronology$Fields",
    "signature": "org.joda.time.chrono.AssembledChronology$Fields.isSupported(DurationField)",
    "snippet": "        private static boolean isSupported(DurationField field) {\n            return field == null ? false : field.isSupported();\n        }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "BaseChronology.BaseChronology",
    "class_name": "org.joda.time.chrono.BaseChronology",
    "signature": "org.joda.time.chrono.BaseChronology.BaseChronology()",
    "snippet": "    protected BaseChronology() {\n        super();\n    }",
    "comment": " Restricted constructor. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "BaseChronology.eras",
    "class_name": "org.joda.time.chrono.BaseChronology",
    "signature": "org.joda.time.chrono.BaseChronology.eras()",
    "snippet": "    public DurationField eras() {\n        return UnsupportedDurationField.getInstance(DurationFieldType.eras());\n    }",
    "comment": " Get the eras duration field for this chronology.  @return DurationField or UnsupportedDurationField if unsupported ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "BasicChronology.BasicChronology",
    "class_name": "org.joda.time.chrono.BasicChronology",
    "signature": "org.joda.time.chrono.BasicChronology.BasicChronology(Chronology,Object,int)",
    "snippet": "    BasicChronology(Chronology base, Object param, int minDaysInFirstWeek) {\n        super(base, param);\n\n        if (minDaysInFirstWeek < 1 || minDaysInFirstWeek > 7) {\n            throw new IllegalArgumentException\n                (\"Invalid min days in first week: \" + minDaysInFirstWeek);\n        }\n\n        iMinDaysInFirstWeek = minDaysInFirstWeek;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "BasicChronology.assemble",
    "class_name": "org.joda.time.chrono.BasicChronology",
    "signature": "org.joda.time.chrono.BasicChronology.assemble(Fields)",
    "snippet": "    protected void assemble(Fields fields) {\n        // First copy fields that are the same for all Gregorian and Julian\n        // chronologies.\n\n        fields.millis = cMillisField;\n        fields.seconds = cSecondsField;\n        fields.minutes = cMinutesField;\n        fields.hours = cHoursField;\n        fields.halfdays = cHalfdaysField;\n        fields.days = cDaysField;\n        fields.weeks = cWeeksField;\n\n        fields.millisOfSecond = cMillisOfSecondField;\n        fields.millisOfDay = cMillisOfDayField;\n        fields.secondOfMinute = cSecondOfMinuteField;\n        fields.secondOfDay = cSecondOfDayField;\n        fields.minuteOfHour = cMinuteOfHourField;\n        fields.minuteOfDay = cMinuteOfDayField;\n        fields.hourOfDay = cHourOfDayField;\n        fields.hourOfHalfday = cHourOfHalfdayField;\n        fields.clockhourOfDay = cClockhourOfDayField;\n        fields.clockhourOfHalfday = cClockhourOfHalfdayField;\n        fields.halfdayOfDay = cHalfdayOfDayField;\n\n        // Now create fields that have unique behavior for Gregorian and Julian\n        // chronologies.\n\n        fields.year = new BasicYearDateTimeField(this);\n        fields.yearOfEra = new GJYearOfEraDateTimeField(fields.year, this);\n\n        // Define one-based centuryOfEra and yearOfCentury.\n        DateTimeField field = new OffsetDateTimeField(\n            fields.yearOfEra, 99);\n        fields.centuryOfEra = new DividedDateTimeField(\n            field, DateTimeFieldType.centuryOfEra(), 100);\n        \n        field = new RemainderDateTimeField(\n            (DividedDateTimeField) fields.centuryOfEra);\n        fields.yearOfCentury = new OffsetDateTimeField(\n            field, DateTimeFieldType.yearOfCentury(), 1);\n\n        fields.era = new GJEraDateTimeField(this);\n        fields.dayOfWeek = new GJDayOfWeekDateTimeField(this, fields.days);\n        fields.dayOfMonth = new BasicDayOfMonthDateTimeField(this, fields.days);\n        fields.dayOfYear = new BasicDayOfYearDateTimeField(this, fields.days);\n        fields.monthOfYear = new GJMonthOfYearDateTimeField(this);\n        fields.weekyear = new BasicWeekyearDateTimeField(this);\n        fields.weekOfWeekyear = new BasicWeekOfWeekyearDateTimeField(this, fields.weeks);\n        \n        field = new RemainderDateTimeField(\n            fields.weekyear, DateTimeFieldType.weekyearOfCentury(), 100);\n        fields.weekyearOfCentury = new OffsetDateTimeField(\n            field, DateTimeFieldType.weekyearOfCentury(), 1);\n        \n        // The remaining (imprecise) durations are available from the newly\n        // created datetime fields.\n\n        fields.years = fields.year.getDurationField();\n        fields.centuries = fields.centuryOfEra.getDurationField();\n        fields.months = fields.monthOfYear.getDurationField();\n        fields.weekyears = fields.weekyear.getDurationField();\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "BasicChronology.getDateMidnightMillis",
    "class_name": "org.joda.time.chrono.BasicChronology",
    "signature": "org.joda.time.chrono.BasicChronology.getDateMidnightMillis(int,int,int)",
    "snippet": "    long getDateMidnightMillis(int year, int monthOfYear, int dayOfMonth) {\n        FieldUtils.verifyValueBounds(DateTimeFieldType.year(), year, getMinYear(), getMaxYear());\n        FieldUtils.verifyValueBounds(DateTimeFieldType.monthOfYear(), monthOfYear, 1, getMaxMonth(year));\n        FieldUtils.verifyValueBounds(DateTimeFieldType.dayOfMonth(), dayOfMonth, 1, getDaysInYearMonth(year, monthOfYear));\n        return getYearMonthDayMillis(year, monthOfYear, dayOfMonth);\n    }",
    "comment": " Gets the milliseconds for a date at midnight.  @param year  the year @param monthOfYear  the month @param dayOfMonth  the day @return the milliseconds ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "BasicChronology.getDateTimeMillis",
    "class_name": "org.joda.time.chrono.BasicChronology",
    "signature": "org.joda.time.chrono.BasicChronology.getDateTimeMillis(int,int,int,int,int,int,int)",
    "snippet": "    public long getDateTimeMillis(\n            int year, int monthOfYear, int dayOfMonth,\n            int hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond)\n            throws IllegalArgumentException {\n        Chronology base;\n        if ((base = getBase()) != null) {\n            return base.getDateTimeMillis(year, monthOfYear, dayOfMonth,\n                                          hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond);\n        }\n\n        FieldUtils.verifyValueBounds(DateTimeFieldType.hourOfDay(), hourOfDay, 0, 23);\n        FieldUtils.verifyValueBounds(DateTimeFieldType.minuteOfHour(), minuteOfHour, 0, 59);\n        FieldUtils.verifyValueBounds(DateTimeFieldType.secondOfMinute(), secondOfMinute, 0, 59);\n        FieldUtils.verifyValueBounds(DateTimeFieldType.millisOfSecond(), millisOfSecond, 0, 999);\n\n        return getDateMidnightMillis(year, monthOfYear, dayOfMonth)\n            + hourOfDay * DateTimeConstants.MILLIS_PER_HOUR\n            + minuteOfHour * DateTimeConstants.MILLIS_PER_MINUTE\n            + secondOfMinute * DateTimeConstants.MILLIS_PER_SECOND\n            + millisOfSecond;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "BasicChronology.getDayOfMonth",
    "class_name": "org.joda.time.chrono.BasicChronology",
    "signature": "org.joda.time.chrono.BasicChronology.getDayOfMonth(long)",
    "snippet": "    int getDayOfMonth(long millis) {\n        int year = getYear(millis);\n        int month = getMonthOfYear(millis, year);\n        return getDayOfMonth(millis, year, month);\n    }",
    "comment": " @param millis from 1970-01-01T00:00:00Z ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "BasicChronology.getDayOfMonth",
    "class_name": "org.joda.time.chrono.BasicChronology",
    "signature": "org.joda.time.chrono.BasicChronology.getDayOfMonth(long,int,int)",
    "snippet": "    int getDayOfMonth(long millis, int year, int month) {\n        long dateMillis = getYearMillis(year);\n        dateMillis += getTotalMillisByYearMonth(year, month);\n        return (int) ((millis - dateMillis) / DateTimeConstants.MILLIS_PER_DAY) + 1;\n    }",
    "comment": " @param millis from 1970-01-01T00:00:00Z @param year precalculated year of millis @param month precalculated month of millis ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "BasicChronology.getMaxMonth",
    "class_name": "org.joda.time.chrono.BasicChronology",
    "signature": "org.joda.time.chrono.BasicChronology.getMaxMonth()",
    "snippet": "    int getMaxMonth() {\n        return 12;\n    }",
    "comment": " Gets the maximum number of months.  @return 12 ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "BasicChronology.getMaxMonth",
    "class_name": "org.joda.time.chrono.BasicChronology",
    "signature": "org.joda.time.chrono.BasicChronology.getMaxMonth(int)",
    "snippet": "    int getMaxMonth(int year) {\n        return getMaxMonth();\n    }",
    "comment": " Gets the maximum month for the specified year. This implementation calls getMaxMonth().  @param year  the year @return the maximum month value ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "BasicChronology.getMonthOfYear",
    "class_name": "org.joda.time.chrono.BasicChronology",
    "signature": "org.joda.time.chrono.BasicChronology.getMonthOfYear(long)",
    "snippet": "    int getMonthOfYear(long millis) {\n        return getMonthOfYear(millis, getYear(millis));\n    }",
    "comment": " @param millis from 1970-01-01T00:00:00Z ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "BasicChronology.getYear",
    "class_name": "org.joda.time.chrono.BasicChronology",
    "signature": "org.joda.time.chrono.BasicChronology.getYear(long)",
    "snippet": "    int getYear(long instant) {\n        // Get an initial estimate of the year, and the millis value that\n        // represents the start of that year. Then verify estimate and fix if\n        // necessary.\n\n        // Initial estimate uses values divided by two to avoid overflow.\n        long unitMillis = getAverageMillisPerYearDividedByTwo();\n        long i2 = (instant >> 1) + getApproxMillisAtEpochDividedByTwo();\n        if (i2 < 0) {\n            i2 = i2 - unitMillis + 1;\n        }\n        int year = (int) (i2 / unitMillis);\n\n        long yearStart = getYearMillis(year);\n        long diff = instant - yearStart;\n\n        if (diff < 0) {\n            year--;\n        } else if (diff >= DateTimeConstants.MILLIS_PER_DAY * 365L) {\n            // One year may need to be added to fix estimate.\n            long oneYear;\n            if (isLeapYear(year)) {\n                oneYear = DateTimeConstants.MILLIS_PER_DAY * 366L;\n            } else {\n                oneYear = DateTimeConstants.MILLIS_PER_DAY * 365L;\n            }\n\n            yearStart += oneYear;\n\n            if (yearStart <= instant) {\n                // Didn't go too far, so actually add one year.\n                year++;\n            }\n        }\n\n        return year;\n    }",
    "comment": " @param instant millis from 1970-01-01T00:00:00Z ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "BasicChronology.getYearInfo",
    "class_name": "org.joda.time.chrono.BasicChronology",
    "signature": "org.joda.time.chrono.BasicChronology.getYearInfo(int)",
    "snippet": "    private YearInfo getYearInfo(int year) {\n        YearInfo info = iYearInfoCache[year & CACHE_MASK];\n        if (info == null || info.iYear != year) {\n            info = new YearInfo(year, calculateFirstDayOfYearMillis(year));\n            iYearInfoCache[year & CACHE_MASK] = info;\n        }\n        return info;\n    }",
    "comment": "Although accessed by multiple threads, this method doesn't need to be synchronized.",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "BasicChronology.getYearMillis",
    "class_name": "org.joda.time.chrono.BasicChronology",
    "signature": "org.joda.time.chrono.BasicChronology.getYearMillis(int)",
    "snippet": "    long getYearMillis(int year) {\n        return getYearInfo(year).iFirstDayMillis;\n    }",
    "comment": " Get the milliseconds for the start of a year.  @param year The year to use. @return millis from 1970-01-01T00:00:00Z ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "BasicChronology.getYearMonthDayMillis",
    "class_name": "org.joda.time.chrono.BasicChronology",
    "signature": "org.joda.time.chrono.BasicChronology.getYearMonthDayMillis(int,int,int)",
    "snippet": "    long getYearMonthDayMillis(int year, int month, int dayOfMonth) {\n        long millis = getYearMillis(year);\n        millis += getTotalMillisByYearMonth(year, month);\n        return millis + (dayOfMonth - 1) * (long)DateTimeConstants.MILLIS_PER_DAY;\n    }",
    "comment": " Get the milliseconds for a particular date.  @param year The year to use. @param month The month to use @param dayOfMonth The day of the month to use @return millis from 1970-01-01T00:00:00Z ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "BasicChronology.getZone",
    "class_name": "org.joda.time.chrono.BasicChronology",
    "signature": "org.joda.time.chrono.BasicChronology.getZone()",
    "snippet": "    public DateTimeZone getZone() {\n        Chronology base;\n        if ((base = getBase()) != null) {\n            return base.getZone();\n        }\n        return DateTimeZone.UTC;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "BasicDayOfMonthDateTimeField.BasicDayOfMonthDateTimeField",
    "class_name": "org.joda.time.chrono.BasicDayOfMonthDateTimeField",
    "signature": "org.joda.time.chrono.BasicDayOfMonthDateTimeField.BasicDayOfMonthDateTimeField(BasicChronology,DurationField)",
    "snippet": "    BasicDayOfMonthDateTimeField(BasicChronology chronology, DurationField days) {\n        super(DateTimeFieldType.dayOfMonth(), days);\n        iChronology = chronology;\n    }",
    "comment": " Restricted constructor. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "BasicDayOfMonthDateTimeField.get",
    "class_name": "org.joda.time.chrono.BasicDayOfMonthDateTimeField",
    "signature": "org.joda.time.chrono.BasicDayOfMonthDateTimeField.get(long)",
    "snippet": "    public int get(long instant) {\n        return iChronology.getDayOfMonth(instant);\n    }",
    "comment": "-----------------------------------------------------------------------",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "BasicDayOfMonthDateTimeField.getRangeDurationField",
    "class_name": "org.joda.time.chrono.BasicDayOfMonthDateTimeField",
    "signature": "org.joda.time.chrono.BasicDayOfMonthDateTimeField.getRangeDurationField()",
    "snippet": "    public DurationField getRangeDurationField() {\n        return iChronology.months();\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "BasicDayOfYearDateTimeField.BasicDayOfYearDateTimeField",
    "class_name": "org.joda.time.chrono.BasicDayOfYearDateTimeField",
    "signature": "org.joda.time.chrono.BasicDayOfYearDateTimeField.BasicDayOfYearDateTimeField(BasicChronology,DurationField)",
    "snippet": "    BasicDayOfYearDateTimeField(BasicChronology chronology, DurationField days) {\n        super(DateTimeFieldType.dayOfYear(), days);\n        iChronology = chronology;\n    }",
    "comment": " Restricted constructor ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "BasicDayOfYearDateTimeField.getRangeDurationField",
    "class_name": "org.joda.time.chrono.BasicDayOfYearDateTimeField",
    "signature": "org.joda.time.chrono.BasicDayOfYearDateTimeField.getRangeDurationField()",
    "snippet": "    public DurationField getRangeDurationField() {\n        return iChronology.years();\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "BasicGJChronology.BasicGJChronology",
    "class_name": "org.joda.time.chrono.BasicGJChronology",
    "signature": "org.joda.time.chrono.BasicGJChronology.BasicGJChronology(Chronology,Object,int)",
    "snippet": "    BasicGJChronology(Chronology base, Object param, int minDaysInFirstWeek) {\n        super(base, param, minDaysInFirstWeek);\n    }",
    "comment": " Constructor. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "BasicGJChronology.getDaysInYearMonth",
    "class_name": "org.joda.time.chrono.BasicGJChronology",
    "signature": "org.joda.time.chrono.BasicGJChronology.getDaysInYearMonth(int,int)",
    "snippet": "    int getDaysInYearMonth(int year, int month) {\n        if (isLeapYear(year)) {\n            return MAX_DAYS_PER_MONTH_ARRAY[month - 1];\n        } else {\n            return MIN_DAYS_PER_MONTH_ARRAY[month - 1];\n        }\n    }",
    "comment": " Gets the number of days in the specified month and year.  @param year  the year @param month  the month @return the number of days ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "BasicGJChronology.getMonthOfYear",
    "class_name": "org.joda.time.chrono.BasicGJChronology",
    "signature": "org.joda.time.chrono.BasicGJChronology.getMonthOfYear(long,int)",
    "snippet": "    int getMonthOfYear(long millis, int year) {\n        // Perform a binary search to get the month. To make it go even faster,\n        // compare using ints instead of longs. The number of milliseconds per\n        // year exceeds the limit of a 32-bit int's capacity, so divide by\n        // 1024. No precision is lost (except time of day) since the number of\n        // milliseconds per day contains 1024 as a factor. After the division,\n        // the instant isn't measured in milliseconds, but in units of\n        // (128/125)seconds.\n\n        int i = (int)((millis - getYearMillis(year)) >> 10);\n\n        // There are 86400000 milliseconds per day, but divided by 1024 is\n        // 84375. There are 84375 (128/125)seconds per day.\n\n        return\n            (isLeapYear(year))\n            ? ((i < 182 * 84375)\n               ? ((i < 91 * 84375)\n                  ? ((i < 31 * 84375) ? 1 : (i < 60 * 84375) ? 2 : 3)\n                  : ((i < 121 * 84375) ? 4 : (i < 152 * 84375) ? 5 : 6))\n               : ((i < 274 * 84375)\n                  ? ((i < 213 * 84375) ? 7 : (i < 244 * 84375) ? 8 : 9)\n                  : ((i < 305 * 84375) ? 10 : (i < 335 * 84375) ? 11 : 12)))\n            : ((i < 181 * 84375)\n               ? ((i < 90 * 84375)\n                  ? ((i < 31 * 84375) ? 1 : (i < 59 * 84375) ? 2 : 3)\n                  : ((i < 120 * 84375) ? 4 : (i < 151 * 84375) ? 5 : 6))\n               : ((i < 273 * 84375)\n                  ? ((i < 212 * 84375) ? 7 : (i < 243 * 84375) ? 8 : 9)\n                  : ((i < 304 * 84375) ? 10 : (i < 334 * 84375) ? 11 : 12)));\n    }",
    "comment": "-----------------------------------------------------------------------",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "BasicGJChronology.getTotalMillisByYearMonth",
    "class_name": "org.joda.time.chrono.BasicGJChronology",
    "signature": "org.joda.time.chrono.BasicGJChronology.getTotalMillisByYearMonth(int,int)",
    "snippet": "    long getTotalMillisByYearMonth(int year, int month) {\n        if (isLeapYear(year)) {\n            return MAX_TOTAL_MILLIS_BY_MONTH_ARRAY[month - 1];\n        } else {\n            return MIN_TOTAL_MILLIS_BY_MONTH_ARRAY[month - 1];\n        }\n    }",
    "comment": "-----------------------------------------------------------------------",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "BasicMonthOfYearDateTimeField.BasicMonthOfYearDateTimeField",
    "class_name": "org.joda.time.chrono.BasicMonthOfYearDateTimeField",
    "signature": "org.joda.time.chrono.BasicMonthOfYearDateTimeField.BasicMonthOfYearDateTimeField(BasicChronology,int)",
    "snippet": "    BasicMonthOfYearDateTimeField(BasicChronology chronology, int leapMonth) {\n        super(DateTimeFieldType.monthOfYear(), chronology.getAverageMillisPerMonth());\n        iChronology = chronology;\n        iMax = iChronology.getMaxMonth();\n        iLeapMonth = leapMonth;\n    }",
    "comment": " Restricted constructor.  @param leapMonth the month of year that leaps ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "BasicMonthOfYearDateTimeField.get",
    "class_name": "org.joda.time.chrono.BasicMonthOfYearDateTimeField",
    "signature": "org.joda.time.chrono.BasicMonthOfYearDateTimeField.get(long)",
    "snippet": "    public int get(long instant) {\n        return iChronology.getMonthOfYear(instant);\n    }",
    "comment": " Get the Month component of the specified time instant.  @see org.joda.time.DateTimeField#get(long) @see org.joda.time.ReadableDateTime#getMonthOfYear() @param instant  the time instant in millis to query. @return the month extracted from the input. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "BasicMonthOfYearDateTimeField.getLeapDurationField",
    "class_name": "org.joda.time.chrono.BasicMonthOfYearDateTimeField",
    "signature": "org.joda.time.chrono.BasicMonthOfYearDateTimeField.getLeapDurationField()",
    "snippet": "    public DurationField getLeapDurationField() {\n        return iChronology.days();\n    }",
    "comment": "-----------------------------------------------------------------------",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "BasicMonthOfYearDateTimeField.getRangeDurationField",
    "class_name": "org.joda.time.chrono.BasicMonthOfYearDateTimeField",
    "signature": "org.joda.time.chrono.BasicMonthOfYearDateTimeField.getRangeDurationField()",
    "snippet": "    public DurationField getRangeDurationField() {\n        return iChronology.years();\n    }",
    "comment": "-----------------------------------------------------------------------",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "BasicWeekOfWeekyearDateTimeField.BasicWeekOfWeekyearDateTimeField",
    "class_name": "org.joda.time.chrono.BasicWeekOfWeekyearDateTimeField",
    "signature": "org.joda.time.chrono.BasicWeekOfWeekyearDateTimeField.BasicWeekOfWeekyearDateTimeField(BasicChronology,DurationField)",
    "snippet": "    BasicWeekOfWeekyearDateTimeField(BasicChronology chronology, DurationField weeks) {\n        super(DateTimeFieldType.weekOfWeekyear(), weeks);\n        iChronology = chronology;\n    }",
    "comment": " Restricted constructor ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "BasicWeekOfWeekyearDateTimeField.getRangeDurationField",
    "class_name": "org.joda.time.chrono.BasicWeekOfWeekyearDateTimeField",
    "signature": "org.joda.time.chrono.BasicWeekOfWeekyearDateTimeField.getRangeDurationField()",
    "snippet": "    public DurationField getRangeDurationField() {\n        return iChronology.weekyears();\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "BasicWeekyearDateTimeField.BasicWeekyearDateTimeField",
    "class_name": "org.joda.time.chrono.BasicWeekyearDateTimeField",
    "signature": "org.joda.time.chrono.BasicWeekyearDateTimeField.BasicWeekyearDateTimeField(BasicChronology)",
    "snippet": "    BasicWeekyearDateTimeField(BasicChronology chronology) {\n        super(DateTimeFieldType.weekyear(), chronology.getAverageMillisPerYear());\n        iChronology = chronology;\n    }",
    "comment": " Restricted constructor ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "BasicWeekyearDateTimeField.getLeapDurationField",
    "class_name": "org.joda.time.chrono.BasicWeekyearDateTimeField",
    "signature": "org.joda.time.chrono.BasicWeekyearDateTimeField.getLeapDurationField()",
    "snippet": "    public DurationField getLeapDurationField() {\n        return iChronology.weeks();\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "BasicWeekyearDateTimeField.getRangeDurationField",
    "class_name": "org.joda.time.chrono.BasicWeekyearDateTimeField",
    "signature": "org.joda.time.chrono.BasicWeekyearDateTimeField.getRangeDurationField()",
    "snippet": "    public DurationField getRangeDurationField() {\n        return null;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "BasicYearDateTimeField.BasicYearDateTimeField",
    "class_name": "org.joda.time.chrono.BasicYearDateTimeField",
    "signature": "org.joda.time.chrono.BasicYearDateTimeField.BasicYearDateTimeField(BasicChronology)",
    "snippet": "    BasicYearDateTimeField(BasicChronology chronology) {\n        super(DateTimeFieldType.year(), chronology.getAverageMillisPerYear());\n        iChronology = chronology;\n    }",
    "comment": " Restricted constructor.  @param chronology  the chronology this field belogs to ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "BasicYearDateTimeField.get",
    "class_name": "org.joda.time.chrono.BasicYearDateTimeField",
    "signature": "org.joda.time.chrono.BasicYearDateTimeField.get(long)",
    "snippet": "    public int get(long instant) {\n        return iChronology.getYear(instant);\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "BasicYearDateTimeField.getLeapDurationField",
    "class_name": "org.joda.time.chrono.BasicYearDateTimeField",
    "signature": "org.joda.time.chrono.BasicYearDateTimeField.getLeapDurationField()",
    "snippet": "    public DurationField getLeapDurationField() {\n        return iChronology.days();\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "BasicYearDateTimeField.getMaximumValue",
    "class_name": "org.joda.time.chrono.BasicYearDateTimeField",
    "signature": "org.joda.time.chrono.BasicYearDateTimeField.getMaximumValue()",
    "snippet": "    public int getMaximumValue() {\n        return iChronology.getMaxYear();\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "BasicYearDateTimeField.getRangeDurationField",
    "class_name": "org.joda.time.chrono.BasicYearDateTimeField",
    "signature": "org.joda.time.chrono.BasicYearDateTimeField.getRangeDurationField()",
    "snippet": "    public DurationField getRangeDurationField() {\n        return null;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "GJDayOfWeekDateTimeField.GJDayOfWeekDateTimeField",
    "class_name": "org.joda.time.chrono.GJDayOfWeekDateTimeField",
    "signature": "org.joda.time.chrono.GJDayOfWeekDateTimeField.GJDayOfWeekDateTimeField(BasicChronology,DurationField)",
    "snippet": "    GJDayOfWeekDateTimeField(BasicChronology chronology, DurationField days) {\n        super(DateTimeFieldType.dayOfWeek(), days);\n        iChronology = chronology;\n    }",
    "comment": " Restricted constructor. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "GJDayOfWeekDateTimeField.getRangeDurationField",
    "class_name": "org.joda.time.chrono.GJDayOfWeekDateTimeField",
    "signature": "org.joda.time.chrono.GJDayOfWeekDateTimeField.getRangeDurationField()",
    "snippet": "    public DurationField getRangeDurationField() {\n        return iChronology.weeks();\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "GJEraDateTimeField.GJEraDateTimeField",
    "class_name": "org.joda.time.chrono.GJEraDateTimeField",
    "signature": "org.joda.time.chrono.GJEraDateTimeField.GJEraDateTimeField(BasicChronology)",
    "snippet": "    GJEraDateTimeField(BasicChronology chronology) {\n        super(DateTimeFieldType.era());\n        iChronology = chronology;\n    }",
    "comment": " Restricted constructor ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "GJEraDateTimeField.getDurationField",
    "class_name": "org.joda.time.chrono.GJEraDateTimeField",
    "signature": "org.joda.time.chrono.GJEraDateTimeField.getDurationField()",
    "snippet": "    public DurationField getDurationField() {\n        return UnsupportedDurationField.getInstance(DurationFieldType.eras());\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "GJEraDateTimeField.getRangeDurationField",
    "class_name": "org.joda.time.chrono.GJEraDateTimeField",
    "signature": "org.joda.time.chrono.GJEraDateTimeField.getRangeDurationField()",
    "snippet": "    public DurationField getRangeDurationField() {\n        return null;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "GJMonthOfYearDateTimeField.GJMonthOfYearDateTimeField",
    "class_name": "org.joda.time.chrono.GJMonthOfYearDateTimeField",
    "signature": "org.joda.time.chrono.GJMonthOfYearDateTimeField.GJMonthOfYearDateTimeField(BasicChronology)",
    "snippet": "    GJMonthOfYearDateTimeField(BasicChronology chronology) {\n        super(chronology, 2);\n    }",
    "comment": " Restricted constructor ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "GJYearOfEraDateTimeField.GJYearOfEraDateTimeField",
    "class_name": "org.joda.time.chrono.GJYearOfEraDateTimeField",
    "signature": "org.joda.time.chrono.GJYearOfEraDateTimeField.GJYearOfEraDateTimeField(DateTimeField,BasicChronology)",
    "snippet": "    GJYearOfEraDateTimeField(DateTimeField yearField, BasicChronology chronology) {\n        super(yearField, DateTimeFieldType.yearOfEra());\n        iChronology = chronology;\n    }",
    "comment": " Restricted constructor. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "GJYearOfEraDateTimeField.getMaximumValue",
    "class_name": "org.joda.time.chrono.GJYearOfEraDateTimeField",
    "signature": "org.joda.time.chrono.GJYearOfEraDateTimeField.getMaximumValue()",
    "snippet": "    public int getMaximumValue() {\n        return getWrappedField().getMaximumValue();\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "GJYearOfEraDateTimeField.getMinimumValue",
    "class_name": "org.joda.time.chrono.GJYearOfEraDateTimeField",
    "signature": "org.joda.time.chrono.GJYearOfEraDateTimeField.getMinimumValue()",
    "snippet": "    public int getMinimumValue() {\n        return 1;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "GregorianChronology.assemble",
    "class_name": "org.joda.time.chrono.GregorianChronology",
    "signature": "org.joda.time.chrono.GregorianChronology.assemble(Fields)",
    "snippet": "    protected void assemble(Fields fields) {\n        if (getBase() == null) {\n            super.assemble(fields);\n        }\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "GregorianChronology.calculateFirstDayOfYearMillis",
    "class_name": "org.joda.time.chrono.GregorianChronology",
    "signature": "org.joda.time.chrono.GregorianChronology.calculateFirstDayOfYearMillis(int)",
    "snippet": "    long calculateFirstDayOfYearMillis(int year) {\n        // Initial value is just temporary.\n        int leapYears = year / 100;\n        if (year < 0) {\n            // Add 3 before shifting right since /4 and >>2 behave differently\n            // on negative numbers. When the expression is written as\n            // (year / 4) - (year / 100) + (year / 400),\n            // it works for both positive and negative values, except this optimization\n            // eliminates two divisions.\n            leapYears = ((year + 3) >> 2) - leapYears + ((leapYears + 3) >> 2) - 1;\n        } else {\n            leapYears = (year >> 2) - leapYears + (leapYears >> 2);\n            if (isLeapYear(year)) {\n                leapYears--;\n            }\n        }\n\n        return (year * 365L + (leapYears - DAYS_0000_TO_1970)) * DateTimeConstants.MILLIS_PER_DAY;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "GregorianChronology.getApproxMillisAtEpochDividedByTwo",
    "class_name": "org.joda.time.chrono.GregorianChronology",
    "signature": "org.joda.time.chrono.GregorianChronology.getApproxMillisAtEpochDividedByTwo()",
    "snippet": "    long getApproxMillisAtEpochDividedByTwo() {\n        return (1970L * MILLIS_PER_YEAR) / 2;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "GregorianChronology.getAverageMillisPerMonth",
    "class_name": "org.joda.time.chrono.GregorianChronology",
    "signature": "org.joda.time.chrono.GregorianChronology.getAverageMillisPerMonth()",
    "snippet": "    long getAverageMillisPerMonth() {\n        return MILLIS_PER_MONTH;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "GregorianChronology.getAverageMillisPerYear",
    "class_name": "org.joda.time.chrono.GregorianChronology",
    "signature": "org.joda.time.chrono.GregorianChronology.getAverageMillisPerYear()",
    "snippet": "    long getAverageMillisPerYear() {\n        return MILLIS_PER_YEAR;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "GregorianChronology.getAverageMillisPerYearDividedByTwo",
    "class_name": "org.joda.time.chrono.GregorianChronology",
    "signature": "org.joda.time.chrono.GregorianChronology.getAverageMillisPerYearDividedByTwo()",
    "snippet": "    long getAverageMillisPerYearDividedByTwo() {\n        return MILLIS_PER_YEAR / 2;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "GregorianChronology.getInstance",
    "class_name": "org.joda.time.chrono.GregorianChronology",
    "signature": "org.joda.time.chrono.GregorianChronology.getInstance(DateTimeZone)",
    "snippet": "    public static GregorianChronology getInstance(DateTimeZone zone) {\n        return getInstance(zone, 4);\n    }",
    "comment": " Gets an instance of the GregorianChronology in the given time zone.  @param zone  the time zone to get the chronology in, null is default @return a chronology in the specified time zone ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "GregorianChronology.getInstance",
    "class_name": "org.joda.time.chrono.GregorianChronology",
    "signature": "org.joda.time.chrono.GregorianChronology.getInstance(DateTimeZone,int)",
    "snippet": "    public static GregorianChronology getInstance(DateTimeZone zone, int minDaysInFirstWeek) {\n        if (zone == null) {\n            zone = DateTimeZone.getDefault();\n        }\n        GregorianChronology chrono;\n        synchronized (cCache) {\n            GregorianChronology[] chronos = cCache.get(zone);\n            if (chronos == null) {\n                chronos = new GregorianChronology[7];\n                cCache.put(zone, chronos);\n            }\n            try {\n                chrono = chronos[minDaysInFirstWeek - 1];\n            } catch (ArrayIndexOutOfBoundsException e) {\n                throw new IllegalArgumentException\n                    (\"Invalid min days in first week: \" + minDaysInFirstWeek);\n            }\n            if (chrono == null) {\n                if (zone == DateTimeZone.UTC) {\n                    chrono = new GregorianChronology(null, null, minDaysInFirstWeek);\n                } else {\n                    chrono = getInstance(DateTimeZone.UTC, minDaysInFirstWeek);\n                    chrono = new GregorianChronology\n                        (ZonedChronology.getInstance(chrono, zone), null, minDaysInFirstWeek);\n                }\n                chronos[minDaysInFirstWeek - 1] = chrono;\n            }\n        }\n        return chrono;\n    }",
    "comment": " Gets an instance of the GregorianChronology in the given time zone.  @param zone  the time zone to get the chronology in, null is default @param minDaysInFirstWeek  minimum number of days in first week of the year; default is 4 @return a chronology in the specified time zone ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "GregorianChronology.getInstanceUTC",
    "class_name": "org.joda.time.chrono.GregorianChronology",
    "signature": "org.joda.time.chrono.GregorianChronology.getInstanceUTC()",
    "snippet": "    public static GregorianChronology getInstanceUTC() {\n        return INSTANCE_UTC;\n    }",
    "comment": " Gets an instance of the GregorianChronology. The time zone of the returned instance is UTC.  @return a singleton UTC instance of the chronology ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "GregorianChronology.getMaxYear",
    "class_name": "org.joda.time.chrono.GregorianChronology",
    "signature": "org.joda.time.chrono.GregorianChronology.getMaxYear()",
    "snippet": "    int getMaxYear() {\n        return MAX_YEAR;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "GregorianChronology.getMinYear",
    "class_name": "org.joda.time.chrono.GregorianChronology",
    "signature": "org.joda.time.chrono.GregorianChronology.getMinYear()",
    "snippet": "    int getMinYear() {\n        return MIN_YEAR;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "GregorianChronology.isLeapYear",
    "class_name": "org.joda.time.chrono.GregorianChronology",
    "signature": "org.joda.time.chrono.GregorianChronology.isLeapYear(int)",
    "snippet": "    boolean isLeapYear(int year) {\n        return ((year & 3) == 0) && ((year % 100) != 0 || (year % 400) == 0);\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "ISOChronology.assemble",
    "class_name": "org.joda.time.chrono.ISOChronology",
    "signature": "org.joda.time.chrono.ISOChronology.assemble(Fields)",
    "snippet": "    protected void assemble(Fields fields) {\n        if (getBase().getZone() == DateTimeZone.UTC) {\n            // Use zero based century and year of century.\n            fields.centuryOfEra = new DividedDateTimeField(\n                ISOYearOfEraDateTimeField.INSTANCE, DateTimeFieldType.centuryOfEra(), 100);\n            fields.yearOfCentury = new RemainderDateTimeField(\n                (DividedDateTimeField) fields.centuryOfEra, DateTimeFieldType.yearOfCentury());\n            fields.weekyearOfCentury = new RemainderDateTimeField(\n                (DividedDateTimeField) fields.centuryOfEra, DateTimeFieldType.weekyearOfCentury());\n\n            fields.centuries = fields.centuryOfEra.getDurationField();\n        }\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "ISOChronology.getInstance",
    "class_name": "org.joda.time.chrono.ISOChronology",
    "signature": "org.joda.time.chrono.ISOChronology.getInstance()",
    "snippet": "    public static ISOChronology getInstance() {\n        return getInstance(DateTimeZone.getDefault());\n    }",
    "comment": " Gets an instance of the ISOChronology in the default time zone.  @return a chronology in the default time zone ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "ISOChronology.getInstance",
    "class_name": "org.joda.time.chrono.ISOChronology",
    "signature": "org.joda.time.chrono.ISOChronology.getInstance(DateTimeZone)",
    "snippet": "    public static ISOChronology getInstance(DateTimeZone zone) {\n        if (zone == null) {\n            zone = DateTimeZone.getDefault();\n        }\n        int index = System.identityHashCode(zone) & (FAST_CACHE_SIZE - 1);\n        ISOChronology chrono = cFastCache[index];\n        if (chrono != null && chrono.getZone() == zone) {\n            return chrono;\n        }\n        synchronized (cCache) {\n            chrono = cCache.get(zone);\n            if (chrono == null) {\n                chrono = new ISOChronology(ZonedChronology.getInstance(INSTANCE_UTC, zone));\n                cCache.put(zone, chrono);\n            }\n        }\n        cFastCache[index] = chrono;\n        return chrono;\n    }",
    "comment": " Gets an instance of the ISOChronology in the given time zone.  @param zone  the time zone to get the chronology in, null is default @return a chronology in the specified time zone ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "ISOChronology.withUTC",
    "class_name": "org.joda.time.chrono.ISOChronology",
    "signature": "org.joda.time.chrono.ISOChronology.withUTC()",
    "snippet": "    public Chronology withUTC() {\n        return INSTANCE_UTC;\n    }",
    "comment": " Gets the Chronology in the UTC time zone.  @return the chronology in UTC ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "ISOYearOfEraDateTimeField.getMaximumValue",
    "class_name": "org.joda.time.chrono.ISOYearOfEraDateTimeField",
    "signature": "org.joda.time.chrono.ISOYearOfEraDateTimeField.getMaximumValue()",
    "snippet": "    public int getMaximumValue() {\n        return getWrappedField().getMaximumValue();\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "ISOYearOfEraDateTimeField.getMinimumValue",
    "class_name": "org.joda.time.chrono.ISOYearOfEraDateTimeField",
    "signature": "org.joda.time.chrono.ISOYearOfEraDateTimeField.getMinimumValue()",
    "snippet": "    public int getMinimumValue() {\n        return 0;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "ZonedChronology.assemble",
    "class_name": "org.joda.time.chrono.ZonedChronology",
    "signature": "org.joda.time.chrono.ZonedChronology.assemble(Fields)",
    "snippet": "    protected void assemble(Fields fields) {\n        // Keep a local cache of converted fields so as not to create redundant\n        // objects.\n        HashMap<Object, Object> converted = new HashMap<Object, Object>();\n\n        // Convert duration fields...\n\n        fields.eras = convertField(fields.eras, converted);\n        fields.centuries = convertField(fields.centuries, converted);\n        fields.years = convertField(fields.years, converted);\n        fields.months = convertField(fields.months, converted);\n        fields.weekyears = convertField(fields.weekyears, converted);\n        fields.weeks = convertField(fields.weeks, converted);\n        fields.days = convertField(fields.days, converted);\n\n        fields.halfdays = convertField(fields.halfdays, converted);\n        fields.hours = convertField(fields.hours, converted);\n        fields.minutes = convertField(fields.minutes, converted);\n        fields.seconds = convertField(fields.seconds, converted);\n        fields.millis = convertField(fields.millis, converted);\n\n        // Convert datetime fields...\n\n        fields.year = convertField(fields.year, converted);\n        fields.yearOfEra = convertField(fields.yearOfEra, converted);\n        fields.yearOfCentury = convertField(fields.yearOfCentury, converted);\n        fields.centuryOfEra = convertField(fields.centuryOfEra, converted);\n        fields.era = convertField(fields.era, converted);\n        fields.dayOfWeek = convertField(fields.dayOfWeek, converted);\n        fields.dayOfMonth = convertField(fields.dayOfMonth, converted);\n        fields.dayOfYear = convertField(fields.dayOfYear, converted);\n        fields.monthOfYear = convertField(fields.monthOfYear, converted);\n        fields.weekOfWeekyear = convertField(fields.weekOfWeekyear, converted);\n        fields.weekyear = convertField(fields.weekyear, converted);\n        fields.weekyearOfCentury = convertField(fields.weekyearOfCentury, converted);\n\n        fields.millisOfSecond = convertField(fields.millisOfSecond, converted);\n        fields.millisOfDay = convertField(fields.millisOfDay, converted);\n        fields.secondOfMinute = convertField(fields.secondOfMinute, converted);\n        fields.secondOfDay = convertField(fields.secondOfDay, converted);\n        fields.minuteOfHour = convertField(fields.minuteOfHour, converted);\n        fields.minuteOfDay = convertField(fields.minuteOfDay, converted);\n        fields.hourOfDay = convertField(fields.hourOfDay, converted);\n        fields.hourOfHalfday = convertField(fields.hourOfHalfday, converted);\n        fields.clockhourOfDay = convertField(fields.clockhourOfDay, converted);\n        fields.clockhourOfHalfday = convertField(fields.clockhourOfHalfday, converted);\n        fields.halfdayOfDay = convertField(fields.halfdayOfDay, converted);\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "ZonedChronology.convertField",
    "class_name": "org.joda.time.chrono.ZonedChronology",
    "signature": "org.joda.time.chrono.ZonedChronology.convertField(DateTimeField,HashMap)",
    "snippet": "    private DateTimeField convertField(DateTimeField field, HashMap<Object, Object> converted) {\n        if (field == null || !field.isSupported()) {\n            return field;\n        }\n        if (converted.containsKey(field)) {\n            return (DateTimeField)converted.get(field);\n        }\n        ZonedDateTimeField zonedField =\n            new ZonedDateTimeField(field, getZone(),\n                                   convertField(field.getDurationField(), converted),\n                                   convertField(field.getRangeDurationField(), converted),\n                                   convertField(field.getLeapDurationField(), converted));\n        converted.put(field, zonedField);\n        return zonedField;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "ZonedChronology.convertField",
    "class_name": "org.joda.time.chrono.ZonedChronology",
    "signature": "org.joda.time.chrono.ZonedChronology.convertField(DurationField,HashMap)",
    "snippet": "    private DurationField convertField(DurationField field, HashMap<Object, Object> converted) {\n        if (field == null || !field.isSupported()) {\n            return field;\n        }\n        if (converted.containsKey(field)) {\n            return (DurationField)converted.get(field);\n        }\n        ZonedDurationField zonedField = new ZonedDurationField(field, getZone());\n        converted.put(field, zonedField);\n        return zonedField;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "ZonedChronology.getDateTimeMillis",
    "class_name": "org.joda.time.chrono.ZonedChronology",
    "signature": "org.joda.time.chrono.ZonedChronology.getDateTimeMillis(int,int,int,int,int,int,int)",
    "snippet": "    public long getDateTimeMillis(int year, int monthOfYear, int dayOfMonth,\n                                  int hourOfDay, int minuteOfHour,\n                                  int secondOfMinute, int millisOfSecond)\n        throws IllegalArgumentException\n    {\n        return localToUTC(getBase().getDateTimeMillis\n                          (year, monthOfYear, dayOfMonth, \n                           hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond));\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "ZonedChronology.getInstance",
    "class_name": "org.joda.time.chrono.ZonedChronology",
    "signature": "org.joda.time.chrono.ZonedChronology.getInstance(Chronology,DateTimeZone)",
    "snippet": "    public static ZonedChronology getInstance(Chronology base, DateTimeZone zone) {\n        if (base == null) {\n            throw new IllegalArgumentException(\"Must supply a chronology\");\n        }\n        base = base.withUTC();\n        if (base == null) {\n            throw new IllegalArgumentException(\"UTC chronology must not be null\");\n        }\n        if (zone == null) {\n            throw new IllegalArgumentException(\"DateTimeZone must not be null\");\n        }\n        return new ZonedChronology(base, zone);\n    }",
    "comment": " Create a ZonedChronology for any chronology, overriding any time zone it may already have.  @param base base chronology to wrap @param zone the time zone @throws IllegalArgumentException if chronology or time zone is null ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "ZonedChronology.getZone",
    "class_name": "org.joda.time.chrono.ZonedChronology",
    "signature": "org.joda.time.chrono.ZonedChronology.getZone()",
    "snippet": "    public DateTimeZone getZone() {\n        return (DateTimeZone)getParam();\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "ZonedChronology.localToUTC",
    "class_name": "org.joda.time.chrono.ZonedChronology",
    "signature": "org.joda.time.chrono.ZonedChronology.localToUTC(long)",
    "snippet": "    private long localToUTC(long instant) {\n        DateTimeZone zone = getZone();\n        int offset = zone.getOffsetFromLocal(instant);\n        instant -= offset;\n        if (offset != zone.getOffset(instant)) {\n            throw new IllegalArgumentException\n                (\"Illegal instant due to time zone offset transition: \" +\n                    DateTimeFormat.forPattern(\"yyyy-MM-dd'T'HH:mm:ss.SSS\").print(new Instant(instant)));\n        }\n        return instant;\n    }",
    "comment": " @param instant instant from 1970-01-01T00:00:00 local time @return instant from 1970-01-01T00:00:00Z ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "ZonedChronology.useTimeArithmetic",
    "class_name": "org.joda.time.chrono.ZonedChronology",
    "signature": "org.joda.time.chrono.ZonedChronology.useTimeArithmetic(DurationField)",
    "snippet": "    static boolean useTimeArithmetic(DurationField field) {\n        // Use time of day arithmetic rules for unit durations less than\n        // typical time zone offsets.\n        return field != null && field.getUnitMillis() < DateTimeConstants.MILLIS_PER_HOUR * 12;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "ZonedDurationField.getUnitMillis",
    "class_name": "org.joda.time.chrono.ZonedChronology$ZonedDurationField",
    "signature": "org.joda.time.chrono.ZonedChronology$ZonedDurationField.getUnitMillis()",
    "snippet": "        public long getUnitMillis() {\n            return iField.getUnitMillis();\n        }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "BaseDateTimeField.BaseDateTimeField",
    "class_name": "org.joda.time.field.BaseDateTimeField",
    "signature": "org.joda.time.field.BaseDateTimeField.BaseDateTimeField(DateTimeFieldType)",
    "snippet": "    protected BaseDateTimeField(DateTimeFieldType type) {\n        super();\n        if (type == null) {\n            throw new IllegalArgumentException(\"The type must not be null\");\n        }\n        iType = type;\n    }",
    "comment": " Constructor. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "BaseDateTimeField.getLeapDurationField",
    "class_name": "org.joda.time.field.BaseDateTimeField",
    "signature": "org.joda.time.field.BaseDateTimeField.getLeapDurationField()",
    "snippet": "    public DurationField getLeapDurationField() {\n        return null;\n    }",
    "comment": " If this field were to leap, then it would be in units described by the returned duration. If this field doesn't ever leap, null is returned. <p> This implementation returns null. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "BaseDateTimeField.getType",
    "class_name": "org.joda.time.field.BaseDateTimeField",
    "signature": "org.joda.time.field.BaseDateTimeField.getType()",
    "snippet": "    public final DateTimeFieldType getType() {\n        return iType;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "BaseDateTimeField.isSupported",
    "class_name": "org.joda.time.field.BaseDateTimeField",
    "signature": "org.joda.time.field.BaseDateTimeField.isSupported()",
    "snippet": "    public final boolean isSupported() {\n        return true;\n    }",
    "comment": " @return true always ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "BaseDurationField.BaseDurationField",
    "class_name": "org.joda.time.field.BaseDurationField",
    "signature": "org.joda.time.field.BaseDurationField.BaseDurationField(DurationFieldType)",
    "snippet": "    protected BaseDurationField(DurationFieldType type) {\n        super();\n        if (type == null) {\n            throw new IllegalArgumentException(\"The type must not be null\");\n        }\n        iType = type;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "BaseDurationField.getType",
    "class_name": "org.joda.time.field.BaseDurationField",
    "signature": "org.joda.time.field.BaseDurationField.getType()",
    "snippet": "    public final DurationFieldType getType() {\n        return iType;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "BaseDurationField.isSupported",
    "class_name": "org.joda.time.field.BaseDurationField",
    "signature": "org.joda.time.field.BaseDurationField.isSupported()",
    "snippet": "    public final boolean isSupported() {\n        return true;\n    }",
    "comment": " @return true always ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "DecoratedDateTimeField.DecoratedDateTimeField",
    "class_name": "org.joda.time.field.DecoratedDateTimeField",
    "signature": "org.joda.time.field.DecoratedDateTimeField.DecoratedDateTimeField(DateTimeField,DateTimeFieldType)",
    "snippet": "    protected DecoratedDateTimeField(DateTimeField field, DateTimeFieldType type) {\n        super(type);\n        if (field == null) {\n            throw new IllegalArgumentException(\"The field must not be null\");\n        }\n        if (!field.isSupported()) {\n            throw new IllegalArgumentException(\"The field must be supported\");\n        }\n        iField = field;\n    }",
    "comment": " Constructor.  @param field  the field being decorated @param type  allow type to be overridden ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "DecoratedDateTimeField.getDurationField",
    "class_name": "org.joda.time.field.DecoratedDateTimeField",
    "signature": "org.joda.time.field.DecoratedDateTimeField.getDurationField()",
    "snippet": "    public DurationField getDurationField() {\n        return iField.getDurationField();\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "DecoratedDateTimeField.getRangeDurationField",
    "class_name": "org.joda.time.field.DecoratedDateTimeField",
    "signature": "org.joda.time.field.DecoratedDateTimeField.getRangeDurationField()",
    "snippet": "    public DurationField getRangeDurationField() {\n        return iField.getRangeDurationField();\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "DecoratedDateTimeField.getWrappedField",
    "class_name": "org.joda.time.field.DecoratedDateTimeField",
    "signature": "org.joda.time.field.DecoratedDateTimeField.getWrappedField()",
    "snippet": "    public final DateTimeField getWrappedField() {\n        return iField;\n    }",
    "comment": " Gets the wrapped date time field.  @return the wrapped DateTimeField ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "DecoratedDurationField.DecoratedDurationField",
    "class_name": "org.joda.time.field.DecoratedDurationField",
    "signature": "org.joda.time.field.DecoratedDurationField.DecoratedDurationField(DurationField,DurationFieldType)",
    "snippet": "    public DecoratedDurationField(DurationField field, DurationFieldType type) {\n        super(type);\n        if (field == null) {\n            throw new IllegalArgumentException(\"The field must not be null\");\n        }\n        if (!field.isSupported()) {\n            throw new IllegalArgumentException(\"The field must be supported\");\n        }\n        iField = field;\n    }",
    "comment": " Constructor.  @param field  the base field @param type  the type to actually use ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "DecoratedDurationField.getWrappedField",
    "class_name": "org.joda.time.field.DecoratedDurationField",
    "signature": "org.joda.time.field.DecoratedDurationField.getWrappedField()",
    "snippet": "    public final DurationField getWrappedField() {\n        return iField;\n    }",
    "comment": " Gets the wrapped duration field.  @return the wrapped DurationField ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "DividedDateTimeField.DividedDateTimeField",
    "class_name": "org.joda.time.field.DividedDateTimeField",
    "signature": "org.joda.time.field.DividedDateTimeField.DividedDateTimeField(DateTimeField,DateTimeFieldType,int)",
    "snippet": "    public DividedDateTimeField(DateTimeField field,\n                                DateTimeFieldType type, int divisor) {\n        super(field, type);\n                \n        if (divisor < 2) {\n            throw new IllegalArgumentException(\"The divisor must be at least 2\");\n        }\n\n        DurationField unitField = field.getDurationField();\n        if (unitField == null) {\n            iDurationField = null;\n        } else {\n            iDurationField = new ScaledDurationField(\n                unitField, type.getDurationType(), divisor);\n        }\n\n        iDivisor = divisor;\n\n        int i = field.getMinimumValue();\n        int min = (i >= 0) ? i / divisor : ((i + 1) / divisor - 1);\n\n        int j = field.getMaximumValue();\n        int max = (j >= 0) ? j / divisor : ((j + 1) / divisor - 1);\n\n        iMin = min;\n        iMax = max;\n    }",
    "comment": " Constructor.  @param field  the field to wrap, like \"year()\". @param type  the field type this field will actually use @param divisor  divisor, such as 100 years in a century @throws IllegalArgumentException if divisor is less than two ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "DividedDateTimeField.getDurationField",
    "class_name": "org.joda.time.field.DividedDateTimeField",
    "signature": "org.joda.time.field.DividedDateTimeField.getDurationField()",
    "snippet": "    public DurationField getDurationField() {\n        return iDurationField;\n    }",
    "comment": " Returns a scaled version of the wrapped field's unit duration field. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "FieldUtils.verifyValueBounds",
    "class_name": "org.joda.time.field.FieldUtils",
    "signature": "org.joda.time.field.FieldUtils.verifyValueBounds(DateTimeFieldType,int,int,int)",
    "snippet": "    public static void verifyValueBounds(DateTimeFieldType fieldType, \n                                         int value, int lowerBound, int upperBound) {\n        if ((value < lowerBound) || (value > upperBound)) {\n            throw new IllegalFieldValueException\n                (fieldType, Integer.valueOf(value),\n                 Integer.valueOf(lowerBound), Integer.valueOf(upperBound));\n        }\n    }",
    "comment": " Verify that input values are within specified bounds.  @param value  the value to check @param lowerBound  the lower bound allowed for value @param upperBound  the upper bound allowed for value @throws IllegalFieldValueException if value is not in the specified bounds @since 1.1 ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "ImpreciseDateTimeField.ImpreciseDateTimeField",
    "class_name": "org.joda.time.field.ImpreciseDateTimeField",
    "signature": "org.joda.time.field.ImpreciseDateTimeField.ImpreciseDateTimeField(DateTimeFieldType,long)",
    "snippet": "    public ImpreciseDateTimeField(DateTimeFieldType type, long unitMillis) {\n        super(type);\n        iUnitMillis = unitMillis;\n        iDurationField = new LinkedDurationField(type.getDurationType());\n    }",
    "comment": " Constructor.  @param type  the field type @param unitMillis  the average duration unit milliseconds ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "ImpreciseDateTimeField.getDurationField",
    "class_name": "org.joda.time.field.ImpreciseDateTimeField",
    "signature": "org.joda.time.field.ImpreciseDateTimeField.getDurationField()",
    "snippet": "    public final DurationField getDurationField() {\n        return iDurationField;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "LinkedDurationField.getUnitMillis",
    "class_name": "org.joda.time.field.ImpreciseDateTimeField$LinkedDurationField",
    "signature": "org.joda.time.field.ImpreciseDateTimeField$LinkedDurationField.getUnitMillis()",
    "snippet": "        public long getUnitMillis() {\n            return iUnitMillis;\n        }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "MillisDurationField.getType",
    "class_name": "org.joda.time.field.MillisDurationField",
    "signature": "org.joda.time.field.MillisDurationField.getType()",
    "snippet": "    public DurationFieldType getType() {\n        return DurationFieldType.millis();\n    }",
    "comment": "------------------------------------------------------------------------",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "MillisDurationField.getUnitMillis",
    "class_name": "org.joda.time.field.MillisDurationField",
    "signature": "org.joda.time.field.MillisDurationField.getUnitMillis()",
    "snippet": "    public final long getUnitMillis() {\n        return 1;\n    }",
    "comment": " Returns the amount of milliseconds per unit value of this field.  @return one always ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "MillisDurationField.hashCode",
    "class_name": "org.joda.time.field.MillisDurationField",
    "signature": "org.joda.time.field.MillisDurationField.hashCode()",
    "snippet": "    public int hashCode() {\n        return (int) getUnitMillis();\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "MillisDurationField.isPrecise",
    "class_name": "org.joda.time.field.MillisDurationField",
    "signature": "org.joda.time.field.MillisDurationField.isPrecise()",
    "snippet": "    public final boolean isPrecise() {\n        return true;\n    }",
    "comment": " Returns true as this field is precise.  @return true always ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "MillisDurationField.isSupported",
    "class_name": "org.joda.time.field.MillisDurationField",
    "signature": "org.joda.time.field.MillisDurationField.isSupported()",
    "snippet": "    public boolean isSupported() {\n        return true;\n    }",
    "comment": " Returns true as this field is supported.  @return true always ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "OffsetDateTimeField.OffsetDateTimeField",
    "class_name": "org.joda.time.field.OffsetDateTimeField",
    "signature": "org.joda.time.field.OffsetDateTimeField.OffsetDateTimeField(DateTimeField,DateTimeFieldType,int)",
    "snippet": "    public OffsetDateTimeField(DateTimeField field, DateTimeFieldType type, int offset) {\n        this(field, type, offset, Integer.MIN_VALUE, Integer.MAX_VALUE);\n    }",
    "comment": " Constructor.  @param field  the field to wrap, like \"year()\". @param type  the field type this field actually uses @param offset  offset to add to field values @throws IllegalArgumentException if offset is zero ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "OffsetDateTimeField.OffsetDateTimeField",
    "class_name": "org.joda.time.field.OffsetDateTimeField",
    "signature": "org.joda.time.field.OffsetDateTimeField.OffsetDateTimeField(DateTimeField,DateTimeFieldType,int,int,int)",
    "snippet": "    public OffsetDateTimeField(DateTimeField field, DateTimeFieldType type, int offset,\n                               int minValue, int maxValue) {\n        super(field, type);\n                \n        if (offset == 0) {\n            throw new IllegalArgumentException(\"The offset cannot be zero\");\n        }\n\n        iOffset = offset;\n\n        if (minValue < (field.getMinimumValue() + offset)) {\n            iMin = field.getMinimumValue() + offset;\n        } else {\n            iMin = minValue;\n        }\n        if (maxValue > (field.getMaximumValue() + offset)) {\n            iMax = field.getMaximumValue() + offset;\n        } else {\n            iMax = maxValue;\n        }\n    }",
    "comment": " Constructor.  @param field  the field to wrap, like \"year()\". @param type  the field type this field actually uses @param offset  offset to add to field values @param minValue  minimum allowed value @param maxValue  maximum allowed value @throws IllegalArgumentException if offset is zero ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "OffsetDateTimeField.OffsetDateTimeField",
    "class_name": "org.joda.time.field.OffsetDateTimeField",
    "signature": "org.joda.time.field.OffsetDateTimeField.OffsetDateTimeField(DateTimeField,int)",
    "snippet": "    public OffsetDateTimeField(DateTimeField field, int offset) {\n        this(field, (field == null ? null : field.getType()), offset, Integer.MIN_VALUE, Integer.MAX_VALUE);\n    }",
    "comment": " Constructor.  @param field  the field to wrap, like \"year()\". @param offset  offset to add to field values @throws IllegalArgumentException if offset is zero ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "OffsetDateTimeField.getMaximumValue",
    "class_name": "org.joda.time.field.OffsetDateTimeField",
    "signature": "org.joda.time.field.OffsetDateTimeField.getMaximumValue()",
    "snippet": "    public int getMaximumValue() {\n        return iMax;\n    }",
    "comment": " Get the maximum value for the field.  @return the maximum value ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "OffsetDateTimeField.getMinimumValue",
    "class_name": "org.joda.time.field.OffsetDateTimeField",
    "signature": "org.joda.time.field.OffsetDateTimeField.getMinimumValue()",
    "snippet": "    public int getMinimumValue() {\n        return iMin;\n    }",
    "comment": " Get the minimum value for the field.  @return the minimum value ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "PreciseDateTimeField.PreciseDateTimeField",
    "class_name": "org.joda.time.field.PreciseDateTimeField",
    "signature": "org.joda.time.field.PreciseDateTimeField.PreciseDateTimeField(DateTimeFieldType,DurationField,DurationField)",
    "snippet": "    public PreciseDateTimeField(DateTimeFieldType type,\n                                DurationField unit, DurationField range) {\n        super(type, unit);\n\n        if (!range.isPrecise()) {\n            throw new IllegalArgumentException(\"Range duration field must be precise\");\n        }\n\n        long rangeMillis = range.getUnitMillis();\n        iRange = (int)(rangeMillis / getUnitMillis());\n        if (iRange < 2) {\n            throw new IllegalArgumentException(\"The effective range must be at least 2\");\n        }\n\n        iRangeField = range;\n    }",
    "comment": " Constructor.  @param type  the field type this field uses @param unit  precise unit duration, like \"seconds()\". @param range precise range duration, preferably a multiple of the unit, like \"minutes()\". @throws IllegalArgumentException if either duration field is imprecise @throws IllegalArgumentException if unit milliseconds is less than one or effective value range is less than two. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "PreciseDateTimeField.get",
    "class_name": "org.joda.time.field.PreciseDateTimeField",
    "signature": "org.joda.time.field.PreciseDateTimeField.get(long)",
    "snippet": "    public int get(long instant) {\n        if (instant >= 0) {\n            return (int) ((instant / getUnitMillis()) % iRange);\n        } else {\n            return iRange - 1 + (int) (((instant + 1) / getUnitMillis()) % iRange);\n        }\n    }",
    "comment": " Get the amount of fractional units from the specified time instant.  @param instant  the milliseconds from 1970-01-01T00:00:00Z to query @return the amount of fractional units extracted from the input. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "PreciseDateTimeField.getRangeDurationField",
    "class_name": "org.joda.time.field.PreciseDateTimeField",
    "signature": "org.joda.time.field.PreciseDateTimeField.getRangeDurationField()",
    "snippet": "    public DurationField getRangeDurationField() {\n        return iRangeField;\n    }",
    "comment": " Returns the range duration of this field. For example, if this field represents \"minute of hour\", then the range duration field is an hours.  @return the range duration of this field, or null if field has no range ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "PreciseDurationDateTimeField.PreciseDurationDateTimeField",
    "class_name": "org.joda.time.field.PreciseDurationDateTimeField",
    "signature": "org.joda.time.field.PreciseDurationDateTimeField.PreciseDurationDateTimeField(DateTimeFieldType,DurationField)",
    "snippet": "    public PreciseDurationDateTimeField(DateTimeFieldType type, DurationField unit) {\n        super(type);\n\n        if (!unit.isPrecise()) {\n            throw new IllegalArgumentException(\"Unit duration field must be precise\");\n        }\n\n        iUnitMillis = unit.getUnitMillis();\n        if (iUnitMillis < 1) {\n            throw new IllegalArgumentException(\"The unit milliseconds must be at least 1\");\n        }\n\n        iUnitField = unit;\n    }",
    "comment": " Constructor.  @param type  the field type @param unit  precise unit duration, like \"days()\". @throws IllegalArgumentException if duration field is imprecise @throws IllegalArgumentException if unit milliseconds is less than one ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "PreciseDurationDateTimeField.getDurationField",
    "class_name": "org.joda.time.field.PreciseDurationDateTimeField",
    "signature": "org.joda.time.field.PreciseDurationDateTimeField.getDurationField()",
    "snippet": "    public DurationField getDurationField() {\n        return iUnitField;\n    }",
    "comment": " Returns the duration per unit value of this field. For example, if this field represents \"minute of hour\", then the duration field is minutes.  @return the duration of this field, or UnsupportedDurationField if field has no duration ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "PreciseDurationDateTimeField.getMinimumValue",
    "class_name": "org.joda.time.field.PreciseDurationDateTimeField",
    "signature": "org.joda.time.field.PreciseDurationDateTimeField.getMinimumValue()",
    "snippet": "    public int getMinimumValue() {\n        return 0;\n    }",
    "comment": " Get the minimum value for the field.  @return the minimum value ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "PreciseDurationDateTimeField.getUnitMillis",
    "class_name": "org.joda.time.field.PreciseDurationDateTimeField",
    "signature": "org.joda.time.field.PreciseDurationDateTimeField.getUnitMillis()",
    "snippet": "    public final long getUnitMillis() {\n        return iUnitMillis;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "PreciseDurationField.PreciseDurationField",
    "class_name": "org.joda.time.field.PreciseDurationField",
    "signature": "org.joda.time.field.PreciseDurationField.PreciseDurationField(DurationFieldType,long)",
    "snippet": "    public PreciseDurationField(DurationFieldType type, long unitMillis) {\n        super(type);\n        iUnitMillis = unitMillis;\n    }",
    "comment": " Constructor.  @param type  the field type @param unitMillis  the unit milliseconds ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "PreciseDurationField.getUnitMillis",
    "class_name": "org.joda.time.field.PreciseDurationField",
    "signature": "org.joda.time.field.PreciseDurationField.getUnitMillis()",
    "snippet": "    public final long getUnitMillis() {\n        return iUnitMillis;\n    }",
    "comment": " Returns the amount of milliseconds per unit value of this field.  @return the unit size of this field, in milliseconds ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "PreciseDurationField.hashCode",
    "class_name": "org.joda.time.field.PreciseDurationField",
    "signature": "org.joda.time.field.PreciseDurationField.hashCode()",
    "snippet": "    public int hashCode() {\n        long millis = iUnitMillis;\n        int hash = (int) (millis ^ (millis >>> 32));\n        hash += getType().hashCode();\n        return hash;\n    }",
    "comment": " Gets a hash code for this instance.  @return a suitable hashcode ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "PreciseDurationField.isPrecise",
    "class_name": "org.joda.time.field.PreciseDurationField",
    "signature": "org.joda.time.field.PreciseDurationField.isPrecise()",
    "snippet": "    public final boolean isPrecise() {\n        return true;\n    }",
    "comment": " This field is precise.  @return true always ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "RemainderDateTimeField.RemainderDateTimeField",
    "class_name": "org.joda.time.field.RemainderDateTimeField",
    "signature": "org.joda.time.field.RemainderDateTimeField.RemainderDateTimeField(DateTimeField,DateTimeFieldType,int)",
    "snippet": "    public RemainderDateTimeField(DateTimeField field,\n                                  DateTimeFieldType type, int divisor) {\n        super(field, type);\n\n        if (divisor < 2) {\n            throw new IllegalArgumentException(\"The divisor must be at least 2\");\n        }\n\n        DurationField rangeField = field.getDurationField();\n        if (rangeField == null) {\n            iRangeField = null;\n        } else {\n            iRangeField = new ScaledDurationField(\n                rangeField, type.getRangeDurationType(), divisor);\n        }\n\n        iDivisor = divisor;\n    }",
    "comment": " Constructor.  @param field  the field to wrap, like \"year()\". @param type  the field type this field actually uses @param divisor  divisor, such as 100 years in a century @throws IllegalArgumentException if divisor is less than two ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "RemainderDateTimeField.RemainderDateTimeField",
    "class_name": "org.joda.time.field.RemainderDateTimeField",
    "signature": "org.joda.time.field.RemainderDateTimeField.RemainderDateTimeField(DividedDateTimeField)",
    "snippet": "    public RemainderDateTimeField(DividedDateTimeField dividedField) {\n        this(dividedField, dividedField.getType());\n    }",
    "comment": " Construct a RemainderDateTimeField that compliments the given DividedDateTimeField.  @param dividedField  complimentary divided field, like \"century()\". ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "RemainderDateTimeField.RemainderDateTimeField",
    "class_name": "org.joda.time.field.RemainderDateTimeField",
    "signature": "org.joda.time.field.RemainderDateTimeField.RemainderDateTimeField(DividedDateTimeField,DateTimeFieldType)",
    "snippet": "    public RemainderDateTimeField(DividedDateTimeField dividedField, DateTimeFieldType type) {\n        super(dividedField.getWrappedField(), type);\n        iDivisor = dividedField.iDivisor;\n        iRangeField = dividedField.iDurationField;\n    }",
    "comment": " Construct a RemainderDateTimeField that compliments the given DividedDateTimeField.  @param dividedField  complimentary divided field, like \"century()\". @param type  the field type this field actually uses ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "RemainderDateTimeField.getMaximumValue",
    "class_name": "org.joda.time.field.RemainderDateTimeField",
    "signature": "org.joda.time.field.RemainderDateTimeField.getMaximumValue()",
    "snippet": "    public int getMaximumValue() {\n        return iDivisor - 1;\n    }",
    "comment": " Get the maximum value for the field, which is always one less than the divisor.  @return the maximum value ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "RemainderDateTimeField.getMinimumValue",
    "class_name": "org.joda.time.field.RemainderDateTimeField",
    "signature": "org.joda.time.field.RemainderDateTimeField.getMinimumValue()",
    "snippet": "    public int getMinimumValue() {\n        return 0;\n    }",
    "comment": " Get the minimum value for the field, which is always zero.  @return the minimum value of zero. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "RemainderDateTimeField.getRangeDurationField",
    "class_name": "org.joda.time.field.RemainderDateTimeField",
    "signature": "org.joda.time.field.RemainderDateTimeField.getRangeDurationField()",
    "snippet": "    public DurationField getRangeDurationField() {\n        return iRangeField;\n    }",
    "comment": " Returns a scaled version of the wrapped field's unit duration field. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "ScaledDurationField.ScaledDurationField",
    "class_name": "org.joda.time.field.ScaledDurationField",
    "signature": "org.joda.time.field.ScaledDurationField.ScaledDurationField(DurationField,DurationFieldType,int)",
    "snippet": "    public ScaledDurationField(DurationField field, DurationFieldType type, int scalar) {\n        super(field, type);\n        if (scalar == 0 || scalar == 1) {\n            throw new IllegalArgumentException(\"The scalar must not be 0 or 1\");\n        }\n        iScalar = scalar;\n    }",
    "comment": " Constructor  @param field  the field to wrap, like \"year()\". @param type  the type this field will actually use @param scalar  scalar, such as 100 years in a century @throws IllegalArgumentException if scalar is zero or one. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "ScaledDurationField.getUnitMillis",
    "class_name": "org.joda.time.field.ScaledDurationField",
    "signature": "org.joda.time.field.ScaledDurationField.getUnitMillis()",
    "snippet": "    public long getUnitMillis() {\n        return getWrappedField().getUnitMillis() * iScalar;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "ScaledDurationField.hashCode",
    "class_name": "org.joda.time.field.ScaledDurationField",
    "signature": "org.joda.time.field.ScaledDurationField.hashCode()",
    "snippet": "    public int hashCode() {\n        long scalar = iScalar;\n        int hash = (int) (scalar ^ (scalar >>> 32));\n        hash += getType().hashCode();\n        hash += getWrappedField().hashCode();\n        return hash;\n    }",
    "comment": " Gets a hash code for this instance.  @return a suitable hashcode ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "UnsupportedDurationField.getInstance",
    "class_name": "org.joda.time.field.UnsupportedDurationField",
    "signature": "org.joda.time.field.UnsupportedDurationField.getInstance(DurationFieldType)",
    "snippet": "    public static synchronized UnsupportedDurationField getInstance(DurationFieldType type) {\n        UnsupportedDurationField field;\n        if (cCache == null) {\n            cCache = new HashMap<DurationFieldType, UnsupportedDurationField>(7);\n            field = null;\n        } else {\n            field = cCache.get(type);\n        }\n        if (field == null) {\n            field = new UnsupportedDurationField(type);\n            cCache.put(type, field);\n        }\n        return field;\n    }",
    "comment": " Gets an instance of UnsupportedDurationField for a specific named field. The returned instance is cached.  @param type  the type to obtain @return the instance ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "UnsupportedDurationField.getUnitMillis",
    "class_name": "org.joda.time.field.UnsupportedDurationField",
    "signature": "org.joda.time.field.UnsupportedDurationField.getUnitMillis()",
    "snippet": "    public long getUnitMillis() {\n        return 0;\n    }",
    "comment": " Always returns zero.  @return zero always ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "UnsupportedDurationField.isSupported",
    "class_name": "org.joda.time.field.UnsupportedDurationField",
    "signature": "org.joda.time.field.UnsupportedDurationField.isSupported()",
    "snippet": "    public boolean isSupported() {\n        return false;\n    }",
    "comment": " This field is not supported.  @return false always ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "ZeroIsMaxDateTimeField.ZeroIsMaxDateTimeField",
    "class_name": "org.joda.time.field.ZeroIsMaxDateTimeField",
    "signature": "org.joda.time.field.ZeroIsMaxDateTimeField.ZeroIsMaxDateTimeField(DateTimeField,DateTimeFieldType)",
    "snippet": "    public ZeroIsMaxDateTimeField(DateTimeField field, DateTimeFieldType type) {\n        super(field, type);\n        if (field.getMinimumValue() != 0) {\n            throw new IllegalArgumentException(\"Wrapped field's minumum value must be zero\");\n        }\n    }",
    "comment": " Constructor.  @param field  the base field @param type  the field type this field will actually use @throws IllegalArgumentException if wrapped field's minimum value is not zero ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "ZeroIsMaxDateTimeField.getLeapDurationField",
    "class_name": "org.joda.time.field.ZeroIsMaxDateTimeField",
    "signature": "org.joda.time.field.ZeroIsMaxDateTimeField.getLeapDurationField()",
    "snippet": "    public DurationField getLeapDurationField() {\n        return getWrappedField().getLeapDurationField();\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "DateTimeFormat.appendPatternTo",
    "class_name": "org.joda.time.format.DateTimeFormat",
    "signature": "org.joda.time.format.DateTimeFormat.appendPatternTo(DateTimeFormatterBuilder,String)",
    "snippet": "    static void appendPatternTo(DateTimeFormatterBuilder builder, String pattern) {\n        parsePatternTo(builder, pattern);\n    }",
    "comment": " Parses the given pattern and appends the rules to the given DateTimeFormatterBuilder.  @param pattern  pattern specification @throws IllegalArgumentException if the pattern is invalid ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "DateTimeFormat.isNumericToken",
    "class_name": "org.joda.time.format.DateTimeFormat",
    "signature": "org.joda.time.format.DateTimeFormat.isNumericToken(String)",
    "snippet": "    private static boolean isNumericToken(String token) {\n        int tokenLen = token.length();\n        if (tokenLen > 0) {\n            char c = token.charAt(0);\n            switch (c) {\n            case 'c': // century (number)\n            case 'C': // century of era (number)\n            case 'x': // weekyear (number)\n            case 'y': // year (number)\n            case 'Y': // year of era (number)\n            case 'd': // day of month (number)\n            case 'h': // hour of day (number, 1..12)\n            case 'H': // hour of day (number, 0..23)\n            case 'm': // minute of hour (number)\n            case 's': // second of minute (number)\n            case 'S': // fraction of second (number)\n            case 'e': // day of week (number)\n            case 'D': // day of year (number)\n            case 'F': // day of week in month (number)\n            case 'w': // week of year (number)\n            case 'W': // week of month (number)\n            case 'k': // hour of day (1..24)\n            case 'K': // hour of day (0..11)\n                return true;\n            case 'M': // month of year (text and number)\n                if (tokenLen <= 2) {\n                    return true;\n                }\n            }\n        }\n            \n        return false;\n    }",
    "comment": " Returns true if token should be parsed as a numeric field.  @param token  the token to parse @return true if numeric field ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "DateTimeFormat.parsePatternTo",
    "class_name": "org.joda.time.format.DateTimeFormat",
    "signature": "org.joda.time.format.DateTimeFormat.parsePatternTo(DateTimeFormatterBuilder,String)",
    "snippet": "    private static void parsePatternTo(DateTimeFormatterBuilder builder, String pattern) {\n        int length = pattern.length();\n        int[] indexRef = new int[1];\n\n        for (int i=0; i<length; i++) {\n            indexRef[0] = i;\n            String token = parseToken(pattern, indexRef);\n            i = indexRef[0];\n\n            int tokenLen = token.length();\n            if (tokenLen == 0) {\n                break;\n            }\n            char c = token.charAt(0);\n\n            switch (c) {\n            case 'G': // era designator (text)\n                builder.appendEraText();\n                break;\n            case 'C': // century of era (number)\n                builder.appendCenturyOfEra(tokenLen, tokenLen);\n                break;\n            case 'x': // weekyear (number)\n            case 'y': // year (number)\n            case 'Y': // year of era (number)\n                if (tokenLen == 2) {\n                    boolean lenientParse = true;\n\n                    // Peek ahead to next token.\n                    if (i + 1 < length) {\n                        indexRef[0]++;\n                        if (isNumericToken(parseToken(pattern, indexRef))) {\n                            // If next token is a number, cannot support\n                            // lenient parse, because it will consume digits\n                            // that it should not.\n                            lenientParse = false;\n                        }\n                        indexRef[0]--;\n                    }\n\n                    // Use pivots which are compatible with SimpleDateFormat.\n                    switch (c) {\n                    case 'x':\n                        builder.appendTwoDigitWeekyear\n                            (new DateTime().getWeekyear() - 30, lenientParse);\n                        break;\n                    case 'y':\n                    case 'Y':\n                    default:\n                        builder.appendTwoDigitYear(new DateTime().getYear() - 30, lenientParse);\n                        break;\n                    }\n                } else {\n                    // Try to support long year values.\n                    int maxDigits = 9;\n\n                    // Peek ahead to next token.\n                    if (i + 1 < length) {\n                        indexRef[0]++;\n                        if (isNumericToken(parseToken(pattern, indexRef))) {\n                            // If next token is a number, cannot support long years.\n                            maxDigits = tokenLen;\n                        }\n                        indexRef[0]--;\n                    }\n\n                    switch (c) {\n                    case 'x':\n                        builder.appendWeekyear(tokenLen, maxDigits);\n                        break;\n                    case 'y':\n                        builder.appendYear(tokenLen, maxDigits);\n                        break;\n                    case 'Y':\n                        builder.appendYearOfEra(tokenLen, maxDigits);\n                        break;\n                    }\n                }\n                break;\n            case 'M': // month of year (text and number)\n                if (tokenLen >= 3) {\n                    if (tokenLen >= 4) {\n                        builder.appendMonthOfYearText();\n                    } else {\n                        builder.appendMonthOfYearShortText();\n                    }\n                } else {\n                    builder.appendMonthOfYear(tokenLen);\n                }\n                break;\n            case 'd': // day of month (number)\n                builder.appendDayOfMonth(tokenLen);\n                break;\n            case 'a': // am/pm marker (text)\n                builder.appendHalfdayOfDayText();\n                break;\n            case 'h': // clockhour of halfday (number, 1..12)\n                builder.appendClockhourOfHalfday(tokenLen);\n                break;\n            case 'H': // hour of day (number, 0..23)\n                builder.appendHourOfDay(tokenLen);\n                break;\n            case 'k': // clockhour of day (1..24)\n                builder.appendClockhourOfDay(tokenLen);\n                break;\n            case 'K': // hour of halfday (0..11)\n                builder.appendHourOfHalfday(tokenLen);\n                break;\n            case 'm': // minute of hour (number)\n                builder.appendMinuteOfHour(tokenLen);\n                break;\n            case 's': // second of minute (number)\n                builder.appendSecondOfMinute(tokenLen);\n                break;\n            case 'S': // fraction of second (number)\n                builder.appendFractionOfSecond(tokenLen, tokenLen);\n                break;\n            case 'e': // day of week (number)\n                builder.appendDayOfWeek(tokenLen);\n                break;\n            case 'E': // dayOfWeek (text)\n                if (tokenLen >= 4) {\n                    builder.appendDayOfWeekText();\n                } else {\n                    builder.appendDayOfWeekShortText();\n                }\n                break;\n            case 'D': // day of year (number)\n                builder.appendDayOfYear(tokenLen);\n                break;\n            case 'w': // week of weekyear (number)\n                builder.appendWeekOfWeekyear(tokenLen);\n                break;\n            case 'z': // time zone (text)\n                if (tokenLen >= 4) {\n                    builder.appendTimeZoneName();\n                } else {\n                    builder.appendTimeZoneShortName();\n                }\n                break;\n            case 'Z': // time zone offset\n                if (tokenLen == 1) {\n                    builder.appendTimeZoneOffset(null, \"Z\", false, 2, 2);\n                } else if (tokenLen == 2) {\n                    builder.appendTimeZoneOffset(null, \"Z\", true, 2, 2);\n                } else {\n                    builder.appendTimeZoneId();\n                }\n                break;\n            case '\\'': // literal text\n                String sub = token.substring(1);\n                if (sub.length() == 1) {\n                    builder.appendLiteral(sub.charAt(0));\n                } else {\n                    // Create copy of sub since otherwise the temporary quoted\n                    // string would still be referenced internally.\n                    builder.appendLiteral(new String(sub));\n                }\n                break;\n            default:\n                throw new IllegalArgumentException\n                    (\"Illegal pattern component: \" + token);\n            }\n        }\n    }",
    "comment": " Parses the given pattern and appends the rules to the given DateTimeFormatterBuilder.  @param pattern  pattern specification @throws IllegalArgumentException if the pattern is invalid @see #forPattern ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "DateTimeFormat.parseToken",
    "class_name": "org.joda.time.format.DateTimeFormat",
    "signature": "org.joda.time.format.DateTimeFormat.parseToken(String,int[])",
    "snippet": "    private static String parseToken(String pattern, int[] indexRef) {\n        StringBuffer buf = new StringBuffer();\n\n        int i = indexRef[0];\n        int length = pattern.length();\n\n        char c = pattern.charAt(i);\n        if (c >= 'A' && c <= 'Z' || c >= 'a' && c <= 'z') {\n            // Scan a run of the same character, which indicates a time\n            // pattern.\n            buf.append(c);\n\n            while (i + 1 < length) {\n                char peek = pattern.charAt(i + 1);\n                if (peek == c) {\n                    buf.append(c);\n                    i++;\n                } else {\n                    break;\n                }\n            }\n        } else {\n            // This will identify token as text.\n            buf.append('\\'');\n\n            boolean inLiteral = false;\n\n            for (; i < length; i++) {\n                c = pattern.charAt(i);\n                \n                if (c == '\\'') {\n                    if (i + 1 < length && pattern.charAt(i + 1) == '\\'') {\n                        // '' is treated as escaped '\n                        i++;\n                        buf.append(c);\n                    } else {\n                        inLiteral = !inLiteral;\n                    }\n                } else if (!inLiteral &&\n                           (c >= 'A' && c <= 'Z' || c >= 'a' && c <= 'z')) {\n                    i--;\n                    break;\n                } else {\n                    buf.append(c);\n                }\n            }\n        }\n\n        indexRef[0] = i;\n        return buf.toString();\n    }",
    "comment": " Parses an individual token.  @param pattern  the pattern string @param indexRef  a single element array, where the input is the start location and the output is the location after parsing the token @return the parsed token ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "DateTimeFormatter.DateTimeFormatter",
    "class_name": "org.joda.time.format.DateTimeFormatter",
    "signature": "org.joda.time.format.DateTimeFormatter.DateTimeFormatter(DateTimePrinter,DateTimeParser)",
    "snippet": "    public DateTimeFormatter(\n            DateTimePrinter printer, DateTimeParser parser) {\n        super();\n        iPrinter = printer;\n        iParser = parser;\n        iLocale = null;\n        iOffsetParsed = false;\n        iChrono = null;\n        iZone = null;\n        iPivotYear = null;\n        iDefaultYear = 2000;\n    }",
    "comment": " Creates a new formatter, however you will normally use the factory or the builder.  @param printer  the internal printer, null if cannot print @param parser  the internal parser, null if cannot parse ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "DateTimeFormatter.parseDateTime",
    "class_name": "org.joda.time.format.DateTimeFormatter",
    "signature": "org.joda.time.format.DateTimeFormatter.parseDateTime(String)",
    "snippet": "    public DateTime parseDateTime(String text) {\n        DateTimeParser parser = requireParser();\n        \n        Chronology chrono = selectChronology(null);\n        DateTimeParserBucket bucket = new DateTimeParserBucket(0, chrono, iLocale, iPivotYear, iDefaultYear);\n        int newPos = parser.parseInto(bucket, text, 0);\n        if (newPos >= 0) {\n            if (newPos >= text.length()) {\n                long millis = bucket.computeMillis(true, text);\n                if (iOffsetParsed && bucket.getOffsetInteger() != null) {\n                    int parsedOffset = bucket.getOffsetInteger();\n                    DateTimeZone parsedZone = DateTimeZone.forOffsetMillis(parsedOffset);\n                    chrono = chrono.withZone(parsedZone);\n                } else if (bucket.getZone() != null) {\n                    chrono = chrono.withZone(bucket.getZone());\n                }\n                DateTime dt = new DateTime(millis, chrono);\n                if (iZone != null) {\n                    dt = dt.withZone(iZone);\n                }\n                return dt;\n            }\n        } else {\n            newPos = ~newPos;\n        }\n        throw new IllegalArgumentException(FormatUtils.createErrorMessage(text, newPos));\n    }",
    "comment": " Parses a date-time from the given text, returning a new DateTime. <p> The parse will use the zone and chronology specified on this formatter. <p> If the text contains a time zone string then that will be taken into account in adjusting the time of day as follows. If the {@link #withOffsetParsed()} has been called, then the resulting DateTime will have a fixed offset based on the parsed time zone. Otherwise the resulting DateTime will have the zone of this formatter, but the parsed zone may have caused the time to be adjusted.  @param text  the text to parse, not null @return the parsed date-time, never null @throws UnsupportedOperationException if parsing is not supported @throws IllegalArgumentException if the text to parse is invalid ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "DateTimeFormatter.print",
    "class_name": "org.joda.time.format.DateTimeFormatter",
    "signature": "org.joda.time.format.DateTimeFormatter.print(ReadableInstant)",
    "snippet": "    public String print(ReadableInstant instant) {\n        StringBuffer buf = new StringBuffer(requirePrinter().estimatePrintedLength());\n        printTo(buf, instant);\n        return buf.toString();\n    }",
    "comment": " Prints a ReadableInstant to a String. <p> This method will use the override zone and the override chronololgy if they are set. Otherwise it will use the chronology and zone of the instant.  @param instant  instant to format, null means now @return the printed result ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "DateTimeFormatter.printTo",
    "class_name": "org.joda.time.format.DateTimeFormatter",
    "signature": "org.joda.time.format.DateTimeFormatter.printTo(StringBuffer,ReadableInstant)",
    "snippet": "    public void printTo(StringBuffer buf, ReadableInstant instant) {\n        long millis = DateTimeUtils.getInstantMillis(instant);\n        Chronology chrono = DateTimeUtils.getInstantChronology(instant);\n        printTo(buf, millis, chrono);\n    }",
    "comment": " Prints a ReadableInstant, using the chronology supplied by the instant.  @param buf  the destination to format to, not null @param instant  instant to format, null means now ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "DateTimeFormatter.printTo",
    "class_name": "org.joda.time.format.DateTimeFormatter",
    "signature": "org.joda.time.format.DateTimeFormatter.printTo(StringBuffer,long,Chronology)",
    "snippet": "    private void printTo(StringBuffer buf, long instant, Chronology chrono) {\n        DateTimePrinter printer = requirePrinter();\n        chrono = selectChronology(chrono);\n        // Shift instant into local time (UTC) to avoid excessive offset\n        // calculations when printing multiple fields in a composite printer.\n        DateTimeZone zone = chrono.getZone();\n        int offset = zone.getOffset(instant);\n        long adjustedInstant = instant + offset;\n        if ((instant ^ adjustedInstant) < 0 && (instant ^ offset) >= 0) {\n            // Time zone offset overflow, so revert to UTC.\n            zone = DateTimeZone.UTC;\n            offset = 0;\n            adjustedInstant = instant;\n        }\n        printer.printTo(buf, adjustedInstant, chrono.withUTC(), offset, zone, iLocale);\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "DateTimeFormatter.requireParser",
    "class_name": "org.joda.time.format.DateTimeFormatter",
    "signature": "org.joda.time.format.DateTimeFormatter.requireParser()",
    "snippet": "    private DateTimeParser requireParser() {\n        DateTimeParser parser = iParser;\n        if (parser == null) {\n            throw new UnsupportedOperationException(\"Parsing not supported\");\n        }\n        return parser;\n    }",
    "comment": " Checks whether parsing is supported.  @throws UnsupportedOperationException if parsing is not supported ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "DateTimeFormatter.requirePrinter",
    "class_name": "org.joda.time.format.DateTimeFormatter",
    "signature": "org.joda.time.format.DateTimeFormatter.requirePrinter()",
    "snippet": "    private DateTimePrinter requirePrinter() {\n        DateTimePrinter printer = iPrinter;\n        if (printer == null) {\n            throw new UnsupportedOperationException(\"Printing not supported\");\n        }\n        return printer;\n    }",
    "comment": " Checks whether printing is supported.  @throws UnsupportedOperationException if printing is not supported ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "DateTimeFormatter.selectChronology",
    "class_name": "org.joda.time.format.DateTimeFormatter",
    "signature": "org.joda.time.format.DateTimeFormatter.selectChronology(Chronology)",
    "snippet": "    private Chronology selectChronology(Chronology chrono) {\n        chrono = DateTimeUtils.getChronology(chrono);\n        if (iChrono != null) {\n            chrono = iChrono;\n        }\n        if (iZone != null) {\n            chrono = chrono.withZone(iZone);\n        }\n        return chrono;\n    }",
    "comment": " Determines the correct chronology to use.  @param chrono  the proposed chronology @return the actual chronology ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "DateTimeFormatterBuilder.DateTimeFormatterBuilder",
    "class_name": "org.joda.time.format.DateTimeFormatterBuilder",
    "signature": "org.joda.time.format.DateTimeFormatterBuilder.DateTimeFormatterBuilder()",
    "snippet": "    public DateTimeFormatterBuilder() {\n        super();\n        iElementPairs = new ArrayList<Object>();\n    }",
    "comment": " Creates a DateTimeFormatterBuilder. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "DateTimeFormatterBuilder.append0",
    "class_name": "org.joda.time.format.DateTimeFormatterBuilder",
    "signature": "org.joda.time.format.DateTimeFormatterBuilder.append0(DateTimePrinter,DateTimeParser)",
    "snippet": "    private DateTimeFormatterBuilder append0(\n            DateTimePrinter printer, DateTimeParser parser) {\n        iFormatter = null;\n        iElementPairs.add(printer);\n        iElementPairs.add(parser);\n        return this;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "DateTimeFormatterBuilder.append0",
    "class_name": "org.joda.time.format.DateTimeFormatterBuilder",
    "signature": "org.joda.time.format.DateTimeFormatterBuilder.append0(Object)",
    "snippet": "    private DateTimeFormatterBuilder append0(Object element) {\n        iFormatter = null;\n        // Add the element as both a printer and parser.\n        iElementPairs.add(element);\n        iElementPairs.add(element);\n        return this;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "DateTimeFormatterBuilder.appendDayOfMonth",
    "class_name": "org.joda.time.format.DateTimeFormatterBuilder",
    "signature": "org.joda.time.format.DateTimeFormatterBuilder.appendDayOfMonth(int)",
    "snippet": "    public DateTimeFormatterBuilder appendDayOfMonth(int minDigits) {\n        return appendDecimal(DateTimeFieldType.dayOfMonth(), minDigits, 2);\n    }",
    "comment": " Instructs the printer to emit a numeric dayOfMonth field.  @param minDigits  minimum number of digits to print @return this DateTimeFormatterBuilder, for chaining ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "DateTimeFormatterBuilder.appendDecimal",
    "class_name": "org.joda.time.format.DateTimeFormatterBuilder",
    "signature": "org.joda.time.format.DateTimeFormatterBuilder.appendDecimal(DateTimeFieldType,int,int)",
    "snippet": "    public DateTimeFormatterBuilder appendDecimal(\n            DateTimeFieldType fieldType, int minDigits, int maxDigits) {\n        if (fieldType == null) {\n            throw new IllegalArgumentException(\"Field type must not be null\");\n        }\n        if (maxDigits < minDigits) {\n            maxDigits = minDigits;\n        }\n        if (minDigits < 0 || maxDigits <= 0) {\n            throw new IllegalArgumentException();\n        }\n        if (minDigits <= 1) {\n            return append0(new UnpaddedNumber(fieldType, maxDigits, false));\n        } else {\n            return append0(new PaddedNumber(fieldType, maxDigits, false, minDigits));\n        }\n    }",
    "comment": " Instructs the printer to emit a field value as a decimal number, and the parser to expect an unsigned decimal number.  @param fieldType  type of field to append @param minDigits  minimum number of digits to <i>print</i> @param maxDigits  maximum number of digits to <i>parse</i>, or the estimated maximum number of digits to print @return this DateTimeFormatterBuilder, for chaining @throws IllegalArgumentException if field type is null ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "DateTimeFormatterBuilder.appendHourOfDay",
    "class_name": "org.joda.time.format.DateTimeFormatterBuilder",
    "signature": "org.joda.time.format.DateTimeFormatterBuilder.appendHourOfDay(int)",
    "snippet": "    public DateTimeFormatterBuilder appendHourOfDay(int minDigits) {\n        return appendDecimal(DateTimeFieldType.hourOfDay(), minDigits, 2);\n    }",
    "comment": " Instructs the printer to emit a numeric hourOfDay field.  @param minDigits  minimum number of digits to print @return this DateTimeFormatterBuilder, for chaining ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "DateTimeFormatterBuilder.appendLiteral",
    "class_name": "org.joda.time.format.DateTimeFormatterBuilder",
    "signature": "org.joda.time.format.DateTimeFormatterBuilder.appendLiteral(char)",
    "snippet": "    public DateTimeFormatterBuilder appendLiteral(char c) {\n        return append0(new CharacterLiteral(c));\n    }",
    "comment": " Instructs the printer to emit a specific character, and the parser to expect it. The parser is case-insensitive.  @return this DateTimeFormatterBuilder, for chaining ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "DateTimeFormatterBuilder.appendMinuteOfHour",
    "class_name": "org.joda.time.format.DateTimeFormatterBuilder",
    "signature": "org.joda.time.format.DateTimeFormatterBuilder.appendMinuteOfHour(int)",
    "snippet": "    public DateTimeFormatterBuilder appendMinuteOfHour(int minDigits) {\n        return appendDecimal(DateTimeFieldType.minuteOfHour(), minDigits, 2);\n    }",
    "comment": " Instructs the printer to emit a numeric minuteOfHour field.  @param minDigits  minimum number of digits to print @return this DateTimeFormatterBuilder, for chaining ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "DateTimeFormatterBuilder.appendMonthOfYear",
    "class_name": "org.joda.time.format.DateTimeFormatterBuilder",
    "signature": "org.joda.time.format.DateTimeFormatterBuilder.appendMonthOfYear(int)",
    "snippet": "    public DateTimeFormatterBuilder appendMonthOfYear(int minDigits) {\n        return appendDecimal(DateTimeFieldType.monthOfYear(), minDigits, 2);\n    }",
    "comment": " Instructs the printer to emit a numeric monthOfYear field.  @param minDigits  minimum number of digits to print @return this DateTimeFormatterBuilder, for chaining ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "DateTimeFormatterBuilder.appendPattern",
    "class_name": "org.joda.time.format.DateTimeFormatterBuilder",
    "signature": "org.joda.time.format.DateTimeFormatterBuilder.appendPattern(String)",
    "snippet": "    public DateTimeFormatterBuilder appendPattern(String pattern) {\n        DateTimeFormat.appendPatternTo(this, pattern);\n        return this;\n    }",
    "comment": " Calls upon {@link DateTimeFormat} to parse the pattern and append the results into this builder.  @param pattern  pattern specification @throws IllegalArgumentException if the pattern is invalid @see DateTimeFormat ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "DateTimeFormatterBuilder.appendSignedDecimal",
    "class_name": "org.joda.time.format.DateTimeFormatterBuilder",
    "signature": "org.joda.time.format.DateTimeFormatterBuilder.appendSignedDecimal(DateTimeFieldType,int,int)",
    "snippet": "    public DateTimeFormatterBuilder appendSignedDecimal(\n            DateTimeFieldType fieldType, int minDigits, int maxDigits) {\n        if (fieldType == null) {\n            throw new IllegalArgumentException(\"Field type must not be null\");\n        }\n        if (maxDigits < minDigits) {\n            maxDigits = minDigits;\n        }\n        if (minDigits < 0 || maxDigits <= 0) {\n            throw new IllegalArgumentException();\n        }\n        if (minDigits <= 1) {\n            return append0(new UnpaddedNumber(fieldType, maxDigits, true));\n        } else {\n            return append0(new PaddedNumber(fieldType, maxDigits, true, minDigits));\n        }\n    }",
    "comment": " Instructs the printer to emit a field value as a decimal number, and the parser to expect a signed decimal number.  @param fieldType  type of field to append @param minDigits  minimum number of digits to <i>print</i> @param maxDigits  maximum number of digits to <i>parse</i>, or the estimated maximum number of digits to print @return this DateTimeFormatterBuilder, for chaining @throws IllegalArgumentException if field type is null ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "DateTimeFormatterBuilder.appendTimeZoneId",
    "class_name": "org.joda.time.format.DateTimeFormatterBuilder",
    "signature": "org.joda.time.format.DateTimeFormatterBuilder.appendTimeZoneId()",
    "snippet": "    public DateTimeFormatterBuilder appendTimeZoneId() {\n        return append0(TimeZoneId.INSTANCE, TimeZoneId.INSTANCE);\n    }",
    "comment": " Instructs the printer to emit the identifier of the time zone. From version 2.0, this field can be parsed.  @return this DateTimeFormatterBuilder, for chaining ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "DateTimeFormatterBuilder.appendYear",
    "class_name": "org.joda.time.format.DateTimeFormatterBuilder",
    "signature": "org.joda.time.format.DateTimeFormatterBuilder.appendYear(int,int)",
    "snippet": "    public DateTimeFormatterBuilder appendYear(int minDigits, int maxDigits) {\n        return appendSignedDecimal(DateTimeFieldType.year(), minDigits, maxDigits);\n    }",
    "comment": " Instructs the printer to emit a numeric year field.  @param minDigits  minimum number of digits to <i>print</i> @param maxDigits  maximum number of digits to <i>parse</i>, or the estimated maximum number of digits to print @return this DateTimeFormatterBuilder, for chaining ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "DateTimeFormatterBuilder.getFormatter",
    "class_name": "org.joda.time.format.DateTimeFormatterBuilder",
    "signature": "org.joda.time.format.DateTimeFormatterBuilder.getFormatter()",
    "snippet": "    private Object getFormatter() {\n        Object f = iFormatter;\n\n        if (f == null) {\n            if (iElementPairs.size() == 2) {\n                Object printer = iElementPairs.get(0);\n                Object parser = iElementPairs.get(1);\n\n                if (printer != null) {\n                    if (printer == parser || parser == null) {\n                        f = printer;\n                    }\n                } else {\n                    f = parser;\n                }\n            }\n\n            if (f == null) {\n                f = new Composite(iElementPairs);\n            }\n\n            iFormatter = f;\n        }\n\n        return f;\n    }",
    "comment": "-----------------------------------------------------------------------",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "DateTimeFormatterBuilder.isParser",
    "class_name": "org.joda.time.format.DateTimeFormatterBuilder",
    "signature": "org.joda.time.format.DateTimeFormatterBuilder.isParser(Object)",
    "snippet": "    private boolean isParser(Object f) {\n        if (f instanceof DateTimeParser) {\n            if (f instanceof Composite) {\n                return ((Composite)f).isParser();\n            }\n            return true;\n        }\n        return false;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "DateTimeFormatterBuilder.isPrinter",
    "class_name": "org.joda.time.format.DateTimeFormatterBuilder",
    "signature": "org.joda.time.format.DateTimeFormatterBuilder.isPrinter(Object)",
    "snippet": "    private boolean isPrinter(Object f) {\n        if (f instanceof DateTimePrinter) {\n            if (f instanceof Composite) {\n                return ((Composite)f).isPrinter();\n            }\n            return true;\n        }\n        return false;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "DateTimeFormatterBuilder.toFormatter",
    "class_name": "org.joda.time.format.DateTimeFormatterBuilder",
    "signature": "org.joda.time.format.DateTimeFormatterBuilder.toFormatter()",
    "snippet": "    public DateTimeFormatter toFormatter() {\n        Object f = getFormatter();\n        DateTimePrinter printer = null;\n        if (isPrinter(f)) {\n            printer = (DateTimePrinter) f;\n        }\n        DateTimeParser parser = null;\n        if (isParser(f)) {\n            parser = (DateTimeParser) f;\n        }\n        if (printer != null || parser != null) {\n            return new DateTimeFormatter(printer, parser);\n        }\n        throw new UnsupportedOperationException(\"Both printing and parsing not supported\");\n    }",
    "comment": " Constructs a DateTimeFormatter using all the appended elements. <p> This is the main method used by applications at the end of the build process to create a usable formatter. <p> Subsequent changes to this builder do not affect the returned formatter. <p> The returned formatter may not support both printing and parsing. The methods {@link DateTimeFormatter#isPrinter()} and {@link DateTimeFormatter#isParser()} will help you determine the state of the formatter.  @throws UnsupportedOperationException if neither printing nor parsing is supported ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "CharacterLiteral.estimateParsedLength",
    "class_name": "org.joda.time.format.DateTimeFormatterBuilder$CharacterLiteral",
    "signature": "org.joda.time.format.DateTimeFormatterBuilder$CharacterLiteral.estimateParsedLength()",
    "snippet": "        public int estimateParsedLength() {\n            return 1;\n        }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "CharacterLiteral.estimatePrintedLength",
    "class_name": "org.joda.time.format.DateTimeFormatterBuilder$CharacterLiteral",
    "signature": "org.joda.time.format.DateTimeFormatterBuilder$CharacterLiteral.estimatePrintedLength()",
    "snippet": "        public int estimatePrintedLength() {\n            return 1;\n        }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "CharacterLiteral.parseInto",
    "class_name": "org.joda.time.format.DateTimeFormatterBuilder$CharacterLiteral",
    "signature": "org.joda.time.format.DateTimeFormatterBuilder$CharacterLiteral.parseInto(DateTimeParserBucket,String,int)",
    "snippet": "        public int parseInto(DateTimeParserBucket bucket, String text, int position) {\n            if (position >= text.length()) {\n                return ~position;\n            }\n\n            char a = text.charAt(position);\n            char b = iValue;\n\n            if (a != b) {\n                a = Character.toUpperCase(a);\n                b = Character.toUpperCase(b);\n                if (a != b) {\n                    a = Character.toLowerCase(a);\n                    b = Character.toLowerCase(b);\n                    if (a != b) {\n                        return ~position;\n                    }\n                }\n            }\n\n            return position + 1;\n        }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "CharacterLiteral.printTo",
    "class_name": "org.joda.time.format.DateTimeFormatterBuilder$CharacterLiteral",
    "signature": "org.joda.time.format.DateTimeFormatterBuilder$CharacterLiteral.printTo(StringBuffer,long,Chronology,int,DateTimeZone,Locale)",
    "snippet": "        public void printTo(\n                StringBuffer buf, long instant, Chronology chrono,\n                int displayOffset, DateTimeZone displayZone, Locale locale) {\n            buf.append(iValue);\n        }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "Composite.decompose",
    "class_name": "org.joda.time.format.DateTimeFormatterBuilder$Composite",
    "signature": "org.joda.time.format.DateTimeFormatterBuilder$Composite.decompose(List,List,List)",
    "snippet": "        private void decompose(List<Object> elementPairs, List<Object> printerList, List<Object> parserList) {\n            int size = elementPairs.size();\n            for (int i=0; i<size; i+=2) {\n                Object element = elementPairs.get(i);\n                if (element instanceof DateTimePrinter) {\n                    if (element instanceof Composite) {\n                        addArrayToList(printerList, ((Composite)element).iPrinters);\n                    } else {\n                        printerList.add(element);\n                    }\n                }\n\n                element = elementPairs.get(i + 1);\n                if (element instanceof DateTimeParser) {\n                    if (element instanceof Composite) {\n                        addArrayToList(parserList, ((Composite)element).iParsers);\n                    } else {\n                        parserList.add(element);\n                    }\n                }\n            }\n        }",
    "comment": " Processes the element pairs, putting results into the given printer and parser lists. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "Composite.estimatePrintedLength",
    "class_name": "org.joda.time.format.DateTimeFormatterBuilder$Composite",
    "signature": "org.joda.time.format.DateTimeFormatterBuilder$Composite.estimatePrintedLength()",
    "snippet": "        public int estimatePrintedLength() {\n            return iPrintedLengthEstimate;\n        }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "Composite.isParser",
    "class_name": "org.joda.time.format.DateTimeFormatterBuilder$Composite",
    "signature": "org.joda.time.format.DateTimeFormatterBuilder$Composite.isParser()",
    "snippet": "        boolean isParser() {\n            return iParsers != null;\n        }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "Composite.isPrinter",
    "class_name": "org.joda.time.format.DateTimeFormatterBuilder$Composite",
    "signature": "org.joda.time.format.DateTimeFormatterBuilder$Composite.isPrinter()",
    "snippet": "        boolean isPrinter() {\n            return iPrinters != null;\n        }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "Composite.parseInto",
    "class_name": "org.joda.time.format.DateTimeFormatterBuilder$Composite",
    "signature": "org.joda.time.format.DateTimeFormatterBuilder$Composite.parseInto(DateTimeParserBucket,String,int)",
    "snippet": "        public int parseInto(DateTimeParserBucket bucket, String text, int position) {\n            DateTimeParser[] elements = iParsers;\n            if (elements == null) {\n                throw new UnsupportedOperationException();\n            }\n\n            int len = elements.length;\n            for (int i=0; i<len && position >= 0; i++) {\n                position = elements[i].parseInto(bucket, text, position);\n            }\n            return position;\n        }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "Composite.printTo",
    "class_name": "org.joda.time.format.DateTimeFormatterBuilder$Composite",
    "signature": "org.joda.time.format.DateTimeFormatterBuilder$Composite.printTo(StringBuffer,long,Chronology,int,DateTimeZone,Locale)",
    "snippet": "        public void printTo(\n                StringBuffer buf, long instant, Chronology chrono,\n                int displayOffset, DateTimeZone displayZone, Locale locale) {\n            DateTimePrinter[] elements = iPrinters;\n            if (elements == null) {\n                throw new UnsupportedOperationException();\n            }\n\n            if (locale == null) {\n                // Guard against default locale changing concurrently.\n                locale = Locale.getDefault();\n            }\n\n            int len = elements.length;\n            for (int i = 0; i < len; i++) {\n                elements[i].printTo(buf, instant, chrono, displayOffset, displayZone, locale);\n            }\n        }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "NumberFormatter.estimateParsedLength",
    "class_name": "org.joda.time.format.DateTimeFormatterBuilder$NumberFormatter",
    "signature": "org.joda.time.format.DateTimeFormatterBuilder$NumberFormatter.estimateParsedLength()",
    "snippet": "        public int estimateParsedLength() {\n            return iMaxParsedDigits;\n        }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "NumberFormatter.parseInto",
    "class_name": "org.joda.time.format.DateTimeFormatterBuilder$NumberFormatter",
    "signature": "org.joda.time.format.DateTimeFormatterBuilder$NumberFormatter.parseInto(DateTimeParserBucket,String,int)",
    "snippet": "        public int parseInto(DateTimeParserBucket bucket, String text, int position) {\n            int limit = Math.min(iMaxParsedDigits, text.length() - position);\n\n            boolean negative = false;\n            int length = 0;\n            while (length < limit) {\n                char c = text.charAt(position + length);\n                if (length == 0 && (c == '-' || c == '+') && iSigned) {\n                    negative = c == '-';\n\n                    // Next character must be a digit.\n                    if (length + 1 >= limit || \n                        (c = text.charAt(position + length + 1)) < '0' || c > '9')\n                    {\n                        break;\n                    }\n\n                    if (negative) {\n                        length++;\n                    } else {\n                        // Skip the '+' for parseInt to succeed.\n                        position++;\n                    }\n                    // Expand the limit to disregard the sign character.\n                    limit = Math.min(limit + 1, text.length() - position);\n                    continue;\n                }\n                if (c < '0' || c > '9') {\n                    break;\n                }\n                length++;\n            }\n\n            if (length == 0) {\n                return ~position;\n            }\n\n            int value;\n            if (length >= 9) {\n                // Since value may exceed integer limits, use stock parser\n                // which checks for this.\n                value = Integer.parseInt(text.substring(position, position += length));\n            } else {\n                int i = position;\n                if (negative) {\n                    i++;\n                }\n                try {\n                    value = text.charAt(i++) - '0';\n                } catch (StringIndexOutOfBoundsException e) {\n                    return ~position;\n                }\n                position += length;\n                while (i < position) {\n                    value = ((value << 3) + (value << 1)) + text.charAt(i++) - '0';\n                }\n                if (negative) {\n                    value = -value;\n                }\n            }\n\n            bucket.saveField(iFieldType, value);\n            return position;\n        }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "PaddedNumber.estimatePrintedLength",
    "class_name": "org.joda.time.format.DateTimeFormatterBuilder$PaddedNumber",
    "signature": "org.joda.time.format.DateTimeFormatterBuilder$PaddedNumber.estimatePrintedLength()",
    "snippet": "        public int estimatePrintedLength() {\n            return iMaxParsedDigits;\n        }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "PaddedNumber.printTo",
    "class_name": "org.joda.time.format.DateTimeFormatterBuilder$PaddedNumber",
    "signature": "org.joda.time.format.DateTimeFormatterBuilder$PaddedNumber.printTo(StringBuffer,long,Chronology,int,DateTimeZone,Locale)",
    "snippet": "        public void printTo(\n                StringBuffer buf, long instant, Chronology chrono,\n                int displayOffset, DateTimeZone displayZone, Locale locale) {\n            try {\n                DateTimeField field = iFieldType.getField(chrono);\n                FormatUtils.appendPaddedInteger(buf, field.get(instant), iMinPrintedDigits);\n            } catch (RuntimeException e) {\n                appendUnknownString(buf, iMinPrintedDigits);\n            }\n        }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "TimeZoneId.estimateParsedLength",
    "class_name": "org.joda.time.format.DateTimeFormatterBuilder$TimeZoneId",
    "signature": "org.joda.time.format.DateTimeFormatterBuilder$TimeZoneId.estimateParsedLength()",
    "snippet": "        public int estimateParsedLength() {\n            return MAX_LENGTH;\n        }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "TimeZoneId.estimatePrintedLength",
    "class_name": "org.joda.time.format.DateTimeFormatterBuilder$TimeZoneId",
    "signature": "org.joda.time.format.DateTimeFormatterBuilder$TimeZoneId.estimatePrintedLength()",
    "snippet": "        public int estimatePrintedLength() {\n            return MAX_LENGTH;\n        }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "TimeZoneId.parseInto",
    "class_name": "org.joda.time.format.DateTimeFormatterBuilder$TimeZoneId",
    "signature": "org.joda.time.format.DateTimeFormatterBuilder$TimeZoneId.parseInto(DateTimeParserBucket,String,int)",
    "snippet": "        public int parseInto(DateTimeParserBucket bucket, String text, int position) {\n            String str = text.substring(position);\n            for (String id : ALL_IDS) {\n                if (str.startsWith(id)) {\n                    bucket.setZone(DateTimeZone.forID(id));\n                    return position + id.length();\n                }\n            }\n            return ~position;\n        }",
    "comment": "",
    "is_bug": true,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "TimeZoneId.printTo",
    "class_name": "org.joda.time.format.DateTimeFormatterBuilder$TimeZoneId",
    "signature": "org.joda.time.format.DateTimeFormatterBuilder$TimeZoneId.printTo(StringBuffer,long,Chronology,int,DateTimeZone,Locale)",
    "snippet": "        public void printTo(\n                StringBuffer buf, long instant, Chronology chrono,\n                int displayOffset, DateTimeZone displayZone, Locale locale) {\n            buf.append(displayZone != null ? displayZone.getID() : \"\");\n        }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "DateTimeParserBucket.DateTimeParserBucket",
    "class_name": "org.joda.time.format.DateTimeParserBucket",
    "signature": "org.joda.time.format.DateTimeParserBucket.DateTimeParserBucket(long,Chronology,Locale,Integer,int)",
    "snippet": "    public DateTimeParserBucket(long instantLocal, Chronology chrono,\n            Locale locale, Integer pivotYear, int defaultYear) {\n        super();\n        chrono = DateTimeUtils.getChronology(chrono);\n        iMillis = instantLocal;\n        iZone = chrono.getZone();\n        iChrono = chrono.withUTC();\n        iLocale = (locale == null ? Locale.getDefault() : locale);\n        iPivotYear = pivotYear;\n        iDefaultYear = defaultYear;\n    }",
    "comment": " Constructs a bucket, with the option of specifying the pivot year for two-digit year parsing.  @param instantLocal  the initial millis from 1970-01-01T00:00:00, local time @param chrono  the chronology to use @param locale  the locale to use @param pivotYear  the pivot year to use when parsing two-digit years @since 2.0 ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "DateTimeParserBucket.saveField",
    "class_name": "org.joda.time.format.DateTimeParserBucket",
    "signature": "org.joda.time.format.DateTimeParserBucket.saveField(DateTimeFieldType,int)",
    "snippet": "    public void saveField(DateTimeFieldType fieldType, int value) {\n        saveField(new SavedField(fieldType.getField(iChrono), value));\n    }",
    "comment": " Saves a datetime field value.  @param fieldType  the field type @param value  the value ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "DateTimeParserBucket.saveField",
    "class_name": "org.joda.time.format.DateTimeParserBucket",
    "signature": "org.joda.time.format.DateTimeParserBucket.saveField(SavedField)",
    "snippet": "    private void saveField(SavedField field) {\n        SavedField[] savedFields = iSavedFields;\n        int savedFieldsCount = iSavedFieldsCount;\n        \n        if (savedFieldsCount == savedFields.length || iSavedFieldsShared) {\n            // Expand capacity or merely copy if saved fields are shared.\n            SavedField[] newArray = new SavedField\n                [savedFieldsCount == savedFields.length ? savedFieldsCount * 2 : savedFields.length];\n            System.arraycopy(savedFields, 0, newArray, 0, savedFieldsCount);\n            iSavedFields = savedFields = newArray;\n            iSavedFieldsShared = false;\n        }\n        \n        iSavedState = null;\n        savedFields[savedFieldsCount] = field;\n        iSavedFieldsCount = savedFieldsCount + 1;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "DateTimeParserBucket.setZone",
    "class_name": "org.joda.time.format.DateTimeParserBucket",
    "signature": "org.joda.time.format.DateTimeParserBucket.setZone(DateTimeZone)",
    "snippet": "    public void setZone(DateTimeZone zone) {\n        iSavedState = null;\n        iZone = zone;\n    }",
    "comment": " Set a time zone to be used when computeMillis is called. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "FormatUtils.appendPaddedInteger",
    "class_name": "org.joda.time.format.FormatUtils",
    "signature": "org.joda.time.format.FormatUtils.appendPaddedInteger(StringBuffer,int,int)",
    "snippet": "    public static void appendPaddedInteger(StringBuffer buf, int value, int size) {\n        if (value < 0) {\n            buf.append('-');\n            if (value != Integer.MIN_VALUE) {\n                value = -value;\n            } else {\n                for (; size > 10; size--) {\n                    buf.append('0');\n                }\n                buf.append(\"\" + -(long)Integer.MIN_VALUE);\n                return;\n            }\n        }\n        if (value < 10) {\n            for (; size > 1; size--) {\n                buf.append('0');\n            }\n            buf.append((char)(value + '0'));\n        } else if (value < 100) {\n            for (; size > 2; size--) {\n                buf.append('0');\n            }\n            // Calculate value div/mod by 10 without using two expensive\n            // division operations. (2 ^ 27) / 10 = 13421772. Add one to\n            // value to correct rounding error.\n            int d = ((value + 1) * 13421772) >> 27;\n            buf.append((char) (d + '0'));\n            // Append remainder by calculating (value - d * 10).\n            buf.append((char) (value - (d << 3) - (d << 1) + '0'));\n        } else {\n            int digits;\n            if (value < 1000) {\n                digits = 3;\n            } else if (value < 10000) {\n                digits = 4;\n            } else {\n                digits = (int)(Math.log(value) / LOG_10) + 1;\n            }\n            for (; size > digits; size--) {\n                buf.append('0');\n            }\n            buf.append(Integer.toString(value));\n        }\n    }",
    "comment": " Converts an integer to a string, prepended with a variable amount of '0' pad characters, and appends it to the given buffer.  <p>This method is optimized for converting small values to strings.  @param buf receives integer converted to a string @param value value to convert to a string @param size minumum amount of digits to append ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "FormatUtils.createErrorMessage",
    "class_name": "org.joda.time.format.FormatUtils",
    "signature": "org.joda.time.format.FormatUtils.createErrorMessage(String,int)",
    "snippet": "    static String createErrorMessage(final String text, final int errorPos) {\n        int sampleLen = errorPos + 32;\n        String sampleText;\n        if (text.length() <= sampleLen + 3) {\n            sampleText = text;\n        } else {\n            sampleText = text.substring(0, sampleLen).concat(\"...\");\n        }\n        \n        if (errorPos <= 0) {\n            return \"Invalid format: \\\"\" + sampleText + '\"';\n        }\n        \n        if (errorPos >= text.length()) {\n            return \"Invalid format: \\\"\" + sampleText + \"\\\" is too short\";\n        }\n        \n        return \"Invalid format: \\\"\" + sampleText + \"\\\" is malformed at \\\"\" +\n            sampleText.substring(errorPos) + '\"';\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "CachedDateTimeZone.createInfo",
    "class_name": "org.joda.time.tz.CachedDateTimeZone",
    "signature": "org.joda.time.tz.CachedDateTimeZone.createInfo(long)",
    "snippet": "    private Info createInfo(long millis) {\n        long periodStart = millis & (0xffffffffL << 32);\n        Info info = new Info(iZone, periodStart);\n        \n        long end = periodStart | 0xffffffffL;\n        Info chain = info;\n        while (true) {\n            long next = iZone.nextTransition(periodStart);\n            if (next == periodStart || next > end) {\n                break;\n            }\n            periodStart = next;\n            chain = (chain.iNextInfo = new Info(iZone, periodStart));\n        }\n\n        return info;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "CachedDateTimeZone.forZone",
    "class_name": "org.joda.time.tz.CachedDateTimeZone",
    "signature": "org.joda.time.tz.CachedDateTimeZone.forZone(DateTimeZone)",
    "snippet": "    public static CachedDateTimeZone forZone(DateTimeZone zone) {\n        if (zone instanceof CachedDateTimeZone) {\n            return (CachedDateTimeZone)zone;\n        }\n        return new CachedDateTimeZone(zone);\n    }",
    "comment": " Returns a new CachedDateTimeZone unless given zone is already cached. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "CachedDateTimeZone.getInfo",
    "class_name": "org.joda.time.tz.CachedDateTimeZone",
    "signature": "org.joda.time.tz.CachedDateTimeZone.getInfo(long)",
    "snippet": "    private Info getInfo(long millis) {\n        int period = (int)(millis >> 32);\n        Info[] cache = iInfoCache;\n        int index = period & cInfoCacheMask;\n        Info info = cache[index];\n        if (info == null || (int)((info.iPeriodStart >> 32)) != period) {\n            info = createInfo(millis);\n            cache[index] = info;\n        }\n        return info;\n    }",
    "comment": "synchronized.",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "CachedDateTimeZone.getOffset",
    "class_name": "org.joda.time.tz.CachedDateTimeZone",
    "signature": "org.joda.time.tz.CachedDateTimeZone.getOffset(long)",
    "snippet": "    public int getOffset(long instant) {\n        return getInfo(instant).getOffset(instant);\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "CachedDateTimeZone.hashCode",
    "class_name": "org.joda.time.tz.CachedDateTimeZone",
    "signature": "org.joda.time.tz.CachedDateTimeZone.hashCode()",
    "snippet": "    public int hashCode() {\n        return iZone.hashCode();\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "Info.getOffset",
    "class_name": "org.joda.time.tz.CachedDateTimeZone$Info",
    "signature": "org.joda.time.tz.CachedDateTimeZone$Info.getOffset(long)",
    "snippet": "        public int getOffset(long millis) {\n            if (iNextInfo == null || millis < iNextInfo.iPeriodStart) {\n                if (iOffset == Integer.MIN_VALUE) {\n                    iOffset = iZoneRef.getOffset(iPeriodStart);\n                }\n                return iOffset;\n            }\n            return iNextInfo.getOffset(millis);\n        }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "DateTimeZoneBuilder.readFrom",
    "class_name": "org.joda.time.tz.DateTimeZoneBuilder",
    "signature": "org.joda.time.tz.DateTimeZoneBuilder.readFrom(DataInput,String)",
    "snippet": "    public static DateTimeZone readFrom(DataInput in, String id) throws IOException {\n        switch (in.readUnsignedByte()) {\n        case 'F':\n            DateTimeZone fixed = new FixedDateTimeZone\n                (id, in.readUTF(), (int)readMillis(in), (int)readMillis(in));\n            if (fixed.equals(DateTimeZone.UTC)) {\n                fixed = DateTimeZone.UTC;\n            }\n            return fixed;\n        case 'C':\n            return CachedDateTimeZone.forZone(PrecalculatedZone.readFrom(in, id));\n        case 'P':\n            return PrecalculatedZone.readFrom(in, id);\n        default:\n            throw new IOException(\"Invalid encoding\");\n        }\n    }",
    "comment": " Decodes a built DateTimeZone from the given stream, as encoded by writeTo.  @param in input stream to read encoded DateTimeZone from. @param id time zone id to assign ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "DateTimeZoneBuilder.readFrom",
    "class_name": "org.joda.time.tz.DateTimeZoneBuilder",
    "signature": "org.joda.time.tz.DateTimeZoneBuilder.readFrom(InputStream,String)",
    "snippet": "    public static DateTimeZone readFrom(InputStream in, String id) throws IOException {\n        if (in instanceof DataInput) {\n            return readFrom((DataInput)in, id);\n        } else {\n            return readFrom((DataInput)new DataInputStream(in), id);\n        }\n    }",
    "comment": " Decodes a built DateTimeZone from the given stream, as encoded by writeTo.  @param in input stream to read encoded DateTimeZone from. @param id time zone id to assign ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "DateTimeZoneBuilder.readMillis",
    "class_name": "org.joda.time.tz.DateTimeZoneBuilder",
    "signature": "org.joda.time.tz.DateTimeZoneBuilder.readMillis(DataInput)",
    "snippet": "    static long readMillis(DataInput in) throws IOException {\n        int v = in.readUnsignedByte();\n        switch (v >> 6) {\n        case 0: default:\n            // Form 00 (6 bits effective precision)\n            v = (v << (32 - 6)) >> (32 - 6);\n            return v * (30 * 60000L);\n\n        case 1:\n            // Form 01 (30 bits effective precision)\n            v = (v << (32 - 6)) >> (32 - 30);\n            v |= (in.readUnsignedByte()) << 16;\n            v |= (in.readUnsignedByte()) << 8;\n            v |= (in.readUnsignedByte());\n            return v * 60000L;\n\n        case 2:\n            // Form 10 (38 bits effective precision)\n            long w = (((long)v) << (64 - 6)) >> (64 - 38);\n            w |= (in.readUnsignedByte()) << 24;\n            w |= (in.readUnsignedByte()) << 16;\n            w |= (in.readUnsignedByte()) << 8;\n            w |= (in.readUnsignedByte());\n            return w * 1000L;\n\n        case 3:\n            // Form 11 (64 bits effective precision)\n            return in.readLong();\n        }\n    }",
    "comment": " Reads encoding generated by writeMillis. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "DSTZone.readFrom",
    "class_name": "org.joda.time.tz.DateTimeZoneBuilder$DSTZone",
    "signature": "org.joda.time.tz.DateTimeZoneBuilder$DSTZone.readFrom(DataInput,String)",
    "snippet": "        static DSTZone readFrom(DataInput in, String id) throws IOException {\n            return new DSTZone(id, (int)readMillis(in), \n                               Recurrence.readFrom(in), Recurrence.readFrom(in));\n        }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "OfYear.readFrom",
    "class_name": "org.joda.time.tz.DateTimeZoneBuilder$OfYear",
    "signature": "org.joda.time.tz.DateTimeZoneBuilder$OfYear.readFrom(DataInput)",
    "snippet": "        static OfYear readFrom(DataInput in) throws IOException {\n            return new OfYear((char)in.readUnsignedByte(),\n                              (int)in.readUnsignedByte(),\n                              (int)in.readByte(),\n                              (int)in.readUnsignedByte(),\n                              in.readBoolean(),\n                              (int)readMillis(in));\n        }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "PrecalculatedZone.getOffset",
    "class_name": "org.joda.time.tz.DateTimeZoneBuilder$PrecalculatedZone",
    "signature": "org.joda.time.tz.DateTimeZoneBuilder$PrecalculatedZone.getOffset(long)",
    "snippet": "        public int getOffset(long instant) {\n            long[] transitions = iTransitions;\n            int i = Arrays.binarySearch(transitions, instant);\n            if (i >= 0) {\n                return iWallOffsets[i];\n            }\n            i = ~i;\n            if (i < transitions.length) {\n                if (i > 0) {\n                    return iWallOffsets[i - 1];\n                }\n                return 0;\n            }\n            if (iTailZone == null) {\n                return iWallOffsets[i - 1];\n            }\n            return iTailZone.getOffset(instant);\n        }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "PrecalculatedZone.nextTransition",
    "class_name": "org.joda.time.tz.DateTimeZoneBuilder$PrecalculatedZone",
    "signature": "org.joda.time.tz.DateTimeZoneBuilder$PrecalculatedZone.nextTransition(long)",
    "snippet": "        public long nextTransition(long instant) {\n            long[] transitions = iTransitions;\n            int i = Arrays.binarySearch(transitions, instant);\n            i = (i >= 0) ? (i + 1) : ~i;\n            if (i < transitions.length) {\n                return transitions[i];\n            }\n            if (iTailZone == null) {\n                return instant;\n            }\n            long end = transitions[transitions.length - 1];\n            if (instant < end) {\n                instant = end;\n            }\n            return iTailZone.nextTransition(instant);\n        }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "PrecalculatedZone.readFrom",
    "class_name": "org.joda.time.tz.DateTimeZoneBuilder$PrecalculatedZone",
    "signature": "org.joda.time.tz.DateTimeZoneBuilder$PrecalculatedZone.readFrom(DataInput,String)",
    "snippet": "        static PrecalculatedZone readFrom(DataInput in, String id) throws IOException {\n            // Read string pool.\n            int poolSize = in.readUnsignedShort();\n            String[] pool = new String[poolSize];\n            for (int i=0; i<poolSize; i++) {\n                pool[i] = in.readUTF();\n            }\n\n            int size = in.readInt();\n            long[] transitions = new long[size];\n            int[] wallOffsets = new int[size];\n            int[] standardOffsets = new int[size];\n            String[] nameKeys = new String[size];\n            \n            for (int i=0; i<size; i++) {\n                transitions[i] = readMillis(in);\n                wallOffsets[i] = (int)readMillis(in);\n                standardOffsets[i] = (int)readMillis(in);\n                try {\n                    int index;\n                    if (poolSize < 256) {\n                        index = in.readUnsignedByte();\n                    } else {\n                        index = in.readUnsignedShort();\n                    }\n                    nameKeys[i] = pool[index];\n                } catch (ArrayIndexOutOfBoundsException e) {\n                    throw new IOException(\"Invalid encoding\");\n                }\n            }\n\n            DSTZone tailZone = null;\n            if (in.readBoolean()) {\n                tailZone = DSTZone.readFrom(in, id);\n            }\n\n            return new PrecalculatedZone\n                (id, transitions, wallOffsets, standardOffsets, nameKeys, tailZone);\n        }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "Recurrence.readFrom",
    "class_name": "org.joda.time.tz.DateTimeZoneBuilder$Recurrence",
    "signature": "org.joda.time.tz.DateTimeZoneBuilder$Recurrence.readFrom(DataInput)",
    "snippet": "        static Recurrence readFrom(DataInput in) throws IOException {\n            return new Recurrence(OfYear.readFrom(in), in.readUTF(), (int)readMillis(in));\n        }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "DefaultNameProvider.DefaultNameProvider",
    "class_name": "org.joda.time.tz.DefaultNameProvider",
    "signature": "org.joda.time.tz.DefaultNameProvider.DefaultNameProvider()",
    "snippet": "    public DefaultNameProvider() {\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "DefaultNameProvider.createCache",
    "class_name": "org.joda.time.tz.DefaultNameProvider",
    "signature": "org.joda.time.tz.DefaultNameProvider.createCache()",
    "snippet": "    private HashMap createCache() {\n        return new HashMap(7);\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "FixedDateTimeZone.FixedDateTimeZone",
    "class_name": "org.joda.time.tz.FixedDateTimeZone",
    "signature": "org.joda.time.tz.FixedDateTimeZone.FixedDateTimeZone(String,String,int,int)",
    "snippet": "    public FixedDateTimeZone(String id, String nameKey,\n                             int wallOffset, int standardOffset) {\n        super(id);\n        iNameKey = nameKey;\n        iWallOffset = wallOffset;\n        iStandardOffset = standardOffset;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "FixedDateTimeZone.equals",
    "class_name": "org.joda.time.tz.FixedDateTimeZone",
    "signature": "org.joda.time.tz.FixedDateTimeZone.equals(Object)",
    "snippet": "    public boolean equals(Object obj) {\n        if (this == obj) {\n            return true;\n        }\n        if (obj instanceof FixedDateTimeZone) {\n            FixedDateTimeZone other = (FixedDateTimeZone)obj;\n            return\n                getID().equals(other.getID()) &&\n                iStandardOffset == other.iStandardOffset &&\n                iWallOffset == other.iWallOffset;\n        }\n        return false;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "FixedDateTimeZone.hashCode",
    "class_name": "org.joda.time.tz.FixedDateTimeZone",
    "signature": "org.joda.time.tz.FixedDateTimeZone.hashCode()",
    "snippet": "    public int hashCode() {\n        return getID().hashCode() + 37 * iStandardOffset + 31 * iWallOffset;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "ZoneInfoProvider.ZoneInfoProvider",
    "class_name": "org.joda.time.tz.ZoneInfoProvider",
    "signature": "org.joda.time.tz.ZoneInfoProvider.ZoneInfoProvider(String)",
    "snippet": "    public ZoneInfoProvider(String resourcePath) throws IOException {\n        this(resourcePath, null, false);\n    }",
    "comment": " ZoneInfoProvider searches the given ClassLoader resource path for compiled data files. Resources are loaded from the ClassLoader that loaded this class.  @throws IOException if directory or map file cannot be read ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "ZoneInfoProvider.getAvailableIDs",
    "class_name": "org.joda.time.tz.ZoneInfoProvider",
    "signature": "org.joda.time.tz.ZoneInfoProvider.getAvailableIDs()",
    "snippet": "    public Set<String> getAvailableIDs() {\n        // Return a copy of the keys rather than an umodifiable collection.\n        // This prevents ConcurrentModificationExceptions from being thrown by\n        // some JVMs if zones are opened while this set is iterated over.\n        return new TreeSet<String>(iZoneInfoMap.keySet());\n    }",
    "comment": " Gets a list of all the available zone ids.  @return the zone ids ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "ZoneInfoProvider.getZone",
    "class_name": "org.joda.time.tz.ZoneInfoProvider",
    "signature": "org.joda.time.tz.ZoneInfoProvider.getZone(String)",
    "snippet": "    public DateTimeZone getZone(String id) {\n        if (id == null) {\n            return null;\n        }\n\n        Object obj = iZoneInfoMap.get(id);\n        if (obj == null) {\n            return null;\n        }\n\n        if (id.equals(obj)) {\n            // Load zone data for the first time.\n            return loadZoneData(id);\n        }\n\n        if (obj instanceof SoftReference<?>) {\n            @SuppressWarnings(\"unchecked\")\n            SoftReference<DateTimeZone> ref = (SoftReference<DateTimeZone>) obj;\n            DateTimeZone tz = ref.get();\n            if (tz != null) {\n                return tz;\n            }\n            // Reference cleared; load data again.\n            return loadZoneData(id);\n        }\n\n        // If this point is reached, mapping must link to another.\n        return getZone((String)obj);\n    }",
    "comment": " If an error is thrown while loading zone data, uncaughtException is called to log the error and null is returned for this and all future requests.  @param id  the id to load @return the loaded zone ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "ZoneInfoProvider.loadZoneData",
    "class_name": "org.joda.time.tz.ZoneInfoProvider",
    "signature": "org.joda.time.tz.ZoneInfoProvider.loadZoneData(String)",
    "snippet": "    private DateTimeZone loadZoneData(String id) {\n        InputStream in = null;\n        try {\n            in = openResource(id);\n            DateTimeZone tz = DateTimeZoneBuilder.readFrom(in, id);\n            iZoneInfoMap.put(id, new SoftReference<DateTimeZone>(tz));\n            return tz;\n        } catch (IOException e) {\n            uncaughtException(e);\n            iZoneInfoMap.remove(id);\n            return null;\n        } finally {\n            try {\n                if (in != null) {\n                    in.close();\n                }\n            } catch (IOException e) {\n            }\n        }\n    }",
    "comment": " Loads the time zone data for one id.  @param id  the id to load @return the zone ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "ZoneInfoProvider.loadZoneInfoMap",
    "class_name": "org.joda.time.tz.ZoneInfoProvider",
    "signature": "org.joda.time.tz.ZoneInfoProvider.loadZoneInfoMap(InputStream)",
    "snippet": "    private static Map<String, Object> loadZoneInfoMap(InputStream in) throws IOException {\n        Map<String, Object> map = new ConcurrentHashMap<String, Object>();\n        DataInputStream din = new DataInputStream(in);\n        try {\n            readZoneInfoMap(din, map);\n        } finally {\n            try {\n                din.close();\n            } catch (IOException e) {\n            }\n        }\n        map.put(\"UTC\", new SoftReference<DateTimeZone>(DateTimeZone.UTC));\n        return map;\n    }",
    "comment": " Loads the zone info map.  @param in  the input stream @return the map ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "ZoneInfoProvider.openResource",
    "class_name": "org.joda.time.tz.ZoneInfoProvider",
    "signature": "org.joda.time.tz.ZoneInfoProvider.openResource(String)",
    "snippet": "    private InputStream openResource(String name) throws IOException {\n        InputStream in;\n        if (iFileDir != null) {\n            in = new FileInputStream(new File(iFileDir, name));\n        } else {\n            String path = iResourcePath.concat(name);\n            if (iLoader != null) {\n                in = iLoader.getResourceAsStream(path);\n            } else {\n                in = ClassLoader.getSystemResourceAsStream(path);\n            }\n            if (in == null) {\n                StringBuffer buf = new StringBuffer(40)\n                    .append(\"Resource not found: \\\"\")\n                    .append(path)\n                    .append(\"\\\" ClassLoader: \")\n                    .append(iLoader != null ? iLoader.toString() : \"system\");\n                throw new IOException(buf.toString());\n            }\n        }\n        return in;\n    }",
    "comment": " Opens a resource from file or classpath.  @param name  the name to open @return the input stream @throws IOException if an error occurs ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "ZoneInfoProvider.readZoneInfoMap",
    "class_name": "org.joda.time.tz.ZoneInfoProvider",
    "signature": "org.joda.time.tz.ZoneInfoProvider.readZoneInfoMap(DataInputStream,Map)",
    "snippet": "    private static void readZoneInfoMap(DataInputStream din, Map<String, Object> zimap) throws IOException {\n        // Read the string pool.\n        int size = din.readUnsignedShort();\n        String[] pool = new String[size];\n        for (int i=0; i<size; i++) {\n            pool[i] = din.readUTF().intern();\n        }\n\n        // Read the mappings.\n        size = din.readUnsignedShort();\n        for (int i=0; i<size; i++) {\n            try {\n                zimap.put(pool[din.readUnsignedShort()], pool[din.readUnsignedShort()]);\n            } catch (ArrayIndexOutOfBoundsException e) {\n                throw new IOException(\"Corrupt zone info map\");\n            }\n        }\n    }",
    "comment": " Reads the zone info map from file.  @param din  the input stream @param zimap  gets filled with string id to string id mappings ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  }
]