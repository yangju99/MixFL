[
  {
    "name": "AbstractCompiler.getLifeCycleStage",
    "class_name": "com.google.javascript.jscomp.AbstractCompiler",
    "signature": "com.google.javascript.jscomp.AbstractCompiler.getLifeCycleStage()",
    "snippet": "  LifeCycleStage getLifeCycleStage() {\n    return stage;\n  }",
    "comment": " @return The current life-cycle stage of the AST we're working on. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "AbstractCompiler.setLifeCycleStage",
    "class_name": "com.google.javascript.jscomp.AbstractCompiler",
    "signature": "com.google.javascript.jscomp.AbstractCompiler.setLifeCycleStage(LifeCycleStage)",
    "snippet": "  void setLifeCycleStage(LifeCycleStage stage) {\n    this.stage = stage;\n  }",
    "comment": " Set the current life-cycle state. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "LifeCycleStage.isNormalized",
    "class_name": "com.google.javascript.jscomp.AbstractCompiler$LifeCycleStage",
    "signature": "com.google.javascript.jscomp.AbstractCompiler$LifeCycleStage.isNormalized()",
    "snippet": "    boolean isNormalized() {\n      return this == NORMALIZED || this == NORMALIZED_OBFUSCATED;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "LifeCycleStage.isNormalizedObfuscated",
    "class_name": "com.google.javascript.jscomp.AbstractCompiler$LifeCycleStage",
    "signature": "com.google.javascript.jscomp.AbstractCompiler$LifeCycleStage.isNormalizedObfuscated()",
    "snippet": "    boolean isNormalizedObfuscated() {\n      return this == NORMALIZED_OBFUSCATED;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "AbstractMessageFormatter.AbstractMessageFormatter",
    "class_name": "com.google.javascript.jscomp.AbstractMessageFormatter",
    "signature": "com.google.javascript.jscomp.AbstractMessageFormatter.AbstractMessageFormatter(SourceExcerptProvider)",
    "snippet": "  public AbstractMessageFormatter(SourceExcerptProvider source) {\n    this.source = source;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "AbstractMessageFormatter.setColorize",
    "class_name": "com.google.javascript.jscomp.AbstractMessageFormatter",
    "signature": "com.google.javascript.jscomp.AbstractMessageFormatter.setColorize(boolean)",
    "snippet": "  public void setColorize(boolean colorize) {\n    this.colorize = colorize;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "AstValidator.AstValidator",
    "class_name": "com.google.javascript.jscomp.AstValidator",
    "signature": "com.google.javascript.jscomp.AstValidator.AstValidator()",
    "snippet": "  public AstValidator() {\n    this.violationHandler = new ViolationHandler() {\n      @Override\n      public void handleViolation(String message, Node n) {\n        throw new IllegalStateException(\n            message + \" Reference node \" + n.toString());\n      }\n    };\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "AstValidator.validateBlock",
    "class_name": "com.google.javascript.jscomp.AstValidator",
    "signature": "com.google.javascript.jscomp.AstValidator.validateBlock(Node)",
    "snippet": "  private void validateBlock(Node n) {\n    validateNodeType(Token.BLOCK, n);\n    for (Node c = n.getFirstChild(); c != null; c = c.getNext()) {\n      validateStatement(c);\n    }\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "AstValidator.validateCall",
    "class_name": "com.google.javascript.jscomp.AstValidator",
    "signature": "com.google.javascript.jscomp.AstValidator.validateCall(Node)",
    "snippet": "  private void validateCall(Node n) {\n    validateNodeType(Token.CALL, n);\n    validateMinimumChildCount(n, 1);\n    for (Node c = n.getFirstChild(); c != null; c = c.getNext()) {\n      validateExpression(c);\n    }\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "AstValidator.validateChildCount",
    "class_name": "com.google.javascript.jscomp.AstValidator",
    "signature": "com.google.javascript.jscomp.AstValidator.validateChildCount(Node,int)",
    "snippet": "  private void validateChildCount(Node n, int i) {\n    boolean valid = false;\n    if (i == 0) {\n      valid = !n.hasChildren();\n    } else if (i == 1) {\n      valid = n.hasOneChild();\n    } else {\n      valid = (n.getChildCount() == i);\n    }\n    if (!valid) {\n      violation(\n          \"Expected \" + i + \" children, but was \"\n              + n.getChildCount(), n);\n    }\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "AstValidator.validateCodeRoot",
    "class_name": "com.google.javascript.jscomp.AstValidator",
    "signature": "com.google.javascript.jscomp.AstValidator.validateCodeRoot(Node)",
    "snippet": "  public void validateCodeRoot(Node n) {\n    validateNodeType(Token.BLOCK, n);\n    validateIsSynthetic(n);\n    for (Node c = n.getFirstChild(); c != null; c = c.getNext()) {\n      validateScript(c);\n    }\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "AstValidator.validateExprStmt",
    "class_name": "com.google.javascript.jscomp.AstValidator",
    "signature": "com.google.javascript.jscomp.AstValidator.validateExprStmt(Node)",
    "snippet": "  private void validateExprStmt(Node n) {\n    validateNodeType(Token.EXPR_RESULT, n);\n    validateChildCount(n, 1);\n    validateExpression(n.getFirstChild());\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "AstValidator.validateExpression",
    "class_name": "com.google.javascript.jscomp.AstValidator",
    "signature": "com.google.javascript.jscomp.AstValidator.validateExpression(Node)",
    "snippet": "  public void validateExpression(Node n) {\n    switch (n.getType()) {\n      // Childless expressions\n      case Token.FALSE:\n      case Token.NULL:\n      case Token.THIS:\n      case Token.TRUE:\n        validateChildless(n);\n        return;\n\n      // General uniary ops\n      case Token.DELPROP:\n      case Token.POS:\n      case Token.NEG:\n      case Token.NOT:\n      case Token.INC:\n      case Token.DEC:\n      case Token.TYPEOF:\n      case Token.VOID:\n      case Token.BITNOT:\n        validateUnaryOp(n);\n        return;\n\n      // General binary ops\n      case Token.COMMA:\n      case Token.OR:\n      case Token.AND:\n      case Token.BITOR:\n      case Token.BITXOR:\n      case Token.BITAND:\n      case Token.EQ:\n      case Token.NE:\n      case Token.SHEQ:\n      case Token.SHNE:\n      case Token.LT:\n      case Token.GT:\n      case Token.LE:\n      case Token.GE:\n      case Token.INSTANCEOF:\n      case Token.IN:\n      case Token.LSH:\n      case Token.RSH:\n      case Token.URSH:\n      case Token.SUB:\n      case Token.ADD:\n      case Token.MUL:\n      case Token.MOD:\n      case Token.DIV:\n        validateBinaryOp(n);\n        return;\n\n      // Assignments\n      case Token.ASSIGN:\n      case Token.ASSIGN_BITOR:\n      case Token.ASSIGN_BITXOR:\n      case Token.ASSIGN_BITAND:\n      case Token.ASSIGN_LSH:\n      case Token.ASSIGN_RSH:\n      case Token.ASSIGN_URSH:\n      case Token.ASSIGN_ADD:\n      case Token.ASSIGN_SUB:\n      case Token.ASSIGN_MUL:\n      case Token.ASSIGN_DIV:\n      case Token.ASSIGN_MOD:\n        validateAssignmentExpression(n);\n        return;\n\n      case Token.HOOK:\n        validateTrinaryOp(n);\n        return;\n\n      // Node types that require special handling\n      case Token.STRING:\n        validateString(n);\n        return;\n\n      case Token.NUMBER:\n        validateNumber(n);\n        return;\n\n      case Token.NAME:\n        validateName(n);\n        return;\n\n      case Token.GETELEM:\n        validateBinaryOp(n);\n        return;\n\n      case Token.GETPROP:\n        validateGetProp(n);\n        return;\n\n      case Token.ARRAYLIT:\n        validateArrayLit(n);\n        return;\n\n      case Token.OBJECTLIT:\n        validateObjectLit(n);\n        return;\n\n      case Token.REGEXP:\n        validateRegExpLit(n);\n        return;\n\n      case Token.CALL:\n        validateCall(n);\n        return;\n\n      case Token.NEW:\n        validateNew(n);\n        return;\n\n      case Token.FUNCTION:\n        validateFunctionExpression(n);\n        return;\n\n      default:\n        violation(\"Expected expression but was \"\n            + Node.tokenToName(n.getType()), n);\n    }\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "AstValidator.validateFunctionStatement",
    "class_name": "com.google.javascript.jscomp.AstValidator",
    "signature": "com.google.javascript.jscomp.AstValidator.validateFunctionStatement(Node)",
    "snippet": "  private void validateFunctionStatement(Node n) {\n    validateNodeType(Token.FUNCTION, n);\n    validateChildCount(n, 3);\n    validateName(n.getFirstChild());\n    validateParameters(n.getChildAtIndex(1));\n    validateBlock(n.getLastChild());\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "AstValidator.validateIsSynthetic",
    "class_name": "com.google.javascript.jscomp.AstValidator",
    "signature": "com.google.javascript.jscomp.AstValidator.validateIsSynthetic(Node)",
    "snippet": "  private void validateIsSynthetic(Node n) {\n    if (!n.getBooleanProp(Node.SYNTHETIC_BLOCK_PROP)) {\n      violation(\"Missing 'synthetic block' annotation.\", n);\n    }\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "AstValidator.validateLabel",
    "class_name": "com.google.javascript.jscomp.AstValidator",
    "signature": "com.google.javascript.jscomp.AstValidator.validateLabel(Node)",
    "snippet": "  private void validateLabel(Node n) {\n    validateNodeType(Token.LABEL, n);\n    validateChildCount(n, 2);\n    validateLabelName(n.getFirstChild());\n    validateStatement(n.getLastChild());\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "AstValidator.validateLabelName",
    "class_name": "com.google.javascript.jscomp.AstValidator",
    "signature": "com.google.javascript.jscomp.AstValidator.validateLabelName(Node)",
    "snippet": "  private void validateLabelName(Node n) {\n    validateNodeType(Token.LABEL_NAME, n);\n    validateNonEmptyString(n);\n    validateChildCount(n, 0);\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "AstValidator.validateMinimumChildCount",
    "class_name": "com.google.javascript.jscomp.AstValidator",
    "signature": "com.google.javascript.jscomp.AstValidator.validateMinimumChildCount(Node,int)",
    "snippet": "  private void validateMinimumChildCount(Node n, int i) {\n    boolean valid = false;\n    if (i == 1) {\n      valid = n.hasChildren();\n    } else if (i == 2) {\n      valid = n.hasMoreThanOneChild();\n    } else {\n      valid = n.getChildCount() >= i;\n    }\n\n    if (!valid) {\n      violation(\n          \"Expected at least \" + i + \" children, but was \"\n              + n.getChildCount(), n);\n    }\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "AstValidator.validateName",
    "class_name": "com.google.javascript.jscomp.AstValidator",
    "signature": "com.google.javascript.jscomp.AstValidator.validateName(Node)",
    "snippet": "  private void validateName(Node n) {\n    validateNodeType(Token.NAME, n);\n    validateNonEmptyString(n);\n    validateChildCount(n, 0);\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "AstValidator.validateNodeType",
    "class_name": "com.google.javascript.jscomp.AstValidator",
    "signature": "com.google.javascript.jscomp.AstValidator.validateNodeType(int,Node)",
    "snippet": "  private void validateNodeType(int type, Node n) {\n    if (n.getType() != type) {\n      violation(\n          \"Expected \" + Node.tokenToName(type) + \" but was \"\n              + Node.tokenToName(n.getType()), n);\n    }\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "AstValidator.validateNonEmptyString",
    "class_name": "com.google.javascript.jscomp.AstValidator",
    "signature": "com.google.javascript.jscomp.AstValidator.validateNonEmptyString(Node)",
    "snippet": "  private void validateNonEmptyString(Node n) {\n    validateNonNullString(n);\n    if (n.getString().isEmpty()) {\n      violation(\"Expected non-empty string.\", n);\n    }\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "AstValidator.validateNonNullString",
    "class_name": "com.google.javascript.jscomp.AstValidator",
    "signature": "com.google.javascript.jscomp.AstValidator.validateNonNullString(Node)",
    "snippet": "  private void validateNonNullString(Node n) {\n    if (n.getString() == null) {\n      violation(\"Expected non-null string.\", n);\n    }\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "AstValidator.validateNumber",
    "class_name": "com.google.javascript.jscomp.AstValidator",
    "signature": "com.google.javascript.jscomp.AstValidator.validateNumber(Node)",
    "snippet": "  private void validateNumber(Node n) {\n    validateNodeType(Token.NUMBER, n);\n    validateChildCount(n, 0);\n    try {\n      // Validate that getDouble doesn't throw\n      n.getDouble();\n    } catch (UnsupportedOperationException e) {\n      violation(\"Invalid NUMBER node.\", n);\n    }\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "AstValidator.validateParameters",
    "class_name": "com.google.javascript.jscomp.AstValidator",
    "signature": "com.google.javascript.jscomp.AstValidator.validateParameters(Node)",
    "snippet": "  private void validateParameters(Node n) {\n    validateNodeType(Token.LP, n);\n    for (Node c = n.getFirstChild(); c != null; c = c.getNext()) {\n      validateName(c);\n    }\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "AstValidator.validateRoot",
    "class_name": "com.google.javascript.jscomp.AstValidator",
    "signature": "com.google.javascript.jscomp.AstValidator.validateRoot(Node)",
    "snippet": "  public void validateRoot(Node n) {\n    validateNodeType(Token.BLOCK, n);\n    validateIsSynthetic(n);\n    validateChildCount(n, 2);\n    validateCodeRoot(n.getFirstChild());\n    validateCodeRoot(n.getLastChild());\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "AstValidator.validateScript",
    "class_name": "com.google.javascript.jscomp.AstValidator",
    "signature": "com.google.javascript.jscomp.AstValidator.validateScript(Node)",
    "snippet": "  public void validateScript(Node n) {\n    validateNodeType(Token.SCRIPT, n);\n    validateIsSynthetic(n);\n    for (Node c = n.getFirstChild(); c != null; c = c.getNext()) {\n      validateStatement(c);\n    }\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "AstValidator.validateStatement",
    "class_name": "com.google.javascript.jscomp.AstValidator",
    "signature": "com.google.javascript.jscomp.AstValidator.validateStatement(Node)",
    "snippet": "  public void validateStatement(Node n) {\n    switch (n.getType()) {\n      case Token.LABEL:\n        validateLabel(n);\n        return;\n      case Token.BLOCK:\n        validateBlock(n);\n        return;\n      case Token.FUNCTION:\n        validateFunctionStatement(n);\n        return;\n      case Token.WITH:\n        validateWith(n);\n        return;\n      case Token.FOR:\n        validateFor(n);\n        return;\n      case Token.WHILE:\n        validateWhile(n);\n        return;\n      case Token.DO:\n        validateDo(n);\n        return;\n      case Token.SWITCH:\n        validateSwitch(n);\n        return;\n      case Token.IF:\n        validateIf(n);\n        return;\n      case Token.VAR:\n        validateVar(n);\n        return;\n      case Token.EXPR_RESULT:\n        validateExprStmt(n);\n        return;\n      case Token.RETURN:\n        validateReturn(n);\n        return;\n      case Token.THROW:\n        validateThrow(n);\n        return;\n      case Token.TRY:\n        validateTry(n);\n        return;\n      case Token.BREAK:\n        validateBreak(n);\n        return;\n      case Token.CONTINUE:\n        validateContinue(n);\n        return;\n      case Token.EMPTY:\n        validateChildless(n);\n        return;\n      case Token.DEBUGGER:\n        validateChildless(n);\n        return;\n      default:\n        violation(\"Expected statement but was \"\n            + Node.tokenToName(n.getType()) + \".\", n);\n    }\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "BasicErrorManager.getErrorCount",
    "class_name": "com.google.javascript.jscomp.BasicErrorManager",
    "signature": "com.google.javascript.jscomp.BasicErrorManager.getErrorCount()",
    "snippet": "  public int getErrorCount() {\n    return errorCount;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "BasicErrorManager.getErrors",
    "class_name": "com.google.javascript.jscomp.BasicErrorManager",
    "signature": "com.google.javascript.jscomp.BasicErrorManager.getErrors()",
    "snippet": "  public JSError[] getErrors() {\n    return toArray(CheckLevel.ERROR);\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "BasicErrorManager.getWarningCount",
    "class_name": "com.google.javascript.jscomp.BasicErrorManager",
    "signature": "com.google.javascript.jscomp.BasicErrorManager.getWarningCount()",
    "snippet": "  public int getWarningCount() {\n    return warningCount;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "BasicErrorManager.getWarnings",
    "class_name": "com.google.javascript.jscomp.BasicErrorManager",
    "signature": "com.google.javascript.jscomp.BasicErrorManager.getWarnings()",
    "snippet": "  public JSError[] getWarnings() {\n    return toArray(CheckLevel.WARNING);\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "BasicErrorManager.toArray",
    "class_name": "com.google.javascript.jscomp.BasicErrorManager",
    "signature": "com.google.javascript.jscomp.BasicErrorManager.toArray(CheckLevel)",
    "snippet": "  private JSError[] toArray(CheckLevel level) {\n    List<JSError> errors = new ArrayList<JSError>(messages.size());\n    for (ErrorWithLevel p : messages) {\n      if (p.level == level) {\n        errors.add(p.error);\n      }\n    }\n    return errors.toArray(new JSError[errors.size()]);\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "CheckLevel.isOn",
    "class_name": "com.google.javascript.jscomp.CheckLevel",
    "signature": "com.google.javascript.jscomp.CheckLevel.isOn()",
    "snippet": "  boolean isOn() {\n    return this != OFF;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "RecentChange.hasCodeChanged",
    "class_name": "com.google.javascript.jscomp.CodeChangeHandler$RecentChange",
    "signature": "com.google.javascript.jscomp.CodeChangeHandler$RecentChange.hasCodeChanged()",
    "snippet": "    boolean hasCodeChanged() {\n      return hasChanged;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "RecentChange.reportChange",
    "class_name": "com.google.javascript.jscomp.CodeChangeHandler$RecentChange",
    "signature": "com.google.javascript.jscomp.CodeChangeHandler$RecentChange.reportChange()",
    "snippet": "    public void reportChange() {\n      hasChanged = true;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "RecentChange.reset",
    "class_name": "com.google.javascript.jscomp.CodeChangeHandler$RecentChange",
    "signature": "com.google.javascript.jscomp.CodeChangeHandler$RecentChange.reset()",
    "snippet": "    void reset() {\n      hasChanged = false;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "CodeConsumer.add",
    "class_name": "com.google.javascript.jscomp.CodeConsumer",
    "signature": "com.google.javascript.jscomp.CodeConsumer.add(String)",
    "snippet": "  void add(String newcode) {\n    maybeEndStatement();\n\n    if (newcode.length() == 0) {\n      return;\n    }\n\n    char c = newcode.charAt(0);\n    if ((isWordChar(c) || c == '\\\\') &&\n        isWordChar(getLastChar())) {\n      // need space to separate. This is not pretty printing.\n      // For example: \"return foo;\"\n      append(\" \");\n    }\n\n    append(newcode);\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "CodeConsumer.addIdentifier",
    "class_name": "com.google.javascript.jscomp.CodeConsumer",
    "signature": "com.google.javascript.jscomp.CodeConsumer.addIdentifier(String)",
    "snippet": "  void addIdentifier(String identifier) {\n    add(identifier);\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "CodeConsumer.addNumber",
    "class_name": "com.google.javascript.jscomp.CodeConsumer",
    "signature": "com.google.javascript.jscomp.CodeConsumer.addNumber(double)",
    "snippet": "  void addNumber(double x) {\n    // This is not pretty printing. This is to prevent misparsing of x- -4 as\n    // x--4 (which is a syntax error).\n    char prev = getLastChar();\n    if (x < 0 && prev == '-') {\n      add(\" \");\n    }\n\n    if ((long) x == x) {\n      long value = (long) x;\n      long mantissa = value;\n      int exp = 0;\n      if (Math.abs(x) >= 100) {\n        while (mantissa / 10 * Math.pow(10, exp + 1) == value) {\n          mantissa /= 10;\n          exp++;\n        }\n      }\n      if (exp > 2) {\n        add(Long.toString(mantissa) + \"E\" + Integer.toString(exp));\n      } else {\n        add(Long.toString(value));\n      }\n    } else {\n      add(String.valueOf(x));\n    }\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "CodeConsumer.continueProcessing",
    "class_name": "com.google.javascript.jscomp.CodeConsumer",
    "signature": "com.google.javascript.jscomp.CodeConsumer.continueProcessing()",
    "snippet": "  boolean continueProcessing() {\n    return true;\n  }",
    "comment": " Provides a means of interrupting the CodeGenerator. Derived classes should return false to stop further processing. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "CodeConsumer.endFile",
    "class_name": "com.google.javascript.jscomp.CodeConsumer",
    "signature": "com.google.javascript.jscomp.CodeConsumer.endFile()",
    "snippet": "  void endFile() {}",
    "comment": "Called when we're at the end of a file. */",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "CodeConsumer.endStatement",
    "class_name": "com.google.javascript.jscomp.CodeConsumer",
    "signature": "com.google.javascript.jscomp.CodeConsumer.endStatement()",
    "snippet": "  void endStatement() {\n    endStatement(false);\n  }",
    "comment": " Indicates the end of a statement and a ';' may need to be added. But we don't add it now, in case we're at the end of a block (in which case we don't have to add the ';'). See maybeEndStatement() ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "CodeConsumer.endStatement",
    "class_name": "com.google.javascript.jscomp.CodeConsumer",
    "signature": "com.google.javascript.jscomp.CodeConsumer.endStatement(boolean)",
    "snippet": "  void endStatement(boolean needSemiColon) {\n    if (needSemiColon) {\n      append(\";\");\n      maybeLineBreak();\n      statementNeedsEnded = false;\n    } else if (statementStarted) {\n      statementNeedsEnded = true;\n    }\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "CodeConsumer.isWordChar",
    "class_name": "com.google.javascript.jscomp.CodeConsumer",
    "signature": "com.google.javascript.jscomp.CodeConsumer.isWordChar(char)",
    "snippet": "  static boolean isWordChar(char ch) {\n    return (ch == '_' ||\n            ch == '$' ||\n            Character.isLetterOrDigit(ch));\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "CodeConsumer.maybeEndStatement",
    "class_name": "com.google.javascript.jscomp.CodeConsumer",
    "signature": "com.google.javascript.jscomp.CodeConsumer.maybeEndStatement()",
    "snippet": "  void maybeEndStatement() {\n    // Add a ';' if we need to.\n    if (statementNeedsEnded) {\n      append(\";\");\n      maybeLineBreak();\n      endLine();\n      statementNeedsEnded = false;\n    }\n    statementStarted = true;\n  }",
    "comment": " This is to be called when we're in a statement. If the prev statement needs to be ended, add a ';'. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "CodeConsumer.shouldPreserveExtraBlocks",
    "class_name": "com.google.javascript.jscomp.CodeConsumer",
    "signature": "com.google.javascript.jscomp.CodeConsumer.shouldPreserveExtraBlocks()",
    "snippet": "  boolean shouldPreserveExtraBlocks() {\n    return false;\n  }",
    "comment": " If the body of a for loop or the then clause of an if statement has a single statement, should it be wrapped in a block?  Doing so can help when pretty-printing the code, and permits putting a debugging breakpoint on the statement inside the condition.  @return {@boolean true} if such expressions should be wrapped ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "CodeGenerator.CodeGenerator",
    "class_name": "com.google.javascript.jscomp.CodeGenerator",
    "signature": "com.google.javascript.jscomp.CodeGenerator.CodeGenerator(CodeConsumer,Charset)",
    "snippet": "  CodeGenerator(\n      CodeConsumer consumer, Charset outputCharset) {\n    cc = consumer;\n    if (outputCharset == null || outputCharset == Charsets.US_ASCII) {\n      // If we want our default (pretending to be UTF-8, but escaping anything\n      // outside of straight ASCII), then don't use the encoder, but\n      // just special-case the code.  This keeps the normal path through\n      // the code identical to how it's been for years.\n      this.outputCharsetEncoder = null;\n    } else {\n      this.outputCharsetEncoder = outputCharset.newEncoder();\n    }\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "CodeGenerator.add",
    "class_name": "com.google.javascript.jscomp.CodeGenerator",
    "signature": "com.google.javascript.jscomp.CodeGenerator.add(Node)",
    "snippet": "  void add(Node n) {\n    add(n, Context.OTHER);\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "CodeGenerator.add",
    "class_name": "com.google.javascript.jscomp.CodeGenerator",
    "signature": "com.google.javascript.jscomp.CodeGenerator.add(Node,Context)",
    "snippet": "  void add(Node n, Context context) {\n    if (!cc.continueProcessing()) {\n      return;\n    }\n\n    int type = n.getType();\n    String opstr = NodeUtil.opToStr(type);\n    int childCount = n.getChildCount();\n    Node first = n.getFirstChild();\n    Node last = n.getLastChild();\n\n    // Handle all binary operators\n    if (opstr != null && first != last) {\n      Preconditions.checkState(\n          childCount == 2,\n          \"Bad binary operator \\\"%s\\\": expected 2 arguments but got %s\",\n          opstr, childCount);\n      int p = NodeUtil.precedence(type);\n      addLeftExpr(first, p, context);\n      cc.addOp(opstr, true);\n\n      // For right-hand-side of operations, only pass context if it's\n      // the IN_FOR_INIT_CLAUSE one.\n      Context rhsContext = getContextForNoInOperator(context);\n\n      // Handle associativity.\n      // e.g. if the parse tree is a * (b * c),\n      // we can simply generate a * b * c.\n      if (last.getType() == type &&\n          NodeUtil.isAssociative(type)) {\n        addExpr(last, p, rhsContext);\n      } else if (NodeUtil.isAssignmentOp(n) && NodeUtil.isAssignmentOp(last)) {\n        // Assignments are the only right-associative binary operators\n        addExpr(last, p, rhsContext);\n      } else {\n        addExpr(last, p + 1, rhsContext);\n      }\n      return;\n    }\n\n    cc.startSourceMapping(n);\n\n    switch (type) {\n      case Token.TRY: {\n        Preconditions.checkState(first.getNext().getType() == Token.BLOCK &&\n                !first.getNext().hasMoreThanOneChild());\n        Preconditions.checkState(childCount >= 2 && childCount <= 3);\n\n        add(\"try\");\n        add(first, Context.PRESERVE_BLOCK);\n\n        // second child contains the catch block, or nothing if there\n        // isn't a catch block\n        Node catchblock = first.getNext().getFirstChild();\n        if (catchblock != null) {\n          add(catchblock);\n        }\n\n        if (childCount == 3) {\n          add(\"finally\");\n          add(last, Context.PRESERVE_BLOCK);\n        }\n        break;\n      }\n\n      case Token.CATCH:\n        Preconditions.checkState(childCount == 2);\n        add(\"catch(\");\n        add(first);\n        add(\")\");\n        add(last, Context.PRESERVE_BLOCK);\n        break;\n\n      case Token.THROW:\n        Preconditions.checkState(childCount == 1);\n        add(\"throw\");\n        add(first);\n\n        // Must have a ';' after a throw statement, otherwise safari can't\n        // parse this.\n        cc.endStatement(true);\n        break;\n\n      case Token.RETURN:\n        add(\"return\");\n        if (childCount == 1) {\n          add(first);\n        } else {\n          Preconditions.checkState(childCount == 0);\n        }\n        cc.endStatement();\n        break;\n\n      case Token.VAR:\n        if (first != null) {\n          add(\"var \");\n          addList(first, false, getContextForNoInOperator(context));\n        }\n        break;\n\n      case Token.LABEL_NAME:\n        Preconditions.checkState(!n.getString().isEmpty());\n        addIdentifier(n.getString());\n        break;\n\n      case Token.NAME:\n        if (first == null || first.getType() == Token.EMPTY) {\n          addIdentifier(n.getString());\n        } else {\n          Preconditions.checkState(childCount == 1);\n          addIdentifier(n.getString());\n          cc.addOp(\"=\", true);\n          if (first.getType() == Token.COMMA) {\n            addExpr(first, NodeUtil.precedence(Token.ASSIGN));\n          } else {\n            // Add expression, consider nearby code at lowest level of\n            // precedence.\n            addExpr(first, 0, getContextForNoInOperator(context));\n          }\n        }\n        break;\n\n      case Token.ARRAYLIT:\n        add(\"[\");\n        addArrayList(first);\n        add(\"]\");\n        break;\n\n      case Token.LP:\n        add(\"(\");\n        addList(first);\n        add(\")\");\n        break;\n\n      case Token.COMMA:\n        Preconditions.checkState(childCount == 2);\n        addList(first, false, context);\n        break;\n\n      case Token.NUMBER:\n        Preconditions.checkState(childCount == 0);\n        cc.addNumber(n.getDouble());\n        break;\n\n      case Token.TYPEOF:\n      case Token.VOID:\n      case Token.NOT:\n      case Token.BITNOT:\n      case Token.POS: {\n        // All of these unary operators are right-associative\n        Preconditions.checkState(childCount == 1);\n        cc.addOp(NodeUtil.opToStrNoFail(type), false);\n        addExpr(first, NodeUtil.precedence(type));\n        break;\n      }\n\n      case Token.NEG: {\n        Preconditions.checkState(childCount == 1);\n\n        // It's important to our sanity checker that the code\n        // we print produces the same AST as the code we parse back.\n        // NEG is a weird case because Rhino parses \"- -2\" as \"2\".\n        if (n.getFirstChild().getType() == Token.NUMBER) {\n          cc.addNumber(-n.getFirstChild().getDouble());\n        } else {\n          cc.addOp(NodeUtil.opToStrNoFail(type), false);\n          addExpr(first, NodeUtil.precedence(type));\n        }\n\n        break;\n      }\n\n      case Token.HOOK: {\n        Preconditions.checkState(childCount == 3);\n        int p = NodeUtil.precedence(type);\n        addLeftExpr(first, p + 1, context);\n        cc.addOp(\"?\", true);\n        addExpr(first.getNext(), 1);\n        cc.addOp(\":\", true);\n        addExpr(last, 1);\n        break;\n      }\n\n      case Token.REGEXP:\n        if (first.getType() != Token.STRING ||\n            last.getType() != Token.STRING) {\n          throw new Error(\"Expected children to be strings\");\n        }\n\n        String regexp = regexpEscape(first.getString(), outputCharsetEncoder);\n\n        // I only use one .add because whitespace matters\n        if (childCount == 2) {\n          add(regexp + last.getString());\n        } else {\n          Preconditions.checkState(childCount == 1);\n          add(regexp);\n        }\n        break;\n\n      case Token.GET_REF:\n        add(first);\n        break;\n\n      case Token.REF_SPECIAL:\n        Preconditions.checkState(childCount == 1);\n        add(first);\n        add(\".\");\n        add((String) n.getProp(Node.NAME_PROP));\n        break;\n\n      case Token.FUNCTION:\n        if (n.getClass() != Node.class) {\n          throw new Error(\"Unexpected Node subclass.\");\n        }\n        Preconditions.checkState(childCount == 3);\n        boolean funcNeedsParens = (context == Context.START_OF_EXPR);\n        if (funcNeedsParens) {\n          add(\"(\");\n        }\n\n        add(\"function\");\n        add(first);\n\n        add(first.getNext());\n        add(last, Context.PRESERVE_BLOCK);\n        cc.endFunction(context == Context.STATEMENT);\n\n        if (funcNeedsParens) {\n          add(\")\");\n        }\n        break;\n\n      case Token.GET:\n      case Token.SET:\n        Preconditions.checkState(n.getParent().getType() == Token.OBJECTLIT);\n        Preconditions.checkState(childCount == 1);\n        Preconditions.checkState(first.getType() == Token.FUNCTION);\n\n        // Get methods are unnamed\n        Preconditions.checkState(first.getFirstChild().getString().isEmpty());\n        if (type == Token.GET) {\n          // Get methods have no parameters.\n          Preconditions.checkState(!first.getChildAtIndex(1).hasChildren());\n          add(\"get \");\n        } else {\n          // Set methods have one parameter.\n          Preconditions.checkState(first.getChildAtIndex(1).hasOneChild());\n          add(\"set \");\n        }\n\n        // The name is on the GET or SET node.\n        String name = n.getString();\n        Node fn = first;\n        Node parameters = fn.getChildAtIndex(1);\n        Node body = fn.getLastChild();\n\n        // Add the property name.\n        if (!n.isQuotedString() &&\n            TokenStream.isJSIdentifier(name) &&\n            // do not encode literally any non-literal characters that were\n            // unicode escaped.\n            NodeUtil.isLatin(name)) {\n          add(name);\n        } else {\n          // Determine if the string is a simple number.\n          double d = getSimpleNumber(name);\n          if (!Double.isNaN(d)) {\n            cc.addNumber(d);\n          } else {\n            add(jsString(n.getString(), outputCharsetEncoder));\n          }\n        }\n\n        add(parameters);\n        add(body, Context.PRESERVE_BLOCK);\n        break;\n\n      case Token.SCRIPT:\n      case Token.BLOCK: {\n        if (n.getClass() != Node.class) {\n          throw new Error(\"Unexpected Node subclass.\");\n        }\n        boolean preserveBlock = context == Context.PRESERVE_BLOCK;\n        if (preserveBlock) {\n          cc.beginBlock();\n        }\n\n        boolean preferLineBreaks =\n            type == Token.SCRIPT ||\n            (type == Token.BLOCK &&\n                !preserveBlock &&\n                n.getParent() != null &&\n                n.getParent().getType() == Token.SCRIPT);\n        for (Node c = first; c != null; c = c.getNext()) {\n          add(c, Context.STATEMENT);\n\n          // VAR doesn't include ';' since it gets used in expressions\n          if (c.getType() == Token.VAR) {\n            cc.endStatement();\n          }\n\n          if (c.getType() == Token.FUNCTION) {\n            cc.maybeLineBreak();\n          }\n\n          // Prefer to break lines in between top-level statements\n          // because top level statements are more homogeneous.\n          if (preferLineBreaks) {\n            cc.notePreferredLineBreak();\n          }\n        }\n        if (preserveBlock) {\n          cc.endBlock(cc.breakAfterBlockFor(n, context == Context.STATEMENT));\n        }\n        break;\n      }\n\n      case Token.FOR:\n        if (childCount == 4) {\n          add(\"for(\");\n          if (first.getType() == Token.VAR) {\n            add(first, Context.IN_FOR_INIT_CLAUSE);\n          } else {\n            addExpr(first, 0, Context.IN_FOR_INIT_CLAUSE);\n          }\n          add(\";\");\n          add(first.getNext());\n          add(\";\");\n          add(first.getNext().getNext());\n          add(\")\");\n          addNonEmptyStatement(\n              last, getContextForNonEmptyExpression(context), false);\n        } else {\n          Preconditions.checkState(childCount == 3);\n          add(\"for(\");\n          add(first);\n          add(\"in\");\n          add(first.getNext());\n          add(\")\");\n          addNonEmptyStatement(\n              last, getContextForNonEmptyExpression(context), false);\n        }\n        break;\n\n      case Token.DO:\n        Preconditions.checkState(childCount == 2);\n        add(\"do\");\n        addNonEmptyStatement(first, Context.OTHER, false);\n        add(\"while(\");\n        add(last);\n        add(\")\");\n        cc.endStatement();\n        break;\n\n      case Token.WHILE:\n        Preconditions.checkState(childCount == 2);\n        add(\"while(\");\n        add(first);\n        add(\")\");\n        addNonEmptyStatement(\n            last, getContextForNonEmptyExpression(context), false);\n        break;\n\n      case Token.EMPTY:\n        Preconditions.checkState(childCount == 0);\n        break;\n\n      case Token.GETPROP: {\n        Preconditions.checkState(\n            childCount == 2,\n            \"Bad GETPROP: expected 2 children, but got %s\", childCount);\n        Preconditions.checkState(\n            last.getType() == Token.STRING,\n            \"Bad GETPROP: RHS should be STRING\");\n        boolean needsParens = (first.getType() == Token.NUMBER);\n        if (needsParens) {\n          add(\"(\");\n        }\n        addLeftExpr(first, NodeUtil.precedence(type), context);\n        if (needsParens) {\n          add(\")\");\n        }\n        add(\".\");\n        addIdentifier(last.getString());\n        break;\n      }\n\n      case Token.GETELEM:\n        Preconditions.checkState(\n            childCount == 2,\n            \"Bad GETELEM: expected 2 children but got %s\", childCount);\n        addLeftExpr(first, NodeUtil.precedence(type), context);\n        add(\"[\");\n        add(first.getNext());\n        add(\"]\");\n        break;\n\n      case Token.WITH:\n        Preconditions.checkState(childCount == 2);\n        add(\"with(\");\n        add(first);\n        add(\")\");\n        addNonEmptyStatement(\n            last, getContextForNonEmptyExpression(context), false);\n        break;\n\n      case Token.INC:\n      case Token.DEC: {\n        Preconditions.checkState(childCount == 1);\n        String o = type == Token.INC ? \"++\" : \"--\";\n        int postProp = n.getIntProp(Node.INCRDECR_PROP);\n        // A non-zero post-prop value indicates a post inc/dec, default of zero\n        // is a pre-inc/dec.\n        if (postProp != 0) {\n          addLeftExpr(first, NodeUtil.precedence(type), context);\n          cc.addOp(o, false);\n        } else {\n          cc.addOp(o, false);\n          add(first);\n        }\n        break;\n      }\n\n      case Token.CALL:\n        // We have two special cases here:\n        // 1) If the left hand side of the call is a direct reference to eval,\n        // then it must have a DIRECT_EVAL annotation. If it does not, then\n        // that means it was originally an indirect call to eval, and that\n        // indirectness must be preserved.\n        // 2) If the left hand side of the call is a property reference,\n        // then the call must not a FREE_CALL annotation. If it does, then\n        // that means it was originally an call without an explicit this and\n        // that must be preserved.\n        if (isIndirectEval(first)\n            || n.getBooleanProp(Node.FREE_CALL) && NodeUtil.isGet(first)) {\n          add(\"(0,\");\n          addExpr(first, NodeUtil.precedence(Token.COMMA));\n          add(\")\");\n        } else {\n          addLeftExpr(first, NodeUtil.precedence(type), context);\n        }\n        add(\"(\");\n        addList(first.getNext());\n        add(\")\");\n        break;\n\n      case Token.IF:\n        boolean hasElse = childCount == 3;\n        boolean ambiguousElseClause =\n            context == Context.BEFORE_DANGLING_ELSE && !hasElse;\n        if (ambiguousElseClause) {\n          cc.beginBlock();\n        }\n\n        add(\"if(\");\n        add(first);\n        add(\")\");\n\n        if (hasElse) {\n          addNonEmptyStatement(\n              first.getNext(), Context.BEFORE_DANGLING_ELSE, false);\n          add(\"else\");\n          addNonEmptyStatement(\n              last, getContextForNonEmptyExpression(context), false);\n        } else {\n          addNonEmptyStatement(first.getNext(), Context.OTHER, false);\n          Preconditions.checkState(childCount == 2);\n        }\n\n        if (ambiguousElseClause) {\n          cc.endBlock();\n        }\n        break;\n\n      case Token.NULL:\n      case Token.THIS:\n      case Token.FALSE:\n      case Token.TRUE:\n        Preconditions.checkState(childCount == 0);\n        add(Node.tokenToName(type));\n        break;\n\n      case Token.CONTINUE:\n        Preconditions.checkState(childCount <= 1);\n        add(\"continue\");\n        if (childCount == 1) {\n          if (first.getType() != Token.LABEL_NAME) {\n            throw new Error(\"Unexpected token type. Should be LABEL_NAME.\");\n          }\n          add(\" \");\n          add(first);\n        }\n        cc.endStatement();\n        break;\n\n      case Token.DEBUGGER:\n        Preconditions.checkState(childCount == 0);\n        add(\"debugger\");\n        cc.endStatement();\n        break;\n\n      case Token.BREAK:\n        Preconditions.checkState(childCount <= 1);\n        add(\"break\");\n        if (childCount == 1) {\n          if (first.getType() != Token.LABEL_NAME) {\n            throw new Error(\"Unexpected token type. Should be LABEL_NAME.\");\n          }\n          add(\" \");\n          add(first);\n        }\n        cc.endStatement();\n        break;\n\n      case Token.EXPR_VOID:\n        throw new Error(\"Unexpected EXPR_VOID. Should be EXPR_RESULT.\");\n\n      case Token.EXPR_RESULT:\n        Preconditions.checkState(childCount == 1);\n        add(first, Context.START_OF_EXPR);\n        cc.endStatement();\n        break;\n\n      case Token.NEW:\n        add(\"new \");\n        int precedence = NodeUtil.precedence(type);\n\n        // If the first child contains a CALL, then claim higher precedence\n        // to force parentheses. Otherwise, when parsed, NEW will bind to the\n        // first viable parentheses (don't traverse into functions).\n        if (NodeUtil.containsType(first, Token.CALL, new MatchNotFunction())) {\n          precedence = NodeUtil.precedence(first.getType()) + 1;\n        }\n        addExpr(first, precedence);\n\n        // '()' is optional when no arguments are present\n        Node next = first.getNext();\n        if (next != null) {\n          add(\"(\");\n          addList(next);\n          add(\")\");\n        }\n        break;\n\n      case Token.STRING:\n        if (childCount !=\n            ((n.getParent() != null &&\n              n.getParent().getType() == Token.OBJECTLIT) ? 1 : 0)) {\n          throw new IllegalStateException(\n              \"Unexpected String children: \" + n.getParent().toStringTree());\n        }\n        add(jsString(n.getString(), outputCharsetEncoder));\n        break;\n\n      case Token.DELPROP:\n        Preconditions.checkState(childCount == 1);\n        add(\"delete \");\n        add(first);\n        break;\n\n      case Token.OBJECTLIT: {\n        boolean needsParens = (context == Context.START_OF_EXPR);\n        if (needsParens) {\n          add(\"(\");\n        }\n        add(\"{\");\n        for (Node c = first; c != null; c = c.getNext()) {\n          if (c != first) {\n            cc.listSeparator();\n          }\n\n          if (c.getType() == Token.GET || c.getType() == Token.SET) {\n            add(c);\n          } else {\n            Preconditions.checkState(c.getType() == Token.STRING);\n            String key = c.getString();\n            // Object literal property names don't have to be quoted if they\n            // are not JavaScript keywords\n            if (!c.isQuotedString() &&\n                !TokenStream.isKeyword(key) &&\n                TokenStream.isJSIdentifier(key) &&\n                // do not encode literally any non-literal characters that\n                // were unicode escaped.\n                NodeUtil.isLatin(key)) {\n              add(key);\n            } else {\n              // Determine if the string is a simple number.\n              double d = getSimpleNumber(key);\n              if (!Double.isNaN(d)) {\n                cc.addNumber(d);\n              } else {\n                addExpr(c, 1);\n              }\n            }\n            add(\":\");\n            addExpr(c.getFirstChild(), 1);\n          }\n        }\n        add(\"}\");\n        if (needsParens) {\n          add(\")\");\n        }\n        break;\n      }\n\n      case Token.SWITCH:\n        add(\"switch(\");\n        add(first);\n        add(\")\");\n        cc.beginBlock();\n        addAllSiblings(first.getNext());\n        cc.endBlock(context == Context.STATEMENT);\n        break;\n\n      case Token.CASE:\n        Preconditions.checkState(childCount == 2);\n        add(\"case \");\n        add(first);\n        addCaseBody(last);\n        break;\n\n      case Token.DEFAULT:\n        Preconditions.checkState(childCount == 1);\n        add(\"default\");\n        addCaseBody(first);\n        break;\n\n      case Token.LABEL:\n        Preconditions.checkState(childCount == 2);\n        if (first.getType() != Token.LABEL_NAME) {\n          throw new Error(\"Unexpected token type. Should be LABEL_NAME.\");\n        }\n        add(first);\n        add(\":\");\n        addNonEmptyStatement(\n            last, getContextForNonEmptyExpression(context), true);\n        break;\n\n      // This node is auto generated in anonymous functions and should just get\n      // ignored for our purposes.\n      case Token.SETNAME:\n        break;\n\n      default:\n        throw new Error(\"Unknown type \" + type + \"\\n\" + n.toStringTree());\n    }\n\n    cc.endSourceMapping(n);\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "CodeGenerator.add",
    "class_name": "com.google.javascript.jscomp.CodeGenerator",
    "signature": "com.google.javascript.jscomp.CodeGenerator.add(String)",
    "snippet": "  void add(String str) {\n    cc.add(str);\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "CodeGenerator.addIdentifier",
    "class_name": "com.google.javascript.jscomp.CodeGenerator",
    "signature": "com.google.javascript.jscomp.CodeGenerator.addIdentifier(String)",
    "snippet": "  private void addIdentifier(String identifier) {\n    cc.addIdentifier(identifierEscape(identifier));\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "CodeGenerator.addNonEmptyStatement",
    "class_name": "com.google.javascript.jscomp.CodeGenerator",
    "signature": "com.google.javascript.jscomp.CodeGenerator.addNonEmptyStatement(Node,Context,boolean)",
    "snippet": "  private void addNonEmptyStatement(\n      Node n, Context context, boolean allowNonBlockChild) {\n    Node nodeToProcess = n;\n\n    if (!allowNonBlockChild && n.getType() != Token.BLOCK) {\n      throw new Error(\"Missing BLOCK child.\");\n    }\n\n    // Strip unneeded blocks, that is blocks with <2 children unless\n    // the CodePrinter specifically wants to keep them.\n    if (n.getType() == Token.BLOCK) {\n      int count = getNonEmptyChildCount(n, 2);\n      if (count == 0) {\n        if (cc.shouldPreserveExtraBlocks()) {\n          cc.beginBlock();\n          cc.endBlock(cc.breakAfterBlockFor(n, context == Context.STATEMENT));\n        } else {\n          cc.endStatement(true);\n        }\n        return;\n      }\n\n      if (count == 1) {\n        // Hack around a couple of browser bugs:\n        //   Safari needs a block around function declarations.\n        //   IE6/7 needs a block around DOs.\n        Node firstAndOnlyChild = getFirstNonEmptyChild(n);\n        boolean alwaysWrapInBlock = cc.shouldPreserveExtraBlocks();\n        if (alwaysWrapInBlock || isOneExactlyFunctionOrDo(firstAndOnlyChild)) {\n          cc.beginBlock();\n          add(firstAndOnlyChild, Context.STATEMENT);\n          cc.maybeLineBreak();\n          cc.endBlock(cc.breakAfterBlockFor(n, context == Context.STATEMENT));\n          return;\n        } else {\n          // Continue with the only child.\n          nodeToProcess = firstAndOnlyChild;\n        }\n      }\n\n      if (count > 1) {\n        context = Context.PRESERVE_BLOCK;\n      }\n    }\n\n    if (nodeToProcess.getType() == Token.EMPTY) {\n      cc.endStatement(true);\n    } else {\n      add(nodeToProcess, context);\n\n      // VAR doesn't include ';' since it gets used in expressions - so any\n      // VAR in a statement context needs a call to endStatement() here.\n      if (nodeToProcess.getType() == Token.VAR) {\n        cc.endStatement();\n      }\n    }\n  }",
    "comment": " Adds a block or expression, substituting a VOID with an empty statement. This is used for \"for (...);\" and \"if (...);\" type statements.  @param n The node to print. @param context The context to determine how the node should be printed. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "CodeGenerator.getContextForNonEmptyExpression",
    "class_name": "com.google.javascript.jscomp.CodeGenerator",
    "signature": "com.google.javascript.jscomp.CodeGenerator.getContextForNonEmptyExpression(Context)",
    "snippet": "  private Context getContextForNonEmptyExpression(Context currentContext) {\n    return currentContext == Context.BEFORE_DANGLING_ELSE ?\n        Context.BEFORE_DANGLING_ELSE : Context.OTHER;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "CodeGenerator.getFirstNonEmptyChild",
    "class_name": "com.google.javascript.jscomp.CodeGenerator",
    "signature": "com.google.javascript.jscomp.CodeGenerator.getFirstNonEmptyChild(Node)",
    "snippet": "  private static Node getFirstNonEmptyChild(Node n) {\n    for (Node c = n.getFirstChild(); c != null; c = c.getNext()) {\n      if (c.getType() == Token.BLOCK) {\n        Node result = getFirstNonEmptyChild(c);\n        if (result != null) {\n          return result;\n        }\n      } else if (c.getType() != Token.EMPTY) {\n        return c;\n      }\n    }\n    return null;\n  }",
    "comment": "Gets the first non-empty child of the given node. */",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "CodeGenerator.getNonEmptyChildCount",
    "class_name": "com.google.javascript.jscomp.CodeGenerator",
    "signature": "com.google.javascript.jscomp.CodeGenerator.getNonEmptyChildCount(Node,int)",
    "snippet": "  private static int getNonEmptyChildCount(Node n, int maxCount) {\n    int i = 0;\n    Node c = n.getFirstChild();\n    for (; c != null && i < maxCount; c = c.getNext()) {\n      if (c.getType() == Token.BLOCK) {\n        i += getNonEmptyChildCount(c, maxCount-i);\n      } else if (c.getType() != Token.EMPTY) {\n        i++;\n      }\n    }\n    return i;\n  }",
    "comment": " @param maxCount The maximum number of children to look for. @return The number of children of this node that are non empty up to maxCount. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "CodeGenerator.identifierEscape",
    "class_name": "com.google.javascript.jscomp.CodeGenerator",
    "signature": "com.google.javascript.jscomp.CodeGenerator.identifierEscape(String)",
    "snippet": "  static String identifierEscape(String s) {\n    // First check if escaping is needed at all -- in most cases it isn't.\n    if (NodeUtil.isLatin(s)) {\n      return s;\n    }\n\n    // Now going through the string to escape non-latin characters if needed.\n    StringBuilder sb = new StringBuilder();\n    for (int i = 0; i < s.length(); i++) {\n      char c = s.charAt(i);\n      // Identifiers should always go to Latin1/ ASCII characters because\n      // different browser's rules for valid identifier characters are\n      // crazy.\n      if (c > 0x1F && c < 0x7F) {\n        sb.append(c);\n      } else {\n        appendHexJavaScriptRepresentation(sb, c);\n      }\n    }\n    return sb.toString();\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "CodeGenerator.isOneExactlyFunctionOrDo",
    "class_name": "com.google.javascript.jscomp.CodeGenerator",
    "signature": "com.google.javascript.jscomp.CodeGenerator.isOneExactlyFunctionOrDo(Node)",
    "snippet": "  private boolean isOneExactlyFunctionOrDo(Node n) {\n    if (n.getType() == Token.LABEL) {\n      Node labeledStatement = n.getLastChild();\n      if (labeledStatement.getType() != Token.BLOCK) {\n        return isOneExactlyFunctionOrDo(labeledStatement);\n      } else {\n        // For labels with block children, we need to ensure that a\n        // labeled FUNCTION or DO isn't generated when extraneous BLOCKs\n        // are skipped.\n        if (getNonEmptyChildCount(n, 2) == 1) {\n          return isOneExactlyFunctionOrDo(getFirstNonEmptyChild(n));\n        } else {\n          // Either a empty statement or an block with more than one child,\n          // way it isn't a FUNCTION or DO.\n          return false;\n        }\n      }\n    } else {\n      return (n.getType() == Token.FUNCTION || n.getType() == Token.DO);\n    }\n  }",
    "comment": " @return Whether the Node is a DO or FUNCTION (with or without labels). ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "CodePrinter.toSource",
    "class_name": "com.google.javascript.jscomp.CodePrinter",
    "signature": "com.google.javascript.jscomp.CodePrinter.toSource(Node,Format,boolean,int,SourceMap,DetailLevel,Charset,boolean)",
    "snippet": "  private static String toSource(Node root, Format outputFormat,\n                                 boolean lineBreak,  int lineLengthThreshold,\n                                 SourceMap sourceMap,\n                                 SourceMap.DetailLevel sourceMapDetailLevel,\n                                 Charset outputCharset,\n                                 boolean tagAsStrict) {\n    Preconditions.checkState(sourceMapDetailLevel != null);\n\n    boolean createSourceMap = (sourceMap != null);\n    MappedCodePrinter mcp =\n        outputFormat == Format.COMPACT\n        ? new CompactCodePrinter(\n            lineBreak, lineLengthThreshold,\n            createSourceMap, sourceMapDetailLevel)\n        : new PrettyCodePrinter(\n            lineLengthThreshold, createSourceMap, sourceMapDetailLevel);\n    CodeGenerator cg =\n        outputFormat == Format.TYPED\n        ? new TypedCodeGenerator(mcp, outputCharset)\n        : new CodeGenerator(mcp, outputCharset);\n\n    if (tagAsStrict) {\n      cg.tagAsStrict();\n    }\n\n    cg.add(root);\n    mcp.endFile();\n\n    String code = mcp.getCode();\n\n    if (createSourceMap) {\n      mcp.generateSourceMap(sourceMap);\n    }\n\n    return code;\n  }",
    "comment": " Converts a tree to js code ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "Builder.build",
    "class_name": "com.google.javascript.jscomp.CodePrinter$Builder",
    "signature": "com.google.javascript.jscomp.CodePrinter$Builder.build()",
    "snippet": "    String build() {\n      if (root == null) {\n        throw new IllegalStateException(\n            \"Cannot build without root node being specified\");\n      }\n\n      Format outputFormat = outputTypes\n          ? Format.TYPED\n          : prettyPrint\n              ? Format.PRETTY\n              : Format.COMPACT;\n\n      return toSource(root, outputFormat, lineBreak, lineLengthThreshold,\n          sourceMap, sourceMapDetailLevel, outputCharset, tagAsStrict);\n    }",
    "comment": " Generates the source code and returns it. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "Builder.setLineBreak",
    "class_name": "com.google.javascript.jscomp.CodePrinter$Builder",
    "signature": "com.google.javascript.jscomp.CodePrinter$Builder.setLineBreak(boolean)",
    "snippet": "    Builder setLineBreak(boolean lineBreak) {\n      this.lineBreak = lineBreak;\n      return this;\n    }",
    "comment": " Sets whether line breaking should be done automatically. @param lineBreak If true, line breaking is done automatically. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "Builder.setLineLengthThreshold",
    "class_name": "com.google.javascript.jscomp.CodePrinter$Builder",
    "signature": "com.google.javascript.jscomp.CodePrinter$Builder.setLineLengthThreshold(int)",
    "snippet": "    Builder setLineLengthThreshold(int threshold) {\n      this.lineLengthThreshold = threshold;\n      return this;\n    }",
    "comment": " Sets the line length threshold that will be used to determine when to break lines, if line breaking is on.  @param threshold The line length threshold. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "Builder.setOutputCharset",
    "class_name": "com.google.javascript.jscomp.CodePrinter$Builder",
    "signature": "com.google.javascript.jscomp.CodePrinter$Builder.setOutputCharset(Charset)",
    "snippet": "    Builder setOutputCharset(Charset outCharset) {\n      this.outputCharset = outCharset;\n      return this;\n    }",
    "comment": " Set the charset to use when determining what characters need to be escaped in the output. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "Builder.setPrettyPrint",
    "class_name": "com.google.javascript.jscomp.CodePrinter$Builder",
    "signature": "com.google.javascript.jscomp.CodePrinter$Builder.setPrettyPrint(boolean)",
    "snippet": "    Builder setPrettyPrint(boolean prettyPrint) {\n      this.prettyPrint = prettyPrint;\n      return this;\n    }",
    "comment": " Sets whether pretty printing should be used. @param prettyPrint If true, pretty printing will be used. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "Builder.setSourceMap",
    "class_name": "com.google.javascript.jscomp.CodePrinter$Builder",
    "signature": "com.google.javascript.jscomp.CodePrinter$Builder.setSourceMap(SourceMap)",
    "snippet": "    Builder setSourceMap(SourceMap sourceMap) {\n      this.sourceMap = sourceMap;\n      return this;\n    }",
    "comment": " Sets the source map to which to write the metadata about the generated source code.  @param sourceMap The source map. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "Builder.setSourceMapDetailLevel",
    "class_name": "com.google.javascript.jscomp.CodePrinter$Builder",
    "signature": "com.google.javascript.jscomp.CodePrinter$Builder.setSourceMapDetailLevel(DetailLevel)",
    "snippet": "    Builder setSourceMapDetailLevel(SourceMap.DetailLevel level) {\n      Preconditions.checkState(level != null);\n      this.sourceMapDetailLevel = level;\n      return this;\n    }",
    "comment": " @param level The detail level to use. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "Builder.setTagAsStrict",
    "class_name": "com.google.javascript.jscomp.CodePrinter$Builder",
    "signature": "com.google.javascript.jscomp.CodePrinter$Builder.setTagAsStrict(boolean)",
    "snippet": "    Builder setTagAsStrict(boolean tagAsStrict) {\n      this.tagAsStrict = tagAsStrict;\n      return this;\n    }",
    "comment": " Set whether the output should be tags as ECMASCRIPT 5 Strict. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "CompactCodePrinter.append",
    "class_name": "com.google.javascript.jscomp.CodePrinter$CompactCodePrinter",
    "signature": "com.google.javascript.jscomp.CodePrinter$CompactCodePrinter.append(String)",
    "snippet": "    @Override\n    void append(String str) {\n      code.append(str);\n      lineLength += str.length();\n    }",
    "comment": " Appends a string to the code, keeping track of the current line length. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "CompactCodePrinter.notePreferredLineBreak",
    "class_name": "com.google.javascript.jscomp.CodePrinter$CompactCodePrinter",
    "signature": "com.google.javascript.jscomp.CodePrinter$CompactCodePrinter.notePreferredLineBreak()",
    "snippet": "    @Override\n    void notePreferredLineBreak() {\n      preferredBreakPosition = code.length();\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "MappedCodePrinter.endSourceMapping",
    "class_name": "com.google.javascript.jscomp.CodePrinter$MappedCodePrinter",
    "signature": "com.google.javascript.jscomp.CodePrinter$MappedCodePrinter.endSourceMapping(Node)",
    "snippet": "    @Override\n    void endSourceMapping(Node node) {\n      if (createSrcMap && !mappings.isEmpty() && mappings.peek().node == node) {\n        Mapping mapping = mappings.pop();\n        int line = getCurrentLineIndex();\n        int index = getCurrentCharIndex();\n        Preconditions.checkState(line >= 0);\n        mapping.end = new FilePosition(line, index);\n      }\n    }",
    "comment": " Finishes the source mapping for the given node at the current position. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "MappedCodePrinter.getCode",
    "class_name": "com.google.javascript.jscomp.CodePrinter$MappedCodePrinter",
    "signature": "com.google.javascript.jscomp.CodePrinter$MappedCodePrinter.getCode()",
    "snippet": "    public String getCode() {\n      return code.toString();\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "MappedCodePrinter.getLastChar",
    "class_name": "com.google.javascript.jscomp.CodePrinter$MappedCodePrinter",
    "signature": "com.google.javascript.jscomp.CodePrinter$MappedCodePrinter.getLastChar()",
    "snippet": "    @Override\n    char getLastChar() {\n      return (code.length() > 0) ? code.charAt(code.length() - 1) : '\\0';\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "MappedCodePrinter.startSourceMapping",
    "class_name": "com.google.javascript.jscomp.CodePrinter$MappedCodePrinter",
    "signature": "com.google.javascript.jscomp.CodePrinter$MappedCodePrinter.startSourceMapping(Node)",
    "snippet": "    @Override\n    void startSourceMapping(Node node) {\n      Preconditions.checkState(sourceMapDetailLevel != null);\n      Preconditions.checkState(node != null);\n      if (createSrcMap\n          && node.getProp(Node.SOURCENAME_PROP) != null\n          && node.getLineno() > 0\n          && sourceMapDetailLevel.apply(node)) {\n        int line = getCurrentLineIndex();\n        int index = getCurrentCharIndex();\n        Preconditions.checkState(line >= 0);\n        Mapping mapping = new Mapping();\n        mapping.node = node;\n        mapping.start = new FilePosition(line, index);\n        mappings.push(mapping);\n        allMappings.add(mapping);\n      }\n    }",
    "comment": " Starts the source mapping for the given node at the current position. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "Compiler.Compiler",
    "class_name": "com.google.javascript.jscomp.Compiler",
    "signature": "com.google.javascript.jscomp.Compiler.Compiler()",
    "snippet": "  public Compiler() {\n    this((PrintStream) null);\n  }",
    "comment": " Creates a Compiler that reports errors and warnings to its logger. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "Compiler.Compiler",
    "class_name": "com.google.javascript.jscomp.Compiler",
    "signature": "com.google.javascript.jscomp.Compiler.Compiler(PrintStream)",
    "snippet": "  public Compiler(PrintStream stream) {\n    addChangeHandler(recentChange);\n    outStream = stream;\n  }",
    "comment": " Creates n Compiler that reports errors and warnings to an output stream. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "Compiler.acceptConstKeyword",
    "class_name": "com.google.javascript.jscomp.Compiler",
    "signature": "com.google.javascript.jscomp.Compiler.acceptConstKeyword()",
    "snippet": "  @Override\n  public boolean acceptConstKeyword() {\n    return options.acceptConstKeyword;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "Compiler.addChangeHandler",
    "class_name": "com.google.javascript.jscomp.Compiler",
    "signature": "com.google.javascript.jscomp.Compiler.addChangeHandler(CodeChangeHandler)",
    "snippet": "  @Override\n  void addChangeHandler(CodeChangeHandler handler) {\n    codeChangeHandlers.add(handler);\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "Compiler.addToDebugLog",
    "class_name": "com.google.javascript.jscomp.Compiler",
    "signature": "com.google.javascript.jscomp.Compiler.addToDebugLog(String)",
    "snippet": "  @Override\n  void addToDebugLog(String str) {\n    debugLog.append(str);\n    debugLog.append('\\n');\n    logger.fine(str);\n  }",
    "comment": "Called from the compiler passes, adds debug info */",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "Compiler.checkFirstModule",
    "class_name": "com.google.javascript.jscomp.Compiler",
    "signature": "com.google.javascript.jscomp.Compiler.checkFirstModule(List)",
    "snippet": "  private void checkFirstModule(List<JSModule> modules) {\n    if (modules.isEmpty()) {\n      report(JSError.make(EMPTY_MODULE_LIST_ERROR));\n    } else if (modules.get(0).getInputs().isEmpty() && modules.size() > 1) {\n      // The root module may only be empty if there is exactly 1 module.\n      report(JSError.make(EMPTY_ROOT_MODULE_ERROR,\n          modules.get(0).getName()));\n    }\n  }",
    "comment": " Verifies that at least one module has been provided and that the first one has at least one source code input. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "Compiler.createMessageFormatter",
    "class_name": "com.google.javascript.jscomp.Compiler",
    "signature": "com.google.javascript.jscomp.Compiler.createMessageFormatter()",
    "snippet": "  private MessageFormatter createMessageFormatter() {\n    boolean colorize = options.shouldColorizeErrorOutput();\n    return options.errorFormat.toFormatter(this, colorize);\n  }",
    "comment": " Creates a message formatter instance corresponding to the value of {@link CompilerOptions}. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "Compiler.fillEmptyModules",
    "class_name": "com.google.javascript.jscomp.Compiler",
    "signature": "com.google.javascript.jscomp.Compiler.fillEmptyModules(List)",
    "snippet": "  private static void fillEmptyModules(List<JSModule> modules) {\n    for (JSModule module : modules) {\n      if (module.getInputs().isEmpty()) {\n        module.add(JSSourceFile.fromCode(\"[\" + module.getName() + \"]\", \"\"));\n      }\n    }\n  }",
    "comment": " Fill any empty modules with a place holder file. It makes any cross module motion easier. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "Compiler.getAllInputsFromModules",
    "class_name": "com.google.javascript.jscomp.Compiler",
    "signature": "com.google.javascript.jscomp.Compiler.getAllInputsFromModules(List)",
    "snippet": "  private static List<CompilerInput> getAllInputsFromModules(\n      List<JSModule> modules) {\n    List<CompilerInput> inputs = Lists.newArrayList();\n    Map<String, JSModule> inputMap = Maps.newHashMap();\n    for (JSModule module : modules) {\n      for (CompilerInput input : module.getInputs()) {\n        String inputName = input.getName();\n\n        // NOTE(nicksantos): If an input is in more than one module,\n        // it will show up twice in the inputs list, and then we\n        // will get an error down the line.\n        inputs.add(input);\n        inputMap.put(inputName, module);\n      }\n    }\n    return inputs;\n  }",
    "comment": " Builds a single list of all module inputs. Verifies that it contains no duplicates. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "Compiler.getCodingConvention",
    "class_name": "com.google.javascript.jscomp.Compiler",
    "signature": "com.google.javascript.jscomp.Compiler.getCodingConvention()",
    "snippet": "  @Override\n  public CodingConvention getCodingConvention() {\n    CodingConvention convention = options.getCodingConvention();\n    convention = convention != null ? convention : defaultCodingConvention;\n    return convention;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "Compiler.getDefaultErrorReporter",
    "class_name": "com.google.javascript.jscomp.Compiler",
    "signature": "com.google.javascript.jscomp.Compiler.getDefaultErrorReporter()",
    "snippet": "  @Override\n  ErrorReporter getDefaultErrorReporter() {\n    return defaultErrorReporter;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "Compiler.getDiagnosticGroups",
    "class_name": "com.google.javascript.jscomp.Compiler",
    "signature": "com.google.javascript.jscomp.Compiler.getDiagnosticGroups()",
    "snippet": "  protected DiagnosticGroups getDiagnosticGroups() {\n    return new DiagnosticGroups();\n  }",
    "comment": " The warning classes that are available from the command-line, and are suppressable by the {@code @suppress} annotation. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "Compiler.getErrorCount",
    "class_name": "com.google.javascript.jscomp.Compiler",
    "signature": "com.google.javascript.jscomp.Compiler.getErrorCount()",
    "snippet": "  public int getErrorCount() {\n    return errorManager.getErrorCount();\n  }",
    "comment": " Gets the number of errors. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "Compiler.getErrors",
    "class_name": "com.google.javascript.jscomp.Compiler",
    "signature": "com.google.javascript.jscomp.Compiler.getErrors()",
    "snippet": "  public JSError[] getErrors() {\n    return errorManager.getErrors();\n  }",
    "comment": " Returns the array of errors (never null). ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "Compiler.getInput",
    "class_name": "com.google.javascript.jscomp.Compiler",
    "signature": "com.google.javascript.jscomp.Compiler.getInput(String)",
    "snippet": "  @Override\n  public CompilerInput getInput(String name) {\n    return inputsByName.get(name);\n  }",
    "comment": "interface, and which ones should always be injected.",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "Compiler.getModuleGraph",
    "class_name": "com.google.javascript.jscomp.Compiler",
    "signature": "com.google.javascript.jscomp.Compiler.getModuleGraph()",
    "snippet": "  @Override\n  JSModuleGraph getModuleGraph() {\n    return moduleGraph;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "Compiler.getParserConfig",
    "class_name": "com.google.javascript.jscomp.Compiler",
    "signature": "com.google.javascript.jscomp.Compiler.getParserConfig()",
    "snippet": "  @Override\n  Config getParserConfig() {\n    if (parserConfig == null) {\n      Config.LanguageMode mode;\n      switch (options.getLanguageIn()) {\n        case ECMASCRIPT3:\n          mode = Config.LanguageMode.ECMASCRIPT3;\n          break;\n        case ECMASCRIPT5:\n          mode = Config.LanguageMode.ECMASCRIPT5;\n          break;\n        case ECMASCRIPT5_STRICT:\n          mode = Config.LanguageMode.ECMASCRIPT5_STRICT;\n          break;\n        default:\n          throw new IllegalStateException(\"unexpected language mode\");\n      }\n\n      parserConfig = ParserRunner.createConfig(\n        isIdeMode(),\n        mode,\n        acceptConstKeyword());\n    }\n    return parserConfig;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "Compiler.getTypeRegistry",
    "class_name": "com.google.javascript.jscomp.Compiler",
    "signature": "com.google.javascript.jscomp.Compiler.getTypeRegistry()",
    "snippet": "  @Override\n  public JSTypeRegistry getTypeRegistry() {\n    if (typeRegistry == null) {\n      typeRegistry = new JSTypeRegistry(oldErrorReporter, options.looseTypes);\n    }\n    return typeRegistry;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "Compiler.getUniqueNameIdSupplier",
    "class_name": "com.google.javascript.jscomp.Compiler",
    "signature": "com.google.javascript.jscomp.Compiler.getUniqueNameIdSupplier()",
    "snippet": "  @Override\n  Supplier<String> getUniqueNameIdSupplier() {\n    final Compiler self = this;\n    return new Supplier<String>() {\n      public String get() {\n        return String.valueOf(self.nextUniqueNameId());\n      }\n    };\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "Compiler.getWarnings",
    "class_name": "com.google.javascript.jscomp.Compiler",
    "signature": "com.google.javascript.jscomp.Compiler.getWarnings()",
    "snippet": "  public JSError[] getWarnings() {\n    return errorManager.getWarnings();\n  }",
    "comment": " Returns the array of warnings (never null). ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "Compiler.hasErrors",
    "class_name": "com.google.javascript.jscomp.Compiler",
    "signature": "com.google.javascript.jscomp.Compiler.hasErrors()",
    "snippet": "  public boolean hasErrors() {\n    return hasHaltingErrors();\n  }",
    "comment": " Consults the {@link ErrorManager} to see if we've encountered errors that should halt compilation. <p>  If {@link CompilerOptions#ideMode} is {@code true}, this function always returns {@code false} without consulting the error manager. The error manager will continue to be told about new errors and warnings, but the compiler will complete compilation of all inputs.<p> ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "Compiler.hasHaltingErrors",
    "class_name": "com.google.javascript.jscomp.Compiler",
    "signature": "com.google.javascript.jscomp.Compiler.hasHaltingErrors()",
    "snippet": "  @Override\n  boolean hasHaltingErrors() {\n    return !isIdeMode() && getErrorCount() > 0;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "Compiler.init",
    "class_name": "com.google.javascript.jscomp.Compiler",
    "signature": "com.google.javascript.jscomp.Compiler.init(JSSourceFile[],JSSourceFile[],CompilerOptions)",
    "snippet": "  public void init(JSSourceFile[] externs, JSSourceFile[] inputs,\n      CompilerOptions options) {\n    init(Lists.<JSSourceFile>newArrayList(externs),\n        Lists.<JSSourceFile>newArrayList(inputs), options);\n  }",
    "comment": " Initializes the instance state needed for a compile job. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "Compiler.init",
    "class_name": "com.google.javascript.jscomp.Compiler",
    "signature": "com.google.javascript.jscomp.Compiler.init(List,List,CompilerOptions)",
    "snippet": "  public void init(List<JSSourceFile> externs, List<JSSourceFile> inputs,\n      CompilerOptions options) {\n    JSModule module = new JSModule(\"[singleton]\");\n    for (JSSourceFile input : inputs) {\n      module.add(input);\n    }\n\n    initModules(externs, Lists.newArrayList(module), options);\n  }",
    "comment": " Initializes the instance state needed for a compile job. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "Compiler.initBasedOnOptions",
    "class_name": "com.google.javascript.jscomp.Compiler",
    "signature": "com.google.javascript.jscomp.Compiler.initBasedOnOptions()",
    "snippet": "  private void initBasedOnOptions() {\n    // Create the source map if necessary.\n    if (options.sourceMapOutputPath != null) {\n      sourceMap = options.sourceMapFormat.getInstance();\n    }\n  }",
    "comment": " Do any initialization that is dependent on the compiler options. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "Compiler.initCompilerOptionsIfTesting",
    "class_name": "com.google.javascript.jscomp.Compiler",
    "signature": "com.google.javascript.jscomp.Compiler.initCompilerOptionsIfTesting()",
    "snippet": "  void initCompilerOptionsIfTesting() {\n    if (options == null) {\n      // initialization for tests that don't initialize the compiler\n      // by the normal mechanisms.\n      initOptions(new CompilerOptions());\n    }\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "Compiler.initInputsByNameMap",
    "class_name": "com.google.javascript.jscomp.Compiler",
    "signature": "com.google.javascript.jscomp.Compiler.initInputsByNameMap()",
    "snippet": "  void initInputsByNameMap() {\n    inputsByName = new HashMap<String, CompilerInput>();\n    for (CompilerInput input : externs) {\n      String name = input.getName();\n      if (!inputsByName.containsKey(name)) {\n        inputsByName.put(name, input);\n      } else {\n        report(JSError.make(DUPLICATE_EXTERN_INPUT, name));\n      }\n    }\n    for (CompilerInput input : inputs) {\n      String name = input.getName();\n      if (!inputsByName.containsKey(name)) {\n        inputsByName.put(name, input);\n      } else {\n        report(JSError.make(DUPLICATE_INPUT, name));\n      }\n    }\n  }",
    "comment": " Creates a map to make looking up an input by name fast. Also checks for duplicate inputs. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "Compiler.initModules",
    "class_name": "com.google.javascript.jscomp.Compiler",
    "signature": "com.google.javascript.jscomp.Compiler.initModules(List,List,CompilerOptions)",
    "snippet": "  public void initModules(\n      List<JSSourceFile> externs, List<JSModule> modules,\n      CompilerOptions options) {\n    initOptions(options);\n\n    checkFirstModule(modules);\n    fillEmptyModules(modules);\n\n    this.externs = makeCompilerInput(externs, true);\n\n    // Generate the module graph, and report any errors in the module\n    // specification as errors.\n    this.modules = modules;\n    if (modules.size() > 1) {\n      try {\n        this.moduleGraph = new JSModuleGraph(modules);\n      } catch (JSModuleGraph.ModuleDependenceException e) {\n        // problems with the module format.  Report as an error.  The\n        // message gives all details.\n        report(JSError.make(MODULE_DEPENDENCY_ERROR,\n                e.getModule().getName(), e.getDependentModule().getName()));\n        return;\n      }\n    } else {\n      this.moduleGraph = null;\n    }\n\n    this.inputs = getAllInputsFromModules(modules);\n    initBasedOnOptions();\n\n    initInputsByNameMap();\n  }",
    "comment": " Initializes the instance state needed for a compile job if the sources are in modules. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "Compiler.initOptions",
    "class_name": "com.google.javascript.jscomp.Compiler",
    "signature": "com.google.javascript.jscomp.Compiler.initOptions(CompilerOptions)",
    "snippet": "  public void initOptions(CompilerOptions options) {\n    this.options = options;\n    this.options.initDeserializedProperties();\n    if (errorManager == null) {\n      if (outStream == null) {\n        setErrorManager(\n            new LoggerErrorManager(createMessageFormatter(), logger));\n      } else {\n        PrintStreamErrorManager printer =\n            new PrintStreamErrorManager(createMessageFormatter(), outStream);\n        printer.setSummaryDetailLevel(options.summaryDetailLevel);\n        setErrorManager(printer);\n      }\n    }\n\n    // DiagnosticGroups override the plain checkTypes option.\n    if (options.enables(DiagnosticGroups.CHECK_TYPES)) {\n      options.checkTypes = true;\n    } else if (options.disables(DiagnosticGroups.CHECK_TYPES)) {\n      options.checkTypes = false;\n    } else if (!options.checkTypes) {\n      // If DiagnosticGroups did not override the plain checkTypes\n      // option, and checkTypes is enabled, then turn off the\n      // parser type warnings.\n      options.setWarningLevel(\n          DiagnosticGroup.forType(\n              RhinoErrorReporter.TYPE_PARSE_ERROR),\n          CheckLevel.OFF);\n    }\n\n    if (options.checkGlobalThisLevel.isOn()) {\n      options.setWarningLevel(\n          DiagnosticGroups.GLOBAL_THIS,\n          options.checkGlobalThisLevel);\n    }\n\n    // Initialize the warnings guard.\n    List<WarningsGuard> guards = Lists.newArrayList();\n    guards.add(\n        new SuppressDocWarningsGuard(\n            getDiagnosticGroups().getRegisteredGroups()));\n    guards.add(options.getWarningsGuard());\n\n    // All passes must run the variable check. This synthesizes\n    // variables later so that the compiler doesn't crash. It also\n    // checks the externs file for validity. If you don't want to warn\n    // about missing variable declarations, we shut that specific\n    // error off.\n    if (!options.checkSymbols &&\n        (warningsGuard == null || !warningsGuard.disables(\n            DiagnosticGroups.CHECK_VARIABLES))) {\n      guards.add(new DiagnosticGroupWarningsGuard(\n          DiagnosticGroups.CHECK_VARIABLES, CheckLevel.OFF));\n    }\n\n    this.warningsGuard = new ComposeWarningsGuard(guards);\n  }",
    "comment": " Initialize the compiler options. Only necessary if you're not doing a normal compile() job. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "Compiler.isIdeMode",
    "class_name": "com.google.javascript.jscomp.Compiler",
    "signature": "com.google.javascript.jscomp.Compiler.isIdeMode()",
    "snippet": "  @Override\n  public boolean isIdeMode() {\n    return options.ideMode;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "Compiler.makeCompilerInput",
    "class_name": "com.google.javascript.jscomp.Compiler",
    "signature": "com.google.javascript.jscomp.Compiler.makeCompilerInput(List,boolean)",
    "snippet": "  private List<CompilerInput> makeCompilerInput(\n      List<JSSourceFile> files, boolean isExtern) {\n    List<CompilerInput> inputs = Lists.newArrayList();\n    for (JSSourceFile file : files) {\n      inputs.add(new CompilerInput(file, isExtern));\n    }\n    return inputs;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "Compiler.newTracer",
    "class_name": "com.google.javascript.jscomp.Compiler",
    "signature": "com.google.javascript.jscomp.Compiler.newTracer(String)",
    "snippet": "  Tracer newTracer(String passName) {\n    String comment = passName\n        + (recentChange.hasCodeChanged() ? \" on recently changed AST\" : \"\");\n    if (options.tracer.isOn()) {\n      tracker.recordPassStart(passName);\n    }\n    return new Tracer(\"Compiler\", comment);\n  }",
    "comment": " Returns a new tracer for the given pass name. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "Compiler.nextUniqueNameId",
    "class_name": "com.google.javascript.jscomp.Compiler",
    "signature": "com.google.javascript.jscomp.Compiler.nextUniqueNameId()",
    "snippet": "  private int nextUniqueNameId() {\n    return uniqueNameId++;\n  }",
    "comment": " Creates a new id for making unique names. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "Compiler.parseInputs",
    "class_name": "com.google.javascript.jscomp.Compiler",
    "signature": "com.google.javascript.jscomp.Compiler.parseInputs()",
    "snippet": "  Node parseInputs() {\n    boolean devMode = options.devMode != DevMode.OFF;\n\n    // If old roots exist (we are parsing a second time), detach each of the\n    // individual file parse trees.\n    if (externsRoot != null) {\n      externsRoot.detachChildren();\n    }\n    if (jsRoot != null) {\n      jsRoot.detachChildren();\n    }\n\n    // Parse main js sources.\n    jsRoot = new Node(Token.BLOCK);\n    jsRoot.setIsSyntheticBlock(true);\n\n    externsRoot = new Node(Token.BLOCK);\n    externsRoot.setIsSyntheticBlock(true);\n\n    externAndJsRoot = new Node(Token.BLOCK, externsRoot, jsRoot);\n    externAndJsRoot.setIsSyntheticBlock(true);\n\n    if (options.tracer.isOn()) {\n      tracker = new PerformanceTracker(jsRoot,\n          options.tracer == TracerMode.ALL);\n      addChangeHandler(tracker.getCodeChangeHandler());\n    }\n\n    Tracer tracer = newTracer(\"parseInputs\");\n\n    try {\n      // Parse externs sources.\n      for (CompilerInput input : externs) {\n        Node n = input.getAstRoot(this);\n        if (hasErrors()) {\n          return null;\n        }\n        externsRoot.addChildToBack(n);\n      }\n\n      // Check if the sources need to be re-ordered.\n      if (options.manageClosureDependencies) {\n        for (CompilerInput input : inputs) {\n          input.setCompiler(this);\n\n          // Forward-declare all the provided types, so that they\n          // are not flagged even if they are dropped from the process.\n          for (String provide : input.getProvides()) {\n            getTypeRegistry().forwardDeclareType(provide);\n          }\n        }\n\n        try {\n          inputs =\n              (moduleGraph == null ? new JSModuleGraph(modules) : moduleGraph)\n              .manageDependencies(\n                  options.manageClosureDependenciesEntryPoints, inputs);\n        } catch (CircularDependencyException e) {\n          report(JSError.make(\n              JSModule.CIRCULAR_DEPENDENCY_ERROR, e.getMessage()));\n          return null;\n        } catch (MissingProvideException e) {\n          report(JSError.make(\n              MISSING_ENTRY_ERROR, e.getMessage()));\n          return null;\n        }\n      }\n\n      // Check if inputs need to be rebuilt from modules.\n      boolean staleInputs = false;\n      for (CompilerInput input : inputs) {\n        Node n = input.getAstRoot(this);\n\n        // Inputs can have a null AST during initial parse.\n        if (n == null) {\n          continue;\n        }\n\n        if (n.getJSDocInfo() != null) {\n          JSDocInfo info = n.getJSDocInfo();\n          if (info.isExterns()) {\n            // If the input file is explicitly marked as an externs file, then\n            // assume the programmer made a mistake and throw it into\n            // the externs pile anyways.\n            externsRoot.addChildToBack(n);\n            input.setIsExtern(true);\n\n            input.getModule().remove(input);\n\n            externs.add(input);\n            staleInputs = true;\n          } else if (info.isNoCompile()) {\n            input.getModule().remove(input);\n            staleInputs = true;\n          }\n        }\n      }\n\n      if (staleInputs) {\n        fillEmptyModules(modules);\n        rebuildInputsFromModules();\n      }\n\n      // Build the AST.\n      for (CompilerInput input : inputs) {\n        Node n = input.getAstRoot(this);\n        if (n == null) {\n          continue;\n        }\n\n        if (devMode) {\n          runSanityCheck();\n          if (hasErrors()) {\n            return null;\n          }\n        }\n\n        if (options.sourceMapOutputPath != null ||\n            options.nameReferenceReportPath != null) {\n\n          // Annotate the nodes in the tree with information from the\n          // input file. This information is used to construct the SourceMap.\n          SourceInformationAnnotator sia =\n              new SourceInformationAnnotator(\n                  input.getName(), options.devMode != DevMode.OFF);\n          NodeTraversal.traverse(this, n, sia);\n        }\n\n        jsRoot.addChildToBack(n);\n      }\n\n      if (hasErrors()) {\n        return null;\n      }\n      return externAndJsRoot;\n    } finally {\n      stopTracer(tracer, \"parseInputs\");\n    }\n  }",
    "comment": " Parses the externs and main inputs.  @return A synthetic root node whose two children are the externs root and the main root ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "Compiler.prepareAst",
    "class_name": "com.google.javascript.jscomp.Compiler",
    "signature": "com.google.javascript.jscomp.Compiler.prepareAst(Node)",
    "snippet": "  @Override\n  void prepareAst(Node root) {\n    Tracer tracer = newTracer(\"prepareAst\");\n    CompilerPass pass = new PrepareAst(this);\n    pass.process(null, root);\n    stopTracer(tracer, \"prepareAst\");\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "Compiler.reportCodeChange",
    "class_name": "com.google.javascript.jscomp.Compiler",
    "signature": "com.google.javascript.jscomp.Compiler.reportCodeChange()",
    "snippet": "  @Override\n  public void reportCodeChange() {\n    for (CodeChangeHandler handler : codeChangeHandlers) {\n      handler.reportChange();\n    }\n  }",
    "comment": " All passes should call reportCodeChange() when they alter the JS tree structure. This is verified by CompilerTestCase. This allows us to optimize to a fixed point. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "Compiler.resetUniqueNameId",
    "class_name": "com.google.javascript.jscomp.Compiler",
    "signature": "com.google.javascript.jscomp.Compiler.resetUniqueNameId()",
    "snippet": "  @VisibleForTesting\n  void resetUniqueNameId() {\n    uniqueNameId = 0;\n  }",
    "comment": " Resets the unique name id counter ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "Compiler.setErrorManager",
    "class_name": "com.google.javascript.jscomp.Compiler",
    "signature": "com.google.javascript.jscomp.Compiler.setErrorManager(ErrorManager)",
    "snippet": "  public void setErrorManager(ErrorManager errorManager) {\n    Preconditions.checkNotNull(\n        errorManager, \"the error manager cannot be null\");\n    this.errorManager = errorManager;\n  }",
    "comment": " Sets the error manager.  @param errorManager the error manager, it cannot be {@code null} ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "Compiler.stopTracer",
    "class_name": "com.google.javascript.jscomp.Compiler",
    "signature": "com.google.javascript.jscomp.Compiler.stopTracer(Tracer,String)",
    "snippet": "  void stopTracer(Tracer t, String passName) {\n    long result = t.stop();\n    if (options.tracer.isOn()) {\n      tracker.recordPassStop(passName, result);\n    }\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "Compiler.toSource",
    "class_name": "com.google.javascript.jscomp.Compiler",
    "signature": "com.google.javascript.jscomp.Compiler.toSource(Node)",
    "snippet": "  @Override\n  String toSource(Node n) {\n    initCompilerOptionsIfTesting();\n    return toSource(n, null);\n  }",
    "comment": " Generates JavaScript source code for an AST, doesn't generate source map info. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "Compiler.toSource",
    "class_name": "com.google.javascript.jscomp.Compiler",
    "signature": "com.google.javascript.jscomp.Compiler.toSource(Node,SourceMap)",
    "snippet": "  private String toSource(Node n, SourceMap sourceMap) {\n    CodePrinter.Builder builder = new CodePrinter.Builder(n);\n    builder.setPrettyPrint(options.prettyPrint);\n    builder.setLineBreak(options.lineBreak);\n    builder.setSourceMap(sourceMap);\n    builder.setSourceMapDetailLevel(options.sourceMapDetailLevel);\n    builder.setTagAsStrict(\n        options.getLanguageOut() == LanguageMode.ECMASCRIPT5_STRICT);\n    builder.setLineLengthThreshold(options.lineLengthThreshold);\n\n    Charset charset = options.outputCharset != null ?\n        Charset.forName(options.outputCharset) : null;\n    builder.setOutputCharset(charset);\n\n    return builder.build();\n  }",
    "comment": " Generates JavaScript source code for an AST. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "CompilerInput.CompilerInput",
    "class_name": "com.google.javascript.jscomp.CompilerInput",
    "signature": "com.google.javascript.jscomp.CompilerInput.CompilerInput(JSSourceFile)",
    "snippet": "  public CompilerInput(JSSourceFile file) {\n    this(file, false);\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "CompilerInput.CompilerInput",
    "class_name": "com.google.javascript.jscomp.CompilerInput",
    "signature": "com.google.javascript.jscomp.CompilerInput.CompilerInput(JSSourceFile,boolean)",
    "snippet": "  public CompilerInput(JSSourceFile file, boolean isExtern) {\n    this.ast = new JsAst(file);\n    this.name = file.getName();\n    this.isExtern = isExtern;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "CompilerInput.getAstRoot",
    "class_name": "com.google.javascript.jscomp.CompilerInput",
    "signature": "com.google.javascript.jscomp.CompilerInput.getAstRoot(AbstractCompiler)",
    "snippet": "  @Override\n  public Node getAstRoot(AbstractCompiler compiler) {\n    return ast.getAstRoot(compiler);\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "CompilerInput.getModule",
    "class_name": "com.google.javascript.jscomp.CompilerInput",
    "signature": "com.google.javascript.jscomp.CompilerInput.getModule()",
    "snippet": "  public JSModule getModule() {\n    return module;\n  }",
    "comment": "Returns the module to which the input belongs. */",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "CompilerInput.getName",
    "class_name": "com.google.javascript.jscomp.CompilerInput",
    "signature": "com.google.javascript.jscomp.CompilerInput.getName()",
    "snippet": "  @Override\n  public String getName() {\n    return name;\n  }",
    "comment": "Returns a name for this input. Must be unique across all inputs. */",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "CompilerInput.setModule",
    "class_name": "com.google.javascript.jscomp.CompilerInput",
    "signature": "com.google.javascript.jscomp.CompilerInput.setModule(JSModule)",
    "snippet": "  public void setModule(JSModule module) {\n    // An input may only belong to one module.\n    Preconditions.checkArgument(\n        module == null || this.module == null || this.module == module);\n    this.module = module;\n  }",
    "comment": "Sets the module to which the input belongs. */",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "CompilerOptions.CompilerOptions",
    "class_name": "com.google.javascript.jscomp.CompilerOptions",
    "signature": "com.google.javascript.jscomp.CompilerOptions.CompilerOptions()",
    "snippet": "  public CompilerOptions() {\n    // Accepted language\n    languageIn = LanguageMode.ECMASCRIPT3;\n\n    // Language variation\n    acceptConstKeyword = false;\n\n    // Checks\n    skipAllPasses = false;\n    nameAnonymousFunctionsOnly = false;\n    devMode = DevMode.OFF;\n    checkSymbols = false;\n    checkShadowVars = CheckLevel.OFF;\n    aggressiveVarCheck = CheckLevel.OFF;\n    checkFunctions = CheckLevel.OFF;\n    checkMethods = CheckLevel.OFF;\n    checkDuplicateMessages = false;\n    allowLegacyJsMessages = false;\n    strictMessageReplacement = false;\n    checkSuspiciousCode = false;\n    checkControlStructures = false;\n    checkUndefinedProperties = CheckLevel.OFF;\n    checkUnusedPropertiesEarly = false;\n    checkTypes = false;\n    tightenTypes = false;\n    inferTypesInGlobalScope = false;\n    checkTypedPropertyCalls = false;\n    reportMissingOverride = CheckLevel.OFF;\n    reportUnknownTypes = CheckLevel.OFF;\n    checkRequires = CheckLevel.OFF;\n    checkProvides = CheckLevel.OFF;\n    checkGlobalNamesLevel = CheckLevel.OFF;\n    brokenClosureRequiresLevel = CheckLevel.ERROR;\n    checkGlobalThisLevel = CheckLevel.OFF;\n    checkUnreachableCode = CheckLevel.OFF;\n    checkMissingReturn = CheckLevel.OFF;\n    checkMissingGetCssNameLevel = CheckLevel.OFF;\n    checkMissingGetCssNameBlacklist = null;\n    checkEs5Strict = false;\n    checkCaja = false;\n    computeFunctionSideEffects = false;\n    chainCalls = false;\n\n    // Optimizations\n    foldConstants = false;\n    coalesceVariableNames = false;\n    deadAssignmentElimination = false;\n    inlineConstantVars = false;\n    inlineFunctions = false;\n    inlineLocalFunctions = false;\n    crossModuleCodeMotion = false;\n    crossModuleMethodMotion = false;\n    inlineGetters = false;\n    inlineVariables = false;\n    inlineLocalVariables = false;\n    smartNameRemoval = false;\n    removeDeadCode = false;\n    extractPrototypeMemberDeclarations = false;\n    removeUnusedPrototypeProperties = false;\n    removeUnusedPrototypePropertiesInExterns = false;\n    removeUnusedVars = false;\n    removeUnusedLocalVars = false;\n    aliasExternals = false;\n    collapseVariableDeclarations = false;\n    groupVariableDeclarations = false;\n    collapseAnonymousFunctions = false;\n    aliasableStrings = Collections.emptySet();\n    aliasStringsBlacklist = \"\";\n    aliasAllStrings = false;\n    outputJsStringUsage = false;\n    convertToDottedProperties = false;\n    rewriteFunctionExpressions = false;\n    optimizeParameters = false;\n    optimizeReturns = false;\n\n    // Renaming\n    variableRenaming = VariableRenamingPolicy.OFF;\n    propertyRenaming = PropertyRenamingPolicy.OFF;\n    propertyAffinity = false;\n    labelRenaming = false;\n    generatePseudoNames = false;\n    shadowVariables = false;\n    renamePrefix = null;\n    aliasKeywords = false;\n    collapseProperties = false;\n    collapsePropertiesOnExternTypes = false;\n    devirtualizePrototypeMethods = false;\n    disambiguateProperties = false;\n    ambiguateProperties = false;\n    anonymousFunctionNaming = AnonymousFunctionNamingPolicy.OFF;\n    exportTestFunctions = false;\n\n    // Alterations\n    runtimeTypeCheck = false;\n    runtimeTypeCheckLogFunction = null;\n    instrumentForCoverage = false;\n    instrumentForCoverageOnly = false;\n    ignoreCajaProperties = false;\n    syntheticBlockStartMarker = null;\n    syntheticBlockEndMarker = null;\n    locale = null;\n    markAsCompiled = false;\n    removeTryCatchFinally = false;\n    closurePass = false;\n    rewriteNewDateGoogNow = true;\n    removeAbstractMethods = true;\n    removeClosureAsserts = false;\n    stripTypes = Collections.emptySet();\n    stripNameSuffixes = Collections.emptySet();\n    stripNamePrefixes = Collections.emptySet();\n    stripTypePrefixes = Collections.emptySet();\n    customPasses = null;\n    markNoSideEffectCalls = false;\n    defineReplacements = Maps.newHashMap();\n    tweakProcessing = TweakProcessing.OFF;\n    tweakReplacements = Maps.newHashMap();\n    moveFunctionDeclarations = false;\n    instrumentationTemplate = null;\n    appNameStr = \"\";\n    recordFunctionInformation = false;\n    generateExports = false;\n    cssRenamingMap = null;\n    processObjectPropertyString = false;\n    idGenerators = Collections.emptySet();\n    replaceStringsFunctionDescriptions = Collections.emptyList();\n    replaceStringsPlaceholderToken = \"\";\n    replaceStringsReservedStrings = Collections.emptySet();\n\n    // Output\n    printInputDelimiter = false;\n    prettyPrint = false;\n    lineBreak = false;\n    reportPath = null;\n    tracer = TracerMode.OFF;\n    colorizeErrorOutput = false;\n    errorFormat = ErrorFormat.SINGLELINE;\n    debugFunctionSideEffectsPath = null;\n    jsOutputFile = \"\";\n    externExports = false;\n    nameReferenceReportPath = null;\n    nameReferenceGraphPath = null;\n\n    // Debugging\n    aliasHandler = NULL_ALIAS_TRANSFORMATION_HANDLER;\n\n    operaCompoundAssignFix = true;\n  }",
    "comment": " Initializes compiler options. All options are disabled by default.  Command-line frontends to the compiler should set these properties like a builder. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "CompilerOptions.addWarningsGuard",
    "class_name": "com.google.javascript.jscomp.CompilerOptions",
    "signature": "com.google.javascript.jscomp.CompilerOptions.addWarningsGuard(WarningsGuard)",
    "snippet": "  public void addWarningsGuard(WarningsGuard guard) {\n    warningsGuard.addGuard(guard);\n  }",
    "comment": " Add a guard to the set of warnings guards. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "CompilerOptions.enables",
    "class_name": "com.google.javascript.jscomp.CompilerOptions",
    "signature": "com.google.javascript.jscomp.CompilerOptions.enables(DiagnosticGroup)",
    "snippet": "  boolean enables(DiagnosticGroup type) {\n    return warningsGuard.enables(type);\n  }",
    "comment": " Whether the warnings guard in this Options object enables the given group of warnings. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "CompilerOptions.getCodingConvention",
    "class_name": "com.google.javascript.jscomp.CompilerOptions",
    "signature": "com.google.javascript.jscomp.CompilerOptions.getCodingConvention()",
    "snippet": "  public CodingConvention getCodingConvention() {\n    return codingConvention;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "CompilerOptions.getLanguageIn",
    "class_name": "com.google.javascript.jscomp.CompilerOptions",
    "signature": "com.google.javascript.jscomp.CompilerOptions.getLanguageIn()",
    "snippet": "  public LanguageMode getLanguageIn() {\n    return languageIn;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "CompilerOptions.getLanguageOut",
    "class_name": "com.google.javascript.jscomp.CompilerOptions",
    "signature": "com.google.javascript.jscomp.CompilerOptions.getLanguageOut()",
    "snippet": "  public LanguageMode getLanguageOut() {\n    return languageOut;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "CompilerOptions.getWarningsGuard",
    "class_name": "com.google.javascript.jscomp.CompilerOptions",
    "signature": "com.google.javascript.jscomp.CompilerOptions.getWarningsGuard()",
    "snippet": "  WarningsGuard getWarningsGuard() {\n    return warningsGuard;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "CompilerOptions.initDeserializedProperties",
    "class_name": "com.google.javascript.jscomp.CompilerOptions",
    "signature": "com.google.javascript.jscomp.CompilerOptions.initDeserializedProperties()",
    "snippet": "  void initDeserializedProperties() {\n    // If this object was initialized by deserialization, initialize\n    // transient fields now. This is a temporary hack.\n    if (warningsGuard == null) {\n      warningsGuard = new ComposeWarningsGuard();\n    }\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "CompilerOptions.setCodingConvention",
    "class_name": "com.google.javascript.jscomp.CompilerOptions",
    "signature": "com.google.javascript.jscomp.CompilerOptions.setCodingConvention(CodingConvention)",
    "snippet": "  public void setCodingConvention(CodingConvention codingConvention) {\n    this.codingConvention = codingConvention;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "CompilerOptions.setLanguageIn",
    "class_name": "com.google.javascript.jscomp.CompilerOptions",
    "signature": "com.google.javascript.jscomp.CompilerOptions.setLanguageIn(LanguageMode)",
    "snippet": "  public void setLanguageIn(LanguageMode languageIn) {\n    this.languageIn = languageIn;\n    this.languageOut = languageIn;\n  }",
    "comment": " Sets how goog.tweak calls are processed. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "CompilerOptions.setWarningLevel",
    "class_name": "com.google.javascript.jscomp.CompilerOptions",
    "signature": "com.google.javascript.jscomp.CompilerOptions.setWarningLevel(DiagnosticGroup,CheckLevel)",
    "snippet": "  public void setWarningLevel(DiagnosticGroup type, CheckLevel level) {\n    addWarningsGuard(new DiagnosticGroupWarningsGuard(type, level));\n  }",
    "comment": " Configure the given type of warning to the given level. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "CompilerOptions.shouldColorizeErrorOutput",
    "class_name": "com.google.javascript.jscomp.CompilerOptions",
    "signature": "com.google.javascript.jscomp.CompilerOptions.shouldColorizeErrorOutput()",
    "snippet": "  public boolean shouldColorizeErrorOutput() {\n    return colorizeErrorOutput;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "TracerMode.isOn",
    "class_name": "com.google.javascript.jscomp.CompilerOptions$TracerMode",
    "signature": "com.google.javascript.jscomp.CompilerOptions$TracerMode.isOn()",
    "snippet": "    boolean isOn() {\n      return this != OFF;\n    }",
    "comment": "Collect no timing and size metrics.",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "ComposeWarningsGuard.ComposeWarningsGuard",
    "class_name": "com.google.javascript.jscomp.ComposeWarningsGuard",
    "signature": "com.google.javascript.jscomp.ComposeWarningsGuard.ComposeWarningsGuard(List)",
    "snippet": "  public ComposeWarningsGuard(List<WarningsGuard> guards) {\n    addGuards(guards);\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "ComposeWarningsGuard.ComposeWarningsGuard",
    "class_name": "com.google.javascript.jscomp.ComposeWarningsGuard",
    "signature": "com.google.javascript.jscomp.ComposeWarningsGuard.ComposeWarningsGuard(WarningsGuard[])",
    "snippet": "  public ComposeWarningsGuard(WarningsGuard... guards) {\n    this(Lists.newArrayList(guards));\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "ComposeWarningsGuard.addGuard",
    "class_name": "com.google.javascript.jscomp.ComposeWarningsGuard",
    "signature": "com.google.javascript.jscomp.ComposeWarningsGuard.addGuard(WarningsGuard)",
    "snippet": "  void addGuard(WarningsGuard guard) {\n    if (guard instanceof ComposeWarningsGuard) {\n      // Reverse the guards, so that they have the same order in the result.\n      addGuards(((ComposeWarningsGuard) guard).guards.descendingSet());\n    } else {\n      numberOfAdds++;\n      orderOfAddition.put(guard, numberOfAdds);\n      guards.remove(guard);\n      guards.add(guard);\n    }\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "ComposeWarningsGuard.addGuards",
    "class_name": "com.google.javascript.jscomp.ComposeWarningsGuard",
    "signature": "com.google.javascript.jscomp.ComposeWarningsGuard.addGuards(Iterable)",
    "snippet": "  private void addGuards(Iterable<WarningsGuard> guards) {\n    for (WarningsGuard guard : guards) {\n      addGuard(guard);\n    }\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "ComposeWarningsGuard.enables",
    "class_name": "com.google.javascript.jscomp.ComposeWarningsGuard",
    "signature": "com.google.javascript.jscomp.ComposeWarningsGuard.enables(DiagnosticGroup)",
    "snippet": "  @Override\n  public boolean enables(DiagnosticGroup group) {\n    for (WarningsGuard guard : guards) {\n      if (guard.enables(group)) {\n        return true;\n      } else if (guard.disables(group)) {\n        return false;\n      }\n    }\n\n    return false;\n  }",
    "comment": " Determines whether this guard will \"elevate\" the status of any disabled diagnostic type in the group to a warning or an error. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "DefaultCodingConvention.isExported",
    "class_name": "com.google.javascript.jscomp.DefaultCodingConvention",
    "signature": "com.google.javascript.jscomp.DefaultCodingConvention.isExported(String)",
    "snippet": "  @Override\n  public boolean isExported(String name) {\n    return isExported(name, false) || isExported(name, true);\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "DefaultCodingConvention.isExported",
    "class_name": "com.google.javascript.jscomp.DefaultCodingConvention",
    "signature": "com.google.javascript.jscomp.DefaultCodingConvention.isExported(String,boolean)",
    "snippet": "  @Override\n  public boolean isExported(String name, boolean local) {\n    return local && name.startsWith(\"$super\");\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "DefinitionSite.DefinitionSite",
    "class_name": "com.google.javascript.jscomp.DefinitionSite",
    "signature": "com.google.javascript.jscomp.DefinitionSite.DefinitionSite(Node,Definition,JSModule,boolean,boolean)",
    "snippet": "  DefinitionSite(Node node,\n                 Definition definition,\n                 JSModule module,\n                 boolean inGlobalScope,\n                 boolean inExterns) {\n    this.node = node;\n    this.definition = definition;\n    this.module = module;\n    this.inGlobalScope = inGlobalScope;\n    this.inExterns = inExterns;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "DefinitionsRemover.getDefinition",
    "class_name": "com.google.javascript.jscomp.DefinitionsRemover",
    "signature": "com.google.javascript.jscomp.DefinitionsRemover.getDefinition(Node,boolean)",
    "snippet": "  static Definition getDefinition(Node n, boolean isExtern) {\n    // TODO(user): Since we have parent pointers handy. A lot of constructors\n    // can be simplified.\n\n    // This logic must match #isDefinitionNode\n    Node parent = n.getParent();\n    if (parent == null) {\n      return null;\n    }\n\n    if (NodeUtil.isVarDeclaration(n) && n.hasChildren()) {\n      return new VarDefinition(n, isExtern);\n    } else if (NodeUtil.isFunction(parent) && parent.getFirstChild() == n) {\n      if (!NodeUtil.isFunctionExpression(parent)) {\n        return new NamedFunctionDefinition(parent, isExtern);\n      } else if (!n.getString().equals(\"\")) {\n        return new FunctionExpressionDefinition(parent, isExtern);\n      }\n    } else if (NodeUtil.isAssign(parent) && parent.getFirstChild() == n) {\n      return new AssignmentDefinition(parent, isExtern);\n    } else if (NodeUtil.isObjectLitKey(n, parent)) {\n      return new ObjectLiteralPropertyDefinition(parent, n, n.getFirstChild(),\n          isExtern);\n    } else if (parent.getType() == Token.LP) {\n      Node function = parent.getParent();\n      return new FunctionArgumentDefinition(function, n, isExtern);\n    }\n    return null;\n  }",
    "comment": " @return an {@link Definition} object if the node contains a definition or {@code null} otherwise. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "FunctionDefinition.getLValue",
    "class_name": "com.google.javascript.jscomp.DefinitionsRemover$FunctionDefinition",
    "signature": "com.google.javascript.jscomp.DefinitionsRemover$FunctionDefinition.getLValue()",
    "snippet": "    @Override\n    public Node getLValue() {\n      return function.getFirstChild();\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "FunctionDefinition.getRValue",
    "class_name": "com.google.javascript.jscomp.DefinitionsRemover$FunctionDefinition",
    "signature": "com.google.javascript.jscomp.DefinitionsRemover$FunctionDefinition.getRValue()",
    "snippet": "    @Override\n    public Node getRValue() {\n      return function;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "DiagnosticGroup.DiagnosticGroup",
    "class_name": "com.google.javascript.jscomp.DiagnosticGroup",
    "signature": "com.google.javascript.jscomp.DiagnosticGroup.DiagnosticGroup(DiagnosticType[])",
    "snippet": "  public DiagnosticGroup(DiagnosticType ...types) {\n    this(null, types);\n  }",
    "comment": " Create a group that matches all errors of the given types. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "DiagnosticGroup.DiagnosticGroup",
    "class_name": "com.google.javascript.jscomp.DiagnosticGroup",
    "signature": "com.google.javascript.jscomp.DiagnosticGroup.DiagnosticGroup(String,DiagnosticGroup[])",
    "snippet": "  public DiagnosticGroup(String name, DiagnosticGroup ...groups) {\n    Set<DiagnosticType> set = Sets.newHashSet();\n\n    for (DiagnosticGroup group : groups) {\n      set.addAll(group.types);\n    }\n\n    this.name = name;\n    this.types = ImmutableSet.copyOf(set);\n  }",
    "comment": " Create a composite group. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "DiagnosticGroup.DiagnosticGroup",
    "class_name": "com.google.javascript.jscomp.DiagnosticGroup",
    "signature": "com.google.javascript.jscomp.DiagnosticGroup.DiagnosticGroup(String,DiagnosticType[])",
    "snippet": "  DiagnosticGroup(String name, DiagnosticType ...types) {\n    this.name = name;\n    this.types = ImmutableSet.copyOf(Arrays.asList(types));\n  }",
    "comment": " Create a group that matches all errors of the given types. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "DiagnosticGroup.getTypes",
    "class_name": "com.google.javascript.jscomp.DiagnosticGroup",
    "signature": "com.google.javascript.jscomp.DiagnosticGroup.getTypes()",
    "snippet": "  Collection<DiagnosticType> getTypes() {\n    return types;\n  }",
    "comment": " Returns an iterator over all the types in this group. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "DiagnosticGroup.matches",
    "class_name": "com.google.javascript.jscomp.DiagnosticGroup",
    "signature": "com.google.javascript.jscomp.DiagnosticGroup.matches(DiagnosticType)",
    "snippet": "  public boolean matches(DiagnosticType type) {\n    return types.contains(type);\n  }",
    "comment": " Returns whether the given type matches a type in this group. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "DiagnosticGroupWarningsGuard.DiagnosticGroupWarningsGuard",
    "class_name": "com.google.javascript.jscomp.DiagnosticGroupWarningsGuard",
    "signature": "com.google.javascript.jscomp.DiagnosticGroupWarningsGuard.DiagnosticGroupWarningsGuard(DiagnosticGroup,CheckLevel)",
    "snippet": "  public DiagnosticGroupWarningsGuard(\n      DiagnosticGroup group, CheckLevel level) {\n    this.group = group;\n    this.level = level;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "DiagnosticGroupWarningsGuard.enables",
    "class_name": "com.google.javascript.jscomp.DiagnosticGroupWarningsGuard",
    "signature": "com.google.javascript.jscomp.DiagnosticGroupWarningsGuard.enables(DiagnosticGroup)",
    "snippet": "  @Override\n  public boolean enables(DiagnosticGroup otherGroup) {\n    if (level.isOn()) {\n      for (DiagnosticType type : otherGroup.getTypes()) {\n        if (group.matches(type)) {\n          return true;\n        }\n      }\n    }\n\n    return false;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "DiagnosticGroups.DiagnosticGroups",
    "class_name": "com.google.javascript.jscomp.DiagnosticGroups",
    "signature": "com.google.javascript.jscomp.DiagnosticGroups.DiagnosticGroups()",
    "snippet": "  public DiagnosticGroups() {}",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "DiagnosticGroups.getRegisteredGroups",
    "class_name": "com.google.javascript.jscomp.DiagnosticGroups",
    "signature": "com.google.javascript.jscomp.DiagnosticGroups.getRegisteredGroups()",
    "snippet": "  protected Map<String, DiagnosticGroup> getRegisteredGroups() {\n    return ImmutableMap.copyOf(groupsByName);\n  }",
    "comment": "Get the registered diagnostic groups, indexed by name. */",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "DiagnosticGroups.registerGroup",
    "class_name": "com.google.javascript.jscomp.DiagnosticGroups",
    "signature": "com.google.javascript.jscomp.DiagnosticGroups.registerGroup(String,DiagnosticGroup[])",
    "snippet": "  static DiagnosticGroup registerGroup(String name,\n      DiagnosticGroup ... groups) {\n    DiagnosticGroup group = new DiagnosticGroup(name, groups);\n    groupsByName.put(name, group);\n    return group;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "DiagnosticGroups.registerGroup",
    "class_name": "com.google.javascript.jscomp.DiagnosticGroups",
    "signature": "com.google.javascript.jscomp.DiagnosticGroups.registerGroup(String,DiagnosticType[])",
    "snippet": "  static DiagnosticGroup registerGroup(String name,\n      DiagnosticType ... types) {\n    DiagnosticGroup group = new DiagnosticGroup(name, types);\n    groupsByName.put(name, group);\n    return group;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "DiagnosticType.disabled",
    "class_name": "com.google.javascript.jscomp.DiagnosticType",
    "signature": "com.google.javascript.jscomp.DiagnosticType.disabled(String,String)",
    "snippet": "  public static DiagnosticType disabled(String name,\n      String descriptionFormat) {\n    return make(name, CheckLevel.OFF, descriptionFormat);\n  }",
    "comment": " Create a DiagnosticType at level CheckLevel.OFF  @param name An identifier @param descriptionFormat A format string @return A new DiagnosticType ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "DiagnosticType.error",
    "class_name": "com.google.javascript.jscomp.DiagnosticType",
    "signature": "com.google.javascript.jscomp.DiagnosticType.error(String,String)",
    "snippet": "  public static DiagnosticType error(String name, String descriptionFormat) {\n    return make(name, CheckLevel.ERROR, descriptionFormat);\n  }",
    "comment": " Create a DiagnosticType at level CheckLevel.ERROR  @param name An identifier @param descriptionFormat A format string @return A new DiagnosticType ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "DiagnosticType.make",
    "class_name": "com.google.javascript.jscomp.DiagnosticType",
    "signature": "com.google.javascript.jscomp.DiagnosticType.make(String,CheckLevel,String)",
    "snippet": "  public static DiagnosticType make(String name, CheckLevel level,\n                                    String descriptionFormat) {\n    return\n        new DiagnosticType(name, level, new MessageFormat(descriptionFormat));\n  }",
    "comment": " Create a DiagnosticType at a given CheckLevel.  @param name An identifier @param level Either CheckLevel.ERROR or CheckLevel.WARNING @param descriptionFormat A format string @return A new DiagnosticType ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "DiagnosticType.warning",
    "class_name": "com.google.javascript.jscomp.DiagnosticType",
    "signature": "com.google.javascript.jscomp.DiagnosticType.warning(String,String)",
    "snippet": "  public static DiagnosticType warning(String name, String descriptionFormat) {\n    return make(name, CheckLevel.WARNING, descriptionFormat);\n  }",
    "comment": " Create a DiagnosticType at level CheckLevel.WARNING  @param name An identifier @param descriptionFormat A format string @return A new DiagnosticType ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "ExpressionDecomposer.ExpressionDecomposer",
    "class_name": "com.google.javascript.jscomp.ExpressionDecomposer",
    "signature": "com.google.javascript.jscomp.ExpressionDecomposer.ExpressionDecomposer(AbstractCompiler,Supplier,Set)",
    "snippet": "  public ExpressionDecomposer(\n      AbstractCompiler compiler,\n      Supplier<String> safeNameIdSupplier,\n      Set<String> constNames) {\n    Preconditions.checkNotNull(compiler);\n    Preconditions.checkNotNull(safeNameIdSupplier);\n    Preconditions.checkNotNull(constNames);\n    this.compiler = compiler;\n    this.safeNameIdSupplier = safeNameIdSupplier;\n    this.knownConstants = constNames;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "FunctionArgumentInjector.findModifiedParameters",
    "class_name": "com.google.javascript.jscomp.FunctionArgumentInjector",
    "signature": "com.google.javascript.jscomp.FunctionArgumentInjector.findModifiedParameters(Node)",
    "snippet": "  static Set<String> findModifiedParameters(Node fnNode) {\n    Set<String> names = getFunctionParameterSet(fnNode);\n    Set<String> unsafeNames = Sets.newHashSet();\n    return findModifiedParameters(\n        fnNode, null, names, unsafeNames);\n  }",
    "comment": " Retrieve a set of names that can not be safely substituted in place. Example: function(a) { a = 0; } Inlining this without taking precautions would cause the call site value to be modified (bad). ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "FunctionArgumentInjector.findModifiedParameters",
    "class_name": "com.google.javascript.jscomp.FunctionArgumentInjector",
    "signature": "com.google.javascript.jscomp.FunctionArgumentInjector.findModifiedParameters(Node,Node,Set,Set)",
    "snippet": "  private static Set<String> findModifiedParameters(\n      Node n, Node parent, Set<String> names, Set<String> unsafe) {\n    Preconditions.checkArgument(unsafe != null);\n    if (n.getType() == Token.NAME) {\n      if (names.contains(n.getString())) {\n        if (canNameValueChange(n, parent)) {\n          unsafe.add(n.getString());\n        }\n      }\n    }\n\n    for (Node c : n.children()) {\n      findModifiedParameters(c, n, names, unsafe);\n    }\n\n    return unsafe;\n  }",
    "comment": " Check for uses of the named value that imply a pass-by-value parameter is expected.  This is used to prevent cases like:  function (x) { x=2; return x; }  We don't want \"undefined\" to be substituted for \"x\", and get undefined=2  @param n The node in question. @param parent The parent of the node. @param names The set of names to check. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "FunctionArgumentInjector.getFunctionCallParameterMap",
    "class_name": "com.google.javascript.jscomp.FunctionArgumentInjector",
    "signature": "com.google.javascript.jscomp.FunctionArgumentInjector.getFunctionCallParameterMap(Node,Node,Supplier)",
    "snippet": "  static LinkedHashMap<String, Node> getFunctionCallParameterMap(\n      Node fnNode, Node callNode, Supplier<String> safeNameIdSupplier) {\n    // Create an argName -> expression map\n    // NOTE: A linked map is created here to provide ordering.\n    LinkedHashMap<String, Node> argMap = Maps.newLinkedHashMap();\n\n    // CALL NODE: [ NAME, ARG1, ARG2, ... ]\n    Node cArg = callNode.getFirstChild().getNext();\n    if (callNode.getFirstChild().getType() != Token.NAME) {\n      if (NodeUtil.isFunctionObjectCall(callNode)) {\n        // TODO(johnlenz): Support replace this with a value.\n        Preconditions.checkNotNull(cArg);\n        Preconditions.checkState(cArg.getType() == Token.THIS);\n        cArg = cArg.getNext();\n      } else {\n        Preconditions.checkState(!NodeUtil.isFunctionObjectApply(callNode));\n      }\n    }\n\n    for (Node fnArg : NodeUtil.getFnParameters(fnNode).children()) {\n      if (cArg != null) {\n        argMap.put(fnArg.getString(), cArg);\n        cArg = cArg.getNext();\n      } else {\n        Node srcLocation = callNode;\n        argMap.put(fnArg.getString(), NodeUtil.newUndefinedNode(srcLocation));\n      }\n    }\n\n    // Add temp names for arguments that don't have named parameters in the\n    // called function.\n    int anonArg = 0;\n    while (cArg != null) {\n      String uniquePlaceholder =\n        getUniqueAnonymousParameterName(safeNameIdSupplier);\n      argMap.put(uniquePlaceholder, cArg);\n      cArg = cArg.getNext();\n    }\n\n    return argMap;\n  }",
    "comment": " Get a mapping for function parameter names to call arguments. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "FunctionArgumentInjector.getFunctionParameterSet",
    "class_name": "com.google.javascript.jscomp.FunctionArgumentInjector",
    "signature": "com.google.javascript.jscomp.FunctionArgumentInjector.getFunctionParameterSet(Node)",
    "snippet": "  private static Set<String> getFunctionParameterSet(Node fnNode) {\n    Set<String> set = Sets.newHashSet();\n    for (Node n : NodeUtil.getFnParameters(fnNode).children()) {\n      set.add(n.getString());\n    }\n    return set;\n  }",
    "comment": " Get a set of function parameter names. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "FunctionInjector.FunctionInjector",
    "class_name": "com.google.javascript.jscomp.FunctionInjector",
    "signature": "com.google.javascript.jscomp.FunctionInjector.FunctionInjector(AbstractCompiler,Supplier,boolean)",
    "snippet": "  public FunctionInjector(\n      AbstractCompiler compiler,\n      Supplier<String> safeNameIdSupplier,\n      boolean allowDecomposition) {\n    Preconditions.checkNotNull(compiler);\n    Preconditions.checkNotNull(safeNameIdSupplier);\n    this.compiler = compiler;\n    this.safeNameIdSupplier = safeNameIdSupplier;\n    this.allowDecomposition = allowDecomposition;\n  }",
    "comment": " @param allowDecomposition Whether an effort should be made to break down expressions into simpler expressions to allow functions to be injected where they would otherwise be disallowed. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "FunctionInjector.callMeetsBlockInliningRequirements",
    "class_name": "com.google.javascript.jscomp.FunctionInjector",
    "signature": "com.google.javascript.jscomp.FunctionInjector.callMeetsBlockInliningRequirements(NodeTraversal,Node,Node,Set)",
    "snippet": "  private boolean callMeetsBlockInliningRequirements(\n      NodeTraversal t, Node callNode, Node fnNode, Set<String> namesToAlias) {\n    // Note: functions that contain function definitions are filtered out\n    // in isCanidateFunction.\n\n    // TODO(johnlenz): Determining if the called function contains VARs\n    // or if the caller contains inner functions accounts for 20% of the\n    // runtime cost of this pass.\n\n    // Don't inline functions with var declarations into a scope with inner\n    // functions as the new vars would leak into the inner function and\n    // cause memory leaks.\n    boolean fnContainsVars = NodeUtil.has(\n        NodeUtil.getFunctionBody(fnNode),\n        new NodeUtil.MatchDeclaration(),\n        new NodeUtil.MatchShallowStatement());\n    boolean callerContainsFunction = false;\n    if (!t.inGlobalScope()) {\n      Node fnCaller = t.getScopeRoot();\n      Node fnCallerBody = fnCaller.getLastChild();\n\n      callerContainsFunction = NodeUtil.containsFunction(fnCallerBody);\n    }\n\n    if (fnContainsVars && callerContainsFunction) {\n      return false;\n    }\n\n    // If the caller contains functions, verify we aren't adding any\n    // additional VAR declarations because aliasing is needed.\n    if (callerContainsFunction) {\n      Map<String, Node> args =\n          FunctionArgumentInjector.getFunctionCallParameterMap(\n              fnNode, callNode, this.safeNameIdSupplier);\n      boolean hasArgs = !args.isEmpty();\n      if (hasArgs) {\n        // Limit the inlining\n        Set<String> allNamesToAlias = Sets.newHashSet(namesToAlias);\n        FunctionArgumentInjector.maybeAddTempsForCallArguments(\n            fnNode, args, allNamesToAlias, compiler.getCodingConvention());\n        if (!allNamesToAlias.isEmpty()) {\n          return false;\n        }\n      }\n    }\n\n    return true;\n  }",
    "comment": " Determines whether a function can be inlined at a particular call site. - Don't inline if the calling function contains an inner function and inlining would introduce new globals. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "FunctionInjector.canInlineReferenceAsStatementBlock",
    "class_name": "com.google.javascript.jscomp.FunctionInjector",
    "signature": "com.google.javascript.jscomp.FunctionInjector.canInlineReferenceAsStatementBlock(NodeTraversal,Node,Node,Set)",
    "snippet": "  private CanInlineResult canInlineReferenceAsStatementBlock(\n      NodeTraversal t, Node callNode, Node fnNode, Set<String> namesToAlias) {\n    CallSiteType callSiteType = classifyCallSite(callNode);\n    if (callSiteType == CallSiteType.UNSUPPORTED) {\n      return CanInlineResult.NO;\n    }\n\n    if (!allowDecomposition\n        && callSiteType == CallSiteType.DECOMPOSABLE_EXPRESSION) {\n      return CanInlineResult.NO;\n    }\n\n    if (!callMeetsBlockInliningRequirements(\n            t, callNode, fnNode, namesToAlias)) {\n      return CanInlineResult.NO;\n    }\n\n    if (callSiteType == CallSiteType.DECOMPOSABLE_EXPRESSION)  {\n      return CanInlineResult.AFTER_DECOMPOSITION;\n    } else {\n      return CanInlineResult.YES;\n    }\n  }",
    "comment": " Determines whether a function can be inlined at a particular call site. There are several criteria that the function and reference must hold in order for the functions to be inlined: - It must be a simple call, or assignment, or var initialization. <pre> f(); a = foo(); var a = foo(); </pre> ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "FunctionInjector.canInlineReferenceToFunction",
    "class_name": "com.google.javascript.jscomp.FunctionInjector",
    "signature": "com.google.javascript.jscomp.FunctionInjector.canInlineReferenceToFunction(NodeTraversal,Node,Node,Set,InliningMode,boolean,boolean)",
    "snippet": "  CanInlineResult canInlineReferenceToFunction(NodeTraversal t,\n      Node callNode, Node fnNode, Set<String> needAliases,\n      InliningMode mode, boolean referencesThis, boolean containsFunctions) {\n    // TODO(johnlenz): This function takes too many parameter, without\n    // context.  Modify the API to take a structure describing the function.\n\n    // Allow direct function calls or \"fn.call\" style calls.\n    if (!isSupportedCallType(callNode)) {\n      return CanInlineResult.NO;\n    }\n\n    // Limit where functions that contain functions can be inline.  Introducing\n    // an inner function into another function can capture a variable and cause\n    // a memory leak.  This isn't a problem in the global scope as those values\n    // last until explicitly cleared.\n    if (containsFunctions && !t.inGlobalScope()) {\n      // TODO(johnlenz): Allow inlining into any scope without local names or\n      // inner functions.\n      return CanInlineResult.NO;\n    }\n\n    // TODO(johnlenz): Add support for 'apply'\n    if (referencesThis && !NodeUtil.isFunctionObjectCall(callNode)) {\n      // TODO(johnlenz): Allow 'this' references to be replaced with a\n      // global 'this' object.\n      return CanInlineResult.NO;\n    }\n\n    if (mode == InliningMode.DIRECT) {\n      return canInlineReferenceDirectly(callNode, fnNode);\n    } else {\n      return canInlineReferenceAsStatementBlock(\n          t, callNode, fnNode, needAliases);\n    }\n  }",
    "comment": " @param t  The traversal use to reach the call site. @param callNode The CALL node. @param fnNode The function to evaluate for inlining. @param needAliases A set of function parameter names that can not be used without aliasing. Returned by getUnsafeParameterNames(). @param mode Inlining mode to be used. @param referencesThis Whether fnNode contains references to its this object. @param containsFunctions Whether fnNode contains inner functions. @return Whether the inlining can occur. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "FunctionInjector.classifyCallSite",
    "class_name": "com.google.javascript.jscomp.FunctionInjector",
    "signature": "com.google.javascript.jscomp.FunctionInjector.classifyCallSite(Node)",
    "snippet": "  private CallSiteType classifyCallSite(Node callNode) {\n    Node parent = callNode.getParent();\n    Node grandParent = parent.getParent();\n\n    // Verify the call site:\n    if (NodeUtil.isExprCall(parent)) {\n      // This is a simple call?  Example: \"foo();\".\n      return CallSiteType.SIMPLE_CALL;\n    } else if (NodeUtil.isExprAssign(grandParent)\n        && !NodeUtil.isLhs(callNode, parent)\n        && parent.getFirstChild().getType() == Token.NAME\n        && !NodeUtil.isConstantName(parent.getFirstChild())) {\n      // This is a simple assignment.  Example: \"x = foo();\"\n      return CallSiteType.SIMPLE_ASSIGNMENT;\n    } else if (parent.getType() == Token.NAME\n        && !NodeUtil.isConstantName(parent)\n        && grandParent.getType() == Token.VAR\n        && grandParent.hasOneChild()) {\n      // This is a var declaration.  Example: \"var x = foo();\"\n      // TODO(johnlenz): Should we be checking for constants on the\n      // left-hand-side of the assignments (and handling them as EXPRESSION?\n      return CallSiteType.VAR_DECL_SIMPLE_ASSIGNMENT;\n    } else {\n      Node expressionRoot = ExpressionDecomposer.findExpressionRoot(callNode);\n      if (expressionRoot != null) {\n        ExpressionDecomposer decomposer = new ExpressionDecomposer(\n            compiler, safeNameIdSupplier, knownConstants);\n        DecompositionType type = decomposer.canExposeExpression(\n            callNode);\n        if (type == DecompositionType.MOVABLE) {\n          return CallSiteType.EXPRESSION;\n        } else if (type == DecompositionType.DECOMPOSABLE) {\n          return CallSiteType.DECOMPOSABLE_EXPRESSION;\n        } else {\n          Preconditions.checkState(type == DecompositionType.UNDECOMPOSABLE);\n        }\n      }\n    }\n\n    return CallSiteType.UNSUPPORTED;\n  }",
    "comment": " Determine which, if any, of the supported types the call site is. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "FunctionInjector.doesFunctionMeetMinimumRequirements",
    "class_name": "com.google.javascript.jscomp.FunctionInjector",
    "signature": "com.google.javascript.jscomp.FunctionInjector.doesFunctionMeetMinimumRequirements(String,Node)",
    "snippet": "  boolean doesFunctionMeetMinimumRequirements(\n      final String fnName, Node fnNode) {\n    Node block = NodeUtil.getFunctionBody(fnNode);\n\n    // Basic restrictions on functions that can be inlined:\n    // 1) It contains a reference to itself.\n    // 2) It uses its parameters indirectly using \"arguments\" (it isn't\n    //    handled yet.\n    // 3) It references \"eval\". Inline a function containing eval can have\n    //    large performance implications.\n\n    final String fnRecursionName = fnNode.getFirstChild().getString();\n    Preconditions.checkState(fnRecursionName != null);\n\n    Predicate<Node> p = new Predicate<Node>(){\n      public boolean apply(Node n) {\n        if (n.getType() == Token.NAME) {\n          return n.getString().equals(\"arguments\")\n            || n.getString().equals(\"eval\")\n            || n.getString().equals(fnName)\n            || (!fnRecursionName.isEmpty()\n                && n.getString().equals(fnRecursionName));\n        }\n        return false;\n      }\n    };\n\n    return !NodeUtil.has(block, p, Predicates.<Node>alwaysTrue());\n  }",
    "comment": " @param fnName The name of this function. This either the name of the variable to which the function is assigned or the name from the FUNCTION node. @param fnNode The FUNCTION node of the function to inspect. @return Whether the function node meets the minimum requirements for inlining. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "FunctionInjector.doesLowerCost",
    "class_name": "com.google.javascript.jscomp.FunctionInjector",
    "signature": "com.google.javascript.jscomp.FunctionInjector.doesLowerCost(Node,int,int,int,int,int,boolean)",
    "snippet": "  private boolean doesLowerCost(\n      Node fnNode, int callCost,\n      int directInlines, int costDeltaDirect,\n      int blockInlines, int costDeltaBlock,\n      boolean removable) {\n\n    // Determine the threshold value for this inequality:\n    //     inline_cost < call_cost\n    // But solve it for the function declaration size so the size of it\n    // is only calculated once and terminated early if possible.\n\n    int fnInstanceCount = directInlines + blockInlines - (removable ? 1 : 0);\n    // Prevent division by zero.\n    if (fnInstanceCount == 0) {\n      // Special case single reference function that are being block inlined:\n      // If the cost of the inline is greater than the function definition size,\n      // don't inline.\n      if (blockInlines > 0 && costDeltaBlock > 0) {\n        return false;\n      }\n      return true;\n    }\n\n    int costDelta = (directInlines * costDeltaDirect) +\n        (blockInlines * costDeltaBlock);\n    int threshold = (callCost - costDelta) / fnInstanceCount;\n\n    return InlineCostEstimator.getCost(fnNode, threshold + 1) <= threshold;\n  }",
    "comment": " @return Whether inlining will lower cost. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "FunctionInjector.estimateCallCost",
    "class_name": "com.google.javascript.jscomp.FunctionInjector",
    "signature": "com.google.javascript.jscomp.FunctionInjector.estimateCallCost(Node,boolean)",
    "snippet": "  private static int estimateCallCost(Node fnNode, boolean referencesThis) {\n    Node argsNode = NodeUtil.getFnParameters(fnNode);\n    int numArgs = argsNode.getChildCount();\n\n    int callCost = NAME_COST_ESTIMATE + PAREN_COST;\n    if (numArgs > 0) {\n      callCost += (numArgs * NAME_COST_ESTIMATE) + ((numArgs - 1) * COMMA_COST);\n    }\n\n    if (referencesThis) {\n      // TODO(johnlenz): Update this if we start supporting inlining\n      // other functions that reference this.\n      // The only functions that reference this that are currently inlined\n      // are those that are called via \".call\" with an explicit \"this\".\n      callCost += 5 + 5;  // \".call\" + \"this,\"\n    }\n\n    return callCost;\n  }",
    "comment": " Gets an estimate of the cost in characters of making the function call: the sum of the identifiers and the separators. @param referencesThis ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "FunctionInjector.inline",
    "class_name": "com.google.javascript.jscomp.FunctionInjector",
    "signature": "com.google.javascript.jscomp.FunctionInjector.inline(NodeTraversal,Node,String,Node,InliningMode)",
    "snippet": "  Node inline(\n      NodeTraversal t, Node callNode, String fnName, Node fnNode,\n      InliningMode mode) {\n    Preconditions.checkState(compiler.getLifeCycleStage().isNormalized());\n\n    if (mode == InliningMode.DIRECT) {\n      return inlineReturnValue(callNode, fnNode);\n    } else {\n      return inlineFunction(callNode, fnNode, fnName);\n    }\n  }",
    "comment": " Inline a function into the call site. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "FunctionInjector.inlineCostDelta",
    "class_name": "com.google.javascript.jscomp.FunctionInjector",
    "signature": "com.google.javascript.jscomp.FunctionInjector.inlineCostDelta(Node,Set,InliningMode)",
    "snippet": "  private static int inlineCostDelta(\n      Node fnNode, Set<String> namesToAlias, InliningMode mode) {\n    // The part of the function that is never inlined:\n    //    \"function xx(xx,xx){}\" (15 + (param count * 3) -1;\n    int paramCount = NodeUtil.getFnParameters(fnNode).getChildCount();\n    int commaCount = (paramCount > 1) ? paramCount - 1 : 0;\n    int costDeltaFunctionOverhead = 15 + commaCount +\n        (paramCount * InlineCostEstimator.ESTIMATED_IDENTIFIER_COST);\n\n    Node block = fnNode.getLastChild();\n    if (!block.hasChildren()) {\n      // Assume the inline cost is zero for empty functions.\n      return -costDeltaFunctionOverhead;\n    }\n\n    if (mode == InliningMode.DIRECT) {\n      // The part of the function that is inlined using direct inlining:\n      //    \"return \" (7)\n      return -(costDeltaFunctionOverhead + 7);\n    } else {\n      int aliasCount = namesToAlias.size();\n\n      // Originally, we estimated purely base on the function code size, relying\n      // on later optimizations. But that did not produce good results, so here\n      // we try to estimate the something closer to the actual inlined coded.\n\n      // NOTE 1: Result overhead is only if there is an assignment, but\n      // getting that information would require some refactoring.\n      // NOTE 2: The aliasing overhead is currently an under-estimate,\n      // as some parameters are aliased because of the parameters used.\n      // Perhaps we should just assume all parameters will be aliased?\n      final int INLINE_BLOCK_OVERHEAD = 4; // \"X:{}\"\n      final int PER_RETURN_OVERHEAD = 2;   // \"return\" --> \"break X\"\n      final int PER_RETURN_RESULT_OVERHEAD = 3; // \"XX=\"\n      final int PER_ALIAS_OVERHEAD = 3; // \"XX=\"\n\n      // TODO(johnlenz): Counting the number of returns is relatively expensive\n      //   this information should be determined during the traversal and\n      //   cached.\n      int returnCount = NodeUtil.getNodeTypeReferenceCount(\n          block, Token.RETURN, new NodeUtil.MatchShallowStatement());\n      int resultCount = (returnCount > 0) ? returnCount - 1 : 0;\n      int baseOverhead = (returnCount > 0) ? INLINE_BLOCK_OVERHEAD : 0;\n\n      int overhead = baseOverhead\n          + returnCount * PER_RETURN_OVERHEAD\n          + resultCount * PER_RETURN_RESULT_OVERHEAD\n          + aliasCount * PER_ALIAS_OVERHEAD;\n\n      return (overhead - costDeltaFunctionOverhead);\n    }\n  }",
    "comment": " @return The difference between the function definition cost and inline cost. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "FunctionInjector.inlineFunction",
    "class_name": "com.google.javascript.jscomp.FunctionInjector",
    "signature": "com.google.javascript.jscomp.FunctionInjector.inlineFunction(Node,Node,String)",
    "snippet": "  private Node inlineFunction(\n      Node callNode, Node fnNode, String fnName) {\n    Node parent = callNode.getParent();\n    Node grandParent = parent.getParent();\n\n    // TODO(johnlenz): Consider storing the callSite classification in the\n    // reference object and passing it in here.\n    CallSiteType callSiteType = classifyCallSite(callNode);\n    Preconditions.checkArgument(callSiteType != CallSiteType.UNSUPPORTED);\n\n    // Store the name for the result. This will be used to\n    // replace \"return expr\" statements with \"resultName = expr\"\n    // to replace\n    String resultName = null;\n    boolean needsDefaultReturnResult = true;\n    switch (callSiteType) {\n      case SIMPLE_ASSIGNMENT:\n        resultName = parent.getFirstChild().getString();\n        break;\n\n      case VAR_DECL_SIMPLE_ASSIGNMENT:\n        resultName = parent.getString();\n        break;\n\n      case SIMPLE_CALL:\n        resultName = null;  // \"foo()\" doesn't need a result.\n        needsDefaultReturnResult = false;\n        break;\n\n      case EXPRESSION:\n        resultName = getUniqueResultName();\n        needsDefaultReturnResult = false; // The intermediary result already\n                                          // has the default value.\n        break;\n\n      case DECOMPOSABLE_EXPRESSION:\n        throw new IllegalStateException(\n            \"Decomposable expressions must decomposed before inlining.\");\n\n      default:\n        throw new IllegalStateException(\"Unexpected call site type.\");\n    }\n\n    boolean isCallInLoop = NodeUtil.isWithinLoop(callNode);\n\n    FunctionToBlockMutator mutator = new FunctionToBlockMutator(\n        compiler, this.safeNameIdSupplier);\n\n    Node newBlock = mutator.mutate(\n        fnName, fnNode, callNode, resultName,\n        needsDefaultReturnResult, isCallInLoop);\n\n    // TODO(nicksantos): Create a common mutation function that\n    // can replace either a VAR name assignment, assignment expression or\n    // a EXPR_RESULT.\n    Node greatGrandParent = grandParent.getParent();\n    switch (callSiteType) {\n      case VAR_DECL_SIMPLE_ASSIGNMENT:\n        // Remove the call from the name node.\n        parent.removeChild(parent.getFirstChild());\n        Preconditions.checkState(parent.getFirstChild() == null);\n        // Add the call, after the VAR.\n        greatGrandParent.addChildAfter(newBlock, grandParent);\n        break;\n\n      case SIMPLE_ASSIGNMENT:\n        // The assignment is now part of the inline function so\n        // replace it completely.\n        Preconditions.checkState(NodeUtil.isExpressionNode(grandParent));\n        greatGrandParent.replaceChild(grandParent, newBlock);\n        break;\n\n      case SIMPLE_CALL:\n        // If nothing is looking at the result just replace the call.\n        Preconditions.checkState(NodeUtil.isExpressionNode(parent));\n        grandParent.replaceChild(parent, newBlock);\n        break;\n\n      case EXPRESSION:\n        // TODO(johnlenz): Maybe change this so that movable and decomposable\n        // expressions are handled the same way: The call is moved and\n        // then handled by one the three basic cases, rather than\n        // introducing a new case.\n        Node injectionPoint = ExpressionDecomposer.findInjectionPoint(callNode);\n        Preconditions.checkNotNull(injectionPoint);\n        Node injectionPointParent = injectionPoint.getParent();\n        Preconditions.checkNotNull(injectionPointParent);\n        Preconditions.checkState(\n            NodeUtil.isStatementBlock(injectionPointParent));\n\n        // Declare the intermediate result name.\n        newBlock.addChildrenToFront(\n            NodeUtil.newVarNode(resultName, null)\n                 .copyInformationFromForTree(callNode));\n        // Inline the function before the selected injection point (before\n        // the call).\n        injectionPointParent.addChildBefore(newBlock, injectionPoint);\n        // Replace the call site with a reference to the intermediate\n        // result name.\n        parent.replaceChild(callNode, Node.newString(Token.NAME, resultName));\n        break;\n\n      default:\n        throw new IllegalStateException(\"Unexpected call site type.\");\n    }\n\n    return newBlock;\n  }",
    "comment": " Inline a function which fulfills the requirements of canInlineReferenceAsStatementBlock into the call site, replacing the parent expression. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "FunctionInjector.inliningLowersCost",
    "class_name": "com.google.javascript.jscomp.FunctionInjector",
    "signature": "com.google.javascript.jscomp.FunctionInjector.inliningLowersCost(JSModule,Node,Collection,Set,boolean,boolean)",
    "snippet": "  boolean inliningLowersCost(\n      JSModule fnModule, Node fnNode, Collection<? extends Reference> refs,\n      Set<String> namesToAlias, boolean isRemovable, boolean referencesThis) {\n    int referenceCount = refs.size();\n    if (referenceCount == 0) {\n      return true;\n    }\n\n    int referencesUsingBlockInlining = 0;\n\n    boolean checkModules = isRemovable && fnModule != null;\n    JSModuleGraph moduleGraph = compiler.getModuleGraph();\n\n    for (Reference ref : refs) {\n      if (ref.mode == InliningMode.BLOCK) {\n        referencesUsingBlockInlining++;\n      }\n\n      // Check if any of the references cross the module boundaries.\n      if (checkModules && ref.module != null) {\n        if (ref.module != fnModule &&\n            !moduleGraph.dependsOn(ref.module, fnModule)) {\n          // Calculate the cost as if the function were non-removable,\n          // if it still lowers the cost inline it.\n          isRemovable = false;\n          checkModules = false;  // no need to check additional modules.\n        }\n      }\n    }\n\n    int referencesUsingDirectInlining = referenceCount -\n        referencesUsingBlockInlining;\n\n    // Don't bother calculating the cost of function for simple functions where\n    // possible.\n    // However, when inlining a complex function, even a single reference may be\n    // larger than the original function if there are many returns (resulting\n    // in additional assignments) or many parameters that need to be aliased\n    // so use the cost estimating.\n    if (referenceCount == 1 && isRemovable &&\n        referencesUsingDirectInlining == 1) {\n      return true;\n    }\n\n    int callCost = estimateCallCost(fnNode, referencesThis);\n    int overallCallCost = callCost * referenceCount;\n\n    int costDeltaDirect = inlineCostDelta(\n        fnNode, namesToAlias, InliningMode.DIRECT);\n    int costDeltaBlock = inlineCostDelta(\n        fnNode, namesToAlias, InliningMode.BLOCK);\n\n    return doesLowerCost(fnNode, overallCallCost,\n        referencesUsingDirectInlining, costDeltaDirect,\n        referencesUsingBlockInlining, costDeltaBlock,\n        isRemovable);\n  }",
    "comment": " Determine if inlining the function is likely to reduce the code size. @param namesToAlias ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "FunctionInjector.isDirectCallNodeReplacementPossible",
    "class_name": "com.google.javascript.jscomp.FunctionInjector",
    "signature": "com.google.javascript.jscomp.FunctionInjector.isDirectCallNodeReplacementPossible(Node)",
    "snippet": "  boolean isDirectCallNodeReplacementPossible(Node fnNode) {\n    // Only inline single-statement functions\n    Node block = NodeUtil.getFunctionBody(fnNode);\n\n    // Check if this function is suitable for direct replacement of a CALL node:\n    // a function that consists of single return that returns an expression.\n    if (!block.hasChildren()) {\n      // special case empty functions.\n      return true;\n    } else if (block.hasOneChild()) {\n      // Only inline functions that return something.\n      if (block.getFirstChild().getType() == Token.RETURN\n          && block.getFirstChild().getFirstChild() != null) {\n        return true;\n      }\n    }\n\n    return false;\n  }",
    "comment": " Checks if the given function matches the criteria for an inlinable function, and if so, adds it to our set of inlinable functions. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "FunctionInjector.isSupportedCallType",
    "class_name": "com.google.javascript.jscomp.FunctionInjector",
    "signature": "com.google.javascript.jscomp.FunctionInjector.isSupportedCallType(Node)",
    "snippet": "  private boolean isSupportedCallType(Node callNode) {\n    if (callNode.getFirstChild().getType() != Token.NAME) {\n      if (NodeUtil.isFunctionObjectCall(callNode)) {\n        Node thisValue = callNode.getFirstChild().getNext();\n        if (thisValue == null || thisValue.getType() != Token.THIS) {\n          return false;\n        }\n      } else if (NodeUtil.isFunctionObjectApply(callNode)) {\n        return false;\n      }\n    }\n\n    return true;\n  }",
    "comment": " Only \".call\" calls and direct calls to functions are supported. @param callNode The call evaluate. @return Whether the call is of a type that is supported. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "FunctionInjector.setKnownConstants",
    "class_name": "com.google.javascript.jscomp.FunctionInjector",
    "signature": "com.google.javascript.jscomp.FunctionInjector.setKnownConstants(Set)",
    "snippet": "  public void setKnownConstants(Set<String> knownConstants) {\n    // This is only expected to be set once. The same set should be used\n    // when evaluating call-sites and inlining calls.\n    Preconditions.checkState(this.knownConstants.isEmpty());\n    this.knownConstants = knownConstants;\n  }",
    "comment": " Store the names of known constants to be used when classifying call-sites in expressions. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "FunctionToBlockMutator.FunctionToBlockMutator",
    "class_name": "com.google.javascript.jscomp.FunctionToBlockMutator",
    "signature": "com.google.javascript.jscomp.FunctionToBlockMutator.FunctionToBlockMutator(AbstractCompiler,Supplier)",
    "snippet": "  FunctionToBlockMutator(\n      AbstractCompiler compiler, Supplier<String> safeNameIdSupplier) {\n    this.compiler = compiler;\n    this.safeNameIdSupplier = safeNameIdSupplier;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "FunctionToBlockMutator.getLabelNameForFunction",
    "class_name": "com.google.javascript.jscomp.FunctionToBlockMutator",
    "signature": "com.google.javascript.jscomp.FunctionToBlockMutator.getLabelNameForFunction(String)",
    "snippet": "  private String getLabelNameForFunction(String fnName){\n    String name = (fnName == null || fnName.isEmpty()) ? \"anon\" : fnName;\n    return \"JSCompiler_inline_label_\" + name + \"_\" + safeNameIdSupplier.get();\n  }",
    "comment": " Create a unique label name. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "FunctionToBlockMutator.makeLocalNamesUnique",
    "class_name": "com.google.javascript.jscomp.FunctionToBlockMutator",
    "signature": "com.google.javascript.jscomp.FunctionToBlockMutator.makeLocalNamesUnique(Node,boolean)",
    "snippet": "  private void makeLocalNamesUnique(Node fnNode, boolean isCallInLoop) {\n    Supplier<String> idSupplier = compiler.getUniqueNameIdSupplier();\n    // Make variable names unique to this instance.\n    NodeTraversal.traverse(\n        compiler, fnNode, new MakeDeclaredNamesUnique(\n            new InlineRenamer(\n                idSupplier,\n                \"inline_\",\n                isCallInLoop)));\n    // Make label names unique to this instance.\n  }",
    "comment": " Fix-up all local names to be unique for this subtree. @param fnNode A mutable instance of the function to be inlined. ",
    "is_bug": true,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "FunctionToBlockMutator.mutate",
    "class_name": "com.google.javascript.jscomp.FunctionToBlockMutator",
    "signature": "com.google.javascript.jscomp.FunctionToBlockMutator.mutate(String,Node,Node,String,boolean,boolean)",
    "snippet": "  Node mutate(String fnName, Node fnNode, Node callNode,\n      String resultName, boolean needsDefaultResult, boolean isCallInLoop) {\n    Node newFnNode = fnNode.cloneTree();\n    // Now that parameter names have been replaced, make sure all the local\n    // names are unique, to allow functions to be inlined multiple times\n    // without causing conflicts.\n    makeLocalNamesUnique(newFnNode, isCallInLoop);\n\n    // TODO(johnlenz): Mark NAME nodes constant for parameters that are not\n    // modified.\n    Set<String> namesToAlias =\n        FunctionArgumentInjector.findModifiedParameters(newFnNode);\n    LinkedHashMap<String, Node> args =\n        FunctionArgumentInjector.getFunctionCallParameterMap(\n            newFnNode, callNode, this.safeNameIdSupplier);\n    boolean hasArgs = !args.isEmpty();\n    if (hasArgs) {\n      FunctionArgumentInjector.maybeAddTempsForCallArguments(\n          newFnNode, args, namesToAlias, compiler.getCodingConvention());\n    }\n\n    Node newBlock = NodeUtil.getFunctionBody(newFnNode);\n    // Make the newBlock insertable .\n    newBlock.detachFromParent();\n\n    if (hasArgs) {\n      Node inlineResult = aliasAndInlineArguments(newBlock,\n          args, namesToAlias);\n      Preconditions.checkState(newBlock == inlineResult);\n    }\n\n    //\n    // For calls inlined into loops, VAR declarations are not reinitialized to\n    // undefined as they would have been if the function were called, so ensure\n    // that they are properly initialized.\n    //\n    if (isCallInLoop) {\n      fixUnitializedVarDeclarations(newBlock);\n    }\n\n    String labelName = getLabelNameForFunction(fnName);\n    Node injectableBlock = replaceReturns(\n        newBlock, resultName, labelName, needsDefaultResult);\n    Preconditions.checkState(injectableBlock != null);\n\n    return injectableBlock;\n  }",
    "comment": " @param fnName The name to use when preparing human readable names. @param fnNode The function to prepare. @param callNode The call node that will be replaced. @param resultName Function results should be assigned to this name. @param needsDefaultResult Whether the result value must be set. @param isCallInLoop Whether the function body must be prepared to be injected into the body of a loop. @return A clone of the function body mutated to be suitable for injection as a statement into another code block. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "FunctionToBlockMutator.replaceReturns",
    "class_name": "com.google.javascript.jscomp.FunctionToBlockMutator",
    "signature": "com.google.javascript.jscomp.FunctionToBlockMutator.replaceReturns(Node,String,String,boolean)",
    "snippet": "  private static Node replaceReturns(\n      Node block, String resultName, String labelName,\n      boolean resultMustBeSet) {\n    Preconditions.checkNotNull(block);\n    Preconditions.checkNotNull(labelName);\n\n    Node root = block;\n\n    boolean hasReturnAtExit = false;\n    int returnCount = NodeUtil.getNodeTypeReferenceCount(\n        block, Token.RETURN, new NodeUtil.MatchShallowStatement());\n    if (returnCount > 0) {\n      hasReturnAtExit = hasReturnAtExit(block);\n      // TODO(johnlenz): Simpler not to special case this,\n      // and let it be optimized later.\n      if (hasReturnAtExit) {\n        convertLastReturnToStatement(block, resultName);\n        returnCount--;\n      }\n\n      if (returnCount > 0) {\n        // A label and breaks are needed.\n\n        // Add the breaks\n        replaceReturnWithBreak(block, null, resultName, labelName);\n\n        // Add label\n        Node label = new Node(Token.LABEL).copyInformationFrom(block);\n        Node name = Node.newString(Token.LABEL_NAME, labelName)\n            .copyInformationFrom(block);\n        label.addChildToFront(name);\n        label.addChildToBack(block);\n\n        Node newRoot = new Node(Token.BLOCK).copyInformationFrom(block);\n        newRoot.addChildrenToBack(label);\n\n\n        // The label is now the root.\n        root = newRoot;\n      }\n    }\n\n    // If there wasn't an return at the end of the function block, and we need\n    // a result, add one to the block.\n    if (resultMustBeSet && !hasReturnAtExit && resultName != null) {\n      addDummyAssignment(block, resultName);\n    }\n\n    return root;\n  }",
    "comment": " Convert returns to assignments and breaks, as needed. For example, with a lableName of 'foo': { return a; } becomes: foo: { a; break foo; } or foo: { resultName = a; break foo; }  @param resultMustBeSet Whether the result must always be set to a value. @return The node containing the transformed block, this may be different than the passed in node 'block'. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "GoogleCodingConvention.isConstant",
    "class_name": "com.google.javascript.jscomp.GoogleCodingConvention",
    "signature": "com.google.javascript.jscomp.GoogleCodingConvention.isConstant(String)",
    "snippet": "  @Override\n  public boolean isConstant(String name) {\n    if (name.length() <= 1) {\n      return false;\n    }\n\n    // In compiled code, '$' is often a namespace delimiter. To allow inlining\n    // of namespaced constants, we strip off any namespaces here.\n    int pos = name.lastIndexOf('$');\n    if (pos >= 0) {\n      name = name.substring(pos + 1);\n      if (name.length() == 0) {\n        return false;\n      }\n    }\n\n    return isConstantKey(name);\n  }",
    "comment": " {@inheritDoc}  <p>This enforces the Google const name convention, that the first character after the last $ must be an upper-case letter and all subsequent letters must be upper case. The name must be at least 2 characters long.  <p>Examples: <pre> aaa          Not constant - lower-case letters in the name A            Not constant - too short goog$A       Constant - letters after the $ are upper-case. AA17         Constant - digits can appear after the first letter goog$7A      Not constant - first character after the $ must be upper case. $A           Constant - doesn't have to be anything in front of the $ </pre> ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "GoogleCodingConvention.isConstantKey",
    "class_name": "com.google.javascript.jscomp.GoogleCodingConvention",
    "signature": "com.google.javascript.jscomp.GoogleCodingConvention.isConstantKey(String)",
    "snippet": "  @Override\n  public boolean isConstantKey(String name) {\n    if (name.isEmpty() || !Character.isUpperCase(name.charAt(0))) {\n      return false;\n    }\n\n    // hack way of checking that there aren't any lower-case letters\n    return name.toUpperCase().equals(name);\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "GoogleCodingConvention.isExported",
    "class_name": "com.google.javascript.jscomp.GoogleCodingConvention",
    "signature": "com.google.javascript.jscomp.GoogleCodingConvention.isExported(String,boolean)",
    "snippet": "  @Override\n  public boolean isExported(String name, boolean local) {\n    return super.isExported(name, local) ||\n        (!local && name.startsWith(\"_\"));\n  }",
    "comment": " {@inheritDoc}  <p>In Google code, any global name starting with an underscore is considered exported. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "InlineFunctions.InlineFunctions",
    "class_name": "com.google.javascript.jscomp.InlineFunctions",
    "signature": "com.google.javascript.jscomp.InlineFunctions.InlineFunctions(AbstractCompiler,Supplier,boolean,boolean,boolean)",
    "snippet": "  InlineFunctions(AbstractCompiler compiler,\n      Supplier<String> safeNameIdSupplier,\n      boolean inlineGlobalFunctions,\n      boolean inlineLocalFunctions,\n      boolean blockFunctionInliningEnabled) {\n    Preconditions.checkArgument(compiler != null);\n    Preconditions.checkArgument(safeNameIdSupplier != null);\n    this.compiler = compiler;\n\n    this.inlineGlobalFunctions = inlineGlobalFunctions;\n    this.inlineLocalFunctions = inlineLocalFunctions;\n    this.blockFunctionInliningEnabled = blockFunctionInliningEnabled;\n\n    this.injector = new FunctionInjector(compiler, safeNameIdSupplier, true);\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "InlineFunctions.decomposeExpressions",
    "class_name": "com.google.javascript.jscomp.InlineFunctions",
    "signature": "com.google.javascript.jscomp.InlineFunctions.decomposeExpressions(Set)",
    "snippet": "  private void decomposeExpressions(Set<String> fnNames) {\n    ExpressionDecomposer decomposer = new ExpressionDecomposer(\n        compiler, compiler.getUniqueNameIdSupplier(), fnNames);\n\n    for (FunctionState fs : fns.values()) {\n      if (fs.canInline()) {\n        for (Reference ref : fs.getReferences()) {\n          if (ref.requiresDecomposition) {\n            decomposer.maybeDecomposeExpression(ref.callNode);\n          }\n        }\n      }\n    }\n  }",
    "comment": " For any call-site that needs it, prepare the call-site for inlining by rewriting the containing expression. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "InlineFunctions.findCalledFunctions",
    "class_name": "com.google.javascript.jscomp.InlineFunctions",
    "signature": "com.google.javascript.jscomp.InlineFunctions.findCalledFunctions(Node)",
    "snippet": "  private Set<String> findCalledFunctions(Node node) {\n    Set<String> changed = Sets.newHashSet();\n    findCalledFunctions(NodeUtil.getFunctionBody(node), changed);\n    return changed;\n  }",
    "comment": " This functions that may be called directly. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "InlineFunctions.findCalledFunctions",
    "class_name": "com.google.javascript.jscomp.InlineFunctions",
    "signature": "com.google.javascript.jscomp.InlineFunctions.findCalledFunctions(Node,Set)",
    "snippet": "  private void findCalledFunctions(\n      Node node, Set<String> changed) {\n    Preconditions.checkArgument(changed != null);\n    // For each referenced function, add a new reference\n    if (node.getType() == Token.NAME) {\n      if (isCandidateUsage(node)) {\n        changed.add(node.getString());\n      }\n    }\n\n    for (Node c = node.getFirstChild(); c != null; c = c.getNext()) {\n      findCalledFunctions(c, changed);\n    }\n  }",
    "comment": " @see #findCalledFunctions(Node) ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "InlineFunctions.getOrCreateFunctionState",
    "class_name": "com.google.javascript.jscomp.InlineFunctions",
    "signature": "com.google.javascript.jscomp.InlineFunctions.getOrCreateFunctionState(String)",
    "snippet": "  FunctionState getOrCreateFunctionState(String fnName) {\n    FunctionState fs = fns.get(fnName);\n    if (fs == null) {\n      fs = new FunctionState();\n      fns.put(fnName, fs);\n    }\n    return fs;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "InlineFunctions.inliningLowersCost",
    "class_name": "com.google.javascript.jscomp.InlineFunctions",
    "signature": "com.google.javascript.jscomp.InlineFunctions.inliningLowersCost(FunctionState)",
    "snippet": "  private boolean inliningLowersCost(FunctionState fs) {\n    return injector.inliningLowersCost(\n        fs.getModule(),\n        fs.getFn().getFunctionNode(),\n        fs.getReferences(),\n        fs.getNamesToAlias(),\n        fs.canRemove(),\n        fs.getReferencesThis());\n  }",
    "comment": " @return Whether inlining the function reduces code size. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "InlineFunctions.isCandidateFunction",
    "class_name": "com.google.javascript.jscomp.InlineFunctions",
    "signature": "com.google.javascript.jscomp.InlineFunctions.isCandidateFunction(Function)",
    "snippet": "  private boolean isCandidateFunction(Function fn) {\n    // Don't inline exported functions.\n    String fnName = fn.getName();\n    if (compiler.getCodingConvention().isExported(fnName)) {\n      // TODO(johnlenz): Should we allow internal references to be inlined?\n      // An exported name can be replaced externally, any inlined instance\n      // would not reflect this change.\n      // To allow inlining we need to be able to distinguish between exports\n      // that are used in a read-only fashion and those that can be replaced\n      // by external definitions.\n      return false;\n    }\n\n    // Don't inline this special function\n    if (RenameProperties.RENAME_PROPERTY_FUNCTION_NAME.equals(fnName)) {\n      return false;\n    }\n\n    // Don't inline if we are specializing and the function can't be fixed up\n    if (specializationState != null &&\n        !specializationState.canFixupFunction(fn.getFunctionNode())) {\n      return false;\n    }\n\n    Node fnNode = fn.getFunctionNode();\n    return injector.doesFunctionMeetMinimumRequirements(fnName, fnNode);\n  }",
    "comment": " Checks if the given function matches the criteria for an inlinable function. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "InlineFunctions.isCandidateUsage",
    "class_name": "com.google.javascript.jscomp.InlineFunctions",
    "signature": "com.google.javascript.jscomp.InlineFunctions.isCandidateUsage(Node)",
    "snippet": "  static boolean isCandidateUsage(Node name) {\n    Node parent = name.getParent();\n    Preconditions.checkState(name.getType() == Token.NAME);\n    if (parent.getType() == Token.VAR || parent.getType() == Token.FUNCTION) {\n      // This is a declaration.  Duplicate declarations are handle during\n      // function candidate gathering.\n      return true;\n    }\n\n    if (parent.getType() == Token.CALL && parent.getFirstChild() == name) {\n      // This is a normal reference to the function.\n      return true;\n    }\n\n    // Check for a \".call\" to the named function:\n    //   CALL\n    //     GETPROP/GETELEM\n    //       NAME\n    //       STRING == \"call\"\n    //     This-Value\n    //     Function-parameter-1\n    //     ...\n    if (NodeUtil.isGet(parent)\n         && name == parent.getFirstChild()\n         && name.getNext().getType() == Token.STRING\n         && name.getNext().getString().equals(\"call\")) {\n      Node gramps = name.getAncestor(2);\n      if (gramps.getType() == Token.CALL\n          && gramps.getFirstChild() == parent) {\n        // Yep, a \".call\".\n        return true;\n      }\n    }\n    return false;\n  }",
    "comment": " @return Whether the name is used in a way that might be a candidate for inlining. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "InlineFunctions.maybeAddFunction",
    "class_name": "com.google.javascript.jscomp.InlineFunctions",
    "signature": "com.google.javascript.jscomp.InlineFunctions.maybeAddFunction(Function,JSModule)",
    "snippet": "  private void maybeAddFunction(Function fn, JSModule module) {\n    String name = fn.getName();\n    FunctionState fs = getOrCreateFunctionState(name);\n\n    // TODO(johnlenz): Maybe \"smarten\" FunctionState by adding this logic\n    // to it?\n\n    // If the function has multiple definitions, don't inline it.\n    if (fs.hasExistingFunctionDefinition()) {\n      fs.setInline(false);\n    } else {\n      // verify the function hasn't already been marked as \"don't inline\"\n      if (fs.canInline()) {\n        // store it for use when inlining.\n        fs.setFn(fn);\n        if (injector.isDirectCallNodeReplacementPossible(\n            fn.getFunctionNode())) {\n          fs.inlineDirectly(true);\n        }\n\n        // verify the function meets all the requirements.\n        // TODO(johnlenz): Minimum requirement checks are about 5% of the\n        // runtime cost of this pass.\n        if (!isCandidateFunction(fn)) {\n          // It doesn't meet the requirements.\n          fs.setInline(false);\n        }\n\n        // Set the module and gather names that need temporaries.\n        if (fs.canInline()) {\n          fs.setModule(module);\n\n          Node fnNode = fn.getFunctionNode();\n          Set<String> namesToAlias =\n              FunctionArgumentInjector.findModifiedParameters(fnNode);\n          if (!namesToAlias.isEmpty()) {\n            fs.inlineDirectly(false);\n            fs.setNamesToAlias(namesToAlias);\n          }\n\n          Node block = NodeUtil.getFunctionBody(fnNode);\n          if (NodeUtil.referencesThis(block)) {\n            fs.setReferencesThis(true);\n          }\n\n          if (NodeUtil.containsFunction(block)) {\n            fs.setHasInnerFunctions(true);\n            // If there are inner functions, we can inline into global scope\n            // if there are no local vars or named functions.\n            // TODO(johnlenz): this can be improved by looking at the possible\n            // values for locals.  If there are simple values, or constants\n            // we could still inline.\n            if (hasLocalNames(fnNode)) {\n              fs.setInline(false);\n            }\n          }\n        }\n\n        // Check if block inlining is allowed.\n        if (fs.canInline() && !fs.canInlineDirectly()) {\n          if (!blockFunctionInliningEnabled) {\n            fs.setInline(false);\n          }\n        }\n      }\n    }\n  }",
    "comment": " Updates the FunctionState object for the given function. Checks if the given function matches the criteria for an inlinable function. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "InlineFunctions.mimimizeCost",
    "class_name": "com.google.javascript.jscomp.InlineFunctions",
    "signature": "com.google.javascript.jscomp.InlineFunctions.mimimizeCost(FunctionState)",
    "snippet": "  private boolean mimimizeCost(FunctionState fs) {\n    if (!inliningLowersCost(fs)) {\n      // Try again without Block inlining references\n      if (fs.hasBlockInliningReferences()) {\n        fs.setRemove(false);\n        fs.removeBlockInliningReferences();\n        if (!fs.hasReferences() || !inliningLowersCost(fs)) {\n          return false;\n        }\n      } else {\n        return false;\n      }\n    }\n    return true;\n  }",
    "comment": " Determines if the function is worth inlining and potentially trims references that increase the cost. @return Whether inlining the references lowers the overall cost. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "InlineFunctions.process",
    "class_name": "com.google.javascript.jscomp.InlineFunctions",
    "signature": "com.google.javascript.jscomp.InlineFunctions.process(Node,Node)",
    "snippet": "  @Override\n  public void process(Node externs, Node root) {\n    Preconditions.checkState(compiler.getLifeCycleStage().isNormalized());\n\n    NodeTraversal.traverse(compiler, root, new FindCandidateFunctions());\n    if (fns.isEmpty()) {\n      return;  // Nothing left to do.\n    }\n    NodeTraversal.traverse(compiler, root,\n       new FindCandidatesReferences(fns, anonFns));\n    trimCanidatesNotMeetingMinimumRequirements();\n    if (fns.isEmpty()) {\n      return;  // Nothing left to do.\n    }\n\n    // Store the set of function names eligible for inlining and use this to\n    // prevent function names from being moved into temporaries during\n    // expression decomposition. If this movement were allowed it would prevent\n    // the Inline callback from finding the function calls.\n    //\n    // This pass already assumes these are constants, so this is safe for anyone\n    // using function inlining.\n    //\n    Set<String> fnNames = Sets.newHashSet(fns.keySet());\n    injector.setKnownConstants(fnNames);\n\n    trimCanidatesUsingOnCost();\n    if (fns.isEmpty()) {\n      return;  // Nothing left to do.\n    }\n    resolveInlineConflicts();\n    decomposeExpressions(fnNames);\n    NodeTraversal.traverse(compiler, root,\n        new CallVisitor(\n            fns, anonFns, new Inline(injector, specializationState)));\n\n    removeInlinedFunctions();\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "InlineFunctions.removeInlinedFunctions",
    "class_name": "com.google.javascript.jscomp.InlineFunctions",
    "signature": "com.google.javascript.jscomp.InlineFunctions.removeInlinedFunctions()",
    "snippet": "  void removeInlinedFunctions() {\n    for (FunctionState fs : fns.values()) {\n      if (fs.canRemove()) {\n        Function fn = fs.getFn();\n        Preconditions.checkState(fs.canInline());\n        Preconditions.checkState(fn != null);\n        verifyAllReferencesInlined(fs);\n\n        if (specializationState != null) {\n          specializationState.reportRemovedFunction(\n              fn.getFunctionNode(), fn.getDeclaringBlock());\n        }\n\n        fn.remove();\n        compiler.reportCodeChange();\n      }\n    }\n  }",
    "comment": " Removed inlined functions that no longer have any references. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "InlineFunctions.resolveInlineConflicts",
    "class_name": "com.google.javascript.jscomp.InlineFunctions",
    "signature": "com.google.javascript.jscomp.InlineFunctions.resolveInlineConflicts()",
    "snippet": "  private void resolveInlineConflicts() {\n    for (FunctionState fs : fns.values()) {\n      resolveInlineConflictsForFunction(fs);\n    }\n  }",
    "comment": " Size base inlining calculations are thrown off when a function that is being inlined also contains calls to functions that are slated for inlining.  Specifically, a clone of the FUNCTION node tree is used when the function is inlined. Calls in this new tree are not included in the list of function references so they won't be inlined (which is what we want). Here we mark those functions as non-removable (as they will have new references in the cloned node trees).  This prevents a function that would only be inlined because it is referenced once from being inlined into multiple call sites because the calling function has been inlined in multiple locations or the function being removed while there are still references. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "InlineFunctions.resolveInlineConflictsForFunction",
    "class_name": "com.google.javascript.jscomp.InlineFunctions",
    "signature": "com.google.javascript.jscomp.InlineFunctions.resolveInlineConflictsForFunction(FunctionState)",
    "snippet": "  private void resolveInlineConflictsForFunction(FunctionState fs) {\n    // Functions that aren't referenced don't cause conflicts.\n    if (!fs.hasReferences()) {\n      return;\n    }\n\n    Node fnNode = fs.getFn().getFunctionNode();\n    Set<String> names = findCalledFunctions(fnNode);\n    if (!names.isEmpty()) {\n      // Prevent the removal of the referenced functions.\n      for (String name : names) {\n        FunctionState fsCalled = fns.get(name);\n        if (fsCalled != null && fsCalled.canRemove()) {\n          fsCalled.setRemove(false);\n          // For functions that can no longer be removed, check if they should\n          // still be inlined.\n          if (!mimimizeCost(fsCalled)) {\n            // It can't be inlined remove it from the list.\n            fsCalled.setInline(false);\n          }\n        }\n      }\n\n      // Make a copy of the Node, so it isn't changed by other inlines.\n      fs.setSafeFnNode(fs.getFn().getFunctionNode().cloneTree());\n    }\n  }",
    "comment": " @see #resolveInlineConflicts ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "InlineFunctions.trimCanidatesNotMeetingMinimumRequirements",
    "class_name": "com.google.javascript.jscomp.InlineFunctions",
    "signature": "com.google.javascript.jscomp.InlineFunctions.trimCanidatesNotMeetingMinimumRequirements()",
    "snippet": "  private void trimCanidatesNotMeetingMinimumRequirements() {\n   Iterator<Entry<String, FunctionState>> i;\n   for (i = fns.entrySet().iterator(); i.hasNext();) {\n     FunctionState fs = i.next().getValue();\n     if (!fs.hasExistingFunctionDefinition() || !fs.canInline()) {\n       i.remove();\n     }\n   }\n  }",
    "comment": " Remove entries that aren't a valid inline candidates, from the list of encountered names. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "InlineFunctions.trimCanidatesUsingOnCost",
    "class_name": "com.google.javascript.jscomp.InlineFunctions",
    "signature": "com.google.javascript.jscomp.InlineFunctions.trimCanidatesUsingOnCost()",
    "snippet": "  void trimCanidatesUsingOnCost() {\n    Iterator<Entry<String, FunctionState>> i;\n    for (i = fns.entrySet().iterator(); i.hasNext();) {\n      FunctionState fs = i.next().getValue();\n      if (fs.hasReferences()) {\n        // Only inline function if it decreases the code size.\n        boolean lowersCost = mimimizeCost(fs);\n        if (!lowersCost) {\n          // It shouldn't be inlined; remove it from the list.\n          i.remove();\n        }\n      } else if (!fs.canRemove()) {\n        // Don't bother tracking functions without references that can't be\n        // removed.\n        i.remove();\n      }\n    }\n  }",
    "comment": " Remove entries from the list of candidates that can't be inlined. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "InlineFunctions.verifyAllReferencesInlined",
    "class_name": "com.google.javascript.jscomp.InlineFunctions",
    "signature": "com.google.javascript.jscomp.InlineFunctions.verifyAllReferencesInlined(FunctionState)",
    "snippet": "  void verifyAllReferencesInlined(FunctionState fs) {\n    for (Reference ref : fs.getReferences()) {\n      if (!ref.inlined) {\n        throw new IllegalStateException(\"Call site missed.\\n call: \"\n            + ref.callNode.toStringTree() + \"\\n parent:  \"\n            + ref.callNode.getParent().toStringTree());\n      }\n    }\n  }",
    "comment": " Sanity check to verify, that expression rewriting didn't make a call inaccessible. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "CallVisitor.visit",
    "class_name": "com.google.javascript.jscomp.InlineFunctions$CallVisitor",
    "signature": "com.google.javascript.jscomp.InlineFunctions$CallVisitor.visit(NodeTraversal,Node,Node)",
    "snippet": "    public void visit(NodeTraversal t, Node n, Node parent) {\n      switch (n.getType()) {\n        // Function calls\n        case Token.CALL:\n          Node child = n.getFirstChild();\n          String name = null;\n          // NOTE: The normalization pass insures that local names do not\n          // collide with global names.\n          if (child.getType() == Token.NAME) {\n            name = child.getString();\n          } else if (child.getType() == Token.FUNCTION) {\n            name = anonFunctionMap.get(child);\n          } else if (NodeUtil.isFunctionObjectCall(n)) {\n            Preconditions.checkState(NodeUtil.isGet(child));\n            Node fnIdentifingNode = child.getFirstChild();\n            if (fnIdentifingNode.getType() == Token.NAME) {\n              name = fnIdentifingNode.getString();\n            } else if (fnIdentifingNode.getType() == Token.FUNCTION) {\n              name = anonFunctionMap.get(fnIdentifingNode);\n            }\n          }\n\n          if (name != null) {\n            FunctionState fs = functionMap.get(name);\n            // Only visit call-sites for functions that can be inlined.\n            if (fs != null) {\n              callback.visitCallSite(t, n, parent, fs);\n            }\n          }\n          break;\n      }\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "FindCandidateFunctions.findFunctionExpressions",
    "class_name": "com.google.javascript.jscomp.InlineFunctions$FindCandidateFunctions",
    "signature": "com.google.javascript.jscomp.InlineFunctions$FindCandidateFunctions.findFunctionExpressions(NodeTraversal,Node)",
    "snippet": "    public void findFunctionExpressions(NodeTraversal t, Node n) {\n      switch (n.getType()) {\n        // Functions expressions in the form of:\n        //   (function(){})();\n        case Token.CALL:\n          Node fnNode = null;\n          if (n.getFirstChild().getType() == Token.FUNCTION) {\n            fnNode = n.getFirstChild();\n          } else if (NodeUtil.isFunctionObjectCall(n)) {\n            Node fnIdentifingNode = n.getFirstChild().getFirstChild();\n            if (fnIdentifingNode.getType() == Token.FUNCTION) {\n              fnNode = fnIdentifingNode;\n            }\n          }\n\n          // If a interesting function was discovered, add it.\n          if (fnNode != null) {\n            Function fn = new FunctionExpression(fnNode, callsSeen++);\n            maybeAddFunction(fn, t.getModule());\n            anonFns.put(fnNode, fn.getName());\n          }\n          break;\n      }\n    }",
    "comment": " Find function expressions that are called directly in the form of (function(a,b,...){...})(a,b,...) or (function(a,b,...){...}).call(this,a,b, ...) ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "FindCandidateFunctions.findNamedFunctions",
    "class_name": "com.google.javascript.jscomp.InlineFunctions$FindCandidateFunctions",
    "signature": "com.google.javascript.jscomp.InlineFunctions$FindCandidateFunctions.findNamedFunctions(NodeTraversal,Node,Node)",
    "snippet": "    public void findNamedFunctions(NodeTraversal t, Node n, Node parent) {\n      if (!NodeUtil.isStatement(n)) {\n        // There aren't any interesting functions here.\n        return;\n      }\n\n      switch (n.getType()) {\n        // Functions expressions in the form of:\n        //   var fooFn = function(x) { return ... }\n        case Token.VAR:\n          Preconditions.checkState(n.hasOneChild());\n          Node nameNode = n.getFirstChild();\n          if (nameNode.getType() == Token.NAME && nameNode.hasChildren()\n              && nameNode.getFirstChild().getType() == Token.FUNCTION) {\n            maybeAddFunction(new FunctionVar(n), t.getModule());\n          }\n          break;\n\n        // Named functions\n        // function Foo(x) { return ... }\n        case Token.FUNCTION:\n          Preconditions.checkState(NodeUtil.isStatementBlock(parent)\n              || parent.getType() == Token.LABEL);\n          if (!NodeUtil.isFunctionExpression(n)) {\n            Function fn = new NamedFunction(n);\n            maybeAddFunction(fn, t.getModule());\n          }\n          break;\n      }\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "FindCandidateFunctions.shouldTraverse",
    "class_name": "com.google.javascript.jscomp.InlineFunctions$FindCandidateFunctions",
    "signature": "com.google.javascript.jscomp.InlineFunctions$FindCandidateFunctions.shouldTraverse(NodeTraversal,Node,Node)",
    "snippet": "    @Override\n    public boolean shouldTraverse(\n        NodeTraversal nodeTraversal, Node n, Node parent) {\n      // Don't traverse into function bodies\n      // if we aren't inlining local functions.\n      return inlineLocalFunctions || nodeTraversal.inGlobalScope();\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "FindCandidateFunctions.visit",
    "class_name": "com.google.javascript.jscomp.InlineFunctions$FindCandidateFunctions",
    "signature": "com.google.javascript.jscomp.InlineFunctions$FindCandidateFunctions.visit(NodeTraversal,Node,Node)",
    "snippet": "    public void visit(NodeTraversal t, Node n, Node parent) {\n      if ((t.inGlobalScope() && inlineGlobalFunctions)\n          || (!t.inGlobalScope() && inlineLocalFunctions)) {\n        findNamedFunctions(t, n, parent);\n\n        findFunctionExpressions(t, n);\n      }\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "FindCandidatesReferences.checkNameUsage",
    "class_name": "com.google.javascript.jscomp.InlineFunctions$FindCandidatesReferences",
    "signature": "com.google.javascript.jscomp.InlineFunctions$FindCandidatesReferences.checkNameUsage(NodeTraversal,Node,Node)",
    "snippet": "    private void checkNameUsage(NodeTraversal t, Node n, Node parent) {\n      Preconditions.checkState(n.getType() == Token.NAME);\n\n      if (isCandidateUsage(n)) {\n        return;\n      }\n\n      // Other refs to a function name remove its candidacy for inlining\n      String name = n.getString();\n      FunctionState fs = fns.get(name);\n      if (fs == null) {\n        return;\n      }\n\n      // Unlike normal call/new parameters, references passed to\n      // JSCompiler_ObjectPropertyString are not aliases of a value, but\n      // a reference to the name itself, as such the value of the name is\n      // unknown and can not be inlined.\n      if (parent.getType() == Token.NEW) {\n        Node target = parent.getFirstChild();\n        if (target.getType() == Token.NAME && target.getString().equals(\n            ObjectPropertyStringPreprocess.EXTERN_OBJECT_PROPERTY_STRING)) {\n          // This method is going to be replaced so don't inline it anywhere.\n          fs.setInline(false);\n        }\n      }\n\n      // If the name is being assigned to it can not be inlined.\n      if (parent.getType() == Token.ASSIGN && parent.getFirstChild() == n) {\n        // e.g. bar = something; <== we can't inline \"bar\"\n        // so mark the function as uninlinable.\n        // TODO(johnlenz): Should we just remove it from fns here?\n        fs.setInline(false);\n      } else {\n        // e.g. var fn = bar; <== we can't inline \"bar\"\n        // As this reference can't be inlined mark the function as\n        // unremovable.\n        fs.setRemove(false);\n      }\n    }",
    "comment": " Find functions that can be inlined. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "FindCandidatesReferences.maybeAddReference",
    "class_name": "com.google.javascript.jscomp.InlineFunctions$FindCandidatesReferences",
    "signature": "com.google.javascript.jscomp.InlineFunctions$FindCandidatesReferences.maybeAddReference(NodeTraversal,FunctionState,Node,JSModule)",
    "snippet": "    void maybeAddReference(NodeTraversal t, FunctionState fs,\n        Node callNode, JSModule module) {\n      if (!fs.canInline()) {\n        return;\n      }\n\n      boolean referenceAdded = false;\n      InliningMode mode = fs.canInlineDirectly()\n           ? InliningMode.DIRECT : InliningMode.BLOCK;\n      referenceAdded = maybeAddReferenceUsingMode(\n          t, fs, callNode, module, mode);\n      if (!referenceAdded &&\n          mode == InliningMode.DIRECT && blockFunctionInliningEnabled) {\n        // This reference can not be directly inlined, see if\n        // block replacement inlining is possible.\n        mode = InliningMode.BLOCK;\n        referenceAdded = maybeAddReferenceUsingMode(\n            t, fs, callNode, module, mode);\n      }\n\n      if (!referenceAdded) {\n        // Don't try to remove a function if we can't inline all\n        // the references.\n        fs.setRemove(false);\n      }\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "FindCandidatesReferences.maybeAddReferenceUsingMode",
    "class_name": "com.google.javascript.jscomp.InlineFunctions$FindCandidatesReferences",
    "signature": "com.google.javascript.jscomp.InlineFunctions$FindCandidatesReferences.maybeAddReferenceUsingMode(NodeTraversal,FunctionState,Node,JSModule,InliningMode)",
    "snippet": "    private boolean maybeAddReferenceUsingMode(\n        NodeTraversal t, FunctionState fs, Node callNode,\n        JSModule module, InliningMode mode) {\n\n      if (specializationState != null) {\n        // If we're specializing, make sure we can fixup\n        // the containing function before inlining\n        Node containingFunction = getContainingFunction(t);\n        if (containingFunction != null && !specializationState.canFixupFunction(\n            containingFunction)) {\n            return false;\n        }\n      }\n\n      CanInlineResult result = injector.canInlineReferenceToFunction(\n          t, callNode, fs.getFn().getFunctionNode(),\n          fs.getNamesToAlias(), mode, fs.getReferencesThis(),\n          fs.hasInnerFunctions());\n      if (result != CanInlineResult.NO) {\n        // Yeah!\n        boolean decompose =\n          (result == CanInlineResult.AFTER_DECOMPOSITION);\n        fs.addReference(new Reference(callNode, module, mode, decompose));\n        return true;\n      }\n\n      return false;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "FindCandidatesReferences.visit",
    "class_name": "com.google.javascript.jscomp.InlineFunctions$FindCandidatesReferences",
    "signature": "com.google.javascript.jscomp.InlineFunctions$FindCandidatesReferences.visit(NodeTraversal,Node,Node)",
    "snippet": "    @Override\n    public void visit(NodeTraversal t, Node n, Node parent) {\n      super.visit(t, n, parent);\n      if (n.getType() == Token.NAME) {\n        checkNameUsage(t, n, parent);\n      }\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "FindCandidatesReferences.visitCallSite",
    "class_name": "com.google.javascript.jscomp.InlineFunctions$FindCandidatesReferences",
    "signature": "com.google.javascript.jscomp.InlineFunctions$FindCandidatesReferences.visitCallSite(NodeTraversal,Node,Node,FunctionState)",
    "snippet": "    public void visitCallSite(\n        NodeTraversal t, Node callNode, Node parent, FunctionState fs) {\n      maybeAddReference(t, fs, callNode, t.getModule());\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "FunctionState.addReference",
    "class_name": "com.google.javascript.jscomp.InlineFunctions$FunctionState",
    "signature": "com.google.javascript.jscomp.InlineFunctions$FunctionState.addReference(Reference)",
    "snippet": "    public void addReference(Reference ref) {\n      if (references == null) {\n        references = Maps.newHashMap();\n      }\n      references.put(ref.callNode, ref);\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "FunctionState.canInline",
    "class_name": "com.google.javascript.jscomp.InlineFunctions$FunctionState",
    "signature": "com.google.javascript.jscomp.InlineFunctions$FunctionState.canInline()",
    "snippet": "    public boolean canInline() {\n      return inline;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "FunctionState.canInlineDirectly",
    "class_name": "com.google.javascript.jscomp.InlineFunctions$FunctionState",
    "signature": "com.google.javascript.jscomp.InlineFunctions$FunctionState.canInlineDirectly()",
    "snippet": "    public boolean canInlineDirectly() {\n      return inlineDirectly;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "FunctionState.canRemove",
    "class_name": "com.google.javascript.jscomp.InlineFunctions$FunctionState",
    "signature": "com.google.javascript.jscomp.InlineFunctions$FunctionState.canRemove()",
    "snippet": "    public boolean canRemove() {\n      return remove;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "FunctionState.getFn",
    "class_name": "com.google.javascript.jscomp.InlineFunctions$FunctionState",
    "signature": "com.google.javascript.jscomp.InlineFunctions$FunctionState.getFn()",
    "snippet": "    public Function getFn() {\n      return fn;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "FunctionState.getModule",
    "class_name": "com.google.javascript.jscomp.InlineFunctions$FunctionState",
    "signature": "com.google.javascript.jscomp.InlineFunctions$FunctionState.getModule()",
    "snippet": "    public JSModule getModule() {\n      return module;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "FunctionState.getNamesToAlias",
    "class_name": "com.google.javascript.jscomp.InlineFunctions$FunctionState",
    "signature": "com.google.javascript.jscomp.InlineFunctions$FunctionState.getNamesToAlias()",
    "snippet": "    public Set<String> getNamesToAlias() {\n      if (namesToAlias == null) {\n        return Collections.emptySet();\n      }\n      return Collections.unmodifiableSet(namesToAlias);\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "FunctionState.getReference",
    "class_name": "com.google.javascript.jscomp.InlineFunctions$FunctionState",
    "signature": "com.google.javascript.jscomp.InlineFunctions$FunctionState.getReference(Node)",
    "snippet": "    public Reference getReference(Node n) {\n      return getReferencesInternal().get(n);\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "FunctionState.getReferences",
    "class_name": "com.google.javascript.jscomp.InlineFunctions$FunctionState",
    "signature": "com.google.javascript.jscomp.InlineFunctions$FunctionState.getReferences()",
    "snippet": "    public Collection<Reference> getReferences() {\n      return getReferencesInternal().values();\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "FunctionState.getReferencesInternal",
    "class_name": "com.google.javascript.jscomp.InlineFunctions$FunctionState",
    "signature": "com.google.javascript.jscomp.InlineFunctions$FunctionState.getReferencesInternal()",
    "snippet": "    private Map<Node, Reference> getReferencesInternal() {\n      if (references == null) {\n        return Collections.emptyMap();\n      }\n      return references;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "FunctionState.getReferencesThis",
    "class_name": "com.google.javascript.jscomp.InlineFunctions$FunctionState",
    "signature": "com.google.javascript.jscomp.InlineFunctions$FunctionState.getReferencesThis()",
    "snippet": "    public boolean getReferencesThis() {\n      return this.referencesThis;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "FunctionState.getSafeFnNode",
    "class_name": "com.google.javascript.jscomp.InlineFunctions$FunctionState",
    "signature": "com.google.javascript.jscomp.InlineFunctions$FunctionState.getSafeFnNode()",
    "snippet": "    public Node getSafeFnNode() {\n      return (safeFnNode != null) ? safeFnNode : fn.getFunctionNode();\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "FunctionState.hasExistingFunctionDefinition",
    "class_name": "com.google.javascript.jscomp.InlineFunctions$FunctionState",
    "signature": "com.google.javascript.jscomp.InlineFunctions$FunctionState.hasExistingFunctionDefinition()",
    "snippet": "    boolean hasExistingFunctionDefinition() {\n      return (fn != null);\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "FunctionState.hasInnerFunctions",
    "class_name": "com.google.javascript.jscomp.InlineFunctions$FunctionState",
    "signature": "com.google.javascript.jscomp.InlineFunctions$FunctionState.hasInnerFunctions()",
    "snippet": "    public boolean hasInnerFunctions() {\n      return hasInnerFunctions;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "FunctionState.hasReferences",
    "class_name": "com.google.javascript.jscomp.InlineFunctions$FunctionState",
    "signature": "com.google.javascript.jscomp.InlineFunctions$FunctionState.hasReferences()",
    "snippet": "    public boolean hasReferences() {\n      return (references != null && !references.isEmpty());\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "FunctionState.setFn",
    "class_name": "com.google.javascript.jscomp.InlineFunctions$FunctionState",
    "signature": "com.google.javascript.jscomp.InlineFunctions$FunctionState.setFn(Function)",
    "snippet": "    public void setFn(Function fn) {\n      Preconditions.checkState(this.fn == null);\n      this.fn = fn;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "FunctionState.setModule",
    "class_name": "com.google.javascript.jscomp.InlineFunctions$FunctionState",
    "signature": "com.google.javascript.jscomp.InlineFunctions$FunctionState.setModule(JSModule)",
    "snippet": "    public void setModule(JSModule module) {\n      this.module = module;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "Inline.inlineFunction",
    "class_name": "com.google.javascript.jscomp.InlineFunctions$Inline",
    "signature": "com.google.javascript.jscomp.InlineFunctions$Inline.inlineFunction(NodeTraversal,Node,FunctionState,InliningMode)",
    "snippet": "    private void inlineFunction(\n        NodeTraversal t, Node callNode, FunctionState fs, InliningMode mode) {\n      Function fn = fs.getFn();\n      String fnName = fn.getName();\n      Node fnNode = fs.getSafeFnNode();\n\n      Node newCode = injector.inline(t, callNode, fnName, fnNode, mode);\n      t.getCompiler().reportCodeChange();\n      t.getCompiler().addToDebugLog(\"Inlined function: \" + fn.getName());\n    }",
    "comment": " Inline a function into the call site. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "Inline.visitCallSite",
    "class_name": "com.google.javascript.jscomp.InlineFunctions$Inline",
    "signature": "com.google.javascript.jscomp.InlineFunctions$Inline.visitCallSite(NodeTraversal,Node,Node,FunctionState)",
    "snippet": "    public void visitCallSite(\n        NodeTraversal t, Node callNode, Node parent, FunctionState fs) {\n      Preconditions.checkState(fs.hasExistingFunctionDefinition());\n      if (fs.canInline()) {\n        Reference ref = fs.getReference(callNode);\n        // There are two cases ref can be null: if the call site was introduce\n        // because it was part of a function that was inlined during this pass\n        // or if the call site was trimmed from the list of references because\n        // the function couldn't be inlined at this location.\n        if (ref != null) {\n          if (specializationState != null) {\n            Node containingFunction = getContainingFunction(t);\n\n            if (containingFunction != null) {\n              // Report that the function was specialized so that\n              // {@link SpecializeModule} can fix it up.\n              specializationState.reportSpecializedFunction(containingFunction);\n            }\n          }\n\n          inlineFunction(t, callNode, fs, ref.mode);\n          // Keep track of references that have been inlined so that\n          // we can verify that none have been missed.\n          ref.inlined = true;\n        }\n      }\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "NamedFunction.getFunctionNode",
    "class_name": "com.google.javascript.jscomp.InlineFunctions$NamedFunction",
    "signature": "com.google.javascript.jscomp.InlineFunctions$NamedFunction.getFunctionNode()",
    "snippet": "    public Node getFunctionNode() {\n      return fn;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "NamedFunction.getName",
    "class_name": "com.google.javascript.jscomp.InlineFunctions$NamedFunction",
    "signature": "com.google.javascript.jscomp.InlineFunctions$NamedFunction.getName()",
    "snippet": "    public String getName() {\n      return fn.getFirstChild().getString();\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "NamedFunction.remove",
    "class_name": "com.google.javascript.jscomp.InlineFunctions$NamedFunction",
    "signature": "com.google.javascript.jscomp.InlineFunctions$NamedFunction.remove()",
    "snippet": "    public void remove() {\n      NodeUtil.removeChild(fn.getParent(), fn);\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "JSModule.JSModule",
    "class_name": "com.google.javascript.jscomp.JSModule",
    "signature": "com.google.javascript.jscomp.JSModule.JSModule(String)",
    "snippet": "  public JSModule(String name) {\n    this.name = name;\n    this.depth = -1;\n  }",
    "comment": " Creates an instance.  @param name A unique name for the module ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "JSModule.add",
    "class_name": "com.google.javascript.jscomp.JSModule",
    "signature": "com.google.javascript.jscomp.JSModule.add(CompilerInput)",
    "snippet": "  public void add(CompilerInput input) {\n    inputs.add(input);\n    input.setModule(this);\n  }",
    "comment": "Adds a source code input to this module. */",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "JSModule.add",
    "class_name": "com.google.javascript.jscomp.JSModule",
    "signature": "com.google.javascript.jscomp.JSModule.add(JSSourceFile)",
    "snippet": "  public void add(JSSourceFile file) {\n    add(new CompilerInput(file));\n  }",
    "comment": "Adds a source file input to this module. */",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "JSModule.getInputs",
    "class_name": "com.google.javascript.jscomp.JSModule",
    "signature": "com.google.javascript.jscomp.JSModule.getInputs()",
    "snippet": "  public List<CompilerInput> getInputs() {\n    return inputs;\n  }",
    "comment": " Gets this module's list of source code inputs.  @return A list that may be empty but not null ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "JSSourceFile.fromCode",
    "class_name": "com.google.javascript.jscomp.JSSourceFile",
    "signature": "com.google.javascript.jscomp.JSSourceFile.fromCode(String,String)",
    "snippet": "  public static JSSourceFile fromCode(String fileName, String code) {\n    return new JSSourceFile(SourceFile.fromCode(fileName, code));\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "JSSourceFile.getCode",
    "class_name": "com.google.javascript.jscomp.JSSourceFile",
    "signature": "com.google.javascript.jscomp.JSSourceFile.getCode()",
    "snippet": "  @Override\n  public String getCode() throws IOException {\n    return referenced.getCode();\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "JsAst.JsAst",
    "class_name": "com.google.javascript.jscomp.JsAst",
    "signature": "com.google.javascript.jscomp.JsAst.JsAst(SourceFile)",
    "snippet": "  public JsAst(SourceFile sourceFile) {\n    this.sourceFile = sourceFile;\n    this.fileName = sourceFile.getName();\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "JsAst.createAst",
    "class_name": "com.google.javascript.jscomp.JsAst",
    "signature": "com.google.javascript.jscomp.JsAst.createAst(AbstractCompiler)",
    "snippet": "  private void createAst(AbstractCompiler compiler) {\n    try {\n      parse(compiler, sourceFile.getName(), sourceFile.getCode());\n    } catch (IOException e) {\n      compiler.report(\n          JSError.make(AbstractCompiler.READ_ERROR, sourceFile.getName()));\n    }\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "JsAst.getAstRoot",
    "class_name": "com.google.javascript.jscomp.JsAst",
    "signature": "com.google.javascript.jscomp.JsAst.getAstRoot(AbstractCompiler)",
    "snippet": "  @Override\n  public Node getAstRoot(AbstractCompiler compiler) {\n    if (root == null) {\n      createAst(compiler);\n    }\n    return root;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "JsAst.parse",
    "class_name": "com.google.javascript.jscomp.JsAst",
    "signature": "com.google.javascript.jscomp.JsAst.parse(AbstractCompiler,String,String)",
    "snippet": "  private void parse(AbstractCompiler compiler, String sourceName,\n      String sourceStr) {\n    try {\n      logger_.fine(\"Parsing: \" + sourceName);\n      root = ParserRunner.parse(sourceName, sourceStr,\n          compiler.getParserConfig(),\n          compiler.getDefaultErrorReporter(),\n          logger_);\n    } catch (IOException e) {\n      compiler.report(JSError.make(AbstractCompiler.READ_ERROR, sourceName));\n    }\n\n    if (root == null || compiler.hasHaltingErrors()) {\n      // There was a parse error or IOException, so use a dummy block.\n      root = new Node(Token.BLOCK);\n    } else {\n      compiler.prepareAst(root);\n    }\n\n    // Set the source name so that the compiler passes can track\n    // the source file and module.\n    root.putProp(Node.SOURCENAME_PROP, sourceName);\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "LightweightMessageFormatter.LightweightMessageFormatter",
    "class_name": "com.google.javascript.jscomp.LightweightMessageFormatter",
    "signature": "com.google.javascript.jscomp.LightweightMessageFormatter.LightweightMessageFormatter(SourceExcerptProvider)",
    "snippet": "  public LightweightMessageFormatter(SourceExcerptProvider source) {\n    this(source, LINE);\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "LightweightMessageFormatter.LightweightMessageFormatter",
    "class_name": "com.google.javascript.jscomp.LightweightMessageFormatter",
    "signature": "com.google.javascript.jscomp.LightweightMessageFormatter.LightweightMessageFormatter(SourceExcerptProvider,SourceExcerpt)",
    "snippet": "  public LightweightMessageFormatter(SourceExcerptProvider source,\n      SourceExcerpt excerpt) {\n    super(source);\n    Preconditions.checkNotNull(source);\n    this.excerpt = excerpt;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "LineNumberCheck.LineNumberCheck",
    "class_name": "com.google.javascript.jscomp.LineNumberCheck",
    "signature": "com.google.javascript.jscomp.LineNumberCheck.LineNumberCheck(AbstractCompiler)",
    "snippet": "  LineNumberCheck(AbstractCompiler compiler) {\n    this.compiler = compiler;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "LineNumberCheck.process",
    "class_name": "com.google.javascript.jscomp.LineNumberCheck",
    "signature": "com.google.javascript.jscomp.LineNumberCheck.process(Node,Node)",
    "snippet": "  public void process(Node externs, Node root) {\n    requiresLineNumbers = false;\n\n    NodeTraversal.traverse(compiler, root, this);\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "LineNumberCheck.shouldTraverse",
    "class_name": "com.google.javascript.jscomp.LineNumberCheck",
    "signature": "com.google.javascript.jscomp.LineNumberCheck.shouldTraverse(NodeTraversal,Node,Node)",
    "snippet": "  public boolean shouldTraverse(NodeTraversal t, Node n, Node parent) {\n    // Each JavaScript file is rooted in a script node, so we'll only\n    // have line number information inside the script node.\n    if (n.getType() == Token.SCRIPT) {\n      requiresLineNumbers = true;\n    }\n    return true;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "LineNumberCheck.visit",
    "class_name": "com.google.javascript.jscomp.LineNumberCheck",
    "signature": "com.google.javascript.jscomp.LineNumberCheck.visit(NodeTraversal,Node,Node)",
    "snippet": "  public void visit(NodeTraversal t, Node n, Node parent) {\n    if (n.getType() == Token.SCRIPT) {\n      requiresLineNumbers = false;\n    } else if (requiresLineNumbers) {\n      if (n.getLineno() == -1) {\n        // The tree version of the node is really the best diagnostic\n        // info we have to offer here.\n        compiler.report(\n            t.makeError(n, MISSING_LINE_INFO,\n                n.toStringTree()));\n      }\n    }\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "LoggerErrorManager.LoggerErrorManager",
    "class_name": "com.google.javascript.jscomp.LoggerErrorManager",
    "signature": "com.google.javascript.jscomp.LoggerErrorManager.LoggerErrorManager(MessageFormatter,Logger)",
    "snippet": "  public LoggerErrorManager(MessageFormatter formatter, Logger logger) {\n    this.formatter = formatter;\n    this.logger = logger;\n  }",
    "comment": " Creates an instance. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "MakeDeclaredNamesUnique.MakeDeclaredNamesUnique",
    "class_name": "com.google.javascript.jscomp.MakeDeclaredNamesUnique",
    "signature": "com.google.javascript.jscomp.MakeDeclaredNamesUnique.MakeDeclaredNamesUnique()",
    "snippet": "  MakeDeclaredNamesUnique() {\n    this(new ContextualRenamer());\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "MakeDeclaredNamesUnique.MakeDeclaredNamesUnique",
    "class_name": "com.google.javascript.jscomp.MakeDeclaredNamesUnique",
    "signature": "com.google.javascript.jscomp.MakeDeclaredNamesUnique.MakeDeclaredNamesUnique(Renamer)",
    "snippet": "  MakeDeclaredNamesUnique(Renamer renamer) {\n    this.rootRenamer = renamer;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "MakeDeclaredNamesUnique.enterScope",
    "class_name": "com.google.javascript.jscomp.MakeDeclaredNamesUnique",
    "signature": "com.google.javascript.jscomp.MakeDeclaredNamesUnique.enterScope(NodeTraversal)",
    "snippet": "  @Override\n  public void enterScope(NodeTraversal t) {\n    Node declarationRoot = t.getScopeRoot();\n    Renamer renamer;\n    if (nameStack.isEmpty()) {\n      // If the contextual renamer is being used the starting context can not\n      // be a function.\n      Preconditions.checkState(\n          declarationRoot.getType() != Token.FUNCTION ||\n          !(rootRenamer instanceof ContextualRenamer));\n      Preconditions.checkState(t.inGlobalScope());\n      renamer = rootRenamer;\n    } else {\n      renamer = nameStack.peek().forChildScope();\n    }\n\n    if (declarationRoot.getType() == Token.FUNCTION) {\n      // Add the function parameters\n      Node fnParams = declarationRoot.getFirstChild().getNext();\n      for (Node c = fnParams.getFirstChild(); c != null; c = c.getNext()) {\n        String name = c.getString();\n        renamer.addDeclaredName(name);\n      }\n\n      // Add the function body declarations\n      Node functionBody = declarationRoot.getLastChild();\n      findDeclaredNames(functionBody, null, renamer);\n    } else {\n      // Add the block declarations\n      findDeclaredNames(declarationRoot, null, renamer);\n    }\n    nameStack.push(renamer);\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "MakeDeclaredNamesUnique.exitScope",
    "class_name": "com.google.javascript.jscomp.MakeDeclaredNamesUnique",
    "signature": "com.google.javascript.jscomp.MakeDeclaredNamesUnique.exitScope(NodeTraversal)",
    "snippet": "  @Override\n  public void exitScope(NodeTraversal t) {\n    if (!t.inGlobalScope()) {\n      nameStack.pop();\n    }\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "MakeDeclaredNamesUnique.findDeclaredNames",
    "class_name": "com.google.javascript.jscomp.MakeDeclaredNamesUnique",
    "signature": "com.google.javascript.jscomp.MakeDeclaredNamesUnique.findDeclaredNames(Node,Node,Renamer)",
    "snippet": "  private void findDeclaredNames(Node n, Node parent, Renamer renamer) {\n    // Do a shallow traversal, so don't traverse into function declarations,\n    // except for the name of the function itself.\n    if (parent == null\n        || parent.getType() != Token.FUNCTION\n        || n == parent.getFirstChild()) {\n      if (NodeUtil.isVarDeclaration(n)) {\n        renamer.addDeclaredName(n.getString());\n      } else if (NodeUtil.isFunctionDeclaration(n)) {\n        Node nameNode = n.getFirstChild();\n        renamer.addDeclaredName(nameNode.getString());\n      }\n\n      for (Node c = n.getFirstChild(); c != null; c = c.getNext()) {\n        findDeclaredNames(c, n, renamer);\n      }\n    }\n  }",
    "comment": " Traverses the current scope and collects declared names.  Does not decent into functions or add CATCH exceptions. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "MakeDeclaredNamesUnique.getReplacementName",
    "class_name": "com.google.javascript.jscomp.MakeDeclaredNamesUnique",
    "signature": "com.google.javascript.jscomp.MakeDeclaredNamesUnique.getReplacementName(String)",
    "snippet": "  private String getReplacementName(String oldName) {\n    for (Renamer names : nameStack) {\n      String newName = names.getReplacementName(oldName);\n      if (newName != null) {\n        return newName;\n      }\n    }\n    return null;\n  }",
    "comment": " Walks the stack of name maps and finds the replacement name for the current scope. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "MakeDeclaredNamesUnique.shouldTraverse",
    "class_name": "com.google.javascript.jscomp.MakeDeclaredNamesUnique",
    "signature": "com.google.javascript.jscomp.MakeDeclaredNamesUnique.shouldTraverse(NodeTraversal,Node,Node)",
    "snippet": "  @Override\n  public boolean shouldTraverse(NodeTraversal t, Node n, Node parent) {\n\n    switch (n.getType()) {\n      case Token.FUNCTION:\n        {\n          // Add recursive function name, if needed.\n          // NOTE: \"enterScope\" is called after we need to pick up this name.\n          Renamer renamer = nameStack.peek().forChildScope();\n\n          // If needed, add the function recursive name.\n          String name = n.getFirstChild().getString();\n          if (name != null && !name.isEmpty() && parent != null\n              && !NodeUtil.isFunctionDeclaration(n)) {\n            renamer.addDeclaredName(name);\n          }\n\n          nameStack.push(renamer);\n        }\n        break;\n\n      case Token.CATCH:\n        {\n          Renamer renamer = nameStack.peek().forChildScope();\n\n          String name = n.getFirstChild().getString();\n          renamer.addDeclaredName(name);\n\n          nameStack.push(renamer);\n        }\n        break;\n    }\n\n    return true;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "MakeDeclaredNamesUnique.visit",
    "class_name": "com.google.javascript.jscomp.MakeDeclaredNamesUnique",
    "signature": "com.google.javascript.jscomp.MakeDeclaredNamesUnique.visit(NodeTraversal,Node,Node)",
    "snippet": "  @Override\n  public void visit(NodeTraversal t, Node n, Node parent) {\n    switch (n.getType()) {\n      case Token.NAME:\n        String newName = getReplacementName(n.getString());\n        if (newName != null) {\n          Renamer renamer = nameStack.peek();\n          if (renamer.stripConstIfReplaced()) {\n            // TODO(johnlenz): Do we need to do anything about the javadoc?\n            n.removeProp(Node.IS_CONSTANT_NAME);\n          }\n          n.setString(newName);\n          t.getCompiler().reportCodeChange();\n        }\n        break;\n\n      case Token.FUNCTION:\n        // Remove function recursive name (if any).\n        nameStack.pop();\n        break;\n\n      case Token.CATCH:\n        // Remove catch except name from the stack of names.\n        nameStack.pop();\n        break;\n    }\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "ContextualRenamer.addDeclaredName",
    "class_name": "com.google.javascript.jscomp.MakeDeclaredNamesUnique$ContextualRenamer",
    "signature": "com.google.javascript.jscomp.MakeDeclaredNamesUnique$ContextualRenamer.addDeclaredName(String)",
    "snippet": "    @Override\n    public void addDeclaredName(String name) {\n      if (!name.equals(ARGUMENTS)) {\n        if (global) {\n          reserveName(name);\n        } else {\n          // It hasn't been declared locally yet, so increment the count.\n          if (!declarations.containsKey(name)) {\n            int id = incrementNameCount(name);\n            String newName = null;\n            if (id != 0) {\n              newName = getUniqueName(name, id);\n            }\n            declarations.put(name, newName);\n          }\n        }\n      }\n    }",
    "comment": " Adds a name to the map of names declared in this scope. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "ContextualRenamer.forChildScope",
    "class_name": "com.google.javascript.jscomp.MakeDeclaredNamesUnique$ContextualRenamer",
    "signature": "com.google.javascript.jscomp.MakeDeclaredNamesUnique$ContextualRenamer.forChildScope()",
    "snippet": "    @Override\n    public Renamer forChildScope() {\n      return new ContextualRenamer(nameUsage);\n    }",
    "comment": " Create a ContextualRenamer ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "ContextualRenamer.getReplacementName",
    "class_name": "com.google.javascript.jscomp.MakeDeclaredNamesUnique$ContextualRenamer",
    "signature": "com.google.javascript.jscomp.MakeDeclaredNamesUnique$ContextualRenamer.getReplacementName(String)",
    "snippet": "    @Override\n    public String getReplacementName(String oldName) {\n      return declarations.get(oldName);\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "ContextualRenamer.reserveName",
    "class_name": "com.google.javascript.jscomp.MakeDeclaredNamesUnique$ContextualRenamer",
    "signature": "com.google.javascript.jscomp.MakeDeclaredNamesUnique$ContextualRenamer.reserveName(String)",
    "snippet": "    private void reserveName(String name) {\n      nameUsage.setCount(name, 0, 1);\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "InlineRenamer.forChildScope",
    "class_name": "com.google.javascript.jscomp.MakeDeclaredNamesUnique$InlineRenamer",
    "signature": "com.google.javascript.jscomp.MakeDeclaredNamesUnique$InlineRenamer.forChildScope()",
    "snippet": "    @Override\n    public Renamer forChildScope() {\n      return new InlineRenamer(uniqueIdSupplier, idPrefix, removeConstness);\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "InlineRenamer.getReplacementName",
    "class_name": "com.google.javascript.jscomp.MakeDeclaredNamesUnique$InlineRenamer",
    "signature": "com.google.javascript.jscomp.MakeDeclaredNamesUnique$InlineRenamer.getReplacementName(String)",
    "snippet": "    @Override\n    public String getReplacementName(String oldName) {\n      return declarations.get(oldName);\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "MarkNoSideEffectCalls.MarkNoSideEffectCalls",
    "class_name": "com.google.javascript.jscomp.MarkNoSideEffectCalls",
    "signature": "com.google.javascript.jscomp.MarkNoSideEffectCalls.MarkNoSideEffectCalls(AbstractCompiler)",
    "snippet": "  MarkNoSideEffectCalls(AbstractCompiler compiler) {\n    this.compiler = compiler;\n    this.noSideEffectFunctionNames = Sets.newHashSet();\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "MarkNoSideEffectCalls.definitionTypeContainsFunctionType",
    "class_name": "com.google.javascript.jscomp.MarkNoSideEffectCalls",
    "signature": "com.google.javascript.jscomp.MarkNoSideEffectCalls.definitionTypeContainsFunctionType(Definition)",
    "snippet": "  private static boolean definitionTypeContainsFunctionType(Definition def) {\n    Node rhs = def.getRValue();\n    if (rhs == null) {\n      return true;\n    }\n\n    switch (rhs.getType()) {\n      case Token.ASSIGN:\n      case Token.AND:\n      case Token.CALL:\n      case Token.GETPROP:\n      case Token.GETELEM:\n      case Token.FUNCTION:\n      case Token.HOOK:\n      case Token.NAME:\n      case Token.NEW:\n      case Token.OR:\n        return true;\n      default:\n        return false;\n    }\n  }",
    "comment": " Determines if the type of the value of the rhs expression can be a function node. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "MarkNoSideEffectCalls.hasNoSideEffectsAnnotation",
    "class_name": "com.google.javascript.jscomp.MarkNoSideEffectCalls",
    "signature": "com.google.javascript.jscomp.MarkNoSideEffectCalls.hasNoSideEffectsAnnotation(Node)",
    "snippet": "  private static boolean hasNoSideEffectsAnnotation(Node node) {\n    JSDocInfo docInfo = node.getJSDocInfo();\n    return docInfo != null && docInfo.isNoSideEffects();\n  }",
    "comment": " Get the value of the @nosideeffects annotation stored in the doc info. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "MarkNoSideEffectCalls.process",
    "class_name": "com.google.javascript.jscomp.MarkNoSideEffectCalls",
    "signature": "com.google.javascript.jscomp.MarkNoSideEffectCalls.process(Node,Node)",
    "snippet": "  @Override\n  public void process(Node externs, Node root) {\n    SimpleDefinitionFinder defFinder = new SimpleDefinitionFinder(compiler);\n    defFinder.process(externs, root);\n\n    // Gather the list of function nodes that have @nosideeffect annotations.\n    // For use by SetNoSideEffectCallProperty.\n    NodeTraversal.traverse(\n        compiler, externs, new GatherNoSideEffectFunctions(true));\n    NodeTraversal.traverse(\n        compiler, root, new GatherNoSideEffectFunctions(false));\n\n    NodeTraversal.traverse(compiler, root,\n                           new SetNoSideEffectCallProperty(defFinder));\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "GatherNoSideEffectFunctions.visit",
    "class_name": "com.google.javascript.jscomp.MarkNoSideEffectCalls$GatherNoSideEffectFunctions",
    "signature": "com.google.javascript.jscomp.MarkNoSideEffectCalls$GatherNoSideEffectFunctions.visit(NodeTraversal,Node,Node)",
    "snippet": "    @Override\n    public void visit(NodeTraversal traversal, Node node, Node parent) {\n      if (!inExterns && hasNoSideEffectsAnnotation(node)) {\n        traversal.report(node, INVALID_NO_SIDE_EFFECT_ANNOTATION);\n      }\n\n      if (NodeUtil.isGetProp(node)) {\n        if (NodeUtil.isExpressionNode(parent) &&\n            hasNoSideEffectsAnnotation(node)) {\n          noSideEffectFunctionNames.add(node);\n        }\n      } else if (NodeUtil.isFunction(node)) {\n\n        // The annotation may attached to the function node, the\n        // variable declaration or assignment expression.\n        boolean hasAnnotation = hasNoSideEffectsAnnotation(node);\n        List<Node> nameNodes = Lists.newArrayList();\n        nameNodes.add(node.getFirstChild());\n\n        Node nameNode = null;\n\n        if (NodeUtil.isName(parent)) {\n          Node gramp = parent.getParent();\n          if (NodeUtil.isVar(gramp) &&\n              gramp.hasOneChild() &&\n              hasNoSideEffectsAnnotation(gramp)) {\n            hasAnnotation = true;\n          }\n\n          nameNodes.add(parent);\n        } else if (NodeUtil.isAssign(parent)) {\n          if (hasNoSideEffectsAnnotation(parent)) {\n            hasAnnotation = true;\n          }\n\n          nameNodes.add(parent.getFirstChild());\n        }\n\n        if (hasAnnotation) {\n          noSideEffectFunctionNames.addAll(nameNodes);\n        }\n      }\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "SetNoSideEffectCallProperty.visit",
    "class_name": "com.google.javascript.jscomp.MarkNoSideEffectCalls$SetNoSideEffectCallProperty",
    "signature": "com.google.javascript.jscomp.MarkNoSideEffectCalls$SetNoSideEffectCallProperty.visit(NodeTraversal,Node,Node)",
    "snippet": "    @Override\n    public void visit(NodeTraversal traversal, Node node, Node parent) {\n      if (!NodeUtil.isCall(node) && !NodeUtil.isNew(node)) {\n        return;\n      }\n\n      Collection<Definition> definitions =\n          defFinder.getDefinitionsReferencedAt(node.getFirstChild());\n      if (definitions == null) {\n        return;\n      }\n\n      for (Definition def : definitions) {\n        Node lValue = def.getLValue();\n        Preconditions.checkNotNull(lValue);\n        if (!noSideEffectFunctionNames.contains(lValue) &&\n            definitionTypeContainsFunctionType(def)) {\n          return;\n        }\n      }\n\n      node.setSideEffectFlags(Node.NO_SIDE_EFFECTS);\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "NodeTraversal.NodeTraversal",
    "class_name": "com.google.javascript.jscomp.NodeTraversal",
    "signature": "com.google.javascript.jscomp.NodeTraversal.NodeTraversal(AbstractCompiler,Callback)",
    "snippet": "  public NodeTraversal(AbstractCompiler compiler, Callback cb) {\n    this(compiler, cb, new SyntacticScopeCreator(compiler));\n  }",
    "comment": " Creates a node traversal using the specified callback interface. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "NodeTraversal.NodeTraversal",
    "class_name": "com.google.javascript.jscomp.NodeTraversal",
    "signature": "com.google.javascript.jscomp.NodeTraversal.NodeTraversal(AbstractCompiler,Callback,ScopeCreator)",
    "snippet": "  public NodeTraversal(AbstractCompiler compiler, Callback cb,\n      ScopeCreator scopeCreator) {\n    this.callback = cb;\n    if (cb instanceof ScopedCallback) {\n      this.scopeCallback = (ScopedCallback) cb;\n    }\n    this.compiler = compiler;\n    this.sourceName = \"\";\n    this.scopeCreator = scopeCreator;\n  }",
    "comment": " Creates a node traversal using the specified callback interface and the scope creator. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "NodeTraversal.getCompiler",
    "class_name": "com.google.javascript.jscomp.NodeTraversal",
    "signature": "com.google.javascript.jscomp.NodeTraversal.getCompiler()",
    "snippet": "  public Compiler getCompiler() {\n    // TODO(nicksantos): Remove this type cast. This is just temporary\n    // while refactoring.\n    return (Compiler) compiler;\n  }",
    "comment": " Gets the compiler. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "NodeTraversal.getInput",
    "class_name": "com.google.javascript.jscomp.NodeTraversal",
    "signature": "com.google.javascript.jscomp.NodeTraversal.getInput()",
    "snippet": "  public CompilerInput getInput() {\n    return compiler.getInput(sourceName);\n  }",
    "comment": " Gets the current input source. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "NodeTraversal.getModule",
    "class_name": "com.google.javascript.jscomp.NodeTraversal",
    "signature": "com.google.javascript.jscomp.NodeTraversal.getModule()",
    "snippet": "  public JSModule getModule() {\n    CompilerInput input = getInput();\n    return input == null ? null : input.getModule();\n  }",
    "comment": " Gets the current input module. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "NodeTraversal.getScope",
    "class_name": "com.google.javascript.jscomp.NodeTraversal",
    "signature": "com.google.javascript.jscomp.NodeTraversal.getScope()",
    "snippet": "  public Scope getScope() {\n    Scope scope = scopes.isEmpty() ? null : scopes.peek();\n    if (scopeRoots.isEmpty()) {\n      return scope;\n    }\n\n    Iterator<Node> it = scopeRoots.descendingIterator();\n    while (it.hasNext()) {\n      scope = scopeCreator.createScope(it.next(), scope);\n      scopes.push(scope);\n    }\n    scopeRoots.clear();\n\n    return scope;\n  }",
    "comment": "Gets the current scope. */",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "NodeTraversal.getScopeDepth",
    "class_name": "com.google.javascript.jscomp.NodeTraversal",
    "signature": "com.google.javascript.jscomp.NodeTraversal.getScopeDepth()",
    "snippet": "  int getScopeDepth() {\n    return scopes.size() + scopeRoots.size();\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "NodeTraversal.getScopeRoot",
    "class_name": "com.google.javascript.jscomp.NodeTraversal",
    "signature": "com.google.javascript.jscomp.NodeTraversal.getScopeRoot()",
    "snippet": "  public Node getScopeRoot() {\n    if (scopeRoots.isEmpty()) {\n      return scopes.peek().getRootNode();\n    } else {\n      return scopeRoots.peek();\n    }\n  }",
    "comment": "Returns the current scope's root. */",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "NodeTraversal.getSourceName",
    "class_name": "com.google.javascript.jscomp.NodeTraversal",
    "signature": "com.google.javascript.jscomp.NodeTraversal.getSourceName(Node)",
    "snippet": "  private static String getSourceName(Node n) {\n    String name = (String) n.getProp(Node.SOURCENAME_PROP);\n    return name == null ? \"\" : name;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "NodeTraversal.inGlobalScope",
    "class_name": "com.google.javascript.jscomp.NodeTraversal",
    "signature": "com.google.javascript.jscomp.NodeTraversal.inGlobalScope()",
    "snippet": "  boolean inGlobalScope() {\n    return getScopeDepth() <= 1;\n  }",
    "comment": " Determines whether the traversal is currently in the global scope. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "NodeTraversal.popScope",
    "class_name": "com.google.javascript.jscomp.NodeTraversal",
    "signature": "com.google.javascript.jscomp.NodeTraversal.popScope()",
    "snippet": "  private void popScope() {\n    if (scopeCallback != null) {\n      scopeCallback.exitScope(this);\n    }\n    if (scopeRoots.isEmpty()) {\n      scopes.pop();\n    } else {\n      scopeRoots.pop();\n    }\n    cfgs.pop();\n  }",
    "comment": "Pops back to the previous scope (e.g. when leaving a function). */",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "NodeTraversal.pushScope",
    "class_name": "com.google.javascript.jscomp.NodeTraversal",
    "signature": "com.google.javascript.jscomp.NodeTraversal.pushScope(Node)",
    "snippet": "  private void pushScope(Node node) {\n    Preconditions.checkState(curNode != null);\n    scopeRoots.push(node);\n    cfgs.push(null);\n    if (scopeCallback != null) {\n      scopeCallback.enterScope(this);\n    }\n  }",
    "comment": "Creates a new scope (e.g. when entering a function). */",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "NodeTraversal.traverse",
    "class_name": "com.google.javascript.jscomp.NodeTraversal",
    "signature": "com.google.javascript.jscomp.NodeTraversal.traverse(AbstractCompiler,Node,Callback)",
    "snippet": "  public static void traverse(\n      AbstractCompiler compiler, Node root, Callback cb) {\n    NodeTraversal t = new NodeTraversal(compiler, cb);\n    t.traverse(root);\n  }",
    "comment": " Traverses a node recursively. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "NodeTraversal.traverse",
    "class_name": "com.google.javascript.jscomp.NodeTraversal",
    "signature": "com.google.javascript.jscomp.NodeTraversal.traverse(Node)",
    "snippet": "  public void traverse(Node root) {\n    try {\n      sourceName = \"\";\n      curNode = root;\n      pushScope(root);\n      traverseBranch(root, null);\n      popScope();\n    } catch (Exception unexpectedException) {\n      throwUnexpectedException(unexpectedException);\n    }\n  }",
    "comment": " Traverses a parse tree recursively. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "NodeTraversal.traverseBranch",
    "class_name": "com.google.javascript.jscomp.NodeTraversal",
    "signature": "com.google.javascript.jscomp.NodeTraversal.traverseBranch(Node,Node)",
    "snippet": "  @SuppressWarnings(\"fallthrough\")\n  private void traverseBranch(Node n, Node parent) {\n    int type = n.getType();\n    if (type == Token.SCRIPT) {\n      sourceName = getSourceName(n);\n    }\n\n    curNode = n;\n    if (!callback.shouldTraverse(this, n, parent)) return;\n\n    switch (type) {\n      case Token.FUNCTION:\n        traverseFunction(n, parent);\n        break;\n\n      default:\n        for (Node child = n.getFirstChild(); child != null; ) {\n          // child could be replaced, in which case our child node\n          // would no longer point to the true next\n          Node next = child.getNext();\n          traverseBranch(child, n);\n          child = next;\n        }\n        break;\n    }\n\n    curNode = n;\n    callback.visit(this, n, parent);\n  }",
    "comment": " Traverses a branch. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "NodeTraversal.traverseFunction",
    "class_name": "com.google.javascript.jscomp.NodeTraversal",
    "signature": "com.google.javascript.jscomp.NodeTraversal.traverseFunction(Node,Node)",
    "snippet": "  private void traverseFunction(Node n, Node parent) {\n    Preconditions.checkState(n.getChildCount() == 3);\n    Preconditions.checkState(n.getType() == Token.FUNCTION);\n\n    final Node fnName = n.getFirstChild();\n\n    boolean isFunctionExpression = (parent != null)\n        && NodeUtil.isFunctionExpression(n);\n\n    if (!isFunctionExpression) {\n      // Functions declarations are in the scope containing the declaration.\n      traverseBranch(fnName, n);\n    }\n\n    curNode = n;\n    pushScope(n);\n\n    if (isFunctionExpression) {\n      // Function expression names are only accessible within the function\n      // scope.\n      traverseBranch(fnName, n);\n    }\n\n    final Node args = fnName.getNext();\n    final Node body = args.getNext();\n\n    // Args\n    traverseBranch(args, n);\n\n    // Body\n    Preconditions.checkState(body.getNext() == null &&\n            body.getType() == Token.BLOCK);\n    traverseBranch(body, n);\n\n    popScope();\n  }",
    "comment": " Traverses a function. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "NodeTraversal.traverseRoots",
    "class_name": "com.google.javascript.jscomp.NodeTraversal",
    "signature": "com.google.javascript.jscomp.NodeTraversal.traverseRoots(AbstractCompiler,List,Callback)",
    "snippet": "  public static void traverseRoots(\n      AbstractCompiler compiler, List<Node> roots, Callback cb) {\n    NodeTraversal t = new NodeTraversal(compiler, cb);\n    t.traverseRoots(roots);\n  }",
    "comment": " Traverses a list of node trees. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "NodeTraversal.traverseRoots",
    "class_name": "com.google.javascript.jscomp.NodeTraversal",
    "signature": "com.google.javascript.jscomp.NodeTraversal.traverseRoots(List)",
    "snippet": "  public void traverseRoots(List<Node> roots) {\n    if (roots.isEmpty()) {\n      return;\n    }\n\n    try {\n      Node scopeRoot = roots.get(0).getParent();\n      Preconditions.checkState(scopeRoot != null);\n\n      sourceName = \"\";\n      curNode = scopeRoot;\n      pushScope(scopeRoot);\n\n      for (Node root : roots) {\n        Preconditions.checkState(root.getParent() == scopeRoot);\n        traverseBranch(root, scopeRoot);\n      }\n\n      popScope();\n    } catch (Exception unexpectedException) {\n      throwUnexpectedException(unexpectedException);\n    }\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "NodeTraversal.traverseRoots",
    "class_name": "com.google.javascript.jscomp.NodeTraversal",
    "signature": "com.google.javascript.jscomp.NodeTraversal.traverseRoots(Node[])",
    "snippet": "  public void traverseRoots(Node ... roots) {\n    traverseRoots(Lists.newArrayList(roots));\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "AbstractPostOrderCallback.shouldTraverse",
    "class_name": "com.google.javascript.jscomp.NodeTraversal$AbstractPostOrderCallback",
    "signature": "com.google.javascript.jscomp.NodeTraversal$AbstractPostOrderCallback.shouldTraverse(NodeTraversal,Node,Node)",
    "snippet": "    public final boolean shouldTraverse(NodeTraversal nodeTraversal, Node n,\n        Node parent) {\n      return true;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "NodeUtil.containsFunction",
    "class_name": "com.google.javascript.jscomp.NodeUtil",
    "signature": "com.google.javascript.jscomp.NodeUtil.containsFunction(Node)",
    "snippet": "  static boolean containsFunction(Node n) {\n    return containsType(n, Token.FUNCTION);\n  }",
    "comment": " Determines if the given node contains a function statement or function expression. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "NodeUtil.containsType",
    "class_name": "com.google.javascript.jscomp.NodeUtil",
    "signature": "com.google.javascript.jscomp.NodeUtil.containsType(Node,int)",
    "snippet": "  static boolean containsType(Node node, int type) {\n    return containsType(node, type, Predicates.<Node>alwaysTrue());\n  }",
    "comment": " @return true if n or any of its children are of the specified type ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "NodeUtil.containsType",
    "class_name": "com.google.javascript.jscomp.NodeUtil",
    "signature": "com.google.javascript.jscomp.NodeUtil.containsType(Node,int,Predicate)",
    "snippet": "  static boolean containsType(Node node,\n                              int type,\n                              Predicate<Node> traverseChildrenPred) {\n    return has(node, new MatchNodeType(type), traverseChildrenPred);\n  }",
    "comment": " @return true if n or any of its children are of the specified type ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "NodeUtil.getCount",
    "class_name": "com.google.javascript.jscomp.NodeUtil",
    "signature": "com.google.javascript.jscomp.NodeUtil.getCount(Node,Predicate,Predicate)",
    "snippet": "  static int getCount(\n      Node n, Predicate<Node> pred, Predicate<Node> traverseChildrenPred) {\n    int total = 0;\n\n    if (pred.apply(n)) {\n      total++;\n    }\n\n    if (traverseChildrenPred.apply(n)) {\n      for (Node c = n.getFirstChild(); c != null; c = c.getNext()) {\n        total += getCount(c, pred, traverseChildrenPred);\n      }\n    }\n\n    return total;\n  }",
    "comment": " @return The number of times the the predicate is true for the node or any of its children. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "NodeUtil.getFnParameters",
    "class_name": "com.google.javascript.jscomp.NodeUtil",
    "signature": "com.google.javascript.jscomp.NodeUtil.getFnParameters(Node)",
    "snippet": "  static Node getFnParameters(Node fnNode) {\n    // Function NODE: [ FUNCTION -> NAME, LP -> ARG1, ARG2, ... ]\n    Preconditions.checkArgument(fnNode.getType() == Token.FUNCTION);\n    return fnNode.getFirstChild().getNext();\n  }",
    "comment": " @param fnNode The function. @return The Node containing the Function parameters. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "NodeUtil.getFunctionBody",
    "class_name": "com.google.javascript.jscomp.NodeUtil",
    "signature": "com.google.javascript.jscomp.NodeUtil.getFunctionBody(Node)",
    "snippet": "  static Node getFunctionBody(Node fn) {\n    Preconditions.checkArgument(isFunction(fn));\n    return fn.getLastChild();\n  }",
    "comment": " Return a BLOCK node for the given FUNCTION node. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "NodeUtil.getFunctionInfo",
    "class_name": "com.google.javascript.jscomp.NodeUtil",
    "signature": "com.google.javascript.jscomp.NodeUtil.getFunctionInfo(Node)",
    "snippet": "  static JSDocInfo getFunctionInfo(Node n) {\n    Preconditions.checkState(n.getType() == Token.FUNCTION);\n    JSDocInfo fnInfo = n.getJSDocInfo();\n    if (fnInfo == null && NodeUtil.isFunctionExpression(n)) {\n      // Look for the info on other nodes.\n      Node parent = n.getParent();\n      if (parent.getType() == Token.ASSIGN) {\n        // on ASSIGNs\n        fnInfo = parent.getJSDocInfo();\n      } else if (parent.getType() == Token.NAME) {\n        // on var NAME = function() { ... };\n        fnInfo = parent.getParent().getJSDocInfo();\n      }\n    }\n    return fnInfo;\n  }",
    "comment": " Get the JSDocInfo for a function. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "NodeUtil.getInfoForNameNode",
    "class_name": "com.google.javascript.jscomp.NodeUtil",
    "signature": "com.google.javascript.jscomp.NodeUtil.getInfoForNameNode(Node)",
    "snippet": "  static JSDocInfo getInfoForNameNode(Node nameNode) {\n    JSDocInfo info = null;\n    Node parent = null;\n    if (nameNode != null) {\n      info = nameNode.getJSDocInfo();\n      parent = nameNode.getParent();\n    }\n\n    if (info == null && parent != null &&\n        ((parent.getType() == Token.VAR && parent.hasOneChild()) ||\n          parent.getType() == Token.FUNCTION)) {\n      info = parent.getJSDocInfo();\n    }\n    return info;\n  }",
    "comment": " @param nameNode A name node @return The JSDocInfo for the name node ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "NodeUtil.getNodeTypeReferenceCount",
    "class_name": "com.google.javascript.jscomp.NodeUtil",
    "signature": "com.google.javascript.jscomp.NodeUtil.getNodeTypeReferenceCount(Node,int,Predicate)",
    "snippet": "  static int getNodeTypeReferenceCount(\n      Node node, int type, Predicate<Node> traverseChildrenPred) {\n    return getCount(node, new MatchNodeType(type), traverseChildrenPred);\n  }",
    "comment": " Finds the number of times a type is referenced within the node tree. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "NodeUtil.has",
    "class_name": "com.google.javascript.jscomp.NodeUtil",
    "signature": "com.google.javascript.jscomp.NodeUtil.has(Node,Predicate,Predicate)",
    "snippet": "  static boolean has(Node node,\n                     Predicate<Node> pred,\n                     Predicate<Node> traverseChildrenPred) {\n    if (pred.apply(node)) {\n      return true;\n    }\n\n    if (!traverseChildrenPred.apply(node)) {\n      return false;\n    }\n\n    for (Node c = node.getFirstChild(); c != null; c = c.getNext()) {\n      if (has(c, pred, traverseChildrenPred)) {\n        return true;\n      }\n    }\n\n    return false;\n  }",
    "comment": " @return Whether the predicate is true for the node or any of its children. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "NodeUtil.isAssign",
    "class_name": "com.google.javascript.jscomp.NodeUtil",
    "signature": "com.google.javascript.jscomp.NodeUtil.isAssign(Node)",
    "snippet": "  static boolean isAssign(Node n) {\n    return n.getType() == Token.ASSIGN;\n  }",
    "comment": " Is this an ASSIGN node? ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "NodeUtil.isCall",
    "class_name": "com.google.javascript.jscomp.NodeUtil",
    "signature": "com.google.javascript.jscomp.NodeUtil.isCall(Node)",
    "snippet": "  static boolean isCall(Node n) {\n    return n.getType() == Token.CALL;\n  }",
    "comment": " Is this a CALL node? ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "NodeUtil.isConstantByConvention",
    "class_name": "com.google.javascript.jscomp.NodeUtil",
    "signature": "com.google.javascript.jscomp.NodeUtil.isConstantByConvention(CodingConvention,Node,Node)",
    "snippet": "  static boolean isConstantByConvention(\n      CodingConvention convention, Node node, Node parent) {\n    String name = node.getString();\n    if (parent.getType() == Token.GETPROP &&\n        node == parent.getLastChild()) {\n      return convention.isConstantKey(name);\n    } else if (isObjectLitKey(node, parent)) {\n      return convention.isConstantKey(name);\n    } else {\n      return convention.isConstant(name);\n    }\n  }",
    "comment": "Whether the given name is constant by coding convention. */",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "NodeUtil.isControlStructure",
    "class_name": "com.google.javascript.jscomp.NodeUtil",
    "signature": "com.google.javascript.jscomp.NodeUtil.isControlStructure(Node)",
    "snippet": "  static boolean isControlStructure(Node n) {\n    switch (n.getType()) {\n      case Token.FOR:\n      case Token.DO:\n      case Token.WHILE:\n      case Token.WITH:\n      case Token.IF:\n      case Token.LABEL:\n      case Token.TRY:\n      case Token.CATCH:\n      case Token.SWITCH:\n      case Token.CASE:\n      case Token.DEFAULT:\n        return true;\n      default:\n        return false;\n    }\n  }",
    "comment": " Determines whether the given node is a FOR, DO, WHILE, WITH, or IF node. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "NodeUtil.isExprCall",
    "class_name": "com.google.javascript.jscomp.NodeUtil",
    "signature": "com.google.javascript.jscomp.NodeUtil.isExprCall(Node)",
    "snippet": "  static boolean isExprCall(Node n) {\n    return n.getType() == Token.EXPR_RESULT\n        && n.getFirstChild().getType() == Token.CALL;\n  }",
    "comment": " Is this node a call expression statement?  @param n The node @return True if {@code n} is EXPR_RESULT and {@code n}'s first child is CALL ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "NodeUtil.isExpressionNode",
    "class_name": "com.google.javascript.jscomp.NodeUtil",
    "signature": "com.google.javascript.jscomp.NodeUtil.isExpressionNode(Node)",
    "snippet": "  static boolean isExpressionNode(Node n) {\n    return n.getType() == Token.EXPR_RESULT;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "NodeUtil.isFunction",
    "class_name": "com.google.javascript.jscomp.NodeUtil",
    "signature": "com.google.javascript.jscomp.NodeUtil.isFunction(Node)",
    "snippet": "  static boolean isFunction(Node n) {\n    return n.getType() == Token.FUNCTION;\n  }",
    "comment": " Is this a FUNCTION node? ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "NodeUtil.isFunctionDeclaration",
    "class_name": "com.google.javascript.jscomp.NodeUtil",
    "signature": "com.google.javascript.jscomp.NodeUtil.isFunctionDeclaration(Node)",
    "snippet": "  static boolean isFunctionDeclaration(Node n) {\n    return n.getType() == Token.FUNCTION && isStatement(n);\n  }",
    "comment": " Is this node a function declaration? A function declaration is a function that has a name that is added to the current scope (i.e. a function that is not part of a expression; see {@link #isFunctionExpression}). ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "NodeUtil.isFunctionExpression",
    "class_name": "com.google.javascript.jscomp.NodeUtil",
    "signature": "com.google.javascript.jscomp.NodeUtil.isFunctionExpression(Node)",
    "snippet": "  static boolean isFunctionExpression(Node n) {\n    return n.getType() == Token.FUNCTION && !isStatement(n);\n  }",
    "comment": " Is a FUNCTION node an function expression? An function expression is one that has either no name or a name that is not added to the current scope.  <p>Some examples of function expressions: <pre> (function () {}) (function f() {})() [ function f() {} ] var f = function f() {}; for (function f() {};;) {} </pre>  <p>Some examples of functions that are <em>not</em> expressions: <pre> function f() {} if (x); else function f() {} for (;;) { function f() {} } </pre>  @param n A node @return Whether n is an function used within an expression. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "NodeUtil.isFunctionObjectCall",
    "class_name": "com.google.javascript.jscomp.NodeUtil",
    "signature": "com.google.javascript.jscomp.NodeUtil.isFunctionObjectCall(Node)",
    "snippet": "  static boolean isFunctionObjectCall(Node callNode) {\n    return isObjectCallMethod(callNode, \"call\");\n  }",
    "comment": " @return Whether the callNode represents an expression in the form of: x.call(...) x['call'](...) ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "NodeUtil.isGet",
    "class_name": "com.google.javascript.jscomp.NodeUtil",
    "signature": "com.google.javascript.jscomp.NodeUtil.isGet(Node)",
    "snippet": "  static boolean isGet(Node n) {\n    return n.getType() == Token.GETPROP\n        || n.getType() == Token.GETELEM;\n  }",
    "comment": " Is this a GETPROP or GETELEM node? ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "NodeUtil.isGetProp",
    "class_name": "com.google.javascript.jscomp.NodeUtil",
    "signature": "com.google.javascript.jscomp.NodeUtil.isGetProp(Node)",
    "snippet": "  static boolean isGetProp(Node n) {\n    return n.getType() == Token.GETPROP;\n  }",
    "comment": " Is this a GETPROP node? ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "NodeUtil.isHoistedFunctionDeclaration",
    "class_name": "com.google.javascript.jscomp.NodeUtil",
    "signature": "com.google.javascript.jscomp.NodeUtil.isHoistedFunctionDeclaration(Node)",
    "snippet": "  static boolean isHoistedFunctionDeclaration(Node n) {\n    return isFunctionDeclaration(n)\n        && (n.getParent().getType() == Token.SCRIPT\n            || n.getParent().getParent().getType() == Token.FUNCTION);\n  }",
    "comment": " Is this node a hoisted function declaration? A function declaration in the scope root is hoisted to the top of the scope. See {@link #isFunctionDeclaration}). ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "NodeUtil.isImmutableValue",
    "class_name": "com.google.javascript.jscomp.NodeUtil",
    "signature": "com.google.javascript.jscomp.NodeUtil.isImmutableValue(Node)",
    "snippet": "  static boolean isImmutableValue(Node n) {\n    switch (n.getType()) {\n      case Token.STRING:\n      case Token.NUMBER:\n      case Token.NULL:\n      case Token.TRUE:\n      case Token.FALSE:\n        return true;\n      case Token.NOT:\n        return isImmutableValue(n.getFirstChild());\n      case Token.VOID:\n      case Token.NEG:\n        return isImmutableValue(n.getFirstChild());\n      case Token.NAME:\n        String name = n.getString();\n        // We assume here that programs don't change the value of the keyword\n        // undefined to something other than the value undefined.\n        return \"undefined\".equals(name)\n            || \"Infinity\".equals(name)\n            || \"NaN\".equals(name);\n    }\n\n    return false;\n  }",
    "comment": " Returns true if this is an immutable value. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "NodeUtil.isLatin",
    "class_name": "com.google.javascript.jscomp.NodeUtil",
    "signature": "com.google.javascript.jscomp.NodeUtil.isLatin(String)",
    "snippet": "  static boolean isLatin(String s) {\n    char LARGEST_BASIC_LATIN = 0x7f;\n    int len = s.length();\n    for (int index = 0; index < len; index++) {\n      char c = s.charAt(index);\n      if (c > LARGEST_BASIC_LATIN) {\n        return false;\n      }\n    }\n    return true;\n  }",
    "comment": "Test if all characters in the string are in the Basic Latin (aka ASCII) character set - that they have UTF-16 values equal to or below 0x7f. This check can find which identifiers with Unicode characters need to be escaped in order to allow resulting files to be processed by non-Unicode aware UNIX tools and editors.  See http://en.wikipedia.org/wiki/Latin_characters_in_Unicode for more on Basic Latin.  @param s The string to be checked for ASCII-goodness.  @return True if all characters in the string are in Basic Latin set. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "NodeUtil.isLoopStructure",
    "class_name": "com.google.javascript.jscomp.NodeUtil",
    "signature": "com.google.javascript.jscomp.NodeUtil.isLoopStructure(Node)",
    "snippet": "  static boolean isLoopStructure(Node n) {\n    switch (n.getType()) {\n      case Token.FOR:\n      case Token.DO:\n      case Token.WHILE:\n        return true;\n      default:\n        return false;\n    }\n  }",
    "comment": " Determines whether the given node is a FOR, DO, or WHILE node. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "NodeUtil.isName",
    "class_name": "com.google.javascript.jscomp.NodeUtil",
    "signature": "com.google.javascript.jscomp.NodeUtil.isName(Node)",
    "snippet": "  static boolean isName(Node n) {\n    return n.getType() == Token.NAME;\n  }",
    "comment": " Is this a NAME node? ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "NodeUtil.isNew",
    "class_name": "com.google.javascript.jscomp.NodeUtil",
    "signature": "com.google.javascript.jscomp.NodeUtil.isNew(Node)",
    "snippet": "  static boolean isNew(Node n) {\n    return n.getType() == Token.NEW;\n  }",
    "comment": " Is this a NEW node? ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "NodeUtil.isObjectCallMethod",
    "class_name": "com.google.javascript.jscomp.NodeUtil",
    "signature": "com.google.javascript.jscomp.NodeUtil.isObjectCallMethod(Node,String)",
    "snippet": "  static boolean isObjectCallMethod(Node callNode, String methodName) {\n    if (callNode.getType() == Token.CALL) {\n      Node functionIndentifyingExpression = callNode.getFirstChild();\n      if (isGet(functionIndentifyingExpression)) {\n        Node last = functionIndentifyingExpression.getLastChild();\n        if (last != null && last.getType() == Token.STRING) {\n          String propName = last.getString();\n          return (propName.equals(methodName));\n        }\n      }\n    }\n    return false;\n  }",
    "comment": " @return Whether node is a call to methodName. a.f(...) a['f'](...) ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "NodeUtil.isObjectLitKey",
    "class_name": "com.google.javascript.jscomp.NodeUtil",
    "signature": "com.google.javascript.jscomp.NodeUtil.isObjectLitKey(Node,Node)",
    "snippet": "  static boolean isObjectLitKey(Node node, Node parent) {\n    switch (node.getType()) {\n      case Token.STRING:\n        return parent.getType() == Token.OBJECTLIT;\n      case Token.GET:\n      case Token.SET:\n        return true;\n    }\n    return false;\n  }",
    "comment": " Determines whether a node represents an object literal key (e.g. key1 in {key1: value1, key2: value2}).  @param node A node @param parent The node's parent ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "NodeUtil.isStatement",
    "class_name": "com.google.javascript.jscomp.NodeUtil",
    "signature": "com.google.javascript.jscomp.NodeUtil.isStatement(Node)",
    "snippet": "  static boolean isStatement(Node n) {\n    return isStatementParent(n.getParent());\n  }",
    "comment": " @return Whether the node is used as a statement. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "NodeUtil.isStatementBlock",
    "class_name": "com.google.javascript.jscomp.NodeUtil",
    "signature": "com.google.javascript.jscomp.NodeUtil.isStatementBlock(Node)",
    "snippet": "  static boolean isStatementBlock(Node n) {\n    return n.getType() == Token.SCRIPT || n.getType() == Token.BLOCK;\n  }",
    "comment": " @return Whether the node is of a type that contain other statements. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "NodeUtil.isStatementParent",
    "class_name": "com.google.javascript.jscomp.NodeUtil",
    "signature": "com.google.javascript.jscomp.NodeUtil.isStatementParent(Node)",
    "snippet": "  static boolean isStatementParent(Node parent) {\n    // It is not possible to determine definitely if a node is a statement\n    // or not if it is not part of the AST.  A FUNCTION node can be\n    // either part of an expression or a statement.\n    Preconditions.checkState(parent != null);\n    switch (parent.getType()) {\n      case Token.SCRIPT:\n      case Token.BLOCK:\n      case Token.LABEL:\n        return true;\n      default:\n        return false;\n    }\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "NodeUtil.isTryCatchNodeContainer",
    "class_name": "com.google.javascript.jscomp.NodeUtil",
    "signature": "com.google.javascript.jscomp.NodeUtil.isTryCatchNodeContainer(Node)",
    "snippet": "  static boolean isTryCatchNodeContainer(Node n) {\n    Node parent = n.getParent();\n    return parent.getType() == Token.TRY\n        && parent.getFirstChild().getNext() == n;\n  }",
    "comment": "Whether the node is a CATCH container BLOCK. */",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "NodeUtil.isTryFinallyNode",
    "class_name": "com.google.javascript.jscomp.NodeUtil",
    "signature": "com.google.javascript.jscomp.NodeUtil.isTryFinallyNode(Node,Node)",
    "snippet": "  static boolean isTryFinallyNode(Node parent, Node child) {\n    return parent.getType() == Token.TRY && parent.getChildCount() == 3\n        && child == parent.getLastChild();\n  }",
    "comment": "Whether the child node is the FINALLY block of a try. */",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "NodeUtil.isVarDeclaration",
    "class_name": "com.google.javascript.jscomp.NodeUtil",
    "signature": "com.google.javascript.jscomp.NodeUtil.isVarDeclaration(Node)",
    "snippet": "  static boolean isVarDeclaration(Node n) {\n    // There is no need to verify that parent != null because a NAME node\n    // always has a parent in a valid parse tree.\n    return n.getType() == Token.NAME && n.getParent().getType() == Token.VAR;\n  }",
    "comment": " Is this node the name of a variable being declared?  @param n The node @return True if {@code n} is NAME and {@code parent} is VAR ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "NodeUtil.isWithinLoop",
    "class_name": "com.google.javascript.jscomp.NodeUtil",
    "signature": "com.google.javascript.jscomp.NodeUtil.isWithinLoop(Node)",
    "snippet": "  static boolean isWithinLoop(Node n) {\n    for (Node parent : n.getAncestors()) {\n      if (NodeUtil.isLoopStructure(parent)) {\n        return true;\n      }\n\n      if (NodeUtil.isFunction(parent)) {\n        break;\n      }\n    }\n    return false;\n  }",
    "comment": " @return Whether the specified node has a loop parent that is within the current scope. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "NodeUtil.opToStr",
    "class_name": "com.google.javascript.jscomp.NodeUtil",
    "signature": "com.google.javascript.jscomp.NodeUtil.opToStr(int)",
    "snippet": "  static String opToStr(int operator) {\n    switch (operator) {\n      case Token.BITOR: return \"|\";\n      case Token.OR: return \"||\";\n      case Token.BITXOR: return \"^\";\n      case Token.AND: return \"&&\";\n      case Token.BITAND: return \"&\";\n      case Token.SHEQ: return \"===\";\n      case Token.EQ: return \"==\";\n      case Token.NOT: return \"!\";\n      case Token.NE: return \"!=\";\n      case Token.SHNE: return \"!==\";\n      case Token.LSH: return \"<<\";\n      case Token.IN: return \"in\";\n      case Token.LE: return \"<=\";\n      case Token.LT: return \"<\";\n      case Token.URSH: return \">>>\";\n      case Token.RSH: return \">>\";\n      case Token.GE: return \">=\";\n      case Token.GT: return \">\";\n      case Token.MUL: return \"*\";\n      case Token.DIV: return \"/\";\n      case Token.MOD: return \"%\";\n      case Token.BITNOT: return \"~\";\n      case Token.ADD: return \"+\";\n      case Token.SUB: return \"-\";\n      case Token.POS: return \"+\";\n      case Token.NEG: return \"-\";\n      case Token.ASSIGN: return \"=\";\n      case Token.ASSIGN_BITOR: return \"|=\";\n      case Token.ASSIGN_BITXOR: return \"^=\";\n      case Token.ASSIGN_BITAND: return \"&=\";\n      case Token.ASSIGN_LSH: return \"<<=\";\n      case Token.ASSIGN_RSH: return \">>=\";\n      case Token.ASSIGN_URSH: return \">>>=\";\n      case Token.ASSIGN_ADD: return \"+=\";\n      case Token.ASSIGN_SUB: return \"-=\";\n      case Token.ASSIGN_MUL: return \"*=\";\n      case Token.ASSIGN_DIV: return \"/=\";\n      case Token.ASSIGN_MOD: return \"%=\";\n      case Token.VOID: return \"void\";\n      case Token.TYPEOF: return \"typeof\";\n      case Token.INSTANCEOF: return \"instanceof\";\n      default: return null;\n    }\n  }",
    "comment": " Converts an operator's token value (see {@link Token}) to a string representation.  @param operator the operator's token value to convert @return the string representation or {@code null} if the token value is not an operator ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "NodeUtil.referencesThis",
    "class_name": "com.google.javascript.jscomp.NodeUtil",
    "signature": "com.google.javascript.jscomp.NodeUtil.referencesThis(Node)",
    "snippet": "  static boolean referencesThis(Node n) {\n    Node start = (isFunction(n)) ? n.getLastChild() : n;\n    return containsType(start, Token.THIS, new MatchNotFunction());\n  }",
    "comment": " Returns true if the shallow scope contains references to 'this' keyword ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "NodeUtil.removeChild",
    "class_name": "com.google.javascript.jscomp.NodeUtil",
    "signature": "com.google.javascript.jscomp.NodeUtil.removeChild(Node,Node)",
    "snippet": "  static void removeChild(Node parent, Node node) {\n    if (isTryFinallyNode(parent, node)) {\n      if (NodeUtil.hasCatchHandler(getCatchBlock(parent))) {\n        // A finally can only be removed if there is a catch.\n        parent.removeChild(node);\n      } else {\n        // Otherwise only its children can be removed.\n        node.detachChildren();\n      }\n    } else if (node.getType() == Token.CATCH) {\n      // The CATCH can can only be removed if there is a finally clause.\n      Node tryNode = node.getParent().getParent();\n      Preconditions.checkState(NodeUtil.hasFinally(tryNode));\n      node.detachFromParent();\n    } else if (isTryCatchNodeContainer(node)) {\n      // The container node itself can't be removed, but the contained CATCH\n      // can if there is a 'finally' clause\n      Node tryNode = node.getParent();\n      Preconditions.checkState(NodeUtil.hasFinally(tryNode));\n      node.detachChildren();\n    } else if (node.getType() == Token.BLOCK) {\n      // Simply empty the block.  This maintains source location and\n      // \"synthetic\"-ness.\n      node.detachChildren();\n    } else if (isStatementBlock(parent)\n        || isSwitchCase(node)) {\n      // A statement in a block can simply be removed.\n      parent.removeChild(node);\n    } else if (parent.getType() == Token.VAR) {\n      if (parent.hasMoreThanOneChild()) {\n        parent.removeChild(node);\n      } else {\n        // Remove the node from the parent, so it can be reused.\n        parent.removeChild(node);\n        // This would leave an empty VAR, remove the VAR itself.\n        removeChild(parent.getParent(), parent);\n      }\n    } else if (parent.getType() == Token.LABEL\n        && node == parent.getLastChild()) {\n      // Remove the node from the parent, so it can be reused.\n      parent.removeChild(node);\n      // A LABEL without children can not be referred to, remove it.\n      removeChild(parent.getParent(), parent);\n    } else if (parent.getType() == Token.FOR\n        && parent.getChildCount() == 4) {\n      // Only Token.FOR can have an Token.EMPTY other control structure\n      // need something for the condition. Others need to be replaced\n      // or the structure removed.\n      parent.replaceChild(node, new Node(Token.EMPTY));\n    } else {\n      throw new IllegalStateException(\"Invalid attempt to remove node: \" +\n          node.toString() + \" of \"+ parent.toString());\n    }\n  }",
    "comment": "Safely remove children while maintaining a valid node structure. */",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "MatchDeclaration.apply",
    "class_name": "com.google.javascript.jscomp.NodeUtil$MatchDeclaration",
    "signature": "com.google.javascript.jscomp.NodeUtil$MatchDeclaration.apply(Node)",
    "snippet": "    public boolean apply(Node n) {\n      return isFunctionDeclaration(n) || n.getType() == Token.VAR;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "MatchNodeType.apply",
    "class_name": "com.google.javascript.jscomp.NodeUtil$MatchNodeType",
    "signature": "com.google.javascript.jscomp.NodeUtil$MatchNodeType.apply(Node)",
    "snippet": "    public boolean apply(Node n) {\n      return n.getType() == type;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "MatchNotFunction.apply",
    "class_name": "com.google.javascript.jscomp.NodeUtil$MatchNotFunction",
    "signature": "com.google.javascript.jscomp.NodeUtil$MatchNotFunction.apply(Node)",
    "snippet": "    public boolean apply(Node n) {\n      return !isFunction(n);\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "MatchShallowStatement.apply",
    "class_name": "com.google.javascript.jscomp.NodeUtil$MatchShallowStatement",
    "signature": "com.google.javascript.jscomp.NodeUtil$MatchShallowStatement.apply(Node)",
    "snippet": "    public boolean apply(Node n) {\n      Node parent = n.getParent();\n      return n.getType() == Token.BLOCK\n          || (!isFunction(n) && (parent == null\n              || isControlStructure(parent)\n              || isStatementBlock(parent)));\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "Normalize.Normalize",
    "class_name": "com.google.javascript.jscomp.Normalize",
    "signature": "com.google.javascript.jscomp.Normalize.Normalize(AbstractCompiler,boolean)",
    "snippet": "  Normalize(AbstractCompiler compiler, boolean assertOnChange) {\n    this.compiler = compiler;\n    this.assertOnChange = assertOnChange;\n\n    // TODO(nicksantos): assertOnChange should only be true if the tree\n    // is normalized.\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "Normalize.process",
    "class_name": "com.google.javascript.jscomp.Normalize",
    "signature": "com.google.javascript.jscomp.Normalize.process(Node,Node)",
    "snippet": "  @Override\n  public void process(Node externs, Node root) {\n    new NodeTraversal(\n        compiler, new NormalizeStatements(compiler, assertOnChange))\n        .traverseRoots(externs, root);\n    if (MAKE_LOCAL_NAMES_UNIQUE) {\n      MakeDeclaredNamesUnique renamer = new MakeDeclaredNamesUnique();\n      NodeTraversal t = new NodeTraversal(compiler, renamer);\n      t.traverseRoots(externs, root);\n    }\n    // It is important that removeDuplicateDeclarations runs after\n    // MakeDeclaredNamesUnique in order for catch block exception names to be\n    // handled properly. Specifically, catch block exception names are\n    // only valid within the catch block, but our currect Scope logic\n    // has no concept of this and includes it in the containing function\n    // (or global scope). MakeDeclaredNamesUnique makes the catch exception\n    // names unique so that removeDuplicateDeclarations() will properly handle\n    // cases where a function scope variable conflict with a exception name:\n    //   function f() {\n    //      try {throw 0;} catch(e) {e; /* catch scope 'e'*/}\n    //      var e = 1; // f scope 'e'\n    //   }\n    // otherwise 'var e = 1' would be rewritten as 'e = 1'.\n    // TODO(johnlenz): Introduce a seperate scope for catch nodes.\n    removeDuplicateDeclarations(externs, root);\n    new PropagateConstantAnnotationsOverVars(compiler, assertOnChange)\n        .process(externs, root);\n\n    if (!compiler.getLifeCycleStage().isNormalized()) {\n      compiler.setLifeCycleStage(LifeCycleStage.NORMALIZED);\n    }\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "Normalize.removeDuplicateDeclarations",
    "class_name": "com.google.javascript.jscomp.Normalize",
    "signature": "com.google.javascript.jscomp.Normalize.removeDuplicateDeclarations(Node,Node)",
    "snippet": "  private void removeDuplicateDeclarations(Node externs, Node root) {\n    Callback tickler = new ScopeTicklingCallback();\n    ScopeCreator scopeCreator =  new SyntacticScopeCreator(\n        compiler, new DuplicateDeclarationHandler());\n    NodeTraversal t = new NodeTraversal(compiler, tickler, scopeCreator);\n    t.traverseRoots(externs, root);\n  }",
    "comment": " Remove duplicate VAR declarations. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "NormalizeStatements.annotateConstantsByConvention",
    "class_name": "com.google.javascript.jscomp.Normalize$NormalizeStatements",
    "signature": "com.google.javascript.jscomp.Normalize$NormalizeStatements.annotateConstantsByConvention(Node,Node)",
    "snippet": "    private void annotateConstantsByConvention(Node n, Node parent) {\n      Preconditions.checkState(\n          n.getType() == Token.NAME\n          || n.getType() == Token.STRING\n          || n.getType() == Token.GET\n          || n.getType() == Token.SET);\n\n      // There are only two cases where a string token\n      // may be a variable reference: The right side of a GETPROP\n      // or an OBJECTLIT key.\n      boolean isObjLitKey = NodeUtil.isObjectLitKey(n, parent);\n      boolean isProperty = isObjLitKey ||\n          (parent.getType() == Token.GETPROP &&\n           parent.getLastChild() == n);\n      if (n.getType() == Token.NAME || isProperty) {\n        boolean isMarkedConstant = n.getBooleanProp(Node.IS_CONSTANT_NAME);\n        if (!isMarkedConstant &&\n            NodeUtil.isConstantByConvention(\n                compiler.getCodingConvention(), n, parent)) {\n          if (assertOnChange) {\n            String name = n.getString();\n            throw new IllegalStateException(\n                \"Unexpected const change.\\n\" +\n                \"  name: \"+ name + \"\\n\" +\n                \"  parent:\" + n.getParent().toStringTree());\n          }\n          n.putBooleanProp(Node.IS_CONSTANT_NAME, true);\n        }\n      }\n    }",
    "comment": " Mark names and properties that are constants by convention. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "NormalizeStatements.doStatementNormalizations",
    "class_name": "com.google.javascript.jscomp.Normalize$NormalizeStatements",
    "signature": "com.google.javascript.jscomp.Normalize$NormalizeStatements.doStatementNormalizations(NodeTraversal,Node,Node)",
    "snippet": "    private void doStatementNormalizations(\n        NodeTraversal t, Node n, Node parent) {\n      if (n.getType() == Token.LABEL) {\n        normalizeLabels(n);\n      }\n\n      // Only inspect the children of SCRIPTs, BLOCKs and LABELs, as all these\n      // are the only legal place for VARs and FOR statements.\n      if (NodeUtil.isStatementBlock(n) || n.getType() == Token.LABEL) {\n        extractForInitializer(n, null, null);\n      }\n\n      // Only inspect the children of SCRIPTs, BLOCKs, as all these\n      // are the only legal place for VARs.\n      if (NodeUtil.isStatementBlock(n)) {\n        splitVarDeclarations(n);\n      }\n\n      if (n.getType() == Token.FUNCTION) {\n        moveNamedFunctions(n.getLastChild());\n      }\n    }",
    "comment": " Do normalizations that introduce new siblings or parents. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "NormalizeStatements.extractForInitializer",
    "class_name": "com.google.javascript.jscomp.Normalize$NormalizeStatements",
    "signature": "com.google.javascript.jscomp.Normalize$NormalizeStatements.extractForInitializer(Node,Node,Node)",
    "snippet": "    private void extractForInitializer(\n        Node n, Node before, Node beforeParent) {\n\n      for (Node next, c = n.getFirstChild(); c != null; c = next) {\n        next = c.getNext();\n        Node insertBefore = (before == null) ? c : before;\n        Node insertBeforeParent = (before == null) ? n : beforeParent;\n        switch (c.getType()) {\n          case Token.LABEL:\n            extractForInitializer(c, insertBefore, insertBeforeParent);\n            break;\n          case Token.FOR:\n            if (NodeUtil.isForIn(c)) {\n              Node first = c.getFirstChild();\n              if (first.getType() == Token.VAR) {\n                // Transform:\n                //    for (var a = 1 in b) {}\n                // to:\n                //    var a = 1; for (a in b) {};\n                Node newStatement = first;\n                // Clone just the node, to remove any initialization.\n                Node name = newStatement.getFirstChild().cloneNode();\n                first.getParent().replaceChild(first, name);\n                insertBeforeParent.addChildBefore(newStatement, insertBefore);\n                reportCodeChange(\"FOR-IN var declaration\");\n              }\n            } else if (c.getFirstChild().getType() != Token.EMPTY) {\n              Node init = c.getFirstChild();\n              Node empty = new Node(Token.EMPTY);\n              empty.copyInformationFrom(c);\n              c.replaceChild(init, empty);\n\n              Node newStatement;\n              // Only VAR statements, and expressions are allowed,\n              // but are handled differently.\n              if (init.getType() == Token.VAR) {\n                newStatement = init;\n              } else {\n                newStatement = NodeUtil.newExpr(init);\n              }\n\n              insertBeforeParent.addChildBefore(newStatement, insertBefore);\n              reportCodeChange(\"FOR initializer\");\n            }\n            break;\n        }\n      }\n    }",
    "comment": " Bring the initializers out of FOR loops.  These need to be placed before any associated LABEL nodes. This needs to be done from the top level label first so this is called as a pre-order callback (from shouldTraverse).  @param n The node to inspect. @param before The node to insert the initializer before. @param beforeParent The parent of the node before which the initializer will be inserted. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "NormalizeStatements.moveNamedFunctions",
    "class_name": "com.google.javascript.jscomp.Normalize$NormalizeStatements",
    "signature": "com.google.javascript.jscomp.Normalize$NormalizeStatements.moveNamedFunctions(Node)",
    "snippet": "    private void moveNamedFunctions(Node functionBody) {\n      Preconditions.checkState(\n          functionBody.getParent().getType() == Token.FUNCTION);\n      Node previous = null;\n      Node current = functionBody.getFirstChild();\n      // Skip any declarations at the beginning of the function body, they\n      // are already in the right place.\n      while (current != null && NodeUtil.isFunctionDeclaration(current)) {\n        previous = current;\n        current = current.getNext();\n      }\n\n      // Find any remaining declarations and move them.\n      Node insertAfter = previous;\n      while (current != null) {\n        // Save off the next node as the current node maybe removed.\n        Node next = current.getNext();\n        if (NodeUtil.isFunctionDeclaration(current)) {\n          // Remove the declaration from the body.\n          Preconditions.checkNotNull(previous);\n          functionBody.removeChildAfter(previous);\n\n          // Readd the function at the top of the function body (after any\n          // previous declarations).\n          insertAfter = addToFront(functionBody, current, insertAfter);\n          reportCodeChange(\"Move function declaration not at top of function\");\n        } else {\n          // Update the previous only if the current node hasn't been moved.\n          previous = current;\n        }\n        current = next;\n      }\n    }",
    "comment": " Move all the functions that are valid at the execution of the first statement of the function to the beginning of the function definition. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "NormalizeStatements.normalizeFunctionDeclaration",
    "class_name": "com.google.javascript.jscomp.Normalize$NormalizeStatements",
    "signature": "com.google.javascript.jscomp.Normalize$NormalizeStatements.normalizeFunctionDeclaration(Node)",
    "snippet": "    private void normalizeFunctionDeclaration(Node n) {\n      Preconditions.checkState(n.getType() == Token.FUNCTION);\n      if (!NodeUtil.isFunctionExpression(n)\n          && !NodeUtil.isHoistedFunctionDeclaration(n)) {\n        rewriteFunctionDeclaration(n);\n      }\n    }",
    "comment": " Rewrite named unhoisted functions declarations to a known consistent behavior so we don't to different logic paths for the same code. From: function f() {} to: var f = function () {}; ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "NormalizeStatements.normalizeLabels",
    "class_name": "com.google.javascript.jscomp.Normalize$NormalizeStatements",
    "signature": "com.google.javascript.jscomp.Normalize$NormalizeStatements.normalizeLabels(Node)",
    "snippet": "    private void normalizeLabels(Node n) {\n      Preconditions.checkArgument(n.getType() == Token.LABEL);\n\n      Node last = n.getLastChild();\n      switch (last.getType()) {\n        case Token.LABEL:\n        case Token.BLOCK:\n        case Token.FOR:\n        case Token.WHILE:\n        case Token.DO:\n          return;\n        default:\n          Node block = new Node(Token.BLOCK);\n          block.copyInformationFrom(last);\n          n.replaceChild(last, block);\n          block.addChildToFront(last);\n          reportCodeChange(\"LABEL normalization\");\n          return;\n      }\n    }",
    "comment": " Limit the number of special cases where LABELs need to be handled. Only BLOCK and loops are allowed to be labeled.  Loop labels must remain in place as the named continues are not allowed for labeled blocks. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "NormalizeStatements.shouldTraverse",
    "class_name": "com.google.javascript.jscomp.Normalize$NormalizeStatements",
    "signature": "com.google.javascript.jscomp.Normalize$NormalizeStatements.shouldTraverse(NodeTraversal,Node,Node)",
    "snippet": "    @Override\n    public boolean shouldTraverse(NodeTraversal t, Node n, Node parent) {\n      doStatementNormalizations(t, n, parent);\n\n      return true;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "NormalizeStatements.splitVarDeclarations",
    "class_name": "com.google.javascript.jscomp.Normalize$NormalizeStatements",
    "signature": "com.google.javascript.jscomp.Normalize$NormalizeStatements.splitVarDeclarations(Node)",
    "snippet": "    private void splitVarDeclarations(Node n) {\n      for (Node next, c = n.getFirstChild(); c != null; c = next) {\n        next = c.getNext();\n        if (c.getType() == Token.VAR) {\n          if (assertOnChange && !c.hasChildren()) {\n            throw new IllegalStateException(\"Empty VAR node.\");\n          }\n\n          while (c.getFirstChild() != c.getLastChild()) {\n            Node name = c.getFirstChild();\n            c.removeChild(name);\n            Node newVar = new Node(\n                Token.VAR, name, n.getLineno(), n.getCharno());\n            n.addChildBefore(newVar, c);\n            reportCodeChange(\"VAR with multiple children\");\n          }\n        }\n      }\n    }",
    "comment": " Split a var node such as: var a, b; into individual statements: var a; var b; @param n The whose children we should inspect. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "NormalizeStatements.visit",
    "class_name": "com.google.javascript.jscomp.Normalize$NormalizeStatements",
    "signature": "com.google.javascript.jscomp.Normalize$NormalizeStatements.visit(NodeTraversal,Node,Node)",
    "snippet": "    @Override\n    public void visit(NodeTraversal t, Node n, Node parent) {\n      switch (n.getType()) {\n        case Token.WHILE:\n          if (CONVERT_WHILE_TO_FOR) {\n            Node expr = n.getFirstChild();\n            n.setType(Token.FOR);\n            Node empty = new Node(Token.EMPTY);\n            empty.copyInformationFrom(n);\n            n.addChildBefore(empty, expr);\n            n.addChildAfter(empty.cloneNode(), expr);\n            reportCodeChange(\"WHILE node\");\n          }\n          break;\n\n        case Token.FUNCTION:\n          normalizeFunctionDeclaration(n);\n          break;\n\n        case Token.NAME:\n        case Token.STRING:\n        case Token.GET:\n        case Token.SET:\n          if (!compiler.getLifeCycleStage().isNormalizedObfuscated()) {\n            annotateConstantsByConvention(n, parent);\n          }\n          break;\n      }\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "PropagateConstantAnnotationsOverVars.process",
    "class_name": "com.google.javascript.jscomp.Normalize$PropagateConstantAnnotationsOverVars",
    "signature": "com.google.javascript.jscomp.Normalize$PropagateConstantAnnotationsOverVars.process(Node,Node)",
    "snippet": "    @Override\n    public void process(Node externs, Node root) {\n      new NodeTraversal(compiler, this).traverseRoots(externs, root);\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "PropagateConstantAnnotationsOverVars.visit",
    "class_name": "com.google.javascript.jscomp.Normalize$PropagateConstantAnnotationsOverVars",
    "signature": "com.google.javascript.jscomp.Normalize$PropagateConstantAnnotationsOverVars.visit(NodeTraversal,Node,Node)",
    "snippet": "    @Override\n    public void visit(NodeTraversal t, Node n, Node parent) {\n      // Note: Constant properties annotations are not propagated.\n      if (n.getType() == Token.NAME) {\n        if (n.getString().isEmpty()) {\n          return;\n        }\n\n        JSDocInfo info = null;\n        // Find the JSDocInfo for a top level variable.\n        Var var = t.getScope().getVar(n.getString());\n        if (var != null) {\n          info = var.getJSDocInfo();\n        }\n\n        boolean shouldBeConstant =\n            (info != null && info.isConstant()) ||\n            NodeUtil.isConstantByConvention(\n                compiler.getCodingConvention(), n, parent);\n        boolean isMarkedConstant = n.getBooleanProp(Node.IS_CONSTANT_NAME);\n        if (shouldBeConstant && !isMarkedConstant) {\n          if (assertOnChange) {\n            String name = n.getString();\n            throw new IllegalStateException(\n                \"Unexpected const change.\\n\" +\n                \"  name: \"+ name + \"\\n\" +\n                \"  parent:\" + n.getParent().toStringTree());\n          }\n          n.putBooleanProp(Node.IS_CONSTANT_NAME, true);\n        }\n      }\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "ScopeTicklingCallback.enterScope",
    "class_name": "com.google.javascript.jscomp.Normalize$ScopeTicklingCallback",
    "signature": "com.google.javascript.jscomp.Normalize$ScopeTicklingCallback.enterScope(NodeTraversal)",
    "snippet": "    @Override\n    public void enterScope(NodeTraversal t) {\n      // Cause the scope to be created, which will cause duplicate\n      // to be found.\n      t.getScope();\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "ScopeTicklingCallback.exitScope",
    "class_name": "com.google.javascript.jscomp.Normalize$ScopeTicklingCallback",
    "signature": "com.google.javascript.jscomp.Normalize$ScopeTicklingCallback.exitScope(NodeTraversal)",
    "snippet": "    @Override\n    public void exitScope(NodeTraversal t) {\n      // Nothing to do.\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "ScopeTicklingCallback.shouldTraverse",
    "class_name": "com.google.javascript.jscomp.Normalize$ScopeTicklingCallback",
    "signature": "com.google.javascript.jscomp.Normalize$ScopeTicklingCallback.shouldTraverse(NodeTraversal,Node,Node)",
    "snippet": "    @Override\n    public boolean shouldTraverse(\n        NodeTraversal nodeTraversal, Node n, Node parent) {\n      return true;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "ScopeTicklingCallback.visit",
    "class_name": "com.google.javascript.jscomp.Normalize$ScopeTicklingCallback",
    "signature": "com.google.javascript.jscomp.Normalize$ScopeTicklingCallback.visit(NodeTraversal,Node,Node)",
    "snippet": "    @Override\n    public void visit(NodeTraversal t, Node n, Node parent) {\n      // Nothing to do.\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "VerifyConstants.process",
    "class_name": "com.google.javascript.jscomp.Normalize$VerifyConstants",
    "signature": "com.google.javascript.jscomp.Normalize$VerifyConstants.process(Node,Node)",
    "snippet": "    @Override\n    public void process(Node externs, Node root) {\n      Node externsAndJs = root.getParent();\n      Preconditions.checkState(externsAndJs != null);\n      Preconditions.checkState(externsAndJs.hasChild(externs));\n\n      NodeTraversal.traverseRoots(\n          compiler, Lists.newArrayList(externs, root), this);\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "VerifyConstants.visit",
    "class_name": "com.google.javascript.jscomp.Normalize$VerifyConstants",
    "signature": "com.google.javascript.jscomp.Normalize$VerifyConstants.visit(NodeTraversal,Node,Node)",
    "snippet": "    @Override\n    public void visit(NodeTraversal t, Node n, Node parent) {\n      if (n.getType() == Token.NAME) {\n        String name = n.getString();\n        if (n.getString().isEmpty()) {\n          return;\n        }\n\n        boolean isConst = n.getBooleanProp(Node.IS_CONSTANT_NAME);\n        if (checkUserDeclarations) {\n          boolean expectedConst = false;\n          CodingConvention convention = compiler.getCodingConvention();\n          if (NodeUtil.isConstantName(n)\n              || NodeUtil.isConstantByConvention(convention, n, parent)) {\n            expectedConst = true;\n          } else {\n            expectedConst = false;\n\n            JSDocInfo info = null;\n            Var var = t.getScope().getVar(n.getString());\n            if (var != null) {\n              info = var.getJSDocInfo();\n            }\n\n            if (info != null && info.isConstant()) {\n              expectedConst = true;\n            } else {\n              expectedConst = false;\n            }\n          }\n\n          if (expectedConst) {\n            Preconditions.checkState(expectedConst == isConst,\n                \"The name \" + name + \" is not annotated as constant.\");\n          } else {\n            Preconditions.checkState(expectedConst == isConst,\n                \"The name \" + name + \" should not be annotated as constant.\");\n          }\n        }\n\n        Boolean value = constantMap.get(name);\n        if (value == null) {\n          constantMap.put(name, isConst);\n        } else {\n          Preconditions.checkState(value.booleanValue() == isConst,\n              \"The name \" + name + \" is not consistently annotated as \" +\n              \"constant.\");\n        }\n      }\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "PassFactory.PassFactory",
    "class_name": "com.google.javascript.jscomp.PassFactory",
    "signature": "com.google.javascript.jscomp.PassFactory.PassFactory(String,boolean)",
    "snippet": "  protected PassFactory(String name, boolean isOneTimePass) {\n    this.name = name;\n    this.isOneTimePass = isOneTimePass;\n  }",
    "comment": " @param name The name of the pass that this factory creates. @param isOneTimePass If true, the pass produced by this factory can only be run once. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "PrepareAst.PrepareAst",
    "class_name": "com.google.javascript.jscomp.PrepareAst",
    "signature": "com.google.javascript.jscomp.PrepareAst.PrepareAst(AbstractCompiler)",
    "snippet": "  PrepareAst(AbstractCompiler compiler) {\n    this(compiler, false);\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "PrepareAst.PrepareAst",
    "class_name": "com.google.javascript.jscomp.PrepareAst",
    "signature": "com.google.javascript.jscomp.PrepareAst.PrepareAst(AbstractCompiler,boolean)",
    "snippet": "  PrepareAst(AbstractCompiler compiler, boolean checkOnly) {\n    this.compiler = compiler;\n    this.checkOnly = checkOnly;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "PrepareAst.process",
    "class_name": "com.google.javascript.jscomp.PrepareAst",
    "signature": "com.google.javascript.jscomp.PrepareAst.process(Node,Node)",
    "snippet": "  @Override\n  public void process(Node externs, Node root) {\n    if (checkOnly) {\n      normalizeNodeTypes(root);\n    } else {\n      // Don't perform \"PrepareAnnotations\" when doing checks as\n      // they currently aren't valid during sanity checks.  In particular,\n      // they DIRECT_EVAL shouldn't be applied after inlining has been\n      // performed.\n      if (externs != null) {\n        NodeTraversal.traverse(\n            compiler, externs, new PrepareAnnotations(compiler));\n      }\n      if (root != null) {\n        NodeTraversal.traverse(\n            compiler, root, new PrepareAnnotations(compiler));\n      }\n    }\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "PrepareAnnotations.annotateCalls",
    "class_name": "com.google.javascript.jscomp.PrepareAst$PrepareAnnotations",
    "signature": "com.google.javascript.jscomp.PrepareAst$PrepareAnnotations.annotateCalls(Node)",
    "snippet": "    private void annotateCalls(Node n) {\n      Preconditions.checkState(n.getType() == Token.CALL);\n\n      // Keep track of of the \"this\" context of a call.  A call without an\n      // explicit \"this\" is a free call.\n      Node first = n.getFirstChild();\n      if (!NodeUtil.isGet(first)) {\n        n.putBooleanProp(Node.FREE_CALL, true);\n      }\n\n      // Keep track of the context in which eval is called. It is important\n      // to distinguish between \"(0, eval)()\" and \"eval()\".\n      if (first.getType() == Token.NAME &&\n          \"eval\".equals(first.getString())) {\n        first.putBooleanProp(Node.DIRECT_EVAL, true);\n      }\n    }",
    "comment": " There are two types of calls we are interested in calls without explicit \"this\" values (what we are call \"free\" calls) and direct call to eval. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "PrepareAnnotations.annotateDispatchers",
    "class_name": "com.google.javascript.jscomp.PrepareAst$PrepareAnnotations",
    "signature": "com.google.javascript.jscomp.PrepareAst$PrepareAnnotations.annotateDispatchers(Node,Node)",
    "snippet": "    private void annotateDispatchers(Node n, Node parent) {\n      Preconditions.checkState(n.getType() == Token.FUNCTION);\n      if (parent.getJSDocInfo() != null\n          && parent.getJSDocInfo().isJavaDispatch()) {\n        if (parent.getType() == Token.ASSIGN) {\n          Preconditions.checkState(parent.getLastChild() == n);\n          n.putBooleanProp(Node.IS_DISPATCHER, true);\n        }\n      }\n    }",
    "comment": " Translate dispatcher info into the property expected node. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "PrepareAnnotations.annotateFunctions",
    "class_name": "com.google.javascript.jscomp.PrepareAst$PrepareAnnotations",
    "signature": "com.google.javascript.jscomp.PrepareAst$PrepareAnnotations.annotateFunctions(Node,Node)",
    "snippet": "    private void annotateFunctions(Node n, Node parent) {\n      JSDocInfo fnInfo = NodeUtil.getFunctionInfo(n);\n\n      // Compute which function parameters are optional and\n      // which are var_args.\n      Node args = n.getFirstChild().getNext();\n      for (Node arg = args.getFirstChild();\n           arg != null;\n           arg = arg.getNext()) {\n        String argName = arg.getString();\n        JSTypeExpression typeExpr = fnInfo == null ?\n            null : fnInfo.getParameterType(argName);\n\n        if (convention.isOptionalParameter(arg) ||\n            typeExpr != null && typeExpr.isOptionalArg()) {\n          arg.putBooleanProp(Node.IS_OPTIONAL_PARAM, true);\n        }\n        if (convention.isVarArgsParameter(arg) ||\n            typeExpr != null && typeExpr.isVarArgs()) {\n          arg.putBooleanProp(Node.IS_VAR_ARGS_PARAM, true);\n        }\n      }\n    }",
    "comment": " Annotate optional and var_arg function parameters. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "PrepareAnnotations.shouldTraverse",
    "class_name": "com.google.javascript.jscomp.PrepareAst$PrepareAnnotations",
    "signature": "com.google.javascript.jscomp.PrepareAst$PrepareAnnotations.shouldTraverse(NodeTraversal,Node,Node)",
    "snippet": "    @Override\n    public boolean shouldTraverse(NodeTraversal t, Node n, Node parent) {\n      if (n.getType() == Token.OBJECTLIT) {\n        normalizeObjectLiteralAnnotations(n);\n      }\n      return true;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "PrepareAnnotations.visit",
    "class_name": "com.google.javascript.jscomp.PrepareAst$PrepareAnnotations",
    "signature": "com.google.javascript.jscomp.PrepareAst$PrepareAnnotations.visit(NodeTraversal,Node,Node)",
    "snippet": "    @Override\n    public void visit(NodeTraversal t, Node n, Node parent) {\n      switch (n.getType()) {\n        case Token.CALL:\n          annotateCalls(n);\n          break;\n\n        case Token.FUNCTION:\n          annotateFunctions(n, parent);\n          annotateDispatchers(n, parent);\n          break;\n      }\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "TweakFunction.getName",
    "class_name": "com.google.javascript.jscomp.ProcessTweaks$TweakFunction",
    "signature": "com.google.javascript.jscomp.ProcessTweaks$TweakFunction.getName()",
    "snippet": "    String getName() {\n      return name;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "RhinoErrorReporter.forNewRhino",
    "class_name": "com.google.javascript.jscomp.RhinoErrorReporter",
    "signature": "com.google.javascript.jscomp.RhinoErrorReporter.forNewRhino(AbstractCompiler)",
    "snippet": "  public static com.google.javascript.jscomp.mozilla.rhino.ErrorReporter\n      forNewRhino(AbstractCompiler compiler) {\n    return new NewRhinoErrorReporter(compiler);\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "RhinoErrorReporter.forOldRhino",
    "class_name": "com.google.javascript.jscomp.RhinoErrorReporter",
    "signature": "com.google.javascript.jscomp.RhinoErrorReporter.forOldRhino(AbstractCompiler)",
    "snippet": "  public static ErrorReporter forOldRhino(AbstractCompiler compiler) {\n    return new OldRhinoErrorReporter(compiler);\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "RhinoErrorReporter.replacePlaceHolders",
    "class_name": "com.google.javascript.jscomp.RhinoErrorReporter",
    "signature": "com.google.javascript.jscomp.RhinoErrorReporter.replacePlaceHolders(String)",
    "snippet": "  private Pattern replacePlaceHolders(String s) {\n    s = Pattern.quote(s);\n    return Pattern.compile(s.replaceAll(\"\\\\{\\\\d+\\\\}\", \"\\\\\\\\E.*\\\\\\\\Q\"));\n  }",
    "comment": " For each message such as \"Not a good use of {0}\", replace the place holder {0} with a wild card that matches all possible strings. Also put the any non-place-holder in quotes for regex matching later. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "Scope.Scope",
    "class_name": "com.google.javascript.jscomp.Scope",
    "signature": "com.google.javascript.jscomp.Scope.Scope(Node,AbstractCompiler)",
    "snippet": "  Scope(Node rootNode, AbstractCompiler compiler) {\n    this.parent = null;\n    this.rootNode = rootNode;\n    thisType = compiler.getTypeRegistry().getNativeObjectType(GLOBAL_THIS);\n    this.isBottom = false;\n    this.depth = 0;\n  }",
    "comment": " Creates a global Scope. @param rootNode  Typically the global BLOCK node. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "Scope.Scope",
    "class_name": "com.google.javascript.jscomp.Scope",
    "signature": "com.google.javascript.jscomp.Scope.Scope(Scope,Node)",
    "snippet": "  Scope(Scope parent, Node rootNode) {\n    Preconditions.checkNotNull(parent);\n    Preconditions.checkArgument(rootNode != parent.rootNode);\n\n    this.parent = parent;\n    this.rootNode = rootNode;\n    JSType nodeType = rootNode.getJSType();\n    if (nodeType != null && nodeType instanceof FunctionType) {\n      thisType = ((FunctionType) nodeType).getTypeOfThis();\n    } else {\n      thisType = parent.thisType;\n    }\n    this.isBottom = false;\n    this.depth = parent.depth + 1;\n  }",
    "comment": " Creates a Scope given the parent Scope and the root node of the scope. @param parent  The parent Scope. Cannot be null. @param rootNode  Typically the FUNCTION node. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "Scope.declare",
    "class_name": "com.google.javascript.jscomp.Scope",
    "signature": "com.google.javascript.jscomp.Scope.declare(String,Node,JSType,CompilerInput)",
    "snippet": "  Var declare(String name, Node nameNode, JSType type, CompilerInput input) {\n    return declare(name, nameNode, type, input, true);\n  }",
    "comment": " Declares a variable whose type is inferred.  @param name name of the variable @param nameNode the NAME node declaring the variable @param type the variable's type @param input the input in which this variable is defined. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "Scope.declare",
    "class_name": "com.google.javascript.jscomp.Scope",
    "signature": "com.google.javascript.jscomp.Scope.declare(String,Node,JSType,CompilerInput,boolean)",
    "snippet": "  Var declare(String name, Node nameNode,\n      JSType type, CompilerInput input, boolean inferred) {\n    Preconditions.checkState(name != null && name.length() > 0);\n\n    // Make sure that it's declared only once\n    Preconditions.checkState(vars.get(name) == null);\n\n    // native variables do not have a name node.\n    // TODO(user): make Var abstract and have NativeVar, NormalVar.\n    JSDocInfo info = NodeUtil.getInfoForNameNode(nameNode);\n\n    Var var = new Var(inferred, name, nameNode, type, this, vars.size(), input,\n        info != null && info.isDefine(), info);\n\n    vars.put(name, var);\n    return var;\n  }",
    "comment": " Declares a variable.  @param name name of the variable @param nameNode the NAME node declaring the variable @param type the variable's type @param input the input in which this variable is defined. @param inferred Whether this variable's type is inferred (as opposed to declared). ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "Scope.getParent",
    "class_name": "com.google.javascript.jscomp.Scope",
    "signature": "com.google.javascript.jscomp.Scope.getParent()",
    "snippet": "  public Scope getParent() {\n    return parent;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "Scope.getVar",
    "class_name": "com.google.javascript.jscomp.Scope",
    "signature": "com.google.javascript.jscomp.Scope.getVar(String)",
    "snippet": "  public Var getVar(String name) {\n    Var var = vars.get(name);\n    if (var != null) {\n      return var;\n    } else if (parent != null) { // Recurse up the parent Scope\n      return parent.getVar(name);\n    } else {\n      return null;\n    }\n  }",
    "comment": " Returns the variable, may be null ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "Scope.isDeclared",
    "class_name": "com.google.javascript.jscomp.Scope",
    "signature": "com.google.javascript.jscomp.Scope.isDeclared(String,boolean)",
    "snippet": "  public boolean isDeclared(String name, boolean recurse) {\n    Scope scope = this;\n    if (scope.vars.containsKey(name))\n      return true;\n\n    if (scope.parent != null && recurse) {\n      return scope.parent.isDeclared(name, recurse);\n    }\n    return false;\n  }",
    "comment": " Returns true if a variable is declared. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "Scope.isGlobal",
    "class_name": "com.google.javascript.jscomp.Scope",
    "signature": "com.google.javascript.jscomp.Scope.isGlobal()",
    "snippet": "  public boolean isGlobal() {\n    return parent == null;\n  }",
    "comment": " Returns whether this is the global scope. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "Scope.isLocal",
    "class_name": "com.google.javascript.jscomp.Scope",
    "signature": "com.google.javascript.jscomp.Scope.isLocal()",
    "snippet": "  public boolean isLocal() {\n    return !isGlobal();\n  }",
    "comment": " Returns whether this is a local scope (i.e. not the global scope). ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "Var.getJSDocInfo",
    "class_name": "com.google.javascript.jscomp.Scope$Var",
    "signature": "com.google.javascript.jscomp.Scope$Var.getJSDocInfo()",
    "snippet": "    public JSDocInfo getJSDocInfo() {\n      return info;\n    }",
    "comment": " Gets the JSDocInfo for the variable. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "SimpleDefinitionFinder.SimpleDefinitionFinder",
    "class_name": "com.google.javascript.jscomp.SimpleDefinitionFinder",
    "signature": "com.google.javascript.jscomp.SimpleDefinitionFinder.SimpleDefinitionFinder(AbstractCompiler)",
    "snippet": "  public SimpleDefinitionFinder(AbstractCompiler compiler) {\n    this.compiler = compiler;\n    this.definitionSiteMap = Maps.newLinkedHashMap();\n    this.nameDefinitionMultimap = HashMultimap.create();\n    this.nameUseSiteMultimap = HashMultimap.create();\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "SimpleDefinitionFinder.getDefinitionsReferencedAt",
    "class_name": "com.google.javascript.jscomp.SimpleDefinitionFinder",
    "signature": "com.google.javascript.jscomp.SimpleDefinitionFinder.getDefinitionsReferencedAt(Node)",
    "snippet": "  @Override\n  public Collection<Definition> getDefinitionsReferencedAt(Node useSite) {\n    if (definitionSiteMap.containsKey(useSite)) {\n      return null;\n    }\n\n    if (NodeUtil.isGetProp(useSite)) {\n      String propName = useSite.getLastChild().getString();\n      if (propName.equals(\"apply\") || propName.equals(\"call\")) {\n        useSite = useSite.getFirstChild();\n      }\n    }\n\n    String name = getSimplifiedName(useSite);\n    if (name != null) {\n      Collection<Definition> defs = nameDefinitionMultimap.get(name);\n      if (!defs.isEmpty()) {\n        return defs;\n      } else {\n        return null;\n      }\n    } else {\n      return null;\n    }\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "SimpleDefinitionFinder.getSimplifiedName",
    "class_name": "com.google.javascript.jscomp.SimpleDefinitionFinder",
    "signature": "com.google.javascript.jscomp.SimpleDefinitionFinder.getSimplifiedName(Node)",
    "snippet": "  private static String getSimplifiedName(Node node) {\n    if (NodeUtil.isName(node)) {\n      String name = node.getString();\n      if (name != null && !name.isEmpty()) {\n        return name;\n      } else {\n        return null;\n      }\n    } else if (NodeUtil.isGetProp(node)) {\n      return \"this.\" + node.getLastChild().getString();\n    }\n    return null;\n  }",
    "comment": " Extract a name from a node.  In the case of GETPROP nodes, replace the namespace or object expression with \"this\" for simplicity and correctness at the expense of inefficiencies due to higher chances of name collisions.  TODO(user) revisit.  it would be helpful to at least use fully qualified names in the case of namespaces.  Might not matter as much if this pass runs after \"collapsing properties\". ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "SimpleDefinitionFinder.process",
    "class_name": "com.google.javascript.jscomp.SimpleDefinitionFinder",
    "signature": "com.google.javascript.jscomp.SimpleDefinitionFinder.process(Node,Node)",
    "snippet": "  @Override\n  public void process(Node externs, Node source) {\n    NodeTraversal.traverse(\n        compiler, externs, new DefinitionGatheringCallback(true));\n    NodeTraversal.traverse(\n        compiler, source, new DefinitionGatheringCallback(false));\n    NodeTraversal.traverse(\n        compiler, source, new UseSiteGatheringCallback());\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "DefinitionGatheringCallback.visit",
    "class_name": "com.google.javascript.jscomp.SimpleDefinitionFinder$DefinitionGatheringCallback",
    "signature": "com.google.javascript.jscomp.SimpleDefinitionFinder$DefinitionGatheringCallback.visit(NodeTraversal,Node,Node)",
    "snippet": "    @Override\n    public void visit(NodeTraversal traversal, Node node, Node parent) {\n      // Arguments of external functions should not count as name\n      // definitions.  They are placeholder names for documentation\n      // purposes only which are not reachable from anywhere.\n      if (inExterns && NodeUtil.isName(node) && parent.getType() == Token.LP) {\n        return;\n      }\n\n      Definition def =\n          DefinitionsRemover.getDefinition(node, inExterns);\n      if (def != null) {\n        String name = getSimplifiedName(def.getLValue());\n        if (name != null) {\n          Node rValue = def.getRValue();\n          if ((rValue != null) &&\n              !NodeUtil.isImmutableValue(rValue) &&\n              !NodeUtil.isFunction(rValue)) {\n\n            // Unhandled complex expression\n            Definition unknownDef =\n                new UnknownDefinition(def.getLValue(), inExterns);\n            def = unknownDef;\n          }\n\n          // TODO(johnlenz) : remove this stub dropping code if it becomes\n          // illegal to have untyped stubs in the externs definitions.\n          if (inExterns) {\n            // We need special handling of untyped externs stubs here:\n            //    the stub should be dropped if the name is provided elsewhere.\n\n            List<Definition> stubsToRemove = Lists.newArrayList();\n            String qualifiedName = node.getQualifiedName();\n\n            // If there is no qualified name for this, then there will be\n            // no stubs to remove. This will happen if node is an object\n            // literal key.\n            if (qualifiedName != null) {\n              for (Definition prevDef : nameDefinitionMultimap.get(name)) {\n                if (prevDef instanceof ExternalNameOnlyDefinition\n                    && !jsdocContainsDeclarations(node)) {\n                  String prevName = prevDef.getLValue().getQualifiedName();\n                  if (qualifiedName.equals(prevName)) {\n                    // Drop this stub, there is a real definition.\n                    stubsToRemove.add(prevDef);\n                  }\n                }\n              }\n\n              for (Definition prevDef : stubsToRemove) {\n                nameDefinitionMultimap.remove(name, prevDef);\n              }\n            }\n          }\n\n          nameDefinitionMultimap.put(name, def);\n          definitionSiteMap.put(node,\n                                new DefinitionSite(node,\n                                                   def,\n                                                   traversal.getModule(),\n                                                   traversal.inGlobalScope(),\n                                                   inExterns));\n        }\n      }\n\n      if (inExterns && (parent != null) && NodeUtil.isExpressionNode(parent)) {\n        String name = getSimplifiedName(node);\n        if (name != null) {\n\n          // TODO(johnlenz) : remove this code if it becomes illegal to have\n          // stubs in the externs definitions.\n\n          // We need special handling of untyped externs stubs here:\n          //    the stub should be dropped if the name is provided elsewhere.\n          // We can't just drop the stub now as it needs to be used as the\n          //    externs definition if no other definition is provided.\n\n          boolean dropStub = false;\n          if (!jsdocContainsDeclarations(node)) {\n            String qualifiedName = node.getQualifiedName();\n            if (qualifiedName != null) {\n              for (Definition prevDef : nameDefinitionMultimap.get(name)) {\n                String prevName = prevDef.getLValue().getQualifiedName();\n                if (qualifiedName.equals(prevName)) {\n                  dropStub = true;\n                  break;\n                }\n              }\n            }\n          }\n\n          if (!dropStub) {\n            // Incomplete definition\n            Definition definition = new ExternalNameOnlyDefinition(node);\n            nameDefinitionMultimap.put(name, definition);\n            definitionSiteMap.put(node,\n                                  new DefinitionSite(node,\n                                                     definition,\n                                                     traversal.getModule(),\n                                                     traversal.inGlobalScope(),\n                                                     inExterns));\n          }\n        }\n      }\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "UseSiteGatheringCallback.visit",
    "class_name": "com.google.javascript.jscomp.SimpleDefinitionFinder$UseSiteGatheringCallback",
    "signature": "com.google.javascript.jscomp.SimpleDefinitionFinder$UseSiteGatheringCallback.visit(NodeTraversal,Node,Node)",
    "snippet": "    @Override\n    public void visit(NodeTraversal traversal, Node node, Node parent) {\n\n      Collection<Definition> defs = getDefinitionsReferencedAt(node);\n      if (defs == null) {\n        return;\n      }\n\n      Definition first = defs.iterator().next();\n\n      String name = getSimplifiedName(first.getLValue());\n      Preconditions.checkNotNull(name);\n      nameUseSiteMultimap.put(\n          name,\n          new UseSite(node, traversal.getScope(), traversal.getModule()));\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "SourceFile.SourceFile",
    "class_name": "com.google.javascript.jscomp.SourceFile",
    "signature": "com.google.javascript.jscomp.SourceFile.SourceFile(String)",
    "snippet": "  SourceFile(String fileName) {\n    this.fileName = fileName;\n    // Starting point: offset 0 is at line 1.\n    this.lastOffset = 0;\n    this.lastLine = 1;\n  }",
    "comment": " Construct a new abstract source file.  @param fileName The file name of the source file. It does not necessarily need to correspond to a real path. But it should be unique. Will appear in warning messages emitted by the compiler. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "SourceFile.fromCode",
    "class_name": "com.google.javascript.jscomp.SourceFile",
    "signature": "com.google.javascript.jscomp.SourceFile.fromCode(String,String)",
    "snippet": "  public static SourceFile fromCode(String fileName, String code) {\n    return new Preloaded(fileName, code);\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "SourceFile.getCode",
    "class_name": "com.google.javascript.jscomp.SourceFile",
    "signature": "com.google.javascript.jscomp.SourceFile.getCode()",
    "snippet": "  public String getCode() throws IOException {\n    return code;\n  }",
    "comment": " Gets all the code in this source file. @throws IOException ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "SourceFile.getName",
    "class_name": "com.google.javascript.jscomp.SourceFile",
    "signature": "com.google.javascript.jscomp.SourceFile.getName()",
    "snippet": "  public String getName() {\n    return fileName;\n  }",
    "comment": "Returns a unique name for the source file. */",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "SourceFile.setCode",
    "class_name": "com.google.javascript.jscomp.SourceFile",
    "signature": "com.google.javascript.jscomp.SourceFile.setCode(String)",
    "snippet": "  private void setCode(String sourceCode) {\n    code = sourceCode;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "SourceFile.setOriginalPath",
    "class_name": "com.google.javascript.jscomp.SourceFile",
    "signature": "com.google.javascript.jscomp.SourceFile.setOriginalPath(String)",
    "snippet": "  public void setOriginalPath(String originalPath) {\n    this.originalPath = originalPath;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "SuppressDocWarningsGuard.SuppressDocWarningsGuard",
    "class_name": "com.google.javascript.jscomp.SuppressDocWarningsGuard",
    "signature": "com.google.javascript.jscomp.SuppressDocWarningsGuard.SuppressDocWarningsGuard(Map)",
    "snippet": "  SuppressDocWarningsGuard(Map<String, DiagnosticGroup> suppressableGroups) {\n    for (Map.Entry<String, DiagnosticGroup> entry :\n             suppressableGroups.entrySet()) {\n      suppressors.put(\n          entry.getKey(),\n          new DiagnosticGroupWarningsGuard(\n              entry.getValue(),\n              CheckLevel.OFF));\n    }\n  }",
    "comment": " The suppressable groups, indexed by name. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "SuppressDocWarningsGuard.getPriority",
    "class_name": "com.google.javascript.jscomp.SuppressDocWarningsGuard",
    "signature": "com.google.javascript.jscomp.SuppressDocWarningsGuard.getPriority()",
    "snippet": "  @Override\n  public int getPriority() {\n    // Happens after path-based filtering, but before other times\n    // of filtering.\n    return WarningsGuard.Priority.SUPPRESS_DOC.value;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "SyntacticScopeCreator.SyntacticScopeCreator",
    "class_name": "com.google.javascript.jscomp.SyntacticScopeCreator",
    "signature": "com.google.javascript.jscomp.SyntacticScopeCreator.SyntacticScopeCreator(AbstractCompiler)",
    "snippet": "  SyntacticScopeCreator(AbstractCompiler compiler) {\n    this.compiler = compiler;\n    this.redeclarationHandler = new DefaultRedeclarationHandler();\n  }",
    "comment": " Creates a ScopeCreator. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "SyntacticScopeCreator.SyntacticScopeCreator",
    "class_name": "com.google.javascript.jscomp.SyntacticScopeCreator",
    "signature": "com.google.javascript.jscomp.SyntacticScopeCreator.SyntacticScopeCreator(AbstractCompiler,RedeclarationHandler)",
    "snippet": "  SyntacticScopeCreator(\n      AbstractCompiler compiler, RedeclarationHandler redeclarationHandler) {\n    this.compiler = compiler;\n    this.redeclarationHandler = redeclarationHandler;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "SyntacticScopeCreator.createScope",
    "class_name": "com.google.javascript.jscomp.SyntacticScopeCreator",
    "signature": "com.google.javascript.jscomp.SyntacticScopeCreator.createScope(Node,Scope)",
    "snippet": "  public Scope createScope(Node n, Scope parent) {\n    sourceName = null;\n    if (parent == null) {\n      scope = new Scope(n, compiler);\n    } else {\n      scope = new Scope(parent, n);\n    }\n\n    scanRoot(n, parent);\n\n    sourceName = null;\n    Scope returnedScope = scope;\n    scope = null;\n    return returnedScope;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "SyntacticScopeCreator.declareVar",
    "class_name": "com.google.javascript.jscomp.SyntacticScopeCreator",
    "signature": "com.google.javascript.jscomp.SyntacticScopeCreator.declareVar(Node)",
    "snippet": "  private void declareVar(Node n) {\n    Preconditions.checkState(n.getType() == Token.NAME);\n\n    CompilerInput input = compiler.getInput(sourceName);\n    String name = n.getString();\n    if (scope.isDeclared(name, false)\n        || (scope.isLocal() && name.equals(ARGUMENTS))) {\n      redeclarationHandler.onRedeclaration(\n          scope, name, n, input);\n    } else {\n      scope.declare(name, n, null, input);\n    }\n  }",
    "comment": " Declares a variable.  @param n The node corresponding to the variable name. @param declaredType The variable's type, according to JSDoc ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "SyntacticScopeCreator.scanRoot",
    "class_name": "com.google.javascript.jscomp.SyntacticScopeCreator",
    "signature": "com.google.javascript.jscomp.SyntacticScopeCreator.scanRoot(Node,Scope)",
    "snippet": "  private void scanRoot(Node n, Scope parent) {\n    if (n.getType() == Token.FUNCTION) {\n      sourceName = (String) n.getProp(Node.SOURCENAME_PROP);\n\n      final Node fnNameNode = n.getFirstChild();\n      final Node args = fnNameNode.getNext();\n      final Node body = args.getNext();\n\n      // Bleed the function name into the scope, if it hasn't\n      // been declared in the outer scope.\n      String fnName = fnNameNode.getString();\n      if (!fnName.isEmpty() && NodeUtil.isFunctionExpression(n)) {\n        declareVar(fnNameNode);\n      }\n\n      // Args: Declare function variables\n      Preconditions.checkState(args.getType() == Token.LP);\n      for (Node a = args.getFirstChild(); a != null;\n           a = a.getNext()) {\n        Preconditions.checkState(a.getType() == Token.NAME);\n        declareVar(a);\n      }\n\n      // Body\n      scanVars(body, n);\n    } else {\n      // It's the global block\n      Preconditions.checkState(scope.getParent() == null);\n      scanVars(n, null);\n    }\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "SyntacticScopeCreator.scanVars",
    "class_name": "com.google.javascript.jscomp.SyntacticScopeCreator",
    "signature": "com.google.javascript.jscomp.SyntacticScopeCreator.scanVars(Node,Node)",
    "snippet": "  private void scanVars(Node n, Node parent) {\n    switch (n.getType()) {\n      case Token.VAR:\n        // Declare all variables. e.g. var x = 1, y, z;\n        for (Node child = n.getFirstChild();\n             child != null;) {\n          Node next = child.getNext();\n          declareVar(child);\n          child = next;\n        }\n        return;\n\n      case Token.FUNCTION:\n        if (NodeUtil.isFunctionExpression(n)) {\n          return;\n        }\n\n        String fnName = n.getFirstChild().getString();\n        if (fnName.isEmpty()) {\n          // This is invalid, but allow it so the checks can catch it.\n          return;\n        }\n        declareVar(n.getFirstChild());\n        return;   // should not examine function's children\n\n      case Token.CATCH:\n        Preconditions.checkState(n.getChildCount() == 2);\n        Preconditions.checkState(n.getFirstChild().getType() == Token.NAME);\n        // the first child is the catch var and the third child\n        // is the code block\n\n        final Node var = n.getFirstChild();\n        final Node block = var.getNext();\n\n        declareVar(var);\n        scanVars(block, n);\n        return;  // only one child to scan\n\n      case Token.SCRIPT:\n        sourceName = (String) n.getProp(Node.SOURCENAME_PROP);\n        break;\n    }\n\n    // Variables can only occur in statement-level nodes, so\n    // we only need to traverse children in a couple special cases.\n    if (NodeUtil.isControlStructure(n) || NodeUtil.isStatementBlock(n)) {\n      for (Node child = n.getFirstChild();\n           child != null;) {\n        Node next = child.getNext();\n        scanVars(child, n);\n        child = next;\n      }\n    }\n  }",
    "comment": " Scans and gather variables declarations under a Node ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "Tracer.Tracer",
    "class_name": "com.google.javascript.jscomp.Tracer",
    "signature": "com.google.javascript.jscomp.Tracer.Tracer(String,String)",
    "snippet": "  Tracer(@Nullable String type, @Nullable String comment) {\n    this.type = type;\n    this.comment = comment == null ? \"\" : comment;\n    startTimeMs = clock.currentTimeMillis();\n    startThread = Thread.currentThread();\n    if (!extraTracingStatistics.isEmpty()) {\n      int size = extraTracingStatistics.size();\n      extraTracingValues = new long[size];\n      int i = 0;\n      for (TracingStatistic tracingStatistic : extraTracingStatistics) {\n        extraTracingValues[i] = tracingStatistic.start(startThread);\n        i++;\n      }\n    }\n\n    ThreadTrace trace = getThreadTrace();\n\n    // Do nothing if the current thread trace wasn't initialized.\n    if (!trace.isInitialized()) {\n      return;\n    }\n\n    // Check if we are creating too many Tracers.\n    if (trace.events.size() >= MAX_TRACE_SIZE) {\n      logger.log(Level.WARNING,\n                  \"Giant thread trace. Too many Tracers created. \"\n                    + \"Clearing to avoid memory leak.\",\n                  new Throwable(trace.toString()));\n      trace.truncateEvents();\n    }\n\n    // Check if we forgot to close the Tracers.\n    if (trace.outstandingEvents.size() >= MAX_TRACE_SIZE) {\n      logger.log(Level.WARNING,\n                  \"Too many outstanding Tracers. Tracer.stop() is missing \"\n                    + \"or Tracer.stop() is not wrapped in a \"\n                    + \"try/finally block. \"\n                    + \"Clearing to avoid memory leak.\",\n                  new Throwable(trace.toString()));\n      trace.truncateOutstandingEvents();\n    }\n\n    trace.startEvent(this);\n  }",
    "comment": " Create and start a tracer. Both type and comment may be null. See class comment for usage.  @param type The type for totalling @param comment Comment about this tracer ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "Tracer.getThreadTrace",
    "class_name": "com.google.javascript.jscomp.Tracer",
    "signature": "com.google.javascript.jscomp.Tracer.getThreadTrace()",
    "snippet": "  static ThreadTrace getThreadTrace() {\n    ThreadTrace t = traces.get();\n    if (t == null) {\n      t = new ThreadTrace();\n      t.prettyPrint = defaultPrettyPrint;\n      traces.set(t);\n    }\n    return t;\n  }",
    "comment": " Get the ThreadTrace for the current thread, creating one if necessary. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "Tracer.stop",
    "class_name": "com.google.javascript.jscomp.Tracer",
    "signature": "com.google.javascript.jscomp.Tracer.stop()",
    "snippet": "  long stop() {\n    return stop(-1);\n  }",
    "comment": "Stop the trace using the default silence_threshold  @return  The time that this trace actually ran. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "Tracer.stop",
    "class_name": "com.google.javascript.jscomp.Tracer",
    "signature": "com.google.javascript.jscomp.Tracer.stop(int)",
    "snippet": "  long stop(int silence_threshold) {\n    Preconditions.checkState(Thread.currentThread() == startThread);\n\n    ThreadTrace trace = getThreadTrace();\n    // Do nothing if the thread trace was not initialized.\n    if (!trace.isInitialized()) {\n      return 0;\n    }\n\n    stopTimeMs = clock.currentTimeMillis();\n    if (extraTracingValues != null) {\n      // We use extraTracingValues.length rather than\n      // extraTracingStatistics.size() because a new statistic may\n      // have been added\n      for (int i = 0; i < extraTracingValues.length; i++) {\n        long value = extraTracingStatistics.get(i).stop(startThread);\n        extraTracingValues[i] = value - extraTracingValues[i];\n      }\n    }\n\n    // Do nothing if the thread trace was not initialized.\n    if (!trace.isInitialized()) {\n      return 0;\n    }\n\n    trace.endEvent(this, silence_threshold);\n    return stopTimeMs - startTimeMs;\n  }",
    "comment": " Stop the trace. This may only be done once and must be done from the same thread that started it. @param silence_threshold Traces for time less than silence_threshold ms will be left out of the trace report. A value of -1 indicates that the current ThreadTrace silence_threshold should be used. @return The time that this trace actually ran ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "ThreadTrace.isInitialized",
    "class_name": "com.google.javascript.jscomp.Tracer$ThreadTrace",
    "signature": "com.google.javascript.jscomp.Tracer$ThreadTrace.isInitialized()",
    "snippet": "    boolean isInitialized() {\n      return isInitialized;\n    }",
    "comment": "Is initialized? */",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "UseSite.UseSite",
    "class_name": "com.google.javascript.jscomp.UseSite",
    "signature": "com.google.javascript.jscomp.UseSite.UseSite(Node,Scope,JSModule)",
    "snippet": "  UseSite(Node node, Scope scope, JSModule module) {\n    this.node = node;\n    this.scope = scope;\n    this.module = module;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "UseSite.hashCode",
    "class_name": "com.google.javascript.jscomp.UseSite",
    "signature": "com.google.javascript.jscomp.UseSite.hashCode()",
    "snippet": "  @Override\n  public int hashCode() {\n    return this.node.hashCode();\n  }",
    "comment": "Use the node as the identifying feature to make the UseSite recreatable.",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "WarningsGuard.getPriority",
    "class_name": "com.google.javascript.jscomp.WarningsGuard",
    "signature": "com.google.javascript.jscomp.WarningsGuard.getPriority()",
    "snippet": "  protected int getPriority() {\n    return Priority.DEFAULT.value;\n  }",
    "comment": " The priority in which warnings guards are applied. Lower means the guard will be applied sooner. Expressed on a scale of 1 to 100. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "Config.Config",
    "class_name": "com.google.javascript.jscomp.parsing.Config",
    "signature": "com.google.javascript.jscomp.parsing.Config.Config(Set,Set,boolean,LanguageMode,boolean)",
    "snippet": "  Config(Set<String> annotationWhitelist, Set<String> suppressionNames,\n      boolean isIdeMode, LanguageMode languageMode,\n      boolean acceptConstKeyword) {\n    this.annotationNames = buildAnnotationNames(annotationWhitelist);\n    this.parseJsDocDocumentation = isIdeMode;\n    this.suppressionNames = suppressionNames;\n    this.isIdeMode = isIdeMode;\n    this.languageMode = languageMode;\n    this.acceptConstKeyword = acceptConstKeyword;\n  }",
    "comment": " Annotation names. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "Config.buildAnnotationNames",
    "class_name": "com.google.javascript.jscomp.parsing.Config",
    "signature": "com.google.javascript.jscomp.parsing.Config.buildAnnotationNames(Set)",
    "snippet": "  private static Map<String, Annotation> buildAnnotationNames(\n      Set<String> annotationWhitelist) {\n    ImmutableMap.Builder<String, Annotation> annotationBuilder =\n        ImmutableMap.builder();\n    annotationBuilder.putAll(Annotation.recognizedAnnotations);\n    for (String unrecognizedAnnotation : annotationWhitelist) {\n      if (!Annotation.recognizedAnnotations.containsKey(\n              unrecognizedAnnotation)) {\n        annotationBuilder.put(\n            unrecognizedAnnotation, Annotation.NOT_IMPLEMENTED);\n      }\n    }\n    return annotationBuilder.build();\n  }",
    "comment": " Create the annotation names from the user-specified annotation whitelist. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "IRFactory.createTemplateNode",
    "class_name": "com.google.javascript.jscomp.parsing.IRFactory",
    "signature": "com.google.javascript.jscomp.parsing.IRFactory.createTemplateNode()",
    "snippet": "  private Node createTemplateNode() {\n    // The Node type choice is arbitrary.\n    Node templateNode = new Node(Token.SCRIPT);\n    templateNode.putProp(Node.SOURCENAME_PROP, sourceName);\n    return templateNode;\n  }",
    "comment": "This reduces the cost of these properties to O(nodes) to O(files).",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "IRFactory.handleJsDoc",
    "class_name": "com.google.javascript.jscomp.parsing.IRFactory",
    "signature": "com.google.javascript.jscomp.parsing.IRFactory.handleJsDoc(AstNode)",
    "snippet": "  private JSDocInfo handleJsDoc(AstNode node) {\n    Comment comment = node.getJsDocNode();\n    if (comment != null) {\n      JsDocInfoParser jsDocParser = createJsDocInfoParser(comment);\n      comment.setParsed(true);\n      if (!handlePossibleFileOverviewJsDoc(jsDocParser)) {\n        return jsDocParser.retrieveAndResetParsedJSDocInfo();\n      }\n    }\n    return null;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "IRFactory.justTransform",
    "class_name": "com.google.javascript.jscomp.parsing.IRFactory",
    "signature": "com.google.javascript.jscomp.parsing.IRFactory.justTransform(AstNode)",
    "snippet": "  private Node justTransform(AstNode node) {\n    return transformDispatcher.process(node);\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "IRFactory.newNode",
    "class_name": "com.google.javascript.jscomp.parsing.IRFactory",
    "signature": "com.google.javascript.jscomp.parsing.IRFactory.newNode(int)",
    "snippet": "  private Node newNode(int type) {\n    return new Node(type).clonePropsFrom(templateNode);\n  }",
    "comment": "Simple helper to create nodes and set the initial node properties.",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "IRFactory.newNode",
    "class_name": "com.google.javascript.jscomp.parsing.IRFactory",
    "signature": "com.google.javascript.jscomp.parsing.IRFactory.newNode(int,Node)",
    "snippet": "  private Node newNode(int type, Node child1) {\n    return new Node(type, child1).clonePropsFrom(templateNode);\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "IRFactory.newNumberNode",
    "class_name": "com.google.javascript.jscomp.parsing.IRFactory",
    "signature": "com.google.javascript.jscomp.parsing.IRFactory.newNumberNode(Double)",
    "snippet": "  private Node newNumberNode(Double value) {\n    return Node.newNumber(value).clonePropsFrom(templateNode);\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "IRFactory.newStringNode",
    "class_name": "com.google.javascript.jscomp.parsing.IRFactory",
    "signature": "com.google.javascript.jscomp.parsing.IRFactory.newStringNode(int,String)",
    "snippet": "  private Node newStringNode(int type, String value) {\n    return Node.newString(type, value).clonePropsFrom(templateNode);\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "IRFactory.position2charno",
    "class_name": "com.google.javascript.jscomp.parsing.IRFactory",
    "signature": "com.google.javascript.jscomp.parsing.IRFactory.position2charno(int)",
    "snippet": "  private int position2charno(int position) {\n    int lineIndex = sourceString.lastIndexOf('\\n', position);\n    if (lineIndex == -1) {\n      return position;\n    } else {\n      // Subtract one for initial position being 0.\n      return position - lineIndex - 1;\n    }\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "IRFactory.setFileOverviewJsDoc",
    "class_name": "com.google.javascript.jscomp.parsing.IRFactory",
    "signature": "com.google.javascript.jscomp.parsing.IRFactory.setFileOverviewJsDoc(Node)",
    "snippet": "  private void setFileOverviewJsDoc(Node irNode) {\n    // Only after we've seen all @fileoverview entries, attach the\n    // last one to the root node, and copy the found license strings\n    // to that node.\n    irNode.setJSDocInfo(rootNodeJsDocHolder.getJSDocInfo());\n    if (fileOverviewInfo != null) {\n      if ((irNode.getJSDocInfo() != null) &&\n          (irNode.getJSDocInfo().getLicense() != null)) {\n        fileOverviewInfo.setLicense(irNode.getJSDocInfo().getLicense());\n      }\n      irNode.setJSDocInfo(fileOverviewInfo);\n    }\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "IRFactory.setSourceInfo",
    "class_name": "com.google.javascript.jscomp.parsing.IRFactory",
    "signature": "com.google.javascript.jscomp.parsing.IRFactory.setSourceInfo(Node,AstNode)",
    "snippet": "  private void setSourceInfo(Node irNode, AstNode node) {\n    // If we have a named function, set the position to that of the name.\n    if (irNode.getType() == Token.FUNCTION &&\n        irNode.getFirstChild().getLineno() != -1) {\n      irNode.setLineno(irNode.getFirstChild().getLineno());\n      irNode.setCharno(irNode.getFirstChild().getCharno());\n    } else {\n      if (irNode.getLineno() == -1) {\n        // If we didn't already set the line, then set it now.  This avoids\n        // cases like ParenthesizedExpression where we just return a previous\n        // node, but don't want the new node to get its parent's line number.\n        int lineno = node.getLineno();\n        irNode.setLineno(lineno);\n        int charno = position2charno(node.getAbsolutePosition());\n        irNode.setCharno(charno);\n      }\n    }\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "IRFactory.transform",
    "class_name": "com.google.javascript.jscomp.parsing.IRFactory",
    "signature": "com.google.javascript.jscomp.parsing.IRFactory.transform(AstNode)",
    "snippet": "  private Node transform(AstNode node) {\n    JSDocInfo jsDocInfo = handleJsDoc(node);\n    Node irNode = justTransform(node);\n    if (jsDocInfo != null) {\n      irNode.setJSDocInfo(jsDocInfo);\n    }\n    setSourceInfo(irNode, node);\n    return irNode;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "IRFactory.transformTokenType",
    "class_name": "com.google.javascript.jscomp.parsing.IRFactory",
    "signature": "com.google.javascript.jscomp.parsing.IRFactory.transformTokenType(int)",
    "snippet": "  private static int transformTokenType(int token) {\n    switch (token) {\n      case com.google.javascript.jscomp.mozilla.rhino.Token.RETURN:\n        return Token.RETURN;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.BITOR:\n        return Token.BITOR;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.BITXOR:\n        return Token.BITXOR;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.BITAND:\n        return Token.BITAND;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.EQ:\n        return Token.EQ;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.NE:\n        return Token.NE;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.LT:\n        return Token.LT;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.LE:\n        return Token.LE;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.GT:\n        return Token.GT;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.GE:\n        return Token.GE;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.LSH:\n        return Token.LSH;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.RSH:\n        return Token.RSH;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.URSH:\n        return Token.URSH;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.ADD:\n        return Token.ADD;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.SUB:\n        return Token.SUB;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.MUL:\n        return Token.MUL;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.DIV:\n        return Token.DIV;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.MOD:\n        return Token.MOD;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.NOT:\n        return Token.NOT;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.BITNOT:\n        return Token.BITNOT;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.POS:\n        return Token.POS;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.NEG:\n        return Token.NEG;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.NEW:\n        return Token.NEW;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.DELPROP:\n        return Token.DELPROP;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.TYPEOF:\n        return Token.TYPEOF;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.GETPROP:\n        return Token.GETPROP;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.SETPROP:\n        return Token.SETPROP;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.GETELEM:\n        return Token.GETELEM;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.SETELEM:\n        return Token.SETELEM;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.CALL:\n        return Token.CALL;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.NAME:\n        return Token.NAME;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.NUMBER:\n        return Token.NUMBER;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.STRING:\n        return Token.STRING;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.NULL:\n        return Token.NULL;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.THIS:\n        return Token.THIS;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.FALSE:\n        return Token.FALSE;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.TRUE:\n        return Token.TRUE;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.SHEQ:\n        return Token.SHEQ;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.SHNE:\n        return Token.SHNE;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.REGEXP:\n        return Token.REGEXP;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.THROW:\n        return Token.THROW;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.IN:\n        return Token.IN;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.INSTANCEOF:\n        return Token.INSTANCEOF;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.ARRAYLIT:\n        return Token.ARRAYLIT;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.OBJECTLIT:\n        return Token.OBJECTLIT;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.TRY:\n        return Token.TRY;\n      // The LP represents a parameter list\n      case com.google.javascript.jscomp.mozilla.rhino.Token.LP:\n        return Token.LP;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.COMMA:\n        return Token.COMMA;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.ASSIGN:\n        return Token.ASSIGN;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.ASSIGN_BITOR:\n        return Token.ASSIGN_BITOR;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.ASSIGN_BITXOR:\n        return Token.ASSIGN_BITXOR;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.ASSIGN_BITAND:\n        return Token.ASSIGN_BITAND;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.ASSIGN_LSH:\n        return Token.ASSIGN_LSH;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.ASSIGN_RSH:\n        return Token.ASSIGN_RSH;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.ASSIGN_URSH:\n        return Token.ASSIGN_URSH;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.ASSIGN_ADD:\n        return Token.ASSIGN_ADD;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.ASSIGN_SUB:\n        return Token.ASSIGN_SUB;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.ASSIGN_MUL:\n        return Token.ASSIGN_MUL;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.ASSIGN_DIV:\n        return Token.ASSIGN_DIV;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.ASSIGN_MOD:\n        return Token.ASSIGN_MOD;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.HOOK:\n        return Token.HOOK;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.COLON:\n        return Token.COLON;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.OR:\n        return Token.OR;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.AND:\n        return Token.AND;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.INC:\n        return Token.INC;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.DEC:\n        return Token.DEC;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.FUNCTION:\n        return Token.FUNCTION;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.IF:\n        return Token.IF;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.ELSE:\n        return Token.ELSE;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.SWITCH:\n        return Token.SWITCH;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.CASE:\n        return Token.CASE;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.DEFAULT:\n        return Token.DEFAULT;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.WHILE:\n        return Token.WHILE;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.DO:\n        return Token.DO;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.FOR:\n        return Token.FOR;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.BREAK:\n        return Token.BREAK;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.CONTINUE:\n        return Token.CONTINUE;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.VAR:\n        return Token.VAR;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.WITH:\n        return Token.WITH;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.CATCH:\n        return Token.CATCH;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.FINALLY:\n        return Token.FINALLY;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.VOID:\n        return Token.VOID;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.EMPTY:\n        return Token.EMPTY;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.BLOCK:\n        return Token.BLOCK;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.LABEL:\n        return Token.LABEL;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.EXPR_VOID:\n      case com.google.javascript.jscomp.mozilla.rhino.Token.EXPR_RESULT:\n        return Token.EXPR_RESULT;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.SCRIPT:\n        return Token.SCRIPT;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.GET:\n        return Token.GET;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.SET:\n        return Token.SET;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.CONST:\n        return Token.CONST;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.DEBUGGER:\n        return Token.DEBUGGER;\n    }\n\n    // Token without name\n    throw new IllegalStateException(String.valueOf(token));\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "IRFactory.transformTree",
    "class_name": "com.google.javascript.jscomp.parsing.IRFactory",
    "signature": "com.google.javascript.jscomp.parsing.IRFactory.transformTree(AstRoot,String,Config,ErrorReporter)",
    "snippet": "  public static Node transformTree(AstRoot node,\n                                   String sourceString,\n                                   Config config,\n                                   ErrorReporter errorReporter) {\n    IRFactory irFactory = new IRFactory(sourceString, node.getSourceName(),\n        config, errorReporter);\n    Node irNode = irFactory.transform(node);\n\n    if (node.getComments() != null) {\n      for (Comment comment : node.getComments()) {\n        if (comment.getCommentType() == CommentType.JSDOC &&\n            !comment.isParsed()) {\n          irFactory.handlePossibleFileOverviewJsDoc(comment);\n        } else if (comment.getCommentType() == CommentType.BLOCK) {\n          irFactory.handleBlockComment(comment);\n        }\n      }\n    }\n\n    irFactory.setFileOverviewJsDoc(irNode);\n\n    return irNode;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "TransformDispatcher.isDirective",
    "class_name": "com.google.javascript.jscomp.parsing.IRFactory$TransformDispatcher",
    "signature": "com.google.javascript.jscomp.parsing.IRFactory$TransformDispatcher.isDirective(Node)",
    "snippet": "    private boolean isDirective(Node n) {\n      if (n == null) return false;\n\n      int nType = n.getType();\n      return (nType == Token.EXPR_RESULT || nType == Token.EXPR_VOID) &&\n          n.getFirstChild().getType() == Token.STRING &&\n          ALLOWED_DIRECTIVES.contains(n.getFirstChild().getString());\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "TransformDispatcher.isReservedKeyword",
    "class_name": "com.google.javascript.jscomp.parsing.IRFactory$TransformDispatcher",
    "signature": "com.google.javascript.jscomp.parsing.IRFactory$TransformDispatcher.isReservedKeyword(String)",
    "snippet": "    private boolean isReservedKeyword(String identifier) {\n      return reservedKeywords != null && reservedKeywords.contains(identifier);\n    }",
    "comment": " @return Whether the ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "TransformDispatcher.parseDirectives",
    "class_name": "com.google.javascript.jscomp.parsing.IRFactory$TransformDispatcher",
    "signature": "com.google.javascript.jscomp.parsing.IRFactory$TransformDispatcher.parseDirectives(Node)",
    "snippet": "    private void parseDirectives(Node node) {\n      // Remove all the directives, and encode them in the AST.\n      Set<String> directives = null;\n      while (isDirective(node.getFirstChild())) {\n        String directive = node.removeFirstChild().getFirstChild().getString();\n        if (directives == null) {\n          directives = Sets.newHashSet(directive);\n        } else {\n          directives.add(directive);\n        }\n      }\n\n      if (directives != null) {\n        node.setDirectives(directives);\n      }\n    }",
    "comment": " Parse the directives, encode them in the AST, and remove their nodes.  For information on ES5 directives, see section 14.1 of Ecma-262, Edition 5.  It would be nice if Rhino would eventually take care of this for us, but right now their directive-processing is a one-off. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "TransformDispatcher.processAstRoot",
    "class_name": "com.google.javascript.jscomp.parsing.IRFactory$TransformDispatcher",
    "signature": "com.google.javascript.jscomp.parsing.IRFactory$TransformDispatcher.processAstRoot(AstRoot)",
    "snippet": "    @Override\n    Node processAstRoot(AstRoot rootNode) {\n      Node node = newNode(Token.SCRIPT);\n      for (com.google.javascript.jscomp.mozilla.rhino.Node child : rootNode) {\n        node.addChildToBack(transform((AstNode)child));\n      }\n      parseDirectives(node);\n      return node;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "TransformDispatcher.processBlock",
    "class_name": "com.google.javascript.jscomp.parsing.IRFactory$TransformDispatcher",
    "signature": "com.google.javascript.jscomp.parsing.IRFactory$TransformDispatcher.processBlock(Block)",
    "snippet": "    @Override\n    Node processBlock(Block blockNode) {\n      return processGeneric(blockNode);\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "TransformDispatcher.processExpressionStatement",
    "class_name": "com.google.javascript.jscomp.parsing.IRFactory$TransformDispatcher",
    "signature": "com.google.javascript.jscomp.parsing.IRFactory$TransformDispatcher.processExpressionStatement(ExpressionStatement)",
    "snippet": "    @Override\n    Node processExpressionStatement(ExpressionStatement statementNode) {\n      Node node = newNode(transformTokenType(statementNode.getType()));\n      node.addChildToBack(transform(statementNode.getExpression()));\n      return node;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "TransformDispatcher.processFunctionCall",
    "class_name": "com.google.javascript.jscomp.parsing.IRFactory$TransformDispatcher",
    "signature": "com.google.javascript.jscomp.parsing.IRFactory$TransformDispatcher.processFunctionCall(FunctionCall)",
    "snippet": "    @Override\n    Node processFunctionCall(FunctionCall callNode) {\n      Node node = newNode(transformTokenType(callNode.getType()),\n                           transform(callNode.getTarget()));\n      for (AstNode child : callNode.getArguments()) {\n        node.addChildToBack(transform(child));\n      }\n\n      int leftParamPos = callNode.getAbsolutePosition() + callNode.getLp();\n      node.setLineno(callNode.getLineno());\n      node.setCharno(position2charno(leftParamPos));\n      return node;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "TransformDispatcher.processFunctionNode",
    "class_name": "com.google.javascript.jscomp.parsing.IRFactory$TransformDispatcher",
    "signature": "com.google.javascript.jscomp.parsing.IRFactory$TransformDispatcher.processFunctionNode(FunctionNode)",
    "snippet": "    @Override\n    Node processFunctionNode(FunctionNode functionNode) {\n      Name name = functionNode.getFunctionName();\n      Boolean isUnnamedFunction = false;\n      if (name == null) {\n        int functionType = functionNode.getFunctionType();\n        if (functionType != FunctionNode.FUNCTION_EXPRESSION) {\n          errorReporter.error(\n            \"unnamed function statement\",\n            sourceName,\n            functionNode.getLineno(), \"\", 0);\n        }\n        name = new Name();\n        name.setIdentifier(\"\");\n        isUnnamedFunction = true;\n      }\n      Node node = newNode(Token.FUNCTION);\n      Node newName = transform(name);\n      if (isUnnamedFunction) {\n        // Old Rhino tagged the empty name node with the line number of the\n        // declaration.\n        newName.setLineno(functionNode.getLineno());\n        // TODO(bowdidge) Mark line number of paren correctly.\n        // Same problem as below - the left paren might not be on the\n        // same line as the function keyword.\n        int lpColumn = functionNode.getAbsolutePosition() +\n            functionNode.getLp();\n        newName.setCharno(position2charno(lpColumn));\n      }\n\n      node.addChildToBack(newName);\n      Node lp = newNode(Token.LP);\n      // The left paren's complicated because it's not represented by an\n      // AstNode, so there's nothing that has the actual line number that it\n      // appeared on.  We know the paren has to appear on the same line as the\n      // function name (or else a semicolon will be inserted.)  If there's no\n      // function name, assume the paren was on the same line as the function.\n      // TODO(bowdidge): Mark line number of paren correctly.\n      Name fnName = functionNode.getFunctionName();\n      if (fnName != null) {\n        lp.setLineno(fnName.getLineno());\n      } else {\n        lp.setLineno(functionNode.getLineno());\n      }\n      int lparenCharno = functionNode.getLp() +\n          functionNode.getAbsolutePosition();\n\n      lp.setCharno(position2charno(lparenCharno));\n      for (AstNode param : functionNode.getParams()) {\n        lp.addChildToBack(transform(param));\n      }\n      node.addChildToBack(lp);\n\n      Node bodyNode = transform(functionNode.getBody());\n      parseDirectives(bodyNode);\n      node.addChildToBack(bodyNode);\n     return node;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "TransformDispatcher.processGeneric",
    "class_name": "com.google.javascript.jscomp.parsing.IRFactory$TransformDispatcher",
    "signature": "com.google.javascript.jscomp.parsing.IRFactory$TransformDispatcher.processGeneric(Node)",
    "snippet": "    private Node processGeneric(\n        com.google.javascript.jscomp.mozilla.rhino.Node n) {\n      Node node = newNode(transformTokenType(n.getType()));\n      for (com.google.javascript.jscomp.mozilla.rhino.Node child : n) {\n        node.addChildToBack(transform((AstNode)child));\n      }\n      return node;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "TransformDispatcher.processLabel",
    "class_name": "com.google.javascript.jscomp.parsing.IRFactory$TransformDispatcher",
    "signature": "com.google.javascript.jscomp.parsing.IRFactory$TransformDispatcher.processLabel(Label)",
    "snippet": "    @Override\n    Node processLabel(Label labelNode) {\n      return newStringNode(Token.LABEL_NAME, labelNode.getName());\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "TransformDispatcher.processLabeledStatement",
    "class_name": "com.google.javascript.jscomp.parsing.IRFactory$TransformDispatcher",
    "signature": "com.google.javascript.jscomp.parsing.IRFactory$TransformDispatcher.processLabeledStatement(LabeledStatement)",
    "snippet": "    @Override\n    Node processLabeledStatement(LabeledStatement statementNode) {\n      Node node = newNode(Token.LABEL);\n      Node prev = null;\n      Node cur = node;\n      for (Label label : statementNode.getLabels()) {\n        if (prev != null) {\n          prev.addChildToBack(cur);\n        }\n        cur.addChildToBack(transform(label));\n\n        cur.setLineno(label.getLineno());\n        int clauseAbsolutePosition =\n            position2charno(label.getAbsolutePosition());\n        cur.setCharno(clauseAbsolutePosition);\n\n        prev = cur;\n        cur = newNode(Token.LABEL);\n      }\n      prev.addChildToBack(transform(statementNode.getStatement()));\n      return node;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "TransformDispatcher.processName",
    "class_name": "com.google.javascript.jscomp.parsing.IRFactory$TransformDispatcher",
    "signature": "com.google.javascript.jscomp.parsing.IRFactory$TransformDispatcher.processName(Name)",
    "snippet": "    @Override\n    Node processName(Name nameNode) {\n      return processName(nameNode, false);\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "TransformDispatcher.processName",
    "class_name": "com.google.javascript.jscomp.parsing.IRFactory$TransformDispatcher",
    "signature": "com.google.javascript.jscomp.parsing.IRFactory$TransformDispatcher.processName(Name,boolean)",
    "snippet": "    Node processName(Name nameNode, boolean asString) {\n      if (asString) {\n        return newStringNode(Token.STRING, nameNode.getIdentifier());\n      } else {\n        if (isReservedKeyword(nameNode.getIdentifier())) {\n          errorReporter.error(\n            \"identifier is a reserved word\",\n            sourceName,\n            nameNode.getLineno(), \"\", 0);\n        }\n        return newStringNode(Token.NAME, nameNode.getIdentifier());\n      }\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "TransformDispatcher.processNumberLiteral",
    "class_name": "com.google.javascript.jscomp.parsing.IRFactory$TransformDispatcher",
    "signature": "com.google.javascript.jscomp.parsing.IRFactory$TransformDispatcher.processNumberLiteral(NumberLiteral)",
    "snippet": "    @Override\n    Node processNumberLiteral(NumberLiteral literalNode) {\n      return newNumberNode(literalNode.getNumber());\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "TransformDispatcher.processScope",
    "class_name": "com.google.javascript.jscomp.parsing.IRFactory$TransformDispatcher",
    "signature": "com.google.javascript.jscomp.parsing.IRFactory$TransformDispatcher.processScope(Scope)",
    "snippet": "    @Override\n    Node processScope(Scope scopeNode) {\n      return processGeneric(scopeNode);\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "ParserRunner.createConfig",
    "class_name": "com.google.javascript.jscomp.parsing.ParserRunner",
    "signature": "com.google.javascript.jscomp.parsing.ParserRunner.createConfig(boolean,LanguageMode,boolean)",
    "snippet": "  public static Config createConfig(boolean isIdeMode,\n                                    LanguageMode languageMode,\n                                    boolean acceptConstKeyword) {\n    initResourceConfig();\n    return new Config(annotationNames, suppressionNames,\n                      isIdeMode, languageMode,\n                      acceptConstKeyword);\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "ParserRunner.extractList",
    "class_name": "com.google.javascript.jscomp.parsing.ParserRunner",
    "signature": "com.google.javascript.jscomp.parsing.ParserRunner.extractList(String)",
    "snippet": "  private static Set<String> extractList(String configProp) {\n    String[] names = configProp.split(\",\");\n    Set<String> trimmedNames = Sets.newHashSet();\n    for (String name : names) {\n      trimmedNames.add(name.trim());\n    }\n    return ImmutableSet.copyOf(trimmedNames);\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "ParserRunner.initResourceConfig",
    "class_name": "com.google.javascript.jscomp.parsing.ParserRunner",
    "signature": "com.google.javascript.jscomp.parsing.ParserRunner.initResourceConfig()",
    "snippet": "  private static synchronized void initResourceConfig() {\n    if (annotationNames != null) {\n      return;\n    }\n\n    ResourceBundle config = ResourceBundle.getBundle(configResource);\n    annotationNames = extractList(config.getString(\"jsdoc.annotations\"));\n    suppressionNames = extractList(config.getString(\"jsdoc.suppressions\"));\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "ParserRunner.parse",
    "class_name": "com.google.javascript.jscomp.parsing.ParserRunner",
    "signature": "com.google.javascript.jscomp.parsing.ParserRunner.parse(String,String,Config,ErrorReporter,Logger)",
    "snippet": "  public static Node parse(String sourceName,\n                           String sourceString,\n                           Config config,\n                           ErrorReporter errorReporter,\n                           Logger logger) throws IOException {\n    Context cx = Context.enter();\n    cx.setErrorReporter(errorReporter);\n    cx.setLanguageVersion(Context.VERSION_1_5);\n    CompilerEnvirons compilerEnv = new CompilerEnvirons();\n    compilerEnv.initFromContext(cx);\n    compilerEnv.setRecordingComments(true);\n    compilerEnv.setRecordingLocalJsDocComments(true);\n    // ES5 specifically allows trailing commas\n    compilerEnv.setWarnTrailingComma(\n        config.languageMode == LanguageMode.ECMASCRIPT3);\n\n    if (config.isIdeMode || config.languageMode != LanguageMode.ECMASCRIPT3) {\n      // Do our own identifier check for ECMASCRIPT 5\n      compilerEnv.setReservedKeywordAsIdentifier(true);\n      compilerEnv.setAllowKeywordAsObjectPropertyName(true);\n    }\n\n    if (config.isIdeMode) {\n      compilerEnv.setAllowMemberExprAsFunctionName(true);\n    }\n\n    Parser p = new Parser(compilerEnv, errorReporter);\n    AstRoot astRoot = null;\n    try {\n      astRoot = p.parse(sourceString, sourceName, 1);\n    } catch (EvaluatorException e) {\n      logger.info(\"Error parsing \" + sourceName + \": \" + e.getMessage());\n    } finally {\n      Context.exit();\n    }\n    Node root = null;\n    if (astRoot != null) {\n      root = IRFactory.transformTree(\n          astRoot, sourceString, config, errorReporter);\n      root.setIsSyntheticBlock(true);\n    }\n    return root;\n  }",
    "comment": " Parses the JavaScript text given by a reader.  @param sourceName The filename. @param sourceString Source code from the file. @param errorReporter An error. @param logger A logger. @return The AST of the given text. @throws IOException ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "TypeSafeDispatcher.process",
    "class_name": "com.google.javascript.jscomp.parsing.TypeSafeDispatcher",
    "signature": "com.google.javascript.jscomp.parsing.TypeSafeDispatcher.process(AstNode)",
    "snippet": "  public T process(AstNode node) {\n    switch (node.getType()) {\n      case Token.ADD:\n      case Token.AND:\n      case Token.BITAND:\n      case Token.BITOR:\n      case Token.BITXOR:\n      case Token.COMMA:\n      case Token.DIV:\n      case Token.EQ:\n      case Token.GE:\n      case Token.GT:\n      case Token.IN:\n      case Token.INSTANCEOF:\n      case Token.LE:\n      case Token.LSH:\n      case Token.LT:\n      case Token.MOD:\n      case Token.MUL:\n      case Token.NE:\n      case Token.OR:\n      case Token.RSH:\n      case Token.SHEQ:\n      case Token.SHNE:\n      case Token.SUB:\n      case Token.URSH:\n        return processInfixExpression((InfixExpression) node);\n      case Token.ARRAYLIT:\n        return processArrayLiteral((ArrayLiteral) node);\n      case Token.ASSIGN:\n      case Token.ASSIGN_ADD:\n      case Token.ASSIGN_BITAND:\n      case Token.ASSIGN_BITOR:\n      case Token.ASSIGN_BITXOR:\n      case Token.ASSIGN_DIV:\n      case Token.ASSIGN_LSH:\n      case Token.ASSIGN_MOD:\n      case Token.ASSIGN_MUL:\n      case Token.ASSIGN_RSH:\n      case Token.ASSIGN_SUB:\n      case Token.ASSIGN_URSH:\n        return processAssignment((Assignment) node);\n      case Token.BITNOT:\n      case Token.DEC:\n      case Token.DELPROP:\n      case Token.INC:\n      case Token.NEG:\n      case Token.NOT:\n      case Token.POS:\n      case Token.TYPEOF:\n      case Token.VOID:\n        return processUnaryExpression((UnaryExpression) node);\n      case Token.BLOCK:\n        if (node instanceof Block) {\n          return processBlock((Block) node);\n        } else  if (node instanceof Scope) {\n          return processScope((Scope) node);\n        } else {\n          throw new IllegalStateException(\"Unexpected node type.  class: \" +\n                                          node.getClass() +\n                                          \" type: \" +\n                                          Token.typeToName(node.getType()));\n        }\n      case Token.BREAK:\n        return processBreakStatement((BreakStatement) node);\n      case Token.CALL:\n        return processFunctionCall((FunctionCall) node);\n      case Token.CASE:\n      case Token.DEFAULT:\n        return processSwitchCase((SwitchCase) node);\n      case Token.CATCH:\n      case Token.FINALLY:\n        return processCatchClause((CatchClause) node);\n      case Token.COLON:\n        return processObjectProperty((ObjectProperty) node);\n      case Token.CONTINUE:\n        return processContinueStatement((ContinueStatement) node);\n      case Token.DO:\n        return processDoLoop((DoLoop) node);\n      case Token.EMPTY:\n        return processEmptyExpression((EmptyExpression) node);\n      case Token.EXPR_RESULT:\n      case Token.EXPR_VOID:\n        if (node instanceof ExpressionStatement) {\n          return processExpressionStatement((ExpressionStatement) node);\n        } else  if (node instanceof LabeledStatement) {\n          return processLabeledStatement((LabeledStatement) node);\n        } else {\n          throw new IllegalStateException(\"Unexpected node type.  class: \" +\n                                          node.getClass() +\n                                          \" type: \" +\n                                          Token.typeToName(node.getType()));\n        }\n      case Token.DEBUGGER:\n      case Token.FALSE:\n      case Token.NULL:\n      case Token.THIS:\n      case Token.TRUE:\n        return processKeywordLiteral((KeywordLiteral) node);\n      case Token.FOR:\n        if (node instanceof ForInLoop) {\n          return processForInLoop((ForInLoop) node);\n        } else  if (node instanceof ForLoop) {\n          return processForLoop((ForLoop) node);\n        } else {\n          throw new IllegalStateException(\"Unexpected node type.  class: \" +\n                                          node.getClass() +\n                                          \" type: \" +\n                                          Token.typeToName(node.getType()));\n        }\n      case Token.FUNCTION:\n        return processFunctionNode((FunctionNode) node);\n      case Token.GETELEM:\n        return processElementGet((ElementGet) node);\n      case Token.GETPROP:\n        return processPropertyGet((PropertyGet) node);\n      case Token.HOOK:\n        return processConditionalExpression((ConditionalExpression) node);\n      case Token.IF:\n        return processIfStatement((IfStatement) node);\n      case Token.LABEL:\n        return processLabel((Label) node);\n      case Token.LP:\n        return processParenthesizedExpression((ParenthesizedExpression) node);\n      case Token.NAME:\n        return processName((Name) node);\n      case Token.NEW:\n        return processNewExpression((NewExpression) node);\n      case Token.NUMBER:\n        return processNumberLiteral((NumberLiteral) node);\n      case Token.OBJECTLIT:\n        return processObjectLiteral((ObjectLiteral) node);\n      case Token.REGEXP:\n        return processRegExpLiteral((RegExpLiteral) node);\n      case Token.RETURN:\n        return processReturnStatement((ReturnStatement) node);\n      case Token.SCRIPT:\n        return processAstRoot((AstRoot) node);\n      case Token.STRING:\n        return processStringLiteral((StringLiteral) node);\n      case Token.SWITCH:\n        return processSwitchStatement((SwitchStatement) node);\n      case Token.THROW:\n        return processThrowStatement((ThrowStatement) node);\n      case Token.TRY:\n        return processTryStatement((TryStatement) node);\n      case Token.CONST:\n      case Token.VAR:\n        if (node instanceof VariableDeclaration) {\n          return processVariableDeclaration((VariableDeclaration) node);\n        } else  if (node instanceof VariableInitializer) {\n          return processVariableInitializer((VariableInitializer) node);\n        } else {\n          throw new IllegalStateException(\"Unexpected node type.  class: \" +\n                                          node.getClass() +\n                                          \" type: \" +\n                                          Token.typeToName(node.getType()));\n        }\n      case Token.WHILE:\n        return processWhileLoop((WhileLoop) node);\n      case Token.WITH:\n        return processWithStatement((WithStatement) node);\n    }\n    return processIllegalToken(node);\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "Context.getCurrentContext",
    "class_name": "com.google.javascript.rhino.Context",
    "signature": "com.google.javascript.rhino.Context.getCurrentContext()",
    "snippet": "    public static Context getCurrentContext() {\n        return threadContexts.get();\n    }",
    "comment": " Get the current Context.  The current Context is per-thread; this method looks up the Context associated with the current thread. <p>  @return the Context associated with the current thread, or null if no context is associated with the current thread. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "Node.Node",
    "class_name": "com.google.javascript.rhino.Node",
    "signature": "com.google.javascript.rhino.Node.Node(int)",
    "snippet": "  public Node(int nodeType) {\n    type = nodeType;\n    parent = null;\n    sourcePosition = -1;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "Node.Node",
    "class_name": "com.google.javascript.rhino.Node",
    "signature": "com.google.javascript.rhino.Node.Node(int,Node)",
    "snippet": "  public Node(int nodeType, Node child) {\n    Preconditions.checkArgument(child.parent == null,\n        \"new child has existing parent\");\n    Preconditions.checkArgument(child.next == null,\n        \"new child has existing sibling\");\n\n    type = nodeType;\n    parent = null;\n    first = last = child;\n    child.next = null;\n    child.parent = this;\n    sourcePosition = -1;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "Node.Node",
    "class_name": "com.google.javascript.rhino.Node",
    "signature": "com.google.javascript.rhino.Node.Node(int,Node,Node)",
    "snippet": "  public Node(int nodeType, Node left, Node right) {\n    Preconditions.checkArgument(left.parent == null,\n        \"first new child has existing parent\");\n    Preconditions.checkArgument(left.next == null,\n        \"first new child has existing sibling\");\n    Preconditions.checkArgument(right.parent == null,\n        \"second new child has existing parent\");\n    Preconditions.checkArgument(right.next == null,\n        \"second new child has existing sibling\");\n    type = nodeType;\n    parent = null;\n    first = left;\n    last = right;\n    left.next = right;\n    left.parent = this;\n    right.next = null;\n    right.parent = this;\n    sourcePosition = -1;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "Node.addChildToBack",
    "class_name": "com.google.javascript.rhino.Node",
    "signature": "com.google.javascript.rhino.Node.addChildToBack(Node)",
    "snippet": "  public void addChildToBack(Node child) {\n    Preconditions.checkArgument(child.parent == null);\n    Preconditions.checkArgument(child.next == null);\n    child.parent = this;\n    child.next = null;\n    if (last == null) {\n      first = last = child;\n      return;\n    }\n    last.next = child;\n    last = child;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "Node.appendStringTree",
    "class_name": "com.google.javascript.rhino.Node",
    "signature": "com.google.javascript.rhino.Node.appendStringTree(Appendable)",
    "snippet": "  public void appendStringTree(Appendable appendable) throws IOException {\n    toStringTreeHelper(this, 0, appendable);\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "Node.checkTreeEquals",
    "class_name": "com.google.javascript.rhino.Node",
    "signature": "com.google.javascript.rhino.Node.checkTreeEquals(Node)",
    "snippet": "  public String checkTreeEquals(Node node2) {\n      NodeMismatch diff = checkTreeEqualsImpl(node2);\n      if (diff != null) {\n        return \"Node tree inequality:\" +\n            \"\\nTree1:\\n\" + toStringTree() +\n            \"\\n\\nTree2:\\n\" + node2.toStringTree() +\n            \"\\n\\nSubtree1: \" + diff.nodeA.toStringTree() +\n            \"\\n\\nSubtree2: \" + diff.nodeB.toStringTree();\n      }\n      return null;\n  }",
    "comment": " Checks if the subtree under this node is the same as another subtree. Returns null if it's equal, or a message describing the differences. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "Node.checkTreeEqualsImpl",
    "class_name": "com.google.javascript.rhino.Node",
    "signature": "com.google.javascript.rhino.Node.checkTreeEqualsImpl(Node)",
    "snippet": "  NodeMismatch checkTreeEqualsImpl(Node node2) {\n    if (!isEquivalentTo(node2, false, false)) {\n      return new NodeMismatch(this, node2);\n    }\n\n    NodeMismatch res = null;\n    Node n, n2;\n    for (n = first, n2 = node2.first;\n         res == null && n != null;\n         n = n.next, n2 = n2.next) {\n      if (node2 == null) {\n        throw new IllegalStateException();\n      }\n      res = n.checkTreeEqualsImpl(n2);\n      if (res != null) {\n        return res;\n      }\n    }\n    return res;\n  }",
    "comment": " Compare this node to node2 recursively and return the first pair of nodes that differs doing a preorder depth-first traversal. Package private for testing. Returns null if the nodes are equivalent. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "Node.children",
    "class_name": "com.google.javascript.rhino.Node",
    "signature": "com.google.javascript.rhino.Node.children()",
    "snippet": "  public Iterable<Node> children() {\n    if (first == null) {\n      return Collections.emptySet();\n    } else {\n      return new SiblingNodeIterable(first);\n    }\n  }",
    "comment": " <p>Return an iterable object that iterates over this nodes's children. The iterator does not support the optional operation {@link Iterator#remove()}.</p>  <p>To iterate over a node's siblings, one can write</p> <pre>Node n = ...; for (Node child : n.children()) { ...</pre> ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "Node.cloneNode",
    "class_name": "com.google.javascript.rhino.Node",
    "signature": "com.google.javascript.rhino.Node.cloneNode()",
    "snippet": "  public Node cloneNode() {\n    Node result;\n    try {\n      result = (Node) super.clone();\n      // PropListItem lists are immutable and can be shared so there is no\n      // need to clone them here.\n      result.next = null;\n      result.first = null;\n      result.last = null;\n      result.parent = null;\n    } catch (CloneNotSupportedException e) {\n      throw new RuntimeException(e.getMessage());\n    }\n    return result;\n  }",
    "comment": " @return A detached clone of the Node, specifically excluding its children. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "Node.clonePropsFrom",
    "class_name": "com.google.javascript.rhino.Node",
    "signature": "com.google.javascript.rhino.Node.clonePropsFrom(Node)",
    "snippet": "  public Node clonePropsFrom(Node other) {\n    Preconditions.checkState(this.propListHead == null,\n        \"Node has existing properties.\");\n    this.propListHead = other.propListHead;\n    return this;\n  }",
    "comment": " Clone the properties from the provided node without copying the property object.  The recieving node may not have any existing properties. @param other The node to clone properties from. @return this node. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "Node.cloneTree",
    "class_name": "com.google.javascript.rhino.Node",
    "signature": "com.google.javascript.rhino.Node.cloneTree()",
    "snippet": "  public Node cloneTree() {\n    Node result = cloneNode();\n    for (Node n2 = getFirstChild(); n2 != null; n2 = n2.getNext()) {\n      Node n2clone = n2.cloneTree();\n      n2clone.parent = result;\n      if (result.last != null) {\n        result.last.next = n2clone;\n      }\n      if (result.first == null) {\n        result.first = n2clone;\n      }\n      result.last = n2clone;\n    }\n    return result;\n  }",
    "comment": " @return A detached clone of the Node and all its children. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "Node.copyInformationFrom",
    "class_name": "com.google.javascript.rhino.Node",
    "signature": "com.google.javascript.rhino.Node.copyInformationFrom(Node)",
    "snippet": "  public Node copyInformationFrom(Node other) {\n    if (getProp(ORIGINALNAME_PROP) == null) {\n        putProp(ORIGINALNAME_PROP, other.getProp(ORIGINALNAME_PROP));\n    }\n\n    if (getProp(SOURCENAME_PROP) == null) {\n        putProp(SOURCENAME_PROP, other.getProp(SOURCENAME_PROP));\n      sourcePosition = other.sourcePosition;\n    }\n\n    return this;\n  }",
    "comment": " Copies source file and name information from the other node given to the current node. Used for maintaining debug information across node append and remove operations. @return this ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "Node.detachFromParent",
    "class_name": "com.google.javascript.rhino.Node",
    "signature": "com.google.javascript.rhino.Node.detachFromParent()",
    "snippet": "  public Node detachFromParent() {\n    Preconditions.checkState(parent != null);\n    parent.removeChild(this);\n    return this;\n  }",
    "comment": " Removes this node from its parent. Equivalent to: node.getParent().removeChild(); ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "Node.extractCharno",
    "class_name": "com.google.javascript.rhino.Node",
    "signature": "com.google.javascript.rhino.Node.extractCharno(int)",
    "snippet": "  protected static int extractCharno(int lineCharNo) {\n    if (lineCharNo == -1) {\n      return -1;\n    } else {\n      return lineCharNo & COLUMN_MASK;\n    }\n  }",
    "comment": " Extracts the character number and character number from a merged line char number (see {@link #mergeLineCharNo(int, int)}). ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "Node.extractLineno",
    "class_name": "com.google.javascript.rhino.Node",
    "signature": "com.google.javascript.rhino.Node.extractLineno(int)",
    "snippet": "  protected static int extractLineno(int lineCharNo) {\n    if (lineCharNo == -1) {\n      return -1;\n    } else {\n      return lineCharNo >>> COLUMN_BITS;\n    }\n  }",
    "comment": " Extracts the line number and character number from a merged line char number (see {@link #mergeLineCharNo(int, int)}). ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "Node.getAncestors",
    "class_name": "com.google.javascript.rhino.Node",
    "signature": "com.google.javascript.rhino.Node.getAncestors()",
    "snippet": "  public AncestorIterable getAncestors() {\n    return new AncestorIterable(this.getParent());\n  }",
    "comment": " Iterates all of the node's ancestors excluding itself. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "Node.getBooleanProp",
    "class_name": "com.google.javascript.rhino.Node",
    "signature": "com.google.javascript.rhino.Node.getBooleanProp(int)",
    "snippet": "  public boolean getBooleanProp(int propType) {\n    return getIntProp(propType) != 0;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "Node.getCharno",
    "class_name": "com.google.javascript.rhino.Node",
    "signature": "com.google.javascript.rhino.Node.getCharno()",
    "snippet": "  public int getCharno() {\n    return extractCharno(sourcePosition);\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "Node.getChildAtIndex",
    "class_name": "com.google.javascript.rhino.Node",
    "signature": "com.google.javascript.rhino.Node.getChildAtIndex(int)",
    "snippet": "  public Node getChildAtIndex(int i) {\n    Node n = first;\n    while (i > 0) {\n      n = n.next;\n      i--;\n    }\n    return n;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "Node.getChildBefore",
    "class_name": "com.google.javascript.rhino.Node",
    "signature": "com.google.javascript.rhino.Node.getChildBefore(Node)",
    "snippet": "  public Node getChildBefore(Node child) {\n    if (child == first) {\n      return null;\n    }\n    Node n = first;\n    while (n.next != child) {\n      n = n.next;\n      if (n == null) {\n        throw new RuntimeException(\"node is not a child\");\n      }\n    }\n    return n;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "Node.getChildCount",
    "class_name": "com.google.javascript.rhino.Node",
    "signature": "com.google.javascript.rhino.Node.getChildCount()",
    "snippet": "  public int getChildCount() {\n    int c = 0;\n    for (Node n = first; n != null; n = n.next)\n      c++;\n\n    return c;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "Node.getFirstChild",
    "class_name": "com.google.javascript.rhino.Node",
    "signature": "com.google.javascript.rhino.Node.getFirstChild()",
    "snippet": "  public Node getFirstChild() {\n    return first;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "Node.getIntProp",
    "class_name": "com.google.javascript.rhino.Node",
    "signature": "com.google.javascript.rhino.Node.getIntProp(int)",
    "snippet": "  public int getIntProp(int propType) {\n    PropListItem item = lookupProperty(propType);\n    if (item == null) {\n      return 0;\n    }\n    return item.intValue;\n  }",
    "comment": " Returns the integer value for the property, or 0 if the property is not defined. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "Node.getJSDocInfo",
    "class_name": "com.google.javascript.rhino.Node",
    "signature": "com.google.javascript.rhino.Node.getJSDocInfo()",
    "snippet": "  public JSDocInfo getJSDocInfo() {\n    return (JSDocInfo) getProp(JSDOC_INFO_PROP);\n  }",
    "comment": " Get the {@link JSDocInfo} attached to this node. @return the information or {@code null} if no JSDoc is attached to this node ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "Node.getJSType",
    "class_name": "com.google.javascript.rhino.Node",
    "signature": "com.google.javascript.rhino.Node.getJSType()",
    "snippet": "  public JSType getJSType() {\n      return jsType;\n  }",
    "comment": "Custom annotations",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "Node.getJsDocBuilderForNode",
    "class_name": "com.google.javascript.rhino.Node",
    "signature": "com.google.javascript.rhino.Node.getJsDocBuilderForNode()",
    "snippet": "  public FileLevelJsDocBuilder getJsDocBuilderForNode() {\n    return new FileLevelJsDocBuilder();\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "Node.getLastChild",
    "class_name": "com.google.javascript.rhino.Node",
    "signature": "com.google.javascript.rhino.Node.getLastChild()",
    "snippet": "  public Node getLastChild() {\n    return last;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "Node.getLineno",
    "class_name": "com.google.javascript.rhino.Node",
    "signature": "com.google.javascript.rhino.Node.getLineno()",
    "snippet": "  public int getLineno() {\n    return extractLineno(sourcePosition);\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "Node.getNext",
    "class_name": "com.google.javascript.rhino.Node",
    "signature": "com.google.javascript.rhino.Node.getNext()",
    "snippet": "  public Node getNext() {\n    return next;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "Node.getNodeClass",
    "class_name": "com.google.javascript.rhino.Node",
    "signature": "com.google.javascript.rhino.Node.getNodeClass(Node)",
    "snippet": "  @SuppressWarnings(\"unchecked\")\n  static private Class getNodeClass(Node n) {\n    Class c = n.getClass();\n    if (c == FunctionNode.class || c == ScriptOrFnNode.class) {\n      return Node.class;\n    }\n    return c;\n  }",
    "comment": " Helper function to ignore differences in Node subclasses that are no longer used. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "Node.getParent",
    "class_name": "com.google.javascript.rhino.Node",
    "signature": "com.google.javascript.rhino.Node.getParent()",
    "snippet": "  public Node getParent() {\n    return parent;\n  }",
    "comment": "Accessors",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "Node.getProp",
    "class_name": "com.google.javascript.rhino.Node",
    "signature": "com.google.javascript.rhino.Node.getProp(int)",
    "snippet": "  public Object getProp(int propType) {\n    PropListItem item = lookupProperty(propType);\n    if (item == null) {\n      return null;\n    }\n    return item.objectValue;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "Node.getSortedPropTypes",
    "class_name": "com.google.javascript.rhino.Node",
    "signature": "com.google.javascript.rhino.Node.getSortedPropTypes()",
    "snippet": "  private int[] getSortedPropTypes() {\n    int count = 0;\n    for (PropListItem x = propListHead; x != null; x = x.next) {\n      count++;\n    }\n\n    int[] keys = new int[count];\n    for (PropListItem x = propListHead; x != null; x = x.next) {\n      count--;\n      keys[count] = x.type;\n    }\n\n    Arrays.sort(keys);\n    return keys;\n  }",
    "comment": "Gets all the property types, in sorted order.",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "Node.getType",
    "class_name": "com.google.javascript.rhino.Node",
    "signature": "com.google.javascript.rhino.Node.getType()",
    "snippet": "  public int getType() {\n    return type;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "Node.hasChild",
    "class_name": "com.google.javascript.rhino.Node",
    "signature": "com.google.javascript.rhino.Node.hasChild(Node)",
    "snippet": "  public boolean hasChild(Node child) {\n    for (Node n = first; n != null; n = n.getNext()) {\n      if (child == n) {\n        return true;\n      }\n    }\n    return false;\n  }",
    "comment": "Intended for testing and verification only.",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "Node.hasChildren",
    "class_name": "com.google.javascript.rhino.Node",
    "signature": "com.google.javascript.rhino.Node.hasChildren()",
    "snippet": "  public boolean hasChildren() {\n    return first != null;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "Node.hasOneChild",
    "class_name": "com.google.javascript.rhino.Node",
    "signature": "com.google.javascript.rhino.Node.hasOneChild()",
    "snippet": "  public boolean hasOneChild() {\n    return first != null && first == last;\n  }",
    "comment": " Check for one child more efficiently than by iterating over all the children as is done with Node.getChildCount().  @return Whether the node has exactly one child. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "Node.isEquivalentTo",
    "class_name": "com.google.javascript.rhino.Node",
    "signature": "com.google.javascript.rhino.Node.isEquivalentTo(Node)",
    "snippet": "  public boolean isEquivalentTo(Node node) {\n    return isEquivalentTo(node, false, true);\n  }",
    "comment": "Returns true if this node is equivalent semantically to another */",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "Node.isEquivalentTo",
    "class_name": "com.google.javascript.rhino.Node",
    "signature": "com.google.javascript.rhino.Node.isEquivalentTo(Node,boolean,boolean)",
    "snippet": "  boolean isEquivalentTo(Node node, boolean compareJsType, boolean recurse) {\n    if (type != node.getType()\n        || getChildCount() != node.getChildCount()\n        || getNodeClass(this) != getNodeClass(node)) {\n      return false;\n    }\n\n    if (compareJsType && !JSType.isEquivalent(jsType, node.getJSType())) {\n      return false;\n    }\n\n    if (type == Token.ARRAYLIT) {\n      try {\n        int[] indices1 = (int[]) getProp(Node.SKIP_INDEXES_PROP);\n        int[] indices2 = (int[]) node.getProp(Node.SKIP_INDEXES_PROP);\n        if (indices1 == null) {\n          if (indices2 != null) {\n            return false;\n          }\n        } else if (indices2 == null) {\n          return false;\n        } else if (indices1.length != indices2.length) {\n          return false;\n        } else {\n          for (int i = 0; i < indices1.length; i++) {\n            if (indices1[i] != indices2[i]) {\n              return false;\n            }\n          }\n        }\n      } catch (Exception e) {\n        return false;\n      }\n    } else if (type == Token.INC || type == Token.DEC) {\n      int post1 = this.getIntProp(INCRDECR_PROP);\n      int post2 = node.getIntProp(INCRDECR_PROP);\n      if (post1 != post2) {\n        return false;\n      }\n    } else if (type == Token.STRING) {\n      int quoted1 = this.getIntProp(QUOTED_PROP);\n      int quoted2 = node.getIntProp(QUOTED_PROP);\n      if (quoted1 != quoted2) {\n        return false;\n      }\n    }\n\n    if (recurse) {\n      Node n, n2;\n      for (n = first, n2 = node.first;\n           n != null;\n           n = n.next, n2 = n2.next) {\n        if (!n.isEquivalentTo(n2, compareJsType, true)) {\n          return false;\n        }\n      }\n    }\n\n    return true;\n  }",
    "comment": " @param compareJsType Whether to compare the JSTypes of the nodes. @param recurse Whether to compare the children of the current node, if not only the the count of the children are compared. @return Whether this node is equivalent semantically to the provided node. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "Node.lookupProperty",
    "class_name": "com.google.javascript.rhino.Node",
    "signature": "com.google.javascript.rhino.Node.lookupProperty(int)",
    "snippet": "  @VisibleForTesting\n  PropListItem lookupProperty(int propType) {\n    PropListItem x = propListHead;\n    while (x != null && propType != x.type) {\n      x = x.next;\n    }\n    return x;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "Node.mergeLineCharNo",
    "class_name": "com.google.javascript.rhino.Node",
    "signature": "com.google.javascript.rhino.Node.mergeLineCharNo(int,int)",
    "snippet": "  protected static int mergeLineCharNo(int lineno, int charno) {\n    if (lineno < 0 || charno < 0) {\n      return -1;\n    } else if ((charno & ~COLUMN_MASK) != 0) {\n      return lineno << COLUMN_BITS | COLUMN_MASK;\n    } else {\n      return lineno << COLUMN_BITS | (charno & COLUMN_MASK);\n    }\n  }",
    "comment": " Merges the line number and character number in one integer. The Character number takes the first 12 bits and the line number takes the rest. If the character number is greater than <code>2<sup>12</sup>-1</code> it is adjusted to <code>2<sup>12</sup>-1</code>. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "Node.newNumber",
    "class_name": "com.google.javascript.rhino.Node",
    "signature": "com.google.javascript.rhino.Node.newNumber(double)",
    "snippet": "  public static Node newNumber(double number) {\n    return new NumberNode(number);\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "Node.newString",
    "class_name": "com.google.javascript.rhino.Node",
    "signature": "com.google.javascript.rhino.Node.newString(int,String)",
    "snippet": "  public static Node newString(int type, String str) {\n    return new StringNode(type, str);\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "Node.propToString",
    "class_name": "com.google.javascript.rhino.Node",
    "signature": "com.google.javascript.rhino.Node.propToString(int)",
    "snippet": "  private static final String propToString(int propType) {\n      switch (propType) {\n        case LOCAL_BLOCK_PROP:   return \"local_block\";\n        case OBJECT_IDS_PROP:    return \"object_ids_prop\";\n        case CATCH_SCOPE_PROP:   return \"catch_scope_prop\";\n        case LABEL_ID_PROP:      return \"label_id_prop\";\n        case TARGET_PROP:        return \"target\";\n        case BREAK_PROP:         return \"break\";\n        case CONTINUE_PROP:      return \"continue\";\n        case ENUM_PROP:          return \"enum\";\n        case FUNCTION_PROP:      return \"function\";\n        case TEMP_PROP:          return \"temp\";\n        case LOCAL_PROP:         return \"local\";\n        case CODEOFFSET_PROP:    return \"codeoffset\";\n        case FIXUPS_PROP:        return \"fixups\";\n        case VARS_PROP:          return \"vars\";\n        case USES_PROP:          return \"uses\";\n        case REGEXP_PROP:        return \"regexp\";\n        case CASES_PROP:         return \"cases\";\n        case DEFAULT_PROP:       return \"default\";\n        case CASEARRAY_PROP:     return \"casearray\";\n        case SOURCENAME_PROP:    return \"sourcename\";\n        case TYPE_PROP:          return \"type\";\n        case SPECIAL_PROP_PROP:  return \"special_prop\";\n        case LABEL_PROP:         return \"label\";\n        case FINALLY_PROP:       return \"finally\";\n        case LOCALCOUNT_PROP:    return \"localcount\";\n\n        case TARGETBLOCK_PROP:   return \"targetblock\";\n        case VARIABLE_PROP:      return \"variable\";\n        case LASTUSE_PROP:       return \"lastuse\";\n        case ISNUMBER_PROP:      return \"isnumber\";\n        case DIRECTCALL_PROP:    return \"directcall\";\n\n        case SPECIALCALL_PROP:   return \"specialcall\";\n        case DEBUGSOURCE_PROP:   return \"debugsource\";\n\n        case JSDOC_INFO_PROP:    return \"jsdoc_info\";\n\n        case SKIP_INDEXES_PROP:  return \"skip_indexes\";\n        case INCRDECR_PROP:      return \"incrdecr\";\n        case MEMBER_TYPE_PROP:   return \"member_type\";\n        case NAME_PROP:          return \"name\";\n        case PARENTHESIZED_PROP: return \"parenthesized\";\n        case QUOTED_PROP:        return \"quoted\";\n\n        case SYNTHETIC_BLOCK_PROP: return \"synthetic\";\n        case EMPTY_BLOCK:        return \"empty_block\";\n        case ORIGINALNAME_PROP:  return \"originalname\";\n        case SIDE_EFFECT_FLAGS:  return \"side_effect_flags\";\n\n        case IS_CONSTANT_NAME:   return \"is_constant_name\";\n        case IS_OPTIONAL_PARAM:  return \"is_optional_param\";\n        case IS_VAR_ARGS_PARAM:  return \"is_var_args_param\";\n        case IS_NAMESPACE:       return \"is_namespace\";\n        case IS_DISPATCHER:      return \"is_dispatcher\";\n        case DIRECTIVES:         return \"directives\";\n        case DIRECT_EVAL:        return \"direct_eval\";\n        case FREE_CALL:          return \"free_call\";\n        default:\n          Kit.codeBug();\n      }\n      return null;\n  }",
    "comment": "x..y or x..@i",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "Node.putBooleanProp",
    "class_name": "com.google.javascript.rhino.Node",
    "signature": "com.google.javascript.rhino.Node.putBooleanProp(int,boolean)",
    "snippet": "  public void putBooleanProp(int propType, boolean value) {\n    putIntProp(propType, value ? 1 : 0);\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "Node.putIntProp",
    "class_name": "com.google.javascript.rhino.Node",
    "signature": "com.google.javascript.rhino.Node.putIntProp(int,int)",
    "snippet": "  public void putIntProp(int propType, int value) {\n    removeProp(propType);\n    if (value != 0) {\n      propListHead = new PropListItem(propType, value, propListHead);\n    }\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "Node.putProp",
    "class_name": "com.google.javascript.rhino.Node",
    "signature": "com.google.javascript.rhino.Node.putProp(int,Object)",
    "snippet": "  public void putProp(int propType, Object value) {\n    removeProp(propType);\n    if (value != null) {\n      propListHead = new PropListItem(propType, value, propListHead);\n    }\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "Node.removeChild",
    "class_name": "com.google.javascript.rhino.Node",
    "signature": "com.google.javascript.rhino.Node.removeChild(Node)",
    "snippet": "  public void removeChild(Node child) {\n    Node prev = getChildBefore(child);\n    if (prev == null)\n        first = first.next;\n    else\n        prev.next = child.next;\n    if (child == last) last = prev;\n    child.next = null;\n    child.parent = null;\n  }",
    "comment": " Detach a child from its parent and siblings. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "Node.removeProp",
    "class_name": "com.google.javascript.rhino.Node",
    "signature": "com.google.javascript.rhino.Node.removeProp(PropListItem,int)",
    "snippet": "  private PropListItem removeProp(PropListItem item, int propType) {\n    if (item == null) {\n      return null;\n    } else if (item.type == propType) {\n      return item.next;\n    } else {\n      PropListItem result = removeProp(item.next, propType);\n      if (result != item.next) {\n        return new PropListItem(\n            item.type, item.intValue, item.objectValue, result);\n      } else {\n        return item;\n      }\n    }\n  }",
    "comment": " @param item The item to inspect @param propType The property to look for @return The replacement list if the property was removed, or 'item' otherwise. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "Node.removeProp",
    "class_name": "com.google.javascript.rhino.Node",
    "signature": "com.google.javascript.rhino.Node.removeProp(int)",
    "snippet": "  public void removeProp(int propType) {\n    PropListItem result = removeProp(propListHead, propType);\n    if (result != propListHead) {\n      propListHead = result;\n    }\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "Node.replaceChild",
    "class_name": "com.google.javascript.rhino.Node",
    "signature": "com.google.javascript.rhino.Node.replaceChild(Node,Node)",
    "snippet": "  public void replaceChild(Node child, Node newChild) {\n    Preconditions.checkArgument(newChild.next == null,\n        \"The new child node has siblings.\");\n    Preconditions.checkArgument(newChild.parent == null,\n        \"The new child node already has a parent.\");\n\n    // Copy over important information.\n    newChild.copyInformationFrom(child);\n\n    newChild.next = child.next;\n    newChild.parent = this;\n    if (child == first) {\n        first = newChild;\n    } else {\n        Node prev = getChildBefore(child);\n        prev.next = newChild;\n    }\n    if (child == last)\n        last = newChild;\n    child.next = null;\n    child.parent = null;\n  }",
    "comment": " Detaches child from Node and replaces it with newChild. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "Node.setCharno",
    "class_name": "com.google.javascript.rhino.Node",
    "signature": "com.google.javascript.rhino.Node.setCharno(int)",
    "snippet": "  public void setCharno(int charno) {\n      sourcePosition = mergeLineCharNo(getLineno(), charno);\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "Node.setIsSyntheticBlock",
    "class_name": "com.google.javascript.rhino.Node",
    "signature": "com.google.javascript.rhino.Node.setIsSyntheticBlock(boolean)",
    "snippet": "  public void setIsSyntheticBlock(boolean val) {\n    putBooleanProp(SYNTHETIC_BLOCK_PROP, val);\n  }",
    "comment": " Sets whether this is a synthetic block that should not be considered a real source block. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "Node.setJSDocInfo",
    "class_name": "com.google.javascript.rhino.Node",
    "signature": "com.google.javascript.rhino.Node.setJSDocInfo(JSDocInfo)",
    "snippet": "  public void setJSDocInfo(JSDocInfo info) {\n      putProp(JSDOC_INFO_PROP, info);\n  }",
    "comment": " Sets the {@link JSDocInfo} attached to this node. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "Node.setJSType",
    "class_name": "com.google.javascript.rhino.Node",
    "signature": "com.google.javascript.rhino.Node.setJSType(JSType)",
    "snippet": "  public void setJSType(JSType jsType) {\n      this.jsType = jsType;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "Node.setLineno",
    "class_name": "com.google.javascript.rhino.Node",
    "signature": "com.google.javascript.rhino.Node.setLineno(int)",
    "snippet": "  public void setLineno(int lineno) {\n      int charno = getCharno();\n      if (charno == -1) {\n        charno = 0;\n      }\n      sourcePosition = mergeLineCharNo(lineno, charno);\n  }",
    "comment": "Source position management",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "Node.setOptionalArg",
    "class_name": "com.google.javascript.rhino.Node",
    "signature": "com.google.javascript.rhino.Node.setOptionalArg(boolean)",
    "snippet": "  public void setOptionalArg(boolean optionalArg) {\n    putBooleanProp(OPT_ARG_NAME, optionalArg);\n  }",
    "comment": " Sets whether this node is an optional argument node. This method is meaningful only on {@link Token#NAME} nodes used to define a {@link Token#FUNCTION}'s argument list. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "Node.setVarArgs",
    "class_name": "com.google.javascript.rhino.Node",
    "signature": "com.google.javascript.rhino.Node.setVarArgs(boolean)",
    "snippet": "  public void setVarArgs(boolean varArgs) {\n    putBooleanProp(VAR_ARGS_NAME, varArgs);\n  }",
    "comment": " Sets whether this node is a variable length argument node. This method is meaningful only on {@link Token#NAME} nodes used to define a {@link Token#FUNCTION}'s argument list. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "Node.toString",
    "class_name": "com.google.javascript.rhino.Node",
    "signature": "com.google.javascript.rhino.Node.toString()",
    "snippet": "  @Override\n  public String toString() {\n    return toString(true, true, true);\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "Node.toString",
    "class_name": "com.google.javascript.rhino.Node",
    "signature": "com.google.javascript.rhino.Node.toString(StringBuilder,boolean,boolean,boolean)",
    "snippet": "  private void toString(\n      StringBuilder sb,\n      boolean printSource,\n      boolean printAnnotations,\n      boolean printType) {\n    if (Token.printTrees) {\n      sb.append(Token.name(type));\n      if (this instanceof StringNode) {\n        sb.append(' ');\n        sb.append(getString());\n      } else if (type == Token.FUNCTION) {\n        sb.append(' ');\n        // In the case of JsDoc trees, the first child is often not a string\n        // which causes exceptions to be thrown when calling toString or\n        // toStringTree.\n        if (first == null || first.getType() != Token.NAME) {\n          sb.append(\"<invalid>\");\n        } else {\n          sb.append(first.getString());\n        }\n      } else if (this instanceof ScriptOrFnNode) {\n        ScriptOrFnNode sof = (ScriptOrFnNode) this;\n        if (this instanceof FunctionNode) {\n          FunctionNode fn = (FunctionNode) this;\n          sb.append(' ');\n          sb.append(fn.getFunctionName());\n        }\n        if (printSource) {\n          sb.append(\" [source name: \");\n          sb.append(sof.getSourceName());\n          sb.append(\"] [encoded source length: \");\n          sb.append(sof.getEncodedSourceEnd() - sof.getEncodedSourceStart());\n          sb.append(\"] [base line: \");\n          sb.append(sof.getBaseLineno());\n          sb.append(\"] [end line: \");\n          sb.append(sof.getEndLineno());\n          sb.append(']');\n        }\n      } else if (type == Token.NUMBER) {\n        sb.append(' ');\n        sb.append(getDouble());\n      }\n      if (printSource) {\n        int lineno = getLineno();\n        if (lineno != -1) {\n          sb.append(' ');\n          sb.append(lineno);\n        }\n      }\n\n      if (printAnnotations) {\n        int[] keys = getSortedPropTypes();\n        for (int i = 0; i < keys.length; i++) {\n          int type = keys[i];\n          PropListItem x = lookupProperty(type);\n          sb.append(\" [\");\n          sb.append(propToString(type));\n          sb.append(\": \");\n          String value;\n          switch (type) {\n            case TARGETBLOCK_PROP: // can't add this as it recurses\n              value = \"target block property\";\n              break;\n            case LOCAL_BLOCK_PROP: // can't add this as it is dull\n              value = \"last local block\";\n              break;\n            case ISNUMBER_PROP:\n              switch (x.intValue) {\n                case BOTH:\n                  value = \"both\";\n                  break;\n                case RIGHT:\n                  value = \"right\";\n                  break;\n                case LEFT:\n                  value = \"left\";\n                  break;\n                default:\n                  throw Kit.codeBug();\n              }\n              break;\n            case SPECIALCALL_PROP:\n              switch (x.intValue) {\n                case SPECIALCALL_EVAL:\n                  value = \"eval\";\n                  break;\n                case SPECIALCALL_WITH:\n                  value = \"with\";\n                  break;\n                default:\n                  // NON_SPECIALCALL should not be stored\n                  throw Kit.codeBug();\n              }\n              break;\n            default:\n              Object obj = x.objectValue;\n              if (obj != null) {\n                value = obj.toString();\n              } else {\n                value = String.valueOf(x.intValue);\n              }\n              break;\n          }\n          sb.append(value);\n          sb.append(']');\n        }\n      }\n\n      if (printType) {\n        if (jsType != null) {\n          String jsTypeString = jsType.toString();\n          if (jsTypeString != null) {\n            sb.append(\" : \");\n            sb.append(jsTypeString);\n          }\n        }\n      }\n    }\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "Node.toString",
    "class_name": "com.google.javascript.rhino.Node",
    "signature": "com.google.javascript.rhino.Node.toString(boolean,boolean,boolean)",
    "snippet": "  public String toString(\n      boolean printSource,\n      boolean printAnnotations,\n      boolean printType) {\n    if (Token.printTrees) {\n        StringBuilder sb = new StringBuilder();\n        toString(sb, printSource, printAnnotations, printType);\n        return sb.toString();\n    }\n    return String.valueOf(type);\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "Node.toStringTree",
    "class_name": "com.google.javascript.rhino.Node",
    "signature": "com.google.javascript.rhino.Node.toStringTree()",
    "snippet": "  public String toStringTree() {\n    return toStringTreeImpl();\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "Node.toStringTreeHelper",
    "class_name": "com.google.javascript.rhino.Node",
    "signature": "com.google.javascript.rhino.Node.toStringTreeHelper(Node,int,Appendable)",
    "snippet": "  private static void toStringTreeHelper(Node n, int level, Appendable sb)\n      throws IOException {\n    if (Token.printTrees) {\n      for (int i = 0; i != level; ++i) {\n        sb.append(\"    \");\n      }\n      sb.append(n.toString());\n      sb.append('\\n');\n      for (Node cursor = n.getFirstChild();\n           cursor != null;\n           cursor = cursor.getNext()) {\n        toStringTreeHelper(cursor, level + 1, sb);\n      }\n    }\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "Node.toStringTreeImpl",
    "class_name": "com.google.javascript.rhino.Node",
    "signature": "com.google.javascript.rhino.Node.toStringTreeImpl()",
    "snippet": "  private String toStringTreeImpl() {\n    try {\n      StringBuilder s = new StringBuilder();\n      appendStringTree(s);\n      return s.toString();\n    } catch (IOException e) {\n      throw new RuntimeException(\"Should not happen\\n\" + e);\n    }\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "AncestorIterable.iterator",
    "class_name": "com.google.javascript.rhino.Node$AncestorIterable",
    "signature": "com.google.javascript.rhino.Node$AncestorIterable.iterator()",
    "snippet": "    public Iterator<Node> iterator() {\n      return new Iterator<Node>() {\n        public boolean hasNext() {\n          return cur != null;\n        }\n\n        public Node next() {\n          if (!hasNext()) throw new NoSuchElementException();\n          Node n = cur;\n          cur = cur.getParent();\n          return n;\n        }\n\n        public void remove() {\n          throw new UnsupportedOperationException();\n        }\n      };\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "NumberNode.getDouble",
    "class_name": "com.google.javascript.rhino.Node$NumberNode",
    "signature": "com.google.javascript.rhino.Node$NumberNode.getDouble()",
    "snippet": "    @Override\n    public double getDouble() {\n      return this.number;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "SiblingNodeIterable.hasNext",
    "class_name": "com.google.javascript.rhino.Node$SiblingNodeIterable",
    "signature": "com.google.javascript.rhino.Node$SiblingNodeIterable.hasNext()",
    "snippet": "    public boolean hasNext() {\n      return current != null;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "SiblingNodeIterable.iterator",
    "class_name": "com.google.javascript.rhino.Node$SiblingNodeIterable",
    "signature": "com.google.javascript.rhino.Node$SiblingNodeIterable.iterator()",
    "snippet": "    public Iterator<Node> iterator() {\n      if (!used) {\n        used = true;\n        return this;\n      } else {\n        // We have already used the current object as an iterator;\n        // we must create a new SiblingNodeIterable based on this\n        // iterable's start node.\n        //\n        // Since the primary use case for Node.children is in for\n        // loops, this branch is extremely unlikely.\n        return (new SiblingNodeIterable(start)).iterator();\n      }\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "SiblingNodeIterable.next",
    "class_name": "com.google.javascript.rhino.Node$SiblingNodeIterable",
    "signature": "com.google.javascript.rhino.Node$SiblingNodeIterable.next()",
    "snippet": "    public Node next() {\n      if (current == null) {\n        throw new NoSuchElementException();\n      }\n      try {\n        return current;\n      } finally {\n        current = current.getNext();\n      }\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "StringNode.getString",
    "class_name": "com.google.javascript.rhino.Node$StringNode",
    "signature": "com.google.javascript.rhino.Node$StringNode.getString()",
    "snippet": "    @Override\n    public String getString() {\n      return this.str;\n    }",
    "comment": " returns the string content. @return non null. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "StringNode.isEquivalentTo",
    "class_name": "com.google.javascript.rhino.Node$StringNode",
    "signature": "com.google.javascript.rhino.Node$StringNode.isEquivalentTo(Node,boolean,boolean)",
    "snippet": "    @Override\n    boolean isEquivalentTo(Node node, boolean compareJsType, boolean recurse) {\n      return (super.isEquivalentTo(node, compareJsType, recurse)\n          && this.str.equals(((StringNode) node).str));\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "ScriptRuntime.getMessage",
    "class_name": "com.google.javascript.rhino.ScriptRuntime",
    "signature": "com.google.javascript.rhino.ScriptRuntime.getMessage(String,Object[])",
    "snippet": "    public static String getMessage(String messageId, Object[] arguments)\n    {\n        final String defaultResource\n            = \"rhino_ast.java.com.google.javascript.rhino.Messages\";\n\n        Context cx = Context.getCurrentContext();\n        Locale locale = cx != null ? cx.getLocale() : Locale.getDefault();\n\n        // ResourceBundle does cacheing.\n        ResourceBundle rb = ResourceBundle.getBundle(defaultResource, locale);\n\n        String formatString;\n        try {\n            formatString = rb.getString(messageId);\n        } catch (java.util.MissingResourceException mre) {\n            throw new RuntimeException\n                (\"no message resource found for message property \"+ messageId);\n        }\n\n        /*\n         * It's OK to format the string, even if 'arguments' is null;\n         * we need to format it anyway, to make double ''s collapse to\n         * single 's.\n         */\n        // TODO: MessageFormat is not available on pJava\n        MessageFormat formatter = new MessageFormat(formatString);\n        return formatter.format(arguments);\n    }",
    "comment": "OPT there's a noticable delay for the first error!  Maybe it'd make sense to use a ListResourceBundle instead of a properties file to avoid (synchronized) text parsing. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "ScriptRuntime.getMessage0",
    "class_name": "com.google.javascript.rhino.ScriptRuntime",
    "signature": "com.google.javascript.rhino.ScriptRuntime.getMessage0(String)",
    "snippet": "    public static String getMessage0(String messageId)\n    {\n        return getMessage(messageId, null);\n    }",
    "comment": "------------------",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "Token.name",
    "class_name": "com.google.javascript.rhino.Token",
    "signature": "com.google.javascript.rhino.Token.name(int)",
    "snippet": "  public static String name(int token)\n    {\n        if (!printNames) {\n            return String.valueOf(token);\n        }\n        switch (token) {\n          case ERROR:           return \"ERROR\";\n          case EOF:             return \"EOF\";\n          case EOL:             return \"EOL\";\n          case ENTERWITH:       return \"ENTERWITH\";\n          case LEAVEWITH:       return \"LEAVEWITH\";\n          case RETURN:          return \"RETURN\";\n          case GOTO:            return \"GOTO\";\n          case IFEQ:            return \"IFEQ\";\n          case IFNE:            return \"IFNE\";\n          case SETNAME:         return \"SETNAME\";\n          case BITOR:           return \"BITOR\";\n          case BITXOR:          return \"BITXOR\";\n          case BITAND:          return \"BITAND\";\n          case EQ:              return \"EQ\";\n          case NE:              return \"NE\";\n          case LT:              return \"LT\";\n          case LE:              return \"LE\";\n          case GT:              return \"GT\";\n          case GE:              return \"GE\";\n          case LSH:             return \"LSH\";\n          case RSH:             return \"RSH\";\n          case URSH:            return \"URSH\";\n          case ADD:             return \"ADD\";\n          case SUB:             return \"SUB\";\n          case MUL:             return \"MUL\";\n          case DIV:             return \"DIV\";\n          case MOD:             return \"MOD\";\n          case NOT:             return \"NOT\";\n          case BITNOT:          return \"BITNOT\";\n          case POS:             return \"POS\";\n          case NEG:             return \"NEG\";\n          case NEW:             return \"NEW\";\n          case DELPROP:         return \"DELPROP\";\n          case TYPEOF:          return \"TYPEOF\";\n          case GETPROP:         return \"GETPROP\";\n          case SETPROP:         return \"SETPROP\";\n          case GETELEM:         return \"GETELEM\";\n          case SETELEM:         return \"SETELEM\";\n          case CALL:            return \"CALL\";\n          case NAME:            return \"NAME\";\n          case LABEL_NAME:      return \"LABEL_NAME\";\n          case NUMBER:          return \"NUMBER\";\n          case STRING:          return \"STRING\";\n          case NULL:            return \"NULL\";\n          case THIS:            return \"THIS\";\n          case FALSE:           return \"FALSE\";\n          case TRUE:            return \"TRUE\";\n          case SHEQ:            return \"SHEQ\";\n          case SHNE:            return \"SHNE\";\n          case REGEXP:          return \"REGEXP\";\n          case BINDNAME:        return \"BINDNAME\";\n          case THROW:           return \"THROW\";\n          case RETHROW:         return \"RETHROW\";\n          case IN:              return \"IN\";\n          case INSTANCEOF:      return \"INSTANCEOF\";\n          case LOCAL_LOAD:      return \"LOCAL_LOAD\";\n          case GETVAR:          return \"GETVAR\";\n          case SETVAR:          return \"SETVAR\";\n          case CATCH_SCOPE:     return \"CATCH_SCOPE\";\n          case ENUM_INIT_KEYS:  return \"ENUM_INIT_KEYS\";\n          case ENUM_INIT_VALUES:  return \"ENUM_INIT_VALUES\";\n          case ENUM_NEXT:       return \"ENUM_NEXT\";\n          case ENUM_ID:         return \"ENUM_ID\";\n          case THISFN:          return \"THISFN\";\n          case RETURN_RESULT:   return \"RETURN_RESULT\";\n          case ARRAYLIT:        return \"ARRAYLIT\";\n          case OBJECTLIT:       return \"OBJECTLIT\";\n          case GET_REF:         return \"GET_REF\";\n          case SET_REF:         return \"SET_REF\";\n          case DEL_REF:         return \"DEL_REF\";\n          case REF_CALL:        return \"REF_CALL\";\n          case REF_SPECIAL:     return \"REF_SPECIAL\";\n          case DEFAULTNAMESPACE:return \"DEFAULTNAMESPACE\";\n          case ESCXMLTEXT:      return \"ESCXMLTEXT\";\n          case ESCXMLATTR:      return \"ESCXMLATTR\";\n          case REF_MEMBER:      return \"REF_MEMBER\";\n          case REF_NS_MEMBER:   return \"REF_NS_MEMBER\";\n          case REF_NAME:        return \"REF_NAME\";\n          case REF_NS_NAME:     return \"REF_NS_NAME\";\n          case TRY:             return \"TRY\";\n          case SEMI:            return \"SEMI\";\n          case LB:              return \"LB\";\n          case RB:              return \"RB\";\n          case LC:              return \"LC\";\n          case RC:              return \"RC\";\n          case LP:              return \"LP\";\n          case RP:              return \"RP\";\n          case COMMA:           return \"COMMA\";\n          case ASSIGN:          return \"ASSIGN\";\n          case ASSIGN_BITOR:    return \"ASSIGN_BITOR\";\n          case ASSIGN_BITXOR:   return \"ASSIGN_BITXOR\";\n          case ASSIGN_BITAND:   return \"ASSIGN_BITAND\";\n          case ASSIGN_LSH:      return \"ASSIGN_LSH\";\n          case ASSIGN_RSH:      return \"ASSIGN_RSH\";\n          case ASSIGN_URSH:     return \"ASSIGN_URSH\";\n          case ASSIGN_ADD:      return \"ASSIGN_ADD\";\n          case ASSIGN_SUB:      return \"ASSIGN_SUB\";\n          case ASSIGN_MUL:      return \"ASSIGN_MUL\";\n          case ASSIGN_DIV:      return \"ASSIGN_DIV\";\n          case ASSIGN_MOD:      return \"ASSIGN_MOD\";\n          case HOOK:            return \"HOOK\";\n          case COLON:           return \"COLON\";\n          case OR:              return \"OR\";\n          case AND:             return \"AND\";\n          case INC:             return \"INC\";\n          case DEC:             return \"DEC\";\n          case DOT:             return \"DOT\";\n          case FUNCTION:        return \"FUNCTION\";\n          case EXPORT:          return \"EXPORT\";\n          case IMPORT:          return \"IMPORT\";\n          case IF:              return \"IF\";\n          case ELSE:            return \"ELSE\";\n          case SWITCH:          return \"SWITCH\";\n          case CASE:            return \"CASE\";\n          case DEFAULT:         return \"DEFAULT\";\n          case WHILE:           return \"WHILE\";\n          case DO:              return \"DO\";\n          case FOR:             return \"FOR\";\n          case BREAK:           return \"BREAK\";\n          case CONTINUE:        return \"CONTINUE\";\n          case VAR:             return \"VAR\";\n          case WITH:            return \"WITH\";\n          case CATCH:           return \"CATCH\";\n          case FINALLY:         return \"FINALLY\";\n          case RESERVED:        return \"RESERVED\";\n          case EMPTY:           return \"EMPTY\";\n          case BLOCK:           return \"BLOCK\";\n          case LABEL:           return \"LABEL\";\n          case TARGET:          return \"TARGET\";\n          case LOOP:            return \"LOOP\";\n          case EXPR_VOID:       return \"EXPR_VOID\";\n          case EXPR_RESULT:     return \"EXPR_RESULT\";\n          case JSR:             return \"JSR\";\n          case SCRIPT:          return \"SCRIPT\";\n          case TYPEOFNAME:      return \"TYPEOFNAME\";\n          case USE_STACK:       return \"USE_STACK\";\n          case SETPROP_OP:      return \"SETPROP_OP\";\n          case SETELEM_OP:      return \"SETELEM_OP\";\n          case LOCAL_BLOCK:     return \"LOCAL_BLOCK\";\n          case SET_REF_OP:      return \"SET_REF_OP\";\n          case DOTDOT:          return \"DOTDOT\";\n          case COLONCOLON:      return \"COLONCOLON\";\n          case XML:             return \"XML\";\n          case DOTQUERY:        return \"DOTQUERY\";\n          case XMLATTR:         return \"XMLATTR\";\n          case XMLEND:          return \"XMLEND\";\n          case TO_OBJECT:       return \"TO_OBJECT\";\n          case TO_DOUBLE:       return \"TO_DOUBLE\";\n          case GET:             return \"GET\";\n          case SET:             return \"SET\";\n          case CONST:           return \"CONST\";\n          case SETCONST:        return \"SETCONST\";\n          case DEBUGGER:        return \"DEBUGGER\";\n          case ANNOTATION:      return \"ANNOTATION\";\n          case PIPE:            return \"PIPE\";\n          case STAR:            return \"STAR\";\n          case EOC:             return \"EOC\";\n          case QMARK:           return \"QMARK\";\n          case ELLIPSIS:        return \"ELLIPSIS\";\n          case BANG:            return \"BANG\";\n          case VOID:            return \"VOID\";\n          case EQUALS:          return \"EQUALS\";\n        }\n\n        // Token without name\n        throw new IllegalStateException(String.valueOf(token));\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "AllType.AllType",
    "class_name": "com.google.javascript.rhino.jstype.AllType",
    "signature": "com.google.javascript.rhino.jstype.AllType.AllType(JSTypeRegistry)",
    "snippet": "  AllType(JSTypeRegistry registry) {\n    super(registry);\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "AllType.isAllType",
    "class_name": "com.google.javascript.rhino.jstype.AllType",
    "signature": "com.google.javascript.rhino.jstype.AllType.isAllType()",
    "snippet": "  @Override\n  public boolean isAllType() {\n    return true;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "ArrowType.ArrowType",
    "class_name": "com.google.javascript.rhino.jstype.ArrowType",
    "signature": "com.google.javascript.rhino.jstype.ArrowType.ArrowType(JSTypeRegistry,Node,JSType)",
    "snippet": "  ArrowType(JSTypeRegistry registry, Node parameters,\n      JSType returnType) {\n    this(registry, parameters, returnType, false);\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "ArrowType.ArrowType",
    "class_name": "com.google.javascript.rhino.jstype.ArrowType",
    "signature": "com.google.javascript.rhino.jstype.ArrowType.ArrowType(JSTypeRegistry,Node,JSType,boolean)",
    "snippet": "  ArrowType(JSTypeRegistry registry, Node parameters,\n      JSType returnType, boolean returnTypeInferred) {\n    super(registry);\n\n    this.parameters = parameters == null ?\n        registry.createParametersWithVarArgs(getNativeType(UNKNOWN_TYPE)) :\n        parameters;\n    this.returnType = returnType == null ?\n        getNativeType(UNKNOWN_TYPE) : returnType;\n    this.returnTypeInferred = returnTypeInferred;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "BooleanType.BooleanType",
    "class_name": "com.google.javascript.rhino.jstype.BooleanType",
    "signature": "com.google.javascript.rhino.jstype.BooleanType.BooleanType(JSTypeRegistry)",
    "snippet": "  BooleanType(JSTypeRegistry registry) {\n    super(registry);\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "BooleanType.getDisplayName",
    "class_name": "com.google.javascript.rhino.jstype.BooleanType",
    "signature": "com.google.javascript.rhino.jstype.BooleanType.getDisplayName()",
    "snippet": "  @Override\n  public String getDisplayName() {\n    return \"boolean\";\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "BooleanType.toString",
    "class_name": "com.google.javascript.rhino.jstype.BooleanType",
    "signature": "com.google.javascript.rhino.jstype.BooleanType.toString()",
    "snippet": "  @Override\n  public String toString() {\n    return getDisplayName();\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "ErrorFunctionType.ErrorFunctionType",
    "class_name": "com.google.javascript.rhino.jstype.ErrorFunctionType",
    "signature": "com.google.javascript.rhino.jstype.ErrorFunctionType.ErrorFunctionType(JSTypeRegistry,String)",
    "snippet": "  ErrorFunctionType(JSTypeRegistry registry, String name) {\n    super(\n        registry, name, null,\n        registry.createArrowType(\n            registry.createOptionalParameters(\n                registry.getNativeType(ALL_TYPE),\n                registry.getNativeType(ALL_TYPE),\n                registry.getNativeType(ALL_TYPE)),\n            null),\n        null, null, true, true);\n\n    // NOTE(nicksantos): Errors have the weird behavior in that they can\n    // be called as functions, and they will return instances of themselves.\n    // Error('x') instanceof Error => true\n    //\n    // In user-defined types, we would deal with this case by creating\n    // a NamedType with the name \"Error\" and then resolve it later.\n    //\n    // For native types, we don't really want the native types to\n    // depend on type-resolution. So we just set the return type manually\n    // at the end of construction.\n    //\n    // There's similar logic in JSTypeRegistry for Array and RegExp.\n    getInternalArrowType().returnType = getInstanceType();\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "FunctionBuilder.FunctionBuilder",
    "class_name": "com.google.javascript.rhino.jstype.FunctionBuilder",
    "signature": "com.google.javascript.rhino.jstype.FunctionBuilder.FunctionBuilder(JSTypeRegistry)",
    "snippet": "  public FunctionBuilder(JSTypeRegistry registry) {\n    this.registry = registry;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "FunctionBuilder.build",
    "class_name": "com.google.javascript.rhino.jstype.FunctionBuilder",
    "signature": "com.google.javascript.rhino.jstype.FunctionBuilder.build()",
    "snippet": "  public FunctionType build() {\n    return new FunctionType(registry, name, sourceNode,\n        new ArrowType(registry, parametersNode, returnType, inferredReturnType),\n        typeOfThis, templateTypeName, isConstructor, isNativeType);\n  }",
    "comment": "Construct a new function type. */",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "FunctionBuilder.withParamsNode",
    "class_name": "com.google.javascript.rhino.jstype.FunctionBuilder",
    "signature": "com.google.javascript.rhino.jstype.FunctionBuilder.withParamsNode(Node)",
    "snippet": "  public FunctionBuilder withParamsNode(Node parametersNode) {\n    this.parametersNode = parametersNode;\n    return this;\n  }",
    "comment": " Set the parameters of the function type with a specially-formatted node. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "FunctionBuilder.withReturnType",
    "class_name": "com.google.javascript.rhino.jstype.FunctionBuilder",
    "signature": "com.google.javascript.rhino.jstype.FunctionBuilder.withReturnType(JSType)",
    "snippet": "  public FunctionBuilder withReturnType(JSType returnType) {\n    this.returnType = returnType;\n    return this;\n  }",
    "comment": "Set the return type. */",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "FunctionParamBuilder.FunctionParamBuilder",
    "class_name": "com.google.javascript.rhino.jstype.FunctionParamBuilder",
    "signature": "com.google.javascript.rhino.jstype.FunctionParamBuilder.FunctionParamBuilder(JSTypeRegistry)",
    "snippet": "  public FunctionParamBuilder(JSTypeRegistry registry) {\n    this.registry = registry;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "FunctionParamBuilder.addOptionalParams",
    "class_name": "com.google.javascript.rhino.jstype.FunctionParamBuilder",
    "signature": "com.google.javascript.rhino.jstype.FunctionParamBuilder.addOptionalParams(JSType[])",
    "snippet": "  public boolean addOptionalParams(JSType ...types) {\n    if (hasVarArgs()) {\n      return false;\n    }\n\n    for (JSType type : types) {\n      newParameter(registry.createOptionalType(type)).setOptionalArg(true);\n    }\n    return true;\n  }",
    "comment": " Add optional parameters of the given type to the end of the param list. @param types Types for each optional parameter. The builder will make them undefineable. @return False if this is called after var args are added. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "FunctionParamBuilder.addRequiredParams",
    "class_name": "com.google.javascript.rhino.jstype.FunctionParamBuilder",
    "signature": "com.google.javascript.rhino.jstype.FunctionParamBuilder.addRequiredParams(JSType[])",
    "snippet": "  public boolean addRequiredParams(JSType ...types) {\n    if (hasOptionalOrVarArgs()) {\n      return false;\n    }\n\n    for (JSType type : types) {\n      newParameter(type);\n    }\n    return true;\n  }",
    "comment": " Add parameters of the given type to the end of the param list. @return False if this is called after optional params are added. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "FunctionParamBuilder.addVarArgs",
    "class_name": "com.google.javascript.rhino.jstype.FunctionParamBuilder",
    "signature": "com.google.javascript.rhino.jstype.FunctionParamBuilder.addVarArgs(JSType)",
    "snippet": "  public boolean addVarArgs(JSType type) {\n    if (hasVarArgs()) {\n      return false;\n    }\n\n    // There are two types of variable argument functions:\n    // 1) Programmer-defined var args\n    // 2) Native bottom types that can accept any argument.\n    // For the first one, \"undefined\" is a valid value for all arguments.\n    // For the second, we do not want to cast it up to undefined.\n    if (!type.isEmptyType()) {\n      type = registry.createOptionalType(type);\n    }\n    newParameter(type).setVarArgs(true);\n    return true;\n  }",
    "comment": " Add variable arguments to the end of the parameter list. @return False if this is called after var args are added. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "FunctionParamBuilder.build",
    "class_name": "com.google.javascript.rhino.jstype.FunctionParamBuilder",
    "signature": "com.google.javascript.rhino.jstype.FunctionParamBuilder.build()",
    "snippet": "  public Node build() {\n    return root;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "FunctionParamBuilder.hasOptionalOrVarArgs",
    "class_name": "com.google.javascript.rhino.jstype.FunctionParamBuilder",
    "signature": "com.google.javascript.rhino.jstype.FunctionParamBuilder.hasOptionalOrVarArgs()",
    "snippet": "  private boolean hasOptionalOrVarArgs() {\n    Node lastChild = root.getLastChild();\n    return lastChild != null &&\n        (lastChild.isOptionalArg() || lastChild.isVarArgs());\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "FunctionParamBuilder.hasVarArgs",
    "class_name": "com.google.javascript.rhino.jstype.FunctionParamBuilder",
    "signature": "com.google.javascript.rhino.jstype.FunctionParamBuilder.hasVarArgs()",
    "snippet": "  public boolean hasVarArgs() {\n    Node lastChild = root.getLastChild();\n    return lastChild != null && lastChild.isVarArgs();\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "FunctionParamBuilder.newParameter",
    "class_name": "com.google.javascript.rhino.jstype.FunctionParamBuilder",
    "signature": "com.google.javascript.rhino.jstype.FunctionParamBuilder.newParameter(JSType)",
    "snippet": "  private Node newParameter(JSType type) {\n    Node paramNode = Node.newString(Token.NAME, \"\");\n    paramNode.setJSType(type);\n    root.addChildToBack(paramNode);\n    return paramNode;\n  }",
    "comment": "Add a parameter to the list with the given type.",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "FunctionPrototypeType.FunctionPrototypeType",
    "class_name": "com.google.javascript.rhino.jstype.FunctionPrototypeType",
    "signature": "com.google.javascript.rhino.jstype.FunctionPrototypeType.FunctionPrototypeType(JSTypeRegistry,FunctionType,ObjectType)",
    "snippet": "  FunctionPrototypeType(JSTypeRegistry registry, FunctionType ownerFunction,\n      ObjectType implicitPrototype) {\n    this(registry, ownerFunction, implicitPrototype, false);\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "FunctionPrototypeType.FunctionPrototypeType",
    "class_name": "com.google.javascript.rhino.jstype.FunctionPrototypeType",
    "signature": "com.google.javascript.rhino.jstype.FunctionPrototypeType.FunctionPrototypeType(JSTypeRegistry,FunctionType,ObjectType,boolean)",
    "snippet": "  FunctionPrototypeType(JSTypeRegistry registry, FunctionType ownerFunction,\n      ObjectType implicitPrototype, boolean isNative) {\n    super(registry, null /* has no class name */, implicitPrototype,\n        isNative);\n    this.ownerFunction = ownerFunction;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "FunctionPrototypeType.getReferenceName",
    "class_name": "com.google.javascript.rhino.jstype.FunctionPrototypeType",
    "signature": "com.google.javascript.rhino.jstype.FunctionPrototypeType.getReferenceName()",
    "snippet": "  @Override\n  public String getReferenceName() {\n    if (ownerFunction == null) {\n      return \"{...}.prototype\";\n    } else {\n      return ownerFunction.getReferenceName() + \".prototype\";\n    }\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "FunctionPrototypeType.hasReferenceName",
    "class_name": "com.google.javascript.rhino.jstype.FunctionPrototypeType",
    "signature": "com.google.javascript.rhino.jstype.FunctionPrototypeType.hasReferenceName()",
    "snippet": "  @Override\n  public boolean hasReferenceName() {\n    return ownerFunction != null && ownerFunction.hasReferenceName();\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "FunctionType.FunctionType",
    "class_name": "com.google.javascript.rhino.jstype.FunctionType",
    "signature": "com.google.javascript.rhino.jstype.FunctionType.FunctionType(JSTypeRegistry,String,Node,ArrowType,ObjectType,String,boolean,boolean)",
    "snippet": "  FunctionType(JSTypeRegistry registry, String name, Node source,\n      ArrowType arrowType, ObjectType typeOfThis,\n      String templateTypeName,  boolean isConstructor, boolean nativeType) {\n    super(registry, name,\n        registry.getNativeObjectType(JSTypeNative.FUNCTION_INSTANCE_TYPE),\n        nativeType);\n    Preconditions.checkArgument(source == null ||\n        Token.FUNCTION == source.getType());\n    Preconditions.checkNotNull(arrowType);\n    this.source = source;\n    this.kind = isConstructor ? Kind.CONSTRUCTOR : Kind.ORDINARY;\n    if (isConstructor) {\n      this.typeOfThis = typeOfThis != null ?\n          typeOfThis : new InstanceObjectType(registry, this, nativeType);\n    } else {\n      this.typeOfThis = typeOfThis != null ?\n          typeOfThis :\n          registry.getNativeObjectType(JSTypeNative.UNKNOWN_TYPE);\n    }\n    this.call = arrowType;\n    this.templateTypeName = templateTypeName;\n  }",
    "comment": "Creates an instance for a function that might be a constructor. */",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "FunctionType.addSubType",
    "class_name": "com.google.javascript.rhino.jstype.FunctionType",
    "signature": "com.google.javascript.rhino.jstype.FunctionType.addSubType(FunctionType)",
    "snippet": "  private void addSubType(FunctionType subType) {\n    if (subTypes == null) {\n      subTypes = Lists.newArrayList();\n    }\n    subTypes.add(subType);\n  }",
    "comment": "Adds a type to the list of subtypes for this type. */",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "FunctionType.clearCachedValues",
    "class_name": "com.google.javascript.rhino.jstype.FunctionType",
    "signature": "com.google.javascript.rhino.jstype.FunctionType.clearCachedValues()",
    "snippet": "  @Override\n  public void clearCachedValues() {\n    super.clearCachedValues();\n\n    if (subTypes != null) {\n      for (FunctionType subType : subTypes) {\n        subType.clearCachedValues();\n      }\n    }\n\n    if (!isNativeObjectType()) {\n      if (hasInstanceType()) {\n        getInstanceType().clearCachedValues();\n      }\n\n      if (prototype != null) {\n        prototype.clearCachedValues();\n      }\n    }\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "FunctionType.defineProperty",
    "class_name": "com.google.javascript.rhino.jstype.FunctionType",
    "signature": "com.google.javascript.rhino.jstype.FunctionType.defineProperty(String,JSType,boolean,boolean,Node)",
    "snippet": "  @Override\n  boolean defineProperty(String name, JSType type,\n      boolean inferred, boolean inExterns, Node propertyNode) {\n    if (\"prototype\".equals(name)) {\n      ObjectType objType = type.toObjectType();\n      if (objType != null) {\n        if (objType.isEquivalentTo(prototype)) {\n          return true;\n        }\n        return setPrototype(\n            new FunctionPrototypeType(\n                registry, this, objType, isNativeObjectType()));\n      } else {\n        return false;\n      }\n    }\n    return super.defineProperty(name, type, inferred, inExterns, propertyNode);\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "FunctionType.getInstanceType",
    "class_name": "com.google.javascript.rhino.jstype.FunctionType",
    "signature": "com.google.javascript.rhino.jstype.FunctionType.getInstanceType()",
    "snippet": "  public ObjectType getInstanceType() {\n    Preconditions.checkState(hasInstanceType());\n    return typeOfThis;\n  }",
    "comment": " Gets the type of instance of this function. @throws IllegalStateException if this function is not a constructor (see {@link #isConstructor()}). ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "FunctionType.getInternalArrowType",
    "class_name": "com.google.javascript.rhino.jstype.FunctionType",
    "signature": "com.google.javascript.rhino.jstype.FunctionType.getInternalArrowType()",
    "snippet": "  ArrowType getInternalArrowType() {\n    return call;\n  }",
    "comment": "Gets the internal arrow type. For use by subclasses only. */",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "FunctionType.getPrototype",
    "class_name": "com.google.javascript.rhino.jstype.FunctionType",
    "signature": "com.google.javascript.rhino.jstype.FunctionType.getPrototype()",
    "snippet": "  public FunctionPrototypeType getPrototype() {\n    // lazy initialization of the prototype field\n    if (prototype == null) {\n      setPrototype(new FunctionPrototypeType(registry, this, null));\n    }\n    return prototype;\n  }",
    "comment": " Gets the {@code prototype} property of this function type. This is equivalent to {@code (ObjectType) getPropertyType(\"prototype\")}. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "FunctionType.getSuperClassConstructor",
    "class_name": "com.google.javascript.rhino.jstype.FunctionType",
    "signature": "com.google.javascript.rhino.jstype.FunctionType.getSuperClassConstructor()",
    "snippet": "  public FunctionType getSuperClassConstructor() {\n    Preconditions.checkArgument(isConstructor() || isInterface());\n    ObjectType maybeSuperInstanceType = getPrototype().getImplicitPrototype();\n    if (maybeSuperInstanceType == null) {\n      return null;\n    }\n    return maybeSuperInstanceType.getConstructor();\n  }",
    "comment": " Given a constructor or an interface type, get its superclass constructor or {@code null} if none exists. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "FunctionType.hasCachedValues",
    "class_name": "com.google.javascript.rhino.jstype.FunctionType",
    "signature": "com.google.javascript.rhino.jstype.FunctionType.hasCachedValues()",
    "snippet": "  @Override\n  public boolean hasCachedValues() {\n    return prototype != null || super.hasCachedValues();\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "FunctionType.hasInstanceType",
    "class_name": "com.google.javascript.rhino.jstype.FunctionType",
    "signature": "com.google.javascript.rhino.jstype.FunctionType.hasInstanceType()",
    "snippet": "  public boolean hasInstanceType() {\n    return isConstructor() || isInterface();\n  }",
    "comment": " Returns whether this function type has an instance type. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "FunctionType.isConstructor",
    "class_name": "com.google.javascript.rhino.jstype.FunctionType",
    "signature": "com.google.javascript.rhino.jstype.FunctionType.isConstructor()",
    "snippet": "  @Override\n  public boolean isConstructor() {\n    return kind == Kind.CONSTRUCTOR;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "FunctionType.isEquivalentTo",
    "class_name": "com.google.javascript.rhino.jstype.FunctionType",
    "signature": "com.google.javascript.rhino.jstype.FunctionType.isEquivalentTo(JSType)",
    "snippet": "  @Override\n  public boolean isEquivalentTo(JSType otherType) {\n    if (!(otherType instanceof FunctionType)) {\n      return false;\n    }\n    FunctionType that = (FunctionType) otherType;\n    if (!that.isFunctionType()) {\n      return false;\n    }\n    if (this.isConstructor()) {\n      if (that.isConstructor()) {\n        return this == that;\n      }\n      return false;\n    }\n    if (this.isInterface()) {\n      if (that.isInterface()) {\n        return this.getReferenceName().equals(that.getReferenceName());\n      }\n      return false;\n    }\n    if (that.isInterface()) {\n      return false;\n    }\n    return this.typeOfThis.isEquivalentTo(that.typeOfThis) &&\n        this.call.isEquivalentTo(that.call);\n  }",
    "comment": " Two function types are equal if their signatures match. Since they don't have signatures, two interfaces are equal if their names match. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "FunctionType.isFunctionType",
    "class_name": "com.google.javascript.rhino.jstype.FunctionType",
    "signature": "com.google.javascript.rhino.jstype.FunctionType.isFunctionType()",
    "snippet": "  @Override\n  public boolean isFunctionType() {\n    return true;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "FunctionType.isInterface",
    "class_name": "com.google.javascript.rhino.jstype.FunctionType",
    "signature": "com.google.javascript.rhino.jstype.FunctionType.isInterface()",
    "snippet": "  @Override\n  public boolean isInterface() {\n    return kind == Kind.INTERFACE;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "FunctionType.isSubtype",
    "class_name": "com.google.javascript.rhino.jstype.FunctionType",
    "signature": "com.google.javascript.rhino.jstype.FunctionType.isSubtype(JSType)",
    "snippet": "  @Override\n  public boolean isSubtype(JSType that) {\n    if (JSType.isSubtype(this, that)) {\n      return true;\n    }\n\n    if (that.isFunctionType()) {\n      if (((FunctionType) that).isInterface()) {\n        // Any function can be assigned to an interface function.\n        return true;\n      }\n      if (this.isInterface()) {\n        // An interface function cannot be assigned to anything.\n        return false;\n      }\n      // If functionA is a subtype of functionB, then their \"this\" types\n      // should be contravariant. However, this causes problems because\n      // of the way we enforce overrides. Because function(this:SubFoo)\n      // is not a subtype of function(this:Foo), our override check treats\n      // this as an error. It also screws up out standard method\n      // for aliasing constructors. Let's punt on all this for now.\n      // TODO(nicksantos): fix this.\n      FunctionType other = (FunctionType) that;\n      boolean treatThisTypesAsCovariant =\n        // If either one of these is a ctor, skip 'this' checking.\n        this.isConstructor() || other.isConstructor() ||\n\n        // An interface 'this'-type is non-restrictive.\n        // In practical terms, if C implements I, and I has a method m,\n        // then any m doesn't necessarily have to C#m's 'this'\n        // type doesn't need to match I.\n        (other.typeOfThis.getConstructor() != null &&\n             other.typeOfThis.getConstructor().isInterface()) ||\n\n        // If one of the 'this' types is covariant of the other,\n        // then we'll treat them as covariant (see comment above).\n        other.typeOfThis.isSubtype(this.typeOfThis) ||\n        this.typeOfThis.isSubtype(other.typeOfThis);\n      return treatThisTypesAsCovariant && this.call.isSubtype(other.call);\n    }\n\n    return getNativeType(JSTypeNative.FUNCTION_PROTOTYPE).isSubtype(that);\n  }",
    "comment": " A function is a subtype of another if their call methods are related via subtyping and {@code this} is a subtype of {@code that} with regard to the prototype chain. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "FunctionType.setInstanceType",
    "class_name": "com.google.javascript.rhino.jstype.FunctionType",
    "signature": "com.google.javascript.rhino.jstype.FunctionType.setInstanceType(ObjectType)",
    "snippet": "  void setInstanceType(ObjectType instanceType) {\n    typeOfThis = instanceType;\n  }",
    "comment": " Sets the instance type. This should only be used for special native types. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "FunctionType.setPrototype",
    "class_name": "com.google.javascript.rhino.jstype.FunctionType",
    "signature": "com.google.javascript.rhino.jstype.FunctionType.setPrototype(FunctionPrototypeType)",
    "snippet": "  public boolean setPrototype(FunctionPrototypeType prototype) {\n    if (prototype == null) {\n      return false;\n    }\n    // getInstanceType fails if the function is not a constructor\n    if (isConstructor() && prototype == getInstanceType()) {\n      return false;\n    }\n\n    boolean replacedPrototype = prototype != null;\n    this.prototype = prototype;\n\n    if (isConstructor() || isInterface()) {\n      FunctionType superClass = getSuperClassConstructor();\n      if (superClass != null) {\n        superClass.addSubType(this);\n      }\n    }\n\n    if (replacedPrototype) {\n      clearCachedValues();\n    }\n\n    return true;\n  }",
    "comment": " Sets the prototype. @param prototype the prototype. If this value is {@code null} it will silently be discarded. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "FunctionType.setPrototypeBasedOn",
    "class_name": "com.google.javascript.rhino.jstype.FunctionType",
    "signature": "com.google.javascript.rhino.jstype.FunctionType.setPrototypeBasedOn(ObjectType)",
    "snippet": "  public void setPrototypeBasedOn(ObjectType baseType) {\n    if (prototype == null) {\n      setPrototype(\n          new FunctionPrototypeType(\n              registry, this, baseType, isNativeObjectType()));\n    } else {\n      prototype.setImplicitPrototype(baseType);\n    }\n  }",
    "comment": " Sets the prototype, creating the prototype object from the given base type. @param baseType The base type. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "InstanceObjectType.InstanceObjectType",
    "class_name": "com.google.javascript.rhino.jstype.InstanceObjectType",
    "signature": "com.google.javascript.rhino.jstype.InstanceObjectType.InstanceObjectType(JSTypeRegistry,FunctionType,boolean)",
    "snippet": "  InstanceObjectType(JSTypeRegistry registry, FunctionType constructor,\n                     boolean isNativeType) {\n    super(registry, null, null, isNativeType);\n    Preconditions.checkNotNull(constructor);\n    this.constructor = constructor;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "InstanceObjectType.defineProperty",
    "class_name": "com.google.javascript.rhino.jstype.InstanceObjectType",
    "signature": "com.google.javascript.rhino.jstype.InstanceObjectType.defineProperty(String,JSType,boolean,boolean,Node)",
    "snippet": "  @Override\n  boolean defineProperty(String name, JSType type, boolean inferred,\n      boolean inExterns, Node propertyNode) {\n    ObjectType proto = getImplicitPrototype();\n    if (proto != null && proto.hasOwnDeclaredProperty(name)) {\n      return false;\n    }\n    return super.defineProperty(name, type, inferred, inExterns, propertyNode);\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "InstanceObjectType.getConstructor",
    "class_name": "com.google.javascript.rhino.jstype.InstanceObjectType",
    "signature": "com.google.javascript.rhino.jstype.InstanceObjectType.getConstructor()",
    "snippet": "  @Override\n  public FunctionType getConstructor() {\n    return constructor;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "InstanceObjectType.getImplicitPrototype",
    "class_name": "com.google.javascript.rhino.jstype.InstanceObjectType",
    "signature": "com.google.javascript.rhino.jstype.InstanceObjectType.getImplicitPrototype()",
    "snippet": "  @Override\n  public ObjectType getImplicitPrototype() {\n    return getConstructor().getPrototype();\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "InstanceObjectType.getReferenceName",
    "class_name": "com.google.javascript.rhino.jstype.InstanceObjectType",
    "signature": "com.google.javascript.rhino.jstype.InstanceObjectType.getReferenceName()",
    "snippet": "  @Override\n  public String getReferenceName() {\n    return getConstructor().getReferenceName();\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "InstanceObjectType.hasReferenceName",
    "class_name": "com.google.javascript.rhino.jstype.InstanceObjectType",
    "signature": "com.google.javascript.rhino.jstype.InstanceObjectType.hasReferenceName()",
    "snippet": "  @Override\n  public boolean hasReferenceName() {\n    return getConstructor().hasReferenceName();\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "InstanceObjectType.hashCode",
    "class_name": "com.google.javascript.rhino.jstype.InstanceObjectType",
    "signature": "com.google.javascript.rhino.jstype.InstanceObjectType.hashCode()",
    "snippet": "  @Override\n  public int hashCode() {\n    if (hasReferenceName()) {\n      return getReferenceName().hashCode();\n    } else {\n      return super.hashCode();\n    }\n  }",
    "comment": " If this is equal to a NamedType object, its hashCode must be equal to the hashCode of the NamedType object. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "InstanceObjectType.isEquivalentTo",
    "class_name": "com.google.javascript.rhino.jstype.InstanceObjectType",
    "signature": "com.google.javascript.rhino.jstype.InstanceObjectType.isEquivalentTo(JSType)",
    "snippet": "  @Override\n  public boolean isEquivalentTo(JSType that) {\n    if (this == that) {\n      return true;\n    } else if (this.isNominalType()) {\n      ObjectType thatObj = ObjectType.cast(that);\n      if (thatObj != null && thatObj.isNominalType()) {\n        return getReferenceName().equals(thatObj.getReferenceName());\n      }\n    }\n    return false;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "InstanceObjectType.isNominalType",
    "class_name": "com.google.javascript.rhino.jstype.InstanceObjectType",
    "signature": "com.google.javascript.rhino.jstype.InstanceObjectType.isNominalType()",
    "snippet": "  @Override\n  public boolean isNominalType() {\n    return hasReferenceName();\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "InstanceObjectType.toString",
    "class_name": "com.google.javascript.rhino.jstype.InstanceObjectType",
    "signature": "com.google.javascript.rhino.jstype.InstanceObjectType.toString()",
    "snippet": "  @Override\n  public String toString() {\n    if (constructor.hasReferenceName()) {\n      return constructor.getReferenceName();\n    } else {\n      return super.toString();\n    }\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "JSType.JSType",
    "class_name": "com.google.javascript.rhino.jstype.JSType",
    "signature": "com.google.javascript.rhino.jstype.JSType.JSType(JSTypeRegistry)",
    "snippet": "  JSType(JSTypeRegistry registry) {\n    this.registry = registry;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "JSType.getNativeType",
    "class_name": "com.google.javascript.rhino.jstype.JSType",
    "signature": "com.google.javascript.rhino.jstype.JSType.getNativeType(JSTypeNative)",
    "snippet": "  JSType getNativeType(JSTypeNative typeId) {\n    return registry.getNativeType(typeId);\n  }",
    "comment": " Utility method for less verbose code. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "JSType.hashCode",
    "class_name": "com.google.javascript.rhino.jstype.JSType",
    "signature": "com.google.javascript.rhino.jstype.JSType.hashCode()",
    "snippet": "  @Override\n  public int hashCode() {\n    return System.identityHashCode(this);\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "JSType.isAllType",
    "class_name": "com.google.javascript.rhino.jstype.JSType",
    "signature": "com.google.javascript.rhino.jstype.JSType.isAllType()",
    "snippet": "  public boolean isAllType() {\n    return false;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "JSType.isEmptyType",
    "class_name": "com.google.javascript.rhino.jstype.JSType",
    "signature": "com.google.javascript.rhino.jstype.JSType.isEmptyType()",
    "snippet": "  public final boolean isEmptyType() {\n    return isNoType() || isNoObjectType() || isNoResolvedType() ||\n        (registry.getNativeFunctionType(\n             JSTypeNative.LEAST_FUNCTION_TYPE) == this);\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "JSType.isEquivalentTo",
    "class_name": "com.google.javascript.rhino.jstype.JSType",
    "signature": "com.google.javascript.rhino.jstype.JSType.isEquivalentTo(JSType)",
    "snippet": "  public boolean isEquivalentTo(JSType jsType) {\n    if (jsType instanceof ProxyObjectType) {\n      return jsType.isEquivalentTo(this);\n    }\n    // Relies on the fact that for the base {@link JSType}, only one\n    // instance of each sub-type will ever be created in a given registry, so\n    // there is no need to verify members. If the object pointers are not\n    // identical, then the type member must be different.\n    return this == jsType;\n  }",
    "comment": " Checks if two types are equivalent. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "JSType.isNoObjectType",
    "class_name": "com.google.javascript.rhino.jstype.JSType",
    "signature": "com.google.javascript.rhino.jstype.JSType.isNoObjectType()",
    "snippet": "  public boolean isNoObjectType() {\n    return false;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "JSType.isNoResolvedType",
    "class_name": "com.google.javascript.rhino.jstype.JSType",
    "signature": "com.google.javascript.rhino.jstype.JSType.isNoResolvedType()",
    "snippet": "  public boolean isNoResolvedType() {\n    return false;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "JSType.isNoType",
    "class_name": "com.google.javascript.rhino.jstype.JSType",
    "signature": "com.google.javascript.rhino.jstype.JSType.isNoType()",
    "snippet": "  public boolean isNoType() {\n    return false;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "JSType.isNominalType",
    "class_name": "com.google.javascript.rhino.jstype.JSType",
    "signature": "com.google.javascript.rhino.jstype.JSType.isNominalType()",
    "snippet": "  public boolean isNominalType() {\n    return false;\n  }",
    "comment": " Whether this type is a nominal type (a named instance object or a named enum). ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "JSType.isSubtype",
    "class_name": "com.google.javascript.rhino.jstype.JSType",
    "signature": "com.google.javascript.rhino.jstype.JSType.isSubtype(JSType,JSType)",
    "snippet": "  static boolean isSubtype(JSType thisType, JSType thatType) {\n    // unknown\n    if (thatType.isUnknownType()) {\n      return true;\n    }\n    // equality\n    if (thisType.isEquivalentTo(thatType)) {\n      return true;\n    }\n    // all type\n    if (thatType.isAllType()) {\n      return true;\n    }\n    // unions\n    if (thatType instanceof UnionType) {\n      UnionType union = (UnionType)thatType;\n      for (JSType element : union.alternates) {\n        if (thisType.isSubtype(element)) {\n          return true;\n        }\n      }\n    }\n    // named types\n    if (thatType instanceof NamedType) {\n      return thisType.isSubtype(((NamedType)thatType).getReferencedType());\n    }\n    return false;\n  }",
    "comment": " A generic implementation meant to be used as a helper for common subtyping cases. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "JSType.isUnknownType",
    "class_name": "com.google.javascript.rhino.jstype.JSType",
    "signature": "com.google.javascript.rhino.jstype.JSType.isUnknownType()",
    "snippet": "  public boolean isUnknownType() {\n    return false;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "JSType.toObjectType",
    "class_name": "com.google.javascript.rhino.jstype.JSType",
    "signature": "com.google.javascript.rhino.jstype.JSType.toObjectType()",
    "snippet": "  public ObjectType toObjectType() {\n    return this instanceof ObjectType ? (ObjectType) this : null;\n  }",
    "comment": " Casts this to an ObjectType, or returns null if this is not an ObjectType.  Does not change the underlying JS type. If you want to simulate JS autoboxing or dereferencing, you should use autoboxesTo() or dereference(). Those methods may change the underlying JS type. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "JSTypeRegistry.JSTypeRegistry",
    "class_name": "com.google.javascript.rhino.jstype.JSTypeRegistry",
    "signature": "com.google.javascript.rhino.jstype.JSTypeRegistry.JSTypeRegistry(ErrorReporter,boolean)",
    "snippet": "  public JSTypeRegistry(\n      ErrorReporter reporter, boolean tolerateUndefinedValues) {\n    this.reporter = reporter;\n    nativeTypes = new JSType[JSTypeNative.values().length];\n    namesToTypes = new HashMap<String, JSType>();\n    resetForTypeCheck();\n    this.tolerateUndefinedValues = tolerateUndefinedValues;\n  }",
    "comment": " Constructs a new type registry populated with the built-in types. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "JSTypeRegistry.addReferenceTypeIndexedByProperty",
    "class_name": "com.google.javascript.rhino.jstype.JSTypeRegistry",
    "signature": "com.google.javascript.rhino.jstype.JSTypeRegistry.addReferenceTypeIndexedByProperty(String,JSType)",
    "snippet": "  private void addReferenceTypeIndexedByProperty(\n      String propertyName, JSType type) {\n    if (type instanceof ObjectType && ((ObjectType) type).hasReferenceName()) {\n      Map<String, ObjectType> typeSet =\n          eachRefTypeIndexedByProperty.get(propertyName);\n      if (typeSet == null) {\n        typeSet = Maps.newHashMap();\n        eachRefTypeIndexedByProperty.put(propertyName, typeSet);\n      }\n      ObjectType objType = (ObjectType) type;\n      typeSet.put(objType.getReferenceName(), objType);\n    } else if (type instanceof NamedType) {\n      addReferenceTypeIndexedByProperty(\n          propertyName, ((NamedType) type).getReferencedType());\n    } else if (type instanceof UnionType) {\n      for (JSType alternate : ((UnionType) type).getAlternates()) {\n        addReferenceTypeIndexedByProperty(propertyName, alternate);\n      }\n    }\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "JSTypeRegistry.createArrowType",
    "class_name": "com.google.javascript.rhino.jstype.JSTypeRegistry",
    "signature": "com.google.javascript.rhino.jstype.JSTypeRegistry.createArrowType(Node)",
    "snippet": "  ArrowType createArrowType(Node parametersNode) {\n    return new ArrowType(this, parametersNode, null);\n  }",
    "comment": " Creates an arrow type with an unknown return type.  @param parametersNode the parameters' types, formatted as a Node with param names and optionality info. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "JSTypeRegistry.createArrowType",
    "class_name": "com.google.javascript.rhino.jstype.JSTypeRegistry",
    "signature": "com.google.javascript.rhino.jstype.JSTypeRegistry.createArrowType(Node,JSType)",
    "snippet": "  ArrowType createArrowType(Node parametersNode, JSType returnType) {\n    return new ArrowType(this, parametersNode, returnType);\n  }",
    "comment": " Creates an arrow type, an abstract representation of the parameters and return value of a function.  @param parametersNode the parameters' types, formatted as a Node with param names and optionality info. @param returnType the function's return type ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "JSTypeRegistry.createFunctionType",
    "class_name": "com.google.javascript.rhino.jstype.JSTypeRegistry",
    "signature": "com.google.javascript.rhino.jstype.JSTypeRegistry.createFunctionType(JSType,Node)",
    "snippet": "  public FunctionType createFunctionType(\n      JSType returnType, Node parameters) {\n    return new FunctionBuilder(this)\n        .withParamsNode(parameters)\n        .withReturnType(returnType)\n        .build();\n  }",
    "comment": " @param parameters the function's parameters or {@code null} to indicate that the parameter types are unknown. @param returnType the function's return type or {@code null} to indicate that the return type is unknown. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "JSTypeRegistry.createFunctionType",
    "class_name": "com.google.javascript.rhino.jstype.JSTypeRegistry",
    "signature": "com.google.javascript.rhino.jstype.JSTypeRegistry.createFunctionType(JSType,boolean,JSType[])",
    "snippet": "  public FunctionType createFunctionType(JSType returnType,\n      boolean lastVarArgs, JSType... parameterTypes) {\n    if (lastVarArgs) {\n      return createFunctionTypeWithVarArgs(returnType, parameterTypes);\n    } else {\n      return createFunctionType(returnType, parameterTypes);\n    }\n  }",
    "comment": " Creates a function type. @param returnType the function's return type @param lastVarArgs whether the last parameter type should be considered as an extensible var_args parameter @param parameterTypes the parameters' types ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "JSTypeRegistry.createFunctionTypeWithVarArgs",
    "class_name": "com.google.javascript.rhino.jstype.JSTypeRegistry",
    "signature": "com.google.javascript.rhino.jstype.JSTypeRegistry.createFunctionTypeWithVarArgs(JSType,JSType[])",
    "snippet": "  public FunctionType createFunctionTypeWithVarArgs(\n      JSType returnType, JSType... parameterTypes) {\n    return createFunctionType(\n        returnType, createParametersWithVarArgs(parameterTypes));\n  }",
    "comment": " Creates a function type. The last parameter type of the function is considered a variable length argument.  @param returnType the function's return type @param parameterTypes the parameters' types ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "JSTypeRegistry.createNullableType",
    "class_name": "com.google.javascript.rhino.jstype.JSTypeRegistry",
    "signature": "com.google.javascript.rhino.jstype.JSTypeRegistry.createNullableType(JSType)",
    "snippet": "  public JSType createNullableType(JSType type) {\n    return createUnionType(type, getNativeType(JSTypeNative.NULL_TYPE));\n  }",
    "comment": " Creates a type representing nullable values of the given type. @return the union of the type and the Null type ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "JSTypeRegistry.createOptionalParameters",
    "class_name": "com.google.javascript.rhino.jstype.JSTypeRegistry",
    "signature": "com.google.javascript.rhino.jstype.JSTypeRegistry.createOptionalParameters(JSType[])",
    "snippet": "  public Node createOptionalParameters(JSType... parameterTypes) {\n    FunctionParamBuilder builder = new FunctionParamBuilder(this);\n    builder.addOptionalParams(parameterTypes);\n    return builder.build();\n  }",
    "comment": " Creates a tree hierarchy representing a typed parameter list in which every parameter is optional. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "JSTypeRegistry.createOptionalType",
    "class_name": "com.google.javascript.rhino.jstype.JSTypeRegistry",
    "signature": "com.google.javascript.rhino.jstype.JSTypeRegistry.createOptionalType(JSType)",
    "snippet": "  public JSType createOptionalType(JSType type) {\n    if (type instanceof UnknownType || type.isAllType()) {\n      return type;\n    } else {\n      return createUnionType(type, getNativeType(JSTypeNative.VOID_TYPE));\n    }\n  }",
    "comment": " Creates a type representing optional values of the given type. @return the union of the type and the void type ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "JSTypeRegistry.createParameters",
    "class_name": "com.google.javascript.rhino.jstype.JSTypeRegistry",
    "signature": "com.google.javascript.rhino.jstype.JSTypeRegistry.createParameters(boolean,JSType[])",
    "snippet": "  private Node createParameters(boolean lastVarArgs, JSType... parameterTypes) {\n    FunctionParamBuilder builder = new FunctionParamBuilder(this);\n    int max = parameterTypes.length - 1;\n    for (int i = 0; i <= max; i++) {\n      if (lastVarArgs && i == max) {\n        builder.addVarArgs(parameterTypes[i]);\n      } else {\n        builder.addRequiredParams(parameterTypes[i]);\n      }\n    }\n    return builder.build();\n  }",
    "comment": " Creates a tree hierarchy representing a typed argument list.  @param lastVarArgs whether the last type should considered as a variable length argument. @param parameterTypes the parameter types. The last element of this array is considered a variable length argument is {@code lastVarArgs} is {@code true}. @return a tree hierarchy representing a typed argument list ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "JSTypeRegistry.createParametersWithVarArgs",
    "class_name": "com.google.javascript.rhino.jstype.JSTypeRegistry",
    "signature": "com.google.javascript.rhino.jstype.JSTypeRegistry.createParametersWithVarArgs(JSType[])",
    "snippet": "  public Node createParametersWithVarArgs(JSType... parameterTypes) {\n    return createParameters(true, parameterTypes);\n  }",
    "comment": " Creates a tree hierarchy representing a typed argument list. The last parameter type is considered a variable length argument.  @param parameterTypes the parameter types. The last element of this array is considered a variable length argument. @return a tree hierarchy representing a typed argument list. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "JSTypeRegistry.createUnionType",
    "class_name": "com.google.javascript.rhino.jstype.JSTypeRegistry",
    "signature": "com.google.javascript.rhino.jstype.JSTypeRegistry.createUnionType(JSType[])",
    "snippet": "  public JSType createUnionType(JSType... variants) {\n    UnionTypeBuilder builder = new UnionTypeBuilder(this);\n    for (JSType type : variants) {\n      builder.addAlternate(type);\n    }\n    return builder.build();\n  }",
    "comment": " Creates a union type whose variants are the arguments. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "JSTypeRegistry.getNativeFunctionType",
    "class_name": "com.google.javascript.rhino.jstype.JSTypeRegistry",
    "signature": "com.google.javascript.rhino.jstype.JSTypeRegistry.getNativeFunctionType(JSTypeNative)",
    "snippet": "  public FunctionType getNativeFunctionType(JSTypeNative typeId) {\n    return (FunctionType) getNativeType(typeId);\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "JSTypeRegistry.getNativeObjectType",
    "class_name": "com.google.javascript.rhino.jstype.JSTypeRegistry",
    "signature": "com.google.javascript.rhino.jstype.JSTypeRegistry.getNativeObjectType(JSTypeNative)",
    "snippet": "  public ObjectType getNativeObjectType(JSTypeNative typeId) {\n    return (ObjectType) getNativeType(typeId);\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "JSTypeRegistry.getNativeType",
    "class_name": "com.google.javascript.rhino.jstype.JSTypeRegistry",
    "signature": "com.google.javascript.rhino.jstype.JSTypeRegistry.getNativeType(JSTypeNative)",
    "snippet": "  public JSType getNativeType(JSTypeNative typeId) {\n    return nativeTypes[typeId.ordinal()];\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "JSTypeRegistry.initializeBuiltInTypes",
    "class_name": "com.google.javascript.rhino.jstype.JSTypeRegistry",
    "signature": "com.google.javascript.rhino.jstype.JSTypeRegistry.initializeBuiltInTypes()",
    "snippet": "  private void initializeBuiltInTypes() {\n    // These locals shouldn't be all caps.\n    BooleanType BOOLEAN_TYPE = new BooleanType(this);\n    registerNativeType(JSTypeNative.BOOLEAN_TYPE, BOOLEAN_TYPE);\n\n    NullType NULL_TYPE = new NullType(this);\n    registerNativeType(JSTypeNative.NULL_TYPE, NULL_TYPE);\n\n    NumberType NUMBER_TYPE = new NumberType(this);\n    registerNativeType(JSTypeNative.NUMBER_TYPE, NUMBER_TYPE);\n\n    StringType STRING_TYPE = new StringType(this);\n    registerNativeType(JSTypeNative.STRING_TYPE, STRING_TYPE);\n\n    UnknownType UNKNOWN_TYPE = new UnknownType(this, false);\n    registerNativeType(JSTypeNative.UNKNOWN_TYPE, UNKNOWN_TYPE);\n    registerNativeType(\n        JSTypeNative.CHECKED_UNKNOWN_TYPE, new UnknownType(this, true));\n\n    VoidType VOID_TYPE = new VoidType(this);\n    registerNativeType(JSTypeNative.VOID_TYPE, VOID_TYPE);\n\n    AllType ALL_TYPE = new AllType(this);\n    registerNativeType(JSTypeNative.ALL_TYPE, ALL_TYPE);\n\n    // Top Level Prototype (the One)\n    // The initializations of TOP_LEVEL_PROTOTYPE and OBJECT_FUNCTION_TYPE\n    // use each other's results, so at least one of them will get null\n    // instead of an actual type; however, this seems to be benign.\n    ObjectType TOP_LEVEL_PROTOTYPE =\n        new FunctionPrototypeType(this, null, null, true);\n    registerNativeType(JSTypeNative.TOP_LEVEL_PROTOTYPE, TOP_LEVEL_PROTOTYPE);\n\n    // Object\n    FunctionType OBJECT_FUNCTION_TYPE =\n        new FunctionType(this, \"Object\", null,\n            createArrowType(createOptionalParameters(ALL_TYPE), UNKNOWN_TYPE),\n            null, null, true, true);\n    OBJECT_FUNCTION_TYPE.defineDeclaredProperty(\n        \"prototype\", TOP_LEVEL_PROTOTYPE, true, null);\n    registerNativeType(JSTypeNative.OBJECT_FUNCTION_TYPE, OBJECT_FUNCTION_TYPE);\n\n    ObjectType OBJECT_PROTOTYPE = OBJECT_FUNCTION_TYPE.getPrototype();\n    registerNativeType(JSTypeNative.OBJECT_PROTOTYPE, OBJECT_PROTOTYPE);\n\n    ObjectType OBJECT_TYPE = OBJECT_FUNCTION_TYPE.getInstanceType();\n    registerNativeType(JSTypeNative.OBJECT_TYPE, OBJECT_TYPE);\n\n    // Function\n    FunctionType FUNCTION_FUNCTION_TYPE =\n        new FunctionType(this, \"Function\", null,\n            createArrowType(\n                createParametersWithVarArgs(ALL_TYPE), UNKNOWN_TYPE),\n            null, null, true, true);\n    FUNCTION_FUNCTION_TYPE.setPrototypeBasedOn(OBJECT_TYPE);\n    registerNativeType(\n        JSTypeNative.FUNCTION_FUNCTION_TYPE, FUNCTION_FUNCTION_TYPE);\n\n    ObjectType FUNCTION_PROTOTYPE = FUNCTION_FUNCTION_TYPE.getPrototype();\n    registerNativeType(JSTypeNative.FUNCTION_PROTOTYPE, FUNCTION_PROTOTYPE);\n\n    NoType NO_TYPE = new NoType(this);\n    registerNativeType(JSTypeNative.NO_TYPE, NO_TYPE);\n\n    NoObjectType NO_OBJECT_TYPE = new NoObjectType(this);\n    registerNativeType(JSTypeNative.NO_OBJECT_TYPE, NO_OBJECT_TYPE);\n\n    NoObjectType NO_RESOLVED_TYPE = new NoResolvedType(this);\n    registerNativeType(JSTypeNative.NO_RESOLVED_TYPE, NO_RESOLVED_TYPE);\n\n    // Array\n    FunctionType ARRAY_FUNCTION_TYPE =\n      new FunctionType(this, \"Array\", null,\n          createArrowType(createParametersWithVarArgs(ALL_TYPE), null),\n          null, null, true, true);\n    ARRAY_FUNCTION_TYPE.getInternalArrowType().returnType =\n        ARRAY_FUNCTION_TYPE.getInstanceType();\n\n    ObjectType arrayPrototype = ARRAY_FUNCTION_TYPE.getPrototype();\n    registerNativeType(JSTypeNative.ARRAY_FUNCTION_TYPE, ARRAY_FUNCTION_TYPE);\n\n    ObjectType ARRAY_TYPE = ARRAY_FUNCTION_TYPE.getInstanceType();\n    registerNativeType(JSTypeNative.ARRAY_TYPE, ARRAY_TYPE);\n\n    // Boolean\n    FunctionType BOOLEAN_OBJECT_FUNCTION_TYPE =\n        new FunctionType(this, \"Boolean\", null,\n            createArrowType(createParameters(false, ALL_TYPE), BOOLEAN_TYPE),\n            null, null, true, true);\n    ObjectType booleanPrototype = BOOLEAN_OBJECT_FUNCTION_TYPE.getPrototype();\n    registerNativeType(\n        JSTypeNative.BOOLEAN_OBJECT_FUNCTION_TYPE,\n        BOOLEAN_OBJECT_FUNCTION_TYPE);\n\n    ObjectType BOOLEAN_OBJECT_TYPE =\n        BOOLEAN_OBJECT_FUNCTION_TYPE.getInstanceType();\n    registerNativeType(JSTypeNative.BOOLEAN_OBJECT_TYPE, BOOLEAN_OBJECT_TYPE);\n\n    // Date\n    FunctionType DATE_FUNCTION_TYPE =\n      new FunctionType(this, \"Date\", null,\n          createArrowType(\n              createOptionalParameters(UNKNOWN_TYPE, UNKNOWN_TYPE, UNKNOWN_TYPE,\n                  UNKNOWN_TYPE, UNKNOWN_TYPE, UNKNOWN_TYPE, UNKNOWN_TYPE),\n              STRING_TYPE),\n          null, null, true, true);\n    ObjectType datePrototype = DATE_FUNCTION_TYPE.getPrototype();\n    registerNativeType(JSTypeNative.DATE_FUNCTION_TYPE, DATE_FUNCTION_TYPE);\n\n    ObjectType DATE_TYPE = DATE_FUNCTION_TYPE.getInstanceType();\n    registerNativeType(JSTypeNative.DATE_TYPE, DATE_TYPE);\n\n    // Error\n    FunctionType ERROR_FUNCTION_TYPE = new ErrorFunctionType(this, \"Error\");\n    registerNativeType(JSTypeNative.ERROR_FUNCTION_TYPE, ERROR_FUNCTION_TYPE);\n\n    ObjectType ERROR_TYPE = ERROR_FUNCTION_TYPE.getInstanceType();\n    registerNativeType(JSTypeNative.ERROR_TYPE, ERROR_TYPE);\n\n    // EvalError\n    FunctionType EVAL_ERROR_FUNCTION_TYPE =\n        new ErrorFunctionType(this, \"EvalError\");\n    EVAL_ERROR_FUNCTION_TYPE.setPrototypeBasedOn(ERROR_TYPE);\n    registerNativeType(\n        JSTypeNative.EVAL_ERROR_FUNCTION_TYPE, EVAL_ERROR_FUNCTION_TYPE);\n\n    ObjectType EVAL_ERROR_TYPE = EVAL_ERROR_FUNCTION_TYPE.getInstanceType();\n    registerNativeType(JSTypeNative.EVAL_ERROR_TYPE, EVAL_ERROR_TYPE);\n\n    // RangeError\n    FunctionType RANGE_ERROR_FUNCTION_TYPE =\n        new ErrorFunctionType(this, \"RangeError\");\n    RANGE_ERROR_FUNCTION_TYPE.setPrototypeBasedOn(ERROR_TYPE);\n    registerNativeType(\n        JSTypeNative.RANGE_ERROR_FUNCTION_TYPE, RANGE_ERROR_FUNCTION_TYPE);\n\n    ObjectType RANGE_ERROR_TYPE = RANGE_ERROR_FUNCTION_TYPE.getInstanceType();\n    registerNativeType(JSTypeNative.RANGE_ERROR_TYPE, RANGE_ERROR_TYPE);\n\n    // ReferenceError\n    FunctionType REFERENCE_ERROR_FUNCTION_TYPE =\n        new ErrorFunctionType(this, \"ReferenceError\");\n    REFERENCE_ERROR_FUNCTION_TYPE.setPrototypeBasedOn(ERROR_TYPE);\n    registerNativeType(\n        JSTypeNative.REFERENCE_ERROR_FUNCTION_TYPE,\n        REFERENCE_ERROR_FUNCTION_TYPE);\n\n    ObjectType REFERENCE_ERROR_TYPE =\n        REFERENCE_ERROR_FUNCTION_TYPE.getInstanceType();\n    registerNativeType(JSTypeNative.REFERENCE_ERROR_TYPE, REFERENCE_ERROR_TYPE);\n\n    // SyntaxError\n    FunctionType SYNTAX_ERROR_FUNCTION_TYPE =\n        new ErrorFunctionType(this, \"SyntaxError\");\n    SYNTAX_ERROR_FUNCTION_TYPE.setPrototypeBasedOn(ERROR_TYPE);\n    registerNativeType(\n        JSTypeNative.SYNTAX_ERROR_FUNCTION_TYPE, SYNTAX_ERROR_FUNCTION_TYPE);\n\n    ObjectType SYNTAX_ERROR_TYPE = SYNTAX_ERROR_FUNCTION_TYPE.getInstanceType();\n    registerNativeType(JSTypeNative.SYNTAX_ERROR_TYPE, SYNTAX_ERROR_TYPE);\n\n    // TypeError\n    FunctionType TYPE_ERROR_FUNCTION_TYPE =\n        new ErrorFunctionType(this, \"TypeError\");\n    TYPE_ERROR_FUNCTION_TYPE.setPrototypeBasedOn(ERROR_TYPE);\n    registerNativeType(\n        JSTypeNative.TYPE_ERROR_FUNCTION_TYPE, TYPE_ERROR_FUNCTION_TYPE);\n\n    ObjectType TYPE_ERROR_TYPE = TYPE_ERROR_FUNCTION_TYPE.getInstanceType();\n    registerNativeType(JSTypeNative.TYPE_ERROR_TYPE, TYPE_ERROR_TYPE);\n\n    // URIError\n    FunctionType URI_ERROR_FUNCTION_TYPE =\n        new ErrorFunctionType(this, \"URIError\");\n    URI_ERROR_FUNCTION_TYPE.setPrototypeBasedOn(ERROR_TYPE);\n    registerNativeType(\n        JSTypeNative.URI_ERROR_FUNCTION_TYPE, URI_ERROR_FUNCTION_TYPE);\n\n    ObjectType URI_ERROR_TYPE = URI_ERROR_FUNCTION_TYPE.getInstanceType();\n    registerNativeType(JSTypeNative.URI_ERROR_TYPE, URI_ERROR_TYPE);\n\n    // Number\n    FunctionType NUMBER_OBJECT_FUNCTION_TYPE =\n        new FunctionType(this, \"Number\", null,\n            createArrowType(createParameters(false, ALL_TYPE), NUMBER_TYPE),\n            null, null, true, true);\n    ObjectType numberPrototype = NUMBER_OBJECT_FUNCTION_TYPE.getPrototype();\n    registerNativeType(\n        JSTypeNative.NUMBER_OBJECT_FUNCTION_TYPE, NUMBER_OBJECT_FUNCTION_TYPE);\n\n    ObjectType NUMBER_OBJECT_TYPE =\n        NUMBER_OBJECT_FUNCTION_TYPE.getInstanceType();\n    registerNativeType(JSTypeNative.NUMBER_OBJECT_TYPE, NUMBER_OBJECT_TYPE);\n\n    // RegExp\n    FunctionType REGEXP_FUNCTION_TYPE =\n      new FunctionType(this, \"RegExp\", null,\n          createArrowType(createOptionalParameters(ALL_TYPE, ALL_TYPE)),\n          null, null, true, true);\n    REGEXP_FUNCTION_TYPE.getInternalArrowType().returnType =\n        REGEXP_FUNCTION_TYPE.getInstanceType();\n\n    ObjectType regexpPrototype = REGEXP_FUNCTION_TYPE.getPrototype();\n    registerNativeType(JSTypeNative.REGEXP_FUNCTION_TYPE, REGEXP_FUNCTION_TYPE);\n\n    ObjectType REGEXP_TYPE = REGEXP_FUNCTION_TYPE.getInstanceType();\n    registerNativeType(JSTypeNative.REGEXP_TYPE, REGEXP_TYPE);\n\n    // String\n    FunctionType STRING_OBJECT_FUNCTION_TYPE =\n        new FunctionType(this, \"String\", null,\n            createArrowType(createParameters(false, ALL_TYPE), STRING_TYPE),\n            null, null, true, true);\n    ObjectType stringPrototype = STRING_OBJECT_FUNCTION_TYPE.getPrototype();\n    registerNativeType(\n        JSTypeNative.STRING_OBJECT_FUNCTION_TYPE, STRING_OBJECT_FUNCTION_TYPE);\n\n    ObjectType STRING_OBJECT_TYPE =\n        STRING_OBJECT_FUNCTION_TYPE.getInstanceType();\n    registerNativeType(\n        JSTypeNative.STRING_OBJECT_TYPE, STRING_OBJECT_TYPE);\n\n    // (Object,string,number)\n    JSType OBJECT_NUMBER_STRING =\n        createUnionType(OBJECT_TYPE, NUMBER_TYPE, STRING_TYPE);\n    registerNativeType(JSTypeNative.OBJECT_NUMBER_STRING, OBJECT_NUMBER_STRING);\n\n    // (Object,string,number,boolean)\n    JSType OBJECT_NUMBER_STRING_BOOLEAN =\n        createUnionType(OBJECT_TYPE, NUMBER_TYPE, STRING_TYPE, BOOLEAN_TYPE);\n    registerNativeType(JSTypeNative.OBJECT_NUMBER_STRING_BOOLEAN,\n        OBJECT_NUMBER_STRING_BOOLEAN);\n\n    // (string,number,boolean)\n    JSType NUMBER_STRING_BOOLEAN =\n        createUnionType(NUMBER_TYPE, STRING_TYPE, BOOLEAN_TYPE);\n    registerNativeType(JSTypeNative.NUMBER_STRING_BOOLEAN,\n        NUMBER_STRING_BOOLEAN);\n\n    // (string,number)\n    JSType NUMBER_STRING = createUnionType(NUMBER_TYPE, STRING_TYPE);\n    registerNativeType(JSTypeNative.NUMBER_STRING, NUMBER_STRING);\n\n    // Native object properties are filled in by externs...\n\n    // (String, string)\n    JSType STRING_VALUE_OR_OBJECT_TYPE =\n        createUnionType(STRING_OBJECT_TYPE, STRING_TYPE);\n    registerNativeType(\n        JSTypeNative.STRING_VALUE_OR_OBJECT_TYPE, STRING_VALUE_OR_OBJECT_TYPE);\n\n    // (Number, number)\n    JSType NUMBER_VALUE_OR_OBJECT_TYPE =\n        createUnionType(NUMBER_OBJECT_TYPE, NUMBER_TYPE);\n    registerNativeType(\n        JSTypeNative.NUMBER_VALUE_OR_OBJECT_TYPE, NUMBER_VALUE_OR_OBJECT_TYPE);\n\n    // unknown function type, i.e. (?...) -> ?\n    FunctionType U2U_FUNCTION_TYPE =\n        createFunctionType(UNKNOWN_TYPE, true, UNKNOWN_TYPE);\n    registerNativeType(JSTypeNative.U2U_FUNCTION_TYPE, U2U_FUNCTION_TYPE);\n\n    // unknown constructor type, i.e. (?...) -> ? with the NoObject type\n    // as instance type\n    FunctionType U2U_CONSTRUCTOR_TYPE =\n        // This is equivalent to\n        // createConstructorType(UNKNOWN_TYPE, true, UNKNOWN_TYPE), but,\n        // in addition, overrides getInstanceType() to return the NoObject type\n        // instead of a new anonymous object.\n        new FunctionType(this, \"Function\", null,\n            createArrowType(\n                createParametersWithVarArgs(UNKNOWN_TYPE),\n                UNKNOWN_TYPE),\n            NO_OBJECT_TYPE, null, true, true) {\n          private static final long serialVersionUID = 1L;\n\n          @Override public FunctionType getConstructor() {\n            return registry.getNativeFunctionType(\n                JSTypeNative.FUNCTION_FUNCTION_TYPE);\n          }\n        };\n\n    // The U2U_CONSTRUCTOR is weird, because it's the supertype of its\n    // own constructor.\n    registerNativeType(JSTypeNative.U2U_CONSTRUCTOR_TYPE, U2U_CONSTRUCTOR_TYPE);\n    registerNativeType(\n        JSTypeNative.FUNCTION_INSTANCE_TYPE, U2U_CONSTRUCTOR_TYPE);\n\n    FUNCTION_FUNCTION_TYPE.setInstanceType(U2U_CONSTRUCTOR_TYPE);\n    U2U_CONSTRUCTOR_TYPE.setImplicitPrototype(FUNCTION_PROTOTYPE);\n\n    // least function type, i.e. (All...) -> NoType\n    FunctionType LEAST_FUNCTION_TYPE =\n        createFunctionType(NO_TYPE, true, ALL_TYPE);\n    registerNativeType(JSTypeNative.LEAST_FUNCTION_TYPE, LEAST_FUNCTION_TYPE);\n\n    // the 'this' object in the global scope\n    FunctionType GLOBAL_THIS_CTOR =\n        new FunctionType(this, \"global this\", null,\n            createArrowType(createParameters(false, ALL_TYPE), NUMBER_TYPE),\n            null, null, true, true);\n    ObjectType GLOBAL_THIS = GLOBAL_THIS_CTOR.getInstanceType();\n    registerNativeType(JSTypeNative.GLOBAL_THIS, GLOBAL_THIS);\n\n    // greatest function type, i.e. (NoType...) -> All\n    FunctionType GREATEST_FUNCTION_TYPE =\n      createFunctionType(ALL_TYPE, true, NO_TYPE);\n    registerNativeType(JSTypeNative.GREATEST_FUNCTION_TYPE,\n        GREATEST_FUNCTION_TYPE);\n\n    // Register the prototype property. See the comments below in\n    // registerPropertyOnType about the bootstrapping process.\n    registerPropertyOnType(\"prototype\", OBJECT_FUNCTION_TYPE);\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "JSTypeRegistry.initializeRegistry",
    "class_name": "com.google.javascript.rhino.jstype.JSTypeRegistry",
    "signature": "com.google.javascript.rhino.jstype.JSTypeRegistry.initializeRegistry()",
    "snippet": "  private void initializeRegistry() {\n    register(getNativeType(JSTypeNative.ARRAY_TYPE));\n    register(getNativeType(JSTypeNative.BOOLEAN_OBJECT_TYPE));\n    register(getNativeType(JSTypeNative.BOOLEAN_TYPE));\n    register(getNativeType(JSTypeNative.DATE_TYPE));\n    register(getNativeType(JSTypeNative.NULL_TYPE));\n    register(getNativeType(JSTypeNative.NULL_TYPE), \"Null\");\n    register(getNativeType(JSTypeNative.NUMBER_OBJECT_TYPE));\n    register(getNativeType(JSTypeNative.NUMBER_TYPE));\n    register(getNativeType(JSTypeNative.OBJECT_TYPE));\n    register(getNativeType(JSTypeNative.ERROR_TYPE));\n    register(getNativeType(JSTypeNative.URI_ERROR_TYPE));\n    register(getNativeType(JSTypeNative.EVAL_ERROR_TYPE));\n    register(getNativeType(JSTypeNative.TYPE_ERROR_TYPE));\n    register(getNativeType(JSTypeNative.RANGE_ERROR_TYPE));\n    register(getNativeType(JSTypeNative.REFERENCE_ERROR_TYPE));\n    register(getNativeType(JSTypeNative.SYNTAX_ERROR_TYPE));\n    register(getNativeType(JSTypeNative.REGEXP_TYPE));\n    register(getNativeType(JSTypeNative.STRING_OBJECT_TYPE));\n    register(getNativeType(JSTypeNative.STRING_TYPE));\n    register(getNativeType(JSTypeNative.VOID_TYPE));\n    register(getNativeType(JSTypeNative.VOID_TYPE), \"Undefined\");\n    register(getNativeType(JSTypeNative.VOID_TYPE), \"void\");\n    register(getNativeType(JSTypeNative.FUNCTION_INSTANCE_TYPE), \"Function\");\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "JSTypeRegistry.register",
    "class_name": "com.google.javascript.rhino.jstype.JSTypeRegistry",
    "signature": "com.google.javascript.rhino.jstype.JSTypeRegistry.register(JSType)",
    "snippet": "  private void register(JSType type) {\n    register(type, type.toString());\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "JSTypeRegistry.register",
    "class_name": "com.google.javascript.rhino.jstype.JSTypeRegistry",
    "signature": "com.google.javascript.rhino.jstype.JSTypeRegistry.register(JSType,String)",
    "snippet": "  private void register(JSType type, String name) {\n    namesToTypes.put(name, type);\n\n    // Add all the namespaces in which this name lives.\n    while (name.indexOf('.') > 0) {\n      name = name.substring(0, name.lastIndexOf('.'));\n      namespaces.add(name);\n    }\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "JSTypeRegistry.registerNativeType",
    "class_name": "com.google.javascript.rhino.jstype.JSTypeRegistry",
    "signature": "com.google.javascript.rhino.jstype.JSTypeRegistry.registerNativeType(JSTypeNative,JSType)",
    "snippet": "  private void registerNativeType(JSTypeNative typeId, JSType type) {\n    nativeTypes[typeId.ordinal()] = type;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "JSTypeRegistry.registerPropertyOnType",
    "class_name": "com.google.javascript.rhino.jstype.JSTypeRegistry",
    "signature": "com.google.javascript.rhino.jstype.JSTypeRegistry.registerPropertyOnType(String,JSType)",
    "snippet": "  public void registerPropertyOnType(String propertyName, JSType type) {\n    UnionTypeBuilder typeSet = typesIndexedByProperty.get(propertyName);\n    if (typeSet == null) {\n      typeSet = new UnionTypeBuilder(this);\n      typesIndexedByProperty.put(propertyName, typeSet);\n    }\n\n    typeSet.addAlternate(type);\n    addReferenceTypeIndexedByProperty(propertyName, type);\n\n    // Clear cached values that depend on typesIndexedByProperty.\n    greatestSubtypeByProperty.remove(propertyName);\n  }",
    "comment": " Tells the type system that {@code owner} may have a property named {@code propertyName}. This allows the registry to keep track of what types a property is defined upon.  This is NOT the same as saying that {@code owner} must have a property named type. ObjectType#hasProperty attempts to minimize false positives (\"if we're not sure, then don't type check this property\"). The type registry, on the other hand, should attempt to minimize false negatives (\"if this property is assigned anywhere in the program, it must show up in the type registry\"). ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "JSTypeRegistry.resetForTypeCheck",
    "class_name": "com.google.javascript.rhino.jstype.JSTypeRegistry",
    "signature": "com.google.javascript.rhino.jstype.JSTypeRegistry.resetForTypeCheck()",
    "snippet": "  public void resetForTypeCheck() {\n    typesIndexedByProperty.clear();\n    eachRefTypeIndexedByProperty.clear();\n    initializeBuiltInTypes();\n    namesToTypes.clear();\n    namespaces.clear();\n    initializeRegistry();\n  }",
    "comment": " Reset to run the TypeCheck pass. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "NoObjectType.NoObjectType",
    "class_name": "com.google.javascript.rhino.jstype.NoObjectType",
    "signature": "com.google.javascript.rhino.jstype.NoObjectType.NoObjectType(JSTypeRegistry)",
    "snippet": "  NoObjectType(JSTypeRegistry registry) {\n    super(registry, null, null,\n          registry.createArrowType(null, null),\n          null, null, true, true);\n    getInternalArrowType().returnType = this;\n    this.setInstanceType(this);\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "NoResolvedType.NoResolvedType",
    "class_name": "com.google.javascript.rhino.jstype.NoResolvedType",
    "signature": "com.google.javascript.rhino.jstype.NoResolvedType.NoResolvedType(JSTypeRegistry)",
    "snippet": "  NoResolvedType(JSTypeRegistry registry) {\n    super(registry);\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "NoType.NoType",
    "class_name": "com.google.javascript.rhino.jstype.NoType",
    "signature": "com.google.javascript.rhino.jstype.NoType.NoType(JSTypeRegistry)",
    "snippet": "  NoType(JSTypeRegistry registry) {\n    super(registry);\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "NoType.isNoType",
    "class_name": "com.google.javascript.rhino.jstype.NoType",
    "signature": "com.google.javascript.rhino.jstype.NoType.isNoType()",
    "snippet": "  @Override\n  public boolean isNoType() {\n    return true;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "NullType.NullType",
    "class_name": "com.google.javascript.rhino.jstype.NullType",
    "signature": "com.google.javascript.rhino.jstype.NullType.NullType(JSTypeRegistry)",
    "snippet": "  NullType(JSTypeRegistry registry) {\n    super(registry);\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "NullType.getDisplayName",
    "class_name": "com.google.javascript.rhino.jstype.NullType",
    "signature": "com.google.javascript.rhino.jstype.NullType.getDisplayName()",
    "snippet": "  @Override\n  public String getDisplayName() {\n    return \"null\";\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "NullType.toString",
    "class_name": "com.google.javascript.rhino.jstype.NullType",
    "signature": "com.google.javascript.rhino.jstype.NullType.toString()",
    "snippet": "  @Override\n  public String toString() {\n    return getDisplayName();\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "NumberType.NumberType",
    "class_name": "com.google.javascript.rhino.jstype.NumberType",
    "signature": "com.google.javascript.rhino.jstype.NumberType.NumberType(JSTypeRegistry)",
    "snippet": "  NumberType(JSTypeRegistry registry) {\n    super(registry);\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "NumberType.getDisplayName",
    "class_name": "com.google.javascript.rhino.jstype.NumberType",
    "signature": "com.google.javascript.rhino.jstype.NumberType.getDisplayName()",
    "snippet": "  @Override\n  public String getDisplayName() {\n    return \"number\";\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "NumberType.toString",
    "class_name": "com.google.javascript.rhino.jstype.NumberType",
    "signature": "com.google.javascript.rhino.jstype.NumberType.toString()",
    "snippet": "  @Override\n  public String toString() {\n    return getDisplayName();\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "ObjectType.ObjectType",
    "class_name": "com.google.javascript.rhino.jstype.ObjectType",
    "signature": "com.google.javascript.rhino.jstype.ObjectType.ObjectType(JSTypeRegistry)",
    "snippet": "  ObjectType(JSTypeRegistry registry) {\n    super(registry);\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "ObjectType.cast",
    "class_name": "com.google.javascript.rhino.jstype.ObjectType",
    "signature": "com.google.javascript.rhino.jstype.ObjectType.cast(JSType)",
    "snippet": "  public static ObjectType cast(JSType type) {\n    return type == null ? null : type.toObjectType();\n  }",
    "comment": " A null-safe version of JSType#toObjectType. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "ObjectType.clearCachedValues",
    "class_name": "com.google.javascript.rhino.jstype.ObjectType",
    "signature": "com.google.javascript.rhino.jstype.ObjectType.clearCachedValues()",
    "snippet": "  public void clearCachedValues() {\n    unknown = true;\n  }",
    "comment": " Clear cached values. Should be called before making changes to a prototype that may have been changed since creation. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "ObjectType.createDelegateSuffix",
    "class_name": "com.google.javascript.rhino.jstype.ObjectType",
    "signature": "com.google.javascript.rhino.jstype.ObjectType.createDelegateSuffix(String)",
    "snippet": "  public static String createDelegateSuffix(String suffix) {\n    return \"(\" + suffix + \")\";\n  }",
    "comment": " Creates a suffix for a proxy delegate. @see #getNormalizedReferenceName ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "ObjectType.defineDeclaredProperty",
    "class_name": "com.google.javascript.rhino.jstype.ObjectType",
    "signature": "com.google.javascript.rhino.jstype.ObjectType.defineDeclaredProperty(String,JSType,boolean,Node)",
    "snippet": "  public final boolean defineDeclaredProperty(String propertyName,\n      JSType type, boolean inExterns, Node propertyNode) {\n    boolean result = defineProperty(propertyName, type, false, inExterns,\n        propertyNode);\n\n    // All property definitions go through this method\n    // or defineDeclaredProperty. Because the properties defined an an\n    // object can affect subtyping, it's slightly more efficient\n    // to register this after defining the property.\n    registry.registerPropertyOnType(propertyName, this);\n\n    return result;\n  }",
    "comment": " Defines a property whose type is synthesized (i.e. not inferred). @param propertyName the property's name @param type the type @param inExterns {@code true} if this property was defined in an externs file. TightenTypes assumes that any function passed to an externs property could be called, so setting this incorrectly could result in live code being removed. @param propertyNode the node corresponding to the declaration of property which might later be accessed using {@code getPropertyNode}. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "ObjectType.hasCachedValues",
    "class_name": "com.google.javascript.rhino.jstype.ObjectType",
    "signature": "com.google.javascript.rhino.jstype.ObjectType.hasCachedValues()",
    "snippet": "  public boolean hasCachedValues() {\n    return !unknown;\n  }",
    "comment": " Returns true if any cached valeus have been set for this type.  If true, then the prototype chain should not be changed, as it might invalidate the cached values. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "ObjectType.hasOwnDeclaredProperty",
    "class_name": "com.google.javascript.rhino.jstype.ObjectType",
    "signature": "com.google.javascript.rhino.jstype.ObjectType.hasOwnDeclaredProperty(String)",
    "snippet": "  boolean hasOwnDeclaredProperty(String name) {\n    return hasOwnProperty(name) && isPropertyTypeDeclared(name);\n  }",
    "comment": " Whether the given property is declared on this object. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "ObjectType.isImplicitPrototype",
    "class_name": "com.google.javascript.rhino.jstype.ObjectType",
    "signature": "com.google.javascript.rhino.jstype.ObjectType.isImplicitPrototype(ObjectType)",
    "snippet": "  final boolean isImplicitPrototype(ObjectType prototype) {\n    for (ObjectType current = this;\n         current != null;\n         current = current.getImplicitPrototype()) {\n      if (current.isEquivalentTo(prototype)) {\n        return true;\n      }\n    }\n    return false;\n  }",
    "comment": " Checks that the prototype is an implicit prototype of this object. Since each object has an implicit prototype, an implicit prototype's implicit prototype is also this implicit prototype's.  @param prototype any prototype based object  @return {@code true} if {@code prototype} is {@code equal} to any object in this object's implicit prototype chain. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "ObjectType.isUnknownType",
    "class_name": "com.google.javascript.rhino.jstype.ObjectType",
    "signature": "com.google.javascript.rhino.jstype.ObjectType.isUnknownType()",
    "snippet": "  @Override\n  public boolean isUnknownType() {\n    // If the object is unknown now, check the supertype again,\n    // because it might have been resolved since the last check.\n    if (unknown) {\n      ObjectType implicitProto = getImplicitPrototype();\n      if (implicitProto == null ||\n          implicitProto.isNativeObjectType()) {\n        unknown = false;\n      } else {\n        unknown = implicitProto.isUnknownType();\n      }\n    }\n    return unknown;\n  }",
    "comment": " We treat this as the unknown type if any of its implicit prototype properties is unknown. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "PrototypeObjectType.PrototypeObjectType",
    "class_name": "com.google.javascript.rhino.jstype.PrototypeObjectType",
    "signature": "com.google.javascript.rhino.jstype.PrototypeObjectType.PrototypeObjectType(JSTypeRegistry,String,ObjectType,boolean)",
    "snippet": "  PrototypeObjectType(JSTypeRegistry registry, String className,\n      ObjectType implicitPrototype, boolean nativeType) {\n    super(registry);\n    this.properties = Maps.newTreeMap();\n    this.className = className;\n    this.nativeType = nativeType;\n    if (nativeType || implicitPrototype != null) {\n      setImplicitPrototype(implicitPrototype);\n    } else {\n      setImplicitPrototype(\n          registry.getNativeObjectType(JSTypeNative.OBJECT_TYPE));\n    }\n  }",
    "comment": " Creates an object type, allowing specification of the implicit prototype when creating native objects. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "PrototypeObjectType.defineProperty",
    "class_name": "com.google.javascript.rhino.jstype.PrototypeObjectType",
    "signature": "com.google.javascript.rhino.jstype.PrototypeObjectType.defineProperty(String,JSType,boolean,boolean,Node)",
    "snippet": "  @Override\n  boolean defineProperty(String name, JSType type, boolean inferred,\n      boolean inExterns, Node propertyNode) {\n    if (hasOwnDeclaredProperty(name)) {\n      return false;\n    }\n    properties.put(name, new Property(type, inferred, inExterns, propertyNode));\n    return true;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "PrototypeObjectType.getConstructor",
    "class_name": "com.google.javascript.rhino.jstype.PrototypeObjectType",
    "signature": "com.google.javascript.rhino.jstype.PrototypeObjectType.getConstructor()",
    "snippet": "  @Override\n  public FunctionType getConstructor() {\n    return null;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "PrototypeObjectType.getImplicitPrototype",
    "class_name": "com.google.javascript.rhino.jstype.PrototypeObjectType",
    "signature": "com.google.javascript.rhino.jstype.PrototypeObjectType.getImplicitPrototype()",
    "snippet": "  @Override\n  public ObjectType getImplicitPrototype() {\n    return implicitPrototypeFallback;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "PrototypeObjectType.getReferenceName",
    "class_name": "com.google.javascript.rhino.jstype.PrototypeObjectType",
    "signature": "com.google.javascript.rhino.jstype.PrototypeObjectType.getReferenceName()",
    "snippet": "  @Override\n  public String getReferenceName() {\n    if (className != null) {\n      return className;\n    } else {\n      return null;\n    }\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "PrototypeObjectType.hasCachedValues",
    "class_name": "com.google.javascript.rhino.jstype.PrototypeObjectType",
    "signature": "com.google.javascript.rhino.jstype.PrototypeObjectType.hasCachedValues()",
    "snippet": "  @Override\n  public boolean hasCachedValues() {\n    return super.hasCachedValues();\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "PrototypeObjectType.hasOwnProperty",
    "class_name": "com.google.javascript.rhino.jstype.PrototypeObjectType",
    "signature": "com.google.javascript.rhino.jstype.PrototypeObjectType.hasOwnProperty(String)",
    "snippet": "  @Override\n  public boolean hasOwnProperty(String propertyName) {\n    return properties.get(propertyName) != null;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "PrototypeObjectType.hasReferenceName",
    "class_name": "com.google.javascript.rhino.jstype.PrototypeObjectType",
    "signature": "com.google.javascript.rhino.jstype.PrototypeObjectType.hasReferenceName()",
    "snippet": "  @Override\n  public boolean hasReferenceName() {\n    return className != null;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "PrototypeObjectType.implicitPrototypeChainIsUnknown",
    "class_name": "com.google.javascript.rhino.jstype.PrototypeObjectType",
    "signature": "com.google.javascript.rhino.jstype.PrototypeObjectType.implicitPrototypeChainIsUnknown()",
    "snippet": "  private boolean implicitPrototypeChainIsUnknown() {\n    ObjectType p = getImplicitPrototype();\n    while (p != null) {\n      if (p.isUnknownType()) {\n        return true;\n      }\n      p = p.getImplicitPrototype();\n    }\n    return false;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "PrototypeObjectType.isNativeObjectType",
    "class_name": "com.google.javascript.rhino.jstype.PrototypeObjectType",
    "signature": "com.google.javascript.rhino.jstype.PrototypeObjectType.isNativeObjectType()",
    "snippet": "  @Override\n  public boolean isNativeObjectType() {\n    return nativeType;\n  }",
    "comment": "Whether this is a built-in object. */",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "PrototypeObjectType.isSubtype",
    "class_name": "com.google.javascript.rhino.jstype.PrototypeObjectType",
    "signature": "com.google.javascript.rhino.jstype.PrototypeObjectType.isSubtype(JSType)",
    "snippet": "  @Override\n  public boolean isSubtype(JSType that) {\n    if (JSType.isSubtype(this, that)) {\n      return true;\n    }\n\n    // Union types\n    if (that instanceof UnionType) {\n      // The static {@code JSType.isSubtype} check already decomposed\n      // union types, so we don't need to check those again.\n      return false;\n    }\n\n    // record types\n    if (that instanceof RecordType) {\n      return RecordType.isSubtype(this, (RecordType) that);\n    }\n\n    // Interfaces\n    // Find all the interfaces implemented by this class and compare each one\n    // to the interface instance.\n    ObjectType thatObj = that.toObjectType();\n    ObjectType thatCtor = thatObj == null ? null : thatObj.getConstructor();\n    if (thatCtor != null && thatCtor.isInterface()) {\n      Iterable<ObjectType> thisInterfaces = getCtorImplementedInterfaces();\n      for (ObjectType thisInterface : thisInterfaces) {\n        if (thisInterface.isSubtype(that)) {\n          return true;\n        }\n      }\n    }\n\n    // other prototype based objects\n    if (that != null) {\n      if (isUnknownType() || implicitPrototypeChainIsUnknown()) {\n        // If unsure, say 'yes', to avoid spurious warnings.\n        // TODO(user): resolve the prototype chain completely in all cases,\n        // to avoid guessing.\n        return true;\n      }\n      return this.isImplicitPrototype(thatObj);\n    }\n\n    return false;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "PrototypeObjectType.setImplicitPrototype",
    "class_name": "com.google.javascript.rhino.jstype.PrototypeObjectType",
    "signature": "com.google.javascript.rhino.jstype.PrototypeObjectType.setImplicitPrototype(ObjectType)",
    "snippet": "  final void setImplicitPrototype(ObjectType implicitPrototype) {\n    checkState(!hasCachedValues());\n    this.implicitPrototypeFallback = implicitPrototype;\n  }",
    "comment": " This should only be reset on the FunctionPrototypeType, only to fix an incorrectly established prototype chain due to the user having a mismatch in super class declaration, and only before properties on that type are processed. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "StringType.StringType",
    "class_name": "com.google.javascript.rhino.jstype.StringType",
    "signature": "com.google.javascript.rhino.jstype.StringType.StringType(JSTypeRegistry)",
    "snippet": "  StringType(JSTypeRegistry registry) {\n    super(registry);\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "StringType.getDisplayName",
    "class_name": "com.google.javascript.rhino.jstype.StringType",
    "signature": "com.google.javascript.rhino.jstype.StringType.getDisplayName()",
    "snippet": "  @Override\n  public String getDisplayName() {\n    return \"string\";\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "StringType.toString",
    "class_name": "com.google.javascript.rhino.jstype.StringType",
    "signature": "com.google.javascript.rhino.jstype.StringType.toString()",
    "snippet": "  @Override\n  public String toString() {\n    return getDisplayName();\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "UnionType.UnionType",
    "class_name": "com.google.javascript.rhino.jstype.UnionType",
    "signature": "com.google.javascript.rhino.jstype.UnionType.UnionType(JSTypeRegistry,Collection)",
    "snippet": "  UnionType(JSTypeRegistry registry, Collection<JSType> alternates) {\n    super(registry);\n    this.alternates = alternates;\n    this.hashcode = this.alternates.hashCode();\n  }",
    "comment": " Creates a union type.  @param alternates the alternates of the union ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "UnionTypeBuilder.UnionTypeBuilder",
    "class_name": "com.google.javascript.rhino.jstype.UnionTypeBuilder",
    "signature": "com.google.javascript.rhino.jstype.UnionTypeBuilder.UnionTypeBuilder(JSTypeRegistry)",
    "snippet": "  UnionTypeBuilder(JSTypeRegistry registry) {\n    this.registry = registry;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "UnionTypeBuilder.addAlternate",
    "class_name": "com.google.javascript.rhino.jstype.UnionTypeBuilder",
    "signature": "com.google.javascript.rhino.jstype.UnionTypeBuilder.addAlternate(JSType)",
    "snippet": "  UnionTypeBuilder addAlternate(JSType alternate) {\n    // build() returns the bottom type by default, so we can\n    // just bail out early here.\n    if (alternate.isNoType()) {\n      return this;\n    }\n\n    isAllType = isAllType || alternate.isAllType();\n\n    boolean isAlternateUnknown = alternate instanceof UnknownType;\n    isNativeUnknownType = isNativeUnknownType || isAlternateUnknown;\n    if (isAlternateUnknown) {\n      areAllUnknownsChecked = areAllUnknownsChecked &&\n          alternate.isCheckedUnknownType();\n    }\n    if (!isAllType && !isNativeUnknownType) {\n      if (alternate instanceof UnionType) {\n        UnionType union = (UnionType) alternate;\n        for (JSType unionAlt : union.getAlternates()) {\n          addAlternate(unionAlt);\n        }\n      } else {\n        if (alternates.size() > MAX_UNION_SIZE) {\n          return this;\n        }\n\n        // Look through the alternates we've got so far,\n        // and check if any of them are duplicates of\n        // one another.\n        Iterator<JSType> it = alternates.iterator();\n        while (it.hasNext()) {\n          JSType current = it.next();\n\n          // Unknown and NoResolved types may just be names that haven't\n          // been resolved yet. So keep these in the union, and just use\n          // equality checking for simple de-duping.\n          if (alternate.isUnknownType() ||\n              current.isUnknownType() ||\n              alternate.isNoResolvedType() ||\n              current.isNoResolvedType()) {\n            if (alternate.isEquivalentTo(current)) {\n              // Alternate is unnecessary.\n              return this;\n            }\n          } else {\n            if (alternate.isSubtype(current)) {\n              // Alternate is unnecessary.\n              return this;\n            } else if (current.isSubtype(alternate)) {\n              // Alternate makes current obsolete\n              it.remove();\n            }\n          }\n        }\n        alternates.add(alternate);\n        result = null; // invalidate the memoized result\n      }\n    } else {\n      result = null;\n    }\n    return this;\n  }",
    "comment": " Adds an alternate to the union type under construction. Returns this for easy chaining. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "UnionTypeBuilder.build",
    "class_name": "com.google.javascript.rhino.jstype.UnionTypeBuilder",
    "signature": "com.google.javascript.rhino.jstype.UnionTypeBuilder.build()",
    "snippet": "  JSType build() {\n    if (result == null) {\n      result = reduceAlternatesWithoutUnion();\n      if (result == null) {\n        result = new UnionType(registry, getAlternateListCopy());\n      }\n    }\n    return result;\n  }",
    "comment": " Creates a union. @return A UnionType if it has two or more alternates, the only alternate if it has one and otherwise {@code NO_TYPE}. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "UnionTypeBuilder.getAlternateListCopy",
    "class_name": "com.google.javascript.rhino.jstype.UnionTypeBuilder",
    "signature": "com.google.javascript.rhino.jstype.UnionTypeBuilder.getAlternateListCopy()",
    "snippet": "  private Collection<JSType> getAlternateListCopy() {\n    // TODO(nicksantos): Until we're at a place where we're no longer\n    // using java's built-in equals to test type equivalence, we need\n    // hash codes to be the same. So the alternates need to be sorted.\n    Collections.sort(alternates, typeSorter);\n\n    return ImmutableList.copyOf(alternates);\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "UnionTypeBuilder.reduceAlternatesWithoutUnion",
    "class_name": "com.google.javascript.rhino.jstype.UnionTypeBuilder",
    "signature": "com.google.javascript.rhino.jstype.UnionTypeBuilder.reduceAlternatesWithoutUnion()",
    "snippet": "  private JSType reduceAlternatesWithoutUnion() {\n    if (isAllType) {\n      return registry.getNativeType(ALL_TYPE);\n    } else if (isNativeUnknownType) {\n      if (areAllUnknownsChecked) {\n        return registry.getNativeType(CHECKED_UNKNOWN_TYPE);\n      } else {\n        return registry.getNativeType(UNKNOWN_TYPE);\n      }\n    } else {\n      int size = alternates.size();\n      if (size > MAX_UNION_SIZE) {\n        return registry.getNativeType(UNKNOWN_TYPE);\n      } else if (size > 1) {\n        return null;\n      } else if (size == 1) {\n        return alternates.iterator().next();\n      } else {\n        return registry.getNativeType(NO_TYPE);\n      }\n    }\n  }",
    "comment": " Reduce the alternates into a non-union type. If the alternates can't be accurately represented with a non-union type, return null. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "UnknownType.UnknownType",
    "class_name": "com.google.javascript.rhino.jstype.UnknownType",
    "signature": "com.google.javascript.rhino.jstype.UnknownType.UnknownType(JSTypeRegistry,boolean)",
    "snippet": "  UnknownType(JSTypeRegistry registry, boolean isChecked) {\n    super(registry);\n    this.isChecked = isChecked;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "ValueType.ValueType",
    "class_name": "com.google.javascript.rhino.jstype.ValueType",
    "signature": "com.google.javascript.rhino.jstype.ValueType.ValueType(JSTypeRegistry)",
    "snippet": "  ValueType(JSTypeRegistry registry) {\n    super(registry);\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "ValueType.isSubtype",
    "class_name": "com.google.javascript.rhino.jstype.ValueType",
    "signature": "com.google.javascript.rhino.jstype.ValueType.isSubtype(JSType)",
    "snippet": "  @Override\n  public boolean isSubtype(JSType that) {\n    return JSType.isSubtype(this, that);\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "VoidType.VoidType",
    "class_name": "com.google.javascript.rhino.jstype.VoidType",
    "signature": "com.google.javascript.rhino.jstype.VoidType.VoidType(JSTypeRegistry)",
    "snippet": "  VoidType(JSTypeRegistry registry) {\n    super(registry);\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "VoidType.getDisplayName",
    "class_name": "com.google.javascript.rhino.jstype.VoidType",
    "signature": "com.google.javascript.rhino.jstype.VoidType.getDisplayName()",
    "snippet": "  @Override\n  public String getDisplayName() {\n    return \"undefined\";\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  },
  {
    "name": "VoidType.toString",
    "class_name": "com.google.javascript.rhino.jstype.VoidType",
    "signature": "com.google.javascript.rhino.jstype.VoidType.toString()",
    "snippet": "  @Override\n  public String toString() {\n    return getDisplayName();\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 2
  }
]