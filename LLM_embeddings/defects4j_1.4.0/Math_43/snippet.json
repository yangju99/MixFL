[
  {
    "name": "AbstractStorelessUnivariateStatistic.evaluate",
    "class_name": "org.apache.commons.math.stat.descriptive.AbstractStorelessUnivariateStatistic",
    "signature": "org.apache.commons.math.stat.descriptive.AbstractStorelessUnivariateStatistic.evaluate(double[])",
    "snippet": "    @Override\n    public double evaluate(final double[] values) {\n        if (values == null) {\n            throw new NullArgumentException(LocalizedFormats.INPUT_ARRAY);\n        }\n        return evaluate(values, 0, values.length);\n    }",
    "comment": " This default implementation calls {@link #clear}, then invokes {@link #increment} in a loop over the the input array, and then uses {@link #getResult} to compute the return value. <p> Note that this implementation changes the internal state of the statistic.  Its side effects are the same as invoking {@link #clear} and then {@link #incrementAll(double[])}.</p> <p> Implementations may override this method with a more efficient and possibly more accurate implementation that works directly with the input array.</p> <p> If the array is null, an IllegalArgumentException is thrown.</p> @param values input array @return the value of the statistic applied to the input array @see org.apache.commons.math.stat.descriptive.UnivariateStatistic#evaluate(double[]) ",
    "is_bug": false,
    "failing_test_cases": 6,
    "buggy_methods": 1
  },
  {
    "name": "AbstractUnivariateStatistic.test",
    "class_name": "org.apache.commons.math.stat.descriptive.AbstractUnivariateStatistic",
    "signature": "org.apache.commons.math.stat.descriptive.AbstractUnivariateStatistic.test(double[],int,int)",
    "snippet": "    protected boolean test(\n        final double[] values,\n        final int begin,\n        final int length) {\n        return test(values, begin, length, false);\n    }",
    "comment": " This method is used by <code>evaluate(double[], int, int)</code> methods to verify that the input parameters designate a subarray of positive length. <p> <ul> <li>returns <code>true</code> iff the parameters designate a subarray of positive length</li> <li>throws <code>IllegalArgumentException</code> if the array is null or or the indices are invalid</li> <li>returns <code>false</li> if the array is non-null, but <code>length</code> is 0. </ul></p>  @param values the input array @param begin index of the first array element to include @param length the number of elements to include @return true if the parameters are valid and designate a subarray of positive length @throws IllegalArgumentException if the indices are invalid or the array is null ",
    "is_bug": false,
    "failing_test_cases": 6,
    "buggy_methods": 1
  },
  {
    "name": "AbstractUnivariateStatistic.test",
    "class_name": "org.apache.commons.math.stat.descriptive.AbstractUnivariateStatistic",
    "signature": "org.apache.commons.math.stat.descriptive.AbstractUnivariateStatistic.test(double[],int,int,boolean)",
    "snippet": "    protected boolean test(final double[] values, final int begin, final int length, final boolean allowEmpty){\n\n        if (values == null) {\n            throw new NullArgumentException(LocalizedFormats.INPUT_ARRAY);\n        }\n\n        if (begin < 0) {\n            throw new NotPositiveException(LocalizedFormats.START_POSITION, begin);\n        }\n\n        if (length < 0) {\n            throw new NotPositiveException(LocalizedFormats.LENGTH, length);\n        }\n\n        if (begin + length > values.length) {\n            throw new NumberIsTooLargeException(LocalizedFormats.SUBARRAY_ENDS_AFTER_ARRAY_END,\n                                                begin + length, values.length, true);\n        }\n\n        if (length == 0 && !allowEmpty) {\n            return false;\n        }\n\n        return true;\n\n    }",
    "comment": " This method is used by <code>evaluate(double[], int, int)</code> methods to verify that the input parameters designate a subarray of positive length. <p> <ul> <li>returns <code>true</code> iff the parameters designate a subarray of non-negative length</li> <li>throws <code>IllegalArgumentException</code> if the array is null or or the indices are invalid</li> <li>returns <code>false</li> if the array is non-null, but <code>length</code> is 0 unless <code>allowEmpty</code> is <code>true</code> </ul></p>  @param values the input array @param begin index of the first array element to include @param length the number of elements to include @param allowEmpty if <code>true</code> then zero length arrays are allowed @return true if the parameters are valid @throws IllegalArgumentException if the indices are invalid or the array is null @since 3.0 ",
    "is_bug": false,
    "failing_test_cases": 6,
    "buggy_methods": 1
  },
  {
    "name": "SummaryStatistics.SummaryStatistics",
    "class_name": "org.apache.commons.math.stat.descriptive.SummaryStatistics",
    "signature": "org.apache.commons.math.stat.descriptive.SummaryStatistics.SummaryStatistics()",
    "snippet": "    public SummaryStatistics() {\n    }",
    "comment": " Construct a SummaryStatistics instance ",
    "is_bug": false,
    "failing_test_cases": 6,
    "buggy_methods": 1
  },
  {
    "name": "SummaryStatistics.addValue",
    "class_name": "org.apache.commons.math.stat.descriptive.SummaryStatistics",
    "signature": "org.apache.commons.math.stat.descriptive.SummaryStatistics.addValue(double)",
    "snippet": "    public void addValue(double value) {\n        sumImpl.increment(value);\n        sumsqImpl.increment(value);\n        minImpl.increment(value);\n        maxImpl.increment(value);\n        sumLogImpl.increment(value);\n        secondMoment.increment(value);\n        // If mean, variance or geomean have been overridden,\n        // need to increment these\n        if (!(meanImpl instanceof Mean)) {\n            meanImpl.increment(value);\n        }\n        if (!(varianceImpl instanceof Variance)) {\n            varianceImpl.increment(value);\n        }\n        if (!(geoMeanImpl instanceof GeometricMean)) {\n            geoMeanImpl.increment(value);\n        }\n        n++;\n    }",
    "comment": " Add a value to the data @param value the value to add ",
    "is_bug": true,
    "failing_test_cases": 6,
    "buggy_methods": 1
  },
  {
    "name": "SummaryStatistics.checkEmpty",
    "class_name": "org.apache.commons.math.stat.descriptive.SummaryStatistics",
    "signature": "org.apache.commons.math.stat.descriptive.SummaryStatistics.checkEmpty()",
    "snippet": "    private void checkEmpty() {\n        if (n > 0) {\n            throw new MathIllegalStateException(\n                LocalizedFormats.VALUES_ADDED_BEFORE_CONFIGURING_STATISTIC, n);\n        }\n    }",
    "comment": " Throws IllegalStateException if n > 0. ",
    "is_bug": false,
    "failing_test_cases": 6,
    "buggy_methods": 1
  },
  {
    "name": "SummaryStatistics.getGeometricMean",
    "class_name": "org.apache.commons.math.stat.descriptive.SummaryStatistics",
    "signature": "org.apache.commons.math.stat.descriptive.SummaryStatistics.getGeometricMean()",
    "snippet": "    public double getGeometricMean() {\n        return geoMeanImpl.getResult();\n    }",
    "comment": " Returns the geometric mean of the values that have been added. <p> Double.NaN is returned if no values have been added. </p> @return the geometric mean ",
    "is_bug": false,
    "failing_test_cases": 6,
    "buggy_methods": 1
  },
  {
    "name": "SummaryStatistics.getMean",
    "class_name": "org.apache.commons.math.stat.descriptive.SummaryStatistics",
    "signature": "org.apache.commons.math.stat.descriptive.SummaryStatistics.getMean()",
    "snippet": "    public double getMean() {\n        return meanImpl.getResult();\n    }",
    "comment": " Returns the mean of the values that have been added. <p> Double.NaN is returned if no values have been added. </p> @return the mean ",
    "is_bug": false,
    "failing_test_cases": 6,
    "buggy_methods": 1
  },
  {
    "name": "SummaryStatistics.getVariance",
    "class_name": "org.apache.commons.math.stat.descriptive.SummaryStatistics",
    "signature": "org.apache.commons.math.stat.descriptive.SummaryStatistics.getVariance()",
    "snippet": "    public double getVariance() {\n        return varianceImpl.getResult();\n    }",
    "comment": " Returns the (sample) variance of the available values.  <p>This method returns the bias-corrected sample variance (using {@code n - 1} in the denominator).  Use {@link #getPopulationVariance()} for the non-bias-corrected population variance.</p>  <p>Double.NaN is returned if no values have been added.</p>  @return the variance ",
    "is_bug": false,
    "failing_test_cases": 6,
    "buggy_methods": 1
  },
  {
    "name": "SummaryStatistics.setGeoMeanImpl",
    "class_name": "org.apache.commons.math.stat.descriptive.SummaryStatistics",
    "signature": "org.apache.commons.math.stat.descriptive.SummaryStatistics.setGeoMeanImpl(StorelessUnivariateStatistic)",
    "snippet": "    public void setGeoMeanImpl(StorelessUnivariateStatistic geoMeanImpl) {\n        checkEmpty();\n        this.geoMeanImpl = geoMeanImpl;\n    }",
    "comment": " <p> Sets the implementation for the geometric mean. </p> <p> This method must be activated before any data has been added - i.e., before {@link #addValue(double) addValue} has been used to add data; otherwise an IllegalStateException will be thrown. </p> @param geoMeanImpl the StorelessUnivariateStatistic instance to use for computing the geometric mean @throws IllegalStateException if data has already been added (i.e if n > 0) @since 1.2 ",
    "is_bug": false,
    "failing_test_cases": 6,
    "buggy_methods": 1
  },
  {
    "name": "SummaryStatistics.setMeanImpl",
    "class_name": "org.apache.commons.math.stat.descriptive.SummaryStatistics",
    "signature": "org.apache.commons.math.stat.descriptive.SummaryStatistics.setMeanImpl(StorelessUnivariateStatistic)",
    "snippet": "    public void setMeanImpl(StorelessUnivariateStatistic meanImpl) {\n        checkEmpty();\n        this.meanImpl = meanImpl;\n    }",
    "comment": " <p> Sets the implementation for the mean. </p> <p> This method must be activated before any data has been added - i.e., before {@link #addValue(double) addValue} has been used to add data; otherwise an IllegalStateException will be thrown. </p> @param meanImpl the StorelessUnivariateStatistic instance to use for computing the mean @throws IllegalStateException if data has already been added (i.e if n > 0) @since 1.2 ",
    "is_bug": false,
    "failing_test_cases": 6,
    "buggy_methods": 1
  },
  {
    "name": "SummaryStatistics.setVarianceImpl",
    "class_name": "org.apache.commons.math.stat.descriptive.SummaryStatistics",
    "signature": "org.apache.commons.math.stat.descriptive.SummaryStatistics.setVarianceImpl(StorelessUnivariateStatistic)",
    "snippet": "    public void setVarianceImpl(StorelessUnivariateStatistic varianceImpl) {\n        checkEmpty();\n        this.varianceImpl = varianceImpl;\n    }",
    "comment": " <p> Sets the implementation for the variance. </p> <p> This method must be activated before any data has been added - i.e., before {@link #addValue(double) addValue} has been used to add data; otherwise an IllegalStateException will be thrown. </p> @param varianceImpl the StorelessUnivariateStatistic instance to use for computing the variance @throws IllegalStateException if data has already been added (i.e if n > 0) @since 1.2 ",
    "is_bug": false,
    "failing_test_cases": 6,
    "buggy_methods": 1
  },
  {
    "name": "FirstMoment.FirstMoment",
    "class_name": "org.apache.commons.math.stat.descriptive.moment.FirstMoment",
    "signature": "org.apache.commons.math.stat.descriptive.moment.FirstMoment.FirstMoment()",
    "snippet": "    public FirstMoment() {\n        n = 0;\n        m1 = Double.NaN;\n        dev = Double.NaN;\n        nDev = Double.NaN;\n    }",
    "comment": " Create a FirstMoment instance ",
    "is_bug": false,
    "failing_test_cases": 6,
    "buggy_methods": 1
  },
  {
    "name": "FirstMoment.clear",
    "class_name": "org.apache.commons.math.stat.descriptive.moment.FirstMoment",
    "signature": "org.apache.commons.math.stat.descriptive.moment.FirstMoment.clear()",
    "snippet": "    @Override\n    public void clear() {\n        m1 = Double.NaN;\n        n = 0;\n        dev = Double.NaN;\n        nDev = Double.NaN;\n    }",
    "comment": " {@inheritDoc} ",
    "is_bug": false,
    "failing_test_cases": 6,
    "buggy_methods": 1
  },
  {
    "name": "FirstMoment.increment",
    "class_name": "org.apache.commons.math.stat.descriptive.moment.FirstMoment",
    "signature": "org.apache.commons.math.stat.descriptive.moment.FirstMoment.increment(double)",
    "snippet": "     @Override\n    public void increment(final double d) {\n        if (n == 0) {\n            m1 = 0.0;\n        }\n        n++;\n        double n0 = n;\n        dev = d - m1;\n        nDev = dev / n0;\n        m1 += nDev;\n    }",
    "comment": " {@inheritDoc} ",
    "is_bug": false,
    "failing_test_cases": 6,
    "buggy_methods": 1
  },
  {
    "name": "GeometricMean.GeometricMean",
    "class_name": "org.apache.commons.math.stat.descriptive.moment.GeometricMean",
    "signature": "org.apache.commons.math.stat.descriptive.moment.GeometricMean.GeometricMean()",
    "snippet": "    public GeometricMean() {\n        sumOfLogs = new SumOfLogs();\n    }",
    "comment": " Create a GeometricMean instance ",
    "is_bug": false,
    "failing_test_cases": 6,
    "buggy_methods": 1
  },
  {
    "name": "GeometricMean.GeometricMean",
    "class_name": "org.apache.commons.math.stat.descriptive.moment.GeometricMean",
    "signature": "org.apache.commons.math.stat.descriptive.moment.GeometricMean.GeometricMean(SumOfLogs)",
    "snippet": "    public GeometricMean(SumOfLogs sumOfLogs) {\n        this.sumOfLogs = sumOfLogs;\n    }",
    "comment": " Create a GeometricMean instance using the given SumOfLogs instance @param sumOfLogs sum of logs instance to use for computation ",
    "is_bug": false,
    "failing_test_cases": 6,
    "buggy_methods": 1
  },
  {
    "name": "GeometricMean.evaluate",
    "class_name": "org.apache.commons.math.stat.descriptive.moment.GeometricMean",
    "signature": "org.apache.commons.math.stat.descriptive.moment.GeometricMean.evaluate(double[],int,int)",
    "snippet": "    @Override\n    public double evaluate(\n        final double[] values, final int begin, final int length) {\n        return FastMath.exp(\n            sumOfLogs.evaluate(values, begin, length) / length);\n    }",
    "comment": " Returns the geometric mean of the entries in the specified portion of the input array. <p> See {@link GeometricMean} for details on the computing algorithm.</p> <p> Throws <code>IllegalArgumentException</code> if the array is null.</p>  @param values input array containing the values @param begin first array element to include @param length the number of elements to include @return the geometric mean or Double.NaN if length = 0 or any of the values are &lt;= 0. @throws IllegalArgumentException if the input array is null or the array index parameters are not valid ",
    "is_bug": false,
    "failing_test_cases": 6,
    "buggy_methods": 1
  },
  {
    "name": "GeometricMean.getResult",
    "class_name": "org.apache.commons.math.stat.descriptive.moment.GeometricMean",
    "signature": "org.apache.commons.math.stat.descriptive.moment.GeometricMean.getResult()",
    "snippet": "    @Override\n    public double getResult() {\n        if (sumOfLogs.getN() > 0) {\n            return FastMath.exp(sumOfLogs.getResult() / sumOfLogs.getN());\n        } else {\n            return Double.NaN;\n        }\n    }",
    "comment": " {@inheritDoc} ",
    "is_bug": false,
    "failing_test_cases": 6,
    "buggy_methods": 1
  },
  {
    "name": "Mean.Mean",
    "class_name": "org.apache.commons.math.stat.descriptive.moment.Mean",
    "signature": "org.apache.commons.math.stat.descriptive.moment.Mean.Mean()",
    "snippet": "    public Mean() {\n        incMoment = true;\n        moment = new FirstMoment();\n    }",
    "comment": "Constructs a Mean. */",
    "is_bug": false,
    "failing_test_cases": 6,
    "buggy_methods": 1
  },
  {
    "name": "Mean.Mean",
    "class_name": "org.apache.commons.math.stat.descriptive.moment.Mean",
    "signature": "org.apache.commons.math.stat.descriptive.moment.Mean.Mean(FirstMoment)",
    "snippet": "    public Mean(final FirstMoment m1) {\n        this.moment = m1;\n        incMoment = false;\n    }",
    "comment": " Constructs a Mean with an External Moment.  @param m1 the moment ",
    "is_bug": false,
    "failing_test_cases": 6,
    "buggy_methods": 1
  },
  {
    "name": "Mean.evaluate",
    "class_name": "org.apache.commons.math.stat.descriptive.moment.Mean",
    "signature": "org.apache.commons.math.stat.descriptive.moment.Mean.evaluate(double[],int,int)",
    "snippet": "    @Override\n    public double evaluate(final double[] values,final int begin, final int length) {\n        if (test(values, begin, length)) {\n            Sum sum = new Sum();\n            double sampleSize = length;\n\n            // Compute initial estimate using definitional formula\n            double xbar = sum.evaluate(values, begin, length) / sampleSize;\n\n            // Compute correction factor in second pass\n            double correction = 0;\n            for (int i = begin; i < begin + length; i++) {\n                correction += values[i] - xbar;\n            }\n            return xbar + (correction/sampleSize);\n        }\n        return Double.NaN;\n    }",
    "comment": " Returns the arithmetic mean of the entries in the specified portion of the input array, or <code>Double.NaN</code> if the designated subarray is empty. <p> Throws <code>IllegalArgumentException</code> if the array is null.</p> <p> See {@link Mean} for details on the computing algorithm.</p>  @param values the input array @param begin index of the first array element to include @param length the number of elements to include @return the mean of the values or Double.NaN if length = 0 @throws IllegalArgumentException if the array is null or the array index parameters are not valid ",
    "is_bug": false,
    "failing_test_cases": 6,
    "buggy_methods": 1
  },
  {
    "name": "Mean.getResult",
    "class_name": "org.apache.commons.math.stat.descriptive.moment.Mean",
    "signature": "org.apache.commons.math.stat.descriptive.moment.Mean.getResult()",
    "snippet": "    @Override\n    public double getResult() {\n        return moment.m1;\n    }",
    "comment": " {@inheritDoc} ",
    "is_bug": false,
    "failing_test_cases": 6,
    "buggy_methods": 1
  },
  {
    "name": "SecondMoment.SecondMoment",
    "class_name": "org.apache.commons.math.stat.descriptive.moment.SecondMoment",
    "signature": "org.apache.commons.math.stat.descriptive.moment.SecondMoment.SecondMoment()",
    "snippet": "    public SecondMoment() {\n        super();\n        m2 = Double.NaN;\n    }",
    "comment": " Create a SecondMoment instance ",
    "is_bug": false,
    "failing_test_cases": 6,
    "buggy_methods": 1
  },
  {
    "name": "SecondMoment.clear",
    "class_name": "org.apache.commons.math.stat.descriptive.moment.SecondMoment",
    "signature": "org.apache.commons.math.stat.descriptive.moment.SecondMoment.clear()",
    "snippet": "    @Override\n    public void clear() {\n        super.clear();\n        m2 = Double.NaN;\n    }",
    "comment": " {@inheritDoc} ",
    "is_bug": false,
    "failing_test_cases": 6,
    "buggy_methods": 1
  },
  {
    "name": "SecondMoment.increment",
    "class_name": "org.apache.commons.math.stat.descriptive.moment.SecondMoment",
    "signature": "org.apache.commons.math.stat.descriptive.moment.SecondMoment.increment(double)",
    "snippet": "    @Override\n    public void increment(final double d) {\n        if (n < 1) {\n            m1 = m2 = 0.0;\n        }\n        super.increment(d);\n        m2 += ((double) n - 1) * dev * nDev;\n    }",
    "comment": " {@inheritDoc} ",
    "is_bug": false,
    "failing_test_cases": 6,
    "buggy_methods": 1
  },
  {
    "name": "Variance.Variance",
    "class_name": "org.apache.commons.math.stat.descriptive.moment.Variance",
    "signature": "org.apache.commons.math.stat.descriptive.moment.Variance.Variance(SecondMoment)",
    "snippet": "    public Variance(final SecondMoment m2) {\n        incMoment = false;\n        this.moment = m2;\n    }",
    "comment": " Constructs a Variance based on an external second moment. When this constructor is used, the statistic may only be incremented via the moment, i.e., {@link #increment(double)} does nothing; whereas {@code m2.increment(value)} increments both {@code m2} and the Variance instance constructed from it.  @param m2 the SecondMoment (Third or Fourth moments work here as well.) ",
    "is_bug": false,
    "failing_test_cases": 6,
    "buggy_methods": 1
  },
  {
    "name": "Variance.Variance",
    "class_name": "org.apache.commons.math.stat.descriptive.moment.Variance",
    "signature": "org.apache.commons.math.stat.descriptive.moment.Variance.Variance(boolean)",
    "snippet": "    public Variance(boolean isBiasCorrected) {\n        moment = new SecondMoment();\n        this.isBiasCorrected = isBiasCorrected;\n    }",
    "comment": " Constructs a Variance with the specified <code>isBiasCorrected</code> property  @param isBiasCorrected  setting for bias correction - true means bias will be corrected and is equivalent to using the argumentless constructor ",
    "is_bug": false,
    "failing_test_cases": 6,
    "buggy_methods": 1
  },
  {
    "name": "Variance.clear",
    "class_name": "org.apache.commons.math.stat.descriptive.moment.Variance",
    "signature": "org.apache.commons.math.stat.descriptive.moment.Variance.clear()",
    "snippet": "    @Override\n    public void clear() {\n        if (incMoment) {\n            moment.clear();\n        }\n    }",
    "comment": " {@inheritDoc} ",
    "is_bug": false,
    "failing_test_cases": 6,
    "buggy_methods": 1
  },
  {
    "name": "Variance.evaluate",
    "class_name": "org.apache.commons.math.stat.descriptive.moment.Variance",
    "signature": "org.apache.commons.math.stat.descriptive.moment.Variance.evaluate(double[])",
    "snippet": "    @Override\n    public double evaluate(final double[] values) {\n        if (values == null) {\n            throw new NullArgumentException(LocalizedFormats.INPUT_ARRAY);\n        }\n        return evaluate(values, 0, values.length);\n    }",
    "comment": " Returns the variance of the entries in the input array, or <code>Double.NaN</code> if the array is empty. <p> See {@link Variance} for details on the computing algorithm.</p> <p> Returns 0 for a single-value (i.e. length = 1) sample.</p> <p> Throws <code>IllegalArgumentException</code> if the array is null.</p> <p> Does not change the internal state of the statistic.</p>  @param values the input array @return the variance of the values or Double.NaN if length = 0 @throws IllegalArgumentException if the array is null ",
    "is_bug": false,
    "failing_test_cases": 6,
    "buggy_methods": 1
  },
  {
    "name": "Variance.evaluate",
    "class_name": "org.apache.commons.math.stat.descriptive.moment.Variance",
    "signature": "org.apache.commons.math.stat.descriptive.moment.Variance.evaluate(double[],double,int,int)",
    "snippet": "    public double evaluate(final double[] values, final double mean,\n            final int begin, final int length) {\n\n        double var = Double.NaN;\n\n        if (test(values, begin, length)) {\n            if (length == 1) {\n                var = 0.0;\n            } else if (length > 1) {\n                double accum = 0.0;\n                double dev = 0.0;\n                double accum2 = 0.0;\n                for (int i = begin; i < begin + length; i++) {\n                    dev = values[i] - mean;\n                    accum += dev * dev;\n                    accum2 += dev;\n                }\n                double len = length;\n                if (isBiasCorrected) {\n                    var = (accum - (accum2 * accum2 / len)) / (len - 1.0);\n                } else {\n                    var = (accum - (accum2 * accum2 / len)) / len;\n                }\n            }\n        }\n        return var;\n    }",
    "comment": " Returns the variance of the entries in the specified portion of the input array, using the precomputed mean value.  Returns <code>Double.NaN</code> if the designated subarray is empty. <p> See {@link Variance} for details on the computing algorithm.</p> <p> The formula used assumes that the supplied mean value is the arithmetic mean of the sample data, not a known population parameter.  This method is supplied only to save computation when the mean has already been computed.</p> <p> Returns 0 for a single-value (i.e. length = 1) sample.</p> <p> Throws <code>IllegalArgumentException</code> if the array is null.</p> <p> Does not change the internal state of the statistic.</p>  @param values the input array @param mean the precomputed mean value @param begin index of the first array element to include @param length the number of elements to include @return the variance of the values or Double.NaN if length = 0 @throws IllegalArgumentException if the array is null or the array index parameters are not valid ",
    "is_bug": false,
    "failing_test_cases": 6,
    "buggy_methods": 1
  },
  {
    "name": "Variance.evaluate",
    "class_name": "org.apache.commons.math.stat.descriptive.moment.Variance",
    "signature": "org.apache.commons.math.stat.descriptive.moment.Variance.evaluate(double[],int,int)",
    "snippet": "    @Override\n    public double evaluate(final double[] values, final int begin, final int length) {\n\n        double var = Double.NaN;\n\n        if (test(values, begin, length)) {\n            clear();\n            if (length == 1) {\n                var = 0.0;\n            } else if (length > 1) {\n                Mean mean = new Mean();\n                double m = mean.evaluate(values, begin, length);\n                var = evaluate(values, m, begin, length);\n            }\n        }\n        return var;\n    }",
    "comment": " Returns the variance of the entries in the specified portion of the input array, or <code>Double.NaN</code> if the designated subarray is empty. <p> See {@link Variance} for details on the computing algorithm.</p> <p> Returns 0 for a single-value (i.e. length = 1) sample.</p> <p> Does not change the internal state of the statistic.</p> <p> Throws <code>IllegalArgumentException</code> if the array is null.</p>  @param values the input array @param begin index of the first array element to include @param length the number of elements to include @return the variance of the values or Double.NaN if length = 0 @throws IllegalArgumentException if the array is null or the array index parameters are not valid ",
    "is_bug": false,
    "failing_test_cases": 6,
    "buggy_methods": 1
  },
  {
    "name": "Variance.getResult",
    "class_name": "org.apache.commons.math.stat.descriptive.moment.Variance",
    "signature": "org.apache.commons.math.stat.descriptive.moment.Variance.getResult()",
    "snippet": "    @Override\n    public double getResult() {\n            if (moment.n == 0) {\n                return Double.NaN;\n            } else if (moment.n == 1) {\n                return 0d;\n            } else {\n                if (isBiasCorrected) {\n                    return moment.m2 / (moment.n - 1d);\n                } else {\n                    return moment.m2 / (moment.n);\n                }\n            }\n    }",
    "comment": " {@inheritDoc} ",
    "is_bug": false,
    "failing_test_cases": 6,
    "buggy_methods": 1
  },
  {
    "name": "Max.Max",
    "class_name": "org.apache.commons.math.stat.descriptive.rank.Max",
    "signature": "org.apache.commons.math.stat.descriptive.rank.Max.Max()",
    "snippet": "    public Max() {\n        n = 0;\n        value = Double.NaN;\n    }",
    "comment": " Create a Max instance ",
    "is_bug": false,
    "failing_test_cases": 6,
    "buggy_methods": 1
  },
  {
    "name": "Max.increment",
    "class_name": "org.apache.commons.math.stat.descriptive.rank.Max",
    "signature": "org.apache.commons.math.stat.descriptive.rank.Max.increment(double)",
    "snippet": "    @Override\n    public void increment(final double d) {\n        if (d > value || Double.isNaN(value)) {\n            value = d;\n        }\n        n++;\n    }",
    "comment": " {@inheritDoc} ",
    "is_bug": false,
    "failing_test_cases": 6,
    "buggy_methods": 1
  },
  {
    "name": "Min.Min",
    "class_name": "org.apache.commons.math.stat.descriptive.rank.Min",
    "signature": "org.apache.commons.math.stat.descriptive.rank.Min.Min()",
    "snippet": "    public Min() {\n        n = 0;\n        value = Double.NaN;\n    }",
    "comment": " Create a Min instance ",
    "is_bug": false,
    "failing_test_cases": 6,
    "buggy_methods": 1
  },
  {
    "name": "Min.increment",
    "class_name": "org.apache.commons.math.stat.descriptive.rank.Min",
    "signature": "org.apache.commons.math.stat.descriptive.rank.Min.increment(double)",
    "snippet": "    @Override\n    public void increment(final double d) {\n        if (d < value || Double.isNaN(value)) {\n            value = d;\n        }\n        n++;\n    }",
    "comment": " {@inheritDoc} ",
    "is_bug": false,
    "failing_test_cases": 6,
    "buggy_methods": 1
  },
  {
    "name": "Sum.Sum",
    "class_name": "org.apache.commons.math.stat.descriptive.summary.Sum",
    "signature": "org.apache.commons.math.stat.descriptive.summary.Sum.Sum()",
    "snippet": "    public Sum() {\n        n = 0;\n        value = 0;\n    }",
    "comment": " Create a Sum instance ",
    "is_bug": false,
    "failing_test_cases": 6,
    "buggy_methods": 1
  },
  {
    "name": "Sum.evaluate",
    "class_name": "org.apache.commons.math.stat.descriptive.summary.Sum",
    "signature": "org.apache.commons.math.stat.descriptive.summary.Sum.evaluate(double[],int,int)",
    "snippet": "    @Override\n    public double evaluate(final double[] values, final int begin, final int length) {\n        double sum = Double.NaN;\n        if (test(values, begin, length, true)) {\n            sum = 0.0;\n            for (int i = begin; i < begin + length; i++) {\n                sum += values[i];\n            }\n        }\n        return sum;\n    }",
    "comment": " The sum of the entries in the specified portion of the input array, or 0 if the designated subarray is empty. <p> Throws <code>IllegalArgumentException</code> if the array is null.</p>  @param values the input array @param begin index of the first array element to include @param length the number of elements to include @return the sum of the values or 0 if length = 0 @throws IllegalArgumentException if the array is null or the array index parameters are not valid ",
    "is_bug": false,
    "failing_test_cases": 6,
    "buggy_methods": 1
  },
  {
    "name": "Sum.increment",
    "class_name": "org.apache.commons.math.stat.descriptive.summary.Sum",
    "signature": "org.apache.commons.math.stat.descriptive.summary.Sum.increment(double)",
    "snippet": "    @Override\n    public void increment(final double d) {\n        value += d;\n        n++;\n    }",
    "comment": " {@inheritDoc} ",
    "is_bug": false,
    "failing_test_cases": 6,
    "buggy_methods": 1
  },
  {
    "name": "SumOfLogs.SumOfLogs",
    "class_name": "org.apache.commons.math.stat.descriptive.summary.SumOfLogs",
    "signature": "org.apache.commons.math.stat.descriptive.summary.SumOfLogs.SumOfLogs()",
    "snippet": "    public SumOfLogs() {\n       value = 0d;\n       n = 0;\n    }",
    "comment": " Create a SumOfLogs instance ",
    "is_bug": false,
    "failing_test_cases": 6,
    "buggy_methods": 1
  },
  {
    "name": "SumOfLogs.evaluate",
    "class_name": "org.apache.commons.math.stat.descriptive.summary.SumOfLogs",
    "signature": "org.apache.commons.math.stat.descriptive.summary.SumOfLogs.evaluate(double[],int,int)",
    "snippet": "    @Override\n    public double evaluate(final double[] values, final int begin, final int length) {\n        double sumLog = Double.NaN;\n        if (test(values, begin, length, true)) {\n            sumLog = 0.0;\n            for (int i = begin; i < begin + length; i++) {\n                sumLog += FastMath.log(values[i]);\n            }\n        }\n        return sumLog;\n    }",
    "comment": " Returns the sum of the natural logs of the entries in the specified portion of the input array, or <code>Double.NaN</code> if the designated subarray is empty. <p> Throws <code>IllegalArgumentException</code> if the array is null.</p> <p> See {@link SumOfLogs}.</p>  @param values the input array @param begin index of the first array element to include @param length the number of elements to include @return the sum of the natural logs of the values or 0 if length = 0 @throws IllegalArgumentException if the array is null or the array index parameters are not valid ",
    "is_bug": false,
    "failing_test_cases": 6,
    "buggy_methods": 1
  },
  {
    "name": "SumOfLogs.getN",
    "class_name": "org.apache.commons.math.stat.descriptive.summary.SumOfLogs",
    "signature": "org.apache.commons.math.stat.descriptive.summary.SumOfLogs.getN()",
    "snippet": "    public long getN() {\n        return n;\n    }",
    "comment": " {@inheritDoc} ",
    "is_bug": false,
    "failing_test_cases": 6,
    "buggy_methods": 1
  },
  {
    "name": "SumOfLogs.increment",
    "class_name": "org.apache.commons.math.stat.descriptive.summary.SumOfLogs",
    "signature": "org.apache.commons.math.stat.descriptive.summary.SumOfLogs.increment(double)",
    "snippet": "    @Override\n    public void increment(final double d) {\n        value += FastMath.log(d);\n        n++;\n    }",
    "comment": " {@inheritDoc} ",
    "is_bug": false,
    "failing_test_cases": 6,
    "buggy_methods": 1
  },
  {
    "name": "SumOfSquares.SumOfSquares",
    "class_name": "org.apache.commons.math.stat.descriptive.summary.SumOfSquares",
    "signature": "org.apache.commons.math.stat.descriptive.summary.SumOfSquares.SumOfSquares()",
    "snippet": "    public SumOfSquares() {\n        n = 0;\n        value = 0;\n    }",
    "comment": " Create a SumOfSquares instance ",
    "is_bug": false,
    "failing_test_cases": 6,
    "buggy_methods": 1
  },
  {
    "name": "SumOfSquares.increment",
    "class_name": "org.apache.commons.math.stat.descriptive.summary.SumOfSquares",
    "signature": "org.apache.commons.math.stat.descriptive.summary.SumOfSquares.increment(double)",
    "snippet": "    @Override\n    public void increment(final double d) {\n        value += d * d;\n        n++;\n    }",
    "comment": " {@inheritDoc} ",
    "is_bug": false,
    "failing_test_cases": 6,
    "buggy_methods": 1
  },
  {
    "name": "FastMath.exp",
    "class_name": "org.apache.commons.math.util.FastMath",
    "signature": "org.apache.commons.math.util.FastMath.exp(double)",
    "snippet": "    public static double exp(double x) {\n        return exp(x, 0.0, null);\n    }",
    "comment": " Exponential function.  Computes exp(x), function result is nearly rounded.   It will be correctly rounded to the theoretical value for 99.9% of input values, otherwise it will have a 1 UPL error.  Method: Lookup intVal = exp(int(x)) Lookup fracVal = exp(int(x-int(x) / 1024.0) * 1024.0 ); Compute z as the exponential of the remaining bits by a polynomial minus one exp(x) = intVal * fracVal * (1 + z)  Accuracy: Calculation is done with 63 bits of precision, so result should be correctly rounded for 99.9% of input values, with less than 1 ULP error otherwise.  @param x   a double @return double e<sup>x</sup> ",
    "is_bug": false,
    "failing_test_cases": 6,
    "buggy_methods": 1
  },
  {
    "name": "FastMath.exp",
    "class_name": "org.apache.commons.math.util.FastMath",
    "signature": "org.apache.commons.math.util.FastMath.exp(double,double,double[])",
    "snippet": "    private static double exp(double x, double extra, double[] hiPrec) {\n        double intPartA;\n        double intPartB;\n        int intVal;\n\n        /* Lookup exp(floor(x)).\n         * intPartA will have the upper 22 bits, intPartB will have the lower\n         * 52 bits.\n         */\n        if (x < 0.0) {\n            intVal = (int) -x;\n\n            if (intVal > 746) {\n                if (hiPrec != null) {\n                    hiPrec[0] = 0.0;\n                    hiPrec[1] = 0.0;\n                }\n                return 0.0;\n            }\n\n            if (intVal > 709) {\n                /* This will produce a subnormal output */\n                final double result = exp(x+40.19140625, extra, hiPrec) / 285040095144011776.0;\n                if (hiPrec != null) {\n                    hiPrec[0] /= 285040095144011776.0;\n                    hiPrec[1] /= 285040095144011776.0;\n                }\n                return result;\n            }\n\n            if (intVal == 709) {\n                /* exp(1.494140625) is nearly a machine number... */\n                final double result = exp(x+1.494140625, extra, hiPrec) / 4.455505956692756620;\n                if (hiPrec != null) {\n                    hiPrec[0] /= 4.455505956692756620;\n                    hiPrec[1] /= 4.455505956692756620;\n                }\n                return result;\n            }\n\n            intVal++;\n\n            intPartA = ExpIntTable.EXP_INT_TABLE_A[EXP_INT_TABLE_MAX_INDEX-intVal];\n            intPartB = ExpIntTable.EXP_INT_TABLE_B[EXP_INT_TABLE_MAX_INDEX-intVal];\n\n            intVal = -intVal;\n        } else {\n            intVal = (int) x;\n\n            if (intVal > 709) {\n                if (hiPrec != null) {\n                    hiPrec[0] = Double.POSITIVE_INFINITY;\n                    hiPrec[1] = 0.0;\n                }\n                return Double.POSITIVE_INFINITY;\n            }\n\n            intPartA = ExpIntTable.EXP_INT_TABLE_A[EXP_INT_TABLE_MAX_INDEX+intVal];\n            intPartB = ExpIntTable.EXP_INT_TABLE_B[EXP_INT_TABLE_MAX_INDEX+intVal];\n        }\n\n        /* Get the fractional part of x, find the greatest multiple of 2^-10 less than\n         * x and look up the exp function of it.\n         * fracPartA will have the upper 22 bits, fracPartB the lower 52 bits.\n         */\n        final int intFrac = (int) ((x - intVal) * 1024.0);\n        final double fracPartA = ExpFracTable.EXP_FRAC_TABLE_A[intFrac];\n        final double fracPartB = ExpFracTable.EXP_FRAC_TABLE_B[intFrac];\n\n        /* epsilon is the difference in x from the nearest multiple of 2^-10.  It\n         * has a value in the range 0 <= epsilon < 2^-10.\n         * Do the subtraction from x as the last step to avoid possible loss of percison.\n         */\n        final double epsilon = x - (intVal + intFrac / 1024.0);\n\n        /* Compute z = exp(epsilon) - 1.0 via a minimax polynomial.  z has\n       full double precision (52 bits).  Since z < 2^-10, we will have\n       62 bits of precision when combined with the contant 1.  This will be\n       used in the last addition below to get proper rounding. */\n\n        /* Remez generated polynomial.  Converges on the interval [0, 2^-10], error\n       is less than 0.5 ULP */\n        double z = 0.04168701738764507;\n        z = z * epsilon + 0.1666666505023083;\n        z = z * epsilon + 0.5000000000042687;\n        z = z * epsilon + 1.0;\n        z = z * epsilon + -3.940510424527919E-20;\n\n        /* Compute (intPartA+intPartB) * (fracPartA+fracPartB) by binomial\n       expansion.\n       tempA is exact since intPartA and intPartB only have 22 bits each.\n       tempB will have 52 bits of precision.\n         */\n        double tempA = intPartA * fracPartA;\n        double tempB = intPartA * fracPartB + intPartB * fracPartA + intPartB * fracPartB;\n\n        /* Compute the result.  (1+z)(tempA+tempB).  Order of operations is\n       important.  For accuracy add by increasing size.  tempA is exact and\n       much larger than the others.  If there are extra bits specified from the\n       pow() function, use them. */\n        final double tempC = tempB + tempA;\n        final double result;\n        if (extra != 0.0) {\n            result = tempC*extra*z + tempC*extra + tempC*z + tempB + tempA;\n        } else {\n            result = tempC*z + tempB + tempA;\n        }\n\n        if (hiPrec != null) {\n            // If requesting high precision\n            hiPrec[0] = tempA;\n            hiPrec[1] = tempC*extra*z + tempC*extra + tempC*z + tempB;\n        }\n\n        return result;\n    }",
    "comment": " Internal helper method for exponential function. @param x original argument of the exponential function @param extra extra bits of precision on input (To Be Confirmed) @param hiPrec extra bits of precision on output (To Be Confirmed) @return exp(x) ",
    "is_bug": false,
    "failing_test_cases": 6,
    "buggy_methods": 1
  },
  {
    "name": "FastMath.log",
    "class_name": "org.apache.commons.math.util.FastMath",
    "signature": "org.apache.commons.math.util.FastMath.log(double)",
    "snippet": "    public static double log(final double x) {\n        return log(x, null);\n    }",
    "comment": " Natural logarithm.  @param x   a double @return log(x) ",
    "is_bug": false,
    "failing_test_cases": 6,
    "buggy_methods": 1
  },
  {
    "name": "FastMath.log",
    "class_name": "org.apache.commons.math.util.FastMath",
    "signature": "org.apache.commons.math.util.FastMath.log(double,double[])",
    "snippet": "    private static double log(final double x, final double[] hiPrec) {\n        if (x==0) { // Handle special case of +0/-0\n            return Double.NEGATIVE_INFINITY;\n        }\n        long bits = Double.doubleToLongBits(x);\n\n        /* Handle special cases of negative input, and NaN */\n        if ((bits & 0x8000000000000000L) != 0 || x != x) {\n            if (x != 0.0) {\n                if (hiPrec != null) {\n                    hiPrec[0] = Double.NaN;\n                }\n\n                return Double.NaN;\n            }\n        }\n\n        /* Handle special cases of Positive infinity. */\n        if (x == Double.POSITIVE_INFINITY) {\n            if (hiPrec != null) {\n                hiPrec[0] = Double.POSITIVE_INFINITY;\n            }\n\n            return Double.POSITIVE_INFINITY;\n        }\n\n        /* Extract the exponent */\n        int exp = (int)(bits >> 52)-1023;\n\n        if ((bits & 0x7ff0000000000000L) == 0) {\n            // Subnormal!\n            if (x == 0) {\n                // Zero\n                if (hiPrec != null) {\n                    hiPrec[0] = Double.NEGATIVE_INFINITY;\n                }\n\n                return Double.NEGATIVE_INFINITY;\n            }\n\n            /* Normalize the subnormal number. */\n            bits <<= 1;\n            while ( (bits & 0x0010000000000000L) == 0) {\n                exp--;\n                bits <<= 1;\n            }\n        }\n\n\n        if (exp == -1 || exp == 0) {\n            if (x < 1.01 && x > 0.99 && hiPrec == null) {\n                /* The normal method doesn't work well in the range [0.99, 1.01], so call do a straight\n           polynomial expansion in higer precision. */\n\n               /* Compute x - 1.0 and split it */\n                double xa = x - 1.0;\n                double xb = xa - x + 1.0;\n                double tmp = xa * HEX_40000000;\n                double aa = xa + tmp - tmp;\n                double ab = xa - aa;\n                xa = aa;\n                xb = ab;\n\n                double ya = LN_QUICK_COEF[LN_QUICK_COEF.length-1][0];\n                double yb = LN_QUICK_COEF[LN_QUICK_COEF.length-1][1];\n\n                for (int i = LN_QUICK_COEF.length - 2; i >= 0; i--) {\n                    /* Multiply a = y * x */\n                    aa = ya * xa;\n                    ab = ya * xb + yb * xa + yb * xb;\n                    /* split, so now y = a */\n                    tmp = aa * HEX_40000000;\n                    ya = aa + tmp - tmp;\n                    yb = aa - ya + ab;\n\n                    /* Add  a = y + lnQuickCoef */\n                    aa = ya + LN_QUICK_COEF[i][0];\n                    ab = yb + LN_QUICK_COEF[i][1];\n                    /* Split y = a */\n                    tmp = aa * HEX_40000000;\n                    ya = aa + tmp - tmp;\n                    yb = aa - ya + ab;\n                }\n\n                /* Multiply a = y * x */\n                aa = ya * xa;\n                ab = ya * xb + yb * xa + yb * xb;\n                /* split, so now y = a */\n                tmp = aa * HEX_40000000;\n                ya = aa + tmp - tmp;\n                yb = aa - ya + ab;\n\n                return ya + yb;\n            }\n        }\n\n        // lnm is a log of a number in the range of 1.0 - 2.0, so 0 <= lnm < ln(2)\n        double lnm[] = lnMant.LN_MANT[(int)((bits & 0x000ffc0000000000L) >> 42)];\n\n        /*\n    double epsilon = x / Double.longBitsToDouble(bits & 0xfffffc0000000000L);\n\n    epsilon -= 1.0;\n         */\n\n        // y is the most significant 10 bits of the mantissa\n        //double y = Double.longBitsToDouble(bits & 0xfffffc0000000000L);\n        //double epsilon = (x - y) / y;\n        double epsilon = (bits & 0x3ffffffffffL) / (TWO_POWER_52 + (bits & 0x000ffc0000000000L));\n\n        double lnza = 0.0;\n        double lnzb = 0.0;\n\n        if (hiPrec != null) {\n            /* split epsilon -> x */\n            double tmp = epsilon * HEX_40000000;\n            double aa = epsilon + tmp - tmp;\n            double ab = epsilon - aa;\n            double xa = aa;\n            double xb = ab;\n\n            /* Need a more accurate epsilon, so adjust the division. */\n            double numer = bits & 0x3ffffffffffL;\n            double denom = TWO_POWER_52 + (bits & 0x000ffc0000000000L);\n            aa = numer - xa*denom - xb * denom;\n            xb += aa / denom;\n\n            /* Remez polynomial evaluation */\n            double ya = LN_HI_PREC_COEF[LN_HI_PREC_COEF.length-1][0];\n            double yb = LN_HI_PREC_COEF[LN_HI_PREC_COEF.length-1][1];\n\n            for (int i = LN_HI_PREC_COEF.length - 2; i >= 0; i--) {\n                /* Multiply a = y * x */\n                aa = ya * xa;\n                ab = ya * xb + yb * xa + yb * xb;\n                /* split, so now y = a */\n                tmp = aa * HEX_40000000;\n                ya = aa + tmp - tmp;\n                yb = aa - ya + ab;\n\n                /* Add  a = y + lnHiPrecCoef */\n                aa = ya + LN_HI_PREC_COEF[i][0];\n                ab = yb + LN_HI_PREC_COEF[i][1];\n                /* Split y = a */\n                tmp = aa * HEX_40000000;\n                ya = aa + tmp - tmp;\n                yb = aa - ya + ab;\n            }\n\n            /* Multiply a = y * x */\n            aa = ya * xa;\n            ab = ya * xb + yb * xa + yb * xb;\n\n            /* split, so now lnz = a */\n            /*\n      tmp = aa * 1073741824.0;\n      lnza = aa + tmp - tmp;\n      lnzb = aa - lnza + ab;\n             */\n            lnza = aa + ab;\n            lnzb = -(lnza - aa - ab);\n        } else {\n            /* High precision not required.  Eval Remez polynomial\n         using standard double precision */\n            lnza = -0.16624882440418567;\n            lnza = lnza * epsilon + 0.19999954120254515;\n            lnza = lnza * epsilon + -0.2499999997677497;\n            lnza = lnza * epsilon + 0.3333333333332802;\n            lnza = lnza * epsilon + -0.5;\n            lnza = lnza * epsilon + 1.0;\n            lnza = lnza * epsilon;\n        }\n\n        /* Relative sizes:\n         * lnzb     [0, 2.33E-10]\n         * lnm[1]   [0, 1.17E-7]\n         * ln2B*exp [0, 1.12E-4]\n         * lnza      [0, 9.7E-4]\n         * lnm[0]   [0, 0.692]\n         * ln2A*exp [0, 709]\n         */\n\n        /* Compute the following sum:\n         * lnzb + lnm[1] + ln2B*exp + lnza + lnm[0] + ln2A*exp;\n         */\n\n        //return lnzb + lnm[1] + ln2B*exp + lnza + lnm[0] + ln2A*exp;\n        double a = LN_2_A*exp;\n        double b = 0.0;\n        double c = a+lnm[0];\n        double d = -(c-a-lnm[0]);\n        a = c;\n        b = b + d;\n\n        c = a + lnza;\n        d = -(c - a - lnza);\n        a = c;\n        b = b + d;\n\n        c = a + LN_2_B*exp;\n        d = -(c - a - LN_2_B*exp);\n        a = c;\n        b = b + d;\n\n        c = a + lnm[1];\n        d = -(c - a - lnm[1]);\n        a = c;\n        b = b + d;\n\n        c = a + lnzb;\n        d = -(c - a - lnzb);\n        a = c;\n        b = b + d;\n\n        if (hiPrec != null) {\n            hiPrec[0] = a;\n            hiPrec[1] = b;\n        }\n\n        return a + b;\n    }",
    "comment": " Internal helper method for natural logarithm function. @param x original argument of the natural logarithm function @param hiPrec extra bits of precision on output (To Be Confirmed) @return log(x) ",
    "is_bug": false,
    "failing_test_cases": 6,
    "buggy_methods": 1
  },
  {
    "name": "FastMath.sqrt",
    "class_name": "org.apache.commons.math.util.FastMath",
    "signature": "org.apache.commons.math.util.FastMath.sqrt(double)",
    "snippet": "    public static double sqrt(final double a) {\n        return Math.sqrt(a);\n    }",
    "comment": "Compute the square root of a number. <p><b>Note:</b> this implementation currently delegates to {@link Math#sqrt} @param a number on which evaluation is done @return square root of a ",
    "is_bug": false,
    "failing_test_cases": 6,
    "buggy_methods": 1
  },
  {
    "name": "FastMathLiteralArrays.loadExpFracA",
    "class_name": "org.apache.commons.math.util.FastMathLiteralArrays",
    "signature": "org.apache.commons.math.util.FastMathLiteralArrays.loadExpFracA()",
    "snippet": "    static double[] loadExpFracA() {\n        return EXP_FRAC_A;\n    }",
    "comment": " Load \"EXP_FRAC_A\".  @return the data array. ",
    "is_bug": false,
    "failing_test_cases": 6,
    "buggy_methods": 1
  },
  {
    "name": "FastMathLiteralArrays.loadExpFracB",
    "class_name": "org.apache.commons.math.util.FastMathLiteralArrays",
    "signature": "org.apache.commons.math.util.FastMathLiteralArrays.loadExpFracB()",
    "snippet": "    static double[] loadExpFracB() {\n        return EXP_FRAC_B;\n    }",
    "comment": " Load \"EXP_FRAC_B\".  @return the data array. ",
    "is_bug": false,
    "failing_test_cases": 6,
    "buggy_methods": 1
  },
  {
    "name": "FastMathLiteralArrays.loadExpIntA",
    "class_name": "org.apache.commons.math.util.FastMathLiteralArrays",
    "signature": "org.apache.commons.math.util.FastMathLiteralArrays.loadExpIntA()",
    "snippet": "    static double[] loadExpIntA() {\n        return EXP_INT_A;\n    }",
    "comment": " Load \"EXP_INT_A\".  @return the data array. ",
    "is_bug": false,
    "failing_test_cases": 6,
    "buggy_methods": 1
  },
  {
    "name": "FastMathLiteralArrays.loadExpIntB",
    "class_name": "org.apache.commons.math.util.FastMathLiteralArrays",
    "signature": "org.apache.commons.math.util.FastMathLiteralArrays.loadExpIntB()",
    "snippet": "    static double[] loadExpIntB() {\n        return EXP_INT_B;\n    }",
    "comment": " Load \"EXP_INT_B\".  @return the data array. ",
    "is_bug": false,
    "failing_test_cases": 6,
    "buggy_methods": 1
  },
  {
    "name": "FastMathLiteralArrays.loadLnMant",
    "class_name": "org.apache.commons.math.util.FastMathLiteralArrays",
    "signature": "org.apache.commons.math.util.FastMathLiteralArrays.loadLnMant()",
    "snippet": "    static double[][] loadLnMant() {\n        return LN_MANT;\n    }",
    "comment": " Load \"LN_MANT\".  @return the data array. ",
    "is_bug": false,
    "failing_test_cases": 6,
    "buggy_methods": 1
  }
]