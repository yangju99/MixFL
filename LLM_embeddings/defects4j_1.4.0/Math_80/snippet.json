[
  {
    "name": "AbstractRealMatrix.AbstractRealMatrix",
    "class_name": "org.apache.commons.math.linear.AbstractRealMatrix",
    "signature": "org.apache.commons.math.linear.AbstractRealMatrix.AbstractRealMatrix()",
    "snippet": "    protected AbstractRealMatrix() {\n        lu = null;\n    }",
    "comment": " Creates a matrix with no data ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "AbstractRealMatrix.AbstractRealMatrix",
    "class_name": "org.apache.commons.math.linear.AbstractRealMatrix",
    "signature": "org.apache.commons.math.linear.AbstractRealMatrix.AbstractRealMatrix(int,int)",
    "snippet": "    protected AbstractRealMatrix(final int rowDimension, final int columnDimension)\n        throws IllegalArgumentException {\n        if (rowDimension <= 0 ) {\n            throw MathRuntimeException.createIllegalArgumentException(\n                    \"invalid row dimension {0} (must be positive)\",\n                    rowDimension);\n        }\n        if (columnDimension <= 0) {\n            throw MathRuntimeException.createIllegalArgumentException(\n                    \"invalid column dimension {0} (must be positive)\",\n                    columnDimension);\n        }\n        lu = null;\n    }",
    "comment": " Create a new RealMatrix with the supplied row and column dimensions.  @param rowDimension  the number of rows in the new matrix @param columnDimension  the number of columns in the new matrix @throws IllegalArgumentException if row or column dimension is not positive ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "AbstractRealMatrix.transpose",
    "class_name": "org.apache.commons.math.linear.AbstractRealMatrix",
    "signature": "org.apache.commons.math.linear.AbstractRealMatrix.transpose()",
    "snippet": "    public RealMatrix transpose() {\n\n        final int nRows = getRowDimension();\n        final int nCols = getColumnDimension();\n        final RealMatrix out = createMatrix(nCols, nRows);\n        walkInOptimizedOrder(new DefaultRealMatrixPreservingVisitor() {\n\n            /** {@inheritDoc} */\n            @Override\n            public void visit(final int row, final int column, final double value) {\n                out.setEntry(column, row, value);\n            }\n\n        });\n\n        return out;\n\n    }",
    "comment": "{@inheritDoc} */",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "AbstractRealMatrix.walkInOptimizedOrder",
    "class_name": "org.apache.commons.math.linear.AbstractRealMatrix",
    "signature": "org.apache.commons.math.linear.AbstractRealMatrix.walkInOptimizedOrder(RealMatrixPreservingVisitor)",
    "snippet": "    public double walkInOptimizedOrder(final RealMatrixPreservingVisitor visitor)\n        throws MatrixVisitorException {\n        return walkInRowOrder(visitor);\n    }",
    "comment": "{@inheritDoc} */",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "Array2DRowRealMatrix.Array2DRowRealMatrix",
    "class_name": "org.apache.commons.math.linear.Array2DRowRealMatrix",
    "signature": "org.apache.commons.math.linear.Array2DRowRealMatrix.Array2DRowRealMatrix(double[][])",
    "snippet": "    public Array2DRowRealMatrix(final double[][] d)\n        throws IllegalArgumentException, NullPointerException {\n        copyIn(d);\n    }",
    "comment": " Create a new RealMatrix using the input array as the underlying data array. <p>The input array is copied, not referenced. This constructor has the same effect as calling {@link #Array2DRowRealMatrix(double[][], boolean)} with the second argument set to <code>true</code>.</p>  @param d data for new matrix @throws IllegalArgumentException if <code>d</code> is not rectangular (not all rows have the same length) or empty @throws NullPointerException if <code>d</code> is null @see #Array2DRowRealMatrix(double[][], boolean) ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "Array2DRowRealMatrix.Array2DRowRealMatrix",
    "class_name": "org.apache.commons.math.linear.Array2DRowRealMatrix",
    "signature": "org.apache.commons.math.linear.Array2DRowRealMatrix.Array2DRowRealMatrix(double[][],boolean)",
    "snippet": "    public Array2DRowRealMatrix(final double[][] d, final boolean copyArray)\n        throws IllegalArgumentException, NullPointerException {\n        if (copyArray) {\n            copyIn(d);\n        } else {\n            if (d == null) {\n                throw new NullPointerException();\n            }\n            final int nRows = d.length;\n            if (nRows == 0) {\n                throw MathRuntimeException.createIllegalArgumentException(\"matrix must have at least one row\");\n            }\n            final int nCols = d[0].length;\n            if (nCols == 0) {\n                throw MathRuntimeException.createIllegalArgumentException(\"matrix must have at least one column\");\n            }\n            for (int r = 1; r < nRows; r++) {\n                if (d[r].length != nCols) {\n                    throw MathRuntimeException.createIllegalArgumentException(\n                            \"some rows have length {0} while others have length {1}\",\n                            nCols, d[r].length);\n                }\n            }\n            data = d;\n        }\n    }",
    "comment": " Create a new RealMatrix using the input array as the underlying data array. <p>If an array is built specially in order to be embedded in a RealMatrix and not used directly, the <code>copyArray</code> may be set to <code>false</code. This will prevent the copying and improve performance as no new array will be built and no data will be copied.</p> @param d data for new matrix @param copyArray if true, the input array will be copied, otherwise it will be referenced @throws IllegalArgumentException if <code>d</code> is not rectangular (not all rows have the same length) or empty @throws NullPointerException if <code>d</code> is null @see #Array2DRowRealMatrix(double[][]) ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "Array2DRowRealMatrix.Array2DRowRealMatrix",
    "class_name": "org.apache.commons.math.linear.Array2DRowRealMatrix",
    "signature": "org.apache.commons.math.linear.Array2DRowRealMatrix.Array2DRowRealMatrix(int,int)",
    "snippet": "    public Array2DRowRealMatrix(final int rowDimension, final int columnDimension)\n        throws IllegalArgumentException {\n        super(rowDimension, columnDimension);\n        data = new double[rowDimension][columnDimension];\n    }",
    "comment": " Create a new RealMatrix with the supplied row and column dimensions.  @param rowDimension  the number of rows in the new matrix @param columnDimension  the number of columns in the new matrix @throws IllegalArgumentException if row or column dimension is not positive ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "Array2DRowRealMatrix.copyIn",
    "class_name": "org.apache.commons.math.linear.Array2DRowRealMatrix",
    "signature": "org.apache.commons.math.linear.Array2DRowRealMatrix.copyIn(double[][])",
    "snippet": "    private void copyIn(final double[][] in) {\n        setSubMatrix(in, 0, 0);\n    }",
    "comment": " Replaces data with a fresh copy of the input array. <p> Verifies that the input array is rectangular and non-empty.</p>  @param in data to copy in @throws IllegalArgumentException if input array is empty or not rectangular @throws NullPointerException if input array is null ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "Array2DRowRealMatrix.createMatrix",
    "class_name": "org.apache.commons.math.linear.Array2DRowRealMatrix",
    "signature": "org.apache.commons.math.linear.Array2DRowRealMatrix.createMatrix(int,int)",
    "snippet": "    @Override\n    public RealMatrix createMatrix(final int rowDimension, final int columnDimension)\n        throws IllegalArgumentException {\n        return new Array2DRowRealMatrix(rowDimension, columnDimension);\n    }",
    "comment": "{@inheritDoc} */",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "Array2DRowRealMatrix.getColumnDimension",
    "class_name": "org.apache.commons.math.linear.Array2DRowRealMatrix",
    "signature": "org.apache.commons.math.linear.Array2DRowRealMatrix.getColumnDimension()",
    "snippet": "    @Override\n    public int getColumnDimension() {\n        return ((data == null) || (data[0] == null)) ? 0 : data[0].length;\n    }",
    "comment": "{@inheritDoc} */",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "Array2DRowRealMatrix.getRowDimension",
    "class_name": "org.apache.commons.math.linear.Array2DRowRealMatrix",
    "signature": "org.apache.commons.math.linear.Array2DRowRealMatrix.getRowDimension()",
    "snippet": "    @Override\n    public int getRowDimension() {\n        return (data == null) ? 0 : data.length;\n    }",
    "comment": "{@inheritDoc} */",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "Array2DRowRealMatrix.multiply",
    "class_name": "org.apache.commons.math.linear.Array2DRowRealMatrix",
    "signature": "org.apache.commons.math.linear.Array2DRowRealMatrix.multiply(Array2DRowRealMatrix)",
    "snippet": "    public Array2DRowRealMatrix multiply(final Array2DRowRealMatrix m)\n        throws IllegalArgumentException {\n\n        // safety check\n        MatrixUtils.checkMultiplicationCompatible(this, m);\n\n        final int nRows = this.getRowDimension();\n        final int nCols = m.getColumnDimension();\n        final int nSum = this.getColumnDimension();\n        final double[][] outData = new double[nRows][nCols];\n        for (int row = 0; row < nRows; row++) {\n            final double[] dataRow    = data[row];\n            final double[] outDataRow = outData[row];\n            for (int col = 0; col < nCols; col++) {\n                double sum = 0;\n                for (int i = 0; i < nSum; i++) {\n                    sum += dataRow[i] * m.data[i][col];\n                }\n                outDataRow[col] = sum;\n            }\n        }\n\n        return new Array2DRowRealMatrix(outData, false);\n\n    }",
    "comment": " Returns the result of postmultiplying this by <code>m</code>. @param m    matrix to postmultiply by @return     this*m @throws     IllegalArgumentException if columnDimension(this) != rowDimension(m) ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "Array2DRowRealMatrix.multiply",
    "class_name": "org.apache.commons.math.linear.Array2DRowRealMatrix",
    "signature": "org.apache.commons.math.linear.Array2DRowRealMatrix.multiply(RealMatrix)",
    "snippet": "    @Override\n    public RealMatrix multiply(final RealMatrix m)\n        throws IllegalArgumentException {\n        try {\n            return multiply((Array2DRowRealMatrix) m);\n        } catch (ClassCastException cce) {\n            return super.multiply(m);\n        }\n    }",
    "comment": "{@inheritDoc} */",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "Array2DRowRealMatrix.setEntry",
    "class_name": "org.apache.commons.math.linear.Array2DRowRealMatrix",
    "signature": "org.apache.commons.math.linear.Array2DRowRealMatrix.setEntry(int,int,double)",
    "snippet": "    @Override\n    public void setEntry(final int row, final int column, final double value)\n        throws MatrixIndexException {\n        try {\n            data[row][column] = value;\n        } catch (ArrayIndexOutOfBoundsException e) {\n            throw new MatrixIndexException(\n                    \"no entry at indices ({0}, {1}) in a {2}x{3} matrix\",\n                    row, column, getRowDimension(), getColumnDimension());\n        }\n    }",
    "comment": "{@inheritDoc} */",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "Array2DRowRealMatrix.setSubMatrix",
    "class_name": "org.apache.commons.math.linear.Array2DRowRealMatrix",
    "signature": "org.apache.commons.math.linear.Array2DRowRealMatrix.setSubMatrix(double[][],int,int)",
    "snippet": "    @Override\n    public void setSubMatrix(final double[][] subMatrix, final int row, final int column)\n    throws MatrixIndexException {\n        if (data == null) {\n            if (row > 0) {\n                throw MathRuntimeException.createIllegalStateException(\n                        \"first {0} rows are not initialized yet\",\n                        row);\n            }\n            if (column > 0) {\n                throw MathRuntimeException.createIllegalStateException(\n                        \"first {0} columns are not initialized yet\",\n                        column);\n            }\n            final int nRows = subMatrix.length;\n            if (nRows == 0) {\n                throw MathRuntimeException.createIllegalArgumentException(\"matrix must have at least one row\");\n            }\n\n            final int nCols = subMatrix[0].length;\n            if (nCols == 0) {\n                throw MathRuntimeException.createIllegalArgumentException(\"matrix must have at least one column\");\n            }\n            data = new double[subMatrix.length][nCols];\n            for (int i = 0; i < data.length; ++i) {\n                if (subMatrix[i].length != nCols) {\n                    throw MathRuntimeException.createIllegalArgumentException(\n                            \"some rows have length {0} while others have length {1}\",\n                            nCols, subMatrix[i].length);\n                }\n                System.arraycopy(subMatrix[i], 0, data[i + row], column, nCols);\n            }\n        } else {\n            super.setSubMatrix(subMatrix, row, column);\n        }\n\n    }",
    "comment": "{@inheritDoc} */",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "Array2DRowRealMatrix.walkInRowOrder",
    "class_name": "org.apache.commons.math.linear.Array2DRowRealMatrix",
    "signature": "org.apache.commons.math.linear.Array2DRowRealMatrix.walkInRowOrder(RealMatrixPreservingVisitor)",
    "snippet": "    @Override\n    public double walkInRowOrder(final RealMatrixPreservingVisitor visitor)\n        throws MatrixVisitorException {\n        final int rows    = getRowDimension();\n        final int columns = getColumnDimension();\n        visitor.start(rows, columns, 0, rows - 1, 0, columns - 1);\n        for (int i = 0; i < rows; ++i) {\n            final double[] rowI = data[i];\n            for (int j = 0; j < columns; ++j) {\n                visitor.visit(i, j, rowI[j]);\n            }\n        }\n        return visitor.end();\n    }",
    "comment": "{@inheritDoc} */",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "ArrayRealVector.ArrayRealVector",
    "class_name": "org.apache.commons.math.linear.ArrayRealVector",
    "signature": "org.apache.commons.math.linear.ArrayRealVector.ArrayRealVector(ArrayRealVector,boolean)",
    "snippet": "    public ArrayRealVector(ArrayRealVector v, boolean deep) {\n        data = deep ? v.data.clone() : v.data;\n    }",
    "comment": " Construct a vector from another vector. @param v vector to copy @param deep if true perform a deep copy otherwise perform a shallow copy ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "ArrayRealVector.ArrayRealVector",
    "class_name": "org.apache.commons.math.linear.ArrayRealVector",
    "signature": "org.apache.commons.math.linear.ArrayRealVector.ArrayRealVector(double[])",
    "snippet": "    public ArrayRealVector(double[] d) {\n        data = d.clone();\n    }",
    "comment": " Construct a vector from an array, copying the input array. @param d array of doubles. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "ArrayRealVector.ArrayRealVector",
    "class_name": "org.apache.commons.math.linear.ArrayRealVector",
    "signature": "org.apache.commons.math.linear.ArrayRealVector.ArrayRealVector(double[],boolean)",
    "snippet": "    public ArrayRealVector(double[] d, boolean copyArray)\n        throws NullPointerException, IllegalArgumentException {\n        if (d == null) {\n            throw new NullPointerException();\n        }\n        if (d.length == 0) {\n            throw MathRuntimeException.createIllegalArgumentException(\"vector must have at least one element\");\n        }\n        data = copyArray ? d.clone() :  d;\n    }",
    "comment": " Create a new ArrayRealVector using the input array as the underlying data array. <p>If an array is built specially in order to be embedded in a ArrayRealVector and not used directly, the <code>copyArray</code> may be set to <code>false</code. This will prevent the copying and improve performance as no new array will be built and no data will be copied.</p> @param d data for new vector @param copyArray if true, the input array will be copied, otherwise it will be referenced @throws IllegalArgumentException if <code>d</code> is empty @throws NullPointerException if <code>d</code> is null @see #ArrayRealVector(double[]) ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "ArrayRealVector.checkVectorDimensions",
    "class_name": "org.apache.commons.math.linear.ArrayRealVector",
    "signature": "org.apache.commons.math.linear.ArrayRealVector.checkVectorDimensions(int)",
    "snippet": "    protected void checkVectorDimensions(int n)\n        throws IllegalArgumentException {\n        if (data.length != n) {\n            throw MathRuntimeException.createIllegalArgumentException(\n                    \"vector length mismatch: got {0} but expected {1}\",\n                    data.length, n);\n        }\n    }",
    "comment": " Check if instance dimension is equal to some expected value.  @param n expected dimension. @exception IllegalArgumentException if the dimension is inconsistent with vector size ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "ArrayRealVector.copy",
    "class_name": "org.apache.commons.math.linear.ArrayRealVector",
    "signature": "org.apache.commons.math.linear.ArrayRealVector.copy()",
    "snippet": "    public RealVector copy() {\n        return new ArrayRealVector(this, true);\n    }",
    "comment": "{@inheritDoc} */",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "ArrayRealVector.dotProduct",
    "class_name": "org.apache.commons.math.linear.ArrayRealVector",
    "signature": "org.apache.commons.math.linear.ArrayRealVector.dotProduct(ArrayRealVector)",
    "snippet": "    public double dotProduct(ArrayRealVector v)\n        throws IllegalArgumentException {\n        return dotProduct(v.data);\n    }",
    "comment": " Compute the dot product. @param v vector with which dot product should be computed @return the scalar dot product between instance and v @exception IllegalArgumentException if v is not the same size as this ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "ArrayRealVector.dotProduct",
    "class_name": "org.apache.commons.math.linear.ArrayRealVector",
    "signature": "org.apache.commons.math.linear.ArrayRealVector.dotProduct(RealVector)",
    "snippet": "    public double dotProduct(RealVector v)\n        throws IllegalArgumentException {\n        try {\n            return dotProduct((ArrayRealVector) v);\n        } catch (ClassCastException cce) {\n            checkVectorDimensions(v);\n            double dot = 0;\n            for (int i = 0; i < data.length; i++) {\n                dot += data[i] * v.getEntry(i);\n            }\n            return dot;\n        }\n    }",
    "comment": "{@inheritDoc} */",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "ArrayRealVector.dotProduct",
    "class_name": "org.apache.commons.math.linear.ArrayRealVector",
    "signature": "org.apache.commons.math.linear.ArrayRealVector.dotProduct(double[])",
    "snippet": "    public double dotProduct(double[] v)\n        throws IllegalArgumentException {\n        checkVectorDimensions(v.length);\n        double dot = 0;\n        for (int i = 0; i < data.length; i++) {\n            dot += data[i] * v[i];\n        }\n        return dot;\n    }",
    "comment": "{@inheritDoc} */",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "ArrayRealVector.getNorm",
    "class_name": "org.apache.commons.math.linear.ArrayRealVector",
    "signature": "org.apache.commons.math.linear.ArrayRealVector.getNorm()",
    "snippet": "    public double getNorm() {\n        double sum = 0;\n        for (double a : data) {\n            sum += a * a;\n        }\n        return Math.sqrt(sum);\n    }",
    "comment": "{@inheritDoc} */",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "ArrayRealVector.subtract",
    "class_name": "org.apache.commons.math.linear.ArrayRealVector",
    "signature": "org.apache.commons.math.linear.ArrayRealVector.subtract(ArrayRealVector)",
    "snippet": "    public ArrayRealVector subtract(ArrayRealVector v)\n        throws IllegalArgumentException {\n        return (ArrayRealVector) subtract(v.data);\n    }",
    "comment": " Compute this minus v. @param v vector to be subtracted @return this + v @throws IllegalArgumentException if v is not the same size as this ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "ArrayRealVector.subtract",
    "class_name": "org.apache.commons.math.linear.ArrayRealVector",
    "signature": "org.apache.commons.math.linear.ArrayRealVector.subtract(RealVector)",
    "snippet": "    public RealVector subtract(RealVector v)\n    throws IllegalArgumentException {\n        try {\n            return subtract((ArrayRealVector) v);\n        } catch (ClassCastException cce) {\n            checkVectorDimensions(v);\n            double[] out = new double[data.length];\n            for (int i = 0; i < data.length; i++) {\n                out[i] = data[i] - v.getEntry(i);\n            }\n            return new ArrayRealVector(out);\n        }\n    }",
    "comment": "{@inheritDoc} */",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "ArrayRealVector.subtract",
    "class_name": "org.apache.commons.math.linear.ArrayRealVector",
    "signature": "org.apache.commons.math.linear.ArrayRealVector.subtract(double[])",
    "snippet": "    public RealVector subtract(double[] v)\n    throws IllegalArgumentException {\n        checkVectorDimensions(v.length);\n        double[] out = new double[data.length];\n        for (int i = 0; i < data.length; i++) {\n            out[i] = data[i] - v[i];\n        }\n        return new ArrayRealVector(out);\n    }",
    "comment": "{@inheritDoc} */",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "DefaultRealMatrixPreservingVisitor.end",
    "class_name": "org.apache.commons.math.linear.DefaultRealMatrixPreservingVisitor",
    "signature": "org.apache.commons.math.linear.DefaultRealMatrixPreservingVisitor.end()",
    "snippet": "    public double end() {\n        return 0;\n    }",
    "comment": "{@inheritDoc} */",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "DefaultRealMatrixPreservingVisitor.start",
    "class_name": "org.apache.commons.math.linear.DefaultRealMatrixPreservingVisitor",
    "signature": "org.apache.commons.math.linear.DefaultRealMatrixPreservingVisitor.start(int,int,int,int,int,int)",
    "snippet": "    public void start(int rows, int columns,\n                      int startRow, int endRow, int startColumn, int endColumn) {\n    }",
    "comment": "{@inheritDoc} */",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "EigenDecompositionImpl.EigenDecompositionImpl",
    "class_name": "org.apache.commons.math.linear.EigenDecompositionImpl",
    "signature": "org.apache.commons.math.linear.EigenDecompositionImpl.EigenDecompositionImpl(double[],double[],double)",
    "snippet": "    public EigenDecompositionImpl(final double[] main, double[] secondary,\n            final double splitTolerance)\n        throws InvalidMatrixException {\n\n        this.main      = main.clone();\n        this.secondary = secondary.clone();\n        transformer    = null;\n\n        // pre-compute some elements\n        squaredSecondary = new double[secondary.length];\n        for (int i = 0; i < squaredSecondary.length; ++i) {\n            final double s = secondary[i];\n            squaredSecondary[i] = s * s;\n        }\n\n        this.splitTolerance = splitTolerance;\n        decompose();\n\n    }",
    "comment": " Calculates the eigen decomposition of the given tridiagonal symmetric matrix. @param main the main diagonal of the matrix (will be copied) @param secondary the secondary diagonal of the matrix (will be copied) @param splitTolerance tolerance on the off-diagonal elements relative to the geometric mean to split the tridiagonal matrix (a suggested value is {@link MathUtils#SAFE_MIN}) @exception InvalidMatrixException (wrapping a {@link org.apache.commons.math.ConvergenceException} if algorithm fails to converge ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "EigenDecompositionImpl.computeGershgorinCircles",
    "class_name": "org.apache.commons.math.linear.EigenDecompositionImpl",
    "signature": "org.apache.commons.math.linear.EigenDecompositionImpl.computeGershgorinCircles()",
    "snippet": "    private void computeGershgorinCircles() {\n\n        final int m     = main.length;\n        final int lowerStart = 4 * m;\n        final int upperStart = 5 * m;\n        lowerSpectra = Double.POSITIVE_INFINITY;\n        upperSpectra = Double.NEGATIVE_INFINITY;\n        double eMax = 0;\n\n        double eCurrent = 0;\n        for (int i = 0; i < m - 1; ++i) {\n\n            final double dCurrent = main[i];\n            final double ePrevious = eCurrent;\n            eCurrent = Math.abs(secondary[i]);\n            eMax = Math.max(eMax, eCurrent);\n            final double radius = ePrevious + eCurrent;\n\n            final double lower = dCurrent - radius;\n            work[lowerStart + i] = lower;\n            lowerSpectra = Math.min(lowerSpectra, lower);\n\n            final double upper = dCurrent + radius;\n            work[upperStart + i] = upper;\n            upperSpectra = Math.max(upperSpectra, upper);\n\n        }\n\n        final double dCurrent = main[m - 1];\n        final double lower = dCurrent - eCurrent;\n        work[lowerStart + m - 1] = lower;\n        lowerSpectra = Math.min(lowerSpectra, lower);\n        final double upper = dCurrent + eCurrent;\n        work[upperStart + m - 1] = upper;\n        upperSpectra = Math.max(upperSpectra, upper);\n        minPivot = MathUtils.SAFE_MIN * Math.max(1.0, eMax * eMax);\n\n    }",
    "comment": " Compute the Gershgorin circles for all rows. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "EigenDecompositionImpl.computeShiftIncrement",
    "class_name": "org.apache.commons.math.linear.EigenDecompositionImpl",
    "signature": "org.apache.commons.math.linear.EigenDecompositionImpl.computeShiftIncrement(int,int,int)",
    "snippet": "    private void computeShiftIncrement(final int start, final int end, final int deflated) {\n\n        final double cnst1 = 0.563;\n        final double cnst2 = 1.010;\n        final double cnst3 = 1.05;\n\n        // a negative dMin forces the shift to take that absolute value\n        // tType records the type of shift.\n        if (dMin <= 0.0) {\n            tau = -dMin;\n            tType = -1;\n            return;\n        }\n\n        int nn = 4 * end + pingPong - 1;\n        switch (deflated) {\n\n        case 0 : // no realEigenvalues deflated.\n            if (dMin == dN || dMin == dN1) {\n\n                double b1 = Math.sqrt(work[nn - 3]) * Math.sqrt(work[nn - 5]);\n                double b2 = Math.sqrt(work[nn - 7]) * Math.sqrt(work[nn - 9]);\n                double a2 = work[nn - 7] + work[nn - 5];\n\n                if (dMin == dN && dMin1 == dN1) {\n                    // cases 2 and 3.\n                    final double gap2 = dMin2 - a2 - dMin2 * 0.25;\n                    final double gap1 = a2 - dN - ((gap2 > 0.0 && gap2 > b2) ? (b2 / gap2) * b2 : (b1 + b2));\n                    if (gap1 > 0.0 && gap1 > b1) {\n                        tau   = Math.max(dN - (b1 / gap1) * b1, 0.5 * dMin);\n                        tType = -2;\n                    } else {\n                        double s = 0.0;\n                        if (dN > b1) {\n                            s = dN - b1;\n                        }\n                        if (a2 > (b1 + b2)) {\n                            s = Math.min(s, a2 - (b1 + b2));\n                        }\n                        tau   = Math.max(s, 0.333 * dMin);\n                        tType = -3;\n                    }\n                } else {\n                    // case 4.\n                    tType = -4;\n                    double s = 0.25 * dMin;\n                    double gam;\n                    int np;\n                    if (dMin == dN) {\n                        gam = dN;\n                        a2 = 0.0;\n                        if (work[nn - 5]  >  work[nn - 7]) {\n                            return;\n                        }\n                        b2 = work[nn - 5] / work[nn - 7];\n                        np = nn - 9;\n                    } else {\n                        np = nn - 2 * pingPong;\n                        b2 = work[np - 2];\n                        gam = dN1;\n                        if (work[np - 4]  >  work[np - 2]) {\n                            return;\n                        }\n                        a2 = work[np - 4] / work[np - 2];\n                        if (work[nn - 9]  >  work[nn - 11]) {\n                            return;\n                        }\n                        b2 = work[nn - 9] / work[nn - 11];\n                        np = nn - 13;\n                    }\n\n                    // approximate contribution to norm squared from i < nn-1.\n                    a2 = a2 + b2;\n                    for (int i4 = np; i4 >= 4 * start + 2 + pingPong; i4 -= 4) {\n                        if(b2 == 0.0) {\n                            break;\n                        }\n                        b1 = b2;\n                        if (work[i4]  >  work[i4 - 2]) {\n                            return;\n                        }\n                        b2 = b2 * (work[i4] / work[i4 - 2]);\n                        a2 = a2 + b2;\n                        if (100 * Math.max(b2, b1) < a2 || cnst1 < a2) {\n                            break;\n                        }\n                    }\n                    a2 = cnst3 * a2;\n\n                    // rayleigh quotient residual bound.\n                    if (a2 < cnst1) {\n                        s = gam * (1 - Math.sqrt(a2)) / (1 + a2);\n                    }\n                    tau = s;\n\n                }\n            } else if (dMin == dN2) {\n\n                // case 5.\n                tType = -5;\n                double s = 0.25 * dMin;\n\n                // compute contribution to norm squared from i > nn-2.\n                final int np = nn - 2 * pingPong;\n                double b1 = work[np - 2];\n                double b2 = work[np - 6];\n                final double gam = dN2;\n                if (work[np - 8] > b2 || work[np - 4] > b1) {\n                    return;\n                }\n                double a2 = (work[np - 8] / b2) * (1 + work[np - 4] / b1);\n\n                // approximate contribution to norm squared from i < nn-2.\n                if (end - start > 3) {\n                    b2 = work[nn - 13] / work[nn - 15];\n                    a2 = a2 + b2;\n                    for (int i4 = nn - 17; i4 >= 4 * start + 2 + pingPong; i4 -= 4) {\n                        if (b2 == 0.0) {\n                            break;\n                        }\n                        b1 = b2;\n                        if (work[i4]  >  work[i4 - 2]) {\n                            return;\n                        }\n                        b2 = b2 * (work[i4] / work[i4 - 2]);\n                        a2 = a2 + b2;\n                        if (100 * Math.max(b2, b1) < a2 || cnst1 < a2)  {\n                            break;\n                        }\n                    }\n                    a2 = cnst3 * a2;\n                }\n\n                if (a2 < cnst1) {\n                    tau = gam * (1 - Math.sqrt(a2)) / (1 + a2);\n                } else {\n                    tau = s;\n                }\n\n            } else {\n\n                // case 6, no information to guide us.\n                if (tType == -6) {\n                    g += 0.333 * (1 - g);\n                } else if (tType == -18) {\n                    g = 0.25 * 0.333;\n                } else {\n                    g = 0.25;\n                }\n                tau   = g * dMin;\n                tType = -6;\n\n            }\n            break;\n\n        case 1 : // one eigenvalue just deflated. use dMin1, dN1 for dMin and dN.\n            if (dMin1 == dN1 && dMin2 == dN2) {\n\n                // cases 7 and 8.\n                tType = -7;\n                double s = 0.333 * dMin1;\n                if (work[nn - 5] > work[nn - 7]) {\n                    return;\n                }\n                double b1 = work[nn - 5] / work[nn - 7];\n                double b2 = b1;\n                if (b2 != 0.0) {\n                    for (int i4 = 4 * end - 10 + pingPong; i4 >= 4 * start + 2 + pingPong; i4 -= 4) {\n                        final double oldB1 = b1;\n                        if (work[i4] > work[i4 - 2]) {\n                            return;\n                        }\n                        b1 = b1 * (work[i4] / work[i4 - 2]);\n                        b2 = b2 + b1;\n                        if (100 * Math.max(b1, oldB1) < b2) {\n                            break;\n                        }\n                    }\n                }\n                b2 = Math.sqrt(cnst3 * b2);\n                final double a2 = dMin1 / (1 + b2 * b2);\n                final double gap2 = 0.5 * dMin2 - a2;\n                if (gap2 > 0.0 && gap2 > b2 * a2) {\n                    tau = Math.max(s, a2 * (1 - cnst2 * a2 * (b2 / gap2) * b2));\n                } else {\n                    tau = Math.max(s, a2 * (1 - cnst2 * b2));\n                    tType = -8;\n                }\n            } else {\n\n                // case 9.\n                tau = 0.25 * dMin1;\n                if (dMin1 == dN1) {\n                    tau = 0.5 * dMin1;\n                }\n                tType = -9;\n            }\n            break;\n\n        case 2 : // two realEigenvalues deflated. use dMin2, dN2 for dMin and dN.\n\n            // cases 10 and 11.\n            if (dMin2 == dN2 && 2 * work[nn - 5] < work[nn - 7]) {\n                tType = -10;\n                final double s = 0.333 * dMin2;\n                if (work[nn - 5] > work[nn - 7]) {\n                    return;\n                }\n                double b1 = work[nn - 5] / work[nn - 7];\n                double b2 = b1;\n                if (b2 != 0.0){\n                    for (int i4 = 4 * end - 9 + pingPong; i4 >= 4 * start + 2 + pingPong; i4 -= 4) {\n                        if (work[i4] > work[i4 - 2]) {\n                            return;\n                        }\n                        b1 *= work[i4] / work[i4 - 2];\n                        b2 += b1;\n                        if (100 * b1 < b2) {\n                            break;\n                        }\n                    }\n                }\n                b2 = Math.sqrt(cnst3 * b2);\n                final double a2 = dMin2 / (1 + b2 * b2);\n                final double gap2 = work[nn - 7] + work[nn - 9] -\n                Math.sqrt(work[nn - 11]) * Math.sqrt(work[nn - 9]) - a2;\n                if (gap2 > 0.0 && gap2 > b2 * a2) {\n                    tau = Math.max(s, a2 * (1 - cnst2 * a2 * (b2 / gap2) * b2));\n                } else {\n                    tau = Math.max(s, a2 * (1 - cnst2 * b2));\n                }\n            } else {\n                tau   = 0.25 * dMin2;\n                tType = -11;\n            }\n            break;\n\n        default : // case 12, more than two realEigenvalues deflated. no information.\n            tau   = 0.0;\n            tType = -12;\n        }\n\n    }",
    "comment": " Compute the shift increment as an estimate of the smallest eigenvalue. <p>This implementation is a translation of the LAPACK routine DLAZQ4.</p> @param start start index @param end end index @param deflated number of realEigenvalues just deflated ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "EigenDecompositionImpl.computeSplits",
    "class_name": "org.apache.commons.math.linear.EigenDecompositionImpl",
    "signature": "org.apache.commons.math.linear.EigenDecompositionImpl.computeSplits()",
    "snippet": "    private List<Integer> computeSplits() {\n\n        final List<Integer> list = new ArrayList<Integer>();\n\n        // splitting preserving relative accuracy\n        double absDCurrent = Math.abs(main[0]);\n        for (int i = 0; i < secondary.length; ++i) {\n            final double absDPrevious = absDCurrent;\n            absDCurrent = Math.abs(main[i + 1]);\n            final double max = splitTolerance * Math.sqrt(absDPrevious * absDCurrent);\n            if (Math.abs(secondary[i]) <= max) {\n                list.add(i + 1);\n                secondary[i] = 0;\n                squaredSecondary[i] = 0;\n            }\n        }\n\n        list.add(secondary.length + 1);\n        return list;\n\n    }",
    "comment": " Compute splitting points. @return list of indices after matrix can be split ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "EigenDecompositionImpl.countEigenValues",
    "class_name": "org.apache.commons.math.linear.EigenDecompositionImpl",
    "signature": "org.apache.commons.math.linear.EigenDecompositionImpl.countEigenValues(double,int,int)",
    "snippet": "    private int countEigenValues(final double t, final int index, final int n) {\n        double ratio = main[index] - t;\n        int count = (ratio > 0) ? 0 : 1;\n        for (int i = 1; i < n; ++i) {\n            ratio = main[index + i] - squaredSecondary[index + i - 1] / ratio - t;\n            if (ratio <= 0) {\n                ++count;\n            }\n        }\n        return count;\n    }",
    "comment": " Count the number of realEigenvalues below a point. @param t value below which we must count the number of realEigenvalues @param index index of the first row of the block @param n number of rows of the block @return number of realEigenvalues smaller than t ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "EigenDecompositionImpl.decompose",
    "class_name": "org.apache.commons.math.linear.EigenDecompositionImpl",
    "signature": "org.apache.commons.math.linear.EigenDecompositionImpl.decompose()",
    "snippet": "    private void decompose() {\n\n        cachedV  = null;\n        cachedD  = null;\n        cachedVt = null;\n        work     = new double[6 * main.length];\n\n        // compute the Gershgorin circles\n        computeGershgorinCircles();\n\n        // find all the realEigenvalues\n        findEigenvalues();\n\n        // we will search for eigenvectors only if required\n        eigenvectors = null;\n\n    }",
    "comment": " Decompose a tridiagonal symmetric matrix. @exception InvalidMatrixException (wrapping a {@link org.apache.commons.math.ConvergenceException} if algorithm fails to converge ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "EigenDecompositionImpl.dqd",
    "class_name": "org.apache.commons.math.linear.EigenDecompositionImpl",
    "signature": "org.apache.commons.math.linear.EigenDecompositionImpl.dqd(int,int)",
    "snippet": "    private void dqd(final int start, final int end) {\n\n        eMin = work[4 * start + pingPong + 4];\n        double d = work[4 * start + pingPong];\n        dMin = d;\n\n        if (pingPong == 0) {\n            for (int j4 = 4 * start + 3; j4 < 4 * (end - 3); j4 += 4) {\n                work[j4 - 2] = d + work[j4 - 1];\n                if (work[j4 - 2] == 0.0) {\n                    work[j4] = 0.0;\n                    d = work[j4 + 1];\n                    dMin = d;\n                    eMin = 0.0;\n                } else if ((MathUtils.SAFE_MIN * work[j4 + 1] < work[j4 - 2]) &&\n                           (MathUtils.SAFE_MIN * work[j4 - 2] < work[j4 + 1])) {\n                    final double tmp = work[j4 + 1] / work[j4 - 2];\n                    work[j4] = work[j4 - 1] * tmp;\n                    d *= tmp;\n                } else {\n                    work[j4] = work[j4 + 1] * (work[j4 - 1] / work[j4 - 2]);\n                    d *= work[j4 + 1] / work[j4 - 2];\n                }\n                dMin = Math.min(dMin, d);\n                eMin = Math.min(eMin, work[j4]);\n            }\n        } else {\n            for (int j4 = 4 * start + 3; j4 < 4 * (end - 3); j4 += 4) {\n                work[j4 - 3] = d + work[j4];\n                if (work[j4 - 3] == 0.0) {\n                    work[j4 - 1] = 0.0;\n                    d = work[j4 + 2];\n                    dMin = d;\n                    eMin = 0.0;\n                } else if ((MathUtils.SAFE_MIN * work[j4 + 2] < work[j4 - 3]) &&\n                           (MathUtils.SAFE_MIN * work[j4 - 3] < work[j4 + 2])) {\n                    final double tmp = work[j4 + 2] / work[j4 - 3];\n                    work[j4 - 1] = work[j4] * tmp;\n                    d *= tmp;\n                } else {\n                    work[j4 - 1] = work[j4 + 2] * (work[j4] / work[j4 - 3]);\n                    d *= work[j4 + 2] / work[j4 - 3];\n                }\n                dMin = Math.min(dMin, d);\n                eMin = Math.min(eMin, work[j4 - 1]);\n            }\n        }\n\n        // Unroll last two steps\n        dN2   = d;\n        dMin2 = dMin;\n        int j4 = 4 * (end - 2) - pingPong - 1;\n        int j4p2 = j4 + 2 * pingPong - 1;\n        work[j4 - 2] = dN2 + work[j4p2];\n        if (work[j4 - 2] == 0.0) {\n            work[j4] = 0.0;\n            dN1  = work[j4p2 + 2];\n            dMin = dN1;\n            eMin = 0.0;\n        } else if ((MathUtils.SAFE_MIN * work[j4p2 + 2] < work[j4 - 2]) &&\n                   (MathUtils.SAFE_MIN * work[j4 - 2] < work[j4p2 + 2])) {\n            final double tmp = work[j4p2 + 2] / work[j4 - 2];\n            work[j4] = work[j4p2] * tmp;\n            dN1 = dN2 * tmp;\n        } else {\n            work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]);\n            dN1 = work[j4p2 + 2] * (dN2 / work[j4 - 2]);\n        }\n        dMin = Math.min(dMin, dN1);\n\n        dMin1 = dMin;\n        j4 = j4 + 4;\n        j4p2 = j4 + 2 * pingPong - 1;\n        work[j4 - 2] = dN1 + work[j4p2];\n        if (work[j4 - 2] == 0.0) {\n            work[j4] = 0.0;\n            dN   = work[j4p2 + 2];\n            dMin = dN;\n            eMin = 0.0;\n        } else if ((MathUtils.SAFE_MIN * work[j4p2 + 2] < work[j4 - 2]) &&\n                   (MathUtils.SAFE_MIN * work[j4 - 2] < work[j4p2 + 2])) {\n            final double tmp = work[j4p2 + 2] / work[j4 - 2];\n            work[j4] = work[j4p2] * tmp;\n            dN = dN1 * tmp;\n        } else {\n            work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]);\n            dN = work[j4p2 + 2] * (dN1 / work[j4 - 2]);\n        }\n        dMin = Math.min(dMin, dN);\n\n        work[j4 + 2] = dN;\n        work[4 * end - pingPong - 1] = eMin;\n\n    }",
    "comment": " Perform a dqd step. <p>This implementation is a translation of the LAPACK routine DLASQ6.</p> @param start start index @param end end index ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "EigenDecompositionImpl.dqds",
    "class_name": "org.apache.commons.math.linear.EigenDecompositionImpl",
    "signature": "org.apache.commons.math.linear.EigenDecompositionImpl.dqds(int,int)",
    "snippet": "    private void dqds(final int start, final int end) {\n\n        eMin = work[4 * start + pingPong + 4];\n        double d = work[4 * start + pingPong] - tau;\n        dMin = d;\n        dMin1 = -work[4 * start + pingPong];\n\n        if (pingPong == 0) {\n            for (int j4 = 4 * start + 3; j4 <= 4 * (end - 3); j4 += 4) {\n                work[j4 - 2] = d + work[j4 - 1];\n                final double tmp = work[j4 + 1] / work[j4 - 2];\n                d = d * tmp - tau;\n                dMin = Math.min(dMin, d);\n                work[j4] = work[j4 - 1] * tmp;\n                eMin = Math.min(work[j4], eMin);\n            }\n        } else {\n            for (int j4 = 4 * start + 3; j4 <= 4 * (end - 3); j4 += 4) {\n                work[j4 - 3] = d + work[j4];\n                final double tmp = work[j4 + 2] / work[j4 - 3];\n                d = d * tmp - tau;\n                dMin = Math.min(dMin, d);\n                work[j4 - 1] = work[j4] * tmp;\n                eMin = Math.min(work[j4 - 1], eMin);\n            }\n        }\n\n        // unroll last two steps.\n        dN2 = d;\n        dMin2 = dMin;\n        int j4 = 4 * (end - 2) - pingPong - 1;\n        int j4p2 = j4 + 2 * pingPong - 1;\n        work[j4 - 2] = dN2 + work[j4p2];\n        work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]);\n        dN1 = work[j4p2 + 2] * (dN2 / work[j4 - 2]) - tau;\n        dMin = Math.min(dMin, dN1);\n\n        dMin1 = dMin;\n        j4 = j4 + 4;\n        j4p2 = j4 + 2 * pingPong - 1;\n        work[j4 - 2] = dN1 + work[j4p2];\n        work[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]);\n        dN = work[j4p2 + 2] * (dN1 / work[j4 - 2]) - tau;\n        dMin = Math.min(dMin, dN);\n\n        work[j4 + 2] = dN;\n        work[4 * end - pingPong - 1] = eMin;\n\n    }",
    "comment": " Perform a dqds step, using current shift increment. <p>This implementation is a translation of the LAPACK routine DLASQ5.</p> @param start start index @param end end index ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "EigenDecompositionImpl.eigenvaluesRange",
    "class_name": "org.apache.commons.math.linear.EigenDecompositionImpl",
    "signature": "org.apache.commons.math.linear.EigenDecompositionImpl.eigenvaluesRange(int,int)",
    "snippet": "    private double[] eigenvaluesRange(final int index, final int n) {\n\n        // find the bounds of the spectra of the local block\n        final int lowerStart = 4 * main.length;\n        final int upperStart = 5 * main.length;\n        double lower = Double.POSITIVE_INFINITY;\n        double upper = Double.NEGATIVE_INFINITY;\n        for (int i = 0; i < n; ++i) {\n            lower = Math.min(lower, work[lowerStart + index +i]);\n            upper = Math.max(upper, work[upperStart + index +i]);\n        }\n\n        // set thresholds\n        final double tNorm = Math.max(Math.abs(lower), Math.abs(upper));\n        final double relativeTolerance = Math.sqrt(MathUtils.EPSILON);\n        final double absoluteTolerance = 4 * minPivot;\n        final int maxIter =\n            2 + (int) ((Math.log(tNorm + minPivot) - Math.log(minPivot)) / Math.log(2.0));\n        final double margin = 2 * (tNorm * MathUtils.EPSILON * n + 2 * minPivot);\n\n        // search lower eigenvalue\n        double left  = lower - margin;\n        double right = upper + margin;\n        for (int i = 0; i < maxIter; ++i) {\n\n            final double range = right - left;\n            if ((range < absoluteTolerance) ||\n                (range < relativeTolerance * Math.max(Math.abs(left), Math.abs(right)))) {\n                // search has converged\n                break;\n            }\n\n            final double middle = 0.5 * (left + right);\n            if (countEigenValues(middle, index, n) >= 1) {\n                right = middle;\n            } else {\n                left = middle;\n            }\n\n        }\n        lower = Math.max(lower, left - 100 * MathUtils.EPSILON * Math.abs(left));\n\n        // search upper eigenvalue\n        left  = lower - margin;\n        right = upper + margin;\n        for (int i = 0; i < maxIter; ++i) {\n\n            final double range = right - left;\n            if ((range < absoluteTolerance) ||\n                (range < relativeTolerance * Math.max(Math.abs(left), Math.abs(right)))) {\n                // search has converged\n                break;\n            }\n\n            final double middle = 0.5 * (left + right);\n            if (countEigenValues(middle, index, n) >= n) {\n                right = middle;\n            } else {\n                left = middle;\n            }\n\n        }\n        upper = Math.min(upper, right + 100 * MathUtils.EPSILON * Math.abs(right));\n\n        return new double[] { lower, upper };\n\n    }",
    "comment": " Compute an interval containing all realEigenvalues of a block. @param index index of the first row of the block @param n number of rows of the block @return an interval containing the realEigenvalues ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "EigenDecompositionImpl.findEigenVectors",
    "class_name": "org.apache.commons.math.linear.EigenDecompositionImpl",
    "signature": "org.apache.commons.math.linear.EigenDecompositionImpl.findEigenVectors()",
    "snippet": "    private void findEigenVectors() {\n\n        final int m = main.length;\n        eigenvectors = new ArrayRealVector[m];\n\n        // perform an initial non-shifted LDLt decomposition\n        final double[] d = new double[m];\n        final double[] l = new double[m - 1];\n        // avoid zero divide on indefinite matrix\n        final double mu = realEigenvalues[m-1] <= 0 && realEigenvalues[0] > 0 ? 0.5-realEigenvalues[m-1] : 0;\n        double di = main[0]+mu;\n        d[0] = di;\n        for (int i = 1; i < m; ++i) {\n            final double eiM1  = secondary[i - 1];\n            final double ratio = eiM1 / di;\n            di       = main[i] - eiM1 * ratio + mu;\n            l[i - 1] = ratio;\n            d[i]     = di;\n        }\n\n        // compute eigenvectors\n        for (int i = 0; i < m; ++i) {\n            eigenvectors[i] = findEigenvector(realEigenvalues[i]+mu, d, l);\n        }\n\n    }",
    "comment": " Find eigenvectors. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "EigenDecompositionImpl.findEigenvalues",
    "class_name": "org.apache.commons.math.linear.EigenDecompositionImpl",
    "signature": "org.apache.commons.math.linear.EigenDecompositionImpl.findEigenvalues()",
    "snippet": "    private void findEigenvalues()\n        throws InvalidMatrixException {\n\n        // compute splitting points\n        List<Integer> splitIndices = computeSplits();\n\n        // find realEigenvalues in each block\n        realEigenvalues = new double[main.length];\n        imagEigenvalues = new double[main.length];\n        int begin = 0;\n        for (final int end : splitIndices) {\n            final int n = end - begin;\n            switch (n) {\n\n            case 1:\n                // apply dedicated method for dimension 1\n                process1RowBlock(begin);\n                break;\n\n            case 2:\n                // apply dedicated method for dimension 2\n                process2RowsBlock(begin);\n                break;\n\n            case 3:\n                // apply dedicated method for dimension 3\n                process3RowsBlock(begin);\n                break;\n\n            default:\n\n                // choose an initial shift for LDL<sup>T</sup> decomposition\n                final double[] range       = eigenvaluesRange(begin, n);\n                final double oneFourth     = 0.25 * (3 * range[0] + range[1]);\n                final int oneFourthCount   = countEigenValues(oneFourth, begin, n);\n                final double threeFourth   = 0.25 * (range[0] + 3 * range[1]);\n                final int threeFourthCount = countEigenValues(threeFourth, begin, n);\n                final boolean chooseLeft   = (oneFourthCount - 1) >= (n - threeFourthCount);\n                final double lambda        = chooseLeft ? range[0] : range[1];\n\n                tau = (range[1] - range[0]) * MathUtils.EPSILON * n + 2 * minPivot;\n\n                // decompose T-&lambda;I as LDL<sup>T</sup>\n                ldlTDecomposition(lambda, begin, n);\n\n                // apply general dqd/dqds method\n                processGeneralBlock(n);\n\n                // extract realEigenvalues\n                if (chooseLeft) {\n                    for (int i = 0; i < n; ++i) {\n                        realEigenvalues[begin + i] = lambda + work[4 * i];\n                    }\n                } else {\n                    for (int i = 0; i < n; ++i) {\n                        realEigenvalues[begin + i] = lambda - work[4 * i];\n                    }\n                }\n\n            }\n            begin = end;\n        }\n\n        // sort the realEigenvalues in decreasing order\n        Arrays.sort(realEigenvalues);\n        int j = realEigenvalues.length - 1;\n        for (int i = 0; i < j; ++i) {\n            final double tmp = realEigenvalues[i];\n            realEigenvalues[i] = realEigenvalues[j];\n            realEigenvalues[j] = tmp;\n            --j;\n        }\n\n    }",
    "comment": " Find the realEigenvalues. @exception InvalidMatrixException if a block cannot be diagonalized ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "EigenDecompositionImpl.findEigenvector",
    "class_name": "org.apache.commons.math.linear.EigenDecompositionImpl",
    "signature": "org.apache.commons.math.linear.EigenDecompositionImpl.findEigenvector(double,double[],double[])",
    "snippet": "    private ArrayRealVector findEigenvector(final double eigenvalue,\n                                           final double[] d, final double[] l) {\n\n        // compute the LDLt and UDUt decompositions of the\n        // perfectly shifted tridiagonal matrix\n        final int m = main.length;\n        stationaryQuotientDifferenceWithShift(d, l, eigenvalue);\n        progressiveQuotientDifferenceWithShift(d, l, eigenvalue);\n\n        // select the twist index leading to\n        // the least diagonal element in the twisted factorization\n        int r = m - 1;\n        double minG = Math.abs(work[6 * r] + work[6 * r + 3] + eigenvalue);\n        int sixI = 0;\n        for (int i = 0; i < m - 1; ++i) {\n            final double absG = Math.abs(work[sixI] + d[i] * work[sixI + 9] / work[sixI + 10]);\n            if (absG < minG) {\n                r = i;\n                minG = absG;\n            }\n            sixI += 6;\n        }\n\n        // solve the singular system by ignoring the equation\n        // at twist index and propagating upwards and downwards\n        double[] eigenvector = new double[m];\n        double n2 = 1;\n        eigenvector[r] = 1;\n        double z = 1;\n        for (int i = r - 1; i >= 0; --i) {\n            z *= -work[6 * i + 2];\n            eigenvector[i] = z;\n            n2 += z * z;\n        }\n        z = 1;\n        for (int i = r + 1; i < m; ++i) {\n            z *= -work[6 * i - 1];\n            eigenvector[i] = z;\n            n2 += z * z;\n        }\n\n        // normalize vector\n        final double inv = 1.0 / Math.sqrt(n2);\n        for (int i = 0; i < m; ++i) {\n            eigenvector[i] *= inv;\n        }\n\n        return (transformer == null) ?\n               new ArrayRealVector(eigenvector, false) :\n               new ArrayRealVector(transformer.getQ().operate(eigenvector), false);\n\n    }",
    "comment": " Find an eigenvector corresponding to an eigenvalue, using bidiagonals. <p>This method corresponds to algorithm X from Dhillon's thesis.</p>  @param eigenvalue eigenvalue for which eigenvector is desired @param d diagonal elements of the initial non-shifted D matrix @param l off-diagonal elements of the initial non-shifted L matrix @return an eigenvector ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "EigenDecompositionImpl.flipIfWarranted",
    "class_name": "org.apache.commons.math.linear.EigenDecompositionImpl",
    "signature": "org.apache.commons.math.linear.EigenDecompositionImpl.flipIfWarranted(int,int)",
    "snippet": "    private boolean flipIfWarranted(final int n, final int step) {\n        if (1.5 * work[pingPong] < work[4 * (n - 1) + pingPong]) {\n            // flip array\n            int j = 4 * n - 1;\n            for (int i = 0; i < j; i += 4) {\n                for (int k = 0; k < 4; k += step) {\n                    final double tmp = work[i + k];\n                    work[i + k] = work[j - k];\n                    work[j - k] = tmp;\n                }\n                j -= 4;\n            }\n            return true;\n        }\n        return false;\n    }",
    "comment": " Flip qd array if warranted. @param n number of rows in the block @param step within the array (1 for flipping all elements, 2 for flipping only every other element) @return true if qd array was flipped ",
    "is_bug": true,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "EigenDecompositionImpl.getEigenvector",
    "class_name": "org.apache.commons.math.linear.EigenDecompositionImpl",
    "signature": "org.apache.commons.math.linear.EigenDecompositionImpl.getEigenvector(int)",
    "snippet": "    public RealVector getEigenvector(final int i)\n        throws InvalidMatrixException, ArrayIndexOutOfBoundsException {\n        if (eigenvectors == null) {\n            findEigenVectors();\n        }\n        return eigenvectors[i].copy();\n    }",
    "comment": "{@inheritDoc} */",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "EigenDecompositionImpl.getRealEigenvalues",
    "class_name": "org.apache.commons.math.linear.EigenDecompositionImpl",
    "signature": "org.apache.commons.math.linear.EigenDecompositionImpl.getRealEigenvalues()",
    "snippet": "    public double[] getRealEigenvalues()\n        throws InvalidMatrixException {\n        return realEigenvalues.clone();\n    }",
    "comment": "{@inheritDoc} */",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "EigenDecompositionImpl.goodStep",
    "class_name": "org.apache.commons.math.linear.EigenDecompositionImpl",
    "signature": "org.apache.commons.math.linear.EigenDecompositionImpl.goodStep(int,int)",
    "snippet": "    private int goodStep(final int start, final int end) {\n\n        g = 0.0;\n\n        // step 1: accepting realEigenvalues\n        int deflatedEnd = end;\n        for (boolean deflating = true; deflating;) {\n\n            if (start >= deflatedEnd) {\n                // the array has been completely deflated\n                return deflatedEnd;\n            }\n\n            final int k = 4 * deflatedEnd + pingPong - 1;\n\n            if ((start == deflatedEnd - 1) ||\n                ((start != deflatedEnd - 2) &&\n                 ((work[k - 5] <= TOLERANCE_2 * (sigma + work[k - 3])) ||\n                  (work[k - 2 * pingPong - 4] <= TOLERANCE_2 * work[k - 7])))) {\n\n                // one eigenvalue found, deflate array\n                work[4 * deflatedEnd - 4] = sigma + work[4 * deflatedEnd - 4 + pingPong];\n                deflatedEnd -= 1;\n\n            } else if ((start == deflatedEnd - 2) ||\n                (work[k - 9] <= TOLERANCE_2 * sigma) ||\n                (work[k - 2 * pingPong - 8] <= TOLERANCE_2 * work[k - 11])) {\n\n                // two realEigenvalues found, deflate array\n                if (work[k - 3] > work[k - 7]) {\n                    final double tmp = work[k - 3];\n                    work[k - 3] = work[k - 7];\n                    work[k - 7] = tmp;\n                }\n\n                if (work[k - 5] > TOLERANCE_2 * work[k - 3]) {\n                    double t = 0.5 * ((work[k - 7] - work[k - 3]) + work[k - 5]);\n                    double s = work[k - 3] * (work[k - 5] / t);\n                    if (s <= t) {\n                        s = work[k - 3] * work[k - 5] / (t * (1 + Math.sqrt(1 + s / t)));\n                    } else {\n                        s = work[k - 3] * work[k - 5] / (t + Math.sqrt(t * (t + s)));\n                    }\n                    t = work[k - 7] + (s + work[k - 5]);\n                    work[k - 3] *= work[k - 7] / t;\n                    work[k - 7]  = t;\n                }\n                work[4 * deflatedEnd - 8] = sigma + work[k - 7];\n                work[4 * deflatedEnd - 4] = sigma + work[k - 3];\n                deflatedEnd -= 2;\n            } else {\n\n                // no more realEigenvalues found, we need to iterate\n                deflating = false;\n\n            }\n\n        }\n\n        final int l = 4 * deflatedEnd + pingPong - 1;\n\n        // step 2: flip array if needed\n        if ((dMin <= 0) || (deflatedEnd < end)) {\n            if (flipIfWarranted(deflatedEnd, 1)) {\n                dMin2 = Math.min(dMin2, work[l - 1]);\n                work[l - 1] =\n                    Math.min(work[l - 1],\n                             Math.min(work[3 + pingPong], work[7 + pingPong]));\n                work[l - 2 * pingPong] =\n                    Math.min(work[l - 2 * pingPong],\n                             Math.min(work[6 + pingPong], work[6 + pingPong]));\n                qMax  = Math.max(qMax, Math.max(work[3 + pingPong], work[7 + pingPong]));\n                dMin  = -0.0;\n            }\n        }\n\n        if ((dMin < 0) ||\n            (MathUtils.SAFE_MIN * qMax < Math.min(work[l - 1],\n                                                  Math.min(work[l - 9],\n                                                           dMin2 + work[l - 2 * pingPong])))) {\n            // step 3: choose a shift\n            computeShiftIncrement(start, deflatedEnd, end - deflatedEnd);\n\n            // step 4a: dqds\n            for (boolean loop = true; loop;) {\n\n                // perform one dqds step with the chosen shift\n                dqds(start, deflatedEnd);\n\n                // check result of the dqds step\n                if ((dMin >= 0) && (dMin1 > 0)) {\n                    // the shift was good\n                    updateSigma(tau);\n                    return deflatedEnd;\n                } else if ((dMin < 0.0) &&\n                           (dMin1 > 0.0) &&\n                           (work[4 * deflatedEnd - 5 - pingPong] < TOLERANCE * (sigma + dN1)) &&\n                           (Math.abs(dN) < TOLERANCE * sigma)) {\n                   // convergence hidden by negative DN.\n                    work[4 * deflatedEnd - 3 - pingPong] = 0.0;\n                    dMin = 0.0;\n                    updateSigma(tau);\n                    return deflatedEnd;\n                } else if (dMin < 0.0) {\n                    // tau too big. Select new tau and try again.\n                    if (tType < -22) {\n                        // failed twice. Play it safe.\n                        tau = 0.0;\n                    } else if (dMin1 > 0.0) {\n                        // late failure. Gives excellent shift.\n                        tau = (tau + dMin) * (1.0 - 2.0 * MathUtils.EPSILON);\n                        tType -= 11;\n                    } else {\n                        // early failure. Divide by 4.\n                        tau *= 0.25;\n                        tType -= 12;\n                    }\n                } else if (Double.isNaN(dMin)) {\n                    tau = 0.0;\n                } else {\n                    // possible underflow. Play it safe.\n                    loop = false;\n                }\n            }\n\n        }\n\n        // perform a dqd step (i.e. no shift)\n        dqd(start, deflatedEnd);\n\n        return deflatedEnd;\n\n    }",
    "comment": " Perform one \"good\" dqd/dqds step. <p>This implementation is based on Beresford N. Parlett and Osni A. Marques paper <a href=\"http://www.netlib.org/lapack/lawnspdf/lawn155.pdf\">An Implementation of the dqds Algorithm (Positive Case)</a> and on the corresponding LAPACK routine DLAZQ3.</p> @param start start index @param end end index @return new end (maybe deflated) ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "EigenDecompositionImpl.initialSplits",
    "class_name": "org.apache.commons.math.linear.EigenDecompositionImpl",
    "signature": "org.apache.commons.math.linear.EigenDecompositionImpl.initialSplits(int)",
    "snippet": "    private void initialSplits(final int n) {\n\n        pingPong = 0;\n        for (int k = 0; k < 2; ++k) {\n\n            // apply Li's reverse test\n            double d = work[4 * (n - 1) + pingPong];\n            for (int i = 4 * (n - 2) + pingPong; i >= 0; i -= 4) {\n                if (work[i + 2] <= TOLERANCE_2 * d) {\n                    work[i + 2] = -0.0;\n                    d = work[i];\n                } else {\n                    d *= work[i] / (d + work[i + 2]);\n                }\n            }\n\n            // apply dqd plus Li's forward test.\n            d = work[pingPong];\n            for (int i = 2 + pingPong; i < 4 * n - 2; i += 4) {\n                final int j = i - 2 * pingPong - 1;\n                work[j] = d + work[i];\n                if (work[i] <= TOLERANCE_2 * d) {\n                    work[i]     = -0.0;\n                    work[j]     = d;\n                    work[j + 2] = 0.0;\n                    d = work[i + 2];\n                } else if ((MathUtils.SAFE_MIN * work[i + 2] < work[j]) &&\n                           (MathUtils.SAFE_MIN * work[j] < work[i + 2])) {\n                    final double tmp = work[i + 2] / work[j];\n                    work[j + 2] = work[i] * tmp;\n                    d *= tmp;\n                } else {\n                    work[j + 2] = work[i + 2] * (work[i] / work[j]);\n                    d *= work[i + 2] / work[j];\n               }\n            }\n            work[4 * n - 3 - pingPong] = d;\n\n            // from ping to pong\n            pingPong = 1 - pingPong;\n\n        }\n\n    }",
    "comment": " Perform two iterations with Li's tests for initial splits. @param n number of rows of the matrix to process ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "EigenDecompositionImpl.ldlTDecomposition",
    "class_name": "org.apache.commons.math.linear.EigenDecompositionImpl",
    "signature": "org.apache.commons.math.linear.EigenDecompositionImpl.ldlTDecomposition(double,int,int)",
    "snippet": "    private void ldlTDecomposition(final double lambda, final int index, final int n) {\n        double di = main[index] - lambda;\n        work[0] = Math.abs(di);\n        for (int i = 1; i < n; ++i) {\n            final int    fourI = 4 * i;\n            final double eiM1  = secondary[index + i - 1];\n            final double ratio = eiM1 / di;\n            work[fourI - 2] = ratio * ratio * Math.abs(di);\n            di = (main[index + i] - lambda) - eiM1 * ratio;\n            work[fourI] = Math.abs(di);\n        }\n    }",
    "comment": " Decompose the shifted tridiagonal matrix T-&lambda;I as LDL<sup>T</sup>. <p>A shifted symmetric tridiagonal matrix T can be decomposed as LDL<sup>T</sup> where L is a lower bidiagonal matrix with unit diagonal and D is a diagonal matrix. This method is an implementation of algorithm 4.4.7 from Dhillon's thesis.</p> @param lambda shift to add to the matrix before decomposing it to ensure it is positive definite @param index index of the first row of the block @param n number of rows of the block ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "EigenDecompositionImpl.processGeneralBlock",
    "class_name": "org.apache.commons.math.linear.EigenDecompositionImpl",
    "signature": "org.apache.commons.math.linear.EigenDecompositionImpl.processGeneralBlock(int)",
    "snippet": "    private void processGeneralBlock(final int n)\n        throws InvalidMatrixException {\n\n        // check decomposed matrix data range\n        double sumOffDiag = 0;\n        for (int i = 0; i < n - 1; ++i) {\n            final int fourI = 4 * i;\n            final double ei = work[fourI + 2];\n            sumOffDiag += ei;\n        }\n\n        if (sumOffDiag == 0) {\n            // matrix is already diagonal\n            return;\n        }\n\n        // initial checks for splits (see Parlett & Marques section 3.3)\n        flipIfWarranted(n, 2);\n\n        // two iterations with Li's test for initial splits\n        initialSplits(n);\n\n        // initialize parameters used by goodStep\n        tType = 0;\n        dMin1 = 0;\n        dMin2 = 0;\n        dN    = 0;\n        dN1   = 0;\n        dN2   = 0;\n        tau   = 0;\n\n        // process split segments\n        int i0 = 0;\n        int n0 = n;\n        while (n0 > 0) {\n\n            // retrieve shift that was temporarily stored as a negative off-diagonal element\n            sigma    = (n0 == n) ? 0 : -work[4 * n0 - 2];\n            sigmaLow = 0;\n\n            // find start of a new split segment to process\n            double offDiagMin = (i0 == n0) ? 0 : work[4 * n0 - 6];\n            double offDiagMax = 0;\n            double diagMax    = work[4 * n0 - 4];\n            double diagMin    = diagMax;\n            i0 = 0;\n            for (int i = 4 * (n0 - 2); i >= 0; i -= 4) {\n                if (work[i + 2] <= 0) {\n                    i0 = 1 + i / 4;\n                    break;\n                }\n                if (diagMin >= 4 * offDiagMax) {\n                    diagMin    = Math.min(diagMin, work[i + 4]);\n                    offDiagMax = Math.max(offDiagMax, work[i + 2]);\n                }\n                diagMax    = Math.max(diagMax, work[i] + work[i + 2]);\n                offDiagMin = Math.min(offDiagMin, work[i + 2]);\n            }\n            work[4 * n0 - 2] = offDiagMin;\n\n            // lower bound of Gershgorin disk\n            dMin = -Math.max(0, diagMin - 2 * Math.sqrt(diagMin * offDiagMax));\n\n            pingPong = 0;\n            int maxIter = 30 * (n0 - i0);\n            for (int k = 0; i0 < n0; ++k) {\n                if (k >= maxIter) {\n                    throw new InvalidMatrixException(new MaxIterationsExceededException(maxIter));\n                }\n\n                // perform one step\n                n0 = goodStep(i0, n0);\n                pingPong = 1 - pingPong;\n\n                // check for new splits after \"ping\" steps\n                // when the last elements of qd array are very small\n                if ((pingPong == 0) && (n0 - i0 > 3) &&\n                    (work[4 * n0 - 1] <= TOLERANCE_2 * diagMax) &&\n                    (work[4 * n0 - 2] <= TOLERANCE_2 * sigma)) {\n                    int split  = i0 - 1;\n                    diagMax    = work[4 * i0];\n                    offDiagMin = work[4 * i0 + 2];\n                    double previousEMin = work[4 * i0 + 3];\n                    for (int i = 4 * i0; i < 4 * n0 - 16; i += 4) {\n                        if ((work[i + 3] <= TOLERANCE_2 * work[i]) ||\n                            (work[i + 2] <= TOLERANCE_2 * sigma)) {\n                            // insert a split\n                            work[i + 2]  = -sigma;\n                            split        = i / 4;\n                            diagMax      = 0;\n                            offDiagMin   = work[i + 6];\n                            previousEMin = work[i + 7];\n                        } else {\n                            diagMax      = Math.max(diagMax, work[i + 4]);\n                            offDiagMin   = Math.min(offDiagMin, work[i + 2]);\n                            previousEMin = Math.min(previousEMin, work[i + 3]);\n                        }\n                    }\n                    work[4 * n0 - 2] = offDiagMin;\n                    work[4 * n0 - 1] = previousEMin;\n                    i0 = split + 1;\n                }\n            }\n\n        }\n\n    }",
    "comment": " Find realEigenvalues using dqd/dqds algorithms. <p>This implementation is based on Beresford N. Parlett and Osni A. Marques paper <a href=\"http://www.netlib.org/lapack/lawnspdf/lawn155.pdf\">An Implementation of the dqds Algorithm (Positive Case)</a> and on the corresponding LAPACK routine DLASQ2.</p> @param n number of rows of the block @exception InvalidMatrixException if block cannot be diagonalized after 30 * n iterations ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "EigenDecompositionImpl.progressiveQuotientDifferenceWithShift",
    "class_name": "org.apache.commons.math.linear.EigenDecompositionImpl",
    "signature": "org.apache.commons.math.linear.EigenDecompositionImpl.progressiveQuotientDifferenceWithShift(double[],double[],double)",
    "snippet": "    private void progressiveQuotientDifferenceWithShift(final double[] d, final double[] l,\n                                                        final double lambda) {\n        final int nM1 = d.length - 1;\n        double pi = d[nM1] - lambda;\n        int sixI = 6 * (nM1 - 1);\n        for (int i = nM1 - 1; i >= 0; --i) {\n            final double di   = d[i];\n            final double li   = l[i];\n            final double diP1 = di * li * li + pi;\n            final double t    = di / diP1;\n            work[sixI +  9]   = pi;\n            work[sixI + 10]   = diP1;\n            work[sixI +  5]   = li * t;\n            pi = pi * t - lambda;\n            sixI -= 6;\n        }\n        work[3] = pi;\n        work[4] = pi;\n    }",
    "comment": " Decompose matrix LDL<sup>T</sup> - &lambda; I as U<sub>-</sub>D<sub>-</sub>U<sub>-</sub><sup>T</sup>. <p>This method corresponds to algorithm 4.4.5 (dqds) from Dhillon's thesis.</p> @param d diagonal elements of D @param l off-diagonal elements of L @param lambda shift to apply ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "EigenDecompositionImpl.stationaryQuotientDifferenceWithShift",
    "class_name": "org.apache.commons.math.linear.EigenDecompositionImpl",
    "signature": "org.apache.commons.math.linear.EigenDecompositionImpl.stationaryQuotientDifferenceWithShift(double[],double[],double)",
    "snippet": "    private void stationaryQuotientDifferenceWithShift(final double[] d, final double[] l,\n                                                       final double lambda) {\n        final int nM1 = d.length - 1;\n        double si = -lambda;\n        int sixI = 0;\n        for (int i = 0; i < nM1; ++i) {\n            final double di   = d[i];\n            final double li   = l[i];\n            final double diP1 = di + si;\n            final double liP1 = li * di / diP1;\n            work[sixI]        = si;\n            work[sixI + 1]    = diP1;\n            work[sixI + 2]    = liP1;\n            si = li * liP1 * si - lambda;\n            sixI += 6;\n        }\n        work[6 * nM1 + 1] = d[nM1] + si;\n        work[6 * nM1]     = si;\n    }",
    "comment": " Decompose matrix LDL<sup>T</sup> - &lambda; I as L<sub>+</sub>D<sub>+</sub>L<sub>+</sub><sup>T</sup>. <p>This method corresponds to algorithm 4.4.3 (dstqds) from Dhillon's thesis.</p> @param d diagonal elements of D, @param l off-diagonal elements of L @param lambda shift to apply ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "EigenDecompositionImpl.updateSigma",
    "class_name": "org.apache.commons.math.linear.EigenDecompositionImpl",
    "signature": "org.apache.commons.math.linear.EigenDecompositionImpl.updateSigma(double)",
    "snippet": "    private void updateSigma(final double shift) {\n        // BEWARE: do NOT attempt to simplify the following statements\n        // the expressions below take care to accumulate the part of sigma\n        // that does not fit within a double variable into sigmaLow\n        if (shift < sigma) {\n            sigmaLow += shift;\n            final double t = sigma + sigmaLow;\n            sigmaLow -= t - sigma;\n            sigma = t;\n        } else {\n            final double t = sigma + shift;\n            sigmaLow += sigma - (t - shift);\n            sigma = t;\n        }\n    }",
    "comment": " Update sigma. @param shift shift to apply to sigma ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "MatrixUtils.checkMultiplicationCompatible",
    "class_name": "org.apache.commons.math.linear.MatrixUtils",
    "signature": "org.apache.commons.math.linear.MatrixUtils.checkMultiplicationCompatible(AnyMatrix,AnyMatrix)",
    "snippet": "    public static void checkMultiplicationCompatible(final AnyMatrix left, final AnyMatrix right)\n        throws IllegalArgumentException {\n        if (left.getColumnDimension() != right.getRowDimension()) {\n            throw MathRuntimeException.createIllegalArgumentException(\n                    \"{0}x{1} and {2}x{3} matrices are not multiplication compatible\",\n                    left.getRowDimension(), left.getColumnDimension(),\n                    right.getRowDimension(), right.getColumnDimension());\n        }\n    }",
    "comment": " Check if matrices are multiplication compatible @param left left hand side matrix @param right right hand side matrix @exception IllegalArgumentException if matrices are not multiplication compatible ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "MatrixUtils.createRealMatrix",
    "class_name": "org.apache.commons.math.linear.MatrixUtils",
    "signature": "org.apache.commons.math.linear.MatrixUtils.createRealMatrix(double[][])",
    "snippet": "    public static RealMatrix createRealMatrix(double[][] data) {\n        return (data.length * data[0].length <= 4096) ?\n                new Array2DRowRealMatrix(data) : new BlockRealMatrix(data);\n    }",
    "comment": " Returns a {@link RealMatrix} whose entries are the the values in the the input array. <p>The type of matrix returned depends on the dimension. Below 2<sup>12</sup> elements (i.e. 4096 elements or 64&times;64 for a square matrix) which can be stored in a 32kB array, a {@link Array2DRowRealMatrix} instance is built. Above this threshold a {@link BlockRealMatrix} instance is built.</p> <p>The input array is copied, not referenced.</p>  @param data input array @return  RealMatrix containing the values of the array @throws IllegalArgumentException if <code>data</code> is not rectangular (not all rows have the same length) or empty @throws NullPointerException if either <code>data</code> or <code>data[0]</code> is null @see #createRealMatrix(int, int) ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "RealVectorFormat.RealVectorFormat",
    "class_name": "org.apache.commons.math.linear.RealVectorFormat",
    "signature": "org.apache.commons.math.linear.RealVectorFormat.RealVectorFormat(NumberFormat)",
    "snippet": "    public RealVectorFormat(final NumberFormat format) {\n        this(DEFAULT_PREFIX, DEFAULT_SUFFIX, DEFAULT_SEPARATOR, format);\n    }",
    "comment": " Create an instance with a custom number format for components. @param format the custom format for components. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "RealVectorFormat.RealVectorFormat",
    "class_name": "org.apache.commons.math.linear.RealVectorFormat",
    "signature": "org.apache.commons.math.linear.RealVectorFormat.RealVectorFormat(String,String,String,NumberFormat)",
    "snippet": "    public RealVectorFormat(final String prefix, final String suffix,\n                            final String separator, final NumberFormat format) {\n        this.prefix      = prefix;\n        this.suffix      = suffix;\n        this.separator   = separator;\n        trimmedPrefix    = prefix.trim();\n        trimmedSuffix    = suffix.trim();\n        trimmedSeparator = separator.trim();\n        this.format      = format;\n    }",
    "comment": " Create an instance with custom prefix, suffix, separator and format for components. @param prefix prefix to use instead of the default \"{\" @param suffix suffix to use instead of the default \"}\" @param separator separator to use instead of the default \"; \" @param format the custom format for components. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "RealVectorFormat.getInstance",
    "class_name": "org.apache.commons.math.linear.RealVectorFormat",
    "signature": "org.apache.commons.math.linear.RealVectorFormat.getInstance()",
    "snippet": "    public static RealVectorFormat getInstance() {\n        return getInstance(Locale.getDefault());\n    }",
    "comment": " Returns the default real vector format for the current locale. @return the default real vector format. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "RealVectorFormat.getInstance",
    "class_name": "org.apache.commons.math.linear.RealVectorFormat",
    "signature": "org.apache.commons.math.linear.RealVectorFormat.getInstance(Locale)",
    "snippet": "    public static RealVectorFormat getInstance(final Locale locale) {\n        return new RealVectorFormat(getDefaultNumberFormat(locale));\n    }",
    "comment": " Returns the default real vector format for the given locale. @param locale the specific locale used by the format. @return the real vector format specific to the given locale. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "CompositeFormat.getDefaultNumberFormat",
    "class_name": "org.apache.commons.math.util.CompositeFormat",
    "signature": "org.apache.commons.math.util.CompositeFormat.getDefaultNumberFormat(Locale)",
    "snippet": "    protected static NumberFormat getDefaultNumberFormat(final Locale locale) {\n        final NumberFormat nf = NumberFormat.getInstance(locale);\n        nf.setMaximumFractionDigits(2);\n        return nf;\n    }",
    "comment": " Create a default number format.  The default number format is based on {@link NumberFormat#getInstance(java.util.Locale)} with the only customizing that the maximum number of fraction digits is set to 2. @param locale the specific locale used by the format. @return the default number format specific to the given locale. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  }
]