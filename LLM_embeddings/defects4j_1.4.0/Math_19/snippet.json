[
  {
    "name": "MathIllegalStateException.MathIllegalStateException",
    "class_name": "org.apache.commons.math3.exception.MathIllegalStateException",
    "signature": "org.apache.commons.math3.exception.MathIllegalStateException.MathIllegalStateException()",
    "snippet": "    public MathIllegalStateException() {\n        this(LocalizedFormats.ILLEGAL_STATE);\n    }",
    "comment": " Default constructor. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "MathIllegalStateException.MathIllegalStateException",
    "class_name": "org.apache.commons.math3.exception.MathIllegalStateException",
    "signature": "org.apache.commons.math3.exception.MathIllegalStateException.MathIllegalStateException(Localizable,Object[])",
    "snippet": "    public MathIllegalStateException(Localizable pattern,\n                                     Object ... args) {\n        context = new ExceptionContext(this);\n        context.addMessage(pattern, args);\n    }",
    "comment": " Simple constructor.  @param pattern Message pattern explaining the cause of the error. @param args Arguments. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "MathIllegalStateException.getLocalizedMessage",
    "class_name": "org.apache.commons.math3.exception.MathIllegalStateException",
    "signature": "org.apache.commons.math3.exception.MathIllegalStateException.getLocalizedMessage()",
    "snippet": "    @Override\n    public String getLocalizedMessage() {\n        return context.getLocalizedMessage();\n    }",
    "comment": "{@inheritDoc} */",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "ArgUtils.flatten",
    "class_name": "org.apache.commons.math3.exception.util.ArgUtils",
    "signature": "org.apache.commons.math3.exception.util.ArgUtils.flatten(Object[])",
    "snippet": "    public static Object[] flatten(Object[] array) {\n        final List<Object> list = new ArrayList<Object>();\n        if (array != null) {\n            for (Object o : array) {\n                if (o instanceof Object[]) {\n                    for (Object oR : flatten((Object[]) o)) {\n                        list.add(oR);\n                    }\n                } else {\n                    list.add(o);\n                }\n            }\n        }\n        return list.toArray();\n    }",
    "comment": " Transform a multidimensional array into a one-dimensional list.  @param array Array (possibly multidimensional). @return a list of all the {@code Object} instances contained in {@code array}. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "ExceptionContext.ExceptionContext",
    "class_name": "org.apache.commons.math3.exception.util.ExceptionContext",
    "signature": "org.apache.commons.math3.exception.util.ExceptionContext.ExceptionContext(Throwable)",
    "snippet": "    public ExceptionContext(final Throwable throwable) {\n        this.throwable = throwable;\n        msgPatterns    = new ArrayList<Localizable>();\n        msgArguments   = new ArrayList<Object[]>();\n        context        = new HashMap<String, Object>();\n    }",
    "comment": "Simple constructor. @param throwable the exception this context refers too ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "ExceptionContext.addMessage",
    "class_name": "org.apache.commons.math3.exception.util.ExceptionContext",
    "signature": "org.apache.commons.math3.exception.util.ExceptionContext.addMessage(Localizable,Object[])",
    "snippet": "    public void addMessage(Localizable pattern,\n                           Object ... arguments) {\n        msgPatterns.add(pattern);\n        msgArguments.add(ArgUtils.flatten(arguments));\n    }",
    "comment": " Adds a message.  @param pattern Message pattern. @param arguments Values for replacing the placeholders in the message pattern. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "ExceptionContext.buildMessage",
    "class_name": "org.apache.commons.math3.exception.util.ExceptionContext",
    "signature": "org.apache.commons.math3.exception.util.ExceptionContext.buildMessage(Locale,String)",
    "snippet": "    private String buildMessage(Locale locale,\n                                String separator) {\n        final StringBuilder sb = new StringBuilder();\n        int count = 0;\n        final int len = msgPatterns.size();\n        for (int i = 0; i < len; i++) {\n            final Localizable pat = msgPatterns.get(i);\n            final Object[] args = msgArguments.get(i);\n            final MessageFormat fmt = new MessageFormat(pat.getLocalizedString(locale),\n                                                        locale);\n            sb.append(fmt.format(args));\n            if (++count < len) {\n                // Add a separator if there are other messages.\n                sb.append(separator);\n            }\n        }\n\n        return sb.toString();\n    }",
    "comment": " Builds a message string.  @param locale Locale in which the message should be translated. @param separator Message separator. @return a localized message string. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "ExceptionContext.getLocalizedMessage",
    "class_name": "org.apache.commons.math3.exception.util.ExceptionContext",
    "signature": "org.apache.commons.math3.exception.util.ExceptionContext.getLocalizedMessage()",
    "snippet": "    public String getLocalizedMessage() {\n        return getMessage(Locale.getDefault());\n    }",
    "comment": " Gets the message in the default locale.  @return the localized message. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "ExceptionContext.getMessage",
    "class_name": "org.apache.commons.math3.exception.util.ExceptionContext",
    "signature": "org.apache.commons.math3.exception.util.ExceptionContext.getMessage(Locale)",
    "snippet": "    public String getMessage(final Locale locale) {\n        return buildMessage(locale, \": \");\n    }",
    "comment": " Gets the message in a specified locale.  @param locale Locale in which the message should be translated. @return the localized message. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "LocalizedFormats.getLocalizedString",
    "class_name": "org.apache.commons.math3.exception.util.LocalizedFormats",
    "signature": "org.apache.commons.math3.exception.util.LocalizedFormats.getLocalizedString(Locale)",
    "snippet": "    public String getLocalizedString(final Locale locale) {\n        try {\n            final String path = LocalizedFormats.class.getName().replaceAll(\"\\\\.\", \"/\");\n            ResourceBundle bundle =\n                    ResourceBundle.getBundle(\"assets/\" + path, locale);\n            if (bundle.getLocale().getLanguage().equals(locale.getLanguage())) {\n                // the value of the resource is the translated format\n                return bundle.getString(toString());\n            }\n\n        } catch (MissingResourceException mre) {\n            // do nothing here\n        }\n\n        // either the locale is not supported or the resource is unknown\n        // don't translate and fall back to using the source format\n        return sourceFormat;\n\n    }",
    "comment": "{@inheritDoc} */",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "AbstractRealMatrix.AbstractRealMatrix",
    "class_name": "org.apache.commons.math3.linear.AbstractRealMatrix",
    "signature": "org.apache.commons.math3.linear.AbstractRealMatrix.AbstractRealMatrix()",
    "snippet": "    protected AbstractRealMatrix() {}",
    "comment": " Creates a matrix with no data ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "AbstractRealMatrix.AbstractRealMatrix",
    "class_name": "org.apache.commons.math3.linear.AbstractRealMatrix",
    "signature": "org.apache.commons.math3.linear.AbstractRealMatrix.AbstractRealMatrix(int,int)",
    "snippet": "    protected AbstractRealMatrix(final int rowDimension,\n        final int columnDimension)\n        throws NotStrictlyPositiveException {\n        if (rowDimension < 1) {\n            throw new NotStrictlyPositiveException(rowDimension);\n        }\n        if (columnDimension < 1) {\n            throw new NotStrictlyPositiveException(columnDimension);\n        }\n    }",
    "comment": " Create a new RealMatrix with the supplied row and column dimensions.  @param rowDimension  the number of rows in the new matrix @param columnDimension  the number of columns in the new matrix @throws NotStrictlyPositiveException if row or column dimension is not positive ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "AbstractRealMatrix.getFrobeniusNorm",
    "class_name": "org.apache.commons.math3.linear.AbstractRealMatrix",
    "signature": "org.apache.commons.math3.linear.AbstractRealMatrix.getFrobeniusNorm()",
    "snippet": "    public double getFrobeniusNorm() {\n        return walkInOptimizedOrder(new RealMatrixPreservingVisitor() {\n\n            /** Sum of squared entries. */\n            private double sum;\n\n            /** {@inheritDoc} */\n            public void start(final int rows, final int columns,\n                              final int startRow, final int endRow,\n                              final int startColumn, final int endColumn) {\n                sum = 0;\n            }\n\n            /** {@inheritDoc} */\n            public void visit(final int row, final int column, final double value) {\n                sum += value * value;\n            }\n\n            /** {@inheritDoc} */\n            public double end() {\n                return FastMath.sqrt(sum);\n            }\n        });\n    }",
    "comment": "{@inheritDoc} */",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "AbstractRealMatrix.multiply",
    "class_name": "org.apache.commons.math3.linear.AbstractRealMatrix",
    "signature": "org.apache.commons.math3.linear.AbstractRealMatrix.multiply(RealMatrix)",
    "snippet": "    public RealMatrix multiply(final RealMatrix m)\n        throws DimensionMismatchException {\n        MatrixUtils.checkMultiplicationCompatible(this, m);\n\n        final int nRows = getRowDimension();\n        final int nCols = m.getColumnDimension();\n        final int nSum  = getColumnDimension();\n        final RealMatrix out = createMatrix(nRows, nCols);\n        for (int row = 0; row < nRows; ++row) {\n            for (int col = 0; col < nCols; ++col) {\n                double sum = 0;\n                for (int i = 0; i < nSum; ++i) {\n                    sum += getEntry(row, i) * m.getEntry(i, col);\n                }\n                out.setEntry(row, col, sum);\n            }\n        }\n\n        return out;\n    }",
    "comment": "{@inheritDoc} */",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "AbstractRealMatrix.scalarAdd",
    "class_name": "org.apache.commons.math3.linear.AbstractRealMatrix",
    "signature": "org.apache.commons.math3.linear.AbstractRealMatrix.scalarAdd(double)",
    "snippet": "    public RealMatrix scalarAdd(final double d) {\n        final int rowCount    = getRowDimension();\n        final int columnCount = getColumnDimension();\n        final RealMatrix out = createMatrix(rowCount, columnCount);\n        for (int row = 0; row < rowCount; ++row) {\n            for (int col = 0; col < columnCount; ++col) {\n                out.setEntry(row, col, getEntry(row, col) + d);\n            }\n        }\n\n        return out;\n    }",
    "comment": "{@inheritDoc} */",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "AbstractRealMatrix.scalarMultiply",
    "class_name": "org.apache.commons.math3.linear.AbstractRealMatrix",
    "signature": "org.apache.commons.math3.linear.AbstractRealMatrix.scalarMultiply(double)",
    "snippet": "    public RealMatrix scalarMultiply(final double d) {\n        final int rowCount    = getRowDimension();\n        final int columnCount = getColumnDimension();\n        final RealMatrix out = createMatrix(rowCount, columnCount);\n        for (int row = 0; row < rowCount; ++row) {\n            for (int col = 0; col < columnCount; ++col) {\n                out.setEntry(row, col, getEntry(row, col) * d);\n            }\n        }\n\n        return out;\n    }",
    "comment": "{@inheritDoc} */",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "AbstractRealMatrix.transpose",
    "class_name": "org.apache.commons.math3.linear.AbstractRealMatrix",
    "signature": "org.apache.commons.math3.linear.AbstractRealMatrix.transpose()",
    "snippet": "    public RealMatrix transpose() {\n        final int nRows = getRowDimension();\n        final int nCols = getColumnDimension();\n        final RealMatrix out = createMatrix(nCols, nRows);\n        walkInOptimizedOrder(new DefaultRealMatrixPreservingVisitor() {\n\n            /** {@inheritDoc} */\n            @Override\n            public void visit(final int row, final int column, final double value) {\n                out.setEntry(column, row, value);\n            }\n\n        });\n\n        return out;\n    }",
    "comment": "{@inheritDoc} */",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "AbstractRealMatrix.walkInOptimizedOrder",
    "class_name": "org.apache.commons.math3.linear.AbstractRealMatrix",
    "signature": "org.apache.commons.math3.linear.AbstractRealMatrix.walkInOptimizedOrder(RealMatrixPreservingVisitor)",
    "snippet": "    public double walkInOptimizedOrder(final RealMatrixPreservingVisitor visitor) {\n        return walkInRowOrder(visitor);\n    }",
    "comment": "{@inheritDoc} */",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "Array2DRowRealMatrix.Array2DRowRealMatrix",
    "class_name": "org.apache.commons.math3.linear.Array2DRowRealMatrix",
    "signature": "org.apache.commons.math3.linear.Array2DRowRealMatrix.Array2DRowRealMatrix(double[][],boolean)",
    "snippet": "    public Array2DRowRealMatrix(final double[][] d, final boolean copyArray)\n        throws DimensionMismatchException, NoDataException,\n        NullArgumentException {\n        if (copyArray) {\n            copyIn(d);\n        } else {\n            if (d == null) {\n                throw new NullArgumentException();\n            }\n            final int nRows = d.length;\n            if (nRows == 0) {\n                throw new NoDataException(LocalizedFormats.AT_LEAST_ONE_ROW);\n            }\n            final int nCols = d[0].length;\n            if (nCols == 0) {\n                throw new NoDataException(LocalizedFormats.AT_LEAST_ONE_COLUMN);\n            }\n            for (int r = 1; r < nRows; r++) {\n                if (d[r].length != nCols) {\n                    throw new DimensionMismatchException(d[r].length, nCols);\n                }\n            }\n            data = d;\n        }\n    }",
    "comment": " Create a new RealMatrix using the input array as the underlying data array. If an array is built specially in order to be embedded in a RealMatrix and not used directly, the {@code copyArray} may be set to {@code false}. This will prevent the copying and improve performance as no new array will be built and no data will be copied.  @param d Data for new matrix. @param copyArray if {@code true}, the input array will be copied, otherwise it will be referenced. @throws DimensionMismatchException if {@code d} is not rectangular. @throws NoDataException if {@code d} row or colum dimension is zero. @throws NullArgumentException if {@code d} is {@code null}. @see #Array2DRowRealMatrix(double[][]) ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "Array2DRowRealMatrix.Array2DRowRealMatrix",
    "class_name": "org.apache.commons.math3.linear.Array2DRowRealMatrix",
    "signature": "org.apache.commons.math3.linear.Array2DRowRealMatrix.Array2DRowRealMatrix(int,int)",
    "snippet": "    public Array2DRowRealMatrix(final int rowDimension,\n                                final int columnDimension)\n        throws NotStrictlyPositiveException {\n        super(rowDimension, columnDimension);\n        data = new double[rowDimension][columnDimension];\n    }",
    "comment": " Create a new RealMatrix with the supplied row and column dimensions.  @param rowDimension Number of rows in the new matrix. @param columnDimension Number of columns in the new matrix. @throws NotStrictlyPositiveException if the row or column dimension is not positive. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "Array2DRowRealMatrix.createMatrix",
    "class_name": "org.apache.commons.math3.linear.Array2DRowRealMatrix",
    "signature": "org.apache.commons.math3.linear.Array2DRowRealMatrix.createMatrix(int,int)",
    "snippet": "    public RealMatrix createMatrix(final int rowDimension,\n                                   final int columnDimension)\n        throws NotStrictlyPositiveException {\n        return new Array2DRowRealMatrix(rowDimension, columnDimension);\n    }",
    "comment": "{@inheritDoc} */",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "Array2DRowRealMatrix.getColumnDimension",
    "class_name": "org.apache.commons.math3.linear.Array2DRowRealMatrix",
    "signature": "org.apache.commons.math3.linear.Array2DRowRealMatrix.getColumnDimension()",
    "snippet": "    @Override\n    public int getColumnDimension() {\n        return ((data == null) || (data[0] == null)) ? 0 : data[0].length;\n    }",
    "comment": "{@inheritDoc} */",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "Array2DRowRealMatrix.getEntry",
    "class_name": "org.apache.commons.math3.linear.Array2DRowRealMatrix",
    "signature": "org.apache.commons.math3.linear.Array2DRowRealMatrix.getEntry(int,int)",
    "snippet": "    public double getEntry(final int row, final int column)\n        throws OutOfRangeException {\n        MatrixUtils.checkMatrixIndex(this, row, column);\n        return data[row][column];\n    }",
    "comment": "{@inheritDoc} */",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "Array2DRowRealMatrix.getRowDimension",
    "class_name": "org.apache.commons.math3.linear.Array2DRowRealMatrix",
    "signature": "org.apache.commons.math3.linear.Array2DRowRealMatrix.getRowDimension()",
    "snippet": "    @Override\n    public int getRowDimension() {\n        return (data == null) ? 0 : data.length;\n    }",
    "comment": "{@inheritDoc} */",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "Array2DRowRealMatrix.setEntry",
    "class_name": "org.apache.commons.math3.linear.Array2DRowRealMatrix",
    "signature": "org.apache.commons.math3.linear.Array2DRowRealMatrix.setEntry(int,int,double)",
    "snippet": "    public void setEntry(final int row, final int column, final double value)\n        throws OutOfRangeException {\n        MatrixUtils.checkMatrixIndex(this, row, column);\n        data[row][column] = value;\n    }",
    "comment": "{@inheritDoc} */",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "Array2DRowRealMatrix.walkInRowOrder",
    "class_name": "org.apache.commons.math3.linear.Array2DRowRealMatrix",
    "signature": "org.apache.commons.math3.linear.Array2DRowRealMatrix.walkInRowOrder(RealMatrixPreservingVisitor)",
    "snippet": "    @Override\n    public double walkInRowOrder(final RealMatrixPreservingVisitor visitor) {\n        final int rows    = getRowDimension();\n        final int columns = getColumnDimension();\n        visitor.start(rows, columns, 0, rows - 1, 0, columns - 1);\n        for (int i = 0; i < rows; ++i) {\n            final double[] rowI = data[i];\n            for (int j = 0; j < columns; ++j) {\n                visitor.visit(i, j, rowI[j]);\n            }\n        }\n        return visitor.end();\n    }",
    "comment": "{@inheritDoc} */",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "DefaultRealMatrixPreservingVisitor.end",
    "class_name": "org.apache.commons.math3.linear.DefaultRealMatrixPreservingVisitor",
    "signature": "org.apache.commons.math3.linear.DefaultRealMatrixPreservingVisitor.end()",
    "snippet": "    public double end() {\n        return 0;\n    }",
    "comment": "{@inheritDoc} */",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "DefaultRealMatrixPreservingVisitor.start",
    "class_name": "org.apache.commons.math3.linear.DefaultRealMatrixPreservingVisitor",
    "signature": "org.apache.commons.math3.linear.DefaultRealMatrixPreservingVisitor.start(int,int,int,int,int,int)",
    "snippet": "    public void start(int rows, int columns,\n                      int startRow, int endRow, int startColumn, int endColumn) {\n    }",
    "comment": "{@inheritDoc} */",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "MatrixUtils.checkColumnIndex",
    "class_name": "org.apache.commons.math3.linear.MatrixUtils",
    "signature": "org.apache.commons.math3.linear.MatrixUtils.checkColumnIndex(AnyMatrix,int)",
    "snippet": "    public static void checkColumnIndex(final AnyMatrix m, final int column)\n        throws OutOfRangeException {\n        if (column < 0 || column >= m.getColumnDimension()) {\n            throw new OutOfRangeException(LocalizedFormats.COLUMN_INDEX,\n                                           column, 0, m.getColumnDimension() - 1);\n        }\n    }",
    "comment": " Check if a column index is valid.  @param m Matrix. @param column Column index to check. @throws OutOfRangeException if {@code column} is not a valid index. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "MatrixUtils.checkMatrixIndex",
    "class_name": "org.apache.commons.math3.linear.MatrixUtils",
    "signature": "org.apache.commons.math3.linear.MatrixUtils.checkMatrixIndex(AnyMatrix,int,int)",
    "snippet": "    public static void checkMatrixIndex(final AnyMatrix m,\n                                        final int row, final int column)\n        throws OutOfRangeException {\n        checkRowIndex(m, row);\n        checkColumnIndex(m, column);\n    }",
    "comment": " Check if matrix indices are valid.  @param m Matrix. @param row Row index to check. @param column Column index to check. @throws OutOfRangeException if {@code row} or {@code column} is not a valid index. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "MatrixUtils.checkMultiplicationCompatible",
    "class_name": "org.apache.commons.math3.linear.MatrixUtils",
    "signature": "org.apache.commons.math3.linear.MatrixUtils.checkMultiplicationCompatible(AnyMatrix,AnyMatrix)",
    "snippet": "    public static void checkMultiplicationCompatible(final AnyMatrix left, final AnyMatrix right)\n        throws DimensionMismatchException {\n\n        if (left.getColumnDimension() != right.getRowDimension()) {\n            throw new DimensionMismatchException(left.getColumnDimension(),\n                                                 right.getRowDimension());\n        }\n    }",
    "comment": " Check if matrices are multiplication compatible  @param left Left hand side matrix. @param right Right hand side matrix. @throws DimensionMismatchException if matrices are not multiplication compatible. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "MatrixUtils.checkRowIndex",
    "class_name": "org.apache.commons.math3.linear.MatrixUtils",
    "signature": "org.apache.commons.math3.linear.MatrixUtils.checkRowIndex(AnyMatrix,int)",
    "snippet": "    public static void checkRowIndex(final AnyMatrix m, final int row)\n        throws OutOfRangeException {\n        if (row < 0 ||\n            row >= m.getRowDimension()) {\n            throw new OutOfRangeException(LocalizedFormats.ROW_INDEX,\n                                          row, 0, m.getRowDimension() - 1);\n        }\n    }",
    "comment": " Check if a row index is valid.  @param m Matrix. @param row Row index to check. @throws OutOfRangeException if {@code row} is not a valid index. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "MatrixUtils.createColumnRealMatrix",
    "class_name": "org.apache.commons.math3.linear.MatrixUtils",
    "signature": "org.apache.commons.math3.linear.MatrixUtils.createColumnRealMatrix(double[])",
    "snippet": "    public static RealMatrix createColumnRealMatrix(double[] columnData)\n        throws NoDataException, NullArgumentException {\n        if (columnData == null) {\n            throw new NullArgumentException();\n        }\n        final int nRows = columnData.length;\n        final RealMatrix m = createRealMatrix(nRows, 1);\n        for (int i = 0; i < nRows; ++i) {\n            m.setEntry(i, 0, columnData[i]);\n        }\n        return m;\n    }",
    "comment": " Creates a column {@link RealMatrix} using the data from the input array.  @param columnData  the input column data @return a columnData x 1 RealMatrix @throws NoDataException if {@code columnData} is empty. @throws NullArgumentException if {@code columnData} is {@code null}. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "MatrixUtils.createRealMatrix",
    "class_name": "org.apache.commons.math3.linear.MatrixUtils",
    "signature": "org.apache.commons.math3.linear.MatrixUtils.createRealMatrix(int,int)",
    "snippet": "    public static RealMatrix createRealMatrix(final int rows, final int columns) {\n        return (rows * columns <= 4096) ?\n                new Array2DRowRealMatrix(rows, columns) : new BlockRealMatrix(rows, columns);\n    }",
    "comment": " Returns a {@link RealMatrix} with specified dimensions. <p>The type of matrix returned depends on the dimension. Below 2<sup>12</sup> elements (i.e. 4096 elements or 64&times;64 for a square matrix) which can be stored in a 32kB array, a {@link Array2DRowRealMatrix} instance is built. Above this threshold a {@link BlockRealMatrix} instance is built.</p> <p>The matrix elements are all set to 0.0.</p> @param rows number of rows of the matrix @param columns number of columns of the matrix @return  RealMatrix with specified dimensions @see #createRealMatrix(double[][]) ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "RealMatrixFormat.RealMatrixFormat",
    "class_name": "org.apache.commons.math3.linear.RealMatrixFormat",
    "signature": "org.apache.commons.math3.linear.RealMatrixFormat.RealMatrixFormat(NumberFormat)",
    "snippet": "    public RealMatrixFormat(final NumberFormat format) {\n        this(DEFAULT_PREFIX, DEFAULT_SUFFIX, DEFAULT_ROW_PREFIX, DEFAULT_ROW_SUFFIX,\n                DEFAULT_ROW_SEPARATOR, DEFAULT_COLUMN_SEPARATOR, format);\n    }",
    "comment": " Create an instance with a custom number format for components. @param format the custom format for components. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "RealMatrixFormat.RealMatrixFormat",
    "class_name": "org.apache.commons.math3.linear.RealMatrixFormat",
    "signature": "org.apache.commons.math3.linear.RealMatrixFormat.RealMatrixFormat(String,String,String,String,String,String)",
    "snippet": "    public RealMatrixFormat(final String prefix, final String suffix,\n                            final String rowPrefix, final String rowSuffix,\n                            final String rowSeparator, final String columnSeparator) {\n        this(prefix, suffix, rowPrefix, rowSuffix, rowSeparator, columnSeparator,\n                CompositeFormat.getDefaultNumberFormat());\n    }",
    "comment": " Create an instance with custom prefix, suffix and separator. @param prefix prefix to use instead of the default \"{\" @param suffix suffix to use instead of the default \"}\" @param rowPrefix row prefix to use instead of the default \"{\" @param rowSuffix row suffix to use instead of the default \"}\" @param rowSeparator tow separator to use instead of the default \";\" @param columnSeparator column separator to use instead of the default \", \" ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "RealMatrixFormat.RealMatrixFormat",
    "class_name": "org.apache.commons.math3.linear.RealMatrixFormat",
    "signature": "org.apache.commons.math3.linear.RealMatrixFormat.RealMatrixFormat(String,String,String,String,String,String,NumberFormat)",
    "snippet": "    public RealMatrixFormat(final String prefix, final String suffix,\n                            final String rowPrefix, final String rowSuffix,\n                            final String rowSeparator, final String columnSeparator,\n                            final NumberFormat format) {\n        this.prefix            = prefix;\n        this.suffix            = suffix;\n        this.rowPrefix         = rowPrefix;\n        this.rowSuffix         = rowSuffix;\n        this.rowSeparator      = rowSeparator;\n        this.columnSeparator   = columnSeparator;\n        this.format            = format;\n        // disable grouping to prevent parsing problems\n        this.format.setGroupingUsed(false);\n    }",
    "comment": " Create an instance with custom prefix, suffix, separator and format for components. @param prefix prefix to use instead of the default \"{\" @param suffix suffix to use instead of the default \"}\" @param rowPrefix row prefix to use instead of the default \"{\" @param rowSuffix row suffix to use instead of the default \"}\" @param rowSeparator tow separator to use instead of the default \";\" @param columnSeparator column separator to use instead of the default \", \" @param format the custom format for components. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "RealMatrixFormat.getFormat",
    "class_name": "org.apache.commons.math3.linear.RealMatrixFormat",
    "signature": "org.apache.commons.math3.linear.RealMatrixFormat.getFormat()",
    "snippet": "    public NumberFormat getFormat() {\n        return format;\n    }",
    "comment": " Get the components format. @return components format. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "RealMatrixFormat.getInstance",
    "class_name": "org.apache.commons.math3.linear.RealMatrixFormat",
    "signature": "org.apache.commons.math3.linear.RealMatrixFormat.getInstance()",
    "snippet": "    public static RealMatrixFormat getInstance() {\n        return getInstance(Locale.getDefault());\n    }",
    "comment": " Returns the default real vector format for the current locale. @return the default real vector format. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "RealMatrixFormat.getInstance",
    "class_name": "org.apache.commons.math3.linear.RealMatrixFormat",
    "signature": "org.apache.commons.math3.linear.RealMatrixFormat.getInstance(Locale)",
    "snippet": "    public static RealMatrixFormat getInstance(final Locale locale) {\n        return new RealMatrixFormat(CompositeFormat.getDefaultNumberFormat(locale));\n    }",
    "comment": " Returns the default real vector format for the given locale. @param locale the specific locale used by the format. @return the real vector format specific to the given locale. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "AbstractConvergenceChecker.AbstractConvergenceChecker",
    "class_name": "org.apache.commons.math3.optimization.AbstractConvergenceChecker",
    "signature": "org.apache.commons.math3.optimization.AbstractConvergenceChecker.AbstractConvergenceChecker()",
    "snippet": "    @Deprecated\n    public AbstractConvergenceChecker() {\n        this.relativeThreshold = DEFAULT_RELATIVE_THRESHOLD;\n        this.absoluteThreshold = DEFAULT_ABSOLUTE_THRESHOLD;\n    }",
    "comment": " Build an instance with default thresholds. @deprecated in 3.1 (to be removed in 4.0). Convergence thresholds are problem-dependent. As this class is intended for users who want to set their own convergence criterion instead of relying on an algorithm's default procedure, they should also set the thresholds appropriately (cf. MATH-798). ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "SimpleValueChecker.SimpleValueChecker",
    "class_name": "org.apache.commons.math3.optimization.SimpleValueChecker",
    "signature": "org.apache.commons.math3.optimization.SimpleValueChecker.SimpleValueChecker()",
    "snippet": "    @Deprecated\n    public SimpleValueChecker() {}",
    "comment": " Build an instance with default thresholds. @deprecated See {@link AbstractConvergenceChecker#AbstractConvergenceChecker()} ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "BaseAbstractMultivariateOptimizer.BaseAbstractMultivariateOptimizer",
    "class_name": "org.apache.commons.math3.optimization.direct.BaseAbstractMultivariateOptimizer",
    "signature": "org.apache.commons.math3.optimization.direct.BaseAbstractMultivariateOptimizer.BaseAbstractMultivariateOptimizer(ConvergenceChecker)",
    "snippet": "    protected BaseAbstractMultivariateOptimizer(ConvergenceChecker<PointValuePair> checker) {\n        this.checker = checker;\n    }",
    "comment": " @param checker Convergence checker. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "BaseAbstractMultivariateOptimizer.computeObjectiveValue",
    "class_name": "org.apache.commons.math3.optimization.direct.BaseAbstractMultivariateOptimizer",
    "signature": "org.apache.commons.math3.optimization.direct.BaseAbstractMultivariateOptimizer.computeObjectiveValue(double[])",
    "snippet": "    protected double computeObjectiveValue(double[] point) {\n        try {\n            evaluations.incrementCount();\n        } catch (MaxCountExceededException e) {\n            throw new TooManyEvaluationsException(e.getMax());\n        }\n        return function.value(point);\n    }",
    "comment": " Compute the objective function value.  @param point Point at which the objective function must be evaluated. @return the objective function value at the specified point. @throws TooManyEvaluationsException if the maximal number of evaluations is exceeded. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "BaseAbstractMultivariateOptimizer.getGoalType",
    "class_name": "org.apache.commons.math3.optimization.direct.BaseAbstractMultivariateOptimizer",
    "signature": "org.apache.commons.math3.optimization.direct.BaseAbstractMultivariateOptimizer.getGoalType()",
    "snippet": "    public GoalType getGoalType() {\n        return goal;\n    }",
    "comment": " @return the optimization type. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "BaseAbstractMultivariateOptimizer.getMaxEvaluations",
    "class_name": "org.apache.commons.math3.optimization.direct.BaseAbstractMultivariateOptimizer",
    "signature": "org.apache.commons.math3.optimization.direct.BaseAbstractMultivariateOptimizer.getMaxEvaluations()",
    "snippet": "    public int getMaxEvaluations() {\n        return evaluations.getMaximalCount();\n    }",
    "comment": "{@inheritDoc} */",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "BaseAbstractMultivariateOptimizer.getStartPoint",
    "class_name": "org.apache.commons.math3.optimization.direct.BaseAbstractMultivariateOptimizer",
    "signature": "org.apache.commons.math3.optimization.direct.BaseAbstractMultivariateOptimizer.getStartPoint()",
    "snippet": "    public double[] getStartPoint() {\n        return start.clone();\n    }",
    "comment": " @return the initial guess. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "BaseAbstractMultivariateOptimizer.optimizeInternal",
    "class_name": "org.apache.commons.math3.optimization.direct.BaseAbstractMultivariateOptimizer",
    "signature": "org.apache.commons.math3.optimization.direct.BaseAbstractMultivariateOptimizer.optimizeInternal(int,MultivariateFunction,GoalType,double[])",
    "snippet": "    protected PointValuePair optimizeInternal(int maxEval, MultivariateFunction f, GoalType goalType,\n                                              double[] startPoint) {\n        // Checks.\n        if (f == null) {\n            throw new NullArgumentException();\n        }\n        if (goalType == null) {\n            throw new NullArgumentException();\n        }\n        if (startPoint == null) {\n            throw new NullArgumentException();\n        }\n\n        // Reset.\n        evaluations.setMaximalCount(maxEval);\n        evaluations.resetCount();\n\n        // Store optimization problem characteristics.\n        function = f;\n        goal = goalType;\n        start = startPoint.clone();\n\n        // Perform computation.\n        return doOptimize();\n    }",
    "comment": " Optimize an objective function.  @param f Objective function. @param goalType Type of optimization goal: either {@link GoalType#MAXIMIZE} or {@link GoalType#MINIMIZE}. @param startPoint Start point for optimization. @param maxEval Maximum number of function evaluations. @return the point/value pair giving the optimal value for objective function. @throws org.apache.commons.math3.exception.DimensionMismatchException if the start point dimension is wrong. @throws org.apache.commons.math3.exception.TooManyEvaluationsException if the maximal number of evaluations is exceeded. @throws org.apache.commons.math3.exception.NullArgumentException if any argument is {@code null}. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "BaseAbstractMultivariateSimpleBoundsOptimizer.BaseAbstractMultivariateSimpleBoundsOptimizer",
    "class_name": "org.apache.commons.math3.optimization.direct.BaseAbstractMultivariateSimpleBoundsOptimizer",
    "signature": "org.apache.commons.math3.optimization.direct.BaseAbstractMultivariateSimpleBoundsOptimizer.BaseAbstractMultivariateSimpleBoundsOptimizer(ConvergenceChecker)",
    "snippet": "    protected BaseAbstractMultivariateSimpleBoundsOptimizer(ConvergenceChecker<PointValuePair> checker) {\n        super(checker);\n    }",
    "comment": " @param checker Convergence checker. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "BaseAbstractMultivariateSimpleBoundsOptimizer.getLowerBound",
    "class_name": "org.apache.commons.math3.optimization.direct.BaseAbstractMultivariateSimpleBoundsOptimizer",
    "signature": "org.apache.commons.math3.optimization.direct.BaseAbstractMultivariateSimpleBoundsOptimizer.getLowerBound()",
    "snippet": "    public double[] getLowerBound() {\n        return lowerBound.clone();\n    }",
    "comment": " @return the lower bounds. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "BaseAbstractMultivariateSimpleBoundsOptimizer.getUpperBound",
    "class_name": "org.apache.commons.math3.optimization.direct.BaseAbstractMultivariateSimpleBoundsOptimizer",
    "signature": "org.apache.commons.math3.optimization.direct.BaseAbstractMultivariateSimpleBoundsOptimizer.getUpperBound()",
    "snippet": "    public double[] getUpperBound() {\n        return upperBound.clone();\n    }",
    "comment": " @return the upper bounds. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "CMAESOptimizer.CMAESOptimizer",
    "class_name": "org.apache.commons.math3.optimization.direct.CMAESOptimizer",
    "signature": "org.apache.commons.math3.optimization.direct.CMAESOptimizer.CMAESOptimizer()",
    "snippet": "    public CMAESOptimizer() {\n        this(0);\n    }",
    "comment": " Default constructor, uses default parameters ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "CMAESOptimizer.CMAESOptimizer",
    "class_name": "org.apache.commons.math3.optimization.direct.CMAESOptimizer",
    "signature": "org.apache.commons.math3.optimization.direct.CMAESOptimizer.CMAESOptimizer(int)",
    "snippet": "    public CMAESOptimizer(int lambda) {\n        this(lambda, null, DEFAULT_MAXITERATIONS, DEFAULT_STOPFITNESS,\n             DEFAULT_ISACTIVECMA, DEFAULT_DIAGONALONLY,\n             DEFAULT_CHECKFEASABLECOUNT, DEFAULT_RANDOMGENERATOR, false);\n    }",
    "comment": " @param lambda Population size. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "CMAESOptimizer.CMAESOptimizer",
    "class_name": "org.apache.commons.math3.optimization.direct.CMAESOptimizer",
    "signature": "org.apache.commons.math3.optimization.direct.CMAESOptimizer.CMAESOptimizer(int,double[],int,double,boolean,int,int,RandomGenerator,boolean)",
    "snippet": "    @Deprecated\n    public CMAESOptimizer(int lambda, double[] inputSigma,\n                          int maxIterations, double stopFitness,\n                          boolean isActiveCMA, int diagonalOnly, int checkFeasableCount,\n                          RandomGenerator random, boolean generateStatistics) {\n        this(lambda, inputSigma, maxIterations, stopFitness, isActiveCMA,\n             diagonalOnly, checkFeasableCount, random, generateStatistics,\n             new SimpleValueChecker());\n    }",
    "comment": " @param lambda Population size. @param inputSigma Initial search volume; sigma of offspring objective variables. @param maxIterations Maximal number of iterations. @param stopFitness Whether to stop if objective function value is smaller than {@code stopFitness}. @param isActiveCMA Chooses the covariance matrix update method. @param diagonalOnly Number of initial iterations, where the covariance matrix remains diagonal. @param checkFeasableCount Determines how often new random objective variables are generated in case they are out of bounds. @param random Random generator. @param generateStatistics Whether statistic data is collected. @deprecated See {@link SimpleValueChecker#SimpleValueChecker()} ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "CMAESOptimizer.CMAESOptimizer",
    "class_name": "org.apache.commons.math3.optimization.direct.CMAESOptimizer",
    "signature": "org.apache.commons.math3.optimization.direct.CMAESOptimizer.CMAESOptimizer(int,double[],int,double,boolean,int,int,RandomGenerator,boolean,ConvergenceChecker)",
    "snippet": "    public CMAESOptimizer(int lambda, double[] inputSigma,\n                          int maxIterations, double stopFitness,\n                          boolean isActiveCMA, int diagonalOnly, int checkFeasableCount,\n                          RandomGenerator random, boolean generateStatistics,\n                          ConvergenceChecker<PointValuePair> checker) {\n        super(checker);\n        this.lambda = lambda;\n        this.inputSigma = inputSigma == null ? null : (double[]) inputSigma.clone();\n        this.maxIterations = maxIterations;\n        this.stopFitness = stopFitness;\n        this.isActiveCMA = isActiveCMA;\n        this.diagonalOnly = diagonalOnly;\n        this.checkFeasableCount = checkFeasableCount;\n        this.random = random;\n        this.generateStatistics = generateStatistics;\n    }",
    "comment": " @param lambda Population size. @param inputSigma Initial search volume; sigma of offspring objective variables. @param maxIterations Maximal number of iterations. @param stopFitness Whether to stop if objective function value is smaller than {@code stopFitness}. @param isActiveCMA Chooses the covariance matrix update method. @param diagonalOnly Number of initial iterations, where the covariance matrix remains diagonal. @param checkFeasableCount Determines how often new random objective variables are generated in case they are out of bounds. @param random Random generator. @param generateStatistics Whether statistic data is collected. @param checker Convergence checker. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "CMAESOptimizer.checkParameters",
    "class_name": "org.apache.commons.math3.optimization.direct.CMAESOptimizer",
    "signature": "org.apache.commons.math3.optimization.direct.CMAESOptimizer.checkParameters()",
    "snippet": "    private void checkParameters() {\n        final double[] init = getStartPoint();\n        final double[] lB = getLowerBound();\n        final double[] uB = getUpperBound();\n\n        // Checks whether there is at least one finite bound value.\n        boolean hasFiniteBounds = false;\n        for (int i = 0; i < lB.length; i++) {\n            if (!Double.isInfinite(lB[i]) ||\n                !Double.isInfinite(uB[i])) {\n                hasFiniteBounds = true;\n                break;\n            }\n        }\n        // Checks whether there is at least one infinite bound value.\n        boolean hasInfiniteBounds = false;\n        if (hasFiniteBounds) {\n            for (int i = 0; i < lB.length; i++) {\n                if (Double.isInfinite(lB[i]) ||\n                    Double.isInfinite(uB[i])) {\n                    hasInfiniteBounds = true;\n                    break;\n                }\n            }\n\n            if (hasInfiniteBounds) {\n                // If there is at least one finite bound, none can be infinite,\n                // because mixed cases are not supported by the current code.\n                throw new MathUnsupportedOperationException();\n            } else {\n                // Convert API to internal handling of boundaries.\n                boundaries = new double[2][];\n                boundaries[0] = lB;\n                boundaries[1] = uB;\n\n                // Abort early if the normalization will overflow (cf. \"encode\" method).\n            }\n        } else {\n            // Convert API to internal handling of boundaries.\n            boundaries = null;\n        }\n\n        if (inputSigma != null) {\n            if (inputSigma.length != init.length) {\n                throw new DimensionMismatchException(inputSigma.length, init.length);\n            }\n            for (int i = 0; i < init.length; i++) {\n                if (inputSigma[i] < 0) {\n                    throw new NotPositiveException(inputSigma[i]);\n                }\n                if (boundaries != null) {\n                    if (inputSigma[i] > boundaries[1][i] - boundaries[0][i]) {\n                        throw new OutOfRangeException(inputSigma[i], 0, boundaries[1][i] - boundaries[0][i]);\n                    }\n                }\n            }\n        }\n    }",
    "comment": " Checks dimensions and values of boundaries and inputSigma if defined. ",
    "is_bug": true,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "CMAESOptimizer.diag",
    "class_name": "org.apache.commons.math3.optimization.direct.CMAESOptimizer",
    "signature": "org.apache.commons.math3.optimization.direct.CMAESOptimizer.diag(RealMatrix)",
    "snippet": "    private static RealMatrix diag(final RealMatrix m) {\n        if (m.getColumnDimension() == 1) {\n            double[][] d = new double[m.getRowDimension()][m.getRowDimension()];\n            for (int i = 0; i < m.getRowDimension(); i++) {\n                d[i][i] = m.getEntry(i, 0);\n            }\n            return new Array2DRowRealMatrix(d, false);\n        } else {\n            double[][] d = new double[m.getRowDimension()][1];\n            for (int i = 0; i < m.getColumnDimension(); i++) {\n                d[i][0] = m.getEntry(i, i);\n            }\n            return new Array2DRowRealMatrix(d, false);\n        }\n    }",
    "comment": " @param m Input matrix. @return the diagonal n-by-n matrix if m is a column matrix or the column matrix representing the diagonal if m is a n-by-n matrix. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "CMAESOptimizer.doOptimize",
    "class_name": "org.apache.commons.math3.optimization.direct.CMAESOptimizer",
    "signature": "org.apache.commons.math3.optimization.direct.CMAESOptimizer.doOptimize()",
    "snippet": "    @Override\n    protected PointValuePair doOptimize() {\n        checkParameters();\n         // -------------------- Initialization --------------------------------\n        isMinimize = getGoalType().equals(GoalType.MINIMIZE);\n        final FitnessFunction fitfun = new FitnessFunction();\n        final double[] guess = fitfun.encode(getStartPoint());\n        // number of objective variables/problem dimension\n        dimension = guess.length;\n        initializeCMA(guess);\n        iterations = 0;\n        double bestValue = fitfun.value(guess);\n        push(fitnessHistory, bestValue);\n        PointValuePair optimum = new PointValuePair(getStartPoint(),\n                isMinimize ? bestValue : -bestValue);\n        PointValuePair lastResult = null;\n\n        // -------------------- Generation Loop --------------------------------\n\n        generationLoop:\n            for (iterations = 1; iterations <= maxIterations; iterations++) {\n                // Generate and evaluate lambda offspring\n                RealMatrix arz = randn1(dimension, lambda);\n                RealMatrix arx = zeros(dimension, lambda);\n                double[] fitness = new double[lambda];\n                // generate random offspring\n                for (int k = 0; k < lambda; k++) {\n                    RealMatrix arxk = null;\n                    for (int i = 0; i < checkFeasableCount+1; i++) {\n                        if (diagonalOnly <= 0) {\n                            arxk = xmean.add(BD.multiply(arz.getColumnMatrix(k))\n                                    .scalarMultiply(sigma)); // m + sig * Normal(0,C)\n                        } else {\n                            arxk = xmean.add(times(diagD,arz.getColumnMatrix(k))\n                                    .scalarMultiply(sigma));\n                        }\n                        if (i >= checkFeasableCount || fitfun.isFeasible(arxk.getColumn(0))) {\n                            break;\n                        }\n                        // regenerate random arguments for row\n                        arz.setColumn(k, randn(dimension));\n                    }\n                    copyColumn(arxk, 0, arx, k);\n                    try {\n                        fitness[k] = fitfun.value(arx.getColumn(k)); // compute fitness\n                    } catch (TooManyEvaluationsException e) {\n                        break generationLoop;\n                    }\n                }\n                // Sort by fitness and compute weighted mean into xmean\n                int[] arindex = sortedIndices(fitness);\n                // Calculate new xmean, this is selection and recombination\n                RealMatrix xold = xmean; // for speed up of Eq. (2) and (3)\n                RealMatrix bestArx = selectColumns(arx, MathArrays.copyOf(arindex, mu));\n                xmean = bestArx.multiply(weights);\n                RealMatrix bestArz = selectColumns(arz, MathArrays.copyOf(arindex, mu));\n                RealMatrix zmean = bestArz.multiply(weights);\n                boolean hsig = updateEvolutionPaths(zmean, xold);\n                if (diagonalOnly <= 0) {\n                    updateCovariance(hsig, bestArx, arz, arindex, xold);\n                } else {\n                    updateCovarianceDiagonalOnly(hsig, bestArz, xold);\n                }\n                // Adapt step size sigma - Eq. (5)\n                sigma *= Math.exp(Math.min(1.0,(normps/chiN - 1.)*cs/damps));\n                double bestFitness = fitness[arindex[0]];\n                double worstFitness = fitness[arindex[arindex.length-1]];\n                if (bestValue > bestFitness) {\n                    bestValue = bestFitness;\n                    lastResult = optimum;\n                    optimum = new PointValuePair(\n                            fitfun.repairAndDecode(bestArx.getColumn(0)),\n                            isMinimize ? bestFitness : -bestFitness);\n                    if (getConvergenceChecker() != null && lastResult != null) {\n                        if (getConvergenceChecker().converged(iterations, optimum, lastResult)) {\n                            break generationLoop;\n                        }\n                    }\n                }\n                // handle termination criteria\n                // Break, if fitness is good enough\n                if (stopFitness != 0) { // only if stopFitness is defined\n                    if (bestFitness < (isMinimize ? stopFitness : -stopFitness)) {\n                        break generationLoop;\n                    }\n                }\n                double[] sqrtDiagC = sqrt(diagC).getColumn(0);\n                double[] pcCol = pc.getColumn(0);\n                for (int i = 0; i < dimension; i++) {\n                    if (sigma*(Math.max(Math.abs(pcCol[i]), sqrtDiagC[i])) > stopTolX) {\n                        break;\n                    }\n                    if (i >= dimension-1) {\n                        break generationLoop;\n                    }\n                }\n                for (int i = 0; i < dimension; i++) {\n                    if (sigma*sqrtDiagC[i] > stopTolUpX) {\n                        break generationLoop;\n                    }\n                }\n                double historyBest = min(fitnessHistory);\n                double historyWorst = max(fitnessHistory);\n                if (iterations > 2 && Math.max(historyWorst, worstFitness) -\n                        Math.min(historyBest, bestFitness) < stopTolFun) {\n                    break generationLoop;\n                }\n                if (iterations > fitnessHistory.length &&\n                        historyWorst-historyBest < stopTolHistFun) {\n                    break generationLoop;\n                }\n                // condition number of the covariance matrix exceeds 1e14\n                if (max(diagD)/min(diagD) > 1e7) {\n                    break generationLoop;\n                }\n                // user defined termination\n                if (getConvergenceChecker() != null) {\n                    PointValuePair current =\n                        new PointValuePair(bestArx.getColumn(0),\n                                isMinimize ? bestFitness : -bestFitness);\n                    if (lastResult != null &&\n                        getConvergenceChecker().converged(iterations, current, lastResult)) {\n                        break generationLoop;\n                    }\n                    lastResult = current;\n                }\n                // Adjust step size in case of equal function values (flat fitness)\n                if (bestValue == fitness[arindex[(int)(0.1+lambda/4.)]]) {\n                    sigma = sigma * Math.exp(0.2+cs/damps);\n                }\n                if (iterations > 2 && Math.max(historyWorst, bestFitness) -\n                        Math.min(historyBest, bestFitness) == 0) {\n                    sigma = sigma * Math.exp(0.2+cs/damps);\n                }\n                // store best in history\n                push(fitnessHistory,bestFitness);\n                fitfun.setValueRange(worstFitness-bestFitness);\n                if (generateStatistics) {\n                    statisticsSigmaHistory.add(sigma);\n                    statisticsFitnessHistory.add(bestFitness);\n                    statisticsMeanHistory.add(xmean.transpose());\n                    statisticsDHistory.add(diagD.transpose().scalarMultiply(1E5));\n                }\n            }\n        return optimum;\n    }",
    "comment": "{@inheritDoc} */",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "CMAESOptimizer.eye",
    "class_name": "org.apache.commons.math3.optimization.direct.CMAESOptimizer",
    "signature": "org.apache.commons.math3.optimization.direct.CMAESOptimizer.eye(int,int)",
    "snippet": "    private static RealMatrix eye(int n, int m) {\n        double[][] d = new double[n][m];\n        for (int r = 0; r < n; r++) {\n            if (r < m) {\n                d[r][r] = 1;\n            }\n        }\n        return new Array2DRowRealMatrix(d, false);\n    }",
    "comment": " @param n Number of rows. @param m Number of columns. @return n-by-m matrix of 0.0-values, diagonal has values 1.0. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "CMAESOptimizer.initializeCMA",
    "class_name": "org.apache.commons.math3.optimization.direct.CMAESOptimizer",
    "signature": "org.apache.commons.math3.optimization.direct.CMAESOptimizer.initializeCMA(double[])",
    "snippet": "    private void initializeCMA(double[] guess) {\n        if (lambda <= 0) {\n            lambda = 4 + (int) (3. * Math.log(dimension));\n        }\n        // initialize sigma\n        double[][] sigmaArray = new double[guess.length][1];\n        for (int i = 0; i < guess.length; i++) {\n            final double range =  (boundaries == null) ? 1.0 : boundaries[1][i] - boundaries[0][i];\n            sigmaArray[i][0]   = ((inputSigma == null) ? 0.3 : inputSigma[i]) / range;\n        }\n        RealMatrix insigma = new Array2DRowRealMatrix(sigmaArray, false);\n        sigma = max(insigma); // overall standard deviation\n\n        // initialize termination criteria\n        stopTolUpX = 1e3 * max(insigma);\n        stopTolX = 1e-11 * max(insigma);\n        stopTolFun = 1e-12;\n        stopTolHistFun = 1e-13;\n\n        // initialize selection strategy parameters\n        mu = lambda / 2; // number of parents/points for recombination\n        logMu2 = Math.log(mu + 0.5);\n        weights = log(sequence(1, mu, 1)).scalarMultiply(-1.).scalarAdd(logMu2);\n        double sumw = 0;\n        double sumwq = 0;\n        for (int i = 0; i < mu; i++) {\n            double w = weights.getEntry(i, 0);\n            sumw += w;\n            sumwq += w * w;\n        }\n        weights = weights.scalarMultiply(1. / sumw);\n        mueff = sumw * sumw / sumwq; // variance-effectiveness of sum w_i x_i\n\n        // initialize dynamic strategy parameters and constants\n        cc = (4. + mueff / dimension) /\n                (dimension + 4. + 2. * mueff / dimension);\n        cs = (mueff + 2.) / (dimension + mueff + 3.);\n        damps = (1. + 2. * Math.max(0, Math.sqrt((mueff - 1.) /\n                (dimension + 1.)) - 1.)) *\n                Math.max(0.3, 1. - dimension /\n                        (1e-6 + Math.min(maxIterations, getMaxEvaluations() /\n                                lambda))) + cs; // minor increment\n        ccov1 = 2. / ((dimension + 1.3) * (dimension + 1.3) + mueff);\n        ccovmu = Math.min(1 - ccov1, 2. * (mueff - 2. + 1. / mueff) /\n                ((dimension + 2.) * (dimension + 2.) + mueff));\n        ccov1Sep = Math.min(1, ccov1 * (dimension + 1.5) / 3.);\n        ccovmuSep = Math.min(1 - ccov1, ccovmu * (dimension + 1.5) / 3.);\n        chiN = Math.sqrt(dimension) *\n                (1. - 1. / (4. * dimension) + 1 / (21. * dimension * dimension));\n        // intialize CMA internal values - updated each generation\n        xmean = MatrixUtils.createColumnRealMatrix(guess); // objective\n                                                           // variables\n        diagD = insigma.scalarMultiply(1. / sigma);\n        diagC = square(diagD);\n        pc = zeros(dimension, 1); // evolution paths for C and sigma\n        ps = zeros(dimension, 1); // B defines the coordinate system\n        normps = ps.getFrobeniusNorm();\n\n        B = eye(dimension, dimension);\n        D = ones(dimension, 1); // diagonal D defines the scaling\n        BD = times(B, repmat(diagD.transpose(), dimension, 1));\n        C = B.multiply(diag(square(D)).multiply(B.transpose())); // covariance\n        historySize = 10 + (int) (3. * 10. * dimension / lambda);\n        fitnessHistory = new double[historySize]; // history of fitness values\n        for (int i = 0; i < historySize; i++) {\n            fitnessHistory[i] = Double.MAX_VALUE;\n        }\n    }",
    "comment": " Initialization of the dynamic search parameters  @param guess Initial guess for the arguments of the fitness function. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "CMAESOptimizer.log",
    "class_name": "org.apache.commons.math3.optimization.direct.CMAESOptimizer",
    "signature": "org.apache.commons.math3.optimization.direct.CMAESOptimizer.log(RealMatrix)",
    "snippet": "    private static RealMatrix log(final RealMatrix m) {\n        double[][] d = new double[m.getRowDimension()][m.getColumnDimension()];\n        for (int r = 0; r < m.getRowDimension(); r++) {\n            for (int c = 0; c < m.getColumnDimension(); c++) {\n                d[r][c] = Math.log(m.getEntry(r, c));\n            }\n        }\n        return new Array2DRowRealMatrix(d, false);\n    }",
    "comment": " @param m Input matrix @return Matrix representing the element-wise logarithm of m. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "CMAESOptimizer.max",
    "class_name": "org.apache.commons.math3.optimization.direct.CMAESOptimizer",
    "signature": "org.apache.commons.math3.optimization.direct.CMAESOptimizer.max(RealMatrix)",
    "snippet": "    private static double max(final RealMatrix m) {\n        double max = -Double.MAX_VALUE;\n        for (int r = 0; r < m.getRowDimension(); r++) {\n            for (int c = 0; c < m.getColumnDimension(); c++) {\n                double e = m.getEntry(r, c);\n                if (max < e) {\n                    max = e;\n                }\n            }\n        }\n        return max;\n    }",
    "comment": " @param m Input matrix. @return the maximum of the matrix element values. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "CMAESOptimizer.ones",
    "class_name": "org.apache.commons.math3.optimization.direct.CMAESOptimizer",
    "signature": "org.apache.commons.math3.optimization.direct.CMAESOptimizer.ones(int,int)",
    "snippet": "    private static RealMatrix ones(int n, int m) {\n        double[][] d = new double[n][m];\n        for (int r = 0; r < n; r++) {\n            Arrays.fill(d[r], 1.0);\n        }\n        return new Array2DRowRealMatrix(d, false);\n    }",
    "comment": " @param n Number of rows. @param m Number of columns. @return n-by-m matrix filled with 1. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "CMAESOptimizer.repmat",
    "class_name": "org.apache.commons.math3.optimization.direct.CMAESOptimizer",
    "signature": "org.apache.commons.math3.optimization.direct.CMAESOptimizer.repmat(RealMatrix,int,int)",
    "snippet": "    private static RealMatrix repmat(final RealMatrix mat, int n, int m) {\n        int rd = mat.getRowDimension();\n        int cd = mat.getColumnDimension();\n        double[][] d = new double[n * rd][m * cd];\n        for (int r = 0; r < n * rd; r++) {\n            for (int c = 0; c < m * cd; c++) {\n                d[r][c] = mat.getEntry(r % rd, c % cd);\n            }\n        }\n        return new Array2DRowRealMatrix(d, false);\n    }",
    "comment": " @param mat Input matrix. @param n Number of row replicates. @param m Number of column replicates. @return a matrix which replicates the input matrix in both directions. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "CMAESOptimizer.sequence",
    "class_name": "org.apache.commons.math3.optimization.direct.CMAESOptimizer",
    "signature": "org.apache.commons.math3.optimization.direct.CMAESOptimizer.sequence(double,double,double)",
    "snippet": "    private static RealMatrix sequence(double start, double end, double step) {\n        int size = (int) ((end - start) / step + 1);\n        double[][] d = new double[size][1];\n        double value = start;\n        for (int r = 0; r < size; r++) {\n            d[r][0] = value;\n            value += step;\n        }\n        return new Array2DRowRealMatrix(d, false);\n    }",
    "comment": " @param start Start value. @param end End value. @param step Step size. @return a sequence as column matrix. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "CMAESOptimizer.square",
    "class_name": "org.apache.commons.math3.optimization.direct.CMAESOptimizer",
    "signature": "org.apache.commons.math3.optimization.direct.CMAESOptimizer.square(RealMatrix)",
    "snippet": "    private static RealMatrix square(final RealMatrix m) {\n        double[][] d = new double[m.getRowDimension()][m.getColumnDimension()];\n        for (int r = 0; r < m.getRowDimension(); r++) {\n            for (int c = 0; c < m.getColumnDimension(); c++) {\n                double e = m.getEntry(r, c);\n                d[r][c] = e * e;\n            }\n        }\n        return new Array2DRowRealMatrix(d, false);\n    }",
    "comment": " @param m Input matrix @return Matrix representing the element-wise square (^2) of m. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "CMAESOptimizer.times",
    "class_name": "org.apache.commons.math3.optimization.direct.CMAESOptimizer",
    "signature": "org.apache.commons.math3.optimization.direct.CMAESOptimizer.times(RealMatrix,RealMatrix)",
    "snippet": "    private static RealMatrix times(final RealMatrix m, final RealMatrix n) {\n        double[][] d = new double[m.getRowDimension()][m.getColumnDimension()];\n        for (int r = 0; r < m.getRowDimension(); r++) {\n            for (int c = 0; c < m.getColumnDimension(); c++) {\n                d[r][c] = m.getEntry(r, c) * n.getEntry(r, c);\n            }\n        }\n        return new Array2DRowRealMatrix(d, false);\n    }",
    "comment": " @param m Input matrix 1. @param n Input matrix 2. @return the matrix where the elements of m and n are element-wise multiplied. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "CMAESOptimizer.zeros",
    "class_name": "org.apache.commons.math3.optimization.direct.CMAESOptimizer",
    "signature": "org.apache.commons.math3.optimization.direct.CMAESOptimizer.zeros(int,int)",
    "snippet": "    private static RealMatrix zeros(int n, int m) {\n        return new Array2DRowRealMatrix(n, m);\n    }",
    "comment": " @param n Number of rows. @param m Number of columns. @return n-by-m matrix of 0.0-values. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "FitnessFunction.decode",
    "class_name": "org.apache.commons.math3.optimization.direct.CMAESOptimizer$FitnessFunction",
    "signature": "org.apache.commons.math3.optimization.direct.CMAESOptimizer$FitnessFunction.decode(double[])",
    "snippet": "        public double[] decode(final double[] x) {\n            if (boundaries == null) {\n                return x;\n            }\n            double[] res = new double[x.length];\n            for (int i = 0; i < x.length; i++) {\n                double diff = boundaries[1][i] - boundaries[0][i];\n                res[i] = diff * x[i] + boundaries[0][i];\n            }\n            return res;\n        }",
    "comment": " @param x Normalized objective variables. @return the original objective variables. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "FitnessFunction.encode",
    "class_name": "org.apache.commons.math3.optimization.direct.CMAESOptimizer$FitnessFunction",
    "signature": "org.apache.commons.math3.optimization.direct.CMAESOptimizer$FitnessFunction.encode(double[])",
    "snippet": "        public double[] encode(final double[] x) {\n            if (boundaries == null) {\n                return x;\n            }\n            double[] res = new double[x.length];\n            for (int i = 0; i < x.length; i++) {\n                double diff = boundaries[1][i] - boundaries[0][i];\n                res[i] = (x[i] - boundaries[0][i]) / diff;\n            }\n            return res;\n        }",
    "comment": " @param x Original objective variables. @return the normalized objective variables. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "FitnessFunction.repair",
    "class_name": "org.apache.commons.math3.optimization.direct.CMAESOptimizer$FitnessFunction",
    "signature": "org.apache.commons.math3.optimization.direct.CMAESOptimizer$FitnessFunction.repair(double[])",
    "snippet": "        private double[] repair(final double[] x) {\n            double[] repaired = new double[x.length];\n            for (int i = 0; i < x.length; i++) {\n                if (x[i] < 0) {\n                    repaired[i] = 0;\n                } else if (x[i] > 1.0) {\n                    repaired[i] = 1.0;\n                } else {\n                    repaired[i] = x[i];\n                }\n            }\n            return repaired;\n        }",
    "comment": " @param x Normalized objective variables. @return the repaired objective variables - all in bounds. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "FitnessFunction.value",
    "class_name": "org.apache.commons.math3.optimization.direct.CMAESOptimizer$FitnessFunction",
    "signature": "org.apache.commons.math3.optimization.direct.CMAESOptimizer$FitnessFunction.value(double[])",
    "snippet": "        public double value(final double[] point) {\n            double value;\n            if (boundaries != null && isRepairMode) {\n                double[] repaired = repair(point);\n                value = CMAESOptimizer.this\n                        .computeObjectiveValue(decode(repaired)) +\n                        penalty(point, repaired);\n            } else {\n                value = CMAESOptimizer.this\n                        .computeObjectiveValue(decode(point));\n            }\n            return isMinimize ? value : -value;\n        }",
    "comment": " @param point Normalized objective variables. @return the objective value + penalty for violated bounds. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "BitsStreamGenerator.BitsStreamGenerator",
    "class_name": "org.apache.commons.math3.random.BitsStreamGenerator",
    "signature": "org.apache.commons.math3.random.BitsStreamGenerator.BitsStreamGenerator()",
    "snippet": "    public BitsStreamGenerator() {\n        nextGaussian = Double.NaN;\n    }",
    "comment": "Creates a new random number generator. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "BitsStreamGenerator.clear",
    "class_name": "org.apache.commons.math3.random.BitsStreamGenerator",
    "signature": "org.apache.commons.math3.random.BitsStreamGenerator.clear()",
    "snippet": "    public void clear() {\n        nextGaussian = Double.NaN;\n    }",
    "comment": " Clears the cache used by the default implementation of {@link #nextGaussian}. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "MersenneTwister.MersenneTwister",
    "class_name": "org.apache.commons.math3.random.MersenneTwister",
    "signature": "org.apache.commons.math3.random.MersenneTwister.MersenneTwister()",
    "snippet": "    public MersenneTwister() {\n        mt = new int[N];\n        setSeed(System.currentTimeMillis() + System.identityHashCode(this));\n    }",
    "comment": "Creates a new random number generator. <p>The instance is initialized using the current time plus the system identity hash code of this instance as the seed.</p> ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "MersenneTwister.setSeed",
    "class_name": "org.apache.commons.math3.random.MersenneTwister",
    "signature": "org.apache.commons.math3.random.MersenneTwister.setSeed(int)",
    "snippet": "    @Override\n    public void setSeed(int seed) {\n        // we use a long masked by 0xffffffffL as a poor man unsigned int\n        long longMT = seed;\n        // NB: unlike original C code, we are working with java longs, the cast below makes masking unnecessary\n        mt[0]= (int) longMT;\n        for (mti = 1; mti < N; ++mti) {\n            // See Knuth TAOCP Vol2. 3rd Ed. P.106 for multiplier.\n            // initializer from the 2002-01-09 C version by Makoto Matsumoto\n            longMT = (1812433253l * (longMT ^ (longMT >> 30)) + mti) & 0xffffffffL;\n            mt[mti]= (int) longMT;\n        }\n\n        clear(); // Clear normal deviate cache\n    }",
    "comment": "Reinitialize the generator as if just built with the given int seed. <p>The state of the generator is exactly the same as a new generator built with the same seed.</p> @param seed the initial seed (32 bits integer) ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "MersenneTwister.setSeed",
    "class_name": "org.apache.commons.math3.random.MersenneTwister",
    "signature": "org.apache.commons.math3.random.MersenneTwister.setSeed(int[])",
    "snippet": "    @Override\n    public void setSeed(int[] seed) {\n\n        if (seed == null) {\n            setSeed(System.currentTimeMillis() + System.identityHashCode(this));\n            return;\n        }\n\n        setSeed(19650218);\n        int i = 1;\n        int j = 0;\n\n        for (int k = FastMath.max(N, seed.length); k != 0; k--) {\n            long l0 = (mt[i] & 0x7fffffffl)   | ((mt[i]   < 0) ? 0x80000000l : 0x0l);\n            long l1 = (mt[i-1] & 0x7fffffffl) | ((mt[i-1] < 0) ? 0x80000000l : 0x0l);\n            long l  = (l0 ^ ((l1 ^ (l1 >> 30)) * 1664525l)) + seed[j] + j; // non linear\n            mt[i]   = (int) (l & 0xffffffffl);\n            i++; j++;\n            if (i >= N) {\n                mt[0] = mt[N - 1];\n                i = 1;\n            }\n            if (j >= seed.length) {\n                j = 0;\n            }\n        }\n\n        for (int k = N - 1; k != 0; k--) {\n            long l0 = (mt[i] & 0x7fffffffl)   | ((mt[i]   < 0) ? 0x80000000l : 0x0l);\n            long l1 = (mt[i-1] & 0x7fffffffl) | ((mt[i-1] < 0) ? 0x80000000l : 0x0l);\n            long l  = (l0 ^ ((l1 ^ (l1 >> 30)) * 1566083941l)) - i; // non linear\n            mt[i]   = (int) (l & 0xffffffffL);\n            i++;\n            if (i >= N) {\n                mt[0] = mt[N - 1];\n                i = 1;\n            }\n        }\n\n        mt[0] = 0x80000000; // MSB is 1; assuring non-zero initial array\n\n        clear(); // Clear normal deviate cache\n\n    }",
    "comment": "Reinitialize the generator as if just built with the given int array seed. <p>The state of the generator is exactly the same as a new generator built with the same seed.</p> @param seed the initial seed (32 bits integers array), if null the seed of the generator will be the current system time plus the system identity hash code of this instance ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "MersenneTwister.setSeed",
    "class_name": "org.apache.commons.math3.random.MersenneTwister",
    "signature": "org.apache.commons.math3.random.MersenneTwister.setSeed(long)",
    "snippet": "    @Override\n    public void setSeed(long seed) {\n        setSeed(new int[] { (int) (seed >>> 32), (int) (seed & 0xffffffffl) });\n    }",
    "comment": "Reinitialize the generator as if just built with the given long seed. <p>The state of the generator is exactly the same as a new generator built with the same seed.</p> @param seed the initial seed (64 bits integer) ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "CompositeFormat.getDefaultNumberFormat",
    "class_name": "org.apache.commons.math3.util.CompositeFormat",
    "signature": "org.apache.commons.math3.util.CompositeFormat.getDefaultNumberFormat()",
    "snippet": "    public static NumberFormat getDefaultNumberFormat() {\n        return getDefaultNumberFormat(Locale.getDefault());\n    }",
    "comment": " Create a default number format.  The default number format is based on {@link NumberFormat#getInstance()} with the only customizing that the maximum number of fraction digits is set to 10. @return the default number format. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "CompositeFormat.getDefaultNumberFormat",
    "class_name": "org.apache.commons.math3.util.CompositeFormat",
    "signature": "org.apache.commons.math3.util.CompositeFormat.getDefaultNumberFormat(Locale)",
    "snippet": "    public static NumberFormat getDefaultNumberFormat(final Locale locale) {\n        final NumberFormat nf = NumberFormat.getInstance(locale);\n        nf.setMaximumFractionDigits(10);\n        return nf;\n    }",
    "comment": " Create a default number format.  The default number format is based on {@link NumberFormat#getInstance(java.util.Locale)} with the only customizing that the maximum number of fraction digits is set to 10. @param locale the specific locale used by the format. @return the default number format specific to the given locale. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "FastMath.max",
    "class_name": "org.apache.commons.math3.util.FastMath",
    "signature": "org.apache.commons.math3.util.FastMath.max(int,int)",
    "snippet": "    public static int max(final int a, final int b) {\n        return (a <= b) ? b : a;\n    }",
    "comment": "Compute the maximum of two values @param a first value @param b second value @return b if a is lesser or equal to b, a otherwise ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "FastMath.nextAfter",
    "class_name": "org.apache.commons.math3.util.FastMath",
    "signature": "org.apache.commons.math3.util.FastMath.nextAfter(double,double)",
    "snippet": "    public static double nextAfter(double d, double direction) {\n\n        // handling of some important special cases\n        if (Double.isNaN(d) || Double.isNaN(direction)) {\n            return Double.NaN;\n        } else if (d == direction) {\n            return direction;\n        } else if (Double.isInfinite(d)) {\n            return (d < 0) ? -Double.MAX_VALUE : Double.MAX_VALUE;\n        } else if (d == 0) {\n            return (direction < 0) ? -Double.MIN_VALUE : Double.MIN_VALUE;\n        }\n        // special cases MAX_VALUE to infinity and  MIN_VALUE to 0\n        // are handled just as normal numbers\n\n        final long bits = Double.doubleToLongBits(d);\n        final long sign = bits & 0x8000000000000000L;\n        if ((direction < d) ^ (sign == 0L)) {\n            return Double.longBitsToDouble(sign | ((bits & 0x7fffffffffffffffL) + 1));\n        } else {\n            return Double.longBitsToDouble(sign | ((bits & 0x7fffffffffffffffL) - 1));\n        }\n\n    }",
    "comment": " Get the next machine representable number after a number, moving in the direction of another number. <p> The ordering is as follows (increasing): <ul> <li>-INFINITY</li> <li>-MAX_VALUE</li> <li>-MIN_VALUE</li> <li>-0.0</li> <li>+0.0</li> <li>+MIN_VALUE</li> <li>+MAX_VALUE</li> <li>+INFINITY</li> <li></li> <p> If arguments compare equal, then the second argument is returned. <p> If {@code direction} is greater than {@code d}, the smallest machine representable number strictly greater than {@code d} is returned; if less, then the largest representable number strictly less than {@code d} is returned.</p> <p> If {@code d} is infinite and direction does not bring it back to finite numbers, it is returned unchanged.</p>  @param d base number @param direction (the only important thing is whether {@code direction} is greater or smaller than {@code d}) @return the next machine representable number in the specified direction ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "FastMath.nextUp",
    "class_name": "org.apache.commons.math3.util.FastMath",
    "signature": "org.apache.commons.math3.util.FastMath.nextUp(double)",
    "snippet": "    public static double nextUp(final double a) {\n        return nextAfter(a, Double.POSITIVE_INFINITY);\n    }",
    "comment": "Compute next number towards positive infinity. @param a number to which neighbor should be computed @return neighbor of a towards positive infinity ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "FastMath.sqrt",
    "class_name": "org.apache.commons.math3.util.FastMath",
    "signature": "org.apache.commons.math3.util.FastMath.sqrt(double)",
    "snippet": "    public static double sqrt(final double a) {\n        return Math.sqrt(a);\n    }",
    "comment": "Compute the square root of a number. <p><b>Note:</b> this implementation currently delegates to {@link Math#sqrt} @param a number on which evaluation is done @return square root of a ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "Incrementor.Incrementor",
    "class_name": "org.apache.commons.math3.util.Incrementor",
    "signature": "org.apache.commons.math3.util.Incrementor.Incrementor()",
    "snippet": "    public Incrementor() {\n        this(0);\n    }",
    "comment": " Default constructor. For the new instance to be useful, the maximal count must be set by calling {@link #setMaximalCount(int) setMaximalCount}. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "Incrementor.Incrementor",
    "class_name": "org.apache.commons.math3.util.Incrementor",
    "signature": "org.apache.commons.math3.util.Incrementor.Incrementor(int)",
    "snippet": "    public Incrementor(int max) {\n        this(max,\n             new MaxCountExceededCallback() {\n                 /** {@inheritDoc} */\n                 public void trigger(int max) {\n                     throw new MaxCountExceededException(max);\n                 }\n             });\n    }",
    "comment": " Defines a maximal count.  @param max Maximal count. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "Incrementor.Incrementor",
    "class_name": "org.apache.commons.math3.util.Incrementor",
    "signature": "org.apache.commons.math3.util.Incrementor.Incrementor(int,MaxCountExceededCallback)",
    "snippet": "    public Incrementor(int max,\n                       MaxCountExceededCallback cb) {\n        if (cb == null){\n            throw new NullArgumentException();\n        }\n        maximalCount = max;\n        maxCountCallback = cb;\n    }",
    "comment": " Defines a maximal count and a callback method to be triggered at counter exhaustion.  @param max Maximal count. @param cb Function to be called when the maximal count has been reached. @throws NullArgumentException if {@code cb} is {@code null} ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "Incrementor.getMaximalCount",
    "class_name": "org.apache.commons.math3.util.Incrementor",
    "signature": "org.apache.commons.math3.util.Incrementor.getMaximalCount()",
    "snippet": "    public int getMaximalCount() {\n        return maximalCount;\n    }",
    "comment": " Gets the upper limit of the counter.  @return the counter upper limit. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "Incrementor.incrementCount",
    "class_name": "org.apache.commons.math3.util.Incrementor",
    "signature": "org.apache.commons.math3.util.Incrementor.incrementCount()",
    "snippet": "    public void incrementCount() {\n        if (++count > maximalCount) {\n            maxCountCallback.trigger(maximalCount);\n        }\n    }",
    "comment": " Adds one to the current iteration count. At counter exhaustion, this method will call the {@link MaxCountExceededCallback#trigger(int) trigger} method of the callback object passed to the {@link #Incrementor(int,MaxCountExceededCallback) constructor}. If not explictly set, a default callback is used that will throw a {@code MaxCountExceededException}.  @throws MaxCountExceededException at counter exhaustion, unless a custom {@link MaxCountExceededCallback callback} has been set at construction. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "Incrementor.resetCount",
    "class_name": "org.apache.commons.math3.util.Incrementor",
    "signature": "org.apache.commons.math3.util.Incrementor.resetCount()",
    "snippet": "    public void resetCount() {\n        count = 0;\n    }",
    "comment": " Resets the counter to 0. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "Incrementor.setMaximalCount",
    "class_name": "org.apache.commons.math3.util.Incrementor",
    "signature": "org.apache.commons.math3.util.Incrementor.setMaximalCount(int)",
    "snippet": "    public void setMaximalCount(int max) {\n        maximalCount = max;\n    }",
    "comment": " Sets the upper limit for the counter. This does not automatically reset the current count to zero (see {@link #resetCount()}).  @param max Upper limit of the counter. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  }
]