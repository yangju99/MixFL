[
  {
    "name": "AbstractMessageFormatter.AbstractMessageFormatter",
    "class_name": "com.google.javascript.jscomp.AbstractMessageFormatter",
    "signature": "com.google.javascript.jscomp.AbstractMessageFormatter.AbstractMessageFormatter(SourceExcerptProvider)",
    "snippet": "  public AbstractMessageFormatter(SourceExcerptProvider source) {\n    this.source = source;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 0
  },
  {
    "name": "AbstractMessageFormatter.setColorize",
    "class_name": "com.google.javascript.jscomp.AbstractMessageFormatter",
    "signature": "com.google.javascript.jscomp.AbstractMessageFormatter.setColorize(boolean)",
    "snippet": "  public void setColorize(boolean colorize) {\n    this.colorize = colorize;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 0
  },
  {
    "name": "AstValidator.AstValidator",
    "class_name": "com.google.javascript.jscomp.AstValidator",
    "signature": "com.google.javascript.jscomp.AstValidator.AstValidator()",
    "snippet": "  public AstValidator() {\n    this.violationHandler = new ViolationHandler() {\n      @Override\n      public void handleViolation(String message, Node n) {\n        throw new IllegalStateException(\n            message + \" Reference node \" + n.toString());\n      }\n    };\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 0
  },
  {
    "name": "AstValidator.validateBlock",
    "class_name": "com.google.javascript.jscomp.AstValidator",
    "signature": "com.google.javascript.jscomp.AstValidator.validateBlock(Node)",
    "snippet": "  private void validateBlock(Node n) {\n    validateNodeType(Token.BLOCK, n);\n    for (Node c = n.getFirstChild(); c != null; c = c.getNext()) {\n      validateStatement(c);\n    }\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 0
  },
  {
    "name": "AstValidator.validateCall",
    "class_name": "com.google.javascript.jscomp.AstValidator",
    "signature": "com.google.javascript.jscomp.AstValidator.validateCall(Node)",
    "snippet": "  private void validateCall(Node n) {\n    validateNodeType(Token.CALL, n);\n    validateMinimumChildCount(n, 1);\n    for (Node c = n.getFirstChild(); c != null; c = c.getNext()) {\n      validateExpression(c);\n    }\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 0
  },
  {
    "name": "AstValidator.validateChildCount",
    "class_name": "com.google.javascript.jscomp.AstValidator",
    "signature": "com.google.javascript.jscomp.AstValidator.validateChildCount(Node,int)",
    "snippet": "  private void validateChildCount(Node n, int i) {\n    boolean valid = false;\n    if (i == 0) {\n      valid = !n.hasChildren();\n    } else if (i == 1) {\n      valid = n.hasOneChild();\n    } else {\n      valid = (n.getChildCount() == i);\n    }\n    if (!valid) {\n      violation(\n          \"Expected \" + i + \" children, but was \"\n              + n.getChildCount(), n);\n    }\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 0
  },
  {
    "name": "AstValidator.validateChildless",
    "class_name": "com.google.javascript.jscomp.AstValidator",
    "signature": "com.google.javascript.jscomp.AstValidator.validateChildless(Node)",
    "snippet": "  private void validateChildless(Node n) {\n    validateChildCount(n, 0);\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 0
  },
  {
    "name": "AstValidator.validateCodeRoot",
    "class_name": "com.google.javascript.jscomp.AstValidator",
    "signature": "com.google.javascript.jscomp.AstValidator.validateCodeRoot(Node)",
    "snippet": "  public void validateCodeRoot(Node n) {\n    validateNodeType(Token.BLOCK, n);\n    validateIsSynthetic(n);\n    for (Node c = n.getFirstChild(); c != null; c = c.getNext()) {\n      validateScript(c);\n    }\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 0
  },
  {
    "name": "AstValidator.validateExprStmt",
    "class_name": "com.google.javascript.jscomp.AstValidator",
    "signature": "com.google.javascript.jscomp.AstValidator.validateExprStmt(Node)",
    "snippet": "  private void validateExprStmt(Node n) {\n    validateNodeType(Token.EXPR_RESULT, n);\n    validateChildCount(n, 1);\n    validateExpression(n.getFirstChild());\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 0
  },
  {
    "name": "AstValidator.validateExpression",
    "class_name": "com.google.javascript.jscomp.AstValidator",
    "signature": "com.google.javascript.jscomp.AstValidator.validateExpression(Node)",
    "snippet": "  public void validateExpression(Node n) {\n    switch (n.getType()) {\n      // Childless expressions\n      case Token.FALSE:\n      case Token.NULL:\n      case Token.THIS:\n      case Token.TRUE:\n        validateChildless(n);\n        return;\n\n      // General uniary ops\n      case Token.DELPROP:\n      case Token.POS:\n      case Token.NEG:\n      case Token.NOT:\n      case Token.INC:\n      case Token.DEC:\n      case Token.TYPEOF:\n      case Token.VOID:\n      case Token.BITNOT:\n        validateUnaryOp(n);\n        return;\n\n      // General binary ops\n      case Token.COMMA:\n      case Token.OR:\n      case Token.AND:\n      case Token.BITOR:\n      case Token.BITXOR:\n      case Token.BITAND:\n      case Token.EQ:\n      case Token.NE:\n      case Token.SHEQ:\n      case Token.SHNE:\n      case Token.LT:\n      case Token.GT:\n      case Token.LE:\n      case Token.GE:\n      case Token.INSTANCEOF:\n      case Token.IN:\n      case Token.LSH:\n      case Token.RSH:\n      case Token.URSH:\n      case Token.SUB:\n      case Token.ADD:\n      case Token.MUL:\n      case Token.MOD:\n      case Token.DIV:\n        validateBinaryOp(n);\n        return;\n\n      // Assignments\n      case Token.ASSIGN:\n      case Token.ASSIGN_BITOR:\n      case Token.ASSIGN_BITXOR:\n      case Token.ASSIGN_BITAND:\n      case Token.ASSIGN_LSH:\n      case Token.ASSIGN_RSH:\n      case Token.ASSIGN_URSH:\n      case Token.ASSIGN_ADD:\n      case Token.ASSIGN_SUB:\n      case Token.ASSIGN_MUL:\n      case Token.ASSIGN_DIV:\n      case Token.ASSIGN_MOD:\n        validateAssignmentExpression(n);\n        return;\n\n      case Token.HOOK:\n        validateTrinaryOp(n);\n        return;\n\n      // Node types that require special handling\n      case Token.STRING:\n        validateString(n);\n        return;\n\n      case Token.NUMBER:\n        validateNumber(n);\n        return;\n\n      case Token.NAME:\n        validateName(n);\n        return;\n\n      case Token.GETELEM:\n        validateBinaryOp(n);\n        return;\n\n      case Token.GETPROP:\n        validateGetProp(n);\n        return;\n\n      case Token.ARRAYLIT:\n        validateArrayLit(n);\n        return;\n\n      case Token.OBJECTLIT:\n        validateObjectLit(n);\n        return;\n\n      case Token.REGEXP:\n        validateRegExpLit(n);\n        return;\n\n      case Token.CALL:\n        validateCall(n);\n        return;\n\n      case Token.NEW:\n        validateNew(n);\n        return;\n\n      case Token.FUNCTION:\n        validateFunctionExpression(n);\n        return;\n\n      default:\n        violation(\"Expected expression but was \"\n            + Token.name(n.getType()), n);\n    }\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 0
  },
  {
    "name": "AstValidator.validateFunctionExpression",
    "class_name": "com.google.javascript.jscomp.AstValidator",
    "signature": "com.google.javascript.jscomp.AstValidator.validateFunctionExpression(Node)",
    "snippet": "  private void validateFunctionExpression(Node n) {\n    validateNodeType(Token.FUNCTION, n);\n    validateChildCount(n, 3);\n    validateOptionalName(n.getFirstChild());\n    validateParameters(n.getChildAtIndex(1));\n    validateBlock(n.getLastChild());\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 0
  },
  {
    "name": "AstValidator.validateHasInputId",
    "class_name": "com.google.javascript.jscomp.AstValidator",
    "signature": "com.google.javascript.jscomp.AstValidator.validateHasInputId(Node)",
    "snippet": "  private void validateHasInputId(Node n) {\n    InputId inputId = n.getInputId();\n    if (inputId == null) {\n      violation(\"Missing 'input id' annotation.\", n);\n    }\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 0
  },
  {
    "name": "AstValidator.validateHasSourceName",
    "class_name": "com.google.javascript.jscomp.AstValidator",
    "signature": "com.google.javascript.jscomp.AstValidator.validateHasSourceName(Node)",
    "snippet": "  private void validateHasSourceName(Node n) {\n    String sourceName = n.getSourceFileName();\n    if (sourceName == null || sourceName.isEmpty()) {\n      violation(\"Missing 'source name' annotation.\", n);\n    }\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 0
  },
  {
    "name": "AstValidator.validateIf",
    "class_name": "com.google.javascript.jscomp.AstValidator",
    "signature": "com.google.javascript.jscomp.AstValidator.validateIf(Node)",
    "snippet": "  private void validateIf(Node n) {\n    validateNodeType(Token.IF, n);\n    validateMinimumChildCount(n, 2);\n    validateMaximumChildCount(n, 3);\n    validateExpression(n.getFirstChild());\n    validateBlock(n.getChildAtIndex(1));\n    if (n.getChildCount() == 3) {\n      validateBlock(n.getLastChild());\n    }\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 0
  },
  {
    "name": "AstValidator.validateIsSynthetic",
    "class_name": "com.google.javascript.jscomp.AstValidator",
    "signature": "com.google.javascript.jscomp.AstValidator.validateIsSynthetic(Node)",
    "snippet": "  private void validateIsSynthetic(Node n) {\n    if (!n.getBooleanProp(Node.SYNTHETIC_BLOCK_PROP)) {\n      violation(\"Missing 'synthetic block' annotation.\", n);\n    }\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 0
  },
  {
    "name": "AstValidator.validateMaximumChildCount",
    "class_name": "com.google.javascript.jscomp.AstValidator",
    "signature": "com.google.javascript.jscomp.AstValidator.validateMaximumChildCount(Node,int)",
    "snippet": "  private void validateMaximumChildCount(Node n, int i) {\n    boolean valid = false;\n    if (i == 1) {\n      valid = !n.hasMoreThanOneChild();\n    } else {\n      valid = n.getChildCount() <= i;\n    }\n    if (!valid) {\n      violation(\n          \"Expected no more than \" + i + \" children, but was \"\n              + n.getChildCount(), n);\n    }\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 0
  },
  {
    "name": "AstValidator.validateMinimumChildCount",
    "class_name": "com.google.javascript.jscomp.AstValidator",
    "signature": "com.google.javascript.jscomp.AstValidator.validateMinimumChildCount(Node,int)",
    "snippet": "  private void validateMinimumChildCount(Node n, int i) {\n    boolean valid = false;\n    if (i == 1) {\n      valid = n.hasChildren();\n    } else if (i == 2) {\n      valid = n.hasMoreThanOneChild();\n    } else {\n      valid = n.getChildCount() >= i;\n    }\n\n    if (!valid) {\n      violation(\n          \"Expected at least \" + i + \" children, but was \"\n              + n.getChildCount(), n);\n    }\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 0
  },
  {
    "name": "AstValidator.validateName",
    "class_name": "com.google.javascript.jscomp.AstValidator",
    "signature": "com.google.javascript.jscomp.AstValidator.validateName(Node)",
    "snippet": "  private void validateName(Node n) {\n    validateNodeType(Token.NAME, n);\n    validateNonEmptyString(n);\n    validateChildCount(n, 0);\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 0
  },
  {
    "name": "AstValidator.validateNodeType",
    "class_name": "com.google.javascript.jscomp.AstValidator",
    "signature": "com.google.javascript.jscomp.AstValidator.validateNodeType(int,Node)",
    "snippet": "  private void validateNodeType(int type, Node n) {\n    if (n.getType() != type) {\n      violation(\n          \"Expected \" + Token.name(type) + \" but was \"\n              + Token.name(n.getType()), n);\n    }\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 0
  },
  {
    "name": "AstValidator.validateNonEmptyString",
    "class_name": "com.google.javascript.jscomp.AstValidator",
    "signature": "com.google.javascript.jscomp.AstValidator.validateNonEmptyString(Node)",
    "snippet": "  private void validateNonEmptyString(Node n) {\n    validateNonNullString(n);\n    if (n.getString().isEmpty()) {\n      violation(\"Expected non-empty string.\", n);\n    }\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 0
  },
  {
    "name": "AstValidator.validateNonNullString",
    "class_name": "com.google.javascript.jscomp.AstValidator",
    "signature": "com.google.javascript.jscomp.AstValidator.validateNonNullString(Node)",
    "snippet": "  private void validateNonNullString(Node n) {\n    if (n.getString() == null) {\n      violation(\"Expected non-null string.\", n);\n    }\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 0
  },
  {
    "name": "AstValidator.validateOptionalName",
    "class_name": "com.google.javascript.jscomp.AstValidator",
    "signature": "com.google.javascript.jscomp.AstValidator.validateOptionalName(Node)",
    "snippet": "  private void validateOptionalName(Node n) {\n    validateNodeType(Token.NAME, n);\n    validateNonNullString(n);\n    validateChildCount(n, 0);\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 0
  },
  {
    "name": "AstValidator.validateParameters",
    "class_name": "com.google.javascript.jscomp.AstValidator",
    "signature": "com.google.javascript.jscomp.AstValidator.validateParameters(Node)",
    "snippet": "  private void validateParameters(Node n) {\n    validateNodeType(Token.PARAM_LIST, n);\n    for (Node c = n.getFirstChild(); c != null; c = c.getNext()) {\n      validateName(c);\n    }\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 0
  },
  {
    "name": "AstValidator.validateReturn",
    "class_name": "com.google.javascript.jscomp.AstValidator",
    "signature": "com.google.javascript.jscomp.AstValidator.validateReturn(Node)",
    "snippet": "  private void validateReturn(Node n) {\n    validateNodeType(Token.RETURN, n);\n    validateMaximumChildCount(n, 1);\n    if (n.hasChildren()) {\n      validateExpression(n.getFirstChild());\n    }\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 0
  },
  {
    "name": "AstValidator.validateRoot",
    "class_name": "com.google.javascript.jscomp.AstValidator",
    "signature": "com.google.javascript.jscomp.AstValidator.validateRoot(Node)",
    "snippet": "  public void validateRoot(Node n) {\n    validateNodeType(Token.BLOCK, n);\n    validateIsSynthetic(n);\n    validateChildCount(n, 2);\n    validateCodeRoot(n.getFirstChild());\n    validateCodeRoot(n.getLastChild());\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 0
  },
  {
    "name": "AstValidator.validateScript",
    "class_name": "com.google.javascript.jscomp.AstValidator",
    "signature": "com.google.javascript.jscomp.AstValidator.validateScript(Node)",
    "snippet": "  public void validateScript(Node n) {\n    validateNodeType(Token.SCRIPT, n);\n    validateIsSynthetic(n);\n    validateHasSourceName(n);\n    validateHasInputId(n);\n    for (Node c = n.getFirstChild(); c != null; c = c.getNext()) {\n      validateStatement(c);\n    }\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 0
  },
  {
    "name": "AstValidator.validateStatement",
    "class_name": "com.google.javascript.jscomp.AstValidator",
    "signature": "com.google.javascript.jscomp.AstValidator.validateStatement(Node)",
    "snippet": "  public void validateStatement(Node n) {\n    switch (n.getType()) {\n      case Token.LABEL:\n        validateLabel(n);\n        return;\n      case Token.BLOCK:\n        validateBlock(n);\n        return;\n      case Token.FUNCTION:\n        validateFunctionStatement(n);\n        return;\n      case Token.WITH:\n        validateWith(n);\n        return;\n      case Token.FOR:\n        validateFor(n);\n        return;\n      case Token.WHILE:\n        validateWhile(n);\n        return;\n      case Token.DO:\n        validateDo(n);\n        return;\n      case Token.SWITCH:\n        validateSwitch(n);\n        return;\n      case Token.IF:\n        validateIf(n);\n        return;\n      case Token.VAR:\n        validateVar(n);\n        return;\n      case Token.EXPR_RESULT:\n        validateExprStmt(n);\n        return;\n      case Token.RETURN:\n        validateReturn(n);\n        return;\n      case Token.THROW:\n        validateThrow(n);\n        return;\n      case Token.TRY:\n        validateTry(n);\n        return;\n      case Token.BREAK:\n        validateBreak(n);\n        return;\n      case Token.CONTINUE:\n        validateContinue(n);\n        return;\n      case Token.EMPTY:\n        validateChildless(n);\n        return;\n      case Token.DEBUGGER:\n        validateChildless(n);\n        return;\n      default:\n        violation(\"Expected statement but was \"\n            + Token.name(n.getType()) + \".\", n);\n    }\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 0
  },
  {
    "name": "AstValidator.validateString",
    "class_name": "com.google.javascript.jscomp.AstValidator",
    "signature": "com.google.javascript.jscomp.AstValidator.validateString(Node)",
    "snippet": "  private void validateString(Node n) {\n    validateNodeType(Token.STRING, n);\n    validateChildCount(n, 0);\n    try {\n      // Validate that getString doesn't throw\n      n.getString();\n    } catch (UnsupportedOperationException e) {\n      violation(\"Invalid STRING node.\", n);\n    }\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 0
  },
  {
    "name": "AstValidator.validateUnaryOp",
    "class_name": "com.google.javascript.jscomp.AstValidator",
    "signature": "com.google.javascript.jscomp.AstValidator.validateUnaryOp(Node)",
    "snippet": "  private void validateUnaryOp(Node n) {\n    validateChildCount(n, 1);\n    validateExpression(n.getFirstChild());\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 0
  },
  {
    "name": "AstValidator.validateVar",
    "class_name": "com.google.javascript.jscomp.AstValidator",
    "signature": "com.google.javascript.jscomp.AstValidator.validateVar(Node)",
    "snippet": "  private void validateVar(Node n) {\n    validateNodeType(Token.VAR, n);\n    this.validateMinimumChildCount(n, 1);\n    for (Node c = n.getFirstChild(); c != null; c = c.getNext()) {\n      // Don't use the validateName here as the NAME is allowed to have\n      // a child.\n      validateNodeType(Token.NAME, c);\n      validateNonEmptyString(c);\n      validateMaximumChildCount(c, 1);\n      if (c.hasChildren()) {\n        validateExpression(c.getFirstChild());\n      }\n    }\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 0
  },
  {
    "name": "BasicErrorManager.getErrorCount",
    "class_name": "com.google.javascript.jscomp.BasicErrorManager",
    "signature": "com.google.javascript.jscomp.BasicErrorManager.getErrorCount()",
    "snippet": "  @Override\n  public int getErrorCount() {\n    return errorCount;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 0
  },
  {
    "name": "CheckLevel.isOn",
    "class_name": "com.google.javascript.jscomp.CheckLevel",
    "signature": "com.google.javascript.jscomp.CheckLevel.isOn()",
    "snippet": "  boolean isOn() {\n    return this != OFF;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 0
  },
  {
    "name": "ClosureCodingConvention.ClosureCodingConvention",
    "class_name": "com.google.javascript.jscomp.ClosureCodingConvention",
    "signature": "com.google.javascript.jscomp.ClosureCodingConvention.ClosureCodingConvention()",
    "snippet": "  public ClosureCodingConvention() {\n    this(CodingConventions.getDefault());\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 0
  },
  {
    "name": "ClosureCodingConvention.ClosureCodingConvention",
    "class_name": "com.google.javascript.jscomp.ClosureCodingConvention",
    "signature": "com.google.javascript.jscomp.ClosureCodingConvention.ClosureCodingConvention(CodingConvention)",
    "snippet": "  public ClosureCodingConvention(CodingConvention wrapped) {\n    super(wrapped);\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 0
  },
  {
    "name": "CodeConsumer.add",
    "class_name": "com.google.javascript.jscomp.CodeConsumer",
    "signature": "com.google.javascript.jscomp.CodeConsumer.add(String)",
    "snippet": "  void add(String newcode) {\n    maybeEndStatement();\n\n    if (newcode.length() == 0) {\n      return;\n    }\n\n    char c = newcode.charAt(0);\n    if ((isWordChar(c) || c == '\\\\') &&\n        isWordChar(getLastChar())) {\n      // need space to separate. This is not pretty printing.\n      // For example: \"return foo;\"\n      append(\" \");\n    } else if (c == '/' && getLastChar() == '/') {\n      // Do not allow a forward slash to appear after a DIV.\n      // For example,\n      // REGEXP DIV REGEXP\n      // is valid and should print like\n      // / // / /\n      append(\" \");\n    }\n\n    append(newcode);\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 0
  },
  {
    "name": "CodeConsumer.addConstant",
    "class_name": "com.google.javascript.jscomp.CodeConsumer",
    "signature": "com.google.javascript.jscomp.CodeConsumer.addConstant(String)",
    "snippet": "  void addConstant(String newcode) {\n    add(newcode);\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 0
  },
  {
    "name": "CodeConsumer.addNumber",
    "class_name": "com.google.javascript.jscomp.CodeConsumer",
    "signature": "com.google.javascript.jscomp.CodeConsumer.addNumber(double)",
    "snippet": "  void addNumber(double x) {\n    // This is not pretty printing. This is to prevent misparsing of x- -4 as\n    // x--4 (which is a syntax error).\n    char prev = getLastChar();\n    boolean negativeZero = isNegativeZero(x);\n    if ((x < 0 || negativeZero) && prev == '-') {\n      add(\" \");\n    }\n\n    if ((long) x == x && !negativeZero) {\n      long value = (long) x;\n      long mantissa = value;\n      int exp = 0;\n      if (Math.abs(x) >= 100) {\n        while (mantissa / 10 * Math.pow(10, exp + 1) == value) {\n          mantissa /= 10;\n          exp++;\n        }\n      }\n      if (exp > 2) {\n        addConstant(Long.toString(mantissa) + \"E\" + Integer.toString(exp));\n      } else {\n        addConstant(Long.toString(value));\n      }\n    } else {\n      addConstant(String.valueOf(x));\n    }\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 0
  },
  {
    "name": "CodeConsumer.continueProcessing",
    "class_name": "com.google.javascript.jscomp.CodeConsumer",
    "signature": "com.google.javascript.jscomp.CodeConsumer.continueProcessing()",
    "snippet": "  boolean continueProcessing() {\n    return true;\n  }",
    "comment": " Provides a means of interrupting the CodeGenerator. Derived classes should return false to stop further processing. ",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 0
  },
  {
    "name": "CodeConsumer.endFile",
    "class_name": "com.google.javascript.jscomp.CodeConsumer",
    "signature": "com.google.javascript.jscomp.CodeConsumer.endFile()",
    "snippet": "  void endFile() {}",
    "comment": "Called when we're at the end of a file. */",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 0
  },
  {
    "name": "CodeConsumer.endSourceMapping",
    "class_name": "com.google.javascript.jscomp.CodeConsumer",
    "signature": "com.google.javascript.jscomp.CodeConsumer.endSourceMapping(Node)",
    "snippet": "  void endSourceMapping(Node node) {\n  }",
    "comment": " Finishes the source mapping for the given node at the current position. ",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 0
  },
  {
    "name": "CodeConsumer.endStatement",
    "class_name": "com.google.javascript.jscomp.CodeConsumer",
    "signature": "com.google.javascript.jscomp.CodeConsumer.endStatement()",
    "snippet": "  void endStatement() {\n    endStatement(false);\n  }",
    "comment": " Indicates the end of a statement and a ';' may need to be added. But we don't add it now, in case we're at the end of a block (in which case we don't have to add the ';'). See maybeEndStatement() ",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 0
  },
  {
    "name": "CodeConsumer.endStatement",
    "class_name": "com.google.javascript.jscomp.CodeConsumer",
    "signature": "com.google.javascript.jscomp.CodeConsumer.endStatement(boolean)",
    "snippet": "  void endStatement(boolean needSemiColon) {\n    if (needSemiColon) {\n      append(\";\");\n      maybeLineBreak();\n      statementNeedsEnded = false;\n    } else if (statementStarted) {\n      statementNeedsEnded = true;\n    }\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 0
  },
  {
    "name": "CodeConsumer.isNegativeZero",
    "class_name": "com.google.javascript.jscomp.CodeConsumer",
    "signature": "com.google.javascript.jscomp.CodeConsumer.isNegativeZero(double)",
    "snippet": "  static boolean isNegativeZero(double x) {\n    return x == 0.0 && Math.copySign(1, x) == -1.0;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 0
  },
  {
    "name": "CodeConsumer.isWordChar",
    "class_name": "com.google.javascript.jscomp.CodeConsumer",
    "signature": "com.google.javascript.jscomp.CodeConsumer.isWordChar(char)",
    "snippet": "  static boolean isWordChar(char ch) {\n    return (ch == '_' ||\n            ch == '$' ||\n            Character.isLetterOrDigit(ch));\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 0
  },
  {
    "name": "CodeConsumer.maybeEndStatement",
    "class_name": "com.google.javascript.jscomp.CodeConsumer",
    "signature": "com.google.javascript.jscomp.CodeConsumer.maybeEndStatement()",
    "snippet": "  void maybeEndStatement() {\n    // Add a ';' if we need to.\n    if (statementNeedsEnded) {\n      append(\";\");\n      maybeLineBreak();\n      endLine();\n      statementNeedsEnded = false;\n    }\n    statementStarted = true;\n  }",
    "comment": " This is to be called when we're in a statement. If the prev statement needs to be ended, add a ';'. ",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 0
  },
  {
    "name": "CodeConsumer.notePreferredLineBreak",
    "class_name": "com.google.javascript.jscomp.CodeConsumer",
    "signature": "com.google.javascript.jscomp.CodeConsumer.notePreferredLineBreak()",
    "snippet": "  void notePreferredLineBreak() {\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 0
  },
  {
    "name": "CodeConsumer.startSourceMapping",
    "class_name": "com.google.javascript.jscomp.CodeConsumer",
    "signature": "com.google.javascript.jscomp.CodeConsumer.startSourceMapping(Node)",
    "snippet": "  void startSourceMapping(Node node) {\n  }",
    "comment": " Starts the source mapping for the given node at the current position. ",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 0
  },
  {
    "name": "CodeGenerator.CodeGenerator",
    "class_name": "com.google.javascript.jscomp.CodeGenerator",
    "signature": "com.google.javascript.jscomp.CodeGenerator.CodeGenerator(CodeConsumer)",
    "snippet": "  CodeGenerator(CodeConsumer consumer) {\n    this(consumer, null);\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 0
  },
  {
    "name": "CodeGenerator.CodeGenerator",
    "class_name": "com.google.javascript.jscomp.CodeGenerator",
    "signature": "com.google.javascript.jscomp.CodeGenerator.CodeGenerator(CodeConsumer,Charset)",
    "snippet": "  CodeGenerator(\n      CodeConsumer consumer, Charset outputCharset) {\n    cc = consumer;\n    if (outputCharset == null || outputCharset == Charsets.US_ASCII) {\n      // If we want our default (pretending to be UTF-8, but escaping anything\n      // outside of straight ASCII), then don't use the encoder, but\n      // just special-case the code.  This keeps the normal path through\n      // the code identical to how it's been for years.\n      this.outputCharsetEncoder = null;\n    } else {\n      this.outputCharsetEncoder = outputCharset.newEncoder();\n    }\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 0
  },
  {
    "name": "CodeGenerator.add",
    "class_name": "com.google.javascript.jscomp.CodeGenerator",
    "signature": "com.google.javascript.jscomp.CodeGenerator.add(Node)",
    "snippet": "  void add(Node n) {\n    add(n, Context.OTHER);\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 0
  },
  {
    "name": "CodeGenerator.add",
    "class_name": "com.google.javascript.jscomp.CodeGenerator",
    "signature": "com.google.javascript.jscomp.CodeGenerator.add(Node,Context)",
    "snippet": "  void add(Node n, Context context) {\n    if (!cc.continueProcessing()) {\n      return;\n    }\n\n    int type = n.getType();\n    String opstr = NodeUtil.opToStr(type);\n    int childCount = n.getChildCount();\n    Node first = n.getFirstChild();\n    Node last = n.getLastChild();\n\n    // Handle all binary operators\n    if (opstr != null && first != last) {\n      Preconditions.checkState(\n          childCount == 2,\n          \"Bad binary operator \\\"%s\\\": expected 2 arguments but got %s\",\n          opstr, childCount);\n      int p = NodeUtil.precedence(type);\n\n      // For right-hand-side of operations, only pass context if it's\n      // the IN_FOR_INIT_CLAUSE one.\n      Context rhsContext = getContextForNoInOperator(context);\n\n      // Handle associativity.\n      // e.g. if the parse tree is a * (b * c),\n      // we can simply generate a * b * c.\n      if (last.getType() == type &&\n          NodeUtil.isAssociative(type)) {\n        addExpr(first, p, context);\n        cc.addOp(opstr, true);\n        addExpr(last, p, rhsContext);\n      } else if (NodeUtil.isAssignmentOp(n) && NodeUtil.isAssignmentOp(last)) {\n        // Assignments are the only right-associative binary operators\n        addExpr(first, p, context);\n        cc.addOp(opstr, true);\n        addExpr(last, p, rhsContext);\n      } else {\n        unrollBinaryOperator(n, type, opstr, context, rhsContext, p, p + 1);\n      }\n      return;\n    }\n\n    cc.startSourceMapping(n);\n\n    switch (type) {\n      case Token.TRY: {\n        Preconditions.checkState(first.getNext().isBlock() &&\n                !first.getNext().hasMoreThanOneChild());\n        Preconditions.checkState(childCount >= 2 && childCount <= 3);\n\n        add(\"try\");\n        add(first, Context.PRESERVE_BLOCK);\n\n        // second child contains the catch block, or nothing if there\n        // isn't a catch block\n        Node catchblock = first.getNext().getFirstChild();\n        if (catchblock != null) {\n          add(catchblock);\n        }\n\n        if (childCount == 3) {\n          add(\"finally\");\n          add(last, Context.PRESERVE_BLOCK);\n        }\n        break;\n      }\n\n      case Token.CATCH:\n        Preconditions.checkState(childCount == 2);\n        add(\"catch(\");\n        add(first);\n        add(\")\");\n        add(last, Context.PRESERVE_BLOCK);\n        break;\n\n      case Token.THROW:\n        Preconditions.checkState(childCount == 1);\n        add(\"throw\");\n        add(first);\n\n        // Must have a ';' after a throw statement, otherwise safari can't\n        // parse this.\n        cc.endStatement(true);\n        break;\n\n      case Token.RETURN:\n        add(\"return\");\n        if (childCount == 1) {\n          add(first);\n        } else {\n          Preconditions.checkState(childCount == 0);\n        }\n        cc.endStatement();\n        break;\n\n      case Token.VAR:\n        if (first != null) {\n          add(\"var \");\n          addList(first, false, getContextForNoInOperator(context));\n        }\n        break;\n\n      case Token.LABEL_NAME:\n        Preconditions.checkState(!n.getString().isEmpty());\n        addIdentifier(n.getString());\n        break;\n\n      case Token.NAME:\n        if (first == null || first.isEmpty()) {\n          addIdentifier(n.getString());\n        } else {\n          Preconditions.checkState(childCount == 1);\n          addIdentifier(n.getString());\n          cc.addOp(\"=\", true);\n          if (first.isComma()) {\n            addExpr(first, NodeUtil.precedence(Token.ASSIGN), Context.OTHER);\n          } else {\n            // Add expression, consider nearby code at lowest level of\n            // precedence.\n            addExpr(first, 0, getContextForNoInOperator(context));\n          }\n        }\n        break;\n\n      case Token.ARRAYLIT:\n        add(\"[\");\n        addArrayList(first);\n        add(\"]\");\n        break;\n\n      case Token.PARAM_LIST:\n        add(\"(\");\n        addList(first);\n        add(\")\");\n        break;\n\n      case Token.COMMA:\n        Preconditions.checkState(childCount == 2);\n        unrollBinaryOperator(n, Token.COMMA, \",\", context, Context.OTHER, 0, 0);\n        break;\n\n      case Token.NUMBER:\n        Preconditions.checkState(childCount == 0);\n        cc.addNumber(n.getDouble());\n        break;\n\n      case Token.TYPEOF:\n      case Token.VOID:\n      case Token.NOT:\n      case Token.BITNOT:\n      case Token.POS: {\n        // All of these unary operators are right-associative\n        Preconditions.checkState(childCount == 1);\n        cc.addOp(NodeUtil.opToStrNoFail(type), false);\n        addExpr(first, NodeUtil.precedence(type), Context.OTHER);\n        break;\n      }\n\n      case Token.NEG: {\n        Preconditions.checkState(childCount == 1);\n\n        // It's important to our sanity checker that the code\n        // we print produces the same AST as the code we parse back.\n        // NEG is a weird case because Rhino parses \"- -2\" as \"2\".\n        if (n.getFirstChild().isNumber()) {\n          cc.addNumber(-n.getFirstChild().getDouble());\n        } else {\n          cc.addOp(NodeUtil.opToStrNoFail(type), false);\n          addExpr(first, NodeUtil.precedence(type), Context.OTHER);\n        }\n\n        break;\n      }\n\n      case Token.HOOK: {\n        Preconditions.checkState(childCount == 3);\n        int p = NodeUtil.precedence(type);\n        addExpr(first, p + 1, context);\n        cc.addOp(\"?\", true);\n        addExpr(first.getNext(), 1, Context.OTHER);\n        cc.addOp(\":\", true);\n        addExpr(last, 1, Context.OTHER);\n        break;\n      }\n\n      case Token.REGEXP:\n        if (!first.isString() ||\n            !last.isString()) {\n          throw new Error(\"Expected children to be strings\");\n        }\n\n        String regexp = regexpEscape(first.getString(), outputCharsetEncoder);\n\n        // I only use one .add because whitespace matters\n        if (childCount == 2) {\n          add(regexp + last.getString());\n        } else {\n          Preconditions.checkState(childCount == 1);\n          add(regexp);\n        }\n        break;\n\n      case Token.FUNCTION:\n        if (n.getClass() != Node.class) {\n          throw new Error(\"Unexpected Node subclass.\");\n        }\n        Preconditions.checkState(childCount == 3);\n        boolean funcNeedsParens = (context == Context.START_OF_EXPR);\n        if (funcNeedsParens) {\n          add(\"(\");\n        }\n\n        add(\"function\");\n        add(first);\n\n        add(first.getNext());\n        add(last, Context.PRESERVE_BLOCK);\n        cc.endFunction(context == Context.STATEMENT);\n\n        if (funcNeedsParens) {\n          add(\")\");\n        }\n        break;\n\n      case Token.GETTER_DEF:\n      case Token.SETTER_DEF:\n        Preconditions.checkState(n.getParent().isObjectLit());\n        Preconditions.checkState(childCount == 1);\n        Preconditions.checkState(first.isFunction());\n\n        // Get methods are unnamed\n        Preconditions.checkState(first.getFirstChild().getString().isEmpty());\n        if (type == Token.GETTER_DEF) {\n          // Get methods have no parameters.\n          Preconditions.checkState(!first.getChildAtIndex(1).hasChildren());\n          add(\"get \");\n        } else {\n          // Set methods have one parameter.\n          Preconditions.checkState(first.getChildAtIndex(1).hasOneChild());\n          add(\"set \");\n        }\n\n        // The name is on the GET or SET node.\n        String name = n.getString();\n        Node fn = first;\n        Node parameters = fn.getChildAtIndex(1);\n        Node body = fn.getLastChild();\n\n        // Add the property name.\n        if (!n.isQuotedString() &&\n            TokenStream.isJSIdentifier(name) &&\n            // do not encode literally any non-literal characters that were\n            // unicode escaped.\n            NodeUtil.isLatin(name)) {\n          add(name);\n        } else {\n          // Determine if the string is a simple number.\n          double d = getSimpleNumber(name);\n          if (!Double.isNaN(d)) {\n            cc.addNumber(d);\n          } else {\n            addJsString(n);\n          }\n        }\n\n        add(parameters);\n        add(body, Context.PRESERVE_BLOCK);\n        break;\n\n      case Token.SCRIPT:\n      case Token.BLOCK: {\n        if (n.getClass() != Node.class) {\n          throw new Error(\"Unexpected Node subclass.\");\n        }\n        boolean preserveBlock = context == Context.PRESERVE_BLOCK;\n        if (preserveBlock) {\n          cc.beginBlock();\n        }\n\n        boolean preferLineBreaks =\n            type == Token.SCRIPT ||\n            (type == Token.BLOCK &&\n                !preserveBlock &&\n                n.getParent() != null &&\n                n.getParent().isScript());\n        for (Node c = first; c != null; c = c.getNext()) {\n          add(c, Context.STATEMENT);\n\n          // VAR doesn't include ';' since it gets used in expressions\n          if (c.isVar()) {\n            cc.endStatement();\n          }\n\n          if (c.isFunction()) {\n            cc.maybeLineBreak();\n          }\n\n          // Prefer to break lines in between top-level statements\n          // because top level statements are more homogeneous.\n          if (preferLineBreaks) {\n            cc.notePreferredLineBreak();\n          }\n        }\n        if (preserveBlock) {\n          cc.endBlock(cc.breakAfterBlockFor(n, context == Context.STATEMENT));\n        }\n        break;\n      }\n\n      case Token.FOR:\n        if (childCount == 4) {\n          add(\"for(\");\n          if (first.isVar()) {\n            add(first, Context.IN_FOR_INIT_CLAUSE);\n          } else {\n            addExpr(first, 0, Context.IN_FOR_INIT_CLAUSE);\n          }\n          add(\";\");\n          add(first.getNext());\n          add(\";\");\n          add(first.getNext().getNext());\n          add(\")\");\n          addNonEmptyStatement(\n              last, getContextForNonEmptyExpression(context), false);\n        } else {\n          Preconditions.checkState(childCount == 3);\n          add(\"for(\");\n          add(first);\n          add(\"in\");\n          add(first.getNext());\n          add(\")\");\n          addNonEmptyStatement(\n              last, getContextForNonEmptyExpression(context), false);\n        }\n        break;\n\n      case Token.DO:\n        Preconditions.checkState(childCount == 2);\n        add(\"do\");\n        addNonEmptyStatement(first, Context.OTHER, false);\n        add(\"while(\");\n        add(last);\n        add(\")\");\n        cc.endStatement();\n        break;\n\n      case Token.WHILE:\n        Preconditions.checkState(childCount == 2);\n        add(\"while(\");\n        add(first);\n        add(\")\");\n        addNonEmptyStatement(\n            last, getContextForNonEmptyExpression(context), false);\n        break;\n\n      case Token.EMPTY:\n        Preconditions.checkState(childCount == 0);\n        break;\n\n      case Token.GETPROP: {\n        Preconditions.checkState(\n            childCount == 2,\n            \"Bad GETPROP: expected 2 children, but got %s\", childCount);\n        Preconditions.checkState(\n            last.isString(),\n            \"Bad GETPROP: RHS should be STRING\");\n        boolean needsParens = (first.isNumber());\n        if (needsParens) {\n          add(\"(\");\n        }\n        addExpr(first, NodeUtil.precedence(type), context);\n        if (needsParens) {\n          add(\")\");\n        }\n        add(\".\");\n        addIdentifier(last.getString());\n        break;\n      }\n\n      case Token.GETELEM:\n        Preconditions.checkState(\n            childCount == 2,\n            \"Bad GETELEM: expected 2 children but got %s\", childCount);\n        addExpr(first, NodeUtil.precedence(type), context);\n        add(\"[\");\n        add(first.getNext());\n        add(\"]\");\n        break;\n\n      case Token.WITH:\n        Preconditions.checkState(childCount == 2);\n        add(\"with(\");\n        add(first);\n        add(\")\");\n        addNonEmptyStatement(\n            last, getContextForNonEmptyExpression(context), false);\n        break;\n\n      case Token.INC:\n      case Token.DEC: {\n        Preconditions.checkState(childCount == 1);\n        String o = type == Token.INC ? \"++\" : \"--\";\n        int postProp = n.getIntProp(Node.INCRDECR_PROP);\n        // A non-zero post-prop value indicates a post inc/dec, default of zero\n        // is a pre-inc/dec.\n        if (postProp != 0) {\n          addExpr(first, NodeUtil.precedence(type), context);\n          cc.addOp(o, false);\n        } else {\n          cc.addOp(o, false);\n          add(first);\n        }\n        break;\n      }\n\n      case Token.CALL:\n        // We have two special cases here:\n        // 1) If the left hand side of the call is a direct reference to eval,\n        // then it must have a DIRECT_EVAL annotation. If it does not, then\n        // that means it was originally an indirect call to eval, and that\n        // indirectness must be preserved.\n        // 2) If the left hand side of the call is a property reference,\n        // then the call must not a FREE_CALL annotation. If it does, then\n        // that means it was originally an call without an explicit this and\n        // that must be preserved.\n        if (isIndirectEval(first)\n            || n.getBooleanProp(Node.FREE_CALL) && NodeUtil.isGet(first)) {\n          add(\"(0,\");\n          addExpr(first, NodeUtil.precedence(Token.COMMA), Context.OTHER);\n          add(\")\");\n        } else {\n          addExpr(first, NodeUtil.precedence(type), context);\n        }\n        add(\"(\");\n        addList(first.getNext());\n        add(\")\");\n        break;\n\n      case Token.IF:\n        boolean hasElse = childCount == 3;\n        boolean ambiguousElseClause =\n            context == Context.BEFORE_DANGLING_ELSE && !hasElse;\n        if (ambiguousElseClause) {\n          cc.beginBlock();\n        }\n\n        add(\"if(\");\n        add(first);\n        add(\")\");\n\n        if (hasElse) {\n          addNonEmptyStatement(\n              first.getNext(), Context.BEFORE_DANGLING_ELSE, false);\n          add(\"else\");\n          addNonEmptyStatement(\n              last, getContextForNonEmptyExpression(context), false);\n        } else {\n          addNonEmptyStatement(first.getNext(), Context.OTHER, false);\n          Preconditions.checkState(childCount == 2);\n        }\n\n        if (ambiguousElseClause) {\n          cc.endBlock();\n        }\n        break;\n\n      case Token.NULL:\n        Preconditions.checkState(childCount == 0);\n        cc.addConstant(\"null\");\n        break;\n\n      case Token.THIS:\n        Preconditions.checkState(childCount == 0);\n        add(\"this\");\n        break;\n\n      case Token.FALSE:\n        Preconditions.checkState(childCount == 0);\n        cc.addConstant(\"false\");\n        break;\n\n      case Token.TRUE:\n        Preconditions.checkState(childCount == 0);\n        cc.addConstant(\"true\");\n        break;\n\n      case Token.CONTINUE:\n        Preconditions.checkState(childCount <= 1);\n        add(\"continue\");\n        if (childCount == 1) {\n          if (!first.isLabelName()) {\n            throw new Error(\"Unexpected token type. Should be LABEL_NAME.\");\n          }\n          add(\" \");\n          add(first);\n        }\n        cc.endStatement();\n        break;\n\n      case Token.DEBUGGER:\n        Preconditions.checkState(childCount == 0);\n        add(\"debugger\");\n        cc.endStatement();\n        break;\n\n      case Token.BREAK:\n        Preconditions.checkState(childCount <= 1);\n        add(\"break\");\n        if (childCount == 1) {\n          if (!first.isLabelName()) {\n            throw new Error(\"Unexpected token type. Should be LABEL_NAME.\");\n          }\n          add(\" \");\n          add(first);\n        }\n        cc.endStatement();\n        break;\n\n      case Token.EXPR_RESULT:\n        Preconditions.checkState(childCount == 1);\n        add(first, Context.START_OF_EXPR);\n        cc.endStatement();\n        break;\n\n      case Token.NEW:\n        add(\"new \");\n        int precedence = NodeUtil.precedence(type);\n\n        // If the first child contains a CALL, then claim higher precedence\n        // to force parentheses. Otherwise, when parsed, NEW will bind to the\n        // first viable parentheses (don't traverse into functions).\n        if (NodeUtil.containsType(\n            first, Token.CALL, NodeUtil.MATCH_NOT_FUNCTION)) {\n          precedence = NodeUtil.precedence(first.getType()) + 1;\n        }\n        addExpr(first, precedence, Context.OTHER);\n\n        // '()' is optional when no arguments are present\n        Node next = first.getNext();\n        if (next != null) {\n          add(\"(\");\n          addList(next);\n          add(\")\");\n        }\n        break;\n\n      case Token.STRING_KEY:\n        Preconditions.checkState(\n            childCount == 1, \"Object lit key must have 1 child\");\n        addJsString(n);\n        break;\n\n      case Token.STRING:\n        Preconditions.checkState(\n            childCount == 0, \"A string may not have children\");\n        addJsString(n);\n        break;\n\n      case Token.DELPROP:\n        Preconditions.checkState(childCount == 1);\n        add(\"delete \");\n        add(first);\n        break;\n\n      case Token.OBJECTLIT: {\n        boolean needsParens = (context == Context.START_OF_EXPR);\n        if (needsParens) {\n          add(\"(\");\n        }\n        add(\"{\");\n        for (Node c = first; c != null; c = c.getNext()) {\n          if (c != first) {\n            cc.listSeparator();\n          }\n\n          if (c.isGetterDef() || c.isSetterDef()) {\n            add(c);\n          } else {\n            Preconditions.checkState(c.isStringKey());\n            String key = c.getString();\n            // Object literal property names don't have to be quoted if they\n            // are not JavaScript keywords\n            if (!c.isQuotedString() &&\n                !TokenStream.isKeyword(key) &&\n                TokenStream.isJSIdentifier(key) &&\n                // do not encode literally any non-literal characters that\n                // were unicode escaped.\n                NodeUtil.isLatin(key)) {\n              add(key);\n            } else {\n              // Determine if the string is a simple number.\n              double d = getSimpleNumber(key);\n              if (!Double.isNaN(d)) {\n                cc.addNumber(d);\n              } else {\n                addExpr(c, 1, Context.OTHER);\n              }\n            }\n            add(\":\");\n            addExpr(c.getFirstChild(), 1, Context.OTHER);\n          }\n        }\n        add(\"}\");\n        if (needsParens) {\n          add(\")\");\n        }\n        break;\n      }\n\n      case Token.SWITCH:\n        add(\"switch(\");\n        add(first);\n        add(\")\");\n        cc.beginBlock();\n        addAllSiblings(first.getNext());\n        cc.endBlock(context == Context.STATEMENT);\n        break;\n\n      case Token.CASE:\n        Preconditions.checkState(childCount == 2);\n        add(\"case \");\n        add(first);\n        addCaseBody(last);\n        break;\n\n      case Token.DEFAULT_CASE:\n        Preconditions.checkState(childCount == 1);\n        add(\"default\");\n        addCaseBody(first);\n        break;\n\n      case Token.LABEL:\n        Preconditions.checkState(childCount == 2);\n        if (!first.isLabelName()) {\n          throw new Error(\"Unexpected token type. Should be LABEL_NAME.\");\n        }\n        add(first);\n        add(\":\");\n        addNonEmptyStatement(\n            last, getContextForNonEmptyExpression(context), true);\n        break;\n\n      default:\n        throw new Error(\"Unknown type \" + type + \"\\n\" + n.toStringTree());\n    }\n\n    cc.endSourceMapping(n);\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 0
  },
  {
    "name": "CodePrinter.toSource",
    "class_name": "com.google.javascript.jscomp.CodePrinter",
    "signature": "com.google.javascript.jscomp.CodePrinter.toSource(Node,Format,boolean,boolean,int,SourceMap,DetailLevel,Charset,boolean)",
    "snippet": "  private static String toSource(Node root, Format outputFormat,\n                                 boolean lineBreak,  boolean preferEndOfFileBreak,\n                                 int lineLengthThreshold,\n                                 SourceMap sourceMap,\n                                 SourceMap.DetailLevel sourceMapDetailLevel,\n                                 Charset outputCharset,\n                                 boolean tagAsStrict) {\n    Preconditions.checkState(sourceMapDetailLevel != null);\n\n    boolean createSourceMap = (sourceMap != null);\n    MappedCodePrinter mcp =\n        outputFormat == Format.COMPACT\n        ? new CompactCodePrinter(\n            lineBreak, preferEndOfFileBreak, lineLengthThreshold,\n            createSourceMap, sourceMapDetailLevel)\n        : new PrettyCodePrinter(\n            lineLengthThreshold, createSourceMap, sourceMapDetailLevel);\n    CodeGenerator cg =\n        outputFormat == Format.TYPED\n        ? new TypedCodeGenerator(mcp, outputCharset)\n        : new CodeGenerator(mcp, outputCharset);\n\n    if (tagAsStrict) {\n      cg.tagAsStrict();\n    }\n\n    cg.add(root);\n    mcp.endFile();\n\n    String code = mcp.getCode();\n\n    if (createSourceMap) {\n      mcp.generateSourceMap(sourceMap);\n    }\n\n    return code;\n  }",
    "comment": " Converts a tree to js code ",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 0
  },
  {
    "name": "Builder.build",
    "class_name": "com.google.javascript.jscomp.CodePrinter$Builder",
    "signature": "com.google.javascript.jscomp.CodePrinter$Builder.build()",
    "snippet": "    String build() {\n      if (root == null) {\n        throw new IllegalStateException(\n            \"Cannot build without root node being specified\");\n      }\n\n      Format outputFormat = outputTypes\n          ? Format.TYPED\n          : prettyPrint\n              ? Format.PRETTY\n              : Format.COMPACT;\n\n      return toSource(root, outputFormat, lineBreak, preferLineBreakAtEndOfFile,\n          lineLengthThreshold, sourceMap, sourceMapDetailLevel, outputCharset,\n          tagAsStrict);\n    }",
    "comment": " Generates the source code and returns it. ",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 0
  },
  {
    "name": "Builder.setLineLengthThreshold",
    "class_name": "com.google.javascript.jscomp.CodePrinter$Builder",
    "signature": "com.google.javascript.jscomp.CodePrinter$Builder.setLineLengthThreshold(int)",
    "snippet": "    Builder setLineLengthThreshold(int threshold) {\n      this.lineLengthThreshold = threshold;\n      return this;\n    }",
    "comment": " Sets the line length threshold that will be used to determine when to break lines, if line breaking is on.  @param threshold The line length threshold. ",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 0
  },
  {
    "name": "CompactCodePrinter.append",
    "class_name": "com.google.javascript.jscomp.CodePrinter$CompactCodePrinter",
    "signature": "com.google.javascript.jscomp.CodePrinter$CompactCodePrinter.append(String)",
    "snippet": "    @Override\n    void append(String str) {\n      code.append(str);\n      lineLength += str.length();\n    }",
    "comment": " Appends a string to the code, keeping track of the current line length. ",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 0
  },
  {
    "name": "CompactCodePrinter.endFile",
    "class_name": "com.google.javascript.jscomp.CodePrinter$CompactCodePrinter",
    "signature": "com.google.javascript.jscomp.CodePrinter$CompactCodePrinter.endFile()",
    "snippet": "    @Override\n    void endFile() {\n      super.endFile();\n      if (!preferLineBreakAtEndOfFile) {\n        return;\n      }\n      if (lineLength > lineLengthThreshold / 2) {\n        // Add an extra break at end of file.\n        append(\";\");\n        startNewLine();\n      } else if (prevCutPosition > 0) {\n        // Shift the previous break to end of file by replacing it with a\n        // <space> and adding a new break at end of file. Adding the space\n        // handles cases like instanceof\\nfoo. (it would be nice to avoid this)\n        code.setCharAt(prevCutPosition, ' ');\n        lineStartPosition = prevLineStartPosition;\n        lineLength = code.length() - lineStartPosition;\n        reportLineCut(lineIndex, prevCutPosition + 1, false);\n        lineIndex--;\n        prevCutPosition = 0;\n        prevLineStartPosition = 0;\n        append(\";\");\n        startNewLine();\n      } else {\n        // A small file with no line breaks. We do nothing in this case to\n        // avoid excessive line breaks. It's not ideal if a lot of these pile\n        // up, but that is reasonably unlikely.\n      }\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 0
  },
  {
    "name": "CompactCodePrinter.notePreferredLineBreak",
    "class_name": "com.google.javascript.jscomp.CodePrinter$CompactCodePrinter",
    "signature": "com.google.javascript.jscomp.CodePrinter$CompactCodePrinter.notePreferredLineBreak()",
    "snippet": "    @Override\n    void notePreferredLineBreak() {\n      preferredBreakPosition = code.length();\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 0
  },
  {
    "name": "MappedCodePrinter.endSourceMapping",
    "class_name": "com.google.javascript.jscomp.CodePrinter$MappedCodePrinter",
    "signature": "com.google.javascript.jscomp.CodePrinter$MappedCodePrinter.endSourceMapping(Node)",
    "snippet": "    @Override\n    void endSourceMapping(Node node) {\n      if (createSrcMap && !mappings.isEmpty() && mappings.peek().node == node) {\n        Mapping mapping = mappings.pop();\n        int line = getCurrentLineIndex();\n        int index = getCurrentCharIndex();\n        Preconditions.checkState(line >= 0);\n        mapping.end = new FilePosition(line, index);\n      }\n    }",
    "comment": " Finishes the source mapping for the given node at the current position. ",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 0
  },
  {
    "name": "MappedCodePrinter.getCode",
    "class_name": "com.google.javascript.jscomp.CodePrinter$MappedCodePrinter",
    "signature": "com.google.javascript.jscomp.CodePrinter$MappedCodePrinter.getCode()",
    "snippet": "    public String getCode() {\n      return code.toString();\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 0
  },
  {
    "name": "MappedCodePrinter.getLastChar",
    "class_name": "com.google.javascript.jscomp.CodePrinter$MappedCodePrinter",
    "signature": "com.google.javascript.jscomp.CodePrinter$MappedCodePrinter.getLastChar()",
    "snippet": "    @Override\n    char getLastChar() {\n      return (code.length() > 0) ? code.charAt(code.length() - 1) : '\\0';\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 0
  },
  {
    "name": "MappedCodePrinter.startSourceMapping",
    "class_name": "com.google.javascript.jscomp.CodePrinter$MappedCodePrinter",
    "signature": "com.google.javascript.jscomp.CodePrinter$MappedCodePrinter.startSourceMapping(Node)",
    "snippet": "    @Override\n    void startSourceMapping(Node node) {\n      Preconditions.checkState(sourceMapDetailLevel != null);\n      Preconditions.checkState(node != null);\n      if (createSrcMap\n          && node.getSourceFileName() != null\n          && node.getLineno() > 0\n          && sourceMapDetailLevel.apply(node)) {\n        int line = getCurrentLineIndex();\n        int index = getCurrentCharIndex();\n        Preconditions.checkState(line >= 0);\n        Mapping mapping = new Mapping();\n        mapping.node = node;\n        mapping.start = new FilePosition(line, index);\n        mappings.push(mapping);\n        allMappings.add(mapping);\n      }\n    }",
    "comment": " Starts the source mapping for the given node at the current position. ",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 0
  },
  {
    "name": "CodingConventions.getDefault",
    "class_name": "com.google.javascript.jscomp.CodingConventions",
    "signature": "com.google.javascript.jscomp.CodingConventions.getDefault()",
    "snippet": "  public static CodingConvention getDefault() {\n    return new DefaultCodingConvention();\n  }",
    "comment": "Gets the default coding convention. */",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 0
  },
  {
    "name": "Compiler.Compiler",
    "class_name": "com.google.javascript.jscomp.Compiler",
    "signature": "com.google.javascript.jscomp.Compiler.Compiler()",
    "snippet": "  public Compiler() {\n    this((PrintStream) null);\n  }",
    "comment": " Creates a Compiler that reports errors and warnings to its logger. ",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 0
  },
  {
    "name": "Compiler.Compiler",
    "class_name": "com.google.javascript.jscomp.Compiler",
    "signature": "com.google.javascript.jscomp.Compiler.Compiler(PrintStream)",
    "snippet": "  public Compiler(PrintStream stream) {\n    addChangeHandler(recentChange);\n    outStream = stream;\n  }",
    "comment": " Creates n Compiler that reports errors and warnings to an output stream. ",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 0
  },
  {
    "name": "Compiler.acceptConstKeyword",
    "class_name": "com.google.javascript.jscomp.Compiler",
    "signature": "com.google.javascript.jscomp.Compiler.acceptConstKeyword()",
    "snippet": "  @Override\n  public boolean acceptConstKeyword() {\n    return options.acceptConstKeyword;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 0
  },
  {
    "name": "Compiler.addChangeHandler",
    "class_name": "com.google.javascript.jscomp.Compiler",
    "signature": "com.google.javascript.jscomp.Compiler.addChangeHandler(CodeChangeHandler)",
    "snippet": "  @Override\n  void addChangeHandler(CodeChangeHandler handler) {\n    codeChangeHandlers.add(handler);\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 0
  },
  {
    "name": "Compiler.createMessageFormatter",
    "class_name": "com.google.javascript.jscomp.Compiler",
    "signature": "com.google.javascript.jscomp.Compiler.createMessageFormatter()",
    "snippet": "  private MessageFormatter createMessageFormatter() {\n    boolean colorize = options.shouldColorizeErrorOutput();\n    return options.errorFormat.toFormatter(this, colorize);\n  }",
    "comment": " Creates a message formatter instance corresponding to the value of {@link CompilerOptions}. ",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 0
  },
  {
    "name": "Compiler.getCodingConvention",
    "class_name": "com.google.javascript.jscomp.Compiler",
    "signature": "com.google.javascript.jscomp.Compiler.getCodingConvention()",
    "snippet": "  @Override\n  public CodingConvention getCodingConvention() {\n    CodingConvention convention = options.getCodingConvention();\n    convention = convention != null ? convention : defaultCodingConvention;\n    return convention;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 0
  },
  {
    "name": "Compiler.getDefaultErrorReporter",
    "class_name": "com.google.javascript.jscomp.Compiler",
    "signature": "com.google.javascript.jscomp.Compiler.getDefaultErrorReporter()",
    "snippet": "  @Override\n  ErrorReporter getDefaultErrorReporter() {\n    return defaultErrorReporter;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 0
  },
  {
    "name": "Compiler.getDiagnosticGroups",
    "class_name": "com.google.javascript.jscomp.Compiler",
    "signature": "com.google.javascript.jscomp.Compiler.getDiagnosticGroups()",
    "snippet": "  protected DiagnosticGroups getDiagnosticGroups() {\n    return new DiagnosticGroups();\n  }",
    "comment": " The warning classes that are available from the command-line, and are suppressable by the {@code @suppress} annotation. ",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 0
  },
  {
    "name": "Compiler.getErrorCount",
    "class_name": "com.google.javascript.jscomp.Compiler",
    "signature": "com.google.javascript.jscomp.Compiler.getErrorCount()",
    "snippet": "  public int getErrorCount() {\n    return errorManager.getErrorCount();\n  }",
    "comment": " Gets the number of errors. ",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 0
  },
  {
    "name": "Compiler.getParserConfig",
    "class_name": "com.google.javascript.jscomp.Compiler",
    "signature": "com.google.javascript.jscomp.Compiler.getParserConfig()",
    "snippet": "  @Override\n  Config getParserConfig() {\n    if (parserConfig == null) {\n      Config.LanguageMode mode;\n      switch (options.getLanguageIn()) {\n        case ECMASCRIPT3:\n          mode = Config.LanguageMode.ECMASCRIPT3;\n          break;\n        case ECMASCRIPT5:\n          mode = Config.LanguageMode.ECMASCRIPT5;\n          break;\n        case ECMASCRIPT5_STRICT:\n          mode = Config.LanguageMode.ECMASCRIPT5_STRICT;\n          break;\n        default:\n          throw new IllegalStateException(\"unexpected language mode\");\n      }\n\n      parserConfig = ParserRunner.createConfig(\n        isIdeMode(),\n        mode,\n        acceptConstKeyword(),\n        options.extraAnnotationNames);\n    }\n    return parserConfig;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 0
  },
  {
    "name": "Compiler.hasHaltingErrors",
    "class_name": "com.google.javascript.jscomp.Compiler",
    "signature": "com.google.javascript.jscomp.Compiler.hasHaltingErrors()",
    "snippet": "  @Override\n  boolean hasHaltingErrors() {\n    return !isIdeMode() && getErrorCount() > 0;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 0
  },
  {
    "name": "Compiler.initCompilerOptionsIfTesting",
    "class_name": "com.google.javascript.jscomp.Compiler",
    "signature": "com.google.javascript.jscomp.Compiler.initCompilerOptionsIfTesting()",
    "snippet": "  void initCompilerOptionsIfTesting() {\n    if (options == null) {\n      // initialization for tests that don't initialize the compiler\n      // by the normal mechanisms.\n      initOptions(newCompilerOptions());\n    }\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 0
  },
  {
    "name": "Compiler.initOptions",
    "class_name": "com.google.javascript.jscomp.Compiler",
    "signature": "com.google.javascript.jscomp.Compiler.initOptions(CompilerOptions)",
    "snippet": "  public void initOptions(CompilerOptions options) {\n    this.options = options;\n    if (errorManager == null) {\n      if (outStream == null) {\n        setErrorManager(\n            new LoggerErrorManager(createMessageFormatter(), logger));\n      } else {\n        PrintStreamErrorManager printer =\n            new PrintStreamErrorManager(createMessageFormatter(), outStream);\n        printer.setSummaryDetailLevel(options.summaryDetailLevel);\n        setErrorManager(printer);\n      }\n    }\n\n    // DiagnosticGroups override the plain checkTypes option.\n    if (options.enables(DiagnosticGroups.CHECK_TYPES)) {\n      options.checkTypes = true;\n    } else if (options.disables(DiagnosticGroups.CHECK_TYPES)) {\n      options.checkTypes = false;\n    } else if (!options.checkTypes) {\n      // If DiagnosticGroups did not override the plain checkTypes\n      // option, and checkTypes is enabled, then turn off the\n      // parser type warnings.\n      options.setWarningLevel(\n          DiagnosticGroup.forType(\n              RhinoErrorReporter.TYPE_PARSE_ERROR),\n          CheckLevel.OFF);\n    }\n\n    if (options.checkGlobalThisLevel.isOn() &&\n        !options.disables(DiagnosticGroups.GLOBAL_THIS)) {\n      options.setWarningLevel(\n          DiagnosticGroups.GLOBAL_THIS,\n          options.checkGlobalThisLevel);\n    }\n\n    if (options.getLanguageIn() == LanguageMode.ECMASCRIPT5_STRICT) {\n      options.setWarningLevel(\n          DiagnosticGroups.ES5_STRICT,\n          CheckLevel.ERROR);\n    }\n\n    // Initialize the warnings guard.\n    List<WarningsGuard> guards = Lists.newArrayList();\n    guards.add(\n        new SuppressDocWarningsGuard(\n            getDiagnosticGroups().getRegisteredGroups()));\n    guards.add(options.getWarningsGuard());\n\n    ComposeWarningsGuard composedGuards = new ComposeWarningsGuard(guards);\n\n    // All passes must run the variable check. This synthesizes\n    // variables later so that the compiler doesn't crash. It also\n    // checks the externs file for validity. If you don't want to warn\n    // about missing variable declarations, we shut that specific\n    // error off.\n    if (!options.checkSymbols &&\n        !composedGuards.enables(DiagnosticGroups.CHECK_VARIABLES)) {\n      composedGuards.addGuard(new DiagnosticGroupWarningsGuard(\n          DiagnosticGroups.CHECK_VARIABLES, CheckLevel.OFF));\n    }\n\n    this.warningsGuard = composedGuards;\n  }",
    "comment": " Initialize the compiler options. Only necessary if you're not doing a normal compile() job. ",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 0
  },
  {
    "name": "Compiler.isIdeMode",
    "class_name": "com.google.javascript.jscomp.Compiler",
    "signature": "com.google.javascript.jscomp.Compiler.isIdeMode()",
    "snippet": "  @Override\n  public boolean isIdeMode() {\n    return options.ideMode;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 0
  },
  {
    "name": "Compiler.newCompilerOptions",
    "class_name": "com.google.javascript.jscomp.Compiler",
    "signature": "com.google.javascript.jscomp.Compiler.newCompilerOptions()",
    "snippet": "  protected CompilerOptions newCompilerOptions() {\n    return new CompilerOptions();\n  }",
    "comment": " Allow subclasses to override the default CompileOptions object. ",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 0
  },
  {
    "name": "Compiler.parseTestCode",
    "class_name": "com.google.javascript.jscomp.Compiler",
    "signature": "com.google.javascript.jscomp.Compiler.parseTestCode(String)",
    "snippet": "  @Override\n  Node parseTestCode(String js) {\n    initCompilerOptionsIfTesting();\n    CompilerInput input = new CompilerInput(\n        SourceFile.fromCode(\"[testcode]\", js));\n    if (inputsById == null) {\n      inputsById = Maps.newHashMap();\n    }\n    putCompilerInput(input.getInputId(), input);\n    return input.getAstRoot(this);\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 0
  },
  {
    "name": "Compiler.prepareAst",
    "class_name": "com.google.javascript.jscomp.Compiler",
    "signature": "com.google.javascript.jscomp.Compiler.prepareAst(Node)",
    "snippet": "  @Override\n  void prepareAst(Node root) {\n    CompilerPass pass = new PrepareAst(this);\n    pass.process(null, root);\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 0
  },
  {
    "name": "Compiler.putCompilerInput",
    "class_name": "com.google.javascript.jscomp.Compiler",
    "signature": "com.google.javascript.jscomp.Compiler.putCompilerInput(InputId,CompilerInput)",
    "snippet": "  private CompilerInput putCompilerInput(InputId id, CompilerInput input) {\n    input.setCompiler(this);\n    return inputsById.put(id, input);\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 0
  },
  {
    "name": "Compiler.setErrorManager",
    "class_name": "com.google.javascript.jscomp.Compiler",
    "signature": "com.google.javascript.jscomp.Compiler.setErrorManager(ErrorManager)",
    "snippet": "  public void setErrorManager(ErrorManager errorManager) {\n    Preconditions.checkNotNull(\n        errorManager, \"the error manager cannot be null\");\n    this.errorManager = errorManager;\n  }",
    "comment": " Sets the error manager.  @param errorManager the error manager, it cannot be {@code null} ",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 0
  },
  {
    "name": "CompilerInput.CompilerInput",
    "class_name": "com.google.javascript.jscomp.CompilerInput",
    "signature": "com.google.javascript.jscomp.CompilerInput.CompilerInput(SourceAst,InputId,boolean)",
    "snippet": "  public CompilerInput(SourceAst ast, InputId inputId, boolean isExtern) {\n    this.ast = ast;\n    this.id = inputId;\n\n    // TODO(nicksantos): Add a precondition check here. People are passing\n    // in null, but they should not be.\n    if (ast != null && ast.getSourceFile() != null) {\n      ast.getSourceFile().setIsExtern(isExtern);\n    }\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 0
  },
  {
    "name": "CompilerInput.CompilerInput",
    "class_name": "com.google.javascript.jscomp.CompilerInput",
    "signature": "com.google.javascript.jscomp.CompilerInput.CompilerInput(SourceAst,boolean)",
    "snippet": "  public CompilerInput(SourceAst ast, boolean isExtern) {\n    this(ast, ast.getInputId(), isExtern);\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 0
  },
  {
    "name": "CompilerInput.CompilerInput",
    "class_name": "com.google.javascript.jscomp.CompilerInput",
    "signature": "com.google.javascript.jscomp.CompilerInput.CompilerInput(SourceFile)",
    "snippet": "  public CompilerInput(SourceFile file) {\n    this(file, false);\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 0
  },
  {
    "name": "CompilerInput.CompilerInput",
    "class_name": "com.google.javascript.jscomp.CompilerInput",
    "signature": "com.google.javascript.jscomp.CompilerInput.CompilerInput(SourceFile,boolean)",
    "snippet": "  public CompilerInput(SourceFile file, boolean isExtern) {\n    this(new JsAst(file), isExtern);\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 0
  },
  {
    "name": "CompilerInput.getAstRoot",
    "class_name": "com.google.javascript.jscomp.CompilerInput",
    "signature": "com.google.javascript.jscomp.CompilerInput.getAstRoot(AbstractCompiler)",
    "snippet": "  @Override\n  public Node getAstRoot(AbstractCompiler compiler) {\n    Node root = ast.getAstRoot(compiler);\n    // The root maybe null if the AST can not be created.\n    if (root != null) {\n      Preconditions.checkState(root.isScript());\n      Preconditions.checkNotNull(root.getInputId());\n    }\n    return root;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 0
  },
  {
    "name": "CompilerInput.getInputId",
    "class_name": "com.google.javascript.jscomp.CompilerInput",
    "signature": "com.google.javascript.jscomp.CompilerInput.getInputId()",
    "snippet": "  @Override\n  public InputId getInputId() {\n    return id;\n  }",
    "comment": "Returns a name for this input. Must be unique across all inputs. */",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 0
  },
  {
    "name": "CompilerInput.setCompiler",
    "class_name": "com.google.javascript.jscomp.CompilerInput",
    "signature": "com.google.javascript.jscomp.CompilerInput.setCompiler(AbstractCompiler)",
    "snippet": "  public void setCompiler(AbstractCompiler compiler) {\n    this.compiler = compiler;\n  }",
    "comment": "Sets an abstract compiler for doing parsing. */",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 0
  },
  {
    "name": "CompilerOptions.CompilerOptions",
    "class_name": "com.google.javascript.jscomp.CompilerOptions",
    "signature": "com.google.javascript.jscomp.CompilerOptions.CompilerOptions()",
    "snippet": "  public CompilerOptions() {\n    // Accepted language\n    languageIn = LanguageMode.ECMASCRIPT3;\n\n    // Language variation\n    acceptConstKeyword = false;\n\n    // Checks\n    skipAllPasses = false;\n    nameAnonymousFunctionsOnly = false;\n    devMode = DevMode.OFF;\n    checkSymbols = false;\n    aggressiveVarCheck = CheckLevel.OFF;\n    checkSuspiciousCode = false;\n    checkControlStructures = false;\n    checkTypes = false;\n    tightenTypes = false;\n    reportMissingOverride = CheckLevel.OFF;\n    reportUnknownTypes = CheckLevel.OFF;\n    checkRequires = CheckLevel.OFF;\n    checkProvides = CheckLevel.OFF;\n    checkGlobalNamesLevel = CheckLevel.OFF;\n    brokenClosureRequiresLevel = CheckLevel.ERROR;\n    checkGlobalThisLevel = CheckLevel.OFF;\n    checkUnreachableCode = CheckLevel.OFF;\n    checkMissingReturn = CheckLevel.OFF;\n    checkMissingGetCssNameLevel = CheckLevel.OFF;\n    checkMissingGetCssNameBlacklist = null;\n    checkCaja = false;\n    computeFunctionSideEffects = false;\n    chainCalls = false;\n    extraAnnotationNames = null;\n\n    // Optimizations\n    foldConstants = false;\n    coalesceVariableNames = false;\n    deadAssignmentElimination = false;\n    inlineConstantVars = false;\n    inlineFunctions = false;\n    inlineLocalFunctions = false;\n    assumeStrictThis = false;\n    assumeClosuresOnlyCaptureReferences = false;\n    inlineProperties = false;\n    crossModuleCodeMotion = false;\n    crossModuleMethodMotion = false;\n    inlineGetters = false;\n    inlineVariables = false;\n    inlineLocalVariables = false;\n    smartNameRemoval = false;\n    removeDeadCode = false;\n    extractPrototypeMemberDeclarations = false;\n    removeUnusedPrototypeProperties = false;\n    removeUnusedPrototypePropertiesInExterns = false;\n    removeUnusedVars = false;\n    removeUnusedLocalVars = false;\n    aliasExternals = false;\n    collapseVariableDeclarations = false;\n    groupVariableDeclarations = false;\n    collapseAnonymousFunctions = false;\n    aliasableStrings = Collections.emptySet();\n    aliasStringsBlacklist = \"\";\n    aliasAllStrings = false;\n    outputJsStringUsage = false;\n    convertToDottedProperties = false;\n    rewriteFunctionExpressions = false;\n    optimizeParameters = false;\n    optimizeReturns = false;\n\n    // Renaming\n    variableRenaming = VariableRenamingPolicy.OFF;\n    propertyRenaming = PropertyRenamingPolicy.OFF;\n    propertyAffinity = false;\n    labelRenaming = false;\n    generatePseudoNames = false;\n    shadowVariables = false;\n    renamePrefix = null;\n    aliasKeywords = false;\n    collapseProperties = false;\n    collapsePropertiesOnExternTypes = false;\n    collapseObjectLiterals = false;\n    devirtualizePrototypeMethods = false;\n    disambiguateProperties = false;\n    ambiguateProperties = false;\n    anonymousFunctionNaming = AnonymousFunctionNamingPolicy.OFF;\n    exportTestFunctions = false;\n\n    // Alterations\n    runtimeTypeCheck = false;\n    runtimeTypeCheckLogFunction = null;\n    ignoreCajaProperties = false;\n    syntheticBlockStartMarker = null;\n    syntheticBlockEndMarker = null;\n    locale = null;\n    markAsCompiled = false;\n    removeTryCatchFinally = false;\n    closurePass = false;\n    jqueryPass = false;\n    rewriteNewDateGoogNow = true;\n    removeAbstractMethods = true;\n    removeClosureAsserts = false;\n    stripTypes = Collections.emptySet();\n    stripNameSuffixes = Collections.emptySet();\n    stripNamePrefixes = Collections.emptySet();\n    stripTypePrefixes = Collections.emptySet();\n    customPasses = null;\n    markNoSideEffectCalls = false;\n    defineReplacements = Maps.newHashMap();\n    tweakProcessing = TweakProcessing.OFF;\n    tweakReplacements = Maps.newHashMap();\n    moveFunctionDeclarations = false;\n    instrumentationTemplate = null;\n    appNameStr = \"\";\n    recordFunctionInformation = false;\n    generateExports = false;\n    cssRenamingMap = null;\n    processObjectPropertyString = false;\n    idGenerators = Collections.emptySet();\n    replaceStringsFunctionDescriptions = Collections.emptyList();\n    replaceStringsPlaceholderToken = \"\";\n    replaceStringsReservedStrings = Collections.emptySet();\n    propertyInvalidationErrors = Maps.newHashMap();\n\n    // Output\n    printInputDelimiter = false;\n    prettyPrint = false;\n    lineBreak = false;\n    preferLineBreakAtEndOfFile = false;\n    reportPath = null;\n    tracer = TracerMode.OFF;\n    colorizeErrorOutput = false;\n    errorFormat = ErrorFormat.SINGLELINE;\n    debugFunctionSideEffectsPath = null;\n    externExports = false;\n    nameReferenceReportPath = null;\n    nameReferenceGraphPath = null;\n\n    // Debugging\n    aliasHandler = NULL_ALIAS_TRANSFORMATION_HANDLER;\n    errorHandler = null;\n  }",
    "comment": " Initializes compiler options. All options are disabled by default.  Command-line frontends to the compiler should set these properties like a builder. ",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 0
  },
  {
    "name": "CompilerOptions.addWarningsGuard",
    "class_name": "com.google.javascript.jscomp.CompilerOptions",
    "signature": "com.google.javascript.jscomp.CompilerOptions.addWarningsGuard(WarningsGuard)",
    "snippet": "  public void addWarningsGuard(WarningsGuard guard) {\n    warningsGuard.addGuard(guard);\n  }",
    "comment": " Add a guard to the set of warnings guards. ",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 0
  },
  {
    "name": "CompilerOptions.disables",
    "class_name": "com.google.javascript.jscomp.CompilerOptions",
    "signature": "com.google.javascript.jscomp.CompilerOptions.disables(DiagnosticGroup)",
    "snippet": "  boolean disables(DiagnosticGroup type) {\n    return warningsGuard.disables(type);\n  }",
    "comment": " Whether the warnings guard in this Options object disables the given group of warnings. ",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 0
  },
  {
    "name": "CompilerOptions.enables",
    "class_name": "com.google.javascript.jscomp.CompilerOptions",
    "signature": "com.google.javascript.jscomp.CompilerOptions.enables(DiagnosticGroup)",
    "snippet": "  boolean enables(DiagnosticGroup type) {\n    return warningsGuard.enables(type);\n  }",
    "comment": " Whether the warnings guard in this Options object enables the given group of warnings. ",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 0
  },
  {
    "name": "CompilerOptions.getCodingConvention",
    "class_name": "com.google.javascript.jscomp.CompilerOptions",
    "signature": "com.google.javascript.jscomp.CompilerOptions.getCodingConvention()",
    "snippet": "  public CodingConvention getCodingConvention() {\n    return codingConvention;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 0
  },
  {
    "name": "CompilerOptions.getLanguageIn",
    "class_name": "com.google.javascript.jscomp.CompilerOptions",
    "signature": "com.google.javascript.jscomp.CompilerOptions.getLanguageIn()",
    "snippet": "  public LanguageMode getLanguageIn() {\n    return languageIn;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 0
  },
  {
    "name": "CompilerOptions.getWarningsGuard",
    "class_name": "com.google.javascript.jscomp.CompilerOptions",
    "signature": "com.google.javascript.jscomp.CompilerOptions.getWarningsGuard()",
    "snippet": "  WarningsGuard getWarningsGuard() {\n    return warningsGuard;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 0
  },
  {
    "name": "CompilerOptions.setWarningLevel",
    "class_name": "com.google.javascript.jscomp.CompilerOptions",
    "signature": "com.google.javascript.jscomp.CompilerOptions.setWarningLevel(DiagnosticGroup,CheckLevel)",
    "snippet": "  public void setWarningLevel(DiagnosticGroup type, CheckLevel level) {\n    addWarningsGuard(new DiagnosticGroupWarningsGuard(type, level));\n  }",
    "comment": " Configure the given type of warning to the given level. ",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 0
  },
  {
    "name": "CompilerOptions.shouldColorizeErrorOutput",
    "class_name": "com.google.javascript.jscomp.CompilerOptions",
    "signature": "com.google.javascript.jscomp.CompilerOptions.shouldColorizeErrorOutput()",
    "snippet": "  public boolean shouldColorizeErrorOutput() {\n    return colorizeErrorOutput;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 0
  },
  {
    "name": "ComposeWarningsGuard.ComposeWarningsGuard",
    "class_name": "com.google.javascript.jscomp.ComposeWarningsGuard",
    "signature": "com.google.javascript.jscomp.ComposeWarningsGuard.ComposeWarningsGuard(List)",
    "snippet": "  public ComposeWarningsGuard(List<WarningsGuard> guards) {\n    addGuards(guards);\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 0
  },
  {
    "name": "ComposeWarningsGuard.ComposeWarningsGuard",
    "class_name": "com.google.javascript.jscomp.ComposeWarningsGuard",
    "signature": "com.google.javascript.jscomp.ComposeWarningsGuard.ComposeWarningsGuard(WarningsGuard[])",
    "snippet": "  public ComposeWarningsGuard(WarningsGuard... guards) {\n    this(Lists.newArrayList(guards));\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 0
  },
  {
    "name": "ComposeWarningsGuard.addGuard",
    "class_name": "com.google.javascript.jscomp.ComposeWarningsGuard",
    "signature": "com.google.javascript.jscomp.ComposeWarningsGuard.addGuard(WarningsGuard)",
    "snippet": "  void addGuard(WarningsGuard guard) {\n    if (guard instanceof ComposeWarningsGuard) {\n      ComposeWarningsGuard composeGuard = (ComposeWarningsGuard) guard;\n      if (composeGuard.demoteErrors) {\n        this.demoteErrors = composeGuard.demoteErrors;\n      }\n\n      // Reverse the guards, so that they have the same order in the result.\n      addGuards(Lists.newArrayList(composeGuard.guards.descendingSet()));\n    } else {\n      numberOfAdds++;\n      orderOfAddition.put(guard, numberOfAdds);\n      guards.remove(guard);\n      guards.add(guard);\n    }\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 0
  },
  {
    "name": "ComposeWarningsGuard.addGuards",
    "class_name": "com.google.javascript.jscomp.ComposeWarningsGuard",
    "signature": "com.google.javascript.jscomp.ComposeWarningsGuard.addGuards(Iterable)",
    "snippet": "  private void addGuards(Iterable<WarningsGuard> guards) {\n    for (WarningsGuard guard : guards) {\n      addGuard(guard);\n    }\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 0
  },
  {
    "name": "ComposeWarningsGuard.disables",
    "class_name": "com.google.javascript.jscomp.ComposeWarningsGuard",
    "signature": "com.google.javascript.jscomp.ComposeWarningsGuard.disables(DiagnosticGroup)",
    "snippet": "  @Override\n  public boolean disables(DiagnosticGroup group) {\n    nextSingleton:\n    for (DiagnosticType type : group.getTypes()) {\n      DiagnosticGroup singleton = DiagnosticGroup.forType(type);\n\n      for (WarningsGuard guard : guards) {\n        if (guard.disables(singleton)) {\n          continue nextSingleton;\n        } else if (guard.enables(singleton)) {\n          return false;\n        }\n      }\n\n      return false;\n    }\n\n    return true;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 0
  },
  {
    "name": "ComposeWarningsGuard.enables",
    "class_name": "com.google.javascript.jscomp.ComposeWarningsGuard",
    "signature": "com.google.javascript.jscomp.ComposeWarningsGuard.enables(DiagnosticGroup)",
    "snippet": "  @Override\n  public boolean enables(DiagnosticGroup group) {\n    for (WarningsGuard guard : guards) {\n      if (guard.enables(group)) {\n        return true;\n      } else if (guard.disables(group)) {\n        return false;\n      }\n    }\n\n    return false;\n  }",
    "comment": " Determines whether this guard will \"elevate\" the status of any disabled diagnostic type in the group to a warning or an error. ",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 0
  },
  {
    "name": "GuardComparator.compare",
    "class_name": "com.google.javascript.jscomp.ComposeWarningsGuard$GuardComparator",
    "signature": "com.google.javascript.jscomp.ComposeWarningsGuard$GuardComparator.compare(WarningsGuard,WarningsGuard)",
    "snippet": "    @Override\n    public int compare(WarningsGuard a, WarningsGuard b) {\n      int priorityDiff = a.getPriority() - b.getPriority();\n      if (priorityDiff != 0) {\n        return priorityDiff;\n      }\n\n      // If the warnings guards have the same priority, the one that\n      // was added last wins.\n      return orderOfAddition.get(b).intValue() -\n          orderOfAddition.get(a).intValue();\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 0
  },
  {
    "name": "DefinitionSite.DefinitionSite",
    "class_name": "com.google.javascript.jscomp.DefinitionSite",
    "signature": "com.google.javascript.jscomp.DefinitionSite.DefinitionSite(Node,Definition,JSModule,boolean,boolean)",
    "snippet": "  DefinitionSite(Node node,\n                 Definition definition,\n                 JSModule module,\n                 boolean inGlobalScope,\n                 boolean inExterns) {\n    this.node = node;\n    this.definition = definition;\n    this.module = module;\n    this.inGlobalScope = inGlobalScope;\n    this.inExterns = inExterns;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 0
  },
  {
    "name": "DefinitionsRemover.getDefinition",
    "class_name": "com.google.javascript.jscomp.DefinitionsRemover",
    "signature": "com.google.javascript.jscomp.DefinitionsRemover.getDefinition(Node,boolean)",
    "snippet": "  static Definition getDefinition(Node n, boolean isExtern) {\n    // TODO(user): Since we have parent pointers handy. A lot of constructors\n    // can be simplified.\n\n    // This logic must match #isDefinitionNode\n    Node parent = n.getParent();\n    if (parent == null) {\n      return null;\n    }\n\n    if (NodeUtil.isVarDeclaration(n) && n.hasChildren()) {\n      return new VarDefinition(n, isExtern);\n    } else if (parent.isFunction() && parent.getFirstChild() == n) {\n      if (!NodeUtil.isFunctionExpression(parent)) {\n        return new NamedFunctionDefinition(parent, isExtern);\n      } else if (!n.getString().equals(\"\")) {\n        return new FunctionExpressionDefinition(parent, isExtern);\n      }\n    } else if (parent.isAssign() && parent.getFirstChild() == n) {\n      return new AssignmentDefinition(parent, isExtern);\n    } else if (NodeUtil.isObjectLitKey(n, parent)) {\n      return new ObjectLiteralPropertyDefinition(parent, n, n.getFirstChild(),\n          isExtern);\n    } else if (parent.isParamList()) {\n      Node function = parent.getParent();\n      return new FunctionArgumentDefinition(function, n, isExtern);\n    }\n    return null;\n  }",
    "comment": " @return an {@link Definition} object if the node contains a definition or {@code null} otherwise. ",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 0
  },
  {
    "name": "VarDefinition.getLValue",
    "class_name": "com.google.javascript.jscomp.DefinitionsRemover$VarDefinition",
    "signature": "com.google.javascript.jscomp.DefinitionsRemover$VarDefinition.getLValue()",
    "snippet": "    @Override\n    public Node getLValue() {\n      return name;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 0
  },
  {
    "name": "VarDefinition.getRValue",
    "class_name": "com.google.javascript.jscomp.DefinitionsRemover$VarDefinition",
    "signature": "com.google.javascript.jscomp.DefinitionsRemover$VarDefinition.getRValue()",
    "snippet": "    @Override\n    public Node getRValue() {\n      return name.getFirstChild();\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 0
  },
  {
    "name": "DiagnosticGroup.DiagnosticGroup",
    "class_name": "com.google.javascript.jscomp.DiagnosticGroup",
    "signature": "com.google.javascript.jscomp.DiagnosticGroup.DiagnosticGroup(DiagnosticType[])",
    "snippet": "  public DiagnosticGroup(DiagnosticType ...types) {\n    this(null, types);\n  }",
    "comment": " Create a group that matches all errors of the given types. ",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 0
  },
  {
    "name": "DiagnosticGroup.DiagnosticGroup",
    "class_name": "com.google.javascript.jscomp.DiagnosticGroup",
    "signature": "com.google.javascript.jscomp.DiagnosticGroup.DiagnosticGroup(String,DiagnosticGroup[])",
    "snippet": "  public DiagnosticGroup(String name, DiagnosticGroup ...groups) {\n    Set<DiagnosticType> set = Sets.newHashSet();\n\n    for (DiagnosticGroup group : groups) {\n      set.addAll(group.types);\n    }\n\n    this.name = name;\n    this.types = ImmutableSet.copyOf(set);\n  }",
    "comment": " Create a composite group. ",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 0
  },
  {
    "name": "DiagnosticGroup.DiagnosticGroup",
    "class_name": "com.google.javascript.jscomp.DiagnosticGroup",
    "signature": "com.google.javascript.jscomp.DiagnosticGroup.DiagnosticGroup(String,DiagnosticType[])",
    "snippet": "  DiagnosticGroup(String name, DiagnosticType ...types) {\n    this.name = name;\n    this.types = ImmutableSet.copyOf(Arrays.asList(types));\n  }",
    "comment": " Create a group that matches all errors of the given types. ",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 0
  },
  {
    "name": "DiagnosticGroup.forType",
    "class_name": "com.google.javascript.jscomp.DiagnosticGroup",
    "signature": "com.google.javascript.jscomp.DiagnosticGroup.forType(DiagnosticType)",
    "snippet": "  public static DiagnosticGroup forType(DiagnosticType type) {\n    if (!singletons.containsKey(type)) {\n      singletons.put(type, new DiagnosticGroup(type));\n    }\n    return singletons.get(type);\n  }",
    "comment": "Create a diagnostic group that matches only the given type. */",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 0
  },
  {
    "name": "DiagnosticGroup.getTypes",
    "class_name": "com.google.javascript.jscomp.DiagnosticGroup",
    "signature": "com.google.javascript.jscomp.DiagnosticGroup.getTypes()",
    "snippet": "  public Iterable<DiagnosticType> getTypes() {\n    return types;\n  }",
    "comment": " Returns an iterable over all the types in this group. ",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 0
  },
  {
    "name": "DiagnosticGroup.isSubGroup",
    "class_name": "com.google.javascript.jscomp.DiagnosticGroup",
    "signature": "com.google.javascript.jscomp.DiagnosticGroup.isSubGroup(DiagnosticGroup)",
    "snippet": "  boolean isSubGroup(DiagnosticGroup group) {\n    for (DiagnosticType type : group.types) {\n      if (!matches(type)) {\n        return false;\n      }\n    }\n    return true;\n  }",
    "comment": " Returns whether all of the types in the given group are in this group. ",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 0
  },
  {
    "name": "DiagnosticGroup.matches",
    "class_name": "com.google.javascript.jscomp.DiagnosticGroup",
    "signature": "com.google.javascript.jscomp.DiagnosticGroup.matches(DiagnosticType)",
    "snippet": "  public boolean matches(DiagnosticType type) {\n    return types.contains(type);\n  }",
    "comment": " Returns whether the given type matches a type in this group. ",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 0
  },
  {
    "name": "DiagnosticGroupWarningsGuard.DiagnosticGroupWarningsGuard",
    "class_name": "com.google.javascript.jscomp.DiagnosticGroupWarningsGuard",
    "signature": "com.google.javascript.jscomp.DiagnosticGroupWarningsGuard.DiagnosticGroupWarningsGuard(DiagnosticGroup,CheckLevel)",
    "snippet": "  public DiagnosticGroupWarningsGuard(\n      DiagnosticGroup group, CheckLevel level) {\n    this.group = group;\n    this.level = level;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 0
  },
  {
    "name": "DiagnosticGroupWarningsGuard.disables",
    "class_name": "com.google.javascript.jscomp.DiagnosticGroupWarningsGuard",
    "signature": "com.google.javascript.jscomp.DiagnosticGroupWarningsGuard.disables(DiagnosticGroup)",
    "snippet": "  @Override\n  public boolean disables(DiagnosticGroup otherGroup) {\n    return !level.isOn() && group.isSubGroup(otherGroup);\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 0
  },
  {
    "name": "DiagnosticGroupWarningsGuard.enables",
    "class_name": "com.google.javascript.jscomp.DiagnosticGroupWarningsGuard",
    "signature": "com.google.javascript.jscomp.DiagnosticGroupWarningsGuard.enables(DiagnosticGroup)",
    "snippet": "  @Override\n  public boolean enables(DiagnosticGroup otherGroup) {\n    if (level.isOn()) {\n      for (DiagnosticType type : otherGroup.getTypes()) {\n        if (group.matches(type)) {\n          return true;\n        }\n      }\n    }\n\n    return false;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 0
  },
  {
    "name": "DiagnosticGroups.DiagnosticGroups",
    "class_name": "com.google.javascript.jscomp.DiagnosticGroups",
    "signature": "com.google.javascript.jscomp.DiagnosticGroups.DiagnosticGroups()",
    "snippet": "  public DiagnosticGroups() {}",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 0
  },
  {
    "name": "DiagnosticGroups.getRegisteredGroups",
    "class_name": "com.google.javascript.jscomp.DiagnosticGroups",
    "signature": "com.google.javascript.jscomp.DiagnosticGroups.getRegisteredGroups()",
    "snippet": "  protected Map<String, DiagnosticGroup> getRegisteredGroups() {\n    return ImmutableMap.copyOf(groupsByName);\n  }",
    "comment": "Get the registered diagnostic groups, indexed by name. */",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 0
  },
  {
    "name": "DiagnosticGroups.registerDeprecatedGroup",
    "class_name": "com.google.javascript.jscomp.DiagnosticGroups",
    "signature": "com.google.javascript.jscomp.DiagnosticGroups.registerDeprecatedGroup(String)",
    "snippet": "  static DiagnosticGroup registerDeprecatedGroup(String name) {\n    return registerGroup(name, new DiagnosticGroup(name, UNUSED));\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 0
  },
  {
    "name": "DiagnosticGroups.registerGroup",
    "class_name": "com.google.javascript.jscomp.DiagnosticGroups",
    "signature": "com.google.javascript.jscomp.DiagnosticGroups.registerGroup(String,DiagnosticGroup)",
    "snippet": "  static DiagnosticGroup registerGroup(String name,\n      DiagnosticGroup group) {\n    groupsByName.put(name, group);\n    return group;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 0
  },
  {
    "name": "DiagnosticGroups.registerGroup",
    "class_name": "com.google.javascript.jscomp.DiagnosticGroups",
    "signature": "com.google.javascript.jscomp.DiagnosticGroups.registerGroup(String,DiagnosticGroup[])",
    "snippet": "  static DiagnosticGroup registerGroup(String name,\n      DiagnosticGroup ... groups) {\n    DiagnosticGroup group = new DiagnosticGroup(name, groups);\n    groupsByName.put(name, group);\n    return group;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 0
  },
  {
    "name": "DiagnosticGroups.registerGroup",
    "class_name": "com.google.javascript.jscomp.DiagnosticGroups",
    "signature": "com.google.javascript.jscomp.DiagnosticGroups.registerGroup(String,DiagnosticType[])",
    "snippet": "  static DiagnosticGroup registerGroup(String name,\n      DiagnosticType ... types) {\n    DiagnosticGroup group = new DiagnosticGroup(name, types);\n    groupsByName.put(name, group);\n    return group;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 0
  },
  {
    "name": "DiagnosticType.disabled",
    "class_name": "com.google.javascript.jscomp.DiagnosticType",
    "signature": "com.google.javascript.jscomp.DiagnosticType.disabled(String,String)",
    "snippet": "  public static DiagnosticType disabled(String name,\n      String descriptionFormat) {\n    return make(name, CheckLevel.OFF, descriptionFormat);\n  }",
    "comment": " Create a DiagnosticType at level CheckLevel.OFF  @param name An identifier @param descriptionFormat A format string @return A new DiagnosticType ",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 0
  },
  {
    "name": "DiagnosticType.equals",
    "class_name": "com.google.javascript.jscomp.DiagnosticType",
    "signature": "com.google.javascript.jscomp.DiagnosticType.equals(Object)",
    "snippet": "  @Override\n  public boolean equals(Object type) {\n    return type instanceof DiagnosticType &&\n        ((DiagnosticType) type).key.equals(key);\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 0
  },
  {
    "name": "DiagnosticType.error",
    "class_name": "com.google.javascript.jscomp.DiagnosticType",
    "signature": "com.google.javascript.jscomp.DiagnosticType.error(String,String)",
    "snippet": "  public static DiagnosticType error(String name, String descriptionFormat) {\n    return make(name, CheckLevel.ERROR, descriptionFormat);\n  }",
    "comment": " Create a DiagnosticType at level CheckLevel.ERROR  @param name An identifier @param descriptionFormat A format string @return A new DiagnosticType ",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 0
  },
  {
    "name": "DiagnosticType.hashCode",
    "class_name": "com.google.javascript.jscomp.DiagnosticType",
    "signature": "com.google.javascript.jscomp.DiagnosticType.hashCode()",
    "snippet": "  @Override\n  public int hashCode() {\n    return key.hashCode();\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 0
  },
  {
    "name": "DiagnosticType.make",
    "class_name": "com.google.javascript.jscomp.DiagnosticType",
    "signature": "com.google.javascript.jscomp.DiagnosticType.make(String,CheckLevel,String)",
    "snippet": "  public static DiagnosticType make(String name, CheckLevel level,\n                                    String descriptionFormat) {\n    return\n        new DiagnosticType(name, level, new MessageFormat(descriptionFormat));\n  }",
    "comment": " Create a DiagnosticType at a given CheckLevel.  @param name An identifier @param level Either CheckLevel.ERROR or CheckLevel.WARNING @param descriptionFormat A format string @return A new DiagnosticType ",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 0
  },
  {
    "name": "DiagnosticType.warning",
    "class_name": "com.google.javascript.jscomp.DiagnosticType",
    "signature": "com.google.javascript.jscomp.DiagnosticType.warning(String,String)",
    "snippet": "  public static DiagnosticType warning(String name, String descriptionFormat) {\n    return make(name, CheckLevel.WARNING, descriptionFormat);\n  }",
    "comment": " Create a DiagnosticType at level CheckLevel.WARNING  @param name An identifier @param descriptionFormat A format string @return A new DiagnosticType ",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 0
  },
  {
    "name": "FunctionArgumentInjector.findModifiedParameters",
    "class_name": "com.google.javascript.jscomp.FunctionArgumentInjector",
    "signature": "com.google.javascript.jscomp.FunctionArgumentInjector.findModifiedParameters(Node)",
    "snippet": "  static Set<String> findModifiedParameters(Node fnNode) {\n    Set<String> names = getFunctionParameterSet(fnNode);\n    Set<String> unsafeNames = Sets.newHashSet();\n    return findModifiedParameters(\n        fnNode.getLastChild(), null, names, unsafeNames, false);\n  }",
    "comment": " Retrieve a set of names that can not be safely substituted in place. Example: function(a) { a = 0; } Inlining this without taking precautions would cause the call site value to be modified (bad). ",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 0
  },
  {
    "name": "FunctionArgumentInjector.findModifiedParameters",
    "class_name": "com.google.javascript.jscomp.FunctionArgumentInjector",
    "signature": "com.google.javascript.jscomp.FunctionArgumentInjector.findModifiedParameters(Node,Node,Set,Set,boolean)",
    "snippet": "  private static Set<String> findModifiedParameters(\n      Node n, Node parent, Set<String> names, Set<String> unsafe,\n      boolean inInnerFunction) {\n    Preconditions.checkArgument(unsafe != null);\n    if (n.isName()) {\n      if (names.contains(n.getString())) {\n        if (inInnerFunction || canNameValueChange(n, parent)) {\n          unsafe.add(n.getString());\n        }\n      }\n    } else if (n.isFunction()) {\n      // A function parameter can not be replaced with a direct inlined value\n      // if it is referred to by an inner function. The inner function\n      // can out live the call we are replacing, so inner function must\n      // capture a unique name.  This approach does not work within loop\n      // bodies so those are forbidden elsewhere.\n      inInnerFunction = true;\n    }\n\n    for (Node c : n.children()) {\n      findModifiedParameters(c, n, names, unsafe, inInnerFunction);\n    }\n\n    return unsafe;\n  }",
    "comment": " Check for uses of the named value that imply a pass-by-value parameter is expected.  This is used to prevent cases like:  function (x) { x=2; return x; }  We don't want \"undefined\" to be substituted for \"x\", and get undefined=2  @param n The node in question. @param parent The parent of the node. @param names The set of names to check. @param unsafe The set of names that require aliases. @param inInnerFunction Whether the inspection is occurring on a inner function. ",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 0
  },
  {
    "name": "FunctionArgumentInjector.getFunctionParameterSet",
    "class_name": "com.google.javascript.jscomp.FunctionArgumentInjector",
    "signature": "com.google.javascript.jscomp.FunctionArgumentInjector.getFunctionParameterSet(Node)",
    "snippet": "  private static Set<String> getFunctionParameterSet(Node fnNode) {\n    Set<String> set = Sets.newHashSet();\n    for (Node n : NodeUtil.getFunctionParameters(fnNode).children()) {\n      set.add(n.getString());\n    }\n    return set;\n  }",
    "comment": " Get a set of function parameter names. ",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 0
  },
  {
    "name": "FunctionInjector.FunctionInjector",
    "class_name": "com.google.javascript.jscomp.FunctionInjector",
    "signature": "com.google.javascript.jscomp.FunctionInjector.FunctionInjector(AbstractCompiler,Supplier,boolean,boolean,boolean)",
    "snippet": "  public FunctionInjector(\n      AbstractCompiler compiler,\n      Supplier<String> safeNameIdSupplier,\n      boolean allowDecomposition,\n      boolean assumeStrictThis,\n      boolean assumeMinimumCapture) {\n    Preconditions.checkNotNull(compiler);\n    Preconditions.checkNotNull(safeNameIdSupplier);\n    this.compiler = compiler;\n    this.safeNameIdSupplier = safeNameIdSupplier;\n    this.allowDecomposition = allowDecomposition;\n    this.assumeStrictThis = assumeStrictThis;\n    this.assumeMinimumCapture = assumeMinimumCapture;\n  }",
    "comment": " @param allowDecomposition Whether an effort should be made to break down expressions into simpler expressions to allow functions to be injected where they would otherwise be disallowed. ",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 0
  },
  {
    "name": "FunctionInjector.canInlineReferenceDirectly",
    "class_name": "com.google.javascript.jscomp.FunctionInjector",
    "signature": "com.google.javascript.jscomp.FunctionInjector.canInlineReferenceDirectly(Node,Node)",
    "snippet": "  private CanInlineResult canInlineReferenceDirectly(\n      Node callNode, Node fnNode) {\n    if (!isDirectCallNodeReplacementPossible(fnNode)) {\n      return CanInlineResult.NO;\n    }\n\n    Node block = fnNode.getLastChild();\n\n    // CALL NODE: [ NAME, ARG1, ARG2, ... ]\n    Node cArg = callNode.getFirstChild().getNext();\n\n    // Functions called via 'call' and 'apply' have a this-object as\n    // the first parameter, but this is not part of the called function's\n    // parameter list.\n    if (!callNode.getFirstChild().isName()) {\n      if (NodeUtil.isFunctionObjectCall(callNode)) {\n        // TODO(johnlenz): Support replace this with a value.\n        if (cArg == null || !cArg.isThis()) {\n          return CanInlineResult.NO;\n        }\n        cArg = cArg.getNext();\n      } else {\n        // \".apply\" call should be filtered before this.\n        Preconditions.checkState(!NodeUtil.isFunctionObjectApply(callNode));\n      }\n    }\n\n    // FUNCTION NODE -> LP NODE: [ ARG1, ARG2, ... ]\n    Node fnParam = NodeUtil.getFunctionParameters(fnNode).getFirstChild();\n    while (cArg != null || fnParam != null) {\n      // For each named parameter check if a mutable argument use more than one.\n      if (fnParam != null) {\n        if (cArg != null) {\n          // Check for arguments that are evaluated more than once.\n          // Note: Unlike block inlining, there it is not possible that a\n          // parameter reference will be in a loop.\n          if (NodeUtil.mayEffectMutableState(cArg)\n              && NodeUtil.getNameReferenceCount(\n                  block, fnParam.getString()) > 1) {\n            return CanInlineResult.NO;\n          }\n        }\n\n        // Move to the next name.\n        fnParam = fnParam.getNext();\n      }\n\n      // For every call argument check for side-effects, even if there\n      // isn't a named parameter to match.\n      if (cArg != null) {\n        if (NodeUtil.mayHaveSideEffects(cArg)) {\n          return CanInlineResult.NO;\n        }\n        cArg = cArg.getNext();\n      }\n    }\n\n    return CanInlineResult.YES;\n  }",
    "comment": " Determines whether a function can be inlined at a particular call site. There are several criteria that the function and reference must hold in order for the functions to be inlined: 1) If a call's arguments have side effects, the corresponding argument in the function must only be referenced once. For instance, this will not be inlined: <pre> function foo(a) { return a + a } x = foo(i++); </pre> ",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 0
  },
  {
    "name": "FunctionInjector.canInlineReferenceToFunction",
    "class_name": "com.google.javascript.jscomp.FunctionInjector",
    "signature": "com.google.javascript.jscomp.FunctionInjector.canInlineReferenceToFunction(NodeTraversal,Node,Node,Set,InliningMode,boolean,boolean)",
    "snippet": "  CanInlineResult canInlineReferenceToFunction(NodeTraversal t,\n      Node callNode, Node fnNode, Set<String> needAliases,\n      InliningMode mode, boolean referencesThis, boolean containsFunctions) {\n    // TODO(johnlenz): This function takes too many parameter, without\n    // context.  Modify the API to take a structure describing the function.\n\n    // Allow direct function calls or \"fn.call\" style calls.\n    if (!isSupportedCallType(callNode)) {\n      return CanInlineResult.NO;\n    }\n\n    // Limit where functions that contain functions can be inline.  Introducing\n    // an inner function into another function can capture a variable and cause\n    // a memory leak.  This isn't a problem in the global scope as those values\n    // last until explicitly cleared.\n    if (containsFunctions) {\n      if (!assumeMinimumCapture && !t.inGlobalScope()) {\n        // TODO(johnlenz): Allow inlining into any scope without local names or\n        // inner functions.\n        return CanInlineResult.NO;\n      } else if (NodeUtil.isWithinLoop(callNode)) {\n        // An inner closure maybe relying on a local value holding a value for a\n        // single iteration through a loop.\n        return CanInlineResult.NO;\n      }\n    }\n\n    // TODO(johnlenz): Add support for 'apply'\n    if (referencesThis && !NodeUtil.isFunctionObjectCall(callNode)) {\n      // TODO(johnlenz): Allow 'this' references to be replaced with a\n      // global 'this' object.\n      return CanInlineResult.NO;\n    }\n\n    if (mode == InliningMode.DIRECT) {\n      return canInlineReferenceDirectly(callNode, fnNode);\n    } else {\n      return canInlineReferenceAsStatementBlock(\n          t, callNode, fnNode, needAliases);\n    }\n  }",
    "comment": " @param t  The traversal use to reach the call site. @param callNode The CALL node. @param fnNode The function to evaluate for inlining. @param needAliases A set of function parameter names that can not be used without aliasing. Returned by getUnsafeParameterNames(). @param mode Inlining mode to be used. @param referencesThis Whether fnNode contains references to its this object. @param containsFunctions Whether fnNode contains inner functions. @return Whether the inlining can occur. ",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 0
  },
  {
    "name": "FunctionInjector.doesFunctionMeetMinimumRequirements",
    "class_name": "com.google.javascript.jscomp.FunctionInjector",
    "signature": "com.google.javascript.jscomp.FunctionInjector.doesFunctionMeetMinimumRequirements(String,Node)",
    "snippet": "  boolean doesFunctionMeetMinimumRequirements(\n      final String fnName, Node fnNode) {\n    Node block = NodeUtil.getFunctionBody(fnNode);\n\n    // Basic restrictions on functions that can be inlined:\n    // 0) The function is inlinable by convention\n    // 1) It contains a reference to itself.\n    // 2) It uses its parameters indirectly using \"arguments\" (it isn't\n    //    handled yet.\n    // 3) It references \"eval\". Inline a function containing eval can have\n    //    large performance implications.\n\n    if (!compiler.getCodingConvention().isInlinableFunction(fnNode)) {\n      return false;\n    }\n\n    final String fnRecursionName = fnNode.getFirstChild().getString();\n    Preconditions.checkState(fnRecursionName != null);\n\n    // If the function references \"arguments\" directly in the function\n    boolean referencesArguments = NodeUtil.isNameReferenced(\n        block, \"arguments\", NodeUtil.MATCH_NOT_FUNCTION);\n\n    // or it references \"eval\" or one of its names anywhere.\n    Predicate<Node> p = new Predicate<Node>(){\n      @Override\n      public boolean apply(Node n) {\n        if (n.isName()) {\n          return n.getString().equals(\"eval\")\n            || (!fnName.isEmpty()\n                && n.getString().equals(fnName))\n            || (!fnRecursionName.isEmpty()\n                && n.getString().equals(fnRecursionName));\n        }\n        return false;\n      }\n    };\n\n    return !referencesArguments\n        && !NodeUtil.has(block, p, Predicates.<Node>alwaysTrue());\n  }",
    "comment": " @param fnName The name of this function. This either the name of the variable to which the function is assigned or the name from the FUNCTION node. @param fnNode The FUNCTION node of the function to inspect. @return Whether the function node meets the minimum requirements for inlining. ",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 0
  },
  {
    "name": "FunctionInjector.doesLowerCost",
    "class_name": "com.google.javascript.jscomp.FunctionInjector",
    "signature": "com.google.javascript.jscomp.FunctionInjector.doesLowerCost(Node,int,int,int,int,int,boolean)",
    "snippet": "  private boolean doesLowerCost(\n      Node fnNode, int callCost,\n      int directInlines, int costDeltaDirect,\n      int blockInlines, int costDeltaBlock,\n      boolean removable) {\n\n    // Determine the threshold value for this inequality:\n    //     inline_cost < call_cost\n    // But solve it for the function declaration size so the size of it\n    // is only calculated once and terminated early if possible.\n\n    int fnInstanceCount = directInlines + blockInlines - (removable ? 1 : 0);\n    // Prevent division by zero.\n    if (fnInstanceCount == 0) {\n      // Special case single reference function that are being block inlined:\n      // If the cost of the inline is greater than the function definition size,\n      // don't inline.\n      if (blockInlines > 0 && costDeltaBlock > 0) {\n        return false;\n      }\n      return true;\n    }\n\n    int costDelta = (directInlines * costDeltaDirect) +\n        (blockInlines * costDeltaBlock);\n    int threshold = (callCost - costDelta) / fnInstanceCount;\n\n    return InlineCostEstimator.getCost(fnNode, threshold + 1) <= threshold;\n  }",
    "comment": " @return Whether inlining will lower cost. ",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 0
  },
  {
    "name": "FunctionInjector.estimateCallCost",
    "class_name": "com.google.javascript.jscomp.FunctionInjector",
    "signature": "com.google.javascript.jscomp.FunctionInjector.estimateCallCost(Node,boolean)",
    "snippet": "  private static int estimateCallCost(Node fnNode, boolean referencesThis) {\n    Node argsNode = NodeUtil.getFunctionParameters(fnNode);\n    int numArgs = argsNode.getChildCount();\n\n    int callCost = NAME_COST_ESTIMATE + PAREN_COST;\n    if (numArgs > 0) {\n      callCost += (numArgs * NAME_COST_ESTIMATE) + ((numArgs - 1) * COMMA_COST);\n    }\n\n    if (referencesThis) {\n      // TODO(johnlenz): Update this if we start supporting inlining\n      // other functions that reference this.\n      // The only functions that reference this that are currently inlined\n      // are those that are called via \".call\" with an explicit \"this\".\n      callCost += 5 + 5;  // \".call\" + \"this,\"\n    }\n\n    return callCost;\n  }",
    "comment": " Gets an estimate of the cost in characters of making the function call: the sum of the identifiers and the separators. @param referencesThis ",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 0
  },
  {
    "name": "FunctionInjector.inlineCostDelta",
    "class_name": "com.google.javascript.jscomp.FunctionInjector",
    "signature": "com.google.javascript.jscomp.FunctionInjector.inlineCostDelta(Node,Set,InliningMode)",
    "snippet": "  private static int inlineCostDelta(\n      Node fnNode, Set<String> namesToAlias, InliningMode mode) {\n    // The part of the function that is never inlined:\n    //    \"function xx(xx,xx){}\" (15 + (param count * 3) -1;\n    int paramCount = NodeUtil.getFunctionParameters(fnNode).getChildCount();\n    int commaCount = (paramCount > 1) ? paramCount - 1 : 0;\n    int costDeltaFunctionOverhead = 15 + commaCount +\n        (paramCount * InlineCostEstimator.ESTIMATED_IDENTIFIER_COST);\n\n    Node block = fnNode.getLastChild();\n    if (!block.hasChildren()) {\n      // Assume the inline cost is zero for empty functions.\n      return -costDeltaFunctionOverhead;\n    }\n\n    if (mode == InliningMode.DIRECT) {\n      // The part of the function that is inlined using direct inlining:\n      //    \"return \" (7)\n      return -(costDeltaFunctionOverhead + 7);\n    } else {\n      int aliasCount = namesToAlias.size();\n\n      // Originally, we estimated purely base on the function code size, relying\n      // on later optimizations. But that did not produce good results, so here\n      // we try to estimate the something closer to the actual inlined coded.\n\n      // NOTE 1: Result overhead is only if there is an assignment, but\n      // getting that information would require some refactoring.\n      // NOTE 2: The aliasing overhead is currently an under-estimate,\n      // as some parameters are aliased because of the parameters used.\n      // Perhaps we should just assume all parameters will be aliased?\n      final int INLINE_BLOCK_OVERHEAD = 4; // \"X:{}\"\n      final int PER_RETURN_OVERHEAD = 2;   // \"return\" --> \"break X\"\n      final int PER_RETURN_RESULT_OVERHEAD = 3; // \"XX=\"\n      final int PER_ALIAS_OVERHEAD = 3; // \"XX=\"\n\n      // TODO(johnlenz): Counting the number of returns is relatively expensive\n      //   this information should be determined during the traversal and\n      //   cached.\n      int returnCount = NodeUtil.getNodeTypeReferenceCount(\n          block, Token.RETURN, new NodeUtil.MatchShallowStatement());\n      int resultCount = (returnCount > 0) ? returnCount - 1 : 0;\n      int baseOverhead = (returnCount > 0) ? INLINE_BLOCK_OVERHEAD : 0;\n\n      int overhead = baseOverhead\n          + returnCount * PER_RETURN_OVERHEAD\n          + resultCount * PER_RETURN_RESULT_OVERHEAD\n          + aliasCount * PER_ALIAS_OVERHEAD;\n\n      return (overhead - costDeltaFunctionOverhead);\n    }\n  }",
    "comment": " @return The difference between the function definition cost and inline cost. ",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 0
  },
  {
    "name": "FunctionInjector.inliningLowersCost",
    "class_name": "com.google.javascript.jscomp.FunctionInjector",
    "signature": "com.google.javascript.jscomp.FunctionInjector.inliningLowersCost(JSModule,Node,Collection,Set,boolean,boolean)",
    "snippet": "  boolean inliningLowersCost(\n      JSModule fnModule, Node fnNode, Collection<? extends Reference> refs,\n      Set<String> namesToAlias, boolean isRemovable, boolean referencesThis) {\n    int referenceCount = refs.size();\n    if (referenceCount == 0) {\n      return true;\n    }\n\n    int referencesUsingBlockInlining = 0;\n\n    boolean checkModules = isRemovable && fnModule != null;\n    JSModuleGraph moduleGraph = compiler.getModuleGraph();\n\n    for (Reference ref : refs) {\n      if (ref.mode == InliningMode.BLOCK) {\n        referencesUsingBlockInlining++;\n      }\n\n      // Check if any of the references cross the module boundaries.\n      if (checkModules && ref.module != null) {\n        if (ref.module != fnModule &&\n            !moduleGraph.dependsOn(ref.module, fnModule)) {\n          // Calculate the cost as if the function were non-removable,\n          // if it still lowers the cost inline it.\n          isRemovable = false;\n          checkModules = false;  // no need to check additional modules.\n        }\n      }\n    }\n\n    int referencesUsingDirectInlining = referenceCount -\n        referencesUsingBlockInlining;\n\n    // Don't bother calculating the cost of function for simple functions where\n    // possible.\n    // However, when inlining a complex function, even a single reference may be\n    // larger than the original function if there are many returns (resulting\n    // in additional assignments) or many parameters that need to be aliased\n    // so use the cost estimating.\n    if (referenceCount == 1 && isRemovable &&\n        referencesUsingDirectInlining == 1) {\n      return true;\n    }\n\n    int callCost = estimateCallCost(fnNode, referencesThis);\n    int overallCallCost = callCost * referenceCount;\n\n    int costDeltaDirect = inlineCostDelta(\n        fnNode, namesToAlias, InliningMode.DIRECT);\n    int costDeltaBlock = inlineCostDelta(\n        fnNode, namesToAlias, InliningMode.BLOCK);\n\n    return doesLowerCost(fnNode, overallCallCost,\n        referencesUsingDirectInlining, costDeltaDirect,\n        referencesUsingBlockInlining, costDeltaBlock,\n        isRemovable);\n  }",
    "comment": " Determine if inlining the function is likely to reduce the code size. @param namesToAlias ",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 0
  },
  {
    "name": "FunctionInjector.isDirectCallNodeReplacementPossible",
    "class_name": "com.google.javascript.jscomp.FunctionInjector",
    "signature": "com.google.javascript.jscomp.FunctionInjector.isDirectCallNodeReplacementPossible(Node)",
    "snippet": "  boolean isDirectCallNodeReplacementPossible(Node fnNode) {\n    // Only inline single-statement functions\n    Node block = NodeUtil.getFunctionBody(fnNode);\n\n    // Check if this function is suitable for direct replacement of a CALL node:\n    // a function that consists of single return that returns an expression.\n    if (!block.hasChildren()) {\n      // special case empty functions.\n      return true;\n    } else if (block.hasOneChild()) {\n      // Only inline functions that return something.\n      if (block.getFirstChild().isReturn()\n          && block.getFirstChild().getFirstChild() != null) {\n        return true;\n      }\n    }\n\n    return false;\n  }",
    "comment": " Checks if the given function matches the criteria for an inlinable function, and if so, adds it to our set of inlinable functions. ",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 0
  },
  {
    "name": "FunctionInjector.isSupportedCallType",
    "class_name": "com.google.javascript.jscomp.FunctionInjector",
    "signature": "com.google.javascript.jscomp.FunctionInjector.isSupportedCallType(Node)",
    "snippet": "  private boolean isSupportedCallType(Node callNode) {\n    if (!callNode.getFirstChild().isName()) {\n      if (NodeUtil.isFunctionObjectCall(callNode)) {\n        if (!assumeStrictThis) {\n          Node thisValue = callNode.getFirstChild().getNext();\n          if (thisValue == null || !thisValue.isThis()) {\n            return false;\n          }\n        }\n      } else if (NodeUtil.isFunctionObjectApply(callNode)) {\n        return false;\n      }\n    }\n\n    return true;\n  }",
    "comment": " Only \".call\" calls and direct calls to functions are supported. @param callNode The call evaluate. @return Whether the call is of a type that is supported. ",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 0
  },
  {
    "name": "FunctionInjector.setKnownConstants",
    "class_name": "com.google.javascript.jscomp.FunctionInjector",
    "signature": "com.google.javascript.jscomp.FunctionInjector.setKnownConstants(Set)",
    "snippet": "  public void setKnownConstants(Set<String> knownConstants) {\n    // This is only expected to be set once. The same set should be used\n    // when evaluating call-sites and inlining calls.\n    Preconditions.checkState(this.knownConstants.isEmpty());\n    this.knownConstants = knownConstants;\n  }",
    "comment": " Store the names of known constants to be used when classifying call-sites in expressions. ",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 0
  },
  {
    "name": "GoogleCodingConvention.GoogleCodingConvention",
    "class_name": "com.google.javascript.jscomp.GoogleCodingConvention",
    "signature": "com.google.javascript.jscomp.GoogleCodingConvention.GoogleCodingConvention()",
    "snippet": "  public GoogleCodingConvention() {\n    this(new ClosureCodingConvention());\n  }",
    "comment": "By default, decorate the ClosureCodingConvention. */",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 0
  },
  {
    "name": "GoogleCodingConvention.GoogleCodingConvention",
    "class_name": "com.google.javascript.jscomp.GoogleCodingConvention",
    "signature": "com.google.javascript.jscomp.GoogleCodingConvention.GoogleCodingConvention(CodingConvention)",
    "snippet": "  public GoogleCodingConvention(CodingConvention convention) {\n    super(convention);\n  }",
    "comment": "Decorates a wrapped CodingConvention. */",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 0
  },
  {
    "name": "GoogleCodingConvention.isConstant",
    "class_name": "com.google.javascript.jscomp.GoogleCodingConvention",
    "signature": "com.google.javascript.jscomp.GoogleCodingConvention.isConstant(String)",
    "snippet": "  @Override\n  public boolean isConstant(String name) {\n    if (name.length() <= 1) {\n      return false;\n    }\n\n    // In compiled code, '$' is often a namespace delimiter. To allow inlining\n    // of namespaced constants, we strip off any namespaces here.\n    int pos = name.lastIndexOf('$');\n    if (pos >= 0) {\n      name = name.substring(pos + 1);\n      if (name.length() == 0) {\n        return false;\n      }\n    }\n\n    return isConstantKey(name);\n  }",
    "comment": " {@inheritDoc}  <p>This enforces the Google const name convention, that the first character after the last $ must be an upper-case letter and all subsequent letters must be upper case. The name must be at least 2 characters long.  <p>Examples: <pre> aaa          Not constant - lower-case letters in the name A            Not constant - too short goog$A       Constant - letters after the $ are upper-case. AA17         Constant - digits can appear after the first letter goog$7A      Not constant - first character after the $ must be upper case. $A           Constant - doesn't have to be anything in front of the $ </pre> ",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 0
  },
  {
    "name": "GoogleCodingConvention.isConstantKey",
    "class_name": "com.google.javascript.jscomp.GoogleCodingConvention",
    "signature": "com.google.javascript.jscomp.GoogleCodingConvention.isConstantKey(String)",
    "snippet": "  @Override\n  public boolean isConstantKey(String name) {\n    if (name.isEmpty() || !Character.isUpperCase(name.charAt(0))) {\n      return false;\n    }\n\n    // hack way of checking that there aren't any lower-case letters\n    return name.toUpperCase().equals(name);\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 0
  },
  {
    "name": "GoogleCodingConvention.isExported",
    "class_name": "com.google.javascript.jscomp.GoogleCodingConvention",
    "signature": "com.google.javascript.jscomp.GoogleCodingConvention.isExported(String,boolean)",
    "snippet": "  @Override\n  public boolean isExported(String name, boolean local) {\n    return super.isExported(name, local) ||\n        (!local && name.startsWith(\"_\"));\n  }",
    "comment": " {@inheritDoc}  <p>In Google code, any global name starting with an underscore is considered exported. ",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 0
  },
  {
    "name": "InlineCostEstimator.getCost",
    "class_name": "com.google.javascript.jscomp.InlineCostEstimator",
    "signature": "com.google.javascript.jscomp.InlineCostEstimator.getCost(Node)",
    "snippet": "  static int getCost(Node root) {\n    return getCost(root, Integer.MAX_VALUE);\n  }",
    "comment": " Determines the size of the js code. ",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 0
  },
  {
    "name": "InlineCostEstimator.getCost",
    "class_name": "com.google.javascript.jscomp.InlineCostEstimator",
    "signature": "com.google.javascript.jscomp.InlineCostEstimator.getCost(Node,int)",
    "snippet": "  static int getCost(Node root, int costThreshhold) {\n    CompiledSizeEstimator estimator = new CompiledSizeEstimator(costThreshhold);\n    estimator.add(root);\n    return estimator.getCost();\n  }",
    "comment": " Determines the estimated size of the js snippet represented by the node. ",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 0
  },
  {
    "name": "CompiledSizeEstimator.add",
    "class_name": "com.google.javascript.jscomp.InlineCostEstimator$CompiledSizeEstimator",
    "signature": "com.google.javascript.jscomp.InlineCostEstimator$CompiledSizeEstimator.add(Node)",
    "snippet": "    void add(Node root) {\n      CodeGenerator cg = new CodeGenerator(this);\n      cg.add(root);\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 0
  },
  {
    "name": "CompiledSizeEstimator.append",
    "class_name": "com.google.javascript.jscomp.InlineCostEstimator$CompiledSizeEstimator",
    "signature": "com.google.javascript.jscomp.InlineCostEstimator$CompiledSizeEstimator.append(String)",
    "snippet": "    @Override\n    void append(String str){\n      last = str.charAt(str.length() - 1);\n      cost += str.length();\n      if (maxCost <= cost) {\n        continueProcessing = false;\n      }\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 0
  },
  {
    "name": "CompiledSizeEstimator.continueProcessing",
    "class_name": "com.google.javascript.jscomp.InlineCostEstimator$CompiledSizeEstimator",
    "signature": "com.google.javascript.jscomp.InlineCostEstimator$CompiledSizeEstimator.continueProcessing()",
    "snippet": "    @Override\n    boolean continueProcessing() {\n      return continueProcessing;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 0
  },
  {
    "name": "CompiledSizeEstimator.getCost",
    "class_name": "com.google.javascript.jscomp.InlineCostEstimator$CompiledSizeEstimator",
    "signature": "com.google.javascript.jscomp.InlineCostEstimator$CompiledSizeEstimator.getCost()",
    "snippet": "    int getCost() {\n      return cost;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 0
  },
  {
    "name": "CompiledSizeEstimator.getLastChar",
    "class_name": "com.google.javascript.jscomp.InlineCostEstimator$CompiledSizeEstimator",
    "signature": "com.google.javascript.jscomp.InlineCostEstimator$CompiledSizeEstimator.getLastChar()",
    "snippet": "    @Override\n    char getLastChar() {\n      return last;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 0
  },
  {
    "name": "InlineFunctions.InlineFunctions",
    "class_name": "com.google.javascript.jscomp.InlineFunctions",
    "signature": "com.google.javascript.jscomp.InlineFunctions.InlineFunctions(AbstractCompiler,Supplier,boolean,boolean,boolean,boolean,boolean)",
    "snippet": "  InlineFunctions(AbstractCompiler compiler,\n      Supplier<String> safeNameIdSupplier,\n      boolean inlineGlobalFunctions,\n      boolean inlineLocalFunctions,\n      boolean blockFunctionInliningEnabled,\n      boolean assumeStrictThis,\n      boolean assumeMinimumCapture) {\n    Preconditions.checkArgument(compiler != null);\n    Preconditions.checkArgument(safeNameIdSupplier != null);\n    this.compiler = compiler;\n\n    this.inlineGlobalFunctions = inlineGlobalFunctions;\n    this.inlineLocalFunctions = inlineLocalFunctions;\n    this.blockFunctionInliningEnabled = blockFunctionInliningEnabled;\n    this.assumeMinimumCapture = assumeMinimumCapture;\n\n    this.injector = new FunctionInjector(\n        compiler, safeNameIdSupplier,\n        true, assumeStrictThis, assumeMinimumCapture);\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 0
  },
  {
    "name": "InlineFunctions.getOrCreateFunctionState",
    "class_name": "com.google.javascript.jscomp.InlineFunctions",
    "signature": "com.google.javascript.jscomp.InlineFunctions.getOrCreateFunctionState(String)",
    "snippet": "  FunctionState getOrCreateFunctionState(String fnName) {\n    FunctionState fs = fns.get(fnName);\n    if (fs == null) {\n      fs = new FunctionState();\n      fns.put(fnName, fs);\n    }\n    return fs;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 0
  },
  {
    "name": "InlineFunctions.inliningLowersCost",
    "class_name": "com.google.javascript.jscomp.InlineFunctions",
    "signature": "com.google.javascript.jscomp.InlineFunctions.inliningLowersCost(FunctionState)",
    "snippet": "  private boolean inliningLowersCost(FunctionState fs) {\n    return injector.inliningLowersCost(\n        fs.getModule(),\n        fs.getFn().getFunctionNode(),\n        fs.getReferences(),\n        fs.getNamesToAlias(),\n        fs.canRemove(),\n        fs.getReferencesThis());\n  }",
    "comment": " @return Whether inlining the function reduces code size. ",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 0
  },
  {
    "name": "InlineFunctions.isCandidateFunction",
    "class_name": "com.google.javascript.jscomp.InlineFunctions",
    "signature": "com.google.javascript.jscomp.InlineFunctions.isCandidateFunction(Function)",
    "snippet": "  private boolean isCandidateFunction(Function fn) {\n    // Don't inline exported functions.\n    String fnName = fn.getName();\n    if (compiler.getCodingConvention().isExported(fnName)) {\n      // TODO(johnlenz): Should we allow internal references to be inlined?\n      // An exported name can be replaced externally, any inlined instance\n      // would not reflect this change.\n      // To allow inlining we need to be able to distinguish between exports\n      // that are used in a read-only fashion and those that can be replaced\n      // by external definitions.\n      return false;\n    }\n\n    // Don't inline this special function\n    if (RenameProperties.RENAME_PROPERTY_FUNCTION_NAME.equals(fnName)) {\n      return false;\n    }\n\n    // Don't inline if we are specializing and the function can't be fixed up\n    if (specializationState != null &&\n        !specializationState.canFixupFunction(fn.getFunctionNode())) {\n      return false;\n    }\n\n    Node fnNode = fn.getFunctionNode();\n    return injector.doesFunctionMeetMinimumRequirements(fnName, fnNode);\n  }",
    "comment": " Checks if the given function matches the criteria for an inlinable function. ",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 0
  },
  {
    "name": "InlineFunctions.isCandidateUsage",
    "class_name": "com.google.javascript.jscomp.InlineFunctions",
    "signature": "com.google.javascript.jscomp.InlineFunctions.isCandidateUsage(Node)",
    "snippet": "  static boolean isCandidateUsage(Node name) {\n    Node parent = name.getParent();\n    Preconditions.checkState(name.isName());\n    if (parent.isVar() || parent.isFunction()) {\n      // This is a declaration.  Duplicate declarations are handle during\n      // function candidate gathering.\n      return true;\n    }\n\n    if (parent.isCall() && parent.getFirstChild() == name) {\n      // This is a normal reference to the function.\n      return true;\n    }\n\n    // Check for a \".call\" to the named function:\n    //   CALL\n    //     GETPROP/GETELEM\n    //       NAME\n    //       STRING == \"call\"\n    //     This-Value\n    //     Function-parameter-1\n    //     ...\n    if (NodeUtil.isGet(parent)\n         && name == parent.getFirstChild()\n         && name.getNext().isString()\n         && name.getNext().getString().equals(\"call\")) {\n      Node gramps = name.getAncestor(2);\n      if (gramps.isCall()\n          && gramps.getFirstChild() == parent) {\n        // Yep, a \".call\".\n        return true;\n      }\n    }\n    return false;\n  }",
    "comment": " @return Whether the name is used in a way that might be a candidate for inlining. ",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 0
  },
  {
    "name": "InlineFunctions.maybeAddFunction",
    "class_name": "com.google.javascript.jscomp.InlineFunctions",
    "signature": "com.google.javascript.jscomp.InlineFunctions.maybeAddFunction(Function,JSModule)",
    "snippet": "  private void maybeAddFunction(Function fn, JSModule module) {\n    String name = fn.getName();\n    FunctionState fs = getOrCreateFunctionState(name);\n\n    // TODO(johnlenz): Maybe \"smarten\" FunctionState by adding this logic\n    // to it?\n\n    // If the function has multiple definitions, don't inline it.\n    if (fs.hasExistingFunctionDefinition()) {\n      fs.setInline(false);\n    } else {\n      // verify the function hasn't already been marked as \"don't inline\"\n      if (fs.canInline()) {\n        // store it for use when inlining.\n        fs.setFn(fn);\n        if (injector.isDirectCallNodeReplacementPossible(\n            fn.getFunctionNode())) {\n          fs.inlineDirectly(true);\n        }\n\n        // verify the function meets all the requirements.\n        // TODO(johnlenz): Minimum requirement checks are about 5% of the\n        // runtime cost of this pass.\n        if (!isCandidateFunction(fn)) {\n          // It doesn't meet the requirements.\n          fs.setInline(false);\n        }\n\n        // Set the module and gather names that need temporaries.\n        if (fs.canInline()) {\n          fs.setModule(module);\n\n          Node fnNode = fn.getFunctionNode();\n          Set<String> namesToAlias =\n              FunctionArgumentInjector.findModifiedParameters(fnNode);\n          if (!namesToAlias.isEmpty()) {\n            fs.inlineDirectly(false);\n            fs.setNamesToAlias(namesToAlias);\n          }\n\n          Node block = NodeUtil.getFunctionBody(fnNode);\n          if (NodeUtil.referencesThis(block)) {\n            fs.setReferencesThis(true);\n          }\n\n          if (NodeUtil.containsFunction(block)) {\n            fs.setHasInnerFunctions(true);\n            // If there are inner functions, we can inline into global scope\n            // if there are no local vars or named functions.\n            // TODO(johnlenz): this can be improved by looking at the possible\n            // values for locals.  If there are simple values, or constants\n            // we could still inline.\n            if (!assumeMinimumCapture && hasLocalNames(fnNode)) {\n              fs.setInline(false);\n            }\n          }\n        }\n\n        // Check if block inlining is allowed.\n        if (fs.canInline() && !fs.canInlineDirectly()) {\n          if (!blockFunctionInliningEnabled) {\n            fs.setInline(false);\n          }\n        }\n      }\n    }\n  }",
    "comment": " Updates the FunctionState object for the given function. Checks if the given function matches the criteria for an inlinable function. ",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 0
  },
  {
    "name": "InlineFunctions.mimimizeCost",
    "class_name": "com.google.javascript.jscomp.InlineFunctions",
    "signature": "com.google.javascript.jscomp.InlineFunctions.mimimizeCost(FunctionState)",
    "snippet": "  private boolean mimimizeCost(FunctionState fs) {\n    if (!inliningLowersCost(fs)) {\n      // Try again without Block inlining references\n      if (fs.hasBlockInliningReferences()) {\n        fs.setRemove(false);\n        fs.removeBlockInliningReferences();\n        if (!fs.hasReferences() || !inliningLowersCost(fs)) {\n          return false;\n        }\n      } else {\n        return false;\n      }\n    }\n    return true;\n  }",
    "comment": " Determines if the function is worth inlining and potentially trims references that increase the cost. @return Whether inlining the references lowers the overall cost. ",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 0
  },
  {
    "name": "InlineFunctions.process",
    "class_name": "com.google.javascript.jscomp.InlineFunctions",
    "signature": "com.google.javascript.jscomp.InlineFunctions.process(Node,Node)",
    "snippet": "  @Override\n  public void process(Node externs, Node root) {\n    Preconditions.checkState(compiler.getLifeCycleStage().isNormalized());\n\n    NodeTraversal.traverse(compiler, root, new FindCandidateFunctions());\n    if (fns.isEmpty()) {\n      return;  // Nothing left to do.\n    }\n    NodeTraversal.traverse(compiler, root,\n       new FindCandidatesReferences(fns, anonFns));\n    trimCanidatesNotMeetingMinimumRequirements();\n    if (fns.isEmpty()) {\n      return;  // Nothing left to do.\n    }\n\n    // Store the set of function names eligible for inlining and use this to\n    // prevent function names from being moved into temporaries during\n    // expression decomposition. If this movement were allowed it would prevent\n    // the Inline callback from finding the function calls.\n    //\n    // This pass already assumes these are constants, so this is safe for anyone\n    // using function inlining.\n    //\n    Set<String> fnNames = Sets.newHashSet(fns.keySet());\n    injector.setKnownConstants(fnNames);\n\n    trimCanidatesUsingOnCost();\n    if (fns.isEmpty()) {\n      return;  // Nothing left to do.\n    }\n    resolveInlineConflicts();\n    decomposeExpressions(fnNames);\n    NodeTraversal.traverse(compiler, root,\n        new CallVisitor(\n            fns, anonFns, new Inline(injector, specializationState)));\n\n    removeInlinedFunctions();\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 0
  },
  {
    "name": "InlineFunctions.trimCanidatesNotMeetingMinimumRequirements",
    "class_name": "com.google.javascript.jscomp.InlineFunctions",
    "signature": "com.google.javascript.jscomp.InlineFunctions.trimCanidatesNotMeetingMinimumRequirements()",
    "snippet": "  private void trimCanidatesNotMeetingMinimumRequirements() {\n   Iterator<Entry<String, FunctionState>> i;\n   for (i = fns.entrySet().iterator(); i.hasNext();) {\n     FunctionState fs = i.next().getValue();\n     if (!fs.hasExistingFunctionDefinition() || !fs.canInline()) {\n       i.remove();\n     }\n   }\n  }",
    "comment": " Remove entries that aren't a valid inline candidates, from the list of encountered names. ",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 0
  },
  {
    "name": "InlineFunctions.trimCanidatesUsingOnCost",
    "class_name": "com.google.javascript.jscomp.InlineFunctions",
    "signature": "com.google.javascript.jscomp.InlineFunctions.trimCanidatesUsingOnCost()",
    "snippet": "  void trimCanidatesUsingOnCost() {\n    Iterator<Entry<String, FunctionState>> i;\n    for (i = fns.entrySet().iterator(); i.hasNext();) {\n      FunctionState fs = i.next().getValue();\n      if (fs.hasReferences()) {\n        // Only inline function if it decreases the code size.\n        boolean lowersCost = mimimizeCost(fs);\n        if (!lowersCost) {\n          // It shouldn't be inlined; remove it from the list.\n          i.remove();\n        }\n      } else if (!fs.canRemove()) {\n        // Don't bother tracking functions without references that can't be\n        // removed.\n        i.remove();\n      }\n    }\n  }",
    "comment": " Remove entries from the list of candidates that can't be inlined. ",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 0
  },
  {
    "name": "CallVisitor.visit",
    "class_name": "com.google.javascript.jscomp.InlineFunctions$CallVisitor",
    "signature": "com.google.javascript.jscomp.InlineFunctions$CallVisitor.visit(NodeTraversal,Node,Node)",
    "snippet": "    @Override\n    public void visit(NodeTraversal t, Node n, Node parent) {\n      switch (n.getType()) {\n        // Function calls\n        case Token.CALL:\n          Node child = n.getFirstChild();\n          String name = null;\n          // NOTE: The normalization pass insures that local names do not\n          // collide with global names.\n          if (child.isName()) {\n            name = child.getString();\n          } else if (child.isFunction()) {\n            name = anonFunctionMap.get(child);\n          } else if (NodeUtil.isFunctionObjectCall(n)) {\n            Preconditions.checkState(NodeUtil.isGet(child));\n            Node fnIdentifingNode = child.getFirstChild();\n            if (fnIdentifingNode.isName()) {\n              name = fnIdentifingNode.getString();\n            } else if (fnIdentifingNode.isFunction()) {\n              name = anonFunctionMap.get(fnIdentifingNode);\n            }\n          }\n\n          if (name != null) {\n            FunctionState fs = functionMap.get(name);\n            // Only visit call-sites for functions that can be inlined.\n            if (fs != null) {\n              callback.visitCallSite(t, n, parent, fs);\n            }\n          }\n          break;\n      }\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 0
  },
  {
    "name": "FindCandidateFunctions.findFunctionExpressions",
    "class_name": "com.google.javascript.jscomp.InlineFunctions$FindCandidateFunctions",
    "signature": "com.google.javascript.jscomp.InlineFunctions$FindCandidateFunctions.findFunctionExpressions(NodeTraversal,Node)",
    "snippet": "    public void findFunctionExpressions(NodeTraversal t, Node n) {\n      switch (n.getType()) {\n        // Functions expressions in the form of:\n        //   (function(){})();\n        case Token.CALL:\n          Node fnNode = null;\n          if (n.getFirstChild().isFunction()) {\n            fnNode = n.getFirstChild();\n          } else if (NodeUtil.isFunctionObjectCall(n)) {\n            Node fnIdentifingNode = n.getFirstChild().getFirstChild();\n            if (fnIdentifingNode.isFunction()) {\n              fnNode = fnIdentifingNode;\n            }\n          }\n\n          // If a interesting function was discovered, add it.\n          if (fnNode != null) {\n            Function fn = new FunctionExpression(fnNode, callsSeen++);\n            maybeAddFunction(fn, t.getModule());\n            anonFns.put(fnNode, fn.getName());\n          }\n          break;\n      }\n    }",
    "comment": " Find function expressions that are called directly in the form of (function(a,b,...){...})(a,b,...) or (function(a,b,...){...}).call(this,a,b, ...) ",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 0
  },
  {
    "name": "FindCandidateFunctions.findNamedFunctions",
    "class_name": "com.google.javascript.jscomp.InlineFunctions$FindCandidateFunctions",
    "signature": "com.google.javascript.jscomp.InlineFunctions$FindCandidateFunctions.findNamedFunctions(NodeTraversal,Node,Node)",
    "snippet": "    public void findNamedFunctions(NodeTraversal t, Node n, Node parent) {\n      if (!NodeUtil.isStatement(n)) {\n        // There aren't any interesting functions here.\n        return;\n      }\n\n      switch (n.getType()) {\n        // Functions expressions in the form of:\n        //   var fooFn = function(x) { return ... }\n        case Token.VAR:\n          Preconditions.checkState(n.hasOneChild());\n          Node nameNode = n.getFirstChild();\n          if (nameNode.isName() && nameNode.hasChildren()\n              && nameNode.getFirstChild().isFunction()) {\n            maybeAddFunction(new FunctionVar(n), t.getModule());\n          }\n          break;\n\n        // Named functions\n        // function Foo(x) { return ... }\n        case Token.FUNCTION:\n          Preconditions.checkState(NodeUtil.isStatementBlock(parent)\n              || parent.isLabel());\n          if (!NodeUtil.isFunctionExpression(n)) {\n            Function fn = new NamedFunction(n);\n            maybeAddFunction(fn, t.getModule());\n          }\n          break;\n      }\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 0
  },
  {
    "name": "FindCandidateFunctions.shouldTraverse",
    "class_name": "com.google.javascript.jscomp.InlineFunctions$FindCandidateFunctions",
    "signature": "com.google.javascript.jscomp.InlineFunctions$FindCandidateFunctions.shouldTraverse(NodeTraversal,Node,Node)",
    "snippet": "    @Override\n    public boolean shouldTraverse(\n        NodeTraversal nodeTraversal, Node n, Node parent) {\n      // Don't traverse into function bodies\n      // if we aren't inlining local functions.\n      return inlineLocalFunctions || nodeTraversal.inGlobalScope();\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 0
  },
  {
    "name": "FindCandidateFunctions.visit",
    "class_name": "com.google.javascript.jscomp.InlineFunctions$FindCandidateFunctions",
    "signature": "com.google.javascript.jscomp.InlineFunctions$FindCandidateFunctions.visit(NodeTraversal,Node,Node)",
    "snippet": "    @Override\n    public void visit(NodeTraversal t, Node n, Node parent) {\n      if ((t.inGlobalScope() && inlineGlobalFunctions)\n          || (!t.inGlobalScope() && inlineLocalFunctions)) {\n        findNamedFunctions(t, n, parent);\n\n        findFunctionExpressions(t, n);\n      }\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 0
  },
  {
    "name": "FindCandidatesReferences.checkNameUsage",
    "class_name": "com.google.javascript.jscomp.InlineFunctions$FindCandidatesReferences",
    "signature": "com.google.javascript.jscomp.InlineFunctions$FindCandidatesReferences.checkNameUsage(NodeTraversal,Node,Node)",
    "snippet": "    private void checkNameUsage(NodeTraversal t, Node n, Node parent) {\n      Preconditions.checkState(n.isName());\n\n      if (isCandidateUsage(n)) {\n        return;\n      }\n\n      // Other refs to a function name remove its candidacy for inlining\n      String name = n.getString();\n      FunctionState fs = fns.get(name);\n      if (fs == null) {\n        return;\n      }\n\n      // Unlike normal call/new parameters, references passed to\n      // JSCompiler_ObjectPropertyString are not aliases of a value, but\n      // a reference to the name itself, as such the value of the name is\n      // unknown and can not be inlined.\n      if (parent.isNew()) {\n        Node target = parent.getFirstChild();\n        if (target.isName() && target.getString().equals(\n            ObjectPropertyStringPreprocess.EXTERN_OBJECT_PROPERTY_STRING)) {\n          // This method is going to be replaced so don't inline it anywhere.\n          fs.setInline(false);\n        }\n      }\n\n      // If the name is being assigned to it can not be inlined.\n      if (parent.isAssign() && parent.getFirstChild() == n) {\n        // e.g. bar = something; <== we can't inline \"bar\"\n        // so mark the function as uninlinable.\n        // TODO(johnlenz): Should we just remove it from fns here?\n        fs.setInline(false);\n      } else {\n        // e.g. var fn = bar; <== we can't inline \"bar\"\n        // As this reference can't be inlined mark the function as\n        // unremovable.\n        fs.setRemove(false);\n      }\n    }",
    "comment": " Find functions that can be inlined. ",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 0
  },
  {
    "name": "FindCandidatesReferences.maybeAddReference",
    "class_name": "com.google.javascript.jscomp.InlineFunctions$FindCandidatesReferences",
    "signature": "com.google.javascript.jscomp.InlineFunctions$FindCandidatesReferences.maybeAddReference(NodeTraversal,FunctionState,Node,JSModule)",
    "snippet": "    void maybeAddReference(NodeTraversal t, FunctionState fs,\n        Node callNode, JSModule module) {\n      if (!fs.canInline()) {\n        return;\n      }\n\n      boolean referenceAdded = false;\n      InliningMode mode = fs.canInlineDirectly()\n           ? InliningMode.DIRECT : InliningMode.BLOCK;\n      referenceAdded = maybeAddReferenceUsingMode(\n          t, fs, callNode, module, mode);\n      if (!referenceAdded &&\n          mode == InliningMode.DIRECT && blockFunctionInliningEnabled) {\n        // This reference can not be directly inlined, see if\n        // block replacement inlining is possible.\n        mode = InliningMode.BLOCK;\n        referenceAdded = maybeAddReferenceUsingMode(\n            t, fs, callNode, module, mode);\n      }\n\n      if (!referenceAdded) {\n        // Don't try to remove a function if we can't inline all\n        // the references.\n        fs.setRemove(false);\n      }\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 0
  },
  {
    "name": "FindCandidatesReferences.maybeAddReferenceUsingMode",
    "class_name": "com.google.javascript.jscomp.InlineFunctions$FindCandidatesReferences",
    "signature": "com.google.javascript.jscomp.InlineFunctions$FindCandidatesReferences.maybeAddReferenceUsingMode(NodeTraversal,FunctionState,Node,JSModule,InliningMode)",
    "snippet": "    private boolean maybeAddReferenceUsingMode(\n        NodeTraversal t, FunctionState fs, Node callNode,\n        JSModule module, InliningMode mode) {\n\n      if (specializationState != null) {\n        // If we're specializing, make sure we can fixup\n        // the containing function before inlining\n        Node containingFunction = getContainingFunction(t);\n        if (containingFunction != null && !specializationState.canFixupFunction(\n            containingFunction)) {\n            return false;\n        }\n      }\n\n      CanInlineResult result = injector.canInlineReferenceToFunction(\n          t, callNode, fs.getFn().getFunctionNode(),\n          fs.getNamesToAlias(), mode, fs.getReferencesThis(),\n          fs.hasInnerFunctions());\n      if (result != CanInlineResult.NO) {\n        // Yeah!\n        boolean decompose =\n          (result == CanInlineResult.AFTER_DECOMPOSITION);\n        fs.addReference(new Reference(callNode, module, mode, decompose));\n        return true;\n      }\n\n      return false;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 0
  },
  {
    "name": "FindCandidatesReferences.visit",
    "class_name": "com.google.javascript.jscomp.InlineFunctions$FindCandidatesReferences",
    "signature": "com.google.javascript.jscomp.InlineFunctions$FindCandidatesReferences.visit(NodeTraversal,Node,Node)",
    "snippet": "    @Override\n    public void visit(NodeTraversal t, Node n, Node parent) {\n      super.visit(t, n, parent);\n      if (n.isName()) {\n        checkNameUsage(t, n, parent);\n      }\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 0
  },
  {
    "name": "FindCandidatesReferences.visitCallSite",
    "class_name": "com.google.javascript.jscomp.InlineFunctions$FindCandidatesReferences",
    "signature": "com.google.javascript.jscomp.InlineFunctions$FindCandidatesReferences.visitCallSite(NodeTraversal,Node,Node,FunctionState)",
    "snippet": "    @Override\n    public void visitCallSite(\n        NodeTraversal t, Node callNode, Node parent, FunctionState fs) {\n      maybeAddReference(t, fs, callNode, t.getModule());\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 0
  },
  {
    "name": "FunctionState.addReference",
    "class_name": "com.google.javascript.jscomp.InlineFunctions$FunctionState",
    "signature": "com.google.javascript.jscomp.InlineFunctions$FunctionState.addReference(Reference)",
    "snippet": "    public void addReference(Reference ref) {\n      if (references == null) {\n        references = Maps.newHashMap();\n      }\n      references.put(ref.callNode, ref);\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 0
  },
  {
    "name": "FunctionState.canInline",
    "class_name": "com.google.javascript.jscomp.InlineFunctions$FunctionState",
    "signature": "com.google.javascript.jscomp.InlineFunctions$FunctionState.canInline()",
    "snippet": "    public boolean canInline() {\n      return inline;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 0
  },
  {
    "name": "FunctionState.canInlineDirectly",
    "class_name": "com.google.javascript.jscomp.InlineFunctions$FunctionState",
    "signature": "com.google.javascript.jscomp.InlineFunctions$FunctionState.canInlineDirectly()",
    "snippet": "    public boolean canInlineDirectly() {\n      return inlineDirectly;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 0
  },
  {
    "name": "FunctionState.canRemove",
    "class_name": "com.google.javascript.jscomp.InlineFunctions$FunctionState",
    "signature": "com.google.javascript.jscomp.InlineFunctions$FunctionState.canRemove()",
    "snippet": "    public boolean canRemove() {\n      return remove;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 0
  },
  {
    "name": "FunctionState.getFn",
    "class_name": "com.google.javascript.jscomp.InlineFunctions$FunctionState",
    "signature": "com.google.javascript.jscomp.InlineFunctions$FunctionState.getFn()",
    "snippet": "    public Function getFn() {\n      return fn;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 0
  },
  {
    "name": "FunctionState.getModule",
    "class_name": "com.google.javascript.jscomp.InlineFunctions$FunctionState",
    "signature": "com.google.javascript.jscomp.InlineFunctions$FunctionState.getModule()",
    "snippet": "    public JSModule getModule() {\n      return module;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 0
  },
  {
    "name": "FunctionState.getNamesToAlias",
    "class_name": "com.google.javascript.jscomp.InlineFunctions$FunctionState",
    "signature": "com.google.javascript.jscomp.InlineFunctions$FunctionState.getNamesToAlias()",
    "snippet": "    public Set<String> getNamesToAlias() {\n      if (namesToAlias == null) {\n        return Collections.emptySet();\n      }\n      return Collections.unmodifiableSet(namesToAlias);\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 0
  },
  {
    "name": "FunctionState.getReferences",
    "class_name": "com.google.javascript.jscomp.InlineFunctions$FunctionState",
    "signature": "com.google.javascript.jscomp.InlineFunctions$FunctionState.getReferences()",
    "snippet": "    public Collection<Reference> getReferences() {\n      return getReferencesInternal().values();\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 0
  },
  {
    "name": "FunctionState.getReferencesInternal",
    "class_name": "com.google.javascript.jscomp.InlineFunctions$FunctionState",
    "signature": "com.google.javascript.jscomp.InlineFunctions$FunctionState.getReferencesInternal()",
    "snippet": "    private Map<Node, Reference> getReferencesInternal() {\n      if (references == null) {\n        return Collections.emptyMap();\n      }\n      return references;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 0
  },
  {
    "name": "FunctionState.getReferencesThis",
    "class_name": "com.google.javascript.jscomp.InlineFunctions$FunctionState",
    "signature": "com.google.javascript.jscomp.InlineFunctions$FunctionState.getReferencesThis()",
    "snippet": "    public boolean getReferencesThis() {\n      return this.referencesThis;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 0
  },
  {
    "name": "FunctionState.hasBlockInliningReferences",
    "class_name": "com.google.javascript.jscomp.InlineFunctions$FunctionState",
    "signature": "com.google.javascript.jscomp.InlineFunctions$FunctionState.hasBlockInliningReferences()",
    "snippet": "    public boolean hasBlockInliningReferences() {\n      for (Reference r : getReferencesInternal().values()) {\n        if (r.mode == InliningMode.BLOCK) {\n          return true;\n        }\n      }\n      return false;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 0
  },
  {
    "name": "FunctionState.hasExistingFunctionDefinition",
    "class_name": "com.google.javascript.jscomp.InlineFunctions$FunctionState",
    "signature": "com.google.javascript.jscomp.InlineFunctions$FunctionState.hasExistingFunctionDefinition()",
    "snippet": "    boolean hasExistingFunctionDefinition() {\n      return (fn != null);\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 0
  },
  {
    "name": "FunctionState.hasInnerFunctions",
    "class_name": "com.google.javascript.jscomp.InlineFunctions$FunctionState",
    "signature": "com.google.javascript.jscomp.InlineFunctions$FunctionState.hasInnerFunctions()",
    "snippet": "    public boolean hasInnerFunctions() {\n      return hasInnerFunctions;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 0
  },
  {
    "name": "FunctionState.hasReferences",
    "class_name": "com.google.javascript.jscomp.InlineFunctions$FunctionState",
    "signature": "com.google.javascript.jscomp.InlineFunctions$FunctionState.hasReferences()",
    "snippet": "    public boolean hasReferences() {\n      return (references != null && !references.isEmpty());\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 0
  },
  {
    "name": "FunctionState.inlineDirectly",
    "class_name": "com.google.javascript.jscomp.InlineFunctions$FunctionState",
    "signature": "com.google.javascript.jscomp.InlineFunctions$FunctionState.inlineDirectly(boolean)",
    "snippet": "    public void inlineDirectly(boolean directReplacement) {\n      this.inlineDirectly = directReplacement;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 0
  },
  {
    "name": "FunctionState.setFn",
    "class_name": "com.google.javascript.jscomp.InlineFunctions$FunctionState",
    "signature": "com.google.javascript.jscomp.InlineFunctions$FunctionState.setFn(Function)",
    "snippet": "    public void setFn(Function fn) {\n      Preconditions.checkState(this.fn == null);\n      this.fn = fn;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 0
  },
  {
    "name": "FunctionState.setModule",
    "class_name": "com.google.javascript.jscomp.InlineFunctions$FunctionState",
    "signature": "com.google.javascript.jscomp.InlineFunctions$FunctionState.setModule(JSModule)",
    "snippet": "    public void setModule(JSModule module) {\n      this.module = module;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 0
  },
  {
    "name": "FunctionVar.getFunctionNode",
    "class_name": "com.google.javascript.jscomp.InlineFunctions$FunctionVar",
    "signature": "com.google.javascript.jscomp.InlineFunctions$FunctionVar.getFunctionNode()",
    "snippet": "    @Override\n    public Node getFunctionNode() {\n      return var.getFirstChild().getFirstChild();\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 0
  },
  {
    "name": "FunctionVar.getName",
    "class_name": "com.google.javascript.jscomp.InlineFunctions$FunctionVar",
    "signature": "com.google.javascript.jscomp.InlineFunctions$FunctionVar.getName()",
    "snippet": "    @Override\n    public String getName() {\n      return var.getFirstChild().getString();\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 0
  },
  {
    "name": "JSModule.JSModule",
    "class_name": "com.google.javascript.jscomp.JSModule",
    "signature": "com.google.javascript.jscomp.JSModule.JSModule(String)",
    "snippet": "  public JSModule(String name) {\n    this.name = name;\n    this.depth = -1;\n  }",
    "comment": " Creates an instance.  @param name A unique name for the module ",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 0
  },
  {
    "name": "JSModule.add",
    "class_name": "com.google.javascript.jscomp.JSModule",
    "signature": "com.google.javascript.jscomp.JSModule.add(CompilerInput)",
    "snippet": "  public void add(CompilerInput input) {\n    inputs.add(input);\n    input.setModule(this);\n  }",
    "comment": "Adds a source code input to this module. */",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 0
  },
  {
    "name": "JSModule.add",
    "class_name": "com.google.javascript.jscomp.JSModule",
    "signature": "com.google.javascript.jscomp.JSModule.add(SourceFile)",
    "snippet": "  public void add(SourceFile file) {\n    add(new CompilerInput(file));\n  }",
    "comment": "Adds a source file input to this module. */",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 0
  },
  {
    "name": "JSModule.getInputs",
    "class_name": "com.google.javascript.jscomp.JSModule",
    "signature": "com.google.javascript.jscomp.JSModule.getInputs()",
    "snippet": "  public List<CompilerInput> getInputs() {\n    return inputs;\n  }",
    "comment": " Gets this module's list of source code inputs.  @return A list that may be empty but not null ",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 0
  },
  {
    "name": "JsAst.JsAst",
    "class_name": "com.google.javascript.jscomp.JsAst",
    "signature": "com.google.javascript.jscomp.JsAst.JsAst(SourceFile)",
    "snippet": "  public JsAst(SourceFile sourceFile) {\n    this.inputId = new InputId(sourceFile.getName());\n    this.sourceFile = sourceFile;\n    this.fileName = sourceFile.getName();\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 0
  },
  {
    "name": "JsAst.getAstRoot",
    "class_name": "com.google.javascript.jscomp.JsAst",
    "signature": "com.google.javascript.jscomp.JsAst.getAstRoot(AbstractCompiler)",
    "snippet": "  @Override\n  public Node getAstRoot(AbstractCompiler compiler) {\n    if (root == null) {\n      parse(compiler);\n      root.setInputId(inputId);\n    }\n    return root;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 0
  },
  {
    "name": "JsAst.getInputId",
    "class_name": "com.google.javascript.jscomp.JsAst",
    "signature": "com.google.javascript.jscomp.JsAst.getInputId()",
    "snippet": "  @Override\n  public InputId getInputId() {\n    return inputId;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 0
  },
  {
    "name": "JsAst.getSourceFile",
    "class_name": "com.google.javascript.jscomp.JsAst",
    "signature": "com.google.javascript.jscomp.JsAst.getSourceFile()",
    "snippet": "  @Override\n  public SourceFile getSourceFile() {\n    return sourceFile;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 0
  },
  {
    "name": "JsAst.parse",
    "class_name": "com.google.javascript.jscomp.JsAst",
    "signature": "com.google.javascript.jscomp.JsAst.parse(AbstractCompiler)",
    "snippet": "  private void parse(AbstractCompiler compiler) {\n    try {\n      logger_.fine(\"Parsing: \" + sourceFile.getName());\n      root = ParserRunner.parse(sourceFile, sourceFile.getCode(),\n          compiler.getParserConfig(),\n          compiler.getDefaultErrorReporter(),\n          logger_);\n    } catch (IOException e) {\n      compiler.report(\n          JSError.make(AbstractCompiler.READ_ERROR, sourceFile.getName()));\n    }\n\n    if (root == null || compiler.hasHaltingErrors()) {\n      // There was a parse error or IOException, so use a dummy block.\n      root = IR.script();\n    } else {\n      compiler.prepareAst(root);\n    }\n\n    // Set the source name so that the compiler passes can track\n    // the source file and module.\n    root.setStaticSourceFile(sourceFile);\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 0
  },
  {
    "name": "LightweightMessageFormatter.LightweightMessageFormatter",
    "class_name": "com.google.javascript.jscomp.LightweightMessageFormatter",
    "signature": "com.google.javascript.jscomp.LightweightMessageFormatter.LightweightMessageFormatter(SourceExcerptProvider)",
    "snippet": "  public LightweightMessageFormatter(SourceExcerptProvider source) {\n    this(source, LINE);\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 0
  },
  {
    "name": "LightweightMessageFormatter.LightweightMessageFormatter",
    "class_name": "com.google.javascript.jscomp.LightweightMessageFormatter",
    "signature": "com.google.javascript.jscomp.LightweightMessageFormatter.LightweightMessageFormatter(SourceExcerptProvider,SourceExcerpt)",
    "snippet": "  public LightweightMessageFormatter(SourceExcerptProvider source,\n      SourceExcerpt excerpt) {\n    super(source);\n    Preconditions.checkNotNull(source);\n    this.excerpt = excerpt;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 0
  },
  {
    "name": "LineNumberCheck.LineNumberCheck",
    "class_name": "com.google.javascript.jscomp.LineNumberCheck",
    "signature": "com.google.javascript.jscomp.LineNumberCheck.LineNumberCheck(AbstractCompiler)",
    "snippet": "  LineNumberCheck(AbstractCompiler compiler) {\n    this.compiler = compiler;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 0
  },
  {
    "name": "LineNumberCheck.process",
    "class_name": "com.google.javascript.jscomp.LineNumberCheck",
    "signature": "com.google.javascript.jscomp.LineNumberCheck.process(Node,Node)",
    "snippet": "  @Override\n  public void process(Node externs, Node root) {\n    requiresLineNumbers = false;\n\n    NodeTraversal.traverse(compiler, root, this);\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 0
  },
  {
    "name": "LineNumberCheck.shouldTraverse",
    "class_name": "com.google.javascript.jscomp.LineNumberCheck",
    "signature": "com.google.javascript.jscomp.LineNumberCheck.shouldTraverse(NodeTraversal,Node,Node)",
    "snippet": "  @Override\n  public boolean shouldTraverse(NodeTraversal t, Node n, Node parent) {\n    // Each JavaScript file is rooted in a script node, so we'll only\n    // have line number information inside the script node.\n    if (n.isScript()) {\n      requiresLineNumbers = true;\n    }\n    return true;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 0
  },
  {
    "name": "LineNumberCheck.visit",
    "class_name": "com.google.javascript.jscomp.LineNumberCheck",
    "signature": "com.google.javascript.jscomp.LineNumberCheck.visit(NodeTraversal,Node,Node)",
    "snippet": "  @Override\n  public void visit(NodeTraversal t, Node n, Node parent) {\n    if (n.isScript()) {\n      requiresLineNumbers = false;\n    } else if (requiresLineNumbers) {\n      if (n.getLineno() == -1) {\n        // The tree version of the node is really the best diagnostic\n        // info we have to offer here.\n        compiler.report(\n            t.makeError(n, MISSING_LINE_INFO,\n                n.toStringTree()));\n      }\n    }\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 0
  },
  {
    "name": "LoggerErrorManager.LoggerErrorManager",
    "class_name": "com.google.javascript.jscomp.LoggerErrorManager",
    "signature": "com.google.javascript.jscomp.LoggerErrorManager.LoggerErrorManager(MessageFormatter,Logger)",
    "snippet": "  public LoggerErrorManager(MessageFormatter formatter, Logger logger) {\n    this.formatter = formatter;\n    this.logger = logger;\n  }",
    "comment": " Creates an instance. ",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 0
  },
  {
    "name": "MakeDeclaredNamesUnique.MakeDeclaredNamesUnique",
    "class_name": "com.google.javascript.jscomp.MakeDeclaredNamesUnique",
    "signature": "com.google.javascript.jscomp.MakeDeclaredNamesUnique.MakeDeclaredNamesUnique()",
    "snippet": "  MakeDeclaredNamesUnique() {\n    this(new ContextualRenamer());\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 0
  },
  {
    "name": "MakeDeclaredNamesUnique.MakeDeclaredNamesUnique",
    "class_name": "com.google.javascript.jscomp.MakeDeclaredNamesUnique",
    "signature": "com.google.javascript.jscomp.MakeDeclaredNamesUnique.MakeDeclaredNamesUnique(Renamer)",
    "snippet": "  MakeDeclaredNamesUnique(Renamer renamer) {\n    this.rootRenamer = renamer;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 0
  },
  {
    "name": "MakeDeclaredNamesUnique.enterScope",
    "class_name": "com.google.javascript.jscomp.MakeDeclaredNamesUnique",
    "signature": "com.google.javascript.jscomp.MakeDeclaredNamesUnique.enterScope(NodeTraversal)",
    "snippet": "  @Override\n  public void enterScope(NodeTraversal t) {\n    Node declarationRoot = t.getScopeRoot();\n    Renamer renamer;\n    if (nameStack.isEmpty()) {\n      // If the contextual renamer is being used the starting context can not\n      // be a function.\n      Preconditions.checkState(\n          !declarationRoot.isFunction() ||\n          !(rootRenamer instanceof ContextualRenamer));\n      Preconditions.checkState(t.inGlobalScope());\n      renamer = rootRenamer;\n    } else {\n      renamer = nameStack.peek().forChildScope();\n    }\n\n    if (!declarationRoot.isFunction()) {\n      // Add the block declarations\n      findDeclaredNames(declarationRoot, null, renamer);\n    }\n    nameStack.push(renamer);\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 0
  },
  {
    "name": "MakeDeclaredNamesUnique.exitScope",
    "class_name": "com.google.javascript.jscomp.MakeDeclaredNamesUnique",
    "signature": "com.google.javascript.jscomp.MakeDeclaredNamesUnique.exitScope(NodeTraversal)",
    "snippet": "  @Override\n  public void exitScope(NodeTraversal t) {\n    if (!t.inGlobalScope()) {\n      nameStack.pop();\n    }\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 0
  },
  {
    "name": "MakeDeclaredNamesUnique.findDeclaredNames",
    "class_name": "com.google.javascript.jscomp.MakeDeclaredNamesUnique",
    "signature": "com.google.javascript.jscomp.MakeDeclaredNamesUnique.findDeclaredNames(Node,Node,Renamer)",
    "snippet": "  private void findDeclaredNames(Node n, Node parent, Renamer renamer) {\n    // Do a shallow traversal, so don't traverse into function declarations,\n    // except for the name of the function itself.\n    if (parent == null\n        || !parent.isFunction()\n        || n == parent.getFirstChild()) {\n      if (NodeUtil.isVarDeclaration(n)) {\n        renamer.addDeclaredName(n.getString());\n      } else if (NodeUtil.isFunctionDeclaration(n)) {\n        Node nameNode = n.getFirstChild();\n        renamer.addDeclaredName(nameNode.getString());\n      }\n\n      for (Node c = n.getFirstChild(); c != null; c = c.getNext()) {\n        findDeclaredNames(c, n, renamer);\n      }\n    }\n  }",
    "comment": " Traverses the current scope and collects declared names.  Does not decent into functions or add CATCH exceptions. ",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 0
  },
  {
    "name": "MakeDeclaredNamesUnique.getReplacementName",
    "class_name": "com.google.javascript.jscomp.MakeDeclaredNamesUnique",
    "signature": "com.google.javascript.jscomp.MakeDeclaredNamesUnique.getReplacementName(String)",
    "snippet": "  private String getReplacementName(String oldName) {\n    for (Renamer names : nameStack) {\n      String newName = names.getReplacementName(oldName);\n      if (newName != null) {\n        return newName;\n      }\n    }\n    return null;\n  }",
    "comment": " Walks the stack of name maps and finds the replacement name for the current scope. ",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 0
  },
  {
    "name": "MakeDeclaredNamesUnique.shouldTraverse",
    "class_name": "com.google.javascript.jscomp.MakeDeclaredNamesUnique",
    "signature": "com.google.javascript.jscomp.MakeDeclaredNamesUnique.shouldTraverse(NodeTraversal,Node,Node)",
    "snippet": "  @Override\n  public boolean shouldTraverse(NodeTraversal t, Node n, Node parent) {\n\n    switch (n.getType()) {\n      case Token.FUNCTION:\n        {\n          // Add recursive function name, if needed.\n          // NOTE: \"enterScope\" is called after we need to pick up this name.\n          Renamer renamer = nameStack.peek().forChildScope();\n\n          // If needed, add the function recursive name.\n          String name = n.getFirstChild().getString();\n          if (name != null && !name.isEmpty() && parent != null\n              && !NodeUtil.isFunctionDeclaration(n)) {\n            renamer.addDeclaredName(name);\n          }\n\n          nameStack.push(renamer);\n        }\n        break;\n\n      case Token.PARAM_LIST: {\n          Renamer renamer = nameStack.peek().forChildScope();\n\n          // Add the function parameters\n          for (Node c = n.getFirstChild(); c != null; c = c.getNext()) {\n            String name = c.getString();\n            renamer.addDeclaredName(name);\n          }\n\n          // Add the function body declarations\n          Node functionBody = n.getNext();\n          findDeclaredNames(functionBody, null, renamer);\n\n          nameStack.push(renamer);\n        }\n        break;\n\n      case Token.CATCH:\n        {\n          Renamer renamer = nameStack.peek().forChildScope();\n\n          String name = n.getFirstChild().getString();\n          renamer.addDeclaredName(name);\n\n          nameStack.push(renamer);\n        }\n        break;\n    }\n\n    return true;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 0
  },
  {
    "name": "MakeDeclaredNamesUnique.visit",
    "class_name": "com.google.javascript.jscomp.MakeDeclaredNamesUnique",
    "signature": "com.google.javascript.jscomp.MakeDeclaredNamesUnique.visit(NodeTraversal,Node,Node)",
    "snippet": "  @Override\n  public void visit(NodeTraversal t, Node n, Node parent) {\n    switch (n.getType()) {\n      case Token.NAME:\n        String newName = getReplacementName(n.getString());\n        if (newName != null) {\n          Renamer renamer = nameStack.peek();\n          if (renamer.stripConstIfReplaced()) {\n            // TODO(johnlenz): Do we need to do anything about the javadoc?\n            n.removeProp(Node.IS_CONSTANT_NAME);\n          }\n          n.setString(newName);\n          t.getCompiler().reportCodeChange();\n        }\n        break;\n\n      case Token.FUNCTION:\n        // Remove the function body scope\n        nameStack.pop();\n        // Remove function recursive name (if any).\n        nameStack.pop();\n        break;\n\n      case Token.PARAM_LIST:\n        // Note: The parameters and function body variables live in the\n        // same scope, we introduce the scope when in the \"shouldTraverse\"\n        // visit of LP, but remove it when when we exit the function above.\n        break;\n\n      case Token.CATCH:\n        // Remove catch except name from the stack of names.\n        nameStack.pop();\n        break;\n    }\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 0
  },
  {
    "name": "ContextualRenamer.addDeclaredName",
    "class_name": "com.google.javascript.jscomp.MakeDeclaredNamesUnique$ContextualRenamer",
    "signature": "com.google.javascript.jscomp.MakeDeclaredNamesUnique$ContextualRenamer.addDeclaredName(String)",
    "snippet": "    @Override\n    public void addDeclaredName(String name) {\n      if (!name.equals(ARGUMENTS)) {\n        if (global) {\n          reserveName(name);\n        } else {\n          // It hasn't been declared locally yet, so increment the count.\n          if (!declarations.containsKey(name)) {\n            int id = incrementNameCount(name);\n            String newName = null;\n            if (id != 0) {\n              newName = getUniqueName(name, id);\n            }\n            declarations.put(name, newName);\n          }\n        }\n      }\n    }",
    "comment": " Adds a name to the map of names declared in this scope. ",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 0
  },
  {
    "name": "ContextualRenamer.forChildScope",
    "class_name": "com.google.javascript.jscomp.MakeDeclaredNamesUnique$ContextualRenamer",
    "signature": "com.google.javascript.jscomp.MakeDeclaredNamesUnique$ContextualRenamer.forChildScope()",
    "snippet": "    @Override\n    public Renamer forChildScope() {\n      return new ContextualRenamer(nameUsage);\n    }",
    "comment": " Create a ContextualRenamer ",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 0
  },
  {
    "name": "ContextualRenamer.getReplacementName",
    "class_name": "com.google.javascript.jscomp.MakeDeclaredNamesUnique$ContextualRenamer",
    "signature": "com.google.javascript.jscomp.MakeDeclaredNamesUnique$ContextualRenamer.getReplacementName(String)",
    "snippet": "    @Override\n    public String getReplacementName(String oldName) {\n      return declarations.get(oldName);\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 0
  },
  {
    "name": "ContextualRenamer.reserveName",
    "class_name": "com.google.javascript.jscomp.MakeDeclaredNamesUnique$ContextualRenamer",
    "signature": "com.google.javascript.jscomp.MakeDeclaredNamesUnique$ContextualRenamer.reserveName(String)",
    "snippet": "    private void reserveName(String name) {\n      nameUsage.setCount(name, 0, 1);\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 0
  },
  {
    "name": "MarkNoSideEffectCalls.MarkNoSideEffectCalls",
    "class_name": "com.google.javascript.jscomp.MarkNoSideEffectCalls",
    "signature": "com.google.javascript.jscomp.MarkNoSideEffectCalls.MarkNoSideEffectCalls(AbstractCompiler)",
    "snippet": "  MarkNoSideEffectCalls(AbstractCompiler compiler) {\n    this.compiler = compiler;\n    this.noSideEffectFunctionNames = Sets.newHashSet();\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 0
  },
  {
    "name": "MarkNoSideEffectCalls.definitionTypeContainsFunctionType",
    "class_name": "com.google.javascript.jscomp.MarkNoSideEffectCalls",
    "signature": "com.google.javascript.jscomp.MarkNoSideEffectCalls.definitionTypeContainsFunctionType(Definition)",
    "snippet": "  private static boolean definitionTypeContainsFunctionType(Definition def) {\n    Node rhs = def.getRValue();\n    if (rhs == null) {\n      return true;\n    }\n\n    switch (rhs.getType()) {\n      case Token.ASSIGN:\n      case Token.AND:\n      case Token.CALL:\n      case Token.GETPROP:\n      case Token.GETELEM:\n      case Token.FUNCTION:\n      case Token.HOOK:\n      case Token.NAME:\n      case Token.NEW:\n      case Token.OR:\n        return true;\n      default:\n        return false;\n    }\n  }",
    "comment": " Determines if the type of the value of the rhs expression can be a function node. ",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 0
  },
  {
    "name": "MarkNoSideEffectCalls.hasNoSideEffectsAnnotation",
    "class_name": "com.google.javascript.jscomp.MarkNoSideEffectCalls",
    "signature": "com.google.javascript.jscomp.MarkNoSideEffectCalls.hasNoSideEffectsAnnotation(Node)",
    "snippet": "  private static boolean hasNoSideEffectsAnnotation(Node node) {\n    JSDocInfo docInfo = node.getJSDocInfo();\n    return docInfo != null && docInfo.isNoSideEffects();\n  }",
    "comment": " Get the value of the @nosideeffects annotation stored in the doc info. ",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 0
  },
  {
    "name": "MarkNoSideEffectCalls.process",
    "class_name": "com.google.javascript.jscomp.MarkNoSideEffectCalls",
    "signature": "com.google.javascript.jscomp.MarkNoSideEffectCalls.process(Node,Node)",
    "snippet": "  @Override\n  public void process(Node externs, Node root) {\n    SimpleDefinitionFinder defFinder = new SimpleDefinitionFinder(compiler);\n    defFinder.process(externs, root);\n\n    // Gather the list of function nodes that have @nosideeffect annotations.\n    // For use by SetNoSideEffectCallProperty.\n    NodeTraversal.traverse(\n        compiler, externs, new GatherNoSideEffectFunctions(true));\n    NodeTraversal.traverse(\n        compiler, root, new GatherNoSideEffectFunctions(false));\n\n    NodeTraversal.traverse(compiler, root,\n                           new SetNoSideEffectCallProperty(defFinder));\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 0
  },
  {
    "name": "GatherNoSideEffectFunctions.visit",
    "class_name": "com.google.javascript.jscomp.MarkNoSideEffectCalls$GatherNoSideEffectFunctions",
    "signature": "com.google.javascript.jscomp.MarkNoSideEffectCalls$GatherNoSideEffectFunctions.visit(NodeTraversal,Node,Node)",
    "snippet": "    @Override\n    public void visit(NodeTraversal traversal, Node node, Node parent) {\n      if (!inExterns && hasNoSideEffectsAnnotation(node)) {\n        traversal.report(node, INVALID_NO_SIDE_EFFECT_ANNOTATION);\n      }\n\n      if (node.isGetProp()) {\n        if (parent.isExprResult() &&\n            hasNoSideEffectsAnnotation(node)) {\n          noSideEffectFunctionNames.add(node);\n        }\n      } else if (node.isFunction()) {\n\n        // The annotation may attached to the function node, the\n        // variable declaration or assignment expression.\n        boolean hasAnnotation = hasNoSideEffectsAnnotation(node);\n        List<Node> nameNodes = Lists.newArrayList();\n        nameNodes.add(node.getFirstChild());\n\n        Node nameNode = null;\n\n        if (parent.isName()) {\n          Node gramp = parent.getParent();\n          if (gramp.isVar() &&\n              gramp.hasOneChild() &&\n              hasNoSideEffectsAnnotation(gramp)) {\n            hasAnnotation = true;\n          }\n\n          nameNodes.add(parent);\n        } else if (parent.isAssign()) {\n          if (hasNoSideEffectsAnnotation(parent)) {\n            hasAnnotation = true;\n          }\n\n          nameNodes.add(parent.getFirstChild());\n        }\n\n        if (hasAnnotation) {\n          noSideEffectFunctionNames.addAll(nameNodes);\n        }\n      }\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 0
  },
  {
    "name": "SetNoSideEffectCallProperty.visit",
    "class_name": "com.google.javascript.jscomp.MarkNoSideEffectCalls$SetNoSideEffectCallProperty",
    "signature": "com.google.javascript.jscomp.MarkNoSideEffectCalls$SetNoSideEffectCallProperty.visit(NodeTraversal,Node,Node)",
    "snippet": "    @Override\n    public void visit(NodeTraversal traversal, Node node, Node parent) {\n      if (!node.isCall() && !node.isNew()) {\n        return;\n      }\n\n      Collection<Definition> definitions =\n          defFinder.getDefinitionsReferencedAt(node.getFirstChild());\n      if (definitions == null) {\n        return;\n      }\n\n      for (Definition def : definitions) {\n        Node lValue = def.getLValue();\n        Preconditions.checkNotNull(lValue);\n        if (!noSideEffectFunctionNames.contains(lValue) &&\n            definitionTypeContainsFunctionType(def)) {\n          return;\n        }\n      }\n\n      node.setSideEffectFlags(Node.NO_SIDE_EFFECTS);\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 0
  },
  {
    "name": "NodeTraversal.NodeTraversal",
    "class_name": "com.google.javascript.jscomp.NodeTraversal",
    "signature": "com.google.javascript.jscomp.NodeTraversal.NodeTraversal(AbstractCompiler,Callback)",
    "snippet": "  public NodeTraversal(AbstractCompiler compiler, Callback cb) {\n    this(compiler, cb, new SyntacticScopeCreator(compiler));\n  }",
    "comment": " Creates a node traversal using the specified callback interface. ",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 0
  },
  {
    "name": "NodeTraversal.NodeTraversal",
    "class_name": "com.google.javascript.jscomp.NodeTraversal",
    "signature": "com.google.javascript.jscomp.NodeTraversal.NodeTraversal(AbstractCompiler,Callback,ScopeCreator)",
    "snippet": "  public NodeTraversal(AbstractCompiler compiler, Callback cb,\n      ScopeCreator scopeCreator) {\n    this.callback = cb;\n    if (cb instanceof ScopedCallback) {\n      this.scopeCallback = (ScopedCallback) cb;\n    }\n    this.compiler = compiler;\n    this.inputId = null;\n    this.sourceName = \"\";\n    this.scopeCreator = scopeCreator;\n  }",
    "comment": " Creates a node traversal using the specified callback interface and the scope creator. ",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 0
  },
  {
    "name": "NodeTraversal.getSourceName",
    "class_name": "com.google.javascript.jscomp.NodeTraversal",
    "signature": "com.google.javascript.jscomp.NodeTraversal.getSourceName(Node)",
    "snippet": "  private static String getSourceName(Node n) {\n    String name = n.getSourceFileName();\n    return name == null ? \"\" : name;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 0
  },
  {
    "name": "NodeTraversal.popScope",
    "class_name": "com.google.javascript.jscomp.NodeTraversal",
    "signature": "com.google.javascript.jscomp.NodeTraversal.popScope()",
    "snippet": "  private void popScope() {\n    if (scopeCallback != null) {\n      scopeCallback.exitScope(this);\n    }\n    if (scopeRoots.isEmpty()) {\n      scopes.pop();\n    } else {\n      scopeRoots.pop();\n    }\n    cfgs.pop();\n  }",
    "comment": "Pops back to the previous scope (e.g. when leaving a function). */",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 0
  },
  {
    "name": "NodeTraversal.pushScope",
    "class_name": "com.google.javascript.jscomp.NodeTraversal",
    "signature": "com.google.javascript.jscomp.NodeTraversal.pushScope(Node)",
    "snippet": "  private void pushScope(Node node) {\n    Preconditions.checkState(curNode != null);\n    scopeRoots.push(node);\n    cfgs.push(null);\n    if (scopeCallback != null) {\n      scopeCallback.enterScope(this);\n    }\n  }",
    "comment": "Creates a new scope (e.g. when entering a function). */",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 0
  },
  {
    "name": "NodeTraversal.traverse",
    "class_name": "com.google.javascript.jscomp.NodeTraversal",
    "signature": "com.google.javascript.jscomp.NodeTraversal.traverse(AbstractCompiler,Node,Callback)",
    "snippet": "  public static void traverse(\n      AbstractCompiler compiler, Node root, Callback cb) {\n    NodeTraversal t = new NodeTraversal(compiler, cb);\n    t.traverse(root);\n  }",
    "comment": " Traverses a node recursively. ",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 0
  },
  {
    "name": "NodeTraversal.traverse",
    "class_name": "com.google.javascript.jscomp.NodeTraversal",
    "signature": "com.google.javascript.jscomp.NodeTraversal.traverse(Node)",
    "snippet": "  public void traverse(Node root) {\n    try {\n      inputId = NodeUtil.getInputId(root);\n      sourceName = \"\";\n      curNode = root;\n      pushScope(root);\n      traverseBranch(root, null);\n      popScope();\n    } catch (Exception unexpectedException) {\n      throwUnexpectedException(unexpectedException);\n    }\n  }",
    "comment": " Traverses a parse tree recursively. ",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 0
  },
  {
    "name": "NodeTraversal.traverseBranch",
    "class_name": "com.google.javascript.jscomp.NodeTraversal",
    "signature": "com.google.javascript.jscomp.NodeTraversal.traverseBranch(Node,Node)",
    "snippet": "  @SuppressWarnings(\"fallthrough\")\n  private void traverseBranch(Node n, Node parent) {\n    int type = n.getType();\n    if (type == Token.SCRIPT) {\n      inputId = n.getInputId();\n      sourceName = getSourceName(n);\n    }\n\n    curNode = n;\n    if (!callback.shouldTraverse(this, n, parent)) return;\n\n    switch (type) {\n      case Token.FUNCTION:\n        traverseFunction(n, parent);\n        break;\n\n      default:\n        for (Node child = n.getFirstChild(); child != null; ) {\n          // child could be replaced, in which case our child node\n          // would no longer point to the true next\n          Node next = child.getNext();\n          traverseBranch(child, n);\n          child = next;\n        }\n        break;\n    }\n\n    curNode = n;\n    callback.visit(this, n, parent);\n  }",
    "comment": " Traverses a branch. ",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 0
  },
  {
    "name": "NodeUtil.getInputId",
    "class_name": "com.google.javascript.jscomp.NodeUtil",
    "signature": "com.google.javascript.jscomp.NodeUtil.getInputId(Node)",
    "snippet": "  public static InputId getInputId(Node n) {\n    while (n != null && !n.isScript()) {\n      n = n.getParent();\n    }\n\n    return (n != null && n.isScript()) ? n.getInputId() : null;\n  }",
    "comment": " @param n The node. @return The InputId property on the node or its ancestors. ",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 0
  },
  {
    "name": "NodeUtil.opToStr",
    "class_name": "com.google.javascript.jscomp.NodeUtil",
    "signature": "com.google.javascript.jscomp.NodeUtil.opToStr(int)",
    "snippet": "  static String opToStr(int operator) {\n    switch (operator) {\n      case Token.BITOR: return \"|\";\n      case Token.OR: return \"||\";\n      case Token.BITXOR: return \"^\";\n      case Token.AND: return \"&&\";\n      case Token.BITAND: return \"&\";\n      case Token.SHEQ: return \"===\";\n      case Token.EQ: return \"==\";\n      case Token.NOT: return \"!\";\n      case Token.NE: return \"!=\";\n      case Token.SHNE: return \"!==\";\n      case Token.LSH: return \"<<\";\n      case Token.IN: return \"in\";\n      case Token.LE: return \"<=\";\n      case Token.LT: return \"<\";\n      case Token.URSH: return \">>>\";\n      case Token.RSH: return \">>\";\n      case Token.GE: return \">=\";\n      case Token.GT: return \">\";\n      case Token.MUL: return \"*\";\n      case Token.DIV: return \"/\";\n      case Token.MOD: return \"%\";\n      case Token.BITNOT: return \"~\";\n      case Token.ADD: return \"+\";\n      case Token.SUB: return \"-\";\n      case Token.POS: return \"+\";\n      case Token.NEG: return \"-\";\n      case Token.ASSIGN: return \"=\";\n      case Token.ASSIGN_BITOR: return \"|=\";\n      case Token.ASSIGN_BITXOR: return \"^=\";\n      case Token.ASSIGN_BITAND: return \"&=\";\n      case Token.ASSIGN_LSH: return \"<<=\";\n      case Token.ASSIGN_RSH: return \">>=\";\n      case Token.ASSIGN_URSH: return \">>>=\";\n      case Token.ASSIGN_ADD: return \"+=\";\n      case Token.ASSIGN_SUB: return \"-=\";\n      case Token.ASSIGN_MUL: return \"*=\";\n      case Token.ASSIGN_DIV: return \"/=\";\n      case Token.ASSIGN_MOD: return \"%=\";\n      case Token.VOID: return \"void\";\n      case Token.TYPEOF: return \"typeof\";\n      case Token.INSTANCEOF: return \"instanceof\";\n      default: return null;\n    }\n  }",
    "comment": " Converts an operator's token value (see {@link Token}) to a string representation.  @param operator the operator's token value to convert @return the string representation or {@code null} if the token value is not an operator ",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 0
  },
  {
    "name": "Normalize.Normalize",
    "class_name": "com.google.javascript.jscomp.Normalize",
    "signature": "com.google.javascript.jscomp.Normalize.Normalize(AbstractCompiler,boolean)",
    "snippet": "  Normalize(AbstractCompiler compiler, boolean assertOnChange) {\n    this.compiler = compiler;\n    this.assertOnChange = assertOnChange;\n\n    // TODO(nicksantos): assertOnChange should only be true if the tree\n    // is normalized.\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 0
  },
  {
    "name": "Normalize.process",
    "class_name": "com.google.javascript.jscomp.Normalize",
    "signature": "com.google.javascript.jscomp.Normalize.process(Node,Node)",
    "snippet": "  @Override\n  public void process(Node externs, Node root) {\n    new NodeTraversal(\n        compiler, new NormalizeStatements(compiler, assertOnChange))\n        .traverseRoots(externs, root);\n    if (MAKE_LOCAL_NAMES_UNIQUE) {\n      MakeDeclaredNamesUnique renamer = new MakeDeclaredNamesUnique();\n      NodeTraversal t = new NodeTraversal(compiler, renamer);\n      t.traverseRoots(externs, root);\n    }\n    // It is important that removeDuplicateDeclarations runs after\n    // MakeDeclaredNamesUnique in order for catch block exception names to be\n    // handled properly. Specifically, catch block exception names are\n    // only valid within the catch block, but our currect Scope logic\n    // has no concept of this and includes it in the containing function\n    // (or global scope). MakeDeclaredNamesUnique makes the catch exception\n    // names unique so that removeDuplicateDeclarations() will properly handle\n    // cases where a function scope variable conflict with a exception name:\n    //   function f() {\n    //      try {throw 0;} catch(e) {e; /* catch scope 'e'*/}\n    //      var e = 1; // f scope 'e'\n    //   }\n    // otherwise 'var e = 1' would be rewritten as 'e = 1'.\n    // TODO(johnlenz): Introduce a seperate scope for catch nodes.\n    removeDuplicateDeclarations(externs, root);\n    new PropagateConstantAnnotationsOverVars(compiler, assertOnChange)\n        .process(externs, root);\n\n    FindExposeAnnotations findExposeAnnotations = new FindExposeAnnotations();\n    NodeTraversal.traverse(compiler, root, findExposeAnnotations);\n    if (!findExposeAnnotations.exposedProperties.isEmpty()) {\n      NodeTraversal.traverse(compiler, root,\n          new RewriteExposedProperties(\n              findExposeAnnotations.exposedProperties));\n    }\n\n    if (!compiler.getLifeCycleStage().isNormalized()) {\n      compiler.setLifeCycleStage(LifeCycleStage.NORMALIZED);\n    }\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 0
  },
  {
    "name": "Normalize.removeDuplicateDeclarations",
    "class_name": "com.google.javascript.jscomp.Normalize",
    "signature": "com.google.javascript.jscomp.Normalize.removeDuplicateDeclarations(Node,Node)",
    "snippet": "  private void removeDuplicateDeclarations(Node externs, Node root) {\n    Callback tickler = new ScopeTicklingCallback();\n    ScopeCreator scopeCreator =  new SyntacticScopeCreator(\n        compiler, new DuplicateDeclarationHandler());\n    NodeTraversal t = new NodeTraversal(compiler, tickler, scopeCreator);\n    t.traverseRoots(externs, root);\n  }",
    "comment": " Remove duplicate VAR declarations. ",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 0
  },
  {
    "name": "FindExposeAnnotations.visit",
    "class_name": "com.google.javascript.jscomp.Normalize$FindExposeAnnotations",
    "signature": "com.google.javascript.jscomp.Normalize$FindExposeAnnotations.visit(NodeTraversal,Node,Node)",
    "snippet": "    @Override public void visit(NodeTraversal t, Node n, Node parent) {\n      if (NodeUtil.isExprAssign(n)) {\n        Node assign = n.getFirstChild();\n        Node lhs = assign.getFirstChild();\n        if (lhs.isGetProp() && isMarkedExpose(assign)) {\n          exposedProperties.add(lhs.getLastChild().getString());\n        }\n      } else if (n.isStringKey() && isMarkedExpose(n)) {\n        exposedProperties.add(n.getString());\n      }\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 0
  },
  {
    "name": "NormalizeStatements.annotateConstantsByConvention",
    "class_name": "com.google.javascript.jscomp.Normalize$NormalizeStatements",
    "signature": "com.google.javascript.jscomp.Normalize$NormalizeStatements.annotateConstantsByConvention(Node,Node)",
    "snippet": "    private void annotateConstantsByConvention(Node n, Node parent) {\n      Preconditions.checkState(\n          n.isName()\n          || n.isString()\n          || n.isStringKey()\n          || n.isGetterDef()\n          || n.isSetterDef());\n\n      // There are only two cases where a string token\n      // may be a variable reference: The right side of a GETPROP\n      // or an OBJECTLIT key.\n      boolean isObjLitKey = NodeUtil.isObjectLitKey(n, parent);\n      boolean isProperty = isObjLitKey ||\n          (parent.isGetProp() &&\n           parent.getLastChild() == n);\n      if (n.isName() || isProperty) {\n        boolean isMarkedConstant = n.getBooleanProp(Node.IS_CONSTANT_NAME);\n        if (!isMarkedConstant &&\n            NodeUtil.isConstantByConvention(\n                compiler.getCodingConvention(), n, parent)) {\n          if (assertOnChange) {\n            String name = n.getString();\n            throw new IllegalStateException(\n                \"Unexpected const change.\\n\" +\n                \"  name: \"+ name + \"\\n\" +\n                \"  parent:\" + n.getParent().toStringTree());\n          }\n          n.putBooleanProp(Node.IS_CONSTANT_NAME, true);\n        }\n      }\n    }",
    "comment": " Mark names and properties that are constants by convention. ",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 0
  },
  {
    "name": "NormalizeStatements.doStatementNormalizations",
    "class_name": "com.google.javascript.jscomp.Normalize$NormalizeStatements",
    "signature": "com.google.javascript.jscomp.Normalize$NormalizeStatements.doStatementNormalizations(NodeTraversal,Node,Node)",
    "snippet": "    private void doStatementNormalizations(\n        NodeTraversal t, Node n, Node parent) {\n      if (n.isLabel()) {\n        normalizeLabels(n);\n      }\n\n      // Only inspect the children of SCRIPTs, BLOCKs and LABELs, as all these\n      // are the only legal place for VARs and FOR statements.\n      if (NodeUtil.isStatementBlock(n) || n.isLabel()) {\n        extractForInitializer(n, null, null);\n      }\n\n      // Only inspect the children of SCRIPTs, BLOCKs, as all these\n      // are the only legal place for VARs.\n      if (NodeUtil.isStatementBlock(n)) {\n        splitVarDeclarations(n);\n      }\n\n      if (n.isFunction()) {\n        moveNamedFunctions(n.getLastChild());\n      }\n    }",
    "comment": " Do normalizations that introduce new siblings or parents. ",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 0
  },
  {
    "name": "NormalizeStatements.extractForInitializer",
    "class_name": "com.google.javascript.jscomp.Normalize$NormalizeStatements",
    "signature": "com.google.javascript.jscomp.Normalize$NormalizeStatements.extractForInitializer(Node,Node,Node)",
    "snippet": "    private void extractForInitializer(\n        Node n, Node before, Node beforeParent) {\n\n      for (Node next, c = n.getFirstChild(); c != null; c = next) {\n        next = c.getNext();\n        Node insertBefore = (before == null) ? c : before;\n        Node insertBeforeParent = (before == null) ? n : beforeParent;\n        switch (c.getType()) {\n          case Token.LABEL:\n            extractForInitializer(c, insertBefore, insertBeforeParent);\n            break;\n          case Token.FOR:\n            if (NodeUtil.isForIn(c)) {\n              Node first = c.getFirstChild();\n              if (first.isVar()) {\n                // Transform:\n                //    for (var a = 1 in b) {}\n                // to:\n                //    var a = 1; for (a in b) {};\n                Node newStatement = first;\n                // Clone just the node, to remove any initialization.\n                Node name = newStatement.getFirstChild().cloneNode();\n                first.getParent().replaceChild(first, name);\n                insertBeforeParent.addChildBefore(newStatement, insertBefore);\n                reportCodeChange(\"FOR-IN var declaration\");\n              }\n            } else if (!c.getFirstChild().isEmpty()) {\n              Node init = c.getFirstChild();\n              Node empty = IR.empty();\n              empty.copyInformationFrom(c);\n              c.replaceChild(init, empty);\n\n              Node newStatement;\n              // Only VAR statements, and expressions are allowed,\n              // but are handled differently.\n              if (init.isVar()) {\n                newStatement = init;\n              } else {\n                newStatement = NodeUtil.newExpr(init);\n              }\n\n              insertBeforeParent.addChildBefore(newStatement, insertBefore);\n              reportCodeChange(\"FOR initializer\");\n            }\n            break;\n        }\n      }\n    }",
    "comment": " Bring the initializers out of FOR loops.  These need to be placed before any associated LABEL nodes. This needs to be done from the top level label first so this is called as a pre-order callback (from shouldTraverse).  @param n The node to inspect. @param before The node to insert the initializer before. @param beforeParent The parent of the node before which the initializer will be inserted. ",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 0
  },
  {
    "name": "NormalizeStatements.moveNamedFunctions",
    "class_name": "com.google.javascript.jscomp.Normalize$NormalizeStatements",
    "signature": "com.google.javascript.jscomp.Normalize$NormalizeStatements.moveNamedFunctions(Node)",
    "snippet": "    private void moveNamedFunctions(Node functionBody) {\n      Preconditions.checkState(\n          functionBody.getParent().isFunction());\n      Node previous = null;\n      Node current = functionBody.getFirstChild();\n      // Skip any declarations at the beginning of the function body, they\n      // are already in the right place.\n      while (current != null && NodeUtil.isFunctionDeclaration(current)) {\n        previous = current;\n        current = current.getNext();\n      }\n\n      // Find any remaining declarations and move them.\n      Node insertAfter = previous;\n      while (current != null) {\n        // Save off the next node as the current node maybe removed.\n        Node next = current.getNext();\n        if (NodeUtil.isFunctionDeclaration(current)) {\n          // Remove the declaration from the body.\n          Preconditions.checkNotNull(previous);\n          functionBody.removeChildAfter(previous);\n\n          // Readd the function at the top of the function body (after any\n          // previous declarations).\n          insertAfter = addToFront(functionBody, current, insertAfter);\n          reportCodeChange(\"Move function declaration not at top of function\");\n        } else {\n          // Update the previous only if the current node hasn't been moved.\n          previous = current;\n        }\n        current = next;\n      }\n    }",
    "comment": " Move all the functions that are valid at the execution of the first statement of the function to the beginning of the function definition. ",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 0
  },
  {
    "name": "NormalizeStatements.normalizeFunctionDeclaration",
    "class_name": "com.google.javascript.jscomp.Normalize$NormalizeStatements",
    "signature": "com.google.javascript.jscomp.Normalize$NormalizeStatements.normalizeFunctionDeclaration(Node)",
    "snippet": "    private void normalizeFunctionDeclaration(Node n) {\n      Preconditions.checkState(n.isFunction());\n      if (!NodeUtil.isFunctionExpression(n)\n          && !NodeUtil.isHoistedFunctionDeclaration(n)) {\n        rewriteFunctionDeclaration(n);\n      }\n    }",
    "comment": " Rewrite named unhoisted functions declarations to a known consistent behavior so we don't to different logic paths for the same code. From: function f() {} to: var f = function () {}; ",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 0
  },
  {
    "name": "NormalizeStatements.shouldTraverse",
    "class_name": "com.google.javascript.jscomp.Normalize$NormalizeStatements",
    "signature": "com.google.javascript.jscomp.Normalize$NormalizeStatements.shouldTraverse(NodeTraversal,Node,Node)",
    "snippet": "    @Override\n    public boolean shouldTraverse(NodeTraversal t, Node n, Node parent) {\n      doStatementNormalizations(t, n, parent);\n\n      return true;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 0
  },
  {
    "name": "NormalizeStatements.splitVarDeclarations",
    "class_name": "com.google.javascript.jscomp.Normalize$NormalizeStatements",
    "signature": "com.google.javascript.jscomp.Normalize$NormalizeStatements.splitVarDeclarations(Node)",
    "snippet": "    private void splitVarDeclarations(Node n) {\n      for (Node next, c = n.getFirstChild(); c != null; c = next) {\n        next = c.getNext();\n        if (c.isVar()) {\n          if (assertOnChange && !c.hasChildren()) {\n            throw new IllegalStateException(\"Empty VAR node.\");\n          }\n\n          while (c.getFirstChild() != c.getLastChild()) {\n            Node name = c.getFirstChild();\n            c.removeChild(name);\n            Node newVar = IR.var(name).srcref(n);\n            n.addChildBefore(newVar, c);\n            reportCodeChange(\"VAR with multiple children\");\n          }\n        }\n      }\n    }",
    "comment": " Split a var node such as: var a, b; into individual statements: var a; var b; @param n The whose children we should inspect. ",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 0
  },
  {
    "name": "NormalizeStatements.visit",
    "class_name": "com.google.javascript.jscomp.Normalize$NormalizeStatements",
    "signature": "com.google.javascript.jscomp.Normalize$NormalizeStatements.visit(NodeTraversal,Node,Node)",
    "snippet": "    @Override\n    public void visit(NodeTraversal t, Node n, Node parent) {\n      switch (n.getType()) {\n        case Token.WHILE:\n          if (CONVERT_WHILE_TO_FOR) {\n            Node expr = n.getFirstChild();\n            n.setType(Token.FOR);\n            Node empty = IR.empty();\n            empty.copyInformationFrom(n);\n            n.addChildBefore(empty, expr);\n            n.addChildAfter(empty.cloneNode(), expr);\n            reportCodeChange(\"WHILE node\");\n          }\n          break;\n\n        case Token.FUNCTION:\n          normalizeFunctionDeclaration(n);\n          break;\n\n        case Token.NAME:\n        case Token.STRING:\n        case Token.STRING_KEY:\n        case Token.GETTER_DEF:\n        case Token.SETTER_DEF:\n          if (!compiler.getLifeCycleStage().isNormalizedObfuscated()) {\n            annotateConstantsByConvention(n, parent);\n          }\n          break;\n      }\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 0
  },
  {
    "name": "PropagateConstantAnnotationsOverVars.process",
    "class_name": "com.google.javascript.jscomp.Normalize$PropagateConstantAnnotationsOverVars",
    "signature": "com.google.javascript.jscomp.Normalize$PropagateConstantAnnotationsOverVars.process(Node,Node)",
    "snippet": "    @Override\n    public void process(Node externs, Node root) {\n      new NodeTraversal(compiler, this).traverseRoots(externs, root);\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 0
  },
  {
    "name": "PropagateConstantAnnotationsOverVars.visit",
    "class_name": "com.google.javascript.jscomp.Normalize$PropagateConstantAnnotationsOverVars",
    "signature": "com.google.javascript.jscomp.Normalize$PropagateConstantAnnotationsOverVars.visit(NodeTraversal,Node,Node)",
    "snippet": "    @Override\n    public void visit(NodeTraversal t, Node n, Node parent) {\n      // Note: Constant properties annotations are not propagated.\n      if (n.isName()) {\n        if (n.getString().isEmpty()) {\n          return;\n        }\n\n        JSDocInfo info = null;\n        // Find the JSDocInfo for a top level variable.\n        Var var = t.getScope().getVar(n.getString());\n        if (var != null) {\n          info = var.getJSDocInfo();\n        }\n\n        boolean shouldBeConstant =\n            (info != null && info.isConstant()) ||\n            NodeUtil.isConstantByConvention(\n                compiler.getCodingConvention(), n, parent);\n        boolean isMarkedConstant = n.getBooleanProp(Node.IS_CONSTANT_NAME);\n        if (shouldBeConstant && !isMarkedConstant) {\n          if (assertOnChange) {\n            String name = n.getString();\n            throw new IllegalStateException(\n                \"Unexpected const change.\\n\" +\n                \"  name: \"+ name + \"\\n\" +\n                \"  parent:\" + n.getParent().toStringTree());\n          }\n          n.putBooleanProp(Node.IS_CONSTANT_NAME, true);\n        }\n      }\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 0
  },
  {
    "name": "ScopeTicklingCallback.enterScope",
    "class_name": "com.google.javascript.jscomp.Normalize$ScopeTicklingCallback",
    "signature": "com.google.javascript.jscomp.Normalize$ScopeTicklingCallback.enterScope(NodeTraversal)",
    "snippet": "    @Override\n    public void enterScope(NodeTraversal t) {\n      // Cause the scope to be created, which will cause duplicate\n      // to be found.\n      t.getScope();\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 0
  },
  {
    "name": "ScopeTicklingCallback.exitScope",
    "class_name": "com.google.javascript.jscomp.Normalize$ScopeTicklingCallback",
    "signature": "com.google.javascript.jscomp.Normalize$ScopeTicklingCallback.exitScope(NodeTraversal)",
    "snippet": "    @Override\n    public void exitScope(NodeTraversal t) {\n      // Nothing to do.\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 0
  },
  {
    "name": "ScopeTicklingCallback.shouldTraverse",
    "class_name": "com.google.javascript.jscomp.Normalize$ScopeTicklingCallback",
    "signature": "com.google.javascript.jscomp.Normalize$ScopeTicklingCallback.shouldTraverse(NodeTraversal,Node,Node)",
    "snippet": "    @Override\n    public boolean shouldTraverse(\n        NodeTraversal nodeTraversal, Node n, Node parent) {\n      return true;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 0
  },
  {
    "name": "ScopeTicklingCallback.visit",
    "class_name": "com.google.javascript.jscomp.Normalize$ScopeTicklingCallback",
    "signature": "com.google.javascript.jscomp.Normalize$ScopeTicklingCallback.visit(NodeTraversal,Node,Node)",
    "snippet": "    @Override\n    public void visit(NodeTraversal t, Node n, Node parent) {\n      // Nothing to do.\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 0
  },
  {
    "name": "VerifyConstants.process",
    "class_name": "com.google.javascript.jscomp.Normalize$VerifyConstants",
    "signature": "com.google.javascript.jscomp.Normalize$VerifyConstants.process(Node,Node)",
    "snippet": "    @Override\n    public void process(Node externs, Node root) {\n      Node externsAndJs = root.getParent();\n      Preconditions.checkState(externsAndJs != null);\n      Preconditions.checkState(externsAndJs.hasChild(externs));\n\n      NodeTraversal.traverseRoots(\n          compiler, Lists.newArrayList(externs, root), this);\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 0
  },
  {
    "name": "VerifyConstants.visit",
    "class_name": "com.google.javascript.jscomp.Normalize$VerifyConstants",
    "signature": "com.google.javascript.jscomp.Normalize$VerifyConstants.visit(NodeTraversal,Node,Node)",
    "snippet": "    @Override\n    public void visit(NodeTraversal t, Node n, Node parent) {\n      if (n.isName()) {\n        String name = n.getString();\n        if (n.getString().isEmpty()) {\n          return;\n        }\n\n        boolean isConst = n.getBooleanProp(Node.IS_CONSTANT_NAME);\n        if (checkUserDeclarations) {\n          boolean expectedConst = false;\n          CodingConvention convention = compiler.getCodingConvention();\n          if (NodeUtil.isConstantName(n)\n              || NodeUtil.isConstantByConvention(convention, n, parent)) {\n            expectedConst = true;\n          } else {\n            expectedConst = false;\n\n            JSDocInfo info = null;\n            Var var = t.getScope().getVar(n.getString());\n            if (var != null) {\n              info = var.getJSDocInfo();\n            }\n\n            if (info != null && info.isConstant()) {\n              expectedConst = true;\n            } else {\n              expectedConst = false;\n            }\n          }\n\n          if (expectedConst) {\n            Preconditions.checkState(expectedConst == isConst,\n                \"The name %s is not annotated as constant.\", name);\n          } else {\n            Preconditions.checkState(expectedConst == isConst,\n                \"The name %s should not be annotated as constant.\", name);\n          }\n        }\n\n        Boolean value = constantMap.get(name);\n        if (value == null) {\n          constantMap.put(name, isConst);\n        } else {\n          Preconditions.checkState(value.booleanValue() == isConst,\n              \"The name %s is not consistently annotated as constant.\", name);\n        }\n      }\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 0
  },
  {
    "name": "PassFactory.PassFactory",
    "class_name": "com.google.javascript.jscomp.PassFactory",
    "signature": "com.google.javascript.jscomp.PassFactory.PassFactory(String,boolean)",
    "snippet": "  protected PassFactory(String name, boolean isOneTimePass) {\n    this.name = name;\n    this.isOneTimePass = isOneTimePass;\n  }",
    "comment": " @param name The name of the pass that this factory creates. @param isOneTimePass If true, the pass produced by this factory can only be run once. ",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 0
  },
  {
    "name": "PrepareAst.PrepareAst",
    "class_name": "com.google.javascript.jscomp.PrepareAst",
    "signature": "com.google.javascript.jscomp.PrepareAst.PrepareAst(AbstractCompiler)",
    "snippet": "  PrepareAst(AbstractCompiler compiler) {\n    this(compiler, false);\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 0
  },
  {
    "name": "PrepareAst.PrepareAst",
    "class_name": "com.google.javascript.jscomp.PrepareAst",
    "signature": "com.google.javascript.jscomp.PrepareAst.PrepareAst(AbstractCompiler,boolean)",
    "snippet": "  PrepareAst(AbstractCompiler compiler, boolean checkOnly) {\n    this.compiler = compiler;\n    this.checkOnly = checkOnly;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 0
  },
  {
    "name": "PrepareAst.process",
    "class_name": "com.google.javascript.jscomp.PrepareAst",
    "signature": "com.google.javascript.jscomp.PrepareAst.process(Node,Node)",
    "snippet": "  @Override\n  public void process(Node externs, Node root) {\n    if (checkOnly) {\n      normalizeNodeTypes(root);\n    } else {\n      // Don't perform \"PrepareAnnotations\" when doing checks as\n      // they currently aren't valid during sanity checks.  In particular,\n      // they DIRECT_EVAL shouldn't be applied after inlining has been\n      // performed.\n      if (externs != null) {\n        NodeTraversal.traverse(\n            compiler, externs, new PrepareAnnotations(compiler));\n      }\n      if (root != null) {\n        NodeTraversal.traverse(\n            compiler, root, new PrepareAnnotations(compiler));\n      }\n    }\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 0
  },
  {
    "name": "PrepareAnnotations.shouldTraverse",
    "class_name": "com.google.javascript.jscomp.PrepareAst$PrepareAnnotations",
    "signature": "com.google.javascript.jscomp.PrepareAst$PrepareAnnotations.shouldTraverse(NodeTraversal,Node,Node)",
    "snippet": "    @Override\n    public boolean shouldTraverse(NodeTraversal t, Node n, Node parent) {\n      if (n.isObjectLit()) {\n        normalizeObjectLiteralAnnotations(n);\n      }\n      return true;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 0
  },
  {
    "name": "PrepareAnnotations.visit",
    "class_name": "com.google.javascript.jscomp.PrepareAst$PrepareAnnotations",
    "signature": "com.google.javascript.jscomp.PrepareAst$PrepareAnnotations.visit(NodeTraversal,Node,Node)",
    "snippet": "    @Override\n    public void visit(NodeTraversal t, Node n, Node parent) {\n      switch (n.getType()) {\n        case Token.CALL:\n          annotateCalls(n);\n          break;\n\n        case Token.FUNCTION:\n          annotateFunctions(n, parent);\n          annotateDispatchers(n, parent);\n          break;\n      }\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 0
  },
  {
    "name": "TweakFunction.getName",
    "class_name": "com.google.javascript.jscomp.ProcessTweaks$TweakFunction",
    "signature": "com.google.javascript.jscomp.ProcessTweaks$TweakFunction.getName()",
    "snippet": "    String getName() {\n      return name;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 0
  },
  {
    "name": "RhinoErrorReporter.forNewRhino",
    "class_name": "com.google.javascript.jscomp.RhinoErrorReporter",
    "signature": "com.google.javascript.jscomp.RhinoErrorReporter.forNewRhino(AbstractCompiler)",
    "snippet": "  public static com.google.javascript.rhino.head.ErrorReporter\n      forNewRhino(AbstractCompiler compiler) {\n    return new NewRhinoErrorReporter(compiler);\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 0
  },
  {
    "name": "RhinoErrorReporter.forOldRhino",
    "class_name": "com.google.javascript.jscomp.RhinoErrorReporter",
    "signature": "com.google.javascript.jscomp.RhinoErrorReporter.forOldRhino(AbstractCompiler)",
    "snippet": "  public static ErrorReporter forOldRhino(AbstractCompiler compiler) {\n    return new OldRhinoErrorReporter(compiler);\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 0
  },
  {
    "name": "RhinoErrorReporter.replacePlaceHolders",
    "class_name": "com.google.javascript.jscomp.RhinoErrorReporter",
    "signature": "com.google.javascript.jscomp.RhinoErrorReporter.replacePlaceHolders(String)",
    "snippet": "  private Pattern replacePlaceHolders(String s) {\n    s = Pattern.quote(s);\n    return Pattern.compile(s.replaceAll(\"\\\\{\\\\d+\\\\}\", \"\\\\\\\\E.*\\\\\\\\Q\"));\n  }",
    "comment": " For each message such as \"Not a good use of {0}\", replace the place holder {0} with a wild card that matches all possible strings. Also put the any non-place-holder in quotes for regex matching later. ",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 0
  },
  {
    "name": "Scope.Scope",
    "class_name": "com.google.javascript.jscomp.Scope",
    "signature": "com.google.javascript.jscomp.Scope.Scope(Node,AbstractCompiler)",
    "snippet": "  Scope(Node rootNode, AbstractCompiler compiler) {\n    this.parent = null;\n    this.rootNode = rootNode;\n    thisType = compiler.getTypeRegistry().getNativeObjectType(GLOBAL_THIS);\n    this.isBottom = false;\n    this.depth = 0;\n  }",
    "comment": " Creates a global Scope. @param rootNode  Typically the global BLOCK node. ",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 0
  },
  {
    "name": "Scope.Scope",
    "class_name": "com.google.javascript.jscomp.Scope",
    "signature": "com.google.javascript.jscomp.Scope.Scope(Scope,Node)",
    "snippet": "  Scope(Scope parent, Node rootNode) {\n    Preconditions.checkNotNull(parent);\n    Preconditions.checkArgument(rootNode != parent.rootNode);\n\n    this.parent = parent;\n    this.rootNode = rootNode;\n    JSType nodeType = rootNode.getJSType();\n    if (nodeType != null && nodeType.isFunctionType()) {\n      thisType = nodeType.toMaybeFunctionType().getTypeOfThis();\n    } else {\n      thisType = parent.thisType;\n    }\n    this.isBottom = false;\n    this.depth = parent.depth + 1;\n  }",
    "comment": " Creates a Scope given the parent Scope and the root node of the scope. @param parent  The parent Scope. Cannot be null. @param rootNode  Typically the FUNCTION node. ",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 0
  },
  {
    "name": "Scope.declare",
    "class_name": "com.google.javascript.jscomp.Scope",
    "signature": "com.google.javascript.jscomp.Scope.declare(String,Node,JSType,CompilerInput)",
    "snippet": "  Var declare(String name, Node nameNode, JSType type, CompilerInput input) {\n    return declare(name, nameNode, type, input, true);\n  }",
    "comment": " Declares a variable whose type is inferred.  @param name name of the variable @param nameNode the NAME node declaring the variable @param type the variable's type @param input the input in which this variable is defined. ",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 0
  },
  {
    "name": "Scope.declare",
    "class_name": "com.google.javascript.jscomp.Scope",
    "signature": "com.google.javascript.jscomp.Scope.declare(String,Node,JSType,CompilerInput,boolean)",
    "snippet": "  Var declare(String name, Node nameNode,\n      JSType type, CompilerInput input, boolean inferred) {\n    Preconditions.checkState(name != null && name.length() > 0);\n\n    // Make sure that it's declared only once\n    Preconditions.checkState(vars.get(name) == null);\n\n    // native variables do not have a name node.\n    JSDocInfo info = nameNode == null\n        ? null : NodeUtil.getBestJSDocInfo(nameNode);\n\n    Var var = new Var(inferred, name, nameNode, type, this, vars.size(), input,\n        info != null && info.isDefine(), info);\n\n    vars.put(name, var);\n    return var;\n  }",
    "comment": " Declares a variable.  @param name name of the variable @param nameNode the NAME node declaring the variable @param type the variable's type @param input the input in which this variable is defined. @param inferred Whether this variable's type is inferred (as opposed to declared). ",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 0
  },
  {
    "name": "Scope.getParent",
    "class_name": "com.google.javascript.jscomp.Scope",
    "signature": "com.google.javascript.jscomp.Scope.getParent()",
    "snippet": "  public Scope getParent() {\n    return parent;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 0
  },
  {
    "name": "Scope.getVar",
    "class_name": "com.google.javascript.jscomp.Scope",
    "signature": "com.google.javascript.jscomp.Scope.getVar(String)",
    "snippet": "  public Var getVar(String name) {\n    Var var = vars.get(name);\n    if (var != null) {\n      return var;\n    } else if (parent != null) { // Recurse up the parent Scope\n      return parent.getVar(name);\n    } else {\n      return null;\n    }\n  }",
    "comment": " Returns the variable, may be null ",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 0
  },
  {
    "name": "Scope.isDeclared",
    "class_name": "com.google.javascript.jscomp.Scope",
    "signature": "com.google.javascript.jscomp.Scope.isDeclared(String,boolean)",
    "snippet": "  public boolean isDeclared(String name, boolean recurse) {\n    Scope scope = this;\n    if (scope.vars.containsKey(name))\n      return true;\n\n    if (scope.parent != null && recurse) {\n      return scope.parent.isDeclared(name, recurse);\n    }\n    return false;\n  }",
    "comment": " Returns true if a variable is declared. ",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 0
  },
  {
    "name": "Scope.isGlobal",
    "class_name": "com.google.javascript.jscomp.Scope",
    "signature": "com.google.javascript.jscomp.Scope.isGlobal()",
    "snippet": "  public boolean isGlobal() {\n    return parent == null;\n  }",
    "comment": " Returns whether this is the global scope. ",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 0
  },
  {
    "name": "Scope.isLocal",
    "class_name": "com.google.javascript.jscomp.Scope",
    "signature": "com.google.javascript.jscomp.Scope.isLocal()",
    "snippet": "  public boolean isLocal() {\n    return !isGlobal();\n  }",
    "comment": " Returns whether this is a local scope (i.e. not the global scope). ",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 0
  },
  {
    "name": "Var.getJSDocInfo",
    "class_name": "com.google.javascript.jscomp.Scope$Var",
    "signature": "com.google.javascript.jscomp.Scope$Var.getJSDocInfo()",
    "snippet": "    @Override\n    public JSDocInfo getJSDocInfo() {\n      return info;\n    }",
    "comment": " Gets the JSDocInfo for the variable. ",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 0
  },
  {
    "name": "SimpleDefinitionFinder.SimpleDefinitionFinder",
    "class_name": "com.google.javascript.jscomp.SimpleDefinitionFinder",
    "signature": "com.google.javascript.jscomp.SimpleDefinitionFinder.SimpleDefinitionFinder(AbstractCompiler)",
    "snippet": "  public SimpleDefinitionFinder(AbstractCompiler compiler) {\n    this.compiler = compiler;\n    this.definitionSiteMap = Maps.newLinkedHashMap();\n    this.nameDefinitionMultimap = LinkedHashMultimap.create();\n    this.nameUseSiteMultimap = LinkedHashMultimap.create();\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 0
  },
  {
    "name": "SimpleDefinitionFinder.getDefinitionsReferencedAt",
    "class_name": "com.google.javascript.jscomp.SimpleDefinitionFinder",
    "signature": "com.google.javascript.jscomp.SimpleDefinitionFinder.getDefinitionsReferencedAt(Node)",
    "snippet": "  @Override\n  public Collection<Definition> getDefinitionsReferencedAt(Node useSite) {\n    if (definitionSiteMap.containsKey(useSite)) {\n      return null;\n    }\n\n    if (useSite.isGetProp()) {\n      String propName = useSite.getLastChild().getString();\n      if (propName.equals(\"apply\") || propName.equals(\"call\")) {\n        useSite = useSite.getFirstChild();\n      }\n    }\n\n    String name = getSimplifiedName(useSite);\n    if (name != null) {\n      Collection<Definition> defs = nameDefinitionMultimap.get(name);\n      if (!defs.isEmpty()) {\n        return defs;\n      } else {\n        return null;\n      }\n    } else {\n      return null;\n    }\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 0
  },
  {
    "name": "SimpleDefinitionFinder.getSimplifiedName",
    "class_name": "com.google.javascript.jscomp.SimpleDefinitionFinder",
    "signature": "com.google.javascript.jscomp.SimpleDefinitionFinder.getSimplifiedName(Node)",
    "snippet": "  private static String getSimplifiedName(Node node) {\n    if (node.isName()) {\n      String name = node.getString();\n      if (name != null && !name.isEmpty()) {\n        return name;\n      } else {\n        return null;\n      }\n    } else if (node.isGetProp()) {\n      return \"this.\" + node.getLastChild().getString();\n    }\n    return null;\n  }",
    "comment": " Extract a name from a node.  In the case of GETPROP nodes, replace the namespace or object expression with \"this\" for simplicity and correctness at the expense of inefficiencies due to higher chances of name collisions.  TODO(user) revisit.  it would be helpful to at least use fully qualified names in the case of namespaces.  Might not matter as much if this pass runs after \"collapsing properties\". ",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 0
  },
  {
    "name": "SimpleDefinitionFinder.process",
    "class_name": "com.google.javascript.jscomp.SimpleDefinitionFinder",
    "signature": "com.google.javascript.jscomp.SimpleDefinitionFinder.process(Node,Node)",
    "snippet": "  @Override\n  public void process(Node externs, Node source) {\n    NodeTraversal.traverse(\n        compiler, externs, new DefinitionGatheringCallback(true));\n    NodeTraversal.traverse(\n        compiler, source, new DefinitionGatheringCallback(false));\n    NodeTraversal.traverse(\n        compiler, source, new UseSiteGatheringCallback());\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 0
  },
  {
    "name": "DefinitionGatheringCallback.visit",
    "class_name": "com.google.javascript.jscomp.SimpleDefinitionFinder$DefinitionGatheringCallback",
    "signature": "com.google.javascript.jscomp.SimpleDefinitionFinder$DefinitionGatheringCallback.visit(NodeTraversal,Node,Node)",
    "snippet": "    @Override\n    public void visit(NodeTraversal traversal, Node node, Node parent) {\n      // Arguments of external functions should not count as name\n      // definitions.  They are placeholder names for documentation\n      // purposes only which are not reachable from anywhere.\n      if (inExterns && node.isName() && parent.isParamList()) {\n        return;\n      }\n\n      Definition def =\n          DefinitionsRemover.getDefinition(node, inExterns);\n      if (def != null) {\n        String name = getSimplifiedName(def.getLValue());\n        if (name != null) {\n          Node rValue = def.getRValue();\n          if ((rValue != null) &&\n              !NodeUtil.isImmutableValue(rValue) &&\n              !rValue.isFunction()) {\n\n            // Unhandled complex expression\n            Definition unknownDef =\n                new UnknownDefinition(def.getLValue(), inExterns);\n            def = unknownDef;\n          }\n\n          // TODO(johnlenz) : remove this stub dropping code if it becomes\n          // illegal to have untyped stubs in the externs definitions.\n          if (inExterns) {\n            // We need special handling of untyped externs stubs here:\n            //    the stub should be dropped if the name is provided elsewhere.\n\n            List<Definition> stubsToRemove = Lists.newArrayList();\n            String qualifiedName = node.getQualifiedName();\n\n            // If there is no qualified name for this, then there will be\n            // no stubs to remove. This will happen if node is an object\n            // literal key.\n            if (qualifiedName != null) {\n              for (Definition prevDef : nameDefinitionMultimap.get(name)) {\n                if (prevDef instanceof ExternalNameOnlyDefinition\n                    && !jsdocContainsDeclarations(node)) {\n                  String prevName = prevDef.getLValue().getQualifiedName();\n                  if (qualifiedName.equals(prevName)) {\n                    // Drop this stub, there is a real definition.\n                    stubsToRemove.add(prevDef);\n                  }\n                }\n              }\n\n              for (Definition prevDef : stubsToRemove) {\n                nameDefinitionMultimap.remove(name, prevDef);\n              }\n            }\n          }\n\n          nameDefinitionMultimap.put(name, def);\n          definitionSiteMap.put(node,\n                                new DefinitionSite(node,\n                                                   def,\n                                                   traversal.getModule(),\n                                                   traversal.inGlobalScope(),\n                                                   inExterns));\n        }\n      }\n\n      if (inExterns && (parent != null) && parent.isExprResult()) {\n        String name = getSimplifiedName(node);\n        if (name != null) {\n\n          // TODO(johnlenz) : remove this code if it becomes illegal to have\n          // stubs in the externs definitions.\n\n          // We need special handling of untyped externs stubs here:\n          //    the stub should be dropped if the name is provided elsewhere.\n          // We can't just drop the stub now as it needs to be used as the\n          //    externs definition if no other definition is provided.\n\n          boolean dropStub = false;\n          if (!jsdocContainsDeclarations(node)) {\n            String qualifiedName = node.getQualifiedName();\n            if (qualifiedName != null) {\n              for (Definition prevDef : nameDefinitionMultimap.get(name)) {\n                String prevName = prevDef.getLValue().getQualifiedName();\n                if (qualifiedName.equals(prevName)) {\n                  dropStub = true;\n                  break;\n                }\n              }\n            }\n          }\n\n          if (!dropStub) {\n            // Incomplete definition\n            Definition definition = new ExternalNameOnlyDefinition(node);\n            nameDefinitionMultimap.put(name, definition);\n            definitionSiteMap.put(node,\n                                  new DefinitionSite(node,\n                                                     definition,\n                                                     traversal.getModule(),\n                                                     traversal.inGlobalScope(),\n                                                     inExterns));\n          }\n        }\n      }\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 0
  },
  {
    "name": "UseSiteGatheringCallback.visit",
    "class_name": "com.google.javascript.jscomp.SimpleDefinitionFinder$UseSiteGatheringCallback",
    "signature": "com.google.javascript.jscomp.SimpleDefinitionFinder$UseSiteGatheringCallback.visit(NodeTraversal,Node,Node)",
    "snippet": "    @Override\n    public void visit(NodeTraversal traversal, Node node, Node parent) {\n\n      Collection<Definition> defs = getDefinitionsReferencedAt(node);\n      if (defs == null) {\n        return;\n      }\n\n      Definition first = defs.iterator().next();\n\n      String name = getSimplifiedName(first.getLValue());\n      Preconditions.checkNotNull(name);\n      nameUseSiteMultimap.put(\n          name,\n          new UseSite(node, traversal.getScope(), traversal.getModule()));\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 0
  },
  {
    "name": "SourceFile.SourceFile",
    "class_name": "com.google.javascript.jscomp.SourceFile",
    "signature": "com.google.javascript.jscomp.SourceFile.SourceFile(String)",
    "snippet": "  public SourceFile(String fileName) {\n    if (fileName == null || fileName.isEmpty()) {\n      throw new IllegalArgumentException(\"a source must have a name\");\n    }\n    this.fileName = fileName;\n  }",
    "comment": " Construct a new abstract source file.  @param fileName The file name of the source file. It does not necessarily need to correspond to a real path. But it should be unique. Will appear in warning messages emitted by the compiler. ",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 0
  },
  {
    "name": "SourceFile.builder",
    "class_name": "com.google.javascript.jscomp.SourceFile",
    "signature": "com.google.javascript.jscomp.SourceFile.builder()",
    "snippet": "  public static Builder builder() {\n    return new Builder();\n  }",
    "comment": "Create a new builder for source files. */",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 0
  },
  {
    "name": "SourceFile.fromCode",
    "class_name": "com.google.javascript.jscomp.SourceFile",
    "signature": "com.google.javascript.jscomp.SourceFile.fromCode(String,String)",
    "snippet": "  public static SourceFile fromCode(String fileName, String code) {\n    return builder().buildFromCode(fileName, code);\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 0
  },
  {
    "name": "SourceFile.getCode",
    "class_name": "com.google.javascript.jscomp.SourceFile",
    "signature": "com.google.javascript.jscomp.SourceFile.getCode()",
    "snippet": "  public String getCode() throws IOException {\n    return code;\n  }",
    "comment": " Gets all the code in this source file. @throws IOException ",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 0
  },
  {
    "name": "SourceFile.getName",
    "class_name": "com.google.javascript.jscomp.SourceFile",
    "signature": "com.google.javascript.jscomp.SourceFile.getName()",
    "snippet": "  @Override\n  public String getName() {\n    return fileName;\n  }",
    "comment": "Returns a unique name for the source file. */",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 0
  },
  {
    "name": "SourceFile.setCode",
    "class_name": "com.google.javascript.jscomp.SourceFile",
    "signature": "com.google.javascript.jscomp.SourceFile.setCode(String)",
    "snippet": "  private void setCode(String sourceCode) {\n    code = sourceCode;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 0
  },
  {
    "name": "SourceFile.setIsExtern",
    "class_name": "com.google.javascript.jscomp.SourceFile",
    "signature": "com.google.javascript.jscomp.SourceFile.setIsExtern(boolean)",
    "snippet": "  void setIsExtern(boolean newVal) {\n    isExternFile = newVal;\n  }",
    "comment": "Sets that this is an extern. */",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 0
  },
  {
    "name": "SourceFile.setOriginalPath",
    "class_name": "com.google.javascript.jscomp.SourceFile",
    "signature": "com.google.javascript.jscomp.SourceFile.setOriginalPath(String)",
    "snippet": "  public void setOriginalPath(String originalPath) {\n    this.originalPath = originalPath;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 0
  },
  {
    "name": "Builder.buildFromCode",
    "class_name": "com.google.javascript.jscomp.SourceFile$Builder",
    "signature": "com.google.javascript.jscomp.SourceFile$Builder.buildFromCode(String,String)",
    "snippet": "    public SourceFile buildFromCode(String fileName, String code) {\n      return new Preloaded(fileName, originalPath, code);\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 0
  },
  {
    "name": "SuppressDocWarningsGuard.SuppressDocWarningsGuard",
    "class_name": "com.google.javascript.jscomp.SuppressDocWarningsGuard",
    "signature": "com.google.javascript.jscomp.SuppressDocWarningsGuard.SuppressDocWarningsGuard(Map)",
    "snippet": "  SuppressDocWarningsGuard(Map<String, DiagnosticGroup> suppressableGroups) {\n    for (Map.Entry<String, DiagnosticGroup> entry :\n             suppressableGroups.entrySet()) {\n      suppressors.put(\n          entry.getKey(),\n          new DiagnosticGroupWarningsGuard(\n              entry.getValue(),\n              CheckLevel.OFF));\n    }\n  }",
    "comment": " The suppressable groups, indexed by name. ",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 0
  },
  {
    "name": "SuppressDocWarningsGuard.getPriority",
    "class_name": "com.google.javascript.jscomp.SuppressDocWarningsGuard",
    "signature": "com.google.javascript.jscomp.SuppressDocWarningsGuard.getPriority()",
    "snippet": "  @Override\n  public int getPriority() {\n    // Happens after path-based filtering, but before other times\n    // of filtering.\n    return WarningsGuard.Priority.SUPPRESS_DOC.value;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 0
  },
  {
    "name": "SyntacticScopeCreator.SyntacticScopeCreator",
    "class_name": "com.google.javascript.jscomp.SyntacticScopeCreator",
    "signature": "com.google.javascript.jscomp.SyntacticScopeCreator.SyntacticScopeCreator(AbstractCompiler)",
    "snippet": "  SyntacticScopeCreator(AbstractCompiler compiler) {\n    this.compiler = compiler;\n    this.redeclarationHandler = new DefaultRedeclarationHandler();\n  }",
    "comment": " Creates a ScopeCreator. ",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 0
  },
  {
    "name": "Tracer.Tracer",
    "class_name": "com.google.javascript.jscomp.Tracer",
    "signature": "com.google.javascript.jscomp.Tracer.Tracer(String,String)",
    "snippet": "  Tracer(@Nullable String type, @Nullable String comment) {\n    this.type = type;\n    this.comment = comment == null ? \"\" : comment;\n    startTimeMs = clock.currentTimeMillis();\n    startThread = Thread.currentThread();\n    if (!extraTracingStatistics.isEmpty()) {\n      int size = extraTracingStatistics.size();\n      extraTracingValues = new long[size];\n      int i = 0;\n      for (TracingStatistic tracingStatistic : extraTracingStatistics) {\n        extraTracingValues[i] = tracingStatistic.start(startThread);\n        i++;\n      }\n    }\n\n    ThreadTrace trace = getThreadTrace();\n\n    // Do nothing if the current thread trace wasn't initialized.\n    if (!trace.isInitialized()) {\n      return;\n    }\n\n    // Check if we are creating too many Tracers.\n    if (trace.events.size() >= MAX_TRACE_SIZE) {\n      logger.log(Level.WARNING,\n                  \"Giant thread trace. Too many Tracers created. \"\n                    + \"Clearing to avoid memory leak.\",\n                  new Throwable(trace.toString()));\n      trace.truncateEvents();\n    }\n\n    // Check if we forgot to close the Tracers.\n    if (trace.outstandingEvents.size() >= MAX_TRACE_SIZE) {\n      logger.log(Level.WARNING,\n                  \"Too many outstanding Tracers. Tracer.stop() is missing \"\n                    + \"or Tracer.stop() is not wrapped in a \"\n                    + \"try/finally block. \"\n                    + \"Clearing to avoid memory leak.\",\n                  new Throwable(trace.toString()));\n      trace.truncateOutstandingEvents();\n    }\n\n    trace.startEvent(this);\n  }",
    "comment": " Create and start a tracer. Both type and comment may be null. See class comment for usage.  @param type The type for totalling @param comment Comment about this tracer ",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 0
  },
  {
    "name": "Tracer.getThreadTrace",
    "class_name": "com.google.javascript.jscomp.Tracer",
    "signature": "com.google.javascript.jscomp.Tracer.getThreadTrace()",
    "snippet": "  static ThreadTrace getThreadTrace() {\n    ThreadTrace t = traces.get();\n    if (t == null) {\n      t = new ThreadTrace();\n      t.prettyPrint = defaultPrettyPrint;\n      traces.set(t);\n    }\n    return t;\n  }",
    "comment": " Get the ThreadTrace for the current thread, creating one if necessary. ",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 0
  },
  {
    "name": "Tracer.stop",
    "class_name": "com.google.javascript.jscomp.Tracer",
    "signature": "com.google.javascript.jscomp.Tracer.stop()",
    "snippet": "  long stop() {\n    return stop(-1);\n  }",
    "comment": "Stop the trace using the default silence_threshold  @return  The time that this trace actually ran. ",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 0
  },
  {
    "name": "Tracer.stop",
    "class_name": "com.google.javascript.jscomp.Tracer",
    "signature": "com.google.javascript.jscomp.Tracer.stop(int)",
    "snippet": "  long stop(int silence_threshold) {\n    Preconditions.checkState(Thread.currentThread() == startThread);\n\n    ThreadTrace trace = getThreadTrace();\n    // Do nothing if the thread trace was not initialized.\n    if (!trace.isInitialized()) {\n      return 0;\n    }\n\n    stopTimeMs = clock.currentTimeMillis();\n    if (extraTracingValues != null) {\n      // We use extraTracingValues.length rather than\n      // extraTracingStatistics.size() because a new statistic may\n      // have been added\n      for (int i = 0; i < extraTracingValues.length; i++) {\n        long value = extraTracingStatistics.get(i).stop(startThread);\n        extraTracingValues[i] = value - extraTracingValues[i];\n      }\n    }\n\n    // Do nothing if the thread trace was not initialized.\n    if (!trace.isInitialized()) {\n      return 0;\n    }\n\n    trace.endEvent(this, silence_threshold);\n    return stopTimeMs - startTimeMs;\n  }",
    "comment": " Stop the trace. This may only be done once and must be done from the same thread that started it. @param silence_threshold Traces for time less than silence_threshold ms will be left out of the trace report. A value of -1 indicates that the current ThreadTrace silence_threshold should be used. @return The time that this trace actually ran ",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 0
  },
  {
    "name": "ThreadTrace.isInitialized",
    "class_name": "com.google.javascript.jscomp.Tracer$ThreadTrace",
    "signature": "com.google.javascript.jscomp.Tracer$ThreadTrace.isInitialized()",
    "snippet": "    boolean isInitialized() {\n      return isInitialized;\n    }",
    "comment": "Is initialized? */",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 0
  },
  {
    "name": "UseSite.UseSite",
    "class_name": "com.google.javascript.jscomp.UseSite",
    "signature": "com.google.javascript.jscomp.UseSite.UseSite(Node,Scope,JSModule)",
    "snippet": "  UseSite(Node node, Scope scope, JSModule module) {\n    this.node = node;\n    this.scope = scope;\n    this.module = module;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 0
  },
  {
    "name": "UseSite.hashCode",
    "class_name": "com.google.javascript.jscomp.UseSite",
    "signature": "com.google.javascript.jscomp.UseSite.hashCode()",
    "snippet": "  @Override\n  public int hashCode() {\n    return this.node.hashCode();\n  }",
    "comment": "Use the node as the identifying feature to make the UseSite recreatable.",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 0
  },
  {
    "name": "WarningsGuard.disables",
    "class_name": "com.google.javascript.jscomp.WarningsGuard",
    "signature": "com.google.javascript.jscomp.WarningsGuard.disables(DiagnosticGroup)",
    "snippet": "  protected boolean disables(DiagnosticGroup group) {\n    return false;\n  }",
    "comment": " Returns whether all warnings in the given diagnostic group will be filtered out. Used to determine which passes to skip.  @param group A group of DiagnosticTypes. @return Whether all warnings of these types are disabled by this guard. ",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 0
  },
  {
    "name": "WarningsGuard.enables",
    "class_name": "com.google.javascript.jscomp.WarningsGuard",
    "signature": "com.google.javascript.jscomp.WarningsGuard.enables(DiagnosticGroup)",
    "snippet": "  protected boolean enables(DiagnosticGroup group) {\n    return false;\n  }",
    "comment": " Returns whether any of the warnings in the given diagnostic group will be upgraded to a warning or error.  @param group A group of DiagnosticTypes. @return Whether any warnings of these types are enabled by this guard. ",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 0
  },
  {
    "name": "WarningsGuard.getPriority",
    "class_name": "com.google.javascript.jscomp.WarningsGuard",
    "signature": "com.google.javascript.jscomp.WarningsGuard.getPriority()",
    "snippet": "  protected int getPriority() {\n    return Priority.DEFAULT.value;\n  }",
    "comment": " The priority in which warnings guards are applied. Lower means the guard will be applied sooner. Expressed on a scale of 1 to 100. ",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 0
  },
  {
    "name": "Config.Config",
    "class_name": "com.google.javascript.jscomp.parsing.Config",
    "signature": "com.google.javascript.jscomp.parsing.Config.Config(Set,Set,boolean,LanguageMode,boolean)",
    "snippet": "  Config(Set<String> annotationWhitelist, Set<String> suppressionNames,\n      boolean isIdeMode, LanguageMode languageMode,\n      boolean acceptConstKeyword) {\n    this.annotationNames = buildAnnotationNames(annotationWhitelist);\n    this.parseJsDocDocumentation = isIdeMode;\n    this.suppressionNames = suppressionNames;\n    this.isIdeMode = isIdeMode;\n    this.languageMode = languageMode;\n    this.acceptConstKeyword = acceptConstKeyword;\n  }",
    "comment": " Annotation names. ",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 0
  },
  {
    "name": "Config.buildAnnotationNames",
    "class_name": "com.google.javascript.jscomp.parsing.Config",
    "signature": "com.google.javascript.jscomp.parsing.Config.buildAnnotationNames(Set)",
    "snippet": "  private static Map<String, Annotation> buildAnnotationNames(\n      Set<String> annotationWhitelist) {\n    ImmutableMap.Builder<String, Annotation> annotationBuilder =\n        ImmutableMap.builder();\n    annotationBuilder.putAll(Annotation.recognizedAnnotations);\n    for (String unrecognizedAnnotation : annotationWhitelist) {\n      if (!Annotation.recognizedAnnotations.containsKey(\n              unrecognizedAnnotation)) {\n        annotationBuilder.put(\n            unrecognizedAnnotation, Annotation.NOT_IMPLEMENTED);\n      }\n    }\n    return annotationBuilder.build();\n  }",
    "comment": " Create the annotation names from the user-specified annotation whitelist. ",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 0
  },
  {
    "name": "IRFactory.createTemplateNode",
    "class_name": "com.google.javascript.jscomp.parsing.IRFactory",
    "signature": "com.google.javascript.jscomp.parsing.IRFactory.createTemplateNode()",
    "snippet": "  private Node createTemplateNode() {\n    // The Node type choice is arbitrary.\n    Node templateNode = new Node(Token.SCRIPT);\n    templateNode.setStaticSourceFile(sourceFile);\n    return templateNode;\n  }",
    "comment": "This reduces the cost of these properties to O(nodes) to O(files).",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 0
  },
  {
    "name": "IRFactory.handleJsDoc",
    "class_name": "com.google.javascript.jscomp.parsing.IRFactory",
    "signature": "com.google.javascript.jscomp.parsing.IRFactory.handleJsDoc(AstNode,Node)",
    "snippet": "  private JSDocInfo handleJsDoc(AstNode node, Node irNode) {\n    Comment comment = node.getJsDocNode();\n    if (comment != null) {\n      JsDocInfoParser jsDocParser = createJsDocInfoParser(comment, irNode);\n      parsedComments.add(comment);\n      if (!handlePossibleFileOverviewJsDoc(jsDocParser)) {\n        return jsDocParser.retrieveAndResetParsedJSDocInfo();\n      }\n    }\n    return null;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 0
  },
  {
    "name": "IRFactory.justTransform",
    "class_name": "com.google.javascript.jscomp.parsing.IRFactory",
    "signature": "com.google.javascript.jscomp.parsing.IRFactory.justTransform(AstNode)",
    "snippet": "  private Node justTransform(AstNode node) {\n    return transformDispatcher.process(node);\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 0
  },
  {
    "name": "IRFactory.maybeSetLengthFrom",
    "class_name": "com.google.javascript.jscomp.parsing.IRFactory",
    "signature": "com.google.javascript.jscomp.parsing.IRFactory.maybeSetLengthFrom(Node,AstNode)",
    "snippet": "  private void maybeSetLengthFrom(Node node, AstNode source) {\n    if (config.isIdeMode) {\n      node.setLength(source.getLength());\n    }\n  }",
    "comment": "Set the length on the node if we're in IDE mode.",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 0
  },
  {
    "name": "IRFactory.newNode",
    "class_name": "com.google.javascript.jscomp.parsing.IRFactory",
    "signature": "com.google.javascript.jscomp.parsing.IRFactory.newNode(int)",
    "snippet": "  private Node newNode(int type) {\n    return new Node(type).clonePropsFrom(templateNode);\n  }",
    "comment": "Simple helper to create nodes and set the initial node properties.",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 0
  },
  {
    "name": "IRFactory.newNumberNode",
    "class_name": "com.google.javascript.jscomp.parsing.IRFactory",
    "signature": "com.google.javascript.jscomp.parsing.IRFactory.newNumberNode(Double)",
    "snippet": "  private Node newNumberNode(Double value) {\n    return IR.number(value).clonePropsFrom(templateNode);\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 0
  },
  {
    "name": "IRFactory.position2charno",
    "class_name": "com.google.javascript.jscomp.parsing.IRFactory",
    "signature": "com.google.javascript.jscomp.parsing.IRFactory.position2charno(int)",
    "snippet": "  private int position2charno(int position) {\n    int lineIndex = sourceString.lastIndexOf('\\n', position);\n    if (lineIndex == -1) {\n      return position;\n    } else {\n      // Subtract one for initial position being 0.\n      return position - lineIndex - 1;\n    }\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 0
  },
  {
    "name": "IRFactory.setFileOverviewJsDoc",
    "class_name": "com.google.javascript.jscomp.parsing.IRFactory",
    "signature": "com.google.javascript.jscomp.parsing.IRFactory.setFileOverviewJsDoc(Node)",
    "snippet": "  private void setFileOverviewJsDoc(Node irNode) {\n    // Only after we've seen all @fileoverview entries, attach the\n    // last one to the root node, and copy the found license strings\n    // to that node.\n    JSDocInfo rootNodeJsDoc = rootNodeJsDocHolder.getJSDocInfo();\n    if (rootNodeJsDoc != null) {\n      irNode.setJSDocInfo(rootNodeJsDoc);\n      rootNodeJsDoc.setAssociatedNode(irNode);\n    }\n\n    if (fileOverviewInfo != null) {\n      if ((irNode.getJSDocInfo() != null) &&\n          (irNode.getJSDocInfo().getLicense() != null)) {\n        fileOverviewInfo.setLicense(irNode.getJSDocInfo().getLicense());\n      }\n      irNode.setJSDocInfo(fileOverviewInfo);\n      fileOverviewInfo.setAssociatedNode(irNode);\n    }\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 0
  },
  {
    "name": "IRFactory.setSourceInfo",
    "class_name": "com.google.javascript.jscomp.parsing.IRFactory",
    "signature": "com.google.javascript.jscomp.parsing.IRFactory.setSourceInfo(Node,AstNode)",
    "snippet": "  private void setSourceInfo(Node irNode, AstNode node) {\n    if (irNode.getLineno() == -1) {\n      // If we didn't already set the line, then set it now. This avoids\n      // cases like ParenthesizedExpression where we just return a previous\n      // node, but don't want the new node to get its parent's line number.\n      int lineno = node.getLineno();\n      irNode.setLineno(lineno);\n      int charno = position2charno(node.getAbsolutePosition());\n      irNode.setCharno(charno);\n      maybeSetLengthFrom(irNode, node);\n    }\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 0
  },
  {
    "name": "IRFactory.transform",
    "class_name": "com.google.javascript.jscomp.parsing.IRFactory",
    "signature": "com.google.javascript.jscomp.parsing.IRFactory.transform(AstNode)",
    "snippet": "  private Node transform(AstNode node) {\n    Node irNode = justTransform(node);\n    JSDocInfo jsDocInfo = handleJsDoc(node, irNode);\n    if (jsDocInfo != null) {\n      irNode.setJSDocInfo(jsDocInfo);\n    }\n    setSourceInfo(irNode, node);\n    return irNode;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 0
  },
  {
    "name": "IRFactory.transformTokenType",
    "class_name": "com.google.javascript.jscomp.parsing.IRFactory",
    "signature": "com.google.javascript.jscomp.parsing.IRFactory.transformTokenType(int)",
    "snippet": "  private static int transformTokenType(int token) {\n    switch (token) {\n      case com.google.javascript.rhino.head.Token.RETURN:\n        return Token.RETURN;\n      case com.google.javascript.rhino.head.Token.BITOR:\n        return Token.BITOR;\n      case com.google.javascript.rhino.head.Token.BITXOR:\n        return Token.BITXOR;\n      case com.google.javascript.rhino.head.Token.BITAND:\n        return Token.BITAND;\n      case com.google.javascript.rhino.head.Token.EQ:\n        return Token.EQ;\n      case com.google.javascript.rhino.head.Token.NE:\n        return Token.NE;\n      case com.google.javascript.rhino.head.Token.LT:\n        return Token.LT;\n      case com.google.javascript.rhino.head.Token.LE:\n        return Token.LE;\n      case com.google.javascript.rhino.head.Token.GT:\n        return Token.GT;\n      case com.google.javascript.rhino.head.Token.GE:\n        return Token.GE;\n      case com.google.javascript.rhino.head.Token.LSH:\n        return Token.LSH;\n      case com.google.javascript.rhino.head.Token.RSH:\n        return Token.RSH;\n      case com.google.javascript.rhino.head.Token.URSH:\n        return Token.URSH;\n      case com.google.javascript.rhino.head.Token.ADD:\n        return Token.ADD;\n      case com.google.javascript.rhino.head.Token.SUB:\n        return Token.SUB;\n      case com.google.javascript.rhino.head.Token.MUL:\n        return Token.MUL;\n      case com.google.javascript.rhino.head.Token.DIV:\n        return Token.DIV;\n      case com.google.javascript.rhino.head.Token.MOD:\n        return Token.MOD;\n      case com.google.javascript.rhino.head.Token.NOT:\n        return Token.NOT;\n      case com.google.javascript.rhino.head.Token.BITNOT:\n        return Token.BITNOT;\n      case com.google.javascript.rhino.head.Token.POS:\n        return Token.POS;\n      case com.google.javascript.rhino.head.Token.NEG:\n        return Token.NEG;\n      case com.google.javascript.rhino.head.Token.NEW:\n        return Token.NEW;\n      case com.google.javascript.rhino.head.Token.DELPROP:\n        return Token.DELPROP;\n      case com.google.javascript.rhino.head.Token.TYPEOF:\n        return Token.TYPEOF;\n      case com.google.javascript.rhino.head.Token.GETPROP:\n        return Token.GETPROP;\n      case com.google.javascript.rhino.head.Token.GETELEM:\n        return Token.GETELEM;\n      case com.google.javascript.rhino.head.Token.CALL:\n        return Token.CALL;\n      case com.google.javascript.rhino.head.Token.NAME:\n        return Token.NAME;\n      case com.google.javascript.rhino.head.Token.NUMBER:\n        return Token.NUMBER;\n      case com.google.javascript.rhino.head.Token.STRING:\n        return Token.STRING;\n      case com.google.javascript.rhino.head.Token.NULL:\n        return Token.NULL;\n      case com.google.javascript.rhino.head.Token.THIS:\n        return Token.THIS;\n      case com.google.javascript.rhino.head.Token.FALSE:\n        return Token.FALSE;\n      case com.google.javascript.rhino.head.Token.TRUE:\n        return Token.TRUE;\n      case com.google.javascript.rhino.head.Token.SHEQ:\n        return Token.SHEQ;\n      case com.google.javascript.rhino.head.Token.SHNE:\n        return Token.SHNE;\n      case com.google.javascript.rhino.head.Token.REGEXP:\n        return Token.REGEXP;\n      case com.google.javascript.rhino.head.Token.THROW:\n        return Token.THROW;\n      case com.google.javascript.rhino.head.Token.IN:\n        return Token.IN;\n      case com.google.javascript.rhino.head.Token.INSTANCEOF:\n        return Token.INSTANCEOF;\n      case com.google.javascript.rhino.head.Token.ARRAYLIT:\n        return Token.ARRAYLIT;\n      case com.google.javascript.rhino.head.Token.OBJECTLIT:\n        return Token.OBJECTLIT;\n      case com.google.javascript.rhino.head.Token.TRY:\n        return Token.TRY;\n      // The LP represents a parameter list\n      case com.google.javascript.rhino.head.Token.LP:\n        return Token.PARAM_LIST;\n      case com.google.javascript.rhino.head.Token.COMMA:\n        return Token.COMMA;\n      case com.google.javascript.rhino.head.Token.ASSIGN:\n        return Token.ASSIGN;\n      case com.google.javascript.rhino.head.Token.ASSIGN_BITOR:\n        return Token.ASSIGN_BITOR;\n      case com.google.javascript.rhino.head.Token.ASSIGN_BITXOR:\n        return Token.ASSIGN_BITXOR;\n      case com.google.javascript.rhino.head.Token.ASSIGN_BITAND:\n        return Token.ASSIGN_BITAND;\n      case com.google.javascript.rhino.head.Token.ASSIGN_LSH:\n        return Token.ASSIGN_LSH;\n      case com.google.javascript.rhino.head.Token.ASSIGN_RSH:\n        return Token.ASSIGN_RSH;\n      case com.google.javascript.rhino.head.Token.ASSIGN_URSH:\n        return Token.ASSIGN_URSH;\n      case com.google.javascript.rhino.head.Token.ASSIGN_ADD:\n        return Token.ASSIGN_ADD;\n      case com.google.javascript.rhino.head.Token.ASSIGN_SUB:\n        return Token.ASSIGN_SUB;\n      case com.google.javascript.rhino.head.Token.ASSIGN_MUL:\n        return Token.ASSIGN_MUL;\n      case com.google.javascript.rhino.head.Token.ASSIGN_DIV:\n        return Token.ASSIGN_DIV;\n      case com.google.javascript.rhino.head.Token.ASSIGN_MOD:\n        return Token.ASSIGN_MOD;\n      case com.google.javascript.rhino.head.Token.HOOK:\n        return Token.HOOK;\n      case com.google.javascript.rhino.head.Token.OR:\n        return Token.OR;\n      case com.google.javascript.rhino.head.Token.AND:\n        return Token.AND;\n      case com.google.javascript.rhino.head.Token.INC:\n        return Token.INC;\n      case com.google.javascript.rhino.head.Token.DEC:\n        return Token.DEC;\n      case com.google.javascript.rhino.head.Token.FUNCTION:\n        return Token.FUNCTION;\n      case com.google.javascript.rhino.head.Token.IF:\n        return Token.IF;\n      case com.google.javascript.rhino.head.Token.SWITCH:\n        return Token.SWITCH;\n      case com.google.javascript.rhino.head.Token.CASE:\n        return Token.CASE;\n      case com.google.javascript.rhino.head.Token.DEFAULT:\n        return Token.DEFAULT_CASE;\n      case com.google.javascript.rhino.head.Token.WHILE:\n        return Token.WHILE;\n      case com.google.javascript.rhino.head.Token.DO:\n        return Token.DO;\n      case com.google.javascript.rhino.head.Token.FOR:\n        return Token.FOR;\n      case com.google.javascript.rhino.head.Token.BREAK:\n        return Token.BREAK;\n      case com.google.javascript.rhino.head.Token.CONTINUE:\n        return Token.CONTINUE;\n      case com.google.javascript.rhino.head.Token.VAR:\n        return Token.VAR;\n      case com.google.javascript.rhino.head.Token.WITH:\n        return Token.WITH;\n      case com.google.javascript.rhino.head.Token.CATCH:\n        return Token.CATCH;\n      case com.google.javascript.rhino.head.Token.VOID:\n        return Token.VOID;\n      case com.google.javascript.rhino.head.Token.EMPTY:\n        return Token.EMPTY;\n      case com.google.javascript.rhino.head.Token.BLOCK:\n        return Token.BLOCK;\n      case com.google.javascript.rhino.head.Token.LABEL:\n        return Token.LABEL;\n      case com.google.javascript.rhino.head.Token.EXPR_VOID:\n      case com.google.javascript.rhino.head.Token.EXPR_RESULT:\n        return Token.EXPR_RESULT;\n      case com.google.javascript.rhino.head.Token.SCRIPT:\n        return Token.SCRIPT;\n      case com.google.javascript.rhino.head.Token.GET:\n        return Token.GETTER_DEF;\n      case com.google.javascript.rhino.head.Token.SET:\n        return Token.SETTER_DEF;\n      case com.google.javascript.rhino.head.Token.CONST:\n        return Token.CONST;\n      case com.google.javascript.rhino.head.Token.DEBUGGER:\n        return Token.DEBUGGER;\n    }\n\n    // Token without name\n    throw new IllegalStateException(String.valueOf(token));\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 0
  },
  {
    "name": "IRFactory.transformTree",
    "class_name": "com.google.javascript.jscomp.parsing.IRFactory",
    "signature": "com.google.javascript.jscomp.parsing.IRFactory.transformTree(AstRoot,StaticSourceFile,String,Config,ErrorReporter)",
    "snippet": "  public static Node transformTree(AstRoot node,\n                                   StaticSourceFile sourceFile,\n                                   String sourceString,\n                                   Config config,\n                                   ErrorReporter errorReporter) {\n    IRFactory irFactory = new IRFactory(sourceString, sourceFile,\n        config, errorReporter);\n    Node irNode = irFactory.transform(node);\n\n    if (node.getComments() != null) {\n      for (Comment comment : node.getComments()) {\n        if (comment.getCommentType() == CommentType.JSDOC &&\n            !irFactory.parsedComments.contains(comment)) {\n          irFactory.handlePossibleFileOverviewJsDoc(comment, irNode);\n        } else if (comment.getCommentType() == CommentType.BLOCK_COMMENT) {\n          irFactory.handleBlockComment(comment);\n        }\n      }\n    }\n\n    irFactory.setFileOverviewJsDoc(irNode);\n\n    return irNode;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 0
  },
  {
    "name": "TransformDispatcher.isDirective",
    "class_name": "com.google.javascript.jscomp.parsing.IRFactory$TransformDispatcher",
    "signature": "com.google.javascript.jscomp.parsing.IRFactory$TransformDispatcher.isDirective(Node)",
    "snippet": "    private boolean isDirective(Node n) {\n      if (n == null) return false;\n\n      int nType = n.getType();\n      return nType == Token.EXPR_RESULT &&\n          n.getFirstChild().isString() &&\n          ALLOWED_DIRECTIVES.contains(n.getFirstChild().getString());\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 0
  },
  {
    "name": "TransformDispatcher.parseDirectives",
    "class_name": "com.google.javascript.jscomp.parsing.IRFactory$TransformDispatcher",
    "signature": "com.google.javascript.jscomp.parsing.IRFactory$TransformDispatcher.parseDirectives(Node)",
    "snippet": "    private void parseDirectives(Node node) {\n      // Remove all the directives, and encode them in the AST.\n      Set<String> directives = null;\n      while (isDirective(node.getFirstChild())) {\n        String directive = node.removeFirstChild().getFirstChild().getString();\n        if (directives == null) {\n          directives = Sets.newHashSet(directive);\n        } else {\n          directives.add(directive);\n        }\n      }\n\n      if (directives != null) {\n        node.setDirectives(directives);\n      }\n    }",
    "comment": " Parse the directives, encode them in the AST, and remove their nodes.  For information on ES5 directives, see section 14.1 of Ecma-262, Edition 5.  It would be nice if Rhino would eventually take care of this for us, but right now their directive-processing is a one-off. ",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 0
  },
  {
    "name": "TransformDispatcher.processAstRoot",
    "class_name": "com.google.javascript.jscomp.parsing.IRFactory$TransformDispatcher",
    "signature": "com.google.javascript.jscomp.parsing.IRFactory$TransformDispatcher.processAstRoot(AstRoot)",
    "snippet": "    @Override\n    Node processAstRoot(AstRoot rootNode) {\n      Node node = newNode(Token.SCRIPT);\n      for (com.google.javascript.rhino.head.Node child : rootNode) {\n        node.addChildToBack(transform((AstNode)child));\n      }\n      parseDirectives(node);\n      return node;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 0
  },
  {
    "name": "TransformDispatcher.processExpressionStatement",
    "class_name": "com.google.javascript.jscomp.parsing.IRFactory$TransformDispatcher",
    "signature": "com.google.javascript.jscomp.parsing.IRFactory$TransformDispatcher.processExpressionStatement(ExpressionStatement)",
    "snippet": "    @Override\n    Node processExpressionStatement(ExpressionStatement statementNode) {\n      Node node = newNode(transformTokenType(statementNode.getType()));\n      node.addChildToBack(transform(statementNode.getExpression()));\n      return node;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 0
  },
  {
    "name": "TransformDispatcher.processKeywordLiteral",
    "class_name": "com.google.javascript.jscomp.parsing.IRFactory$TransformDispatcher",
    "signature": "com.google.javascript.jscomp.parsing.IRFactory$TransformDispatcher.processKeywordLiteral(KeywordLiteral)",
    "snippet": "    @Override\n    Node processKeywordLiteral(KeywordLiteral literalNode) {\n      return newNode(transformTokenType(literalNode.getType()));\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 0
  },
  {
    "name": "TransformDispatcher.processNumberLiteral",
    "class_name": "com.google.javascript.jscomp.parsing.IRFactory$TransformDispatcher",
    "signature": "com.google.javascript.jscomp.parsing.IRFactory$TransformDispatcher.processNumberLiteral(NumberLiteral)",
    "snippet": "    @Override\n    Node processNumberLiteral(NumberLiteral literalNode) {\n      return newNumberNode(literalNode.getNumber());\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 0
  },
  {
    "name": "ParserRunner.createConfig",
    "class_name": "com.google.javascript.jscomp.parsing.ParserRunner",
    "signature": "com.google.javascript.jscomp.parsing.ParserRunner.createConfig(boolean,LanguageMode,boolean,Set)",
    "snippet": "  public static Config createConfig(boolean isIdeMode,\n                                    LanguageMode languageMode,\n                                    boolean acceptConstKeyword,\n                                    Set<String> extraAnnotationNames) {\n    initResourceConfig();\n    Set<String> effectiveAnnotationNames;\n    if (extraAnnotationNames == null) {\n      effectiveAnnotationNames = annotationNames;\n    } else {\n      effectiveAnnotationNames = new HashSet<String>(annotationNames);\n      effectiveAnnotationNames.addAll(extraAnnotationNames);\n    }\n    return new Config(effectiveAnnotationNames, suppressionNames,\n        isIdeMode, languageMode, acceptConstKeyword);\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 0
  },
  {
    "name": "ParserRunner.extractList",
    "class_name": "com.google.javascript.jscomp.parsing.ParserRunner",
    "signature": "com.google.javascript.jscomp.parsing.ParserRunner.extractList(String)",
    "snippet": "  private static Set<String> extractList(String configProp) {\n    String[] names = configProp.split(\",\");\n    Set<String> trimmedNames = Sets.newHashSet();\n    for (String name : names) {\n      trimmedNames.add(name.trim());\n    }\n    return ImmutableSet.copyOf(trimmedNames);\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 0
  },
  {
    "name": "ParserRunner.initResourceConfig",
    "class_name": "com.google.javascript.jscomp.parsing.ParserRunner",
    "signature": "com.google.javascript.jscomp.parsing.ParserRunner.initResourceConfig()",
    "snippet": "  private static synchronized void initResourceConfig() {\n    if (annotationNames != null) {\n      return;\n    }\n\n    ResourceBundle config = ResourceBundle.getBundle(configResource);\n    annotationNames = extractList(config.getString(\"jsdoc.annotations\"));\n    suppressionNames = extractList(config.getString(\"jsdoc.suppressions\"));\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 0
  },
  {
    "name": "ParserRunner.parse",
    "class_name": "com.google.javascript.jscomp.parsing.ParserRunner",
    "signature": "com.google.javascript.jscomp.parsing.ParserRunner.parse(StaticSourceFile,String,Config,ErrorReporter,Logger)",
    "snippet": "  public static Node parse(StaticSourceFile sourceFile,\n                           String sourceString,\n                           Config config,\n                           ErrorReporter errorReporter,\n                           Logger logger) throws IOException {\n    Context cx = Context.enter();\n    cx.setErrorReporter(errorReporter);\n    cx.setLanguageVersion(Context.VERSION_1_5);\n    CompilerEnvirons compilerEnv = new CompilerEnvirons();\n    compilerEnv.initFromContext(cx);\n    compilerEnv.setRecordingComments(true);\n    compilerEnv.setRecordingLocalJsDocComments(true);\n\n    // ES5 specifically allows trailing commas\n    compilerEnv.setWarnTrailingComma(\n        config.languageMode == LanguageMode.ECMASCRIPT3);\n\n    // Do our own identifier check for ECMASCRIPT 5\n    boolean acceptEs5 =\n        config.isIdeMode || config.languageMode != LanguageMode.ECMASCRIPT3;\n    compilerEnv.setReservedKeywordAsIdentifier(acceptEs5);\n\n    compilerEnv.setAllowMemberExprAsFunctionName(false);\n    compilerEnv.setIdeMode(config.isIdeMode);\n    compilerEnv.setRecoverFromErrors(config.isIdeMode);\n\n    Parser p = new Parser(compilerEnv, errorReporter);\n    AstRoot astRoot = null;\n    try {\n      astRoot = p.parse(sourceString, sourceFile.getName(), 1);\n    } catch (EvaluatorException e) {\n      logger.info(\n          \"Error parsing \" + sourceFile.getName() + \": \" + e.getMessage());\n    } finally {\n      Context.exit();\n    }\n    Node root = null;\n    if (astRoot != null) {\n      root = IRFactory.transformTree(\n          astRoot, sourceFile, sourceString, config, errorReporter);\n      root.setIsSyntheticBlock(true);\n    }\n    return root;\n  }",
    "comment": " Parses the JavaScript text given by a reader.  @param sourceString Source code from the file. @param errorReporter An error. @param logger A logger. @return The AST of the given text. @throws IOException ",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 0
  },
  {
    "name": "TypeSafeDispatcher.process",
    "class_name": "com.google.javascript.jscomp.parsing.TypeSafeDispatcher",
    "signature": "com.google.javascript.jscomp.parsing.TypeSafeDispatcher.process(AstNode)",
    "snippet": "  public T process(AstNode node) {\n    switch (node.getType()) {\n      case Token.ADD:\n      case Token.AND:\n      case Token.BITAND:\n      case Token.BITOR:\n      case Token.BITXOR:\n      case Token.COMMA:\n      case Token.DIV:\n      case Token.EQ:\n      case Token.GE:\n      case Token.GT:\n      case Token.IN:\n      case Token.INSTANCEOF:\n      case Token.LE:\n      case Token.LSH:\n      case Token.LT:\n      case Token.MOD:\n      case Token.MUL:\n      case Token.NE:\n      case Token.OR:\n      case Token.RSH:\n      case Token.SHEQ:\n      case Token.SHNE:\n      case Token.SUB:\n      case Token.URSH:\n        return processInfixExpression((InfixExpression) node);\n      case Token.ARRAYLIT:\n        return processArrayLiteral((ArrayLiteral) node);\n      case Token.ASSIGN:\n      case Token.ASSIGN_ADD:\n      case Token.ASSIGN_BITAND:\n      case Token.ASSIGN_BITOR:\n      case Token.ASSIGN_BITXOR:\n      case Token.ASSIGN_DIV:\n      case Token.ASSIGN_LSH:\n      case Token.ASSIGN_MOD:\n      case Token.ASSIGN_MUL:\n      case Token.ASSIGN_RSH:\n      case Token.ASSIGN_SUB:\n      case Token.ASSIGN_URSH:\n        return processAssignment((Assignment) node);\n      case Token.BITNOT:\n      case Token.DEC:\n      case Token.DELPROP:\n      case Token.INC:\n      case Token.NEG:\n      case Token.NOT:\n      case Token.POS:\n      case Token.TYPEOF:\n      case Token.VOID:\n        return processUnaryExpression((UnaryExpression) node);\n      case Token.BLOCK:\n        if (node instanceof Block) {\n          return processBlock((Block) node);\n        } else  if (node instanceof Scope) {\n          return processScope((Scope) node);\n        } else {\n          throw new IllegalStateException(\"Unexpected node type.  class: \" +\n                                          node.getClass() +\n                                          \" type: \" +\n                                          Token.typeToName(node.getType()));\n        }\n      case Token.BREAK:\n        return processBreakStatement((BreakStatement) node);\n      case Token.CALL:\n        return processFunctionCall((FunctionCall) node);\n      case Token.CASE:\n      case Token.DEFAULT:\n        return processSwitchCase((SwitchCase) node);\n      case Token.CATCH:\n        return processCatchClause((CatchClause) node);\n      case Token.COLON:\n        return processObjectProperty((ObjectProperty) node);\n      case Token.CONTINUE:\n        return processContinueStatement((ContinueStatement) node);\n      case Token.DO:\n        return processDoLoop((DoLoop) node);\n      case Token.EMPTY:\n        return (node instanceof EmptyExpression) ?\n            processEmptyExpression((EmptyExpression) node) :\n            processEmptyStatement((EmptyStatement) node);\n      case Token.EXPR_RESULT:\n      case Token.EXPR_VOID:\n        if (node instanceof ExpressionStatement) {\n          return processExpressionStatement((ExpressionStatement) node);\n        } else  if (node instanceof LabeledStatement) {\n          return processLabeledStatement((LabeledStatement) node);\n        } else {\n          throw new IllegalStateException(\"Unexpected node type.  class: \" +\n                                          node.getClass() +\n                                          \" type: \" +\n                                          Token.typeToName(node.getType()));\n        }\n      case Token.DEBUGGER:\n      case Token.FALSE:\n      case Token.NULL:\n      case Token.THIS:\n      case Token.TRUE:\n        return processKeywordLiteral((KeywordLiteral) node);\n      case Token.FOR:\n        if (node instanceof ForInLoop) {\n          return processForInLoop((ForInLoop) node);\n        } else  if (node instanceof ForLoop) {\n          return processForLoop((ForLoop) node);\n        } else {\n          throw new IllegalStateException(\"Unexpected node type.  class: \" +\n                                          node.getClass() +\n                                          \" type: \" +\n                                          Token.typeToName(node.getType()));\n        }\n      case Token.FUNCTION:\n        return processFunctionNode((FunctionNode) node);\n      case Token.GETELEM:\n        return processElementGet((ElementGet) node);\n      case Token.GETPROP:\n        return processPropertyGet((PropertyGet) node);\n      case Token.HOOK:\n        return processConditionalExpression((ConditionalExpression) node);\n      case Token.IF:\n        return processIfStatement((IfStatement) node);\n      case Token.LABEL:\n        return processLabel((Label) node);\n      case Token.LP:\n        return processParenthesizedExpression((ParenthesizedExpression) node);\n      case Token.NAME:\n        return processName((Name) node);\n      case Token.NEW:\n        return processNewExpression((NewExpression) node);\n      case Token.NUMBER:\n        return processNumberLiteral((NumberLiteral) node);\n      case Token.OBJECTLIT:\n        return processObjectLiteral((ObjectLiteral) node);\n      case Token.REGEXP:\n        return processRegExpLiteral((RegExpLiteral) node);\n      case Token.RETURN:\n        return processReturnStatement((ReturnStatement) node);\n      case Token.SCRIPT:\n        return processAstRoot((AstRoot) node);\n      case Token.STRING:\n        return processStringLiteral((StringLiteral) node);\n      case Token.SWITCH:\n        return processSwitchStatement((SwitchStatement) node);\n      case Token.THROW:\n        return processThrowStatement((ThrowStatement) node);\n      case Token.TRY:\n        return processTryStatement((TryStatement) node);\n      case Token.CONST:\n      case Token.VAR:\n        if (node instanceof VariableDeclaration) {\n          return processVariableDeclaration((VariableDeclaration) node);\n        } else  if (node instanceof VariableInitializer) {\n          return processVariableInitializer((VariableInitializer) node);\n        } else {\n          throw new IllegalStateException(\"Unexpected node type.  class: \" +\n                                          node.getClass() +\n                                          \" type: \" +\n                                          Token.typeToName(node.getType()));\n        }\n      case Token.WHILE:\n        return processWhileLoop((WhileLoop) node);\n      case Token.WITH:\n        return processWithStatement((WithStatement) node);\n    }\n    return processIllegalToken(node);\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 0
  },
  {
    "name": "IR.number",
    "class_name": "com.google.javascript.rhino.IR",
    "signature": "com.google.javascript.rhino.IR.number(double)",
    "snippet": "  public static Node number(double d) {\n    return Node.newNumber(d);\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 0
  },
  {
    "name": "InputId.InputId",
    "class_name": "com.google.javascript.rhino.InputId",
    "signature": "com.google.javascript.rhino.InputId.InputId(String)",
    "snippet": "  public InputId(String id) {\n    this.id = id;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 0
  },
  {
    "name": "InputId.hashCode",
    "class_name": "com.google.javascript.rhino.InputId",
    "signature": "com.google.javascript.rhino.InputId.hashCode()",
    "snippet": "  @Override\n  public int hashCode() {\n    return id.hashCode();\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 0
  },
  {
    "name": "Node.Node",
    "class_name": "com.google.javascript.rhino.Node",
    "signature": "com.google.javascript.rhino.Node.Node(int)",
    "snippet": "  public Node(int nodeType) {\n    type = nodeType;\n    parent = null;\n    sourcePosition = -1;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 0
  },
  {
    "name": "Node.addChildToBack",
    "class_name": "com.google.javascript.rhino.Node",
    "signature": "com.google.javascript.rhino.Node.addChildToBack(Node)",
    "snippet": "  public void addChildToBack(Node child) {\n    Preconditions.checkArgument(child.parent == null);\n    Preconditions.checkArgument(child.next == null);\n    child.parent = this;\n    child.next = null;\n    if (last == null) {\n      first = last = child;\n      return;\n    }\n    last.next = child;\n    last = child;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 0
  },
  {
    "name": "Node.clonePropsFrom",
    "class_name": "com.google.javascript.rhino.Node",
    "signature": "com.google.javascript.rhino.Node.clonePropsFrom(Node)",
    "snippet": "  public Node clonePropsFrom(Node other) {\n    Preconditions.checkState(this.propListHead == null,\n        \"Node has existing properties.\");\n    this.propListHead = other.propListHead;\n    return this;\n  }",
    "comment": " Clone the properties from the provided node without copying the property object.  The recieving node may not have any existing properties. @param other The node to clone properties from. @return this node. ",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 0
  },
  {
    "name": "Node.createProp",
    "class_name": "com.google.javascript.rhino.Node",
    "signature": "com.google.javascript.rhino.Node.createProp(int,Object,PropListItem)",
    "snippet": "  PropListItem createProp(int propType, Object value, PropListItem next) {\n    return new ObjectPropListItem(propType, value, next);\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 0
  },
  {
    "name": "Node.createProp",
    "class_name": "com.google.javascript.rhino.Node",
    "signature": "com.google.javascript.rhino.Node.createProp(int,int,PropListItem)",
    "snippet": "  PropListItem createProp(int propType, int value, PropListItem next) {\n    return new IntPropListItem(propType, value, next);\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 0
  },
  {
    "name": "Node.extractCharno",
    "class_name": "com.google.javascript.rhino.Node",
    "signature": "com.google.javascript.rhino.Node.extractCharno(int)",
    "snippet": "  protected static int extractCharno(int lineCharNo) {\n    if (lineCharNo == -1) {\n      return -1;\n    } else {\n      return lineCharNo & COLUMN_MASK;\n    }\n  }",
    "comment": " Extracts the character number and character number from a merged line char number (see {@link #mergeLineCharNo(int, int)}). ",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 0
  },
  {
    "name": "Node.extractLineno",
    "class_name": "com.google.javascript.rhino.Node",
    "signature": "com.google.javascript.rhino.Node.extractLineno(int)",
    "snippet": "  protected static int extractLineno(int lineCharNo) {\n    if (lineCharNo == -1) {\n      return -1;\n    } else {\n      return lineCharNo >>> COLUMN_BITS;\n    }\n  }",
    "comment": " Extracts the line number and character number from a merged line char number (see {@link #mergeLineCharNo(int, int)}). ",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 0
  },
  {
    "name": "Node.getCharno",
    "class_name": "com.google.javascript.rhino.Node",
    "signature": "com.google.javascript.rhino.Node.getCharno()",
    "snippet": "  public int getCharno() {\n    return extractCharno(sourcePosition);\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 0
  },
  {
    "name": "Node.getChildCount",
    "class_name": "com.google.javascript.rhino.Node",
    "signature": "com.google.javascript.rhino.Node.getChildCount()",
    "snippet": "  public int getChildCount() {\n    int c = 0;\n    for (Node n = first; n != null; n = n.next)\n      c++;\n\n    return c;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 0
  },
  {
    "name": "Node.getFirstChild",
    "class_name": "com.google.javascript.rhino.Node",
    "signature": "com.google.javascript.rhino.Node.getFirstChild()",
    "snippet": "  public Node getFirstChild() {\n    return first;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 0
  },
  {
    "name": "Node.getInputId",
    "class_name": "com.google.javascript.rhino.Node",
    "signature": "com.google.javascript.rhino.Node.getInputId()",
    "snippet": "  public InputId getInputId() {\n    return ((InputId) this.getProp(INPUT_ID));\n  }",
    "comment": " @return The Id of the CompilerInput associated with this Node. ",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 0
  },
  {
    "name": "Node.getJSDocInfo",
    "class_name": "com.google.javascript.rhino.Node",
    "signature": "com.google.javascript.rhino.Node.getJSDocInfo()",
    "snippet": "  public JSDocInfo getJSDocInfo() {\n    return (JSDocInfo) getProp(JSDOC_INFO_PROP);\n  }",
    "comment": " Get the {@link JSDocInfo} attached to this node. @return the information or {@code null} if no JSDoc is attached to this node ",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 0
  },
  {
    "name": "Node.getJsDocBuilderForNode",
    "class_name": "com.google.javascript.rhino.Node",
    "signature": "com.google.javascript.rhino.Node.getJsDocBuilderForNode()",
    "snippet": "  public FileLevelJsDocBuilder getJsDocBuilderForNode() {\n    return new FileLevelJsDocBuilder();\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 0
  },
  {
    "name": "Node.getLastChild",
    "class_name": "com.google.javascript.rhino.Node",
    "signature": "com.google.javascript.rhino.Node.getLastChild()",
    "snippet": "  public Node getLastChild() {\n    return last;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 0
  },
  {
    "name": "Node.getLineno",
    "class_name": "com.google.javascript.rhino.Node",
    "signature": "com.google.javascript.rhino.Node.getLineno()",
    "snippet": "  public int getLineno() {\n    return extractLineno(sourcePosition);\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 0
  },
  {
    "name": "Node.getNext",
    "class_name": "com.google.javascript.rhino.Node",
    "signature": "com.google.javascript.rhino.Node.getNext()",
    "snippet": "  public Node getNext() {\n    return next;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 0
  },
  {
    "name": "Node.getProp",
    "class_name": "com.google.javascript.rhino.Node",
    "signature": "com.google.javascript.rhino.Node.getProp(int)",
    "snippet": "  public Object getProp(int propType) {\n    if (propType == SOURCENAME_PROP) {\n      return getSourceFileName();\n    }\n\n    PropListItem item = lookupProperty(propType);\n    if (item == null) {\n      return null;\n    }\n    return item.getObjectValue();\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 0
  },
  {
    "name": "Node.getSourceFileName",
    "class_name": "com.google.javascript.rhino.Node",
    "signature": "com.google.javascript.rhino.Node.getSourceFileName()",
    "snippet": "  public String getSourceFileName() {\n    StaticSourceFile file = getStaticSourceFile();\n    return file == null ? null : file.getName();\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 0
  },
  {
    "name": "Node.getStaticSourceFile",
    "class_name": "com.google.javascript.rhino.Node",
    "signature": "com.google.javascript.rhino.Node.getStaticSourceFile()",
    "snippet": "  public StaticSourceFile getStaticSourceFile() {\n    return ((StaticSourceFile) this.getProp(STATIC_SOURCE_FILE));\n  }",
    "comment": "Returns the source file associated with this input. May be null */",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 0
  },
  {
    "name": "Node.getType",
    "class_name": "com.google.javascript.rhino.Node",
    "signature": "com.google.javascript.rhino.Node.getType()",
    "snippet": "  public int getType() {\n    return type;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 0
  },
  {
    "name": "Node.isFunction",
    "class_name": "com.google.javascript.rhino.Node",
    "signature": "com.google.javascript.rhino.Node.isFunction()",
    "snippet": "  public boolean isFunction() {\n    return this.getType() == Token.FUNCTION;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 0
  },
  {
    "name": "Node.isObjectLit",
    "class_name": "com.google.javascript.rhino.Node",
    "signature": "com.google.javascript.rhino.Node.isObjectLit()",
    "snippet": "  public boolean isObjectLit() {\n    return this.getType() == Token.OBJECTLIT;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 0
  },
  {
    "name": "Node.isScript",
    "class_name": "com.google.javascript.rhino.Node",
    "signature": "com.google.javascript.rhino.Node.isScript()",
    "snippet": "  public boolean isScript() {\n    return this.getType() == Token.SCRIPT;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 0
  },
  {
    "name": "Node.isString",
    "class_name": "com.google.javascript.rhino.Node",
    "signature": "com.google.javascript.rhino.Node.isString()",
    "snippet": "  public boolean isString() {\n    return this.getType() == Token.STRING;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 0
  },
  {
    "name": "Node.isVar",
    "class_name": "com.google.javascript.rhino.Node",
    "signature": "com.google.javascript.rhino.Node.isVar()",
    "snippet": "  public boolean isVar() {\n    return this.getType() == Token.VAR;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 0
  },
  {
    "name": "Node.lookupProperty",
    "class_name": "com.google.javascript.rhino.Node",
    "signature": "com.google.javascript.rhino.Node.lookupProperty(int)",
    "snippet": "  @VisibleForTesting\n  PropListItem lookupProperty(int propType) {\n    PropListItem x = propListHead;\n    while (x != null && propType != x.getType()) {\n      x = x.getNext();\n    }\n    return x;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 0
  },
  {
    "name": "Node.mergeLineCharNo",
    "class_name": "com.google.javascript.rhino.Node",
    "signature": "com.google.javascript.rhino.Node.mergeLineCharNo(int,int)",
    "snippet": "  protected static int mergeLineCharNo(int lineno, int charno) {\n    if (lineno < 0 || charno < 0) {\n      return -1;\n    } else if ((charno & ~COLUMN_MASK) != 0) {\n      return lineno << COLUMN_BITS | COLUMN_MASK;\n    } else {\n      return lineno << COLUMN_BITS | (charno & COLUMN_MASK);\n    }\n  }",
    "comment": " Merges the line number and character number in one integer. The Character number takes the first 12 bits and the line number takes the rest. If the character number is greater than <code>2<sup>12</sup>-1</code> it is adjusted to <code>2<sup>12</sup>-1</code>. ",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 0
  },
  {
    "name": "Node.newNumber",
    "class_name": "com.google.javascript.rhino.Node",
    "signature": "com.google.javascript.rhino.Node.newNumber(double)",
    "snippet": "  public static Node newNumber(double number) {\n    return new NumberNode(number);\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 0
  },
  {
    "name": "Node.putBooleanProp",
    "class_name": "com.google.javascript.rhino.Node",
    "signature": "com.google.javascript.rhino.Node.putBooleanProp(int,boolean)",
    "snippet": "  public void putBooleanProp(int propType, boolean value) {\n    putIntProp(propType, value ? 1 : 0);\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 0
  },
  {
    "name": "Node.putIntProp",
    "class_name": "com.google.javascript.rhino.Node",
    "signature": "com.google.javascript.rhino.Node.putIntProp(int,int)",
    "snippet": "  public void putIntProp(int propType, int value) {\n    removeProp(propType);\n    if (value != 0) {\n      propListHead = createProp(propType, value, propListHead);\n    }\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 0
  },
  {
    "name": "Node.putProp",
    "class_name": "com.google.javascript.rhino.Node",
    "signature": "com.google.javascript.rhino.Node.putProp(int,Object)",
    "snippet": "  public void putProp(int propType, Object value) {\n    if (propType == SOURCENAME_PROP) {\n      putProp(\n          STATIC_SOURCE_FILE, new SimpleSourceFile((String) value, false));\n      return;\n    }\n\n    removeProp(propType);\n    if (value != null) {\n      propListHead = createProp(propType, value, propListHead);\n    }\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 0
  },
  {
    "name": "Node.removeProp",
    "class_name": "com.google.javascript.rhino.Node",
    "signature": "com.google.javascript.rhino.Node.removeProp(PropListItem,int)",
    "snippet": "  private PropListItem removeProp(PropListItem item, int propType) {\n    if (item == null) {\n      return null;\n    } else if (item.getType() == propType) {\n      return item.getNext();\n    } else {\n      PropListItem result = removeProp(item.getNext(), propType);\n      if (result != item.getNext()) {\n        return item.chain(result);\n      } else {\n        return item;\n      }\n    }\n  }",
    "comment": " @param item The item to inspect @param propType The property to look for @return The replacement list if the property was removed, or 'item' otherwise. ",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 0
  },
  {
    "name": "Node.removeProp",
    "class_name": "com.google.javascript.rhino.Node",
    "signature": "com.google.javascript.rhino.Node.removeProp(int)",
    "snippet": "  public void removeProp(int propType) {\n    PropListItem result = removeProp(propListHead, propType);\n    if (result != propListHead) {\n      propListHead = result;\n    }\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 0
  },
  {
    "name": "Node.setCharno",
    "class_name": "com.google.javascript.rhino.Node",
    "signature": "com.google.javascript.rhino.Node.setCharno(int)",
    "snippet": "  public void setCharno(int charno) {\n      sourcePosition = mergeLineCharNo(getLineno(), charno);\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 0
  },
  {
    "name": "Node.setInputId",
    "class_name": "com.google.javascript.rhino.Node",
    "signature": "com.google.javascript.rhino.Node.setInputId(InputId)",
    "snippet": "  public void setInputId(InputId inputId) {\n    this.putProp(INPUT_ID, inputId);\n  }",
    "comment": " @param inputId ",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 0
  },
  {
    "name": "Node.setIsSyntheticBlock",
    "class_name": "com.google.javascript.rhino.Node",
    "signature": "com.google.javascript.rhino.Node.setIsSyntheticBlock(boolean)",
    "snippet": "  public void setIsSyntheticBlock(boolean val) {\n    putBooleanProp(SYNTHETIC_BLOCK_PROP, val);\n  }",
    "comment": " Sets whether this is a synthetic block that should not be considered a real source block. ",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 0
  },
  {
    "name": "Node.setLineno",
    "class_name": "com.google.javascript.rhino.Node",
    "signature": "com.google.javascript.rhino.Node.setLineno(int)",
    "snippet": "  public void setLineno(int lineno) {\n      int charno = getCharno();\n      if (charno == -1) {\n        charno = 0;\n      }\n      sourcePosition = mergeLineCharNo(lineno, charno);\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 0
  },
  {
    "name": "Node.setStaticSourceFile",
    "class_name": "com.google.javascript.rhino.Node",
    "signature": "com.google.javascript.rhino.Node.setStaticSourceFile(StaticSourceFile)",
    "snippet": "  public void setStaticSourceFile(StaticSourceFile file) {\n    this.putProp(STATIC_SOURCE_FILE, file);\n  }",
    "comment": "Source position management",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 0
  },
  {
    "name": "AbstractPropListItem.getNext",
    "class_name": "com.google.javascript.rhino.Node$AbstractPropListItem",
    "signature": "com.google.javascript.rhino.Node$AbstractPropListItem.getNext()",
    "snippet": "    @Override\n    public PropListItem getNext() {\n      return next;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 0
  },
  {
    "name": "AbstractPropListItem.getType",
    "class_name": "com.google.javascript.rhino.Node$AbstractPropListItem",
    "signature": "com.google.javascript.rhino.Node$AbstractPropListItem.getType()",
    "snippet": "    @Override\n    public int getType() {\n      return propType;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 0
  },
  {
    "name": "IntPropListItem.chain",
    "class_name": "com.google.javascript.rhino.Node$IntPropListItem",
    "signature": "com.google.javascript.rhino.Node$IntPropListItem.chain(PropListItem)",
    "snippet": "    @Override\n    public PropListItem chain(PropListItem next) {\n      return new IntPropListItem(getType(), intValue, next);\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 0
  },
  {
    "name": "NumberNode.getDouble",
    "class_name": "com.google.javascript.rhino.Node$NumberNode",
    "signature": "com.google.javascript.rhino.Node$NumberNode.getDouble()",
    "snippet": "    @Override\n    public double getDouble() {\n      return this.number;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 0
  },
  {
    "name": "ObjectPropListItem.getObjectValue",
    "class_name": "com.google.javascript.rhino.Node$ObjectPropListItem",
    "signature": "com.google.javascript.rhino.Node$ObjectPropListItem.getObjectValue()",
    "snippet": "    @Override\n    public Object getObjectValue() {\n      return objectValue;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 0
  },
  {
    "name": "ScriptRuntime.getMessage",
    "class_name": "com.google.javascript.rhino.ScriptRuntime",
    "signature": "com.google.javascript.rhino.ScriptRuntime.getMessage(String,Object[])",
    "snippet": "    public static String getMessage(String messageId, Object[] arguments) {\n        final String defaultResource\n            = \"rhino_ast.java.com.google.javascript.rhino.Messages\";\n\n        Locale locale = Locale.getDefault();\n\n        // ResourceBundle does cacheing.\n        ResourceBundle rb = ResourceBundle.getBundle(defaultResource, locale);\n\n        String formatString;\n        try {\n            formatString = rb.getString(messageId);\n        } catch (java.util.MissingResourceException mre) {\n            throw new RuntimeException\n                (\"no message resource found for message property \"+ messageId);\n        }\n\n        /*\n         * It's OK to format the string, even if 'arguments' is null;\n         * we need to format it anyway, to make double ''s collapse to\n         * single 's.\n         */\n        // TODO: MessageFormat is not available on pJava\n        MessageFormat formatter = new MessageFormat(formatString);\n        return formatter.format(arguments);\n    }",
    "comment": "OPT there's a noticable delay for the first error!  Maybe it'd make sense to use a ListResourceBundle instead of a properties file to avoid (synchronized) text parsing. ",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 0
  },
  {
    "name": "ScriptRuntime.getMessage0",
    "class_name": "com.google.javascript.rhino.ScriptRuntime",
    "signature": "com.google.javascript.rhino.ScriptRuntime.getMessage0(String)",
    "snippet": "    public static String getMessage0(String messageId) {\n        return getMessage(messageId, null);\n    }",
    "comment": "------------------",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 0
  },
  {
    "name": "Token.name",
    "class_name": "com.google.javascript.rhino.Token",
    "signature": "com.google.javascript.rhino.Token.name(int)",
    "snippet": "  public static String name(int token) {\n        switch (token) {\n          case ERROR:           return \"ERROR\";\n          case RETURN:          return \"RETURN\";\n          case BITOR:           return \"BITOR\";\n          case BITXOR:          return \"BITXOR\";\n          case BITAND:          return \"BITAND\";\n          case EQ:              return \"EQ\";\n          case NE:              return \"NE\";\n          case LT:              return \"LT\";\n          case LE:              return \"LE\";\n          case GT:              return \"GT\";\n          case GE:              return \"GE\";\n          case LSH:             return \"LSH\";\n          case RSH:             return \"RSH\";\n          case URSH:            return \"URSH\";\n          case ADD:             return \"ADD\";\n          case SUB:             return \"SUB\";\n          case MUL:             return \"MUL\";\n          case DIV:             return \"DIV\";\n          case MOD:             return \"MOD\";\n          case NOT:             return \"NOT\";\n          case BITNOT:          return \"BITNOT\";\n          case POS:             return \"POS\";\n          case NEG:             return \"NEG\";\n          case NEW:             return \"NEW\";\n          case DELPROP:         return \"DELPROP\";\n          case TYPEOF:          return \"TYPEOF\";\n          case GETPROP:         return \"GETPROP\";\n          case GETELEM:         return \"GETELEM\";\n          case CALL:            return \"CALL\";\n          case NAME:            return \"NAME\";\n          case LABEL_NAME:      return \"LABEL_NAME\";\n          case NUMBER:          return \"NUMBER\";\n          case STRING:          return \"STRING\";\n          case STRING_KEY:      return \"STRING_KEY\";\n          case NULL:            return \"NULL\";\n          case THIS:            return \"THIS\";\n          case FALSE:           return \"FALSE\";\n          case TRUE:            return \"TRUE\";\n          case SHEQ:            return \"SHEQ\";\n          case SHNE:            return \"SHNE\";\n          case REGEXP:          return \"REGEXP\";\n          case THROW:           return \"THROW\";\n          case IN:              return \"IN\";\n          case INSTANCEOF:      return \"INSTANCEOF\";\n          case ARRAYLIT:        return \"ARRAYLIT\";\n          case OBJECTLIT:       return \"OBJECTLIT\";\n          case TRY:             return \"TRY\";\n          case PARAM_LIST:      return \"PARAM_LIST\";\n          case COMMA:           return \"COMMA\";\n          case ASSIGN:          return \"ASSIGN\";\n          case ASSIGN_BITOR:    return \"ASSIGN_BITOR\";\n          case ASSIGN_BITXOR:   return \"ASSIGN_BITXOR\";\n          case ASSIGN_BITAND:   return \"ASSIGN_BITAND\";\n          case ASSIGN_LSH:      return \"ASSIGN_LSH\";\n          case ASSIGN_RSH:      return \"ASSIGN_RSH\";\n          case ASSIGN_URSH:     return \"ASSIGN_URSH\";\n          case ASSIGN_ADD:      return \"ASSIGN_ADD\";\n          case ASSIGN_SUB:      return \"ASSIGN_SUB\";\n          case ASSIGN_MUL:      return \"ASSIGN_MUL\";\n          case ASSIGN_DIV:      return \"ASSIGN_DIV\";\n          case ASSIGN_MOD:      return \"ASSIGN_MOD\";\n          case HOOK:            return \"HOOK\";\n          case COLON:           return \"COLON\";\n          case OR:              return \"OR\";\n          case AND:             return \"AND\";\n          case INC:             return \"INC\";\n          case DEC:             return \"DEC\";\n          case FUNCTION:        return \"FUNCTION\";\n          case IF:              return \"IF\";\n          case SWITCH:          return \"SWITCH\";\n          case CASE:            return \"CASE\";\n          case DEFAULT_CASE:    return \"DEFAULT_CASE\";\n          case WHILE:           return \"WHILE\";\n          case DO:              return \"DO\";\n          case FOR:             return \"FOR\";\n          case BREAK:           return \"BREAK\";\n          case CONTINUE:        return \"CONTINUE\";\n          case VAR:             return \"VAR\";\n          case WITH:            return \"WITH\";\n          case CATCH:           return \"CATCH\";\n          case EMPTY:           return \"EMPTY\";\n          case BLOCK:           return \"BLOCK\";\n          case LABEL:           return \"LABEL\";\n          case EXPR_RESULT:     return \"EXPR_RESULT\";\n          case SCRIPT:          return \"SCRIPT\";\n          case GETTER_DEF:      return \"GETTER_DEF\";\n          case SETTER_DEF:      return \"SETTER_DEF\";\n          case CONST:           return \"CONST\";\n          case DEBUGGER:        return \"DEBUGGER\";\n          case ANNOTATION:      return \"ANNOTATION\";\n          case PIPE:            return \"PIPE\";\n          case STAR:            return \"STAR\";\n          case EOC:             return \"EOC\";\n          case QMARK:           return \"QMARK\";\n          case ELLIPSIS:        return \"ELLIPSIS\";\n          case BANG:            return \"BANG\";\n          case VOID:            return \"VOID\";\n          case EQUALS:          return \"EQUALS\";\n        }\n\n        // Token without name\n        throw new IllegalStateException(String.valueOf(token));\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 0
  },
  {
    "name": "AllType.AllType",
    "class_name": "com.google.javascript.rhino.jstype.AllType",
    "signature": "com.google.javascript.rhino.jstype.AllType.AllType(JSTypeRegistry)",
    "snippet": "  AllType(JSTypeRegistry registry) {\n    super(registry);\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 0
  },
  {
    "name": "AllType.isAllType",
    "class_name": "com.google.javascript.rhino.jstype.AllType",
    "signature": "com.google.javascript.rhino.jstype.AllType.isAllType()",
    "snippet": "  @Override\n  public boolean isAllType() {\n    return true;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 0
  },
  {
    "name": "ArrowType.ArrowType",
    "class_name": "com.google.javascript.rhino.jstype.ArrowType",
    "signature": "com.google.javascript.rhino.jstype.ArrowType.ArrowType(JSTypeRegistry,Node,JSType)",
    "snippet": "  ArrowType(JSTypeRegistry registry, Node parameters,\n      JSType returnType) {\n    this(registry, parameters, returnType, false);\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 0
  },
  {
    "name": "ArrowType.ArrowType",
    "class_name": "com.google.javascript.rhino.jstype.ArrowType",
    "signature": "com.google.javascript.rhino.jstype.ArrowType.ArrowType(JSTypeRegistry,Node,JSType,boolean)",
    "snippet": "  ArrowType(JSTypeRegistry registry, Node parameters,\n      JSType returnType, boolean returnTypeInferred) {\n    super(registry);\n\n    this.parameters = parameters == null ?\n        registry.createParametersWithVarArgs(getNativeType(UNKNOWN_TYPE)) :\n        parameters;\n    this.returnType = returnType == null ?\n        getNativeType(UNKNOWN_TYPE) : returnType;\n    this.returnTypeInferred = returnTypeInferred;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 0
  },
  {
    "name": "BooleanType.BooleanType",
    "class_name": "com.google.javascript.rhino.jstype.BooleanType",
    "signature": "com.google.javascript.rhino.jstype.BooleanType.BooleanType(JSTypeRegistry)",
    "snippet": "  BooleanType(JSTypeRegistry registry) {\n    super(registry);\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 0
  },
  {
    "name": "BooleanType.getDisplayName",
    "class_name": "com.google.javascript.rhino.jstype.BooleanType",
    "signature": "com.google.javascript.rhino.jstype.BooleanType.getDisplayName()",
    "snippet": "  @Override\n  public String getDisplayName() {\n    return \"boolean\";\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 0
  },
  {
    "name": "BooleanType.toStringHelper",
    "class_name": "com.google.javascript.rhino.jstype.BooleanType",
    "signature": "com.google.javascript.rhino.jstype.BooleanType.toStringHelper(boolean)",
    "snippet": "  @Override\n  String toStringHelper(boolean forAnnotations) {\n    return getDisplayName();\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 0
  },
  {
    "name": "ErrorFunctionType.ErrorFunctionType",
    "class_name": "com.google.javascript.rhino.jstype.ErrorFunctionType",
    "signature": "com.google.javascript.rhino.jstype.ErrorFunctionType.ErrorFunctionType(JSTypeRegistry,String)",
    "snippet": "  ErrorFunctionType(JSTypeRegistry registry, String name) {\n    super(\n        registry, name, null,\n        registry.createArrowType(\n            registry.createOptionalParameters(\n                registry.getNativeType(ALL_TYPE),\n                registry.getNativeType(ALL_TYPE),\n                registry.getNativeType(ALL_TYPE)),\n            null),\n        null, null, true, true);\n\n    // NOTE(nicksantos): Errors have the weird behavior in that they can\n    // be called as functions, and they will return instances of themselves.\n    // Error('x') instanceof Error => true\n    //\n    // In user-defined types, we would deal with this case by creating\n    // a NamedType with the name \"Error\" and then resolve it later.\n    //\n    // For native types, we don't really want the native types to\n    // depend on type-resolution. So we just set the return type manually\n    // at the end of construction.\n    //\n    // There's similar logic in JSTypeRegistry for Array and RegExp.\n    getInternalArrowType().returnType = getInstanceType();\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 0
  },
  {
    "name": "FunctionBuilder.FunctionBuilder",
    "class_name": "com.google.javascript.rhino.jstype.FunctionBuilder",
    "signature": "com.google.javascript.rhino.jstype.FunctionBuilder.FunctionBuilder(JSTypeRegistry)",
    "snippet": "  public FunctionBuilder(JSTypeRegistry registry) {\n    this.registry = registry;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 0
  },
  {
    "name": "FunctionBuilder.build",
    "class_name": "com.google.javascript.rhino.jstype.FunctionBuilder",
    "signature": "com.google.javascript.rhino.jstype.FunctionBuilder.build()",
    "snippet": "  public FunctionType build() {\n    return new FunctionType(registry, name, sourceNode,\n        new ArrowType(registry, parametersNode, returnType, inferredReturnType),\n        typeOfThis, templateTypeName, isConstructor, isNativeType);\n  }",
    "comment": "Construct a new function type. */",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 0
  },
  {
    "name": "FunctionBuilder.withParamsNode",
    "class_name": "com.google.javascript.rhino.jstype.FunctionBuilder",
    "signature": "com.google.javascript.rhino.jstype.FunctionBuilder.withParamsNode(Node)",
    "snippet": "  public FunctionBuilder withParamsNode(Node parametersNode) {\n    this.parametersNode = parametersNode;\n    return this;\n  }",
    "comment": " Set the parameters of the function type with a specially-formatted node. ",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 0
  },
  {
    "name": "FunctionBuilder.withReturnType",
    "class_name": "com.google.javascript.rhino.jstype.FunctionBuilder",
    "signature": "com.google.javascript.rhino.jstype.FunctionBuilder.withReturnType(JSType)",
    "snippet": "  public FunctionBuilder withReturnType(JSType returnType) {\n    this.returnType = returnType;\n    return this;\n  }",
    "comment": "Set the return type. */",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 0
  },
  {
    "name": "FunctionParamBuilder.FunctionParamBuilder",
    "class_name": "com.google.javascript.rhino.jstype.FunctionParamBuilder",
    "signature": "com.google.javascript.rhino.jstype.FunctionParamBuilder.FunctionParamBuilder(JSTypeRegistry)",
    "snippet": "  public FunctionParamBuilder(JSTypeRegistry registry) {\n    this.registry = registry;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 0
  },
  {
    "name": "FunctionParamBuilder.addOptionalParams",
    "class_name": "com.google.javascript.rhino.jstype.FunctionParamBuilder",
    "signature": "com.google.javascript.rhino.jstype.FunctionParamBuilder.addOptionalParams(JSType[])",
    "snippet": "  public boolean addOptionalParams(JSType ...types) {\n    if (hasVarArgs()) {\n      return false;\n    }\n\n    for (JSType type : types) {\n      newParameter(registry.createOptionalType(type)).setOptionalArg(true);\n    }\n    return true;\n  }",
    "comment": " Add optional parameters of the given type to the end of the param list. @param types Types for each optional parameter. The builder will make them undefineable. @return False if this is called after var args are added. ",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 0
  },
  {
    "name": "FunctionParamBuilder.addRequiredParams",
    "class_name": "com.google.javascript.rhino.jstype.FunctionParamBuilder",
    "signature": "com.google.javascript.rhino.jstype.FunctionParamBuilder.addRequiredParams(JSType[])",
    "snippet": "  public boolean addRequiredParams(JSType ...types) {\n    if (hasOptionalOrVarArgs()) {\n      return false;\n    }\n\n    for (JSType type : types) {\n      newParameter(type);\n    }\n    return true;\n  }",
    "comment": " Add parameters of the given type to the end of the param list. @return False if this is called after optional params are added. ",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 0
  },
  {
    "name": "FunctionParamBuilder.addVarArgs",
    "class_name": "com.google.javascript.rhino.jstype.FunctionParamBuilder",
    "signature": "com.google.javascript.rhino.jstype.FunctionParamBuilder.addVarArgs(JSType)",
    "snippet": "  public boolean addVarArgs(JSType type) {\n    if (hasVarArgs()) {\n      return false;\n    }\n\n    // There are two types of variable argument functions:\n    // 1) Programmer-defined var args\n    // 2) Native bottom types that can accept any argument.\n    // For the first one, \"undefined\" is a valid value for all arguments.\n    // For the second, we do not want to cast it up to undefined.\n    if (!type.isEmptyType()) {\n      type = registry.createOptionalType(type);\n    }\n    newParameter(type).setVarArgs(true);\n    return true;\n  }",
    "comment": " Add variable arguments to the end of the parameter list. @return False if this is called after var args are added. ",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 0
  },
  {
    "name": "FunctionParamBuilder.build",
    "class_name": "com.google.javascript.rhino.jstype.FunctionParamBuilder",
    "signature": "com.google.javascript.rhino.jstype.FunctionParamBuilder.build()",
    "snippet": "  public Node build() {\n    return root;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 0
  },
  {
    "name": "FunctionParamBuilder.hasOptionalOrVarArgs",
    "class_name": "com.google.javascript.rhino.jstype.FunctionParamBuilder",
    "signature": "com.google.javascript.rhino.jstype.FunctionParamBuilder.hasOptionalOrVarArgs()",
    "snippet": "  private boolean hasOptionalOrVarArgs() {\n    Node lastChild = root.getLastChild();\n    return lastChild != null &&\n        (lastChild.isOptionalArg() || lastChild.isVarArgs());\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 0
  },
  {
    "name": "FunctionParamBuilder.hasVarArgs",
    "class_name": "com.google.javascript.rhino.jstype.FunctionParamBuilder",
    "signature": "com.google.javascript.rhino.jstype.FunctionParamBuilder.hasVarArgs()",
    "snippet": "  public boolean hasVarArgs() {\n    Node lastChild = root.getLastChild();\n    return lastChild != null && lastChild.isVarArgs();\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 0
  },
  {
    "name": "FunctionParamBuilder.newParameter",
    "class_name": "com.google.javascript.rhino.jstype.FunctionParamBuilder",
    "signature": "com.google.javascript.rhino.jstype.FunctionParamBuilder.newParameter(JSType)",
    "snippet": "  private Node newParameter(JSType type) {\n    Node paramNode = Node.newString(Token.NAME, \"\");\n    paramNode.setJSType(type);\n    root.addChildToBack(paramNode);\n    return paramNode;\n  }",
    "comment": "Add a parameter to the list with the given type.",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 0
  },
  {
    "name": "FunctionType.FunctionType",
    "class_name": "com.google.javascript.rhino.jstype.FunctionType",
    "signature": "com.google.javascript.rhino.jstype.FunctionType.FunctionType(JSTypeRegistry,String,Node,ArrowType,ObjectType,String,boolean,boolean)",
    "snippet": "  FunctionType(JSTypeRegistry registry, String name, Node source,\n      ArrowType arrowType, ObjectType typeOfThis,\n      String templateTypeName,  boolean isConstructor, boolean nativeType) {\n    super(registry, name,\n        registry.getNativeObjectType(JSTypeNative.FUNCTION_INSTANCE_TYPE),\n        nativeType);\n    setPrettyPrint(true);\n\n    Preconditions.checkArgument(source == null ||\n        Token.FUNCTION == source.getType());\n    Preconditions.checkNotNull(arrowType);\n    this.source = source;\n    this.kind = isConstructor ? Kind.CONSTRUCTOR : Kind.ORDINARY;\n    if (isConstructor) {\n      this.typeOfThis = typeOfThis != null ?\n          typeOfThis : new InstanceObjectType(registry, this, nativeType);\n    } else {\n      this.typeOfThis = typeOfThis != null ?\n          typeOfThis :\n          registry.getNativeObjectType(JSTypeNative.UNKNOWN_TYPE);\n    }\n    this.call = arrowType;\n    this.templateTypeName = templateTypeName;\n  }",
    "comment": "Creates an instance for a function that might be a constructor. */",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 0
  },
  {
    "name": "FunctionType.addSubType",
    "class_name": "com.google.javascript.rhino.jstype.FunctionType",
    "signature": "com.google.javascript.rhino.jstype.FunctionType.addSubType(FunctionType)",
    "snippet": "  private void addSubType(FunctionType subType) {\n    if (subTypes == null) {\n      subTypes = Lists.newArrayList();\n    }\n    subTypes.add(subType);\n  }",
    "comment": "Adds a type to the list of subtypes for this type. */",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 0
  },
  {
    "name": "FunctionType.getExtendedInterfaces",
    "class_name": "com.google.javascript.rhino.jstype.FunctionType",
    "signature": "com.google.javascript.rhino.jstype.FunctionType.getExtendedInterfaces()",
    "snippet": "  public Iterable<ObjectType> getExtendedInterfaces() {\n    return extendedInterfaces;\n  }",
    "comment": "Returns interfaces directly extended by an interface */",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 0
  },
  {
    "name": "FunctionType.getInstanceType",
    "class_name": "com.google.javascript.rhino.jstype.FunctionType",
    "signature": "com.google.javascript.rhino.jstype.FunctionType.getInstanceType()",
    "snippet": "  public ObjectType getInstanceType() {\n    Preconditions.checkState(hasInstanceType());\n    return typeOfThis;\n  }",
    "comment": " Gets the type of instance of this function. @throws IllegalStateException if this function is not a constructor (see {@link #isConstructor()}). ",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 0
  },
  {
    "name": "FunctionType.getInternalArrowType",
    "class_name": "com.google.javascript.rhino.jstype.FunctionType",
    "signature": "com.google.javascript.rhino.jstype.FunctionType.getInternalArrowType()",
    "snippet": "  ArrowType getInternalArrowType() {\n    return call;\n  }",
    "comment": "Gets the internal arrow type. For use by subclasses only. */",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 0
  },
  {
    "name": "FunctionType.getPrototype",
    "class_name": "com.google.javascript.rhino.jstype.FunctionType",
    "signature": "com.google.javascript.rhino.jstype.FunctionType.getPrototype()",
    "snippet": "  public ObjectType getPrototype() {\n    // lazy initialization of the prototype field\n    if (prototypeSlot == null) {\n      String refName = getReferenceName();\n      if (refName == null) {\n        // Someone is trying to access the prototype of a structural function.\n        // We don't want to give real properties to this prototype, because\n        // then it would propagate to all structural functions.\n        setPrototype(\n           registry.getNativeObjectType(JSTypeNative.UNKNOWN_TYPE),\n           null);\n      } else {\n        setPrototype(\n            new PrototypeObjectType(\n                registry,\n                this.getReferenceName() + \".prototype\",\n                registry.getNativeObjectType(OBJECT_TYPE),\n                isNativeObjectType()),\n            null);\n      }\n    }\n    return (ObjectType) prototypeSlot.getType();\n  }",
    "comment": " Gets the {@code prototype} property of this function type. This is equivalent to {@code (ObjectType) getPropertyType(\"prototype\")}. ",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 0
  },
  {
    "name": "FunctionType.getSuperClassConstructor",
    "class_name": "com.google.javascript.rhino.jstype.FunctionType",
    "signature": "com.google.javascript.rhino.jstype.FunctionType.getSuperClassConstructor()",
    "snippet": "  public FunctionType getSuperClassConstructor() {\n    Preconditions.checkArgument(isConstructor() || isInterface());\n    ObjectType maybeSuperInstanceType = getPrototype().getImplicitPrototype();\n    if (maybeSuperInstanceType == null) {\n      return null;\n    }\n    return maybeSuperInstanceType.getConstructor();\n  }",
    "comment": " Given a constructor or an interface type, get its superclass constructor or {@code null} if none exists. ",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 0
  },
  {
    "name": "FunctionType.hasCachedValues",
    "class_name": "com.google.javascript.rhino.jstype.FunctionType",
    "signature": "com.google.javascript.rhino.jstype.FunctionType.hasCachedValues()",
    "snippet": "  @Override\n  public boolean hasCachedValues() {\n    return prototypeSlot != null || super.hasCachedValues();\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 0
  },
  {
    "name": "FunctionType.hasInstanceType",
    "class_name": "com.google.javascript.rhino.jstype.FunctionType",
    "signature": "com.google.javascript.rhino.jstype.FunctionType.hasInstanceType()",
    "snippet": "  public boolean hasInstanceType() {\n    return isConstructor() || isInterface();\n  }",
    "comment": " Returns whether this function type has an instance type. ",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 0
  },
  {
    "name": "FunctionType.isConstructor",
    "class_name": "com.google.javascript.rhino.jstype.FunctionType",
    "signature": "com.google.javascript.rhino.jstype.FunctionType.isConstructor()",
    "snippet": "  @Override\n  public boolean isConstructor() {\n    return kind == Kind.CONSTRUCTOR;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 0
  },
  {
    "name": "FunctionType.isInterface",
    "class_name": "com.google.javascript.rhino.jstype.FunctionType",
    "signature": "com.google.javascript.rhino.jstype.FunctionType.isInterface()",
    "snippet": "  @Override\n  public boolean isInterface() {\n    return kind == Kind.INTERFACE;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 0
  },
  {
    "name": "FunctionType.setInstanceType",
    "class_name": "com.google.javascript.rhino.jstype.FunctionType",
    "signature": "com.google.javascript.rhino.jstype.FunctionType.setInstanceType(ObjectType)",
    "snippet": "  void setInstanceType(ObjectType instanceType) {\n    typeOfThis = instanceType;\n  }",
    "comment": " Sets the instance type. This should only be used for special native types. ",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 0
  },
  {
    "name": "FunctionType.setPrototype",
    "class_name": "com.google.javascript.rhino.jstype.FunctionType",
    "signature": "com.google.javascript.rhino.jstype.FunctionType.setPrototype(ObjectType,Node)",
    "snippet": "  boolean setPrototype(ObjectType prototype, Node propertyNode) {\n    if (prototype == null) {\n      return false;\n    }\n    // getInstanceType fails if the function is not a constructor\n    if (isConstructor() && prototype == getInstanceType()) {\n      return false;\n    }\n\n    ObjectType oldPrototype = prototypeSlot == null\n        ? null : (ObjectType) prototypeSlot.getType();\n    boolean replacedPrototype = oldPrototype != null;\n\n    this.prototypeSlot = new Property(\"prototype\", prototype, true,\n        propertyNode == null ? source : propertyNode);\n    prototype.setOwnerFunction(this);\n\n    if (oldPrototype != null) {\n      // Disassociating the old prototype makes this easier to debug--\n      // we don't have to worry about two prototypes running around.\n      oldPrototype.setOwnerFunction(null);\n    }\n\n    if (isConstructor() || isInterface()) {\n      FunctionType superClass = getSuperClassConstructor();\n      if (superClass != null) {\n        superClass.addSubType(this);\n      }\n\n      if (isInterface()) {\n        for (ObjectType interfaceType : getExtendedInterfaces()) {\n          if (interfaceType.getConstructor() != null) {\n            interfaceType.getConstructor().addSubType(this);\n          }\n        }\n      }\n    }\n\n    if (replacedPrototype) {\n      clearCachedValues();\n    }\n\n    return true;\n  }",
    "comment": " Sets the prototype. @param prototype the prototype. If this value is {@code null} it will silently be discarded. ",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 0
  },
  {
    "name": "FunctionType.setPrototypeBasedOn",
    "class_name": "com.google.javascript.rhino.jstype.FunctionType",
    "signature": "com.google.javascript.rhino.jstype.FunctionType.setPrototypeBasedOn(ObjectType)",
    "snippet": "  public void setPrototypeBasedOn(ObjectType baseType) {\n    setPrototypeBasedOn(baseType, null);\n  }",
    "comment": " Sets the prototype, creating the prototype object from the given base type. @param baseType The base type. ",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 0
  },
  {
    "name": "FunctionType.setPrototypeBasedOn",
    "class_name": "com.google.javascript.rhino.jstype.FunctionType",
    "signature": "com.google.javascript.rhino.jstype.FunctionType.setPrototypeBasedOn(ObjectType,Node)",
    "snippet": "  void setPrototypeBasedOn(ObjectType baseType, Node propertyNode) {\n    // This is a bit weird. We need to successfully handle these\n    // two cases:\n    // Foo.prototype = new Bar();\n    // and\n    // Foo.prototype = {baz: 3};\n    // In the first case, we do not want new properties to get\n    // added to Bar. In the second case, we do want new properties\n    // to get added to the type of the anonymous object.\n    //\n    // We handle this by breaking it into two cases:\n    //\n    // In the first case, we create a new PrototypeObjectType and set\n    // its implicit prototype to the type being assigned. This ensures\n    // that Bar will not get any properties of Foo.prototype, but properties\n    // later assigned to Bar will get inherited properly.\n    //\n    // In the second case, we just use the anonymous object as the prototype.\n    if (baseType.hasReferenceName() ||\n        isNativeObjectType() ||\n        baseType.isFunctionPrototypeType()) {\n\n      baseType = new PrototypeObjectType(\n          registry, this.getReferenceName() + \".prototype\", baseType);\n    }\n    setPrototype(baseType, propertyNode);\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 0
  },
  {
    "name": "FunctionType.toMaybeFunctionType",
    "class_name": "com.google.javascript.rhino.jstype.FunctionType",
    "signature": "com.google.javascript.rhino.jstype.FunctionType.toMaybeFunctionType()",
    "snippet": "  @Override\n  public FunctionType toMaybeFunctionType() {\n    return this;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 0
  },
  {
    "name": "InstanceObjectType.InstanceObjectType",
    "class_name": "com.google.javascript.rhino.jstype.InstanceObjectType",
    "signature": "com.google.javascript.rhino.jstype.InstanceObjectType.InstanceObjectType(JSTypeRegistry,FunctionType,boolean)",
    "snippet": "  InstanceObjectType(JSTypeRegistry registry, FunctionType constructor,\n                     boolean isNativeType) {\n    super(registry, null, null, isNativeType);\n    Preconditions.checkNotNull(constructor);\n    this.constructor = constructor;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 0
  },
  {
    "name": "InstanceObjectType.defineProperty",
    "class_name": "com.google.javascript.rhino.jstype.InstanceObjectType",
    "signature": "com.google.javascript.rhino.jstype.InstanceObjectType.defineProperty(String,JSType,boolean,Node)",
    "snippet": "  @Override\n  boolean defineProperty(String name, JSType type, boolean inferred,\n      Node propertyNode) {\n    ObjectType proto = getImplicitPrototype();\n    if (proto != null && proto.hasOwnDeclaredProperty(name)) {\n      return false;\n    }\n    return super.defineProperty(name, type, inferred, propertyNode);\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 0
  },
  {
    "name": "InstanceObjectType.getConstructor",
    "class_name": "com.google.javascript.rhino.jstype.InstanceObjectType",
    "signature": "com.google.javascript.rhino.jstype.InstanceObjectType.getConstructor()",
    "snippet": "  @Override\n  public FunctionType getConstructor() {\n    return constructor;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 0
  },
  {
    "name": "InstanceObjectType.getCtorExtendedInterfaces",
    "class_name": "com.google.javascript.rhino.jstype.InstanceObjectType",
    "signature": "com.google.javascript.rhino.jstype.InstanceObjectType.getCtorExtendedInterfaces()",
    "snippet": "  @Override\n  public Iterable<ObjectType> getCtorExtendedInterfaces() {\n    return getConstructor().getExtendedInterfaces();\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 0
  },
  {
    "name": "InstanceObjectType.getImplicitPrototype",
    "class_name": "com.google.javascript.rhino.jstype.InstanceObjectType",
    "signature": "com.google.javascript.rhino.jstype.InstanceObjectType.getImplicitPrototype()",
    "snippet": "  @Override\n  public ObjectType getImplicitPrototype() {\n    return getConstructor().getPrototype();\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 0
  },
  {
    "name": "InstanceObjectType.getReferenceName",
    "class_name": "com.google.javascript.rhino.jstype.InstanceObjectType",
    "signature": "com.google.javascript.rhino.jstype.InstanceObjectType.getReferenceName()",
    "snippet": "  @Override\n  public String getReferenceName() {\n    return getConstructor().getReferenceName();\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 0
  },
  {
    "name": "InstanceObjectType.hasReferenceName",
    "class_name": "com.google.javascript.rhino.jstype.InstanceObjectType",
    "signature": "com.google.javascript.rhino.jstype.InstanceObjectType.hasReferenceName()",
    "snippet": "  @Override\n  public boolean hasReferenceName() {\n    return getConstructor().hasReferenceName();\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 0
  },
  {
    "name": "InstanceObjectType.hashCode",
    "class_name": "com.google.javascript.rhino.jstype.InstanceObjectType",
    "signature": "com.google.javascript.rhino.jstype.InstanceObjectType.hashCode()",
    "snippet": "  @Override\n  public int hashCode() {\n    if (hasReferenceName()) {\n      return getReferenceName().hashCode();\n    } else {\n      return super.hashCode();\n    }\n  }",
    "comment": " If this is equal to a NamedType object, its hashCode must be equal to the hashCode of the NamedType object. ",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 0
  },
  {
    "name": "InstanceObjectType.isEquivalentTo",
    "class_name": "com.google.javascript.rhino.jstype.InstanceObjectType",
    "signature": "com.google.javascript.rhino.jstype.InstanceObjectType.isEquivalentTo(JSType)",
    "snippet": "  @Override\n  public boolean isEquivalentTo(JSType that) {\n    if (this == that) {\n      return true;\n    } else if (this.isNominalType()) {\n      ObjectType thatObj = ObjectType.cast(that);\n      if (thatObj != null && thatObj.isNominalType()) {\n        return getReferenceName().equals(thatObj.getReferenceName());\n      }\n    }\n    return false;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 0
  },
  {
    "name": "InstanceObjectType.isNominalType",
    "class_name": "com.google.javascript.rhino.jstype.InstanceObjectType",
    "signature": "com.google.javascript.rhino.jstype.InstanceObjectType.isNominalType()",
    "snippet": "  @Override\n  public boolean isNominalType() {\n    return hasReferenceName();\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 0
  },
  {
    "name": "InstanceObjectType.toStringHelper",
    "class_name": "com.google.javascript.rhino.jstype.InstanceObjectType",
    "signature": "com.google.javascript.rhino.jstype.InstanceObjectType.toStringHelper(boolean)",
    "snippet": "  @Override\n  String toStringHelper(boolean forAnnotations) {\n    if (constructor.hasReferenceName()) {\n      return constructor.getReferenceName();\n    } else {\n      return super.toStringHelper(forAnnotations);\n    }\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 0
  },
  {
    "name": "JSTypeRegistry.JSTypeRegistry",
    "class_name": "com.google.javascript.rhino.jstype.JSTypeRegistry",
    "signature": "com.google.javascript.rhino.jstype.JSTypeRegistry.JSTypeRegistry(ErrorReporter,boolean)",
    "snippet": "  public JSTypeRegistry(\n      ErrorReporter reporter, boolean tolerateUndefinedValues) {\n    this.reporter = reporter;\n    nativeTypes = new JSType[JSTypeNative.values().length];\n    namesToTypes = new HashMap<String, JSType>();\n    resetForTypeCheck();\n    this.tolerateUndefinedValues = tolerateUndefinedValues;\n  }",
    "comment": " Constructs a new type registry populated with the built-in types. ",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 0
  },
  {
    "name": "JSTypeRegistry.addReferenceTypeIndexedByProperty",
    "class_name": "com.google.javascript.rhino.jstype.JSTypeRegistry",
    "signature": "com.google.javascript.rhino.jstype.JSTypeRegistry.addReferenceTypeIndexedByProperty(String,JSType)",
    "snippet": "  private void addReferenceTypeIndexedByProperty(\n      String propertyName, JSType type) {\n    if (type instanceof ObjectType && ((ObjectType) type).hasReferenceName()) {\n      Map<String, ObjectType> typeSet =\n          eachRefTypeIndexedByProperty.get(propertyName);\n      if (typeSet == null) {\n        typeSet = Maps.newHashMap();\n        eachRefTypeIndexedByProperty.put(propertyName, typeSet);\n      }\n      ObjectType objType = (ObjectType) type;\n      typeSet.put(objType.getReferenceName(), objType);\n    } else if (type instanceof NamedType) {\n      addReferenceTypeIndexedByProperty(\n          propertyName, ((NamedType) type).getReferencedType());\n    } else if (type.isUnionType()) {\n      for (JSType alternate : type.toMaybeUnionType().getAlternates()) {\n        addReferenceTypeIndexedByProperty(propertyName, alternate);\n      }\n    }\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 0
  },
  {
    "name": "JSTypeRegistry.createArrowType",
    "class_name": "com.google.javascript.rhino.jstype.JSTypeRegistry",
    "signature": "com.google.javascript.rhino.jstype.JSTypeRegistry.createArrowType(Node)",
    "snippet": "  ArrowType createArrowType(Node parametersNode) {\n    return new ArrowType(this, parametersNode, null);\n  }",
    "comment": " Creates an arrow type with an unknown return type.  @param parametersNode the parameters' types, formatted as a Node with param names and optionality info. ",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 0
  },
  {
    "name": "JSTypeRegistry.createArrowType",
    "class_name": "com.google.javascript.rhino.jstype.JSTypeRegistry",
    "signature": "com.google.javascript.rhino.jstype.JSTypeRegistry.createArrowType(Node,JSType)",
    "snippet": "  ArrowType createArrowType(Node parametersNode, JSType returnType) {\n    return new ArrowType(this, parametersNode, returnType);\n  }",
    "comment": " Creates an arrow type, an abstract representation of the parameters and return value of a function.  @param parametersNode the parameters' types, formatted as a Node with param names and optionality info. @param returnType the function's return type ",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 0
  },
  {
    "name": "JSTypeRegistry.createFunctionType",
    "class_name": "com.google.javascript.rhino.jstype.JSTypeRegistry",
    "signature": "com.google.javascript.rhino.jstype.JSTypeRegistry.createFunctionType(JSType,Node)",
    "snippet": "  public FunctionType createFunctionType(\n      JSType returnType, Node parameters) {\n    return new FunctionBuilder(this)\n        .withParamsNode(parameters)\n        .withReturnType(returnType)\n        .build();\n  }",
    "comment": " @param parameters the function's parameters or {@code null} to indicate that the parameter types are unknown. @param returnType the function's return type or {@code null} to indicate that the return type is unknown. ",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 0
  },
  {
    "name": "JSTypeRegistry.createFunctionType",
    "class_name": "com.google.javascript.rhino.jstype.JSTypeRegistry",
    "signature": "com.google.javascript.rhino.jstype.JSTypeRegistry.createFunctionType(JSType,boolean,JSType[])",
    "snippet": "  public FunctionType createFunctionType(JSType returnType,\n      boolean lastVarArgs, JSType... parameterTypes) {\n    if (lastVarArgs) {\n      return createFunctionTypeWithVarArgs(returnType, parameterTypes);\n    } else {\n      return createFunctionType(returnType, parameterTypes);\n    }\n  }",
    "comment": " Creates a function type. @param returnType the function's return type @param lastVarArgs whether the last parameter type should be considered as an extensible var_args parameter @param parameterTypes the parameters' types ",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 0
  },
  {
    "name": "JSTypeRegistry.createFunctionTypeWithVarArgs",
    "class_name": "com.google.javascript.rhino.jstype.JSTypeRegistry",
    "signature": "com.google.javascript.rhino.jstype.JSTypeRegistry.createFunctionTypeWithVarArgs(JSType,JSType[])",
    "snippet": "  public FunctionType createFunctionTypeWithVarArgs(\n      JSType returnType, JSType... parameterTypes) {\n    return createFunctionType(\n        returnType, createParametersWithVarArgs(parameterTypes));\n  }",
    "comment": " Creates a function type. The last parameter type of the function is considered a variable length argument.  @param returnType the function's return type @param parameterTypes the parameters' types ",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 0
  },
  {
    "name": "JSTypeRegistry.createNullableType",
    "class_name": "com.google.javascript.rhino.jstype.JSTypeRegistry",
    "signature": "com.google.javascript.rhino.jstype.JSTypeRegistry.createNullableType(JSType)",
    "snippet": "  public JSType createNullableType(JSType type) {\n    return createUnionType(type, getNativeType(JSTypeNative.NULL_TYPE));\n  }",
    "comment": " Creates a type representing nullable values of the given type. @return the union of the type and the Null type ",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 0
  },
  {
    "name": "JSTypeRegistry.createOptionalParameters",
    "class_name": "com.google.javascript.rhino.jstype.JSTypeRegistry",
    "signature": "com.google.javascript.rhino.jstype.JSTypeRegistry.createOptionalParameters(JSType[])",
    "snippet": "  public Node createOptionalParameters(JSType... parameterTypes) {\n    FunctionParamBuilder builder = new FunctionParamBuilder(this);\n    builder.addOptionalParams(parameterTypes);\n    return builder.build();\n  }",
    "comment": " Creates a tree hierarchy representing a typed parameter list in which every parameter is optional. ",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 0
  },
  {
    "name": "JSTypeRegistry.createOptionalType",
    "class_name": "com.google.javascript.rhino.jstype.JSTypeRegistry",
    "signature": "com.google.javascript.rhino.jstype.JSTypeRegistry.createOptionalType(JSType)",
    "snippet": "  public JSType createOptionalType(JSType type) {\n    if (type instanceof UnknownType || type.isAllType()) {\n      return type;\n    } else {\n      return createUnionType(type, getNativeType(JSTypeNative.VOID_TYPE));\n    }\n  }",
    "comment": " Creates a type representing optional values of the given type. @return the union of the type and the void type ",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 0
  },
  {
    "name": "JSTypeRegistry.createParameters",
    "class_name": "com.google.javascript.rhino.jstype.JSTypeRegistry",
    "signature": "com.google.javascript.rhino.jstype.JSTypeRegistry.createParameters(boolean,JSType[])",
    "snippet": "  private Node createParameters(boolean lastVarArgs, JSType... parameterTypes) {\n    FunctionParamBuilder builder = new FunctionParamBuilder(this);\n    int max = parameterTypes.length - 1;\n    for (int i = 0; i <= max; i++) {\n      if (lastVarArgs && i == max) {\n        builder.addVarArgs(parameterTypes[i]);\n      } else {\n        builder.addRequiredParams(parameterTypes[i]);\n      }\n    }\n    return builder.build();\n  }",
    "comment": " Creates a tree hierarchy representing a typed argument list.  @param lastVarArgs whether the last type should considered as a variable length argument. @param parameterTypes the parameter types. The last element of this array is considered a variable length argument is {@code lastVarArgs} is {@code true}. @return a tree hierarchy representing a typed argument list ",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 0
  },
  {
    "name": "JSTypeRegistry.createParametersWithVarArgs",
    "class_name": "com.google.javascript.rhino.jstype.JSTypeRegistry",
    "signature": "com.google.javascript.rhino.jstype.JSTypeRegistry.createParametersWithVarArgs(JSType[])",
    "snippet": "  public Node createParametersWithVarArgs(JSType... parameterTypes) {\n    return createParameters(true, parameterTypes);\n  }",
    "comment": " Creates a tree hierarchy representing a typed argument list. The last parameter type is considered a variable length argument.  @param parameterTypes the parameter types. The last element of this array is considered a variable length argument. @return a tree hierarchy representing a typed argument list. ",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 0
  },
  {
    "name": "JSTypeRegistry.createUnionType",
    "class_name": "com.google.javascript.rhino.jstype.JSTypeRegistry",
    "signature": "com.google.javascript.rhino.jstype.JSTypeRegistry.createUnionType(JSType[])",
    "snippet": "  public JSType createUnionType(JSType... variants) {\n    UnionTypeBuilder builder = new UnionTypeBuilder(this);\n    for (JSType type : variants) {\n      builder.addAlternate(type);\n    }\n    return builder.build();\n  }",
    "comment": " Creates a union type whose variants are the arguments. ",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 0
  },
  {
    "name": "JSTypeRegistry.getNativeFunctionType",
    "class_name": "com.google.javascript.rhino.jstype.JSTypeRegistry",
    "signature": "com.google.javascript.rhino.jstype.JSTypeRegistry.getNativeFunctionType(JSTypeNative)",
    "snippet": "  public FunctionType getNativeFunctionType(JSTypeNative typeId) {\n    return (FunctionType) getNativeType(typeId);\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 0
  },
  {
    "name": "JSTypeRegistry.getNativeObjectType",
    "class_name": "com.google.javascript.rhino.jstype.JSTypeRegistry",
    "signature": "com.google.javascript.rhino.jstype.JSTypeRegistry.getNativeObjectType(JSTypeNative)",
    "snippet": "  public ObjectType getNativeObjectType(JSTypeNative typeId) {\n    return (ObjectType) getNativeType(typeId);\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 0
  },
  {
    "name": "JSTypeRegistry.getNativeType",
    "class_name": "com.google.javascript.rhino.jstype.JSTypeRegistry",
    "signature": "com.google.javascript.rhino.jstype.JSTypeRegistry.getNativeType(JSTypeNative)",
    "snippet": "  public JSType getNativeType(JSTypeNative typeId) {\n    return nativeTypes[typeId.ordinal()];\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 0
  },
  {
    "name": "JSTypeRegistry.initializeBuiltInTypes",
    "class_name": "com.google.javascript.rhino.jstype.JSTypeRegistry",
    "signature": "com.google.javascript.rhino.jstype.JSTypeRegistry.initializeBuiltInTypes()",
    "snippet": "  private void initializeBuiltInTypes() {\n    // These locals shouldn't be all caps.\n    BooleanType BOOLEAN_TYPE = new BooleanType(this);\n    registerNativeType(JSTypeNative.BOOLEAN_TYPE, BOOLEAN_TYPE);\n\n    NullType NULL_TYPE = new NullType(this);\n    registerNativeType(JSTypeNative.NULL_TYPE, NULL_TYPE);\n\n    NumberType NUMBER_TYPE = new NumberType(this);\n    registerNativeType(JSTypeNative.NUMBER_TYPE, NUMBER_TYPE);\n\n    StringType STRING_TYPE = new StringType(this);\n    registerNativeType(JSTypeNative.STRING_TYPE, STRING_TYPE);\n\n    UnknownType UNKNOWN_TYPE = new UnknownType(this, false);\n    registerNativeType(JSTypeNative.UNKNOWN_TYPE, UNKNOWN_TYPE);\n    registerNativeType(\n        JSTypeNative.CHECKED_UNKNOWN_TYPE, new UnknownType(this, true));\n\n    VoidType VOID_TYPE = new VoidType(this);\n    registerNativeType(JSTypeNative.VOID_TYPE, VOID_TYPE);\n\n    AllType ALL_TYPE = new AllType(this);\n    registerNativeType(JSTypeNative.ALL_TYPE, ALL_TYPE);\n\n    // Top Level Prototype (the One)\n    // The initializations of TOP_LEVEL_PROTOTYPE and OBJECT_FUNCTION_TYPE\n    // use each other's results, so at least one of them will get null\n    // instead of an actual type; however, this seems to be benign.\n    PrototypeObjectType TOP_LEVEL_PROTOTYPE =\n        new PrototypeObjectType(this, null, null, true);\n    registerNativeType(JSTypeNative.TOP_LEVEL_PROTOTYPE, TOP_LEVEL_PROTOTYPE);\n\n    // Object\n    FunctionType OBJECT_FUNCTION_TYPE =\n        new FunctionType(this, \"Object\", null,\n            createArrowType(createOptionalParameters(ALL_TYPE), UNKNOWN_TYPE),\n            null, null, true, true);\n\n    OBJECT_FUNCTION_TYPE.setPrototype(TOP_LEVEL_PROTOTYPE, null);\n    registerNativeType(JSTypeNative.OBJECT_FUNCTION_TYPE, OBJECT_FUNCTION_TYPE);\n\n    ObjectType OBJECT_TYPE = OBJECT_FUNCTION_TYPE.getInstanceType();\n    registerNativeType(JSTypeNative.OBJECT_TYPE, OBJECT_TYPE);\n\n    ObjectType OBJECT_PROTOTYPE = OBJECT_FUNCTION_TYPE.getPrototype();\n    registerNativeType(JSTypeNative.OBJECT_PROTOTYPE, OBJECT_PROTOTYPE);\n\n    // Function\n    FunctionType FUNCTION_FUNCTION_TYPE =\n        new FunctionType(this, \"Function\", null,\n            createArrowType(\n                createParametersWithVarArgs(ALL_TYPE), UNKNOWN_TYPE),\n            null, null, true, true);\n    FUNCTION_FUNCTION_TYPE.setPrototypeBasedOn(OBJECT_TYPE);\n    registerNativeType(\n        JSTypeNative.FUNCTION_FUNCTION_TYPE, FUNCTION_FUNCTION_TYPE);\n\n    ObjectType FUNCTION_PROTOTYPE = FUNCTION_FUNCTION_TYPE.getPrototype();\n    registerNativeType(JSTypeNative.FUNCTION_PROTOTYPE, FUNCTION_PROTOTYPE);\n\n    NoType NO_TYPE = new NoType(this);\n    registerNativeType(JSTypeNative.NO_TYPE, NO_TYPE);\n\n    NoObjectType NO_OBJECT_TYPE = new NoObjectType(this);\n    registerNativeType(JSTypeNative.NO_OBJECT_TYPE, NO_OBJECT_TYPE);\n\n    NoObjectType NO_RESOLVED_TYPE = new NoResolvedType(this);\n    registerNativeType(JSTypeNative.NO_RESOLVED_TYPE, NO_RESOLVED_TYPE);\n\n    // Array\n    FunctionType ARRAY_FUNCTION_TYPE =\n      new FunctionType(this, \"Array\", null,\n          createArrowType(createParametersWithVarArgs(ALL_TYPE), null),\n          null, null, true, true);\n    ARRAY_FUNCTION_TYPE.getInternalArrowType().returnType =\n        ARRAY_FUNCTION_TYPE.getInstanceType();\n\n    ObjectType arrayPrototype = ARRAY_FUNCTION_TYPE.getPrototype();\n    registerNativeType(JSTypeNative.ARRAY_FUNCTION_TYPE, ARRAY_FUNCTION_TYPE);\n\n    ObjectType ARRAY_TYPE = ARRAY_FUNCTION_TYPE.getInstanceType();\n    registerNativeType(JSTypeNative.ARRAY_TYPE, ARRAY_TYPE);\n\n    // Boolean\n    FunctionType BOOLEAN_OBJECT_FUNCTION_TYPE =\n        new FunctionType(this, \"Boolean\", null,\n            createArrowType(createParameters(false, ALL_TYPE), BOOLEAN_TYPE),\n            null, null, true, true);\n    ObjectType booleanPrototype = BOOLEAN_OBJECT_FUNCTION_TYPE.getPrototype();\n    registerNativeType(\n        JSTypeNative.BOOLEAN_OBJECT_FUNCTION_TYPE,\n        BOOLEAN_OBJECT_FUNCTION_TYPE);\n\n    ObjectType BOOLEAN_OBJECT_TYPE =\n        BOOLEAN_OBJECT_FUNCTION_TYPE.getInstanceType();\n    registerNativeType(JSTypeNative.BOOLEAN_OBJECT_TYPE, BOOLEAN_OBJECT_TYPE);\n\n    // Date\n    FunctionType DATE_FUNCTION_TYPE =\n      new FunctionType(this, \"Date\", null,\n          createArrowType(\n              createOptionalParameters(UNKNOWN_TYPE, UNKNOWN_TYPE, UNKNOWN_TYPE,\n                  UNKNOWN_TYPE, UNKNOWN_TYPE, UNKNOWN_TYPE, UNKNOWN_TYPE),\n              STRING_TYPE),\n          null, null, true, true);\n    ObjectType datePrototype = DATE_FUNCTION_TYPE.getPrototype();\n    registerNativeType(JSTypeNative.DATE_FUNCTION_TYPE, DATE_FUNCTION_TYPE);\n\n    ObjectType DATE_TYPE = DATE_FUNCTION_TYPE.getInstanceType();\n    registerNativeType(JSTypeNative.DATE_TYPE, DATE_TYPE);\n\n    // Error\n    FunctionType ERROR_FUNCTION_TYPE = new ErrorFunctionType(this, \"Error\");\n    registerNativeType(JSTypeNative.ERROR_FUNCTION_TYPE, ERROR_FUNCTION_TYPE);\n\n    ObjectType ERROR_TYPE = ERROR_FUNCTION_TYPE.getInstanceType();\n    registerNativeType(JSTypeNative.ERROR_TYPE, ERROR_TYPE);\n\n    // EvalError\n    FunctionType EVAL_ERROR_FUNCTION_TYPE =\n        new ErrorFunctionType(this, \"EvalError\");\n    EVAL_ERROR_FUNCTION_TYPE.setPrototypeBasedOn(ERROR_TYPE);\n    registerNativeType(\n        JSTypeNative.EVAL_ERROR_FUNCTION_TYPE, EVAL_ERROR_FUNCTION_TYPE);\n\n    ObjectType EVAL_ERROR_TYPE = EVAL_ERROR_FUNCTION_TYPE.getInstanceType();\n    registerNativeType(JSTypeNative.EVAL_ERROR_TYPE, EVAL_ERROR_TYPE);\n\n    // RangeError\n    FunctionType RANGE_ERROR_FUNCTION_TYPE =\n        new ErrorFunctionType(this, \"RangeError\");\n    RANGE_ERROR_FUNCTION_TYPE.setPrototypeBasedOn(ERROR_TYPE);\n    registerNativeType(\n        JSTypeNative.RANGE_ERROR_FUNCTION_TYPE, RANGE_ERROR_FUNCTION_TYPE);\n\n    ObjectType RANGE_ERROR_TYPE = RANGE_ERROR_FUNCTION_TYPE.getInstanceType();\n    registerNativeType(JSTypeNative.RANGE_ERROR_TYPE, RANGE_ERROR_TYPE);\n\n    // ReferenceError\n    FunctionType REFERENCE_ERROR_FUNCTION_TYPE =\n        new ErrorFunctionType(this, \"ReferenceError\");\n    REFERENCE_ERROR_FUNCTION_TYPE.setPrototypeBasedOn(ERROR_TYPE);\n    registerNativeType(\n        JSTypeNative.REFERENCE_ERROR_FUNCTION_TYPE,\n        REFERENCE_ERROR_FUNCTION_TYPE);\n\n    ObjectType REFERENCE_ERROR_TYPE =\n        REFERENCE_ERROR_FUNCTION_TYPE.getInstanceType();\n    registerNativeType(JSTypeNative.REFERENCE_ERROR_TYPE, REFERENCE_ERROR_TYPE);\n\n    // SyntaxError\n    FunctionType SYNTAX_ERROR_FUNCTION_TYPE =\n        new ErrorFunctionType(this, \"SyntaxError\");\n    SYNTAX_ERROR_FUNCTION_TYPE.setPrototypeBasedOn(ERROR_TYPE);\n    registerNativeType(\n        JSTypeNative.SYNTAX_ERROR_FUNCTION_TYPE, SYNTAX_ERROR_FUNCTION_TYPE);\n\n    ObjectType SYNTAX_ERROR_TYPE = SYNTAX_ERROR_FUNCTION_TYPE.getInstanceType();\n    registerNativeType(JSTypeNative.SYNTAX_ERROR_TYPE, SYNTAX_ERROR_TYPE);\n\n    // TypeError\n    FunctionType TYPE_ERROR_FUNCTION_TYPE =\n        new ErrorFunctionType(this, \"TypeError\");\n    TYPE_ERROR_FUNCTION_TYPE.setPrototypeBasedOn(ERROR_TYPE);\n    registerNativeType(\n        JSTypeNative.TYPE_ERROR_FUNCTION_TYPE, TYPE_ERROR_FUNCTION_TYPE);\n\n    ObjectType TYPE_ERROR_TYPE = TYPE_ERROR_FUNCTION_TYPE.getInstanceType();\n    registerNativeType(JSTypeNative.TYPE_ERROR_TYPE, TYPE_ERROR_TYPE);\n\n    // URIError\n    FunctionType URI_ERROR_FUNCTION_TYPE =\n        new ErrorFunctionType(this, \"URIError\");\n    URI_ERROR_FUNCTION_TYPE.setPrototypeBasedOn(ERROR_TYPE);\n    registerNativeType(\n        JSTypeNative.URI_ERROR_FUNCTION_TYPE, URI_ERROR_FUNCTION_TYPE);\n\n    ObjectType URI_ERROR_TYPE = URI_ERROR_FUNCTION_TYPE.getInstanceType();\n    registerNativeType(JSTypeNative.URI_ERROR_TYPE, URI_ERROR_TYPE);\n\n    // Number\n    FunctionType NUMBER_OBJECT_FUNCTION_TYPE =\n        new FunctionType(this, \"Number\", null,\n            createArrowType(createParameters(false, ALL_TYPE), NUMBER_TYPE),\n            null, null, true, true);\n    ObjectType numberPrototype = NUMBER_OBJECT_FUNCTION_TYPE.getPrototype();\n    registerNativeType(\n        JSTypeNative.NUMBER_OBJECT_FUNCTION_TYPE, NUMBER_OBJECT_FUNCTION_TYPE);\n\n    ObjectType NUMBER_OBJECT_TYPE =\n        NUMBER_OBJECT_FUNCTION_TYPE.getInstanceType();\n    registerNativeType(JSTypeNative.NUMBER_OBJECT_TYPE, NUMBER_OBJECT_TYPE);\n\n    // RegExp\n    FunctionType REGEXP_FUNCTION_TYPE =\n      new FunctionType(this, \"RegExp\", null,\n          createArrowType(createOptionalParameters(ALL_TYPE, ALL_TYPE)),\n          null, null, true, true);\n    REGEXP_FUNCTION_TYPE.getInternalArrowType().returnType =\n        REGEXP_FUNCTION_TYPE.getInstanceType();\n\n    ObjectType regexpPrototype = REGEXP_FUNCTION_TYPE.getPrototype();\n    registerNativeType(JSTypeNative.REGEXP_FUNCTION_TYPE, REGEXP_FUNCTION_TYPE);\n\n    ObjectType REGEXP_TYPE = REGEXP_FUNCTION_TYPE.getInstanceType();\n    registerNativeType(JSTypeNative.REGEXP_TYPE, REGEXP_TYPE);\n\n    // String\n    FunctionType STRING_OBJECT_FUNCTION_TYPE =\n        new FunctionType(this, \"String\", null,\n            createArrowType(createParameters(false, ALL_TYPE), STRING_TYPE),\n            null, null, true, true);\n    ObjectType stringPrototype = STRING_OBJECT_FUNCTION_TYPE.getPrototype();\n    registerNativeType(\n        JSTypeNative.STRING_OBJECT_FUNCTION_TYPE, STRING_OBJECT_FUNCTION_TYPE);\n\n    ObjectType STRING_OBJECT_TYPE =\n        STRING_OBJECT_FUNCTION_TYPE.getInstanceType();\n    registerNativeType(\n        JSTypeNative.STRING_OBJECT_TYPE, STRING_OBJECT_TYPE);\n\n    // (Object,string,number)\n    JSType OBJECT_NUMBER_STRING =\n        createUnionType(OBJECT_TYPE, NUMBER_TYPE, STRING_TYPE);\n    registerNativeType(JSTypeNative.OBJECT_NUMBER_STRING, OBJECT_NUMBER_STRING);\n\n    // (Object,string,number,boolean)\n    JSType OBJECT_NUMBER_STRING_BOOLEAN =\n        createUnionType(OBJECT_TYPE, NUMBER_TYPE, STRING_TYPE, BOOLEAN_TYPE);\n    registerNativeType(JSTypeNative.OBJECT_NUMBER_STRING_BOOLEAN,\n        OBJECT_NUMBER_STRING_BOOLEAN);\n\n    // (string,number,boolean)\n    JSType NUMBER_STRING_BOOLEAN =\n        createUnionType(NUMBER_TYPE, STRING_TYPE, BOOLEAN_TYPE);\n    registerNativeType(JSTypeNative.NUMBER_STRING_BOOLEAN,\n        NUMBER_STRING_BOOLEAN);\n\n    // (string,number)\n    JSType NUMBER_STRING = createUnionType(NUMBER_TYPE, STRING_TYPE);\n    registerNativeType(JSTypeNative.NUMBER_STRING, NUMBER_STRING);\n\n    // Native object properties are filled in by externs...\n\n    // (String, string)\n    JSType STRING_VALUE_OR_OBJECT_TYPE =\n        createUnionType(STRING_OBJECT_TYPE, STRING_TYPE);\n    registerNativeType(\n        JSTypeNative.STRING_VALUE_OR_OBJECT_TYPE, STRING_VALUE_OR_OBJECT_TYPE);\n\n    // (Number, number)\n    JSType NUMBER_VALUE_OR_OBJECT_TYPE =\n        createUnionType(NUMBER_OBJECT_TYPE, NUMBER_TYPE);\n    registerNativeType(\n        JSTypeNative.NUMBER_VALUE_OR_OBJECT_TYPE, NUMBER_VALUE_OR_OBJECT_TYPE);\n\n    // unknown function type, i.e. (?...) -> ?\n    FunctionType U2U_FUNCTION_TYPE =\n        createFunctionType(UNKNOWN_TYPE, true, UNKNOWN_TYPE);\n    registerNativeType(JSTypeNative.U2U_FUNCTION_TYPE, U2U_FUNCTION_TYPE);\n\n    // unknown constructor type, i.e. (?...) -> ? with the NoObject type\n    // as instance type\n    FunctionType U2U_CONSTRUCTOR_TYPE =\n        // This is equivalent to\n        // createConstructorType(UNKNOWN_TYPE, true, UNKNOWN_TYPE), but,\n        // in addition, overrides getInstanceType() to return the NoObject type\n        // instead of a new anonymous object.\n        new FunctionType(this, \"Function\", null,\n            createArrowType(\n                createParametersWithVarArgs(UNKNOWN_TYPE),\n                UNKNOWN_TYPE),\n            NO_OBJECT_TYPE, null, true, true) {\n          private static final long serialVersionUID = 1L;\n\n          @Override public FunctionType getConstructor() {\n            return registry.getNativeFunctionType(\n                JSTypeNative.FUNCTION_FUNCTION_TYPE);\n          }\n        };\n\n    // The U2U_CONSTRUCTOR is weird, because it's the supertype of its\n    // own constructor.\n    registerNativeType(JSTypeNative.U2U_CONSTRUCTOR_TYPE, U2U_CONSTRUCTOR_TYPE);\n    registerNativeType(\n        JSTypeNative.FUNCTION_INSTANCE_TYPE, U2U_CONSTRUCTOR_TYPE);\n\n    FUNCTION_FUNCTION_TYPE.setInstanceType(U2U_CONSTRUCTOR_TYPE);\n    U2U_CONSTRUCTOR_TYPE.setImplicitPrototype(FUNCTION_PROTOTYPE);\n\n    // least function type, i.e. (All...) -> NoType\n    FunctionType LEAST_FUNCTION_TYPE =\n        createFunctionType(NO_TYPE, true, ALL_TYPE);\n    registerNativeType(JSTypeNative.LEAST_FUNCTION_TYPE, LEAST_FUNCTION_TYPE);\n\n    // the 'this' object in the global scope\n    FunctionType GLOBAL_THIS_CTOR =\n        new FunctionType(this, \"global this\", null,\n            createArrowType(createParameters(false, ALL_TYPE), NUMBER_TYPE),\n            null, null, true, true);\n    ObjectType GLOBAL_THIS = GLOBAL_THIS_CTOR.getInstanceType();\n    registerNativeType(JSTypeNative.GLOBAL_THIS, GLOBAL_THIS);\n\n    // greatest function type, i.e. (NoType...) -> All\n    FunctionType GREATEST_FUNCTION_TYPE =\n      createFunctionType(ALL_TYPE, true, NO_TYPE);\n    registerNativeType(JSTypeNative.GREATEST_FUNCTION_TYPE,\n        GREATEST_FUNCTION_TYPE);\n\n    // Register the prototype property. See the comments below in\n    // registerPropertyOnType about the bootstrapping process.\n    registerPropertyOnType(\"prototype\", OBJECT_FUNCTION_TYPE);\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 0
  },
  {
    "name": "JSTypeRegistry.initializeRegistry",
    "class_name": "com.google.javascript.rhino.jstype.JSTypeRegistry",
    "signature": "com.google.javascript.rhino.jstype.JSTypeRegistry.initializeRegistry()",
    "snippet": "  private void initializeRegistry() {\n    register(getNativeType(JSTypeNative.ARRAY_TYPE));\n    register(getNativeType(JSTypeNative.BOOLEAN_OBJECT_TYPE));\n    register(getNativeType(JSTypeNative.BOOLEAN_TYPE));\n    register(getNativeType(JSTypeNative.DATE_TYPE));\n    register(getNativeType(JSTypeNative.NULL_TYPE));\n    register(getNativeType(JSTypeNative.NULL_TYPE), \"Null\");\n    register(getNativeType(JSTypeNative.NUMBER_OBJECT_TYPE));\n    register(getNativeType(JSTypeNative.NUMBER_TYPE));\n    register(getNativeType(JSTypeNative.OBJECT_TYPE));\n    register(getNativeType(JSTypeNative.ERROR_TYPE));\n    register(getNativeType(JSTypeNative.URI_ERROR_TYPE));\n    register(getNativeType(JSTypeNative.EVAL_ERROR_TYPE));\n    register(getNativeType(JSTypeNative.TYPE_ERROR_TYPE));\n    register(getNativeType(JSTypeNative.RANGE_ERROR_TYPE));\n    register(getNativeType(JSTypeNative.REFERENCE_ERROR_TYPE));\n    register(getNativeType(JSTypeNative.SYNTAX_ERROR_TYPE));\n    register(getNativeType(JSTypeNative.REGEXP_TYPE));\n    register(getNativeType(JSTypeNative.STRING_OBJECT_TYPE));\n    register(getNativeType(JSTypeNative.STRING_TYPE));\n    register(getNativeType(JSTypeNative.VOID_TYPE));\n    register(getNativeType(JSTypeNative.VOID_TYPE), \"Undefined\");\n    register(getNativeType(JSTypeNative.VOID_TYPE), \"void\");\n    register(getNativeType(JSTypeNative.FUNCTION_INSTANCE_TYPE), \"Function\");\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 0
  },
  {
    "name": "JSTypeRegistry.register",
    "class_name": "com.google.javascript.rhino.jstype.JSTypeRegistry",
    "signature": "com.google.javascript.rhino.jstype.JSTypeRegistry.register(JSType)",
    "snippet": "  private void register(JSType type) {\n    register(type, type.toString());\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 0
  },
  {
    "name": "JSTypeRegistry.register",
    "class_name": "com.google.javascript.rhino.jstype.JSTypeRegistry",
    "signature": "com.google.javascript.rhino.jstype.JSTypeRegistry.register(JSType,String)",
    "snippet": "  private void register(JSType type, String name) {\n    namesToTypes.put(name, type);\n\n    // Add all the namespaces in which this name lives.\n    while (name.indexOf('.') > 0) {\n      name = name.substring(0, name.lastIndexOf('.'));\n      namespaces.add(name);\n    }\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 0
  },
  {
    "name": "JSTypeRegistry.registerNativeType",
    "class_name": "com.google.javascript.rhino.jstype.JSTypeRegistry",
    "signature": "com.google.javascript.rhino.jstype.JSTypeRegistry.registerNativeType(JSTypeNative,JSType)",
    "snippet": "  private void registerNativeType(JSTypeNative typeId, JSType type) {\n    nativeTypes[typeId.ordinal()] = type;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 0
  },
  {
    "name": "JSTypeRegistry.registerPropertyOnType",
    "class_name": "com.google.javascript.rhino.jstype.JSTypeRegistry",
    "signature": "com.google.javascript.rhino.jstype.JSTypeRegistry.registerPropertyOnType(String,JSType)",
    "snippet": "  public void registerPropertyOnType(String propertyName, JSType type) {\n    UnionTypeBuilder typeSet = typesIndexedByProperty.get(propertyName);\n    if (typeSet == null) {\n      typeSet = new UnionTypeBuilder(this, PROPERTY_CHECKING_UNION_SIZE);\n      typesIndexedByProperty.put(propertyName, typeSet);\n    }\n\n    typeSet.addAlternate(type);\n    addReferenceTypeIndexedByProperty(propertyName, type);\n\n    // Clear cached values that depend on typesIndexedByProperty.\n    greatestSubtypeByProperty.remove(propertyName);\n  }",
    "comment": " Tells the type system that {@code owner} may have a property named {@code propertyName}. This allows the registry to keep track of what types a property is defined upon.  This is NOT the same as saying that {@code owner} must have a property named type. ObjectType#hasProperty attempts to minimize false positives (\"if we're not sure, then don't type check this property\"). The type registry, on the other hand, should attempt to minimize false negatives (\"if this property is assigned anywhere in the program, it must show up in the type registry\"). ",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 0
  },
  {
    "name": "JSTypeRegistry.resetForTypeCheck",
    "class_name": "com.google.javascript.rhino.jstype.JSTypeRegistry",
    "signature": "com.google.javascript.rhino.jstype.JSTypeRegistry.resetForTypeCheck()",
    "snippet": "  public void resetForTypeCheck() {\n    typesIndexedByProperty.clear();\n    eachRefTypeIndexedByProperty.clear();\n    initializeBuiltInTypes();\n    namesToTypes.clear();\n    namespaces.clear();\n    initializeRegistry();\n  }",
    "comment": " Reset to run the TypeCheck pass. ",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 0
  },
  {
    "name": "NoObjectType.NoObjectType",
    "class_name": "com.google.javascript.rhino.jstype.NoObjectType",
    "signature": "com.google.javascript.rhino.jstype.NoObjectType.NoObjectType(JSTypeRegistry)",
    "snippet": "  NoObjectType(JSTypeRegistry registry) {\n    super(registry, null, null,\n          registry.createArrowType(null, null),\n          null, null, true, true);\n    getInternalArrowType().returnType = this;\n    this.setInstanceType(this);\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 0
  },
  {
    "name": "NoResolvedType.NoResolvedType",
    "class_name": "com.google.javascript.rhino.jstype.NoResolvedType",
    "signature": "com.google.javascript.rhino.jstype.NoResolvedType.NoResolvedType(JSTypeRegistry)",
    "snippet": "  NoResolvedType(JSTypeRegistry registry) {\n    super(registry);\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 0
  },
  {
    "name": "NoType.NoType",
    "class_name": "com.google.javascript.rhino.jstype.NoType",
    "signature": "com.google.javascript.rhino.jstype.NoType.NoType(JSTypeRegistry)",
    "snippet": "  NoType(JSTypeRegistry registry) {\n    super(registry);\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 0
  },
  {
    "name": "NoType.isNoType",
    "class_name": "com.google.javascript.rhino.jstype.NoType",
    "signature": "com.google.javascript.rhino.jstype.NoType.isNoType()",
    "snippet": "  @Override\n  public boolean isNoType() {\n    return true;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 0
  },
  {
    "name": "NullType.NullType",
    "class_name": "com.google.javascript.rhino.jstype.NullType",
    "signature": "com.google.javascript.rhino.jstype.NullType.NullType(JSTypeRegistry)",
    "snippet": "  NullType(JSTypeRegistry registry) {\n    super(registry);\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 0
  },
  {
    "name": "NullType.getDisplayName",
    "class_name": "com.google.javascript.rhino.jstype.NullType",
    "signature": "com.google.javascript.rhino.jstype.NullType.getDisplayName()",
    "snippet": "  @Override\n  public String getDisplayName() {\n    return \"null\";\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 0
  },
  {
    "name": "NullType.toStringHelper",
    "class_name": "com.google.javascript.rhino.jstype.NullType",
    "signature": "com.google.javascript.rhino.jstype.NullType.toStringHelper(boolean)",
    "snippet": "  @Override\n  String toStringHelper(boolean forAnnotations) {\n    return getDisplayName();\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 0
  },
  {
    "name": "NumberType.NumberType",
    "class_name": "com.google.javascript.rhino.jstype.NumberType",
    "signature": "com.google.javascript.rhino.jstype.NumberType.NumberType(JSTypeRegistry)",
    "snippet": "  NumberType(JSTypeRegistry registry) {\n    super(registry);\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 0
  },
  {
    "name": "NumberType.getDisplayName",
    "class_name": "com.google.javascript.rhino.jstype.NumberType",
    "signature": "com.google.javascript.rhino.jstype.NumberType.getDisplayName()",
    "snippet": "  @Override\n  public String getDisplayName() {\n    return \"number\";\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 0
  },
  {
    "name": "NumberType.toStringHelper",
    "class_name": "com.google.javascript.rhino.jstype.NumberType",
    "signature": "com.google.javascript.rhino.jstype.NumberType.toStringHelper(boolean)",
    "snippet": "  @Override\n  String toStringHelper(boolean forAnnotations) {\n    return getDisplayName();\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 0
  },
  {
    "name": "ObjectType.createDelegateSuffix",
    "class_name": "com.google.javascript.rhino.jstype.ObjectType",
    "signature": "com.google.javascript.rhino.jstype.ObjectType.createDelegateSuffix(String)",
    "snippet": "  public static String createDelegateSuffix(String suffix) {\n    return \"(\" + suffix + \")\";\n  }",
    "comment": " Creates a suffix for a proxy delegate. @see #getNormalizedReferenceName ",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 0
  },
  {
    "name": "PrototypeObjectType.PrototypeObjectType",
    "class_name": "com.google.javascript.rhino.jstype.PrototypeObjectType",
    "signature": "com.google.javascript.rhino.jstype.PrototypeObjectType.PrototypeObjectType(JSTypeRegistry,String,ObjectType)",
    "snippet": "  PrototypeObjectType(JSTypeRegistry registry, String className,\n      ObjectType implicitPrototype) {\n    this(registry, className, implicitPrototype, false);\n  }",
    "comment": " Creates an object type.  @param className the name of the class.  May be {@code null} to denote an anonymous class.  @param implicitPrototype the implicit prototype (a.k.a. {@code [[Prototype]]}) as defined by ECMA-262. If the implicit prototype is {@code null} the implicit prototype will be set to the {@link JSTypeNative#OBJECT_TYPE}. ",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 0
  },
  {
    "name": "PrototypeObjectType.PrototypeObjectType",
    "class_name": "com.google.javascript.rhino.jstype.PrototypeObjectType",
    "signature": "com.google.javascript.rhino.jstype.PrototypeObjectType.PrototypeObjectType(JSTypeRegistry,String,ObjectType,boolean)",
    "snippet": "  PrototypeObjectType(JSTypeRegistry registry, String className,\n      ObjectType implicitPrototype, boolean nativeType) {\n    super(registry);\n    this.properties = Maps.newTreeMap();\n    this.className = className;\n    this.nativeType = nativeType;\n    if (nativeType || implicitPrototype != null) {\n      setImplicitPrototype(implicitPrototype);\n    } else {\n      setImplicitPrototype(\n          registry.getNativeObjectType(JSTypeNative.OBJECT_TYPE));\n    }\n  }",
    "comment": " Creates an object type, allowing specification of the implicit prototype when creating native objects. ",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 0
  },
  {
    "name": "PrototypeObjectType.defineProperty",
    "class_name": "com.google.javascript.rhino.jstype.PrototypeObjectType",
    "signature": "com.google.javascript.rhino.jstype.PrototypeObjectType.defineProperty(String,JSType,boolean,Node)",
    "snippet": "  @Override\n  boolean defineProperty(String name, JSType type, boolean inferred,\n      Node propertyNode) {\n    if (hasOwnDeclaredProperty(name)) {\n      return false;\n    }\n    Property newProp = new Property(\n        name, type, inferred, propertyNode);\n    Property oldProp = properties.get(name);\n    if (oldProp != null) {\n      // This is to keep previously inferred jsdoc info, e.g., in a\n      // replaceScript scenario.\n      newProp.setJSDocInfo(oldProp.getJSDocInfo());\n    }\n    properties.put(name, newProp);\n    return true;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 0
  },
  {
    "name": "PrototypeObjectType.getConstructor",
    "class_name": "com.google.javascript.rhino.jstype.PrototypeObjectType",
    "signature": "com.google.javascript.rhino.jstype.PrototypeObjectType.getConstructor()",
    "snippet": "  @Override\n  public FunctionType getConstructor() {\n    return null;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 0
  },
  {
    "name": "PrototypeObjectType.getCtorExtendedInterfaces",
    "class_name": "com.google.javascript.rhino.jstype.PrototypeObjectType",
    "signature": "com.google.javascript.rhino.jstype.PrototypeObjectType.getCtorExtendedInterfaces()",
    "snippet": "  @Override\n  public Iterable<ObjectType> getCtorExtendedInterfaces() {\n    return isFunctionPrototypeType()\n        ? getOwnerFunction().getExtendedInterfaces()\n        : ImmutableList.<ObjectType>of();\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 0
  },
  {
    "name": "PrototypeObjectType.getImplicitPrototype",
    "class_name": "com.google.javascript.rhino.jstype.PrototypeObjectType",
    "signature": "com.google.javascript.rhino.jstype.PrototypeObjectType.getImplicitPrototype()",
    "snippet": "  @Override\n  public ObjectType getImplicitPrototype() {\n    return implicitPrototypeFallback;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 0
  },
  {
    "name": "PrototypeObjectType.getOwnerFunction",
    "class_name": "com.google.javascript.rhino.jstype.PrototypeObjectType",
    "signature": "com.google.javascript.rhino.jstype.PrototypeObjectType.getOwnerFunction()",
    "snippet": "  @Override\n  public FunctionType getOwnerFunction() {\n    return ownerFunction;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 0
  },
  {
    "name": "PrototypeObjectType.getReferenceName",
    "class_name": "com.google.javascript.rhino.jstype.PrototypeObjectType",
    "signature": "com.google.javascript.rhino.jstype.PrototypeObjectType.getReferenceName()",
    "snippet": "  @Override\n  public String getReferenceName() {\n    if (className != null) {\n      return className;\n    } else if (ownerFunction != null) {\n      return ownerFunction.getReferenceName() + \".prototype\";\n    } else {\n      return null;\n    }\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 0
  },
  {
    "name": "PrototypeObjectType.hasCachedValues",
    "class_name": "com.google.javascript.rhino.jstype.PrototypeObjectType",
    "signature": "com.google.javascript.rhino.jstype.PrototypeObjectType.hasCachedValues()",
    "snippet": "  @Override\n  public boolean hasCachedValues() {\n    return super.hasCachedValues();\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 0
  },
  {
    "name": "PrototypeObjectType.hasOwnProperty",
    "class_name": "com.google.javascript.rhino.jstype.PrototypeObjectType",
    "signature": "com.google.javascript.rhino.jstype.PrototypeObjectType.hasOwnProperty(String)",
    "snippet": "  @Override\n  public boolean hasOwnProperty(String propertyName) {\n    return properties.get(propertyName) != null;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 0
  },
  {
    "name": "PrototypeObjectType.hasReferenceName",
    "class_name": "com.google.javascript.rhino.jstype.PrototypeObjectType",
    "signature": "com.google.javascript.rhino.jstype.PrototypeObjectType.hasReferenceName()",
    "snippet": "  @Override\n  public boolean hasReferenceName() {\n    return className != null || ownerFunction != null;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 0
  },
  {
    "name": "PrototypeObjectType.implicitPrototypeChainIsUnknown",
    "class_name": "com.google.javascript.rhino.jstype.PrototypeObjectType",
    "signature": "com.google.javascript.rhino.jstype.PrototypeObjectType.implicitPrototypeChainIsUnknown()",
    "snippet": "  private boolean implicitPrototypeChainIsUnknown() {\n    ObjectType p = getImplicitPrototype();\n    while (p != null) {\n      if (p.isUnknownType()) {\n        return true;\n      }\n      p = p.getImplicitPrototype();\n    }\n    return false;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 0
  },
  {
    "name": "PrototypeObjectType.isNativeObjectType",
    "class_name": "com.google.javascript.rhino.jstype.PrototypeObjectType",
    "signature": "com.google.javascript.rhino.jstype.PrototypeObjectType.isNativeObjectType()",
    "snippet": "  @Override\n  public boolean isNativeObjectType() {\n    return nativeType;\n  }",
    "comment": "Whether this is a built-in object. */",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 0
  },
  {
    "name": "PrototypeObjectType.isSubtype",
    "class_name": "com.google.javascript.rhino.jstype.PrototypeObjectType",
    "signature": "com.google.javascript.rhino.jstype.PrototypeObjectType.isSubtype(JSType)",
    "snippet": "  @Override\n  public boolean isSubtype(JSType that) {\n    if (JSType.isSubtypeHelper(this, that)) {\n      return true;\n    }\n\n    // Union types\n    if (that.isUnionType()) {\n      // The static {@code JSType.isSubtype} check already decomposed\n      // union types, so we don't need to check those again.\n      return false;\n    }\n\n    // record types\n    if (that.isRecordType()) {\n      return RecordType.isSubtype(this, that.toMaybeRecordType());\n    }\n\n    // Interfaces\n    // Find all the interfaces implemented by this class and compare each one\n    // to the interface instance.\n    ObjectType thatObj = that.toObjectType();\n    ObjectType thatCtor = thatObj == null ? null : thatObj.getConstructor();\n    if (thatCtor != null && thatCtor.isInterface()) {\n      Iterable<ObjectType> thisInterfaces = getCtorImplementedInterfaces();\n      for (ObjectType thisInterface : thisInterfaces) {\n        if (thisInterface.isSubtype(that)) {\n          return true;\n        }\n      }\n    }\n\n    if (getConstructor() != null && getConstructor().isInterface()) {\n      for (ObjectType thisInterface : getCtorExtendedInterfaces()) {\n        if (thisInterface.isSubtype(that)) {\n          return true;\n        }\n      }\n    }\n\n    // other prototype based objects\n    if (isUnknownType() || implicitPrototypeChainIsUnknown()) {\n      // If unsure, say 'yes', to avoid spurious warnings.\n      // TODO(user): resolve the prototype chain completely in all cases,\n      // to avoid guessing.\n      return true;\n    }\n    return this.isImplicitPrototype(thatObj);\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 0
  },
  {
    "name": "PrototypeObjectType.setImplicitPrototype",
    "class_name": "com.google.javascript.rhino.jstype.PrototypeObjectType",
    "signature": "com.google.javascript.rhino.jstype.PrototypeObjectType.setImplicitPrototype(ObjectType)",
    "snippet": "  final void setImplicitPrototype(ObjectType implicitPrototype) {\n    checkState(!hasCachedValues());\n    this.implicitPrototypeFallback = implicitPrototype;\n  }",
    "comment": " This should only be reset on the FunctionPrototypeType, only to fix an incorrectly established prototype chain due to the user having a mismatch in super class declaration, and only before properties on that type are processed. ",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 0
  },
  {
    "name": "PrototypeObjectType.setOwnerFunction",
    "class_name": "com.google.javascript.rhino.jstype.PrototypeObjectType",
    "signature": "com.google.javascript.rhino.jstype.PrototypeObjectType.setOwnerFunction(FunctionType)",
    "snippet": "  @Override\n  void setOwnerFunction(FunctionType type) {\n    Preconditions.checkState(ownerFunction == null || type == null);\n    ownerFunction = type;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 0
  },
  {
    "name": "PrototypeObjectType.setPrettyPrint",
    "class_name": "com.google.javascript.rhino.jstype.PrototypeObjectType",
    "signature": "com.google.javascript.rhino.jstype.PrototypeObjectType.setPrettyPrint(boolean)",
    "snippet": "  void setPrettyPrint(boolean prettyPrint) {\n    this.prettyPrint = prettyPrint;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 0
  },
  {
    "name": "StringType.StringType",
    "class_name": "com.google.javascript.rhino.jstype.StringType",
    "signature": "com.google.javascript.rhino.jstype.StringType.StringType(JSTypeRegistry)",
    "snippet": "  StringType(JSTypeRegistry registry) {\n    super(registry);\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 0
  },
  {
    "name": "StringType.getDisplayName",
    "class_name": "com.google.javascript.rhino.jstype.StringType",
    "signature": "com.google.javascript.rhino.jstype.StringType.getDisplayName()",
    "snippet": "  @Override\n  public String getDisplayName() {\n    return \"string\";\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 0
  },
  {
    "name": "StringType.toStringHelper",
    "class_name": "com.google.javascript.rhino.jstype.StringType",
    "signature": "com.google.javascript.rhino.jstype.StringType.toStringHelper(boolean)",
    "snippet": "  @Override\n  String toStringHelper(boolean forAnnotations) {\n    return getDisplayName();\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 0
  },
  {
    "name": "UnionType.UnionType",
    "class_name": "com.google.javascript.rhino.jstype.UnionType",
    "signature": "com.google.javascript.rhino.jstype.UnionType.UnionType(JSTypeRegistry,Collection)",
    "snippet": "  UnionType(JSTypeRegistry registry, Collection<JSType> alternates) {\n    super(registry);\n    this.alternates = alternates;\n    this.hashcode = this.alternates.hashCode();\n  }",
    "comment": " Creates a union type.  @param alternates the alternates of the union ",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 0
  },
  {
    "name": "UnionTypeBuilder.UnionTypeBuilder",
    "class_name": "com.google.javascript.rhino.jstype.UnionTypeBuilder",
    "signature": "com.google.javascript.rhino.jstype.UnionTypeBuilder.UnionTypeBuilder(JSTypeRegistry)",
    "snippet": "  UnionTypeBuilder(JSTypeRegistry registry) {\n    this(registry, DEFAULT_MAX_UNION_SIZE);\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 0
  },
  {
    "name": "UnionTypeBuilder.UnionTypeBuilder",
    "class_name": "com.google.javascript.rhino.jstype.UnionTypeBuilder",
    "signature": "com.google.javascript.rhino.jstype.UnionTypeBuilder.UnionTypeBuilder(JSTypeRegistry,int)",
    "snippet": "  UnionTypeBuilder(JSTypeRegistry registry, int maxUnionSize) {\n    this.registry = registry;\n    this.maxUnionSize = maxUnionSize;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 0
  },
  {
    "name": "UnionTypeBuilder.addAlternate",
    "class_name": "com.google.javascript.rhino.jstype.UnionTypeBuilder",
    "signature": "com.google.javascript.rhino.jstype.UnionTypeBuilder.addAlternate(JSType)",
    "snippet": "  UnionTypeBuilder addAlternate(JSType alternate) {\n    // build() returns the bottom type by default, so we can\n    // just bail out early here.\n    if (alternate.isNoType()) {\n      return this;\n    }\n\n    isAllType = isAllType || alternate.isAllType();\n\n    boolean isAlternateUnknown = alternate instanceof UnknownType;\n    isNativeUnknownType = isNativeUnknownType || isAlternateUnknown;\n    if (isAlternateUnknown) {\n      areAllUnknownsChecked = areAllUnknownsChecked &&\n          alternate.isCheckedUnknownType();\n    }\n    if (!isAllType && !isNativeUnknownType) {\n      if (alternate.isUnionType()) {\n        UnionType union = alternate.toMaybeUnionType();\n        for (JSType unionAlt : union.getAlternates()) {\n          addAlternate(unionAlt);\n        }\n      } else {\n        if (alternates.size() > maxUnionSize) {\n          return this;\n        }\n\n        // Function types are special, because they have their\n        // own bizarro sub-lattice. See the commants on\n        // FunctionType#supAndInf helper and above at functionTypePosition.\n        if (alternate.isFunctionType() && functionTypePosition != -1) {\n          // See the comments on functionTypePosition above.\n          FunctionType other =\n              alternates.get(functionTypePosition).toMaybeFunctionType();\n          FunctionType supremum =\n              alternate.toMaybeFunctionType().supAndInfHelper(other, true);\n          alternates.set(functionTypePosition, supremum);\n          result = null;\n          return this;\n        }\n\n        // Look through the alternates we've got so far,\n        // and check if any of them are duplicates of\n        // one another.\n        int currentIndex = 0;\n        Iterator<JSType> it = alternates.iterator();\n        while (it.hasNext()) {\n          JSType current = it.next();\n\n          // Unknown and NoResolved types may just be names that haven't\n          // been resolved yet. So keep these in the union, and just use\n          // equality checking for simple de-duping.\n          if (alternate.isUnknownType() ||\n              current.isUnknownType() ||\n              alternate.isNoResolvedType() ||\n              current.isNoResolvedType()) {\n            if (alternate.isEquivalentTo(current)) {\n              // Alternate is unnecessary.\n              return this;\n            }\n          } else {\n            if (alternate.isSubtype(current)) {\n              // Alternate is unnecessary.\n              return this;\n            } else if (current.isSubtype(alternate)) {\n              // Alternate makes current obsolete\n              it.remove();\n\n              if (currentIndex == functionTypePosition) {\n                functionTypePosition = -1;\n              } else if (currentIndex < functionTypePosition) {\n                functionTypePosition--;\n                currentIndex--;\n              }\n            }\n          }\n          currentIndex++;\n        }\n\n        if (alternate.isFunctionType()) {\n          // See the comments on functionTypePosition above.\n          Preconditions.checkState(functionTypePosition == -1);\n          functionTypePosition = alternates.size();\n        }\n\n        alternates.add(alternate);\n        result = null; // invalidate the memoized result\n      }\n    } else {\n      result = null;\n    }\n    return this;\n  }",
    "comment": " Adds an alternate to the union type under construction. Returns this for easy chaining. ",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 0
  },
  {
    "name": "UnionTypeBuilder.build",
    "class_name": "com.google.javascript.rhino.jstype.UnionTypeBuilder",
    "signature": "com.google.javascript.rhino.jstype.UnionTypeBuilder.build()",
    "snippet": "  JSType build() {\n    if (result == null) {\n      result = reduceAlternatesWithoutUnion();\n      if (result == null) {\n        result = new UnionType(registry, getAlternateListCopy());\n      }\n    }\n    return result;\n  }",
    "comment": " Creates a union. @return A UnionType if it has two or more alternates, the only alternate if it has one and otherwise {@code NO_TYPE}. ",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 0
  },
  {
    "name": "UnionTypeBuilder.getAlternateListCopy",
    "class_name": "com.google.javascript.rhino.jstype.UnionTypeBuilder",
    "signature": "com.google.javascript.rhino.jstype.UnionTypeBuilder.getAlternateListCopy()",
    "snippet": "  private Collection<JSType> getAlternateListCopy() {\n    return ImmutableList.copyOf(alternates);\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 0
  },
  {
    "name": "UnionTypeBuilder.reduceAlternatesWithoutUnion",
    "class_name": "com.google.javascript.rhino.jstype.UnionTypeBuilder",
    "signature": "com.google.javascript.rhino.jstype.UnionTypeBuilder.reduceAlternatesWithoutUnion()",
    "snippet": "  private JSType reduceAlternatesWithoutUnion() {\n    if (isAllType) {\n      return registry.getNativeType(ALL_TYPE);\n    } else if (isNativeUnknownType) {\n      if (areAllUnknownsChecked) {\n        return registry.getNativeType(CHECKED_UNKNOWN_TYPE);\n      } else {\n        return registry.getNativeType(UNKNOWN_TYPE);\n      }\n    } else {\n      int size = alternates.size();\n      if (size > maxUnionSize) {\n        return registry.getNativeType(UNKNOWN_TYPE);\n      } else if (size > 1) {\n        return null;\n      } else if (size == 1) {\n        return alternates.iterator().next();\n      } else {\n        return registry.getNativeType(NO_TYPE);\n      }\n    }\n  }",
    "comment": " Reduce the alternates into a non-union type. If the alternates can't be accurately represented with a non-union type, return null. ",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 0
  },
  {
    "name": "UnknownType.UnknownType",
    "class_name": "com.google.javascript.rhino.jstype.UnknownType",
    "signature": "com.google.javascript.rhino.jstype.UnknownType.UnknownType(JSTypeRegistry,boolean)",
    "snippet": "  UnknownType(JSTypeRegistry registry, boolean isChecked) {\n    super(registry);\n    this.isChecked = isChecked;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 0
  },
  {
    "name": "ValueType.ValueType",
    "class_name": "com.google.javascript.rhino.jstype.ValueType",
    "signature": "com.google.javascript.rhino.jstype.ValueType.ValueType(JSTypeRegistry)",
    "snippet": "  ValueType(JSTypeRegistry registry) {\n    super(registry);\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 0
  },
  {
    "name": "VoidType.VoidType",
    "class_name": "com.google.javascript.rhino.jstype.VoidType",
    "signature": "com.google.javascript.rhino.jstype.VoidType.VoidType(JSTypeRegistry)",
    "snippet": "  VoidType(JSTypeRegistry registry) {\n    super(registry);\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 0
  },
  {
    "name": "VoidType.getDisplayName",
    "class_name": "com.google.javascript.rhino.jstype.VoidType",
    "signature": "com.google.javascript.rhino.jstype.VoidType.getDisplayName()",
    "snippet": "  @Override\n  public String getDisplayName() {\n    return \"undefined\";\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 0
  },
  {
    "name": "VoidType.toStringHelper",
    "class_name": "com.google.javascript.rhino.jstype.VoidType",
    "signature": "com.google.javascript.rhino.jstype.VoidType.toStringHelper(boolean)",
    "snippet": "  @Override\n  String toStringHelper(boolean forAnnotations) {\n    return getDisplayName();\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 0
  }
]