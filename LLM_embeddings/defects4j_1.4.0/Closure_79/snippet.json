[
  {
    "name": "AbstractCompiler.getLifeCycleStage",
    "class_name": "com.google.javascript.jscomp.AbstractCompiler",
    "signature": "com.google.javascript.jscomp.AbstractCompiler.getLifeCycleStage()",
    "snippet": "  LifeCycleStage getLifeCycleStage() {\n    return stage;\n  }",
    "comment": " @return The current life-cycle stage of the AST we're working on. ",
    "is_bug": false,
    "failing_test_cases": 5,
    "buggy_methods": 2
  },
  {
    "name": "LifeCycleStage.isNormalizedObfuscated",
    "class_name": "com.google.javascript.jscomp.AbstractCompiler$LifeCycleStage",
    "signature": "com.google.javascript.jscomp.AbstractCompiler$LifeCycleStage.isNormalizedObfuscated()",
    "snippet": "    boolean isNormalizedObfuscated() {\n      return this == NORMALIZED_OBFUSCATED;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 5,
    "buggy_methods": 2
  },
  {
    "name": "AbstractMessageFormatter.AbstractMessageFormatter",
    "class_name": "com.google.javascript.jscomp.AbstractMessageFormatter",
    "signature": "com.google.javascript.jscomp.AbstractMessageFormatter.AbstractMessageFormatter(SourceExcerptProvider)",
    "snippet": "  public AbstractMessageFormatter(SourceExcerptProvider source) {\n    this.source = source;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 5,
    "buggy_methods": 2
  },
  {
    "name": "AbstractMessageFormatter.setColorize",
    "class_name": "com.google.javascript.jscomp.AbstractMessageFormatter",
    "signature": "com.google.javascript.jscomp.AbstractMessageFormatter.setColorize(boolean)",
    "snippet": "  public void setColorize(boolean colorize) {\n    this.colorize = colorize;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 5,
    "buggy_methods": 2
  },
  {
    "name": "BasicErrorManager.getErrorCount",
    "class_name": "com.google.javascript.jscomp.BasicErrorManager",
    "signature": "com.google.javascript.jscomp.BasicErrorManager.getErrorCount()",
    "snippet": "  public int getErrorCount() {\n    return errorCount;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 5,
    "buggy_methods": 2
  },
  {
    "name": "BasicErrorManager.getErrors",
    "class_name": "com.google.javascript.jscomp.BasicErrorManager",
    "signature": "com.google.javascript.jscomp.BasicErrorManager.getErrors()",
    "snippet": "  public JSError[] getErrors() {\n    return toArray(CheckLevel.ERROR);\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 5,
    "buggy_methods": 2
  },
  {
    "name": "BasicErrorManager.toArray",
    "class_name": "com.google.javascript.jscomp.BasicErrorManager",
    "signature": "com.google.javascript.jscomp.BasicErrorManager.toArray(CheckLevel)",
    "snippet": "  private JSError[] toArray(CheckLevel level) {\n    List<JSError> errors = new ArrayList<JSError>(messages.size());\n    for (ErrorWithLevel p : messages) {\n      if (p.level == level) {\n        errors.add(p.error);\n      }\n    }\n    return errors.toArray(new JSError[errors.size()]);\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 5,
    "buggy_methods": 2
  },
  {
    "name": "CheckLevel.isOn",
    "class_name": "com.google.javascript.jscomp.CheckLevel",
    "signature": "com.google.javascript.jscomp.CheckLevel.isOn()",
    "snippet": "  boolean isOn() {\n    return this != OFF;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 5,
    "buggy_methods": 2
  },
  {
    "name": "RecentChange.hasCodeChanged",
    "class_name": "com.google.javascript.jscomp.CodeChangeHandler$RecentChange",
    "signature": "com.google.javascript.jscomp.CodeChangeHandler$RecentChange.hasCodeChanged()",
    "snippet": "    boolean hasCodeChanged() {\n      return hasChanged;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 5,
    "buggy_methods": 2
  },
  {
    "name": "RecentChange.reset",
    "class_name": "com.google.javascript.jscomp.CodeChangeHandler$RecentChange",
    "signature": "com.google.javascript.jscomp.CodeChangeHandler$RecentChange.reset()",
    "snippet": "    void reset() {\n      hasChanged = false;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 5,
    "buggy_methods": 2
  },
  {
    "name": "Compiler.Compiler",
    "class_name": "com.google.javascript.jscomp.Compiler",
    "signature": "com.google.javascript.jscomp.Compiler.Compiler()",
    "snippet": "  public Compiler() {\n    this((PrintStream) null);\n  }",
    "comment": " Creates a Compiler that reports errors and warnings to its logger. ",
    "is_bug": false,
    "failing_test_cases": 5,
    "buggy_methods": 2
  },
  {
    "name": "Compiler.Compiler",
    "class_name": "com.google.javascript.jscomp.Compiler",
    "signature": "com.google.javascript.jscomp.Compiler.Compiler(PrintStream)",
    "snippet": "  public Compiler(PrintStream stream) {\n    addChangeHandler(recentChange);\n    outStream = stream;\n  }",
    "comment": " Creates n Compiler that reports errors and warnings to an output stream. ",
    "is_bug": false,
    "failing_test_cases": 5,
    "buggy_methods": 2
  },
  {
    "name": "Compiler.acceptConstKeyword",
    "class_name": "com.google.javascript.jscomp.Compiler",
    "signature": "com.google.javascript.jscomp.Compiler.acceptConstKeyword()",
    "snippet": "  @Override\n  public boolean acceptConstKeyword() {\n    return options.acceptConstKeyword;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 5,
    "buggy_methods": 2
  },
  {
    "name": "Compiler.acceptEcmaScript5",
    "class_name": "com.google.javascript.jscomp.Compiler",
    "signature": "com.google.javascript.jscomp.Compiler.acceptEcmaScript5()",
    "snippet": "  @Override\n  public boolean acceptEcmaScript5() {\n    return options.languageIn == LanguageMode.ECMASCRIPT5;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 5,
    "buggy_methods": 2
  },
  {
    "name": "Compiler.addChangeHandler",
    "class_name": "com.google.javascript.jscomp.Compiler",
    "signature": "com.google.javascript.jscomp.Compiler.addChangeHandler(CodeChangeHandler)",
    "snippet": "  @Override\n  void addChangeHandler(CodeChangeHandler handler) {\n    codeChangeHandlers.add(handler);\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 5,
    "buggy_methods": 2
  },
  {
    "name": "Compiler.checkFirstModule",
    "class_name": "com.google.javascript.jscomp.Compiler",
    "signature": "com.google.javascript.jscomp.Compiler.checkFirstModule(List)",
    "snippet": "  private void checkFirstModule(List<JSModule> modules) {\n    if (modules.isEmpty()) {\n      report(JSError.make(EMPTY_MODULE_LIST_ERROR));\n    } else if (modules.get(0).getInputs().isEmpty() && modules.size() > 1) {\n      // The root module may only be empty if there is exactly 1 module.\n      report(JSError.make(EMPTY_ROOT_MODULE_ERROR,\n          modules.get(0).getName()));\n    }\n  }",
    "comment": " Verifies that at least one module has been provided and that the first one has at least one source code input. ",
    "is_bug": false,
    "failing_test_cases": 5,
    "buggy_methods": 2
  },
  {
    "name": "Compiler.createMessageFormatter",
    "class_name": "com.google.javascript.jscomp.Compiler",
    "signature": "com.google.javascript.jscomp.Compiler.createMessageFormatter()",
    "snippet": "  private MessageFormatter createMessageFormatter() {\n    boolean colorize = options.shouldColorizeErrorOutput();\n    return options.errorFormat.toFormatter(this, colorize);\n  }",
    "comment": " Creates a message formatter instance corresponding to the value of {@link CompilerOptions}. ",
    "is_bug": false,
    "failing_test_cases": 5,
    "buggy_methods": 2
  },
  {
    "name": "Compiler.fillEmptyModules",
    "class_name": "com.google.javascript.jscomp.Compiler",
    "signature": "com.google.javascript.jscomp.Compiler.fillEmptyModules(List)",
    "snippet": "  private static void fillEmptyModules(List<JSModule> modules) {\n    for (JSModule module : modules) {\n      if (module.getInputs().isEmpty()) {\n        module.add(JSSourceFile.fromCode(\"[\" + module.getName() + \"]\", \"\"));\n      }\n    }\n  }",
    "comment": " Fill any empty modules with a place holder file. It makes any cross module motion easier. ",
    "is_bug": false,
    "failing_test_cases": 5,
    "buggy_methods": 2
  },
  {
    "name": "Compiler.getAllInputsFromModules",
    "class_name": "com.google.javascript.jscomp.Compiler",
    "signature": "com.google.javascript.jscomp.Compiler.getAllInputsFromModules(List)",
    "snippet": "  private static List<CompilerInput> getAllInputsFromModules(\n      List<JSModule> modules) {\n    List<CompilerInput> inputs = Lists.newArrayList();\n    Map<String, JSModule> inputMap = Maps.newHashMap();\n    for (JSModule module : modules) {\n      for (CompilerInput input : module.getInputs()) {\n        String inputName = input.getName();\n\n        // NOTE(nicksantos): If an input is in more than one module,\n        // it will show up twice in the inputs list, and then we\n        // will get an error down the line.\n        inputs.add(input);\n        inputMap.put(inputName, module);\n      }\n    }\n    return inputs;\n  }",
    "comment": " Builds a single list of all module inputs. Verifies that it contains no duplicates. ",
    "is_bug": false,
    "failing_test_cases": 5,
    "buggy_methods": 2
  },
  {
    "name": "Compiler.getCodingConvention",
    "class_name": "com.google.javascript.jscomp.Compiler",
    "signature": "com.google.javascript.jscomp.Compiler.getCodingConvention()",
    "snippet": "  @Override\n  public CodingConvention getCodingConvention() {\n    CodingConvention convention = options.getCodingConvention();\n    convention = convention != null ? convention : defaultCodingConvention;\n    return convention;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 5,
    "buggy_methods": 2
  },
  {
    "name": "Compiler.getDefaultErrorReporter",
    "class_name": "com.google.javascript.jscomp.Compiler",
    "signature": "com.google.javascript.jscomp.Compiler.getDefaultErrorReporter()",
    "snippet": "  @Override\n  ErrorReporter getDefaultErrorReporter() {\n    return defaultErrorReporter;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 5,
    "buggy_methods": 2
  },
  {
    "name": "Compiler.getDiagnosticGroups",
    "class_name": "com.google.javascript.jscomp.Compiler",
    "signature": "com.google.javascript.jscomp.Compiler.getDiagnosticGroups()",
    "snippet": "  protected DiagnosticGroups getDiagnosticGroups() {\n    return new DiagnosticGroups();\n  }",
    "comment": " The warning classes that are available from the command-line, and are suppressable by the {@code @suppress} annotation. ",
    "is_bug": false,
    "failing_test_cases": 5,
    "buggy_methods": 2
  },
  {
    "name": "Compiler.getErrorCount",
    "class_name": "com.google.javascript.jscomp.Compiler",
    "signature": "com.google.javascript.jscomp.Compiler.getErrorCount()",
    "snippet": "  public int getErrorCount() {\n    return errorManager.getErrorCount();\n  }",
    "comment": " Gets the number of errors. ",
    "is_bug": false,
    "failing_test_cases": 5,
    "buggy_methods": 2
  },
  {
    "name": "Compiler.getErrors",
    "class_name": "com.google.javascript.jscomp.Compiler",
    "signature": "com.google.javascript.jscomp.Compiler.getErrors()",
    "snippet": "  public JSError[] getErrors() {\n    return errorManager.getErrors();\n  }",
    "comment": " Returns the array of errors (never null). ",
    "is_bug": false,
    "failing_test_cases": 5,
    "buggy_methods": 2
  },
  {
    "name": "Compiler.getInput",
    "class_name": "com.google.javascript.jscomp.Compiler",
    "signature": "com.google.javascript.jscomp.Compiler.getInput(String)",
    "snippet": "  @Override\n  public CompilerInput getInput(String name) {\n    return inputsByName.get(name);\n  }",
    "comment": "interface, and which ones should always be injected.",
    "is_bug": false,
    "failing_test_cases": 5,
    "buggy_methods": 2
  },
  {
    "name": "Compiler.getParserConfig",
    "class_name": "com.google.javascript.jscomp.Compiler",
    "signature": "com.google.javascript.jscomp.Compiler.getParserConfig()",
    "snippet": "  @Override\n  Config getParserConfig() {\n    if (parserConfig == null) {\n      parserConfig = ParserRunner.createConfig(\n        isIdeMode(), acceptEcmaScript5(), acceptConstKeyword());\n    }\n    return parserConfig;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 5,
    "buggy_methods": 2
  },
  {
    "name": "Compiler.getTypeRegistry",
    "class_name": "com.google.javascript.jscomp.Compiler",
    "signature": "com.google.javascript.jscomp.Compiler.getTypeRegistry()",
    "snippet": "  @Override\n  public JSTypeRegistry getTypeRegistry() {\n    if (typeRegistry == null) {\n      typeRegistry = new JSTypeRegistry(oldErrorReporter, options.looseTypes);\n    }\n    return typeRegistry;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 5,
    "buggy_methods": 2
  },
  {
    "name": "Compiler.hasErrors",
    "class_name": "com.google.javascript.jscomp.Compiler",
    "signature": "com.google.javascript.jscomp.Compiler.hasErrors()",
    "snippet": "  public boolean hasErrors() {\n    return hasHaltingErrors();\n  }",
    "comment": " Consults the {@link ErrorManager} to see if we've encountered errors that should halt compilation. <p>  If {@link CompilerOptions#ideMode} is {@code true}, this function always returns {@code false} without consulting the error manager. The error manager will continue to be told about new errors and warnings, but the compiler will complete compilation of all inputs.<p> ",
    "is_bug": false,
    "failing_test_cases": 5,
    "buggy_methods": 2
  },
  {
    "name": "Compiler.hasHaltingErrors",
    "class_name": "com.google.javascript.jscomp.Compiler",
    "signature": "com.google.javascript.jscomp.Compiler.hasHaltingErrors()",
    "snippet": "  @Override\n  boolean hasHaltingErrors() {\n    return !isIdeMode() && getErrorCount() > 0;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 5,
    "buggy_methods": 2
  },
  {
    "name": "Compiler.init",
    "class_name": "com.google.javascript.jscomp.Compiler",
    "signature": "com.google.javascript.jscomp.Compiler.init(JSSourceFile[],JSSourceFile[],CompilerOptions)",
    "snippet": "  public void init(JSSourceFile[] externs, JSSourceFile[] inputs,\n      CompilerOptions options) {\n    init(Lists.<JSSourceFile>newArrayList(externs),\n        Lists.<JSSourceFile>newArrayList(inputs), options);\n  }",
    "comment": " Initializes the instance state needed for a compile job. ",
    "is_bug": false,
    "failing_test_cases": 5,
    "buggy_methods": 2
  },
  {
    "name": "Compiler.init",
    "class_name": "com.google.javascript.jscomp.Compiler",
    "signature": "com.google.javascript.jscomp.Compiler.init(List,List,CompilerOptions)",
    "snippet": "  public void init(List<JSSourceFile> externs, List<JSSourceFile> inputs,\n      CompilerOptions options) {\n    JSModule module = new JSModule(\"[singleton]\");\n    for (JSSourceFile input : inputs) {\n      module.add(input);\n    }\n\n    initModules(externs, Lists.newArrayList(module), options);\n  }",
    "comment": " Initializes the instance state needed for a compile job. ",
    "is_bug": false,
    "failing_test_cases": 5,
    "buggy_methods": 2
  },
  {
    "name": "Compiler.initBasedOnOptions",
    "class_name": "com.google.javascript.jscomp.Compiler",
    "signature": "com.google.javascript.jscomp.Compiler.initBasedOnOptions()",
    "snippet": "  private void initBasedOnOptions() {\n    // Create the source map if necessary.\n    if (options.sourceMapOutputPath != null) {\n      sourceMap = options.sourceMapFormat.getInstance();\n    }\n  }",
    "comment": " Do any initialization that is dependent on the compiler options. ",
    "is_bug": false,
    "failing_test_cases": 5,
    "buggy_methods": 2
  },
  {
    "name": "Compiler.initInputsByNameMap",
    "class_name": "com.google.javascript.jscomp.Compiler",
    "signature": "com.google.javascript.jscomp.Compiler.initInputsByNameMap()",
    "snippet": "  void initInputsByNameMap() {\n    inputsByName = new HashMap<String, CompilerInput>();\n    for (CompilerInput input : externs) {\n      String name = input.getName();\n      if (!inputsByName.containsKey(name)) {\n        inputsByName.put(name, input);\n      } else {\n        report(JSError.make(DUPLICATE_EXTERN_INPUT, name));\n      }\n    }\n    for (CompilerInput input : inputs) {\n      String name = input.getName();\n      if (!inputsByName.containsKey(name)) {\n        inputsByName.put(name, input);\n      } else {\n        report(JSError.make(DUPLICATE_INPUT, name));\n      }\n    }\n  }",
    "comment": " Creates a map to make looking up an input by name fast. Also checks for duplicate inputs. ",
    "is_bug": false,
    "failing_test_cases": 5,
    "buggy_methods": 2
  },
  {
    "name": "Compiler.initModules",
    "class_name": "com.google.javascript.jscomp.Compiler",
    "signature": "com.google.javascript.jscomp.Compiler.initModules(List,List,CompilerOptions)",
    "snippet": "  public void initModules(\n      List<JSSourceFile> externs, List<JSModule> modules,\n      CompilerOptions options) {\n    initOptions(options);\n\n    checkFirstModule(modules);\n    fillEmptyModules(modules);\n\n    this.externs = makeCompilerInput(externs, true);\n\n    // Generate the module graph, and report any errors in the module\n    // specification as errors.\n    this.modules = modules;\n    if (modules.size() > 1) {\n      try {\n        this.moduleGraph = new JSModuleGraph(modules);\n      } catch (JSModuleGraph.ModuleDependenceException e) {\n        // problems with the module format.  Report as an error.  The\n        // message gives all details.\n        report(JSError.make(MODULE_DEPENDENCY_ERROR,\n                e.getModule().getName(), e.getDependentModule().getName()));\n        return;\n      }\n    } else {\n      this.moduleGraph = null;\n    }\n\n    this.inputs = getAllInputsFromModules(modules);\n    initBasedOnOptions();\n\n    initInputsByNameMap();\n  }",
    "comment": " Initializes the instance state needed for a compile job if the sources are in modules. ",
    "is_bug": false,
    "failing_test_cases": 5,
    "buggy_methods": 2
  },
  {
    "name": "Compiler.initOptions",
    "class_name": "com.google.javascript.jscomp.Compiler",
    "signature": "com.google.javascript.jscomp.Compiler.initOptions(CompilerOptions)",
    "snippet": "  public void initOptions(CompilerOptions options) {\n    this.options = options;\n    if (errorManager == null) {\n      if (outStream == null) {\n        setErrorManager(\n            new LoggerErrorManager(createMessageFormatter(), logger));\n      } else {\n        PrintStreamErrorManager printer =\n            new PrintStreamErrorManager(createMessageFormatter(), outStream);\n        printer.setSummaryDetailLevel(options.summaryDetailLevel);\n        setErrorManager(printer);\n      }\n    }\n\n    // Initialize the warnings guard.\n    List<WarningsGuard> guards = Lists.newArrayList();\n    guards.add(\n        new SuppressDocWarningsGuard(\n            getDiagnosticGroups().getRegisteredGroups()));\n    WarningsGuard warningsGuard = options.getWarningsGuard();\n    if (warningsGuard != null) {\n      guards.add(options.getWarningsGuard());\n    }\n\n    // All passes must run the variable check. This synthesizes\n    // variables later so that the compiler doesn't crash. It also\n    // checks the externs file for validity. If you don't want to warn\n    // about missing variable declarations, we shut that specific\n    // error off.\n    if (!options.checkSymbols &&\n        (warningsGuard == null || !warningsGuard.disables(\n            DiagnosticGroups.CHECK_VARIABLES))) {\n      guards.add(new DiagnosticGroupWarningsGuard(\n          DiagnosticGroups.CHECK_VARIABLES, CheckLevel.OFF));\n    }\n    this.warningsGuard = new ComposeWarningsGuard(guards);\n  }",
    "comment": " Initialize the compiler options. Only necessary if you're not doing a normal compile() job. ",
    "is_bug": false,
    "failing_test_cases": 5,
    "buggy_methods": 2
  },
  {
    "name": "Compiler.isIdeMode",
    "class_name": "com.google.javascript.jscomp.Compiler",
    "signature": "com.google.javascript.jscomp.Compiler.isIdeMode()",
    "snippet": "  @Override\n  public boolean isIdeMode() {\n    return options.ideMode;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 5,
    "buggy_methods": 2
  },
  {
    "name": "Compiler.makeCompilerInput",
    "class_name": "com.google.javascript.jscomp.Compiler",
    "signature": "com.google.javascript.jscomp.Compiler.makeCompilerInput(List,boolean)",
    "snippet": "  private List<CompilerInput> makeCompilerInput(\n      List<JSSourceFile> files, boolean isExtern) {\n    List<CompilerInput> inputs = Lists.newArrayList();\n    for (JSSourceFile file : files) {\n      inputs.add(new CompilerInput(file, isExtern));\n    }\n    return inputs;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 5,
    "buggy_methods": 2
  },
  {
    "name": "Compiler.newTracer",
    "class_name": "com.google.javascript.jscomp.Compiler",
    "signature": "com.google.javascript.jscomp.Compiler.newTracer(String)",
    "snippet": "  Tracer newTracer(String passName) {\n    String comment = passName\n        + (recentChange.hasCodeChanged() ? \" on recently changed AST\" : \"\");\n    if (options.tracer.isOn()) {\n      tracker.recordPassStart(passName);\n    }\n    return new Tracer(\"Compiler\", comment);\n  }",
    "comment": " Returns a new tracer for the given pass name. ",
    "is_bug": false,
    "failing_test_cases": 5,
    "buggy_methods": 2
  },
  {
    "name": "Compiler.parseInputs",
    "class_name": "com.google.javascript.jscomp.Compiler",
    "signature": "com.google.javascript.jscomp.Compiler.parseInputs()",
    "snippet": "  Node parseInputs() {\n    boolean devMode = options.devMode != DevMode.OFF;\n\n    // If old roots exist (we are parsing a second time), detach each of the\n    // individual file parse trees.\n    if (externsRoot != null) {\n      externsRoot.detachChildren();\n    }\n    if (jsRoot != null) {\n      jsRoot.detachChildren();\n    }\n\n    // Parse main js sources.\n    jsRoot = new Node(Token.BLOCK);\n    jsRoot.setIsSyntheticBlock(true);\n\n    if (options.tracer.isOn()) {\n      tracker = new PerformanceTracker(jsRoot,\n          options.tracer == TracerMode.ALL);\n      addChangeHandler(tracker.getCodeChangeHandler());\n    }\n\n    Tracer tracer = newTracer(\"parseInputs\");\n\n    try {\n      // Parse externs sources.\n      externsRoot = new Node(Token.BLOCK);\n      externsRoot.setIsSyntheticBlock(true);\n      for (CompilerInput input : externs) {\n        Node n = input.getAstRoot(this);\n        if (hasErrors()) {\n          return null;\n        }\n        externsRoot.addChildToBack(n);\n      }\n\n      // Check if the sources need to be re-ordered.\n      if (options.manageClosureDependencies) {\n        for (CompilerInput input : inputs) {\n          input.setCompiler(this);\n\n          // Forward-declare all the provided types, so that they\n          // are not flagged even if they are dropped from the process.\n          for (String provide : input.getProvides()) {\n            getTypeRegistry().forwardDeclareType(provide);\n          }\n        }\n\n        try {\n          inputs =\n              (moduleGraph == null ? new JSModuleGraph(modules) : moduleGraph)\n              .manageDependencies(\n                  options.manageClosureDependenciesEntryPoints, inputs);\n        } catch (CircularDependencyException e) {\n          report(JSError.make(\n              JSModule.CIRCULAR_DEPENDENCY_ERROR, e.getMessage()));\n          return null;\n        } catch (MissingProvideException e) {\n          report(JSError.make(\n              MISSING_ENTRY_ERROR, e.getMessage()));\n          return null;\n        }\n      }\n\n      // Check if inputs need to be rebuilt from modules.\n      boolean staleInputs = false;\n      for (CompilerInput input : inputs) {\n        Node n = input.getAstRoot(this);\n        if (hasErrors()) {\n          return null;\n        }\n\n        // Inputs can have a null AST during initial parse.\n        if (n == null) {\n          continue;\n        }\n\n        if (n.getJSDocInfo() != null) {\n          JSDocInfo info = n.getJSDocInfo();\n          if (info.isExterns()) {\n            // If the input file is explicitly marked as an externs file, then\n            // assume the programmer made a mistake and throw it into\n            // the externs pile anyways.\n            externsRoot.addChildToBack(n);\n            input.setIsExtern(true);\n\n            input.getModule().remove(input);\n\n            externs.add(input);\n            staleInputs = true;\n          } else if (info.isNoCompile()) {\n            input.getModule().remove(input);\n            staleInputs = true;\n          }\n        }\n      }\n\n      if (staleInputs) {\n        fillEmptyModules(modules);\n        rebuildInputsFromModules();\n      }\n\n      // Build the AST.\n      for (CompilerInput input : inputs) {\n        Node n = input.getAstRoot(this);\n        if (n == null) {\n          continue;\n        }\n\n        if (devMode) {\n          runSanityCheck();\n          if (hasErrors()) {\n            return null;\n          }\n        }\n\n        if (options.sourceMapOutputPath != null ||\n            options.nameReferenceReportPath != null) {\n\n          // Annotate the nodes in the tree with information from the\n          // input file. This information is used to construct the SourceMap.\n          SourceInformationAnnotator sia =\n              new SourceInformationAnnotator(\n                  input.getName(), options.devMode != DevMode.OFF);\n          NodeTraversal.traverse(this, n, sia);\n        }\n\n        jsRoot.addChildToBack(n);\n      }\n\n      externAndJsRoot = new Node(Token.BLOCK, externsRoot, jsRoot);\n      externAndJsRoot.setIsSyntheticBlock(true);\n\n      return externAndJsRoot;\n    } finally {\n      stopTracer(tracer, \"parseInputs\");\n    }\n  }",
    "comment": " Parses the externs and main inputs.  @return A synthetic root node whose two children are the externs root and the main root ",
    "is_bug": false,
    "failing_test_cases": 5,
    "buggy_methods": 2
  },
  {
    "name": "Compiler.prepareAst",
    "class_name": "com.google.javascript.jscomp.Compiler",
    "signature": "com.google.javascript.jscomp.Compiler.prepareAst(Node)",
    "snippet": "  @Override\n  void prepareAst(Node root) {\n    Tracer tracer = newTracer(\"prepareAst\");\n    CompilerPass pass = new PrepareAst(this);\n    pass.process(null, root);\n    stopTracer(tracer, \"prepareAst\");\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 5,
    "buggy_methods": 2
  },
  {
    "name": "Compiler.setErrorManager",
    "class_name": "com.google.javascript.jscomp.Compiler",
    "signature": "com.google.javascript.jscomp.Compiler.setErrorManager(ErrorManager)",
    "snippet": "  public void setErrorManager(ErrorManager errorManager) {\n    Preconditions.checkNotNull(\n        errorManager, \"the error manager cannot be null\");\n    this.errorManager = errorManager;\n  }",
    "comment": " Sets the error manager.  @param errorManager the error manager, it cannot be {@code null} ",
    "is_bug": false,
    "failing_test_cases": 5,
    "buggy_methods": 2
  },
  {
    "name": "Compiler.stopTracer",
    "class_name": "com.google.javascript.jscomp.Compiler",
    "signature": "com.google.javascript.jscomp.Compiler.stopTracer(Tracer,String)",
    "snippet": "  void stopTracer(Tracer t, String passName) {\n    long result = t.stop();\n    if (options.tracer.isOn()) {\n      tracker.recordPassStop(passName, result);\n    }\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 5,
    "buggy_methods": 2
  },
  {
    "name": "Compiler.throwInternalError",
    "class_name": "com.google.javascript.jscomp.Compiler",
    "signature": "com.google.javascript.jscomp.Compiler.throwInternalError(String,Exception)",
    "snippet": "  @Override\n  void throwInternalError(String message, Exception cause) {\n    String finalMessage =\n      \"INTERNAL COMPILER ERROR.\\n\" +\n      \"Please report this problem.\\n\" + message;\n\n    RuntimeException e = new RuntimeException(finalMessage, cause);\n    if (cause != null) {\n      e.setStackTrace(cause.getStackTrace());\n    }\n    throw e;\n  }",
    "comment": " Report an internal error. ",
    "is_bug": false,
    "failing_test_cases": 5,
    "buggy_methods": 2
  },
  {
    "name": "CompilerInput.CompilerInput",
    "class_name": "com.google.javascript.jscomp.CompilerInput",
    "signature": "com.google.javascript.jscomp.CompilerInput.CompilerInput(JSSourceFile)",
    "snippet": "  public CompilerInput(JSSourceFile file) {\n    this(file, false);\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 5,
    "buggy_methods": 2
  },
  {
    "name": "CompilerInput.CompilerInput",
    "class_name": "com.google.javascript.jscomp.CompilerInput",
    "signature": "com.google.javascript.jscomp.CompilerInput.CompilerInput(JSSourceFile,boolean)",
    "snippet": "  public CompilerInput(JSSourceFile file, boolean isExtern) {\n    this.ast = new JsAst(file);\n    this.name = file.getName();\n    this.isExtern = isExtern;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 5,
    "buggy_methods": 2
  },
  {
    "name": "CompilerInput.getAstRoot",
    "class_name": "com.google.javascript.jscomp.CompilerInput",
    "signature": "com.google.javascript.jscomp.CompilerInput.getAstRoot(AbstractCompiler)",
    "snippet": "  @Override\n  public Node getAstRoot(AbstractCompiler compiler) {\n    return ast.getAstRoot(compiler);\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 5,
    "buggy_methods": 2
  },
  {
    "name": "CompilerInput.getName",
    "class_name": "com.google.javascript.jscomp.CompilerInput",
    "signature": "com.google.javascript.jscomp.CompilerInput.getName()",
    "snippet": "  @Override\n  public String getName() {\n    return name;\n  }",
    "comment": "Returns a name for this input. Must be unique across all inputs. */",
    "is_bug": false,
    "failing_test_cases": 5,
    "buggy_methods": 2
  },
  {
    "name": "CompilerInput.isExtern",
    "class_name": "com.google.javascript.jscomp.CompilerInput",
    "signature": "com.google.javascript.jscomp.CompilerInput.isExtern()",
    "snippet": "  public boolean isExtern() {\n    return isExtern;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 5,
    "buggy_methods": 2
  },
  {
    "name": "CompilerInput.setModule",
    "class_name": "com.google.javascript.jscomp.CompilerInput",
    "signature": "com.google.javascript.jscomp.CompilerInput.setModule(JSModule)",
    "snippet": "  public void setModule(JSModule module) {\n    // An input may only belong to one module.\n    Preconditions.checkArgument(\n        module == null || this.module == null || this.module == module);\n    this.module = module;\n  }",
    "comment": "Sets the module to which the input belongs. */",
    "is_bug": false,
    "failing_test_cases": 5,
    "buggy_methods": 2
  },
  {
    "name": "CompilerOptions.CompilerOptions",
    "class_name": "com.google.javascript.jscomp.CompilerOptions",
    "signature": "com.google.javascript.jscomp.CompilerOptions.CompilerOptions()",
    "snippet": "  public CompilerOptions() {\n    // Accepted language\n    languageIn = LanguageMode.ECMASCRIPT3;\n\n    // Language variation\n    acceptConstKeyword = false;\n\n    // Checks\n    skipAllPasses = false;\n    nameAnonymousFunctionsOnly = false;\n    devMode = DevMode.OFF;\n    checkSymbols = false;\n    checkShadowVars = CheckLevel.OFF;\n    aggressiveVarCheck = CheckLevel.OFF;\n    checkFunctions = CheckLevel.OFF;\n    checkMethods = CheckLevel.OFF;\n    checkDuplicateMessages = false;\n    allowLegacyJsMessages = false;\n    strictMessageReplacement = false;\n    checkSuspiciousCode = false;\n    checkControlStructures = false;\n    checkUndefinedProperties = CheckLevel.OFF;\n    checkUnusedPropertiesEarly = false;\n    checkTypes = false;\n    tightenTypes = false;\n    inferTypesInGlobalScope = false;\n    checkTypedPropertyCalls = false;\n    reportMissingOverride = CheckLevel.OFF;\n    reportUnknownTypes = CheckLevel.OFF;\n    checkRequires = CheckLevel.OFF;\n    checkProvides = CheckLevel.OFF;\n    checkGlobalNamesLevel = CheckLevel.OFF;\n    brokenClosureRequiresLevel = CheckLevel.ERROR;\n    checkGlobalThisLevel = CheckLevel.OFF;\n    checkUnreachableCode = CheckLevel.OFF;\n    checkMissingReturn = CheckLevel.OFF;\n    checkMissingGetCssNameLevel = CheckLevel.OFF;\n    checkMissingGetCssNameBlacklist = null;\n    checkEs5Strict = false;\n    checkCaja = false;\n    computeFunctionSideEffects = false;\n    chainCalls = false;\n\n    // Optimizations\n    foldConstants = false;\n    coalesceVariableNames = false;\n    deadAssignmentElimination = false;\n    inlineConstantVars = false;\n    inlineFunctions = false;\n    inlineLocalFunctions = false;\n    crossModuleCodeMotion = false;\n    crossModuleMethodMotion = false;\n    inlineGetters = false;\n    inlineVariables = false;\n    inlineLocalVariables = false;\n    smartNameRemoval = false;\n    removeDeadCode = false;\n    extractPrototypeMemberDeclarations = false;\n    removeUnusedPrototypeProperties = false;\n    removeUnusedPrototypePropertiesInExterns = false;\n    removeUnusedVars = false;\n    removeUnusedLocalVars = false;\n    aliasExternals = false;\n    collapseVariableDeclarations = false;\n    groupVariableDeclarations = false;\n    collapseAnonymousFunctions = false;\n    aliasableStrings = Collections.emptySet();\n    aliasStringsBlacklist = \"\";\n    aliasAllStrings = false;\n    outputJsStringUsage = false;\n    convertToDottedProperties = false;\n    rewriteFunctionExpressions = false;\n    optimizeParameters = false;\n    optimizeReturns = false;\n\n    // Renaming\n    variableRenaming = VariableRenamingPolicy.OFF;\n    propertyRenaming = PropertyRenamingPolicy.OFF;\n    labelRenaming = false;\n    generatePseudoNames = false;\n    shadowVariables = false;\n    renamePrefix = null;\n    aliasKeywords = false;\n    collapseProperties = false;\n    collapsePropertiesOnExternTypes = false;\n    devirtualizePrototypeMethods = false;\n    disambiguateProperties = false;\n    ambiguateProperties = false;\n    anonymousFunctionNaming = AnonymousFunctionNamingPolicy.OFF;\n    exportTestFunctions = false;\n\n    // Alterations\n    runtimeTypeCheck = false;\n    runtimeTypeCheckLogFunction = null;\n    instrumentForCoverage = false;\n    instrumentForCoverageOnly = false;\n    ignoreCajaProperties = false;\n    syntheticBlockStartMarker = null;\n    syntheticBlockEndMarker = null;\n    locale = null;\n    markAsCompiled = false;\n    removeTryCatchFinally = false;\n    closurePass = false;\n    rewriteNewDateGoogNow = true;\n    removeAbstractMethods = true;\n    removeClosureAsserts = false;\n    stripTypes = Collections.emptySet();\n    stripNameSuffixes = Collections.emptySet();\n    stripNamePrefixes = Collections.emptySet();\n    stripTypePrefixes = Collections.emptySet();\n    customPasses = null;\n    markNoSideEffectCalls = false;\n    defineReplacements = Maps.newHashMap();\n    tweakProcessing = TweakProcessing.OFF;\n    tweakReplacements = Maps.newHashMap();\n    moveFunctionDeclarations = false;\n    instrumentationTemplate = null;\n    appNameStr = \"\";\n    recordFunctionInformation = false;\n    generateExports = false;\n    cssRenamingMap = null;\n    processObjectPropertyString = false;\n    idGenerators = Collections.emptySet();\n    replaceStringsFunctionDescriptions = Collections.emptyList();\n    replaceStringsPlaceholderToken = \"\";\n    replaceStringsReservedStrings = Collections.emptySet();\n\n    // Output\n    printInputDelimiter = false;\n    prettyPrint = false;\n    lineBreak = false;\n    reportPath = null;\n    tracer = TracerMode.OFF;\n    colorizeErrorOutput = false;\n    errorFormat = ErrorFormat.SINGLELINE;\n    warningsGuard = null;\n    debugFunctionSideEffectsPath = null;\n    jsOutputFile = \"\";\n    externExports = false;\n    nameReferenceReportPath = null;\n    nameReferenceGraphPath = null;\n  }",
    "comment": " Initializes compiler options. All options are disabled by default.  Command-line frontends to the compiler should set these properties like a builder. ",
    "is_bug": false,
    "failing_test_cases": 5,
    "buggy_methods": 2
  },
  {
    "name": "CompilerOptions.addWarningsGuard",
    "class_name": "com.google.javascript.jscomp.CompilerOptions",
    "signature": "com.google.javascript.jscomp.CompilerOptions.addWarningsGuard(WarningsGuard)",
    "snippet": "  public void addWarningsGuard(WarningsGuard guard) {\n    if (warningsGuard == null) {\n      warningsGuard = new ComposeWarningsGuard(guard);\n    } else {\n      warningsGuard.addGuard(guard);\n    }\n  }",
    "comment": " Add a guard to the set of warnings guards. ",
    "is_bug": false,
    "failing_test_cases": 5,
    "buggy_methods": 2
  },
  {
    "name": "CompilerOptions.getCodingConvention",
    "class_name": "com.google.javascript.jscomp.CompilerOptions",
    "signature": "com.google.javascript.jscomp.CompilerOptions.getCodingConvention()",
    "snippet": "  public CodingConvention getCodingConvention() {\n    return codingConvention;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 5,
    "buggy_methods": 2
  },
  {
    "name": "CompilerOptions.getWarningsGuard",
    "class_name": "com.google.javascript.jscomp.CompilerOptions",
    "signature": "com.google.javascript.jscomp.CompilerOptions.getWarningsGuard()",
    "snippet": "  WarningsGuard getWarningsGuard() {\n    return warningsGuard;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 5,
    "buggy_methods": 2
  },
  {
    "name": "CompilerOptions.setCodingConvention",
    "class_name": "com.google.javascript.jscomp.CompilerOptions",
    "signature": "com.google.javascript.jscomp.CompilerOptions.setCodingConvention(CodingConvention)",
    "snippet": "  public void setCodingConvention(CodingConvention codingConvention) {\n    this.codingConvention = codingConvention;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 5,
    "buggy_methods": 2
  },
  {
    "name": "CompilerOptions.setWarningLevel",
    "class_name": "com.google.javascript.jscomp.CompilerOptions",
    "signature": "com.google.javascript.jscomp.CompilerOptions.setWarningLevel(DiagnosticGroup,CheckLevel)",
    "snippet": "  public void setWarningLevel(DiagnosticGroup type, CheckLevel level) {\n    addWarningsGuard(new DiagnosticGroupWarningsGuard(type, level));\n  }",
    "comment": " Configure the given type of warning to the given level. ",
    "is_bug": false,
    "failing_test_cases": 5,
    "buggy_methods": 2
  },
  {
    "name": "CompilerOptions.shouldColorizeErrorOutput",
    "class_name": "com.google.javascript.jscomp.CompilerOptions",
    "signature": "com.google.javascript.jscomp.CompilerOptions.shouldColorizeErrorOutput()",
    "snippet": "  public boolean shouldColorizeErrorOutput() {\n    return colorizeErrorOutput;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 5,
    "buggy_methods": 2
  },
  {
    "name": "TracerMode.isOn",
    "class_name": "com.google.javascript.jscomp.CompilerOptions$TracerMode",
    "signature": "com.google.javascript.jscomp.CompilerOptions$TracerMode.isOn()",
    "snippet": "    boolean isOn() {\n      return this != OFF;\n    }",
    "comment": "Collect no timing and size metrics.",
    "is_bug": false,
    "failing_test_cases": 5,
    "buggy_methods": 2
  },
  {
    "name": "ComposeWarningsGuard.ComposeWarningsGuard",
    "class_name": "com.google.javascript.jscomp.ComposeWarningsGuard",
    "signature": "com.google.javascript.jscomp.ComposeWarningsGuard.ComposeWarningsGuard(List)",
    "snippet": "  public ComposeWarningsGuard(List<WarningsGuard> guards) {\n    this.guards = Lists.newArrayList();\n    addGuards(guards);\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 5,
    "buggy_methods": 2
  },
  {
    "name": "ComposeWarningsGuard.ComposeWarningsGuard",
    "class_name": "com.google.javascript.jscomp.ComposeWarningsGuard",
    "signature": "com.google.javascript.jscomp.ComposeWarningsGuard.ComposeWarningsGuard(WarningsGuard[])",
    "snippet": "  public ComposeWarningsGuard(WarningsGuard... guards) {\n    this(Lists.newArrayList(guards));\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 5,
    "buggy_methods": 2
  },
  {
    "name": "ComposeWarningsGuard.addGuard",
    "class_name": "com.google.javascript.jscomp.ComposeWarningsGuard",
    "signature": "com.google.javascript.jscomp.ComposeWarningsGuard.addGuard(WarningsGuard)",
    "snippet": "  void addGuard(WarningsGuard guard) {\n    if (guard instanceof ComposeWarningsGuard) {\n      // Reverse the guards, so that they have the same order in the result.\n      addGuards(Lists.reverse(((ComposeWarningsGuard) guard).guards));\n    } else {\n      int index = Collections.binarySearch(this.guards, guard, guardComparator);\n      if (index < 0) {\n        index = -index - 1;\n      }\n      this.guards.add(index, guard);\n    }\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 5,
    "buggy_methods": 2
  },
  {
    "name": "ComposeWarningsGuard.addGuards",
    "class_name": "com.google.javascript.jscomp.ComposeWarningsGuard",
    "signature": "com.google.javascript.jscomp.ComposeWarningsGuard.addGuards(Iterable)",
    "snippet": "  private void addGuards(Iterable<WarningsGuard> guards) {\n    for (WarningsGuard guard : guards) {\n      addGuard(guard);\n    }\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 5,
    "buggy_methods": 2
  },
  {
    "name": "DiagnosticGroup.DiagnosticGroup",
    "class_name": "com.google.javascript.jscomp.DiagnosticGroup",
    "signature": "com.google.javascript.jscomp.DiagnosticGroup.DiagnosticGroup(DiagnosticGroup[])",
    "snippet": "  public DiagnosticGroup(DiagnosticGroup ...groups) {\n    Set<DiagnosticType> set = Sets.newHashSet();\n\n    for (DiagnosticGroup group : groups) {\n      set.addAll(group.types);\n    }\n\n    this.types = ImmutableSet.copyOf(set);\n  }",
    "comment": " Create a composite group. ",
    "is_bug": false,
    "failing_test_cases": 5,
    "buggy_methods": 2
  },
  {
    "name": "DiagnosticGroup.DiagnosticGroup",
    "class_name": "com.google.javascript.jscomp.DiagnosticGroup",
    "signature": "com.google.javascript.jscomp.DiagnosticGroup.DiagnosticGroup(DiagnosticType[])",
    "snippet": "  public DiagnosticGroup(DiagnosticType ...types) {\n    this.types = ImmutableSet.copyOf(Arrays.asList(types));\n  }",
    "comment": " Create a group that matches all errors of the given types. ",
    "is_bug": false,
    "failing_test_cases": 5,
    "buggy_methods": 2
  },
  {
    "name": "DiagnosticGroupWarningsGuard.DiagnosticGroupWarningsGuard",
    "class_name": "com.google.javascript.jscomp.DiagnosticGroupWarningsGuard",
    "signature": "com.google.javascript.jscomp.DiagnosticGroupWarningsGuard.DiagnosticGroupWarningsGuard(DiagnosticGroup,CheckLevel)",
    "snippet": "  public DiagnosticGroupWarningsGuard(\n      DiagnosticGroup group, CheckLevel level) {\n    this.group = group;\n    this.level = level;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 5,
    "buggy_methods": 2
  },
  {
    "name": "DiagnosticGroups.DiagnosticGroups",
    "class_name": "com.google.javascript.jscomp.DiagnosticGroups",
    "signature": "com.google.javascript.jscomp.DiagnosticGroups.DiagnosticGroups()",
    "snippet": "  public DiagnosticGroups() {}",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 5,
    "buggy_methods": 2
  },
  {
    "name": "DiagnosticGroups.getRegisteredGroups",
    "class_name": "com.google.javascript.jscomp.DiagnosticGroups",
    "signature": "com.google.javascript.jscomp.DiagnosticGroups.getRegisteredGroups()",
    "snippet": "  protected Map<String, DiagnosticGroup> getRegisteredGroups() {\n    return ImmutableMap.copyOf(groupsByName);\n  }",
    "comment": "Get the registered diagnostic groups, indexed by name. */",
    "is_bug": false,
    "failing_test_cases": 5,
    "buggy_methods": 2
  },
  {
    "name": "DiagnosticGroups.registerGroup",
    "class_name": "com.google.javascript.jscomp.DiagnosticGroups",
    "signature": "com.google.javascript.jscomp.DiagnosticGroups.registerGroup(String,DiagnosticGroup)",
    "snippet": "  static DiagnosticGroup registerGroup(String name,\n      DiagnosticGroup group) {\n    groupsByName.put(name, group);\n    return group;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 5,
    "buggy_methods": 2
  },
  {
    "name": "DiagnosticType.disabled",
    "class_name": "com.google.javascript.jscomp.DiagnosticType",
    "signature": "com.google.javascript.jscomp.DiagnosticType.disabled(String,String)",
    "snippet": "  public static DiagnosticType disabled(String name,\n      String descriptionFormat) {\n    return make(name, CheckLevel.OFF, descriptionFormat);\n  }",
    "comment": " Create a DiagnosticType at level CheckLevel.OFF  @param name An identifier @param descriptionFormat A format string @return A new DiagnosticType ",
    "is_bug": false,
    "failing_test_cases": 5,
    "buggy_methods": 2
  },
  {
    "name": "DiagnosticType.error",
    "class_name": "com.google.javascript.jscomp.DiagnosticType",
    "signature": "com.google.javascript.jscomp.DiagnosticType.error(String,String)",
    "snippet": "  public static DiagnosticType error(String name, String descriptionFormat) {\n    return make(name, CheckLevel.ERROR, descriptionFormat);\n  }",
    "comment": " Create a DiagnosticType at level CheckLevel.ERROR  @param name An identifier @param descriptionFormat A format string @return A new DiagnosticType ",
    "is_bug": false,
    "failing_test_cases": 5,
    "buggy_methods": 2
  },
  {
    "name": "DiagnosticType.make",
    "class_name": "com.google.javascript.jscomp.DiagnosticType",
    "signature": "com.google.javascript.jscomp.DiagnosticType.make(String,CheckLevel,String)",
    "snippet": "  public static DiagnosticType make(String name, CheckLevel level,\n                                    String descriptionFormat) {\n    return\n        new DiagnosticType(name, level, new MessageFormat(descriptionFormat));\n  }",
    "comment": " Create a DiagnosticType at a given CheckLevel.  @param name An identifier @param level Either CheckLevel.ERROR or CheckLevel.WARNING @param descriptionFormat A format string @return A new DiagnosticType ",
    "is_bug": false,
    "failing_test_cases": 5,
    "buggy_methods": 2
  },
  {
    "name": "DiagnosticType.warning",
    "class_name": "com.google.javascript.jscomp.DiagnosticType",
    "signature": "com.google.javascript.jscomp.DiagnosticType.warning(String,String)",
    "snippet": "  public static DiagnosticType warning(String name, String descriptionFormat) {\n    return make(name, CheckLevel.WARNING, descriptionFormat);\n  }",
    "comment": " Create a DiagnosticType at level CheckLevel.WARNING  @param name An identifier @param descriptionFormat A format string @return A new DiagnosticType ",
    "is_bug": false,
    "failing_test_cases": 5,
    "buggy_methods": 2
  },
  {
    "name": "GoogleCodingConvention.isConstant",
    "class_name": "com.google.javascript.jscomp.GoogleCodingConvention",
    "signature": "com.google.javascript.jscomp.GoogleCodingConvention.isConstant(String)",
    "snippet": "  @Override\n  public boolean isConstant(String name) {\n    if (name.length() <= 1) {\n      return false;\n    }\n\n    // In compiled code, '$' is often a namespace delimiter. To allow inlining\n    // of namespaced constants, we strip off any namespaces here.\n    int pos = name.lastIndexOf('$');\n    if (pos >= 0) {\n      name = name.substring(pos + 1);\n      if (name.length() == 0) {\n        return false;\n      }\n    }\n\n    return isConstantKey(name);\n  }",
    "comment": " {@inheritDoc}  <p>This enforces the Google const name convention, that the first character after the last $ must be an upper-case letter and all subsequent letters must be upper case. The name must be at least 2 characters long.  <p>Examples: <pre> aaa          Not constant - lower-case letters in the name A            Not constant - too short goog$A       Constant - letters after the $ are upper-case. AA17         Constant - digits can appear after the first letter goog$7A      Not constant - first character after the $ must be upper case. $A           Constant - doesn't have to be anything in front of the $ </pre> ",
    "is_bug": false,
    "failing_test_cases": 5,
    "buggy_methods": 2
  },
  {
    "name": "JSError.getCharno",
    "class_name": "com.google.javascript.jscomp.JSError",
    "signature": "com.google.javascript.jscomp.JSError.getCharno()",
    "snippet": "  public int getCharno() {\n    return charno;\n  }",
    "comment": " Get the character number. ",
    "is_bug": false,
    "failing_test_cases": 5,
    "buggy_methods": 2
  },
  {
    "name": "JSError.getType",
    "class_name": "com.google.javascript.jscomp.JSError",
    "signature": "com.google.javascript.jscomp.JSError.getType()",
    "snippet": "  public DiagnosticType getType() {\n    return type;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 5,
    "buggy_methods": 2
  },
  {
    "name": "JSError.make",
    "class_name": "com.google.javascript.jscomp.JSError",
    "signature": "com.google.javascript.jscomp.JSError.make(String,Node,DiagnosticType,String[])",
    "snippet": "  public static JSError make(String sourceName, Node n,\n                             DiagnosticType type, String... arguments) {\n    return new JSError(sourceName, n, type, arguments);\n  }",
    "comment": " Creates a JSError from a file and Node position.  @param sourceName The source file name @param n Determines the line and char position within the source file name @param type The DiagnosticType @param arguments Arguments to be incorporated into the message ",
    "is_bug": false,
    "failing_test_cases": 5,
    "buggy_methods": 2
  },
  {
    "name": "JSError.make",
    "class_name": "com.google.javascript.jscomp.JSError",
    "signature": "com.google.javascript.jscomp.JSError.make(String,int,int,DiagnosticType,String[])",
    "snippet": "  public static JSError make(String sourceName, int lineno, int charno,\n                             DiagnosticType type, String... arguments) {\n    return new JSError(sourceName, null, lineno, charno, type, null, arguments);\n  }",
    "comment": " Creates a JSError at a given source location  @param sourceName The source file name @param lineno Line number with source file, or -1 if unknown @param charno Column number within line, or -1 for whole line. @param type The DiagnosticType @param arguments Arguments to be incorporated into the message ",
    "is_bug": false,
    "failing_test_cases": 5,
    "buggy_methods": 2
  },
  {
    "name": "JSModule.JSModule",
    "class_name": "com.google.javascript.jscomp.JSModule",
    "signature": "com.google.javascript.jscomp.JSModule.JSModule(String)",
    "snippet": "  public JSModule(String name) {\n    this.name = name;\n    this.depth = -1;\n  }",
    "comment": " Creates an instance.  @param name A unique name for the module ",
    "is_bug": false,
    "failing_test_cases": 5,
    "buggy_methods": 2
  },
  {
    "name": "JSModule.add",
    "class_name": "com.google.javascript.jscomp.JSModule",
    "signature": "com.google.javascript.jscomp.JSModule.add(CompilerInput)",
    "snippet": "  public void add(CompilerInput input) {\n    inputs.add(input);\n    input.setModule(this);\n  }",
    "comment": "Adds a source code input to this module. */",
    "is_bug": false,
    "failing_test_cases": 5,
    "buggy_methods": 2
  },
  {
    "name": "JSModule.add",
    "class_name": "com.google.javascript.jscomp.JSModule",
    "signature": "com.google.javascript.jscomp.JSModule.add(JSSourceFile)",
    "snippet": "  public void add(JSSourceFile file) {\n    add(new CompilerInput(file));\n  }",
    "comment": "Adds a source file input to this module. */",
    "is_bug": false,
    "failing_test_cases": 5,
    "buggy_methods": 2
  },
  {
    "name": "JSModule.getInputs",
    "class_name": "com.google.javascript.jscomp.JSModule",
    "signature": "com.google.javascript.jscomp.JSModule.getInputs()",
    "snippet": "  public List<CompilerInput> getInputs() {\n    return inputs;\n  }",
    "comment": " Gets this module's list of source code inputs.  @return A list that may be empty but not null ",
    "is_bug": false,
    "failing_test_cases": 5,
    "buggy_methods": 2
  },
  {
    "name": "JSSourceFile.fromCode",
    "class_name": "com.google.javascript.jscomp.JSSourceFile",
    "signature": "com.google.javascript.jscomp.JSSourceFile.fromCode(String,String)",
    "snippet": "  public static JSSourceFile fromCode(String fileName, String code) {\n    return new JSSourceFile(SourceFile.fromCode(fileName, code));\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 5,
    "buggy_methods": 2
  },
  {
    "name": "JSSourceFile.getCode",
    "class_name": "com.google.javascript.jscomp.JSSourceFile",
    "signature": "com.google.javascript.jscomp.JSSourceFile.getCode()",
    "snippet": "  @Override\n  public String getCode() throws IOException {\n    return referenced.getCode();\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 5,
    "buggy_methods": 2
  },
  {
    "name": "JsAst.JsAst",
    "class_name": "com.google.javascript.jscomp.JsAst",
    "signature": "com.google.javascript.jscomp.JsAst.JsAst(SourceFile)",
    "snippet": "  public JsAst(SourceFile sourceFile) {\n    this.sourceFile = sourceFile;\n    this.fileName = sourceFile.getName();\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 5,
    "buggy_methods": 2
  },
  {
    "name": "JsAst.createAst",
    "class_name": "com.google.javascript.jscomp.JsAst",
    "signature": "com.google.javascript.jscomp.JsAst.createAst(AbstractCompiler)",
    "snippet": "  private void createAst(AbstractCompiler compiler) {\n    try {\n      parse(compiler, sourceFile.getName(), sourceFile.getCode());\n    } catch (IOException e) {\n      compiler.report(\n          JSError.make(AbstractCompiler.READ_ERROR, sourceFile.getName()));\n    }\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 5,
    "buggy_methods": 2
  },
  {
    "name": "JsAst.getAstRoot",
    "class_name": "com.google.javascript.jscomp.JsAst",
    "signature": "com.google.javascript.jscomp.JsAst.getAstRoot(AbstractCompiler)",
    "snippet": "  @Override\n  public Node getAstRoot(AbstractCompiler compiler) {\n    if (root == null) {\n      createAst(compiler);\n    }\n    return root;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 5,
    "buggy_methods": 2
  },
  {
    "name": "JsAst.parse",
    "class_name": "com.google.javascript.jscomp.JsAst",
    "signature": "com.google.javascript.jscomp.JsAst.parse(AbstractCompiler,String,String)",
    "snippet": "  private void parse(AbstractCompiler compiler, String sourceName,\n      String sourceStr) {\n    try {\n      logger_.fine(\"Parsing: \" + sourceName);\n      root = ParserRunner.parse(sourceName, sourceStr,\n          compiler.getParserConfig(),\n          compiler.getDefaultErrorReporter(),\n          logger_);\n    } catch (IOException e) {\n      compiler.report(JSError.make(AbstractCompiler.READ_ERROR, sourceName));\n    }\n\n    if (root == null || compiler.hasHaltingErrors()) {\n      // There was a parse error or IOException, so use a dummy block.\n      root = new Node(Token.BLOCK);\n    } else {\n      compiler.prepareAst(root);\n    }\n\n    // Set the source name so that the compiler passes can track\n    // the source file and module.\n    root.putProp(Node.SOURCENAME_PROP, sourceName);\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 5,
    "buggy_methods": 2
  },
  {
    "name": "LightweightMessageFormatter.LightweightMessageFormatter",
    "class_name": "com.google.javascript.jscomp.LightweightMessageFormatter",
    "signature": "com.google.javascript.jscomp.LightweightMessageFormatter.LightweightMessageFormatter(SourceExcerptProvider)",
    "snippet": "  public LightweightMessageFormatter(SourceExcerptProvider source) {\n    this(source, LINE);\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 5,
    "buggy_methods": 2
  },
  {
    "name": "LightweightMessageFormatter.LightweightMessageFormatter",
    "class_name": "com.google.javascript.jscomp.LightweightMessageFormatter",
    "signature": "com.google.javascript.jscomp.LightweightMessageFormatter.LightweightMessageFormatter(SourceExcerptProvider,SourceExcerpt)",
    "snippet": "  public LightweightMessageFormatter(SourceExcerptProvider source,\n      SourceExcerpt excerpt) {\n    super(source);\n    Preconditions.checkNotNull(source);\n    this.excerpt = excerpt;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 5,
    "buggy_methods": 2
  },
  {
    "name": "LineNumberCheck.LineNumberCheck",
    "class_name": "com.google.javascript.jscomp.LineNumberCheck",
    "signature": "com.google.javascript.jscomp.LineNumberCheck.LineNumberCheck(AbstractCompiler)",
    "snippet": "  LineNumberCheck(AbstractCompiler compiler) {\n    this.compiler = compiler;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 5,
    "buggy_methods": 2
  },
  {
    "name": "LineNumberCheck.process",
    "class_name": "com.google.javascript.jscomp.LineNumberCheck",
    "signature": "com.google.javascript.jscomp.LineNumberCheck.process(Node,Node)",
    "snippet": "  public void process(Node externs, Node root) {\n    requiresLineNumbers = false;\n\n    NodeTraversal.traverse(compiler, root, this);\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 5,
    "buggy_methods": 2
  },
  {
    "name": "LineNumberCheck.shouldTraverse",
    "class_name": "com.google.javascript.jscomp.LineNumberCheck",
    "signature": "com.google.javascript.jscomp.LineNumberCheck.shouldTraverse(NodeTraversal,Node,Node)",
    "snippet": "  public boolean shouldTraverse(NodeTraversal t, Node n, Node parent) {\n    // Each JavaScript file is rooted in a script node, so we'll only\n    // have line number information inside the script node.\n    if (n.getType() == Token.SCRIPT) {\n      requiresLineNumbers = true;\n    }\n    return true;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 5,
    "buggy_methods": 2
  },
  {
    "name": "LineNumberCheck.visit",
    "class_name": "com.google.javascript.jscomp.LineNumberCheck",
    "signature": "com.google.javascript.jscomp.LineNumberCheck.visit(NodeTraversal,Node,Node)",
    "snippet": "  public void visit(NodeTraversal t, Node n, Node parent) {\n    if (n.getType() == Token.SCRIPT) {\n      requiresLineNumbers = false;\n    } else if (requiresLineNumbers) {\n      if (n.getLineno() == -1) {\n        // The tree version of the node is really the best diagnostic\n        // info we have to offer here.\n        compiler.report(\n            t.makeError(n, MISSING_LINE_INFO,\n                n.toStringTree()));\n      }\n    }\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 5,
    "buggy_methods": 2
  },
  {
    "name": "LoggerErrorManager.LoggerErrorManager",
    "class_name": "com.google.javascript.jscomp.LoggerErrorManager",
    "signature": "com.google.javascript.jscomp.LoggerErrorManager.LoggerErrorManager(MessageFormatter,Logger)",
    "snippet": "  public LoggerErrorManager(MessageFormatter formatter, Logger logger) {\n    this.formatter = formatter;\n    this.logger = logger;\n  }",
    "comment": " Creates an instance. ",
    "is_bug": false,
    "failing_test_cases": 5,
    "buggy_methods": 2
  },
  {
    "name": "MakeDeclaredNamesUnique.MakeDeclaredNamesUnique",
    "class_name": "com.google.javascript.jscomp.MakeDeclaredNamesUnique",
    "signature": "com.google.javascript.jscomp.MakeDeclaredNamesUnique.MakeDeclaredNamesUnique()",
    "snippet": "  MakeDeclaredNamesUnique() {\n    this(new ContextualRenamer());\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 5,
    "buggy_methods": 2
  },
  {
    "name": "MakeDeclaredNamesUnique.MakeDeclaredNamesUnique",
    "class_name": "com.google.javascript.jscomp.MakeDeclaredNamesUnique",
    "signature": "com.google.javascript.jscomp.MakeDeclaredNamesUnique.MakeDeclaredNamesUnique(Renamer)",
    "snippet": "  MakeDeclaredNamesUnique(Renamer renamer) {\n    this.rootRenamer = renamer;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 5,
    "buggy_methods": 2
  },
  {
    "name": "MakeDeclaredNamesUnique.enterScope",
    "class_name": "com.google.javascript.jscomp.MakeDeclaredNamesUnique",
    "signature": "com.google.javascript.jscomp.MakeDeclaredNamesUnique.enterScope(NodeTraversal)",
    "snippet": "  @Override\n  public void enterScope(NodeTraversal t) {\n    Node declarationRoot = t.getScopeRoot();\n    Renamer renamer;\n    if (nameStack.isEmpty()) {\n      // If the contextual renamer is being used the starting context can not\n      // be a function.\n      Preconditions.checkState(\n          declarationRoot.getType() != Token.FUNCTION ||\n          !(rootRenamer instanceof ContextualRenamer));\n      Preconditions.checkState(t.inGlobalScope());\n      renamer = rootRenamer;\n    } else {\n      renamer = nameStack.peek().forChildScope();\n    }\n\n    if (declarationRoot.getType() == Token.FUNCTION) {\n      // Add the function parameters\n      Node fnParams = declarationRoot.getFirstChild().getNext();\n      for (Node c = fnParams.getFirstChild(); c != null; c = c.getNext()) {\n        String name = c.getString();\n        renamer.addDeclaredName(name);\n      }\n\n      // Add the function body declarations\n      Node functionBody = declarationRoot.getLastChild();\n      findDeclaredNames(functionBody, null, renamer);\n    } else {\n      // Add the block declarations\n      findDeclaredNames(declarationRoot, null, renamer);\n    }\n    nameStack.push(renamer);\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 5,
    "buggy_methods": 2
  },
  {
    "name": "MakeDeclaredNamesUnique.exitScope",
    "class_name": "com.google.javascript.jscomp.MakeDeclaredNamesUnique",
    "signature": "com.google.javascript.jscomp.MakeDeclaredNamesUnique.exitScope(NodeTraversal)",
    "snippet": "  @Override\n  public void exitScope(NodeTraversal t) {\n    if (!t.inGlobalScope()) {\n      nameStack.pop();\n    }\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 5,
    "buggy_methods": 2
  },
  {
    "name": "MakeDeclaredNamesUnique.findDeclaredNames",
    "class_name": "com.google.javascript.jscomp.MakeDeclaredNamesUnique",
    "signature": "com.google.javascript.jscomp.MakeDeclaredNamesUnique.findDeclaredNames(Node,Node,Renamer)",
    "snippet": "  private void findDeclaredNames(Node n, Node parent, Renamer renamer) {\n    // Do a shallow traversal, so don't traverse into function declarations,\n    // except for the name of the function itself.\n    if (parent == null\n        || parent.getType() != Token.FUNCTION\n        || n == parent.getFirstChild()) {\n      if (NodeUtil.isVarDeclaration(n)) {\n        renamer.addDeclaredName(n.getString());\n      } else if (NodeUtil.isFunctionDeclaration(n)) {\n        Node nameNode = n.getFirstChild();\n        renamer.addDeclaredName(nameNode.getString());\n      }\n\n      for (Node c = n.getFirstChild(); c != null; c = c.getNext()) {\n        findDeclaredNames(c, n, renamer);\n      }\n    }\n  }",
    "comment": " Traverses the current scope and collects declared names.  Does not decent into functions or add CATCH exceptions. ",
    "is_bug": false,
    "failing_test_cases": 5,
    "buggy_methods": 2
  },
  {
    "name": "MakeDeclaredNamesUnique.getReplacementName",
    "class_name": "com.google.javascript.jscomp.MakeDeclaredNamesUnique",
    "signature": "com.google.javascript.jscomp.MakeDeclaredNamesUnique.getReplacementName(String)",
    "snippet": "  private String getReplacementName(String oldName) {\n    for (Renamer names : nameStack) {\n      String newName = names.getReplacementName(oldName);\n      if (newName != null) {\n        return newName;\n      }\n    }\n    return null;\n  }",
    "comment": " Walks the stack of name maps and finds the replacement name for the current scope. ",
    "is_bug": false,
    "failing_test_cases": 5,
    "buggy_methods": 2
  },
  {
    "name": "MakeDeclaredNamesUnique.shouldTraverse",
    "class_name": "com.google.javascript.jscomp.MakeDeclaredNamesUnique",
    "signature": "com.google.javascript.jscomp.MakeDeclaredNamesUnique.shouldTraverse(NodeTraversal,Node,Node)",
    "snippet": "  @Override\n  public boolean shouldTraverse(NodeTraversal t, Node n, Node parent) {\n\n    switch (n.getType()) {\n      case Token.FUNCTION:\n        {\n          // Add recursive function name, if needed.\n          // NOTE: \"enterScope\" is called after we need to pick up this name.\n          Renamer renamer = nameStack.peek().forChildScope();\n\n          // If needed, add the function recursive name.\n          String name = n.getFirstChild().getString();\n          if (name != null && !name.isEmpty() && parent != null\n              && !NodeUtil.isFunctionDeclaration(n)) {\n            renamer.addDeclaredName(name);\n          }\n\n          nameStack.push(renamer);\n        }\n        break;\n\n      case Token.CATCH:\n        {\n          Renamer renamer = nameStack.peek().forChildScope();\n\n          String name = n.getFirstChild().getString();\n          renamer.addDeclaredName(name);\n\n          nameStack.push(renamer);\n        }\n        break;\n    }\n\n    return true;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 5,
    "buggy_methods": 2
  },
  {
    "name": "MakeDeclaredNamesUnique.visit",
    "class_name": "com.google.javascript.jscomp.MakeDeclaredNamesUnique",
    "signature": "com.google.javascript.jscomp.MakeDeclaredNamesUnique.visit(NodeTraversal,Node,Node)",
    "snippet": "  @Override\n  public void visit(NodeTraversal t, Node n, Node parent) {\n    switch (n.getType()) {\n      case Token.NAME:\n        String newName = getReplacementName(n.getString());\n        if (newName != null) {\n          Renamer renamer = nameStack.peek();\n          if (renamer.stripConstIfReplaced()) {\n            // TODO(johnlenz): Do we need to do anything about the javadoc?\n            n.removeProp(Node.IS_CONSTANT_NAME);\n          }\n          n.setString(newName);\n          t.getCompiler().reportCodeChange();\n        }\n        break;\n\n      case Token.FUNCTION:\n        // Remove function recursive name (if any).\n        nameStack.pop();\n        break;\n\n      case Token.CATCH:\n        // Remove catch except name from the stack of names.\n        nameStack.pop();\n        break;\n    }\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 5,
    "buggy_methods": 2
  },
  {
    "name": "ContextualRenamer.addDeclaredName",
    "class_name": "com.google.javascript.jscomp.MakeDeclaredNamesUnique$ContextualRenamer",
    "signature": "com.google.javascript.jscomp.MakeDeclaredNamesUnique$ContextualRenamer.addDeclaredName(String)",
    "snippet": "    @Override\n    public void addDeclaredName(String name) {\n      if (!name.equals(ARGUMENTS)) {\n        if (global) {\n          reserveName(name);\n        } else {\n          // It hasn't been declared locally yet, so increment the count.\n          if (!declarations.containsKey(name)) {\n            int id = incrementNameCount(name);\n            String newName = null;\n            if (id != 0) {\n              newName = getUniqueName(name, id);\n            }\n            declarations.put(name, newName);\n          }\n        }\n      }\n    }",
    "comment": " Adds a name to the map of names declared in this scope. ",
    "is_bug": false,
    "failing_test_cases": 5,
    "buggy_methods": 2
  },
  {
    "name": "ContextualRenamer.getReplacementName",
    "class_name": "com.google.javascript.jscomp.MakeDeclaredNamesUnique$ContextualRenamer",
    "signature": "com.google.javascript.jscomp.MakeDeclaredNamesUnique$ContextualRenamer.getReplacementName(String)",
    "snippet": "    @Override\n    public String getReplacementName(String oldName) {\n      return declarations.get(oldName);\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 5,
    "buggy_methods": 2
  },
  {
    "name": "ContextualRenamer.reserveName",
    "class_name": "com.google.javascript.jscomp.MakeDeclaredNamesUnique$ContextualRenamer",
    "signature": "com.google.javascript.jscomp.MakeDeclaredNamesUnique$ContextualRenamer.reserveName(String)",
    "snippet": "    private void reserveName(String name) {\n      nameUsage.setCount(name, 0, 1);\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 5,
    "buggy_methods": 2
  },
  {
    "name": "NodeTraversal.NodeTraversal",
    "class_name": "com.google.javascript.jscomp.NodeTraversal",
    "signature": "com.google.javascript.jscomp.NodeTraversal.NodeTraversal(AbstractCompiler,Callback)",
    "snippet": "  public NodeTraversal(AbstractCompiler compiler, Callback cb) {\n    this(compiler, cb, new SyntacticScopeCreator(compiler));\n  }",
    "comment": " Creates a node traversal using the specified callback interface. ",
    "is_bug": false,
    "failing_test_cases": 5,
    "buggy_methods": 2
  },
  {
    "name": "NodeTraversal.NodeTraversal",
    "class_name": "com.google.javascript.jscomp.NodeTraversal",
    "signature": "com.google.javascript.jscomp.NodeTraversal.NodeTraversal(AbstractCompiler,Callback,ScopeCreator)",
    "snippet": "  public NodeTraversal(AbstractCompiler compiler, Callback cb,\n      ScopeCreator scopeCreator) {\n    this.callback = cb;\n    if (cb instanceof ScopedCallback) {\n      this.scopeCallback = (ScopedCallback) cb;\n    }\n    this.compiler = compiler;\n    this.sourceName = \"\";\n    this.scopeCreator = scopeCreator;\n  }",
    "comment": " Creates a node traversal using the specified callback interface and the scope creator. ",
    "is_bug": false,
    "failing_test_cases": 5,
    "buggy_methods": 2
  },
  {
    "name": "NodeTraversal.getScope",
    "class_name": "com.google.javascript.jscomp.NodeTraversal",
    "signature": "com.google.javascript.jscomp.NodeTraversal.getScope()",
    "snippet": "  public Scope getScope() {\n    Scope scope = scopes.isEmpty() ? null : scopes.peek();\n    if (scopeRoots.isEmpty()) {\n      return scope;\n    }\n\n    Iterator<Node> it = scopeRoots.descendingIterator();\n    while (it.hasNext()) {\n      scope = scopeCreator.createScope(it.next(), scope);\n      scopes.push(scope);\n    }\n    scopeRoots.clear();\n\n    return scope;\n  }",
    "comment": "Gets the current scope. */",
    "is_bug": false,
    "failing_test_cases": 5,
    "buggy_methods": 2
  },
  {
    "name": "NodeTraversal.getScopeDepth",
    "class_name": "com.google.javascript.jscomp.NodeTraversal",
    "signature": "com.google.javascript.jscomp.NodeTraversal.getScopeDepth()",
    "snippet": "  int getScopeDepth() {\n    return scopes.size() + scopeRoots.size();\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 5,
    "buggy_methods": 2
  },
  {
    "name": "NodeTraversal.getScopeRoot",
    "class_name": "com.google.javascript.jscomp.NodeTraversal",
    "signature": "com.google.javascript.jscomp.NodeTraversal.getScopeRoot()",
    "snippet": "  public Node getScopeRoot() {\n    if (scopeRoots.isEmpty()) {\n      return scopes.peek().getRootNode();\n    } else {\n      return scopeRoots.peek();\n    }\n  }",
    "comment": "Returns the current scope's root. */",
    "is_bug": false,
    "failing_test_cases": 5,
    "buggy_methods": 2
  },
  {
    "name": "NodeTraversal.getSourceName",
    "class_name": "com.google.javascript.jscomp.NodeTraversal",
    "signature": "com.google.javascript.jscomp.NodeTraversal.getSourceName(Node)",
    "snippet": "  private static String getSourceName(Node n) {\n    String name = (String) n.getProp(Node.SOURCENAME_PROP);\n    return name == null ? \"\" : name;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 5,
    "buggy_methods": 2
  },
  {
    "name": "NodeTraversal.inGlobalScope",
    "class_name": "com.google.javascript.jscomp.NodeTraversal",
    "signature": "com.google.javascript.jscomp.NodeTraversal.inGlobalScope()",
    "snippet": "  boolean inGlobalScope() {\n    return getScopeDepth() <= 1;\n  }",
    "comment": " Determines whether the traversal is currently in the global scope. ",
    "is_bug": false,
    "failing_test_cases": 5,
    "buggy_methods": 2
  },
  {
    "name": "NodeTraversal.popScope",
    "class_name": "com.google.javascript.jscomp.NodeTraversal",
    "signature": "com.google.javascript.jscomp.NodeTraversal.popScope()",
    "snippet": "  private void popScope() {\n    if (scopeCallback != null) {\n      scopeCallback.exitScope(this);\n    }\n    if (scopeRoots.isEmpty()) {\n      scopes.pop();\n    } else {\n      scopeRoots.pop();\n    }\n    cfgs.pop();\n  }",
    "comment": "Pops back to the previous scope (e.g. when leaving a function). */",
    "is_bug": false,
    "failing_test_cases": 5,
    "buggy_methods": 2
  },
  {
    "name": "NodeTraversal.pushScope",
    "class_name": "com.google.javascript.jscomp.NodeTraversal",
    "signature": "com.google.javascript.jscomp.NodeTraversal.pushScope(Node)",
    "snippet": "  private void pushScope(Node node) {\n    Preconditions.checkState(curNode != null);\n    scopeRoots.push(node);\n    cfgs.push(null);\n    if (scopeCallback != null) {\n      scopeCallback.enterScope(this);\n    }\n  }",
    "comment": "Creates a new scope (e.g. when entering a function). */",
    "is_bug": false,
    "failing_test_cases": 5,
    "buggy_methods": 2
  },
  {
    "name": "NodeTraversal.throwUnexpectedException",
    "class_name": "com.google.javascript.jscomp.NodeTraversal",
    "signature": "com.google.javascript.jscomp.NodeTraversal.throwUnexpectedException(Exception)",
    "snippet": "  private void throwUnexpectedException(Exception unexpectedException) {\n    // If there's an unexpected exception, try to get the\n    // line number of the code that caused it.\n    String message = unexpectedException.getMessage();\n\n    // TODO(user): It is possible to get more information if curNode or\n    // its parent is missing. We still have the scope stack in which it is still\n    // very useful to find out at least which function caused the exception.\n    if (!sourceName.isEmpty()) {\n      message =\n          unexpectedException.getMessage() + \"\\n\" +\n          formatNodeContext(\"Node\", curNode) +\n          (curNode == null ?\n              \"\" :\n              formatNodeContext(\"Parent\", curNode.getParent()));\n    }\n    compiler.throwInternalError(message, unexpectedException);\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 5,
    "buggy_methods": 2
  },
  {
    "name": "NodeTraversal.traverse",
    "class_name": "com.google.javascript.jscomp.NodeTraversal",
    "signature": "com.google.javascript.jscomp.NodeTraversal.traverse(AbstractCompiler,Node,Callback)",
    "snippet": "  public static void traverse(\n      AbstractCompiler compiler, Node root, Callback cb) {\n    NodeTraversal t = new NodeTraversal(compiler, cb);\n    t.traverse(root);\n  }",
    "comment": " Traverses a node recursively. ",
    "is_bug": false,
    "failing_test_cases": 5,
    "buggy_methods": 2
  },
  {
    "name": "NodeTraversal.traverse",
    "class_name": "com.google.javascript.jscomp.NodeTraversal",
    "signature": "com.google.javascript.jscomp.NodeTraversal.traverse(Node)",
    "snippet": "  public void traverse(Node root) {\n    try {\n      sourceName = \"\";\n      curNode = root;\n      pushScope(root);\n      traverseBranch(root, null);\n      popScope();\n    } catch (Exception unexpectedException) {\n      throwUnexpectedException(unexpectedException);\n    }\n  }",
    "comment": " Traverses a parse tree recursively. ",
    "is_bug": false,
    "failing_test_cases": 5,
    "buggy_methods": 2
  },
  {
    "name": "NodeTraversal.traverseBranch",
    "class_name": "com.google.javascript.jscomp.NodeTraversal",
    "signature": "com.google.javascript.jscomp.NodeTraversal.traverseBranch(Node,Node)",
    "snippet": "  @SuppressWarnings(\"fallthrough\")\n  private void traverseBranch(Node n, Node parent) {\n    int type = n.getType();\n    if (type == Token.SCRIPT) {\n      sourceName = getSourceName(n);\n    }\n\n    curNode = n;\n    if (!callback.shouldTraverse(this, n, parent)) return;\n\n    switch (type) {\n      case Token.FUNCTION:\n        traverseFunction(n, parent);\n        break;\n\n      default:\n        for (Node child = n.getFirstChild(); child != null; ) {\n          // child could be replaced, in which case our child node\n          // would no longer point to the true next\n          Node next = child.getNext();\n          traverseBranch(child, n);\n          child = next;\n        }\n        break;\n    }\n\n    curNode = n;\n    callback.visit(this, n, parent);\n  }",
    "comment": " Traverses a branch. ",
    "is_bug": false,
    "failing_test_cases": 5,
    "buggy_methods": 2
  },
  {
    "name": "NodeTraversal.traverseRoots",
    "class_name": "com.google.javascript.jscomp.NodeTraversal",
    "signature": "com.google.javascript.jscomp.NodeTraversal.traverseRoots(List)",
    "snippet": "  public void traverseRoots(List<Node> roots) {\n    if (roots.isEmpty()) {\n      return;\n    }\n\n    try {\n      Node scopeRoot = roots.get(0).getParent();\n      Preconditions.checkState(scopeRoot != null);\n\n      sourceName = \"\";\n      curNode = scopeRoot;\n      pushScope(scopeRoot);\n\n      for (Node root : roots) {\n        Preconditions.checkState(root.getParent() == scopeRoot);\n        traverseBranch(root, scopeRoot);\n      }\n\n      popScope();\n    } catch (Exception unexpectedException) {\n      throwUnexpectedException(unexpectedException);\n    }\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 5,
    "buggy_methods": 2
  },
  {
    "name": "NodeTraversal.traverseRoots",
    "class_name": "com.google.javascript.jscomp.NodeTraversal",
    "signature": "com.google.javascript.jscomp.NodeTraversal.traverseRoots(Node[])",
    "snippet": "  public void traverseRoots(Node ... roots) {\n    traverseRoots(Lists.newArrayList(roots));\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 5,
    "buggy_methods": 2
  },
  {
    "name": "NodeUtil.getInfoForNameNode",
    "class_name": "com.google.javascript.jscomp.NodeUtil",
    "signature": "com.google.javascript.jscomp.NodeUtil.getInfoForNameNode(Node)",
    "snippet": "  static JSDocInfo getInfoForNameNode(Node nameNode) {\n    JSDocInfo info = null;\n    Node parent = null;\n    if (nameNode != null) {\n      info = nameNode.getJSDocInfo();\n      parent = nameNode.getParent();\n    }\n\n    if (info == null && parent != null &&\n        ((parent.getType() == Token.VAR && parent.hasOneChild()) ||\n          parent.getType() == Token.FUNCTION)) {\n      info = parent.getJSDocInfo();\n    }\n    return info;\n  }",
    "comment": " @param nameNode A name node @return The JSDocInfo for the name node ",
    "is_bug": false,
    "failing_test_cases": 5,
    "buggy_methods": 2
  },
  {
    "name": "NodeUtil.isConstantByConvention",
    "class_name": "com.google.javascript.jscomp.NodeUtil",
    "signature": "com.google.javascript.jscomp.NodeUtil.isConstantByConvention(CodingConvention,Node,Node)",
    "snippet": "  static boolean isConstantByConvention(\n      CodingConvention convention, Node node, Node parent) {\n    String name = node.getString();\n    if (parent.getType() == Token.GETPROP &&\n        node == parent.getLastChild()) {\n      return convention.isConstantKey(name);\n    } else if (isObjectLitKey(node, parent)) {\n      return convention.isConstantKey(name);\n    } else {\n      return convention.isConstant(name);\n    }\n  }",
    "comment": "Whether the given name is constant by coding convention. */",
    "is_bug": false,
    "failing_test_cases": 5,
    "buggy_methods": 2
  },
  {
    "name": "NodeUtil.isControlStructure",
    "class_name": "com.google.javascript.jscomp.NodeUtil",
    "signature": "com.google.javascript.jscomp.NodeUtil.isControlStructure(Node)",
    "snippet": "  static boolean isControlStructure(Node n) {\n    switch (n.getType()) {\n      case Token.FOR:\n      case Token.DO:\n      case Token.WHILE:\n      case Token.WITH:\n      case Token.IF:\n      case Token.LABEL:\n      case Token.TRY:\n      case Token.CATCH:\n      case Token.SWITCH:\n      case Token.CASE:\n      case Token.DEFAULT:\n        return true;\n      default:\n        return false;\n    }\n  }",
    "comment": " Determines whether the given node is a FOR, DO, WHILE, WITH, or IF node. ",
    "is_bug": false,
    "failing_test_cases": 5,
    "buggy_methods": 2
  },
  {
    "name": "NodeUtil.isFunctionDeclaration",
    "class_name": "com.google.javascript.jscomp.NodeUtil",
    "signature": "com.google.javascript.jscomp.NodeUtil.isFunctionDeclaration(Node)",
    "snippet": "  static boolean isFunctionDeclaration(Node n) {\n    return n.getType() == Token.FUNCTION && isStatement(n);\n  }",
    "comment": " Is this node a function declaration? A function declaration is a function that has a name that is added to the current scope (i.e. a function that is not part of a expression; see {@link #isFunctionExpression}). ",
    "is_bug": false,
    "failing_test_cases": 5,
    "buggy_methods": 2
  },
  {
    "name": "NodeUtil.isGet",
    "class_name": "com.google.javascript.jscomp.NodeUtil",
    "signature": "com.google.javascript.jscomp.NodeUtil.isGet(Node)",
    "snippet": "  static boolean isGet(Node n) {\n    return n.getType() == Token.GETPROP\n        || n.getType() == Token.GETELEM;\n  }",
    "comment": " Is this a GETPROP or GETELEM node? ",
    "is_bug": false,
    "failing_test_cases": 5,
    "buggy_methods": 2
  },
  {
    "name": "NodeUtil.isObjectLitKey",
    "class_name": "com.google.javascript.jscomp.NodeUtil",
    "signature": "com.google.javascript.jscomp.NodeUtil.isObjectLitKey(Node,Node)",
    "snippet": "  static boolean isObjectLitKey(Node node, Node parent) {\n    switch (node.getType()) {\n      case Token.NUMBER:\n      case Token.STRING:\n        return parent.getType() == Token.OBJECTLIT;\n      case Token.GET:\n      case Token.SET:\n        return true;\n    }\n    return false;\n  }",
    "comment": " Determines whether a node represents an object literal key (e.g. key1 in {key1: value1, key2: value2}).  @param node A node @param parent The node's parent ",
    "is_bug": false,
    "failing_test_cases": 5,
    "buggy_methods": 2
  },
  {
    "name": "NodeUtil.isStatementBlock",
    "class_name": "com.google.javascript.jscomp.NodeUtil",
    "signature": "com.google.javascript.jscomp.NodeUtil.isStatementBlock(Node)",
    "snippet": "  static boolean isStatementBlock(Node n) {\n    return n.getType() == Token.SCRIPT || n.getType() == Token.BLOCK;\n  }",
    "comment": " @return Whether the node is of a type that contain other statements. ",
    "is_bug": false,
    "failing_test_cases": 5,
    "buggy_methods": 2
  },
  {
    "name": "NodeUtil.isVarDeclaration",
    "class_name": "com.google.javascript.jscomp.NodeUtil",
    "signature": "com.google.javascript.jscomp.NodeUtil.isVarDeclaration(Node)",
    "snippet": "  static boolean isVarDeclaration(Node n) {\n    // There is no need to verify that parent != null because a NAME node\n    // always has a parent in a valid parse tree.\n    return n.getType() == Token.NAME && n.getParent().getType() == Token.VAR;\n  }",
    "comment": " Is this node the name of a variable being declared?  @param n The node @return True if {@code n} is NAME and {@code parent} is VAR ",
    "is_bug": false,
    "failing_test_cases": 5,
    "buggy_methods": 2
  },
  {
    "name": "Normalize.Normalize",
    "class_name": "com.google.javascript.jscomp.Normalize",
    "signature": "com.google.javascript.jscomp.Normalize.Normalize(AbstractCompiler,boolean)",
    "snippet": "  Normalize(AbstractCompiler compiler, boolean assertOnChange) {\n    this.compiler = compiler;\n    this.assertOnChange = assertOnChange;\n\n    // TODO(nicksantos): assertOnChange should only be true if the tree\n    // is normalized.\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 5,
    "buggy_methods": 2
  },
  {
    "name": "Normalize.process",
    "class_name": "com.google.javascript.jscomp.Normalize",
    "signature": "com.google.javascript.jscomp.Normalize.process(Node,Node)",
    "snippet": "  @Override\n  public void process(Node externs, Node root) {\n    new NodeTraversal(\n        compiler, new NormalizeStatements(compiler, assertOnChange))\n        .traverse(root);\n    if (MAKE_LOCAL_NAMES_UNIQUE) {\n      MakeDeclaredNamesUnique renamer = new MakeDeclaredNamesUnique();\n      NodeTraversal t = new NodeTraversal(compiler, renamer);\n      t.traverseRoots(externs, root);\n    }\n    // It is important that removeDuplicateDeclarations runs after\n    // MakeDeclaredNamesUnique in order for catch block exception names to be\n    // handled properly. Specifically, catch block exception names are\n    // only valid within the catch block, but our currect Scope logic\n    // has no concept of this and includes it in the containing function\n    // (or global scope). MakeDeclaredNamesUnique makes the catch exception\n    // names unique so that removeDuplicateDeclarations() will properly handle\n    // cases where a function scope variable conflict with a exception name:\n    //   function f() {\n    //      try {throw 0;} catch(e) {e; /* catch scope 'e'*/}\n    //      var e = 1; // f scope 'e'\n    //   }\n    // otherwise 'var e = 1' would be rewritten as 'e = 1'.\n    // TODO(johnlenz): Introduce a seperate scope for catch nodes.\n    removeDuplicateDeclarations(externs, root);\n    new PropagateConstantAnnotationsOverVars(compiler, assertOnChange)\n        .process(externs, root);\n\n    if (!compiler.getLifeCycleStage().isNormalized()) {\n      compiler.setLifeCycleStage(LifeCycleStage.NORMALIZED);\n    }\n  }",
    "comment": "",
    "is_bug": true,
    "failing_test_cases": 5,
    "buggy_methods": 2
  },
  {
    "name": "Normalize.removeDuplicateDeclarations",
    "class_name": "com.google.javascript.jscomp.Normalize",
    "signature": "com.google.javascript.jscomp.Normalize.removeDuplicateDeclarations(Node,Node)",
    "snippet": "  private void removeDuplicateDeclarations(Node externs, Node root) {\n    Callback tickler = new ScopeTicklingCallback();\n    ScopeCreator scopeCreator =  new SyntacticScopeCreator(\n        compiler, new DuplicateDeclarationHandler());\n    NodeTraversal t = new NodeTraversal(compiler, tickler, scopeCreator);\n    t.traverseRoots(externs, root);\n  }",
    "comment": " Remove duplicate VAR declarations. ",
    "is_bug": false,
    "failing_test_cases": 5,
    "buggy_methods": 2
  },
  {
    "name": "DuplicateDeclarationHandler.onRedeclaration",
    "class_name": "com.google.javascript.jscomp.Normalize$DuplicateDeclarationHandler",
    "signature": "com.google.javascript.jscomp.Normalize$DuplicateDeclarationHandler.onRedeclaration(Scope,String,Node,CompilerInput)",
    "snippet": "    @Override\n    public void onRedeclaration(\n        Scope s, String name, Node n, CompilerInput input) {\n      Preconditions.checkState(n.getType() == Token.NAME);\n      Node parent = n.getParent();\n      Var v = s.getVar(name);\n\n      if (v != null && s.isGlobal()) {\n        // We allow variables to be duplicate declared if one\n        // declaration appears in source and the other in externs.\n        // This deals with issues where a browser built-in is declared\n        // in one browser but not in another.\n        if (v.isExtern() && !input.isExtern()) {\n          if (hasOkDuplicateDeclaration.add(v)) {\n            return;\n          }\n        }\n      }\n\n      // If name is \"arguments\", Var maybe null.\n      if (v != null && v.getParentNode().getType() == Token.CATCH) {\n        // Redeclaration of a catch expression variable is hard to model\n        // without support for \"with\" expressions.\n        // The EcmaScript spec (section 12.14), declares that a catch\n        // \"catch (e) {}\" is handled like \"with ({'e': e}) {}\" so that\n        // \"var e\" would refer to the scope variable, but any following\n        // reference would still refer to \"e\" of the catch expression.\n        // Until we have support for this disallow it.\n        // Currently the Scope object adds the catch expression to the\n        // function scope, which is technically not true but a good\n        // approximation for most uses.\n\n        // TODO(johnlenz): Consider improving how scope handles catch\n        // expression.\n\n        // Use the name of the var before it was made unique.\n        name = MakeDeclaredNamesUnique.ContextualRenameInverter.getOrginalName(\n            name);\n        compiler.report(\n            JSError.make(\n                input.getName(), n,\n                CATCH_BLOCK_VAR_ERROR, name));\n      } else if (v != null && parent.getType() == Token.FUNCTION) {\n        if (v.getParentNode().getType() == Token.VAR) {\n          s.undeclare(v);\n          s.declare(name, n, n.getJSType(), v.input);\n          replaceVarWithAssignment(v.getNameNode(), v.getParentNode(),\n              v.getParentNode().getParent());\n        }\n      } else if (parent.getType() == Token.VAR) {\n        Preconditions.checkState(parent.hasOneChild());\n\n        replaceVarWithAssignment(n, parent, parent.getParent());\n      }\n    }",
    "comment": " Remove duplicate VAR declarations encountered discovered during scope creation. ",
    "is_bug": false,
    "failing_test_cases": 5,
    "buggy_methods": 2
  },
  {
    "name": "NormalizeStatements.annotateConstantsByConvention",
    "class_name": "com.google.javascript.jscomp.Normalize$NormalizeStatements",
    "signature": "com.google.javascript.jscomp.Normalize$NormalizeStatements.annotateConstantsByConvention(Node,Node)",
    "snippet": "    private void annotateConstantsByConvention(Node n, Node parent) {\n      Preconditions.checkState(\n          n.getType() == Token.NAME\n          || n.getType() == Token.STRING\n          || n.getType() == Token.GET\n          || n.getType() == Token.SET);\n\n      // There are only two cases where a string token\n      // may be a variable reference: The right side of a GETPROP\n      // or an OBJECTLIT key.\n      boolean isObjLitKey = NodeUtil.isObjectLitKey(n, parent);\n      boolean isProperty = isObjLitKey ||\n          (parent.getType() == Token.GETPROP &&\n           parent.getLastChild() == n);\n      if (n.getType() == Token.NAME || isProperty) {\n        boolean isMarkedConstant = n.getBooleanProp(Node.IS_CONSTANT_NAME);\n        if (!isMarkedConstant &&\n            NodeUtil.isConstantByConvention(\n                compiler.getCodingConvention(), n, parent)) {\n          if (assertOnChange) {\n            String name = n.getString();\n            throw new IllegalStateException(\n                \"Unexpected const change.\\n\" +\n                \"  name: \"+ name + \"\\n\" +\n                \"  parent:\" + n.getParent().toStringTree());\n          }\n          n.putBooleanProp(Node.IS_CONSTANT_NAME, true);\n        }\n      }\n    }",
    "comment": " Mark names and properties that are constants by convention. ",
    "is_bug": false,
    "failing_test_cases": 5,
    "buggy_methods": 2
  },
  {
    "name": "NormalizeStatements.doStatementNormalizations",
    "class_name": "com.google.javascript.jscomp.Normalize$NormalizeStatements",
    "signature": "com.google.javascript.jscomp.Normalize$NormalizeStatements.doStatementNormalizations(NodeTraversal,Node,Node)",
    "snippet": "    private void doStatementNormalizations(\n        NodeTraversal t, Node n, Node parent) {\n      if (n.getType() == Token.LABEL) {\n        normalizeLabels(n);\n      }\n\n      // Only inspect the children of SCRIPTs, BLOCKs and LABELs, as all these\n      // are the only legal place for VARs and FOR statements.\n      if (NodeUtil.isStatementBlock(n) || n.getType() == Token.LABEL) {\n        extractForInitializer(n, null, null);\n      }\n\n      // Only inspect the children of SCRIPTs, BLOCKs, as all these\n      // are the only legal place for VARs.\n      if (NodeUtil.isStatementBlock(n)) {\n        splitVarDeclarations(n);\n      }\n\n      if (n.getType() == Token.FUNCTION) {\n        moveNamedFunctions(n.getLastChild());\n      }\n    }",
    "comment": " Do normalizations that introduce new siblings or parents. ",
    "is_bug": false,
    "failing_test_cases": 5,
    "buggy_methods": 2
  },
  {
    "name": "NormalizeStatements.extractForInitializer",
    "class_name": "com.google.javascript.jscomp.Normalize$NormalizeStatements",
    "signature": "com.google.javascript.jscomp.Normalize$NormalizeStatements.extractForInitializer(Node,Node,Node)",
    "snippet": "    private void extractForInitializer(\n        Node n, Node before, Node beforeParent) {\n\n      for (Node next, c = n.getFirstChild(); c != null; c = next) {\n        next = c.getNext();\n        Node insertBefore = (before == null) ? c : before;\n        Node insertBeforeParent = (before == null) ? n : beforeParent;\n        switch (c.getType()) {\n          case Token.LABEL:\n            extractForInitializer(c, insertBefore, insertBeforeParent);\n            break;\n          case Token.FOR:\n            if (NodeUtil.isForIn(c)) {\n              Node first = c.getFirstChild();\n              if (first.getType() == Token.VAR) {\n                // Transform:\n                //    for (var a in b) {}\n                // to:\n                //    var a; for (a in b) {};\n                Node newStatement = first.cloneTree();\n                Node name = first.removeFirstChild();\n                first.getParent().replaceChild(first, name);\n                insertBeforeParent.addChildBefore(newStatement, insertBefore);\n                reportCodeChange(\"FOR-IN var declaration\");\n              }\n            } else if (c.getFirstChild().getType() != Token.EMPTY) {\n              Node init = c.getFirstChild();\n              Node empty = new Node(Token.EMPTY);\n              empty.copyInformationFrom(c);\n              c.replaceChild(init, empty);\n\n              Node newStatement;\n              // Only VAR statements, and expressions are allowed,\n              // but are handled differently.\n              if (init.getType() == Token.VAR) {\n                newStatement = init;\n              } else {\n                newStatement = NodeUtil.newExpr(init);\n              }\n\n              insertBeforeParent.addChildBefore(newStatement, insertBefore);\n              reportCodeChange(\"FOR initializer\");\n            }\n            break;\n        }\n      }\n    }",
    "comment": " Bring the initializers out of FOR loops.  These need to be placed before any associated LABEL nodes. This needs to be done from the top level label first so this is called as a pre-order callback (from shouldTraverse).  @param n The node to inspect. @param before The node to insert the initializer before. @param beforeParent The parent of the node before which the initializer will be inserted. ",
    "is_bug": false,
    "failing_test_cases": 5,
    "buggy_methods": 2
  },
  {
    "name": "NormalizeStatements.shouldTraverse",
    "class_name": "com.google.javascript.jscomp.Normalize$NormalizeStatements",
    "signature": "com.google.javascript.jscomp.Normalize$NormalizeStatements.shouldTraverse(NodeTraversal,Node,Node)",
    "snippet": "    @Override\n    public boolean shouldTraverse(NodeTraversal t, Node n, Node parent) {\n      doStatementNormalizations(t, n, parent);\n\n      return true;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 5,
    "buggy_methods": 2
  },
  {
    "name": "NormalizeStatements.splitVarDeclarations",
    "class_name": "com.google.javascript.jscomp.Normalize$NormalizeStatements",
    "signature": "com.google.javascript.jscomp.Normalize$NormalizeStatements.splitVarDeclarations(Node)",
    "snippet": "    private void splitVarDeclarations(Node n) {\n      for (Node next, c = n.getFirstChild(); c != null; c = next) {\n        next = c.getNext();\n        if (c.getType() == Token.VAR) {\n          if (assertOnChange && !c.hasChildren()) {\n            throw new IllegalStateException(\"Empty VAR node.\");\n          }\n\n          while (c.getFirstChild() != c.getLastChild()) {\n            Node name = c.getFirstChild();\n            c.removeChild(name);\n            Node newVar = new Node(\n                Token.VAR, name, n.getLineno(), n.getCharno());\n            n.addChildBefore(newVar, c);\n            reportCodeChange(\"VAR with multiple children\");\n          }\n        }\n      }\n    }",
    "comment": " Split a var node such as: var a, b; into individual statements: var a; var b; @param n The whose children we should inspect. ",
    "is_bug": false,
    "failing_test_cases": 5,
    "buggy_methods": 2
  },
  {
    "name": "NormalizeStatements.visit",
    "class_name": "com.google.javascript.jscomp.Normalize$NormalizeStatements",
    "signature": "com.google.javascript.jscomp.Normalize$NormalizeStatements.visit(NodeTraversal,Node,Node)",
    "snippet": "    @Override\n    public void visit(NodeTraversal t, Node n, Node parent) {\n      switch (n.getType()) {\n        case Token.WHILE:\n          if (CONVERT_WHILE_TO_FOR) {\n            Node expr = n.getFirstChild();\n            n.setType(Token.FOR);\n            Node empty = new Node(Token.EMPTY);\n            empty.copyInformationFrom(n);\n            n.addChildBefore(empty, expr);\n            n.addChildAfter(empty.cloneNode(), expr);\n            reportCodeChange(\"WHILE node\");\n          }\n          break;\n\n        case Token.FUNCTION:\n          normalizeFunctionDeclaration(n);\n          break;\n\n        case Token.NAME:\n        case Token.STRING:\n        case Token.GET:\n        case Token.SET:\n          if (!compiler.getLifeCycleStage().isNormalizedObfuscated()) {\n            annotateConstantsByConvention(n, parent);\n          }\n          break;\n      }\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 5,
    "buggy_methods": 2
  },
  {
    "name": "ScopeTicklingCallback.enterScope",
    "class_name": "com.google.javascript.jscomp.Normalize$ScopeTicklingCallback",
    "signature": "com.google.javascript.jscomp.Normalize$ScopeTicklingCallback.enterScope(NodeTraversal)",
    "snippet": "    @Override\n    public void enterScope(NodeTraversal t) {\n      // Cause the scope to be created, which will cause duplicate\n      // to be found.\n      t.getScope();\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 5,
    "buggy_methods": 2
  },
  {
    "name": "PassFactory.PassFactory",
    "class_name": "com.google.javascript.jscomp.PassFactory",
    "signature": "com.google.javascript.jscomp.PassFactory.PassFactory(String,boolean)",
    "snippet": "  protected PassFactory(String name, boolean isOneTimePass) {\n    this.name = name;\n    this.isOneTimePass = isOneTimePass;\n  }",
    "comment": " @param name The name of the pass that this factory creates. @param isOneTimePass If true, the pass produced by this factory can only be run once. ",
    "is_bug": false,
    "failing_test_cases": 5,
    "buggy_methods": 2
  },
  {
    "name": "PrepareAst.PrepareAst",
    "class_name": "com.google.javascript.jscomp.PrepareAst",
    "signature": "com.google.javascript.jscomp.PrepareAst.PrepareAst(AbstractCompiler)",
    "snippet": "  PrepareAst(AbstractCompiler compiler) {\n    this(compiler, false);\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 5,
    "buggy_methods": 2
  },
  {
    "name": "PrepareAst.PrepareAst",
    "class_name": "com.google.javascript.jscomp.PrepareAst",
    "signature": "com.google.javascript.jscomp.PrepareAst.PrepareAst(AbstractCompiler,boolean)",
    "snippet": "  PrepareAst(AbstractCompiler compiler, boolean checkOnly) {\n    this.compiler = compiler;\n    this.checkOnly = checkOnly;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 5,
    "buggy_methods": 2
  },
  {
    "name": "PrepareAst.process",
    "class_name": "com.google.javascript.jscomp.PrepareAst",
    "signature": "com.google.javascript.jscomp.PrepareAst.process(Node,Node)",
    "snippet": "  @Override\n  public void process(Node externs, Node root) {\n    if (checkOnly) {\n      normalizeNodeTypes(root);\n    } else {\n      // Don't perform \"PrepareAnnotations\" when doing checks as\n      // they currently aren't valid during sanity checks.  In particular,\n      // they DIRECT_EVAL shouldn't be applied after inlining has been\n      // performed.\n      if (externs != null) {\n        NodeTraversal.traverse(\n            compiler, externs, new PrepareAnnotations(compiler));\n      }\n      if (root != null) {\n        NodeTraversal.traverse(\n            compiler, root, new PrepareAnnotations(compiler));\n      }\n    }\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 5,
    "buggy_methods": 2
  },
  {
    "name": "PrepareAnnotations.annotateCalls",
    "class_name": "com.google.javascript.jscomp.PrepareAst$PrepareAnnotations",
    "signature": "com.google.javascript.jscomp.PrepareAst$PrepareAnnotations.annotateCalls(Node)",
    "snippet": "    private void annotateCalls(Node n) {\n      Preconditions.checkState(n.getType() == Token.CALL);\n\n      // Keep track of of the \"this\" context of a call.  A call without an\n      // explicit \"this\" is a free call.\n      Node first = n.getFirstChild();\n      if (!NodeUtil.isGet(first)) {\n        n.putBooleanProp(Node.FREE_CALL, true);\n      }\n\n      // Keep track of the context in which eval is called. It is important\n      // to distinguish between \"(0, eval)()\" and \"eval()\".\n      if (first.getType() == Token.NAME &&\n          \"eval\".equals(first.getString())) {\n        first.putBooleanProp(Node.DIRECT_EVAL, true);\n      }\n    }",
    "comment": " There are two types of calls we are interested in calls without explicit \"this\" values (what we are call \"free\" calls) and direct call to eval. ",
    "is_bug": false,
    "failing_test_cases": 5,
    "buggy_methods": 2
  },
  {
    "name": "PrepareAnnotations.shouldTraverse",
    "class_name": "com.google.javascript.jscomp.PrepareAst$PrepareAnnotations",
    "signature": "com.google.javascript.jscomp.PrepareAst$PrepareAnnotations.shouldTraverse(NodeTraversal,Node,Node)",
    "snippet": "    @Override\n    public boolean shouldTraverse(NodeTraversal t, Node n, Node parent) {\n      if (n.getType() == Token.OBJECTLIT) {\n        normalizeObjectLiteralAnnotations(n);\n      }\n      return true;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 5,
    "buggy_methods": 2
  },
  {
    "name": "PrepareAnnotations.visit",
    "class_name": "com.google.javascript.jscomp.PrepareAst$PrepareAnnotations",
    "signature": "com.google.javascript.jscomp.PrepareAst$PrepareAnnotations.visit(NodeTraversal,Node,Node)",
    "snippet": "    @Override\n    public void visit(NodeTraversal t, Node n, Node parent) {\n      switch (n.getType()) {\n        case Token.CALL:\n          annotateCalls(n);\n          break;\n\n        case Token.FUNCTION:\n          annotateFunctions(n, parent);\n          annotateDispatchers(n, parent);\n          break;\n      }\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 5,
    "buggy_methods": 2
  },
  {
    "name": "TweakFunction.getName",
    "class_name": "com.google.javascript.jscomp.ProcessTweaks$TweakFunction",
    "signature": "com.google.javascript.jscomp.ProcessTweaks$TweakFunction.getName()",
    "snippet": "    String getName() {\n      return name;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 5,
    "buggy_methods": 2
  },
  {
    "name": "RhinoErrorReporter.forNewRhino",
    "class_name": "com.google.javascript.jscomp.RhinoErrorReporter",
    "signature": "com.google.javascript.jscomp.RhinoErrorReporter.forNewRhino(AbstractCompiler)",
    "snippet": "  public static com.google.javascript.jscomp.mozilla.rhino.ErrorReporter\n      forNewRhino(AbstractCompiler compiler) {\n    return new NewRhinoErrorReporter(compiler);\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 5,
    "buggy_methods": 2
  },
  {
    "name": "RhinoErrorReporter.forOldRhino",
    "class_name": "com.google.javascript.jscomp.RhinoErrorReporter",
    "signature": "com.google.javascript.jscomp.RhinoErrorReporter.forOldRhino(AbstractCompiler)",
    "snippet": "  public static ErrorReporter forOldRhino(AbstractCompiler compiler) {\n    return new OldRhinoErrorReporter(compiler);\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 5,
    "buggy_methods": 2
  },
  {
    "name": "RhinoErrorReporter.replacePlaceHolders",
    "class_name": "com.google.javascript.jscomp.RhinoErrorReporter",
    "signature": "com.google.javascript.jscomp.RhinoErrorReporter.replacePlaceHolders(String)",
    "snippet": "  private String replacePlaceHolders(String s) {\n    s = Pattern.quote(s);\n    return s.replaceAll(\"\\\\{\\\\d+\\\\}\", \"\\\\\\\\E.*\\\\\\\\Q\");\n  }",
    "comment": " For each message such as \"Not a good use of {0}\", replace the place holder {0} with a wild card that matches all possible strings. Also put the any non-place-holder in quotes for regex matching later. ",
    "is_bug": false,
    "failing_test_cases": 5,
    "buggy_methods": 2
  },
  {
    "name": "Scope.Scope",
    "class_name": "com.google.javascript.jscomp.Scope",
    "signature": "com.google.javascript.jscomp.Scope.Scope(Node,AbstractCompiler)",
    "snippet": "  Scope(Node rootNode, AbstractCompiler compiler) {\n    this.parent = null;\n    this.rootNode = rootNode;\n    thisType = compiler.getTypeRegistry().getNativeObjectType(GLOBAL_THIS);\n    this.isBottom = false;\n    this.depth = 0;\n  }",
    "comment": " Creates a global Scope. @param rootNode  Typically the global BLOCK node. ",
    "is_bug": false,
    "failing_test_cases": 5,
    "buggy_methods": 2
  },
  {
    "name": "Scope.declare",
    "class_name": "com.google.javascript.jscomp.Scope",
    "signature": "com.google.javascript.jscomp.Scope.declare(String,Node,JSType,CompilerInput)",
    "snippet": "  Var declare(String name, Node nameNode, JSType type, CompilerInput input) {\n    return declare(name, nameNode, type, input, true);\n  }",
    "comment": " Declares a variable whose type is inferred.  @param name name of the variable @param nameNode the NAME node declaring the variable @param type the variable's type @param input the input in which this variable is defined. ",
    "is_bug": false,
    "failing_test_cases": 5,
    "buggy_methods": 2
  },
  {
    "name": "Scope.declare",
    "class_name": "com.google.javascript.jscomp.Scope",
    "signature": "com.google.javascript.jscomp.Scope.declare(String,Node,JSType,CompilerInput,boolean)",
    "snippet": "  Var declare(String name, Node nameNode,\n      JSType type, CompilerInput input, boolean inferred) {\n    Preconditions.checkState(name != null && name.length() > 0);\n\n    // Make sure that it's declared only once\n    Preconditions.checkState(vars.get(name) == null);\n\n    // native variables do not have a name node.\n    // TODO(user): make Var abstract and have NativeVar, NormalVar.\n    JSDocInfo info = NodeUtil.getInfoForNameNode(nameNode);\n\n    Var var = new Var(inferred, name, nameNode, type, this, vars.size(), input,\n        info != null && info.isDefine(), info);\n\n    vars.put(name, var);\n    return var;\n  }",
    "comment": " Declares a variable.  @param name name of the variable @param nameNode the NAME node declaring the variable @param type the variable's type @param input the input in which this variable is defined. @param inferred Whether this variable's type is inferred (as opposed to declared). ",
    "is_bug": false,
    "failing_test_cases": 5,
    "buggy_methods": 2
  },
  {
    "name": "Scope.getParent",
    "class_name": "com.google.javascript.jscomp.Scope",
    "signature": "com.google.javascript.jscomp.Scope.getParent()",
    "snippet": "  public Scope getParent() {\n    return parent;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 5,
    "buggy_methods": 2
  },
  {
    "name": "Scope.getVar",
    "class_name": "com.google.javascript.jscomp.Scope",
    "signature": "com.google.javascript.jscomp.Scope.getVar(String)",
    "snippet": "  public Var getVar(String name) {\n    Var var = vars.get(name);\n    if (var != null) {\n      return var;\n    } else if (parent != null) { // Recurse up the parent Scope\n      return parent.getVar(name);\n    } else {\n      return null;\n    }\n  }",
    "comment": " Returns the variable, may be null ",
    "is_bug": false,
    "failing_test_cases": 5,
    "buggy_methods": 2
  },
  {
    "name": "Scope.isDeclared",
    "class_name": "com.google.javascript.jscomp.Scope",
    "signature": "com.google.javascript.jscomp.Scope.isDeclared(String,boolean)",
    "snippet": "  public boolean isDeclared(String name, boolean recurse) {\n    Scope scope = this;\n    if (scope.vars.containsKey(name))\n      return true;\n\n    if (scope.parent != null && recurse) {\n      return scope.parent.isDeclared(name, recurse);\n    }\n    return false;\n  }",
    "comment": " Returns true if a variable is declared. ",
    "is_bug": false,
    "failing_test_cases": 5,
    "buggy_methods": 2
  },
  {
    "name": "Scope.isGlobal",
    "class_name": "com.google.javascript.jscomp.Scope",
    "signature": "com.google.javascript.jscomp.Scope.isGlobal()",
    "snippet": "  public boolean isGlobal() {\n    return parent == null;\n  }",
    "comment": " Returns whether this is the global scope. ",
    "is_bug": false,
    "failing_test_cases": 5,
    "buggy_methods": 2
  },
  {
    "name": "Scope.isLocal",
    "class_name": "com.google.javascript.jscomp.Scope",
    "signature": "com.google.javascript.jscomp.Scope.isLocal()",
    "snippet": "  public boolean isLocal() {\n    return !isGlobal();\n  }",
    "comment": " Returns whether this is a local scope (i.e. not the global scope). ",
    "is_bug": false,
    "failing_test_cases": 5,
    "buggy_methods": 2
  },
  {
    "name": "Var.getParentNode",
    "class_name": "com.google.javascript.jscomp.Scope$Var",
    "signature": "com.google.javascript.jscomp.Scope$Var.getParentNode()",
    "snippet": "    public Node getParentNode() {\n      return nameNode == null ? null : nameNode.getParent();\n    }",
    "comment": " Gets the parent of the name node. ",
    "is_bug": false,
    "failing_test_cases": 5,
    "buggy_methods": 2
  },
  {
    "name": "Var.isExtern",
    "class_name": "com.google.javascript.jscomp.Scope$Var",
    "signature": "com.google.javascript.jscomp.Scope$Var.isExtern()",
    "snippet": "    boolean isExtern() {\n      return input == null || input.isExtern();\n    }",
    "comment": " Returns whether this is defined in an extern file. ",
    "is_bug": false,
    "failing_test_cases": 5,
    "buggy_methods": 2
  },
  {
    "name": "SourceFile.SourceFile",
    "class_name": "com.google.javascript.jscomp.SourceFile",
    "signature": "com.google.javascript.jscomp.SourceFile.SourceFile(String)",
    "snippet": "  SourceFile(String fileName) {\n    this.fileName = fileName;\n    // Starting point: offset 0 is at line 1.\n    this.lastOffset = 0;\n    this.lastLine = 1;\n  }",
    "comment": " Construct a new abstract source file.  @param fileName The file name of the source file. It does not necessarily need to correspond to a real path. But it should be unique. Will appear in warning messages emitted by the compiler. ",
    "is_bug": false,
    "failing_test_cases": 5,
    "buggy_methods": 2
  },
  {
    "name": "SourceFile.fromCode",
    "class_name": "com.google.javascript.jscomp.SourceFile",
    "signature": "com.google.javascript.jscomp.SourceFile.fromCode(String,String)",
    "snippet": "  public static SourceFile fromCode(String fileName, String code) {\n    return new Preloaded(fileName, code);\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 5,
    "buggy_methods": 2
  },
  {
    "name": "SourceFile.getCode",
    "class_name": "com.google.javascript.jscomp.SourceFile",
    "signature": "com.google.javascript.jscomp.SourceFile.getCode()",
    "snippet": "  public String getCode() throws IOException {\n    return code;\n  }",
    "comment": " Gets all the code in this source file. @throws IOException ",
    "is_bug": false,
    "failing_test_cases": 5,
    "buggy_methods": 2
  },
  {
    "name": "SourceFile.getName",
    "class_name": "com.google.javascript.jscomp.SourceFile",
    "signature": "com.google.javascript.jscomp.SourceFile.getName()",
    "snippet": "  public String getName() {\n    return fileName;\n  }",
    "comment": "Returns a unique name for the source file. */",
    "is_bug": false,
    "failing_test_cases": 5,
    "buggy_methods": 2
  },
  {
    "name": "SourceFile.setCode",
    "class_name": "com.google.javascript.jscomp.SourceFile",
    "signature": "com.google.javascript.jscomp.SourceFile.setCode(String)",
    "snippet": "  private void setCode(String sourceCode) {\n    code = sourceCode;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 5,
    "buggy_methods": 2
  },
  {
    "name": "SourceFile.setOriginalPath",
    "class_name": "com.google.javascript.jscomp.SourceFile",
    "signature": "com.google.javascript.jscomp.SourceFile.setOriginalPath(String)",
    "snippet": "  public void setOriginalPath(String originalPath) {\n    this.originalPath = originalPath;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 5,
    "buggy_methods": 2
  },
  {
    "name": "SuppressDocWarningsGuard.SuppressDocWarningsGuard",
    "class_name": "com.google.javascript.jscomp.SuppressDocWarningsGuard",
    "signature": "com.google.javascript.jscomp.SuppressDocWarningsGuard.SuppressDocWarningsGuard(Map)",
    "snippet": "  SuppressDocWarningsGuard(Map<String, DiagnosticGroup> suppressableGroups) {\n    for (Map.Entry<String, DiagnosticGroup> entry :\n             suppressableGroups.entrySet()) {\n      suppressors.put(\n          entry.getKey(),\n          new DiagnosticGroupWarningsGuard(\n              entry.getValue(),\n              CheckLevel.OFF));\n    }\n  }",
    "comment": " The suppressable groups, indexed by name. ",
    "is_bug": false,
    "failing_test_cases": 5,
    "buggy_methods": 2
  },
  {
    "name": "SuppressDocWarningsGuard.getPriority",
    "class_name": "com.google.javascript.jscomp.SuppressDocWarningsGuard",
    "signature": "com.google.javascript.jscomp.SuppressDocWarningsGuard.getPriority()",
    "snippet": "  @Override\n  public int getPriority() {\n    // Happens after path-based filtering, but before other times\n    // of filtering.\n    return WarningsGuard.Priority.SUPPRESS_DOC.value;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 5,
    "buggy_methods": 2
  },
  {
    "name": "SyntacticScopeCreator.SyntacticScopeCreator",
    "class_name": "com.google.javascript.jscomp.SyntacticScopeCreator",
    "signature": "com.google.javascript.jscomp.SyntacticScopeCreator.SyntacticScopeCreator(AbstractCompiler)",
    "snippet": "  SyntacticScopeCreator(AbstractCompiler compiler) {\n    this.compiler = compiler;\n    this.redeclarationHandler = new DefaultRedeclarationHandler();\n  }",
    "comment": " Creates a ScopeCreator. ",
    "is_bug": false,
    "failing_test_cases": 5,
    "buggy_methods": 2
  },
  {
    "name": "SyntacticScopeCreator.SyntacticScopeCreator",
    "class_name": "com.google.javascript.jscomp.SyntacticScopeCreator",
    "signature": "com.google.javascript.jscomp.SyntacticScopeCreator.SyntacticScopeCreator(AbstractCompiler,RedeclarationHandler)",
    "snippet": "  SyntacticScopeCreator(\n      AbstractCompiler compiler, RedeclarationHandler redeclarationHandler) {\n    this.compiler = compiler;\n    this.redeclarationHandler = redeclarationHandler;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 5,
    "buggy_methods": 2
  },
  {
    "name": "SyntacticScopeCreator.createScope",
    "class_name": "com.google.javascript.jscomp.SyntacticScopeCreator",
    "signature": "com.google.javascript.jscomp.SyntacticScopeCreator.createScope(Node,Scope)",
    "snippet": "  public Scope createScope(Node n, Scope parent) {\n    sourceName = null;\n    if (parent == null) {\n      scope = new Scope(n, compiler);\n    } else {\n      scope = new Scope(parent, n);\n    }\n\n    scanRoot(n, parent);\n\n    sourceName = null;\n    Scope returnedScope = scope;\n    scope = null;\n    return returnedScope;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 5,
    "buggy_methods": 2
  },
  {
    "name": "SyntacticScopeCreator.declareVar",
    "class_name": "com.google.javascript.jscomp.SyntacticScopeCreator",
    "signature": "com.google.javascript.jscomp.SyntacticScopeCreator.declareVar(Node)",
    "snippet": "  private void declareVar(Node n) {\n    Preconditions.checkState(n.getType() == Token.NAME);\n\n    CompilerInput input = compiler.getInput(sourceName);\n    String name = n.getString();\n    if (scope.isDeclared(name, false)\n        || (scope.isLocal() && name.equals(ARGUMENTS))) {\n      redeclarationHandler.onRedeclaration(\n          scope, name, n, input);\n    } else {\n      scope.declare(name, n, null, input);\n    }\n  }",
    "comment": " Declares a variable.  @param n The node corresponding to the variable name. @param declaredType The variable's type, according to JSDoc ",
    "is_bug": false,
    "failing_test_cases": 5,
    "buggy_methods": 2
  },
  {
    "name": "SyntacticScopeCreator.scanRoot",
    "class_name": "com.google.javascript.jscomp.SyntacticScopeCreator",
    "signature": "com.google.javascript.jscomp.SyntacticScopeCreator.scanRoot(Node,Scope)",
    "snippet": "  private void scanRoot(Node n, Scope parent) {\n    if (n.getType() == Token.FUNCTION) {\n      sourceName = (String) n.getProp(Node.SOURCENAME_PROP);\n\n      final Node fnNameNode = n.getFirstChild();\n      final Node args = fnNameNode.getNext();\n      final Node body = args.getNext();\n\n      // Bleed the function name into the scope, if it hasn't\n      // been declared in the outer scope.\n      String fnName = fnNameNode.getString();\n      if (!fnName.isEmpty() && NodeUtil.isFunctionExpression(n)) {\n        declareVar(fnNameNode);\n      }\n\n      // Args: Declare function variables\n      Preconditions.checkState(args.getType() == Token.LP);\n      for (Node a = args.getFirstChild(); a != null;\n           a = a.getNext()) {\n        Preconditions.checkState(a.getType() == Token.NAME);\n        declareVar(a);\n      }\n\n      // Body\n      scanVars(body, n);\n    } else {\n      // It's the global block\n      Preconditions.checkState(scope.getParent() == null);\n      scanVars(n, null);\n    }\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 5,
    "buggy_methods": 2
  },
  {
    "name": "SyntacticScopeCreator.scanVars",
    "class_name": "com.google.javascript.jscomp.SyntacticScopeCreator",
    "signature": "com.google.javascript.jscomp.SyntacticScopeCreator.scanVars(Node,Node)",
    "snippet": "  private void scanVars(Node n, Node parent) {\n    switch (n.getType()) {\n      case Token.VAR:\n        // Declare all variables. e.g. var x = 1, y, z;\n        for (Node child = n.getFirstChild();\n             child != null;) {\n          Node next = child.getNext();\n          declareVar(child);\n          child = next;\n        }\n        return;\n\n      case Token.FUNCTION:\n        if (NodeUtil.isFunctionExpression(n)) {\n          return;\n        }\n\n        String fnName = n.getFirstChild().getString();\n        if (fnName.isEmpty()) {\n          // This is invalid, but allow it so the checks can catch it.\n          return;\n        }\n        declareVar(n.getFirstChild());\n        return;   // should not examine function's children\n\n      case Token.CATCH:\n        Preconditions.checkState(n.getChildCount() == 2);\n        Preconditions.checkState(n.getFirstChild().getType() == Token.NAME);\n        // the first child is the catch var and the third child\n        // is the code block\n\n        final Node var = n.getFirstChild();\n        final Node block = var.getNext();\n\n        declareVar(var);\n        scanVars(block, n);\n        return;  // only one child to scan\n\n      case Token.SCRIPT:\n        sourceName = (String) n.getProp(Node.SOURCENAME_PROP);\n        break;\n    }\n\n    // Variables can only occur in statement-level nodes, so\n    // we only need to traverse children in a couple special cases.\n    if (NodeUtil.isControlStructure(n) || NodeUtil.isStatementBlock(n)) {\n      for (Node child = n.getFirstChild();\n           child != null;) {\n        Node next = child.getNext();\n        scanVars(child, n);\n        child = next;\n      }\n    }\n  }",
    "comment": " Scans and gather variables declarations under a Node ",
    "is_bug": false,
    "failing_test_cases": 5,
    "buggy_methods": 2
  },
  {
    "name": "SyntheticAst.SyntheticAst",
    "class_name": "com.google.javascript.jscomp.SyntheticAst",
    "signature": "com.google.javascript.jscomp.SyntheticAst.SyntheticAst(String)",
    "snippet": "  SyntheticAst(String sourceName) {\n    this.sourceName = sourceName;\n    clearAst();\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 5,
    "buggy_methods": 2
  },
  {
    "name": "SyntheticAst.clearAst",
    "class_name": "com.google.javascript.jscomp.SyntheticAst",
    "signature": "com.google.javascript.jscomp.SyntheticAst.clearAst()",
    "snippet": "  @Override\n  public void clearAst() {\n    root = new Node(Token.SCRIPT);\n    root.putProp(Node.SOURCENAME_PROP, sourceName);\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 5,
    "buggy_methods": 2
  },
  {
    "name": "SyntheticAst.getAstRoot",
    "class_name": "com.google.javascript.jscomp.SyntheticAst",
    "signature": "com.google.javascript.jscomp.SyntheticAst.getAstRoot(AbstractCompiler)",
    "snippet": "  @Override\n  public Node getAstRoot(AbstractCompiler compiler) {\n    return root;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 5,
    "buggy_methods": 2
  },
  {
    "name": "Tracer.Tracer",
    "class_name": "com.google.javascript.jscomp.Tracer",
    "signature": "com.google.javascript.jscomp.Tracer.Tracer(String,String)",
    "snippet": "  Tracer(@Nullable String type, @Nullable String comment) {\n    this.type = type;\n    this.comment = comment == null ? \"\" : comment;\n    startTimeMs = clock.currentTimeMillis();\n    startThread = Thread.currentThread();\n    if (!extraTracingStatistics.isEmpty()) {\n      int size = extraTracingStatistics.size();\n      extraTracingValues = new long[size];\n      int i = 0;\n      for (TracingStatistic tracingStatistic : extraTracingStatistics) {\n        extraTracingValues[i] = tracingStatistic.start(startThread);\n        i++;\n      }\n    }\n\n    ThreadTrace trace = getThreadTrace();\n\n    // Do nothing if the current thread trace wasn't initialized.\n    if (!trace.isInitialized()) {\n      return;\n    }\n\n    // Check if we are creating too many Tracers.\n    if (trace.events.size() >= MAX_TRACE_SIZE) {\n      logger.log(Level.WARNING,\n                  \"Giant thread trace. Too many Tracers created. \"\n                    + \"Clearing to avoid memory leak.\",\n                  new Throwable(trace.toString()));\n      trace.truncateEvents();\n    }\n\n    // Check if we forgot to close the Tracers.\n    if (trace.outstandingEvents.size() >= MAX_TRACE_SIZE) {\n      logger.log(Level.WARNING,\n                  \"Too many outstanding Tracers. Tracer.stop() is missing \"\n                    + \"or Tracer.stop() is not wrapped in a \"\n                    + \"try/finally block. \"\n                    + \"Clearing to avoid memory leak.\",\n                  new Throwable(trace.toString()));\n      trace.truncateOutstandingEvents();\n    }\n\n    trace.startEvent(this);\n  }",
    "comment": " Create and start a tracer. Both type and comment may be null. See class comment for usage.  @param type The type for totalling @param comment Comment about this tracer ",
    "is_bug": false,
    "failing_test_cases": 5,
    "buggy_methods": 2
  },
  {
    "name": "Tracer.getThreadTrace",
    "class_name": "com.google.javascript.jscomp.Tracer",
    "signature": "com.google.javascript.jscomp.Tracer.getThreadTrace()",
    "snippet": "  static ThreadTrace getThreadTrace() {\n    ThreadTrace t = traces.get();\n    if (t == null) {\n      t = new ThreadTrace();\n      t.prettyPrint = defaultPrettyPrint;\n      traces.set(t);\n    }\n    return t;\n  }",
    "comment": " Get the ThreadTrace for the current thread, creating one if necessary. ",
    "is_bug": false,
    "failing_test_cases": 5,
    "buggy_methods": 2
  },
  {
    "name": "Tracer.stop",
    "class_name": "com.google.javascript.jscomp.Tracer",
    "signature": "com.google.javascript.jscomp.Tracer.stop()",
    "snippet": "  long stop() {\n    return stop(-1);\n  }",
    "comment": "Stop the trace using the default silence_threshold  @return  The time that this trace actually ran. ",
    "is_bug": false,
    "failing_test_cases": 5,
    "buggy_methods": 2
  },
  {
    "name": "Tracer.stop",
    "class_name": "com.google.javascript.jscomp.Tracer",
    "signature": "com.google.javascript.jscomp.Tracer.stop(int)",
    "snippet": "  long stop(int silence_threshold) {\n    Preconditions.checkState(Thread.currentThread() == startThread);\n\n    ThreadTrace trace = getThreadTrace();\n    // Do nothing if the thread trace was not initialized.\n    if (!trace.isInitialized()) {\n      return 0;\n    }\n\n    stopTimeMs = clock.currentTimeMillis();\n    if (extraTracingValues != null) {\n      // We use extraTracingValues.length rather than extraTracingStatistics.size() because\n      // a new statistic may have been added\n      for (int i = 0; i < extraTracingValues.length; i++) {\n        long value = extraTracingStatistics.get(i).stop(startThread);\n        extraTracingValues[i] = value - extraTracingValues[i];\n      }\n    }\n\n    // Do nothing if the thread trace was not initialized.\n    if (!trace.isInitialized()) {\n      return 0;\n    }\n\n    trace.endEvent(this, silence_threshold);\n    return stopTimeMs - startTimeMs;\n  }",
    "comment": " Stop the trace. This may only be done once and must be done from the same thread that started it. @param silence_threshold Traces for time less than silence_threshold ms will be left out of the trace report. A value of -1 indicates that the current ThreadTrace silence_threshold should be used. @return The time that this trace actually ran ",
    "is_bug": false,
    "failing_test_cases": 5,
    "buggy_methods": 2
  },
  {
    "name": "ThreadTrace.isInitialized",
    "class_name": "com.google.javascript.jscomp.Tracer$ThreadTrace",
    "signature": "com.google.javascript.jscomp.Tracer$ThreadTrace.isInitialized()",
    "snippet": "    boolean isInitialized() {\n      return isInitialized;\n    }",
    "comment": "Is initialized? */",
    "is_bug": false,
    "failing_test_cases": 5,
    "buggy_methods": 2
  },
  {
    "name": "VarCheck.VarCheck",
    "class_name": "com.google.javascript.jscomp.VarCheck",
    "signature": "com.google.javascript.jscomp.VarCheck.VarCheck(AbstractCompiler,boolean)",
    "snippet": "  VarCheck(AbstractCompiler compiler, boolean sanityCheck) {\n    this.compiler = compiler;\n    this.strictExternCheck = compiler.getErrorLevel(\n        JSError.make(\"\", 0, 0, UNDEFINED_EXTERN_VAR_ERROR)) == CheckLevel.ERROR;\n    this.sanityCheck = sanityCheck;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 5,
    "buggy_methods": 2
  },
  {
    "name": "VarCheck.createSynthesizedExternVar",
    "class_name": "com.google.javascript.jscomp.VarCheck",
    "signature": "com.google.javascript.jscomp.VarCheck.createSynthesizedExternVar(String)",
    "snippet": "  private void createSynthesizedExternVar(String varName) {\n    Node nameNode = Node.newString(Token.NAME, varName);\n\n    // Mark the variable as constant if it matches the coding convention\n    // for constant vars.\n    // NOTE(nicksantos): honestly, i'm not sure how much this matters.\n    // AFAIK, all people who use the CONST coding convention also\n    // compile with undeclaredVars as errors. We have some test\n    // cases for this configuration though, and it makes them happier.\n    if (compiler.getCodingConvention().isConstant(varName)) {\n      nameNode.putBooleanProp(Node.IS_CONSTANT_NAME, true);\n    }\n\n    getSynthesizedExternsRoot().addChildToBack(\n        new Node(Token.VAR, nameNode));\n    varsToDeclareInExterns.remove(varName);\n  }",
    "comment": " Create a new variable in a synthetic script. This will prevent subsequent compiler passes from crashing. ",
    "is_bug": true,
    "failing_test_cases": 5,
    "buggy_methods": 2
  },
  {
    "name": "VarCheck.getSynthesizedExternsInput",
    "class_name": "com.google.javascript.jscomp.VarCheck",
    "signature": "com.google.javascript.jscomp.VarCheck.getSynthesizedExternsInput()",
    "snippet": "  private CompilerInput getSynthesizedExternsInput() {\n    if (synthesizedExternsInput == null) {\n      synthesizedExternsInput =\n          compiler.newExternInput(\"{SyntheticVarsDeclar}\");\n    }\n    return synthesizedExternsInput;\n  }",
    "comment": "Lazily create a \"new\" externs input for undeclared variables. */",
    "is_bug": false,
    "failing_test_cases": 5,
    "buggy_methods": 2
  },
  {
    "name": "VarCheck.getSynthesizedExternsRoot",
    "class_name": "com.google.javascript.jscomp.VarCheck",
    "signature": "com.google.javascript.jscomp.VarCheck.getSynthesizedExternsRoot()",
    "snippet": "  private Node getSynthesizedExternsRoot() {\n    if (synthesizedExternsRoot == null) {\n      CompilerInput synthesizedExterns = getSynthesizedExternsInput();\n      synthesizedExternsRoot = synthesizedExterns.getAstRoot(compiler);\n    }\n    return synthesizedExternsRoot;\n  }",
    "comment": "Lazily create a \"new\" externs root for undeclared variables. */",
    "is_bug": false,
    "failing_test_cases": 5,
    "buggy_methods": 2
  },
  {
    "name": "VarCheck.process",
    "class_name": "com.google.javascript.jscomp.VarCheck",
    "signature": "com.google.javascript.jscomp.VarCheck.process(Node,Node)",
    "snippet": "  @Override\n  public void process(Node externs, Node root) {\n    // Don't run externs-checking in sanity check mode. Normalization will\n    // remove duplicate VAR declarations, which will make\n    // externs look like they have assigns.\n    if (!sanityCheck) {\n      NodeTraversal.traverse(compiler, externs, new NameRefInExternsCheck());\n    }\n\n    NodeTraversal.traverseRoots(\n        compiler, Lists.newArrayList(externs, root), this);\n    for (String varName : varsToDeclareInExterns) {\n      createSynthesizedExternVar(varName);\n    }\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 5,
    "buggy_methods": 2
  },
  {
    "name": "VarCheck.visit",
    "class_name": "com.google.javascript.jscomp.VarCheck",
    "signature": "com.google.javascript.jscomp.VarCheck.visit(NodeTraversal,Node,Node)",
    "snippet": "  @Override\n  public void visit(NodeTraversal t, Node n, Node parent) {\n    if (n.getType() != Token.NAME) {\n      return;\n    }\n\n    String varName = n.getString();\n\n    // Only a function can have an empty name.\n    if (varName.isEmpty()) {\n      Preconditions.checkState(NodeUtil.isFunction(parent));\n\n      // A function declaration with an empty name passes Rhino,\n      // but is supposed to be a syntax error according to the spec.\n      if (!NodeUtil.isFunctionExpression(parent)) {\n        t.report(n, INVALID_FUNCTION_DECL);\n      }\n      return;\n    }\n\n    // Check if this is a declaration for a var that has been declared\n    // elsewhere. If so, mark it as a duplicate.\n    if ((parent.getType() == Token.VAR ||\n         NodeUtil.isFunctionDeclaration(parent)) &&\n        varsToDeclareInExterns.contains(varName)) {\n      createSynthesizedExternVar(varName);\n\n      n.addSuppression(\"duplicate\");\n    }\n\n    // Check that the var has been declared.\n    Scope scope = t.getScope();\n    Scope.Var var = scope.getVar(varName);\n    if (var == null) {\n      if (NodeUtil.isFunctionExpression(parent)) {\n        // e.g. [ function foo() {} ], it's okay if \"foo\" isn't defined in the\n        // current scope.\n      } else {\n        // The extern checks are stricter, don't report a second error.\n        if (!strictExternCheck || !t.getInput().isExtern()) {\n          t.report(n, UNDEFINED_VAR_ERROR, varName);\n        }\n\n        if (sanityCheck) {\n          throw new IllegalStateException(\"Unexpected variable \" + varName);\n        } else {\n          createSynthesizedExternVar(varName);\n          scope.getGlobalScope().declare(varName, n,\n              null, getSynthesizedExternsInput());\n        }\n      }\n      return;\n    }\n\n    CompilerInput currInput = t.getInput();\n    CompilerInput varInput = var.input;\n    if (currInput == varInput || currInput == null || varInput == null) {\n      // The variable was defined in the same file. This is fine.\n      return;\n    }\n\n    // Check module dependencies.\n    JSModule currModule = currInput.getModule();\n    JSModule varModule = varInput.getModule();\n    JSModuleGraph moduleGraph = compiler.getModuleGraph();\n    if (varModule != currModule && varModule != null && currModule != null) {\n      if (moduleGraph.dependsOn(currModule, varModule)) {\n        // The module dependency was properly declared.\n      } else {\n        if (!sanityCheck && scope.isGlobal()) {\n          if (moduleGraph.dependsOn(varModule, currModule)) {\n            // The variable reference violates a declared module dependency.\n            t.report(n, VIOLATED_MODULE_DEP_ERROR,\n                     currModule.getName(), varModule.getName(), varName);\n          } else {\n            // The variable reference is between two modules that have no\n            // dependency relationship. This should probably be considered an\n            // error, but just issue a warning for now.\n            t.report(n, MISSING_MODULE_DEP_ERROR,\n                     currModule.getName(), varModule.getName(), varName);\n          }\n        } else {\n          t.report(n, STRICT_MODULE_DEP_ERROR,\n                   currModule.getName(), varModule.getName(), varName);\n        }\n      }\n    }\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 5,
    "buggy_methods": 2
  },
  {
    "name": "NameRefInExternsCheck.visit",
    "class_name": "com.google.javascript.jscomp.VarCheck$NameRefInExternsCheck",
    "signature": "com.google.javascript.jscomp.VarCheck$NameRefInExternsCheck.visit(NodeTraversal,Node,Node)",
    "snippet": "    public void visit(NodeTraversal t, Node n, Node parent) {\n      if (n.getType() == Token.NAME) {\n        switch (parent.getType()) {\n          case Token.VAR:\n          case Token.FUNCTION:\n          case Token.LP:\n            // These are okay.\n            break;\n          case Token.GETPROP:\n            if (n == parent.getFirstChild()) {\n              Scope scope = t.getScope();\n              Scope.Var var = scope.getVar(n.getString());\n              if (var == null) {\n                t.report(n, UNDEFINED_EXTERN_VAR_ERROR, n.getString());\n                varsToDeclareInExterns.add(n.getString());\n              }\n            }\n            break;\n          default:\n            t.report(n, NAME_REFERENCE_IN_EXTERNS_ERROR, n.getString());\n\n            Scope scope = t.getScope();\n            Scope.Var var = scope.getVar(n.getString());\n            if (var == null) {\n              varsToDeclareInExterns.add(n.getString());\n            }\n            break;\n        }\n      }\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 5,
    "buggy_methods": 2
  },
  {
    "name": "WarningsGuard.getPriority",
    "class_name": "com.google.javascript.jscomp.WarningsGuard",
    "signature": "com.google.javascript.jscomp.WarningsGuard.getPriority()",
    "snippet": "  protected int getPriority() {\n    return Priority.DEFAULT.value;\n  }",
    "comment": " The priority in which warnings guards are applied. Lower means the guard will be applied sooner. Expressed on a scale of 1 to 100. ",
    "is_bug": false,
    "failing_test_cases": 5,
    "buggy_methods": 2
  },
  {
    "name": "Config.Config",
    "class_name": "com.google.javascript.jscomp.parsing.Config",
    "signature": "com.google.javascript.jscomp.parsing.Config.Config(Set,Set,boolean,boolean,boolean)",
    "snippet": "  Config(Set<String> annotationWhitelist, Set<String> suppressionNames,\n      boolean isIdeMode, boolean acceptES5, boolean acceptConstKeyword) {\n    this.annotationNames = buildAnnotationNames(annotationWhitelist);\n    this.parseJsDocDocumentation = isIdeMode;\n    this.suppressionNames = suppressionNames;\n    this.isIdeMode = isIdeMode;\n    this.acceptES5 = acceptES5;\n    this.acceptConstKeyword = acceptConstKeyword;\n  }",
    "comment": " Annotation names. ",
    "is_bug": false,
    "failing_test_cases": 5,
    "buggy_methods": 2
  },
  {
    "name": "Config.buildAnnotationNames",
    "class_name": "com.google.javascript.jscomp.parsing.Config",
    "signature": "com.google.javascript.jscomp.parsing.Config.buildAnnotationNames(Set)",
    "snippet": "  private static Map<String, Annotation> buildAnnotationNames(\n      Set<String> annotationWhitelist) {\n    ImmutableMap.Builder<String, Annotation> annotationBuilder =\n        ImmutableMap.builder();\n    annotationBuilder.putAll(Annotation.recognizedAnnotations);\n    for (String unrecognizedAnnotation : annotationWhitelist) {\n      if (!Annotation.recognizedAnnotations.containsKey(\n              unrecognizedAnnotation)) {\n        annotationBuilder.put(\n            unrecognizedAnnotation, Annotation.NOT_IMPLEMENTED);\n      }\n    }\n    return annotationBuilder.build();\n  }",
    "comment": " Create the annotation names from the user-specified annotation whitelist. ",
    "is_bug": false,
    "failing_test_cases": 5,
    "buggy_methods": 2
  },
  {
    "name": "IRFactory.createTemplateNode",
    "class_name": "com.google.javascript.jscomp.parsing.IRFactory",
    "signature": "com.google.javascript.jscomp.parsing.IRFactory.createTemplateNode()",
    "snippet": "  private Node createTemplateNode() {\n    // The Node type choice is arbitrary.\n    Node templateNode = new Node(Token.SCRIPT);\n    templateNode.putProp(Node.SOURCENAME_PROP, sourceName);\n    return templateNode;\n  }",
    "comment": "This reduces the cost of these properties to O(nodes) to O(files).",
    "is_bug": false,
    "failing_test_cases": 5,
    "buggy_methods": 2
  },
  {
    "name": "IRFactory.handleJsDoc",
    "class_name": "com.google.javascript.jscomp.parsing.IRFactory",
    "signature": "com.google.javascript.jscomp.parsing.IRFactory.handleJsDoc(AstNode)",
    "snippet": "  private JSDocInfo handleJsDoc(AstNode node) {\n    Comment comment = node.getJsDocNode();\n    if (comment != null) {\n      JsDocInfoParser jsDocParser = createJsDocInfoParser(comment);\n      comment.setParsed(true);\n      if (!handlePossibleFileOverviewJsDoc(jsDocParser)) {\n        return jsDocParser.retrieveAndResetParsedJSDocInfo();\n      }\n    }\n    return null;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 5,
    "buggy_methods": 2
  },
  {
    "name": "IRFactory.justTransform",
    "class_name": "com.google.javascript.jscomp.parsing.IRFactory",
    "signature": "com.google.javascript.jscomp.parsing.IRFactory.justTransform(AstNode)",
    "snippet": "  private Node justTransform(AstNode node) {\n    return transformDispatcher.process(node);\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 5,
    "buggy_methods": 2
  },
  {
    "name": "IRFactory.newNode",
    "class_name": "com.google.javascript.jscomp.parsing.IRFactory",
    "signature": "com.google.javascript.jscomp.parsing.IRFactory.newNode(int)",
    "snippet": "  private Node newNode(int type) {\n    return new Node(type).clonePropsFrom(templateNode);\n  }",
    "comment": "Simple helper to create nodes and set the initial node properties.",
    "is_bug": false,
    "failing_test_cases": 5,
    "buggy_methods": 2
  },
  {
    "name": "IRFactory.newNode",
    "class_name": "com.google.javascript.jscomp.parsing.IRFactory",
    "signature": "com.google.javascript.jscomp.parsing.IRFactory.newNode(int,Node)",
    "snippet": "  private Node newNode(int type, Node child1) {\n    return new Node(type, child1).clonePropsFrom(templateNode);\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 5,
    "buggy_methods": 2
  },
  {
    "name": "IRFactory.newNode",
    "class_name": "com.google.javascript.jscomp.parsing.IRFactory",
    "signature": "com.google.javascript.jscomp.parsing.IRFactory.newNode(int,Node,Node)",
    "snippet": "  private Node newNode(int type, Node child1, Node child2) {\n    return new Node(type, child1, child2).clonePropsFrom(templateNode);\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 5,
    "buggy_methods": 2
  },
  {
    "name": "IRFactory.newStringNode",
    "class_name": "com.google.javascript.jscomp.parsing.IRFactory",
    "signature": "com.google.javascript.jscomp.parsing.IRFactory.newStringNode(int,String)",
    "snippet": "  private Node newStringNode(int type, String value) {\n    return Node.newString(type, value).clonePropsFrom(templateNode);\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 5,
    "buggy_methods": 2
  },
  {
    "name": "IRFactory.position2charno",
    "class_name": "com.google.javascript.jscomp.parsing.IRFactory",
    "signature": "com.google.javascript.jscomp.parsing.IRFactory.position2charno(int)",
    "snippet": "  private int position2charno(int position) {\n    int lineIndex = sourceString.lastIndexOf('\\n', position);\n    if (lineIndex == -1) {\n      return position;\n    } else {\n      // Subtract one for initial position being 0.\n      return position - lineIndex - 1;\n    }\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 5,
    "buggy_methods": 2
  },
  {
    "name": "IRFactory.setFileOverviewJsDoc",
    "class_name": "com.google.javascript.jscomp.parsing.IRFactory",
    "signature": "com.google.javascript.jscomp.parsing.IRFactory.setFileOverviewJsDoc(Node)",
    "snippet": "  private void setFileOverviewJsDoc(Node irNode) {\n    // Only after we've seen all @fileoverview entries, attach the\n    // last one to the root node, and copy the found license strings\n    // to that node.\n    irNode.setJSDocInfo(rootNodeJsDocHolder.getJSDocInfo());\n    if (fileOverviewInfo != null) {\n      if ((irNode.getJSDocInfo() != null) &&\n          (irNode.getJSDocInfo().getLicense() != null)) {\n        fileOverviewInfo.setLicense(irNode.getJSDocInfo().getLicense());\n      }\n      irNode.setJSDocInfo(fileOverviewInfo);\n    }\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 5,
    "buggy_methods": 2
  },
  {
    "name": "IRFactory.transform",
    "class_name": "com.google.javascript.jscomp.parsing.IRFactory",
    "signature": "com.google.javascript.jscomp.parsing.IRFactory.transform(AstNode)",
    "snippet": "  private Node transform(AstNode node) {\n    JSDocInfo jsDocInfo = handleJsDoc(node);\n    Node irNode = justTransform(node);\n    if (jsDocInfo != null) {\n      irNode.setJSDocInfo(jsDocInfo);\n    }\n\n    // If we have a named function, set the position to that of the name.\n    if (irNode.getType() == Token.FUNCTION &&\n        irNode.getFirstChild().getLineno() != -1) {\n      irNode.setLineno(irNode.getFirstChild().getLineno());\n      irNode.setCharno(irNode.getFirstChild().getCharno());\n    } else {\n      if (irNode.getLineno() == -1) {\n        // If we didn't already set the line, then set it now.  This avoids\n        // cases like ParenthesizedExpression where we just return a previous\n        // node, but don't want the new node to get its parent's line number.\n        int lineno = node.getLineno();\n        irNode.setLineno(lineno);\n        int charno = position2charno(node.getAbsolutePosition());\n        irNode.setCharno(charno);\n      }\n    }\n    return irNode;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 5,
    "buggy_methods": 2
  },
  {
    "name": "IRFactory.transformTokenType",
    "class_name": "com.google.javascript.jscomp.parsing.IRFactory",
    "signature": "com.google.javascript.jscomp.parsing.IRFactory.transformTokenType(int)",
    "snippet": "  private static int transformTokenType(int token) {\n    switch (token) {\n      case com.google.javascript.jscomp.mozilla.rhino.Token.ERROR:\n        return Token.ERROR;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.EOF:\n        return Token.EOF;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.EOL:\n        return Token.EOL;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.ENTERWITH:\n        return Token.ENTERWITH;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.LEAVEWITH:\n        return Token.LEAVEWITH;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.RETURN:\n        return Token.RETURN;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.GOTO:\n        return Token.GOTO;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.IFEQ:\n        return Token.IFEQ;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.IFNE:\n        return Token.IFNE;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.SETNAME:\n        return Token.SETNAME;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.BITOR:\n        return Token.BITOR;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.BITXOR:\n        return Token.BITXOR;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.BITAND:\n        return Token.BITAND;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.EQ:\n        return Token.EQ;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.NE:\n        return Token.NE;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.LT:\n        return Token.LT;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.LE:\n        return Token.LE;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.GT:\n        return Token.GT;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.GE:\n        return Token.GE;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.LSH:\n        return Token.LSH;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.RSH:\n        return Token.RSH;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.URSH:\n        return Token.URSH;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.ADD:\n        return Token.ADD;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.SUB:\n        return Token.SUB;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.MUL:\n        return Token.MUL;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.DIV:\n        return Token.DIV;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.MOD:\n        return Token.MOD;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.NOT:\n        return Token.NOT;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.BITNOT:\n        return Token.BITNOT;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.POS:\n        return Token.POS;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.NEG:\n        return Token.NEG;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.NEW:\n        return Token.NEW;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.DELPROP:\n        return Token.DELPROP;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.TYPEOF:\n        return Token.TYPEOF;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.GETPROP:\n        return Token.GETPROP;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.SETPROP:\n        return Token.SETPROP;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.GETELEM:\n        return Token.GETELEM;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.SETELEM:\n        return Token.SETELEM;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.CALL:\n        return Token.CALL;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.NAME:\n        return Token.NAME;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.NUMBER:\n        return Token.NUMBER;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.STRING:\n        return Token.STRING;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.NULL:\n        return Token.NULL;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.THIS:\n        return Token.THIS;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.FALSE:\n        return Token.FALSE;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.TRUE:\n        return Token.TRUE;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.SHEQ:\n        return Token.SHEQ;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.SHNE:\n        return Token.SHNE;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.REGEXP:\n        return Token.REGEXP;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.BINDNAME:\n        return Token.BINDNAME;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.THROW:\n        return Token.THROW;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.RETHROW:\n        return Token.RETHROW;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.IN:\n        return Token.IN;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.INSTANCEOF:\n        return Token.INSTANCEOF;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.LOCAL_LOAD:\n        return Token.LOCAL_LOAD;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.GETVAR:\n        return Token.GETVAR;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.SETVAR:\n        return Token.SETVAR;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.CATCH_SCOPE:\n        return Token.CATCH_SCOPE;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.ENUM_INIT_KEYS:\n        return Token.ENUM_INIT_KEYS;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.ENUM_INIT_VALUES:\n        return Token.ENUM_INIT_VALUES;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.ENUM_NEXT:\n        return Token.ENUM_NEXT;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.ENUM_ID:\n        return Token.ENUM_ID;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.THISFN:\n        return Token.THISFN;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.RETURN_RESULT:\n        return Token.RETURN_RESULT;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.ARRAYLIT:\n        return Token.ARRAYLIT;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.OBJECTLIT:\n        return Token.OBJECTLIT;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.GET_REF:\n        return Token.GET_REF;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.SET_REF:\n        return Token.SET_REF;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.DEL_REF:\n        return Token.DEL_REF;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.REF_CALL:\n        return Token.REF_CALL;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.REF_SPECIAL:\n        return Token.REF_SPECIAL;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.DEFAULTNAMESPACE:\n        return Token.DEFAULTNAMESPACE;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.ESCXMLTEXT:\n        return Token.ESCXMLTEXT;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.ESCXMLATTR:\n        return Token.ESCXMLATTR;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.REF_MEMBER:\n        return Token.REF_MEMBER;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.REF_NS_MEMBER:\n        return Token.REF_NS_MEMBER;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.REF_NAME:\n        return Token.REF_NAME;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.REF_NS_NAME:\n        return Token.REF_NS_NAME;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.TRY:\n        return Token.TRY;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.SEMI:\n        return Token.SEMI;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.LB:\n        return Token.LB;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.RB:\n        return Token.RB;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.LC:\n        return Token.LC;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.RC:\n        return Token.RC;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.LP:\n        return Token.LP;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.RP:\n        return Token.RP;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.COMMA:\n        return Token.COMMA;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.ASSIGN:\n        return Token.ASSIGN;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.ASSIGN_BITOR:\n        return Token.ASSIGN_BITOR;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.ASSIGN_BITXOR:\n        return Token.ASSIGN_BITXOR;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.ASSIGN_BITAND:\n        return Token.ASSIGN_BITAND;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.ASSIGN_LSH:\n        return Token.ASSIGN_LSH;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.ASSIGN_RSH:\n        return Token.ASSIGN_RSH;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.ASSIGN_URSH:\n        return Token.ASSIGN_URSH;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.ASSIGN_ADD:\n        return Token.ASSIGN_ADD;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.ASSIGN_SUB:\n        return Token.ASSIGN_SUB;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.ASSIGN_MUL:\n        return Token.ASSIGN_MUL;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.ASSIGN_DIV:\n        return Token.ASSIGN_DIV;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.ASSIGN_MOD:\n        return Token.ASSIGN_MOD;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.HOOK:\n        return Token.HOOK;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.COLON:\n        return Token.COLON;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.OR:\n        return Token.OR;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.AND:\n        return Token.AND;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.INC:\n        return Token.INC;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.DEC:\n        return Token.DEC;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.DOT:\n        return Token.DOT;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.FUNCTION:\n        return Token.FUNCTION;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.EXPORT:\n        return Token.EXPORT;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.IMPORT:\n        return Token.IMPORT;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.IF:\n        return Token.IF;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.ELSE:\n        return Token.ELSE;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.SWITCH:\n        return Token.SWITCH;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.CASE:\n        return Token.CASE;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.DEFAULT:\n        return Token.DEFAULT;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.WHILE:\n        return Token.WHILE;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.DO:\n        return Token.DO;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.FOR:\n        return Token.FOR;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.BREAK:\n        return Token.BREAK;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.CONTINUE:\n        return Token.CONTINUE;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.VAR:\n        return Token.VAR;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.WITH:\n        return Token.WITH;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.CATCH:\n        return Token.CATCH;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.FINALLY:\n        return Token.FINALLY;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.VOID:\n        return Token.VOID;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.RESERVED:\n        return Token.RESERVED;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.EMPTY:\n        return Token.EMPTY;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.BLOCK:\n        return Token.BLOCK;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.LABEL:\n        return Token.LABEL;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.TARGET:\n        return Token.TARGET;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.LOOP:\n        return Token.LOOP;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.EXPR_VOID:\n      case com.google.javascript.jscomp.mozilla.rhino.Token.EXPR_RESULT:\n        return Token.EXPR_RESULT;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.JSR:\n        return Token.JSR;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.SCRIPT:\n        return Token.SCRIPT;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.TYPEOFNAME:\n        return Token.TYPEOFNAME;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.USE_STACK:\n        return Token.USE_STACK;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.SETPROP_OP:\n        return Token.SETPROP_OP;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.SETELEM_OP:\n        return Token.SETELEM_OP;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.LOCAL_BLOCK:\n        return Token.LOCAL_BLOCK;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.SET_REF_OP:\n        return Token.SET_REF_OP;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.DOTDOT:\n        return Token.DOTDOT;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.COLONCOLON:\n        return Token.COLONCOLON;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.XML:\n        return Token.XML;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.DOTQUERY:\n        return Token.DOTQUERY;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.XMLATTR:\n        return Token.XMLATTR;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.XMLEND:\n        return Token.XMLEND;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.TO_OBJECT:\n        return Token.TO_OBJECT;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.TO_DOUBLE:\n        return Token.TO_DOUBLE;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.GET:\n        return Token.GET;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.SET:\n        return Token.SET;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.CONST:\n        return Token.CONST;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.SETCONST:\n        return Token.SETCONST;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.DEBUGGER:\n        return Token.DEBUGGER;\n    }\n\n    // Token without name\n    throw new IllegalStateException(String.valueOf(token));\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 5,
    "buggy_methods": 2
  },
  {
    "name": "IRFactory.transformTree",
    "class_name": "com.google.javascript.jscomp.parsing.IRFactory",
    "signature": "com.google.javascript.jscomp.parsing.IRFactory.transformTree(AstRoot,String,Config,ErrorReporter)",
    "snippet": "  public static Node transformTree(AstRoot node,\n                                   String sourceString,\n                                   Config config,\n                                   ErrorReporter errorReporter) {\n    IRFactory irFactory = new IRFactory(sourceString, node.getSourceName(),\n        config, errorReporter);\n    Node irNode = irFactory.transform(node);\n\n    if (node.getComments() != null) {\n      for (Comment comment : node.getComments()) {\n        if (comment.getCommentType() == JSDOC && !comment.isParsed()) {\n          irFactory.handlePossibleFileOverviewJsDoc(comment);\n        }\n      }\n    }\n\n    irFactory.setFileOverviewJsDoc(irNode);\n\n    return irNode;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 5,
    "buggy_methods": 2
  },
  {
    "name": "TransformDispatcher.isDirective",
    "class_name": "com.google.javascript.jscomp.parsing.IRFactory$TransformDispatcher",
    "signature": "com.google.javascript.jscomp.parsing.IRFactory$TransformDispatcher.isDirective(Node)",
    "snippet": "    private boolean isDirective(Node n) {\n      if (n == null) return false;\n\n      int nType = n.getType();\n      return (nType == Token.EXPR_RESULT || nType == Token.EXPR_VOID) &&\n          n.getFirstChild().getType() == Token.STRING &&\n          ALLOWED_DIRECTIVES.contains(n.getFirstChild().getString());\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 5,
    "buggy_methods": 2
  },
  {
    "name": "TransformDispatcher.parseDirectives",
    "class_name": "com.google.javascript.jscomp.parsing.IRFactory$TransformDispatcher",
    "signature": "com.google.javascript.jscomp.parsing.IRFactory$TransformDispatcher.parseDirectives(Node)",
    "snippet": "    private void parseDirectives(Node node) {\n      // Remove all the directives, and encode them in the AST.\n      Set<String> directives = null;\n      while (isDirective(node.getFirstChild())) {\n        String directive = node.removeFirstChild().getFirstChild().getString();\n        if (directives == null) {\n          directives = Sets.newHashSet(directive);\n        } else {\n          directives.add(directive);\n        }\n      }\n\n      if (directives != null) {\n        node.setDirectives(directives);\n      }\n    }",
    "comment": " Parse the directives, encode them in the AST, and remove their nodes.  For information on ES5 directives, see section 14.1 of Ecma-262, Edition 5.  It would be nice if Rhino would eventually take care of this for us, but right now their directive-processing is a one-off. ",
    "is_bug": false,
    "failing_test_cases": 5,
    "buggy_methods": 2
  },
  {
    "name": "TransformDispatcher.processAstRoot",
    "class_name": "com.google.javascript.jscomp.parsing.IRFactory$TransformDispatcher",
    "signature": "com.google.javascript.jscomp.parsing.IRFactory$TransformDispatcher.processAstRoot(AstRoot)",
    "snippet": "    @Override\n    Node processAstRoot(AstRoot rootNode) {\n      Node node = newNode(Token.SCRIPT);\n      for (com.google.javascript.jscomp.mozilla.rhino.Node child : rootNode) {\n        node.addChildToBack(transform((AstNode)child));\n      }\n      parseDirectives(node);\n      return node;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 5,
    "buggy_methods": 2
  },
  {
    "name": "TransformDispatcher.processExpressionStatement",
    "class_name": "com.google.javascript.jscomp.parsing.IRFactory$TransformDispatcher",
    "signature": "com.google.javascript.jscomp.parsing.IRFactory$TransformDispatcher.processExpressionStatement(ExpressionStatement)",
    "snippet": "    @Override\n    Node processExpressionStatement(ExpressionStatement statementNode) {\n      Node node = newNode(transformTokenType(statementNode.getType()));\n      node.addChildToBack(transform(statementNode.getExpression()));\n      return node;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 5,
    "buggy_methods": 2
  },
  {
    "name": "TransformDispatcher.processFunctionCall",
    "class_name": "com.google.javascript.jscomp.parsing.IRFactory$TransformDispatcher",
    "signature": "com.google.javascript.jscomp.parsing.IRFactory$TransformDispatcher.processFunctionCall(FunctionCall)",
    "snippet": "    @Override\n    Node processFunctionCall(FunctionCall callNode) {\n      Node node = newNode(transformTokenType(callNode.getType()),\n                           transform(callNode.getTarget()));\n      for (AstNode child : callNode.getArguments()) {\n        node.addChildToBack(transform(child));\n      }\n\n      int leftParamPos = callNode.getAbsolutePosition() + callNode.getLp();\n      node.setLineno(callNode.getLineno());\n      node.setCharno(position2charno(leftParamPos));\n      return node;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 5,
    "buggy_methods": 2
  },
  {
    "name": "TransformDispatcher.processInfixExpression",
    "class_name": "com.google.javascript.jscomp.parsing.IRFactory$TransformDispatcher",
    "signature": "com.google.javascript.jscomp.parsing.IRFactory$TransformDispatcher.processInfixExpression(InfixExpression)",
    "snippet": "    @Override\n    Node processInfixExpression(InfixExpression exprNode) {\n      Node n =  newNode(\n          transformTokenType(exprNode.getType()),\n          transform(exprNode.getLeft()),\n          transform(exprNode.getRight()));\n      // Set the line number here so we can fine-tune it in ways transform\n      // doesn't do.\n      n.setLineno(exprNode.getLineno());\n      // Position in new ASTNode is to start of expression, but old-fashioned\n      // line numbers from Node reference the operator token.  Add the offset\n      // to the operator to get the correct character number.\n      n.setCharno(position2charno(exprNode.getAbsolutePosition() +\n          exprNode.getOperatorPosition()));\n      return n;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 5,
    "buggy_methods": 2
  },
  {
    "name": "TransformDispatcher.processName",
    "class_name": "com.google.javascript.jscomp.parsing.IRFactory$TransformDispatcher",
    "signature": "com.google.javascript.jscomp.parsing.IRFactory$TransformDispatcher.processName(Name)",
    "snippet": "    @Override\n    Node processName(Name nameNode) {\n      return newStringNode(Token.NAME, nameNode.getIdentifier());\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 5,
    "buggy_methods": 2
  },
  {
    "name": "TransformDispatcher.processVariableDeclaration",
    "class_name": "com.google.javascript.jscomp.parsing.IRFactory$TransformDispatcher",
    "signature": "com.google.javascript.jscomp.parsing.IRFactory$TransformDispatcher.processVariableDeclaration(VariableDeclaration)",
    "snippet": "    @Override\n    Node processVariableDeclaration(VariableDeclaration declarationNode) {\n      if (!config.acceptConstKeyword && declarationNode.getType() ==\n          com.google.javascript.jscomp.mozilla.rhino.Token.CONST) {\n        processIllegalToken(declarationNode);\n      }\n\n      Node node = newNode(Token.VAR);\n      for (VariableInitializer child : declarationNode.getVariables()) {\n        node.addChildToBack(transform(child));\n      }\n      return node;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 5,
    "buggy_methods": 2
  },
  {
    "name": "TransformDispatcher.processVariableInitializer",
    "class_name": "com.google.javascript.jscomp.parsing.IRFactory$TransformDispatcher",
    "signature": "com.google.javascript.jscomp.parsing.IRFactory$TransformDispatcher.processVariableInitializer(VariableInitializer)",
    "snippet": "    @Override\n    Node processVariableInitializer(VariableInitializer initializerNode) {\n      Node node = transform(initializerNode.getTarget());\n      if (initializerNode.getInitializer() != null) {\n        node.addChildToBack(transform(initializerNode.getInitializer()));\n        node.setLineno(node.getLineno());\n      }\n      return node;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 5,
    "buggy_methods": 2
  },
  {
    "name": "ParserRunner.createConfig",
    "class_name": "com.google.javascript.jscomp.parsing.ParserRunner",
    "signature": "com.google.javascript.jscomp.parsing.ParserRunner.createConfig(boolean,boolean,boolean)",
    "snippet": "  public static Config createConfig(boolean isIdeMode,\n                                    boolean isES5Mode,\n                                    boolean acceptConstKeyword) {\n    initResourceConfig();\n    return new Config(annotationNames, suppressionNames, isIdeMode, isES5Mode,\n                      acceptConstKeyword);\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 5,
    "buggy_methods": 2
  },
  {
    "name": "ParserRunner.extractList",
    "class_name": "com.google.javascript.jscomp.parsing.ParserRunner",
    "signature": "com.google.javascript.jscomp.parsing.ParserRunner.extractList(String)",
    "snippet": "  private static Set<String> extractList(String configProp) {\n    String[] names = configProp.split(\",\");\n    Set<String> trimmedNames = Sets.newHashSet();\n    for (String name : names) {\n      trimmedNames.add(name.trim());\n    }\n    return ImmutableSet.copyOf(trimmedNames);\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 5,
    "buggy_methods": 2
  },
  {
    "name": "ParserRunner.initResourceConfig",
    "class_name": "com.google.javascript.jscomp.parsing.ParserRunner",
    "signature": "com.google.javascript.jscomp.parsing.ParserRunner.initResourceConfig()",
    "snippet": "  private static synchronized void initResourceConfig() {\n    if (annotationNames != null) {\n      return;\n    }\n\n    ResourceBundle config = ResourceBundle.getBundle(configResource);\n    annotationNames = extractList(config.getString(\"jsdoc.annotations\"));\n    suppressionNames = extractList(config.getString(\"jsdoc.suppressions\"));\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 5,
    "buggy_methods": 2
  },
  {
    "name": "ParserRunner.parse",
    "class_name": "com.google.javascript.jscomp.parsing.ParserRunner",
    "signature": "com.google.javascript.jscomp.parsing.ParserRunner.parse(String,String,Config,ErrorReporter,Logger)",
    "snippet": "  public static Node parse(String sourceName,\n                           String sourceString,\n                           Config config,\n                           ErrorReporter errorReporter,\n                           Logger logger) throws IOException {\n    Context cx = Context.enter();\n    cx.setErrorReporter(errorReporter);\n    cx.setLanguageVersion(Context.VERSION_1_5);\n    CompilerEnvirons compilerEnv = new CompilerEnvirons();\n    compilerEnv.initFromContext(cx);\n    compilerEnv.setRecordingComments(true);\n    compilerEnv.setRecordingLocalJsDocComments(true);\n    compilerEnv.setWarnTrailingComma(true);\n    if (config.isIdeMode) {\n      compilerEnv.setReservedKeywordAsIdentifier(true);\n      compilerEnv.setAllowMemberExprAsFunctionName(true);\n    }\n\n    Parser p = new Parser(compilerEnv, errorReporter);\n    AstRoot astRoot = null;\n    try {\n      astRoot = p.parse(sourceString, sourceName, 1);\n    } catch (EvaluatorException e) {\n      logger.info(\"Error parsing \" + sourceName + \": \" + e.getMessage());\n    } finally {\n      Context.exit();\n    }\n    Node root = null;\n    if (astRoot != null) {\n      root = IRFactory.transformTree(\n          astRoot, sourceString, config, errorReporter);\n      root.setIsSyntheticBlock(true);\n    }\n    return root;\n  }",
    "comment": " Parses the JavaScript text given by a reader.  @param sourceName The filename. @param sourceString Source code from the file. @param errorReporter An error. @param logger A logger. @return The AST of the given text. @throws IOException ",
    "is_bug": false,
    "failing_test_cases": 5,
    "buggy_methods": 2
  },
  {
    "name": "TypeSafeDispatcher.process",
    "class_name": "com.google.javascript.jscomp.parsing.TypeSafeDispatcher",
    "signature": "com.google.javascript.jscomp.parsing.TypeSafeDispatcher.process(AstNode)",
    "snippet": "  public T process(AstNode node) {\n    switch (node.getType()) {\n      case Token.ADD:\n      case Token.AND:\n      case Token.BITAND:\n      case Token.BITOR:\n      case Token.BITXOR:\n      case Token.COMMA:\n      case Token.DIV:\n      case Token.EQ:\n      case Token.GE:\n      case Token.GT:\n      case Token.IN:\n      case Token.INSTANCEOF:\n      case Token.LE:\n      case Token.LSH:\n      case Token.LT:\n      case Token.MOD:\n      case Token.MUL:\n      case Token.NE:\n      case Token.OR:\n      case Token.RSH:\n      case Token.SHEQ:\n      case Token.SHNE:\n      case Token.SUB:\n      case Token.URSH:\n        return processInfixExpression((InfixExpression) node);\n      case Token.ARRAYLIT:\n        return processArrayLiteral((ArrayLiteral) node);\n      case Token.ASSIGN:\n      case Token.ASSIGN_ADD:\n      case Token.ASSIGN_BITAND:\n      case Token.ASSIGN_BITOR:\n      case Token.ASSIGN_BITXOR:\n      case Token.ASSIGN_DIV:\n      case Token.ASSIGN_LSH:\n      case Token.ASSIGN_MOD:\n      case Token.ASSIGN_MUL:\n      case Token.ASSIGN_RSH:\n      case Token.ASSIGN_SUB:\n      case Token.ASSIGN_URSH:\n        return processAssignment((Assignment) node);\n      case Token.BITNOT:\n      case Token.DEC:\n      case Token.DELPROP:\n      case Token.INC:\n      case Token.NEG:\n      case Token.NOT:\n      case Token.POS:\n      case Token.TYPEOF:\n      case Token.VOID:\n        return processUnaryExpression((UnaryExpression) node);\n      case Token.BLOCK:\n        if (node instanceof Block) {\n          return processBlock((Block) node);\n        } else  if (node instanceof Scope) {\n          return processScope((Scope) node);\n        } else {\n          throw new IllegalStateException(\"Unexpected node type.  class: \" +\n                                          node.getClass() +\n                                          \" type: \" +\n                                          Token.typeToName(node.getType()));\n        }\n      case Token.BREAK:\n        return processBreakStatement((BreakStatement) node);\n      case Token.CALL:\n        return processFunctionCall((FunctionCall) node);\n      case Token.CASE:\n      case Token.DEFAULT:\n        return processSwitchCase((SwitchCase) node);\n      case Token.CATCH:\n      case Token.FINALLY:\n        return processCatchClause((CatchClause) node);\n      case Token.COLON:\n        return processObjectProperty((ObjectProperty) node);\n      case Token.CONTINUE:\n        return processContinueStatement((ContinueStatement) node);\n      case Token.DO:\n        return processDoLoop((DoLoop) node);\n      case Token.EMPTY:\n        return processEmptyExpression((EmptyExpression) node);\n      case Token.EXPR_RESULT:\n      case Token.EXPR_VOID:\n        if (node instanceof ExpressionStatement) {\n          return processExpressionStatement((ExpressionStatement) node);\n        } else  if (node instanceof LabeledStatement) {\n          return processLabeledStatement((LabeledStatement) node);\n        } else {\n          throw new IllegalStateException(\"Unexpected node type.  class: \" +\n                                          node.getClass() +\n                                          \" type: \" +\n                                          Token.typeToName(node.getType()));\n        }\n      case Token.DEBUGGER:\n      case Token.FALSE:\n      case Token.NULL:\n      case Token.THIS:\n      case Token.TRUE:\n        return processKeywordLiteral((KeywordLiteral) node);\n      case Token.FOR:\n        if (node instanceof ForInLoop) {\n          return processForInLoop((ForInLoop) node);\n        } else  if (node instanceof ForLoop) {\n          return processForLoop((ForLoop) node);\n        } else {\n          throw new IllegalStateException(\"Unexpected node type.  class: \" +\n                                          node.getClass() +\n                                          \" type: \" +\n                                          Token.typeToName(node.getType()));\n        }\n      case Token.FUNCTION:\n        return processFunctionNode((FunctionNode) node);\n      case Token.GETELEM:\n        return processElementGet((ElementGet) node);\n      case Token.GETPROP:\n        return processPropertyGet((PropertyGet) node);\n      case Token.HOOK:\n        return processConditionalExpression((ConditionalExpression) node);\n      case Token.IF:\n        return processIfStatement((IfStatement) node);\n      case Token.LABEL:\n        return processLabel((Label) node);\n      case Token.LP:\n        return processParenthesizedExpression((ParenthesizedExpression) node);\n      case Token.NAME:\n        return processName((Name) node);\n      case Token.NEW:\n        return processNewExpression((NewExpression) node);\n      case Token.NUMBER:\n        return processNumberLiteral((NumberLiteral) node);\n      case Token.OBJECTLIT:\n        return processObjectLiteral((ObjectLiteral) node);\n      case Token.REGEXP:\n        return processRegExpLiteral((RegExpLiteral) node);\n      case Token.RETURN:\n        return processReturnStatement((ReturnStatement) node);\n      case Token.SCRIPT:\n        return processAstRoot((AstRoot) node);\n      case Token.STRING:\n        return processStringLiteral((StringLiteral) node);\n      case Token.SWITCH:\n        return processSwitchStatement((SwitchStatement) node);\n      case Token.THROW:\n        return processThrowStatement((ThrowStatement) node);\n      case Token.TRY:\n        return processTryStatement((TryStatement) node);\n      case Token.CONST:\n      case Token.VAR:\n        if (node instanceof VariableDeclaration) {\n          return processVariableDeclaration((VariableDeclaration) node);\n        } else  if (node instanceof VariableInitializer) {\n          return processVariableInitializer((VariableInitializer) node);\n        } else {\n          throw new IllegalStateException(\"Unexpected node type.  class: \" +\n                                          node.getClass() +\n                                          \" type: \" +\n                                          Token.typeToName(node.getType()));\n        }\n      case Token.WHILE:\n        return processWhileLoop((WhileLoop) node);\n      case Token.WITH:\n        return processWithStatement((WithStatement) node);\n    }\n    return processIllegalToken(node);\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 5,
    "buggy_methods": 2
  },
  {
    "name": "Context.getCurrentContext",
    "class_name": "com.google.javascript.rhino.Context",
    "signature": "com.google.javascript.rhino.Context.getCurrentContext()",
    "snippet": "    public static Context getCurrentContext() {\n        return threadContexts.get();\n    }",
    "comment": " Get the current Context.  The current Context is per-thread; this method looks up the Context associated with the current thread. <p>  @return the Context associated with the current thread, or null if no context is associated with the current thread. ",
    "is_bug": false,
    "failing_test_cases": 5,
    "buggy_methods": 2
  },
  {
    "name": "JSDocInfo.JSDocInfo",
    "class_name": "com.google.javascript.rhino.JSDocInfo",
    "signature": "com.google.javascript.rhino.JSDocInfo.JSDocInfo(boolean)",
    "snippet": "  JSDocInfo(boolean includeDocumentation) {\n    this.includeDocumentation = includeDocumentation;\n  }",
    "comment": " Creates a {@link JSDocInfo} object. This object should be created using a {@link JSDocInfoBuilder}. ",
    "is_bug": false,
    "failing_test_cases": 5,
    "buggy_methods": 2
  },
  {
    "name": "JSDocInfo.addSuppression",
    "class_name": "com.google.javascript.rhino.JSDocInfo",
    "signature": "com.google.javascript.rhino.JSDocInfo.addSuppression(String)",
    "snippet": "  void addSuppression(String suppression) {\n    lazyInitInfo();\n\n    if (info.suppressions == null) {\n      info.suppressions = Sets.newHashSet();\n    }\n    info.suppressions.add(suppression);\n  }",
    "comment": " Add a suppressed warning. ",
    "is_bug": false,
    "failing_test_cases": 5,
    "buggy_methods": 2
  },
  {
    "name": "JSDocInfo.getSuppressions",
    "class_name": "com.google.javascript.rhino.JSDocInfo",
    "signature": "com.google.javascript.rhino.JSDocInfo.getSuppressions()",
    "snippet": "  public Set<String> getSuppressions() {\n    Set<String> suppressions = info == null ? null : info.suppressions;\n    return suppressions == null ? Collections.<String>emptySet() : suppressions;\n  }",
    "comment": " Returns the set of suppressed warnings. ",
    "is_bug": false,
    "failing_test_cases": 5,
    "buggy_methods": 2
  },
  {
    "name": "JSDocInfo.lazyInitInfo",
    "class_name": "com.google.javascript.rhino.JSDocInfo",
    "signature": "com.google.javascript.rhino.JSDocInfo.lazyInitInfo()",
    "snippet": "  private void lazyInitInfo() {\n    if (info == null) {\n      info = new LazilyInitializedInfo();\n    }\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 5,
    "buggy_methods": 2
  },
  {
    "name": "Node.Node",
    "class_name": "com.google.javascript.rhino.Node",
    "signature": "com.google.javascript.rhino.Node.Node(int)",
    "snippet": "  public Node(int nodeType) {\n    type = nodeType;\n    parent = null;\n    sourcePosition = -1;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 5,
    "buggy_methods": 2
  },
  {
    "name": "Node.Node",
    "class_name": "com.google.javascript.rhino.Node",
    "signature": "com.google.javascript.rhino.Node.Node(int,Node)",
    "snippet": "  public Node(int nodeType, Node child) {\n    Preconditions.checkArgument(child.parent == null,\n        \"new child has existing parent\");\n    Preconditions.checkArgument(child.next == null,\n        \"new child has existing sibling\");\n\n    type = nodeType;\n    parent = null;\n    first = last = child;\n    child.next = null;\n    child.parent = this;\n    sourcePosition = -1;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 5,
    "buggy_methods": 2
  },
  {
    "name": "Node.Node",
    "class_name": "com.google.javascript.rhino.Node",
    "signature": "com.google.javascript.rhino.Node.Node(int,Node,Node)",
    "snippet": "  public Node(int nodeType, Node left, Node right) {\n    Preconditions.checkArgument(left.parent == null,\n        \"first new child has existing parent\");\n    Preconditions.checkArgument(left.next == null,\n        \"first new child has existing sibling\");\n    Preconditions.checkArgument(right.parent == null,\n        \"second new child has existing parent\");\n    Preconditions.checkArgument(right.next == null,\n        \"second new child has existing sibling\");\n    type = nodeType;\n    parent = null;\n    first = left;\n    last = right;\n    left.next = right;\n    left.parent = this;\n    right.next = null;\n    right.parent = this;\n    sourcePosition = -1;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 5,
    "buggy_methods": 2
  },
  {
    "name": "Node.addChildToBack",
    "class_name": "com.google.javascript.rhino.Node",
    "signature": "com.google.javascript.rhino.Node.addChildToBack(Node)",
    "snippet": "  public void addChildToBack(Node child) {\n    Preconditions.checkArgument(child.parent == null);\n    Preconditions.checkArgument(child.next == null);\n    child.parent = this;\n    child.next = null;\n    if (last == null) {\n      first = last = child;\n      return;\n    }\n    last.next = child;\n    last = child;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 5,
    "buggy_methods": 2
  },
  {
    "name": "Node.cloneNode",
    "class_name": "com.google.javascript.rhino.Node",
    "signature": "com.google.javascript.rhino.Node.cloneNode()",
    "snippet": "  public Node cloneNode() {\n    Node result;\n    try {\n      result = (Node) super.clone();\n      // PropListItem lists are immutable and can be shared so there is no\n      // need to clone them here.\n      result.next = null;\n      result.first = null;\n      result.last = null;\n      result.parent = null;\n    } catch (CloneNotSupportedException e) {\n      throw new RuntimeException(e.getMessage());\n    }\n    return result;\n  }",
    "comment": " @return A detached clone of the Node, specifically excluding its children. ",
    "is_bug": false,
    "failing_test_cases": 5,
    "buggy_methods": 2
  },
  {
    "name": "Node.clonePropsFrom",
    "class_name": "com.google.javascript.rhino.Node",
    "signature": "com.google.javascript.rhino.Node.clonePropsFrom(Node)",
    "snippet": "  public Node clonePropsFrom(Node other) {\n    Preconditions.checkState(this.propListHead == null,\n        \"Node has existing properties.\");\n    this.propListHead = other.propListHead;\n    return this;\n  }",
    "comment": " Clone the properties from the provided node without copying the property object.  The recieving node may not have any existing properties. @param other The node to clone properties from. @return this node. ",
    "is_bug": false,
    "failing_test_cases": 5,
    "buggy_methods": 2
  },
  {
    "name": "Node.cloneTree",
    "class_name": "com.google.javascript.rhino.Node",
    "signature": "com.google.javascript.rhino.Node.cloneTree()",
    "snippet": "  public Node cloneTree() {\n    Node result = cloneNode();\n    for (Node n2 = getFirstChild(); n2 != null; n2 = n2.getNext()) {\n      Node n2clone = n2.cloneTree();\n      n2clone.parent = result;\n      if (result.last != null) {\n        result.last.next = n2clone;\n      }\n      if (result.first == null) {\n        result.first = n2clone;\n      }\n      result.last = n2clone;\n    }\n    return result;\n  }",
    "comment": " @return A detached clone of the Node and all its children. ",
    "is_bug": false,
    "failing_test_cases": 5,
    "buggy_methods": 2
  },
  {
    "name": "Node.extractCharno",
    "class_name": "com.google.javascript.rhino.Node",
    "signature": "com.google.javascript.rhino.Node.extractCharno(int)",
    "snippet": "  protected static int extractCharno(int lineCharNo) {\n    if (lineCharNo == -1) {\n      return -1;\n    } else {\n      return lineCharNo & COLUMN_MASK;\n    }\n  }",
    "comment": " Extracts the character number and character number from a merged line char number (see {@link #mergeLineCharNo(int, int)}). ",
    "is_bug": false,
    "failing_test_cases": 5,
    "buggy_methods": 2
  },
  {
    "name": "Node.extractLineno",
    "class_name": "com.google.javascript.rhino.Node",
    "signature": "com.google.javascript.rhino.Node.extractLineno(int)",
    "snippet": "  protected static int extractLineno(int lineCharNo) {\n    if (lineCharNo == -1) {\n      return -1;\n    } else {\n      return lineCharNo >>> COLUMN_BITS;\n    }\n  }",
    "comment": " Extracts the line number and character number from a merged line char number (see {@link #mergeLineCharNo(int, int)}). ",
    "is_bug": false,
    "failing_test_cases": 5,
    "buggy_methods": 2
  },
  {
    "name": "Node.getBooleanProp",
    "class_name": "com.google.javascript.rhino.Node",
    "signature": "com.google.javascript.rhino.Node.getBooleanProp(int)",
    "snippet": "  public boolean getBooleanProp(int propType) {\n    return getIntProp(propType) != 0;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 5,
    "buggy_methods": 2
  },
  {
    "name": "Node.getCharno",
    "class_name": "com.google.javascript.rhino.Node",
    "signature": "com.google.javascript.rhino.Node.getCharno()",
    "snippet": "  public int getCharno() {\n    return extractCharno(sourcePosition);\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 5,
    "buggy_methods": 2
  },
  {
    "name": "Node.getFirstChild",
    "class_name": "com.google.javascript.rhino.Node",
    "signature": "com.google.javascript.rhino.Node.getFirstChild()",
    "snippet": "  public Node getFirstChild() {\n    return first;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 5,
    "buggy_methods": 2
  },
  {
    "name": "Node.getIntProp",
    "class_name": "com.google.javascript.rhino.Node",
    "signature": "com.google.javascript.rhino.Node.getIntProp(int)",
    "snippet": "  public int getIntProp(int propType) {\n    PropListItem item = lookupProperty(propType);\n    if (item == null) {\n      return 0;\n    }\n    return item.intValue;\n  }",
    "comment": " Returns the integer value for the property, or 0 if the property is not defined. ",
    "is_bug": false,
    "failing_test_cases": 5,
    "buggy_methods": 2
  },
  {
    "name": "Node.getJSDocInfo",
    "class_name": "com.google.javascript.rhino.Node",
    "signature": "com.google.javascript.rhino.Node.getJSDocInfo()",
    "snippet": "  public JSDocInfo getJSDocInfo() {\n    return (JSDocInfo) getProp(JSDOC_INFO_PROP);\n  }",
    "comment": " Get the {@link JSDocInfo} attached to this node. @return the information or {@code null} if no JSDoc is attached to this node ",
    "is_bug": false,
    "failing_test_cases": 5,
    "buggy_methods": 2
  },
  {
    "name": "Node.getJsDocBuilderForNode",
    "class_name": "com.google.javascript.rhino.Node",
    "signature": "com.google.javascript.rhino.Node.getJsDocBuilderForNode()",
    "snippet": "  public FileLevelJsDocBuilder getJsDocBuilderForNode() {\n    return new FileLevelJsDocBuilder();\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 5,
    "buggy_methods": 2
  },
  {
    "name": "Node.getLastChild",
    "class_name": "com.google.javascript.rhino.Node",
    "signature": "com.google.javascript.rhino.Node.getLastChild()",
    "snippet": "  public Node getLastChild() {\n    return last;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 5,
    "buggy_methods": 2
  },
  {
    "name": "Node.getLineno",
    "class_name": "com.google.javascript.rhino.Node",
    "signature": "com.google.javascript.rhino.Node.getLineno()",
    "snippet": "  public int getLineno() {\n    return extractLineno(sourcePosition);\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 5,
    "buggy_methods": 2
  },
  {
    "name": "Node.getNext",
    "class_name": "com.google.javascript.rhino.Node",
    "signature": "com.google.javascript.rhino.Node.getNext()",
    "snippet": "  public Node getNext() {\n    return next;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 5,
    "buggy_methods": 2
  },
  {
    "name": "Node.getParent",
    "class_name": "com.google.javascript.rhino.Node",
    "signature": "com.google.javascript.rhino.Node.getParent()",
    "snippet": "  public Node getParent() {\n    return parent;\n  }",
    "comment": "Accessors",
    "is_bug": false,
    "failing_test_cases": 5,
    "buggy_methods": 2
  },
  {
    "name": "Node.getProp",
    "class_name": "com.google.javascript.rhino.Node",
    "signature": "com.google.javascript.rhino.Node.getProp(int)",
    "snippet": "  public Object getProp(int propType) {\n    PropListItem item = lookupProperty(propType);\n    if (item == null) {\n      return null;\n    }\n    return item.objectValue;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 5,
    "buggy_methods": 2
  },
  {
    "name": "Node.getType",
    "class_name": "com.google.javascript.rhino.Node",
    "signature": "com.google.javascript.rhino.Node.getType()",
    "snippet": "  public int getType() {\n    return type;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 5,
    "buggy_methods": 2
  },
  {
    "name": "Node.hasOneChild",
    "class_name": "com.google.javascript.rhino.Node",
    "signature": "com.google.javascript.rhino.Node.hasOneChild()",
    "snippet": "  public boolean hasOneChild() {\n    return first != null && first == last;\n  }",
    "comment": " Check for one child more efficiently than by iterating over all the children as is done with Node.getChildCount().  @return Whether the node has exactly one child. ",
    "is_bug": false,
    "failing_test_cases": 5,
    "buggy_methods": 2
  },
  {
    "name": "Node.lookupProperty",
    "class_name": "com.google.javascript.rhino.Node",
    "signature": "com.google.javascript.rhino.Node.lookupProperty(int)",
    "snippet": "  @VisibleForTesting\n  PropListItem lookupProperty(int propType) {\n    PropListItem x = propListHead;\n    while (x != null && propType != x.type) {\n      x = x.next;\n    }\n    return x;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 5,
    "buggy_methods": 2
  },
  {
    "name": "Node.mergeLineCharNo",
    "class_name": "com.google.javascript.rhino.Node",
    "signature": "com.google.javascript.rhino.Node.mergeLineCharNo(int,int)",
    "snippet": "  protected static int mergeLineCharNo(int lineno, int charno) {\n    if (lineno < 0 || charno < 0) {\n      return -1;\n    } else if ((charno & ~COLUMN_MASK) != 0) {\n      return lineno << COLUMN_BITS | COLUMN_MASK;\n    } else {\n      return lineno << COLUMN_BITS | (charno & COLUMN_MASK);\n    }\n  }",
    "comment": " Merges the line number and character number in one integer. The Character number takes the first 12 bits and the line number takes the rest. If the character number is greater than <code>2<sup>12</sup>-1</code> it is adjusted to <code>2<sup>12</sup>-1</code>. ",
    "is_bug": false,
    "failing_test_cases": 5,
    "buggy_methods": 2
  },
  {
    "name": "Node.newString",
    "class_name": "com.google.javascript.rhino.Node",
    "signature": "com.google.javascript.rhino.Node.newString(int,String)",
    "snippet": "  public static Node newString(int type, String str) {\n    return new StringNode(type, str);\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 5,
    "buggy_methods": 2
  },
  {
    "name": "Node.putBooleanProp",
    "class_name": "com.google.javascript.rhino.Node",
    "signature": "com.google.javascript.rhino.Node.putBooleanProp(int,boolean)",
    "snippet": "  public void putBooleanProp(int propType, boolean value) {\n    putIntProp(propType, value ? 1 : 0);\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 5,
    "buggy_methods": 2
  },
  {
    "name": "Node.putIntProp",
    "class_name": "com.google.javascript.rhino.Node",
    "signature": "com.google.javascript.rhino.Node.putIntProp(int,int)",
    "snippet": "  public void putIntProp(int propType, int value) {\n    removeProp(propType);\n    if (value != 0) {\n      propListHead = new PropListItem(propType, value, propListHead);\n    }\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 5,
    "buggy_methods": 2
  },
  {
    "name": "Node.putProp",
    "class_name": "com.google.javascript.rhino.Node",
    "signature": "com.google.javascript.rhino.Node.putProp(int,Object)",
    "snippet": "  public void putProp(int propType, Object value) {\n    removeProp(propType);\n    if (value != null) {\n      propListHead = new PropListItem(propType, value, propListHead);\n    }\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 5,
    "buggy_methods": 2
  },
  {
    "name": "Node.removeProp",
    "class_name": "com.google.javascript.rhino.Node",
    "signature": "com.google.javascript.rhino.Node.removeProp(PropListItem,int)",
    "snippet": "  private PropListItem removeProp(PropListItem item, int propType) {\n    if (item == null) {\n      return null;\n    } else if (item.type == propType) {\n      return item.next;\n    } else {\n      PropListItem result = removeProp(item.next, propType);\n      if (result != item.next) {\n        return new PropListItem(\n            item.type, item.intValue, item.objectValue, result);\n      } else {\n        return item;\n      }\n    }\n  }",
    "comment": " @param item The item to inspect @param propType The property to look for @return The replacement list if the property was removed, or 'item' otherwise. ",
    "is_bug": false,
    "failing_test_cases": 5,
    "buggy_methods": 2
  },
  {
    "name": "Node.removeProp",
    "class_name": "com.google.javascript.rhino.Node",
    "signature": "com.google.javascript.rhino.Node.removeProp(int)",
    "snippet": "  public void removeProp(int propType) {\n    PropListItem result = removeProp(propListHead, propType);\n    if (result != propListHead) {\n      propListHead = result;\n    }\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 5,
    "buggy_methods": 2
  },
  {
    "name": "Node.setCharno",
    "class_name": "com.google.javascript.rhino.Node",
    "signature": "com.google.javascript.rhino.Node.setCharno(int)",
    "snippet": "  public void setCharno(int charno) {\n      sourcePosition = mergeLineCharNo(getLineno(), charno);\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 5,
    "buggy_methods": 2
  },
  {
    "name": "Node.setIsSyntheticBlock",
    "class_name": "com.google.javascript.rhino.Node",
    "signature": "com.google.javascript.rhino.Node.setIsSyntheticBlock(boolean)",
    "snippet": "  public void setIsSyntheticBlock(boolean val) {\n    putBooleanProp(SYNTHETIC_BLOCK_PROP, val);\n  }",
    "comment": " Sets whether this is a synthetic block that should not be considered a real source block. ",
    "is_bug": false,
    "failing_test_cases": 5,
    "buggy_methods": 2
  },
  {
    "name": "Node.setJSDocInfo",
    "class_name": "com.google.javascript.rhino.Node",
    "signature": "com.google.javascript.rhino.Node.setJSDocInfo(JSDocInfo)",
    "snippet": "  public void setJSDocInfo(JSDocInfo info) {\n      putProp(JSDOC_INFO_PROP, info);\n  }",
    "comment": " Sets the {@link JSDocInfo} attached to this node. ",
    "is_bug": false,
    "failing_test_cases": 5,
    "buggy_methods": 2
  },
  {
    "name": "Node.setJSType",
    "class_name": "com.google.javascript.rhino.Node",
    "signature": "com.google.javascript.rhino.Node.setJSType(JSType)",
    "snippet": "  public void setJSType(JSType jsType) {\n      this.jsType = jsType;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 5,
    "buggy_methods": 2
  },
  {
    "name": "Node.setLineno",
    "class_name": "com.google.javascript.rhino.Node",
    "signature": "com.google.javascript.rhino.Node.setLineno(int)",
    "snippet": "  public void setLineno(int lineno) {\n      int charno = getCharno();\n      if (charno == -1) {\n        charno = 0;\n      }\n      sourcePosition = mergeLineCharNo(lineno, charno);\n  }",
    "comment": "Source position management",
    "is_bug": false,
    "failing_test_cases": 5,
    "buggy_methods": 2
  },
  {
    "name": "Node.setOptionalArg",
    "class_name": "com.google.javascript.rhino.Node",
    "signature": "com.google.javascript.rhino.Node.setOptionalArg(boolean)",
    "snippet": "  public void setOptionalArg(boolean optionalArg) {\n    putBooleanProp(OPT_ARG_NAME, optionalArg);\n  }",
    "comment": " Sets whether this node is an optional argument node. This method is meaningful only on {@link Token#NAME} nodes used to define a {@link Token#FUNCTION}'s argument list. ",
    "is_bug": false,
    "failing_test_cases": 5,
    "buggy_methods": 2
  },
  {
    "name": "Node.setVarArgs",
    "class_name": "com.google.javascript.rhino.Node",
    "signature": "com.google.javascript.rhino.Node.setVarArgs(boolean)",
    "snippet": "  public void setVarArgs(boolean varArgs) {\n    putBooleanProp(VAR_ARGS_NAME, varArgs);\n  }",
    "comment": " Sets whether this node is a variable length argument node. This method is meaningful only on {@link Token#NAME} nodes used to define a {@link Token#FUNCTION}'s argument list. ",
    "is_bug": false,
    "failing_test_cases": 5,
    "buggy_methods": 2
  },
  {
    "name": "StringNode.getString",
    "class_name": "com.google.javascript.rhino.Node$StringNode",
    "signature": "com.google.javascript.rhino.Node$StringNode.getString()",
    "snippet": "    @Override\n    public String getString() {\n      return this.str;\n    }",
    "comment": " returns the string content. @return non null. ",
    "is_bug": false,
    "failing_test_cases": 5,
    "buggy_methods": 2
  },
  {
    "name": "ScriptRuntime.getMessage",
    "class_name": "com.google.javascript.rhino.ScriptRuntime",
    "signature": "com.google.javascript.rhino.ScriptRuntime.getMessage(String,Object[])",
    "snippet": "    public static String getMessage(String messageId, Object[] arguments)\n    {\n        final String defaultResource\n            = \"rhino_ast.java.com.google.javascript.rhino.Messages\";\n\n        Context cx = Context.getCurrentContext();\n        Locale locale = cx != null ? cx.getLocale() : Locale.getDefault();\n\n        // ResourceBundle does cacheing.\n        ResourceBundle rb = ResourceBundle.getBundle(defaultResource, locale);\n\n        String formatString;\n        try {\n            formatString = rb.getString(messageId);\n        } catch (java.util.MissingResourceException mre) {\n            throw new RuntimeException\n                (\"no message resource found for message property \"+ messageId);\n        }\n\n        /*\n         * It's OK to format the string, even if 'arguments' is null;\n         * we need to format it anyway, to make double ''s collapse to\n         * single 's.\n         */\n        // TODO: MessageFormat is not available on pJava\n        MessageFormat formatter = new MessageFormat(formatString);\n        return formatter.format(arguments);\n    }",
    "comment": "OPT there's a noticable delay for the first error!  Maybe it'd make sense to use a ListResourceBundle instead of a properties file to avoid (synchronized) text parsing. ",
    "is_bug": false,
    "failing_test_cases": 5,
    "buggy_methods": 2
  },
  {
    "name": "ScriptRuntime.getMessage0",
    "class_name": "com.google.javascript.rhino.ScriptRuntime",
    "signature": "com.google.javascript.rhino.ScriptRuntime.getMessage0(String)",
    "snippet": "    public static String getMessage0(String messageId)\n    {\n        return getMessage(messageId, null);\n    }",
    "comment": "------------------",
    "is_bug": false,
    "failing_test_cases": 5,
    "buggy_methods": 2
  },
  {
    "name": "AllType.AllType",
    "class_name": "com.google.javascript.rhino.jstype.AllType",
    "signature": "com.google.javascript.rhino.jstype.AllType.AllType(JSTypeRegistry)",
    "snippet": "  AllType(JSTypeRegistry registry) {\n    super(registry);\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 5,
    "buggy_methods": 2
  },
  {
    "name": "AllType.isAllType",
    "class_name": "com.google.javascript.rhino.jstype.AllType",
    "signature": "com.google.javascript.rhino.jstype.AllType.isAllType()",
    "snippet": "  @Override\n  public boolean isAllType() {\n    return true;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 5,
    "buggy_methods": 2
  },
  {
    "name": "ArrowType.ArrowType",
    "class_name": "com.google.javascript.rhino.jstype.ArrowType",
    "signature": "com.google.javascript.rhino.jstype.ArrowType.ArrowType(JSTypeRegistry,Node,JSType)",
    "snippet": "  ArrowType(JSTypeRegistry registry, Node parameters,\n      JSType returnType) {\n    this(registry, parameters, returnType, false);\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 5,
    "buggy_methods": 2
  },
  {
    "name": "ArrowType.ArrowType",
    "class_name": "com.google.javascript.rhino.jstype.ArrowType",
    "signature": "com.google.javascript.rhino.jstype.ArrowType.ArrowType(JSTypeRegistry,Node,JSType,boolean)",
    "snippet": "  ArrowType(JSTypeRegistry registry, Node parameters,\n      JSType returnType, boolean returnTypeInferred) {\n    super(registry);\n\n    this.parameters = parameters == null ?\n        registry.createParametersWithVarArgs(getNativeType(UNKNOWN_TYPE)) :\n        parameters;\n    this.returnType = returnType == null ?\n        getNativeType(UNKNOWN_TYPE) : returnType;\n    this.returnTypeInferred = returnTypeInferred;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 5,
    "buggy_methods": 2
  },
  {
    "name": "BooleanType.BooleanType",
    "class_name": "com.google.javascript.rhino.jstype.BooleanType",
    "signature": "com.google.javascript.rhino.jstype.BooleanType.BooleanType(JSTypeRegistry)",
    "snippet": "  BooleanType(JSTypeRegistry registry) {\n    super(registry);\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 5,
    "buggy_methods": 2
  },
  {
    "name": "BooleanType.getDisplayName",
    "class_name": "com.google.javascript.rhino.jstype.BooleanType",
    "signature": "com.google.javascript.rhino.jstype.BooleanType.getDisplayName()",
    "snippet": "  @Override\n  public String getDisplayName() {\n    return \"boolean\";\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 5,
    "buggy_methods": 2
  },
  {
    "name": "BooleanType.toString",
    "class_name": "com.google.javascript.rhino.jstype.BooleanType",
    "signature": "com.google.javascript.rhino.jstype.BooleanType.toString()",
    "snippet": "  @Override\n  public String toString() {\n    return getDisplayName();\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 5,
    "buggy_methods": 2
  },
  {
    "name": "ErrorFunctionType.ErrorFunctionType",
    "class_name": "com.google.javascript.rhino.jstype.ErrorFunctionType",
    "signature": "com.google.javascript.rhino.jstype.ErrorFunctionType.ErrorFunctionType(JSTypeRegistry,String)",
    "snippet": "  ErrorFunctionType(JSTypeRegistry registry, String name) {\n    super(\n        registry, name, null,\n        registry.createArrowType(\n            registry.createOptionalParameters(\n                registry.getNativeType(ALL_TYPE),\n                registry.getNativeType(ALL_TYPE),\n                registry.getNativeType(ALL_TYPE)),\n            null),\n        null, null, true, true);\n\n    // NOTE(nicksantos): Errors have the weird behavior in that they can\n    // be called as functions, and they will return instances of themselves.\n    // Error('x') instanceof Error => true\n    //\n    // In user-defined types, we would deal with this case by creating\n    // a NamedType with the name \"Error\" and then resolve it later.\n    //\n    // For native types, we don't really want the native types to\n    // depend on type-resolution. So we just set the return type manually\n    // at the end of construction.\n    //\n    // There's similar logic in JSTypeRegistry for Array and RegExp.\n    getInternalArrowType().returnType = getInstanceType();\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 5,
    "buggy_methods": 2
  },
  {
    "name": "FunctionBuilder.FunctionBuilder",
    "class_name": "com.google.javascript.rhino.jstype.FunctionBuilder",
    "signature": "com.google.javascript.rhino.jstype.FunctionBuilder.FunctionBuilder(JSTypeRegistry)",
    "snippet": "  public FunctionBuilder(JSTypeRegistry registry) {\n    this.registry = registry;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 5,
    "buggy_methods": 2
  },
  {
    "name": "FunctionBuilder.build",
    "class_name": "com.google.javascript.rhino.jstype.FunctionBuilder",
    "signature": "com.google.javascript.rhino.jstype.FunctionBuilder.build()",
    "snippet": "  public FunctionType build() {\n    return new FunctionType(registry, name, sourceNode,\n        new ArrowType(registry, parametersNode, returnType, inferredReturnType),\n        typeOfThis, templateTypeName, isConstructor, isNativeType);\n  }",
    "comment": "Construct a new function type. */",
    "is_bug": false,
    "failing_test_cases": 5,
    "buggy_methods": 2
  },
  {
    "name": "FunctionBuilder.withParamsNode",
    "class_name": "com.google.javascript.rhino.jstype.FunctionBuilder",
    "signature": "com.google.javascript.rhino.jstype.FunctionBuilder.withParamsNode(Node)",
    "snippet": "  public FunctionBuilder withParamsNode(Node parametersNode) {\n    this.parametersNode = parametersNode;\n    return this;\n  }",
    "comment": " Set the parameters of the function type with a specially-formatted node. ",
    "is_bug": false,
    "failing_test_cases": 5,
    "buggy_methods": 2
  },
  {
    "name": "FunctionBuilder.withReturnType",
    "class_name": "com.google.javascript.rhino.jstype.FunctionBuilder",
    "signature": "com.google.javascript.rhino.jstype.FunctionBuilder.withReturnType(JSType)",
    "snippet": "  public FunctionBuilder withReturnType(JSType returnType) {\n    this.returnType = returnType;\n    return this;\n  }",
    "comment": "Set the return type. */",
    "is_bug": false,
    "failing_test_cases": 5,
    "buggy_methods": 2
  },
  {
    "name": "FunctionParamBuilder.FunctionParamBuilder",
    "class_name": "com.google.javascript.rhino.jstype.FunctionParamBuilder",
    "signature": "com.google.javascript.rhino.jstype.FunctionParamBuilder.FunctionParamBuilder(JSTypeRegistry)",
    "snippet": "  public FunctionParamBuilder(JSTypeRegistry registry) {\n    this.registry = registry;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 5,
    "buggy_methods": 2
  },
  {
    "name": "FunctionParamBuilder.addOptionalParams",
    "class_name": "com.google.javascript.rhino.jstype.FunctionParamBuilder",
    "signature": "com.google.javascript.rhino.jstype.FunctionParamBuilder.addOptionalParams(JSType[])",
    "snippet": "  public boolean addOptionalParams(JSType ...types) {\n    if (hasVarArgs()) {\n      return false;\n    }\n\n    for (JSType type : types) {\n      newParameter(registry.createOptionalType(type)).setOptionalArg(true);\n    }\n    return true;\n  }",
    "comment": " Add optional parameters of the given type to the end of the param list. @param types Types for each optional parameter. The builder will make them undefineable. @return False if this is called after var args are added. ",
    "is_bug": false,
    "failing_test_cases": 5,
    "buggy_methods": 2
  },
  {
    "name": "FunctionParamBuilder.addRequiredParams",
    "class_name": "com.google.javascript.rhino.jstype.FunctionParamBuilder",
    "signature": "com.google.javascript.rhino.jstype.FunctionParamBuilder.addRequiredParams(JSType[])",
    "snippet": "  public boolean addRequiredParams(JSType ...types) {\n    if (hasOptionalOrVarArgs()) {\n      return false;\n    }\n\n    for (JSType type : types) {\n      newParameter(type);\n    }\n    return true;\n  }",
    "comment": " Add parameters of the given type to the end of the param list. @return False if this is called after optional params are added. ",
    "is_bug": false,
    "failing_test_cases": 5,
    "buggy_methods": 2
  },
  {
    "name": "FunctionParamBuilder.addVarArgs",
    "class_name": "com.google.javascript.rhino.jstype.FunctionParamBuilder",
    "signature": "com.google.javascript.rhino.jstype.FunctionParamBuilder.addVarArgs(JSType)",
    "snippet": "  public boolean addVarArgs(JSType type) {\n    if (hasVarArgs()) {\n      return false;\n    }\n\n    // There are two types of variable argument functions:\n    // 1) Programmer-defined var args\n    // 2) Native bottom types that can accept any argument.\n    // For the first one, \"undefined\" is a valid value for all arguments.\n    // For the second, we do not want to cast it up to undefined.\n    if (!type.isEmptyType()) {\n      type = registry.createOptionalType(type);\n    }\n    newParameter(type).setVarArgs(true);\n    return true;\n  }",
    "comment": " Add variable arguments to the end of the parameter list. @return False if this is called after var args are added. ",
    "is_bug": false,
    "failing_test_cases": 5,
    "buggy_methods": 2
  },
  {
    "name": "FunctionParamBuilder.build",
    "class_name": "com.google.javascript.rhino.jstype.FunctionParamBuilder",
    "signature": "com.google.javascript.rhino.jstype.FunctionParamBuilder.build()",
    "snippet": "  public Node build() {\n    return root;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 5,
    "buggy_methods": 2
  },
  {
    "name": "FunctionParamBuilder.hasOptionalOrVarArgs",
    "class_name": "com.google.javascript.rhino.jstype.FunctionParamBuilder",
    "signature": "com.google.javascript.rhino.jstype.FunctionParamBuilder.hasOptionalOrVarArgs()",
    "snippet": "  private boolean hasOptionalOrVarArgs() {\n    Node lastChild = root.getLastChild();\n    return lastChild != null &&\n        (lastChild.isOptionalArg() || lastChild.isVarArgs());\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 5,
    "buggy_methods": 2
  },
  {
    "name": "FunctionParamBuilder.hasVarArgs",
    "class_name": "com.google.javascript.rhino.jstype.FunctionParamBuilder",
    "signature": "com.google.javascript.rhino.jstype.FunctionParamBuilder.hasVarArgs()",
    "snippet": "  public boolean hasVarArgs() {\n    Node lastChild = root.getLastChild();\n    return lastChild != null && lastChild.isVarArgs();\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 5,
    "buggy_methods": 2
  },
  {
    "name": "FunctionParamBuilder.newParameter",
    "class_name": "com.google.javascript.rhino.jstype.FunctionParamBuilder",
    "signature": "com.google.javascript.rhino.jstype.FunctionParamBuilder.newParameter(JSType)",
    "snippet": "  private Node newParameter(JSType type) {\n    Node paramNode = Node.newString(Token.NAME, \"\");\n    paramNode.setJSType(type);\n    root.addChildToBack(paramNode);\n    return paramNode;\n  }",
    "comment": "Add a parameter to the list with the given type.",
    "is_bug": false,
    "failing_test_cases": 5,
    "buggy_methods": 2
  },
  {
    "name": "FunctionPrototypeType.FunctionPrototypeType",
    "class_name": "com.google.javascript.rhino.jstype.FunctionPrototypeType",
    "signature": "com.google.javascript.rhino.jstype.FunctionPrototypeType.FunctionPrototypeType(JSTypeRegistry,FunctionType,ObjectType)",
    "snippet": "  FunctionPrototypeType(JSTypeRegistry registry, FunctionType ownerFunction,\n      ObjectType implicitPrototype) {\n    this(registry, ownerFunction, implicitPrototype, false);\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 5,
    "buggy_methods": 2
  },
  {
    "name": "FunctionPrototypeType.FunctionPrototypeType",
    "class_name": "com.google.javascript.rhino.jstype.FunctionPrototypeType",
    "signature": "com.google.javascript.rhino.jstype.FunctionPrototypeType.FunctionPrototypeType(JSTypeRegistry,FunctionType,ObjectType,boolean)",
    "snippet": "  FunctionPrototypeType(JSTypeRegistry registry, FunctionType ownerFunction,\n      ObjectType implicitPrototype, boolean isNative) {\n    super(registry, null /* has no class name */, implicitPrototype,\n        isNative);\n    this.ownerFunction = ownerFunction;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 5,
    "buggy_methods": 2
  },
  {
    "name": "FunctionPrototypeType.getReferenceName",
    "class_name": "com.google.javascript.rhino.jstype.FunctionPrototypeType",
    "signature": "com.google.javascript.rhino.jstype.FunctionPrototypeType.getReferenceName()",
    "snippet": "  @Override\n  public String getReferenceName() {\n    if (ownerFunction == null) {\n      return \"{...}.prototype\";\n    } else {\n      return ownerFunction.getReferenceName() + \".prototype\";\n    }\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 5,
    "buggy_methods": 2
  },
  {
    "name": "FunctionPrototypeType.hasReferenceName",
    "class_name": "com.google.javascript.rhino.jstype.FunctionPrototypeType",
    "signature": "com.google.javascript.rhino.jstype.FunctionPrototypeType.hasReferenceName()",
    "snippet": "  @Override\n  public boolean hasReferenceName() {\n    return ownerFunction != null && ownerFunction.hasReferenceName();\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 5,
    "buggy_methods": 2
  },
  {
    "name": "FunctionType.FunctionType",
    "class_name": "com.google.javascript.rhino.jstype.FunctionType",
    "signature": "com.google.javascript.rhino.jstype.FunctionType.FunctionType(JSTypeRegistry,String,Node,ArrowType,ObjectType,String,boolean,boolean)",
    "snippet": "  FunctionType(JSTypeRegistry registry, String name, Node source,\n      ArrowType arrowType, ObjectType typeOfThis,\n      String templateTypeName,  boolean isConstructor, boolean nativeType) {\n    super(registry, name,\n        registry.getNativeObjectType(JSTypeNative.FUNCTION_INSTANCE_TYPE),\n        nativeType);\n    Preconditions.checkArgument(source == null ||\n        Token.FUNCTION == source.getType());\n    Preconditions.checkNotNull(arrowType);\n    this.source = source;\n    this.kind = isConstructor ? Kind.CONSTRUCTOR : Kind.ORDINARY;\n    if (isConstructor) {\n      this.typeOfThis = typeOfThis != null ?\n          typeOfThis : new InstanceObjectType(registry, this, nativeType);\n    } else {\n      this.typeOfThis = typeOfThis != null ?\n          typeOfThis :\n          registry.getNativeObjectType(JSTypeNative.UNKNOWN_TYPE);\n    }\n    this.call = arrowType;\n    this.templateTypeName = templateTypeName;\n  }",
    "comment": "Creates an instance for a function that might be a constructor. */",
    "is_bug": false,
    "failing_test_cases": 5,
    "buggy_methods": 2
  },
  {
    "name": "FunctionType.addSubType",
    "class_name": "com.google.javascript.rhino.jstype.FunctionType",
    "signature": "com.google.javascript.rhino.jstype.FunctionType.addSubType(FunctionType)",
    "snippet": "  private void addSubType(FunctionType subType) {\n    if (subTypes == null) {\n      subTypes = Lists.newArrayList();\n    }\n    subTypes.add(subType);\n  }",
    "comment": "Adds a type to the list of subtypes for this type. */",
    "is_bug": false,
    "failing_test_cases": 5,
    "buggy_methods": 2
  },
  {
    "name": "FunctionType.clearCachedValues",
    "class_name": "com.google.javascript.rhino.jstype.FunctionType",
    "signature": "com.google.javascript.rhino.jstype.FunctionType.clearCachedValues()",
    "snippet": "  @Override\n  void clearCachedValues() {\n    super.clearCachedValues();\n\n    if (subTypes != null) {\n      for (FunctionType subType : subTypes) {\n        subType.clearCachedValues();\n      }\n    }\n\n    if (!isNativeObjectType()) {\n      if (hasInstanceType()) {\n        getInstanceType().clearCachedValues();\n      }\n\n      if (prototype != null) {\n        prototype.clearCachedValues();\n      }\n    }\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 5,
    "buggy_methods": 2
  },
  {
    "name": "FunctionType.defineProperty",
    "class_name": "com.google.javascript.rhino.jstype.FunctionType",
    "signature": "com.google.javascript.rhino.jstype.FunctionType.defineProperty(String,JSType,boolean,boolean,Node)",
    "snippet": "  @Override\n  boolean defineProperty(String name, JSType type,\n      boolean inferred, boolean inExterns, Node propertyNode) {\n    if (\"prototype\".equals(name)) {\n      ObjectType objType = type.toObjectType();\n      if (objType != null) {\n        if (objType.isEquivalentTo(prototype)) {\n          return true;\n        }\n        return setPrototype(\n            new FunctionPrototypeType(\n                registry, this, objType, isNativeObjectType()));\n      } else {\n        return false;\n      }\n    }\n    return super.defineProperty(name, type, inferred, inExterns, propertyNode);\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 5,
    "buggy_methods": 2
  },
  {
    "name": "FunctionType.getInstanceType",
    "class_name": "com.google.javascript.rhino.jstype.FunctionType",
    "signature": "com.google.javascript.rhino.jstype.FunctionType.getInstanceType()",
    "snippet": "  public ObjectType getInstanceType() {\n    Preconditions.checkState(hasInstanceType());\n    return typeOfThis;\n  }",
    "comment": " Gets the type of instance of this function. @throws IllegalStateException if this function is not a constructor (see {@link #isConstructor()}). ",
    "is_bug": false,
    "failing_test_cases": 5,
    "buggy_methods": 2
  },
  {
    "name": "FunctionType.getInternalArrowType",
    "class_name": "com.google.javascript.rhino.jstype.FunctionType",
    "signature": "com.google.javascript.rhino.jstype.FunctionType.getInternalArrowType()",
    "snippet": "  ArrowType getInternalArrowType() {\n    return call;\n  }",
    "comment": "Gets the internal arrow type. For use by subclasses only. */",
    "is_bug": false,
    "failing_test_cases": 5,
    "buggy_methods": 2
  },
  {
    "name": "FunctionType.getPrototype",
    "class_name": "com.google.javascript.rhino.jstype.FunctionType",
    "signature": "com.google.javascript.rhino.jstype.FunctionType.getPrototype()",
    "snippet": "  public FunctionPrototypeType getPrototype() {\n    // lazy initialization of the prototype field\n    if (prototype == null) {\n      setPrototype(new FunctionPrototypeType(registry, this, null));\n    }\n    return prototype;\n  }",
    "comment": " Gets the {@code prototype} property of this function type. This is equivalent to {@code (ObjectType) getPropertyType(\"prototype\")}. ",
    "is_bug": false,
    "failing_test_cases": 5,
    "buggy_methods": 2
  },
  {
    "name": "FunctionType.getSuperClassConstructor",
    "class_name": "com.google.javascript.rhino.jstype.FunctionType",
    "signature": "com.google.javascript.rhino.jstype.FunctionType.getSuperClassConstructor()",
    "snippet": "  public FunctionType getSuperClassConstructor() {\n    Preconditions.checkArgument(isConstructor() || isInterface());\n    ObjectType maybeSuperInstanceType = getPrototype().getImplicitPrototype();\n    if (maybeSuperInstanceType == null) {\n      return null;\n    }\n    return maybeSuperInstanceType.getConstructor();\n  }",
    "comment": " Given a constructor or an interface type, get its superclass constructor or {@code null} if none exists. ",
    "is_bug": false,
    "failing_test_cases": 5,
    "buggy_methods": 2
  },
  {
    "name": "FunctionType.hasCachedValues",
    "class_name": "com.google.javascript.rhino.jstype.FunctionType",
    "signature": "com.google.javascript.rhino.jstype.FunctionType.hasCachedValues()",
    "snippet": "  @Override\n  public boolean hasCachedValues() {\n    return prototype != null || super.hasCachedValues();\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 5,
    "buggy_methods": 2
  },
  {
    "name": "FunctionType.hasInstanceType",
    "class_name": "com.google.javascript.rhino.jstype.FunctionType",
    "signature": "com.google.javascript.rhino.jstype.FunctionType.hasInstanceType()",
    "snippet": "  public boolean hasInstanceType() {\n    return isConstructor() || isInterface();\n  }",
    "comment": " Returns whether this function type has an instance type. ",
    "is_bug": false,
    "failing_test_cases": 5,
    "buggy_methods": 2
  },
  {
    "name": "FunctionType.isConstructor",
    "class_name": "com.google.javascript.rhino.jstype.FunctionType",
    "signature": "com.google.javascript.rhino.jstype.FunctionType.isConstructor()",
    "snippet": "  @Override\n  public boolean isConstructor() {\n    return kind == Kind.CONSTRUCTOR;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 5,
    "buggy_methods": 2
  },
  {
    "name": "FunctionType.isEquivalentTo",
    "class_name": "com.google.javascript.rhino.jstype.FunctionType",
    "signature": "com.google.javascript.rhino.jstype.FunctionType.isEquivalentTo(JSType)",
    "snippet": "  @Override\n  public boolean isEquivalentTo(JSType otherType) {\n    if (!(otherType instanceof FunctionType)) {\n      return false;\n    }\n    FunctionType that = (FunctionType) otherType;\n    if (!that.isFunctionType()) {\n      return false;\n    }\n    if (this.isConstructor()) {\n      if (that.isConstructor()) {\n        return this == that;\n      }\n      return false;\n    }\n    if (this.isInterface()) {\n      if (that.isInterface()) {\n        return this.getReferenceName().equals(that.getReferenceName());\n      }\n      return false;\n    }\n    if (that.isInterface()) {\n      return false;\n    }\n    return this.typeOfThis.isEquivalentTo(that.typeOfThis) &&\n        this.call.isEquivalentTo(that.call);\n  }",
    "comment": " Two function types are equal if their signatures match. Since they don't have signatures, two interfaces are equal if their names match. ",
    "is_bug": false,
    "failing_test_cases": 5,
    "buggy_methods": 2
  },
  {
    "name": "FunctionType.isFunctionType",
    "class_name": "com.google.javascript.rhino.jstype.FunctionType",
    "signature": "com.google.javascript.rhino.jstype.FunctionType.isFunctionType()",
    "snippet": "  @Override\n  public boolean isFunctionType() {\n    return true;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 5,
    "buggy_methods": 2
  },
  {
    "name": "FunctionType.isInterface",
    "class_name": "com.google.javascript.rhino.jstype.FunctionType",
    "signature": "com.google.javascript.rhino.jstype.FunctionType.isInterface()",
    "snippet": "  @Override\n  public boolean isInterface() {\n    return kind == Kind.INTERFACE;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 5,
    "buggy_methods": 2
  },
  {
    "name": "FunctionType.isSubtype",
    "class_name": "com.google.javascript.rhino.jstype.FunctionType",
    "signature": "com.google.javascript.rhino.jstype.FunctionType.isSubtype(JSType)",
    "snippet": "  @Override\n  public boolean isSubtype(JSType that) {\n    if (JSType.isSubtype(this, that)) {\n      return true;\n    }\n\n    if (that.isFunctionType()) {\n      if (((FunctionType) that).isInterface()) {\n        // Any function can be assigned to an interface function.\n        return true;\n      }\n      if (this.isInterface()) {\n        // An interface function cannot be assigned to anything.\n        return false;\n      }\n      // If functionA is a subtype of functionB, then their \"this\" types\n      // should be contravariant. However, this causes problems because\n      // of the way we enforce overrides. Because function(this:SubFoo)\n      // is not a subtype of function(this:Foo), our override check treats\n      // this as an error. It also screws up out standard method\n      // for aliasing constructors. Let's punt on all this for now.\n      // TODO(nicksantos): fix this.\n      FunctionType other = (FunctionType) that;\n      boolean treatThisTypesAsCovariant =\n        // If either one of these is a ctor, skip 'this' checking.\n        this.isConstructor() || other.isConstructor() ||\n\n        // An interface 'this'-type is non-restrictive.\n        // In practical terms, if C implements I, and I has a method m,\n        // then any m doesn't necessarily have to C#m's 'this'\n        // type doesn't need to match I.\n        (other.typeOfThis.getConstructor() != null &&\n             other.typeOfThis.getConstructor().isInterface()) ||\n\n        // If one of the 'this' types is covariant of the other,\n        // then we'll treat them as covariant (see comment above).\n        other.typeOfThis.isSubtype(this.typeOfThis) ||\n        this.typeOfThis.isSubtype(other.typeOfThis);\n      return treatThisTypesAsCovariant && this.call.isSubtype(other.call);\n    }\n\n    return getNativeType(JSTypeNative.FUNCTION_PROTOTYPE).isSubtype(that);\n  }",
    "comment": " A function is a subtype of another if their call methods are related via subtyping and {@code this} is a subtype of {@code that} with regard to the prototype chain. ",
    "is_bug": false,
    "failing_test_cases": 5,
    "buggy_methods": 2
  },
  {
    "name": "FunctionType.setInstanceType",
    "class_name": "com.google.javascript.rhino.jstype.FunctionType",
    "signature": "com.google.javascript.rhino.jstype.FunctionType.setInstanceType(ObjectType)",
    "snippet": "  void setInstanceType(ObjectType instanceType) {\n    typeOfThis = instanceType;\n  }",
    "comment": "Sets the instance type. This should only be used for special native types. */",
    "is_bug": false,
    "failing_test_cases": 5,
    "buggy_methods": 2
  },
  {
    "name": "FunctionType.setPrototype",
    "class_name": "com.google.javascript.rhino.jstype.FunctionType",
    "signature": "com.google.javascript.rhino.jstype.FunctionType.setPrototype(FunctionPrototypeType)",
    "snippet": "  public boolean setPrototype(FunctionPrototypeType prototype) {\n    if (prototype == null) {\n      return false;\n    }\n    // getInstanceType fails if the function is not a constructor\n    if (isConstructor() && prototype == getInstanceType()) {\n      return false;\n    }\n\n    boolean replacedPrototype = prototype != null;\n    this.prototype = prototype;\n\n    if (isConstructor() || isInterface()) {\n      FunctionType superClass = getSuperClassConstructor();\n      if (superClass != null) {\n        superClass.addSubType(this);\n      }\n    }\n\n    if (replacedPrototype) {\n      clearCachedValues();\n    }\n\n    return true;\n  }",
    "comment": " Sets the prototype. @param prototype the prototype. If this value is {@code null} it will silently be discarded. ",
    "is_bug": false,
    "failing_test_cases": 5,
    "buggy_methods": 2
  },
  {
    "name": "FunctionType.setPrototypeBasedOn",
    "class_name": "com.google.javascript.rhino.jstype.FunctionType",
    "signature": "com.google.javascript.rhino.jstype.FunctionType.setPrototypeBasedOn(ObjectType)",
    "snippet": "  public void setPrototypeBasedOn(ObjectType baseType) {\n    if (prototype == null) {\n      setPrototype(\n          new FunctionPrototypeType(\n              registry, this, baseType, isNativeObjectType()));\n    } else {\n      prototype.setImplicitPrototype(baseType);\n    }\n  }",
    "comment": " Sets the prototype, creating the prototype object from the given base type. @param baseType The base type. ",
    "is_bug": false,
    "failing_test_cases": 5,
    "buggy_methods": 2
  },
  {
    "name": "InstanceObjectType.InstanceObjectType",
    "class_name": "com.google.javascript.rhino.jstype.InstanceObjectType",
    "signature": "com.google.javascript.rhino.jstype.InstanceObjectType.InstanceObjectType(JSTypeRegistry,FunctionType,boolean)",
    "snippet": "  InstanceObjectType(JSTypeRegistry registry, FunctionType constructor,\n                     boolean isNativeType) {\n    super(registry, null, null, isNativeType);\n    Preconditions.checkNotNull(constructor);\n    this.constructor = constructor;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 5,
    "buggy_methods": 2
  },
  {
    "name": "InstanceObjectType.defineProperty",
    "class_name": "com.google.javascript.rhino.jstype.InstanceObjectType",
    "signature": "com.google.javascript.rhino.jstype.InstanceObjectType.defineProperty(String,JSType,boolean,boolean,Node)",
    "snippet": "  @Override\n  boolean defineProperty(String name, JSType type, boolean inferred,\n      boolean inExterns, Node propertyNode) {\n    ObjectType proto = getImplicitPrototype();\n    if (proto != null && proto.hasOwnDeclaredProperty(name)) {\n      return false;\n    }\n    return super.defineProperty(name, type, inferred, inExterns, propertyNode);\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 5,
    "buggy_methods": 2
  },
  {
    "name": "InstanceObjectType.getConstructor",
    "class_name": "com.google.javascript.rhino.jstype.InstanceObjectType",
    "signature": "com.google.javascript.rhino.jstype.InstanceObjectType.getConstructor()",
    "snippet": "  @Override\n  public FunctionType getConstructor() {\n    return constructor;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 5,
    "buggy_methods": 2
  },
  {
    "name": "InstanceObjectType.getImplicitPrototype",
    "class_name": "com.google.javascript.rhino.jstype.InstanceObjectType",
    "signature": "com.google.javascript.rhino.jstype.InstanceObjectType.getImplicitPrototype()",
    "snippet": "  @Override\n  public ObjectType getImplicitPrototype() {\n    return getConstructor().getPrototype();\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 5,
    "buggy_methods": 2
  },
  {
    "name": "InstanceObjectType.getReferenceName",
    "class_name": "com.google.javascript.rhino.jstype.InstanceObjectType",
    "signature": "com.google.javascript.rhino.jstype.InstanceObjectType.getReferenceName()",
    "snippet": "  @Override\n  public String getReferenceName() {\n    return getConstructor().getReferenceName();\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 5,
    "buggy_methods": 2
  },
  {
    "name": "InstanceObjectType.hasReferenceName",
    "class_name": "com.google.javascript.rhino.jstype.InstanceObjectType",
    "signature": "com.google.javascript.rhino.jstype.InstanceObjectType.hasReferenceName()",
    "snippet": "  @Override\n  public boolean hasReferenceName() {\n    return getConstructor().hasReferenceName();\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 5,
    "buggy_methods": 2
  },
  {
    "name": "InstanceObjectType.hashCode",
    "class_name": "com.google.javascript.rhino.jstype.InstanceObjectType",
    "signature": "com.google.javascript.rhino.jstype.InstanceObjectType.hashCode()",
    "snippet": "  @Override\n  public int hashCode() {\n    if (hasReferenceName()) {\n      return getReferenceName().hashCode();\n    } else {\n      return super.hashCode();\n    }\n  }",
    "comment": " If this is equal to a NamedType object, its hashCode must be equal to the hashCode of the NamedType object. ",
    "is_bug": false,
    "failing_test_cases": 5,
    "buggy_methods": 2
  },
  {
    "name": "InstanceObjectType.isEquivalentTo",
    "class_name": "com.google.javascript.rhino.jstype.InstanceObjectType",
    "signature": "com.google.javascript.rhino.jstype.InstanceObjectType.isEquivalentTo(JSType)",
    "snippet": "  @Override\n  public boolean isEquivalentTo(JSType that) {\n    if (this == that) {\n      return true;\n    } else if (this.isNominalType()) {\n      ObjectType thatObj = ObjectType.cast(that);\n      if (thatObj != null && thatObj.isNominalType()) {\n        return getReferenceName().equals(thatObj.getReferenceName());\n      }\n    }\n    return false;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 5,
    "buggy_methods": 2
  },
  {
    "name": "InstanceObjectType.isNominalType",
    "class_name": "com.google.javascript.rhino.jstype.InstanceObjectType",
    "signature": "com.google.javascript.rhino.jstype.InstanceObjectType.isNominalType()",
    "snippet": "  @Override\n  public boolean isNominalType() {\n    return hasReferenceName();\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 5,
    "buggy_methods": 2
  },
  {
    "name": "InstanceObjectType.toString",
    "class_name": "com.google.javascript.rhino.jstype.InstanceObjectType",
    "signature": "com.google.javascript.rhino.jstype.InstanceObjectType.toString()",
    "snippet": "  @Override\n  public String toString() {\n    if (constructor.hasReferenceName()) {\n      return constructor.getReferenceName();\n    } else {\n      return super.toString();\n    }\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 5,
    "buggy_methods": 2
  },
  {
    "name": "JSType.JSType",
    "class_name": "com.google.javascript.rhino.jstype.JSType",
    "signature": "com.google.javascript.rhino.jstype.JSType.JSType(JSTypeRegistry)",
    "snippet": "  JSType(JSTypeRegistry registry) {\n    this.registry = registry;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 5,
    "buggy_methods": 2
  },
  {
    "name": "JSType.getNativeType",
    "class_name": "com.google.javascript.rhino.jstype.JSType",
    "signature": "com.google.javascript.rhino.jstype.JSType.getNativeType(JSTypeNative)",
    "snippet": "  JSType getNativeType(JSTypeNative typeId) {\n    return registry.getNativeType(typeId);\n  }",
    "comment": " Utility method for less verbose code. ",
    "is_bug": false,
    "failing_test_cases": 5,
    "buggy_methods": 2
  },
  {
    "name": "JSType.hashCode",
    "class_name": "com.google.javascript.rhino.jstype.JSType",
    "signature": "com.google.javascript.rhino.jstype.JSType.hashCode()",
    "snippet": "  @Override\n  public int hashCode() {\n    return System.identityHashCode(this);\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 5,
    "buggy_methods": 2
  },
  {
    "name": "JSType.isAllType",
    "class_name": "com.google.javascript.rhino.jstype.JSType",
    "signature": "com.google.javascript.rhino.jstype.JSType.isAllType()",
    "snippet": "  public boolean isAllType() {\n    return false;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 5,
    "buggy_methods": 2
  },
  {
    "name": "JSType.isEmptyType",
    "class_name": "com.google.javascript.rhino.jstype.JSType",
    "signature": "com.google.javascript.rhino.jstype.JSType.isEmptyType()",
    "snippet": "  public final boolean isEmptyType() {\n    return isNoType() || isNoObjectType() || isNoResolvedType() ||\n        (registry.getNativeFunctionType(\n             JSTypeNative.LEAST_FUNCTION_TYPE) == this);\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 5,
    "buggy_methods": 2
  },
  {
    "name": "JSType.isEquivalentTo",
    "class_name": "com.google.javascript.rhino.jstype.JSType",
    "signature": "com.google.javascript.rhino.jstype.JSType.isEquivalentTo(JSType)",
    "snippet": "  public boolean isEquivalentTo(JSType jsType) {\n    if (jsType instanceof ProxyObjectType) {\n      return jsType.isEquivalentTo(this);\n    }\n    // Relies on the fact that for the base {@link JSType}, only one\n    // instance of each sub-type will ever be created in a given registry, so\n    // there is no need to verify members. If the object pointers are not\n    // identical, then the type member must be different.\n    return this == jsType;\n  }",
    "comment": " Checks if two types are equivalent. ",
    "is_bug": false,
    "failing_test_cases": 5,
    "buggy_methods": 2
  },
  {
    "name": "JSType.isNoObjectType",
    "class_name": "com.google.javascript.rhino.jstype.JSType",
    "signature": "com.google.javascript.rhino.jstype.JSType.isNoObjectType()",
    "snippet": "  public boolean isNoObjectType() {\n    return false;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 5,
    "buggy_methods": 2
  },
  {
    "name": "JSType.isNoResolvedType",
    "class_name": "com.google.javascript.rhino.jstype.JSType",
    "signature": "com.google.javascript.rhino.jstype.JSType.isNoResolvedType()",
    "snippet": "  public boolean isNoResolvedType() {\n    return false;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 5,
    "buggy_methods": 2
  },
  {
    "name": "JSType.isNoType",
    "class_name": "com.google.javascript.rhino.jstype.JSType",
    "signature": "com.google.javascript.rhino.jstype.JSType.isNoType()",
    "snippet": "  public boolean isNoType() {\n    return false;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 5,
    "buggy_methods": 2
  },
  {
    "name": "JSType.isNominalType",
    "class_name": "com.google.javascript.rhino.jstype.JSType",
    "signature": "com.google.javascript.rhino.jstype.JSType.isNominalType()",
    "snippet": "  public boolean isNominalType() {\n    return false;\n  }",
    "comment": " Whether this type is a nominal type (a named instance object or a named enum). ",
    "is_bug": false,
    "failing_test_cases": 5,
    "buggy_methods": 2
  },
  {
    "name": "JSType.isSubtype",
    "class_name": "com.google.javascript.rhino.jstype.JSType",
    "signature": "com.google.javascript.rhino.jstype.JSType.isSubtype(JSType,JSType)",
    "snippet": "  static boolean isSubtype(JSType thisType, JSType thatType) {\n    // unknown\n    if (thatType.isUnknownType()) {\n      return true;\n    }\n    // equality\n    if (thisType.isEquivalentTo(thatType)) {\n      return true;\n    }\n    // all type\n    if (thatType.isAllType()) {\n      return true;\n    }\n    // unions\n    if (thatType instanceof UnionType) {\n      UnionType union = (UnionType)thatType;\n      for (JSType element : union.alternates) {\n        if (thisType.isSubtype(element)) {\n          return true;\n        }\n      }\n    }\n    // named types\n    if (thatType instanceof NamedType) {\n      return thisType.isSubtype(((NamedType)thatType).getReferencedType());\n    }\n    return false;\n  }",
    "comment": " A generic implementation meant to be used as a helper for common subtyping cases. ",
    "is_bug": false,
    "failing_test_cases": 5,
    "buggy_methods": 2
  },
  {
    "name": "JSType.isUnknownType",
    "class_name": "com.google.javascript.rhino.jstype.JSType",
    "signature": "com.google.javascript.rhino.jstype.JSType.isUnknownType()",
    "snippet": "  public boolean isUnknownType() {\n    return false;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 5,
    "buggy_methods": 2
  },
  {
    "name": "JSType.toObjectType",
    "class_name": "com.google.javascript.rhino.jstype.JSType",
    "signature": "com.google.javascript.rhino.jstype.JSType.toObjectType()",
    "snippet": "  public ObjectType toObjectType() {\n    return this instanceof ObjectType ? (ObjectType) this : null;\n  }",
    "comment": " Casts this to an ObjectType, or returns null if this is not an ObjectType.  Does not change the underlying JS type. If you want to simulate JS autoboxing or dereferencing, you should use autoboxesTo() or dereference(). Those methods may change the underlying JS type. ",
    "is_bug": false,
    "failing_test_cases": 5,
    "buggy_methods": 2
  },
  {
    "name": "JSTypeRegistry.JSTypeRegistry",
    "class_name": "com.google.javascript.rhino.jstype.JSTypeRegistry",
    "signature": "com.google.javascript.rhino.jstype.JSTypeRegistry.JSTypeRegistry(ErrorReporter,boolean)",
    "snippet": "  public JSTypeRegistry(\n      ErrorReporter reporter, boolean tolerateUndefinedValues) {\n    this.reporter = reporter;\n    nativeTypes = new JSType[JSTypeNative.values().length];\n    namesToTypes = new HashMap<String, JSType>();\n    resetForTypeCheck();\n    this.tolerateUndefinedValues = tolerateUndefinedValues;\n  }",
    "comment": " Constructs a new type registry populated with the built-in types. ",
    "is_bug": false,
    "failing_test_cases": 5,
    "buggy_methods": 2
  },
  {
    "name": "JSTypeRegistry.addReferenceTypeIndexedByProperty",
    "class_name": "com.google.javascript.rhino.jstype.JSTypeRegistry",
    "signature": "com.google.javascript.rhino.jstype.JSTypeRegistry.addReferenceTypeIndexedByProperty(String,JSType)",
    "snippet": "  private void addReferenceTypeIndexedByProperty(\n      String propertyName, JSType type) {\n    if (type instanceof ObjectType && ((ObjectType) type).hasReferenceName()) {\n      Map<String, ObjectType> typeSet =\n          eachRefTypeIndexedByProperty.get(propertyName);\n      if (typeSet == null) {\n        typeSet = Maps.newHashMap();\n        eachRefTypeIndexedByProperty.put(propertyName, typeSet);\n      }\n      ObjectType objType = (ObjectType) type;\n      typeSet.put(objType.getReferenceName(), objType);\n    } else if (type instanceof NamedType) {\n      addReferenceTypeIndexedByProperty(\n          propertyName, ((NamedType) type).getReferencedType());\n    } else if (type instanceof UnionType) {\n      for (JSType alternate : ((UnionType) type).getAlternates()) {\n        addReferenceTypeIndexedByProperty(propertyName, alternate);\n      }\n    }\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 5,
    "buggy_methods": 2
  },
  {
    "name": "JSTypeRegistry.createArrowType",
    "class_name": "com.google.javascript.rhino.jstype.JSTypeRegistry",
    "signature": "com.google.javascript.rhino.jstype.JSTypeRegistry.createArrowType(Node)",
    "snippet": "  ArrowType createArrowType(Node parametersNode) {\n    return new ArrowType(this, parametersNode, null);\n  }",
    "comment": " Creates an arrow type with an unknown return type.  @param parametersNode the parameters' types, formatted as a Node with param names and optionality info. ",
    "is_bug": false,
    "failing_test_cases": 5,
    "buggy_methods": 2
  },
  {
    "name": "JSTypeRegistry.createArrowType",
    "class_name": "com.google.javascript.rhino.jstype.JSTypeRegistry",
    "signature": "com.google.javascript.rhino.jstype.JSTypeRegistry.createArrowType(Node,JSType)",
    "snippet": "  ArrowType createArrowType(Node parametersNode, JSType returnType) {\n    return new ArrowType(this, parametersNode, returnType);\n  }",
    "comment": " Creates an arrow type, an abstract representation of the parameters and return value of a function.  @param parametersNode the parameters' types, formatted as a Node with param names and optionality info. @param returnType the function's return type ",
    "is_bug": false,
    "failing_test_cases": 5,
    "buggy_methods": 2
  },
  {
    "name": "JSTypeRegistry.createFunctionType",
    "class_name": "com.google.javascript.rhino.jstype.JSTypeRegistry",
    "signature": "com.google.javascript.rhino.jstype.JSTypeRegistry.createFunctionType(JSType,Node)",
    "snippet": "  public FunctionType createFunctionType(\n      JSType returnType, Node parameters) {\n    return new FunctionBuilder(this)\n        .withParamsNode(parameters)\n        .withReturnType(returnType)\n        .build();\n  }",
    "comment": " @param parameters the function's parameters or {@code null} to indicate that the parameter types are unknown. @param returnType the function's return type or {@code null} to indicate that the return type is unknown. ",
    "is_bug": false,
    "failing_test_cases": 5,
    "buggy_methods": 2
  },
  {
    "name": "JSTypeRegistry.createFunctionType",
    "class_name": "com.google.javascript.rhino.jstype.JSTypeRegistry",
    "signature": "com.google.javascript.rhino.jstype.JSTypeRegistry.createFunctionType(JSType,boolean,JSType[])",
    "snippet": "  public FunctionType createFunctionType(JSType returnType,\n      boolean lastVarArgs, JSType... parameterTypes) {\n    if (lastVarArgs) {\n      return createFunctionTypeWithVarArgs(returnType, parameterTypes);\n    } else {\n      return createFunctionType(returnType, parameterTypes);\n    }\n  }",
    "comment": " Creates a function type. @param returnType the function's return type @param lastVarArgs whether the last parameter type should be considered as an extensible var_args parameter @param parameterTypes the parameters' types ",
    "is_bug": false,
    "failing_test_cases": 5,
    "buggy_methods": 2
  },
  {
    "name": "JSTypeRegistry.createFunctionTypeWithVarArgs",
    "class_name": "com.google.javascript.rhino.jstype.JSTypeRegistry",
    "signature": "com.google.javascript.rhino.jstype.JSTypeRegistry.createFunctionTypeWithVarArgs(JSType,JSType[])",
    "snippet": "  public FunctionType createFunctionTypeWithVarArgs(\n      JSType returnType, JSType... parameterTypes) {\n    return createFunctionType(\n        returnType, createParametersWithVarArgs(parameterTypes));\n  }",
    "comment": " Creates a function type. The last parameter type of the function is considered a variable length argument.  @param returnType the function's return type @param parameterTypes the parameters' types ",
    "is_bug": false,
    "failing_test_cases": 5,
    "buggy_methods": 2
  },
  {
    "name": "JSTypeRegistry.createNullableType",
    "class_name": "com.google.javascript.rhino.jstype.JSTypeRegistry",
    "signature": "com.google.javascript.rhino.jstype.JSTypeRegistry.createNullableType(JSType)",
    "snippet": "  public JSType createNullableType(JSType type) {\n    return createUnionType(type, getNativeType(JSTypeNative.NULL_TYPE));\n  }",
    "comment": " Creates a type representing nullable values of the given type. @return the union of the type and the Null type ",
    "is_bug": false,
    "failing_test_cases": 5,
    "buggy_methods": 2
  },
  {
    "name": "JSTypeRegistry.createObjectType",
    "class_name": "com.google.javascript.rhino.jstype.JSTypeRegistry",
    "signature": "com.google.javascript.rhino.jstype.JSTypeRegistry.createObjectType(String,Node,ObjectType)",
    "snippet": "  public ObjectType createObjectType(String name, Node n,\n      ObjectType implicitPrototype) {\n    return new PrototypeObjectType(this, name, implicitPrototype);\n  }",
    "comment": " Create an object type. ",
    "is_bug": false,
    "failing_test_cases": 5,
    "buggy_methods": 2
  },
  {
    "name": "JSTypeRegistry.createOptionalParameters",
    "class_name": "com.google.javascript.rhino.jstype.JSTypeRegistry",
    "signature": "com.google.javascript.rhino.jstype.JSTypeRegistry.createOptionalParameters(JSType[])",
    "snippet": "  public Node createOptionalParameters(JSType... parameterTypes) {\n    FunctionParamBuilder builder = new FunctionParamBuilder(this);\n    builder.addOptionalParams(parameterTypes);\n    return builder.build();\n  }",
    "comment": " Creates a tree hierarchy representing a typed parameter list in which every parameter is optional. ",
    "is_bug": false,
    "failing_test_cases": 5,
    "buggy_methods": 2
  },
  {
    "name": "JSTypeRegistry.createOptionalType",
    "class_name": "com.google.javascript.rhino.jstype.JSTypeRegistry",
    "signature": "com.google.javascript.rhino.jstype.JSTypeRegistry.createOptionalType(JSType)",
    "snippet": "  public JSType createOptionalType(JSType type) {\n    if (type instanceof UnknownType || type.isAllType()) {\n      return type;\n    } else {\n      return createUnionType(type, getNativeType(JSTypeNative.VOID_TYPE));\n    }\n  }",
    "comment": " Creates a type representing optional values of the given type. @return the union of the type and the void type ",
    "is_bug": false,
    "failing_test_cases": 5,
    "buggy_methods": 2
  },
  {
    "name": "JSTypeRegistry.createParameters",
    "class_name": "com.google.javascript.rhino.jstype.JSTypeRegistry",
    "signature": "com.google.javascript.rhino.jstype.JSTypeRegistry.createParameters(boolean,JSType[])",
    "snippet": "  private Node createParameters(boolean lastVarArgs, JSType... parameterTypes) {\n    FunctionParamBuilder builder = new FunctionParamBuilder(this);\n    int max = parameterTypes.length - 1;\n    for (int i = 0; i <= max; i++) {\n      if (lastVarArgs && i == max) {\n        builder.addVarArgs(parameterTypes[i]);\n      } else {\n        builder.addRequiredParams(parameterTypes[i]);\n      }\n    }\n    return builder.build();\n  }",
    "comment": " Creates a tree hierarchy representing a typed argument list.  @param lastVarArgs whether the last type should considered as a variable length argument. @param parameterTypes the parameter types. The last element of this array is considered a variable length argument is {@code lastVarArgs} is {@code true}. @return a tree hierarchy representing a typed argument list ",
    "is_bug": false,
    "failing_test_cases": 5,
    "buggy_methods": 2
  },
  {
    "name": "JSTypeRegistry.createParametersWithVarArgs",
    "class_name": "com.google.javascript.rhino.jstype.JSTypeRegistry",
    "signature": "com.google.javascript.rhino.jstype.JSTypeRegistry.createParametersWithVarArgs(JSType[])",
    "snippet": "  public Node createParametersWithVarArgs(JSType... parameterTypes) {\n    return createParameters(true, parameterTypes);\n  }",
    "comment": " Creates a tree hierarchy representing a typed argument list. The last parameter type is considered a variable length argument.  @param parameterTypes the parameter types. The last element of this array is considered a variable length argument. @return a tree hierarchy representing a typed argument list. ",
    "is_bug": false,
    "failing_test_cases": 5,
    "buggy_methods": 2
  },
  {
    "name": "JSTypeRegistry.createUnionType",
    "class_name": "com.google.javascript.rhino.jstype.JSTypeRegistry",
    "signature": "com.google.javascript.rhino.jstype.JSTypeRegistry.createUnionType(JSType[])",
    "snippet": "  public JSType createUnionType(JSType... variants) {\n    UnionTypeBuilder builder = new UnionTypeBuilder(this);\n    for (JSType type : variants) {\n      builder.addAlternate(type);\n    }\n    return builder.build();\n  }",
    "comment": " Creates a union type whose variants are the arguments. ",
    "is_bug": false,
    "failing_test_cases": 5,
    "buggy_methods": 2
  },
  {
    "name": "JSTypeRegistry.getNativeFunctionType",
    "class_name": "com.google.javascript.rhino.jstype.JSTypeRegistry",
    "signature": "com.google.javascript.rhino.jstype.JSTypeRegistry.getNativeFunctionType(JSTypeNative)",
    "snippet": "  public FunctionType getNativeFunctionType(JSTypeNative typeId) {\n    return (FunctionType) getNativeType(typeId);\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 5,
    "buggy_methods": 2
  },
  {
    "name": "JSTypeRegistry.getNativeObjectType",
    "class_name": "com.google.javascript.rhino.jstype.JSTypeRegistry",
    "signature": "com.google.javascript.rhino.jstype.JSTypeRegistry.getNativeObjectType(JSTypeNative)",
    "snippet": "  public ObjectType getNativeObjectType(JSTypeNative typeId) {\n    return (ObjectType) getNativeType(typeId);\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 5,
    "buggy_methods": 2
  },
  {
    "name": "JSTypeRegistry.getNativeType",
    "class_name": "com.google.javascript.rhino.jstype.JSTypeRegistry",
    "signature": "com.google.javascript.rhino.jstype.JSTypeRegistry.getNativeType(JSTypeNative)",
    "snippet": "  public JSType getNativeType(JSTypeNative typeId) {\n    return nativeTypes[typeId.ordinal()];\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 5,
    "buggy_methods": 2
  },
  {
    "name": "JSTypeRegistry.initializeBuiltInTypes",
    "class_name": "com.google.javascript.rhino.jstype.JSTypeRegistry",
    "signature": "com.google.javascript.rhino.jstype.JSTypeRegistry.initializeBuiltInTypes()",
    "snippet": "  private void initializeBuiltInTypes() {\n    // These locals shouldn't be all caps.\n    BooleanType BOOLEAN_TYPE = new BooleanType(this);\n    registerNativeType(JSTypeNative.BOOLEAN_TYPE, BOOLEAN_TYPE);\n\n    NullType NULL_TYPE = new NullType(this);\n    registerNativeType(JSTypeNative.NULL_TYPE, NULL_TYPE);\n\n    NumberType NUMBER_TYPE = new NumberType(this);\n    registerNativeType(JSTypeNative.NUMBER_TYPE, NUMBER_TYPE);\n\n    StringType STRING_TYPE = new StringType(this);\n    registerNativeType(JSTypeNative.STRING_TYPE, STRING_TYPE);\n\n    UnknownType UNKNOWN_TYPE = new UnknownType(this, false);\n    registerNativeType(JSTypeNative.UNKNOWN_TYPE, UNKNOWN_TYPE);\n    registerNativeType(\n        JSTypeNative.CHECKED_UNKNOWN_TYPE, new UnknownType(this, true));\n\n    VoidType VOID_TYPE = new VoidType(this);\n    registerNativeType(JSTypeNative.VOID_TYPE, VOID_TYPE);\n\n    AllType ALL_TYPE = new AllType(this);\n    registerNativeType(JSTypeNative.ALL_TYPE, ALL_TYPE);\n\n    // Top Level Prototype (the One)\n    // The initializations of TOP_LEVEL_PROTOTYPE and OBJECT_FUNCTION_TYPE\n    // use each other's results, so at least one of them will get null\n    // instead of an actual type; however, this seems to be benign.\n    ObjectType TOP_LEVEL_PROTOTYPE =\n        new FunctionPrototypeType(this, null, null, true);\n    registerNativeType(JSTypeNative.TOP_LEVEL_PROTOTYPE, TOP_LEVEL_PROTOTYPE);\n\n    // Object\n    FunctionType OBJECT_FUNCTION_TYPE =\n        new FunctionType(this, \"Object\", null,\n            createArrowType(createOptionalParameters(ALL_TYPE), UNKNOWN_TYPE),\n            null, null, true, true);\n    OBJECT_FUNCTION_TYPE.defineDeclaredProperty(\n        \"prototype\", TOP_LEVEL_PROTOTYPE, true, null);\n    registerNativeType(JSTypeNative.OBJECT_FUNCTION_TYPE, OBJECT_FUNCTION_TYPE);\n\n    ObjectType OBJECT_PROTOTYPE = OBJECT_FUNCTION_TYPE.getPrototype();\n    registerNativeType(JSTypeNative.OBJECT_PROTOTYPE, OBJECT_PROTOTYPE);\n\n    ObjectType OBJECT_TYPE = OBJECT_FUNCTION_TYPE.getInstanceType();\n    registerNativeType(JSTypeNative.OBJECT_TYPE, OBJECT_TYPE);\n\n    // Function\n    FunctionType FUNCTION_FUNCTION_TYPE =\n        new FunctionType(this, \"Function\", null,\n            createArrowType(\n                createParametersWithVarArgs(ALL_TYPE), UNKNOWN_TYPE),\n            null, null, true, true);\n    FUNCTION_FUNCTION_TYPE.setPrototypeBasedOn(OBJECT_TYPE);\n    registerNativeType(\n        JSTypeNative.FUNCTION_FUNCTION_TYPE, FUNCTION_FUNCTION_TYPE);\n\n    ObjectType FUNCTION_PROTOTYPE = FUNCTION_FUNCTION_TYPE.getPrototype();\n    registerNativeType(JSTypeNative.FUNCTION_PROTOTYPE, FUNCTION_PROTOTYPE);\n\n    NoType NO_TYPE = new NoType(this);\n    registerNativeType(JSTypeNative.NO_TYPE, NO_TYPE);\n\n    NoObjectType NO_OBJECT_TYPE = new NoObjectType(this);\n    registerNativeType(JSTypeNative.NO_OBJECT_TYPE, NO_OBJECT_TYPE);\n\n    NoObjectType NO_RESOLVED_TYPE = new NoResolvedType(this);\n    registerNativeType(JSTypeNative.NO_RESOLVED_TYPE, NO_RESOLVED_TYPE);\n\n    // Array\n    FunctionType ARRAY_FUNCTION_TYPE =\n      new FunctionType(this, \"Array\", null,\n          createArrowType(createParametersWithVarArgs(ALL_TYPE), null),\n          null, null, true, true);\n    ARRAY_FUNCTION_TYPE.getInternalArrowType().returnType =\n        ARRAY_FUNCTION_TYPE.getInstanceType();\n\n    ObjectType arrayPrototype = ARRAY_FUNCTION_TYPE.getPrototype();\n    registerNativeType(JSTypeNative.ARRAY_FUNCTION_TYPE, ARRAY_FUNCTION_TYPE);\n\n    ObjectType ARRAY_TYPE = ARRAY_FUNCTION_TYPE.getInstanceType();\n    registerNativeType(JSTypeNative.ARRAY_TYPE, ARRAY_TYPE);\n\n    // Boolean\n    FunctionType BOOLEAN_OBJECT_FUNCTION_TYPE =\n        new FunctionType(this, \"Boolean\", null,\n            createArrowType(createParameters(false, ALL_TYPE), BOOLEAN_TYPE),\n            null, null, true, true);\n    ObjectType booleanPrototype = BOOLEAN_OBJECT_FUNCTION_TYPE.getPrototype();\n    registerNativeType(\n        JSTypeNative.BOOLEAN_OBJECT_FUNCTION_TYPE, BOOLEAN_OBJECT_FUNCTION_TYPE);\n\n    ObjectType BOOLEAN_OBJECT_TYPE =\n        BOOLEAN_OBJECT_FUNCTION_TYPE.getInstanceType();\n    registerNativeType(JSTypeNative.BOOLEAN_OBJECT_TYPE, BOOLEAN_OBJECT_TYPE);\n\n    // Date\n    FunctionType DATE_FUNCTION_TYPE =\n      new FunctionType(this, \"Date\", null,\n          createArrowType(\n              createOptionalParameters(UNKNOWN_TYPE, UNKNOWN_TYPE, UNKNOWN_TYPE,\n                  UNKNOWN_TYPE, UNKNOWN_TYPE, UNKNOWN_TYPE, UNKNOWN_TYPE),\n              STRING_TYPE),\n          null, null, true, true);\n    ObjectType datePrototype = DATE_FUNCTION_TYPE.getPrototype();\n    registerNativeType(JSTypeNative.DATE_FUNCTION_TYPE, DATE_FUNCTION_TYPE);\n\n    ObjectType DATE_TYPE = DATE_FUNCTION_TYPE.getInstanceType();\n    registerNativeType(JSTypeNative.DATE_TYPE, DATE_TYPE);\n\n    // Error\n    FunctionType ERROR_FUNCTION_TYPE = new ErrorFunctionType(this, \"Error\");\n    registerNativeType(JSTypeNative.ERROR_FUNCTION_TYPE, ERROR_FUNCTION_TYPE);\n\n    ObjectType ERROR_TYPE = ERROR_FUNCTION_TYPE.getInstanceType();\n    registerNativeType(JSTypeNative.ERROR_TYPE, ERROR_TYPE);\n\n    // EvalError\n    FunctionType EVAL_ERROR_FUNCTION_TYPE =\n        new ErrorFunctionType(this, \"EvalError\");\n    EVAL_ERROR_FUNCTION_TYPE.setPrototypeBasedOn(ERROR_TYPE);\n    registerNativeType(\n        JSTypeNative.EVAL_ERROR_FUNCTION_TYPE, EVAL_ERROR_FUNCTION_TYPE);\n\n    ObjectType EVAL_ERROR_TYPE = EVAL_ERROR_FUNCTION_TYPE.getInstanceType();\n    registerNativeType(JSTypeNative.EVAL_ERROR_TYPE, EVAL_ERROR_TYPE);\n\n    // RangeError\n    FunctionType RANGE_ERROR_FUNCTION_TYPE =\n        new ErrorFunctionType(this, \"RangeError\");\n    RANGE_ERROR_FUNCTION_TYPE.setPrototypeBasedOn(ERROR_TYPE);\n    registerNativeType(\n        JSTypeNative.RANGE_ERROR_FUNCTION_TYPE, RANGE_ERROR_FUNCTION_TYPE);\n\n    ObjectType RANGE_ERROR_TYPE = RANGE_ERROR_FUNCTION_TYPE.getInstanceType();\n    registerNativeType(JSTypeNative.RANGE_ERROR_TYPE, RANGE_ERROR_TYPE);\n\n    // ReferenceError\n    FunctionType REFERENCE_ERROR_FUNCTION_TYPE =\n        new ErrorFunctionType(this, \"ReferenceError\");\n    REFERENCE_ERROR_FUNCTION_TYPE.setPrototypeBasedOn(ERROR_TYPE);\n    registerNativeType(\n        JSTypeNative.REFERENCE_ERROR_FUNCTION_TYPE, REFERENCE_ERROR_FUNCTION_TYPE);\n\n    ObjectType REFERENCE_ERROR_TYPE =\n        REFERENCE_ERROR_FUNCTION_TYPE.getInstanceType();\n    registerNativeType(JSTypeNative.REFERENCE_ERROR_TYPE, REFERENCE_ERROR_TYPE);\n\n    // SyntaxError\n    FunctionType SYNTAX_ERROR_FUNCTION_TYPE =\n        new ErrorFunctionType(this, \"SyntaxError\");\n    SYNTAX_ERROR_FUNCTION_TYPE.setPrototypeBasedOn(ERROR_TYPE);\n    registerNativeType(\n        JSTypeNative.SYNTAX_ERROR_FUNCTION_TYPE, SYNTAX_ERROR_FUNCTION_TYPE);\n\n    ObjectType SYNTAX_ERROR_TYPE = SYNTAX_ERROR_FUNCTION_TYPE.getInstanceType();\n    registerNativeType(JSTypeNative.SYNTAX_ERROR_TYPE, SYNTAX_ERROR_TYPE);\n\n    // TypeError\n    FunctionType TYPE_ERROR_FUNCTION_TYPE =\n        new ErrorFunctionType(this, \"TypeError\");\n    TYPE_ERROR_FUNCTION_TYPE.setPrototypeBasedOn(ERROR_TYPE);\n    registerNativeType(\n        JSTypeNative.TYPE_ERROR_FUNCTION_TYPE, TYPE_ERROR_FUNCTION_TYPE);\n\n    ObjectType TYPE_ERROR_TYPE = TYPE_ERROR_FUNCTION_TYPE.getInstanceType();\n    registerNativeType(JSTypeNative.TYPE_ERROR_TYPE, TYPE_ERROR_TYPE);\n\n    // URIError\n    FunctionType URI_ERROR_FUNCTION_TYPE =\n        new ErrorFunctionType(this, \"URIError\");\n    URI_ERROR_FUNCTION_TYPE.setPrototypeBasedOn(ERROR_TYPE);\n    registerNativeType(\n        JSTypeNative.URI_ERROR_FUNCTION_TYPE, URI_ERROR_FUNCTION_TYPE);\n\n    ObjectType URI_ERROR_TYPE = URI_ERROR_FUNCTION_TYPE.getInstanceType();\n    registerNativeType(JSTypeNative.URI_ERROR_TYPE, URI_ERROR_TYPE);\n\n    // Number\n    FunctionType NUMBER_OBJECT_FUNCTION_TYPE =\n        new FunctionType(this, \"Number\", null,\n            createArrowType(createParameters(false, ALL_TYPE), NUMBER_TYPE),\n            null, null, true, true);\n    ObjectType numberPrototype = NUMBER_OBJECT_FUNCTION_TYPE.getPrototype();\n    registerNativeType(\n        JSTypeNative.NUMBER_OBJECT_FUNCTION_TYPE, NUMBER_OBJECT_FUNCTION_TYPE);\n\n    ObjectType NUMBER_OBJECT_TYPE =\n        NUMBER_OBJECT_FUNCTION_TYPE.getInstanceType();\n    registerNativeType(JSTypeNative.NUMBER_OBJECT_TYPE, NUMBER_OBJECT_TYPE);\n\n    // RegExp\n    FunctionType REGEXP_FUNCTION_TYPE =\n      new FunctionType(this, \"RegExp\", null,\n          createArrowType(createOptionalParameters(ALL_TYPE, ALL_TYPE)),\n          null, null, true, true);\n    REGEXP_FUNCTION_TYPE.getInternalArrowType().returnType =\n        REGEXP_FUNCTION_TYPE.getInstanceType();\n\n    ObjectType regexpPrototype = REGEXP_FUNCTION_TYPE.getPrototype();\n    registerNativeType(JSTypeNative.REGEXP_FUNCTION_TYPE, REGEXP_FUNCTION_TYPE);\n\n    ObjectType REGEXP_TYPE = REGEXP_FUNCTION_TYPE.getInstanceType();\n    registerNativeType(JSTypeNative.REGEXP_TYPE, REGEXP_TYPE);\n\n    // String\n    FunctionType STRING_OBJECT_FUNCTION_TYPE =\n        new FunctionType(this, \"String\", null,\n            createArrowType(createParameters(false, ALL_TYPE), STRING_TYPE),\n            null, null, true, true);\n    ObjectType stringPrototype = STRING_OBJECT_FUNCTION_TYPE.getPrototype();\n    registerNativeType(\n        JSTypeNative.STRING_OBJECT_FUNCTION_TYPE, STRING_OBJECT_FUNCTION_TYPE);\n\n    ObjectType STRING_OBJECT_TYPE =\n        STRING_OBJECT_FUNCTION_TYPE.getInstanceType();\n    registerNativeType(\n        JSTypeNative.STRING_OBJECT_TYPE, STRING_OBJECT_TYPE);\n\n    // (Object,string,number)\n    JSType OBJECT_NUMBER_STRING =\n        createUnionType(OBJECT_TYPE, NUMBER_TYPE, STRING_TYPE);\n    registerNativeType(JSTypeNative.OBJECT_NUMBER_STRING, OBJECT_NUMBER_STRING);\n\n    // (Object,string,number,boolean)\n    JSType OBJECT_NUMBER_STRING_BOOLEAN =\n        createUnionType(OBJECT_TYPE, NUMBER_TYPE, STRING_TYPE, BOOLEAN_TYPE);\n    registerNativeType(JSTypeNative.OBJECT_NUMBER_STRING_BOOLEAN,\n        OBJECT_NUMBER_STRING_BOOLEAN);\n\n    // (string,number,boolean)\n    JSType NUMBER_STRING_BOOLEAN =\n        createUnionType(NUMBER_TYPE, STRING_TYPE, BOOLEAN_TYPE);\n    registerNativeType(JSTypeNative.NUMBER_STRING_BOOLEAN,\n        NUMBER_STRING_BOOLEAN);\n\n    // (string,number)\n    JSType NUMBER_STRING = createUnionType(NUMBER_TYPE, STRING_TYPE);\n    registerNativeType(JSTypeNative.NUMBER_STRING, NUMBER_STRING);\n\n    // Native object properties are filled in by externs...\n\n    // (String, string)\n    JSType STRING_VALUE_OR_OBJECT_TYPE =\n        createUnionType(STRING_OBJECT_TYPE, STRING_TYPE);\n    registerNativeType(\n        JSTypeNative.STRING_VALUE_OR_OBJECT_TYPE, STRING_VALUE_OR_OBJECT_TYPE);\n\n    // (Number, number)\n    JSType NUMBER_VALUE_OR_OBJECT_TYPE =\n        createUnionType(NUMBER_OBJECT_TYPE, NUMBER_TYPE);\n    registerNativeType(\n        JSTypeNative.NUMBER_VALUE_OR_OBJECT_TYPE, NUMBER_VALUE_OR_OBJECT_TYPE);\n\n    // unknown function type, i.e. (?...) -> ?\n    FunctionType U2U_FUNCTION_TYPE =\n        createFunctionType(UNKNOWN_TYPE, true, UNKNOWN_TYPE);\n    registerNativeType(JSTypeNative.U2U_FUNCTION_TYPE, U2U_FUNCTION_TYPE);\n\n    // unknown constructor type, i.e. (?...) -> ? with the NoObject type\n    // as instance type\n    FunctionType U2U_CONSTRUCTOR_TYPE =\n        // This is equivalent to\n        // createConstructorType(UNKNOWN_TYPE, true, UNKNOWN_TYPE), but,\n        // in addition, overrides getInstanceType() to return the NoObject type\n        // instead of a new anonymous object.\n        new FunctionType(this, \"Function\", null,\n            createArrowType(\n                createParametersWithVarArgs(UNKNOWN_TYPE),\n                UNKNOWN_TYPE),\n            NO_OBJECT_TYPE, null, true, true) {\n          private static final long serialVersionUID = 1L;\n\n          @Override public FunctionType getConstructor() {\n            return registry.getNativeFunctionType(\n                JSTypeNative.FUNCTION_FUNCTION_TYPE);\n          }\n        };\n\n    // The U2U_CONSTRUCTOR is weird, because it's the supertype of its\n    // own constructor.\n    registerNativeType(JSTypeNative.U2U_CONSTRUCTOR_TYPE, U2U_CONSTRUCTOR_TYPE);\n    registerNativeType(\n        JSTypeNative.FUNCTION_INSTANCE_TYPE, U2U_CONSTRUCTOR_TYPE);\n\n    FUNCTION_FUNCTION_TYPE.setInstanceType(U2U_CONSTRUCTOR_TYPE);\n    U2U_CONSTRUCTOR_TYPE.setImplicitPrototype(FUNCTION_PROTOTYPE);\n\n    // least function type, i.e. (All...) -> NoType\n    FunctionType LEAST_FUNCTION_TYPE =\n        createFunctionType(NO_TYPE, true, ALL_TYPE);\n    registerNativeType(JSTypeNative.LEAST_FUNCTION_TYPE, LEAST_FUNCTION_TYPE);\n\n    // the 'this' object in the global scope\n    ObjectType GLOBAL_THIS = createObjectType(\"global this\", null,\n        UNKNOWN_TYPE /* to be resolved later */);\n    registerNativeType(JSTypeNative.GLOBAL_THIS, GLOBAL_THIS);\n\n    // greatest function type, i.e. (NoType...) -> All\n    FunctionType GREATEST_FUNCTION_TYPE =\n      createFunctionType(ALL_TYPE, true, NO_TYPE);\n    registerNativeType(JSTypeNative.GREATEST_FUNCTION_TYPE,\n        GREATEST_FUNCTION_TYPE);\n\n    // Register the prototype property. See the comments below in\n    // registerPropertyOnType about the bootstrapping process.\n    registerPropertyOnType(\"prototype\", OBJECT_FUNCTION_TYPE);\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 5,
    "buggy_methods": 2
  },
  {
    "name": "JSTypeRegistry.initializeRegistry",
    "class_name": "com.google.javascript.rhino.jstype.JSTypeRegistry",
    "signature": "com.google.javascript.rhino.jstype.JSTypeRegistry.initializeRegistry()",
    "snippet": "  private void initializeRegistry() {\n    register(getNativeType(JSTypeNative.ARRAY_TYPE));\n    register(getNativeType(JSTypeNative.BOOLEAN_OBJECT_TYPE));\n    register(getNativeType(JSTypeNative.BOOLEAN_TYPE));\n    register(getNativeType(JSTypeNative.DATE_TYPE));\n    register(getNativeType(JSTypeNative.NULL_TYPE));\n    register(getNativeType(JSTypeNative.NULL_TYPE), \"Null\");\n    register(getNativeType(JSTypeNative.NUMBER_OBJECT_TYPE));\n    register(getNativeType(JSTypeNative.NUMBER_TYPE));\n    register(getNativeType(JSTypeNative.OBJECT_TYPE));\n    register(getNativeType(JSTypeNative.ERROR_TYPE));\n    register(getNativeType(JSTypeNative.URI_ERROR_TYPE));\n    register(getNativeType(JSTypeNative.EVAL_ERROR_TYPE));\n    register(getNativeType(JSTypeNative.TYPE_ERROR_TYPE));\n    register(getNativeType(JSTypeNative.RANGE_ERROR_TYPE));\n    register(getNativeType(JSTypeNative.REFERENCE_ERROR_TYPE));\n    register(getNativeType(JSTypeNative.SYNTAX_ERROR_TYPE));\n    register(getNativeType(JSTypeNative.REGEXP_TYPE));\n    register(getNativeType(JSTypeNative.STRING_OBJECT_TYPE));\n    register(getNativeType(JSTypeNative.STRING_TYPE));\n    register(getNativeType(JSTypeNative.VOID_TYPE));\n    register(getNativeType(JSTypeNative.VOID_TYPE), \"Undefined\");\n    register(getNativeType(JSTypeNative.VOID_TYPE), \"void\");\n    register(getNativeType(JSTypeNative.FUNCTION_INSTANCE_TYPE), \"Function\");\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 5,
    "buggy_methods": 2
  },
  {
    "name": "JSTypeRegistry.register",
    "class_name": "com.google.javascript.rhino.jstype.JSTypeRegistry",
    "signature": "com.google.javascript.rhino.jstype.JSTypeRegistry.register(JSType)",
    "snippet": "  private void register(JSType type) {\n    register(type, type.toString());\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 5,
    "buggy_methods": 2
  },
  {
    "name": "JSTypeRegistry.register",
    "class_name": "com.google.javascript.rhino.jstype.JSTypeRegistry",
    "signature": "com.google.javascript.rhino.jstype.JSTypeRegistry.register(JSType,String)",
    "snippet": "  private void register(JSType type, String name) {\n    namesToTypes.put(name, type);\n\n    // Add all the namespaces in which this name lives.\n    while (name.indexOf('.') > 0) {\n      name = name.substring(0, name.lastIndexOf('.'));\n      namespaces.add(name);\n    }\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 5,
    "buggy_methods": 2
  },
  {
    "name": "JSTypeRegistry.registerNativeType",
    "class_name": "com.google.javascript.rhino.jstype.JSTypeRegistry",
    "signature": "com.google.javascript.rhino.jstype.JSTypeRegistry.registerNativeType(JSTypeNative,JSType)",
    "snippet": "  private void registerNativeType(JSTypeNative typeId, JSType type) {\n    nativeTypes[typeId.ordinal()] = type;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 5,
    "buggy_methods": 2
  },
  {
    "name": "JSTypeRegistry.registerPropertyOnType",
    "class_name": "com.google.javascript.rhino.jstype.JSTypeRegistry",
    "signature": "com.google.javascript.rhino.jstype.JSTypeRegistry.registerPropertyOnType(String,JSType)",
    "snippet": "  public void registerPropertyOnType(String propertyName, JSType type) {\n    UnionTypeBuilder typeSet = typesIndexedByProperty.get(propertyName);\n    if (typeSet == null) {\n      typeSet = new UnionTypeBuilder(this);\n      typesIndexedByProperty.put(propertyName, typeSet);\n    }\n\n    typeSet.addAlternate(type);\n    addReferenceTypeIndexedByProperty(propertyName, type);\n\n    // Clear cached values that depend on typesIndexedByProperty.\n    greatestSubtypeByProperty.remove(propertyName);\n  }",
    "comment": " Tells the type system that {@code owner} may have a property named {@code propertyName}. This allows the registry to keep track of what types a property is defined upon.  This is NOT the same as saying that {@code owner} must have a property named type. ObjectType#hasProperty attempts to minimize false positives (\"if we're not sure, then don't type check this property\"). The type registry, on the other hand, should attempt to minimize false negatives (\"if this property is assigned anywhere in the program, it must show up in the type registry\"). ",
    "is_bug": false,
    "failing_test_cases": 5,
    "buggy_methods": 2
  },
  {
    "name": "JSTypeRegistry.resetForTypeCheck",
    "class_name": "com.google.javascript.rhino.jstype.JSTypeRegistry",
    "signature": "com.google.javascript.rhino.jstype.JSTypeRegistry.resetForTypeCheck()",
    "snippet": "  public void resetForTypeCheck() {\n    typesIndexedByProperty.clear();\n    eachRefTypeIndexedByProperty.clear();\n    initializeBuiltInTypes();\n    namesToTypes.clear();\n    namespaces.clear();\n    initializeRegistry();\n  }",
    "comment": " Reset to run the TypeCheck pass. ",
    "is_bug": false,
    "failing_test_cases": 5,
    "buggy_methods": 2
  },
  {
    "name": "NoObjectType.NoObjectType",
    "class_name": "com.google.javascript.rhino.jstype.NoObjectType",
    "signature": "com.google.javascript.rhino.jstype.NoObjectType.NoObjectType(JSTypeRegistry)",
    "snippet": "  NoObjectType(JSTypeRegistry registry) {\n    super(registry, null, null,\n          registry.createArrowType(null, null),\n          null, null, true, true);\n    getInternalArrowType().returnType = this;\n    this.setInstanceType(this);\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 5,
    "buggy_methods": 2
  },
  {
    "name": "NoResolvedType.NoResolvedType",
    "class_name": "com.google.javascript.rhino.jstype.NoResolvedType",
    "signature": "com.google.javascript.rhino.jstype.NoResolvedType.NoResolvedType(JSTypeRegistry)",
    "snippet": "  NoResolvedType(JSTypeRegistry registry) {\n    super(registry);\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 5,
    "buggy_methods": 2
  },
  {
    "name": "NoType.NoType",
    "class_name": "com.google.javascript.rhino.jstype.NoType",
    "signature": "com.google.javascript.rhino.jstype.NoType.NoType(JSTypeRegistry)",
    "snippet": "  NoType(JSTypeRegistry registry) {\n    super(registry);\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 5,
    "buggy_methods": 2
  },
  {
    "name": "NoType.isNoType",
    "class_name": "com.google.javascript.rhino.jstype.NoType",
    "signature": "com.google.javascript.rhino.jstype.NoType.isNoType()",
    "snippet": "  @Override\n  public boolean isNoType() {\n    return true;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 5,
    "buggy_methods": 2
  },
  {
    "name": "NullType.NullType",
    "class_name": "com.google.javascript.rhino.jstype.NullType",
    "signature": "com.google.javascript.rhino.jstype.NullType.NullType(JSTypeRegistry)",
    "snippet": "  NullType(JSTypeRegistry registry) {\n    super(registry);\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 5,
    "buggy_methods": 2
  },
  {
    "name": "NullType.getDisplayName",
    "class_name": "com.google.javascript.rhino.jstype.NullType",
    "signature": "com.google.javascript.rhino.jstype.NullType.getDisplayName()",
    "snippet": "  @Override\n  public String getDisplayName() {\n    return \"null\";\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 5,
    "buggy_methods": 2
  },
  {
    "name": "NullType.toString",
    "class_name": "com.google.javascript.rhino.jstype.NullType",
    "signature": "com.google.javascript.rhino.jstype.NullType.toString()",
    "snippet": "  @Override\n  public String toString() {\n    return getDisplayName();\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 5,
    "buggy_methods": 2
  },
  {
    "name": "NumberType.NumberType",
    "class_name": "com.google.javascript.rhino.jstype.NumberType",
    "signature": "com.google.javascript.rhino.jstype.NumberType.NumberType(JSTypeRegistry)",
    "snippet": "  NumberType(JSTypeRegistry registry) {\n    super(registry);\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 5,
    "buggy_methods": 2
  },
  {
    "name": "NumberType.getDisplayName",
    "class_name": "com.google.javascript.rhino.jstype.NumberType",
    "signature": "com.google.javascript.rhino.jstype.NumberType.getDisplayName()",
    "snippet": "  @Override\n  public String getDisplayName() {\n    return \"number\";\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 5,
    "buggy_methods": 2
  },
  {
    "name": "NumberType.toString",
    "class_name": "com.google.javascript.rhino.jstype.NumberType",
    "signature": "com.google.javascript.rhino.jstype.NumberType.toString()",
    "snippet": "  @Override\n  public String toString() {\n    return getDisplayName();\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 5,
    "buggy_methods": 2
  },
  {
    "name": "ObjectType.ObjectType",
    "class_name": "com.google.javascript.rhino.jstype.ObjectType",
    "signature": "com.google.javascript.rhino.jstype.ObjectType.ObjectType(JSTypeRegistry)",
    "snippet": "  ObjectType(JSTypeRegistry registry) {\n    super(registry);\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 5,
    "buggy_methods": 2
  },
  {
    "name": "ObjectType.cast",
    "class_name": "com.google.javascript.rhino.jstype.ObjectType",
    "signature": "com.google.javascript.rhino.jstype.ObjectType.cast(JSType)",
    "snippet": "  public static ObjectType cast(JSType type) {\n    return type == null ? null : type.toObjectType();\n  }",
    "comment": " A null-safe version of JSType#toObjectType. ",
    "is_bug": false,
    "failing_test_cases": 5,
    "buggy_methods": 2
  },
  {
    "name": "ObjectType.clearCachedValues",
    "class_name": "com.google.javascript.rhino.jstype.ObjectType",
    "signature": "com.google.javascript.rhino.jstype.ObjectType.clearCachedValues()",
    "snippet": "  void clearCachedValues() {\n    unknown = true;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 5,
    "buggy_methods": 2
  },
  {
    "name": "ObjectType.createDelegateSuffix",
    "class_name": "com.google.javascript.rhino.jstype.ObjectType",
    "signature": "com.google.javascript.rhino.jstype.ObjectType.createDelegateSuffix(String)",
    "snippet": "  public static String createDelegateSuffix(String suffix) {\n    return \"(\" + suffix + \")\";\n  }",
    "comment": " Creates a suffix for a proxy delegate. @see #getNormalizedReferenceName ",
    "is_bug": false,
    "failing_test_cases": 5,
    "buggy_methods": 2
  },
  {
    "name": "ObjectType.defineDeclaredProperty",
    "class_name": "com.google.javascript.rhino.jstype.ObjectType",
    "signature": "com.google.javascript.rhino.jstype.ObjectType.defineDeclaredProperty(String,JSType,boolean,Node)",
    "snippet": "  public final boolean defineDeclaredProperty(String propertyName,\n      JSType type, boolean inExterns, Node propertyNode) {\n    boolean result = defineProperty(propertyName, type, false, inExterns,\n        propertyNode);\n\n    // All property definitions go through this method\n    // or defineDeclaredProperty. Because the properties defined an an\n    // object can affect subtyping, it's slightly more efficient\n    // to register this after defining the property.\n    registry.registerPropertyOnType(propertyName, this);\n\n    return result;\n  }",
    "comment": " Defines a property whose type is synthesized (i.e. not inferred). @param propertyName the property's name @param type the type @param inExterns {@code true} if this property was defined in an externs file. TightenTypes assumes that any function passed to an externs property could be called, so setting this incorrectly could result in live code being removed. @param propertyNode the node corresponding to the declaration of property which might later be accessed using {@code getPropertyNode}. ",
    "is_bug": false,
    "failing_test_cases": 5,
    "buggy_methods": 2
  },
  {
    "name": "ObjectType.hasCachedValues",
    "class_name": "com.google.javascript.rhino.jstype.ObjectType",
    "signature": "com.google.javascript.rhino.jstype.ObjectType.hasCachedValues()",
    "snippet": "  public boolean hasCachedValues() {\n    return !unknown;\n  }",
    "comment": " Returns true if any cached valeus have been set for this type.  If true, then the prototype chain should not be changed, as it might invalidate the cached values. ",
    "is_bug": false,
    "failing_test_cases": 5,
    "buggy_methods": 2
  },
  {
    "name": "ObjectType.hasOwnDeclaredProperty",
    "class_name": "com.google.javascript.rhino.jstype.ObjectType",
    "signature": "com.google.javascript.rhino.jstype.ObjectType.hasOwnDeclaredProperty(String)",
    "snippet": "  boolean hasOwnDeclaredProperty(String name) {\n    return hasOwnProperty(name) && isPropertyTypeDeclared(name);\n  }",
    "comment": " Whether the given property is declared on this object. ",
    "is_bug": false,
    "failing_test_cases": 5,
    "buggy_methods": 2
  },
  {
    "name": "ObjectType.isImplicitPrototype",
    "class_name": "com.google.javascript.rhino.jstype.ObjectType",
    "signature": "com.google.javascript.rhino.jstype.ObjectType.isImplicitPrototype(ObjectType)",
    "snippet": "  final boolean isImplicitPrototype(ObjectType prototype) {\n    for (ObjectType current = this;\n         current != null;\n         current = current.getImplicitPrototype()) {\n      if (current.isEquivalentTo(prototype)) {\n        return true;\n      }\n    }\n    return false;\n  }",
    "comment": " Checks that the prototype is an implicit prototype of this object. Since each object has an implicit prototype, an implicit prototype's implicit prototype is also this implicit prototype's.  @param prototype any prototype based object  @return {@code true} if {@code prototype} is {@code equal} to any object in this object's implicit prototype chain. ",
    "is_bug": false,
    "failing_test_cases": 5,
    "buggy_methods": 2
  },
  {
    "name": "ObjectType.isUnknownType",
    "class_name": "com.google.javascript.rhino.jstype.ObjectType",
    "signature": "com.google.javascript.rhino.jstype.ObjectType.isUnknownType()",
    "snippet": "  @Override\n  public boolean isUnknownType() {\n    // If the object is unknown now, check the supertype again,\n    // because it might have been resolved since the last check.\n    if (unknown) {\n      ObjectType implicitProto = getImplicitPrototype();\n      if (implicitProto == null ||\n          implicitProto.isNativeObjectType()) {\n        unknown = false;\n      } else {\n        unknown = implicitProto.isUnknownType();\n      }\n    }\n    return unknown;\n  }",
    "comment": " We treat this as the unknown type if any of its implicit prototype properties is unknown. ",
    "is_bug": false,
    "failing_test_cases": 5,
    "buggy_methods": 2
  },
  {
    "name": "PrototypeObjectType.PrototypeObjectType",
    "class_name": "com.google.javascript.rhino.jstype.PrototypeObjectType",
    "signature": "com.google.javascript.rhino.jstype.PrototypeObjectType.PrototypeObjectType(JSTypeRegistry,String,ObjectType)",
    "snippet": "  PrototypeObjectType(JSTypeRegistry registry, String className,\n      ObjectType implicitPrototype) {\n    this(registry, className, implicitPrototype, false);\n  }",
    "comment": " Creates an object type.  @param className the name of the class.  May be {@code null} to denote an anonymous class.  @param implicitPrototype the implicit prototype (a.k.a. {@code [[Prototype]]}) as defined by ECMA-262. If the implicit prototype is {@code null} the implicit prototype will be set to the {@link JSTypeNative#OBJECT_TYPE}. ",
    "is_bug": false,
    "failing_test_cases": 5,
    "buggy_methods": 2
  },
  {
    "name": "PrototypeObjectType.PrototypeObjectType",
    "class_name": "com.google.javascript.rhino.jstype.PrototypeObjectType",
    "signature": "com.google.javascript.rhino.jstype.PrototypeObjectType.PrototypeObjectType(JSTypeRegistry,String,ObjectType,boolean)",
    "snippet": "  PrototypeObjectType(JSTypeRegistry registry, String className,\n      ObjectType implicitPrototype, boolean nativeType) {\n    super(registry);\n    this.properties = Maps.newTreeMap();\n    this.className = className;\n    this.nativeType = nativeType;\n    if (nativeType || implicitPrototype != null) {\n      setImplicitPrototype(implicitPrototype);\n    } else {\n      setImplicitPrototype(\n          registry.getNativeObjectType(JSTypeNative.OBJECT_TYPE));\n    }\n  }",
    "comment": " Creates an object type, allowing specification of the implicit prototype when creating native objects. ",
    "is_bug": false,
    "failing_test_cases": 5,
    "buggy_methods": 2
  },
  {
    "name": "PrototypeObjectType.defineProperty",
    "class_name": "com.google.javascript.rhino.jstype.PrototypeObjectType",
    "signature": "com.google.javascript.rhino.jstype.PrototypeObjectType.defineProperty(String,JSType,boolean,boolean,Node)",
    "snippet": "  @Override\n  boolean defineProperty(String name, JSType type, boolean inferred,\n      boolean inExterns, Node propertyNode) {\n    if (hasOwnDeclaredProperty(name)) {\n      return false;\n    }\n    properties.put(name, new Property(type, inferred, inExterns, propertyNode));\n    return true;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 5,
    "buggy_methods": 2
  },
  {
    "name": "PrototypeObjectType.getConstructor",
    "class_name": "com.google.javascript.rhino.jstype.PrototypeObjectType",
    "signature": "com.google.javascript.rhino.jstype.PrototypeObjectType.getConstructor()",
    "snippet": "  @Override\n  public FunctionType getConstructor() {\n    return null;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 5,
    "buggy_methods": 2
  },
  {
    "name": "PrototypeObjectType.getImplicitPrototype",
    "class_name": "com.google.javascript.rhino.jstype.PrototypeObjectType",
    "signature": "com.google.javascript.rhino.jstype.PrototypeObjectType.getImplicitPrototype()",
    "snippet": "  @Override\n  public ObjectType getImplicitPrototype() {\n    return implicitPrototypeFallback;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 5,
    "buggy_methods": 2
  },
  {
    "name": "PrototypeObjectType.getReferenceName",
    "class_name": "com.google.javascript.rhino.jstype.PrototypeObjectType",
    "signature": "com.google.javascript.rhino.jstype.PrototypeObjectType.getReferenceName()",
    "snippet": "  @Override\n  public String getReferenceName() {\n    if (className != null) {\n      return className;\n    } else {\n      return null;\n    }\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 5,
    "buggy_methods": 2
  },
  {
    "name": "PrototypeObjectType.hasCachedValues",
    "class_name": "com.google.javascript.rhino.jstype.PrototypeObjectType",
    "signature": "com.google.javascript.rhino.jstype.PrototypeObjectType.hasCachedValues()",
    "snippet": "  @Override\n  public boolean hasCachedValues() {\n    return super.hasCachedValues();\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 5,
    "buggy_methods": 2
  },
  {
    "name": "PrototypeObjectType.hasOwnProperty",
    "class_name": "com.google.javascript.rhino.jstype.PrototypeObjectType",
    "signature": "com.google.javascript.rhino.jstype.PrototypeObjectType.hasOwnProperty(String)",
    "snippet": "  @Override\n  public boolean hasOwnProperty(String propertyName) {\n    return properties.get(propertyName) != null;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 5,
    "buggy_methods": 2
  },
  {
    "name": "PrototypeObjectType.hasReferenceName",
    "class_name": "com.google.javascript.rhino.jstype.PrototypeObjectType",
    "signature": "com.google.javascript.rhino.jstype.PrototypeObjectType.hasReferenceName()",
    "snippet": "  @Override\n  public boolean hasReferenceName() {\n    return className != null;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 5,
    "buggy_methods": 2
  },
  {
    "name": "PrototypeObjectType.implicitPrototypeChainIsUnknown",
    "class_name": "com.google.javascript.rhino.jstype.PrototypeObjectType",
    "signature": "com.google.javascript.rhino.jstype.PrototypeObjectType.implicitPrototypeChainIsUnknown()",
    "snippet": "  private boolean implicitPrototypeChainIsUnknown() {\n    ObjectType p = getImplicitPrototype();\n    while (p != null) {\n      if (p.isUnknownType()) {\n        return true;\n      }\n      p = p.getImplicitPrototype();\n    }\n    return false;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 5,
    "buggy_methods": 2
  },
  {
    "name": "PrototypeObjectType.isNativeObjectType",
    "class_name": "com.google.javascript.rhino.jstype.PrototypeObjectType",
    "signature": "com.google.javascript.rhino.jstype.PrototypeObjectType.isNativeObjectType()",
    "snippet": "  @Override\n  public boolean isNativeObjectType() {\n    return nativeType;\n  }",
    "comment": "Whether this is a built-in object. */",
    "is_bug": false,
    "failing_test_cases": 5,
    "buggy_methods": 2
  },
  {
    "name": "PrototypeObjectType.isSubtype",
    "class_name": "com.google.javascript.rhino.jstype.PrototypeObjectType",
    "signature": "com.google.javascript.rhino.jstype.PrototypeObjectType.isSubtype(JSType)",
    "snippet": "  @Override\n  public boolean isSubtype(JSType that) {\n    if (JSType.isSubtype(this, that)) {\n      return true;\n    }\n\n    // Union types\n    if (that instanceof UnionType) {\n      // The static {@code JSType.isSubtype} check already decomposed\n      // union types, so we don't need to check those again.\n      return false;\n    }\n\n    // record types\n    if (that instanceof RecordType) {\n      return RecordType.isSubtype(this, (RecordType) that);\n    }\n\n    // Interfaces\n    // Find all the interfaces implemented by this class and compare each one\n    // to the interface instance.\n    ObjectType thatObj = that.toObjectType();\n    ObjectType thatCtor = thatObj == null ? null : thatObj.getConstructor();\n    if (thatCtor != null && thatCtor.isInterface()) {\n      Iterable<ObjectType> thisInterfaces = getCtorImplementedInterfaces();\n      for (ObjectType thisInterface : thisInterfaces) {\n        if (thisInterface.isSubtype(that)) {\n          return true;\n        }\n      }\n    }\n\n    // other prototype based objects\n    if (that != null) {\n      if (isUnknownType() || implicitPrototypeChainIsUnknown()) {\n        // If unsure, say 'yes', to avoid spurious warnings.\n        // TODO(user): resolve the prototype chain completely in all cases,\n        // to avoid guessing.\n        return true;\n      }\n      return this.isImplicitPrototype(thatObj);\n    }\n\n    return false;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 5,
    "buggy_methods": 2
  },
  {
    "name": "PrototypeObjectType.setImplicitPrototype",
    "class_name": "com.google.javascript.rhino.jstype.PrototypeObjectType",
    "signature": "com.google.javascript.rhino.jstype.PrototypeObjectType.setImplicitPrototype(ObjectType)",
    "snippet": "  final void setImplicitPrototype(ObjectType implicitPrototype) {\n    checkState(!hasCachedValues());\n    this.implicitPrototypeFallback = implicitPrototype;\n  }",
    "comment": " This should only be reset on the FunctionPrototypeType, only to fix an incorrectly established prototype chain due to the user having a mismatch in super class declaration, and only before properties on that type are processed. ",
    "is_bug": false,
    "failing_test_cases": 5,
    "buggy_methods": 2
  },
  {
    "name": "StringType.StringType",
    "class_name": "com.google.javascript.rhino.jstype.StringType",
    "signature": "com.google.javascript.rhino.jstype.StringType.StringType(JSTypeRegistry)",
    "snippet": "  StringType(JSTypeRegistry registry) {\n    super(registry);\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 5,
    "buggy_methods": 2
  },
  {
    "name": "StringType.getDisplayName",
    "class_name": "com.google.javascript.rhino.jstype.StringType",
    "signature": "com.google.javascript.rhino.jstype.StringType.getDisplayName()",
    "snippet": "  @Override\n  public String getDisplayName() {\n    return \"string\";\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 5,
    "buggy_methods": 2
  },
  {
    "name": "StringType.toString",
    "class_name": "com.google.javascript.rhino.jstype.StringType",
    "signature": "com.google.javascript.rhino.jstype.StringType.toString()",
    "snippet": "  @Override\n  public String toString() {\n    return getDisplayName();\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 5,
    "buggy_methods": 2
  },
  {
    "name": "UnionType.UnionType",
    "class_name": "com.google.javascript.rhino.jstype.UnionType",
    "signature": "com.google.javascript.rhino.jstype.UnionType.UnionType(JSTypeRegistry,Collection)",
    "snippet": "  UnionType(JSTypeRegistry registry, Collection<JSType> alternates) {\n    super(registry);\n    this.alternates = alternates;\n    this.hashcode = this.alternates.hashCode();\n  }",
    "comment": " Creates a union type.  @param alternates the alternates of the union ",
    "is_bug": false,
    "failing_test_cases": 5,
    "buggy_methods": 2
  },
  {
    "name": "UnionTypeBuilder.UnionTypeBuilder",
    "class_name": "com.google.javascript.rhino.jstype.UnionTypeBuilder",
    "signature": "com.google.javascript.rhino.jstype.UnionTypeBuilder.UnionTypeBuilder(JSTypeRegistry)",
    "snippet": "  UnionTypeBuilder(JSTypeRegistry registry) {\n    this.registry = registry;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 5,
    "buggy_methods": 2
  },
  {
    "name": "UnionTypeBuilder.addAlternate",
    "class_name": "com.google.javascript.rhino.jstype.UnionTypeBuilder",
    "signature": "com.google.javascript.rhino.jstype.UnionTypeBuilder.addAlternate(JSType)",
    "snippet": "  UnionTypeBuilder addAlternate(JSType alternate) {\n    // build() returns the bottom type by default, so we can\n    // just bail out early here.\n    if (alternate.isNoType()) {\n      return this;\n    }\n\n    isAllType = isAllType || alternate.isAllType();\n\n    boolean isAlternateUnknown = alternate instanceof UnknownType;\n    isNativeUnknownType = isNativeUnknownType || isAlternateUnknown;\n    if (isAlternateUnknown) {\n      areAllUnknownsChecked = areAllUnknownsChecked &&\n          alternate.isCheckedUnknownType();\n    }\n    if (!isAllType && !isNativeUnknownType) {\n      if (alternate instanceof UnionType) {\n        UnionType union = (UnionType) alternate;\n        for (JSType unionAlt : union.getAlternates()) {\n          addAlternate(unionAlt);\n        }\n      } else {\n        if (alternates.size() > MAX_UNION_SIZE) {\n          return this;\n        }\n\n        // Look through the alternates we've got so far,\n        // and check if any of them are duplicates of\n        // one another.\n        Iterator<JSType> it = alternates.iterator();\n        while (it.hasNext()) {\n          JSType current = it.next();\n\n          // Unknown and NoResolved types may just be names that haven't\n          // been resolved yet. So keep these in the union, and just use\n          // equality checking for simple de-duping.\n          if (alternate.isUnknownType() ||\n              current.isUnknownType() ||\n              alternate.isNoResolvedType() ||\n              current.isNoResolvedType()) {\n            if (alternate.isEquivalentTo(current)) {\n              // Alternate is unnecessary.\n              return this;\n            }\n          } else {\n            if (alternate.isSubtype(current)) {\n              // Alternate is unnecessary.\n              return this;\n            } else if (current.isSubtype(alternate)) {\n              // Alternate makes current obsolete\n              it.remove();\n            }\n          }\n        }\n        alternates.add(alternate);\n        result = null; // invalidate the memoized result\n      }\n    } else {\n      result = null;\n    }\n    return this;\n  }",
    "comment": " Adds an alternate to the union type under construction. Returns this for easy chaining. ",
    "is_bug": false,
    "failing_test_cases": 5,
    "buggy_methods": 2
  },
  {
    "name": "UnionTypeBuilder.build",
    "class_name": "com.google.javascript.rhino.jstype.UnionTypeBuilder",
    "signature": "com.google.javascript.rhino.jstype.UnionTypeBuilder.build()",
    "snippet": "  JSType build() {\n    if (result == null) {\n      result = reduceAlternatesWithoutUnion();\n      if (result == null) {\n        result = new UnionType(registry, getAlternateListCopy());\n      }\n    }\n    return result;\n  }",
    "comment": " Creates a union. @return A UnionType if it has two or more alternates, the only alternate if it has one and otherwise {@code NO_TYPE}. ",
    "is_bug": false,
    "failing_test_cases": 5,
    "buggy_methods": 2
  },
  {
    "name": "UnionTypeBuilder.getAlternateListCopy",
    "class_name": "com.google.javascript.rhino.jstype.UnionTypeBuilder",
    "signature": "com.google.javascript.rhino.jstype.UnionTypeBuilder.getAlternateListCopy()",
    "snippet": "  private Collection<JSType> getAlternateListCopy() {\n    // TODO(nicksantos): Until we're at a place where we're no longer\n    // using java's built-in equals to test type equivalence, we need\n    // hash codes to be the same. So the alternates need to be sorted.\n    Collections.sort(alternates, typeSorter);\n\n    return ImmutableList.copyOf(alternates);\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 5,
    "buggy_methods": 2
  },
  {
    "name": "UnionTypeBuilder.reduceAlternatesWithoutUnion",
    "class_name": "com.google.javascript.rhino.jstype.UnionTypeBuilder",
    "signature": "com.google.javascript.rhino.jstype.UnionTypeBuilder.reduceAlternatesWithoutUnion()",
    "snippet": "  private JSType reduceAlternatesWithoutUnion() {\n    if (isAllType) {\n      return registry.getNativeType(ALL_TYPE);\n    } else if (isNativeUnknownType) {\n      if (areAllUnknownsChecked) {\n        return registry.getNativeType(CHECKED_UNKNOWN_TYPE);\n      } else {\n        return registry.getNativeType(UNKNOWN_TYPE);\n      }\n    } else {\n      int size = alternates.size();\n      if (size > MAX_UNION_SIZE) {\n        return registry.getNativeType(UNKNOWN_TYPE);\n      } else if (size > 1) {\n        return null;\n      } else if (size == 1) {\n        return alternates.iterator().next();\n      } else {\n        return registry.getNativeType(NO_TYPE);\n      }\n    }\n  }",
    "comment": " Reduce the alternates into a non-union type. If the alternates can't be accurately represented with a non-union type, return null. ",
    "is_bug": false,
    "failing_test_cases": 5,
    "buggy_methods": 2
  },
  {
    "name": "UnknownType.UnknownType",
    "class_name": "com.google.javascript.rhino.jstype.UnknownType",
    "signature": "com.google.javascript.rhino.jstype.UnknownType.UnknownType(JSTypeRegistry,boolean)",
    "snippet": "  UnknownType(JSTypeRegistry registry, boolean isChecked) {\n    super(registry);\n    this.isChecked = isChecked;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 5,
    "buggy_methods": 2
  },
  {
    "name": "ValueType.ValueType",
    "class_name": "com.google.javascript.rhino.jstype.ValueType",
    "signature": "com.google.javascript.rhino.jstype.ValueType.ValueType(JSTypeRegistry)",
    "snippet": "  ValueType(JSTypeRegistry registry) {\n    super(registry);\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 5,
    "buggy_methods": 2
  },
  {
    "name": "ValueType.isSubtype",
    "class_name": "com.google.javascript.rhino.jstype.ValueType",
    "signature": "com.google.javascript.rhino.jstype.ValueType.isSubtype(JSType)",
    "snippet": "  @Override\n  public boolean isSubtype(JSType that) {\n    return JSType.isSubtype(this, that);\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 5,
    "buggy_methods": 2
  },
  {
    "name": "VoidType.VoidType",
    "class_name": "com.google.javascript.rhino.jstype.VoidType",
    "signature": "com.google.javascript.rhino.jstype.VoidType.VoidType(JSTypeRegistry)",
    "snippet": "  VoidType(JSTypeRegistry registry) {\n    super(registry);\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 5,
    "buggy_methods": 2
  },
  {
    "name": "VoidType.getDisplayName",
    "class_name": "com.google.javascript.rhino.jstype.VoidType",
    "signature": "com.google.javascript.rhino.jstype.VoidType.getDisplayName()",
    "snippet": "  @Override\n  public String getDisplayName() {\n    return \"undefined\";\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 5,
    "buggy_methods": 2
  },
  {
    "name": "VoidType.toString",
    "class_name": "com.google.javascript.rhino.jstype.VoidType",
    "signature": "com.google.javascript.rhino.jstype.VoidType.toString()",
    "snippet": "  @Override\n  public String toString() {\n    return getDisplayName();\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 5,
    "buggy_methods": 2
  }
]