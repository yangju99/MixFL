[
  {
    "name": "UnivariateRealSolverUtils.bracket",
    "class_name": "org.apache.commons.math.analysis.UnivariateRealSolverUtils",
    "signature": "org.apache.commons.math.analysis.UnivariateRealSolverUtils.bracket(UnivariateRealFunction,double,double,double)",
    "snippet": "    public static double[] bracket(UnivariateRealFunction function, \n            double initial, double lowerBound, double upperBound) \n    throws ConvergenceException, FunctionEvaluationException {\n        return bracket( function, initial, lowerBound, upperBound,\n            Integer.MAX_VALUE ) ;\n    }",
    "comment": " This method attempts to find two values a and b satisfying <ul> <li> <code> lowerBound <= a < initial < b <= upperBound</code> </li> <li> <code> f(a) * f(b) < 0 </code></li> </ul> If f is continuous on <code>[a,b],</code> this means that <code>a</code> and <code>b</code> bracket a root of f. <p> The algorithm starts by setting  <code>a := initial -1; b := initial +1,</code> examines the value of the function at <code>a</code> and <code>b</code> and keeps moving the endpoints out by one unit each time through a loop that terminates  when one of the following happens: <ul> <li> <code> f(a) * f(b) < 0 </code> --  success!</li> <li> <code> a = lower </code> and <code> b = upper</code>  -- ConvergenceException </li> <li> <code> Integer.MAX_VALUE</code> iterations elapse  -- ConvergenceException </li> </ul></p> <p> <strong>Note: </strong> this method can take  <code>Integer.MAX_VALUE</code> iterations to throw a  <code>ConvergenceException.</code>  Unless you are confident that there is a root between <code>lowerBound</code> and <code>upperBound</code> near <code>initial,</code> it is better to use  {@link #bracket(UnivariateRealFunction, double, double, double, int)},  explicitly specifying the maximum number of iterations.</p>  @param function the function @param initial initial midpoint of interval being expanded to bracket a root @param lowerBound lower bound (a is never lower than this value) @param upperBound upper bound (b never is greater than this value) @return a two element array holding {a, b} @throws ConvergenceException if a root can not be bracketted @throws FunctionEvaluationException if an error occurs evaluating the function @throws IllegalArgumentException if function is null, maximumIterations is not positive, or initial is not between lowerBound and upperBound ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "UnivariateRealSolverUtils.bracket",
    "class_name": "org.apache.commons.math.analysis.UnivariateRealSolverUtils",
    "signature": "org.apache.commons.math.analysis.UnivariateRealSolverUtils.bracket(UnivariateRealFunction,double,double,double,int)",
    "snippet": "    public static double[] bracket(UnivariateRealFunction function,\n            double initial, double lowerBound, double upperBound, \n            int maximumIterations) throws ConvergenceException, \n            FunctionEvaluationException {\n        \n        if (function == null) {\n            throw new IllegalArgumentException (\"function is null.\");\n        }\n        if (maximumIterations <= 0)  {\n            throw new IllegalArgumentException\n            (\"bad value for maximumIterations: \" + maximumIterations);\n        }\n        if (initial < lowerBound || initial > upperBound || lowerBound >= upperBound) {\n            throw new IllegalArgumentException\n            (\"Invalid endpoint parameters:  lowerBound=\" + lowerBound + \n              \" initial=\" + initial + \" upperBound=\" + upperBound);\n        }\n        double a = initial;\n        double b = initial;\n        double fa;\n        double fb;\n        int numIterations = 0 ;\n    \n        do {\n            a = Math.max(a - 1.0, lowerBound);\n            b = Math.min(b + 1.0, upperBound);\n            fa = function.value(a);\n            \n            fb = function.value(b);\n            numIterations++ ;\n        } while ((fa * fb > 0.0) && (numIterations < maximumIterations) && \n                ((a > lowerBound) || (b < upperBound)));\n   \n        if (fa * fb >= 0.0 ) {\n            throw new ConvergenceException\n            (\"Number of iterations={0}, maximum iterations={1}, initial={2}, lower bound={3}, upper bound={4}, final a value={5}, final b value={6}, f(a)={7}, f(b)={8}\",\n             new Object[] { Integer.valueOf(numIterations), Integer.valueOf(maximumIterations),\n                            Double.valueOf(initial), Double.valueOf(lowerBound), Double.valueOf(upperBound),\n                            Double.valueOf(a), Double.valueOf(b), Double.valueOf(fa), Double.valueOf(fb) });\n        }\n        \n        return new double[]{a, b};\n    }",
    "comment": " This method attempts to find two values a and b satisfying <ul> <li> <code> lowerBound <= a < initial < b <= upperBound</code> </li> <li> <code> f(a) * f(b) < 0 </code> </li> </ul> If f is continuous on <code>[a,b],</code> this means that <code>a</code> and <code>b</code> bracket a root of f. <p> The algorithm starts by setting  <code>a := initial -1; b := initial +1,</code> examines the value of the function at <code>a</code> and <code>b</code> and keeps moving the endpoints out by one unit each time through a loop that terminates  when one of the following happens: <ul> <li> <code> f(a) * f(b) < 0 </code> --  success!</li> <li> <code> a = lower </code> and <code> b = upper</code>  -- ConvergenceException </li> <li> <code> maximumIterations</code> iterations elapse  -- ConvergenceException </li></ul></p>  @param function the function @param initial initial midpoint of interval being expanded to bracket a root @param lowerBound lower bound (a is never lower than this value) @param upperBound upper bound (b never is greater than this value) @param maximumIterations maximum number of iterations to perform @return a two element array holding {a, b}. @throws ConvergenceException if the algorithm fails to find a and b satisfying the desired conditions @throws FunctionEvaluationException if an error occurs evaluating the  function @throws IllegalArgumentException if function is null, maximumIterations is not positive, or initial is not between lowerBound and upperBound ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "AbstractContinuousDistribution.AbstractContinuousDistribution",
    "class_name": "org.apache.commons.math.distribution.AbstractContinuousDistribution",
    "signature": "org.apache.commons.math.distribution.AbstractContinuousDistribution.AbstractContinuousDistribution()",
    "snippet": "    protected AbstractContinuousDistribution() {\n        super();\n    }",
    "comment": " Default constructor. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "AbstractContinuousDistribution.inverseCumulativeProbability",
    "class_name": "org.apache.commons.math.distribution.AbstractContinuousDistribution",
    "signature": "org.apache.commons.math.distribution.AbstractContinuousDistribution.inverseCumulativeProbability(double)",
    "snippet": "    public double inverseCumulativeProbability(final double p)\n        throws MathException {\n        if (p < 0.0 || p > 1.0) {\n            throw new IllegalArgumentException(\"p must be between 0.0 and 1.0, inclusive.\");\n        }\n\n        // by default, do simple root finding using bracketing and default solver.\n        // subclasses can overide if there is a better method.\n        UnivariateRealFunction rootFindingFunction =\n            new UnivariateRealFunction() {\n\n            public double value(double x) throws FunctionEvaluationException {\n                try {\n                    return cumulativeProbability(x) - p;\n                } catch (MathException ex) {\n                    throw new FunctionEvaluationException(x, ex.getPattern(), ex.getArguments(), ex);\n                }\n            }\n        };\n              \n        // Try to bracket root, test domain endoints if this fails     \n        double lowerBound = getDomainLowerBound(p);\n        double upperBound = getDomainUpperBound(p);\n        double[] bracket = null;\n        try {\n            bracket = UnivariateRealSolverUtils.bracket(\n                    rootFindingFunction, getInitialDomain(p),\n                    lowerBound, upperBound);\n        }  catch (ConvergenceException ex) {\n            /* \n             * Check domain endpoints to see if one gives value that is within\n             * the default solver's defaultAbsoluteAccuracy of 0 (will be the\n             * case if density has bounded support and p is 0 or 1).\n             * \n             * TODO: expose the default solver, defaultAbsoluteAccuracy as\n             * a constant.\n             */ \n            if (Math.abs(rootFindingFunction.value(lowerBound)) < 1E-6) {\n                return lowerBound;\n            }\n            if (Math.abs(rootFindingFunction.value(upperBound)) < 1E-6) {\n                return upperBound;\n            }     \n            // Failed bracket convergence was not because of corner solution\n            throw new MathException(ex);\n        }\n\n        // find root\n        double root = UnivariateRealSolverUtils.solve(rootFindingFunction,\n                bracket[0],bracket[1]);\n        return root;\n    }",
    "comment": " For this distribution, X, this method returns the critical point x, such that P(X &lt; x) = <code>p</code>.  @param p the desired probability @return x, such that P(X &lt; x) = <code>p</code> @throws MathException if the inverse cumulative probability can not be computed due to convergence or other numerical errors. @throws IllegalArgumentException if <code>p</code> is not a valid probability. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "AbstractDistribution.AbstractDistribution",
    "class_name": "org.apache.commons.math.distribution.AbstractDistribution",
    "signature": "org.apache.commons.math.distribution.AbstractDistribution.AbstractDistribution()",
    "snippet": "    protected AbstractDistribution() {\n        super();\n    }",
    "comment": " Default constructor. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "FDistributionImpl.FDistributionImpl",
    "class_name": "org.apache.commons.math.distribution.FDistributionImpl",
    "signature": "org.apache.commons.math.distribution.FDistributionImpl.FDistributionImpl(double,double)",
    "snippet": "    public FDistributionImpl(double numeratorDegreesOfFreedom,\n            double denominatorDegreesOfFreedom) {\n        super();\n        setNumeratorDegreesOfFreedom(numeratorDegreesOfFreedom);\n        setDenominatorDegreesOfFreedom(denominatorDegreesOfFreedom);\n    }",
    "comment": " Create a F distribution using the given degrees of freedom. @param numeratorDegreesOfFreedom the numerator degrees of freedom. @param denominatorDegreesOfFreedom the denominator degrees of freedom. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "FDistributionImpl.cumulativeProbability",
    "class_name": "org.apache.commons.math.distribution.FDistributionImpl",
    "signature": "org.apache.commons.math.distribution.FDistributionImpl.cumulativeProbability(double)",
    "snippet": "    public double cumulativeProbability(double x) throws MathException {\n        double ret;\n        if (x <= 0.0) {\n            ret = 0.0;\n        } else {\n            double n = getNumeratorDegreesOfFreedom();\n            double m = getDenominatorDegreesOfFreedom();\n            \n            ret = Beta.regularizedBeta((n * x) / (m + n * x),\n                0.5 * n,\n                0.5 * m);\n        }\n        return ret;\n    }",
    "comment": " For this distribution, X, this method returns P(X &lt; x).  The implementation of this method is based on: <ul> <li> <a href=\"http://mathworld.wolfram.com/F-Distribution.html\"> F-Distribution</a>, equation (4).</li> </ul>  @param x the value at which the CDF is evaluated. @return CDF for this distribution.  @throws MathException if the cumulative probability can not be computed due to convergence or other numerical errors. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "FDistributionImpl.getDenominatorDegreesOfFreedom",
    "class_name": "org.apache.commons.math.distribution.FDistributionImpl",
    "signature": "org.apache.commons.math.distribution.FDistributionImpl.getDenominatorDegreesOfFreedom()",
    "snippet": "    public double getDenominatorDegreesOfFreedom() {\n        return denominatorDegreesOfFreedom;\n    }",
    "comment": " Access the denominator degrees of freedom. @return the denominator degrees of freedom. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "FDistributionImpl.getDomainLowerBound",
    "class_name": "org.apache.commons.math.distribution.FDistributionImpl",
    "signature": "org.apache.commons.math.distribution.FDistributionImpl.getDomainLowerBound(double)",
    "snippet": "    protected double getDomainLowerBound(double p) {\n        return 0.0;\n    }",
    "comment": " Access the domain value lower bound, based on <code>p</code>, used to bracket a CDF root.  This method is used by {@link #inverseCumulativeProbability(double)} to find critical values.  @param p the desired probability for the critical value @return domain value lower bound, i.e. P(X &lt; <i>lower bound</i>) &lt; <code>p</code>  ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "FDistributionImpl.getDomainUpperBound",
    "class_name": "org.apache.commons.math.distribution.FDistributionImpl",
    "signature": "org.apache.commons.math.distribution.FDistributionImpl.getDomainUpperBound(double)",
    "snippet": "    protected double getDomainUpperBound(double p) {\n        return Double.MAX_VALUE;\n    }",
    "comment": " Access the domain value upper bound, based on <code>p</code>, used to bracket a CDF root.  This method is used by {@link #inverseCumulativeProbability(double)} to find critical values.  @param p the desired probability for the critical value @return domain value upper bound, i.e. P(X &lt; <i>upper bound</i>) &gt; <code>p</code>  ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "FDistributionImpl.getInitialDomain",
    "class_name": "org.apache.commons.math.distribution.FDistributionImpl",
    "signature": "org.apache.commons.math.distribution.FDistributionImpl.getInitialDomain(double)",
    "snippet": "    protected double getInitialDomain(double p) {\n        double ret;\n        double d = getDenominatorDegreesOfFreedom();\n            // use mean\n            ret = d / (d - 2.0);\n        return ret;\n    }",
    "comment": " Access the initial domain value, based on <code>p</code>, used to bracket a CDF root.  This method is used by {@link #inverseCumulativeProbability(double)} to find critical values.  @param p the desired probability for the critical value @return initial domain value ",
    "is_bug": true,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "FDistributionImpl.getNumeratorDegreesOfFreedom",
    "class_name": "org.apache.commons.math.distribution.FDistributionImpl",
    "signature": "org.apache.commons.math.distribution.FDistributionImpl.getNumeratorDegreesOfFreedom()",
    "snippet": "    public double getNumeratorDegreesOfFreedom() {\n        return numeratorDegreesOfFreedom;\n    }",
    "comment": " Access the numerator degrees of freedom. @return the numerator degrees of freedom. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "FDistributionImpl.inverseCumulativeProbability",
    "class_name": "org.apache.commons.math.distribution.FDistributionImpl",
    "signature": "org.apache.commons.math.distribution.FDistributionImpl.inverseCumulativeProbability(double)",
    "snippet": "    public double inverseCumulativeProbability(final double p) \n        throws MathException {\n        if (p == 0) {\n            return 0d;\n        }\n        if (p == 1) {\n            return Double.POSITIVE_INFINITY;\n        }\n        return super.inverseCumulativeProbability(p);\n    }",
    "comment": " For this distribution, X, this method returns the critical point x, such that P(X &lt; x) = <code>p</code>. <p> Returns 0 for p=0 and <code>Double.POSITIVE_INFINITY</code> for p=1.</p>  @param p the desired probability @return x, such that P(X &lt; x) = <code>p</code> @throws MathException if the inverse cumulative probability can not be computed due to convergence or other numerical errors. @throws IllegalArgumentException if <code>p</code> is not a valid probability. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "FDistributionImpl.setDenominatorDegreesOfFreedom",
    "class_name": "org.apache.commons.math.distribution.FDistributionImpl",
    "signature": "org.apache.commons.math.distribution.FDistributionImpl.setDenominatorDegreesOfFreedom(double)",
    "snippet": "    public void setDenominatorDegreesOfFreedom(double degreesOfFreedom) {\n        if (degreesOfFreedom <= 0.0) {\n            throw new IllegalArgumentException(\n                \"degrees of freedom must be positive.\");\n        }\n        this.denominatorDegreesOfFreedom = degreesOfFreedom;\n    }",
    "comment": " Modify the denominator degrees of freedom. @param degreesOfFreedom the new denominator degrees of freedom. @throws IllegalArgumentException if <code>degreesOfFreedom</code> is not positive. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "FDistributionImpl.setNumeratorDegreesOfFreedom",
    "class_name": "org.apache.commons.math.distribution.FDistributionImpl",
    "signature": "org.apache.commons.math.distribution.FDistributionImpl.setNumeratorDegreesOfFreedom(double)",
    "snippet": "    public void setNumeratorDegreesOfFreedom(double degreesOfFreedom) {\n        if (degreesOfFreedom <= 0.0) {\n            throw new IllegalArgumentException(\n                \"degrees of freedom must be positive.\");\n        }\n        this.numeratorDegreesOfFreedom = degreesOfFreedom;\n    }",
    "comment": " Modify the numerator degrees of freedom. @param degreesOfFreedom the new numerator degrees of freedom. @throws IllegalArgumentException if <code>degreesOfFreedom</code> is not positive. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "Beta.logBeta",
    "class_name": "org.apache.commons.math.special.Beta",
    "signature": "org.apache.commons.math.special.Beta.logBeta(double,double,double,int)",
    "snippet": "    public static double logBeta(double a, double b, double epsilon,\n        int maxIterations) {\n            \n        double ret;\n\n        if (Double.isNaN(a) || Double.isNaN(b) || (a <= 0.0) || (b <= 0.0)) {\n            ret = Double.NaN;\n        } else {\n            ret = Gamma.logGamma(a) + Gamma.logGamma(b) -\n                Gamma.logGamma(a + b);\n        }\n\n        return ret;\n    }",
    "comment": " Returns the natural logarithm of the beta function B(a, b).  The implementation of this method is based on: <ul> <li><a href=\"http://mathworld.wolfram.com/BetaFunction.html\"> Beta Function</a>, equation (1).</li> </ul>  @param a the a parameter. @param b the b parameter. @param epsilon When the absolute value of the nth item in the series is less than epsilon the approximation ceases to calculate further elements in the series. @param maxIterations Maximum number of \"iterations\" to complete.  @return log(B(a, b)) ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "Beta.regularizedBeta",
    "class_name": "org.apache.commons.math.special.Beta",
    "signature": "org.apache.commons.math.special.Beta.regularizedBeta(double,double,double)",
    "snippet": "    public static double regularizedBeta(double x, double a, double b)\n        throws MathException\n    {\n        return regularizedBeta(x, a, b, DEFAULT_EPSILON, Integer.MAX_VALUE);\n    }",
    "comment": " Returns the <a href=\"http://mathworld.wolfram.com/RegularizedBetaFunction.html\"> regularized beta function</a> I(x, a, b).  @param x the value. @param a the a parameter. @param b the b parameter. @return the regularized beta function I(x, a, b) @throws MathException if the algorithm fails to converge. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "Beta.regularizedBeta",
    "class_name": "org.apache.commons.math.special.Beta",
    "signature": "org.apache.commons.math.special.Beta.regularizedBeta(double,double,double,double,int)",
    "snippet": "    public static double regularizedBeta(double x, final double a,\n        final double b, double epsilon, int maxIterations) throws MathException\n    {\n        double ret;\n\n        if (Double.isNaN(x) || Double.isNaN(a) || Double.isNaN(b) || (x < 0) ||\n            (x > 1) || (a <= 0.0) || (b <= 0.0))\n        {\n            ret = Double.NaN;\n        } else if (x > (a + 1.0) / (a + b + 2.0)) {\n            ret = 1.0 - regularizedBeta(1.0 - x, b, a, epsilon, maxIterations);\n        } else {\n            ContinuedFraction fraction = new ContinuedFraction() {\n\n                private static final long serialVersionUID = -7658917278956100597L;\n\n                protected double getB(int n, double x) {\n                    double ret;\n                    double m;\n                    if (n % 2 == 0) { // even\n                        m = n / 2.0;\n                        ret = (m * (b - m) * x) /\n                            ((a + (2 * m) - 1) * (a + (2 * m)));\n                    } else {\n                        m = (n - 1.0) / 2.0;\n                        ret = -((a + m) * (a + b + m) * x) /\n                                ((a + (2 * m)) * (a + (2 * m) + 1.0));\n                    }\n                    return ret;\n                }\n\n                protected double getA(int n, double x) {\n                    return 1.0;\n                }\n            };\n            ret = Math.exp((a * Math.log(x)) + (b * Math.log(1.0 - x)) -\n                Math.log(a) - logBeta(a, b, epsilon, maxIterations)) *\n                1.0 / fraction.evaluate(x, epsilon, maxIterations);\n        }\n\n        return ret;\n    }",
    "comment": " Returns the regularized beta function I(x, a, b).  The implementation of this method is based on: <ul> <li> <a href=\"http://mathworld.wolfram.com/RegularizedBetaFunction.html\"> Regularized Beta Function</a>.</li> <li> <a href=\"http://functions.wolfram.com/06.21.10.0001.01\"> Regularized Beta Function</a>.</li> </ul>  @param x the value. @param a the a parameter. @param b the b parameter. @param epsilon When the absolute value of the nth item in the series is less than epsilon the approximation ceases to calculate further elements in the series. @param maxIterations Maximum number of \"iterations\" to complete.  @return the regularized beta function I(x, a, b) @throws MathException if the algorithm fails to converge. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "Gamma.logGamma",
    "class_name": "org.apache.commons.math.special.Gamma",
    "signature": "org.apache.commons.math.special.Gamma.logGamma(double)",
    "snippet": "    public static double logGamma(double x) {\n        double ret;\n\n        if (Double.isNaN(x) || (x <= 0.0)) {\n            ret = Double.NaN;\n        } else {\n            double g = 607.0 / 128.0;\n            \n            double sum = 0.0;\n            for (int i = lanczos.length - 1; i > 0; --i) {\n                sum = sum + (lanczos[i] / (x + i));\n            }\n            sum = sum + lanczos[0];\n\n            double tmp = x + g + .5;\n            ret = ((x + .5) * Math.log(tmp)) - tmp +\n                HALF_LOG_2_PI + Math.log(sum / x);\n        }\n\n        return ret;\n    }",
    "comment": " Returns the natural logarithm of the gamma function &#915;(x).  The implementation of this method is based on: <ul> <li><a href=\"http://mathworld.wolfram.com/GammaFunction.html\"> Gamma Function</a>, equation (28).</li> <li><a href=\"http://mathworld.wolfram.com/LanczosApproximation.html\"> Lanczos Approximation</a>, equations (1) through (5).</li> <li><a href=\"http://my.fit.edu/~gabdo/gamma.txt\">Paul Godfrey, A note on the computation of the convergent Lanczos complex Gamma approximation </a></li> </ul>  @param x the value. @return log(&#915;(x)) ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "ContinuedFraction.ContinuedFraction",
    "class_name": "org.apache.commons.math.util.ContinuedFraction",
    "signature": "org.apache.commons.math.util.ContinuedFraction.ContinuedFraction()",
    "snippet": "    protected ContinuedFraction() {\n        super();\n    }",
    "comment": " Default constructor. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "ContinuedFraction.evaluate",
    "class_name": "org.apache.commons.math.util.ContinuedFraction",
    "signature": "org.apache.commons.math.util.ContinuedFraction.evaluate(double,double,int)",
    "snippet": "    public double evaluate(double x, double epsilon, int maxIterations)\n        throws MathException\n    {\n        double p0 = 1.0;\n        double p1 = getA(0, x);\n        double q0 = 0.0;\n        double q1 = 1.0;\n        double c = p1 / q1;\n        int n = 0;\n        double relativeError = Double.MAX_VALUE;\n        while (n < maxIterations && relativeError > epsilon) {\n            ++n;\n            double a = getA(n, x);\n            double b = getB(n, x);\n            double p2 = a * p1 + b * p0;\n            double q2 = a * q1 + b * q0;\n            if (Double.isInfinite(p2) || Double.isInfinite(q2)) {\n                // need to scale\n                if (a != 0.0) {\n                    p2 = p1 + (b / a * p0);\n                    q2 = q1 + (b / a * q0);\n                } else if (b != 0) {\n                    p2 = (a / b * p1) + p0;\n                    q2 = (a / b * q1) + q0;\n                } else {\n                    // can not scale an convergent is unbounded.\n                    throw new ConvergenceException(\n                        \"Continued fraction convergents diverged to +/- infinity for value {0}\",\n                        new Object[] { Double.valueOf(x) });\n                }\n            }\n            double r = p2 / q2;\n            relativeError = Math.abs(r / c - 1.0);\n                \n            // prepare for next iteration\n            c = p2 / q2;\n            p0 = p1;\n            p1 = p2;\n            q0 = q1;\n            q1 = q2;\n        }\n\n        if (n >= maxIterations) {\n            throw new MaxIterationsExceededException(maxIterations,\n                \"Continued fraction convergents failed to converge for value {0}\",\n                new Object[] { Double.valueOf(x) });\n        }\n\n        return c;\n    }",
    "comment": " <p> Evaluates the continued fraction at the value x. </p>  <p> The implementation of this method is based on equations 14-17 of: <ul> <li> Eric W. Weisstein. \"Continued Fraction.\" From MathWorld--A Wolfram Web Resource. <a target=\"_blank\" href=\"http://mathworld.wolfram.com/ContinuedFraction.html\"> http://mathworld.wolfram.com/ContinuedFraction.html</a> </li> </ul> The recurrence relationship defined in those equations can result in very large intermediate results which can result in numerical overflow. As a means to combat these overflow conditions, the intermediate results are scaled whenever they threaten to become numerically unstable.</p>  @param x the evaluation point. @param epsilon maximum error allowed. @param maxIterations maximum number of convergents @return the value of the continued fraction evaluated at x.  @throws MathException if the algorithm fails to converge. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  }
]