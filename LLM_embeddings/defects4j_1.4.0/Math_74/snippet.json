[
  {
    "name": "ConvergingAlgorithmImpl.ConvergingAlgorithmImpl",
    "class_name": "org.apache.commons.math.ConvergingAlgorithmImpl",
    "signature": "org.apache.commons.math.ConvergingAlgorithmImpl.ConvergingAlgorithmImpl(int,double)",
    "snippet": "    protected ConvergingAlgorithmImpl(final int defaultMaximalIterationCount,\n                                      final double defaultAbsoluteAccuracy) {\n        this.defaultAbsoluteAccuracy = defaultAbsoluteAccuracy;\n        this.defaultRelativeAccuracy = 1.0e-14;\n        this.absoluteAccuracy = defaultAbsoluteAccuracy;\n        this.relativeAccuracy = defaultRelativeAccuracy;\n        this.defaultMaximalIterationCount = defaultMaximalIterationCount;\n        this.maximalIterationCount = defaultMaximalIterationCount;\n        this.iterationCount = 0;\n    }",
    "comment": " Construct an algorithm with given iteration count and accuracy.  @param defaultAbsoluteAccuracy maximum absolute error @param defaultMaximalIterationCount maximum number of iterations @throws IllegalArgumentException if f is null or the defaultAbsoluteAccuracy is not valid ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "ConvergingAlgorithmImpl.setAbsoluteAccuracy",
    "class_name": "org.apache.commons.math.ConvergingAlgorithmImpl",
    "signature": "org.apache.commons.math.ConvergingAlgorithmImpl.setAbsoluteAccuracy(double)",
    "snippet": "    public void setAbsoluteAccuracy(double accuracy) {\n        absoluteAccuracy = accuracy;\n    }",
    "comment": "{@inheritDoc} */",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "ConvergingAlgorithmImpl.setMaximalIterationCount",
    "class_name": "org.apache.commons.math.ConvergingAlgorithmImpl",
    "signature": "org.apache.commons.math.ConvergingAlgorithmImpl.setMaximalIterationCount(int)",
    "snippet": "    public void setMaximalIterationCount(int count) {\n        maximalIterationCount = count;\n    }",
    "comment": "{@inheritDoc} */",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "MathException.MathException",
    "class_name": "org.apache.commons.math.MathException",
    "signature": "org.apache.commons.math.MathException.MathException(Throwable)",
    "snippet": "    public MathException(Throwable rootCause) {\n        super(rootCause);\n        this.pattern   = getMessage();\n        this.arguments = new Object[0];\n    }",
    "comment": " Constructs a new <code>MathException</code> with specified nested <code>Throwable</code> root cause.  @param rootCause  the exception or error that caused this exception to be thrown. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "MathException.getMessage",
    "class_name": "org.apache.commons.math.MathException",
    "signature": "org.apache.commons.math.MathException.getMessage()",
    "snippet": "    @Override\n    public String getMessage() {\n        return getMessage(Locale.US);\n    }",
    "comment": "{@inheritDoc} */",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "MathException.getMessage",
    "class_name": "org.apache.commons.math.MathException",
    "signature": "org.apache.commons.math.MathException.getMessage(Locale)",
    "snippet": "    public String getMessage(final Locale locale) {\n        return (pattern == null) ? \"\" : new MessageFormat(translate(pattern, locale), locale).format(arguments);\n    }",
    "comment": "Gets the message in a specified locale.  @param locale Locale in which the message should be translated  @return localized message @since 1.2 ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "BrentSolver.BrentSolver",
    "class_name": "org.apache.commons.math.analysis.solvers.BrentSolver",
    "signature": "org.apache.commons.math.analysis.solvers.BrentSolver.BrentSolver()",
    "snippet": "    public BrentSolver() {\n        super(100, 1E-6);\n    }",
    "comment": " Construct a solver. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "BrentSolver.solve",
    "class_name": "org.apache.commons.math.analysis.solvers.BrentSolver",
    "signature": "org.apache.commons.math.analysis.solvers.BrentSolver.solve(UnivariateRealFunction,double,double)",
    "snippet": "    public double solve(final UnivariateRealFunction f,\n                        final double min, final double max)\n        throws MaxIterationsExceededException,\n        FunctionEvaluationException {\n\n        clearResult();\n        verifyInterval(min, max);\n\n        double ret = Double.NaN;\n\n        double yMin = f.value(min);\n        double yMax = f.value(max);\n\n        // Verify bracketing\n        double sign = yMin * yMax;\n        if (sign > 0) {\n            // check if either value is close to a zero\n            if (Math.abs(yMin) <= functionValueAccuracy) {\n                setResult(min, 0);\n                ret = min;\n            } else if (Math.abs(yMax) <= functionValueAccuracy) {\n                setResult(max, 0);\n                ret = max;\n            } else {\n                // neither value is close to zero and min and max do not bracket root.\n                throw MathRuntimeException.createIllegalArgumentException(\n                        \"function values at endpoints do not have different signs.  \" +\n                        \"Endpoints: [{0}, {1}], Values: [{2}, {3}]\",\n                        min, max, yMin, yMax);\n            }\n        } else if (sign < 0){\n            // solve using only the first endpoint as initial guess\n            ret = solve(f, min, yMin, max, yMax, min, yMin);\n        } else {\n            // either min or max is a root\n            if (yMin == 0.0) {\n                ret = min;\n            } else {\n                ret = max;\n            }\n        }\n\n        return ret;\n    }",
    "comment": " Find a zero in the given interval. <p> Requires that the values of the function at the endpoints have opposite signs. An <code>IllegalArgumentException</code> is thrown if this is not the case.</p>  @param f the function to solve @param min the lower bound for the interval. @param max the upper bound for the interval. @return the value where the function is zero @throws MaxIterationsExceededException if the maximum iteration count is exceeded @throws FunctionEvaluationException if an error occurs evaluating the function @throws IllegalArgumentException if min is not less than max or the signs of the values of the function at the endpoints are not opposites ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "BrentSolver.solve",
    "class_name": "org.apache.commons.math.analysis.solvers.BrentSolver",
    "signature": "org.apache.commons.math.analysis.solvers.BrentSolver.solve(UnivariateRealFunction,double,double,double,double,double,double)",
    "snippet": "    private double solve(final UnivariateRealFunction f,\n                         double x0, double y0,\n                         double x1, double y1,\n                         double x2, double y2)\n    throws MaxIterationsExceededException, FunctionEvaluationException {\n\n        double delta = x1 - x0;\n        double oldDelta = delta;\n\n        int i = 0;\n        while (i < maximalIterationCount) {\n            if (Math.abs(y2) < Math.abs(y1)) {\n                // use the bracket point if is better than last approximation\n                x0 = x1;\n                x1 = x2;\n                x2 = x0;\n                y0 = y1;\n                y1 = y2;\n                y2 = y0;\n            }\n            if (Math.abs(y1) <= functionValueAccuracy) {\n                // Avoid division by very small values. Assume\n                // the iteration has converged (the problem may\n                // still be ill conditioned)\n                setResult(x1, i);\n                return result;\n            }\n            double dx = x2 - x1;\n            double tolerance =\n                Math.max(relativeAccuracy * Math.abs(x1), absoluteAccuracy);\n            if (Math.abs(dx) <= tolerance) {\n                setResult(x1, i);\n                return result;\n            }\n            if ((Math.abs(oldDelta) < tolerance) ||\n                    (Math.abs(y0) <= Math.abs(y1))) {\n                // Force bisection.\n                delta = 0.5 * dx;\n                oldDelta = delta;\n            } else {\n                double r3 = y1 / y0;\n                double p;\n                double p1;\n                // the equality test (x0 == x2) is intentional,\n                // it is part of the original Brent's method,\n                // it should NOT be replaced by proximity test\n                if (x0 == x2) {\n                    // Linear interpolation.\n                    p = dx * r3;\n                    p1 = 1.0 - r3;\n                } else {\n                    // Inverse quadratic interpolation.\n                    double r1 = y0 / y2;\n                    double r2 = y1 / y2;\n                    p = r3 * (dx * r1 * (r1 - r2) - (x1 - x0) * (r2 - 1.0));\n                    p1 = (r1 - 1.0) * (r2 - 1.0) * (r3 - 1.0);\n                }\n                if (p > 0.0) {\n                    p1 = -p1;\n                } else {\n                    p = -p;\n                }\n                if (2.0 * p >= 1.5 * dx * p1 - Math.abs(tolerance * p1) ||\n                        p >= Math.abs(0.5 * oldDelta * p1)) {\n                    // Inverse quadratic interpolation gives a value\n                    // in the wrong direction, or progress is slow.\n                    // Fall back to bisection.\n                    delta = 0.5 * dx;\n                    oldDelta = delta;\n                } else {\n                    oldDelta = delta;\n                    delta = p / p1;\n                }\n            }\n            // Save old X1, Y1\n            x0 = x1;\n            y0 = y1;\n            // Compute new X1, Y1\n            if (Math.abs(delta) > tolerance) {\n                x1 = x1 + delta;\n            } else if (dx > 0.0) {\n                x1 = x1 + 0.5 * tolerance;\n            } else if (dx <= 0.0) {\n                x1 = x1 - 0.5 * tolerance;\n            }\n            y1 = f.value(x1);\n            if ((y1 > 0) == (y2 > 0)) {\n                x2 = x0;\n                y2 = y0;\n                delta = x1 - x0;\n                oldDelta = delta;\n            }\n            i++;\n        }\n        throw new MaxIterationsExceededException(maximalIterationCount);\n    }",
    "comment": " Find a zero starting search according to the three provided points. @param f the function to solve @param x0 old approximation for the root @param y0 function value at the approximation for the root @param x1 last calculated approximation for the root @param y1 function value at the last calculated approximation for the root @param x2 bracket point (must be set to x0 if no bracket point is known, this will force starting with linear interpolation) @param y2 function value at the bracket point. @return the value where the function is zero @throws MaxIterationsExceededException if the maximum iteration count is exceeded @throws FunctionEvaluationException if an error occurs evaluating the function ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "UnivariateRealSolverImpl.UnivariateRealSolverImpl",
    "class_name": "org.apache.commons.math.analysis.solvers.UnivariateRealSolverImpl",
    "signature": "org.apache.commons.math.analysis.solvers.UnivariateRealSolverImpl.UnivariateRealSolverImpl(int,double)",
    "snippet": "    protected UnivariateRealSolverImpl(final int defaultMaximalIterationCount,\n                                       final double defaultAbsoluteAccuracy) {\n        super(defaultMaximalIterationCount, defaultAbsoluteAccuracy);\n        this.defaultFunctionValueAccuracy = 1.0e-15;\n        this.functionValueAccuracy = defaultFunctionValueAccuracy;\n    }",
    "comment": " Construct a solver with given iteration count and accuracy.  @param defaultAbsoluteAccuracy maximum absolute error @param defaultMaximalIterationCount maximum number of iterations @throws IllegalArgumentException if f is null or the defaultAbsoluteAccuracy is not valid ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "UnivariateRealSolverImpl.clearResult",
    "class_name": "org.apache.commons.math.analysis.solvers.UnivariateRealSolverImpl",
    "signature": "org.apache.commons.math.analysis.solvers.UnivariateRealSolverImpl.clearResult()",
    "snippet": "    protected final void clearResult() {\n        this.iterationCount = 0;\n        this.resultComputed = false;\n    }",
    "comment": " Convenience function for implementations. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "UnivariateRealSolverImpl.setResult",
    "class_name": "org.apache.commons.math.analysis.solvers.UnivariateRealSolverImpl",
    "signature": "org.apache.commons.math.analysis.solvers.UnivariateRealSolverImpl.setResult(double,int)",
    "snippet": "    protected final void setResult(final double newResult, final int iterationCount) {\n        this.result         = newResult;\n        this.iterationCount = iterationCount;\n        this.resultComputed = true;\n    }",
    "comment": " Convenience function for implementations.  @param newResult the result to set @param iterationCount the iteration count to set ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "UnivariateRealSolverImpl.verifyInterval",
    "class_name": "org.apache.commons.math.analysis.solvers.UnivariateRealSolverImpl",
    "signature": "org.apache.commons.math.analysis.solvers.UnivariateRealSolverImpl.verifyInterval(double,double)",
    "snippet": "    protected void verifyInterval(final double lower, final double upper) {\n        if (lower >= upper) {\n            throw MathRuntimeException.createIllegalArgumentException(\n                    \"endpoints do not specify an interval: [{0}, {1}]\",\n                    lower, upper);\n        }\n    }",
    "comment": " Verifies that the endpoints specify an interval, throws IllegalArgumentException if not  @param lower  lower endpoint @param upper upper endpoint @throws IllegalArgumentException ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "BigFraction.BigFraction",
    "class_name": "org.apache.commons.math.fraction.BigFraction",
    "signature": "org.apache.commons.math.fraction.BigFraction.BigFraction(BigInteger,BigInteger)",
    "snippet": "    public BigFraction(BigInteger num, BigInteger den) {\n        if (num == null) {\n            throw MathRuntimeException.createNullPointerException(\"numerator is null\");\n        }\n        if (den == null) {\n            throw MathRuntimeException.createNullPointerException(\"denominator is null\");\n        }\n        if (BigInteger.ZERO.equals(den)) {\n            throw MathRuntimeException.createArithmeticException(FORBIDDEN_ZERO_DENOMINATOR);\n        }\n        if (BigInteger.ZERO.equals(num)) {\n            numerator   = BigInteger.ZERO;\n            denominator = BigInteger.ONE;\n        } else {\n\n            // reduce numerator and denominator by greatest common denominator\n            final BigInteger gcd = num.gcd(den);\n            if (BigInteger.ONE.compareTo(gcd) < 0) {\n                num = num.divide(gcd);\n                den = den.divide(gcd);\n            }\n\n            // move sign to numerator\n            if (BigInteger.ZERO.compareTo(den) > 0) {\n                num = num.negate();\n                den = den.negate();\n            }\n\n            // store the values in the final fields\n            numerator   = num;\n            denominator = den;\n\n        }\n    }",
    "comment": " <p> Create a {@link BigFraction} given the numerator and denominator as <code>BigInteger</code>. The {@link BigFraction} is reduced to lowest terms. </p>  @param num the numerator, must not be <code>null</code>. @param den the denominator, must not be <code>null</code>. @throws ArithmeticException if the denominator is <code>zero</code>. @throws NullPointerException if the numerator or the denominator is <code>zero</code>. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "BigFraction.BigFraction",
    "class_name": "org.apache.commons.math.fraction.BigFraction",
    "signature": "org.apache.commons.math.fraction.BigFraction.BigFraction(int)",
    "snippet": "    public BigFraction(final int num) {\n        this(BigInteger.valueOf(num), BigInteger.ONE);\n    }",
    "comment": " <p> Create a {@link BigFraction} equivalent to the passed <tt>int</tt>, ie \"num / 1\". </p>  @param num the numerator. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "BigFraction.BigFraction",
    "class_name": "org.apache.commons.math.fraction.BigFraction",
    "signature": "org.apache.commons.math.fraction.BigFraction.BigFraction(int,int)",
    "snippet": "    public BigFraction(final int num, final int den) {\n        this(BigInteger.valueOf(num), BigInteger.valueOf(den));\n    }",
    "comment": " <p> Create a {@link BigFraction} given the numerator and denominator as simple <tt>int</tt>. The {@link BigFraction} is reduced to lowest terms. </p>  @param num the numerator. @param den the denominator. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "BigFraction.divide",
    "class_name": "org.apache.commons.math.fraction.BigFraction",
    "signature": "org.apache.commons.math.fraction.BigFraction.divide(BigFraction)",
    "snippet": "    public BigFraction divide(final BigFraction fraction) {\n        if (BigInteger.ZERO.equals(fraction.numerator)) {\n            throw MathRuntimeException.createArithmeticException(FORBIDDEN_ZERO_DENOMINATOR);\n        }\n\n        return multiply(fraction.reciprocal());\n    }",
    "comment": " <p> Divide the value of this fraction by another, returning the result in reduced form. </p>  @param fraction the fraction to divide by, must not be <code>null</code>. @return a {@link BigFraction} instance with the resulting values. @throws NullPointerException if the fraction is <code>null</code>. @throws ArithmeticException if the fraction to divide by is zero. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "BigFraction.divide",
    "class_name": "org.apache.commons.math.fraction.BigFraction",
    "signature": "org.apache.commons.math.fraction.BigFraction.divide(BigInteger)",
    "snippet": "    public BigFraction divide(final BigInteger bg) {\n        if (BigInteger.ZERO.equals(bg)) {\n            throw MathRuntimeException.createArithmeticException(FORBIDDEN_ZERO_DENOMINATOR);\n        }\n        return new BigFraction(numerator, denominator.multiply(bg));\n    }",
    "comment": " <p> Divide the value of this fraction by the passed <code>BigInteger</code>, ie \"this * 1 / bg\", returning the result in reduced form. </p>  @param bg the <code>BigInteger</code> to divide by, must not be <code>null</code>. @return a {@link BigFraction} instance with the resulting values. @throws NullPointerException if the <code>BigInteger</code> is <code>null</code>. @throws ArithmeticException if the fraction to divide by is zero. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "BigFraction.doubleValue",
    "class_name": "org.apache.commons.math.fraction.BigFraction",
    "signature": "org.apache.commons.math.fraction.BigFraction.doubleValue()",
    "snippet": "    @Override\n    public double doubleValue() {\n        return numerator.doubleValue() / denominator.doubleValue();\n    }",
    "comment": " <p> Gets the fraction as a <tt>double</tt>. This calculates the fraction as the numerator divided by denominator. </p>  @return the fraction as a <tt>double</tt> @see java.lang.Number#doubleValue() ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "BigFraction.equals",
    "class_name": "org.apache.commons.math.fraction.BigFraction",
    "signature": "org.apache.commons.math.fraction.BigFraction.equals(Object)",
    "snippet": "    @Override\n    public boolean equals(final Object other) {\n        boolean ret = false;\n\n        if (this == other) {\n            ret = true;\n        } else if (other instanceof BigFraction) {\n            BigFraction rhs = ((BigFraction) other).reduce();\n            BigFraction thisOne = this.reduce();\n            ret = thisOne.numerator.equals(rhs.numerator) && thisOne.denominator.equals(rhs.denominator);\n        }\n\n        return ret;\n    }",
    "comment": " <p> Test for the equality of two fractions. If the lowest term numerator and denominators are the same for both fractions, the two fractions are considered to be equal. </p>  @param other fraction to test for equality to this fraction, can be <code>null</code>. @return true if two fractions are equal, false if object is <code>null</code>, not an instance of {@link BigFraction}, or not equal to this fraction instance. @see java.lang.Object#equals(java.lang.Object) ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "BigFraction.getField",
    "class_name": "org.apache.commons.math.fraction.BigFraction",
    "signature": "org.apache.commons.math.fraction.BigFraction.getField()",
    "snippet": "    public BigFractionField getField() {\n        return BigFractionField.getInstance();\n    }",
    "comment": "{@inheritDoc} */",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "BigFraction.getNumeratorAsInt",
    "class_name": "org.apache.commons.math.fraction.BigFraction",
    "signature": "org.apache.commons.math.fraction.BigFraction.getNumeratorAsInt()",
    "snippet": "    public int getNumeratorAsInt() {\n        return numerator.intValue();\n    }",
    "comment": " <p> Access the numerator as a <tt>int</tt>. </p>  @return the numerator as a <tt>int</tt>. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "BigFraction.multiply",
    "class_name": "org.apache.commons.math.fraction.BigFraction",
    "signature": "org.apache.commons.math.fraction.BigFraction.multiply(BigFraction)",
    "snippet": "    public BigFraction multiply(final BigFraction fraction) {\n        BigFraction ret = ZERO;\n\n        if (getNumeratorAsInt() != 0 && fraction.getNumeratorAsInt() != 0) {\n            ret = new BigFraction(numerator.multiply(fraction.numerator), denominator.multiply(fraction.denominator));\n        }\n\n        return ret;\n    }",
    "comment": " <p> Multiplies the value of this fraction by another, returning the result in reduced form. </p>  @param fraction the fraction to multiply by, must not be <code>null</code>. @return a {@link BigFraction} instance with the resulting values. @throws NullPointerException if the fraction is <code>null</code>. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "BigFraction.multiply",
    "class_name": "org.apache.commons.math.fraction.BigFraction",
    "signature": "org.apache.commons.math.fraction.BigFraction.multiply(BigInteger)",
    "snippet": "    public BigFraction multiply(final BigInteger bg) {\n        return new BigFraction(bg.multiply(numerator), denominator);\n    }",
    "comment": " <p> Multiplies the value of this fraction by the passed <code>BigInteger</code>, returning the result in reduced form. </p>  @param bg the <code>BigInteger</code> to multiply by. @return a <code>BigFraction</code> instance with the resulting values. @throws NullPointerException if the bg is <code>null</code>. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "BigFraction.negate",
    "class_name": "org.apache.commons.math.fraction.BigFraction",
    "signature": "org.apache.commons.math.fraction.BigFraction.negate()",
    "snippet": "    public BigFraction negate() {\n        return new BigFraction(numerator.negate(), denominator);\n    }",
    "comment": " <p> Return the additive inverse of this fraction, returning the result in reduced form. </p>  @return the negation of this fraction. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "BigFraction.reciprocal",
    "class_name": "org.apache.commons.math.fraction.BigFraction",
    "signature": "org.apache.commons.math.fraction.BigFraction.reciprocal()",
    "snippet": "    public BigFraction reciprocal() {\n        return new BigFraction(denominator, numerator);\n    }",
    "comment": " <p> Return the multiplicative inverse of this fraction. </p>  @return the reciprocal fraction. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "BigFraction.reduce",
    "class_name": "org.apache.commons.math.fraction.BigFraction",
    "signature": "org.apache.commons.math.fraction.BigFraction.reduce()",
    "snippet": "    public BigFraction reduce() {\n        final BigInteger gcd = numerator.gcd(denominator);\n        return new BigFraction(numerator.divide(gcd), denominator.divide(gcd));\n    }",
    "comment": " <p> Reduce this <code>BigFraction</code> to its lowest terms. </p>  @return the reduced <code>BigFraction</code>. It doesn't change anything if the fraction can be reduced. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "BigFraction.subtract",
    "class_name": "org.apache.commons.math.fraction.BigFraction",
    "signature": "org.apache.commons.math.fraction.BigFraction.subtract(BigFraction)",
    "snippet": "    public BigFraction subtract(final BigFraction fraction) {\n        if (ZERO.equals(fraction)) {\n            return this;\n        }\n\n        BigInteger num = null;\n        BigInteger den = null;\n        if (denominator.equals(fraction.denominator)) {\n            num = numerator.subtract(fraction.numerator);\n            den = denominator;\n        } else {\n            num = (numerator.multiply(fraction.denominator)).subtract((fraction.numerator).multiply(denominator));\n            den = denominator.multiply(fraction.denominator);\n        }\n        return new BigFraction(num, den);\n\n    }",
    "comment": " <p> Subtracts the value of another fraction from the value of this one, returning the result in reduced form. </p>  @param fraction the {@link BigFraction} to subtract, must not be <code>null</code>. @return a {@link BigFraction} instance with the resulting values @throws NullPointerException if the fraction is <code>null</code>. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "BigFraction.subtract",
    "class_name": "org.apache.commons.math.fraction.BigFraction",
    "signature": "org.apache.commons.math.fraction.BigFraction.subtract(BigInteger)",
    "snippet": "    public BigFraction subtract(final BigInteger bg) {\n        return new BigFraction(numerator.subtract(denominator.multiply(bg)), denominator);\n    }",
    "comment": " <p> Subtracts the value of an {@link BigInteger} from the value of this one, returning the result in reduced form. </p>  @param bg the {@link BigInteger} to subtract, must'nt be <code>null</code>. @return a <code>BigFraction</code> instance with the resulting values. @throws NullPointerException if the {@link BigInteger} is <code>null</code>. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "BigFractionField.getInstance",
    "class_name": "org.apache.commons.math.fraction.BigFractionField",
    "signature": "org.apache.commons.math.fraction.BigFractionField.getInstance()",
    "snippet": "    public static BigFractionField getInstance() {\n        return LazyHolder.INSTANCE;\n    }",
    "comment": "Get the unique instance. @return the unique instance ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "BigFractionField.getOne",
    "class_name": "org.apache.commons.math.fraction.BigFractionField",
    "signature": "org.apache.commons.math.fraction.BigFractionField.getOne()",
    "snippet": "    public BigFraction getOne() {\n        return BigFraction.ONE;\n    }",
    "comment": "{@inheritDoc} */",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "BigFractionField.getZero",
    "class_name": "org.apache.commons.math.fraction.BigFractionField",
    "signature": "org.apache.commons.math.fraction.BigFractionField.getZero()",
    "snippet": "    public BigFraction getZero() {\n        return BigFraction.ZERO;\n    }",
    "comment": "{@inheritDoc} */",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "AbstractFieldMatrix.AbstractFieldMatrix",
    "class_name": "org.apache.commons.math.linear.AbstractFieldMatrix",
    "signature": "org.apache.commons.math.linear.AbstractFieldMatrix.AbstractFieldMatrix(Field)",
    "snippet": "    protected AbstractFieldMatrix(final Field<T> field) {\n        this.field = field;\n    }",
    "comment": " Creates a matrix with no data @param field field to which the elements belong ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "AbstractFieldMatrix.AbstractFieldMatrix",
    "class_name": "org.apache.commons.math.linear.AbstractFieldMatrix",
    "signature": "org.apache.commons.math.linear.AbstractFieldMatrix.AbstractFieldMatrix(Field,int,int)",
    "snippet": "    protected AbstractFieldMatrix(final Field<T> field,\n                                  final int rowDimension, final int columnDimension)\n        throws IllegalArgumentException {\n        if (rowDimension <= 0 ) {\n            throw MathRuntimeException.createIllegalArgumentException(\n                    \"invalid row dimension {0} (must be positive)\",\n                    rowDimension);\n        }\n        if (columnDimension <= 0) {\n            throw MathRuntimeException.createIllegalArgumentException(\n                    \"invalid column dimension {0} (must be positive)\",\n                    columnDimension);\n        }\n        this.field = field;\n    }",
    "comment": " Create a new FieldMatrix<T> with the supplied row and column dimensions.  @param field field to which the elements belong @param rowDimension  the number of rows in the new matrix @param columnDimension  the number of columns in the new matrix @throws IllegalArgumentException if row or column dimension is not positive ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "AbstractFieldMatrix.buildArray",
    "class_name": "org.apache.commons.math.linear.AbstractFieldMatrix",
    "signature": "org.apache.commons.math.linear.AbstractFieldMatrix.buildArray(Field,int,int)",
    "snippet": "    @SuppressWarnings(\"unchecked\")\n    protected static <T extends FieldElement<T>> T[][] buildArray(final Field<T> field,\n                                                                  final int rows,\n                                                                  final int columns) {\n        if (columns < 0) {\n            T[] dummyRow = (T[]) Array.newInstance(field.getZero().getClass(), 0);\n            return (T[][]) Array.newInstance(dummyRow.getClass(), rows);\n        }\n        T[][] array =\n            (T[][]) Array.newInstance(field.getZero().getClass(), new int[] { rows, columns });\n        for (int i = 0; i < array.length; ++i) {\n            Arrays.fill(array[i], field.getZero());\n        }\n        return array;\n    }",
    "comment": "Build an array of elements. <p> Complete arrays are filled with field.getZero() </p> @param <T> the type of the field elements @param field field to which array elements belong @param rows number of rows @param columns number of columns (may be negative to build partial arrays in the same way <code>new Field[rows][]</code> works) @return a new array ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "AbstractFieldMatrix.getField",
    "class_name": "org.apache.commons.math.linear.AbstractFieldMatrix",
    "signature": "org.apache.commons.math.linear.AbstractFieldMatrix.getField()",
    "snippet": "    public Field<T> getField() {\n        return field;\n    }",
    "comment": "{@inheritDoc} */",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "AbstractFieldMatrix.isSquare",
    "class_name": "org.apache.commons.math.linear.AbstractFieldMatrix",
    "signature": "org.apache.commons.math.linear.AbstractFieldMatrix.isSquare()",
    "snippet": "    public boolean isSquare() {\n        return getColumnDimension() == getRowDimension();\n    }",
    "comment": "{@inheritDoc} */",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "AbstractFieldMatrix.walkInOptimizedOrder",
    "class_name": "org.apache.commons.math.linear.AbstractFieldMatrix",
    "signature": "org.apache.commons.math.linear.AbstractFieldMatrix.walkInOptimizedOrder(FieldMatrixChangingVisitor)",
    "snippet": "    public T walkInOptimizedOrder(final FieldMatrixChangingVisitor<T> visitor)\n        throws MatrixVisitorException {\n        return walkInRowOrder(visitor);\n    }",
    "comment": "{@inheritDoc} */",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "AbstractFieldMatrix.walkInOptimizedOrder",
    "class_name": "org.apache.commons.math.linear.AbstractFieldMatrix",
    "signature": "org.apache.commons.math.linear.AbstractFieldMatrix.walkInOptimizedOrder(FieldMatrixPreservingVisitor)",
    "snippet": "    public T walkInOptimizedOrder(final FieldMatrixPreservingVisitor<T> visitor)\n        throws MatrixVisitorException {\n        return walkInRowOrder(visitor);\n    }",
    "comment": "{@inheritDoc} */",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "AbstractRealMatrix.AbstractRealMatrix",
    "class_name": "org.apache.commons.math.linear.AbstractRealMatrix",
    "signature": "org.apache.commons.math.linear.AbstractRealMatrix.AbstractRealMatrix()",
    "snippet": "    protected AbstractRealMatrix() {\n        lu = null;\n    }",
    "comment": " Creates a matrix with no data ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "AbstractRealMatrix.walkInOptimizedOrder",
    "class_name": "org.apache.commons.math.linear.AbstractRealMatrix",
    "signature": "org.apache.commons.math.linear.AbstractRealMatrix.walkInOptimizedOrder(RealMatrixPreservingVisitor)",
    "snippet": "    public double walkInOptimizedOrder(final RealMatrixPreservingVisitor visitor)\n        throws MatrixVisitorException {\n        return walkInRowOrder(visitor);\n    }",
    "comment": "{@inheritDoc} */",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "Array2DRowFieldMatrix.Array2DRowFieldMatrix",
    "class_name": "org.apache.commons.math.linear.Array2DRowFieldMatrix",
    "signature": "org.apache.commons.math.linear.Array2DRowFieldMatrix.Array2DRowFieldMatrix(Field,int,int)",
    "snippet": "    public Array2DRowFieldMatrix(final Field<T> field,\n                           final int rowDimension, final int columnDimension)\n        throws IllegalArgumentException {\n        super(field, rowDimension, columnDimension);\n        data = buildArray(field, rowDimension, columnDimension);\n    }",
    "comment": " Create a new FieldMatrix<T> with the supplied row and column dimensions.  @param field field to which the elements belong @param rowDimension  the number of rows in the new matrix @param columnDimension  the number of columns in the new matrix @throws IllegalArgumentException if row or column dimension is not positive ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "Array2DRowFieldMatrix.copyOut",
    "class_name": "org.apache.commons.math.linear.Array2DRowFieldMatrix",
    "signature": "org.apache.commons.math.linear.Array2DRowFieldMatrix.copyOut()",
    "snippet": "    private T[][] copyOut() {\n        final int nRows = this.getRowDimension();\n        final T[][] out = buildArray(getField(), nRows, getColumnDimension());\n        // can't copy 2-d array in one shot, otherwise get row references\n        for (int i = 0; i < nRows; i++) {\n            System.arraycopy(data[i], 0, out[i], 0, data[i].length);\n        }\n        return out;\n    }",
    "comment": " Returns a fresh copy of the underlying data array.  @return a copy of the underlying data array. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "Array2DRowFieldMatrix.getColumnDimension",
    "class_name": "org.apache.commons.math.linear.Array2DRowFieldMatrix",
    "signature": "org.apache.commons.math.linear.Array2DRowFieldMatrix.getColumnDimension()",
    "snippet": "    @Override\n    public int getColumnDimension() {\n        return ((data == null) || (data[0] == null)) ? 0 : data[0].length;\n    }",
    "comment": "{@inheritDoc} */",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "Array2DRowFieldMatrix.getData",
    "class_name": "org.apache.commons.math.linear.Array2DRowFieldMatrix",
    "signature": "org.apache.commons.math.linear.Array2DRowFieldMatrix.getData()",
    "snippet": "    @Override\n    public T[][] getData() {\n        return copyOut();\n    }",
    "comment": "{@inheritDoc} */",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "Array2DRowFieldMatrix.getEntry",
    "class_name": "org.apache.commons.math.linear.Array2DRowFieldMatrix",
    "signature": "org.apache.commons.math.linear.Array2DRowFieldMatrix.getEntry(int,int)",
    "snippet": "    @Override\n    public T getEntry(final int row, final int column)\n        throws MatrixIndexException {\n        try {\n            return data[row][column];\n        } catch (ArrayIndexOutOfBoundsException e) {\n            throw new MatrixIndexException(\n                      NO_ENTRY_MESSAGE, row, column, getRowDimension(), getColumnDimension());\n        }\n    }",
    "comment": "{@inheritDoc} */",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "Array2DRowFieldMatrix.getRowDimension",
    "class_name": "org.apache.commons.math.linear.Array2DRowFieldMatrix",
    "signature": "org.apache.commons.math.linear.Array2DRowFieldMatrix.getRowDimension()",
    "snippet": "    @Override\n    public int getRowDimension() {\n        return (data == null) ? 0 : data.length;\n    }",
    "comment": "{@inheritDoc} */",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "Array2DRowFieldMatrix.walkInRowOrder",
    "class_name": "org.apache.commons.math.linear.Array2DRowFieldMatrix",
    "signature": "org.apache.commons.math.linear.Array2DRowFieldMatrix.walkInRowOrder(FieldMatrixChangingVisitor)",
    "snippet": "    @Override\n    public T walkInRowOrder(final FieldMatrixChangingVisitor<T> visitor)\n        throws MatrixVisitorException {\n        final int rows    = getRowDimension();\n        final int columns = getColumnDimension();\n        visitor.start(rows, columns, 0, rows - 1, 0, columns - 1);\n        for (int i = 0; i < rows; ++i) {\n            final T[] rowI = data[i];\n            for (int j = 0; j < columns; ++j) {\n                rowI[j] = visitor.visit(i, j, rowI[j]);\n            }\n        }\n        return visitor.end();\n    }",
    "comment": "{@inheritDoc} */",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "Array2DRowFieldMatrix.walkInRowOrder",
    "class_name": "org.apache.commons.math.linear.Array2DRowFieldMatrix",
    "signature": "org.apache.commons.math.linear.Array2DRowFieldMatrix.walkInRowOrder(FieldMatrixPreservingVisitor)",
    "snippet": "    @Override\n    public T walkInRowOrder(final FieldMatrixPreservingVisitor<T> visitor)\n        throws MatrixVisitorException {\n        final int rows    = getRowDimension();\n        final int columns = getColumnDimension();\n        visitor.start(rows, columns, 0, rows - 1, 0, columns - 1);\n        for (int i = 0; i < rows; ++i) {\n            final T[] rowI = data[i];\n            for (int j = 0; j < columns; ++j) {\n                visitor.visit(i, j, rowI[j]);\n            }\n        }\n        return visitor.end();\n    }",
    "comment": "{@inheritDoc} */",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "Array2DRowRealMatrix.Array2DRowRealMatrix",
    "class_name": "org.apache.commons.math.linear.Array2DRowRealMatrix",
    "signature": "org.apache.commons.math.linear.Array2DRowRealMatrix.Array2DRowRealMatrix(double[][],boolean)",
    "snippet": "    public Array2DRowRealMatrix(final double[][] d, final boolean copyArray)\n        throws IllegalArgumentException, NullPointerException {\n        if (copyArray) {\n            copyIn(d);\n        } else {\n            if (d == null) {\n                throw new NullPointerException();\n            }\n            final int nRows = d.length;\n            if (nRows == 0) {\n                throw MathRuntimeException.createIllegalArgumentException(\n                      AT_LEAST_ONE_ROW_MESSAGE);\n            }\n            final int nCols = d[0].length;\n            if (nCols == 0) {\n                throw MathRuntimeException.createIllegalArgumentException(\n                      AT_LEAST_ONE_COLUMN_MESSAGE);\n            }\n            for (int r = 1; r < nRows; r++) {\n                if (d[r].length != nCols) {\n                    throw MathRuntimeException.createIllegalArgumentException(\n                          DIFFERENT_ROWS_LENGTHS_MESSAGE, nCols, d[r].length);\n                }\n            }\n            data = d;\n        }\n    }",
    "comment": " Create a new RealMatrix using the input array as the underlying data array. <p>If an array is built specially in order to be embedded in a RealMatrix and not used directly, the <code>copyArray</code> may be set to <code>false</code. This will prevent the copying and improve performance as no new array will be built and no data will be copied.</p> @param d data for new matrix @param copyArray if true, the input array will be copied, otherwise it will be referenced @throws IllegalArgumentException if <code>d</code> is not rectangular (not all rows have the same length) or empty @throws NullPointerException if <code>d</code> is null @see #Array2DRowRealMatrix(double[][]) ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "Array2DRowRealMatrix.getColumnDimension",
    "class_name": "org.apache.commons.math.linear.Array2DRowRealMatrix",
    "signature": "org.apache.commons.math.linear.Array2DRowRealMatrix.getColumnDimension()",
    "snippet": "    @Override\n    public int getColumnDimension() {\n        return ((data == null) || (data[0] == null)) ? 0 : data[0].length;\n    }",
    "comment": "{@inheritDoc} */",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "Array2DRowRealMatrix.getDataRef",
    "class_name": "org.apache.commons.math.linear.Array2DRowRealMatrix",
    "signature": "org.apache.commons.math.linear.Array2DRowRealMatrix.getDataRef()",
    "snippet": "    public double[][] getDataRef() {\n        return data;\n    }",
    "comment": " Returns a reference to the underlying data array. <p> Does <strong>not</strong> make a fresh copy of the underlying data.</p>  @return 2-dimensional array of entries ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "Array2DRowRealMatrix.getRowDimension",
    "class_name": "org.apache.commons.math.linear.Array2DRowRealMatrix",
    "signature": "org.apache.commons.math.linear.Array2DRowRealMatrix.getRowDimension()",
    "snippet": "    @Override\n    public int getRowDimension() {\n        return (data == null) ? 0 : data.length;\n    }",
    "comment": "{@inheritDoc} */",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "Array2DRowRealMatrix.multiply",
    "class_name": "org.apache.commons.math.linear.Array2DRowRealMatrix",
    "signature": "org.apache.commons.math.linear.Array2DRowRealMatrix.multiply(Array2DRowRealMatrix)",
    "snippet": "    public Array2DRowRealMatrix multiply(final Array2DRowRealMatrix m)\n        throws IllegalArgumentException {\n\n        // safety check\n        MatrixUtils.checkMultiplicationCompatible(this, m);\n\n        final int nRows = this.getRowDimension();\n        final int nCols = m.getColumnDimension();\n        final int nSum = this.getColumnDimension();\n        final double[][] outData = new double[nRows][nCols];\n        for (int row = 0; row < nRows; row++) {\n            final double[] dataRow    = data[row];\n            final double[] outDataRow = outData[row];\n            for (int col = 0; col < nCols; col++) {\n                double sum = 0;\n                for (int i = 0; i < nSum; i++) {\n                    sum += dataRow[i] * m.data[i][col];\n                }\n                outDataRow[col] = sum;\n            }\n        }\n\n        return new Array2DRowRealMatrix(outData, false);\n\n    }",
    "comment": " Returns the result of postmultiplying this by <code>m</code>. @param m    matrix to postmultiply by @return     this*m @throws     IllegalArgumentException if columnDimension(this) != rowDimension(m) ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "Array2DRowRealMatrix.walkInRowOrder",
    "class_name": "org.apache.commons.math.linear.Array2DRowRealMatrix",
    "signature": "org.apache.commons.math.linear.Array2DRowRealMatrix.walkInRowOrder(RealMatrixPreservingVisitor)",
    "snippet": "    @Override\n    public double walkInRowOrder(final RealMatrixPreservingVisitor visitor)\n        throws MatrixVisitorException {\n        final int rows    = getRowDimension();\n        final int columns = getColumnDimension();\n        visitor.start(rows, columns, 0, rows - 1, 0, columns - 1);\n        for (int i = 0; i < rows; ++i) {\n            final double[] rowI = data[i];\n            for (int j = 0; j < columns; ++j) {\n                visitor.visit(i, j, rowI[j]);\n            }\n        }\n        return visitor.end();\n    }",
    "comment": "{@inheritDoc} */",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "DefaultFieldMatrixChangingVisitor.end",
    "class_name": "org.apache.commons.math.linear.DefaultFieldMatrixChangingVisitor",
    "signature": "org.apache.commons.math.linear.DefaultFieldMatrixChangingVisitor.end()",
    "snippet": "    public T end() {\n        return zero;\n    }",
    "comment": "{@inheritDoc} */",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "DefaultFieldMatrixChangingVisitor.start",
    "class_name": "org.apache.commons.math.linear.DefaultFieldMatrixChangingVisitor",
    "signature": "org.apache.commons.math.linear.DefaultFieldMatrixChangingVisitor.start(int,int,int,int,int,int)",
    "snippet": "    public void start(int rows, int columns,\n                      int startRow, int endRow, int startColumn, int endColumn) {\n    }",
    "comment": "{@inheritDoc} */",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "DefaultFieldMatrixPreservingVisitor.end",
    "class_name": "org.apache.commons.math.linear.DefaultFieldMatrixPreservingVisitor",
    "signature": "org.apache.commons.math.linear.DefaultFieldMatrixPreservingVisitor.end()",
    "snippet": "    public T end() {\n        return zero;\n    }",
    "comment": "{@inheritDoc} */",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "FieldLUDecompositionImpl.FieldLUDecompositionImpl",
    "class_name": "org.apache.commons.math.linear.FieldLUDecompositionImpl",
    "signature": "org.apache.commons.math.linear.FieldLUDecompositionImpl.FieldLUDecompositionImpl(FieldMatrix)",
    "snippet": "    public FieldLUDecompositionImpl(FieldMatrix<T> matrix)\n        throws NonSquareMatrixException {\n\n        if (!matrix.isSquare()) {\n            throw new NonSquareMatrixException(matrix.getRowDimension(), matrix.getColumnDimension());\n        }\n\n        final int m = matrix.getColumnDimension();\n        field = matrix.getField();\n        lu = matrix.getData();\n        pivot = new int[m];\n        cachedL = null;\n        cachedU = null;\n        cachedP = null;\n\n        // Initialize permutation array and parity\n        for (int row = 0; row < m; row++) {\n            pivot[row] = row;\n        }\n        even     = true;\n        singular = false;\n\n        // Loop over columns\n        for (int col = 0; col < m; col++) {\n\n            T sum = field.getZero();\n\n            // upper\n            for (int row = 0; row < col; row++) {\n                final T[] luRow = lu[row];\n                sum = luRow[col];\n                for (int i = 0; i < row; i++) {\n                    sum = sum.subtract(luRow[i].multiply(lu[i][col]));\n                }\n                luRow[col] = sum;\n            }\n\n            // lower\n            int nonZero = col; // permutation row\n            for (int row = col; row < m; row++) {\n                final T[] luRow = lu[row];\n                sum = luRow[col];\n                for (int i = 0; i < col; i++) {\n                    sum = sum.subtract(luRow[i].multiply(lu[i][col]));\n                }\n                luRow[col] = sum;\n\n                if (lu[nonZero][col].equals(field.getZero())) {\n                    // try to select a better permutation choice\n                    ++nonZero;\n                }\n            }\n\n            // Singularity check\n            if (nonZero >= m) {\n                singular = true;\n                return;\n            }\n\n            // Pivot if necessary\n            if (nonZero != col) {\n                T tmp = field.getZero();\n                for (int i = 0; i < m; i++) {\n                    tmp = lu[nonZero][i];\n                    lu[nonZero][i] = lu[col][i];\n                    lu[col][i] = tmp;\n                }\n                int temp = pivot[nonZero];\n                pivot[nonZero] = pivot[col];\n                pivot[col] = temp;\n                even = !even;\n            }\n\n            // Divide the lower elements by the \"winning\" diagonal elt.\n            final T luDiag = lu[col][col];\n            for (int row = col + 1; row < m; row++) {\n                final T[] luRow = lu[row];\n                luRow[col] = luRow[col].divide(luDiag);\n            }\n        }\n\n    }",
    "comment": " Calculates the LU-decomposition of the given matrix. @param matrix The matrix to decompose. @exception NonSquareMatrixException if matrix is not square ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "FieldLUDecompositionImpl.getSolver",
    "class_name": "org.apache.commons.math.linear.FieldLUDecompositionImpl",
    "signature": "org.apache.commons.math.linear.FieldLUDecompositionImpl.getSolver()",
    "snippet": "    public FieldDecompositionSolver<T> getSolver() {\n        return new Solver<T>(field, lu, pivot, singular);\n    }",
    "comment": "{@inheritDoc} */",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "Solver.getInverse",
    "class_name": "org.apache.commons.math.linear.FieldLUDecompositionImpl$Solver",
    "signature": "org.apache.commons.math.linear.FieldLUDecompositionImpl$Solver.getInverse()",
    "snippet": "        public FieldMatrix<T> getInverse() throws InvalidMatrixException {\n            final int m = pivot.length;\n            final T one = field.getOne();\n            FieldMatrix<T> identity = new Array2DRowFieldMatrix<T>(field, m, m);\n            for (int i = 0; i < m; ++i) {\n                identity.setEntry(i, i, one);\n            }\n            return solve(identity);\n        }",
    "comment": "{@inheritDoc} */",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "Solver.solve",
    "class_name": "org.apache.commons.math.linear.FieldLUDecompositionImpl$Solver",
    "signature": "org.apache.commons.math.linear.FieldLUDecompositionImpl$Solver.solve(FieldMatrix)",
    "snippet": "        public FieldMatrix<T> solve(FieldMatrix<T> b)\n            throws IllegalArgumentException, InvalidMatrixException {\n\n            final int m = pivot.length;\n            if (b.getRowDimension() != m) {\n                throw MathRuntimeException.createIllegalArgumentException(\n                        \"dimensions mismatch: got {0}x{1} but expected {2}x{3}\",\n                        b.getRowDimension(), b.getColumnDimension(), m, \"n\");\n            }\n            if (singular) {\n                throw new SingularMatrixException();\n            }\n\n            final int nColB = b.getColumnDimension();\n\n            // Apply permutations to b\n            @SuppressWarnings(\"unchecked\") // field is of type T\n            final T[][] bp = (T[][]) Array.newInstance(field.getZero().getClass(), new int[] { m, nColB });\n            for (int row = 0; row < m; row++) {\n                final T[] bpRow = bp[row];\n                final int pRow = pivot[row];\n                for (int col = 0; col < nColB; col++) {\n                    bpRow[col] = b.getEntry(pRow, col);\n                }\n            }\n\n            // Solve LY = b\n            for (int col = 0; col < m; col++) {\n                final T[] bpCol = bp[col];\n                for (int i = col + 1; i < m; i++) {\n                    final T[] bpI = bp[i];\n                    final T luICol = lu[i][col];\n                    for (int j = 0; j < nColB; j++) {\n                        bpI[j] = bpI[j].subtract(bpCol[j].multiply(luICol));\n                    }\n                }\n            }\n\n            // Solve UX = Y\n            for (int col = m - 1; col >= 0; col--) {\n                final T[] bpCol = bp[col];\n                final T luDiag = lu[col][col];\n                for (int j = 0; j < nColB; j++) {\n                    bpCol[j] = bpCol[j].divide(luDiag);\n                }\n                for (int i = 0; i < col; i++) {\n                    final T[] bpI = bp[i];\n                    final T luICol = lu[i][col];\n                    for (int j = 0; j < nColB; j++) {\n                        bpI[j] = bpI[j].subtract(bpCol[j].multiply(luICol));\n                    }\n                }\n            }\n\n            return new Array2DRowFieldMatrix<T>(bp, false);\n\n        }",
    "comment": "{@inheritDoc} */",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "MatrixUtils.bigFractionMatrixToRealMatrix",
    "class_name": "org.apache.commons.math.linear.MatrixUtils",
    "signature": "org.apache.commons.math.linear.MatrixUtils.bigFractionMatrixToRealMatrix(FieldMatrix)",
    "snippet": "    public static Array2DRowRealMatrix bigFractionMatrixToRealMatrix(final FieldMatrix<BigFraction> m) {\n        final BigFractionMatrixConverter converter = new BigFractionMatrixConverter();\n        m.walkInOptimizedOrder(converter);\n        return converter.getConvertedMatrix();\n    }",
    "comment": " Convert a {@link FieldMatrix}/{@link BigFraction} matrix to a {@link RealMatrix}. @param m matrix to convert @return converted matrix ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "MatrixUtils.checkMultiplicationCompatible",
    "class_name": "org.apache.commons.math.linear.MatrixUtils",
    "signature": "org.apache.commons.math.linear.MatrixUtils.checkMultiplicationCompatible(AnyMatrix,AnyMatrix)",
    "snippet": "    public static void checkMultiplicationCompatible(final AnyMatrix left, final AnyMatrix right)\n        throws IllegalArgumentException {\n        if (left.getColumnDimension() != right.getRowDimension()) {\n            throw MathRuntimeException.createIllegalArgumentException(\n                    \"{0}x{1} and {2}x{3} matrices are not multiplication compatible\",\n                    left.getRowDimension(), left.getColumnDimension(),\n                    right.getRowDimension(), right.getColumnDimension());\n        }\n    }",
    "comment": " Check if matrices are multiplication compatible @param left left hand side matrix @param right right hand side matrix @exception IllegalArgumentException if matrices are not multiplication compatible ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "BigFractionMatrixConverter.getConvertedMatrix",
    "class_name": "org.apache.commons.math.linear.MatrixUtils$BigFractionMatrixConverter",
    "signature": "org.apache.commons.math.linear.MatrixUtils$BigFractionMatrixConverter.getConvertedMatrix()",
    "snippet": "        Array2DRowRealMatrix getConvertedMatrix() {\n            return new Array2DRowRealMatrix(data, false);\n        }",
    "comment": "Get the converted matrix. @return converted matrix ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "BigFractionMatrixConverter.start",
    "class_name": "org.apache.commons.math.linear.MatrixUtils$BigFractionMatrixConverter",
    "signature": "org.apache.commons.math.linear.MatrixUtils$BigFractionMatrixConverter.start(int,int,int,int,int,int)",
    "snippet": "        @Override\n        public void start(int rows, int columns,\n                          int startRow, int endRow, int startColumn, int endColumn) {\n            data = new double[rows][columns];\n        }",
    "comment": "{@inheritDoc} */",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "BigFractionMatrixConverter.visit",
    "class_name": "org.apache.commons.math.linear.MatrixUtils$BigFractionMatrixConverter",
    "signature": "org.apache.commons.math.linear.MatrixUtils$BigFractionMatrixConverter.visit(int,int,BigFraction)",
    "snippet": "        @Override\n        public void visit(int row, int column, BigFraction value) {\n            data[row][column] = value.doubleValue();\n        }",
    "comment": "{@inheritDoc} */",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "AbstractIntegrator.AbstractIntegrator",
    "class_name": "org.apache.commons.math.ode.AbstractIntegrator",
    "signature": "org.apache.commons.math.ode.AbstractIntegrator.AbstractIntegrator(String)",
    "snippet": "    public AbstractIntegrator(final String name) {\n        this.name = name;\n        stepHandlers = new ArrayList<StepHandler>();\n        stepStart = Double.NaN;\n        stepSize  = Double.NaN;\n        eventsHandlersManager = new CombinedEventsManager();\n        setMaxEvaluations(-1);\n        resetEvaluations();\n    }",
    "comment": "Build an instance. @param name name of the method ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "AbstractIntegrator.addEndTimeChecker",
    "class_name": "org.apache.commons.math.ode.AbstractIntegrator",
    "signature": "org.apache.commons.math.ode.AbstractIntegrator.addEndTimeChecker(double,double,CombinedEventsManager)",
    "snippet": "    protected CombinedEventsManager addEndTimeChecker(final double startTime,\n                                                      final double endTime,\n                                                      final CombinedEventsManager manager) {\n        CombinedEventsManager newManager = new CombinedEventsManager();\n        for (final EventState state : manager.getEventsStates()) {\n            newManager.addEventHandler(state.getEventHandler(),\n                                       state.getMaxCheckInterval(),\n                                       state.getConvergence(),\n                                       state.getMaxIterationCount());\n        }\n        newManager.addEventHandler(new EndTimeChecker(endTime),\n                                   Double.POSITIVE_INFINITY,\n                                   Math.ulp(Math.max(Math.abs(startTime), Math.abs(endTime))),\n                                   100);\n        return newManager;\n    }",
    "comment": "Add an event handler for end time checking. <p>This method can be used to simplify handling of integration end time. It leverages the nominal stop condition with the exceptional stop conditions.</p> @param startTime integration start time @param endTime desired end time @param manager manager containing the user-defined handlers @return a new manager containing all the user-defined handlers plus a dedicated manager triggering a stop event at entTime ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "AbstractIntegrator.addStepHandler",
    "class_name": "org.apache.commons.math.ode.AbstractIntegrator",
    "signature": "org.apache.commons.math.ode.AbstractIntegrator.addStepHandler(StepHandler)",
    "snippet": "    public void addStepHandler(final StepHandler handler) {\n        stepHandlers.add(handler);\n    }",
    "comment": "{@inheritDoc} */",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "AbstractIntegrator.clearEventHandlers",
    "class_name": "org.apache.commons.math.ode.AbstractIntegrator",
    "signature": "org.apache.commons.math.ode.AbstractIntegrator.clearEventHandlers()",
    "snippet": "    public void clearEventHandlers() {\n        eventsHandlersManager.clearEventsHandlers();\n    }",
    "comment": "{@inheritDoc} */",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "AbstractIntegrator.clearStepHandlers",
    "class_name": "org.apache.commons.math.ode.AbstractIntegrator",
    "signature": "org.apache.commons.math.ode.AbstractIntegrator.clearStepHandlers()",
    "snippet": "    public void clearStepHandlers() {\n        stepHandlers.clear();\n    }",
    "comment": "{@inheritDoc} */",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "AbstractIntegrator.computeDerivatives",
    "class_name": "org.apache.commons.math.ode.AbstractIntegrator",
    "signature": "org.apache.commons.math.ode.AbstractIntegrator.computeDerivatives(double,double[],double[])",
    "snippet": "    public void computeDerivatives(final double t, final double[] y, final double[] yDot)\n        throws DerivativeException {\n        if (++evaluations > maxEvaluations) {\n            throw new DerivativeException(new MaxEvaluationsExceededException(maxEvaluations));\n        }\n        equations.computeDerivatives(t, y, yDot);\n    }",
    "comment": "Compute the derivatives and check the number of evaluations. @param t current value of the independent <I>time</I> variable @param y array containing the current value of the state vector @param yDot placeholder array where to put the time derivative of the state vector @throws DerivativeException this exception is propagated to the caller if the underlying user function triggers one ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "AbstractIntegrator.getCurrentSignedStepsize",
    "class_name": "org.apache.commons.math.ode.AbstractIntegrator",
    "signature": "org.apache.commons.math.ode.AbstractIntegrator.getCurrentSignedStepsize()",
    "snippet": "    public double getCurrentSignedStepsize() {\n        return stepSize;\n    }",
    "comment": "{@inheritDoc} */",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "AbstractIntegrator.getEvaluations",
    "class_name": "org.apache.commons.math.ode.AbstractIntegrator",
    "signature": "org.apache.commons.math.ode.AbstractIntegrator.getEvaluations()",
    "snippet": "    public int getEvaluations() {\n        return evaluations;\n    }",
    "comment": "{@inheritDoc} */",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "AbstractIntegrator.requiresDenseOutput",
    "class_name": "org.apache.commons.math.ode.AbstractIntegrator",
    "signature": "org.apache.commons.math.ode.AbstractIntegrator.requiresDenseOutput()",
    "snippet": "    protected boolean requiresDenseOutput() {\n        for (StepHandler handler : stepHandlers) {\n            if (handler.requiresDenseOutput()) {\n                return true;\n            }\n        }\n        return false;\n    }",
    "comment": "Check if one of the step handlers requires dense output. @return true if one of the step handlers requires dense output ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "AbstractIntegrator.resetEvaluations",
    "class_name": "org.apache.commons.math.ode.AbstractIntegrator",
    "signature": "org.apache.commons.math.ode.AbstractIntegrator.resetEvaluations()",
    "snippet": "    protected void resetEvaluations() {\n        evaluations = 0;\n    }",
    "comment": "Reset the number of evaluations to zero. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "AbstractIntegrator.sanityChecks",
    "class_name": "org.apache.commons.math.ode.AbstractIntegrator",
    "signature": "org.apache.commons.math.ode.AbstractIntegrator.sanityChecks(FirstOrderDifferentialEquations,double,double[],double,double[])",
    "snippet": "    protected void sanityChecks(final FirstOrderDifferentialEquations ode,\n                                final double t0, final double[] y0,\n                                final double t, final double[] y)\n        throws IntegratorException {\n\n        if (ode.getDimension() != y0.length) {\n            throw new IntegratorException(\n                    \"dimensions mismatch: ODE problem has dimension {0},\" +\n                    \" initial state vector has dimension {1}\",\n                    ode.getDimension(), y0.length);\n        }\n\n        if (ode.getDimension() != y.length) {\n            throw new IntegratorException(\n                    \"dimensions mismatch: ODE problem has dimension {0},\" +\n                    \" final state vector has dimension {1}\",\n                    ode.getDimension(), y.length);\n        }\n\n        if (Math.abs(t - t0) <= 1.0e-12 * Math.max(Math.abs(t0), Math.abs(t))) {\n            throw new IntegratorException(\n                    \"too small integration interval: length = {0}\",\n                    Math.abs(t - t0));\n        }\n\n    }",
    "comment": "Perform some sanity checks on the integration parameters. @param ode differential equations set @param t0 start time @param y0 state vector at t0 @param t target time for the integration @param y placeholder where to put the state vector @exception IntegratorException if some inconsistency is detected ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "AbstractIntegrator.setEquations",
    "class_name": "org.apache.commons.math.ode.AbstractIntegrator",
    "signature": "org.apache.commons.math.ode.AbstractIntegrator.setEquations(FirstOrderDifferentialEquations)",
    "snippet": "    protected void setEquations(final FirstOrderDifferentialEquations equations) {\n        this.equations = equations;\n    }",
    "comment": "Set the differential equations. @param equations differential equations to integrate @see #computeDerivatives(double, double[], double[]) ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "AbstractIntegrator.setMaxEvaluations",
    "class_name": "org.apache.commons.math.ode.AbstractIntegrator",
    "signature": "org.apache.commons.math.ode.AbstractIntegrator.setMaxEvaluations(int)",
    "snippet": "    public void setMaxEvaluations(int maxEvaluations) {\n        this.maxEvaluations = (maxEvaluations < 0) ? Integer.MAX_VALUE : maxEvaluations;\n    }",
    "comment": "{@inheritDoc} */",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "EndTimeChecker.eventOccurred",
    "class_name": "org.apache.commons.math.ode.AbstractIntegrator$EndTimeChecker",
    "signature": "org.apache.commons.math.ode.AbstractIntegrator$EndTimeChecker.eventOccurred(double,double[],boolean)",
    "snippet": "        public int eventOccurred(double t, double[] y, boolean increasing) {\n            return STOP;\n        }",
    "comment": "{@inheritDoc} */",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "EndTimeChecker.g",
    "class_name": "org.apache.commons.math.ode.AbstractIntegrator$EndTimeChecker",
    "signature": "org.apache.commons.math.ode.AbstractIntegrator$EndTimeChecker.g(double,double[])",
    "snippet": "        public double g(double t, double[] y) {\n            return t - endTime;\n        }",
    "comment": "{@inheritDoc} */",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "DerivativeException.DerivativeException",
    "class_name": "org.apache.commons.math.ode.DerivativeException",
    "signature": "org.apache.commons.math.ode.DerivativeException.DerivativeException(Throwable)",
    "snippet": "  public DerivativeException(final Throwable cause) {\n    super(cause);\n  }",
    "comment": "Build an instance from an underlying cause. @param cause cause for the exception ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "MultistepIntegrator.MultistepIntegrator",
    "class_name": "org.apache.commons.math.ode.MultistepIntegrator",
    "signature": "org.apache.commons.math.ode.MultistepIntegrator.MultistepIntegrator(String,int,int,double,double,double,double)",
    "snippet": "    protected MultistepIntegrator(final String name, final int nSteps,\n                                  final int order,\n                                  final double minStep, final double maxStep,\n                                  final double scalAbsoluteTolerance,\n                                  final double scalRelativeTolerance) {\n\n        super(name, minStep, maxStep, scalAbsoluteTolerance, scalRelativeTolerance);\n\n        if (nSteps <= 0) {\n            throw MathRuntimeException.createIllegalArgumentException(\n                  \"{0} method needs at least one previous point\",\n                  name);\n        }\n\n        starter = new DormandPrince853Integrator(minStep, maxStep,\n                                                 scalAbsoluteTolerance,\n                                                 scalRelativeTolerance);\n        this.nSteps = nSteps;\n\n        exp = -1.0 / order;\n\n        // set the default values of the algorithm control parameters\n        setSafety(0.9);\n        setMinReduction(0.2);\n        setMaxGrowth(Math.pow(2.0, -exp));\n\n    }",
    "comment": " Build a multistep integrator with the given stepsize bounds. <p>The default starter integrator is set to the {@link DormandPrince853Integrator Dormand-Prince 8(5,3)} integrator with some defaults settings.</p> <p> The default max growth factor is set to a quite low value: 2<sup>1/order</sup>. </p> @param name name of the method @param nSteps number of steps of the multistep method (excluding the one being computed) @param order order of the method @param minStep minimal step (must be positive even for backward integration), the last step can be smaller than this @param maxStep maximal step (must be positive even for backward integration) @param scalAbsoluteTolerance allowed absolute error @param scalRelativeTolerance allowed relative error ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "MultistepIntegrator.computeStepGrowShrinkFactor",
    "class_name": "org.apache.commons.math.ode.MultistepIntegrator",
    "signature": "org.apache.commons.math.ode.MultistepIntegrator.computeStepGrowShrinkFactor(double)",
    "snippet": "    protected double computeStepGrowShrinkFactor(final double error) {\n        return Math.min(maxGrowth, Math.max(minReduction, safety * Math.pow(error, exp)));\n    }",
    "comment": "Compute step grow/shrink factor according to normalized error. @param error normalized error of the current step @return grow/shrink factor for next step ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "MultistepIntegrator.setMaxGrowth",
    "class_name": "org.apache.commons.math.ode.MultistepIntegrator",
    "signature": "org.apache.commons.math.ode.MultistepIntegrator.setMaxGrowth(double)",
    "snippet": "    public void setMaxGrowth(final double maxGrowth) {\n        this.maxGrowth = maxGrowth;\n    }",
    "comment": "Set the maximal growth factor for stepsize control. @param maxGrowth maximal growth factor ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "MultistepIntegrator.setMinReduction",
    "class_name": "org.apache.commons.math.ode.MultistepIntegrator",
    "signature": "org.apache.commons.math.ode.MultistepIntegrator.setMinReduction(double)",
    "snippet": "    public void setMinReduction(final double minReduction) {\n        this.minReduction = minReduction;\n    }",
    "comment": "Set the minimal reduction factor for stepsize control. @param minReduction minimal reduction factor ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "MultistepIntegrator.setSafety",
    "class_name": "org.apache.commons.math.ode.MultistepIntegrator",
    "signature": "org.apache.commons.math.ode.MultistepIntegrator.setSafety(double)",
    "snippet": "    public void setSafety(final double safety) {\n      this.safety = safety;\n    }",
    "comment": "Set the safety factor for stepsize control. @param safety safety factor ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "MultistepIntegrator.start",
    "class_name": "org.apache.commons.math.ode.MultistepIntegrator",
    "signature": "org.apache.commons.math.ode.MultistepIntegrator.start(double,double[],double)",
    "snippet": "    protected void start(final double t0, final double[] y0, final double t)\n        throws DerivativeException, IntegratorException {\n\n        // make sure NO user event nor user step handler is triggered,\n        // this is the task of the top level integrator, not the task\n        // of the starter integrator\n        starter.clearEventHandlers();\n        starter.clearStepHandlers();\n\n        // set up one specific step handler to extract initial Nordsieck vector\n        starter.addStepHandler(new NordsieckInitializer(y0.length));\n\n        // start integration, expecting a InitializationCompletedMarkerException\n        try {\n            starter.integrate(new CountingDifferentialEquations(y0.length),\n                              t0, y0, t, new double[y0.length]);\n        } catch (DerivativeException de) {\n            if (!(de instanceof InitializationCompletedMarkerException)) {\n                // this is not the expected nominal interruption of the start integrator\n                throw de;\n            }\n        }\n\n        // remove the specific step handler\n        starter.clearStepHandlers();\n\n    }",
    "comment": "Start the integration. <p>This method computes one step using the underlying starter integrator, and initializes the Nordsieck vector at step start. The starter integrator purpose is only to establish initial conditions, it does not really change time by itself. The top level multistep integrator remains in charge of handling time propagation and events handling as it will starts its own computation right from the beginning. In a sense, the starter integrator can be seen as a dummy one and so it will never trigger any user event nor call any user step handler.</p> @param t0 initial time @param y0 initial value of the state vector at t0 @param t target time for the integration (can be set to a value smaller than <code>t0</code> for backward integration) @throws IntegratorException if the integrator cannot perform integration @throws DerivativeException this exception is propagated to the caller if the underlying user function triggers one ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "CountingDifferentialEquations.computeDerivatives",
    "class_name": "org.apache.commons.math.ode.MultistepIntegrator$CountingDifferentialEquations",
    "signature": "org.apache.commons.math.ode.MultistepIntegrator$CountingDifferentialEquations.computeDerivatives(double,double[],double[])",
    "snippet": "        public void computeDerivatives(double t, double[] y, double[] dot)\n                throws DerivativeException {\n            MultistepIntegrator.this.computeDerivatives(t, y, dot);\n        }",
    "comment": "{@inheritDoc} */",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "CountingDifferentialEquations.getDimension",
    "class_name": "org.apache.commons.math.ode.MultistepIntegrator$CountingDifferentialEquations",
    "signature": "org.apache.commons.math.ode.MultistepIntegrator$CountingDifferentialEquations.getDimension()",
    "snippet": "        public int getDimension() {\n            return dimension;\n        }",
    "comment": "{@inheritDoc} */",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "NordsieckInitializer.handleStep",
    "class_name": "org.apache.commons.math.ode.MultistepIntegrator$NordsieckInitializer",
    "signature": "org.apache.commons.math.ode.MultistepIntegrator$NordsieckInitializer.handleStep(StepInterpolator,boolean)",
    "snippet": "        public void handleStep(StepInterpolator interpolator, boolean isLast)\n            throws DerivativeException {\n\n            final double prev = interpolator.getPreviousTime();\n            final double curr = interpolator.getCurrentTime();\n            stepStart = prev;\n            stepSize  = (curr - prev) / (nSteps + 1);\n\n            // compute the first scaled derivative\n            interpolator.setInterpolatedTime(prev);\n            scaled = interpolator.getInterpolatedDerivatives().clone();\n            for (int j = 0; j < n; ++j) {\n                scaled[j] *= stepSize;\n            }\n\n            // compute the high order scaled derivatives\n            final double[][] multistep = new double[nSteps][];\n            for (int i = 1; i <= nSteps; ++i) {\n                interpolator.setInterpolatedTime(prev + stepSize * i);\n                final double[] msI = interpolator.getInterpolatedDerivatives().clone();\n                for (int j = 0; j < n; ++j) {\n                    msI[j] *= stepSize;\n                }\n                multistep[i - 1] = msI;\n            }\n            nordsieck = initializeHighOrderDerivatives(scaled, multistep);\n\n            // stop the integrator after the first step has been handled\n            throw new InitializationCompletedMarkerException();\n\n        }",
    "comment": "{@inheritDoc} */",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "NordsieckInitializer.requiresDenseOutput",
    "class_name": "org.apache.commons.math.ode.MultistepIntegrator$NordsieckInitializer",
    "signature": "org.apache.commons.math.ode.MultistepIntegrator$NordsieckInitializer.requiresDenseOutput()",
    "snippet": "        public boolean requiresDenseOutput() {\n            return true;\n        }",
    "comment": "{@inheritDoc} */",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "NordsieckInitializer.reset",
    "class_name": "org.apache.commons.math.ode.MultistepIntegrator$NordsieckInitializer",
    "signature": "org.apache.commons.math.ode.MultistepIntegrator$NordsieckInitializer.reset()",
    "snippet": "        public void reset() {\n            // nothing to do\n        }",
    "comment": "{@inheritDoc} */",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "CombinedEventsManager.CombinedEventsManager",
    "class_name": "org.apache.commons.math.ode.events.CombinedEventsManager",
    "signature": "org.apache.commons.math.ode.events.CombinedEventsManager.CombinedEventsManager()",
    "snippet": "    public CombinedEventsManager() {\n        states      = new ArrayList<EventState>();\n        first       = null;\n        initialized = false;\n    }",
    "comment": "Simple constructor. Create an empty manager ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "CombinedEventsManager.addEventHandler",
    "class_name": "org.apache.commons.math.ode.events.CombinedEventsManager",
    "signature": "org.apache.commons.math.ode.events.CombinedEventsManager.addEventHandler(EventHandler,double,double,int)",
    "snippet": "    public void addEventHandler(final EventHandler handler, final double maxCheckInterval,\n                                final double convergence, final int maxIterationCount) {\n        states.add(new EventState(handler, maxCheckInterval,\n                                  convergence, maxIterationCount));\n    }",
    "comment": "Add an events handler. @param handler event handler @param maxCheckInterval maximal time interval between events checks (this interval prevents missing sign changes in case the integration steps becomes very large) @param convergence convergence threshold in the event time search @param maxIterationCount upper limit of the iteration count in the event time search @see #getEventsHandlers() @see #clearEventsHandlers() ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "CombinedEventsManager.clearEventsHandlers",
    "class_name": "org.apache.commons.math.ode.events.CombinedEventsManager",
    "signature": "org.apache.commons.math.ode.events.CombinedEventsManager.clearEventsHandlers()",
    "snippet": "    public void clearEventsHandlers() {\n        states.clear();\n    }",
    "comment": "Remove all the events handlers that have been added to the manager. @see #addEventHandler(EventHandler, double, double, int) @see #getEventsHandlers() ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "CombinedEventsManager.evaluateStep",
    "class_name": "org.apache.commons.math.ode.events.CombinedEventsManager",
    "signature": "org.apache.commons.math.ode.events.CombinedEventsManager.evaluateStep(StepInterpolator)",
    "snippet": "    public boolean evaluateStep(final StepInterpolator interpolator)\n    throws DerivativeException, IntegratorException {\n\n        try {\n\n            first = null;\n            if (states.isEmpty()) {\n                // there is nothing to do, return now to avoid setting the\n                // interpolator time (and hence avoid unneeded calls to the\n                // user function due to interpolator finalization)\n                return false;\n            }\n\n            if (! initialized) {\n\n                // initialize the events states\n                final double t0 = interpolator.getPreviousTime();\n                interpolator.setInterpolatedTime(t0);\n                final double [] y = interpolator.getInterpolatedState();\n                for (EventState state : states) {\n                    state.reinitializeBegin(t0, y);\n                }\n\n                initialized = true;\n\n            }\n\n            // check events occurrence\n            for (EventState state : states) {\n\n                if (state.evaluateStep(interpolator)) {\n                    if (first == null) {\n                        first = state;\n                    } else {\n                        if (interpolator.isForward()) {\n                            if (state.getEventTime() < first.getEventTime()) {\n                                first = state;\n                            }\n                        } else {\n                            if (state.getEventTime() > first.getEventTime()) {\n                                first = state;\n                            }\n                        }\n                    }\n                }\n\n            }\n\n            return first != null;\n\n        } catch (EventException se) {\n            throw new IntegratorException(se);\n        } catch (ConvergenceException ce) {\n            throw new IntegratorException(ce);\n        }\n\n    }",
    "comment": "Evaluate the impact of the proposed step on all managed event handlers. @param interpolator step interpolator for the proposed step @return true if at least one event handler triggers an event before the end of the proposed step (this implies the step should be rejected) @exception DerivativeException if the interpolator fails to compute the function somewhere within the step @exception IntegratorException if an event cannot be located ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "CombinedEventsManager.getEventTime",
    "class_name": "org.apache.commons.math.ode.events.CombinedEventsManager",
    "signature": "org.apache.commons.math.ode.events.CombinedEventsManager.getEventTime()",
    "snippet": "    public double getEventTime() {\n        return (first == null) ? Double.NaN : first.getEventTime();\n    }",
    "comment": "Get the occurrence time of the first event triggered in the last evaluated step. @return occurrence time of the first event triggered in the last evaluated step, or </code>Double.NaN</code> if no event is triggered ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "CombinedEventsManager.getEventsStates",
    "class_name": "org.apache.commons.math.ode.events.CombinedEventsManager",
    "signature": "org.apache.commons.math.ode.events.CombinedEventsManager.getEventsStates()",
    "snippet": "    public Collection<EventState> getEventsStates() {\n        return states;\n    }",
    "comment": "Get all the events state wrapping the handlers that have been added to the manager. @return a collection of the events states @see #getEventsHandlers() ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "CombinedEventsManager.reset",
    "class_name": "org.apache.commons.math.ode.events.CombinedEventsManager",
    "signature": "org.apache.commons.math.ode.events.CombinedEventsManager.reset(double,double[])",
    "snippet": "    public boolean reset(final double t, final double[] y)\n        throws IntegratorException {\n        try {\n            boolean resetDerivatives = false;\n            for (EventState state : states) {\n                if (state.reset(t, y)) {\n                    resetDerivatives = true;\n                }\n            }\n            return resetDerivatives;\n        } catch (EventException se) {\n            throw new IntegratorException(se);\n        }\n    }",
    "comment": "Let the event handlers reset the state if they want. @param t value of the independent <i>time</i> variable at the beginning of the next step @param y array were to put the desired state vector at the beginning of the next step @return true if the integrator should reset the derivatives too @exception IntegratorException if one of the events states that should reset the state fails to do it ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "CombinedEventsManager.stepAccepted",
    "class_name": "org.apache.commons.math.ode.events.CombinedEventsManager",
    "signature": "org.apache.commons.math.ode.events.CombinedEventsManager.stepAccepted(double,double[])",
    "snippet": "    public void stepAccepted(final double t, final double[] y)\n    throws IntegratorException {\n        try {\n            for (EventState state : states) {\n                state.stepAccepted(t, y);\n            }\n        } catch (EventException se) {\n            throw new IntegratorException(se);\n        }\n    }",
    "comment": "Inform the event handlers that the step has been accepted by the integrator. @param t value of the independent <i>time</i> variable at the end of the step @param y array containing the current value of the state vector at the end of the step @exception IntegratorException if the value of one of the events states cannot be evaluated ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "CombinedEventsManager.stop",
    "class_name": "org.apache.commons.math.ode.events.CombinedEventsManager",
    "signature": "org.apache.commons.math.ode.events.CombinedEventsManager.stop()",
    "snippet": "    public boolean stop() {\n        for (EventState state : states) {\n            if (state.stop()) {\n                return true;\n            }\n        }\n        return false;\n    }",
    "comment": "Check if the integration should be stopped at the end of the current step. @return true if the integration should be stopped ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "EventState.EventState",
    "class_name": "org.apache.commons.math.ode.events.EventState",
    "signature": "org.apache.commons.math.ode.events.EventState.EventState(EventHandler,double,double,int)",
    "snippet": "    public EventState(final EventHandler handler, final double maxCheckInterval,\n                      final double convergence, final int maxIterationCount) {\n        this.handler           = handler;\n        this.maxCheckInterval  = maxCheckInterval;\n        this.convergence       = Math.abs(convergence);\n        this.maxIterationCount = maxIterationCount;\n\n        // some dummy values ...\n        t0                = Double.NaN;\n        g0                = Double.NaN;\n        g0Positive        = true;\n        pendingEvent      = false;\n        pendingEventTime  = Double.NaN;\n        previousEventTime = Double.NaN;\n        increasing        = true;\n        nextAction        = EventHandler.CONTINUE;\n\n    }",
    "comment": "Simple constructor. @param handler event handler @param maxCheckInterval maximal time interval between switching function checks (this interval prevents missing sign changes in case the integration steps becomes very large) @param convergence convergence threshold in the event time search @param maxIterationCount upper limit of the iteration count in the event time search ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "EventState.evaluateStep",
    "class_name": "org.apache.commons.math.ode.events.EventState",
    "signature": "org.apache.commons.math.ode.events.EventState.evaluateStep(StepInterpolator)",
    "snippet": "    public boolean evaluateStep(final StepInterpolator interpolator)\n        throws DerivativeException, EventException, ConvergenceException {\n\n        try {\n\n            forward = interpolator.isForward();\n            final double t1 = interpolator.getCurrentTime();\n            final int    n  = Math.max(1, (int) Math.ceil(Math.abs(t1 - t0) / maxCheckInterval));\n            final double h  = (t1 - t0) / n;\n\n            double ta = t0;\n            double ga = g0;\n            double tb = t0 + (interpolator.isForward() ? convergence : -convergence);\n            for (int i = 0; i < n; ++i) {\n\n                // evaluate handler value at the end of the substep\n                tb += h;\n                interpolator.setInterpolatedTime(tb);\n                final double gb = handler.g(tb, interpolator.getInterpolatedState());\n\n                // check events occurrence\n                if (g0Positive ^ (gb >= 0)) {\n                    // there is a sign change: an event is expected during this step\n\n                    if (ga * gb > 0) {\n                        // this is a corner case:\n                        // - there was an event near ta,\n                        // - there is another event between ta and tb\n                        // - when ta was computed, convergence was reached on the \"wrong side\" of the interval\n                        // this implies that the real sign of ga is the same as gb, so we need to slightly\n                        // shift ta to make sure ga and gb get opposite signs and the solver won't complain\n                        // about bracketing\n                        final double epsilon = (forward ? 0.25 : -0.25) * convergence;\n                        for (int k = 0; (k < 4) && (ga * gb > 0); ++k) {\n                            ta += epsilon;\n                            interpolator.setInterpolatedTime(ta);\n                            ga = handler.g(ta, interpolator.getInterpolatedState());\n                        }\n                        if (ga * gb > 0) {\n                            // this should never happen\n                            throw MathRuntimeException.createInternalError(null);\n                        }\n                    }\n\n                    // variation direction, with respect to the integration direction\n                    increasing = gb >= ga;\n\n                    final UnivariateRealFunction f = new UnivariateRealFunction() {\n                        public double value(final double t) throws FunctionEvaluationException {\n                            try {\n                                interpolator.setInterpolatedTime(t);\n                                return handler.g(t, interpolator.getInterpolatedState());\n                            } catch (DerivativeException e) {\n                                throw new FunctionEvaluationException(e, t);\n                            } catch (EventException e) {\n                                throw new FunctionEvaluationException(e, t);\n                            }\n                        }\n                    };\n                    final BrentSolver solver = new BrentSolver();\n                    solver.setAbsoluteAccuracy(convergence);\n                    solver.setMaximalIterationCount(maxIterationCount);\n                    final double root = (ta <= tb) ? solver.solve(f, ta, tb) : solver.solve(f, tb, ta);\n                    if ((Math.abs(root - ta) <= convergence) &&\n                         (Math.abs(root - previousEventTime) <= convergence)) {\n                        // we have either found nothing or found (again ?) a past event, we simply ignore it\n                        ta = tb;\n                        ga = gb;\n                    } else if (Double.isNaN(previousEventTime) ||\n                               (Math.abs(previousEventTime - root) > convergence)) {\n                        pendingEventTime = root;\n                        if (pendingEvent && (Math.abs(t1 - pendingEventTime) <= convergence)) {\n                            // we were already waiting for this event which was\n                            // found during a previous call for a step that was\n                            // rejected, this step must now be accepted since it\n                            // properly ends exactly at the event occurrence\n                            return false;\n                        }\n                        // either we were not waiting for the event or it has\n                        // moved in such a way the step cannot be accepted\n                        pendingEvent = true;\n                        return true;\n                    }\n\n                } else {\n                    // no sign change: there is no event for now\n                    ta = tb;\n                    ga = gb;\n                }\n\n            }\n\n            // no event during the whole step\n            pendingEvent     = false;\n            pendingEventTime = Double.NaN;\n            return false;\n\n        } catch (FunctionEvaluationException e) {\n            final Throwable cause = e.getCause();\n            if ((cause != null) && (cause instanceof DerivativeException)) {\n                throw (DerivativeException) cause;\n            } else if ((cause != null) && (cause instanceof EventException)) {\n                throw (EventException) cause;\n            }\n            throw new EventException(e);\n        }\n\n    }",
    "comment": "Evaluate the impact of the proposed step on the event handler. @param interpolator step interpolator for the proposed step @return true if the event handler triggers an event before the end of the proposed step (this implies the step should be rejected) @exception DerivativeException if the interpolator fails to compute the switching function somewhere within the step @exception EventException if the switching function cannot be evaluated @exception ConvergenceException if an event cannot be located ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "EventState.getEventTime",
    "class_name": "org.apache.commons.math.ode.events.EventState",
    "signature": "org.apache.commons.math.ode.events.EventState.getEventTime()",
    "snippet": "    public double getEventTime() {\n        return pendingEventTime;\n    }",
    "comment": "Get the occurrence time of the event triggered in the current step. @return occurrence time of the event triggered in the current step. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "EventState.reinitializeBegin",
    "class_name": "org.apache.commons.math.ode.events.EventState",
    "signature": "org.apache.commons.math.ode.events.EventState.reinitializeBegin(double,double[])",
    "snippet": "    public void reinitializeBegin(final double tStart, final double[] yStart)\n        throws EventException {\n        t0 = tStart;\n        g0 = handler.g(tStart, yStart);\n        g0Positive = g0 >= 0;\n    }",
    "comment": "Reinitialize the beginning of the step. @param tStart value of the independent <i>time</i> variable at the beginning of the step @param yStart array containing the current value of the state vector at the beginning of the step @exception EventException if the event handler value cannot be evaluated at the beginning of the step ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "EventState.reset",
    "class_name": "org.apache.commons.math.ode.events.EventState",
    "signature": "org.apache.commons.math.ode.events.EventState.reset(double,double[])",
    "snippet": "    public boolean reset(final double t, final double[] y)\n        throws EventException {\n\n        if (! pendingEvent) {\n            return false;\n        }\n\n        if (nextAction == EventHandler.RESET_STATE) {\n            handler.resetState(t, y);\n        }\n        pendingEvent      = false;\n        pendingEventTime  = Double.NaN;\n\n        return (nextAction == EventHandler.RESET_STATE) ||\n               (nextAction == EventHandler.RESET_DERIVATIVES);\n\n    }",
    "comment": "Let the event handler reset the state if it wants. @param t value of the independent <i>time</i> variable at the beginning of the next step @param y array were to put the desired state vector at the beginning of the next step @return true if the integrator should reset the derivatives too @exception EventException if the state cannot be reseted by the event handler ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "EventState.stepAccepted",
    "class_name": "org.apache.commons.math.ode.events.EventState",
    "signature": "org.apache.commons.math.ode.events.EventState.stepAccepted(double,double[])",
    "snippet": "    public void stepAccepted(final double t, final double[] y)\n        throws EventException {\n\n        t0 = t;\n        g0 = handler.g(t, y);\n\n        if (pendingEvent) {\n            // force the sign to its value \"just after the event\"\n            previousEventTime = t;\n            g0Positive        = increasing;\n            nextAction        = handler.eventOccurred(t, y, !(increasing ^ forward));\n        } else {\n            g0Positive = g0 >= 0;\n            nextAction = EventHandler.CONTINUE;\n        }\n    }",
    "comment": "Acknowledge the fact the step has been accepted by the integrator. @param t value of the independent <i>time</i> variable at the end of the step @param y array containing the current value of the state vector at the end of the step @exception EventException if the value of the event handler cannot be evaluated ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "EventState.stop",
    "class_name": "org.apache.commons.math.ode.events.EventState",
    "signature": "org.apache.commons.math.ode.events.EventState.stop()",
    "snippet": "    public boolean stop() {\n        return nextAction == EventHandler.STOP;\n    }",
    "comment": "Check if the integration should be stopped at the end of the current step. @return true if the integration should be stopped ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "AdamsIntegrator.AdamsIntegrator",
    "class_name": "org.apache.commons.math.ode.nonstiff.AdamsIntegrator",
    "signature": "org.apache.commons.math.ode.nonstiff.AdamsIntegrator.AdamsIntegrator(String,int,int,double,double,double,double)",
    "snippet": "    public AdamsIntegrator(final String name, final int nSteps, final int order,\n                           final double minStep, final double maxStep,\n                           final double scalAbsoluteTolerance,\n                           final double scalRelativeTolerance)\n        throws IllegalArgumentException {\n        super(name, nSteps, order, minStep, maxStep,\n              scalAbsoluteTolerance, scalRelativeTolerance);\n        transformer = AdamsNordsieckTransformer.getInstance(nSteps);\n    }",
    "comment": " Build an Adams integrator with the given order and step control prameters. @param name name of the method @param nSteps number of steps of the method excluding the one being computed @param order order of the method @param minStep minimal step (must be positive even for backward integration), the last step can be smaller than this @param maxStep maximal step (must be positive even for backward integration) @param scalAbsoluteTolerance allowed absolute error @param scalRelativeTolerance allowed relative error @exception IllegalArgumentException if order is 1 or less ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "AdamsIntegrator.initializeHighOrderDerivatives",
    "class_name": "org.apache.commons.math.ode.nonstiff.AdamsIntegrator",
    "signature": "org.apache.commons.math.ode.nonstiff.AdamsIntegrator.initializeHighOrderDerivatives(double[],double[][])",
    "snippet": "    @Override\n    protected Array2DRowRealMatrix initializeHighOrderDerivatives(final double[] first,\n                                                        final double[][] multistep) {\n        return transformer.initializeHighOrderDerivatives(first, multistep);\n    }",
    "comment": "{@inheritDoc} */",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "AdamsIntegrator.updateHighOrderDerivativesPhase1",
    "class_name": "org.apache.commons.math.ode.nonstiff.AdamsIntegrator",
    "signature": "org.apache.commons.math.ode.nonstiff.AdamsIntegrator.updateHighOrderDerivativesPhase1(Array2DRowRealMatrix)",
    "snippet": "    public Array2DRowRealMatrix updateHighOrderDerivativesPhase1(final Array2DRowRealMatrix highOrder) {\n        return transformer.updateHighOrderDerivativesPhase1(highOrder);\n    }",
    "comment": "Update the high order scaled derivatives for Adams integrators (phase 1). <p>The complete update of high order derivatives has a form similar to: <pre> r<sub>n+1</sub> = (s<sub>1</sub>(n) - s<sub>1</sub>(n+1)) P<sup>-1</sup> u + P<sup>-1</sup> A P r<sub>n</sub> </pre> this method computes the P<sup>-1</sup> A P r<sub>n</sub> part.</p> @param highOrder high order scaled derivatives (h<sup>2</sup>/2 y'', ... h<sup>k</sup>/k! y(k)) @return updated high order derivatives @see #updateHighOrderDerivativesPhase2(double[], double[], Array2DRowRealMatrix) ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "AdamsIntegrator.updateHighOrderDerivativesPhase2",
    "class_name": "org.apache.commons.math.ode.nonstiff.AdamsIntegrator",
    "signature": "org.apache.commons.math.ode.nonstiff.AdamsIntegrator.updateHighOrderDerivativesPhase2(double[],double[],Array2DRowRealMatrix)",
    "snippet": "    public void updateHighOrderDerivativesPhase2(final double[] start,\n                                                 final double[] end,\n                                                 final Array2DRowRealMatrix highOrder) {\n        transformer.updateHighOrderDerivativesPhase2(start, end, highOrder);\n    }",
    "comment": "Update the high order scaled derivatives Adams integrators (phase 2). <p>The complete update of high order derivatives has a form similar to: <pre> r<sub>n+1</sub> = (s<sub>1</sub>(n) - s<sub>1</sub>(n+1)) P<sup>-1</sup> u + P<sup>-1</sup> A P r<sub>n</sub> </pre> this method computes the (s<sub>1</sub>(n) - s<sub>1</sub>(n+1)) P<sup>-1</sup> u part.</p> <p>Phase 1 of the update must already have been performed.</p> @param start first order scaled derivatives at step start @param end first order scaled derivatives at step end @param highOrder high order scaled derivatives, will be modified (h<sup>2</sup>/2 y'', ... h<sup>k</sup>/k! y(k)) @see #updateHighOrderDerivativesPhase1(Array2DRowRealMatrix) ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "AdamsMoultonIntegrator.AdamsMoultonIntegrator",
    "class_name": "org.apache.commons.math.ode.nonstiff.AdamsMoultonIntegrator",
    "signature": "org.apache.commons.math.ode.nonstiff.AdamsMoultonIntegrator.AdamsMoultonIntegrator(int,double,double,double,double)",
    "snippet": "    public AdamsMoultonIntegrator(final int nSteps,\n                                  final double minStep, final double maxStep,\n                                  final double scalAbsoluteTolerance,\n                                  final double scalRelativeTolerance)\n        throws IllegalArgumentException {\n        super(\"Adams-Moulton\", nSteps, nSteps + 1, minStep, maxStep,\n              scalAbsoluteTolerance, scalRelativeTolerance);\n    }",
    "comment": " Build an Adams-Moulton integrator with the given order and error control parameters. @param nSteps number of steps of the method excluding the one being computed @param minStep minimal step (must be positive even for backward integration), the last step can be smaller than this @param maxStep maximal step (must be positive even for backward integration) @param scalAbsoluteTolerance allowed absolute error @param scalRelativeTolerance allowed relative error @exception IllegalArgumentException if order is 1 or less ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "AdamsMoultonIntegrator.integrate",
    "class_name": "org.apache.commons.math.ode.nonstiff.AdamsMoultonIntegrator",
    "signature": "org.apache.commons.math.ode.nonstiff.AdamsMoultonIntegrator.integrate(FirstOrderDifferentialEquations,double,double[],double,double[])",
    "snippet": "    @Override\n    public double integrate(final FirstOrderDifferentialEquations equations,\n                            final double t0, final double[] y0,\n                            final double t, final double[] y)\n        throws DerivativeException, IntegratorException {\n\n        final int n = y0.length;\n        sanityChecks(equations, t0, y0, t, y);\n        setEquations(equations);\n        resetEvaluations();\n        final boolean forward = t > t0;\n\n        // initialize working arrays\n        if (y != y0) {\n            System.arraycopy(y0, 0, y, 0, n);\n        }\n        final double[] yDot = new double[y0.length];\n        final double[] yTmp = new double[y0.length];\n\n        // set up two interpolators sharing the integrator arrays\n        final NordsieckStepInterpolator interpolator = new NordsieckStepInterpolator();\n        interpolator.reinitialize(y, forward);\n        final NordsieckStepInterpolator interpolatorTmp = new NordsieckStepInterpolator();\n        interpolatorTmp.reinitialize(yTmp, forward);\n\n        // set up integration control objects\n        for (StepHandler handler : stepHandlers) {\n            handler.reset();\n        }\n        CombinedEventsManager manager = addEndTimeChecker(t0, t, eventsHandlersManager);\n\n\n        // compute the initial Nordsieck vector using the configured starter integrator\n        start(t0, y, t);\n        interpolator.reinitialize(stepStart, stepSize, scaled, nordsieck);\n        interpolator.storeTime(stepStart);\n\n        double hNew = stepSize;\n        interpolator.rescale(hNew);\n\n        boolean lastStep = false;\n        while (!lastStep) {\n\n            // shift all data\n            interpolator.shift();\n\n            double error = 0;\n            for (boolean loop = true; loop;) {\n\n                stepSize = hNew;\n\n                // predict a first estimate of the state at step end (P in the PECE sequence)\n                final double stepEnd = stepStart + stepSize;\n                interpolator.setInterpolatedTime(stepEnd);\n                System.arraycopy(interpolator.getInterpolatedState(), 0, yTmp, 0, y0.length);\n\n                // evaluate a first estimate of the derivative (first E in the PECE sequence)\n                computeDerivatives(stepEnd, yTmp, yDot);\n\n                // update Nordsieck vector\n                final double[] predictedScaled = new double[y0.length];\n                for (int j = 0; j < y0.length; ++j) {\n                    predictedScaled[j] = stepSize * yDot[j];\n                }\n                final Array2DRowRealMatrix nordsieckTmp = updateHighOrderDerivativesPhase1(nordsieck);\n                updateHighOrderDerivativesPhase2(scaled, predictedScaled, nordsieckTmp);\n\n                // apply correction (C in the PECE sequence)\n                error = nordsieckTmp.walkInOptimizedOrder(new Corrector(y, predictedScaled, yTmp));\n\n                if (error <= 1.0) {\n\n                    // evaluate a final estimate of the derivative (second E in the PECE sequence)\n                    computeDerivatives(stepEnd, yTmp, yDot);\n\n                    // update Nordsieck vector\n                    final double[] correctedScaled = new double[y0.length];\n                    for (int j = 0; j < y0.length; ++j) {\n                        correctedScaled[j] = stepSize * yDot[j];\n                    }\n                    updateHighOrderDerivativesPhase2(predictedScaled, correctedScaled, nordsieckTmp);\n\n                    // discrete events handling\n                    interpolatorTmp.reinitialize(stepEnd, stepSize, correctedScaled, nordsieckTmp);\n                    interpolatorTmp.storeTime(stepStart);\n                    interpolatorTmp.shift();\n                    interpolatorTmp.storeTime(stepEnd);\n                    if (manager.evaluateStep(interpolatorTmp)) {\n                        final double dt = manager.getEventTime() - stepStart;\n                        if (Math.abs(dt) <= Math.ulp(stepStart)) {\n                            // rejecting the step would lead to a too small next step, we accept it\n                            loop = false;\n                        } else {\n                            // reject the step to match exactly the next switch time\n                            hNew = dt;\n                            interpolator.rescale(hNew);\n                        }\n                    } else {\n                        // accept the step\n                        scaled    = correctedScaled;\n                        nordsieck = nordsieckTmp;\n                        interpolator.reinitialize(stepEnd, stepSize, scaled, nordsieck);\n                        loop = false;\n                    }\n\n                } else {\n                    // reject the step and attempt to reduce error by stepsize control\n                    final double factor = computeStepGrowShrinkFactor(error);\n                    hNew = filterStep(stepSize * factor, forward, false);\n                    interpolator.rescale(hNew);\n                }\n\n            }\n\n            // the step has been accepted (may have been truncated)\n            final double nextStep = stepStart + stepSize;\n            System.arraycopy(yTmp, 0, y, 0, n);\n            interpolator.storeTime(nextStep);\n            manager.stepAccepted(nextStep, y);\n            lastStep = manager.stop();\n\n            // provide the step data to the step handler\n            for (StepHandler handler : stepHandlers) {\n                interpolator.setInterpolatedTime(nextStep);\n                handler.handleStep(interpolator, lastStep);\n            }\n            stepStart = nextStep;\n\n            if (!lastStep && manager.reset(stepStart, y)) {\n\n                // some events handler has triggered changes that\n                // invalidate the derivatives, we need to restart from scratch\n                start(stepStart, y, t);\n                interpolator.reinitialize(stepStart, stepSize, scaled, nordsieck);\n\n            }\n\n            if (! lastStep) {\n                // in some rare cases we may get here with stepSize = 0, for example\n                // when an event occurs at integration start, reducing the first step\n                // to zero; we have to reset the step to some safe non zero value\n                stepSize = filterStep(stepSize, forward, true);\n\n                // stepsize control for next step\n                final double  factor     = computeStepGrowShrinkFactor(error);\n                final double  scaledH    = stepSize * factor;\n                final double  nextT      = stepStart + scaledH;\n                final boolean nextIsLast = forward ? (nextT >= t) : (nextT <= t);\n                hNew = filterStep(scaledH, forward, nextIsLast);\n                interpolator.rescale(hNew);\n            }\n\n        }\n\n        final double stopTime  = stepStart;\n        stepStart = Double.NaN;\n        stepSize  = Double.NaN;\n        return stopTime;\n\n    }",
    "comment": "{@inheritDoc} */",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "Corrector.end",
    "class_name": "org.apache.commons.math.ode.nonstiff.AdamsMoultonIntegrator$Corrector",
    "signature": "org.apache.commons.math.ode.nonstiff.AdamsMoultonIntegrator$Corrector.end()",
    "snippet": "        public double end() {\n\n            double error = 0;\n            for (int i = 0; i < after.length; ++i) {\n                after[i] += previous[i] + scaled[i];\n                final double yScale = Math.max(Math.abs(previous[i]), Math.abs(after[i]));\n                final double tol = (vecAbsoluteTolerance == null) ?\n                                   (scalAbsoluteTolerance + scalRelativeTolerance * yScale) :\n                                   (vecAbsoluteTolerance[i] + vecRelativeTolerance[i] * yScale);\n                final double ratio  = (after[i] - before[i]) / tol;\n                error += ratio * ratio;\n            }\n\n            return Math.sqrt(error / after.length);\n\n        }",
    "comment": " End visiting te Nordsieck vector. <p>The correction is used to control stepsize. So its amplitude is considered to be an error, which must be normalized according to error control settings. If the normalized value is greater than 1, the correction was too large and the step must be rejected.</p> @return the normalized correction, if greater than 1, the step must be rejected ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "Corrector.start",
    "class_name": "org.apache.commons.math.ode.nonstiff.AdamsMoultonIntegrator$Corrector",
    "signature": "org.apache.commons.math.ode.nonstiff.AdamsMoultonIntegrator$Corrector.start(int,int,int,int,int,int)",
    "snippet": "        public void start(int rows, int columns,\n                          int startRow, int endRow, int startColumn, int endColumn) {\n            Arrays.fill(after, 0.0);\n        }",
    "comment": "{@inheritDoc} */",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "Corrector.visit",
    "class_name": "org.apache.commons.math.ode.nonstiff.AdamsMoultonIntegrator$Corrector",
    "signature": "org.apache.commons.math.ode.nonstiff.AdamsMoultonIntegrator$Corrector.visit(int,int,double)",
    "snippet": "        public void visit(int row, int column, double value)\n            throws MatrixVisitorException {\n            if ((row & 0x1) == 0) {\n                after[column] -= value;\n            } else {\n                after[column] += value;\n            }\n        }",
    "comment": "{@inheritDoc} */",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "AdamsNordsieckTransformer.buildP",
    "class_name": "org.apache.commons.math.ode.nonstiff.AdamsNordsieckTransformer",
    "signature": "org.apache.commons.math.ode.nonstiff.AdamsNordsieckTransformer.buildP(int)",
    "snippet": "    private FieldMatrix<BigFraction> buildP(final int nSteps) {\n\n        final BigFraction[][] pData = new BigFraction[nSteps][nSteps];\n\n        for (int i = 0; i < pData.length; ++i) {\n            // build the P matrix elements from Taylor series formulas\n            final BigFraction[] pI = pData[i];\n            final int factor = -(i + 1);\n            int aj = factor;\n            for (int j = 0; j < pI.length; ++j) {\n                pI[j] = new BigFraction(aj * (j + 2));\n                aj *= factor;\n            }\n        }\n\n        return new Array2DRowFieldMatrix<BigFraction>(pData, false);\n\n    }",
    "comment": "Build the P matrix. <p>The P matrix general terms are shifted j (-i)<sup>j-1</sup> terms: <pre> [  -2   3   -4    5  ... ] [  -4  12  -32   80  ... ] P =  [  -6  27 -108  405  ... ] [  -8  48 -256 1280  ... ] [          ...           ] </pre></p> @param nSteps number of steps of the multistep method (excluding the one being computed) @return P matrix ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "AdamsNordsieckTransformer.getInstance",
    "class_name": "org.apache.commons.math.ode.nonstiff.AdamsNordsieckTransformer",
    "signature": "org.apache.commons.math.ode.nonstiff.AdamsNordsieckTransformer.getInstance(int)",
    "snippet": "    public static AdamsNordsieckTransformer getInstance(final int nSteps) {\n        synchronized(CACHE) {\n            AdamsNordsieckTransformer t = CACHE.get(nSteps);\n            if (t == null) {\n                t = new AdamsNordsieckTransformer(nSteps);\n                CACHE.put(nSteps, t);\n            }\n            return t;\n        }\n    }",
    "comment": "Get the Nordsieck transformer for a given number of steps. @param nSteps number of steps of the multistep method (excluding the one being computed) @return Nordsieck transformer for the specified number of steps ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "AdamsNordsieckTransformer.initializeHighOrderDerivatives",
    "class_name": "org.apache.commons.math.ode.nonstiff.AdamsNordsieckTransformer",
    "signature": "org.apache.commons.math.ode.nonstiff.AdamsNordsieckTransformer.initializeHighOrderDerivatives(double[],double[][])",
    "snippet": "    public Array2DRowRealMatrix initializeHighOrderDerivatives(final double[] first,\n                                                     final double[][] multistep) {\n        for (int i = 0; i < multistep.length; ++i) {\n            final double[] msI = multistep[i];\n            for (int j = 0; j < first.length; ++j) {\n                msI[j] -= first[j];\n            }\n        }\n        return initialization.multiply(new Array2DRowRealMatrix(multistep, false));\n    }",
    "comment": "Initialize the high order scaled derivatives at step start. @param first first scaled derivative at step start @param multistep scaled derivatives after step start (hy'1, ..., hy'k-1) will be modified @return high order derivatives at step start ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "AdamsNordsieckTransformer.updateHighOrderDerivativesPhase1",
    "class_name": "org.apache.commons.math.ode.nonstiff.AdamsNordsieckTransformer",
    "signature": "org.apache.commons.math.ode.nonstiff.AdamsNordsieckTransformer.updateHighOrderDerivativesPhase1(Array2DRowRealMatrix)",
    "snippet": "    public Array2DRowRealMatrix updateHighOrderDerivativesPhase1(final Array2DRowRealMatrix highOrder) {\n        return update.multiply(highOrder);\n    }",
    "comment": "Update the high order scaled derivatives for Adams integrators (phase 1). <p>The complete update of high order derivatives has a form similar to: <pre> r<sub>n+1</sub> = (s<sub>1</sub>(n) - s<sub>1</sub>(n+1)) P<sup>-1</sup> u + P<sup>-1</sup> A P r<sub>n</sub> </pre> this method computes the P<sup>-1</sup> A P r<sub>n</sub> part.</p> @param highOrder high order scaled derivatives (h<sup>2</sup>/2 y'', ... h<sup>k</sup>/k! y(k)) @return updated high order derivatives @see #updateHighOrderDerivativesPhase2(double[], double[], Array2DRowRealMatrix) ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "AdamsNordsieckTransformer.updateHighOrderDerivativesPhase2",
    "class_name": "org.apache.commons.math.ode.nonstiff.AdamsNordsieckTransformer",
    "signature": "org.apache.commons.math.ode.nonstiff.AdamsNordsieckTransformer.updateHighOrderDerivativesPhase2(double[],double[],Array2DRowRealMatrix)",
    "snippet": "    public void updateHighOrderDerivativesPhase2(final double[] start,\n                                                 final double[] end,\n                                                 final Array2DRowRealMatrix highOrder) {\n        final double[][] data = highOrder.getDataRef();\n        for (int i = 0; i < data.length; ++i) {\n            final double[] dataI = data[i];\n            final double c1I = c1[i];\n            for (int j = 0; j < dataI.length; ++j) {\n                dataI[j] += c1I * (start[j] - end[j]);\n            }\n        }\n    }",
    "comment": "Update the high order scaled derivatives Adams integrators (phase 2). <p>The complete update of high order derivatives has a form similar to: <pre> r<sub>n+1</sub> = (s<sub>1</sub>(n) - s<sub>1</sub>(n+1)) P<sup>-1</sup> u + P<sup>-1</sup> A P r<sub>n</sub> </pre> this method computes the (s<sub>1</sub>(n) - s<sub>1</sub>(n+1)) P<sup>-1</sup> u part.</p> <p>Phase 1 of the update must already have been performed.</p> @param start first order scaled derivatives at step start @param end first order scaled derivatives at step end @param highOrder high order scaled derivatives, will be modified (h<sup>2</sup>/2 y'', ... h<sup>k</sup>/k! y(k)) @see #updateHighOrderDerivativesPhase1(Array2DRowRealMatrix) ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "AdaptiveStepsizeIntegrator.AdaptiveStepsizeIntegrator",
    "class_name": "org.apache.commons.math.ode.nonstiff.AdaptiveStepsizeIntegrator",
    "signature": "org.apache.commons.math.ode.nonstiff.AdaptiveStepsizeIntegrator.AdaptiveStepsizeIntegrator(String,double,double,double,double)",
    "snippet": "  public AdaptiveStepsizeIntegrator(final String name,\n                                    final double minStep, final double maxStep,\n                                    final double scalAbsoluteTolerance,\n                                    final double scalRelativeTolerance) {\n\n    super(name);\n\n    this.minStep     = Math.abs(minStep);\n    this.maxStep     = Math.abs(maxStep);\n    this.initialStep = -1.0;\n\n    this.scalAbsoluteTolerance = scalAbsoluteTolerance;\n    this.scalRelativeTolerance = scalRelativeTolerance;\n    this.vecAbsoluteTolerance  = null;\n    this.vecRelativeTolerance  = null;\n\n    resetInternalState();\n\n  }",
    "comment": "Build an integrator with the given stepsize bounds. The default step handler does nothing. @param name name of the method @param minStep minimal step (must be positive even for backward integration), the last step can be smaller than this @param maxStep maximal step (must be positive even for backward integration) @param scalAbsoluteTolerance allowed absolute error @param scalRelativeTolerance allowed relative error ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "AdaptiveStepsizeIntegrator.filterStep",
    "class_name": "org.apache.commons.math.ode.nonstiff.AdaptiveStepsizeIntegrator",
    "signature": "org.apache.commons.math.ode.nonstiff.AdaptiveStepsizeIntegrator.filterStep(double,boolean,boolean)",
    "snippet": "  protected double filterStep(final double h, final boolean forward, final boolean acceptSmall)\n    throws IntegratorException {\n\n      double filteredH = h;\n      if (Math.abs(h) < minStep) {\n          if (acceptSmall) {\n              filteredH = forward ? minStep : -minStep;\n          } else {\n              throw new IntegratorException(\n                      \"minimal step size ({0,number,0.00E00}) reached, integration needs {1,number,0.00E00}\",\n                      minStep, Math.abs(h));\n          }\n      }\n\n      if (filteredH > maxStep) {\n          filteredH = maxStep;\n      } else if (filteredH < -maxStep) {\n          filteredH = -maxStep;\n      }\n\n      return filteredH;\n\n  }",
    "comment": "Filter the integration step. @param h signed step @param forward forward integration indicator @param acceptSmall if true, steps smaller than the minimal value are silently increased up to this value, if false such small steps generate an exception @return a bounded integration step (h if no bound is reach, or a bounded value) @exception IntegratorException if the step is too small and acceptSmall is false ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "AdaptiveStepsizeIntegrator.getCurrentStepStart",
    "class_name": "org.apache.commons.math.ode.nonstiff.AdaptiveStepsizeIntegrator",
    "signature": "org.apache.commons.math.ode.nonstiff.AdaptiveStepsizeIntegrator.getCurrentStepStart()",
    "snippet": "  @Override\n  public double getCurrentStepStart() {\n    return stepStart;\n  }",
    "comment": "{@inheritDoc} */",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "AdaptiveStepsizeIntegrator.getMaxStep",
    "class_name": "org.apache.commons.math.ode.nonstiff.AdaptiveStepsizeIntegrator",
    "signature": "org.apache.commons.math.ode.nonstiff.AdaptiveStepsizeIntegrator.getMaxStep()",
    "snippet": "  public double getMaxStep() {\n    return maxStep;\n  }",
    "comment": "Get the maximal step. @return maximal step ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "AdaptiveStepsizeIntegrator.getMinStep",
    "class_name": "org.apache.commons.math.ode.nonstiff.AdaptiveStepsizeIntegrator",
    "signature": "org.apache.commons.math.ode.nonstiff.AdaptiveStepsizeIntegrator.getMinStep()",
    "snippet": "  public double getMinStep() {\n    return minStep;\n  }",
    "comment": "Get the minimal step. @return minimal step ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "AdaptiveStepsizeIntegrator.initializeStep",
    "class_name": "org.apache.commons.math.ode.nonstiff.AdaptiveStepsizeIntegrator",
    "signature": "org.apache.commons.math.ode.nonstiff.AdaptiveStepsizeIntegrator.initializeStep(FirstOrderDifferentialEquations,boolean,int,double[],double,double[],double[],double[],double[])",
    "snippet": "  public double initializeStep(final FirstOrderDifferentialEquations equations,\n                               final boolean forward, final int order, final double[] scale,\n                               final double t0, final double[] y0, final double[] yDot0,\n                               final double[] y1, final double[] yDot1)\n      throws DerivativeException {\n\n    if (initialStep > 0) {\n      // use the user provided value\n      return forward ? initialStep : -initialStep;\n    }\n\n    // very rough first guess : h = 0.01 * ||y/scale|| / ||y'/scale||\n    // this guess will be used to perform an Euler step\n    double ratio;\n    double yOnScale2 = 0;\n    double yDotOnScale2 = 0;\n    for (int j = 0; j < y0.length; ++j) {\n      ratio         = y0[j] / scale[j];\n      yOnScale2    += ratio * ratio;\n      ratio         = yDot0[j] / scale[j];\n      yDotOnScale2 += ratio * ratio;\n    }\n\n    double h = ((yOnScale2 < 1.0e-10) || (yDotOnScale2 < 1.0e-10)) ?\n               1.0e-6 : (0.01 * Math.sqrt(yOnScale2 / yDotOnScale2));\n    if (! forward) {\n      h = -h;\n    }\n\n    // perform an Euler step using the preceding rough guess\n    for (int j = 0; j < y0.length; ++j) {\n      y1[j] = y0[j] + h * yDot0[j];\n    }\n    computeDerivatives(t0 + h, y1, yDot1);\n\n    // estimate the second derivative of the solution\n    double yDDotOnScale = 0;\n    for (int j = 0; j < y0.length; ++j) {\n      ratio         = (yDot1[j] - yDot0[j]) / scale[j];\n      yDDotOnScale += ratio * ratio;\n    }\n    yDDotOnScale = Math.sqrt(yDDotOnScale) / h;\n\n    // step size is computed such that\n    // h^order * max (||y'/tol||, ||y''/tol||) = 0.01\n    final double maxInv2 = Math.max(Math.sqrt(yDotOnScale2), yDDotOnScale);\n    final double h1 = (maxInv2 < 1.0e-15) ?\n                      Math.max(1.0e-6, 0.001 * Math.abs(h)) :\n                      Math.pow(0.01 / maxInv2, 1.0 / order);\n    h = Math.min(100.0 * Math.abs(h), h1);\n    h = Math.max(h, 1.0e-12 * Math.abs(t0));  // avoids cancellation when computing t1 - t0\n    if (h < getMinStep()) {\n      h = getMinStep();\n    }\n    if (h > getMaxStep()) {\n      h = getMaxStep();\n    }\n    if (! forward) {\n      h = -h;\n    }\n\n    return h;\n\n  }",
    "comment": "Initialize the integration step. @param equations differential equations set @param forward forward integration indicator @param order order of the method @param scale scaling vector for the state vector @param t0 start time @param y0 state vector at t0 @param yDot0 first time derivative of y0 @param y1 work array for a state vector @param yDot1 work array for the first time derivative of y1 @return first integration step @exception DerivativeException this exception is propagated to the caller if the underlying user function triggers one ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "AdaptiveStepsizeIntegrator.resetInternalState",
    "class_name": "org.apache.commons.math.ode.nonstiff.AdaptiveStepsizeIntegrator",
    "signature": "org.apache.commons.math.ode.nonstiff.AdaptiveStepsizeIntegrator.resetInternalState()",
    "snippet": "  protected void resetInternalState() {\n    stepStart = Double.NaN;\n    stepSize  = Math.sqrt(minStep * maxStep);\n  }",
    "comment": "Reset internal state to dummy values. */",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "AdaptiveStepsizeIntegrator.sanityChecks",
    "class_name": "org.apache.commons.math.ode.nonstiff.AdaptiveStepsizeIntegrator",
    "signature": "org.apache.commons.math.ode.nonstiff.AdaptiveStepsizeIntegrator.sanityChecks(FirstOrderDifferentialEquations,double,double[],double,double[])",
    "snippet": "  @Override\n  protected void sanityChecks(final FirstOrderDifferentialEquations equations,\n                              final double t0, final double[] y0,\n                              final double t, final double[] y)\n      throws IntegratorException {\n\n      super.sanityChecks(equations, t0, y0, t, y);\n\n      if ((vecAbsoluteTolerance != null) && (vecAbsoluteTolerance.length != y0.length)) {\n          throw new IntegratorException(\n                  \"dimensions mismatch: state vector has dimension {0},\" +\n                  \" absolute tolerance vector has dimension {1}\",\n                  y0.length, vecAbsoluteTolerance.length);\n      }\n\n      if ((vecRelativeTolerance != null) && (vecRelativeTolerance.length != y0.length)) {\n          throw new IntegratorException(\n                  \"dimensions mismatch: state vector has dimension {0},\" +\n                  \" relative tolerance vector has dimension {1}\",\n                  y0.length, vecRelativeTolerance.length);\n      }\n\n  }",
    "comment": "Perform some sanity checks on the integration parameters. @param equations differential equations set @param t0 start time @param y0 state vector at t0 @param t target time for the integration @param y placeholder where to put the state vector @exception IntegratorException if some inconsistency is detected ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "DormandPrince853Integrator.DormandPrince853Integrator",
    "class_name": "org.apache.commons.math.ode.nonstiff.DormandPrince853Integrator",
    "signature": "org.apache.commons.math.ode.nonstiff.DormandPrince853Integrator.DormandPrince853Integrator(double,double,double,double)",
    "snippet": "  public DormandPrince853Integrator(final double minStep, final double maxStep,\n                                    final double scalAbsoluteTolerance,\n                                    final double scalRelativeTolerance) {\n    super(METHOD_NAME, true, STATIC_C, STATIC_A, STATIC_B,\n          new DormandPrince853StepInterpolator(),\n          minStep, maxStep, scalAbsoluteTolerance, scalRelativeTolerance);\n  }",
    "comment": "Simple constructor. Build an eighth order Dormand-Prince integrator with the given step bounds @param minStep minimal step (must be positive even for backward integration), the last step can be smaller than this @param maxStep maximal step (must be positive even for backward integration) @param scalAbsoluteTolerance allowed absolute error @param scalRelativeTolerance allowed relative error ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "DormandPrince853Integrator.estimateError",
    "class_name": "org.apache.commons.math.ode.nonstiff.DormandPrince853Integrator",
    "signature": "org.apache.commons.math.ode.nonstiff.DormandPrince853Integrator.estimateError(double[][],double[],double[],double)",
    "snippet": "  @Override\n  protected double estimateError(final double[][] yDotK,\n                                 final double[] y0, final double[] y1,\n                                 final double h) {\n    double error1 = 0;\n    double error2 = 0;\n\n    for (int j = 0; j < y0.length; ++j) {\n      final double errSum1 = E1_01 * yDotK[0][j]  + E1_06 * yDotK[5][j] +\n                             E1_07 * yDotK[6][j]  + E1_08 * yDotK[7][j] +\n                             E1_09 * yDotK[8][j]  + E1_10 * yDotK[9][j] +\n                             E1_11 * yDotK[10][j] + E1_12 * yDotK[11][j];\n      final double errSum2 = E2_01 * yDotK[0][j]  + E2_06 * yDotK[5][j] +\n                             E2_07 * yDotK[6][j]  + E2_08 * yDotK[7][j] +\n                             E2_09 * yDotK[8][j]  + E2_10 * yDotK[9][j] +\n                             E2_11 * yDotK[10][j] + E2_12 * yDotK[11][j];\n\n      final double yScale = Math.max(Math.abs(y0[j]), Math.abs(y1[j]));\n      final double tol = (vecAbsoluteTolerance == null) ?\n                         (scalAbsoluteTolerance + scalRelativeTolerance * yScale) :\n                         (vecAbsoluteTolerance[j] + vecRelativeTolerance[j] * yScale);\n      final double ratio1  = errSum1 / tol;\n      error1        += ratio1 * ratio1;\n      final double ratio2  = errSum2 / tol;\n      error2        += ratio2 * ratio2;\n    }\n\n    double den = error1 + 0.01 * error2;\n    if (den <= 0.0) {\n      den = 1.0;\n    }\n\n    return Math.abs(h) * error1 / Math.sqrt(y0.length * den);\n\n  }",
    "comment": "{@inheritDoc} */",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "DormandPrince853Integrator.getOrder",
    "class_name": "org.apache.commons.math.ode.nonstiff.DormandPrince853Integrator",
    "signature": "org.apache.commons.math.ode.nonstiff.DormandPrince853Integrator.getOrder()",
    "snippet": "  @Override\n  public int getOrder() {\n    return 8;\n  }",
    "comment": "{@inheritDoc} */",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "DormandPrince853StepInterpolator.DormandPrince853StepInterpolator",
    "class_name": "org.apache.commons.math.ode.nonstiff.DormandPrince853StepInterpolator",
    "signature": "org.apache.commons.math.ode.nonstiff.DormandPrince853StepInterpolator.DormandPrince853StepInterpolator()",
    "snippet": "  public DormandPrince853StepInterpolator() {\n    super();\n    yDotKLast = null;\n    v         = null;\n    vectorsInitialized = false;\n  }",
    "comment": "Simple constructor. This constructor builds an instance that is not usable yet, the {@link #reinitialize} method should be called before using the instance in order to initialize the internal arrays. This constructor is used only in order to delay the initialization in some cases. The {@link EmbeddedRungeKuttaIntegrator} uses the prototyping design pattern to create the step interpolators by cloning an uninitialized model and latter initializing the copy. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "DormandPrince853StepInterpolator.DormandPrince853StepInterpolator",
    "class_name": "org.apache.commons.math.ode.nonstiff.DormandPrince853StepInterpolator",
    "signature": "org.apache.commons.math.ode.nonstiff.DormandPrince853StepInterpolator.DormandPrince853StepInterpolator(DormandPrince853StepInterpolator)",
    "snippet": "  public DormandPrince853StepInterpolator(final DormandPrince853StepInterpolator interpolator) {\n\n    super(interpolator);\n\n    if (interpolator.currentState == null) {\n\n      yDotKLast = null;\n      v         = null;\n      vectorsInitialized = false;\n\n    } else {\n\n      final int dimension = interpolator.currentState.length;\n\n      yDotKLast    = new double[3][];\n      for (int k = 0; k < yDotKLast.length; ++k) {\n        yDotKLast[k] = new double[dimension];\n        System.arraycopy(interpolator.yDotKLast[k], 0, yDotKLast[k], 0,\n                         dimension);\n      }\n\n      v = new double[7][];\n      for (int k = 0; k < v.length; ++k) {\n        v[k] = new double[dimension];\n        System.arraycopy(interpolator.v[k], 0, v[k], 0, dimension);\n      }\n\n      vectorsInitialized = interpolator.vectorsInitialized;\n\n    }\n\n  }",
    "comment": "Copy constructor. @param interpolator interpolator to copy from. The copy is a deep copy: its arrays are separated from the original arrays of the instance ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "DormandPrince853StepInterpolator.computeInterpolatedStateAndDerivatives",
    "class_name": "org.apache.commons.math.ode.nonstiff.DormandPrince853StepInterpolator",
    "signature": "org.apache.commons.math.ode.nonstiff.DormandPrince853StepInterpolator.computeInterpolatedStateAndDerivatives(double,double)",
    "snippet": "  @Override\n  protected void computeInterpolatedStateAndDerivatives(final double theta,\n                                          final double oneMinusThetaH)\n    throws DerivativeException {\n\n    if (! vectorsInitialized) {\n\n      if (v == null) {\n        v = new double[7][];\n        for (int k = 0; k < 7; ++k) {\n          v[k] = new double[interpolatedState.length];\n        }\n      }\n\n      // perform the last evaluations if they have not been done yet\n      finalizeStep();\n\n      // compute the interpolation vectors for this time step\n      for (int i = 0; i < interpolatedState.length; ++i) {\n          final double yDot1  = yDotK[0][i];\n          final double yDot6  = yDotK[5][i];\n          final double yDot7  = yDotK[6][i];\n          final double yDot8  = yDotK[7][i];\n          final double yDot9  = yDotK[8][i];\n          final double yDot10 = yDotK[9][i];\n          final double yDot11 = yDotK[10][i];\n          final double yDot12 = yDotK[11][i];\n          final double yDot13 = yDotK[12][i];\n          final double yDot14 = yDotKLast[0][i];\n          final double yDot15 = yDotKLast[1][i];\n          final double yDot16 = yDotKLast[2][i];\n          v[0][i] = B_01 * yDot1  + B_06 * yDot6 + B_07 * yDot7 +\n                    B_08 * yDot8  + B_09 * yDot9 + B_10 * yDot10 +\n                    B_11 * yDot11 + B_12 * yDot12;\n          v[1][i] = yDot1 - v[0][i];\n          v[2][i] = v[0][i] - v[1][i] - yDotK[12][i];\n          for (int k = 0; k < D.length; ++k) {\n              v[k+3][i] = D[k][0] * yDot1  + D[k][1]  * yDot6  + D[k][2]  * yDot7  +\n                          D[k][3] * yDot8  + D[k][4]  * yDot9  + D[k][5]  * yDot10 +\n                          D[k][6] * yDot11 + D[k][7]  * yDot12 + D[k][8]  * yDot13 +\n                          D[k][9] * yDot14 + D[k][10] * yDot15 + D[k][11] * yDot16;\n          }\n      }\n\n      vectorsInitialized = true;\n\n    }\n\n    final double eta      = 1 - theta;\n    final double twoTheta = 2 * theta;\n    final double theta2   = theta * theta;\n    final double dot1 = 1 - twoTheta;\n    final double dot2 = theta * (2 - 3 * theta);\n    final double dot3 = twoTheta * (1 + theta * (twoTheta -3));\n    final double dot4 = theta2 * (3 + theta * (5 * theta - 8));\n    final double dot5 = theta2 * (3 + theta * (-12 + theta * (15 - 6 * theta)));\n    final double dot6 = theta2 * theta * (4 + theta * (-15 + theta * (18 - 7 * theta)));\n\n    for (int i = 0; i < interpolatedState.length; ++i) {\n      interpolatedState[i] = currentState[i] -\n                             oneMinusThetaH * (v[0][i] -\n                                               theta * (v[1][i] +\n                                                        theta * (v[2][i] +\n                                                                 eta * (v[3][i] +\n                                                                        theta * (v[4][i] +\n                                                                                 eta * (v[5][i] +\n                                                                                        theta * (v[6][i])))))));\n      interpolatedDerivatives[i] =  v[0][i] + dot1 * v[1][i] + dot2 * v[2][i] +\n                                    dot3 * v[3][i] + dot4 * v[4][i] +\n                                    dot5 * v[5][i] + dot6 * v[6][i];\n    }\n\n  }",
    "comment": "{@inheritDoc} */",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "DormandPrince853StepInterpolator.doCopy",
    "class_name": "org.apache.commons.math.ode.nonstiff.DormandPrince853StepInterpolator",
    "signature": "org.apache.commons.math.ode.nonstiff.DormandPrince853StepInterpolator.doCopy()",
    "snippet": "  @Override\n  protected StepInterpolator doCopy() {\n    return new DormandPrince853StepInterpolator(this);\n  }",
    "comment": "{@inheritDoc} */",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "DormandPrince853StepInterpolator.doFinalize",
    "class_name": "org.apache.commons.math.ode.nonstiff.DormandPrince853StepInterpolator",
    "signature": "org.apache.commons.math.ode.nonstiff.DormandPrince853StepInterpolator.doFinalize()",
    "snippet": "  @Override\n  protected void doFinalize()\n    throws DerivativeException {\n\n    if (currentState == null) {\n      // we are finalizing an uninitialized instance\n      return;\n    }\n\n    double s;\n    final double[] yTmp = new double[currentState.length];\n\n    // k14\n    for (int j = 0; j < currentState.length; ++j) {\n      s = K14_01 * yDotK[0][j]  + K14_06 * yDotK[5][j]  + K14_07 * yDotK[6][j] +\n          K14_08 * yDotK[7][j]  + K14_09 * yDotK[8][j]  + K14_10 * yDotK[9][j] +\n          K14_11 * yDotK[10][j] + K14_12 * yDotK[11][j] + K14_13 * yDotK[12][j];\n      yTmp[j] = currentState[j] + h * s;\n    }\n    integrator.computeDerivatives(previousTime + C14 * h, yTmp, yDotKLast[0]);\n\n    // k15\n    for (int j = 0; j < currentState.length; ++j) {\n     s = K15_01 * yDotK[0][j]  + K15_06 * yDotK[5][j]  + K15_07 * yDotK[6][j] +\n         K15_08 * yDotK[7][j]  + K15_09 * yDotK[8][j]  + K15_10 * yDotK[9][j] +\n         K15_11 * yDotK[10][j] + K15_12 * yDotK[11][j] + K15_13 * yDotK[12][j] +\n         K15_14 * yDotKLast[0][j];\n     yTmp[j] = currentState[j] + h * s;\n    }\n    integrator.computeDerivatives(previousTime + C15 * h, yTmp, yDotKLast[1]);\n\n    // k16\n    for (int j = 0; j < currentState.length; ++j) {\n      s = K16_01 * yDotK[0][j]  + K16_06 * yDotK[5][j]  + K16_07 * yDotK[6][j] +\n          K16_08 * yDotK[7][j]  + K16_09 * yDotK[8][j]  + K16_10 * yDotK[9][j] +\n          K16_11 * yDotK[10][j] + K16_12 * yDotK[11][j] + K16_13 * yDotK[12][j] +\n          K16_14 * yDotKLast[0][j] +  K16_15 * yDotKLast[1][j];\n      yTmp[j] = currentState[j] + h * s;\n    }\n    integrator.computeDerivatives(previousTime + C16 * h, yTmp, yDotKLast[2]);\n\n  }",
    "comment": "{@inheritDoc} */",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "DormandPrince853StepInterpolator.reinitialize",
    "class_name": "org.apache.commons.math.ode.nonstiff.DormandPrince853StepInterpolator",
    "signature": "org.apache.commons.math.ode.nonstiff.DormandPrince853StepInterpolator.reinitialize(AbstractIntegrator,double[],double[][],boolean)",
    "snippet": "  @Override\n  public void reinitialize(final AbstractIntegrator integrator,\n                           final double[] y, final double[][] yDotK, final boolean forward) {\n\n    super.reinitialize(integrator, y, yDotK, forward);\n\n    final int dimension = currentState.length;\n\n    yDotKLast = new double[3][];\n    for (int k = 0; k < yDotKLast.length; ++k) {\n      yDotKLast[k] = new double[dimension];\n    }\n\n    v = new double[7][];\n    for (int k = 0; k < v.length; ++k) {\n      v[k]  = new double[dimension];\n    }\n\n    vectorsInitialized = false;\n\n  }",
    "comment": "{@inheritDoc} */",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "DormandPrince853StepInterpolator.storeTime",
    "class_name": "org.apache.commons.math.ode.nonstiff.DormandPrince853StepInterpolator",
    "signature": "org.apache.commons.math.ode.nonstiff.DormandPrince853StepInterpolator.storeTime(double)",
    "snippet": "  @Override\n  public void storeTime(final double t) {\n    super.storeTime(t);\n    vectorsInitialized = false;\n  }",
    "comment": "{@inheritDoc} */",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "EmbeddedRungeKuttaIntegrator.EmbeddedRungeKuttaIntegrator",
    "class_name": "org.apache.commons.math.ode.nonstiff.EmbeddedRungeKuttaIntegrator",
    "signature": "org.apache.commons.math.ode.nonstiff.EmbeddedRungeKuttaIntegrator.EmbeddedRungeKuttaIntegrator(String,boolean,double[],double[][],double[],RungeKuttaStepInterpolator,double,double,double,double)",
    "snippet": "  protected EmbeddedRungeKuttaIntegrator(final String name, final boolean fsal,\n                                         final double[] c, final double[][] a, final double[] b,\n                                         final RungeKuttaStepInterpolator prototype,\n                                         final double minStep, final double maxStep,\n                                         final double scalAbsoluteTolerance,\n                                         final double scalRelativeTolerance) {\n\n    super(name, minStep, maxStep, scalAbsoluteTolerance, scalRelativeTolerance);\n\n    this.fsal      = fsal;\n    this.c         = c;\n    this.a         = a;\n    this.b         = b;\n    this.prototype = prototype;\n\n    exp = -1.0 / getOrder();\n\n    // set the default values of the algorithm control parameters\n    setSafety(0.9);\n    setMinReduction(0.2);\n    setMaxGrowth(10.0);\n\n  }",
    "comment": "Build a Runge-Kutta integrator with the given Butcher array. @param name name of the method @param fsal indicate that the method is an <i>fsal</i> @param c time steps from Butcher array (without the first zero) @param a internal weights from Butcher array (without the first empty row) @param b propagation weights for the high order method from Butcher array @param prototype prototype of the step interpolator to use @param minStep minimal step (must be positive even for backward integration), the last step can be smaller than this @param maxStep maximal step (must be positive even for backward integration) @param scalAbsoluteTolerance allowed absolute error @param scalRelativeTolerance allowed relative error ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "EmbeddedRungeKuttaIntegrator.integrate",
    "class_name": "org.apache.commons.math.ode.nonstiff.EmbeddedRungeKuttaIntegrator",
    "signature": "org.apache.commons.math.ode.nonstiff.EmbeddedRungeKuttaIntegrator.integrate(FirstOrderDifferentialEquations,double,double[],double,double[])",
    "snippet": "  @Override\n  public double integrate(final FirstOrderDifferentialEquations equations,\n                          final double t0, final double[] y0,\n                          final double t, final double[] y)\n  throws DerivativeException, IntegratorException {\n\n    sanityChecks(equations, t0, y0, t, y);\n    setEquations(equations);\n    resetEvaluations();\n    final boolean forward = t > t0;\n\n    // create some internal working arrays\n    final int stages = c.length + 1;\n    if (y != y0) {\n      System.arraycopy(y0, 0, y, 0, y0.length);\n    }\n    final double[][] yDotK = new double[stages][y0.length];\n    final double[] yTmp = new double[y0.length];\n\n    // set up an interpolator sharing the integrator arrays\n    AbstractStepInterpolator interpolator;\n    if (requiresDenseOutput() || (! eventsHandlersManager.isEmpty())) {\n      final RungeKuttaStepInterpolator rki = (RungeKuttaStepInterpolator) prototype.copy();\n      rki.reinitialize(this, yTmp, yDotK, forward);\n      interpolator = rki;\n    } else {\n      interpolator = new DummyStepInterpolator(yTmp, forward);\n    }\n    interpolator.storeTime(t0);\n\n    // set up integration control objects\n    stepStart         = t0;\n    double  hNew      = 0;\n    boolean firstTime = true;\n    for (StepHandler handler : stepHandlers) {\n        handler.reset();\n    }\n    CombinedEventsManager manager = addEndTimeChecker(t0, t, eventsHandlersManager);\n    boolean lastStep = false;\n\n    // main integration loop\n    while (!lastStep) {\n\n      interpolator.shift();\n\n      double error = 0;\n      for (boolean loop = true; loop;) {\n\n        if (firstTime || !fsal) {\n          // first stage\n          computeDerivatives(stepStart, y, yDotK[0]);\n        }\n\n        if (firstTime) {\n          final double[] scale;\n          if (vecAbsoluteTolerance == null) {\n              scale = new double[y0.length];\n              java.util.Arrays.fill(scale, scalAbsoluteTolerance);\n            } else {\n              scale = vecAbsoluteTolerance;\n            }\n          hNew = initializeStep(equations, forward, getOrder(), scale,\n                                stepStart, y, yDotK[0], yTmp, yDotK[1]);\n          firstTime = false;\n        }\n\n        stepSize = hNew;\n\n        // next stages\n        for (int k = 1; k < stages; ++k) {\n\n          for (int j = 0; j < y0.length; ++j) {\n            double sum = a[k-1][0] * yDotK[0][j];\n            for (int l = 1; l < k; ++l) {\n              sum += a[k-1][l] * yDotK[l][j];\n            }\n            yTmp[j] = y[j] + stepSize * sum;\n          }\n\n          computeDerivatives(stepStart + c[k-1] * stepSize, yTmp, yDotK[k]);\n\n        }\n\n        // estimate the state at the end of the step\n        for (int j = 0; j < y0.length; ++j) {\n          double sum    = b[0] * yDotK[0][j];\n          for (int l = 1; l < stages; ++l) {\n            sum    += b[l] * yDotK[l][j];\n          }\n          yTmp[j] = y[j] + stepSize * sum;\n        }\n\n        // estimate the error at the end of the step\n        error = estimateError(yDotK, y, yTmp, stepSize);\n        if (error <= 1.0) {\n\n          // discrete events handling\n          interpolator.storeTime(stepStart + stepSize);\n          if (manager.evaluateStep(interpolator)) {\n              final double dt = manager.getEventTime() - stepStart;\n              if (Math.abs(dt) <= Math.ulp(stepStart)) {\n                  // rejecting the step would lead to a too small next step, we accept it\n                  loop = false;\n              } else {\n                  // reject the step to match exactly the next switch time\n                  hNew = dt;\n              }\n          } else {\n            // accept the step\n            loop = false;\n          }\n\n        } else {\n          // reject the step and attempt to reduce error by stepsize control\n          final double factor =\n              Math.min(maxGrowth,\n                       Math.max(minReduction, safety * Math.pow(error, exp)));\n          hNew = filterStep(stepSize * factor, forward, false);\n        }\n\n      }\n\n      // the step has been accepted\n      final double nextStep = stepStart + stepSize;\n      System.arraycopy(yTmp, 0, y, 0, y0.length);\n      manager.stepAccepted(nextStep, y);\n      lastStep = manager.stop();\n\n      // provide the step data to the step handler\n      interpolator.storeTime(nextStep);\n      for (StepHandler handler : stepHandlers) {\n          handler.handleStep(interpolator, lastStep);\n      }\n      stepStart = nextStep;\n\n      if (fsal) {\n        // save the last evaluation for the next step\n        System.arraycopy(yDotK[stages - 1], 0, yDotK[0], 0, y0.length);\n      }\n\n      if (manager.reset(stepStart, y) && ! lastStep) {\n        // some event handler has triggered changes that\n        // invalidate the derivatives, we need to recompute them\n        computeDerivatives(stepStart, y, yDotK[0]);\n      }\n\n      if (! lastStep) {\n        // in some rare cases we may get here with stepSize = 0, for example\n        // when an event occurs at integration start, reducing the first step\n        // to zero; we have to reset the step to some safe non zero value\n          stepSize = filterStep(stepSize, forward, true);\n\n        // stepsize control for next step\n        final double factor = Math.min(maxGrowth,\n                                       Math.max(minReduction,\n                                                safety * Math.pow(error, exp)));\n        final double  scaledH    = stepSize * factor;\n        final double  nextT      = stepStart + scaledH;\n        final boolean nextIsLast = forward ? (nextT >= t) : (nextT <= t);\n        hNew = filterStep(scaledH, forward, nextIsLast);\n      }\n\n    }\n\n    final double stopTime = stepStart;\n    resetInternalState();\n    return stopTime;\n\n  }",
    "comment": "{@inheritDoc} */",
    "is_bug": true,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "EmbeddedRungeKuttaIntegrator.setMaxGrowth",
    "class_name": "org.apache.commons.math.ode.nonstiff.EmbeddedRungeKuttaIntegrator",
    "signature": "org.apache.commons.math.ode.nonstiff.EmbeddedRungeKuttaIntegrator.setMaxGrowth(double)",
    "snippet": "  public void setMaxGrowth(final double maxGrowth) {\n    this.maxGrowth = maxGrowth;\n  }",
    "comment": "Set the maximal growth factor for stepsize control. @param maxGrowth maximal growth factor ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "EmbeddedRungeKuttaIntegrator.setMinReduction",
    "class_name": "org.apache.commons.math.ode.nonstiff.EmbeddedRungeKuttaIntegrator",
    "signature": "org.apache.commons.math.ode.nonstiff.EmbeddedRungeKuttaIntegrator.setMinReduction(double)",
    "snippet": "  public void setMinReduction(final double minReduction) {\n    this.minReduction = minReduction;\n  }",
    "comment": "Set the minimal reduction factor for stepsize control. @param minReduction minimal reduction factor ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "EmbeddedRungeKuttaIntegrator.setSafety",
    "class_name": "org.apache.commons.math.ode.nonstiff.EmbeddedRungeKuttaIntegrator",
    "signature": "org.apache.commons.math.ode.nonstiff.EmbeddedRungeKuttaIntegrator.setSafety(double)",
    "snippet": "  public void setSafety(final double safety) {\n    this.safety = safety;\n  }",
    "comment": "Set the safety factor for stepsize control. @param safety safety factor ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "RungeKuttaStepInterpolator.RungeKuttaStepInterpolator",
    "class_name": "org.apache.commons.math.ode.nonstiff.RungeKuttaStepInterpolator",
    "signature": "org.apache.commons.math.ode.nonstiff.RungeKuttaStepInterpolator.RungeKuttaStepInterpolator()",
    "snippet": "  protected RungeKuttaStepInterpolator() {\n    super();\n    yDotK      = null;\n    integrator = null;\n  }",
    "comment": "Simple constructor. This constructor builds an instance that is not usable yet, the {@link #reinitialize} method should be called before using the instance in order to initialize the internal arrays. This constructor is used only in order to delay the initialization in some cases. The {@link RungeKuttaIntegrator} and {@link EmbeddedRungeKuttaIntegrator} classes use the prototyping design pattern to create the step interpolators by cloning an uninitialized model and latter initializing the copy. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "RungeKuttaStepInterpolator.RungeKuttaStepInterpolator",
    "class_name": "org.apache.commons.math.ode.nonstiff.RungeKuttaStepInterpolator",
    "signature": "org.apache.commons.math.ode.nonstiff.RungeKuttaStepInterpolator.RungeKuttaStepInterpolator(RungeKuttaStepInterpolator)",
    "snippet": "  public RungeKuttaStepInterpolator(final RungeKuttaStepInterpolator interpolator) {\n\n    super(interpolator);\n\n    if (interpolator.currentState != null) {\n      final int dimension = currentState.length;\n\n      yDotK = new double[interpolator.yDotK.length][];\n      for (int k = 0; k < interpolator.yDotK.length; ++k) {\n        yDotK[k] = new double[dimension];\n        System.arraycopy(interpolator.yDotK[k], 0,\n                         yDotK[k], 0, dimension);\n      }\n\n    } else {\n      yDotK = null;\n    }\n\n    // we cannot keep any reference to the equations in the copy\n    // the interpolator should have been finalized before\n    integrator = null;\n\n  }",
    "comment": "Copy constructor.  <p>The copied interpolator should have been finalized before the copy, otherwise the copy will not be able to perform correctly any interpolation and will throw a {@link NullPointerException} later. Since we don't want this constructor to throw the exceptions finalization may involve and since we don't want this method to modify the state of the copied interpolator, finalization is <strong>not</strong> done automatically, it remains under user control.</p>  <p>The copy is a deep copy: its arrays are separated from the original arrays of the instance.</p>  @param interpolator interpolator to copy from.  ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "RungeKuttaStepInterpolator.reinitialize",
    "class_name": "org.apache.commons.math.ode.nonstiff.RungeKuttaStepInterpolator",
    "signature": "org.apache.commons.math.ode.nonstiff.RungeKuttaStepInterpolator.reinitialize(AbstractIntegrator,double[],double[][],boolean)",
    "snippet": "  public void reinitialize(final AbstractIntegrator rkIntegrator,\n                           final double[] y, final double[][] yDotArray, final boolean forward) {\n    reinitialize(y, forward);\n    this.yDotK = yDotArray;\n    this.integrator = rkIntegrator;\n  }",
    "comment": "Reinitialize the instance <p>Some Runge-Kutta integrators need fewer functions evaluations than their counterpart step interpolators. So the interpolator should perform the last evaluations they need by themselves. The {@link RungeKuttaIntegrator RungeKuttaIntegrator} and {@link EmbeddedRungeKuttaIntegrator EmbeddedRungeKuttaIntegrator} abstract classes call this method in order to let the step interpolator perform the evaluations it needs. These evaluations will be performed during the call to <code>doFinalize</code> if any, i.e. only if the step handler either calls the {@link AbstractStepInterpolator#finalizeStep finalizeStep} method or the {@link AbstractStepInterpolator#getInterpolatedState getInterpolatedState} method (for an interpolator which needs a finalization) or if it clones the step interpolator.</p> @param rkIntegrator integrator being used @param y reference to the integrator array holding the state at the end of the step @param yDotArray reference to the integrator array holding all the intermediate slopes @param forward integration direction indicator ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "AbstractStepInterpolator.AbstractStepInterpolator",
    "class_name": "org.apache.commons.math.ode.sampling.AbstractStepInterpolator",
    "signature": "org.apache.commons.math.ode.sampling.AbstractStepInterpolator.AbstractStepInterpolator()",
    "snippet": "  protected AbstractStepInterpolator() {\n    previousTime            = Double.NaN;\n    currentTime             = Double.NaN;\n    h                       = Double.NaN;\n    interpolatedTime        = Double.NaN;\n    currentState            = null;\n    interpolatedState       = null;\n    interpolatedDerivatives = null;\n    finalized               = false;\n    this.forward            = true;\n    this.dirtyState         = true;\n  }",
    "comment": "Simple constructor. This constructor builds an instance that is not usable yet, the {@link #reinitialize} method should be called before using the instance in order to initialize the internal arrays. This constructor is used only in order to delay the initialization in some cases. As an example, the {@link org.apache.commons.math.ode.nonstiff.EmbeddedRungeKuttaIntegrator} class uses the prototyping design pattern to create the step interpolators by cloning an uninitialized model and latter initializing the copy. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "AbstractStepInterpolator.AbstractStepInterpolator",
    "class_name": "org.apache.commons.math.ode.sampling.AbstractStepInterpolator",
    "signature": "org.apache.commons.math.ode.sampling.AbstractStepInterpolator.AbstractStepInterpolator(AbstractStepInterpolator)",
    "snippet": "  protected AbstractStepInterpolator(final AbstractStepInterpolator interpolator) {\n\n    previousTime      = interpolator.previousTime;\n    currentTime       = interpolator.currentTime;\n    h                 = interpolator.h;\n    interpolatedTime  = interpolator.interpolatedTime;\n\n    if (interpolator.currentState != null) {\n      currentState            = interpolator.currentState.clone();\n      interpolatedState       = interpolator.interpolatedState.clone();\n      interpolatedDerivatives = interpolator.interpolatedDerivatives.clone();\n    } else {\n      currentState            = null;\n      interpolatedState       = null;\n      interpolatedDerivatives = null;\n    }\n\n    finalized  = interpolator.finalized;\n    forward    = interpolator.forward;\n    dirtyState = interpolator.dirtyState;\n\n  }",
    "comment": "Copy constructor.  <p>The copied interpolator should have been finalized before the copy, otherwise the copy will not be able to perform correctly any derivative computation and will throw a {@link NullPointerException} later. Since we don't want this constructor to throw the exceptions finalization may involve and since we don't want this method to modify the state of the copied interpolator, finalization is <strong>not</strong> done automatically, it remains under user control.</p>  <p>The copy is a deep copy: its arrays are separated from the original arrays of the instance.</p>  @param interpolator interpolator to copy from.  ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "AbstractStepInterpolator.copy",
    "class_name": "org.apache.commons.math.ode.sampling.AbstractStepInterpolator",
    "signature": "org.apache.commons.math.ode.sampling.AbstractStepInterpolator.copy()",
    "snippet": "   public StepInterpolator copy() throws DerivativeException {\n\n     // finalize the step before performing copy\n     finalizeStep();\n\n     // create the new independent instance\n     return doCopy();\n\n   }",
    "comment": "{@inheritDoc} */",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "AbstractStepInterpolator.finalizeStep",
    "class_name": "org.apache.commons.math.ode.sampling.AbstractStepInterpolator",
    "signature": "org.apache.commons.math.ode.sampling.AbstractStepInterpolator.finalizeStep()",
    "snippet": "  public final void finalizeStep()\n    throws DerivativeException {\n    if (! finalized) {\n      doFinalize();\n      finalized = true;\n    }\n  }",
    "comment": " Finalize the step.  <p>Some embedded Runge-Kutta integrators need fewer functions evaluations than their counterpart step interpolators. These interpolators should perform the last evaluations they need by themselves only if they need them. This method triggers these extra evaluations. It can be called directly by the user step handler and it is called automatically if {@link #setInterpolatedTime} is called.</p>  <p>Once this method has been called, <strong>no</strong> other evaluation will be performed on this step. If there is a need to have some side effects between the step handler and the differential equations (for example update some data in the equations once the step has been done), it is advised to call this method explicitly from the step handler before these side effects are set up. If the step handler induces no side effect, then this method can safely be ignored, it will be called transparently as needed.</p>  <p><strong>Warning</strong>: since the step interpolator provided to the step handler as a parameter of the {@link StepHandler#handleStep handleStep} is valid only for the duration of the {@link StepHandler#handleStep handleStep} call, one cannot simply store a reference and reuse it later. One should first finalize the instance, then copy this finalized instance into a new object that can be kept.</p>  <p>This method calls the protected <code>doFinalize</code> method if it has never been called during this step and set a flag indicating that it has been called once. It is the <code> doFinalize</code> method which should perform the evaluations. This wrapping prevents from calling <code>doFinalize</code> several times and hence evaluating the differential equations too often. Therefore, subclasses are not allowed not reimplement it, they should rather reimplement <code>doFinalize</code>.</p>  @throws DerivativeException this exception is propagated to the caller if the underlying user function triggers one ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "AbstractStepInterpolator.getCurrentTime",
    "class_name": "org.apache.commons.math.ode.sampling.AbstractStepInterpolator",
    "signature": "org.apache.commons.math.ode.sampling.AbstractStepInterpolator.getCurrentTime()",
    "snippet": "  public double getCurrentTime() {\n    return currentTime;\n  }",
    "comment": "{@inheritDoc} */",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "AbstractStepInterpolator.getInterpolatedDerivatives",
    "class_name": "org.apache.commons.math.ode.sampling.AbstractStepInterpolator",
    "signature": "org.apache.commons.math.ode.sampling.AbstractStepInterpolator.getInterpolatedDerivatives()",
    "snippet": "  public double[] getInterpolatedDerivatives() throws DerivativeException {\n\n      // lazy evaluation of the state\n      if (dirtyState) {\n          final double oneMinusThetaH = currentTime - interpolatedTime;\n          final double theta = (h == 0) ? 0 : (h - oneMinusThetaH) / h;\n          computeInterpolatedStateAndDerivatives(theta, oneMinusThetaH);\n          dirtyState = false;\n      }\n\n      return interpolatedDerivatives;\n\n  }",
    "comment": "{@inheritDoc} */",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "AbstractStepInterpolator.getInterpolatedState",
    "class_name": "org.apache.commons.math.ode.sampling.AbstractStepInterpolator",
    "signature": "org.apache.commons.math.ode.sampling.AbstractStepInterpolator.getInterpolatedState()",
    "snippet": "  public double[] getInterpolatedState() throws DerivativeException {\n\n      // lazy evaluation of the state\n      if (dirtyState) {\n          final double oneMinusThetaH = currentTime - interpolatedTime;\n          final double theta = (h == 0) ? 0 : (h - oneMinusThetaH) / h;\n          computeInterpolatedStateAndDerivatives(theta, oneMinusThetaH);\n          dirtyState = false;\n      }\n\n      return interpolatedState;\n\n  }",
    "comment": "{@inheritDoc} */",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "AbstractStepInterpolator.getInterpolatedTime",
    "class_name": "org.apache.commons.math.ode.sampling.AbstractStepInterpolator",
    "signature": "org.apache.commons.math.ode.sampling.AbstractStepInterpolator.getInterpolatedTime()",
    "snippet": "  public double getInterpolatedTime() {\n    return interpolatedTime;\n  }",
    "comment": "{@inheritDoc} */",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "AbstractStepInterpolator.getPreviousTime",
    "class_name": "org.apache.commons.math.ode.sampling.AbstractStepInterpolator",
    "signature": "org.apache.commons.math.ode.sampling.AbstractStepInterpolator.getPreviousTime()",
    "snippet": "  public double getPreviousTime() {\n    return previousTime;\n  }",
    "comment": "{@inheritDoc} */",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "AbstractStepInterpolator.isForward",
    "class_name": "org.apache.commons.math.ode.sampling.AbstractStepInterpolator",
    "signature": "org.apache.commons.math.ode.sampling.AbstractStepInterpolator.isForward()",
    "snippet": "  public boolean isForward() {\n    return forward;\n  }",
    "comment": "{@inheritDoc} */",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "AbstractStepInterpolator.reinitialize",
    "class_name": "org.apache.commons.math.ode.sampling.AbstractStepInterpolator",
    "signature": "org.apache.commons.math.ode.sampling.AbstractStepInterpolator.reinitialize(double[],boolean)",
    "snippet": "  protected void reinitialize(final double[] y, final boolean isForward) {\n\n    previousTime      = Double.NaN;\n    currentTime       = Double.NaN;\n    h                 = Double.NaN;\n    interpolatedTime  = Double.NaN;\n\n    currentState            = y;\n    interpolatedState       = new double[y.length];\n    interpolatedDerivatives = new double[y.length];\n\n    finalized         = false;\n    this.forward      = isForward;\n    this.dirtyState   = true;\n\n  }",
    "comment": "Reinitialize the instance @param y reference to the integrator array holding the state at the end of the step @param isForward integration direction indicator ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "AbstractStepInterpolator.setInterpolatedTime",
    "class_name": "org.apache.commons.math.ode.sampling.AbstractStepInterpolator",
    "signature": "org.apache.commons.math.ode.sampling.AbstractStepInterpolator.setInterpolatedTime(double)",
    "snippet": "  public void setInterpolatedTime(final double time) {\n      interpolatedTime = time;\n      dirtyState       = true;\n  }",
    "comment": "{@inheritDoc} */",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "AbstractStepInterpolator.shift",
    "class_name": "org.apache.commons.math.ode.sampling.AbstractStepInterpolator",
    "signature": "org.apache.commons.math.ode.sampling.AbstractStepInterpolator.shift()",
    "snippet": "  public void shift() {\n    previousTime = currentTime;\n  }",
    "comment": "Shift one step forward. Copy the current time into the previous time, hence preparing the interpolator for future calls to {@link #storeTime storeTime} ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "AbstractStepInterpolator.storeTime",
    "class_name": "org.apache.commons.math.ode.sampling.AbstractStepInterpolator",
    "signature": "org.apache.commons.math.ode.sampling.AbstractStepInterpolator.storeTime(double)",
    "snippet": "  public void storeTime(final double t) {\n\n    currentTime = t;\n    h           = currentTime - previousTime;\n    setInterpolatedTime(t);\n\n    // the step is not finalized anymore\n    finalized  = false;\n\n  }",
    "comment": "Store the current step time. @param t current time ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "NordsieckStepInterpolator.NordsieckStepInterpolator",
    "class_name": "org.apache.commons.math.ode.sampling.NordsieckStepInterpolator",
    "signature": "org.apache.commons.math.ode.sampling.NordsieckStepInterpolator.NordsieckStepInterpolator()",
    "snippet": "    public NordsieckStepInterpolator() {\n    }",
    "comment": "Simple constructor. This constructor builds an instance that is not usable yet, the {@link AbstractStepInterpolator#reinitialize} method should be called before using the instance in order to initialize the internal arrays. This constructor is used only in order to delay the initialization in some cases. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "NordsieckStepInterpolator.computeInterpolatedStateAndDerivatives",
    "class_name": "org.apache.commons.math.ode.sampling.NordsieckStepInterpolator",
    "signature": "org.apache.commons.math.ode.sampling.NordsieckStepInterpolator.computeInterpolatedStateAndDerivatives(double,double)",
    "snippet": "    @Override\n    protected void computeInterpolatedStateAndDerivatives(final double theta, final double oneMinusThetaH) {\n\n        final double x = interpolatedTime - referenceTime;\n        final double normalizedAbscissa = x / scalingH;\n\n        Arrays.fill(stateVariation, 0.0);\n        Arrays.fill(interpolatedDerivatives, 0.0);\n\n        // apply Taylor formula from high order to low order,\n        // for the sake of numerical accuracy\n        final double[][] nData = nordsieck.getDataRef();\n        for (int i = nData.length - 1; i >= 0; --i) {\n            final int order = i + 2;\n            final double[] nDataI = nData[i];\n            final double power = Math.pow(normalizedAbscissa, order);\n            for (int j = 0; j < nDataI.length; ++j) {\n                final double d = nDataI[j] * power;\n                stateVariation[j]          += d;\n                interpolatedDerivatives[j] += order * d;\n            }\n        }\n\n        for (int j = 0; j < currentState.length; ++j) {\n            stateVariation[j] += scaled[j] * normalizedAbscissa;\n            interpolatedState[j] = currentState[j] + stateVariation[j];\n            interpolatedDerivatives[j] =\n                (interpolatedDerivatives[j] + scaled[j] * normalizedAbscissa) / x;\n        }\n\n    }",
    "comment": "{@inheritDoc} */",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "NordsieckStepInterpolator.reinitialize",
    "class_name": "org.apache.commons.math.ode.sampling.NordsieckStepInterpolator",
    "signature": "org.apache.commons.math.ode.sampling.NordsieckStepInterpolator.reinitialize(double,double,double[],Array2DRowRealMatrix)",
    "snippet": "    public void reinitialize(final double time, final double stepSize,\n                             final double[] scaledDerivative,\n                             final Array2DRowRealMatrix nordsieckVector) {\n        this.referenceTime = time;\n        this.scalingH      = stepSize;\n        this.scaled        = scaledDerivative;\n        this.nordsieck     = nordsieckVector;\n\n        // make sure the state and derivatives will depend on the new arrays\n        setInterpolatedTime(getInterpolatedTime());\n\n    }",
    "comment": "Reinitialize the instance. <p>Beware that all arrays <em>must</em> be references to integrator arrays, in order to ensure proper update without copy.</p> @param time time at which all arrays are defined @param stepSize step size used in the scaled and nordsieck arrays @param scaledDerivative reference to the integrator array holding the first scaled derivative @param nordsieckVector reference to the integrator matrix holding the nordsieck vector ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "NordsieckStepInterpolator.reinitialize",
    "class_name": "org.apache.commons.math.ode.sampling.NordsieckStepInterpolator",
    "signature": "org.apache.commons.math.ode.sampling.NordsieckStepInterpolator.reinitialize(double[],boolean)",
    "snippet": "    @Override\n    public void reinitialize(final double[] y, final boolean forward) {\n        super.reinitialize(y, forward);\n        stateVariation = new double[y.length];\n    }",
    "comment": "Reinitialize the instance. <p>Beware that all arrays <em>must</em> be references to integrator arrays, in order to ensure proper update without copy.</p> @param y reference to the integrator array holding the state at the end of the step @param forward integration direction indicator ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "NordsieckStepInterpolator.rescale",
    "class_name": "org.apache.commons.math.ode.sampling.NordsieckStepInterpolator",
    "signature": "org.apache.commons.math.ode.sampling.NordsieckStepInterpolator.rescale(double)",
    "snippet": "    public void rescale(final double stepSize) {\n\n        final double ratio = stepSize / scalingH;\n        for (int i = 0; i < scaled.length; ++i) {\n            scaled[i] *= ratio;\n        }\n\n        final double[][] nData = nordsieck.getDataRef();\n        double power = ratio;\n        for (int i = 0; i < nData.length; ++i) {\n            power *= ratio;\n            final double[] nDataI = nData[i];\n            for (int j = 0; j < nDataI.length; ++j) {\n                nDataI[j] *= power;\n            }\n        }\n\n        scalingH = stepSize;\n\n    }",
    "comment": "Rescale the instance. <p>Since the scaled and Nordiseck arrays are shared with the caller, this method has the side effect of rescaling this arrays in the caller too.</p> @param stepSize new step size to use in the scaled and nordsieck arrays ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  }
]