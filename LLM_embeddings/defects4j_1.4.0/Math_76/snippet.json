[
  {
    "name": "AbstractRealMatrix.AbstractRealMatrix",
    "class_name": "org.apache.commons.math.linear.AbstractRealMatrix",
    "signature": "org.apache.commons.math.linear.AbstractRealMatrix.AbstractRealMatrix()",
    "snippet": "    protected AbstractRealMatrix() {\n        lu = null;\n    }",
    "comment": " Creates a matrix with no data ",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 2
  },
  {
    "name": "AbstractRealMatrix.AbstractRealMatrix",
    "class_name": "org.apache.commons.math.linear.AbstractRealMatrix",
    "signature": "org.apache.commons.math.linear.AbstractRealMatrix.AbstractRealMatrix(int,int)",
    "snippet": "    protected AbstractRealMatrix(final int rowDimension, final int columnDimension)\n        throws IllegalArgumentException {\n        if (rowDimension <= 0 ) {\n            throw MathRuntimeException.createIllegalArgumentException(\n                    \"invalid row dimension {0} (must be positive)\",\n                    rowDimension);\n        }\n        if (columnDimension <= 0) {\n            throw MathRuntimeException.createIllegalArgumentException(\n                    \"invalid column dimension {0} (must be positive)\",\n                    columnDimension);\n        }\n        lu = null;\n    }",
    "comment": " Create a new RealMatrix with the supplied row and column dimensions.  @param rowDimension  the number of rows in the new matrix @param columnDimension  the number of columns in the new matrix @throws IllegalArgumentException if row or column dimension is not positive ",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 2
  },
  {
    "name": "AbstractRealMatrix.getNorm",
    "class_name": "org.apache.commons.math.linear.AbstractRealMatrix",
    "signature": "org.apache.commons.math.linear.AbstractRealMatrix.getNorm()",
    "snippet": "    public double getNorm() {\n        return walkInColumnOrder(new RealMatrixPreservingVisitor() {\n\n            /** Last row index. */\n            private double endRow;\n\n            /** Sum of absolute values on one column. */\n            private double columnSum;\n\n            /** Maximal sum across all columns. */\n            private double maxColSum;\n\n            /** {@inheritDoc} */\n            public void start(final int rows, final int columns,\n                              final int startRow, final int endRow,\n                              final int startColumn, final int endColumn) {\n                this.endRow = endRow;\n                columnSum   = 0;\n                maxColSum   = 0;\n            }\n\n            /** {@inheritDoc} */\n            public void visit(final int row, final int column, final double value) {\n                columnSum += Math.abs(value);\n                if (row == endRow) {\n                    maxColSum = Math.max(maxColSum, columnSum);\n                    columnSum = 0;\n                }\n            }\n\n            /** {@inheritDoc} */\n            public double end() {\n                return maxColSum;\n            }\n\n        });\n    }",
    "comment": "{@inheritDoc} */",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 2
  },
  {
    "name": "AbstractRealMatrix.getSubMatrix",
    "class_name": "org.apache.commons.math.linear.AbstractRealMatrix",
    "signature": "org.apache.commons.math.linear.AbstractRealMatrix.getSubMatrix(int,int,int,int)",
    "snippet": "    public RealMatrix getSubMatrix(final int startRow, final int endRow,\n                                   final int startColumn, final int endColumn)\n        throws MatrixIndexException {\n\n        MatrixUtils.checkSubMatrixIndex(this, startRow, endRow, startColumn, endColumn);\n\n        final RealMatrix subMatrix =\n            createMatrix(endRow - startRow + 1, endColumn - startColumn + 1);\n        for (int i = startRow; i <= endRow; ++i) {\n            for (int j = startColumn; j <= endColumn; ++j) {\n                subMatrix.setEntry(i - startRow, j - startColumn, getEntry(i, j));\n            }\n        }\n\n        return subMatrix;\n\n    }",
    "comment": "{@inheritDoc} */",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 2
  },
  {
    "name": "AbstractRealMatrix.setColumnVector",
    "class_name": "org.apache.commons.math.linear.AbstractRealMatrix",
    "signature": "org.apache.commons.math.linear.AbstractRealMatrix.setColumnVector(int,RealVector)",
    "snippet": "    public void setColumnVector(final int column, final RealVector vector)\n        throws MatrixIndexException, InvalidMatrixException {\n\n        MatrixUtils.checkColumnIndex(this, column);\n        final int nRows = getRowDimension();\n        if (vector.getDimension() != nRows) {\n            throw new InvalidMatrixException(\n                    \"dimensions mismatch: got {0}x{1} but expected {2}x{3}\",\n                    vector.getDimension(), 1, nRows, 1);\n        }\n        for (int i = 0; i < nRows; ++i) {\n            setEntry(i, column, vector.getEntry(i));\n        }\n\n    }",
    "comment": "{@inheritDoc} */",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 2
  },
  {
    "name": "AbstractRealMatrix.transpose",
    "class_name": "org.apache.commons.math.linear.AbstractRealMatrix",
    "signature": "org.apache.commons.math.linear.AbstractRealMatrix.transpose()",
    "snippet": "    public RealMatrix transpose() {\n\n        final int nRows = getRowDimension();\n        final int nCols = getColumnDimension();\n        final RealMatrix out = createMatrix(nCols, nRows);\n        walkInOptimizedOrder(new DefaultRealMatrixPreservingVisitor() {\n\n            /** {@inheritDoc} */\n            @Override\n            public void visit(final int row, final int column, final double value) {\n                out.setEntry(column, row, value);\n            }\n\n        });\n\n        return out;\n\n    }",
    "comment": "{@inheritDoc} */",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 2
  },
  {
    "name": "AbstractRealMatrix.walkInOptimizedOrder",
    "class_name": "org.apache.commons.math.linear.AbstractRealMatrix",
    "signature": "org.apache.commons.math.linear.AbstractRealMatrix.walkInOptimizedOrder(RealMatrixPreservingVisitor)",
    "snippet": "    public double walkInOptimizedOrder(final RealMatrixPreservingVisitor visitor)\n        throws MatrixVisitorException {\n        return walkInRowOrder(visitor);\n    }",
    "comment": "{@inheritDoc} */",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 2
  },
  {
    "name": "Array2DRowRealMatrix.Array2DRowRealMatrix",
    "class_name": "org.apache.commons.math.linear.Array2DRowRealMatrix",
    "signature": "org.apache.commons.math.linear.Array2DRowRealMatrix.Array2DRowRealMatrix(double[][])",
    "snippet": "    public Array2DRowRealMatrix(final double[][] d)\n        throws IllegalArgumentException, NullPointerException {\n        copyIn(d);\n    }",
    "comment": " Create a new RealMatrix using the input array as the underlying data array. <p>The input array is copied, not referenced. This constructor has the same effect as calling {@link #Array2DRowRealMatrix(double[][], boolean)} with the second argument set to <code>true</code>.</p>  @param d data for new matrix @throws IllegalArgumentException if <code>d</code> is not rectangular (not all rows have the same length) or empty @throws NullPointerException if <code>d</code> is null @see #Array2DRowRealMatrix(double[][], boolean) ",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 2
  },
  {
    "name": "Array2DRowRealMatrix.Array2DRowRealMatrix",
    "class_name": "org.apache.commons.math.linear.Array2DRowRealMatrix",
    "signature": "org.apache.commons.math.linear.Array2DRowRealMatrix.Array2DRowRealMatrix(double[][],boolean)",
    "snippet": "    public Array2DRowRealMatrix(final double[][] d, final boolean copyArray)\n        throws IllegalArgumentException, NullPointerException {\n        if (copyArray) {\n            copyIn(d);\n        } else {\n            if (d == null) {\n                throw new NullPointerException();\n            }\n            final int nRows = d.length;\n            if (nRows == 0) {\n                throw MathRuntimeException.createIllegalArgumentException(\n                      AT_LEAST_ONE_ROW_MESSAGE);\n            }\n            final int nCols = d[0].length;\n            if (nCols == 0) {\n                throw MathRuntimeException.createIllegalArgumentException(\n                      AT_LEAST_ONE_COLUMN_MESSAGE);\n            }\n            for (int r = 1; r < nRows; r++) {\n                if (d[r].length != nCols) {\n                    throw MathRuntimeException.createIllegalArgumentException(\n                          DIFFERENT_ROWS_LENGTHS_MESSAGE, nCols, d[r].length);\n                }\n            }\n            data = d;\n        }\n    }",
    "comment": " Create a new RealMatrix using the input array as the underlying data array. <p>If an array is built specially in order to be embedded in a RealMatrix and not used directly, the <code>copyArray</code> may be set to <code>false</code. This will prevent the copying and improve performance as no new array will be built and no data will be copied.</p> @param d data for new matrix @param copyArray if true, the input array will be copied, otherwise it will be referenced @throws IllegalArgumentException if <code>d</code> is not rectangular (not all rows have the same length) or empty @throws NullPointerException if <code>d</code> is null @see #Array2DRowRealMatrix(double[][]) ",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 2
  },
  {
    "name": "Array2DRowRealMatrix.Array2DRowRealMatrix",
    "class_name": "org.apache.commons.math.linear.Array2DRowRealMatrix",
    "signature": "org.apache.commons.math.linear.Array2DRowRealMatrix.Array2DRowRealMatrix(int,int)",
    "snippet": "    public Array2DRowRealMatrix(final int rowDimension, final int columnDimension)\n        throws IllegalArgumentException {\n        super(rowDimension, columnDimension);\n        data = new double[rowDimension][columnDimension];\n    }",
    "comment": " Create a new RealMatrix with the supplied row and column dimensions.  @param rowDimension  the number of rows in the new matrix @param columnDimension  the number of columns in the new matrix @throws IllegalArgumentException if row or column dimension is not positive ",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 2
  },
  {
    "name": "Array2DRowRealMatrix.addToEntry",
    "class_name": "org.apache.commons.math.linear.Array2DRowRealMatrix",
    "signature": "org.apache.commons.math.linear.Array2DRowRealMatrix.addToEntry(int,int,double)",
    "snippet": "    @Override\n    public void addToEntry(final int row, final int column, final double increment)\n        throws MatrixIndexException {\n        try {\n            data[row][column] += increment;\n        } catch (ArrayIndexOutOfBoundsException e) {\n            throw new MatrixIndexException(\n                      NO_ENTRY_MESSAGE, row, column, getRowDimension(), getColumnDimension());\n        }\n    }",
    "comment": "{@inheritDoc} */",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 2
  },
  {
    "name": "Array2DRowRealMatrix.copyIn",
    "class_name": "org.apache.commons.math.linear.Array2DRowRealMatrix",
    "signature": "org.apache.commons.math.linear.Array2DRowRealMatrix.copyIn(double[][])",
    "snippet": "    private void copyIn(final double[][] in) {\n        setSubMatrix(in, 0, 0);\n    }",
    "comment": " Replaces data with a fresh copy of the input array. <p> Verifies that the input array is rectangular and non-empty.</p>  @param in data to copy in @throws IllegalArgumentException if input array is empty or not rectangular @throws NullPointerException if input array is null ",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 2
  },
  {
    "name": "Array2DRowRealMatrix.copyOut",
    "class_name": "org.apache.commons.math.linear.Array2DRowRealMatrix",
    "signature": "org.apache.commons.math.linear.Array2DRowRealMatrix.copyOut()",
    "snippet": "    private double[][] copyOut() {\n        final int nRows = this.getRowDimension();\n        final double[][] out = new double[nRows][this.getColumnDimension()];\n        // can't copy 2-d array in one shot, otherwise get row references\n        for (int i = 0; i < nRows; i++) {\n            System.arraycopy(data[i], 0, out[i], 0, data[i].length);\n        }\n        return out;\n    }",
    "comment": " Returns a fresh copy of the underlying data array.  @return a copy of the underlying data array. ",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 2
  },
  {
    "name": "Array2DRowRealMatrix.createMatrix",
    "class_name": "org.apache.commons.math.linear.Array2DRowRealMatrix",
    "signature": "org.apache.commons.math.linear.Array2DRowRealMatrix.createMatrix(int,int)",
    "snippet": "    @Override\n    public RealMatrix createMatrix(final int rowDimension, final int columnDimension)\n        throws IllegalArgumentException {\n        return new Array2DRowRealMatrix(rowDimension, columnDimension);\n    }",
    "comment": "{@inheritDoc} */",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 2
  },
  {
    "name": "Array2DRowRealMatrix.getColumnDimension",
    "class_name": "org.apache.commons.math.linear.Array2DRowRealMatrix",
    "signature": "org.apache.commons.math.linear.Array2DRowRealMatrix.getColumnDimension()",
    "snippet": "    @Override\n    public int getColumnDimension() {\n        return ((data == null) || (data[0] == null)) ? 0 : data[0].length;\n    }",
    "comment": "{@inheritDoc} */",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 2
  },
  {
    "name": "Array2DRowRealMatrix.getData",
    "class_name": "org.apache.commons.math.linear.Array2DRowRealMatrix",
    "signature": "org.apache.commons.math.linear.Array2DRowRealMatrix.getData()",
    "snippet": "    @Override\n    public double[][] getData() {\n        return copyOut();\n    }",
    "comment": "{@inheritDoc} */",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 2
  },
  {
    "name": "Array2DRowRealMatrix.getEntry",
    "class_name": "org.apache.commons.math.linear.Array2DRowRealMatrix",
    "signature": "org.apache.commons.math.linear.Array2DRowRealMatrix.getEntry(int,int)",
    "snippet": "    @Override\n    public double getEntry(final int row, final int column)\n        throws MatrixIndexException {\n        try {\n            return data[row][column];\n        } catch (ArrayIndexOutOfBoundsException e) {\n            throw new MatrixIndexException(\n                      NO_ENTRY_MESSAGE, row, column, getRowDimension(), getColumnDimension());\n        }\n    }",
    "comment": "{@inheritDoc} */",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 2
  },
  {
    "name": "Array2DRowRealMatrix.getRowDimension",
    "class_name": "org.apache.commons.math.linear.Array2DRowRealMatrix",
    "signature": "org.apache.commons.math.linear.Array2DRowRealMatrix.getRowDimension()",
    "snippet": "    @Override\n    public int getRowDimension() {\n        return (data == null) ? 0 : data.length;\n    }",
    "comment": "{@inheritDoc} */",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 2
  },
  {
    "name": "Array2DRowRealMatrix.multiply",
    "class_name": "org.apache.commons.math.linear.Array2DRowRealMatrix",
    "signature": "org.apache.commons.math.linear.Array2DRowRealMatrix.multiply(Array2DRowRealMatrix)",
    "snippet": "    public Array2DRowRealMatrix multiply(final Array2DRowRealMatrix m)\n        throws IllegalArgumentException {\n\n        // safety check\n        MatrixUtils.checkMultiplicationCompatible(this, m);\n\n        final int nRows = this.getRowDimension();\n        final int nCols = m.getColumnDimension();\n        final int nSum = this.getColumnDimension();\n        final double[][] outData = new double[nRows][nCols];\n        for (int row = 0; row < nRows; row++) {\n            final double[] dataRow    = data[row];\n            final double[] outDataRow = outData[row];\n            for (int col = 0; col < nCols; col++) {\n                double sum = 0;\n                for (int i = 0; i < nSum; i++) {\n                    sum += dataRow[i] * m.data[i][col];\n                }\n                outDataRow[col] = sum;\n            }\n        }\n\n        return new Array2DRowRealMatrix(outData, false);\n\n    }",
    "comment": " Returns the result of postmultiplying this by <code>m</code>. @param m    matrix to postmultiply by @return     this*m @throws     IllegalArgumentException if columnDimension(this) != rowDimension(m) ",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 2
  },
  {
    "name": "Array2DRowRealMatrix.multiply",
    "class_name": "org.apache.commons.math.linear.Array2DRowRealMatrix",
    "signature": "org.apache.commons.math.linear.Array2DRowRealMatrix.multiply(RealMatrix)",
    "snippet": "    @Override\n    public RealMatrix multiply(final RealMatrix m)\n        throws IllegalArgumentException {\n        try {\n            return multiply((Array2DRowRealMatrix) m);\n        } catch (ClassCastException cce) {\n            return super.multiply(m);\n        }\n    }",
    "comment": "{@inheritDoc} */",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 2
  },
  {
    "name": "Array2DRowRealMatrix.setEntry",
    "class_name": "org.apache.commons.math.linear.Array2DRowRealMatrix",
    "signature": "org.apache.commons.math.linear.Array2DRowRealMatrix.setEntry(int,int,double)",
    "snippet": "    @Override\n    public void setEntry(final int row, final int column, final double value)\n        throws MatrixIndexException {\n        try {\n            data[row][column] = value;\n        } catch (ArrayIndexOutOfBoundsException e) {\n            throw new MatrixIndexException(\n                      NO_ENTRY_MESSAGE, row, column, getRowDimension(), getColumnDimension());\n        }\n    }",
    "comment": "{@inheritDoc} */",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 2
  },
  {
    "name": "Array2DRowRealMatrix.setSubMatrix",
    "class_name": "org.apache.commons.math.linear.Array2DRowRealMatrix",
    "signature": "org.apache.commons.math.linear.Array2DRowRealMatrix.setSubMatrix(double[][],int,int)",
    "snippet": "    @Override\n    public void setSubMatrix(final double[][] subMatrix, final int row, final int column)\n    throws MatrixIndexException {\n        if (data == null) {\n            if (row > 0) {\n                throw MathRuntimeException.createIllegalStateException(\n                      \"first {0} rows are not initialized yet\", row);\n            }\n            if (column > 0) {\n                throw MathRuntimeException.createIllegalStateException(\n                      \"first {0} columns are not initialized yet\", column);\n            }\n            final int nRows = subMatrix.length;\n            if (nRows == 0) {\n                throw MathRuntimeException.createIllegalArgumentException(\n                      AT_LEAST_ONE_ROW_MESSAGE);\n            }\n\n            final int nCols = subMatrix[0].length;\n            if (nCols == 0) {\n                throw MathRuntimeException.createIllegalArgumentException(\n                      AT_LEAST_ONE_COLUMN_MESSAGE);\n            }\n            data = new double[subMatrix.length][nCols];\n            for (int i = 0; i < data.length; ++i) {\n                if (subMatrix[i].length != nCols) {\n                    throw MathRuntimeException.createIllegalArgumentException(\n                          DIFFERENT_ROWS_LENGTHS_MESSAGE, nCols, subMatrix[i].length);\n                }\n                System.arraycopy(subMatrix[i], 0, data[i + row], column, nCols);\n            }\n        } else {\n            super.setSubMatrix(subMatrix, row, column);\n        }\n\n    }",
    "comment": "{@inheritDoc} */",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 2
  },
  {
    "name": "Array2DRowRealMatrix.subtract",
    "class_name": "org.apache.commons.math.linear.Array2DRowRealMatrix",
    "signature": "org.apache.commons.math.linear.Array2DRowRealMatrix.subtract(Array2DRowRealMatrix)",
    "snippet": "    public Array2DRowRealMatrix subtract(final Array2DRowRealMatrix m)\n        throws IllegalArgumentException {\n\n        // safety check\n        MatrixUtils.checkSubtractionCompatible(this, m);\n\n        final int rowCount    = getRowDimension();\n        final int columnCount = getColumnDimension();\n        final double[][] outData = new double[rowCount][columnCount];\n        for (int row = 0; row < rowCount; row++) {\n            final double[] dataRow    = data[row];\n            final double[] mRow       = m.data[row];\n            final double[] outDataRow = outData[row];\n            for (int col = 0; col < columnCount; col++) {\n                outDataRow[col] = dataRow[col] - mRow[col];\n            }\n        }\n\n        return new Array2DRowRealMatrix(outData, false);\n\n    }",
    "comment": " Compute  this minus <code>m</code>.  @param m    matrix to be subtracted @return     this + m @throws  IllegalArgumentException if m is not the same size as this ",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 2
  },
  {
    "name": "Array2DRowRealMatrix.subtract",
    "class_name": "org.apache.commons.math.linear.Array2DRowRealMatrix",
    "signature": "org.apache.commons.math.linear.Array2DRowRealMatrix.subtract(RealMatrix)",
    "snippet": "    @Override\n    public RealMatrix subtract(final RealMatrix m)\n        throws IllegalArgumentException {\n        try {\n            return subtract((Array2DRowRealMatrix) m);\n        } catch (ClassCastException cce) {\n            return super.subtract(m);\n        }\n    }",
    "comment": "{@inheritDoc} */",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 2
  },
  {
    "name": "Array2DRowRealMatrix.walkInColumnOrder",
    "class_name": "org.apache.commons.math.linear.Array2DRowRealMatrix",
    "signature": "org.apache.commons.math.linear.Array2DRowRealMatrix.walkInColumnOrder(RealMatrixPreservingVisitor)",
    "snippet": "    @Override\n    public double walkInColumnOrder(final RealMatrixPreservingVisitor visitor)\n        throws MatrixVisitorException {\n        final int rows    = getRowDimension();\n        final int columns = getColumnDimension();\n        visitor.start(rows, columns, 0, rows - 1, 0, columns - 1);\n        for (int j = 0; j < columns; ++j) {\n            for (int i = 0; i < rows; ++i) {\n                visitor.visit(i, j, data[i][j]);\n            }\n        }\n        return visitor.end();\n    }",
    "comment": "{@inheritDoc} */",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 2
  },
  {
    "name": "Array2DRowRealMatrix.walkInRowOrder",
    "class_name": "org.apache.commons.math.linear.Array2DRowRealMatrix",
    "signature": "org.apache.commons.math.linear.Array2DRowRealMatrix.walkInRowOrder(RealMatrixPreservingVisitor)",
    "snippet": "    @Override\n    public double walkInRowOrder(final RealMatrixPreservingVisitor visitor)\n        throws MatrixVisitorException {\n        final int rows    = getRowDimension();\n        final int columns = getColumnDimension();\n        visitor.start(rows, columns, 0, rows - 1, 0, columns - 1);\n        for (int i = 0; i < rows; ++i) {\n            final double[] rowI = data[i];\n            for (int j = 0; j < columns; ++j) {\n                visitor.visit(i, j, rowI[j]);\n            }\n        }\n        return visitor.end();\n    }",
    "comment": "{@inheritDoc} */",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 2
  },
  {
    "name": "ArrayRealVector.ArrayRealVector",
    "class_name": "org.apache.commons.math.linear.ArrayRealVector",
    "signature": "org.apache.commons.math.linear.ArrayRealVector.ArrayRealVector(double[],boolean)",
    "snippet": "    public ArrayRealVector(double[] d, boolean copyArray)\n        throws NullPointerException, IllegalArgumentException {\n        if (d == null) {\n            throw new NullPointerException();\n        }\n        if (d.length == 0) {\n            throw MathRuntimeException.createIllegalArgumentException(\"vector must have at least one element\");\n        }\n        data = copyArray ? d.clone() :  d;\n    }",
    "comment": " Create a new ArrayRealVector using the input array as the underlying data array. <p>If an array is built specially in order to be embedded in a ArrayRealVector and not used directly, the <code>copyArray</code> may be set to <code>false</code. This will prevent the copying and improve performance as no new array will be built and no data will be copied.</p> @param d data for new vector @param copyArray if true, the input array will be copied, otherwise it will be referenced @throws IllegalArgumentException if <code>d</code> is empty @throws NullPointerException if <code>d</code> is null @see #ArrayRealVector(double[]) ",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 2
  },
  {
    "name": "ArrayRealVector.getDimension",
    "class_name": "org.apache.commons.math.linear.ArrayRealVector",
    "signature": "org.apache.commons.math.linear.ArrayRealVector.getDimension()",
    "snippet": "    public int getDimension() {\n        return data.length;\n    }",
    "comment": "{@inheritDoc} */",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 2
  },
  {
    "name": "ArrayRealVector.getEntry",
    "class_name": "org.apache.commons.math.linear.ArrayRealVector",
    "signature": "org.apache.commons.math.linear.ArrayRealVector.getEntry(int)",
    "snippet": "    public double getEntry(int index) throws MatrixIndexException {\n        return data[index];\n    }",
    "comment": "{@inheritDoc} */",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 2
  },
  {
    "name": "BiDiagonalTransformer.BiDiagonalTransformer",
    "class_name": "org.apache.commons.math.linear.BiDiagonalTransformer",
    "signature": "org.apache.commons.math.linear.BiDiagonalTransformer.BiDiagonalTransformer(RealMatrix)",
    "snippet": "    public BiDiagonalTransformer(RealMatrix matrix) {\n\n        final int m = matrix.getRowDimension();\n        final int n = matrix.getColumnDimension();\n        final int p = Math.min(m, n);\n        householderVectors = matrix.getData();\n        main      = new double[p];\n        secondary = new double[p - 1];\n        cachedU   = null;\n        cachedB   = null;\n        cachedV   = null;\n\n        // transform matrix\n        if (m >= n) {\n            transformToUpperBiDiagonal();\n        } else {\n            transformToLowerBiDiagonal();\n        }\n\n    }",
    "comment": " Build the transformation to bi-diagonal shape of a matrix. @param matrix the matrix to transform. ",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 2
  },
  {
    "name": "BiDiagonalTransformer.getMainDiagonalRef",
    "class_name": "org.apache.commons.math.linear.BiDiagonalTransformer",
    "signature": "org.apache.commons.math.linear.BiDiagonalTransformer.getMainDiagonalRef()",
    "snippet": "    double[] getMainDiagonalRef() {\n        return main;\n    }",
    "comment": " Get the main diagonal elements of the matrix B of the transform. <p>Note that since this class is only intended for internal use, it returns directly a reference to its internal arrays, not a copy.</p> @return the main diagonal elements of the B matrix ",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 2
  },
  {
    "name": "BiDiagonalTransformer.getSecondaryDiagonalRef",
    "class_name": "org.apache.commons.math.linear.BiDiagonalTransformer",
    "signature": "org.apache.commons.math.linear.BiDiagonalTransformer.getSecondaryDiagonalRef()",
    "snippet": "    double[] getSecondaryDiagonalRef() {\n        return secondary;\n    }",
    "comment": " Get the secondary diagonal elements of the matrix B of the transform. <p>Note that since this class is only intended for internal use, it returns directly a reference to its internal arrays, not a copy.</p> @return the secondary diagonal elements of the B matrix ",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 2
  },
  {
    "name": "BiDiagonalTransformer.getU",
    "class_name": "org.apache.commons.math.linear.BiDiagonalTransformer",
    "signature": "org.apache.commons.math.linear.BiDiagonalTransformer.getU()",
    "snippet": "    public RealMatrix getU() {\n\n        if (cachedU == null) {\n\n            final int m = householderVectors.length;\n            final int n = householderVectors[0].length;\n            final int p = main.length;\n            final int diagOffset    = (m >= n) ? 0 : 1;\n            final double[] diagonal = (m >= n) ? main : secondary;\n            cachedU = MatrixUtils.createRealMatrix(m, m);\n\n            // fill up the part of the matrix not affected by Householder transforms\n            for (int k = m - 1; k >= p; --k) {\n                cachedU.setEntry(k, k, 1);\n            }\n\n            // build up first part of the matrix by applying Householder transforms\n            for (int k = p - 1; k >= diagOffset; --k) {\n                final double[] hK = householderVectors[k];\n                cachedU.setEntry(k, k, 1);\n                if (hK[k - diagOffset] != 0.0) {\n                    for (int j = k; j < m; ++j) {\n                        double alpha = 0;\n                        for (int i = k; i < m; ++i) {\n                            alpha -= cachedU.getEntry(i, j) * householderVectors[i][k - diagOffset];\n                        }\n                        alpha /= diagonal[k - diagOffset] * hK[k - diagOffset];\n\n                        for (int i = k; i < m; ++i) {\n                            cachedU.addToEntry(i, j, -alpha * householderVectors[i][k - diagOffset]);\n                        }\n                    }\n                }\n            }\n            if (diagOffset > 0) {\n                cachedU.setEntry(0, 0, 1);\n            }\n\n        }\n\n        // return the cached matrix\n        return cachedU;\n\n    }",
    "comment": " Returns the matrix U of the transform. <p>U is an orthogonal matrix, i.e. its transpose is also its inverse.</p> @return the U matrix ",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 2
  },
  {
    "name": "BiDiagonalTransformer.getV",
    "class_name": "org.apache.commons.math.linear.BiDiagonalTransformer",
    "signature": "org.apache.commons.math.linear.BiDiagonalTransformer.getV()",
    "snippet": "    public RealMatrix getV() {\n\n        if (cachedV == null) {\n\n            final int m = householderVectors.length;\n            final int n = householderVectors[0].length;\n            final int p = main.length;\n            final int diagOffset    = (m >= n) ? 1 : 0;\n            final double[] diagonal = (m >= n) ? secondary : main;\n            cachedV = MatrixUtils.createRealMatrix(n, n);\n\n            // fill up the part of the matrix not affected by Householder transforms\n            for (int k = n - 1; k >= p; --k) {\n                cachedV.setEntry(k, k, 1);\n            }\n\n            // build up first part of the matrix by applying Householder transforms\n            for (int k = p - 1; k >= diagOffset; --k) {\n                final double[] hK = householderVectors[k - diagOffset];\n                cachedV.setEntry(k, k, 1);\n                if (hK[k] != 0.0) {\n                    for (int j = k; j < n; ++j) {\n                        double beta = 0;\n                        for (int i = k; i < n; ++i) {\n                            beta -= cachedV.getEntry(i, j) * hK[i];\n                        }\n                        beta /= diagonal[k - diagOffset] * hK[k];\n\n                        for (int i = k; i < n; ++i) {\n                            cachedV.addToEntry(i, j, -beta * hK[i]);\n                        }\n                    }\n                }\n            }\n            if (diagOffset > 0) {\n                cachedV.setEntry(0, 0, 1);\n            }\n\n        }\n\n        // return the cached matrix\n        return cachedV;\n\n    }",
    "comment": " Returns the matrix V of the transform. <p>V is an orthogonal matrix, i.e. its transpose is also its inverse.</p> @return the V matrix ",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 2
  },
  {
    "name": "BiDiagonalTransformer.transformToUpperBiDiagonal",
    "class_name": "org.apache.commons.math.linear.BiDiagonalTransformer",
    "signature": "org.apache.commons.math.linear.BiDiagonalTransformer.transformToUpperBiDiagonal()",
    "snippet": "    private void transformToUpperBiDiagonal() {\n\n        final int m = householderVectors.length;\n        final int n = householderVectors[0].length;\n        for (int k = 0; k < n; k++) {\n\n            //zero-out a column\n            double xNormSqr = 0;\n            for (int i = k; i < m; ++i) {\n                final double c = householderVectors[i][k];\n                xNormSqr += c * c;\n            }\n            final double[] hK = householderVectors[k];\n            final double a = (hK[k] > 0) ? -Math.sqrt(xNormSqr) : Math.sqrt(xNormSqr);\n            main[k] = a;\n            if (a != 0.0) {\n                hK[k] -= a;\n                for (int j = k + 1; j < n; ++j) {\n                    double alpha = 0;\n                    for (int i = k; i < m; ++i) {\n                        final double[] hI = householderVectors[i];\n                        alpha -= hI[j] * hI[k];\n                    }\n                    alpha /= a * householderVectors[k][k];\n                    for (int i = k; i < m; ++i) {\n                        final double[] hI = householderVectors[i];\n                        hI[j] -= alpha * hI[k];\n                    }\n                }\n            }\n\n            if (k < n - 1) {\n                //zero-out a row\n                xNormSqr = 0;\n                for (int j = k + 1; j < n; ++j) {\n                    final double c = hK[j];\n                    xNormSqr += c * c;\n                }\n                final double b = (hK[k + 1] > 0) ? -Math.sqrt(xNormSqr) : Math.sqrt(xNormSqr);\n                secondary[k] = b;\n                if (b != 0.0) {\n                    hK[k + 1] -= b;\n                    for (int i = k + 1; i < m; ++i) {\n                        final double[] hI = householderVectors[i];\n                        double beta = 0;\n                        for (int j = k + 1; j < n; ++j) {\n                            beta -= hI[j] * hK[j];\n                        }\n                        beta /= b * hK[k + 1];\n                        for (int j = k + 1; j < n; ++j) {\n                            hI[j] -= beta * hK[j];\n                        }\n                    }\n                }\n            }\n\n        }\n    }",
    "comment": " Transform original matrix to upper bi-diagonal form. <p>Transformation is done using alternate Householder transforms on columns and rows.</p> ",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 2
  },
  {
    "name": "DefaultRealMatrixPreservingVisitor.end",
    "class_name": "org.apache.commons.math.linear.DefaultRealMatrixPreservingVisitor",
    "signature": "org.apache.commons.math.linear.DefaultRealMatrixPreservingVisitor.end()",
    "snippet": "    public double end() {\n        return 0;\n    }",
    "comment": "{@inheritDoc} */",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 2
  },
  {
    "name": "DefaultRealMatrixPreservingVisitor.start",
    "class_name": "org.apache.commons.math.linear.DefaultRealMatrixPreservingVisitor",
    "signature": "org.apache.commons.math.linear.DefaultRealMatrixPreservingVisitor.start(int,int,int,int,int,int)",
    "snippet": "    public void start(int rows, int columns,\n                      int startRow, int endRow, int startColumn, int endColumn) {\n    }",
    "comment": "{@inheritDoc} */",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 2
  },
  {
    "name": "EigenDecompositionImpl.EigenDecompositionImpl",
    "class_name": "org.apache.commons.math.linear.EigenDecompositionImpl",
    "signature": "org.apache.commons.math.linear.EigenDecompositionImpl.EigenDecompositionImpl(double[],double[],double)",
    "snippet": "    public EigenDecompositionImpl(final double[] main, double[] secondary,\n            final double splitTolerance)\n        throws InvalidMatrixException {\n\n        this.main      = main.clone();\n        this.secondary = secondary.clone();\n        transformer    = null;\n\n        // pre-compute some elements\n        squaredSecondary = new double[secondary.length];\n        for (int i = 0; i < squaredSecondary.length; ++i) {\n            final double s = secondary[i];\n            squaredSecondary[i] = s * s;\n        }\n\n        this.splitTolerance = splitTolerance;\n        decompose();\n\n    }",
    "comment": " Calculates the eigen decomposition of the given tridiagonal symmetric matrix. @param main the main diagonal of the matrix (will be copied) @param secondary the secondary diagonal of the matrix (will be copied) @param splitTolerance tolerance on the off-diagonal elements relative to the geometric mean to split the tridiagonal matrix (a suggested value is {@link MathUtils#SAFE_MIN}) @exception InvalidMatrixException (wrapping a {@link org.apache.commons.math.ConvergenceException} if algorithm fails to converge ",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 2
  },
  {
    "name": "EigenDecompositionImpl.computeGershgorinCircles",
    "class_name": "org.apache.commons.math.linear.EigenDecompositionImpl",
    "signature": "org.apache.commons.math.linear.EigenDecompositionImpl.computeGershgorinCircles()",
    "snippet": "    private void computeGershgorinCircles() {\n\n        final int m     = main.length;\n        final int lowerStart = 4 * m;\n        final int upperStart = 5 * m;\n        lowerSpectra = Double.POSITIVE_INFINITY;\n        upperSpectra = Double.NEGATIVE_INFINITY;\n        double eMax = 0;\n\n        double eCurrent = 0;\n        for (int i = 0; i < m - 1; ++i) {\n\n            final double dCurrent = main[i];\n            final double ePrevious = eCurrent;\n            eCurrent = Math.abs(secondary[i]);\n            eMax = Math.max(eMax, eCurrent);\n            final double radius = ePrevious + eCurrent;\n\n            final double lower = dCurrent - radius;\n            work[lowerStart + i] = lower;\n            lowerSpectra = Math.min(lowerSpectra, lower);\n\n            final double upper = dCurrent + radius;\n            work[upperStart + i] = upper;\n            upperSpectra = Math.max(upperSpectra, upper);\n\n        }\n\n        final double dCurrent = main[m - 1];\n        final double lower = dCurrent - eCurrent;\n        work[lowerStart + m - 1] = lower;\n        lowerSpectra = Math.min(lowerSpectra, lower);\n        final double upper = dCurrent + eCurrent;\n        work[upperStart + m - 1] = upper;\n        upperSpectra = Math.max(upperSpectra, upper);\n        minPivot = MathUtils.SAFE_MIN * Math.max(1.0, eMax * eMax);\n\n    }",
    "comment": " Compute the Gershgorin circles for all rows. ",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 2
  },
  {
    "name": "EigenDecompositionImpl.computeSplits",
    "class_name": "org.apache.commons.math.linear.EigenDecompositionImpl",
    "signature": "org.apache.commons.math.linear.EigenDecompositionImpl.computeSplits()",
    "snippet": "    private List<Integer> computeSplits() {\n\n        final List<Integer> list = new ArrayList<Integer>();\n\n        // splitting preserving relative accuracy\n        double absDCurrent = Math.abs(main[0]);\n        for (int i = 0; i < secondary.length; ++i) {\n            final double absDPrevious = absDCurrent;\n            absDCurrent = Math.abs(main[i + 1]);\n            final double max = splitTolerance * Math.sqrt(absDPrevious * absDCurrent);\n            if (Math.abs(secondary[i]) <= max) {\n                list.add(i + 1);\n                secondary[i] = 0;\n                squaredSecondary[i] = 0;\n            }\n        }\n\n        list.add(secondary.length + 1);\n        return list;\n\n    }",
    "comment": " Compute splitting points. @return list of indices after matrix can be split ",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 2
  },
  {
    "name": "EigenDecompositionImpl.decompose",
    "class_name": "org.apache.commons.math.linear.EigenDecompositionImpl",
    "signature": "org.apache.commons.math.linear.EigenDecompositionImpl.decompose()",
    "snippet": "    private void decompose() {\n\n        cachedV  = null;\n        cachedD  = null;\n        cachedVt = null;\n        work     = new double[6 * main.length];\n\n        // compute the Gershgorin circles\n        computeGershgorinCircles();\n\n        // find all the realEigenvalues\n        findEigenvalues();\n\n        // we will search for eigenvectors only if required\n        eigenvectors = null;\n\n    }",
    "comment": " Decompose a tridiagonal symmetric matrix. @exception InvalidMatrixException (wrapping a {@link org.apache.commons.math.ConvergenceException} if algorithm fails to converge ",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 2
  },
  {
    "name": "EigenDecompositionImpl.findEigenVectors",
    "class_name": "org.apache.commons.math.linear.EigenDecompositionImpl",
    "signature": "org.apache.commons.math.linear.EigenDecompositionImpl.findEigenVectors()",
    "snippet": "    private void findEigenVectors() {\n\n        final int m = main.length;\n        eigenvectors = new ArrayRealVector[m];\n\n        // perform an initial non-shifted LDLt decomposition\n        final double[] d = new double[m];\n        final double[] l = new double[m - 1];\n        // avoid zero divide on indefinite matrix\n        final double mu = realEigenvalues[m-1] <= 0 && realEigenvalues[0] > 0 ? 0.5-realEigenvalues[m-1] : 0;\n        double di = main[0]+mu;\n        d[0] = di;\n        for (int i = 1; i < m; ++i) {\n            final double eiM1  = secondary[i - 1];\n            final double ratio = eiM1 / di;\n            di       = main[i] - eiM1 * ratio + mu;\n            l[i - 1] = ratio;\n            d[i]     = di;\n        }\n\n        // compute eigenvectors\n        for (int i = 0; i < m; ++i) {\n            eigenvectors[i] = findEigenvector(realEigenvalues[i]+mu, d, l);\n        }\n\n    }",
    "comment": " Find eigenvectors. ",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 2
  },
  {
    "name": "EigenDecompositionImpl.findEigenvalues",
    "class_name": "org.apache.commons.math.linear.EigenDecompositionImpl",
    "signature": "org.apache.commons.math.linear.EigenDecompositionImpl.findEigenvalues()",
    "snippet": "    private void findEigenvalues()\n        throws InvalidMatrixException {\n\n        // compute splitting points\n        List<Integer> splitIndices = computeSplits();\n\n        // find realEigenvalues in each block\n        realEigenvalues = new double[main.length];\n        imagEigenvalues = new double[main.length];\n        int begin = 0;\n        for (final int end : splitIndices) {\n            final int n = end - begin;\n            switch (n) {\n\n            case 1:\n                // apply dedicated method for dimension 1\n                process1RowBlock(begin);\n                break;\n\n            case 2:\n                // apply dedicated method for dimension 2\n                process2RowsBlock(begin);\n                break;\n\n            case 3:\n                // apply dedicated method for dimension 3\n                process3RowsBlock(begin);\n                break;\n\n            default:\n\n                // choose an initial shift for LDL<sup>T</sup> decomposition\n                final double[] range       = eigenvaluesRange(begin, n);\n                final double oneFourth     = 0.25 * (3 * range[0] + range[1]);\n                final int oneFourthCount   = countEigenValues(oneFourth, begin, n);\n                final double threeFourth   = 0.25 * (range[0] + 3 * range[1]);\n                final int threeFourthCount = countEigenValues(threeFourth, begin, n);\n                final boolean chooseLeft   = (oneFourthCount - 1) >= (n - threeFourthCount);\n                final double lambda        = chooseLeft ? range[0] : range[1];\n\n                tau = (range[1] - range[0]) * MathUtils.EPSILON * n + 2 * minPivot;\n\n                // decompose T-&lambda;I as LDL<sup>T</sup>\n                ldlTDecomposition(lambda, begin, n);\n\n                // apply general dqd/dqds method\n                processGeneralBlock(n);\n\n                // extract realEigenvalues\n                if (chooseLeft) {\n                    for (int i = 0; i < n; ++i) {\n                        realEigenvalues[begin + i] = lambda + work[4 * i];\n                    }\n                } else {\n                    for (int i = 0; i < n; ++i) {\n                        realEigenvalues[begin + i] = lambda - work[4 * i];\n                    }\n                }\n\n            }\n            begin = end;\n        }\n\n        // sort the realEigenvalues in decreasing order\n        Arrays.sort(realEigenvalues);\n        int j = realEigenvalues.length - 1;\n        for (int i = 0; i < j; ++i) {\n            final double tmp = realEigenvalues[i];\n            realEigenvalues[i] = realEigenvalues[j];\n            realEigenvalues[j] = tmp;\n            --j;\n        }\n\n    }",
    "comment": " Find the realEigenvalues. @exception InvalidMatrixException if a block cannot be diagonalized ",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 2
  },
  {
    "name": "EigenDecompositionImpl.findEigenvector",
    "class_name": "org.apache.commons.math.linear.EigenDecompositionImpl",
    "signature": "org.apache.commons.math.linear.EigenDecompositionImpl.findEigenvector(double,double[],double[])",
    "snippet": "    private ArrayRealVector findEigenvector(final double eigenvalue,\n                                           final double[] d, final double[] l) {\n\n        // compute the LDLt and UDUt decompositions of the\n        // perfectly shifted tridiagonal matrix\n        final int m = main.length;\n        stationaryQuotientDifferenceWithShift(d, l, eigenvalue);\n        progressiveQuotientDifferenceWithShift(d, l, eigenvalue);\n\n        // select the twist index leading to\n        // the least diagonal element in the twisted factorization\n        int r = m - 1;\n        double minG = Math.abs(work[6 * r] + work[6 * r + 3] + eigenvalue);\n        int sixI = 0;\n        for (int i = 0; i < m - 1; ++i) {\n            final double absG = Math.abs(work[sixI] + d[i] * work[sixI + 9] / work[sixI + 10]);\n            if (absG < minG) {\n                r = i;\n                minG = absG;\n            }\n            sixI += 6;\n        }\n\n        // solve the singular system by ignoring the equation\n        // at twist index and propagating upwards and downwards\n        double[] eigenvector = new double[m];\n        double n2 = 1;\n        eigenvector[r] = 1;\n        double z = 1;\n        for (int i = r - 1; i >= 0; --i) {\n            z *= -work[6 * i + 2];\n            eigenvector[i] = z;\n            n2 += z * z;\n        }\n        z = 1;\n        for (int i = r + 1; i < m; ++i) {\n            z *= -work[6 * i - 1];\n            eigenvector[i] = z;\n            n2 += z * z;\n        }\n\n        // normalize vector\n        final double inv = 1.0 / Math.sqrt(n2);\n        for (int i = 0; i < m; ++i) {\n            eigenvector[i] *= inv;\n        }\n\n        return (transformer == null) ?\n               new ArrayRealVector(eigenvector, false) :\n               new ArrayRealVector(transformer.getQ().operate(eigenvector), false);\n\n    }",
    "comment": " Find an eigenvector corresponding to an eigenvalue, using bidiagonals. <p>This method corresponds to algorithm X from Dhillon's thesis.</p>  @param eigenvalue eigenvalue for which eigenvector is desired @param d diagonal elements of the initial non-shifted D matrix @param l off-diagonal elements of the initial non-shifted L matrix @return an eigenvector ",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 2
  },
  {
    "name": "EigenDecompositionImpl.getRealEigenvalues",
    "class_name": "org.apache.commons.math.linear.EigenDecompositionImpl",
    "signature": "org.apache.commons.math.linear.EigenDecompositionImpl.getRealEigenvalues()",
    "snippet": "    public double[] getRealEigenvalues()\n        throws InvalidMatrixException {\n        return realEigenvalues.clone();\n    }",
    "comment": "{@inheritDoc} */",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 2
  },
  {
    "name": "EigenDecompositionImpl.getV",
    "class_name": "org.apache.commons.math.linear.EigenDecompositionImpl",
    "signature": "org.apache.commons.math.linear.EigenDecompositionImpl.getV()",
    "snippet": "    public RealMatrix getV()\n        throws InvalidMatrixException {\n\n        if (cachedV == null) {\n\n            if (eigenvectors == null) {\n                findEigenVectors();\n            }\n\n            final int m = eigenvectors.length;\n            cachedV = MatrixUtils.createRealMatrix(m, m);\n            for (int k = 0; k < m; ++k) {\n                cachedV.setColumnVector(k, eigenvectors[k]);\n            }\n\n        }\n\n        // return the cached matrix\n        return cachedV;\n\n    }",
    "comment": "{@inheritDoc} */",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 2
  },
  {
    "name": "EigenDecompositionImpl.process2RowsBlock",
    "class_name": "org.apache.commons.math.linear.EigenDecompositionImpl",
    "signature": "org.apache.commons.math.linear.EigenDecompositionImpl.process2RowsBlock(int)",
    "snippet": "    private void process2RowsBlock(final int index)\n        throws InvalidMatrixException {\n\n        // the characteristic polynomial is\n        // X^2 - (q0 + q1) X + q0 q1 - e1^2\n        final double q0   = main[index];\n        final double q1   = main[index + 1];\n        final double e12  = squaredSecondary[index];\n\n        final double s     = q0 + q1;\n        final double p     = q0 * q1 - e12;\n        final double delta = s * s - 4 * p;\n        if (delta < 0) {\n            throw new InvalidMatrixException(\"cannot solve degree {0} equation\", 2);\n        }\n\n        final double largestRoot = 0.5 * (s + Math.sqrt(delta));\n        realEigenvalues[index]     = largestRoot;\n        realEigenvalues[index + 1] = p / largestRoot;\n\n    }",
    "comment": " Find realEigenvalues in a block with 2 rows. <p>In low dimensions, we simply solve the characteristic polynomial.</p> @param index index of the first row of the block @exception InvalidMatrixException if characteristic polynomial cannot be solved ",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 2
  },
  {
    "name": "EigenDecompositionImpl.process3RowsBlock",
    "class_name": "org.apache.commons.math.linear.EigenDecompositionImpl",
    "signature": "org.apache.commons.math.linear.EigenDecompositionImpl.process3RowsBlock(int)",
    "snippet": "    private void process3RowsBlock(final int index)\n        throws InvalidMatrixException {\n\n        // the characteristic polynomial is\n        // X^3 - (q0 + q1 + q2) X^2 + (q0 q1 + q0 q2 + q1 q2 - e1^2 - e2^2) X + q0 e2^2 + q2 e1^2 - q0 q1 q2\n        final double q0       = main[index];\n        final double q1       = main[index + 1];\n        final double q2       = main[index + 2];\n        final double e12      = squaredSecondary[index];\n        final double q1q2Me22 = q1 * q2 - squaredSecondary[index + 1];\n\n        // compute coefficients of the cubic equation as: x^3 + b x^2 + c x + d = 0\n        final double b        = -(q0 + q1 + q2);\n        final double c        = q0 * q1 + q0 * q2 + q1q2Me22 - e12;\n        final double d        = q2 * e12 - q0 * q1q2Me22;\n\n        // solve cubic equation\n        final double b2       = b * b;\n        final double q        = (3 * c - b2) / 9;\n        final double r        = ((9 * c - 2 * b2) * b - 27 * d) / 54;\n        final double delta    = q * q * q + r * r;\n        if (delta >= 0) {\n            // in fact, there are solutions to the equation, but in the context\n            // of symmetric realEigenvalues problem, there should be three distinct\n            // real roots, so we throw an error if this condition is not met\n            throw new InvalidMatrixException(\"cannot solve degree {0} equation\", 3);\n        }\n        final double sqrtMq = Math.sqrt(-q);\n        final double theta  = Math.acos(r / (-q * sqrtMq));\n        final double alpha  = 2 * sqrtMq;\n        final double beta   = b / 3;\n\n        double z0 = alpha * Math.cos(theta / 3) - beta;\n        double z1 = alpha * Math.cos((theta + 2 * Math.PI) / 3) - beta;\n        double z2 = alpha * Math.cos((theta + 4 * Math.PI) / 3) - beta;\n        if (z0 < z1) {\n            final double t = z0;\n            z0 = z1;\n            z1 = t;\n        }\n        if (z1 < z2) {\n            final double t = z1;\n            z1 = z2;\n            z2 = t;\n        }\n        if (z0 < z1) {\n            final double t = z0;\n            z0 = z1;\n            z1 = t;\n        }\n        realEigenvalues[index]     = z0;\n        realEigenvalues[index + 1] = z1;\n        realEigenvalues[index + 2] = z2;\n\n    }",
    "comment": " Find realEigenvalues in a block with 3 rows. <p>In low dimensions, we simply solve the characteristic polynomial.</p> @param index index of the first row of the block @exception InvalidMatrixException if diagonal elements are not positive ",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 2
  },
  {
    "name": "EigenDecompositionImpl.progressiveQuotientDifferenceWithShift",
    "class_name": "org.apache.commons.math.linear.EigenDecompositionImpl",
    "signature": "org.apache.commons.math.linear.EigenDecompositionImpl.progressiveQuotientDifferenceWithShift(double[],double[],double)",
    "snippet": "    private void progressiveQuotientDifferenceWithShift(final double[] d, final double[] l,\n                                                        final double lambda) {\n        final int nM1 = d.length - 1;\n        double pi = d[nM1] - lambda;\n        int sixI = 6 * (nM1 - 1);\n        for (int i = nM1 - 1; i >= 0; --i) {\n            final double di   = d[i];\n            final double li   = l[i];\n            final double diP1 = di * li * li + pi;\n            final double t    = di / diP1;\n            work[sixI +  9]   = pi;\n            work[sixI + 10]   = diP1;\n            work[sixI +  5]   = li * t;\n            pi = pi * t - lambda;\n            sixI -= 6;\n        }\n        if (Double.isNaN(pi)) {\n            // one of the pivot was null, use a slower but safer version of dqds\n            pi = d[nM1] - lambda;\n            sixI = 6 * (nM1 - 1);\n            for (int i = nM1 - 1; i >= 0; --i) {\n                final double di   = d[i];\n                final double li   = l[i];\n                double diP1 = di * li * li + pi;\n                if (Math.abs(diP1) < minPivot) {\n                    diP1 = -minPivot;\n                }\n                final double t    = di / diP1;\n                work[sixI +  9]   = pi;\n                work[sixI + 10]   = diP1;\n                work[sixI +  5]   = li * t;\n                pi = ((t == 0) ? di : pi * t) - lambda;\n                sixI -= 6;\n            }\n        }\n        work[3] = pi;\n        work[4] = pi;\n    }",
    "comment": " Decompose matrix LDL<sup>T</sup> - &lambda; I as U<sub>-</sub>D<sub>-</sub>U<sub>-</sub><sup>T</sup>. <p>This method corresponds to algorithm 4.4.5 (dqds) from Dhillon's thesis.</p> @param d diagonal elements of D @param l off-diagonal elements of L @param lambda shift to apply ",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 2
  },
  {
    "name": "EigenDecompositionImpl.stationaryQuotientDifferenceWithShift",
    "class_name": "org.apache.commons.math.linear.EigenDecompositionImpl",
    "signature": "org.apache.commons.math.linear.EigenDecompositionImpl.stationaryQuotientDifferenceWithShift(double[],double[],double)",
    "snippet": "    private void stationaryQuotientDifferenceWithShift(final double[] d, final double[] l,\n                                                       final double lambda) {\n        final int nM1 = d.length - 1;\n        double si = -lambda;\n        int sixI = 0;\n        for (int i = 0; i < nM1; ++i) {\n            final double di   = d[i];\n            final double li   = l[i];\n            final double ldi  = li * di;\n            final double diP1 = di + si;\n            final double liP1 = ldi / diP1;\n            work[sixI]        = si;\n            work[sixI + 1]    = diP1;\n            work[sixI + 2]    = liP1;\n            si = li * liP1 * si - lambda;\n            sixI += 6;\n        }\n        if (Double.isNaN(si)) {\n            // one of the pivot was null, use a slower but safer version of dstqds\n            si = -lambda;\n            sixI = 0;\n            for (int i = 0; i < nM1; ++i) {\n                final double di   = d[i];\n                final double li   = l[i];\n                final double ldi  = li * di;\n                double diP1 = di + si;\n                if (Math.abs(diP1) < minPivot) {\n                    diP1 = -minPivot;\n                }\n                final double liP1 = ldi / diP1;\n                work[sixI]        = si;\n                work[sixI + 1]    = diP1;\n                work[sixI + 2]    = liP1;\n                si = li * ((liP1 == 0) ? li * di : liP1 * si) - lambda;\n                sixI += 6;\n            }\n        }\n        work[6 * nM1 + 1] = d[nM1] + si;\n        work[6 * nM1]     = si;\n    }",
    "comment": " Decompose matrix LDL<sup>T</sup> - &lambda; I as L<sub>+</sub>D<sub>+</sub>L<sub>+</sub><sup>T</sup>. <p>This method corresponds to algorithm 4.4.3 (dstqds) from Dhillon's thesis.</p> @param d diagonal elements of D, @param l off-diagonal elements of L @param lambda shift to apply ",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 2
  },
  {
    "name": "MatrixUtils.checkColumnIndex",
    "class_name": "org.apache.commons.math.linear.MatrixUtils",
    "signature": "org.apache.commons.math.linear.MatrixUtils.checkColumnIndex(AnyMatrix,int)",
    "snippet": "    public static void checkColumnIndex(final AnyMatrix m, final int column)\n        throws MatrixIndexException {\n        if (column < 0 || column >= m.getColumnDimension()) {\n            throw new MatrixIndexException(\"column index {0} out of allowed range [{1}, {2}]\",\n                                           column, 0, m.getColumnDimension() - 1);\n        }\n    }",
    "comment": " Check if a column index is valid. @param m matrix containing the submatrix @param column column index to check @exception MatrixIndexException if index is not valid ",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 2
  },
  {
    "name": "MatrixUtils.checkMultiplicationCompatible",
    "class_name": "org.apache.commons.math.linear.MatrixUtils",
    "signature": "org.apache.commons.math.linear.MatrixUtils.checkMultiplicationCompatible(AnyMatrix,AnyMatrix)",
    "snippet": "    public static void checkMultiplicationCompatible(final AnyMatrix left, final AnyMatrix right)\n        throws IllegalArgumentException {\n        if (left.getColumnDimension() != right.getRowDimension()) {\n            throw MathRuntimeException.createIllegalArgumentException(\n                    \"{0}x{1} and {2}x{3} matrices are not multiplication compatible\",\n                    left.getRowDimension(), left.getColumnDimension(),\n                    right.getRowDimension(), right.getColumnDimension());\n        }\n    }",
    "comment": " Check if matrices are multiplication compatible @param left left hand side matrix @param right right hand side matrix @exception IllegalArgumentException if matrices are not multiplication compatible ",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 2
  },
  {
    "name": "MatrixUtils.checkRowIndex",
    "class_name": "org.apache.commons.math.linear.MatrixUtils",
    "signature": "org.apache.commons.math.linear.MatrixUtils.checkRowIndex(AnyMatrix,int)",
    "snippet": "    public static void checkRowIndex(final AnyMatrix m, final int row) {\n        if (row < 0 || row >= m.getRowDimension()) {\n            throw new MatrixIndexException(\"row index {0} out of allowed range [{1}, {2}]\",\n                                           row, 0, m.getRowDimension() - 1);\n        }\n    }",
    "comment": " Check if a row index is valid. @param m matrix containing the submatrix @param row row index to check @exception MatrixIndexException if index is not valid ",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 2
  },
  {
    "name": "MatrixUtils.checkSubMatrixIndex",
    "class_name": "org.apache.commons.math.linear.MatrixUtils",
    "signature": "org.apache.commons.math.linear.MatrixUtils.checkSubMatrixIndex(AnyMatrix,int,int,int,int)",
    "snippet": "    public static void checkSubMatrixIndex(final AnyMatrix m,\n                                           final int startRow, final int endRow,\n                                           final int startColumn, final int endColumn) {\n        checkRowIndex(m, startRow);\n        checkRowIndex(m, endRow);\n        if (startRow > endRow) {\n            throw new MatrixIndexException(\"initial row {0} after final row {1}\",\n                                           startRow, endRow);\n        }\n\n        checkColumnIndex(m, startColumn);\n        checkColumnIndex(m, endColumn);\n        if (startColumn > endColumn) {\n            throw new MatrixIndexException(\"initial column {0} after final column {1}\",\n                                           startColumn, endColumn);\n        }\n\n\n    }",
    "comment": " Check if submatrix ranges indices are valid. Rows and columns are indicated counting from 0 to n-1.  @param m matrix containing the submatrix @param startRow Initial row index @param endRow Final row index @param startColumn Initial column index @param endColumn Final column index @exception MatrixIndexException  if the indices are not valid ",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 2
  },
  {
    "name": "MatrixUtils.checkSubtractionCompatible",
    "class_name": "org.apache.commons.math.linear.MatrixUtils",
    "signature": "org.apache.commons.math.linear.MatrixUtils.checkSubtractionCompatible(AnyMatrix,AnyMatrix)",
    "snippet": "    public static void checkSubtractionCompatible(final AnyMatrix left, final AnyMatrix right)\n        throws IllegalArgumentException {\n        if ((left.getRowDimension()    != right.getRowDimension()) ||\n            (left.getColumnDimension() != right.getColumnDimension())) {\n            throw MathRuntimeException.createIllegalArgumentException(\n                    \"{0}x{1} and {2}x{3} matrices are not subtraction compatible\",\n                    left.getRowDimension(), left.getColumnDimension(),\n                    right.getRowDimension(), right.getColumnDimension());\n        }\n    }",
    "comment": " Check if matrices are subtraction compatible @param left left hand side matrix @param right right hand side matrix @exception IllegalArgumentException if matrices are not subtraction compatible ",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 2
  },
  {
    "name": "MatrixUtils.createRealDiagonalMatrix",
    "class_name": "org.apache.commons.math.linear.MatrixUtils",
    "signature": "org.apache.commons.math.linear.MatrixUtils.createRealDiagonalMatrix(double[])",
    "snippet": "    public static RealMatrix createRealDiagonalMatrix(final double[] diagonal) {\n        final RealMatrix m = createRealMatrix(diagonal.length, diagonal.length);\n        for (int i = 0; i < diagonal.length; ++i) {\n            m.setEntry(i, i, diagonal[i]);\n        }\n        return m;\n    }",
    "comment": " Returns a diagonal matrix with specified elements.  @param diagonal diagonal elements of the matrix (the array elements will be copied) @return diagonal matrix @since 2.0 ",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 2
  },
  {
    "name": "MatrixUtils.createRealMatrix",
    "class_name": "org.apache.commons.math.linear.MatrixUtils",
    "signature": "org.apache.commons.math.linear.MatrixUtils.createRealMatrix(double[][])",
    "snippet": "    public static RealMatrix createRealMatrix(double[][] data) {\n        return (data.length * data[0].length <= 4096) ?\n                new Array2DRowRealMatrix(data) : new BlockRealMatrix(data);\n    }",
    "comment": " Returns a {@link RealMatrix} whose entries are the the values in the the input array. <p>The type of matrix returned depends on the dimension. Below 2<sup>12</sup> elements (i.e. 4096 elements or 64&times;64 for a square matrix) which can be stored in a 32kB array, a {@link Array2DRowRealMatrix} instance is built. Above this threshold a {@link BlockRealMatrix} instance is built.</p> <p>The input array is copied, not referenced.</p>  @param data input array @return  RealMatrix containing the values of the array @throws IllegalArgumentException if <code>data</code> is not rectangular (not all rows have the same length) or empty @throws NullPointerException if either <code>data</code> or <code>data[0]</code> is null @see #createRealMatrix(int, int) ",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 2
  },
  {
    "name": "MatrixUtils.createRealMatrix",
    "class_name": "org.apache.commons.math.linear.MatrixUtils",
    "signature": "org.apache.commons.math.linear.MatrixUtils.createRealMatrix(int,int)",
    "snippet": "    public static RealMatrix createRealMatrix(final int rows, final int columns) {\n        return (rows * columns <= 4096) ?\n                new Array2DRowRealMatrix(rows, columns) : new BlockRealMatrix(rows, columns);\n    }",
    "comment": " Returns a {@link RealMatrix} with specified dimensions. <p>The type of matrix returned depends on the dimension. Below 2<sup>12</sup> elements (i.e. 4096 elements or 64&times;64 for a square matrix) which can be stored in a 32kB array, a {@link Array2DRowRealMatrix} instance is built. Above this threshold a {@link BlockRealMatrix} instance is built.</p> <p>The matrix elements are all set to 0.0.</p> @param rows number of rows of the matrix @param columns number of columns of the matrix @return  RealMatrix with specified dimensions @see #createRealMatrix(double[][]) ",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 2
  },
  {
    "name": "RealVectorFormat.RealVectorFormat",
    "class_name": "org.apache.commons.math.linear.RealVectorFormat",
    "signature": "org.apache.commons.math.linear.RealVectorFormat.RealVectorFormat(NumberFormat)",
    "snippet": "    public RealVectorFormat(final NumberFormat format) {\n        this(DEFAULT_PREFIX, DEFAULT_SUFFIX, DEFAULT_SEPARATOR, format);\n    }",
    "comment": " Create an instance with a custom number format for components. @param format the custom format for components. ",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 2
  },
  {
    "name": "RealVectorFormat.RealVectorFormat",
    "class_name": "org.apache.commons.math.linear.RealVectorFormat",
    "signature": "org.apache.commons.math.linear.RealVectorFormat.RealVectorFormat(String,String,String,NumberFormat)",
    "snippet": "    public RealVectorFormat(final String prefix, final String suffix,\n                            final String separator, final NumberFormat format) {\n        this.prefix      = prefix;\n        this.suffix      = suffix;\n        this.separator   = separator;\n        trimmedPrefix    = prefix.trim();\n        trimmedSuffix    = suffix.trim();\n        trimmedSeparator = separator.trim();\n        this.format      = format;\n    }",
    "comment": " Create an instance with custom prefix, suffix, separator and format for components. @param prefix prefix to use instead of the default \"{\" @param suffix suffix to use instead of the default \"}\" @param separator separator to use instead of the default \"; \" @param format the custom format for components. ",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 2
  },
  {
    "name": "RealVectorFormat.getInstance",
    "class_name": "org.apache.commons.math.linear.RealVectorFormat",
    "signature": "org.apache.commons.math.linear.RealVectorFormat.getInstance()",
    "snippet": "    public static RealVectorFormat getInstance() {\n        return getInstance(Locale.getDefault());\n    }",
    "comment": " Returns the default real vector format for the current locale. @return the default real vector format. ",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 2
  },
  {
    "name": "RealVectorFormat.getInstance",
    "class_name": "org.apache.commons.math.linear.RealVectorFormat",
    "signature": "org.apache.commons.math.linear.RealVectorFormat.getInstance(Locale)",
    "snippet": "    public static RealVectorFormat getInstance(final Locale locale) {\n        return new RealVectorFormat(getDefaultNumberFormat(locale));\n    }",
    "comment": " Returns the default real vector format for the given locale. @param locale the specific locale used by the format. @return the real vector format specific to the given locale. ",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 2
  },
  {
    "name": "SingularValueDecompositionImpl.SingularValueDecompositionImpl",
    "class_name": "org.apache.commons.math.linear.SingularValueDecompositionImpl",
    "signature": "org.apache.commons.math.linear.SingularValueDecompositionImpl.SingularValueDecompositionImpl(RealMatrix)",
    "snippet": "    public SingularValueDecompositionImpl(final RealMatrix matrix)\n        throws InvalidMatrixException {\n        this(matrix, Math.min(matrix.getRowDimension(), matrix.getColumnDimension()));\n    }",
    "comment": " Calculates the compact Singular Value Decomposition of the given matrix. @param matrix The matrix to decompose. @exception InvalidMatrixException (wrapping a {@link org.apache.commons.math.ConvergenceException} if algorithm fails to converge ",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 2
  },
  {
    "name": "SingularValueDecompositionImpl.SingularValueDecompositionImpl",
    "class_name": "org.apache.commons.math.linear.SingularValueDecompositionImpl",
    "signature": "org.apache.commons.math.linear.SingularValueDecompositionImpl.SingularValueDecompositionImpl(RealMatrix,int)",
    "snippet": "    public SingularValueDecompositionImpl(final RealMatrix matrix, final int max)\n        throws InvalidMatrixException {\n\n        m = matrix.getRowDimension();\n        n = matrix.getColumnDimension();\n\n        cachedU  = null;\n        cachedS  = null;\n        cachedV  = null;\n        cachedVt = null;\n\n        // transform the matrix to bidiagonal\n        transformer         = new BiDiagonalTransformer(matrix);\n        mainBidiagonal      = transformer.getMainDiagonalRef();\n        secondaryBidiagonal = transformer.getSecondaryDiagonalRef();\n\n        // compute Bt.B (if upper diagonal) or B.Bt (if lower diagonal)\n        mainTridiagonal      = new double[mainBidiagonal.length];\n        secondaryTridiagonal = new double[mainBidiagonal.length - 1];\n        double a = mainBidiagonal[0];\n        mainTridiagonal[0] = a * a;\n        for (int i = 1; i < mainBidiagonal.length; ++i) {\n            final double b  = secondaryBidiagonal[i - 1];\n            secondaryTridiagonal[i - 1] = a * b;\n            a = mainBidiagonal[i];\n            mainTridiagonal[i] = a * a + b * b;\n        }\n\n        // compute singular values\n        eigenDecomposition =\n            new EigenDecompositionImpl(mainTridiagonal, secondaryTridiagonal,\n                                       MathUtils.SAFE_MIN);\n        final double[] eigenValues = eigenDecomposition.getRealEigenvalues();\n        int p = Math.min(max, eigenValues.length);\n        while ((p > 0) && (eigenValues[p - 1] <= 0)) {\n            --p;\n        }\n        singularValues = new double[p];\n        for (int i = 0; i < p; ++i) {\n            singularValues[i] = Math.sqrt(eigenValues[i]);\n        }\n\n    }",
    "comment": " Calculates the Singular Value Decomposition of the given matrix. @param matrix The matrix to decompose. @param max maximal number of singular values to compute @exception InvalidMatrixException (wrapping a {@link org.apache.commons.math.ConvergenceException} if algorithm fails to converge ",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 2
  },
  {
    "name": "SingularValueDecompositionImpl.getS",
    "class_name": "org.apache.commons.math.linear.SingularValueDecompositionImpl",
    "signature": "org.apache.commons.math.linear.SingularValueDecompositionImpl.getS()",
    "snippet": "    public RealMatrix getS()\n        throws InvalidMatrixException {\n\n        if (cachedS == null) {\n\n            // cache the matrix for subsequent calls\n            cachedS = MatrixUtils.createRealDiagonalMatrix(singularValues);\n\n        }\n        return cachedS;\n    }",
    "comment": "{@inheritDoc} */",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 2
  },
  {
    "name": "SingularValueDecompositionImpl.getSingularValues",
    "class_name": "org.apache.commons.math.linear.SingularValueDecompositionImpl",
    "signature": "org.apache.commons.math.linear.SingularValueDecompositionImpl.getSingularValues()",
    "snippet": "    public double[] getSingularValues()\n        throws InvalidMatrixException {\n        return singularValues.clone();\n    }",
    "comment": "{@inheritDoc} */",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 2
  },
  {
    "name": "SingularValueDecompositionImpl.getU",
    "class_name": "org.apache.commons.math.linear.SingularValueDecompositionImpl",
    "signature": "org.apache.commons.math.linear.SingularValueDecompositionImpl.getU()",
    "snippet": "    public RealMatrix getU()\n        throws InvalidMatrixException {\n\n        if (cachedU == null) {\n\n            final int p = singularValues.length;\n            if (m >= n) {\n                // the tridiagonal matrix is Bt.B, where B is upper bidiagonal\n                final RealMatrix e =\n                    eigenDecomposition.getV().getSubMatrix(0, p - 1, 0, p - 1);\n                final double[][] eData = e.getData();\n                final double[][] wData = new double[m][p];\n                double[] ei1 = eData[0];\n                for (int i = 0; i < p - 1; ++i) {\n                    // compute W = B.E.S^(-1) where E is the eigenvectors matrix\n                    final double mi = mainBidiagonal[i];\n                    final double[] ei0 = ei1;\n                    final double[] wi  = wData[i];\n                        ei1 = eData[i + 1];\n                        final double si = secondaryBidiagonal[i];\n                        for (int j = 0; j < p; ++j) {\n                            wi[j] = (mi * ei0[j] + si * ei1[j]) / singularValues[j];\n                        }\n                }\n                        for (int j = 0; j < p; ++j) {\n                            wData[p - 1][j] = ei1[j] * mainBidiagonal[p - 1] / singularValues[j];\n                        }\n\n                for (int i = p; i < m; ++i) {\n                    wData[i] = new double[p];\n                }\n                cachedU =\n                    transformer.getU().multiply(MatrixUtils.createRealMatrix(wData));\n            } else {\n                // the tridiagonal matrix is B.Bt, where B is lower bidiagonal\n                final RealMatrix e =\n                    eigenDecomposition.getV().getSubMatrix(0, m - 1, 0, p - 1);\n                cachedU = transformer.getU().multiply(e);\n            }\n\n        }\n\n        // return the cached matrix\n        return cachedU;\n\n    }",
    "comment": "{@inheritDoc} */",
    "is_bug": true,
    "failing_test_cases": 2,
    "buggy_methods": 2
  },
  {
    "name": "SingularValueDecompositionImpl.getV",
    "class_name": "org.apache.commons.math.linear.SingularValueDecompositionImpl",
    "signature": "org.apache.commons.math.linear.SingularValueDecompositionImpl.getV()",
    "snippet": "    public RealMatrix getV()\n        throws InvalidMatrixException {\n\n        if (cachedV == null) {\n\n            final int p = singularValues.length;\n            if (m >= n) {\n                // the tridiagonal matrix is Bt.B, where B is upper bidiagonal\n                final RealMatrix e =\n                    eigenDecomposition.getV().getSubMatrix(0, n - 1, 0, p - 1);\n                cachedV = transformer.getV().multiply(e);\n            } else {\n                // the tridiagonal matrix is B.Bt, where B is lower bidiagonal\n                // compute W = Bt.E.S^(-1) where E is the eigenvectors matrix\n                final RealMatrix e =\n                    eigenDecomposition.getV().getSubMatrix(0, p - 1, 0, p - 1);\n                final double[][] eData = e.getData();\n                final double[][] wData = new double[n][p];\n                double[] ei1 = eData[0];\n                for (int i = 0; i < p - 1; ++i) {\n                    final double mi = mainBidiagonal[i];\n                    final double[] ei0 = ei1;\n                    final double[] wi  = wData[i];\n                        ei1 = eData[i + 1];\n                        final double si = secondaryBidiagonal[i];\n                        for (int j = 0; j < p; ++j) {\n                            wi[j] = (mi * ei0[j] + si * ei1[j]) / singularValues[j];\n                        }\n                }\n                        for (int j = 0; j < p; ++j) {\n                            wData[p - 1][j] = ei1[j] * mainBidiagonal[p - 1] / singularValues[j];\n                        }\n                for (int i = p; i < n; ++i) {\n                    wData[i] = new double[p];\n                }\n                cachedV =\n                    transformer.getV().multiply(MatrixUtils.createRealMatrix(wData));\n            }\n\n        }\n\n        // return the cached matrix\n        return cachedV;\n\n    }",
    "comment": "{@inheritDoc} */",
    "is_bug": true,
    "failing_test_cases": 2,
    "buggy_methods": 2
  },
  {
    "name": "SingularValueDecompositionImpl.getVT",
    "class_name": "org.apache.commons.math.linear.SingularValueDecompositionImpl",
    "signature": "org.apache.commons.math.linear.SingularValueDecompositionImpl.getVT()",
    "snippet": "    public RealMatrix getVT()\n        throws InvalidMatrixException {\n\n        if (cachedVt == null) {\n            cachedVt = getV().transpose();\n        }\n\n        // return the cached matrix\n        return cachedVt;\n\n    }",
    "comment": "{@inheritDoc} */",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 2
  },
  {
    "name": "CompositeFormat.getDefaultNumberFormat",
    "class_name": "org.apache.commons.math.util.CompositeFormat",
    "signature": "org.apache.commons.math.util.CompositeFormat.getDefaultNumberFormat(Locale)",
    "snippet": "    protected static NumberFormat getDefaultNumberFormat(final Locale locale) {\n        final NumberFormat nf = NumberFormat.getInstance(locale);\n        nf.setMaximumFractionDigits(2);\n        return nf;\n    }",
    "comment": " Create a default number format.  The default number format is based on {@link NumberFormat#getInstance(java.util.Locale)} with the only customizing that the maximum number of fraction digits is set to 2. @param locale the specific locale used by the format. @return the default number format specific to the given locale. ",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 2
  }
]