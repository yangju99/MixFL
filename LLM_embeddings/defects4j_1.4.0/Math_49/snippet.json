[
  {
    "name": "MathRuntimeException.buildMessage",
    "class_name": "org.apache.commons.math.MathRuntimeException",
    "signature": "org.apache.commons.math.MathRuntimeException.buildMessage(Locale,Localizable,Object[])",
    "snippet": "    private static String buildMessage(final Locale locale, final Localizable pattern,\n                                       final Object ... arguments) {\n        return new MessageFormat(pattern.getLocalizedString(locale), locale).format(arguments);\n    }",
    "comment": " Builds a message string by from a pattern and its arguments. @param locale Locale in which the message should be translated @param pattern format specifier @param arguments format arguments @return a message string @since 2.2 ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 4
  },
  {
    "name": "MathRuntimeException.createConcurrentModificationException",
    "class_name": "org.apache.commons.math.MathRuntimeException",
    "signature": "org.apache.commons.math.MathRuntimeException.createConcurrentModificationException(Localizable,Object[])",
    "snippet": "    public static ConcurrentModificationException createConcurrentModificationException(final Localizable pattern,\n                                                                                        final Object ... arguments) {\n        return new ConcurrentModificationException() {\n\n            /** Serializable version identifier. */\n            private static final long serialVersionUID = -1878427236170442052L;\n\n            /** {@inheritDoc} */\n            @Override\n            public String getMessage() {\n                return buildMessage(Locale.US, pattern, arguments);\n            }\n\n            /** {@inheritDoc} */\n            @Override\n            public String getLocalizedMessage() {\n                return buildMessage(Locale.getDefault(), pattern, arguments);\n            }\n\n        };\n    }",
    "comment": " Constructs a new <code>ConcurrentModificationException</code> with specified formatted detail message. Message formatting is delegated to {@link java.text.MessageFormat}. @param pattern format specifier @param arguments format arguments @return built exception @since 2.2 ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 4
  },
  {
    "name": "LocalizedFormats.getLocalizedString",
    "class_name": "org.apache.commons.math.exception.util.LocalizedFormats",
    "signature": "org.apache.commons.math.exception.util.LocalizedFormats.getLocalizedString(Locale)",
    "snippet": "    public String getLocalizedString(final Locale locale) {\n        try {\n            ResourceBundle bundle =\n                    ResourceBundle.getBundle(\"META-INF/localization/LocalizedFormats\", locale);\n            if (bundle.getLocale().getLanguage().equals(locale.getLanguage())) {\n                // the value of the resource is the translated format\n                return bundle.getString(toString());\n            }\n\n        } catch (MissingResourceException mre) {\n            // do nothing here\n        }\n\n        // either the locale is not supported or the resource is unknown\n        // don't translate and fall back to using the source format\n        return sourceFormat;\n\n    }",
    "comment": "{@inheritDoc} */",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 4
  },
  {
    "name": "AbstractRealVector.checkIndex",
    "class_name": "org.apache.commons.math.linear.AbstractRealVector",
    "signature": "org.apache.commons.math.linear.AbstractRealVector.checkIndex(int)",
    "snippet": "    protected void checkIndex(final int index) {\n        if (index < 0 ||\n            index >= getDimension()) {\n            throw new OutOfRangeException(LocalizedFormats.INDEX,\n                                          index, 0, getDimension() - 1);\n        }\n    }",
    "comment": " Check if an index is valid.  @param index Index to check. @exception OutOfRangeException if {@code index} is not valid. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 4
  },
  {
    "name": "AbstractRealVector.checkVectorDimensions",
    "class_name": "org.apache.commons.math.linear.AbstractRealVector",
    "signature": "org.apache.commons.math.linear.AbstractRealVector.checkVectorDimensions(int)",
    "snippet": "    protected void checkVectorDimensions(int n) {\n        int d = getDimension();\n        if (d != n) {\n            throw new DimensionMismatchException(d, n);\n        }\n    }",
    "comment": " Check if instance dimension is equal to some expected value.  @param n Expected dimension. @throws DimensionMismatchException if the dimension is inconsistent with the vector size. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 4
  },
  {
    "name": "OpenMapRealVector.OpenMapRealVector",
    "class_name": "org.apache.commons.math.linear.OpenMapRealVector",
    "signature": "org.apache.commons.math.linear.OpenMapRealVector.OpenMapRealVector(OpenMapRealVector)",
    "snippet": "    public OpenMapRealVector(OpenMapRealVector v) {\n        virtualSize = v.getDimension();\n        entries = new OpenIntToDoubleHashMap(v.getEntries());\n        epsilon = v.epsilon;\n    }",
    "comment": " Copy constructor.  @param v Instance to copy from. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 4
  },
  {
    "name": "OpenMapRealVector.OpenMapRealVector",
    "class_name": "org.apache.commons.math.linear.OpenMapRealVector",
    "signature": "org.apache.commons.math.linear.OpenMapRealVector.OpenMapRealVector(int,double)",
    "snippet": "    public OpenMapRealVector(int dimension, double epsilon) {\n        virtualSize = dimension;\n        entries = new OpenIntToDoubleHashMap(0.0);\n        this.epsilon = epsilon;\n    }",
    "comment": " Construct a vector of zeroes, specifying zero tolerance.  @param dimension Size of the vector. @param epsilon Tolerance below which a value considered zero. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 4
  },
  {
    "name": "OpenMapRealVector.ebeMultiply",
    "class_name": "org.apache.commons.math.linear.OpenMapRealVector",
    "signature": "org.apache.commons.math.linear.OpenMapRealVector.ebeMultiply(RealVector)",
    "snippet": "    public OpenMapRealVector ebeMultiply(RealVector v) {\n        checkVectorDimensions(v.getDimension());\n        OpenMapRealVector res = new OpenMapRealVector(this);\n        Iterator iter = res.entries.iterator();\n        while (iter.hasNext()) {\n            iter.advance();\n            res.setEntry(iter.key(), iter.value() * v.getEntry(iter.key()));\n        }\n        return res;\n    }",
    "comment": "{@inheritDoc} */",
    "is_bug": true,
    "failing_test_cases": 1,
    "buggy_methods": 4
  },
  {
    "name": "OpenMapRealVector.getDimension",
    "class_name": "org.apache.commons.math.linear.OpenMapRealVector",
    "signature": "org.apache.commons.math.linear.OpenMapRealVector.getDimension()",
    "snippet": "    public int getDimension() {\n        return virtualSize;\n    }",
    "comment": "{@inheritDoc} */",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 4
  },
  {
    "name": "OpenMapRealVector.getEntries",
    "class_name": "org.apache.commons.math.linear.OpenMapRealVector",
    "signature": "org.apache.commons.math.linear.OpenMapRealVector.getEntries()",
    "snippet": "    private OpenIntToDoubleHashMap getEntries() {\n        return entries;\n    }",
    "comment": " Get the entries of this instance.  @return the entries of this instance. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 4
  },
  {
    "name": "OpenMapRealVector.getEntry",
    "class_name": "org.apache.commons.math.linear.OpenMapRealVector",
    "signature": "org.apache.commons.math.linear.OpenMapRealVector.getEntry(int)",
    "snippet": "    public double getEntry(int index) {\n        checkIndex(index);\n        return entries.get(index);\n    }",
    "comment": "{@inheritDoc} */",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 4
  },
  {
    "name": "OpenMapRealVector.isDefaultValue",
    "class_name": "org.apache.commons.math.linear.OpenMapRealVector",
    "signature": "org.apache.commons.math.linear.OpenMapRealVector.isDefaultValue(double)",
    "snippet": "    protected boolean isDefaultValue(double value) {\n        return FastMath.abs(value) < epsilon;\n    }",
    "comment": " Determine if this value is within epsilon of zero.  @param value Value to test @return {@code true} if this value is within epsilon to zero, {@code false} otherwise. @since 2.1 ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 4
  },
  {
    "name": "OpenMapRealVector.setEntry",
    "class_name": "org.apache.commons.math.linear.OpenMapRealVector",
    "signature": "org.apache.commons.math.linear.OpenMapRealVector.setEntry(int,double)",
    "snippet": "    public void setEntry(int index, double value) {\n        checkIndex(index);\n        if (!isDefaultValue(value)) {\n            entries.put(index, value);\n        } else if (entries.containsKey(index)) {\n            entries.remove(index);\n        }\n    }",
    "comment": "{@inheritDoc} */",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 4
  },
  {
    "name": "FastMath.abs",
    "class_name": "org.apache.commons.math.util.FastMath",
    "signature": "org.apache.commons.math.util.FastMath.abs(double)",
    "snippet": "    public static double abs(double x) {\n        return (x < 0.0) ? -x : (x == 0.0) ? 0.0 : x; // -0.0 => +0.0\n    }",
    "comment": " Absolute value. @param x number from which absolute value is requested @return abs(x) ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 4
  },
  {
    "name": "FastMath.buildSinCosTables",
    "class_name": "org.apache.commons.math.util.FastMath",
    "signature": "org.apache.commons.math.util.FastMath.buildSinCosTables()",
    "snippet": "    private static void buildSinCosTables() {\n        final double result[] = new double[2];\n\n        /* Use taylor series for 0 <= x <= 6/8 */\n        for (int i = 0; i < 7; i++) {\n            double x = i / 8.0;\n\n            slowSin(x, result);\n            SINE_TABLE_A[i] = result[0];\n            SINE_TABLE_B[i] = result[1];\n\n            slowCos(x, result);\n            COSINE_TABLE_A[i] = result[0];\n            COSINE_TABLE_B[i] = result[1];\n        }\n\n        /* Use angle addition formula to complete table to 13/8, just beyond pi/2 */\n        for (int i = 7; i < 14; i++) {\n            double xs[] = new double[2];\n            double ys[] = new double[2];\n            double as[] = new double[2];\n            double bs[] = new double[2];\n            double temps[] = new double[2];\n\n            if ( (i & 1) == 0) {\n                // Even, use double angle\n                xs[0] = SINE_TABLE_A[i/2];\n                xs[1] = SINE_TABLE_B[i/2];\n                ys[0] = COSINE_TABLE_A[i/2];\n                ys[1] = COSINE_TABLE_B[i/2];\n\n                /* compute sine */\n                splitMult(xs, ys, result);\n                SINE_TABLE_A[i] = result[0] * 2.0;\n                SINE_TABLE_B[i] = result[1] * 2.0;\n\n                /* Compute cosine */\n                splitMult(ys, ys, as);\n                splitMult(xs, xs, temps);\n                temps[0] = -temps[0];\n                temps[1] = -temps[1];\n                splitAdd(as, temps, result);\n                COSINE_TABLE_A[i] = result[0];\n                COSINE_TABLE_B[i] = result[1];\n            } else {\n                xs[0] = SINE_TABLE_A[i/2];\n                xs[1] = SINE_TABLE_B[i/2];\n                ys[0] = COSINE_TABLE_A[i/2];\n                ys[1] = COSINE_TABLE_B[i/2];\n                as[0] = SINE_TABLE_A[i/2+1];\n                as[1] = SINE_TABLE_B[i/2+1];\n                bs[0] = COSINE_TABLE_A[i/2+1];\n                bs[1] = COSINE_TABLE_B[i/2+1];\n\n                /* compute sine */\n                splitMult(xs, bs, temps);\n                splitMult(ys, as, result);\n                splitAdd(result, temps, result);\n                SINE_TABLE_A[i] = result[0];\n                SINE_TABLE_B[i] = result[1];\n\n                /* Compute cosine */\n                splitMult(ys, bs, result);\n                splitMult(xs, as, temps);\n                temps[0] = -temps[0];\n                temps[1] = -temps[1];\n                splitAdd(result, temps, result);\n                COSINE_TABLE_A[i] = result[0];\n                COSINE_TABLE_B[i] = result[1];\n            }\n        }\n\n        /* Compute tangent = sine/cosine */\n        for (int i = 0; i < 14; i++) {\n            double xs[] = new double[2];\n            double ys[] = new double[2];\n            double as[] = new double[2];\n\n            as[0] = COSINE_TABLE_A[i];\n            as[1] = COSINE_TABLE_B[i];\n\n            splitReciprocal(as, ys);\n\n            xs[0] = SINE_TABLE_A[i];\n            xs[1] = SINE_TABLE_B[i];\n\n            splitMult(xs, ys, as);\n\n            TANGENT_TABLE_A[i] = as[0];\n            TANGENT_TABLE_B[i] = as[1];\n        }\n\n    }",
    "comment": "Build the sine and cosine tables. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 4
  },
  {
    "name": "FastMath.ceil",
    "class_name": "org.apache.commons.math.util.FastMath",
    "signature": "org.apache.commons.math.util.FastMath.ceil(double)",
    "snippet": "    public static double ceil(double x) {\n        double y;\n\n        if (x != x) { // NaN\n            return x;\n        }\n\n        y = floor(x);\n        if (y == x) {\n            return y;\n        }\n\n        y += 1.0;\n\n        if (y == 0) {\n            return x*y;\n        }\n\n        return y;\n    }",
    "comment": "Get the smallest whole number larger than x. @param x number from which ceil is requested @return a double number c such that c is an integer c - 1.0 < x <= c ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 4
  },
  {
    "name": "FastMath.expint",
    "class_name": "org.apache.commons.math.util.FastMath",
    "signature": "org.apache.commons.math.util.FastMath.expint(int,double[])",
    "snippet": "    private static double expint(int p, final double result[]) {\n        //double x = M_E;\n        final double xs[] = new double[2];\n        final double as[] = new double[2];\n        final double ys[] = new double[2];\n        //split(x, xs);\n        //xs[1] = (double)(2.7182818284590452353602874713526625L - xs[0]);\n        //xs[0] = 2.71827697753906250000;\n        //xs[1] = 4.85091998273542816811e-06;\n        //xs[0] = Double.longBitsToDouble(0x4005bf0800000000L);\n        //xs[1] = Double.longBitsToDouble(0x3ed458a2bb4a9b00L);\n\n        /* E */\n        xs[0] = 2.718281828459045;\n        xs[1] = 1.4456468917292502E-16;\n\n        split(1.0, ys);\n\n        while (p > 0) {\n            if ((p & 1) != 0) {\n                quadMult(ys, xs, as);\n                ys[0] = as[0]; ys[1] = as[1];\n            }\n\n            quadMult(xs, xs, as);\n            xs[0] = as[0]; xs[1] = as[1];\n\n            p >>= 1;\n        }\n\n        if (result != null) {\n            result[0] = ys[0];\n            result[1] = ys[1];\n\n            resplit(result);\n        }\n\n        return ys[0] + ys[1];\n    }",
    "comment": "Compute exp(p) for a integer p in extended precision. @param p integer whose exponential is requested @param result placeholder where to put the result in extended precision @return exp(p) in standard precision (equal to result[0] + result[1]) ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 4
  },
  {
    "name": "FastMath.floor",
    "class_name": "org.apache.commons.math.util.FastMath",
    "signature": "org.apache.commons.math.util.FastMath.floor(double)",
    "snippet": "    public static double floor(double x) {\n        long y;\n\n        if (x != x) { // NaN\n            return x;\n        }\n\n        if (x >= TWO_POWER_52 || x <= -TWO_POWER_52) {\n            return x;\n        }\n\n        y = (long) x;\n        if (x < 0 && y != x) {\n            y--;\n        }\n\n        if (y == 0) {\n            return x*y;\n        }\n\n        return y;\n    }",
    "comment": "Get the largest whole number smaller than x. @param x number from which floor is requested @return a double number f such that f is an integer f <= x < f + 1.0 ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 4
  },
  {
    "name": "FastMath.quadMult",
    "class_name": "org.apache.commons.math.util.FastMath",
    "signature": "org.apache.commons.math.util.FastMath.quadMult(double[],double[],double[])",
    "snippet": "    private static void quadMult(final double a[], final double b[], final double result[]) {\n        final double xs[] = new double[2];\n        final double ys[] = new double[2];\n        final double zs[] = new double[2];\n\n        /* a[0] * b[0] */\n        split(a[0], xs);\n        split(b[0], ys);\n        splitMult(xs, ys, zs);\n\n        result[0] = zs[0];\n        result[1] = zs[1];\n\n        /* a[0] * b[1] */\n        split(b[1], ys);\n        splitMult(xs, ys, zs);\n\n        double tmp = result[0] + zs[0];\n        result[1] = result[1] - (tmp - result[0] - zs[0]);\n        result[0] = tmp;\n        tmp = result[0] + zs[1];\n        result[1] = result[1] - (tmp - result[0] - zs[1]);\n        result[0] = tmp;\n\n        /* a[1] * b[0] */\n        split(a[1], xs);\n        split(b[0], ys);\n        splitMult(xs, ys, zs);\n\n        tmp = result[0] + zs[0];\n        result[1] = result[1] - (tmp - result[0] - zs[0]);\n        result[0] = tmp;\n        tmp = result[0] + zs[1];\n        result[1] = result[1] - (tmp - result[0] - zs[1]);\n        result[0] = tmp;\n\n        /* a[1] * b[0] */\n        split(a[1], xs);\n        split(b[1], ys);\n        splitMult(xs, ys, zs);\n\n        tmp = result[0] + zs[0];\n        result[1] = result[1] - (tmp - result[0] - zs[0]);\n        result[0] = tmp;\n        tmp = result[0] + zs[1];\n        result[1] = result[1] - (tmp - result[0] - zs[1]);\n        result[0] = tmp;\n    }",
    "comment": "Compute (a[0] + a[1]) * (b[0] + b[1]) in extended precision. @param a first term of the multiplication @param b second term of the multiplication @param result placeholder where to put the result ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 4
  },
  {
    "name": "FastMath.resplit",
    "class_name": "org.apache.commons.math.util.FastMath",
    "signature": "org.apache.commons.math.util.FastMath.resplit(double[])",
    "snippet": "    private static void resplit(final double a[]) {\n        final double c = a[0] + a[1];\n        final double d = -(c - a[0] - a[1]);\n\n        if (c < 8e298 && c > -8e298) {\n            double z = c * HEX_40000000;\n            a[0] = (c + z) - z;\n            a[1] = c - a[0] + d;\n        } else {\n            double z = c * 9.31322574615478515625E-10;\n            a[0] = (c + z - c) * HEX_40000000;\n            a[1] = c - a[0] + d;\n        }\n    }",
    "comment": "Recompute a split. @param a input/out array containing the split, changed on output ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 4
  },
  {
    "name": "FastMath.slowCos",
    "class_name": "org.apache.commons.math.util.FastMath",
    "signature": "org.apache.commons.math.util.FastMath.slowCos(double,double[])",
    "snippet": "    private static double slowCos(final double x, final double result[]) {\n\n        final double xs[] = new double[2];\n        final double ys[] = new double[2];\n        final double facts[] = new double[2];\n        final double as[] = new double[2];\n        split(x, xs);\n        ys[0] = ys[1] = 0.0;\n\n        for (int i = 19; i >= 0; i--) {\n            splitMult(xs, ys, as);\n            ys[0] = as[0]; ys[1] = as[1];\n\n            if ( (i & 1) != 0) {\n                continue;\n            }\n\n            split(FACT[i], as);\n            splitReciprocal(as, facts);\n\n            if ( (i & 2) != 0 ) {\n                facts[0] = -facts[0];\n                facts[1] = -facts[1];\n            }\n\n            splitAdd(ys, facts, as);\n            ys[0] = as[0]; ys[1] = as[1];\n        }\n\n        if (result != null) {\n            result[0] = ys[0];\n            result[1] = ys[1];\n        }\n\n        return ys[0] + ys[1];\n    }",
    "comment": " For x between 0 and pi/4 compute cosine @param x number from which cosine is requested @param result placeholder where to put the result in extended precision @return cos(x) ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 4
  },
  {
    "name": "FastMath.slowLog",
    "class_name": "org.apache.commons.math.util.FastMath",
    "signature": "org.apache.commons.math.util.FastMath.slowLog(double)",
    "snippet": "    private static double[] slowLog(double xi) {\n        double x[] = new double[2];\n        double x2[] = new double[2];\n        double y[] = new double[2];\n        double a[] = new double[2];\n\n        split(xi, x);\n\n        /* Set X = (x-1)/(x+1) */\n        x[0] += 1.0;\n        resplit(x);\n        splitReciprocal(x, a);\n        x[0] -= 2.0;\n        resplit(x);\n        splitMult(x, a, y);\n        x[0] = y[0];\n        x[1] = y[1];\n\n        /* Square X -> X2*/\n        splitMult(x, x, x2);\n\n\n        //x[0] -= 1.0;\n        //resplit(x);\n\n        y[0] = LN_SPLIT_COEF[LN_SPLIT_COEF.length-1][0];\n        y[1] = LN_SPLIT_COEF[LN_SPLIT_COEF.length-1][1];\n\n        for (int i = LN_SPLIT_COEF.length-2; i >= 0; i--) {\n            splitMult(y, x2, a);\n            y[0] = a[0];\n            y[1] = a[1];\n            splitAdd(y, LN_SPLIT_COEF[i], a);\n            y[0] = a[0];\n            y[1] = a[1];\n        }\n\n        splitMult(y, x, a);\n        y[0] = a[0];\n        y[1] = a[1];\n\n        return y;\n    }",
    "comment": "xi in the range of [1, 2]. 3        5        7 x+1           /          x        x        x          \\ ln ----- =   2 *  |  x  +   ----  +  ----  +  ---- + ...  | 1-x           \\          3        5        7          /  So, compute a Remez approximation of the following function  ln ((sqrt(x)+1)/(1-sqrt(x)))  /  x  This will be an even function with only positive coefficents. x is in the range [0 - 1/3].  Transform xi for input to the above function by setting x = (xi-1)/(xi+1).   Input to the polynomial is x^2, then the result is multiplied by x. @param xi number from which log is requested @return log(xi) ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 4
  },
  {
    "name": "FastMath.slowSin",
    "class_name": "org.apache.commons.math.util.FastMath",
    "signature": "org.apache.commons.math.util.FastMath.slowSin(double,double[])",
    "snippet": "    private static double slowSin(final double x, final double result[]) {\n        final double xs[] = new double[2];\n        final double ys[] = new double[2];\n        final double facts[] = new double[2];\n        final double as[] = new double[2];\n        split(x, xs);\n        ys[0] = ys[1] = 0.0;\n\n        for (int i = 19; i >= 0; i--) {\n            splitMult(xs, ys, as);\n            ys[0] = as[0]; ys[1] = as[1];\n\n            if ( (i & 1) == 0) {\n                continue;\n            }\n\n            split(FACT[i], as);\n            splitReciprocal(as, facts);\n\n            if ( (i & 2) != 0 ) {\n                facts[0] = -facts[0];\n                facts[1] = -facts[1];\n            }\n\n            splitAdd(ys, facts, as);\n            ys[0] = as[0]; ys[1] = as[1];\n        }\n\n        if (result != null) {\n            result[0] = ys[0];\n            result[1] = ys[1];\n        }\n\n        return ys[0] + ys[1];\n    }",
    "comment": " For x between 0 and pi/4 compute sine. @param x number from which sine is requested @param result placeholder where to put the result in extended precision @return sin(x) ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 4
  },
  {
    "name": "FastMath.slowexp",
    "class_name": "org.apache.commons.math.util.FastMath",
    "signature": "org.apache.commons.math.util.FastMath.slowexp(double,double[])",
    "snippet": "    private static double slowexp(final double x, final double result[]) {\n        final double xs[] = new double[2];\n        final double ys[] = new double[2];\n        final double facts[] = new double[2];\n        final double as[] = new double[2];\n        split(x, xs);\n        ys[0] = ys[1] = 0.0;\n\n        for (int i = 19; i >= 0; i--) {\n            splitMult(xs, ys, as);\n            ys[0] = as[0];\n            ys[1] = as[1];\n\n            split(FACT[i], as);\n            splitReciprocal(as, facts);\n\n            splitAdd(ys, facts, as);\n            ys[0] = as[0];\n            ys[1] = as[1];\n        }\n\n        if (result != null) {\n            result[0] = ys[0];\n            result[1] = ys[1];\n        }\n\n        return ys[0] + ys[1];\n    }",
    "comment": " For x between 0 and 1, returns exp(x), uses extended precision @param x argument of exponential @param result placeholder where to place exp(x) split in two terms for extra precision (i.e. exp(x) = result[0] Â° result[1] @return exp(x) ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 4
  },
  {
    "name": "FastMath.split",
    "class_name": "org.apache.commons.math.util.FastMath",
    "signature": "org.apache.commons.math.util.FastMath.split(double,double[])",
    "snippet": "    private static void split(final double d, final double split[]) {\n        if (d < 8e298 && d > -8e298) {\n            final double a = d * HEX_40000000;\n            split[0] = (d + a) - a;\n            split[1] = d - split[0];\n        } else {\n            final double a = d * 9.31322574615478515625E-10;\n            split[0] = (d + a - d) * HEX_40000000;\n            split[1] = d - split[0];\n        }\n    }",
    "comment": "Compute split[0], split[1] such that their sum is equal to d, and split[0] has its 30 least significant bits as zero. @param d number to split @param split placeholder where to place the result ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 4
  },
  {
    "name": "FastMath.splitAdd",
    "class_name": "org.apache.commons.math.util.FastMath",
    "signature": "org.apache.commons.math.util.FastMath.splitAdd(double[],double[],double[])",
    "snippet": "    private static void splitAdd(final double a[], final double b[], final double ans[]) {\n        ans[0] = a[0] + b[0];\n        ans[1] = a[1] + b[1];\n\n        resplit(ans);\n    }",
    "comment": "Add two numbers in split form. @param a first term of addition @param b second term of addition @param ans placeholder where to put the result ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 4
  },
  {
    "name": "FastMath.splitMult",
    "class_name": "org.apache.commons.math.util.FastMath",
    "signature": "org.apache.commons.math.util.FastMath.splitMult(double[],double[],double[])",
    "snippet": "    private static void splitMult(double a[], double b[], double ans[]) {\n        ans[0] = a[0] * b[0];\n        ans[1] = a[0] * b[1] + a[1] * b[0] + a[1] * b[1];\n\n        /* Resplit */\n        resplit(ans);\n    }",
    "comment": "Multiply two numbers in split form. @param a first term of multiplication @param b second term of multiplication @param ans placeholder where to put the result ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 4
  },
  {
    "name": "FastMath.splitReciprocal",
    "class_name": "org.apache.commons.math.util.FastMath",
    "signature": "org.apache.commons.math.util.FastMath.splitReciprocal(double[],double[])",
    "snippet": "    private static void splitReciprocal(final double in[], final double result[]) {\n        final double b = 1.0/4194304.0;\n        final double a = 1.0 - b;\n\n        if (in[0] == 0.0) {\n            in[0] = in[1];\n            in[1] = 0.0;\n        }\n\n        result[0] = a / in[0];\n        result[1] = (b*in[0]-a*in[1]) / (in[0]*in[0] + in[0]*in[1]);\n\n        if (result[1] != result[1]) { // can happen if result[1] is NAN\n            result[1] = 0.0;\n        }\n\n        /* Resplit */\n        resplit(result);\n\n        for (int i = 0; i < 2; i++) {\n            /* this may be overkill, probably once is enough */\n            double err = 1.0 - result[0] * in[0] - result[0] * in[1] -\n            result[1] * in[0] - result[1] * in[1];\n            /*err = 1.0 - err; */\n            err = err * (result[0] + result[1]);\n            /*printf(\"err = %16e\\n\", err); */\n            result[1] += err;\n        }\n    }",
    "comment": "Compute the reciprocal of in.  Use the following algorithm. in = c + d. want to find x + y such that x+y = 1/(c+d) and x is much larger than y and x has several zero bits on the right.  Set b = 1/(2^22),  a = 1 - b.  Thus (a+b) = 1. Use following identity to compute (a+b)/(c+d)  (a+b)/(c+d)  =   a/c   +    (bc - ad) / (c^2 + cd) set x = a/c  and y = (bc - ad) / (c^2 + cd) This will be close to the right answer, but there will be some rounding in the calculation of X.  So by carefully computing 1 - (c+d)(x+y) we can compute an error and add that back in.   This is done carefully so that terms of similar size are subtracted first. @param in initial number, in split form @param result placeholder where to put the result ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 4
  },
  {
    "name": "OpenIntToDoubleHashMap.OpenIntToDoubleHashMap",
    "class_name": "org.apache.commons.math.util.OpenIntToDoubleHashMap",
    "signature": "org.apache.commons.math.util.OpenIntToDoubleHashMap.OpenIntToDoubleHashMap(OpenIntToDoubleHashMap)",
    "snippet": "    public OpenIntToDoubleHashMap(final OpenIntToDoubleHashMap source) {\n        final int length = source.keys.length;\n        keys = new int[length];\n        System.arraycopy(source.keys, 0, keys, 0, length);\n        values = new double[length];\n        System.arraycopy(source.values, 0, values, 0, length);\n        states = new byte[length];\n        System.arraycopy(source.states, 0, states, 0, length);\n        missingEntries = source.missingEntries;\n        size  = source.size;\n        mask  = source.mask;\n        count = source.count;\n    }",
    "comment": " Copy constructor. @param source map to copy ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 4
  },
  {
    "name": "OpenIntToDoubleHashMap.OpenIntToDoubleHashMap",
    "class_name": "org.apache.commons.math.util.OpenIntToDoubleHashMap",
    "signature": "org.apache.commons.math.util.OpenIntToDoubleHashMap.OpenIntToDoubleHashMap(double)",
    "snippet": "    public OpenIntToDoubleHashMap(final double missingEntries) {\n        this(DEFAULT_EXPECTED_SIZE, missingEntries);\n    }",
    "comment": " Build an empty map with default size @param missingEntries value to return when a missing entry is fetched ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 4
  },
  {
    "name": "OpenIntToDoubleHashMap.OpenIntToDoubleHashMap",
    "class_name": "org.apache.commons.math.util.OpenIntToDoubleHashMap",
    "signature": "org.apache.commons.math.util.OpenIntToDoubleHashMap.OpenIntToDoubleHashMap(int,double)",
    "snippet": "    public OpenIntToDoubleHashMap(final int expectedSize,\n                                  final double missingEntries) {\n        final int capacity = computeCapacity(expectedSize);\n        keys   = new int[capacity];\n        values = new double[capacity];\n        states = new byte[capacity];\n        this.missingEntries = missingEntries;\n        mask   = capacity - 1;\n    }",
    "comment": " Build an empty map with specified size. @param expectedSize expected number of elements in the map @param missingEntries value to return when a missing entry is fetched ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 4
  },
  {
    "name": "OpenIntToDoubleHashMap.computeCapacity",
    "class_name": "org.apache.commons.math.util.OpenIntToDoubleHashMap",
    "signature": "org.apache.commons.math.util.OpenIntToDoubleHashMap.computeCapacity(int)",
    "snippet": "    private static int computeCapacity(final int expectedSize) {\n        if (expectedSize == 0) {\n            return 1;\n        }\n        final int capacity   = (int) FastMath.ceil(expectedSize / LOAD_FACTOR);\n        final int powerOfTwo = Integer.highestOneBit(capacity);\n        if (powerOfTwo == capacity) {\n            return capacity;\n        }\n        return nextPowerOfTwo(capacity);\n    }",
    "comment": " Compute the capacity needed for a given size. @param expectedSize expected size of the map @return capacity to use for the specified size ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 4
  },
  {
    "name": "OpenIntToDoubleHashMap.containsKey",
    "class_name": "org.apache.commons.math.util.OpenIntToDoubleHashMap",
    "signature": "org.apache.commons.math.util.OpenIntToDoubleHashMap.containsKey(int)",
    "snippet": "    public boolean containsKey(final int key) {\n\n        final int hash  = hashOf(key);\n        int index = hash & mask;\n        if (containsKey(key, index)) {\n            return true;\n        }\n\n        if (states[index] == FREE) {\n            return false;\n        }\n\n        int j = index;\n        for (int perturb = perturb(hash); states[index] != FREE; perturb >>= PERTURB_SHIFT) {\n            j = probe(perturb, j);\n            index = j & mask;\n            if (containsKey(key, index)) {\n                return true;\n            }\n        }\n\n        return false;\n\n    }",
    "comment": " Check if a value is associated with a key. @param key key to check @return true if a value is associated with key ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 4
  },
  {
    "name": "OpenIntToDoubleHashMap.containsKey",
    "class_name": "org.apache.commons.math.util.OpenIntToDoubleHashMap",
    "signature": "org.apache.commons.math.util.OpenIntToDoubleHashMap.containsKey(int,int)",
    "snippet": "    private boolean containsKey(final int key, final int index) {\n        return (key != 0 || states[index] == FULL) && keys[index] == key;\n    }",
    "comment": " Check if the tables contain an element associated with specified key at specified index. @param key key to check @param index index to check @return true if an element is associated with key at index ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 4
  },
  {
    "name": "OpenIntToDoubleHashMap.doRemove",
    "class_name": "org.apache.commons.math.util.OpenIntToDoubleHashMap",
    "signature": "org.apache.commons.math.util.OpenIntToDoubleHashMap.doRemove(int)",
    "snippet": "    private double doRemove(int index) {\n        keys[index]   = 0;\n        states[index] = REMOVED;\n        final double previous = values[index];\n        values[index] = missingEntries;\n        --size;\n        ++count;\n        return previous;\n    }",
    "comment": " Remove an element at specified index. @param index index of the element to remove @return removed value ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 4
  },
  {
    "name": "OpenIntToDoubleHashMap.findInsertionIndex",
    "class_name": "org.apache.commons.math.util.OpenIntToDoubleHashMap",
    "signature": "org.apache.commons.math.util.OpenIntToDoubleHashMap.findInsertionIndex(int)",
    "snippet": "    private int findInsertionIndex(final int key) {\n        return findInsertionIndex(keys, states, key, mask);\n    }",
    "comment": " Find the index at which a key should be inserted @param key key to lookup @return index at which key should be inserted ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 4
  },
  {
    "name": "OpenIntToDoubleHashMap.findInsertionIndex",
    "class_name": "org.apache.commons.math.util.OpenIntToDoubleHashMap",
    "signature": "org.apache.commons.math.util.OpenIntToDoubleHashMap.findInsertionIndex(int[],byte[],int,int)",
    "snippet": "    private static int findInsertionIndex(final int[] keys, final byte[] states,\n                                          final int key, final int mask) {\n        final int hash = hashOf(key);\n        int index = hash & mask;\n        if (states[index] == FREE) {\n            return index;\n        } else if (states[index] == FULL && keys[index] == key) {\n            return changeIndexSign(index);\n        }\n\n        int perturb = perturb(hash);\n        int j = index;\n        if (states[index] == FULL) {\n            while (true) {\n                j = probe(perturb, j);\n                index = j & mask;\n                perturb >>= PERTURB_SHIFT;\n\n                if (states[index] != FULL || keys[index] == key) {\n                    break;\n                }\n            }\n        }\n\n        if (states[index] == FREE) {\n            return index;\n        } else if (states[index] == FULL) {\n            // due to the loop exit condition,\n            // if (states[index] == FULL) then keys[index] == key\n            return changeIndexSign(index);\n        }\n\n        final int firstRemoved = index;\n        while (true) {\n            j = probe(perturb, j);\n            index = j & mask;\n\n            if (states[index] == FREE) {\n                return firstRemoved;\n            } else if (states[index] == FULL && keys[index] == key) {\n                return changeIndexSign(index);\n            }\n\n            perturb >>= PERTURB_SHIFT;\n\n        }\n\n    }",
    "comment": " Find the index at which a key should be inserted @param keys keys table @param states states table @param key key to lookup @param mask bit mask for hash values @return index at which key should be inserted ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 4
  },
  {
    "name": "OpenIntToDoubleHashMap.get",
    "class_name": "org.apache.commons.math.util.OpenIntToDoubleHashMap",
    "signature": "org.apache.commons.math.util.OpenIntToDoubleHashMap.get(int)",
    "snippet": "    public double get(final int key) {\n\n        final int hash  = hashOf(key);\n        int index = hash & mask;\n        if (containsKey(key, index)) {\n            return values[index];\n        }\n\n        if (states[index] == FREE) {\n            return missingEntries;\n        }\n\n        int j = index;\n        for (int perturb = perturb(hash); states[index] != FREE; perturb >>= PERTURB_SHIFT) {\n            j = probe(perturb, j);\n            index = j & mask;\n            if (containsKey(key, index)) {\n                return values[index];\n            }\n        }\n\n        return missingEntries;\n\n    }",
    "comment": " Get the stored value associated with the given key @param key key associated with the data @return data associated with the key ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 4
  },
  {
    "name": "OpenIntToDoubleHashMap.hashOf",
    "class_name": "org.apache.commons.math.util.OpenIntToDoubleHashMap",
    "signature": "org.apache.commons.math.util.OpenIntToDoubleHashMap.hashOf(int)",
    "snippet": "    private static int hashOf(final int key) {\n        final int h = key ^ ((key >>> 20) ^ (key >>> 12));\n        return h ^ (h >>> 7) ^ (h >>> 4);\n    }",
    "comment": " Compute the hash value of a key @param key key to hash @return hash value of the key ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 4
  },
  {
    "name": "OpenIntToDoubleHashMap.iterator",
    "class_name": "org.apache.commons.math.util.OpenIntToDoubleHashMap",
    "signature": "org.apache.commons.math.util.OpenIntToDoubleHashMap.iterator()",
    "snippet": "    public Iterator iterator() {\n        return new Iterator();\n    }",
    "comment": " Get an iterator over map elements. <p>The specialized iterators returned are fail-fast: they throw a <code>ConcurrentModificationException</code> when they detect the map has been modified during iteration.</p> @return iterator over the map elements ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 4
  },
  {
    "name": "OpenIntToDoubleHashMap.put",
    "class_name": "org.apache.commons.math.util.OpenIntToDoubleHashMap",
    "signature": "org.apache.commons.math.util.OpenIntToDoubleHashMap.put(int,double)",
    "snippet": "    public double put(final int key, final double value) {\n        int index = findInsertionIndex(key);\n        double previous = missingEntries;\n        boolean newMapping = true;\n        if (index < 0) {\n            index = changeIndexSign(index);\n            previous = values[index];\n            newMapping = false;\n        }\n        keys[index]   = key;\n        states[index] = FULL;\n        values[index] = value;\n        if (newMapping) {\n            ++size;\n            if (shouldGrowTable()) {\n                growTable();\n            }\n            ++count;\n        }\n        return previous;\n\n    }",
    "comment": " Put a value associated with a key in the map. @param key key to which value is associated @param value value to put in the map @return previous value associated with the key ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 4
  },
  {
    "name": "OpenIntToDoubleHashMap.remove",
    "class_name": "org.apache.commons.math.util.OpenIntToDoubleHashMap",
    "signature": "org.apache.commons.math.util.OpenIntToDoubleHashMap.remove(int)",
    "snippet": "    public double remove(final int key) {\n\n        final int hash  = hashOf(key);\n        int index = hash & mask;\n        if (containsKey(key, index)) {\n            return doRemove(index);\n        }\n\n        if (states[index] == FREE) {\n            return missingEntries;\n        }\n\n        int j = index;\n        for (int perturb = perturb(hash); states[index] != FREE; perturb >>= PERTURB_SHIFT) {\n            j = probe(perturb, j);\n            index = j & mask;\n            if (containsKey(key, index)) {\n                return doRemove(index);\n            }\n        }\n\n        return missingEntries;\n\n    }",
    "comment": " Remove the value associated with a key. @param key key to which the value is associated @return removed value ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 4
  },
  {
    "name": "OpenIntToDoubleHashMap.shouldGrowTable",
    "class_name": "org.apache.commons.math.util.OpenIntToDoubleHashMap",
    "signature": "org.apache.commons.math.util.OpenIntToDoubleHashMap.shouldGrowTable()",
    "snippet": "    private boolean shouldGrowTable() {\n        return size > (mask + 1) * LOAD_FACTOR;\n    }",
    "comment": " Check if tables should grow due to increased size. @return true if  tables should grow ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 4
  },
  {
    "name": "Iterator.advance",
    "class_name": "org.apache.commons.math.util.OpenIntToDoubleHashMap$Iterator",
    "signature": "org.apache.commons.math.util.OpenIntToDoubleHashMap$Iterator.advance()",
    "snippet": "        public void advance()\n            throws ConcurrentModificationException, NoSuchElementException {\n\n            if (referenceCount != count) {\n                throw MathRuntimeException.createConcurrentModificationException(LocalizedFormats.MAP_MODIFIED_WHILE_ITERATING);\n            }\n\n            // advance on step\n            current = next;\n\n            // prepare next step\n            try {\n                while (states[++next] != FULL) {\n                    // nothing to do\n                }\n            } catch (ArrayIndexOutOfBoundsException e) {\n                next = -2;\n                if (current < 0) {\n                    throw MathRuntimeException.createNoSuchElementException(LocalizedFormats.ITERATOR_EXHAUSTED);\n                }\n            }\n\n        }",
    "comment": " Advance iterator one step further. @exception ConcurrentModificationException if the map is modified during iteration @exception NoSuchElementException if there is no element left in the map ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 4
  },
  {
    "name": "Iterator.hasNext",
    "class_name": "org.apache.commons.math.util.OpenIntToDoubleHashMap$Iterator",
    "signature": "org.apache.commons.math.util.OpenIntToDoubleHashMap$Iterator.hasNext()",
    "snippet": "        public boolean hasNext() {\n            return next >= 0;\n        }",
    "comment": " Check if there is a next element in the map. @return true if there is a next element ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 4
  },
  {
    "name": "Iterator.key",
    "class_name": "org.apache.commons.math.util.OpenIntToDoubleHashMap$Iterator",
    "signature": "org.apache.commons.math.util.OpenIntToDoubleHashMap$Iterator.key()",
    "snippet": "        public int key()\n            throws ConcurrentModificationException, NoSuchElementException {\n            if (referenceCount != count) {\n                throw MathRuntimeException.createConcurrentModificationException(LocalizedFormats.MAP_MODIFIED_WHILE_ITERATING);\n            }\n            if (current < 0) {\n                throw MathRuntimeException.createNoSuchElementException(LocalizedFormats.ITERATOR_EXHAUSTED);\n            }\n            return keys[current];\n        }",
    "comment": " Get the key of current entry. @return key of current entry @exception ConcurrentModificationException if the map is modified during iteration @exception NoSuchElementException if there is no element left in the map ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 4
  },
  {
    "name": "Iterator.value",
    "class_name": "org.apache.commons.math.util.OpenIntToDoubleHashMap$Iterator",
    "signature": "org.apache.commons.math.util.OpenIntToDoubleHashMap$Iterator.value()",
    "snippet": "        public double value()\n            throws ConcurrentModificationException, NoSuchElementException {\n            if (referenceCount != count) {\n                throw MathRuntimeException.createConcurrentModificationException(LocalizedFormats.MAP_MODIFIED_WHILE_ITERATING);\n            }\n            if (current < 0) {\n                throw MathRuntimeException.createNoSuchElementException(LocalizedFormats.ITERATOR_EXHAUSTED);\n            }\n            return values[current];\n        }",
    "comment": " Get the value of current entry. @return value of current entry @exception ConcurrentModificationException if the map is modified during iteration @exception NoSuchElementException if there is no element left in the map ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 4
  }
]