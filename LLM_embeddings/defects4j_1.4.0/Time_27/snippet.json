[
  {
    "name": "DateTimeFieldType.DateTimeFieldType",
    "class_name": "org.joda.time.DateTimeFieldType",
    "signature": "org.joda.time.DateTimeFieldType.DateTimeFieldType(String)",
    "snippet": "    protected DateTimeFieldType(String name) {\n        super();\n        iName = name;\n    }",
    "comment": " Constructor.  @param name  the name to use ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "DateTimeFieldType.centuryOfEra",
    "class_name": "org.joda.time.DateTimeFieldType",
    "signature": "org.joda.time.DateTimeFieldType.centuryOfEra()",
    "snippet": "    public static DateTimeFieldType centuryOfEra() {\n        return CENTURY_OF_ERA_TYPE;\n    }",
    "comment": " Get the century of era field type.  @return the DateTimeFieldType constant ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "DateTimeFieldType.clockhourOfDay",
    "class_name": "org.joda.time.DateTimeFieldType",
    "signature": "org.joda.time.DateTimeFieldType.clockhourOfDay()",
    "snippet": "    public static DateTimeFieldType clockhourOfDay() {\n        return CLOCKHOUR_OF_DAY_TYPE;\n    }",
    "comment": " Get the hour of day (offset to 1-24) field type.  @return the DateTimeFieldType constant ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "DateTimeFieldType.clockhourOfHalfday",
    "class_name": "org.joda.time.DateTimeFieldType",
    "signature": "org.joda.time.DateTimeFieldType.clockhourOfHalfday()",
    "snippet": "    public static DateTimeFieldType clockhourOfHalfday() {\n        return CLOCKHOUR_OF_HALFDAY_TYPE;\n    }",
    "comment": " Get the hour of am/pm (offset to 1-12) field type.  @return the DateTimeFieldType constant ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "DateTimeFieldType.dayOfMonth",
    "class_name": "org.joda.time.DateTimeFieldType",
    "signature": "org.joda.time.DateTimeFieldType.dayOfMonth()",
    "snippet": "    public static DateTimeFieldType dayOfMonth() {\n        return DAY_OF_MONTH_TYPE;\n    }",
    "comment": " Get the day of month field type.  @return the DateTimeFieldType constant ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "DateTimeFieldType.dayOfWeek",
    "class_name": "org.joda.time.DateTimeFieldType",
    "signature": "org.joda.time.DateTimeFieldType.dayOfWeek()",
    "snippet": "    public static DateTimeFieldType dayOfWeek() {\n        return DAY_OF_WEEK_TYPE;\n    }",
    "comment": " Get the day of week field type.  @return the DateTimeFieldType constant ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "DateTimeFieldType.dayOfYear",
    "class_name": "org.joda.time.DateTimeFieldType",
    "signature": "org.joda.time.DateTimeFieldType.dayOfYear()",
    "snippet": "    public static DateTimeFieldType dayOfYear() {\n        return DAY_OF_YEAR_TYPE;\n    }",
    "comment": " Get the day of year field type.  @return the DateTimeFieldType constant ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "DateTimeFieldType.era",
    "class_name": "org.joda.time.DateTimeFieldType",
    "signature": "org.joda.time.DateTimeFieldType.era()",
    "snippet": "    public static DateTimeFieldType era() {\n        return ERA_TYPE;\n    }",
    "comment": " Get the era field type.  @return the DateTimeFieldType constant ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "DateTimeFieldType.halfdayOfDay",
    "class_name": "org.joda.time.DateTimeFieldType",
    "signature": "org.joda.time.DateTimeFieldType.halfdayOfDay()",
    "snippet": "    public static DateTimeFieldType halfdayOfDay() {\n        return HALFDAY_OF_DAY_TYPE;\n    }",
    "comment": " Get the AM(0) PM(1) field type.  @return the DateTimeFieldType constant ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "DateTimeFieldType.hourOfDay",
    "class_name": "org.joda.time.DateTimeFieldType",
    "signature": "org.joda.time.DateTimeFieldType.hourOfDay()",
    "snippet": "    public static DateTimeFieldType hourOfDay() {\n        return HOUR_OF_DAY_TYPE;\n    }",
    "comment": " Get the hour of day (0-23) field type.  @return the DateTimeFieldType constant ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "DateTimeFieldType.hourOfHalfday",
    "class_name": "org.joda.time.DateTimeFieldType",
    "signature": "org.joda.time.DateTimeFieldType.hourOfHalfday()",
    "snippet": "    public static DateTimeFieldType hourOfHalfday() {\n        return HOUR_OF_HALFDAY_TYPE;\n    }",
    "comment": " Get the hour of am/pm (0-11) field type.  @return the DateTimeFieldType constant ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "DateTimeFieldType.millisOfDay",
    "class_name": "org.joda.time.DateTimeFieldType",
    "signature": "org.joda.time.DateTimeFieldType.millisOfDay()",
    "snippet": "    public static DateTimeFieldType millisOfDay() {\n        return MILLIS_OF_DAY_TYPE;\n    }",
    "comment": " Get the millis of day field type.  @return the DateTimeFieldType constant ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "DateTimeFieldType.millisOfSecond",
    "class_name": "org.joda.time.DateTimeFieldType",
    "signature": "org.joda.time.DateTimeFieldType.millisOfSecond()",
    "snippet": "    public static DateTimeFieldType millisOfSecond() {\n        return MILLIS_OF_SECOND_TYPE;\n    }",
    "comment": " Get the millis of second field type.  @return the DateTimeFieldType constant ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "DateTimeFieldType.minuteOfDay",
    "class_name": "org.joda.time.DateTimeFieldType",
    "signature": "org.joda.time.DateTimeFieldType.minuteOfDay()",
    "snippet": "    public static DateTimeFieldType minuteOfDay() {\n        return MINUTE_OF_DAY_TYPE;\n    }",
    "comment": " Get the minute of day field type.  @return the DateTimeFieldType constant ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "DateTimeFieldType.minuteOfHour",
    "class_name": "org.joda.time.DateTimeFieldType",
    "signature": "org.joda.time.DateTimeFieldType.minuteOfHour()",
    "snippet": "    public static DateTimeFieldType minuteOfHour() {\n        return MINUTE_OF_HOUR_TYPE;\n    }",
    "comment": " Get the minute of hour field type.  @return the DateTimeFieldType constant ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "DateTimeFieldType.monthOfYear",
    "class_name": "org.joda.time.DateTimeFieldType",
    "signature": "org.joda.time.DateTimeFieldType.monthOfYear()",
    "snippet": "    public static DateTimeFieldType monthOfYear() {\n        return MONTH_OF_YEAR_TYPE;\n    }",
    "comment": " Get the month of year field type.  @return the DateTimeFieldType constant ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "DateTimeFieldType.secondOfDay",
    "class_name": "org.joda.time.DateTimeFieldType",
    "signature": "org.joda.time.DateTimeFieldType.secondOfDay()",
    "snippet": "    public static DateTimeFieldType secondOfDay() {\n        return SECOND_OF_DAY_TYPE;\n    }",
    "comment": " Get the second of day field type.  @return the DateTimeFieldType constant ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "DateTimeFieldType.secondOfMinute",
    "class_name": "org.joda.time.DateTimeFieldType",
    "signature": "org.joda.time.DateTimeFieldType.secondOfMinute()",
    "snippet": "    public static DateTimeFieldType secondOfMinute() {\n        return SECOND_OF_MINUTE_TYPE;\n    }",
    "comment": " Get the second of minute field type.  @return the DateTimeFieldType constant ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "DateTimeFieldType.weekOfWeekyear",
    "class_name": "org.joda.time.DateTimeFieldType",
    "signature": "org.joda.time.DateTimeFieldType.weekOfWeekyear()",
    "snippet": "    public static DateTimeFieldType weekOfWeekyear() {\n        return WEEK_OF_WEEKYEAR_TYPE;\n    }",
    "comment": " Get the week of a week based year field type.  @return the DateTimeFieldType constant ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "DateTimeFieldType.weekyear",
    "class_name": "org.joda.time.DateTimeFieldType",
    "signature": "org.joda.time.DateTimeFieldType.weekyear()",
    "snippet": "    public static DateTimeFieldType weekyear() {\n        return WEEKYEAR_TYPE;\n    }",
    "comment": " Get the year of a week based year field type.  @return the DateTimeFieldType constant ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "DateTimeFieldType.weekyearOfCentury",
    "class_name": "org.joda.time.DateTimeFieldType",
    "signature": "org.joda.time.DateTimeFieldType.weekyearOfCentury()",
    "snippet": "    public static DateTimeFieldType weekyearOfCentury() {\n        return WEEKYEAR_OF_CENTURY_TYPE;\n    }",
    "comment": " Get the year of a week based year within a century field type.  @return the DateTimeFieldType constant ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "DateTimeFieldType.year",
    "class_name": "org.joda.time.DateTimeFieldType",
    "signature": "org.joda.time.DateTimeFieldType.year()",
    "snippet": "    public static DateTimeFieldType year() {\n        return YEAR_TYPE;\n    }",
    "comment": " Get the year field type.  @return the DateTimeFieldType constant ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "DateTimeFieldType.yearOfCentury",
    "class_name": "org.joda.time.DateTimeFieldType",
    "signature": "org.joda.time.DateTimeFieldType.yearOfCentury()",
    "snippet": "    public static DateTimeFieldType yearOfCentury() {\n        return YEAR_OF_CENTURY_TYPE;\n    }",
    "comment": " Get the year of century field type.  @return the DateTimeFieldType constant ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "DateTimeFieldType.yearOfEra",
    "class_name": "org.joda.time.DateTimeFieldType",
    "signature": "org.joda.time.DateTimeFieldType.yearOfEra()",
    "snippet": "    public static DateTimeFieldType yearOfEra() {\n        return YEAR_OF_ERA_TYPE;\n    }",
    "comment": " Get the year of era field type.  @return the DateTimeFieldType constant ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "StandardDateTimeFieldType.getDurationType",
    "class_name": "org.joda.time.DateTimeFieldType$StandardDateTimeFieldType",
    "signature": "org.joda.time.DateTimeFieldType$StandardDateTimeFieldType.getDurationType()",
    "snippet": "        public DurationFieldType getDurationType() {\n            return iUnitType;\n        }",
    "comment": "@inheritdoc */",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "StandardDateTimeFieldType.getRangeDurationType",
    "class_name": "org.joda.time.DateTimeFieldType$StandardDateTimeFieldType",
    "signature": "org.joda.time.DateTimeFieldType$StandardDateTimeFieldType.getRangeDurationType()",
    "snippet": "        public DurationFieldType getRangeDurationType() {\n            return iRangeType;\n        }",
    "comment": "@inheritdoc */",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "DateTimeUtils.checkPermission",
    "class_name": "org.joda.time.DateTimeUtils",
    "signature": "org.joda.time.DateTimeUtils.checkPermission()",
    "snippet": "    private static void checkPermission() throws SecurityException {\n        SecurityManager sm = System.getSecurityManager();\n        if (sm != null) {\n            sm.checkPermission(new JodaTimePermission(\"CurrentTime.setProvider\"));\n        }\n    }",
    "comment": " Checks whether the provider may be changed using permission 'CurrentTime.setProvider'.  @throws SecurityException if the provider may not be changed ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "DateTimeUtils.getChronology",
    "class_name": "org.joda.time.DateTimeUtils",
    "signature": "org.joda.time.DateTimeUtils.getChronology(Chronology)",
    "snippet": "    public static final Chronology getChronology(Chronology chrono) {\n        if (chrono == null) {\n            return ISOChronology.getInstance();\n        }\n        return chrono;\n    }",
    "comment": " Gets the chronology handling null. <p> If the chronology is <code>null</code>, {@link ISOChronology#getInstance()} will be returned. Otherwise, the chronology is returned.  @param chrono  the chronology to use, null means ISO in the default zone @return the chronology, never null ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "DateTimeUtils.getPeriodType",
    "class_name": "org.joda.time.DateTimeUtils",
    "signature": "org.joda.time.DateTimeUtils.getPeriodType(PeriodType)",
    "snippet": "    public static final PeriodType getPeriodType(PeriodType type) {\n        if (type == null) {\n            return PeriodType.standard();\n        }\n        return type;\n    }",
    "comment": " Gets the period type handling null. <p> If the zone is <code>null</code>, {@link PeriodType#standard()} will be returned. Otherwise, the type specified is returned.  @param type  the time zone to use, null means the standard type @return the type to use, never null ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "DateTimeUtils.setCurrentMillisFixed",
    "class_name": "org.joda.time.DateTimeUtils",
    "signature": "org.joda.time.DateTimeUtils.setCurrentMillisFixed(long)",
    "snippet": "    public static final void setCurrentMillisFixed(long fixedMillis) throws SecurityException {\n        checkPermission();\n        cMillisProvider = new FixedMillisProvider(fixedMillis);\n    }",
    "comment": " Sets the current time to return a fixed millisecond time. <p> This method changes the behaviour of {@link #currentTimeMillis()}. Whenever the current time is queried, the same millisecond time will be returned.  @param fixedMillis  the fixed millisecond time to use @throws SecurityException if the application does not have sufficient security rights ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "DateTimeUtils.setCurrentMillisSystem",
    "class_name": "org.joda.time.DateTimeUtils",
    "signature": "org.joda.time.DateTimeUtils.setCurrentMillisSystem()",
    "snippet": "    public static final void setCurrentMillisSystem() throws SecurityException {\n        checkPermission();\n        cMillisProvider = SYSTEM_MILLIS_PROVIDER;\n    }",
    "comment": " Resets the current time to return the system time. <p> This method changes the behaviour of {@link #currentTimeMillis()}. Whenever the current time is queried, {@link System#currentTimeMillis()} is used.  @throws SecurityException if the application does not have sufficient security rights ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "DateTimeZone.DateTimeZone",
    "class_name": "org.joda.time.DateTimeZone",
    "signature": "org.joda.time.DateTimeZone.DateTimeZone(String)",
    "snippet": "    protected DateTimeZone(String id) {\n        if (id == null) {\n            throw new IllegalArgumentException(\"Id must not be null\");\n        }\n        iID = id;\n    }",
    "comment": " Constructor.  @param id  the id to use @throws IllegalArgumentException if the id is null ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "DateTimeZone.forID",
    "class_name": "org.joda.time.DateTimeZone",
    "signature": "org.joda.time.DateTimeZone.forID(String)",
    "snippet": "    public static DateTimeZone forID(String id) {\n        if (id == null) {\n            return getDefault();\n        }\n        if (id.equals(\"UTC\")) {\n            return DateTimeZone.UTC;\n        }\n        DateTimeZone zone = cProvider.getZone(id);\n        if (zone != null) {\n            return zone;\n        }\n        if (id.startsWith(\"+\") || id.startsWith(\"-\")) {\n            int offset = parseOffset(id);\n            if (offset == 0L) {\n                return DateTimeZone.UTC;\n            } else {\n                id = printOffset(offset);\n                return fixedOffsetZone(id, offset);\n            }\n        }\n        throw new IllegalArgumentException(\"The datetime zone id '\" + id + \"' is not recognised\");\n    }",
    "comment": " Gets a time zone instance for the specified time zone id. <p> The time zone id may be one of those returned by getAvailableIDs. Short ids, as accepted by {@link java.util.TimeZone}, are not accepted. All IDs must be specified in the long format. The exception is UTC, which is an acceptable id. <p> Alternatively a locale independent, fixed offset, datetime zone can be specified. The form <code>[+-]hh:mm</code> can be used.  @param id  the ID of the datetime zone, null means default @return the DateTimeZone object for the ID @throws IllegalArgumentException if the ID is not recognised ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "DateTimeZone.forTimeZone",
    "class_name": "org.joda.time.DateTimeZone",
    "signature": "org.joda.time.DateTimeZone.forTimeZone(TimeZone)",
    "snippet": "    public static DateTimeZone forTimeZone(TimeZone zone) {\n        if (zone == null) {\n            return getDefault();\n        }\n        final String id = zone.getID();\n        if (id.equals(\"UTC\")) {\n            return DateTimeZone.UTC;\n        }\n\n        // Convert from old alias before consulting provider since they may differ.\n        DateTimeZone dtz = null;\n        String convId = getConvertedId(id);\n        if (convId != null) {\n            dtz = cProvider.getZone(convId);\n        }\n        if (dtz == null) {\n            dtz = cProvider.getZone(id);\n        }\n        if (dtz != null) {\n            return dtz;\n        }\n\n        // Support GMT+/-hh:mm formats\n        if (convId == null) {\n            convId = zone.getDisplayName();\n            if (convId.startsWith(\"GMT+\") || convId.startsWith(\"GMT-\")) {\n                convId = convId.substring(3);\n                int offset = parseOffset(convId);\n                if (offset == 0L) {\n                    return DateTimeZone.UTC;\n                } else {\n                    convId = printOffset(offset);\n                    return fixedOffsetZone(convId, offset);\n                }\n            }\n        }\n        throw new IllegalArgumentException(\"The datetime zone id '\" + id + \"' is not recognised\");\n    }",
    "comment": " Gets a time zone instance for a JDK TimeZone. <p> DateTimeZone only accepts a subset of the IDs from TimeZone. The excluded IDs are the short three letter form (except UTC). This  method will attempt to convert between time zones created using the short IDs and the full version. <p> This method is not designed to parse time zones with rules created by applications using <code>SimpleTimeZone</code> directly.  @param zone  the zone to convert, null means default @return the DateTimeZone object for the zone @throws IllegalArgumentException if the zone is not recognised ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "DateTimeZone.getConvertedId",
    "class_name": "org.joda.time.DateTimeZone",
    "signature": "org.joda.time.DateTimeZone.getConvertedId(String)",
    "snippet": "    private static synchronized String getConvertedId(String id) {\n        Map<String, String> map = cZoneIdConversion;\n        if (map == null) {\n            // Backwards compatibility with TimeZone.\n            map = new HashMap<String, String>();\n            map.put(\"GMT\", \"UTC\");\n            map.put(\"MIT\", \"Pacific/Apia\");\n            map.put(\"HST\", \"Pacific/Honolulu\");\n            map.put(\"AST\", \"America/Anchorage\");\n            map.put(\"PST\", \"America/Los_Angeles\");\n            map.put(\"MST\", \"America/Denver\");\n            map.put(\"PNT\", \"America/Phoenix\");\n            map.put(\"CST\", \"America/Chicago\");\n            map.put(\"EST\", \"America/New_York\");\n            map.put(\"IET\", \"America/Indianapolis\");\n            map.put(\"PRT\", \"America/Puerto_Rico\");\n            map.put(\"CNT\", \"America/St_Johns\");\n            map.put(\"AGT\", \"America/Buenos_Aires\");\n            map.put(\"BET\", \"America/Sao_Paulo\");\n            map.put(\"WET\", \"Europe/London\");\n            map.put(\"ECT\", \"Europe/Paris\");\n            map.put(\"ART\", \"Africa/Cairo\");\n            map.put(\"CAT\", \"Africa/Harare\");\n            map.put(\"EET\", \"Europe/Bucharest\");\n            map.put(\"EAT\", \"Africa/Addis_Ababa\");\n            map.put(\"MET\", \"Asia/Tehran\");\n            map.put(\"NET\", \"Asia/Yerevan\");\n            map.put(\"PLT\", \"Asia/Karachi\");\n            map.put(\"IST\", \"Asia/Calcutta\");\n            map.put(\"BST\", \"Asia/Dhaka\");\n            map.put(\"VST\", \"Asia/Saigon\");\n            map.put(\"CTT\", \"Asia/Shanghai\");\n            map.put(\"JST\", \"Asia/Tokyo\");\n            map.put(\"ACT\", \"Australia/Darwin\");\n            map.put(\"AET\", \"Australia/Sydney\");\n            map.put(\"SST\", \"Pacific/Guadalcanal\");\n            map.put(\"NST\", \"Pacific/Auckland\");\n            cZoneIdConversion = map;\n        }\n        return map.get(id);\n    }",
    "comment": " Converts an old style id to a new style id.  @param id  the old style id @return the new style id, null if not found ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "DateTimeZone.getDefault",
    "class_name": "org.joda.time.DateTimeZone",
    "signature": "org.joda.time.DateTimeZone.getDefault()",
    "snippet": "    public static DateTimeZone getDefault() {\n        DateTimeZone zone = cDefault;\n        if (zone == null) {\n            synchronized(DateTimeZone.class) {\n                zone = cDefault;\n                if (zone == null) {\n                    DateTimeZone temp = null;\n                    try {\n                        try {\n                            String id = System.getProperty(\"user.timezone\");\n                            if (id != null) {  // null check avoids stack overflow\n                                temp = forID(id);\n                            }\n                        } catch (RuntimeException ex) {\n                            // ignored\n                        }\n                        if (temp == null) {\n                            temp = forTimeZone(TimeZone.getDefault());\n                        }\n                    } catch (IllegalArgumentException ex) {\n                        // ignored\n                    }\n                    if (temp == null) {\n                        temp = UTC;\n                    }\n                    cDefault = zone = temp;\n                }\n            }\n        }\n        return zone;\n    }",
    "comment": " Gets the default time zone. <p> The default time zone is derived from the system property {@code user.timezone}. If that is {@code null} or is not a valid identifier, then the value of the JDK {@code TimeZone} default is converted. If that fails, {@code UTC} is used. <p> NOTE: If the {@code java.util.TimeZone} default is updated <i>after</i> calling this method, then the change will not be picked up here.  @return the default datetime zone object ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "DateTimeZone.getDefaultNameProvider",
    "class_name": "org.joda.time.DateTimeZone",
    "signature": "org.joda.time.DateTimeZone.getDefaultNameProvider()",
    "snippet": "    private static NameProvider getDefaultNameProvider() {\n        NameProvider nameProvider = null;\n        try {\n            String providerClass = System.getProperty(\"org.joda.time.DateTimeZone.NameProvider\");\n            if (providerClass != null) {\n                try {\n                    nameProvider = (NameProvider) Class.forName(providerClass).newInstance();\n                } catch (Exception ex) {\n                    Thread thread = Thread.currentThread();\n                    thread.getThreadGroup().uncaughtException(thread, ex);\n                }\n            }\n        } catch (SecurityException ex) {\n            // ignore\n        }\n\n        if (nameProvider == null) {\n            nameProvider = new DefaultNameProvider();\n        }\n\n        return nameProvider;\n    }",
    "comment": " Gets the default name provider. <p> Tries the system property <code>org.joda.time.DateTimeZone.NameProvider</code>. Then uses <code>DefaultNameProvider</code>.  @return the default name provider ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "DateTimeZone.getDefaultProvider",
    "class_name": "org.joda.time.DateTimeZone",
    "signature": "org.joda.time.DateTimeZone.getDefaultProvider()",
    "snippet": "    private static Provider getDefaultProvider() {\n        Provider provider = null;\n\n        try {\n            String providerClass =\n                System.getProperty(\"org.joda.time.DateTimeZone.Provider\");\n            if (providerClass != null) {\n                try {\n                    provider = (Provider) Class.forName(providerClass).newInstance();\n                } catch (Exception ex) {\n                    Thread thread = Thread.currentThread();\n                    thread.getThreadGroup().uncaughtException(thread, ex);\n                }\n            }\n        } catch (SecurityException ex) {\n            // ignored\n        }\n\n        if (provider == null) {\n            try {\n                provider = new ZoneInfoProvider(\"org/joda/time/tz/data\");\n            } catch (Exception ex) {\n                Thread thread = Thread.currentThread();\n                thread.getThreadGroup().uncaughtException(thread, ex);\n            }\n        }\n\n        if (provider == null) {\n            provider = new UTCProvider();\n        }\n\n        return provider;\n    }",
    "comment": " Gets the default zone provider. <p> Tries the system property <code>org.joda.time.DateTimeZone.Provider</code>. Then tries a <code>ZoneInfoProvider</code> using the data in <code>org/joda/time/tz/data</code>. Then uses <code>UTCProvider</code>.  @return the default name provider ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "DateTimeZone.getID",
    "class_name": "org.joda.time.DateTimeZone",
    "signature": "org.joda.time.DateTimeZone.getID()",
    "snippet": "    public final String getID() {\n        return iID;\n    }",
    "comment": " Gets the ID of this datetime zone.  @return the ID of this datetime zone ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "DateTimeZone.hashCode",
    "class_name": "org.joda.time.DateTimeZone",
    "signature": "org.joda.time.DateTimeZone.hashCode()",
    "snippet": "    public int hashCode() {\n        return 57 + getID().hashCode();\n    }",
    "comment": " Gets a hash code compatable with equals.  @return suitable hashcode ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "DateTimeZone.setDefault",
    "class_name": "org.joda.time.DateTimeZone",
    "signature": "org.joda.time.DateTimeZone.setDefault(DateTimeZone)",
    "snippet": "    public static void setDefault(DateTimeZone zone) throws SecurityException {\n        SecurityManager sm = System.getSecurityManager();\n        if (sm != null) {\n            sm.checkPermission(new JodaTimePermission(\"DateTimeZone.setDefault\"));\n        }\n        if (zone == null) {\n            throw new IllegalArgumentException(\"The datetime zone must not be null\");\n        }\n        synchronized(DateTimeZone.class) {\n            cDefault = zone;\n        }\n    }",
    "comment": " Sets the default time zone. <p> NOTE: Calling this method does <i>not</i> set the {@code java.util.TimeZone} default.  @param zone  the default datetime zone object, must not be null @throws IllegalArgumentException if the zone is null @throws SecurityException if the application has insufficient security rights ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "DateTimeZone.setNameProvider0",
    "class_name": "org.joda.time.DateTimeZone",
    "signature": "org.joda.time.DateTimeZone.setNameProvider0(NameProvider)",
    "snippet": "    private static void setNameProvider0(NameProvider nameProvider) {\n        if (nameProvider == null) {\n            nameProvider = getDefaultNameProvider();\n        }\n        cNameProvider = nameProvider;\n    }",
    "comment": " Sets the name provider factory without performing the security check.  @param nameProvider  provider to use, or null for default @throws IllegalArgumentException if the provider is invalid ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "DateTimeZone.setProvider0",
    "class_name": "org.joda.time.DateTimeZone",
    "signature": "org.joda.time.DateTimeZone.setProvider0(Provider)",
    "snippet": "    private static void setProvider0(Provider provider) {\n        if (provider == null) {\n            provider = getDefaultProvider();\n        }\n        Set<String> ids = provider.getAvailableIDs();\n        if (ids == null || ids.size() == 0) {\n            throw new IllegalArgumentException\n                (\"The provider doesn't have any available ids\");\n        }\n        if (!ids.contains(\"UTC\")) {\n            throw new IllegalArgumentException(\"The provider doesn't support UTC\");\n        }\n        if (!UTC.equals(provider.getZone(\"UTC\"))) {\n            throw new IllegalArgumentException(\"Invalid UTC zone provided\");\n        }\n        cProvider = provider;\n        cAvailableIDs = ids;\n    }",
    "comment": " Sets the zone provider factory without performing the security check.  @param provider  provider to use, or null for default @throws IllegalArgumentException if the provider is invalid ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "DurationFieldType.DurationFieldType",
    "class_name": "org.joda.time.DurationFieldType",
    "signature": "org.joda.time.DurationFieldType.DurationFieldType(String)",
    "snippet": "    protected DurationFieldType(String name) {\n        super();\n        iName = name;\n    }",
    "comment": " Constructor.  @param name  the name to use, which by convention, are plural. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "DurationFieldType.centuries",
    "class_name": "org.joda.time.DurationFieldType",
    "signature": "org.joda.time.DurationFieldType.centuries()",
    "snippet": "    public static DurationFieldType centuries() {\n        return CENTURIES_TYPE;\n    }",
    "comment": " Get the centuries field type.  @return the DateTimeFieldType constant ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "DurationFieldType.days",
    "class_name": "org.joda.time.DurationFieldType",
    "signature": "org.joda.time.DurationFieldType.days()",
    "snippet": "    public static DurationFieldType days() {\n        return DAYS_TYPE;\n    }",
    "comment": " Get the days field type.  @return the DateTimeFieldType constant ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "DurationFieldType.eras",
    "class_name": "org.joda.time.DurationFieldType",
    "signature": "org.joda.time.DurationFieldType.eras()",
    "snippet": "    public static DurationFieldType eras() {\n        return ERAS_TYPE;\n    }",
    "comment": " Get the eras field type.  @return the DateTimeFieldType constant ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "DurationFieldType.halfdays",
    "class_name": "org.joda.time.DurationFieldType",
    "signature": "org.joda.time.DurationFieldType.halfdays()",
    "snippet": "    public static DurationFieldType halfdays() {\n        return HALFDAYS_TYPE;\n    }",
    "comment": " Get the halfdays field type.  @return the DateTimeFieldType constant ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "DurationFieldType.hours",
    "class_name": "org.joda.time.DurationFieldType",
    "signature": "org.joda.time.DurationFieldType.hours()",
    "snippet": "    public static DurationFieldType hours() {\n        return HOURS_TYPE;\n    }",
    "comment": " Get the hours field type.  @return the DateTimeFieldType constant ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "DurationFieldType.millis",
    "class_name": "org.joda.time.DurationFieldType",
    "signature": "org.joda.time.DurationFieldType.millis()",
    "snippet": "    public static DurationFieldType millis() {\n        return MILLIS_TYPE;\n    }",
    "comment": " Get the millis field type.  @return the DateTimeFieldType constant ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "DurationFieldType.minutes",
    "class_name": "org.joda.time.DurationFieldType",
    "signature": "org.joda.time.DurationFieldType.minutes()",
    "snippet": "    public static DurationFieldType minutes() {\n        return MINUTES_TYPE;\n    }",
    "comment": " Get the minutes field type.  @return the DateTimeFieldType constant ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "DurationFieldType.months",
    "class_name": "org.joda.time.DurationFieldType",
    "signature": "org.joda.time.DurationFieldType.months()",
    "snippet": "    public static DurationFieldType months() {\n        return MONTHS_TYPE;\n    }",
    "comment": " Get the months field type.  @return the DateTimeFieldType constant ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "DurationFieldType.seconds",
    "class_name": "org.joda.time.DurationFieldType",
    "signature": "org.joda.time.DurationFieldType.seconds()",
    "snippet": "    public static DurationFieldType seconds() {\n        return SECONDS_TYPE;\n    }",
    "comment": " Get the seconds field type.  @return the DateTimeFieldType constant ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "DurationFieldType.weeks",
    "class_name": "org.joda.time.DurationFieldType",
    "signature": "org.joda.time.DurationFieldType.weeks()",
    "snippet": "    public static DurationFieldType weeks() {\n        return WEEKS_TYPE;\n    }",
    "comment": " Get the weeks field type.  @return the DateTimeFieldType constant ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "DurationFieldType.weekyears",
    "class_name": "org.joda.time.DurationFieldType",
    "signature": "org.joda.time.DurationFieldType.weekyears()",
    "snippet": "    public static DurationFieldType weekyears() {\n        return WEEKYEARS_TYPE;\n    }",
    "comment": " Get the weekyears field type.  @return the DateTimeFieldType constant ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "DurationFieldType.years",
    "class_name": "org.joda.time.DurationFieldType",
    "signature": "org.joda.time.DurationFieldType.years()",
    "snippet": "    public static DurationFieldType years() {\n        return YEARS_TYPE;\n    }",
    "comment": " Get the years field type.  @return the DateTimeFieldType constant ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "MutablePeriod.MutablePeriod",
    "class_name": "org.joda.time.MutablePeriod",
    "signature": "org.joda.time.MutablePeriod.MutablePeriod(Object,PeriodType,Chronology)",
    "snippet": "    public MutablePeriod(Object period, PeriodType type, Chronology chrono) {\n        super(period, type, chrono);\n    }",
    "comment": " Creates a period by converting or copying from another object. <p> The recognised object types are defined in {@link org.joda.time.convert.ConverterManager ConverterManager} and include ReadablePeriod, ReadableInterval and String. The String formats are described by {@link ISOPeriodFormat#standard()}.  @param period  period to convert @param type  which set of fields this period supports, null means use converter @param chrono  the chronology to use, null means ISO in default zone @throws IllegalArgumentException if period is invalid @throws UnsupportedOperationException if an unsupported field's value is non-zero ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "MutablePeriod.MutablePeriod",
    "class_name": "org.joda.time.MutablePeriod",
    "signature": "org.joda.time.MutablePeriod.MutablePeriod(long,PeriodType)",
    "snippet": "    public MutablePeriod(long duration, PeriodType type) {\n        super(duration, type, null);\n    }",
    "comment": " Creates a period from the given millisecond duration. <p> Only precise fields in the period type will be used. Imprecise fields will not be populated. <p> If the duration is small then this method will perform as you might expect and split the fields evenly. <p> If the duration is large then all the remaining duration will be stored in the largest available precise field. For details as to which fields are precise, review the period type javadoc.  @param duration  the duration, in milliseconds @param type  which set of fields this period supports, null means standard ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "MutablePeriod.setMillis",
    "class_name": "org.joda.time.MutablePeriod",
    "signature": "org.joda.time.MutablePeriod.setMillis(int)",
    "snippet": "    public void setMillis(int millis) {\n        super.setField(DurationFieldType.millis(), millis);\n    }",
    "comment": " Sets the number of millis of the period.  @param millis  the number of millis @throws IllegalArgumentException if field is not supported and the value is non-zero ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "MutablePeriod.setPeriod",
    "class_name": "org.joda.time.MutablePeriod",
    "signature": "org.joda.time.MutablePeriod.setPeriod(ReadablePeriod)",
    "snippet": "    public void setPeriod(ReadablePeriod period) {\n        super.setPeriod(period);\n    }",
    "comment": " Sets all the fields in one go from another ReadablePeriod.  @param period  the period to set, null means zero length period @throws IllegalArgumentException if an unsupported field's value is non-zero ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "MutablePeriod.setSeconds",
    "class_name": "org.joda.time.MutablePeriod",
    "signature": "org.joda.time.MutablePeriod.setSeconds(int)",
    "snippet": "    public void setSeconds(int seconds) {\n        super.setField(DurationFieldType.seconds(), seconds);\n    }",
    "comment": " Sets the number of seconds of the period.  @param seconds  the number of seconds @throws IllegalArgumentException if field is not supported and the value is non-zero ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "Period.Period",
    "class_name": "org.joda.time.Period",
    "signature": "org.joda.time.Period.Period()",
    "snippet": "    public Period() {\n        super(0L, null, null);\n    }",
    "comment": " Creates a new empty period with the standard set of fields. <p> One way to initialise a period is as follows: <pre> Period = new Period().withYears(6).withMonths(3).withSeconds(23); </pre> Bear in mind that this creates four period instances in total, three of which are immediately discarded. The alterative is more efficient, but less readable: <pre> Period = new Period(6, 3, 0, 0, 0, 0, 23, 0); </pre> The following is also slightly less wasteful: <pre> Period = Period.years(6).withMonths(3).withSeconds(23); </pre> ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "Period.Period",
    "class_name": "org.joda.time.Period",
    "signature": "org.joda.time.Period.Period(Object)",
    "snippet": "    public Period(Object period) {\n        super(period, null, null);\n    }",
    "comment": " Creates a period by converting or copying from another object. <p> The recognised object types are defined in {@link org.joda.time.convert.ConverterManager ConverterManager} and include ReadablePeriod, ReadableInterval and String. The String formats are described by {@link ISOPeriodFormat#standard()}.  @param period  period to convert @throws IllegalArgumentException if period is invalid @throws UnsupportedOperationException if an unsupported field's value is non-zero ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "Period.Period",
    "class_name": "org.joda.time.Period",
    "signature": "org.joda.time.Period.Period(int,int,int,int,int,int,int,int)",
    "snippet": "    public Period(int years, int months, int weeks, int days,\n                  int hours, int minutes, int seconds, int millis) {\n        super(years, months, weeks, days, hours, minutes, seconds, millis, PeriodType.standard());\n    }",
    "comment": " Create a period from a set of field values using the standard set of fields.  @param years  amount of years in this period @param months  amount of months in this period @param weeks  amount of weeks in this period @param days  amount of days in this period @param hours  amount of hours in this period @param minutes  amount of minutes in this period @param seconds  amount of seconds in this period @param millis  amount of milliseconds in this period ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "Period.Period",
    "class_name": "org.joda.time.Period",
    "signature": "org.joda.time.Period.Period(int,int,int,int,int,int,int,int,PeriodType)",
    "snippet": "    public Period(int years, int months, int weeks, int days,\n                    int hours, int minutes, int seconds, int millis, PeriodType type) {\n        super(years, months, weeks, days, hours, minutes, seconds, millis, type);\n    }",
    "comment": " Create a period from a set of field values. <p> There is usually little need to use this constructor. The period type is used primarily to define how to split an interval into a period. As this constructor already is split, the period type does no real work.  @param years  amount of years in this period, which must be zero if unsupported @param months  amount of months in this period, which must be zero if unsupported @param weeks  amount of weeks in this period, which must be zero if unsupported @param days  amount of days in this period, which must be zero if unsupported @param hours  amount of hours in this period, which must be zero if unsupported @param minutes  amount of minutes in this period, which must be zero if unsupported @param seconds  amount of seconds in this period, which must be zero if unsupported @param millis  amount of milliseconds in this period, which must be zero if unsupported @param type  which set of fields this period supports, null means AllType @throws IllegalArgumentException if an unsupported field's value is non-zero ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "PeriodType.PeriodType",
    "class_name": "org.joda.time.PeriodType",
    "signature": "org.joda.time.PeriodType.PeriodType(String,DurationFieldType[],int[])",
    "snippet": "    protected PeriodType(String name, DurationFieldType[] types, int[] indices) {\n        super();\n        iName = name;\n        iTypes = types;\n        iIndices = indices;\n    }",
    "comment": " Constructor.  @param name  the name @param types  the types @param indices  the indices ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "PeriodType.getFieldType",
    "class_name": "org.joda.time.PeriodType",
    "signature": "org.joda.time.PeriodType.getFieldType(int)",
    "snippet": "    public DurationFieldType getFieldType(int index) {\n        return iTypes[index];\n    }",
    "comment": " Gets the field type by index.  @param index  the index to retrieve @return the field type @throws IndexOutOfBoundsException if the index is invalid ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "PeriodType.indexOf",
    "class_name": "org.joda.time.PeriodType",
    "signature": "org.joda.time.PeriodType.indexOf(DurationFieldType)",
    "snippet": "    public int indexOf(DurationFieldType type) {\n        for (int i = 0, isize = size(); i < isize; i++) {\n            if (iTypes[i] == type) {\n                return i;\n            }\n        }\n        return -1;\n    }",
    "comment": " Gets the index of the field in this period.  @param type  the type to check, may be null which returns -1 @return the index of -1 if not supported ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "PeriodType.size",
    "class_name": "org.joda.time.PeriodType",
    "signature": "org.joda.time.PeriodType.size()",
    "snippet": "    public int size() {\n        return iTypes.length;\n    }",
    "comment": " Gets the number of fields in the period type.  @return the number of fields ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "PeriodType.standard",
    "class_name": "org.joda.time.PeriodType",
    "signature": "org.joda.time.PeriodType.standard()",
    "snippet": "    public static PeriodType standard() {\n        PeriodType type = cStandard;\n        if (type == null) {\n            type = new PeriodType(\n                \"Standard\",\n                new DurationFieldType[] {\n                    DurationFieldType.years(), DurationFieldType.months(),\n                    DurationFieldType.weeks(), DurationFieldType.days(),\n                    DurationFieldType.hours(), DurationFieldType.minutes(),\n                    DurationFieldType.seconds(), DurationFieldType.millis(),\n                },\n                new int[] { 0, 1, 2, 3, 4, 5, 6, 7, }\n            );\n            cStandard = type;\n        }\n        return type;\n    }",
    "comment": " Gets a type that defines all standard fields. <ul> <li>years <li>months <li>weeks <li>days <li>hours <li>minutes <li>seconds <li>milliseconds </ul>  @return the period type ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "PeriodType.yearDayTime",
    "class_name": "org.joda.time.PeriodType",
    "signature": "org.joda.time.PeriodType.yearDayTime()",
    "snippet": "    public static PeriodType yearDayTime() {\n        PeriodType type = cYDTime;\n        if (type == null) {\n            type = new PeriodType(\n                \"YearDayTime\",\n                new DurationFieldType[] {\n                    DurationFieldType.years(), DurationFieldType.days(),\n                    DurationFieldType.hours(), DurationFieldType.minutes(),\n                    DurationFieldType.seconds(), DurationFieldType.millis(),\n                },\n                new int[] { 0, -1, -1, 1, 2, 3, 4, 5, }\n            );\n            cYDTime = type;\n        }\n        return type;\n    }",
    "comment": " Gets a type that defines all standard fields except months and weeks. <ul> <li>years <li>days <li>hours <li>minutes <li>seconds <li>milliseconds </ul>  @return the period type ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "AbstractPeriod.AbstractPeriod",
    "class_name": "org.joda.time.base.AbstractPeriod",
    "signature": "org.joda.time.base.AbstractPeriod.AbstractPeriod()",
    "snippet": "    protected AbstractPeriod() {\n        super();\n    }",
    "comment": " Constructor. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "AbstractPeriod.getValues",
    "class_name": "org.joda.time.base.AbstractPeriod",
    "signature": "org.joda.time.base.AbstractPeriod.getValues()",
    "snippet": "    public int[] getValues() {\n        int[] result = new int[size()];\n        for (int i = 0; i < result.length; i++) {\n            result[i] = getValue(i);\n        }\n        return result;\n    }",
    "comment": " Gets an array of the value of each of the fields that this period supports. <p> The fields are returned largest to smallest, for example Hours, Minutes, Seconds. Each value corresponds to the same array index as <code>getFields()</code>  @return the current values of each field in an array that may be altered, largest to smallest ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "AbstractPeriod.indexOf",
    "class_name": "org.joda.time.base.AbstractPeriod",
    "signature": "org.joda.time.base.AbstractPeriod.indexOf(DurationFieldType)",
    "snippet": "    public int indexOf(DurationFieldType type) {\n        return getPeriodType().indexOf(type);\n    }",
    "comment": " Gets the index of the field in this period.  @param type  the type to check, may be null which returns -1 @return the index of -1 if not supported ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "AbstractPeriod.toPeriod",
    "class_name": "org.joda.time.base.AbstractPeriod",
    "signature": "org.joda.time.base.AbstractPeriod.toPeriod()",
    "snippet": "    public Period toPeriod() {\n        return new Period(this);\n    }",
    "comment": " Get this period as an immutable <code>Period</code> object.  @return a Period using the same field set and values ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "BasePeriod.BasePeriod",
    "class_name": "org.joda.time.base.BasePeriod",
    "signature": "org.joda.time.base.BasePeriod.BasePeriod(Object,PeriodType,Chronology)",
    "snippet": "    protected BasePeriod(Object period, PeriodType type, Chronology chrono) {\n        super();\n        PeriodConverter converter = ConverterManager.getInstance().getPeriodConverter(period);\n        type = (type == null ? converter.getPeriodType(period) : type);\n        type = checkPeriodType(type);\n        iType = type;\n        if (this instanceof ReadWritablePeriod) {\n            iValues = new int[size()];\n            chrono = DateTimeUtils.getChronology(chrono);\n            converter.setInto((ReadWritablePeriod) this, period, chrono);\n        } else {\n            iValues = new MutablePeriod(period, type, chrono).getValues();\n        }\n    }",
    "comment": " Creates a new period based on another using the {@link ConverterManager}.  @param period  the period to convert @param type  which set of fields this period supports, null means use type from object @param chrono  the chronology to use, null means ISO default @throws IllegalArgumentException if period is invalid @throws IllegalArgumentException if an unsupported field's value is non-zero ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "BasePeriod.BasePeriod",
    "class_name": "org.joda.time.base.BasePeriod",
    "signature": "org.joda.time.base.BasePeriod.BasePeriod(int,int,int,int,int,int,int,int,PeriodType)",
    "snippet": "    protected BasePeriod(int years, int months, int weeks, int days,\n                         int hours, int minutes, int seconds, int millis,\n                         PeriodType type) {\n        super();\n        type = checkPeriodType(type);\n        iType = type;\n        setPeriodInternal(years, months, weeks, days, hours, minutes, seconds, millis); // internal method\n    }",
    "comment": " Creates a period from a set of field values.  @param years  amount of years in this period, which must be zero if unsupported @param months  amount of months in this period, which must be zero if unsupported @param weeks  amount of weeks in this period, which must be zero if unsupported @param days  amount of days in this period, which must be zero if unsupported @param hours  amount of hours in this period, which must be zero if unsupported @param minutes  amount of minutes in this period, which must be zero if unsupported @param seconds  amount of seconds in this period, which must be zero if unsupported @param millis  amount of milliseconds in this period, which must be zero if unsupported @param type  which set of fields this period supports @throws IllegalArgumentException if period type is invalid @throws IllegalArgumentException if an unsupported field's value is non-zero ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "BasePeriod.BasePeriod",
    "class_name": "org.joda.time.base.BasePeriod",
    "signature": "org.joda.time.base.BasePeriod.BasePeriod(long,PeriodType,Chronology)",
    "snippet": "    protected BasePeriod(long duration, PeriodType type, Chronology chrono) {\n        super();\n        type = checkPeriodType(type);\n        chrono = DateTimeUtils.getChronology(chrono);\n        iType = type;\n        iValues = chrono.get(this, duration);\n    }",
    "comment": " Creates a period from the given millisecond duration, which is only really suitable for durations less than one day. <p> Only fields that are precise will be used. Thus the largest precise field may have a large value.  @param duration  the duration, in milliseconds @param type  which set of fields this period supports, null means standard @param chrono  the chronology to use, null means ISO default @throws IllegalArgumentException if period type is invalid ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "BasePeriod.checkAndUpdate",
    "class_name": "org.joda.time.base.BasePeriod",
    "signature": "org.joda.time.base.BasePeriod.checkAndUpdate(DurationFieldType,int[],int)",
    "snippet": "    private void checkAndUpdate(DurationFieldType type, int[] values, int newValue) {\n        int index = indexOf(type);\n        if (index == -1) {\n            if (newValue != 0) {\n                throw new IllegalArgumentException(\n                    \"Period does not support field '\" + type.getName() + \"'\");\n            }\n        } else {\n            values[index] = newValue;\n        }\n    }",
    "comment": " Checks whether a field type is supported, and if so adds the new value to the relevent index in the specified array.  @param type  the field type @param values  the array to update @param newValue  the new value to store if successful ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "BasePeriod.checkPeriodType",
    "class_name": "org.joda.time.base.BasePeriod",
    "signature": "org.joda.time.base.BasePeriod.checkPeriodType(PeriodType)",
    "snippet": "    protected PeriodType checkPeriodType(PeriodType type) {\n        return DateTimeUtils.getPeriodType(type);\n    }",
    "comment": " Validates a period type, converting nulls to a default value and checking the type is suitable for this instance.  @param type  the type to check, may be null @return the validated type to use, not null @throws IllegalArgumentException if the period type is invalid ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "BasePeriod.getFieldType",
    "class_name": "org.joda.time.base.BasePeriod",
    "signature": "org.joda.time.base.BasePeriod.getFieldType(int)",
    "snippet": "    public DurationFieldType getFieldType(int index) {\n        return iType.getFieldType(index);\n    }",
    "comment": " Gets the field type at the specified index.  @param index  the index to retrieve @return the field at the specified index @throws IndexOutOfBoundsException if the index is invalid ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "BasePeriod.getPeriodType",
    "class_name": "org.joda.time.base.BasePeriod",
    "signature": "org.joda.time.base.BasePeriod.getPeriodType()",
    "snippet": "    public PeriodType getPeriodType() {\n        return iType;\n    }",
    "comment": " Gets the period type.  @return the period type ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "BasePeriod.getValue",
    "class_name": "org.joda.time.base.BasePeriod",
    "signature": "org.joda.time.base.BasePeriod.getValue(int)",
    "snippet": "    public int getValue(int index) {\n        return iValues[index];\n    }",
    "comment": " Gets the value at the specified index.  @param index  the index to retrieve @return the value of the field at the specified index @throws IndexOutOfBoundsException if the index is invalid ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "BasePeriod.setField",
    "class_name": "org.joda.time.base.BasePeriod",
    "signature": "org.joda.time.base.BasePeriod.setField(DurationFieldType,int)",
    "snippet": "    protected void setField(DurationFieldType field, int value) {\n        setFieldInto(iValues, field, value);\n    }",
    "comment": " Sets the value of a field in this period.  @param field  the field to set @param value  the value to set @throws IllegalArgumentException if field is is null or not supported. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "BasePeriod.setFieldInto",
    "class_name": "org.joda.time.base.BasePeriod",
    "signature": "org.joda.time.base.BasePeriod.setFieldInto(int[],DurationFieldType,int)",
    "snippet": "    protected void setFieldInto(int[] values, DurationFieldType field, int value) {\n        int index = indexOf(field);\n        if (index == -1) {\n            if (value != 0 || field == null) {\n                throw new IllegalArgumentException(\n                    \"Period does not support field '\" + field + \"'\");\n            }\n        } else {\n            values[index] = value;\n        }\n    }",
    "comment": " Sets the value of a field in this period.  @param values  the array of values to update @param field  the field to set @param value  the value to set @throws IllegalArgumentException if field is null or not supported. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "BasePeriod.setPeriod",
    "class_name": "org.joda.time.base.BasePeriod",
    "signature": "org.joda.time.base.BasePeriod.setPeriod(ReadablePeriod)",
    "snippet": "    protected void setPeriod(ReadablePeriod period) {\n        if (period == null) {\n            setValues(new int[size()]);\n        } else {\n            setPeriodInternal(period);\n        }\n    }",
    "comment": " Sets all the fields of this period from another.  @param period  the period to copy from, not null @throws IllegalArgumentException if an unsupported field's value is non-zero ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "BasePeriod.setPeriodInternal",
    "class_name": "org.joda.time.base.BasePeriod",
    "signature": "org.joda.time.base.BasePeriod.setPeriodInternal(ReadablePeriod)",
    "snippet": "    private void setPeriodInternal(ReadablePeriod period) {\n        int[] newValues = new int[size()];\n        for (int i = 0, isize = period.size(); i < isize; i++) {\n            DurationFieldType type = period.getFieldType(i);\n            int value = period.getValue(i);\n            checkAndUpdate(type, newValues, value);\n        }\n        iValues = newValues;\n    }",
    "comment": " Private method called from constructor. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "BasePeriod.setPeriodInternal",
    "class_name": "org.joda.time.base.BasePeriod",
    "signature": "org.joda.time.base.BasePeriod.setPeriodInternal(int,int,int,int,int,int,int,int)",
    "snippet": "    private void setPeriodInternal(int years, int months, int weeks, int days,\n                                   int hours, int minutes, int seconds, int millis) {\n        int[] newValues = new int[size()];\n        checkAndUpdate(DurationFieldType.years(), newValues, years);\n        checkAndUpdate(DurationFieldType.months(), newValues, months);\n        checkAndUpdate(DurationFieldType.weeks(), newValues, weeks);\n        checkAndUpdate(DurationFieldType.days(), newValues, days);\n        checkAndUpdate(DurationFieldType.hours(), newValues, hours);\n        checkAndUpdate(DurationFieldType.minutes(), newValues, minutes);\n        checkAndUpdate(DurationFieldType.seconds(), newValues, seconds);\n        checkAndUpdate(DurationFieldType.millis(), newValues, millis);\n        iValues = newValues;\n    }",
    "comment": " Private method called from constructor. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "BasePeriod.size",
    "class_name": "org.joda.time.base.BasePeriod",
    "signature": "org.joda.time.base.BasePeriod.size()",
    "snippet": "    public int size() {\n        return iType.size();\n    }",
    "comment": " Gets the number of fields that this period supports.  @return the number of fields supported ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "AssembledChronology.AssembledChronology",
    "class_name": "org.joda.time.chrono.AssembledChronology",
    "signature": "org.joda.time.chrono.AssembledChronology.AssembledChronology(Chronology,Object)",
    "snippet": "    protected AssembledChronology(Chronology base, Object param) {\n        iBase = base;\n        iParam = param;\n        setFields();\n    }",
    "comment": " Constructor calls the assemble method, enabling subclasses to define its supported fields. If a base chronology is supplied, the field set initially contains references to each base chronology field. <p> Other methods in this class will delegate to the base chronology, if it can be determined that the base chronology will produce the same results as AbstractChronology.  @param base optional base chronology to copy initial fields from @param param optional param object avalable for assemble method ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "AssembledChronology.centuries",
    "class_name": "org.joda.time.chrono.AssembledChronology",
    "signature": "org.joda.time.chrono.AssembledChronology.centuries()",
    "snippet": "    public final DurationField centuries() {\n        return iCenturies;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "AssembledChronology.centuryOfEra",
    "class_name": "org.joda.time.chrono.AssembledChronology",
    "signature": "org.joda.time.chrono.AssembledChronology.centuryOfEra()",
    "snippet": "    public final DateTimeField centuryOfEra() {\n        return iCenturyOfEra;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "AssembledChronology.clockhourOfDay",
    "class_name": "org.joda.time.chrono.AssembledChronology",
    "signature": "org.joda.time.chrono.AssembledChronology.clockhourOfDay()",
    "snippet": "    public final DateTimeField clockhourOfDay() {\n        return iClockhourOfDay;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "AssembledChronology.clockhourOfHalfday",
    "class_name": "org.joda.time.chrono.AssembledChronology",
    "signature": "org.joda.time.chrono.AssembledChronology.clockhourOfHalfday()",
    "snippet": "    public final DateTimeField clockhourOfHalfday() {\n        return iClockhourOfHalfday;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "AssembledChronology.dayOfMonth",
    "class_name": "org.joda.time.chrono.AssembledChronology",
    "signature": "org.joda.time.chrono.AssembledChronology.dayOfMonth()",
    "snippet": "    public final DateTimeField dayOfMonth() {\n        return iDayOfMonth;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "AssembledChronology.dayOfWeek",
    "class_name": "org.joda.time.chrono.AssembledChronology",
    "signature": "org.joda.time.chrono.AssembledChronology.dayOfWeek()",
    "snippet": "    public final DateTimeField dayOfWeek() {\n        return iDayOfWeek;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "AssembledChronology.dayOfYear",
    "class_name": "org.joda.time.chrono.AssembledChronology",
    "signature": "org.joda.time.chrono.AssembledChronology.dayOfYear()",
    "snippet": "    public final DateTimeField dayOfYear() {\n        return iDayOfYear;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "AssembledChronology.days",
    "class_name": "org.joda.time.chrono.AssembledChronology",
    "signature": "org.joda.time.chrono.AssembledChronology.days()",
    "snippet": "    public final DurationField days() {\n        return iDays;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "AssembledChronology.era",
    "class_name": "org.joda.time.chrono.AssembledChronology",
    "signature": "org.joda.time.chrono.AssembledChronology.era()",
    "snippet": "    public final DateTimeField era() {\n        return iEra;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "AssembledChronology.eras",
    "class_name": "org.joda.time.chrono.AssembledChronology",
    "signature": "org.joda.time.chrono.AssembledChronology.eras()",
    "snippet": "    public final DurationField eras() {\n        return iEras;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "AssembledChronology.getBase",
    "class_name": "org.joda.time.chrono.AssembledChronology",
    "signature": "org.joda.time.chrono.AssembledChronology.getBase()",
    "snippet": "    protected final Chronology getBase() {\n        return iBase;\n    }",
    "comment": " Returns the same base chronology as passed into the constructor. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "AssembledChronology.getParam",
    "class_name": "org.joda.time.chrono.AssembledChronology",
    "signature": "org.joda.time.chrono.AssembledChronology.getParam()",
    "snippet": "    protected final Object getParam() {\n        return iParam;\n    }",
    "comment": " Returns the same param object as passed into the constructor. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "AssembledChronology.getZone",
    "class_name": "org.joda.time.chrono.AssembledChronology",
    "signature": "org.joda.time.chrono.AssembledChronology.getZone()",
    "snippet": "    public DateTimeZone getZone() {\n        Chronology base;\n        if ((base = iBase) != null) {\n            return base.getZone();\n        }\n        return null;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "AssembledChronology.halfdayOfDay",
    "class_name": "org.joda.time.chrono.AssembledChronology",
    "signature": "org.joda.time.chrono.AssembledChronology.halfdayOfDay()",
    "snippet": "    public final DateTimeField halfdayOfDay() {\n        return iHalfdayOfDay;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "AssembledChronology.halfdays",
    "class_name": "org.joda.time.chrono.AssembledChronology",
    "signature": "org.joda.time.chrono.AssembledChronology.halfdays()",
    "snippet": "    public final DurationField halfdays() {\n        return iHalfdays;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "AssembledChronology.hourOfDay",
    "class_name": "org.joda.time.chrono.AssembledChronology",
    "signature": "org.joda.time.chrono.AssembledChronology.hourOfDay()",
    "snippet": "    public final DateTimeField hourOfDay() {\n        return iHourOfDay;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "AssembledChronology.hourOfHalfday",
    "class_name": "org.joda.time.chrono.AssembledChronology",
    "signature": "org.joda.time.chrono.AssembledChronology.hourOfHalfday()",
    "snippet": "    public final DateTimeField hourOfHalfday() {\n        return iHourOfHalfday;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "AssembledChronology.hours",
    "class_name": "org.joda.time.chrono.AssembledChronology",
    "signature": "org.joda.time.chrono.AssembledChronology.hours()",
    "snippet": "    public final DurationField hours() {\n        return iHours;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "AssembledChronology.millis",
    "class_name": "org.joda.time.chrono.AssembledChronology",
    "signature": "org.joda.time.chrono.AssembledChronology.millis()",
    "snippet": "    public final DurationField millis() {\n        return iMillis;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "AssembledChronology.millisOfDay",
    "class_name": "org.joda.time.chrono.AssembledChronology",
    "signature": "org.joda.time.chrono.AssembledChronology.millisOfDay()",
    "snippet": "    public final DateTimeField millisOfDay() {\n        return iMillisOfDay;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "AssembledChronology.millisOfSecond",
    "class_name": "org.joda.time.chrono.AssembledChronology",
    "signature": "org.joda.time.chrono.AssembledChronology.millisOfSecond()",
    "snippet": "    public final DateTimeField millisOfSecond() {\n        return iMillisOfSecond;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "AssembledChronology.minuteOfDay",
    "class_name": "org.joda.time.chrono.AssembledChronology",
    "signature": "org.joda.time.chrono.AssembledChronology.minuteOfDay()",
    "snippet": "    public final DateTimeField minuteOfDay() {\n        return iMinuteOfDay;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "AssembledChronology.minuteOfHour",
    "class_name": "org.joda.time.chrono.AssembledChronology",
    "signature": "org.joda.time.chrono.AssembledChronology.minuteOfHour()",
    "snippet": "    public final DateTimeField minuteOfHour() {\n        return iMinuteOfHour;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "AssembledChronology.minutes",
    "class_name": "org.joda.time.chrono.AssembledChronology",
    "signature": "org.joda.time.chrono.AssembledChronology.minutes()",
    "snippet": "    public final DurationField minutes() {\n        return iMinutes;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "AssembledChronology.monthOfYear",
    "class_name": "org.joda.time.chrono.AssembledChronology",
    "signature": "org.joda.time.chrono.AssembledChronology.monthOfYear()",
    "snippet": "    public final DateTimeField monthOfYear() {\n        return iMonthOfYear;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "AssembledChronology.months",
    "class_name": "org.joda.time.chrono.AssembledChronology",
    "signature": "org.joda.time.chrono.AssembledChronology.months()",
    "snippet": "    public final DurationField months() {\n        return iMonths;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "AssembledChronology.secondOfDay",
    "class_name": "org.joda.time.chrono.AssembledChronology",
    "signature": "org.joda.time.chrono.AssembledChronology.secondOfDay()",
    "snippet": "    public final DateTimeField secondOfDay() {\n        return iSecondOfDay;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "AssembledChronology.secondOfMinute",
    "class_name": "org.joda.time.chrono.AssembledChronology",
    "signature": "org.joda.time.chrono.AssembledChronology.secondOfMinute()",
    "snippet": "    public final DateTimeField secondOfMinute() {\n        return iSecondOfMinute;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "AssembledChronology.seconds",
    "class_name": "org.joda.time.chrono.AssembledChronology",
    "signature": "org.joda.time.chrono.AssembledChronology.seconds()",
    "snippet": "    public final DurationField seconds() {\n        return iSeconds;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "AssembledChronology.setFields",
    "class_name": "org.joda.time.chrono.AssembledChronology",
    "signature": "org.joda.time.chrono.AssembledChronology.setFields()",
    "snippet": "    private void setFields() {\n        Fields fields = new Fields();\n        if (iBase != null) {\n            fields.copyFieldsFrom(iBase);\n        }\n        assemble(fields);\n\n        {\n            DurationField f;\n            iMillis    = (f = fields.millis)    != null ? f : super.millis();\n            iSeconds   = (f = fields.seconds)   != null ? f : super.seconds();\n            iMinutes   = (f = fields.minutes)   != null ? f : super.minutes();\n            iHours     = (f = fields.hours)     != null ? f : super.hours();\n            iHalfdays  = (f = fields.halfdays)  != null ? f : super.halfdays();\n            iDays      = (f = fields.days)      != null ? f : super.days();\n            iWeeks     = (f = fields.weeks)     != null ? f : super.weeks();\n            iWeekyears = (f = fields.weekyears) != null ? f : super.weekyears();\n            iMonths    = (f = fields.months)    != null ? f : super.months();\n            iYears     = (f = fields.years)     != null ? f : super.years();\n            iCenturies = (f = fields.centuries) != null ? f : super.centuries();\n            iEras      = (f = fields.eras)      != null ? f : super.eras();\n        }\n\n        {\n            DateTimeField f;\n            iMillisOfSecond     = (f = fields.millisOfSecond)     != null ? f : super.millisOfSecond();\n            iMillisOfDay        = (f = fields.millisOfDay)        != null ? f : super.millisOfDay();\n            iSecondOfMinute     = (f = fields.secondOfMinute)     != null ? f : super.secondOfMinute();\n            iSecondOfDay        = (f = fields.secondOfDay)        != null ? f : super.secondOfDay();\n            iMinuteOfHour       = (f = fields.minuteOfHour)       != null ? f : super.minuteOfHour();\n            iMinuteOfDay        = (f = fields.minuteOfDay)        != null ? f : super.minuteOfDay();\n            iHourOfDay          = (f = fields.hourOfDay)          != null ? f : super.hourOfDay();\n            iClockhourOfDay     = (f = fields.clockhourOfDay)     != null ? f : super.clockhourOfDay();\n            iHourOfHalfday      = (f = fields.hourOfHalfday)      != null ? f : super.hourOfHalfday();\n            iClockhourOfHalfday = (f = fields.clockhourOfHalfday) != null ? f : super.clockhourOfHalfday();\n            iHalfdayOfDay       = (f = fields.halfdayOfDay)       != null ? f : super.halfdayOfDay();\n            iDayOfWeek          = (f = fields.dayOfWeek)          != null ? f : super.dayOfWeek();\n            iDayOfMonth         = (f = fields.dayOfMonth)         != null ? f : super.dayOfMonth();\n            iDayOfYear          = (f = fields.dayOfYear)          != null ? f : super.dayOfYear();\n            iWeekOfWeekyear     = (f = fields.weekOfWeekyear)     != null ? f : super.weekOfWeekyear();\n            iWeekyear           = (f = fields.weekyear)           != null ? f : super.weekyear();\n            iWeekyearOfCentury  = (f = fields.weekyearOfCentury)  != null ? f : super.weekyearOfCentury();\n            iMonthOfYear        = (f = fields.monthOfYear)        != null ? f : super.monthOfYear();\n            iYear               = (f = fields.year)               != null ? f : super.year();\n            iYearOfEra          = (f = fields.yearOfEra)          != null ? f : super.yearOfEra();\n            iYearOfCentury      = (f = fields.yearOfCentury)      != null ? f : super.yearOfCentury();\n            iCenturyOfEra       = (f = fields.centuryOfEra)       != null ? f : super.centuryOfEra();\n            iEra                = (f = fields.era)                != null ? f : super.era();\n        }\n\n        int flags;\n        if (iBase == null) {\n            flags = 0;\n        } else {\n            flags = \n                ((iHourOfDay      == iBase.hourOfDay()      &&\n                  iMinuteOfHour   == iBase.minuteOfHour()   &&\n                  iSecondOfMinute == iBase.secondOfMinute() &&\n                  iMillisOfSecond == iBase.millisOfSecond()   ) ? 1 : 0) |\n\n                ((iMillisOfDay == iBase.millisOfDay()) ? 2 : 0) |\n\n                ((iYear        == iBase.year()        &&\n                  iMonthOfYear == iBase.monthOfYear() &&\n                  iDayOfMonth  == iBase.dayOfMonth()    ) ? 4 : 0);\n        }\n\n        iBaseFlags = flags;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "AssembledChronology.weekOfWeekyear",
    "class_name": "org.joda.time.chrono.AssembledChronology",
    "signature": "org.joda.time.chrono.AssembledChronology.weekOfWeekyear()",
    "snippet": "    public final DateTimeField weekOfWeekyear() {\n        return iWeekOfWeekyear;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "AssembledChronology.weeks",
    "class_name": "org.joda.time.chrono.AssembledChronology",
    "signature": "org.joda.time.chrono.AssembledChronology.weeks()",
    "snippet": "    public final DurationField weeks() {\n        return iWeeks;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "AssembledChronology.weekyear",
    "class_name": "org.joda.time.chrono.AssembledChronology",
    "signature": "org.joda.time.chrono.AssembledChronology.weekyear()",
    "snippet": "    public final DateTimeField weekyear() {\n        return iWeekyear;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "AssembledChronology.weekyearOfCentury",
    "class_name": "org.joda.time.chrono.AssembledChronology",
    "signature": "org.joda.time.chrono.AssembledChronology.weekyearOfCentury()",
    "snippet": "    public final DateTimeField weekyearOfCentury() {\n        return iWeekyearOfCentury;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "AssembledChronology.weekyears",
    "class_name": "org.joda.time.chrono.AssembledChronology",
    "signature": "org.joda.time.chrono.AssembledChronology.weekyears()",
    "snippet": "    public final DurationField weekyears() {\n        return iWeekyears;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "AssembledChronology.year",
    "class_name": "org.joda.time.chrono.AssembledChronology",
    "signature": "org.joda.time.chrono.AssembledChronology.year()",
    "snippet": "    public final DateTimeField year() {\n        return iYear;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "AssembledChronology.yearOfCentury",
    "class_name": "org.joda.time.chrono.AssembledChronology",
    "signature": "org.joda.time.chrono.AssembledChronology.yearOfCentury()",
    "snippet": "    public final DateTimeField yearOfCentury() {\n        return iYearOfCentury;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "AssembledChronology.yearOfEra",
    "class_name": "org.joda.time.chrono.AssembledChronology",
    "signature": "org.joda.time.chrono.AssembledChronology.yearOfEra()",
    "snippet": "    public final DateTimeField yearOfEra() {\n        return iYearOfEra;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "AssembledChronology.years",
    "class_name": "org.joda.time.chrono.AssembledChronology",
    "signature": "org.joda.time.chrono.AssembledChronology.years()",
    "snippet": "    public final DurationField years() {\n        return iYears;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "Fields.copyFieldsFrom",
    "class_name": "org.joda.time.chrono.AssembledChronology$Fields",
    "signature": "org.joda.time.chrono.AssembledChronology$Fields.copyFieldsFrom(Chronology)",
    "snippet": "        public void copyFieldsFrom(Chronology chrono) {\n            {\n                DurationField f;\n                if (isSupported(f = chrono.millis())) {\n                    millis = f;\n                }\n                if (isSupported(f = chrono.seconds())) {\n                    seconds = f;\n                }\n                if (isSupported(f = chrono.minutes())) {\n                    minutes = f;\n                }\n                if (isSupported(f = chrono.hours())) {\n                    hours = f;\n                }\n                if (isSupported(f = chrono.halfdays())) {\n                    halfdays = f;\n                }\n                if (isSupported(f = chrono.days())) {\n                    days = f;\n                }\n                if (isSupported(f = chrono.weeks())) {\n                    weeks = f;\n                }\n                if (isSupported(f = chrono.weekyears())) {\n                    weekyears = f;\n                }\n                if (isSupported(f = chrono.months())) {\n                    months = f;\n                }\n                if (isSupported(f = chrono.years())) {\n                    years = f;\n                }\n                if (isSupported(f = chrono.centuries())) {\n                    centuries = f;\n                }\n                if (isSupported(f = chrono.eras())) {\n                    eras = f;\n                }\n            }\n\n            {\n                DateTimeField f;\n                if (isSupported(f = chrono.millisOfSecond())) {\n                    millisOfSecond = f;\n                }\n                if (isSupported(f = chrono.millisOfDay())) {\n                    millisOfDay = f;\n                }\n                if (isSupported(f = chrono.secondOfMinute())) {\n                    secondOfMinute = f;\n                }\n                if (isSupported(f = chrono.secondOfDay())) {\n                    secondOfDay = f;\n                }\n                if (isSupported(f = chrono.minuteOfHour())) {\n                    minuteOfHour = f;\n                }\n                if (isSupported(f = chrono.minuteOfDay())) {\n                    minuteOfDay = f;\n                }\n                if (isSupported(f = chrono.hourOfDay())) {\n                    hourOfDay = f;\n                }\n                if (isSupported(f = chrono.clockhourOfDay())) {\n                    clockhourOfDay = f;\n                }\n                if (isSupported(f = chrono.hourOfHalfday())) {\n                    hourOfHalfday = f;\n                }\n                if (isSupported(f = chrono.clockhourOfHalfday())) {\n                    clockhourOfHalfday = f;\n                }\n                if (isSupported(f = chrono.halfdayOfDay())) {\n                    halfdayOfDay = f;\n                }\n                if (isSupported(f = chrono.dayOfWeek())) {\n                    dayOfWeek = f;\n                }\n                if (isSupported(f = chrono.dayOfMonth())) {\n                    dayOfMonth = f;\n                }\n                if (isSupported(f = chrono.dayOfYear())) {\n                    dayOfYear = f;\n                }\n                if (isSupported(f = chrono.weekOfWeekyear())) {\n                    weekOfWeekyear = f;\n                }\n                if (isSupported(f = chrono.weekyear())) {\n                    weekyear = f;\n                }\n                if (isSupported(f = chrono.weekyearOfCentury())) {\n                    weekyearOfCentury = f;\n                }\n                if (isSupported(f = chrono.monthOfYear())) {\n                    monthOfYear = f;\n                }\n                if (isSupported(f = chrono.year())) {\n                    year = f;\n                }\n                if (isSupported(f = chrono.yearOfEra())) {\n                    yearOfEra = f;\n                }\n                if (isSupported(f = chrono.yearOfCentury())) {\n                    yearOfCentury = f;\n                }\n                if (isSupported(f = chrono.centuryOfEra())) {\n                    centuryOfEra = f;\n                }\n                if (isSupported(f = chrono.era())) {\n                    era = f;\n                }\n            }\n        }",
    "comment": " Copy the supported fields from a chronology into this container. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "Fields.isSupported",
    "class_name": "org.joda.time.chrono.AssembledChronology$Fields",
    "signature": "org.joda.time.chrono.AssembledChronology$Fields.isSupported(DateTimeField)",
    "snippet": "        private static boolean isSupported(DateTimeField field) {\n            return field == null ? false : field.isSupported();\n        }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "Fields.isSupported",
    "class_name": "org.joda.time.chrono.AssembledChronology$Fields",
    "signature": "org.joda.time.chrono.AssembledChronology$Fields.isSupported(DurationField)",
    "snippet": "        private static boolean isSupported(DurationField field) {\n            return field == null ? false : field.isSupported();\n        }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "BaseChronology.BaseChronology",
    "class_name": "org.joda.time.chrono.BaseChronology",
    "signature": "org.joda.time.chrono.BaseChronology.BaseChronology()",
    "snippet": "    protected BaseChronology() {\n        super();\n    }",
    "comment": " Restricted constructor. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "BaseChronology.eras",
    "class_name": "org.joda.time.chrono.BaseChronology",
    "signature": "org.joda.time.chrono.BaseChronology.eras()",
    "snippet": "    public DurationField eras() {\n        return UnsupportedDurationField.getInstance(DurationFieldType.eras());\n    }",
    "comment": " Get the eras duration field for this chronology.  @return DurationField or UnsupportedDurationField if unsupported ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "BaseChronology.get",
    "class_name": "org.joda.time.chrono.BaseChronology",
    "signature": "org.joda.time.chrono.BaseChronology.get(ReadablePeriod,long)",
    "snippet": "    public int[] get(ReadablePeriod period, long duration) {\n        int size = period.size();\n        int[] values = new int[size];\n        if (duration != 0) {\n            long current = 0;\n            for (int i = 0; i < size; i++) {\n                DurationField field = period.getFieldType(i).getField(this);\n                if (field.isPrecise()) {\n                    int value = field.getDifference(duration, current);\n                    current = field.add(current, value);\n                    values[i] = value;\n                }\n            }\n        }\n        return values;\n    }",
    "comment": " Gets the values of a period from an interval.  @param period  the period instant to use @param duration  the duration to query @return the values of the period extracted from the duration ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "BasicChronology.BasicChronology",
    "class_name": "org.joda.time.chrono.BasicChronology",
    "signature": "org.joda.time.chrono.BasicChronology.BasicChronology(Chronology,Object,int)",
    "snippet": "    BasicChronology(Chronology base, Object param, int minDaysInFirstWeek) {\n        super(base, param);\n\n        if (minDaysInFirstWeek < 1 || minDaysInFirstWeek > 7) {\n            throw new IllegalArgumentException\n                (\"Invalid min days in first week: \" + minDaysInFirstWeek);\n        }\n\n        iMinDaysInFirstWeek = minDaysInFirstWeek;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "BasicChronology.assemble",
    "class_name": "org.joda.time.chrono.BasicChronology",
    "signature": "org.joda.time.chrono.BasicChronology.assemble(Fields)",
    "snippet": "    protected void assemble(Fields fields) {\n        // First copy fields that are the same for all Gregorian and Julian\n        // chronologies.\n\n        fields.millis = cMillisField;\n        fields.seconds = cSecondsField;\n        fields.minutes = cMinutesField;\n        fields.hours = cHoursField;\n        fields.halfdays = cHalfdaysField;\n        fields.days = cDaysField;\n        fields.weeks = cWeeksField;\n\n        fields.millisOfSecond = cMillisOfSecondField;\n        fields.millisOfDay = cMillisOfDayField;\n        fields.secondOfMinute = cSecondOfMinuteField;\n        fields.secondOfDay = cSecondOfDayField;\n        fields.minuteOfHour = cMinuteOfHourField;\n        fields.minuteOfDay = cMinuteOfDayField;\n        fields.hourOfDay = cHourOfDayField;\n        fields.hourOfHalfday = cHourOfHalfdayField;\n        fields.clockhourOfDay = cClockhourOfDayField;\n        fields.clockhourOfHalfday = cClockhourOfHalfdayField;\n        fields.halfdayOfDay = cHalfdayOfDayField;\n\n        // Now create fields that have unique behavior for Gregorian and Julian\n        // chronologies.\n\n        fields.year = new BasicYearDateTimeField(this);\n        fields.yearOfEra = new GJYearOfEraDateTimeField(fields.year, this);\n\n        // Define one-based centuryOfEra and yearOfCentury.\n        DateTimeField field = new OffsetDateTimeField(\n            fields.yearOfEra, 99);\n        fields.centuryOfEra = new DividedDateTimeField(\n            field, DateTimeFieldType.centuryOfEra(), 100);\n        \n        field = new RemainderDateTimeField(\n            (DividedDateTimeField) fields.centuryOfEra);\n        fields.yearOfCentury = new OffsetDateTimeField(\n            field, DateTimeFieldType.yearOfCentury(), 1);\n\n        fields.era = new GJEraDateTimeField(this);\n        fields.dayOfWeek = new GJDayOfWeekDateTimeField(this, fields.days);\n        fields.dayOfMonth = new BasicDayOfMonthDateTimeField(this, fields.days);\n        fields.dayOfYear = new BasicDayOfYearDateTimeField(this, fields.days);\n        fields.monthOfYear = new GJMonthOfYearDateTimeField(this);\n        fields.weekyear = new BasicWeekyearDateTimeField(this);\n        fields.weekOfWeekyear = new BasicWeekOfWeekyearDateTimeField(this, fields.weeks);\n        \n        field = new RemainderDateTimeField(\n            fields.weekyear, DateTimeFieldType.weekyearOfCentury(), 100);\n        fields.weekyearOfCentury = new OffsetDateTimeField(\n            field, DateTimeFieldType.weekyearOfCentury(), 1);\n        \n        // The remaining (imprecise) durations are available from the newly\n        // created datetime fields.\n\n        fields.years = fields.year.getDurationField();\n        fields.centuries = fields.centuryOfEra.getDurationField();\n        fields.months = fields.monthOfYear.getDurationField();\n        fields.weekyears = fields.weekyear.getDurationField();\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "BasicChronology.getMaxMonth",
    "class_name": "org.joda.time.chrono.BasicChronology",
    "signature": "org.joda.time.chrono.BasicChronology.getMaxMonth()",
    "snippet": "    int getMaxMonth() {\n        return 12;\n    }",
    "comment": " Gets the maximum number of months.  @return 12 ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "BasicChronology.getZone",
    "class_name": "org.joda.time.chrono.BasicChronology",
    "signature": "org.joda.time.chrono.BasicChronology.getZone()",
    "snippet": "    public DateTimeZone getZone() {\n        Chronology base;\n        if ((base = getBase()) != null) {\n            return base.getZone();\n        }\n        return DateTimeZone.UTC;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "BasicDayOfMonthDateTimeField.BasicDayOfMonthDateTimeField",
    "class_name": "org.joda.time.chrono.BasicDayOfMonthDateTimeField",
    "signature": "org.joda.time.chrono.BasicDayOfMonthDateTimeField.BasicDayOfMonthDateTimeField(BasicChronology,DurationField)",
    "snippet": "    BasicDayOfMonthDateTimeField(BasicChronology chronology, DurationField days) {\n        super(DateTimeFieldType.dayOfMonth(), days);\n        iChronology = chronology;\n    }",
    "comment": " Restricted constructor. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "BasicDayOfMonthDateTimeField.getRangeDurationField",
    "class_name": "org.joda.time.chrono.BasicDayOfMonthDateTimeField",
    "signature": "org.joda.time.chrono.BasicDayOfMonthDateTimeField.getRangeDurationField()",
    "snippet": "    public DurationField getRangeDurationField() {\n        return iChronology.months();\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "BasicDayOfYearDateTimeField.BasicDayOfYearDateTimeField",
    "class_name": "org.joda.time.chrono.BasicDayOfYearDateTimeField",
    "signature": "org.joda.time.chrono.BasicDayOfYearDateTimeField.BasicDayOfYearDateTimeField(BasicChronology,DurationField)",
    "snippet": "    BasicDayOfYearDateTimeField(BasicChronology chronology, DurationField days) {\n        super(DateTimeFieldType.dayOfYear(), days);\n        iChronology = chronology;\n    }",
    "comment": " Restricted constructor ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "BasicDayOfYearDateTimeField.getRangeDurationField",
    "class_name": "org.joda.time.chrono.BasicDayOfYearDateTimeField",
    "signature": "org.joda.time.chrono.BasicDayOfYearDateTimeField.getRangeDurationField()",
    "snippet": "    public DurationField getRangeDurationField() {\n        return iChronology.years();\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "BasicGJChronology.BasicGJChronology",
    "class_name": "org.joda.time.chrono.BasicGJChronology",
    "signature": "org.joda.time.chrono.BasicGJChronology.BasicGJChronology(Chronology,Object,int)",
    "snippet": "    BasicGJChronology(Chronology base, Object param, int minDaysInFirstWeek) {\n        super(base, param, minDaysInFirstWeek);\n    }",
    "comment": " Constructor. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "BasicMonthOfYearDateTimeField.BasicMonthOfYearDateTimeField",
    "class_name": "org.joda.time.chrono.BasicMonthOfYearDateTimeField",
    "signature": "org.joda.time.chrono.BasicMonthOfYearDateTimeField.BasicMonthOfYearDateTimeField(BasicChronology,int)",
    "snippet": "    BasicMonthOfYearDateTimeField(BasicChronology chronology, int leapMonth) {\n        super(DateTimeFieldType.monthOfYear(), chronology.getAverageMillisPerMonth());\n        iChronology = chronology;\n        iMax = iChronology.getMaxMonth();\n        iLeapMonth = leapMonth;\n    }",
    "comment": " Restricted constructor.  @param leapMonth the month of year that leaps ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "BasicMonthOfYearDateTimeField.getLeapDurationField",
    "class_name": "org.joda.time.chrono.BasicMonthOfYearDateTimeField",
    "signature": "org.joda.time.chrono.BasicMonthOfYearDateTimeField.getLeapDurationField()",
    "snippet": "    public DurationField getLeapDurationField() {\n        return iChronology.days();\n    }",
    "comment": "-----------------------------------------------------------------------",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "BasicMonthOfYearDateTimeField.getRangeDurationField",
    "class_name": "org.joda.time.chrono.BasicMonthOfYearDateTimeField",
    "signature": "org.joda.time.chrono.BasicMonthOfYearDateTimeField.getRangeDurationField()",
    "snippet": "    public DurationField getRangeDurationField() {\n        return iChronology.years();\n    }",
    "comment": "-----------------------------------------------------------------------",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "BasicWeekOfWeekyearDateTimeField.BasicWeekOfWeekyearDateTimeField",
    "class_name": "org.joda.time.chrono.BasicWeekOfWeekyearDateTimeField",
    "signature": "org.joda.time.chrono.BasicWeekOfWeekyearDateTimeField.BasicWeekOfWeekyearDateTimeField(BasicChronology,DurationField)",
    "snippet": "    BasicWeekOfWeekyearDateTimeField(BasicChronology chronology, DurationField weeks) {\n        super(DateTimeFieldType.weekOfWeekyear(), weeks);\n        iChronology = chronology;\n    }",
    "comment": " Restricted constructor ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "BasicWeekOfWeekyearDateTimeField.getRangeDurationField",
    "class_name": "org.joda.time.chrono.BasicWeekOfWeekyearDateTimeField",
    "signature": "org.joda.time.chrono.BasicWeekOfWeekyearDateTimeField.getRangeDurationField()",
    "snippet": "    public DurationField getRangeDurationField() {\n        return iChronology.weekyears();\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "BasicWeekyearDateTimeField.BasicWeekyearDateTimeField",
    "class_name": "org.joda.time.chrono.BasicWeekyearDateTimeField",
    "signature": "org.joda.time.chrono.BasicWeekyearDateTimeField.BasicWeekyearDateTimeField(BasicChronology)",
    "snippet": "    BasicWeekyearDateTimeField(BasicChronology chronology) {\n        super(DateTimeFieldType.weekyear(), chronology.getAverageMillisPerYear());\n        iChronology = chronology;\n    }",
    "comment": " Restricted constructor ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "BasicWeekyearDateTimeField.getLeapDurationField",
    "class_name": "org.joda.time.chrono.BasicWeekyearDateTimeField",
    "signature": "org.joda.time.chrono.BasicWeekyearDateTimeField.getLeapDurationField()",
    "snippet": "    public DurationField getLeapDurationField() {\n        return iChronology.weeks();\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "BasicWeekyearDateTimeField.getRangeDurationField",
    "class_name": "org.joda.time.chrono.BasicWeekyearDateTimeField",
    "signature": "org.joda.time.chrono.BasicWeekyearDateTimeField.getRangeDurationField()",
    "snippet": "    public DurationField getRangeDurationField() {\n        return null;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "BasicYearDateTimeField.BasicYearDateTimeField",
    "class_name": "org.joda.time.chrono.BasicYearDateTimeField",
    "signature": "org.joda.time.chrono.BasicYearDateTimeField.BasicYearDateTimeField(BasicChronology)",
    "snippet": "    BasicYearDateTimeField(BasicChronology chronology) {\n        super(DateTimeFieldType.year(), chronology.getAverageMillisPerYear());\n        iChronology = chronology;\n    }",
    "comment": " Restricted constructor.  @param chronology  the chronology this field belogs to ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "BasicYearDateTimeField.getLeapDurationField",
    "class_name": "org.joda.time.chrono.BasicYearDateTimeField",
    "signature": "org.joda.time.chrono.BasicYearDateTimeField.getLeapDurationField()",
    "snippet": "    public DurationField getLeapDurationField() {\n        return iChronology.days();\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "BasicYearDateTimeField.getMaximumValue",
    "class_name": "org.joda.time.chrono.BasicYearDateTimeField",
    "signature": "org.joda.time.chrono.BasicYearDateTimeField.getMaximumValue()",
    "snippet": "    public int getMaximumValue() {\n        return iChronology.getMaxYear();\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "BasicYearDateTimeField.getRangeDurationField",
    "class_name": "org.joda.time.chrono.BasicYearDateTimeField",
    "signature": "org.joda.time.chrono.BasicYearDateTimeField.getRangeDurationField()",
    "snippet": "    public DurationField getRangeDurationField() {\n        return null;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "GJDayOfWeekDateTimeField.GJDayOfWeekDateTimeField",
    "class_name": "org.joda.time.chrono.GJDayOfWeekDateTimeField",
    "signature": "org.joda.time.chrono.GJDayOfWeekDateTimeField.GJDayOfWeekDateTimeField(BasicChronology,DurationField)",
    "snippet": "    GJDayOfWeekDateTimeField(BasicChronology chronology, DurationField days) {\n        super(DateTimeFieldType.dayOfWeek(), days);\n        iChronology = chronology;\n    }",
    "comment": " Restricted constructor. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "GJDayOfWeekDateTimeField.getRangeDurationField",
    "class_name": "org.joda.time.chrono.GJDayOfWeekDateTimeField",
    "signature": "org.joda.time.chrono.GJDayOfWeekDateTimeField.getRangeDurationField()",
    "snippet": "    public DurationField getRangeDurationField() {\n        return iChronology.weeks();\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "GJEraDateTimeField.GJEraDateTimeField",
    "class_name": "org.joda.time.chrono.GJEraDateTimeField",
    "signature": "org.joda.time.chrono.GJEraDateTimeField.GJEraDateTimeField(BasicChronology)",
    "snippet": "    GJEraDateTimeField(BasicChronology chronology) {\n        super(DateTimeFieldType.era());\n        iChronology = chronology;\n    }",
    "comment": " Restricted constructor ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "GJEraDateTimeField.getDurationField",
    "class_name": "org.joda.time.chrono.GJEraDateTimeField",
    "signature": "org.joda.time.chrono.GJEraDateTimeField.getDurationField()",
    "snippet": "    public DurationField getDurationField() {\n        return UnsupportedDurationField.getInstance(DurationFieldType.eras());\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "GJEraDateTimeField.getRangeDurationField",
    "class_name": "org.joda.time.chrono.GJEraDateTimeField",
    "signature": "org.joda.time.chrono.GJEraDateTimeField.getRangeDurationField()",
    "snippet": "    public DurationField getRangeDurationField() {\n        return null;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "GJMonthOfYearDateTimeField.GJMonthOfYearDateTimeField",
    "class_name": "org.joda.time.chrono.GJMonthOfYearDateTimeField",
    "signature": "org.joda.time.chrono.GJMonthOfYearDateTimeField.GJMonthOfYearDateTimeField(BasicChronology)",
    "snippet": "    GJMonthOfYearDateTimeField(BasicChronology chronology) {\n        super(chronology, 2);\n    }",
    "comment": " Restricted constructor ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "GJYearOfEraDateTimeField.GJYearOfEraDateTimeField",
    "class_name": "org.joda.time.chrono.GJYearOfEraDateTimeField",
    "signature": "org.joda.time.chrono.GJYearOfEraDateTimeField.GJYearOfEraDateTimeField(DateTimeField,BasicChronology)",
    "snippet": "    GJYearOfEraDateTimeField(DateTimeField yearField, BasicChronology chronology) {\n        super(yearField, DateTimeFieldType.yearOfEra());\n        iChronology = chronology;\n    }",
    "comment": " Restricted constructor. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "GJYearOfEraDateTimeField.getMaximumValue",
    "class_name": "org.joda.time.chrono.GJYearOfEraDateTimeField",
    "signature": "org.joda.time.chrono.GJYearOfEraDateTimeField.getMaximumValue()",
    "snippet": "    public int getMaximumValue() {\n        return getWrappedField().getMaximumValue();\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "GJYearOfEraDateTimeField.getMinimumValue",
    "class_name": "org.joda.time.chrono.GJYearOfEraDateTimeField",
    "signature": "org.joda.time.chrono.GJYearOfEraDateTimeField.getMinimumValue()",
    "snippet": "    public int getMinimumValue() {\n        return 1;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "GregorianChronology.assemble",
    "class_name": "org.joda.time.chrono.GregorianChronology",
    "signature": "org.joda.time.chrono.GregorianChronology.assemble(Fields)",
    "snippet": "    protected void assemble(Fields fields) {\n        if (getBase() == null) {\n            super.assemble(fields);\n        }\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "GregorianChronology.getAverageMillisPerMonth",
    "class_name": "org.joda.time.chrono.GregorianChronology",
    "signature": "org.joda.time.chrono.GregorianChronology.getAverageMillisPerMonth()",
    "snippet": "    long getAverageMillisPerMonth() {\n        return MILLIS_PER_MONTH;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "GregorianChronology.getAverageMillisPerYear",
    "class_name": "org.joda.time.chrono.GregorianChronology",
    "signature": "org.joda.time.chrono.GregorianChronology.getAverageMillisPerYear()",
    "snippet": "    long getAverageMillisPerYear() {\n        return MILLIS_PER_YEAR;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "GregorianChronology.getInstance",
    "class_name": "org.joda.time.chrono.GregorianChronology",
    "signature": "org.joda.time.chrono.GregorianChronology.getInstance(DateTimeZone)",
    "snippet": "    public static GregorianChronology getInstance(DateTimeZone zone) {\n        return getInstance(zone, 4);\n    }",
    "comment": " Gets an instance of the GregorianChronology in the given time zone.  @param zone  the time zone to get the chronology in, null is default @return a chronology in the specified time zone ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "GregorianChronology.getInstance",
    "class_name": "org.joda.time.chrono.GregorianChronology",
    "signature": "org.joda.time.chrono.GregorianChronology.getInstance(DateTimeZone,int)",
    "snippet": "    public static GregorianChronology getInstance(DateTimeZone zone, int minDaysInFirstWeek) {\n        if (zone == null) {\n            zone = DateTimeZone.getDefault();\n        }\n        GregorianChronology chrono;\n        synchronized (cCache) {\n            GregorianChronology[] chronos = cCache.get(zone);\n            if (chronos == null) {\n                chronos = new GregorianChronology[7];\n                cCache.put(zone, chronos);\n            }\n            try {\n                chrono = chronos[minDaysInFirstWeek - 1];\n            } catch (ArrayIndexOutOfBoundsException e) {\n                throw new IllegalArgumentException\n                    (\"Invalid min days in first week: \" + minDaysInFirstWeek);\n            }\n            if (chrono == null) {\n                if (zone == DateTimeZone.UTC) {\n                    chrono = new GregorianChronology(null, null, minDaysInFirstWeek);\n                } else {\n                    chrono = getInstance(DateTimeZone.UTC, minDaysInFirstWeek);\n                    chrono = new GregorianChronology\n                        (ZonedChronology.getInstance(chrono, zone), null, minDaysInFirstWeek);\n                }\n                chronos[minDaysInFirstWeek - 1] = chrono;\n            }\n        }\n        return chrono;\n    }",
    "comment": " Gets an instance of the GregorianChronology in the given time zone.  @param zone  the time zone to get the chronology in, null is default @param minDaysInFirstWeek  minimum number of days in first week of the year; default is 4 @return a chronology in the specified time zone ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "GregorianChronology.getInstanceUTC",
    "class_name": "org.joda.time.chrono.GregorianChronology",
    "signature": "org.joda.time.chrono.GregorianChronology.getInstanceUTC()",
    "snippet": "    public static GregorianChronology getInstanceUTC() {\n        return INSTANCE_UTC;\n    }",
    "comment": " Gets an instance of the GregorianChronology. The time zone of the returned instance is UTC.  @return a singleton UTC instance of the chronology ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "GregorianChronology.getMaxYear",
    "class_name": "org.joda.time.chrono.GregorianChronology",
    "signature": "org.joda.time.chrono.GregorianChronology.getMaxYear()",
    "snippet": "    int getMaxYear() {\n        return MAX_YEAR;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "ISOChronology.assemble",
    "class_name": "org.joda.time.chrono.ISOChronology",
    "signature": "org.joda.time.chrono.ISOChronology.assemble(Fields)",
    "snippet": "    protected void assemble(Fields fields) {\n        if (getBase().getZone() == DateTimeZone.UTC) {\n            // Use zero based century and year of century.\n            fields.centuryOfEra = new DividedDateTimeField(\n                ISOYearOfEraDateTimeField.INSTANCE, DateTimeFieldType.centuryOfEra(), 100);\n            fields.yearOfCentury = new RemainderDateTimeField(\n                (DividedDateTimeField) fields.centuryOfEra, DateTimeFieldType.yearOfCentury());\n            fields.weekyearOfCentury = new RemainderDateTimeField(\n                (DividedDateTimeField) fields.centuryOfEra, DateTimeFieldType.weekyearOfCentury());\n\n            fields.centuries = fields.centuryOfEra.getDurationField();\n        }\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "ISOChronology.getInstance",
    "class_name": "org.joda.time.chrono.ISOChronology",
    "signature": "org.joda.time.chrono.ISOChronology.getInstance()",
    "snippet": "    public static ISOChronology getInstance() {\n        return getInstance(DateTimeZone.getDefault());\n    }",
    "comment": " Gets an instance of the ISOChronology in the default time zone.  @return a chronology in the default time zone ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "ISOChronology.getInstance",
    "class_name": "org.joda.time.chrono.ISOChronology",
    "signature": "org.joda.time.chrono.ISOChronology.getInstance(DateTimeZone)",
    "snippet": "    public static ISOChronology getInstance(DateTimeZone zone) {\n        if (zone == null) {\n            zone = DateTimeZone.getDefault();\n        }\n        int index = System.identityHashCode(zone) & (FAST_CACHE_SIZE - 1);\n        ISOChronology chrono = cFastCache[index];\n        if (chrono != null && chrono.getZone() == zone) {\n            return chrono;\n        }\n        synchronized (cCache) {\n            chrono = cCache.get(zone);\n            if (chrono == null) {\n                chrono = new ISOChronology(ZonedChronology.getInstance(INSTANCE_UTC, zone));\n                cCache.put(zone, chrono);\n            }\n        }\n        cFastCache[index] = chrono;\n        return chrono;\n    }",
    "comment": " Gets an instance of the ISOChronology in the given time zone.  @param zone  the time zone to get the chronology in, null is default @return a chronology in the specified time zone ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "ISOChronology.withUTC",
    "class_name": "org.joda.time.chrono.ISOChronology",
    "signature": "org.joda.time.chrono.ISOChronology.withUTC()",
    "snippet": "    public Chronology withUTC() {\n        return INSTANCE_UTC;\n    }",
    "comment": " Gets the Chronology in the UTC time zone.  @return the chronology in UTC ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "ISOYearOfEraDateTimeField.getMaximumValue",
    "class_name": "org.joda.time.chrono.ISOYearOfEraDateTimeField",
    "signature": "org.joda.time.chrono.ISOYearOfEraDateTimeField.getMaximumValue()",
    "snippet": "    public int getMaximumValue() {\n        return getWrappedField().getMaximumValue();\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "ISOYearOfEraDateTimeField.getMinimumValue",
    "class_name": "org.joda.time.chrono.ISOYearOfEraDateTimeField",
    "signature": "org.joda.time.chrono.ISOYearOfEraDateTimeField.getMinimumValue()",
    "snippet": "    public int getMinimumValue() {\n        return 0;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "ZonedChronology.assemble",
    "class_name": "org.joda.time.chrono.ZonedChronology",
    "signature": "org.joda.time.chrono.ZonedChronology.assemble(Fields)",
    "snippet": "    protected void assemble(Fields fields) {\n        // Keep a local cache of converted fields so as not to create redundant\n        // objects.\n        HashMap<Object, Object> converted = new HashMap<Object, Object>();\n\n        // Convert duration fields...\n\n        fields.eras = convertField(fields.eras, converted);\n        fields.centuries = convertField(fields.centuries, converted);\n        fields.years = convertField(fields.years, converted);\n        fields.months = convertField(fields.months, converted);\n        fields.weekyears = convertField(fields.weekyears, converted);\n        fields.weeks = convertField(fields.weeks, converted);\n        fields.days = convertField(fields.days, converted);\n\n        fields.halfdays = convertField(fields.halfdays, converted);\n        fields.hours = convertField(fields.hours, converted);\n        fields.minutes = convertField(fields.minutes, converted);\n        fields.seconds = convertField(fields.seconds, converted);\n        fields.millis = convertField(fields.millis, converted);\n\n        // Convert datetime fields...\n\n        fields.year = convertField(fields.year, converted);\n        fields.yearOfEra = convertField(fields.yearOfEra, converted);\n        fields.yearOfCentury = convertField(fields.yearOfCentury, converted);\n        fields.centuryOfEra = convertField(fields.centuryOfEra, converted);\n        fields.era = convertField(fields.era, converted);\n        fields.dayOfWeek = convertField(fields.dayOfWeek, converted);\n        fields.dayOfMonth = convertField(fields.dayOfMonth, converted);\n        fields.dayOfYear = convertField(fields.dayOfYear, converted);\n        fields.monthOfYear = convertField(fields.monthOfYear, converted);\n        fields.weekOfWeekyear = convertField(fields.weekOfWeekyear, converted);\n        fields.weekyear = convertField(fields.weekyear, converted);\n        fields.weekyearOfCentury = convertField(fields.weekyearOfCentury, converted);\n\n        fields.millisOfSecond = convertField(fields.millisOfSecond, converted);\n        fields.millisOfDay = convertField(fields.millisOfDay, converted);\n        fields.secondOfMinute = convertField(fields.secondOfMinute, converted);\n        fields.secondOfDay = convertField(fields.secondOfDay, converted);\n        fields.minuteOfHour = convertField(fields.minuteOfHour, converted);\n        fields.minuteOfDay = convertField(fields.minuteOfDay, converted);\n        fields.hourOfDay = convertField(fields.hourOfDay, converted);\n        fields.hourOfHalfday = convertField(fields.hourOfHalfday, converted);\n        fields.clockhourOfDay = convertField(fields.clockhourOfDay, converted);\n        fields.clockhourOfHalfday = convertField(fields.clockhourOfHalfday, converted);\n        fields.halfdayOfDay = convertField(fields.halfdayOfDay, converted);\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "ZonedChronology.convertField",
    "class_name": "org.joda.time.chrono.ZonedChronology",
    "signature": "org.joda.time.chrono.ZonedChronology.convertField(DateTimeField,HashMap)",
    "snippet": "    private DateTimeField convertField(DateTimeField field, HashMap<Object, Object> converted) {\n        if (field == null || !field.isSupported()) {\n            return field;\n        }\n        if (converted.containsKey(field)) {\n            return (DateTimeField)converted.get(field);\n        }\n        ZonedDateTimeField zonedField =\n            new ZonedDateTimeField(field, getZone(),\n                                   convertField(field.getDurationField(), converted),\n                                   convertField(field.getRangeDurationField(), converted),\n                                   convertField(field.getLeapDurationField(), converted));\n        converted.put(field, zonedField);\n        return zonedField;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "ZonedChronology.convertField",
    "class_name": "org.joda.time.chrono.ZonedChronology",
    "signature": "org.joda.time.chrono.ZonedChronology.convertField(DurationField,HashMap)",
    "snippet": "    private DurationField convertField(DurationField field, HashMap<Object, Object> converted) {\n        if (field == null || !field.isSupported()) {\n            return field;\n        }\n        if (converted.containsKey(field)) {\n            return (DurationField)converted.get(field);\n        }\n        ZonedDurationField zonedField = new ZonedDurationField(field, getZone());\n        converted.put(field, zonedField);\n        return zonedField;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "ZonedChronology.getInstance",
    "class_name": "org.joda.time.chrono.ZonedChronology",
    "signature": "org.joda.time.chrono.ZonedChronology.getInstance(Chronology,DateTimeZone)",
    "snippet": "    public static ZonedChronology getInstance(Chronology base, DateTimeZone zone) {\n        if (base == null) {\n            throw new IllegalArgumentException(\"Must supply a chronology\");\n        }\n        base = base.withUTC();\n        if (base == null) {\n            throw new IllegalArgumentException(\"UTC chronology must not be null\");\n        }\n        if (zone == null) {\n            throw new IllegalArgumentException(\"DateTimeZone must not be null\");\n        }\n        return new ZonedChronology(base, zone);\n    }",
    "comment": " Create a ZonedChronology for any chronology, overriding any time zone it may already have.  @param base base chronology to wrap @param zone the time zone @throws IllegalArgumentException if chronology or time zone is null ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "ZonedChronology.getZone",
    "class_name": "org.joda.time.chrono.ZonedChronology",
    "signature": "org.joda.time.chrono.ZonedChronology.getZone()",
    "snippet": "    public DateTimeZone getZone() {\n        return (DateTimeZone)getParam();\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "ZonedChronology.useTimeArithmetic",
    "class_name": "org.joda.time.chrono.ZonedChronology",
    "signature": "org.joda.time.chrono.ZonedChronology.useTimeArithmetic(DurationField)",
    "snippet": "    static boolean useTimeArithmetic(DurationField field) {\n        // Use time of day arithmetic rules for unit durations less than\n        // typical time zone offsets.\n        return field != null && field.getUnitMillis() < DateTimeConstants.MILLIS_PER_HOUR * 12;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "ZonedDurationField.getUnitMillis",
    "class_name": "org.joda.time.chrono.ZonedChronology$ZonedDurationField",
    "signature": "org.joda.time.chrono.ZonedChronology$ZonedDurationField.getUnitMillis()",
    "snippet": "        public long getUnitMillis() {\n            return iField.getUnitMillis();\n        }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "AbstractConverter.AbstractConverter",
    "class_name": "org.joda.time.convert.AbstractConverter",
    "signature": "org.joda.time.convert.AbstractConverter.AbstractConverter()",
    "snippet": "    protected AbstractConverter() {\n        super();\n    }",
    "comment": " Restricted constructor. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "CalendarConverter.CalendarConverter",
    "class_name": "org.joda.time.convert.CalendarConverter",
    "signature": "org.joda.time.convert.CalendarConverter.CalendarConverter()",
    "snippet": "    protected CalendarConverter() {\n        super();\n    }",
    "comment": " Restricted constructor. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "ConverterManager.ConverterManager",
    "class_name": "org.joda.time.convert.ConverterManager",
    "signature": "org.joda.time.convert.ConverterManager.ConverterManager()",
    "snippet": "    protected ConverterManager() {\n        super();\n\n        iInstantConverters = new ConverterSet(new Converter[] {\n            ReadableInstantConverter.INSTANCE,\n            StringConverter.INSTANCE,\n            CalendarConverter.INSTANCE,\n            DateConverter.INSTANCE,\n            LongConverter.INSTANCE,\n            NullConverter.INSTANCE,\n        });\n\n        iPartialConverters = new ConverterSet(new Converter[] {\n            ReadablePartialConverter.INSTANCE,\n            ReadableInstantConverter.INSTANCE,\n            StringConverter.INSTANCE,\n            CalendarConverter.INSTANCE,\n            DateConverter.INSTANCE,\n            LongConverter.INSTANCE,\n            NullConverter.INSTANCE,\n        });\n\n        iDurationConverters = new ConverterSet(new Converter[] {\n            ReadableDurationConverter.INSTANCE,\n            ReadableIntervalConverter.INSTANCE,\n            StringConverter.INSTANCE,\n            LongConverter.INSTANCE,\n            NullConverter.INSTANCE,\n        });\n\n        iPeriodConverters = new ConverterSet(new Converter[] {\n            ReadableDurationConverter.INSTANCE,\n            ReadablePeriodConverter.INSTANCE,\n            ReadableIntervalConverter.INSTANCE,\n            StringConverter.INSTANCE,\n            NullConverter.INSTANCE,\n        });\n\n        iIntervalConverters = new ConverterSet(new Converter[] {\n            ReadableIntervalConverter.INSTANCE,\n            StringConverter.INSTANCE,\n            NullConverter.INSTANCE,\n        });\n    }",
    "comment": " Restricted constructor. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "ConverterManager.getInstance",
    "class_name": "org.joda.time.convert.ConverterManager",
    "signature": "org.joda.time.convert.ConverterManager.getInstance()",
    "snippet": "    public static ConverterManager getInstance() {\n        if (INSTANCE == null) {\n            INSTANCE = new ConverterManager();\n        }\n        return INSTANCE;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "ConverterManager.getPeriodConverter",
    "class_name": "org.joda.time.convert.ConverterManager",
    "signature": "org.joda.time.convert.ConverterManager.getPeriodConverter(Object)",
    "snippet": "    public PeriodConverter getPeriodConverter(Object object) {\n        PeriodConverter converter =\n            (PeriodConverter)iPeriodConverters.select(object == null ? null : object.getClass());\n        if (converter != null) {\n            return converter;\n        }\n        throw new IllegalArgumentException(\"No period converter found for type: \" +\n            (object == null ? \"null\" : object.getClass().getName()));\n    }",
    "comment": " Gets the best converter for the object specified.  @param object  the object to convert @return the converter to use @throws IllegalArgumentException if no suitable converter @throws IllegalStateException if multiple converters match the type equally well ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "ConverterSet.ConverterSet",
    "class_name": "org.joda.time.convert.ConverterSet",
    "signature": "org.joda.time.convert.ConverterSet.ConverterSet(Converter[])",
    "snippet": "    ConverterSet(Converter[] converters) {\n        // Since this is a package private constructor, we trust ourselves not\n        // to alter the array outside this class.\n        iConverters = converters;\n        iSelectEntries = new Entry[1 << 4]; // 16\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "ConverterSet.remove",
    "class_name": "org.joda.time.convert.ConverterSet",
    "signature": "org.joda.time.convert.ConverterSet.remove(int,Converter[])",
    "snippet": "    ConverterSet remove(final int index, Converter[] removed) {\n        Converter[] converters = iConverters;\n        int length = converters.length;\n        if (index >= length) {\n            throw new IndexOutOfBoundsException();\n        }\n\n        if (removed != null) {\n            removed[0] = converters[index];\n        }\n\n        Converter[] copy = new Converter[length - 1];\n                \n        int j = 0;\n        for (int i=0; i<length; i++) {\n            if (i != index) {\n                copy[j++] = converters[i];\n            }\n        }\n        \n        return new ConverterSet(copy);\n    }",
    "comment": " Returns a copy of this set, with the converter at the given index removed.  @param index index of converter to remove @param removed if not null, element 0 is set to the removed converter @throws IndexOutOfBoundsException if the index is invalid ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "ConverterSet.select",
    "class_name": "org.joda.time.convert.ConverterSet",
    "signature": "org.joda.time.convert.ConverterSet.select(Class)",
    "snippet": "    Converter select(Class<?> type) throws IllegalStateException {\n        // Check the hashtable first.\n        Entry[] entries = iSelectEntries;\n        int length = entries.length;\n        int index = type == null ? 0 : type.hashCode() & (length - 1);\n\n        Entry e;\n        // This loop depends on there being at least one null slot.\n        while ((e = entries[index]) != null) {\n            if (e.iType == type) {\n                return e.iConverter;\n            }\n            if (++index >= length) {\n                index = 0;\n            }\n        }\n\n        // Not found in the hashtable, so do actual work.\n\n        Converter converter = selectSlow(this, type);\n        e = new Entry(type, converter);\n\n        // Save the entry for future selects. This class must be threadsafe,\n        // but there is no synchronization. Since the hashtable is being used\n        // as a cache, it is okay to destroy existing entries. This isn't\n        // likely to occur unless there is a high amount of concurrency. As\n        // time goes on, cache updates will occur less often, and the cache\n        // will fill with all the necessary entries.\n\n        // Do all updates on a copy: slots in iSelectEntries must not be\n        // updated by multiple threads as this can allow all null slots to be\n        // consumed.\n        entries = (Entry[])entries.clone();\n\n        // Add new entry.\n        entries[index] = e;\n\n        // Verify that at least one null slot exists!\n        for (int i=0; i<length; i++) {\n            if (entries[i] == null) {\n                // Found a null slot, swap in new hashtable.\n                iSelectEntries = entries;\n                return converter;\n            }\n        }\n\n        // Double capacity and re-hash.\n\n        int newLength = length << 1;\n        Entry[] newEntries = new Entry[newLength];\n        for (int i=0; i<length; i++) {\n            e = entries[i];\n            type = e.iType;\n            index = type == null ? 0 : type.hashCode() & (newLength - 1);\n            while (newEntries[index] != null) {\n                if (++index >= newLength) {\n                    index = 0;\n                }\n            }\n            newEntries[index] = e;\n        }\n\n        // Swap in new hashtable.\n        iSelectEntries = newEntries;\n        return converter;\n    }",
    "comment": " Returns the closest matching converter for the given type, or null if none found.  @param type type to select, which may be null @throws IllegalStateException if multiple converters match the type equally well ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "ConverterSet.selectSlow",
    "class_name": "org.joda.time.convert.ConverterSet",
    "signature": "org.joda.time.convert.ConverterSet.selectSlow(ConverterSet,Class)",
    "snippet": "    private static Converter selectSlow(ConverterSet set, Class<?> type) {\n        Converter[] converters = set.iConverters;\n        int length = converters.length;\n        Converter converter;\n\n        for (int i=length; --i>=0; ) {\n            converter = converters[i];\n            Class<?> supportedType = converter.getSupportedType();\n\n            if (supportedType == type) {\n                // Exact match.\n                return converter;\n            }\n\n            if (supportedType == null || (type != null && !supportedType.isAssignableFrom(type))) {\n                // Eliminate the impossible.\n                set = set.remove(i, null);\n                converters = set.iConverters;\n                length = converters.length;\n            }\n        }\n\n        // Haven't found exact match, so check what remains in the set.\n\n        if (type == null || length == 0) {\n            return null;\n        }\n        if (length == 1) {\n            // Found the one best match.\n            return converters[0];\n        }\n\n        // At this point, there exist multiple potential converters.\n\n        // Eliminate supertypes.\n        for (int i=length; --i>=0; ) {\n            converter = converters[i];\n            Class<?> supportedType = converter.getSupportedType();\n            for (int j=length; --j>=0; ) {\n                if (j != i && converters[j].getSupportedType().isAssignableFrom(supportedType)) {\n                    // Eliminate supertype.\n                    set = set.remove(j, null);\n                    converters = set.iConverters;\n                    length = converters.length;\n                    i = length - 1;\n                }\n            }\n        }        \n        \n        // Check what remains in the set.\n\n        if (length == 1) {\n            // Found the one best match.\n            return converters[0];\n        }\n\n        // Class c implements a, b {}\n        // Converters exist only for a and b. Which is better? Neither.\n\n        StringBuffer msg = new StringBuffer();\n        msg.append(\"Unable to find best converter for type \\\"\");\n        msg.append(type.getName());\n        msg.append(\"\\\" from remaining set: \");\n        for (int i=0; i<length; i++) {\n            converter = converters[i];\n            Class<?> supportedType = converter.getSupportedType();\n\n            msg.append(converter.getClass().getName());\n            msg.append('[');\n            msg.append(supportedType == null ? null : supportedType.getName());\n            msg.append(\"], \");\n        }\n\n        throw new IllegalStateException(msg.toString());\n    }",
    "comment": " Returns the closest matching converter for the given type, but not very efficiently. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "DateConverter.DateConverter",
    "class_name": "org.joda.time.convert.DateConverter",
    "signature": "org.joda.time.convert.DateConverter.DateConverter()",
    "snippet": "    protected DateConverter() {\n        super();\n    }",
    "comment": " Restricted constructor. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "LongConverter.LongConverter",
    "class_name": "org.joda.time.convert.LongConverter",
    "signature": "org.joda.time.convert.LongConverter.LongConverter()",
    "snippet": "    protected LongConverter() {\n        super();\n    }",
    "comment": " Restricted constructor. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "NullConverter.NullConverter",
    "class_name": "org.joda.time.convert.NullConverter",
    "signature": "org.joda.time.convert.NullConverter.NullConverter()",
    "snippet": "    protected NullConverter() {\n        super();\n    }",
    "comment": " Restricted constructor. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "NullConverter.getSupportedType",
    "class_name": "org.joda.time.convert.NullConverter",
    "signature": "org.joda.time.convert.NullConverter.getSupportedType()",
    "snippet": "    public Class<?> getSupportedType() {\n        return null;\n    }",
    "comment": " Returns null.  @return null ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "ReadableDurationConverter.ReadableDurationConverter",
    "class_name": "org.joda.time.convert.ReadableDurationConverter",
    "signature": "org.joda.time.convert.ReadableDurationConverter.ReadableDurationConverter()",
    "snippet": "    protected ReadableDurationConverter() {\n        super();\n    }",
    "comment": " Restricted constructor. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "ReadableDurationConverter.getSupportedType",
    "class_name": "org.joda.time.convert.ReadableDurationConverter",
    "signature": "org.joda.time.convert.ReadableDurationConverter.getSupportedType()",
    "snippet": "    public Class<?> getSupportedType() {\n        return ReadableDuration.class;\n    }",
    "comment": " Returns ReadableDuration.class.  @return ReadableDuration.class ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "ReadableInstantConverter.ReadableInstantConverter",
    "class_name": "org.joda.time.convert.ReadableInstantConverter",
    "signature": "org.joda.time.convert.ReadableInstantConverter.ReadableInstantConverter()",
    "snippet": "    protected ReadableInstantConverter() {\n        super();\n    }",
    "comment": " Restricted constructor. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "ReadableIntervalConverter.ReadableIntervalConverter",
    "class_name": "org.joda.time.convert.ReadableIntervalConverter",
    "signature": "org.joda.time.convert.ReadableIntervalConverter.ReadableIntervalConverter()",
    "snippet": "    protected ReadableIntervalConverter() {\n        super();\n    }",
    "comment": " Restricted constructor. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "ReadableIntervalConverter.getSupportedType",
    "class_name": "org.joda.time.convert.ReadableIntervalConverter",
    "signature": "org.joda.time.convert.ReadableIntervalConverter.getSupportedType()",
    "snippet": "    public Class<?> getSupportedType() {\n        return ReadableInterval.class;\n    }",
    "comment": " Returns ReadableInterval.class. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "ReadablePartialConverter.ReadablePartialConverter",
    "class_name": "org.joda.time.convert.ReadablePartialConverter",
    "signature": "org.joda.time.convert.ReadablePartialConverter.ReadablePartialConverter()",
    "snippet": "    protected ReadablePartialConverter() {\n        super();\n    }",
    "comment": " Restricted constructor. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "ReadablePeriodConverter.ReadablePeriodConverter",
    "class_name": "org.joda.time.convert.ReadablePeriodConverter",
    "signature": "org.joda.time.convert.ReadablePeriodConverter.ReadablePeriodConverter()",
    "snippet": "    protected ReadablePeriodConverter() {\n        super();\n    }",
    "comment": " Restricted constructor. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "ReadablePeriodConverter.getPeriodType",
    "class_name": "org.joda.time.convert.ReadablePeriodConverter",
    "signature": "org.joda.time.convert.ReadablePeriodConverter.getPeriodType(Object)",
    "snippet": "    public PeriodType getPeriodType(Object object) {\n        ReadablePeriod period = (ReadablePeriod) object;\n        return period.getPeriodType();\n    }",
    "comment": " Selects a suitable period type for the given object.  @param object  the object to examine, must not be null @return the period type from the readable duration @throws NullPointerException if the object is null @throws ClassCastException if the object is an invalid type ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "ReadablePeriodConverter.getSupportedType",
    "class_name": "org.joda.time.convert.ReadablePeriodConverter",
    "signature": "org.joda.time.convert.ReadablePeriodConverter.getSupportedType()",
    "snippet": "    public Class<?> getSupportedType() {\n        return ReadablePeriod.class;\n    }",
    "comment": " Returns ReadablePeriod class.  @return ReadablePeriod.class ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "ReadablePeriodConverter.setInto",
    "class_name": "org.joda.time.convert.ReadablePeriodConverter",
    "signature": "org.joda.time.convert.ReadablePeriodConverter.setInto(ReadWritablePeriod,Object,Chronology)",
    "snippet": "    public void setInto(ReadWritablePeriod duration, Object object, Chronology chrono) {\n        duration.setPeriod((ReadablePeriod) object);\n    }",
    "comment": " Extracts duration values from an object of this converter's type, and sets them into the given ReadWritablePeriod.  @param duration duration to get modified @param object  the object to convert, must not be null @param chrono  the chronology to use @throws NullPointerException if the duration or object is null @throws ClassCastException if the object is an invalid type @throws IllegalArgumentException if the object is invalid ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "StringConverter.StringConverter",
    "class_name": "org.joda.time.convert.StringConverter",
    "signature": "org.joda.time.convert.StringConverter.StringConverter()",
    "snippet": "    protected StringConverter() {\n        super();\n    }",
    "comment": " Restricted constructor. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "StringConverter.getSupportedType",
    "class_name": "org.joda.time.convert.StringConverter",
    "signature": "org.joda.time.convert.StringConverter.getSupportedType()",
    "snippet": "    public Class<?> getSupportedType() {\n        return String.class;\n    }",
    "comment": " Returns String.class.  @return String.class ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "BaseDateTimeField.BaseDateTimeField",
    "class_name": "org.joda.time.field.BaseDateTimeField",
    "signature": "org.joda.time.field.BaseDateTimeField.BaseDateTimeField(DateTimeFieldType)",
    "snippet": "    protected BaseDateTimeField(DateTimeFieldType type) {\n        super();\n        if (type == null) {\n            throw new IllegalArgumentException(\"The type must not be null\");\n        }\n        iType = type;\n    }",
    "comment": " Constructor. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "BaseDateTimeField.getLeapDurationField",
    "class_name": "org.joda.time.field.BaseDateTimeField",
    "signature": "org.joda.time.field.BaseDateTimeField.getLeapDurationField()",
    "snippet": "    public DurationField getLeapDurationField() {\n        return null;\n    }",
    "comment": " If this field were to leap, then it would be in units described by the returned duration. If this field doesn't ever leap, null is returned. <p> This implementation returns null. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "BaseDateTimeField.getType",
    "class_name": "org.joda.time.field.BaseDateTimeField",
    "signature": "org.joda.time.field.BaseDateTimeField.getType()",
    "snippet": "    public final DateTimeFieldType getType() {\n        return iType;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "BaseDateTimeField.isSupported",
    "class_name": "org.joda.time.field.BaseDateTimeField",
    "signature": "org.joda.time.field.BaseDateTimeField.isSupported()",
    "snippet": "    public final boolean isSupported() {\n        return true;\n    }",
    "comment": " @return true always ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "BaseDurationField.BaseDurationField",
    "class_name": "org.joda.time.field.BaseDurationField",
    "signature": "org.joda.time.field.BaseDurationField.BaseDurationField(DurationFieldType)",
    "snippet": "    protected BaseDurationField(DurationFieldType type) {\n        super();\n        if (type == null) {\n            throw new IllegalArgumentException(\"The type must not be null\");\n        }\n        iType = type;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "BaseDurationField.getType",
    "class_name": "org.joda.time.field.BaseDurationField",
    "signature": "org.joda.time.field.BaseDurationField.getType()",
    "snippet": "    public final DurationFieldType getType() {\n        return iType;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "BaseDurationField.isSupported",
    "class_name": "org.joda.time.field.BaseDurationField",
    "signature": "org.joda.time.field.BaseDurationField.isSupported()",
    "snippet": "    public final boolean isSupported() {\n        return true;\n    }",
    "comment": " @return true always ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "DecoratedDateTimeField.DecoratedDateTimeField",
    "class_name": "org.joda.time.field.DecoratedDateTimeField",
    "signature": "org.joda.time.field.DecoratedDateTimeField.DecoratedDateTimeField(DateTimeField,DateTimeFieldType)",
    "snippet": "    protected DecoratedDateTimeField(DateTimeField field, DateTimeFieldType type) {\n        super(type);\n        if (field == null) {\n            throw new IllegalArgumentException(\"The field must not be null\");\n        }\n        if (!field.isSupported()) {\n            throw new IllegalArgumentException(\"The field must be supported\");\n        }\n        iField = field;\n    }",
    "comment": " Constructor.  @param field  the field being decorated @param type  allow type to be overridden ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "DecoratedDateTimeField.getDurationField",
    "class_name": "org.joda.time.field.DecoratedDateTimeField",
    "signature": "org.joda.time.field.DecoratedDateTimeField.getDurationField()",
    "snippet": "    public DurationField getDurationField() {\n        return iField.getDurationField();\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "DecoratedDateTimeField.getRangeDurationField",
    "class_name": "org.joda.time.field.DecoratedDateTimeField",
    "signature": "org.joda.time.field.DecoratedDateTimeField.getRangeDurationField()",
    "snippet": "    public DurationField getRangeDurationField() {\n        return iField.getRangeDurationField();\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "DecoratedDateTimeField.getWrappedField",
    "class_name": "org.joda.time.field.DecoratedDateTimeField",
    "signature": "org.joda.time.field.DecoratedDateTimeField.getWrappedField()",
    "snippet": "    public final DateTimeField getWrappedField() {\n        return iField;\n    }",
    "comment": " Gets the wrapped date time field.  @return the wrapped DateTimeField ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "DecoratedDurationField.DecoratedDurationField",
    "class_name": "org.joda.time.field.DecoratedDurationField",
    "signature": "org.joda.time.field.DecoratedDurationField.DecoratedDurationField(DurationField,DurationFieldType)",
    "snippet": "    public DecoratedDurationField(DurationField field, DurationFieldType type) {\n        super(type);\n        if (field == null) {\n            throw new IllegalArgumentException(\"The field must not be null\");\n        }\n        if (!field.isSupported()) {\n            throw new IllegalArgumentException(\"The field must be supported\");\n        }\n        iField = field;\n    }",
    "comment": " Constructor.  @param field  the base field @param type  the type to actually use ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "DecoratedDurationField.getWrappedField",
    "class_name": "org.joda.time.field.DecoratedDurationField",
    "signature": "org.joda.time.field.DecoratedDurationField.getWrappedField()",
    "snippet": "    public final DurationField getWrappedField() {\n        return iField;\n    }",
    "comment": " Gets the wrapped duration field.  @return the wrapped DurationField ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "DividedDateTimeField.DividedDateTimeField",
    "class_name": "org.joda.time.field.DividedDateTimeField",
    "signature": "org.joda.time.field.DividedDateTimeField.DividedDateTimeField(DateTimeField,DateTimeFieldType,int)",
    "snippet": "    public DividedDateTimeField(DateTimeField field,\n                                DateTimeFieldType type, int divisor) {\n        super(field, type);\n                \n        if (divisor < 2) {\n            throw new IllegalArgumentException(\"The divisor must be at least 2\");\n        }\n\n        DurationField unitField = field.getDurationField();\n        if (unitField == null) {\n            iDurationField = null;\n        } else {\n            iDurationField = new ScaledDurationField(\n                unitField, type.getDurationType(), divisor);\n        }\n\n        iDivisor = divisor;\n\n        int i = field.getMinimumValue();\n        int min = (i >= 0) ? i / divisor : ((i + 1) / divisor - 1);\n\n        int j = field.getMaximumValue();\n        int max = (j >= 0) ? j / divisor : ((j + 1) / divisor - 1);\n\n        iMin = min;\n        iMax = max;\n    }",
    "comment": " Constructor.  @param field  the field to wrap, like \"year()\". @param type  the field type this field will actually use @param divisor  divisor, such as 100 years in a century @throws IllegalArgumentException if divisor is less than two ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "DividedDateTimeField.getDurationField",
    "class_name": "org.joda.time.field.DividedDateTimeField",
    "signature": "org.joda.time.field.DividedDateTimeField.getDurationField()",
    "snippet": "    public DurationField getDurationField() {\n        return iDurationField;\n    }",
    "comment": " Returns a scaled version of the wrapped field's unit duration field. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "ImpreciseDateTimeField.ImpreciseDateTimeField",
    "class_name": "org.joda.time.field.ImpreciseDateTimeField",
    "signature": "org.joda.time.field.ImpreciseDateTimeField.ImpreciseDateTimeField(DateTimeFieldType,long)",
    "snippet": "    public ImpreciseDateTimeField(DateTimeFieldType type, long unitMillis) {\n        super(type);\n        iUnitMillis = unitMillis;\n        iDurationField = new LinkedDurationField(type.getDurationType());\n    }",
    "comment": " Constructor.  @param type  the field type @param unitMillis  the average duration unit milliseconds ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "ImpreciseDateTimeField.getDurationField",
    "class_name": "org.joda.time.field.ImpreciseDateTimeField",
    "signature": "org.joda.time.field.ImpreciseDateTimeField.getDurationField()",
    "snippet": "    public final DurationField getDurationField() {\n        return iDurationField;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "LinkedDurationField.getUnitMillis",
    "class_name": "org.joda.time.field.ImpreciseDateTimeField$LinkedDurationField",
    "signature": "org.joda.time.field.ImpreciseDateTimeField$LinkedDurationField.getUnitMillis()",
    "snippet": "        public long getUnitMillis() {\n            return iUnitMillis;\n        }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "MillisDurationField.getType",
    "class_name": "org.joda.time.field.MillisDurationField",
    "signature": "org.joda.time.field.MillisDurationField.getType()",
    "snippet": "    public DurationFieldType getType() {\n        return DurationFieldType.millis();\n    }",
    "comment": "------------------------------------------------------------------------",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "MillisDurationField.getUnitMillis",
    "class_name": "org.joda.time.field.MillisDurationField",
    "signature": "org.joda.time.field.MillisDurationField.getUnitMillis()",
    "snippet": "    public final long getUnitMillis() {\n        return 1;\n    }",
    "comment": " Returns the amount of milliseconds per unit value of this field.  @return one always ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "MillisDurationField.isPrecise",
    "class_name": "org.joda.time.field.MillisDurationField",
    "signature": "org.joda.time.field.MillisDurationField.isPrecise()",
    "snippet": "    public final boolean isPrecise() {\n        return true;\n    }",
    "comment": " Returns true as this field is precise.  @return true always ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "MillisDurationField.isSupported",
    "class_name": "org.joda.time.field.MillisDurationField",
    "signature": "org.joda.time.field.MillisDurationField.isSupported()",
    "snippet": "    public boolean isSupported() {\n        return true;\n    }",
    "comment": " Returns true as this field is supported.  @return true always ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "OffsetDateTimeField.OffsetDateTimeField",
    "class_name": "org.joda.time.field.OffsetDateTimeField",
    "signature": "org.joda.time.field.OffsetDateTimeField.OffsetDateTimeField(DateTimeField,DateTimeFieldType,int)",
    "snippet": "    public OffsetDateTimeField(DateTimeField field, DateTimeFieldType type, int offset) {\n        this(field, type, offset, Integer.MIN_VALUE, Integer.MAX_VALUE);\n    }",
    "comment": " Constructor.  @param field  the field to wrap, like \"year()\". @param type  the field type this field actually uses @param offset  offset to add to field values @throws IllegalArgumentException if offset is zero ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "OffsetDateTimeField.OffsetDateTimeField",
    "class_name": "org.joda.time.field.OffsetDateTimeField",
    "signature": "org.joda.time.field.OffsetDateTimeField.OffsetDateTimeField(DateTimeField,DateTimeFieldType,int,int,int)",
    "snippet": "    public OffsetDateTimeField(DateTimeField field, DateTimeFieldType type, int offset,\n                               int minValue, int maxValue) {\n        super(field, type);\n                \n        if (offset == 0) {\n            throw new IllegalArgumentException(\"The offset cannot be zero\");\n        }\n\n        iOffset = offset;\n\n        if (minValue < (field.getMinimumValue() + offset)) {\n            iMin = field.getMinimumValue() + offset;\n        } else {\n            iMin = minValue;\n        }\n        if (maxValue > (field.getMaximumValue() + offset)) {\n            iMax = field.getMaximumValue() + offset;\n        } else {\n            iMax = maxValue;\n        }\n    }",
    "comment": " Constructor.  @param field  the field to wrap, like \"year()\". @param type  the field type this field actually uses @param offset  offset to add to field values @param minValue  minimum allowed value @param maxValue  maximum allowed value @throws IllegalArgumentException if offset is zero ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "OffsetDateTimeField.OffsetDateTimeField",
    "class_name": "org.joda.time.field.OffsetDateTimeField",
    "signature": "org.joda.time.field.OffsetDateTimeField.OffsetDateTimeField(DateTimeField,int)",
    "snippet": "    public OffsetDateTimeField(DateTimeField field, int offset) {\n        this(field, (field == null ? null : field.getType()), offset, Integer.MIN_VALUE, Integer.MAX_VALUE);\n    }",
    "comment": " Constructor.  @param field  the field to wrap, like \"year()\". @param offset  offset to add to field values @throws IllegalArgumentException if offset is zero ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "OffsetDateTimeField.getMaximumValue",
    "class_name": "org.joda.time.field.OffsetDateTimeField",
    "signature": "org.joda.time.field.OffsetDateTimeField.getMaximumValue()",
    "snippet": "    public int getMaximumValue() {\n        return iMax;\n    }",
    "comment": " Get the maximum value for the field.  @return the maximum value ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "OffsetDateTimeField.getMinimumValue",
    "class_name": "org.joda.time.field.OffsetDateTimeField",
    "signature": "org.joda.time.field.OffsetDateTimeField.getMinimumValue()",
    "snippet": "    public int getMinimumValue() {\n        return iMin;\n    }",
    "comment": " Get the minimum value for the field.  @return the minimum value ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "PreciseDateTimeField.PreciseDateTimeField",
    "class_name": "org.joda.time.field.PreciseDateTimeField",
    "signature": "org.joda.time.field.PreciseDateTimeField.PreciseDateTimeField(DateTimeFieldType,DurationField,DurationField)",
    "snippet": "    public PreciseDateTimeField(DateTimeFieldType type,\n                                DurationField unit, DurationField range) {\n        super(type, unit);\n\n        if (!range.isPrecise()) {\n            throw new IllegalArgumentException(\"Range duration field must be precise\");\n        }\n\n        long rangeMillis = range.getUnitMillis();\n        iRange = (int)(rangeMillis / getUnitMillis());\n        if (iRange < 2) {\n            throw new IllegalArgumentException(\"The effective range must be at least 2\");\n        }\n\n        iRangeField = range;\n    }",
    "comment": " Constructor.  @param type  the field type this field uses @param unit  precise unit duration, like \"seconds()\". @param range precise range duration, preferably a multiple of the unit, like \"minutes()\". @throws IllegalArgumentException if either duration field is imprecise @throws IllegalArgumentException if unit milliseconds is less than one or effective value range is less than two. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "PreciseDateTimeField.getRangeDurationField",
    "class_name": "org.joda.time.field.PreciseDateTimeField",
    "signature": "org.joda.time.field.PreciseDateTimeField.getRangeDurationField()",
    "snippet": "    public DurationField getRangeDurationField() {\n        return iRangeField;\n    }",
    "comment": " Returns the range duration of this field. For example, if this field represents \"minute of hour\", then the range duration field is an hours.  @return the range duration of this field, or null if field has no range ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "PreciseDurationDateTimeField.PreciseDurationDateTimeField",
    "class_name": "org.joda.time.field.PreciseDurationDateTimeField",
    "signature": "org.joda.time.field.PreciseDurationDateTimeField.PreciseDurationDateTimeField(DateTimeFieldType,DurationField)",
    "snippet": "    public PreciseDurationDateTimeField(DateTimeFieldType type, DurationField unit) {\n        super(type);\n\n        if (!unit.isPrecise()) {\n            throw new IllegalArgumentException(\"Unit duration field must be precise\");\n        }\n\n        iUnitMillis = unit.getUnitMillis();\n        if (iUnitMillis < 1) {\n            throw new IllegalArgumentException(\"The unit milliseconds must be at least 1\");\n        }\n\n        iUnitField = unit;\n    }",
    "comment": " Constructor.  @param type  the field type @param unit  precise unit duration, like \"days()\". @throws IllegalArgumentException if duration field is imprecise @throws IllegalArgumentException if unit milliseconds is less than one ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "PreciseDurationDateTimeField.getDurationField",
    "class_name": "org.joda.time.field.PreciseDurationDateTimeField",
    "signature": "org.joda.time.field.PreciseDurationDateTimeField.getDurationField()",
    "snippet": "    public DurationField getDurationField() {\n        return iUnitField;\n    }",
    "comment": " Returns the duration per unit value of this field. For example, if this field represents \"minute of hour\", then the duration field is minutes.  @return the duration of this field, or UnsupportedDurationField if field has no duration ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "PreciseDurationDateTimeField.getMinimumValue",
    "class_name": "org.joda.time.field.PreciseDurationDateTimeField",
    "signature": "org.joda.time.field.PreciseDurationDateTimeField.getMinimumValue()",
    "snippet": "    public int getMinimumValue() {\n        return 0;\n    }",
    "comment": " Get the minimum value for the field.  @return the minimum value ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "PreciseDurationDateTimeField.getUnitMillis",
    "class_name": "org.joda.time.field.PreciseDurationDateTimeField",
    "signature": "org.joda.time.field.PreciseDurationDateTimeField.getUnitMillis()",
    "snippet": "    public final long getUnitMillis() {\n        return iUnitMillis;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "PreciseDurationField.PreciseDurationField",
    "class_name": "org.joda.time.field.PreciseDurationField",
    "signature": "org.joda.time.field.PreciseDurationField.PreciseDurationField(DurationFieldType,long)",
    "snippet": "    public PreciseDurationField(DurationFieldType type, long unitMillis) {\n        super(type);\n        iUnitMillis = unitMillis;\n    }",
    "comment": " Constructor.  @param type  the field type @param unitMillis  the unit milliseconds ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "PreciseDurationField.getUnitMillis",
    "class_name": "org.joda.time.field.PreciseDurationField",
    "signature": "org.joda.time.field.PreciseDurationField.getUnitMillis()",
    "snippet": "    public final long getUnitMillis() {\n        return iUnitMillis;\n    }",
    "comment": " Returns the amount of milliseconds per unit value of this field.  @return the unit size of this field, in milliseconds ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "PreciseDurationField.hashCode",
    "class_name": "org.joda.time.field.PreciseDurationField",
    "signature": "org.joda.time.field.PreciseDurationField.hashCode()",
    "snippet": "    public int hashCode() {\n        long millis = iUnitMillis;\n        int hash = (int) (millis ^ (millis >>> 32));\n        hash += getType().hashCode();\n        return hash;\n    }",
    "comment": " Gets a hash code for this instance.  @return a suitable hashcode ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "PreciseDurationField.isPrecise",
    "class_name": "org.joda.time.field.PreciseDurationField",
    "signature": "org.joda.time.field.PreciseDurationField.isPrecise()",
    "snippet": "    public final boolean isPrecise() {\n        return true;\n    }",
    "comment": " This field is precise.  @return true always ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "RemainderDateTimeField.RemainderDateTimeField",
    "class_name": "org.joda.time.field.RemainderDateTimeField",
    "signature": "org.joda.time.field.RemainderDateTimeField.RemainderDateTimeField(DateTimeField,DateTimeFieldType,int)",
    "snippet": "    public RemainderDateTimeField(DateTimeField field,\n                                  DateTimeFieldType type, int divisor) {\n        super(field, type);\n\n        if (divisor < 2) {\n            throw new IllegalArgumentException(\"The divisor must be at least 2\");\n        }\n\n        DurationField rangeField = field.getDurationField();\n        if (rangeField == null) {\n            iRangeField = null;\n        } else {\n            iRangeField = new ScaledDurationField(\n                rangeField, type.getRangeDurationType(), divisor);\n        }\n\n        iDivisor = divisor;\n    }",
    "comment": " Constructor.  @param field  the field to wrap, like \"year()\". @param type  the field type this field actually uses @param divisor  divisor, such as 100 years in a century @throws IllegalArgumentException if divisor is less than two ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "RemainderDateTimeField.RemainderDateTimeField",
    "class_name": "org.joda.time.field.RemainderDateTimeField",
    "signature": "org.joda.time.field.RemainderDateTimeField.RemainderDateTimeField(DividedDateTimeField)",
    "snippet": "    public RemainderDateTimeField(DividedDateTimeField dividedField) {\n        this(dividedField, dividedField.getType());\n    }",
    "comment": " Construct a RemainderDateTimeField that compliments the given DividedDateTimeField.  @param dividedField  complimentary divided field, like \"century()\". ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "RemainderDateTimeField.RemainderDateTimeField",
    "class_name": "org.joda.time.field.RemainderDateTimeField",
    "signature": "org.joda.time.field.RemainderDateTimeField.RemainderDateTimeField(DividedDateTimeField,DateTimeFieldType)",
    "snippet": "    public RemainderDateTimeField(DividedDateTimeField dividedField, DateTimeFieldType type) {\n        super(dividedField.getWrappedField(), type);\n        iDivisor = dividedField.iDivisor;\n        iRangeField = dividedField.iDurationField;\n    }",
    "comment": " Construct a RemainderDateTimeField that compliments the given DividedDateTimeField.  @param dividedField  complimentary divided field, like \"century()\". @param type  the field type this field actually uses ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "RemainderDateTimeField.getMaximumValue",
    "class_name": "org.joda.time.field.RemainderDateTimeField",
    "signature": "org.joda.time.field.RemainderDateTimeField.getMaximumValue()",
    "snippet": "    public int getMaximumValue() {\n        return iDivisor - 1;\n    }",
    "comment": " Get the maximum value for the field, which is always one less than the divisor.  @return the maximum value ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "RemainderDateTimeField.getMinimumValue",
    "class_name": "org.joda.time.field.RemainderDateTimeField",
    "signature": "org.joda.time.field.RemainderDateTimeField.getMinimumValue()",
    "snippet": "    public int getMinimumValue() {\n        return 0;\n    }",
    "comment": " Get the minimum value for the field, which is always zero.  @return the minimum value of zero. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "RemainderDateTimeField.getRangeDurationField",
    "class_name": "org.joda.time.field.RemainderDateTimeField",
    "signature": "org.joda.time.field.RemainderDateTimeField.getRangeDurationField()",
    "snippet": "    public DurationField getRangeDurationField() {\n        return iRangeField;\n    }",
    "comment": " Returns a scaled version of the wrapped field's unit duration field. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "ScaledDurationField.ScaledDurationField",
    "class_name": "org.joda.time.field.ScaledDurationField",
    "signature": "org.joda.time.field.ScaledDurationField.ScaledDurationField(DurationField,DurationFieldType,int)",
    "snippet": "    public ScaledDurationField(DurationField field, DurationFieldType type, int scalar) {\n        super(field, type);\n        if (scalar == 0 || scalar == 1) {\n            throw new IllegalArgumentException(\"The scalar must not be 0 or 1\");\n        }\n        iScalar = scalar;\n    }",
    "comment": " Constructor  @param field  the field to wrap, like \"year()\". @param type  the type this field will actually use @param scalar  scalar, such as 100 years in a century @throws IllegalArgumentException if scalar is zero or one. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "ScaledDurationField.getUnitMillis",
    "class_name": "org.joda.time.field.ScaledDurationField",
    "signature": "org.joda.time.field.ScaledDurationField.getUnitMillis()",
    "snippet": "    public long getUnitMillis() {\n        return getWrappedField().getUnitMillis() * iScalar;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "ScaledDurationField.hashCode",
    "class_name": "org.joda.time.field.ScaledDurationField",
    "signature": "org.joda.time.field.ScaledDurationField.hashCode()",
    "snippet": "    public int hashCode() {\n        long scalar = iScalar;\n        int hash = (int) (scalar ^ (scalar >>> 32));\n        hash += getType().hashCode();\n        hash += getWrappedField().hashCode();\n        return hash;\n    }",
    "comment": " Gets a hash code for this instance.  @return a suitable hashcode ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "UnsupportedDurationField.getInstance",
    "class_name": "org.joda.time.field.UnsupportedDurationField",
    "signature": "org.joda.time.field.UnsupportedDurationField.getInstance(DurationFieldType)",
    "snippet": "    public static synchronized UnsupportedDurationField getInstance(DurationFieldType type) {\n        UnsupportedDurationField field;\n        if (cCache == null) {\n            cCache = new HashMap<DurationFieldType, UnsupportedDurationField>(7);\n            field = null;\n        } else {\n            field = cCache.get(type);\n        }\n        if (field == null) {\n            field = new UnsupportedDurationField(type);\n            cCache.put(type, field);\n        }\n        return field;\n    }",
    "comment": " Gets an instance of UnsupportedDurationField for a specific named field. The returned instance is cached.  @param type  the type to obtain @return the instance ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "UnsupportedDurationField.getUnitMillis",
    "class_name": "org.joda.time.field.UnsupportedDurationField",
    "signature": "org.joda.time.field.UnsupportedDurationField.getUnitMillis()",
    "snippet": "    public long getUnitMillis() {\n        return 0;\n    }",
    "comment": " Always returns zero.  @return zero always ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "UnsupportedDurationField.isSupported",
    "class_name": "org.joda.time.field.UnsupportedDurationField",
    "signature": "org.joda.time.field.UnsupportedDurationField.isSupported()",
    "snippet": "    public boolean isSupported() {\n        return false;\n    }",
    "comment": " This field is not supported.  @return false always ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "ZeroIsMaxDateTimeField.ZeroIsMaxDateTimeField",
    "class_name": "org.joda.time.field.ZeroIsMaxDateTimeField",
    "signature": "org.joda.time.field.ZeroIsMaxDateTimeField.ZeroIsMaxDateTimeField(DateTimeField,DateTimeFieldType)",
    "snippet": "    public ZeroIsMaxDateTimeField(DateTimeField field, DateTimeFieldType type) {\n        super(field, type);\n        if (field.getMinimumValue() != 0) {\n            throw new IllegalArgumentException(\"Wrapped field's minumum value must be zero\");\n        }\n    }",
    "comment": " Constructor.  @param field  the base field @param type  the field type this field will actually use @throws IllegalArgumentException if wrapped field's minimum value is not zero ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "ZeroIsMaxDateTimeField.getLeapDurationField",
    "class_name": "org.joda.time.field.ZeroIsMaxDateTimeField",
    "signature": "org.joda.time.field.ZeroIsMaxDateTimeField.getLeapDurationField()",
    "snippet": "    public DurationField getLeapDurationField() {\n        return getWrappedField().getLeapDurationField();\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "FormatUtils.createErrorMessage",
    "class_name": "org.joda.time.format.FormatUtils",
    "signature": "org.joda.time.format.FormatUtils.createErrorMessage(String,int)",
    "snippet": "    static String createErrorMessage(final String text, final int errorPos) {\n        int sampleLen = errorPos + 32;\n        String sampleText;\n        if (text.length() <= sampleLen + 3) {\n            sampleText = text;\n        } else {\n            sampleText = text.substring(0, sampleLen).concat(\"...\");\n        }\n        \n        if (errorPos <= 0) {\n            return \"Invalid format: \\\"\" + sampleText + '\"';\n        }\n        \n        if (errorPos >= text.length()) {\n            return \"Invalid format: \\\"\" + sampleText + \"\\\" is too short\";\n        }\n        \n        return \"Invalid format: \\\"\" + sampleText + \"\\\" is malformed at \\\"\" +\n            sampleText.substring(errorPos) + '\"';\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "ISOPeriodFormat.standard",
    "class_name": "org.joda.time.format.ISOPeriodFormat",
    "signature": "org.joda.time.format.ISOPeriodFormat.standard()",
    "snippet": "    public static PeriodFormatter standard() {\n        if (cStandard == null) {\n            cStandard = new PeriodFormatterBuilder()\n                .appendLiteral(\"P\")\n                .appendYears()\n                .appendSuffix(\"Y\")\n                .appendMonths()\n                .appendSuffix(\"M\")\n                .appendWeeks()\n                .appendSuffix(\"W\")\n                .appendDays()\n                .appendSuffix(\"D\")\n                .appendSeparatorIfFieldsAfter(\"T\")\n                .appendHours()\n                .appendSuffix(\"H\")\n                .appendMinutes()\n                .appendSuffix(\"M\")\n                .appendSecondsWithOptionalMillis()\n                .appendSuffix(\"S\")\n                .toFormatter();\n        }\n        return cStandard;\n    }",
    "comment": " The standard ISO format - PyYmMwWdDThHmMsS. Milliseconds are not output. Note that the ISO8601 standard actually indicates weeks should not be shown if any other field is present and vice versa.  @return the formatter ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "PeriodFormatter.PeriodFormatter",
    "class_name": "org.joda.time.format.PeriodFormatter",
    "signature": "org.joda.time.format.PeriodFormatter.PeriodFormatter(PeriodPrinter,PeriodParser)",
    "snippet": "    public PeriodFormatter(\n            PeriodPrinter printer, PeriodParser parser) {\n        super();\n        iPrinter = printer;\n        iParser = parser;\n        iLocale = null;\n        iParseType = null;\n    }",
    "comment": " Creates a new formatter, however you will normally use the factory or the builder.  @param printer  the internal printer, null if cannot print @param parser  the internal parser, null if cannot parse ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "PeriodFormatter.checkParser",
    "class_name": "org.joda.time.format.PeriodFormatter",
    "signature": "org.joda.time.format.PeriodFormatter.checkParser()",
    "snippet": "    private void checkParser() {\n        if (iParser == null) {\n            throw new UnsupportedOperationException(\"Parsing not supported\");\n        }\n    }",
    "comment": " Checks whether parsing is supported.  @throws UnsupportedOperationException if parsing is not supported ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "PeriodFormatter.getParser",
    "class_name": "org.joda.time.format.PeriodFormatter",
    "signature": "org.joda.time.format.PeriodFormatter.getParser()",
    "snippet": "    public PeriodParser getParser() {\n        return iParser;\n    }",
    "comment": " Gets the internal parser object that performs the real parsing work.  @return the internal parser ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "PeriodFormatter.getPrinter",
    "class_name": "org.joda.time.format.PeriodFormatter",
    "signature": "org.joda.time.format.PeriodFormatter.getPrinter()",
    "snippet": "    public PeriodPrinter getPrinter() {\n        return iPrinter;\n    }",
    "comment": " Gets the internal printer object that performs the real printing work.  @return the internal printer ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "PeriodFormatter.parseMutablePeriod",
    "class_name": "org.joda.time.format.PeriodFormatter",
    "signature": "org.joda.time.format.PeriodFormatter.parseMutablePeriod(String)",
    "snippet": "    public MutablePeriod parseMutablePeriod(String text) {\n        checkParser();\n        \n        MutablePeriod period = new MutablePeriod(0, iParseType);\n        int newPos = getParser().parseInto(period, text, 0, iLocale);\n        if (newPos >= 0) {\n            if (newPos >= text.length()) {\n                return period;\n            }\n        } else {\n            newPos = ~newPos;\n        }\n        throw new IllegalArgumentException(FormatUtils.createErrorMessage(text, newPos));\n    }",
    "comment": " Parses a period from the given text, returning a new MutablePeriod.  @param text  text to parse @return parsed value in a MutablePeriod object @throws IllegalArgumentException if any field is out of range ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "PeriodFormatter.parsePeriod",
    "class_name": "org.joda.time.format.PeriodFormatter",
    "signature": "org.joda.time.format.PeriodFormatter.parsePeriod(String)",
    "snippet": "    public Period parsePeriod(String text) {\n        checkParser();\n        \n        return parseMutablePeriod(text).toPeriod();\n    }",
    "comment": " Parses a period from the given text, returning a new Period.  @param text  text to parse @return parsed value in a Period object @throws IllegalArgumentException if any field is out of range ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "PeriodFormatterBuilder.PeriodFormatterBuilder",
    "class_name": "org.joda.time.format.PeriodFormatterBuilder",
    "signature": "org.joda.time.format.PeriodFormatterBuilder.PeriodFormatterBuilder()",
    "snippet": "    public PeriodFormatterBuilder() {\n        clear();\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "PeriodFormatterBuilder.append",
    "class_name": "org.joda.time.format.PeriodFormatterBuilder",
    "signature": "org.joda.time.format.PeriodFormatterBuilder.append(PeriodFormatter)",
    "snippet": "    public PeriodFormatterBuilder append(PeriodFormatter formatter) {\n        if (formatter == null) {\n            throw new IllegalArgumentException(\"No formatter supplied\");\n        }\n        clearPrefix();\n        append0(formatter.getPrinter(), formatter.getParser());\n        return this;\n    }",
    "comment": " Appends another formatter.  @return this PeriodFormatterBuilder ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "PeriodFormatterBuilder.append0",
    "class_name": "org.joda.time.format.PeriodFormatterBuilder",
    "signature": "org.joda.time.format.PeriodFormatterBuilder.append0(PeriodPrinter,PeriodParser)",
    "snippet": "    private PeriodFormatterBuilder append0(PeriodPrinter printer, PeriodParser parser) {\n        iElementPairs.add(printer);\n        iElementPairs.add(parser);\n        iNotPrinter |= (printer == null);\n        iNotParser |= (parser == null);\n        return this;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "PeriodFormatterBuilder.appendDays",
    "class_name": "org.joda.time.format.PeriodFormatterBuilder",
    "signature": "org.joda.time.format.PeriodFormatterBuilder.appendDays()",
    "snippet": "    public PeriodFormatterBuilder appendDays() {\n        appendField(DAYS);\n        return this;\n    }",
    "comment": " Instruct the printer to emit an integer days field, if supported. <p> The number of printed and parsed digits can be controlled using {@link #minimumPrintedDigits(int)} and {@link #maximumParsedDigits(int)}.  @return this PeriodFormatterBuilder ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "PeriodFormatterBuilder.appendField",
    "class_name": "org.joda.time.format.PeriodFormatterBuilder",
    "signature": "org.joda.time.format.PeriodFormatterBuilder.appendField(int)",
    "snippet": "    private void appendField(int type) {\n        appendField(type, iMinPrintedDigits);\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "PeriodFormatterBuilder.appendField",
    "class_name": "org.joda.time.format.PeriodFormatterBuilder",
    "signature": "org.joda.time.format.PeriodFormatterBuilder.appendField(int,int)",
    "snippet": "    private void appendField(int type, int minPrinted) {\n        FieldFormatter field = new FieldFormatter(minPrinted, iPrintZeroSetting,\n            iMaxParsedDigits, iRejectSignedValues, type, iFieldFormatters, iPrefix, null);\n        append0(field, field);\n        iFieldFormatters[type] = field;\n        iPrefix = null;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "PeriodFormatterBuilder.appendHours",
    "class_name": "org.joda.time.format.PeriodFormatterBuilder",
    "signature": "org.joda.time.format.PeriodFormatterBuilder.appendHours()",
    "snippet": "    public PeriodFormatterBuilder appendHours() {\n        appendField(HOURS);\n        return this;\n    }",
    "comment": " Instruct the printer to emit an integer hours field, if supported. <p> The number of printed and parsed digits can be controlled using {@link #minimumPrintedDigits(int)} and {@link #maximumParsedDigits(int)}.  @return this PeriodFormatterBuilder ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "PeriodFormatterBuilder.appendLiteral",
    "class_name": "org.joda.time.format.PeriodFormatterBuilder",
    "signature": "org.joda.time.format.PeriodFormatterBuilder.appendLiteral(String)",
    "snippet": "    public PeriodFormatterBuilder appendLiteral(String text) {\n        if (text == null) {\n            throw new IllegalArgumentException(\"Literal must not be null\");\n        }\n        clearPrefix();\n        Literal literal = new Literal(text);\n        append0(literal, literal);\n        return this;\n    }",
    "comment": " Instructs the printer to emit specific text, and the parser to expect it. The parser is case-insensitive.  @return this PeriodFormatterBuilder @throws IllegalArgumentException if text is null ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "PeriodFormatterBuilder.appendMinutes",
    "class_name": "org.joda.time.format.PeriodFormatterBuilder",
    "signature": "org.joda.time.format.PeriodFormatterBuilder.appendMinutes()",
    "snippet": "    public PeriodFormatterBuilder appendMinutes() {\n        appendField(MINUTES);\n        return this;\n    }",
    "comment": " Instruct the printer to emit an integer minutes field, if supported. <p> The number of printed and parsed digits can be controlled using {@link #minimumPrintedDigits(int)} and {@link #maximumParsedDigits(int)}.  @return this PeriodFormatterBuilder ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "PeriodFormatterBuilder.appendMonths",
    "class_name": "org.joda.time.format.PeriodFormatterBuilder",
    "signature": "org.joda.time.format.PeriodFormatterBuilder.appendMonths()",
    "snippet": "    public PeriodFormatterBuilder appendMonths() {\n        appendField(MONTHS);\n        return this;\n    }",
    "comment": " Instruct the printer to emit an integer months field, if supported. <p> The number of printed and parsed digits can be controlled using {@link #minimumPrintedDigits(int)} and {@link #maximumParsedDigits(int)}.  @return this PeriodFormatterBuilder ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "PeriodFormatterBuilder.appendSecondsWithOptionalMillis",
    "class_name": "org.joda.time.format.PeriodFormatterBuilder",
    "signature": "org.joda.time.format.PeriodFormatterBuilder.appendSecondsWithOptionalMillis()",
    "snippet": "    public PeriodFormatterBuilder appendSecondsWithOptionalMillis() {\n        appendField(SECONDS_OPTIONAL_MILLIS);\n        return this;\n    }",
    "comment": " Instruct the printer to emit a combined seconds and millis field, if supported. The millis will overflow into the seconds if necessary. The millis are only output if non-zero.  @return this PeriodFormatterBuilder ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "PeriodFormatterBuilder.appendSeparator",
    "class_name": "org.joda.time.format.PeriodFormatterBuilder",
    "signature": "org.joda.time.format.PeriodFormatterBuilder.appendSeparator(String,String,String[],boolean,boolean)",
    "snippet": "    private PeriodFormatterBuilder appendSeparator(String text, String finalText,\n                                                   String[] variants,\n                                                   boolean useBefore, boolean useAfter) {\n        if (text == null || finalText == null) {\n            throw new IllegalArgumentException();\n        }\n\n        clearPrefix();\n        \n        // optimise zero formatter case\n        List<Object> pairs = iElementPairs;\n        if (pairs.size() == 0) {\n            if (useAfter && useBefore == false) {\n                Separator separator = new Separator(\n                        text, finalText, variants,\n                        Literal.EMPTY, Literal.EMPTY, useBefore, useAfter);\n                append0(separator, separator);\n            }\n            return this;\n        }\n        \n        // find the last separator added\n        int i;\n        Separator lastSeparator = null;\n        for (i=pairs.size(); --i>=0; ) {\n            if (pairs.get(i) instanceof Separator) {\n                lastSeparator = (Separator) pairs.get(i);\n                pairs = pairs.subList(i + 1, pairs.size());\n                break;\n            }\n            i--;  // element pairs\n        }\n        \n        // merge formatters\n        if (lastSeparator != null && pairs.size() == 0) {\n            throw new IllegalStateException(\"Cannot have two adjacent separators\");\n        } else {\n            Object[] comp = createComposite(pairs);\n            pairs.clear();\n            Separator separator = new Separator(\n                    text, finalText, variants,\n                    (PeriodPrinter) comp[0], (PeriodParser) comp[1],\n                    useBefore, useAfter);\n            pairs.add(separator);\n            pairs.add(separator);\n        }\n        \n        return this;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "PeriodFormatterBuilder.appendSeparatorIfFieldsAfter",
    "class_name": "org.joda.time.format.PeriodFormatterBuilder",
    "signature": "org.joda.time.format.PeriodFormatterBuilder.appendSeparatorIfFieldsAfter(String)",
    "snippet": "    public PeriodFormatterBuilder appendSeparatorIfFieldsAfter(String text) {\n        return appendSeparator(text, text, null, false, true);\n    }",
    "comment": " Append a separator, which is output only if fields are printed after the separator. <p> For example, <code>builder.appendDays().appendSeparatorIfFieldsAfter(\",\").appendHours()</code> will only output the comma if the hours fields is output. <p> The text will be parsed case-insensitively. <p> Note: appending a separator discontinues any further work on the latest appended field.  @param text  the text to use as a separator @return this PeriodFormatterBuilder @throws IllegalStateException if this separator follows a previous one ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "PeriodFormatterBuilder.appendSuffix",
    "class_name": "org.joda.time.format.PeriodFormatterBuilder",
    "signature": "org.joda.time.format.PeriodFormatterBuilder.appendSuffix(PeriodFieldAffix)",
    "snippet": "    private PeriodFormatterBuilder appendSuffix(PeriodFieldAffix suffix) {\n        final Object originalPrinter;\n        final Object originalParser;\n        if (iElementPairs.size() > 0) {\n            originalPrinter = iElementPairs.get(iElementPairs.size() - 2);\n            originalParser = iElementPairs.get(iElementPairs.size() - 1);\n        } else {\n            originalPrinter = null;\n            originalParser = null;\n        }\n\n        if (originalPrinter == null || originalParser == null ||\n                originalPrinter != originalParser ||\n                !(originalPrinter instanceof FieldFormatter)) {\n            throw new IllegalStateException(\"No field to apply suffix to\");\n        }\n\n        clearPrefix();\n        FieldFormatter newField = new FieldFormatter((FieldFormatter) originalPrinter, suffix);\n        iElementPairs.set(iElementPairs.size() - 2, newField);\n        iElementPairs.set(iElementPairs.size() - 1, newField);\n        iFieldFormatters[newField.getFieldType()] = newField;\n        \n        return this;\n    }",
    "comment": " Append a field suffix which applies only to the last appended field. If the field is not printed, neither is the suffix.  @param suffix custom suffix @return this PeriodFormatterBuilder @throws IllegalStateException if no field exists to append to @see #appendPrefix ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "PeriodFormatterBuilder.appendSuffix",
    "class_name": "org.joda.time.format.PeriodFormatterBuilder",
    "signature": "org.joda.time.format.PeriodFormatterBuilder.appendSuffix(String)",
    "snippet": "    public PeriodFormatterBuilder appendSuffix(String text) {\n        if (text == null) {\n            throw new IllegalArgumentException();\n        }\n        return appendSuffix(new SimpleAffix(text));\n    }",
    "comment": " Append a field suffix which applies only to the last appended field. If the field is not printed, neither is the suffix.  @param text text to print after field only if field is printed @return this PeriodFormatterBuilder @throws IllegalStateException if no field exists to append to @see #appendPrefix ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "PeriodFormatterBuilder.appendWeeks",
    "class_name": "org.joda.time.format.PeriodFormatterBuilder",
    "signature": "org.joda.time.format.PeriodFormatterBuilder.appendWeeks()",
    "snippet": "    public PeriodFormatterBuilder appendWeeks() {\n        appendField(WEEKS);\n        return this;\n    }",
    "comment": " Instruct the printer to emit an integer weeks field, if supported. <p> The number of printed and parsed digits can be controlled using {@link #minimumPrintedDigits(int)} and {@link #maximumParsedDigits(int)}.  @return this PeriodFormatterBuilder ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "PeriodFormatterBuilder.appendYears",
    "class_name": "org.joda.time.format.PeriodFormatterBuilder",
    "signature": "org.joda.time.format.PeriodFormatterBuilder.appendYears()",
    "snippet": "    public PeriodFormatterBuilder appendYears() {\n        appendField(YEARS);\n        return this;\n    }",
    "comment": " Instruct the printer to emit an integer years field, if supported. <p> The number of printed and parsed digits can be controlled using {@link #minimumPrintedDigits(int)} and {@link #maximumParsedDigits(int)}.  @return this PeriodFormatterBuilder ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "PeriodFormatterBuilder.clear",
    "class_name": "org.joda.time.format.PeriodFormatterBuilder",
    "signature": "org.joda.time.format.PeriodFormatterBuilder.clear()",
    "snippet": "    public void clear() {\n        iMinPrintedDigits = 1;\n        iPrintZeroSetting = PRINT_ZERO_RARELY_LAST;\n        iMaxParsedDigits = 10;\n        iRejectSignedValues = false;\n        iPrefix = null;\n        if (iElementPairs == null) {\n            iElementPairs = new ArrayList<Object>();\n        } else {\n            iElementPairs.clear();\n        }\n        iNotPrinter = false;\n        iNotParser = false;\n        iFieldFormatters = new FieldFormatter[10];\n    }",
    "comment": " Clears out all the appended elements, allowing this builder to be reused. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "PeriodFormatterBuilder.clearPrefix",
    "class_name": "org.joda.time.format.PeriodFormatterBuilder",
    "signature": "org.joda.time.format.PeriodFormatterBuilder.clearPrefix()",
    "snippet": "    private void clearPrefix() throws IllegalStateException {\n        if (iPrefix != null) {\n            throw new IllegalStateException(\"Prefix not followed by field\");\n        }\n        iPrefix = null;\n    }",
    "comment": "-----------------------------------------------------------------------",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "PeriodFormatterBuilder.createComposite",
    "class_name": "org.joda.time.format.PeriodFormatterBuilder",
    "signature": "org.joda.time.format.PeriodFormatterBuilder.createComposite(List)",
    "snippet": "    private static Object[] createComposite(List<Object> elementPairs) {\n        switch (elementPairs.size()) {\n            case 0:\n                return new Object[] {Literal.EMPTY, Literal.EMPTY};\n            case 1:\n                return new Object[] {elementPairs.get(0), elementPairs.get(1)};\n            default:\n                Composite comp = new Composite(elementPairs);\n                return new Object[] {comp, comp};\n        }\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "PeriodFormatterBuilder.toFormatter",
    "class_name": "org.joda.time.format.PeriodFormatterBuilder",
    "signature": "org.joda.time.format.PeriodFormatterBuilder.toFormatter()",
    "snippet": "    public PeriodFormatter toFormatter() {\n        PeriodFormatter formatter = toFormatter(iElementPairs, iNotPrinter, iNotParser);\n        iFieldFormatters = (FieldFormatter[]) iFieldFormatters.clone();\n        return formatter;\n    }",
    "comment": " Constructs a PeriodFormatter using all the appended elements. <p> This is the main method used by applications at the end of the build process to create a usable formatter. <p> Subsequent changes to this builder do not affect the returned formatter. <p> The returned formatter may not support both printing and parsing. The methods {@link PeriodFormatter#isPrinter()} and {@link PeriodFormatter#isParser()} will help you determine the state of the formatter.  @return the newly created formatter @throws IllegalStateException if the builder can produce neither a printer nor a parser ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "PeriodFormatterBuilder.toFormatter",
    "class_name": "org.joda.time.format.PeriodFormatterBuilder",
    "signature": "org.joda.time.format.PeriodFormatterBuilder.toFormatter(List,boolean,boolean)",
    "snippet": "    private static PeriodFormatter toFormatter(List<Object> elementPairs, boolean notPrinter, boolean notParser) {\n        if (notPrinter && notParser) {\n            throw new IllegalStateException(\"Builder has created neither a printer nor a parser\");\n        }\n        int size = elementPairs.size();\n        if (size >= 2 && elementPairs.get(0) instanceof Separator) {\n            Separator sep = (Separator) elementPairs.get(0);\n                PeriodFormatter f = toFormatter(elementPairs.subList(2, size), notPrinter, notParser);\n                sep = sep.finish(f.getPrinter(), f.getParser());\n                return new PeriodFormatter(sep, sep);\n        }\n        Object[] comp = createComposite(elementPairs);\n        if (notPrinter) {\n            return new PeriodFormatter(null, (PeriodParser) comp[1]);\n        } else if (notParser) {\n            return new PeriodFormatter((PeriodPrinter) comp[0], null);\n        } else {\n            return new PeriodFormatter((PeriodPrinter) comp[0], (PeriodParser) comp[1]);\n        }\n    }",
    "comment": "-----------------------------------------------------------------------",
    "is_bug": true,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "Composite.decompose",
    "class_name": "org.joda.time.format.PeriodFormatterBuilder$Composite",
    "signature": "org.joda.time.format.PeriodFormatterBuilder$Composite.decompose(List,List,List)",
    "snippet": "        private void decompose(List<Object> elementPairs, List<Object> printerList, List<Object> parserList) {\n            int size = elementPairs.size();\n            for (int i=0; i<size; i+=2) {\n                Object element = elementPairs.get(i);\n                if (element instanceof PeriodPrinter) {\n                    if (element instanceof Composite) {\n                        addArrayToList(printerList, ((Composite) element).iPrinters);\n                    } else {\n                        printerList.add(element);\n                    }\n                }\n\n                element = elementPairs.get(i + 1);\n                if (element instanceof PeriodParser) {\n                    if (element instanceof Composite) {\n                        addArrayToList(parserList, ((Composite) element).iParsers);\n                    } else {\n                        parserList.add(element);\n                    }\n                }\n            }\n        }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "Composite.parseInto",
    "class_name": "org.joda.time.format.PeriodFormatterBuilder$Composite",
    "signature": "org.joda.time.format.PeriodFormatterBuilder$Composite.parseInto(ReadWritablePeriod,String,int,Locale)",
    "snippet": "        public int parseInto(\n                ReadWritablePeriod period, String periodStr,\n                int position, Locale locale) {\n            PeriodParser[] parsers = iParsers;\n            if (parsers == null) {\n                throw new UnsupportedOperationException();\n            }\n\n            int len = parsers.length;\n            for (int i=0; i<len && position >= 0; i++) {\n                position = parsers[i].parseInto(period, periodStr, position, locale);\n            }\n            return position;\n        }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "FieldFormatter.getFieldType",
    "class_name": "org.joda.time.format.PeriodFormatterBuilder$FieldFormatter",
    "signature": "org.joda.time.format.PeriodFormatterBuilder$FieldFormatter.getFieldType()",
    "snippet": "        int getFieldType() {\n            return iFieldType;\n        }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "FieldFormatter.parseInt",
    "class_name": "org.joda.time.format.PeriodFormatterBuilder$FieldFormatter",
    "signature": "org.joda.time.format.PeriodFormatterBuilder$FieldFormatter.parseInt(String,int,int)",
    "snippet": "        private int parseInt(String text, int position, int length) {\n            if (length >= 10) {\n                // Since value may exceed max, use stock parser which checks for this.\n                return Integer.parseInt(text.substring(position, position + length));\n            }\n            if (length <= 0) {\n                return 0;\n            }\n            int value = text.charAt(position++);\n            length--;\n            boolean negative;\n            if (value == '-') {\n                if (--length < 0) {\n                    return 0;\n                }\n                negative = true;\n                value = text.charAt(position++);\n            } else {\n                negative = false;\n            }\n            value -= '0';\n            while (length-- > 0) {\n                value = ((value << 3) + (value << 1)) + text.charAt(position++) - '0';\n            }\n            return negative ? -value : value;\n        }",
    "comment": " @param text text to parse @param position position in text @param length exact count of characters to parse @return parsed int value ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "FieldFormatter.parseInto",
    "class_name": "org.joda.time.format.PeriodFormatterBuilder$FieldFormatter",
    "signature": "org.joda.time.format.PeriodFormatterBuilder$FieldFormatter.parseInto(ReadWritablePeriod,String,int,Locale)",
    "snippet": "        public int parseInto(\n                ReadWritablePeriod period, String text, \n                int position, Locale locale) {\n\n            boolean mustParse = (iPrintZeroSetting == PRINT_ZERO_ALWAYS);\n\n            // Shortcut test.\n            if (position >= text.length()) {\n                return mustParse ? ~position : position;\n            }\n\n            if (iPrefix != null) {\n                position = iPrefix.parse(text, position);\n                if (position >= 0) {\n                    // If prefix is found, then the parse must finish.\n                    mustParse = true;\n                } else {\n                    // Prefix not found, so bail.\n                    if (!mustParse) {\n                        // It's okay because parsing of this field is not\n                        // required. Don't return an error. Fields down the\n                        // chain can continue on, trying to parse.\n                        return ~position;\n                    }\n                    return position;\n                }\n            }\n\n            int suffixPos = -1;\n            if (iSuffix != null && !mustParse) {\n                // Pre-scan the suffix, to help determine if this field must be\n                // parsed.\n                suffixPos = iSuffix.scan(text, position);\n                if (suffixPos >= 0) {\n                    // If suffix is found, then parse must finish.\n                    mustParse = true;\n                } else {\n                    // Suffix not found, so bail.\n                    if (!mustParse) {\n                        // It's okay because parsing of this field is not\n                        // required. Don't return an error. Fields down the\n                        // chain can continue on, trying to parse.\n                        return ~suffixPos;\n                    }\n                    return suffixPos;\n                }\n            }\n\n            if (!mustParse && !isSupported(period.getPeriodType(), iFieldType)) {\n                // If parsing is not required and the field is not supported,\n                // exit gracefully so that another parser can continue on.\n                return position;\n            }\n\n            int limit;\n            if (suffixPos > 0) {\n                limit = Math.min(iMaxParsedDigits, suffixPos - position);\n            } else {\n                limit = Math.min(iMaxParsedDigits, text.length() - position);\n            }\n\n            // validate input number\n            int length = 0;\n            int fractPos = -1;\n            boolean hasDigits = false;\n            while (length < limit) {\n                char c = text.charAt(position + length);\n                // leading sign\n                if (length == 0 && (c == '-' || c == '+') && !iRejectSignedValues) {\n                    boolean negative = c == '-';\n\n                    // Next character must be a digit.\n                    if (length + 1 >= limit || \n                        (c = text.charAt(position + length + 1)) < '0' || c > '9')\n                    {\n                        break;\n                    }\n\n                    if (negative) {\n                        length++;\n                    } else {\n                        // Skip the '+' for parseInt to succeed.\n                        position++;\n                    }\n                    // Expand the limit to disregard the sign character.\n                    limit = Math.min(limit + 1, text.length() - position);\n                    continue;\n                }\n                // main number\n                if (c >= '0' && c <= '9') {\n                    hasDigits = true;\n                } else {\n                    if ((c == '.' || c == ',')\n                         && (iFieldType == SECONDS_MILLIS || iFieldType == SECONDS_OPTIONAL_MILLIS)) {\n                        if (fractPos >= 0) {\n                            // can't have two decimals\n                            break;\n                        }\n                        fractPos = position + length + 1;\n                        // Expand the limit to disregard the decimal point.\n                        limit = Math.min(limit + 1, text.length() - position);\n                    } else {\n                        break;\n                    }\n                }\n                length++;\n            }\n\n            if (!hasDigits) {\n                return ~position;\n            }\n\n            if (suffixPos >= 0 && position + length != suffixPos) {\n                // If there are additional non-digit characters before the\n                // suffix is reached, then assume that the suffix found belongs\n                // to a field not yet reached. Return original position so that\n                // another parser can continue on.\n                return position;\n            }\n\n            if (iFieldType != SECONDS_MILLIS && iFieldType != SECONDS_OPTIONAL_MILLIS) {\n                // Handle common case.\n                setFieldValue(period, iFieldType, parseInt(text, position, length));\n            } else if (fractPos < 0) {\n                setFieldValue(period, SECONDS, parseInt(text, position, length));\n                setFieldValue(period, MILLIS, 0);\n            } else {\n                int wholeValue = parseInt(text, position, fractPos - position - 1);\n                setFieldValue(period, SECONDS, wholeValue);\n\n                int fractLen = position + length - fractPos;\n                int fractValue;\n                if (fractLen <= 0) {\n                    fractValue = 0;\n                } else {\n                    if (fractLen >= 3) {\n                        fractValue = parseInt(text, fractPos, 3);\n                    } else {\n                        fractValue = parseInt(text, fractPos, fractLen);\n                        if (fractLen == 1) {\n                            fractValue *= 100;\n                        } else {\n                            fractValue *= 10;\n                        }\n                    }\n                    if (wholeValue < 0) {\n                        fractValue = -fractValue;\n                    }\n                }\n\n                setFieldValue(period, MILLIS, fractValue);\n            }\n                \n            position += length;\n\n            if (position >= 0 && iSuffix != null) {\n                position = iSuffix.parse(text, position);\n            }\n                \n            return position;\n        }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "FieldFormatter.setFieldValue",
    "class_name": "org.joda.time.format.PeriodFormatterBuilder$FieldFormatter",
    "signature": "org.joda.time.format.PeriodFormatterBuilder$FieldFormatter.setFieldValue(ReadWritablePeriod,int,int)",
    "snippet": "        void setFieldValue(ReadWritablePeriod period, int field, int value) {\n            switch (field) {\n            default:\n                break;\n            case YEARS:\n                period.setYears(value);\n                break;\n            case MONTHS:\n                period.setMonths(value);\n                break;\n            case WEEKS:\n                period.setWeeks(value);\n                break;\n            case DAYS:\n                period.setDays(value);\n                break;\n            case HOURS:\n                period.setHours(value);\n                break;\n            case MINUTES:\n                period.setMinutes(value);\n                break;\n            case SECONDS:\n                period.setSeconds(value);\n                break;\n            case MILLIS:\n                period.setMillis(value);\n                break;\n            }\n        }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "Literal.parseInto",
    "class_name": "org.joda.time.format.PeriodFormatterBuilder$Literal",
    "signature": "org.joda.time.format.PeriodFormatterBuilder$Literal.parseInto(ReadWritablePeriod,String,int,Locale)",
    "snippet": "        public int parseInto(\n                ReadWritablePeriod period, String periodStr,\n                int position, Locale locale) {\n            if (periodStr.regionMatches(true, position, iText, 0, iText.length())) {\n                return position + iText.length();\n            }\n            return ~position;\n        }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "Separator.finish",
    "class_name": "org.joda.time.format.PeriodFormatterBuilder$Separator",
    "signature": "org.joda.time.format.PeriodFormatterBuilder$Separator.finish(PeriodPrinter,PeriodParser)",
    "snippet": "        Separator finish(PeriodPrinter afterPrinter, PeriodParser afterParser) {\n            iAfterPrinter = afterPrinter;\n            iAfterParser = afterParser;\n            return this;\n        }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "Separator.parseInto",
    "class_name": "org.joda.time.format.PeriodFormatterBuilder$Separator",
    "signature": "org.joda.time.format.PeriodFormatterBuilder$Separator.parseInto(ReadWritablePeriod,String,int,Locale)",
    "snippet": "        public int parseInto(\n                ReadWritablePeriod period, String periodStr,\n                int position, Locale locale) {\n            int oldPos = position;\n            position = iBeforeParser.parseInto(period, periodStr, position, locale);\n\n            if (position < 0) {\n                return position;\n            }\n\n            boolean found = false;\n            if (position > oldPos) {\n                // Consume this separator.\n                String[] parsedForms = iParsedForms;\n                int length = parsedForms.length;\n                for (int i=0; i < length; i++) {\n                    String parsedForm = parsedForms[i];\n                    if ((parsedForm == null || parsedForm.length() == 0) ||\n                        periodStr.regionMatches\n                        (true, position, parsedForm, 0, parsedForm.length())) {\n                        \n                        position += parsedForm.length();\n                        found = true;\n                        break;\n                    }\n                }\n            }\n\n            oldPos = position;\n            position = iAfterParser.parseInto(period, periodStr, position, locale);\n\n            if (position < 0) {\n                return position;\n            }\n\n            if (found && position == oldPos) {\n                // Separator should not have been supplied.\n                return ~oldPos;\n            }\n\n            if (position > oldPos && !found && !iUseBefore) {\n                // Separator was required.\n                return ~oldPos;\n            }\n\n            return position;\n        }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "SimpleAffix.parse",
    "class_name": "org.joda.time.format.PeriodFormatterBuilder$SimpleAffix",
    "signature": "org.joda.time.format.PeriodFormatterBuilder$SimpleAffix.parse(String,int)",
    "snippet": "        public int parse(String periodStr, int position) {\n            String text = iText;\n            int textLength = text.length();\n            if (periodStr.regionMatches(true, position, text, 0, textLength)) {\n                return position + textLength;\n            }\n            return ~position;\n        }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "SimpleAffix.scan",
    "class_name": "org.joda.time.format.PeriodFormatterBuilder$SimpleAffix",
    "signature": "org.joda.time.format.PeriodFormatterBuilder$SimpleAffix.scan(String,int)",
    "snippet": "        public int scan(String periodStr, final int position) {\n            String text = iText;\n            int textLength = text.length();\n            int sourceLength = periodStr.length();\n            search:\n            for (int pos = position; pos < sourceLength; pos++) {\n                if (periodStr.regionMatches(true, pos, text, 0, textLength)) {\n                    return pos;\n                }\n                // Only allow number characters to be skipped in search of suffix.\n                switch (periodStr.charAt(pos)) {\n                case '0': case '1': case '2': case '3': case '4':\n                case '5': case '6': case '7': case '8': case '9':\n                case '.': case ',': case '+': case '-':\n                    break;\n                default:\n                    break search;\n                }\n            }\n            return ~position;\n        }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "CachedDateTimeZone.forZone",
    "class_name": "org.joda.time.tz.CachedDateTimeZone",
    "signature": "org.joda.time.tz.CachedDateTimeZone.forZone(DateTimeZone)",
    "snippet": "    public static CachedDateTimeZone forZone(DateTimeZone zone) {\n        if (zone instanceof CachedDateTimeZone) {\n            return (CachedDateTimeZone)zone;\n        }\n        return new CachedDateTimeZone(zone);\n    }",
    "comment": " Returns a new CachedDateTimeZone unless given zone is already cached. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "CachedDateTimeZone.hashCode",
    "class_name": "org.joda.time.tz.CachedDateTimeZone",
    "signature": "org.joda.time.tz.CachedDateTimeZone.hashCode()",
    "snippet": "    public int hashCode() {\n        return iZone.hashCode();\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "DateTimeZoneBuilder.readFrom",
    "class_name": "org.joda.time.tz.DateTimeZoneBuilder",
    "signature": "org.joda.time.tz.DateTimeZoneBuilder.readFrom(DataInput,String)",
    "snippet": "    public static DateTimeZone readFrom(DataInput in, String id) throws IOException {\n        switch (in.readUnsignedByte()) {\n        case 'F':\n            DateTimeZone fixed = new FixedDateTimeZone\n                (id, in.readUTF(), (int)readMillis(in), (int)readMillis(in));\n            if (fixed.equals(DateTimeZone.UTC)) {\n                fixed = DateTimeZone.UTC;\n            }\n            return fixed;\n        case 'C':\n            return CachedDateTimeZone.forZone(PrecalculatedZone.readFrom(in, id));\n        case 'P':\n            return PrecalculatedZone.readFrom(in, id);\n        default:\n            throw new IOException(\"Invalid encoding\");\n        }\n    }",
    "comment": " Decodes a built DateTimeZone from the given stream, as encoded by writeTo.  @param in input stream to read encoded DateTimeZone from. @param id time zone id to assign ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "DateTimeZoneBuilder.readFrom",
    "class_name": "org.joda.time.tz.DateTimeZoneBuilder",
    "signature": "org.joda.time.tz.DateTimeZoneBuilder.readFrom(InputStream,String)",
    "snippet": "    public static DateTimeZone readFrom(InputStream in, String id) throws IOException {\n        if (in instanceof DataInput) {\n            return readFrom((DataInput)in, id);\n        } else {\n            return readFrom((DataInput)new DataInputStream(in), id);\n        }\n    }",
    "comment": " Decodes a built DateTimeZone from the given stream, as encoded by writeTo.  @param in input stream to read encoded DateTimeZone from. @param id time zone id to assign ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "DateTimeZoneBuilder.readMillis",
    "class_name": "org.joda.time.tz.DateTimeZoneBuilder",
    "signature": "org.joda.time.tz.DateTimeZoneBuilder.readMillis(DataInput)",
    "snippet": "    static long readMillis(DataInput in) throws IOException {\n        int v = in.readUnsignedByte();\n        switch (v >> 6) {\n        case 0: default:\n            // Form 00 (6 bits effective precision)\n            v = (v << (32 - 6)) >> (32 - 6);\n            return v * (30 * 60000L);\n\n        case 1:\n            // Form 01 (30 bits effective precision)\n            v = (v << (32 - 6)) >> (32 - 30);\n            v |= (in.readUnsignedByte()) << 16;\n            v |= (in.readUnsignedByte()) << 8;\n            v |= (in.readUnsignedByte());\n            return v * 60000L;\n\n        case 2:\n            // Form 10 (38 bits effective precision)\n            long w = (((long)v) << (64 - 6)) >> (64 - 38);\n            w |= (in.readUnsignedByte()) << 24;\n            w |= (in.readUnsignedByte()) << 16;\n            w |= (in.readUnsignedByte()) << 8;\n            w |= (in.readUnsignedByte());\n            return w * 1000L;\n\n        case 3:\n            // Form 11 (64 bits effective precision)\n            return in.readLong();\n        }\n    }",
    "comment": " Reads encoding generated by writeMillis. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "DSTZone.readFrom",
    "class_name": "org.joda.time.tz.DateTimeZoneBuilder$DSTZone",
    "signature": "org.joda.time.tz.DateTimeZoneBuilder$DSTZone.readFrom(DataInput,String)",
    "snippet": "        static DSTZone readFrom(DataInput in, String id) throws IOException {\n            return new DSTZone(id, (int)readMillis(in), \n                               Recurrence.readFrom(in), Recurrence.readFrom(in));\n        }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "OfYear.readFrom",
    "class_name": "org.joda.time.tz.DateTimeZoneBuilder$OfYear",
    "signature": "org.joda.time.tz.DateTimeZoneBuilder$OfYear.readFrom(DataInput)",
    "snippet": "        static OfYear readFrom(DataInput in) throws IOException {\n            return new OfYear((char)in.readUnsignedByte(),\n                              (int)in.readUnsignedByte(),\n                              (int)in.readByte(),\n                              (int)in.readUnsignedByte(),\n                              in.readBoolean(),\n                              (int)readMillis(in));\n        }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "PrecalculatedZone.readFrom",
    "class_name": "org.joda.time.tz.DateTimeZoneBuilder$PrecalculatedZone",
    "signature": "org.joda.time.tz.DateTimeZoneBuilder$PrecalculatedZone.readFrom(DataInput,String)",
    "snippet": "        static PrecalculatedZone readFrom(DataInput in, String id) throws IOException {\n            // Read string pool.\n            int poolSize = in.readUnsignedShort();\n            String[] pool = new String[poolSize];\n            for (int i=0; i<poolSize; i++) {\n                pool[i] = in.readUTF();\n            }\n\n            int size = in.readInt();\n            long[] transitions = new long[size];\n            int[] wallOffsets = new int[size];\n            int[] standardOffsets = new int[size];\n            String[] nameKeys = new String[size];\n            \n            for (int i=0; i<size; i++) {\n                transitions[i] = readMillis(in);\n                wallOffsets[i] = (int)readMillis(in);\n                standardOffsets[i] = (int)readMillis(in);\n                try {\n                    int index;\n                    if (poolSize < 256) {\n                        index = in.readUnsignedByte();\n                    } else {\n                        index = in.readUnsignedShort();\n                    }\n                    nameKeys[i] = pool[index];\n                } catch (ArrayIndexOutOfBoundsException e) {\n                    throw new IOException(\"Invalid encoding\");\n                }\n            }\n\n            DSTZone tailZone = null;\n            if (in.readBoolean()) {\n                tailZone = DSTZone.readFrom(in, id);\n            }\n\n            return new PrecalculatedZone\n                (id, transitions, wallOffsets, standardOffsets, nameKeys, tailZone);\n        }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "Recurrence.readFrom",
    "class_name": "org.joda.time.tz.DateTimeZoneBuilder$Recurrence",
    "signature": "org.joda.time.tz.DateTimeZoneBuilder$Recurrence.readFrom(DataInput)",
    "snippet": "        static Recurrence readFrom(DataInput in) throws IOException {\n            return new Recurrence(OfYear.readFrom(in), in.readUTF(), (int)readMillis(in));\n        }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "DefaultNameProvider.DefaultNameProvider",
    "class_name": "org.joda.time.tz.DefaultNameProvider",
    "signature": "org.joda.time.tz.DefaultNameProvider.DefaultNameProvider()",
    "snippet": "    public DefaultNameProvider() {\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "DefaultNameProvider.createCache",
    "class_name": "org.joda.time.tz.DefaultNameProvider",
    "signature": "org.joda.time.tz.DefaultNameProvider.createCache()",
    "snippet": "    private HashMap createCache() {\n        return new HashMap(7);\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "FixedDateTimeZone.FixedDateTimeZone",
    "class_name": "org.joda.time.tz.FixedDateTimeZone",
    "signature": "org.joda.time.tz.FixedDateTimeZone.FixedDateTimeZone(String,String,int,int)",
    "snippet": "    public FixedDateTimeZone(String id, String nameKey,\n                             int wallOffset, int standardOffset) {\n        super(id);\n        iNameKey = nameKey;\n        iWallOffset = wallOffset;\n        iStandardOffset = standardOffset;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "FixedDateTimeZone.equals",
    "class_name": "org.joda.time.tz.FixedDateTimeZone",
    "signature": "org.joda.time.tz.FixedDateTimeZone.equals(Object)",
    "snippet": "    public boolean equals(Object obj) {\n        if (this == obj) {\n            return true;\n        }\n        if (obj instanceof FixedDateTimeZone) {\n            FixedDateTimeZone other = (FixedDateTimeZone)obj;\n            return\n                getID().equals(other.getID()) &&\n                iStandardOffset == other.iStandardOffset &&\n                iWallOffset == other.iWallOffset;\n        }\n        return false;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "FixedDateTimeZone.hashCode",
    "class_name": "org.joda.time.tz.FixedDateTimeZone",
    "signature": "org.joda.time.tz.FixedDateTimeZone.hashCode()",
    "snippet": "    public int hashCode() {\n        return getID().hashCode() + 37 * iStandardOffset + 31 * iWallOffset;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "ZoneInfoProvider.ZoneInfoProvider",
    "class_name": "org.joda.time.tz.ZoneInfoProvider",
    "signature": "org.joda.time.tz.ZoneInfoProvider.ZoneInfoProvider(String)",
    "snippet": "    public ZoneInfoProvider(String resourcePath) throws IOException {\n        this(resourcePath, null, false);\n    }",
    "comment": " ZoneInfoProvider searches the given ClassLoader resource path for compiled data files. Resources are loaded from the ClassLoader that loaded this class.  @throws IOException if directory or map file cannot be read ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "ZoneInfoProvider.getAvailableIDs",
    "class_name": "org.joda.time.tz.ZoneInfoProvider",
    "signature": "org.joda.time.tz.ZoneInfoProvider.getAvailableIDs()",
    "snippet": "    public Set<String> getAvailableIDs() {\n        // Return a copy of the keys rather than an umodifiable collection.\n        // This prevents ConcurrentModificationExceptions from being thrown by\n        // some JVMs if zones are opened while this set is iterated over.\n        return new TreeSet<String>(iZoneInfoMap.keySet());\n    }",
    "comment": " Gets a list of all the available zone ids.  @return the zone ids ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "ZoneInfoProvider.getZone",
    "class_name": "org.joda.time.tz.ZoneInfoProvider",
    "signature": "org.joda.time.tz.ZoneInfoProvider.getZone(String)",
    "snippet": "    public DateTimeZone getZone(String id) {\n        if (id == null) {\n            return null;\n        }\n\n        Object obj = iZoneInfoMap.get(id);\n        if (obj == null) {\n            return null;\n        }\n\n        if (id.equals(obj)) {\n            // Load zone data for the first time.\n            return loadZoneData(id);\n        }\n\n        if (obj instanceof SoftReference<?>) {\n            @SuppressWarnings(\"unchecked\")\n            SoftReference<DateTimeZone> ref = (SoftReference<DateTimeZone>) obj;\n            DateTimeZone tz = ref.get();\n            if (tz != null) {\n                return tz;\n            }\n            // Reference cleared; load data again.\n            return loadZoneData(id);\n        }\n\n        // If this point is reached, mapping must link to another.\n        return getZone((String)obj);\n    }",
    "comment": " If an error is thrown while loading zone data, uncaughtException is called to log the error and null is returned for this and all future requests.  @param id  the id to load @return the loaded zone ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "ZoneInfoProvider.loadZoneData",
    "class_name": "org.joda.time.tz.ZoneInfoProvider",
    "signature": "org.joda.time.tz.ZoneInfoProvider.loadZoneData(String)",
    "snippet": "    private DateTimeZone loadZoneData(String id) {\n        InputStream in = null;\n        try {\n            in = openResource(id);\n            DateTimeZone tz = DateTimeZoneBuilder.readFrom(in, id);\n            iZoneInfoMap.put(id, new SoftReference<DateTimeZone>(tz));\n            return tz;\n        } catch (IOException e) {\n            uncaughtException(e);\n            iZoneInfoMap.remove(id);\n            return null;\n        } finally {\n            try {\n                if (in != null) {\n                    in.close();\n                }\n            } catch (IOException e) {\n            }\n        }\n    }",
    "comment": " Loads the time zone data for one id.  @param id  the id to load @return the zone ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "ZoneInfoProvider.loadZoneInfoMap",
    "class_name": "org.joda.time.tz.ZoneInfoProvider",
    "signature": "org.joda.time.tz.ZoneInfoProvider.loadZoneInfoMap(InputStream)",
    "snippet": "    private static Map<String, Object> loadZoneInfoMap(InputStream in) throws IOException {\n        Map<String, Object> map = new ConcurrentHashMap<String, Object>();\n        DataInputStream din = new DataInputStream(in);\n        try {\n            readZoneInfoMap(din, map);\n        } finally {\n            try {\n                din.close();\n            } catch (IOException e) {\n            }\n        }\n        map.put(\"UTC\", new SoftReference<DateTimeZone>(DateTimeZone.UTC));\n        return map;\n    }",
    "comment": " Loads the zone info map.  @param in  the input stream @return the map ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "ZoneInfoProvider.openResource",
    "class_name": "org.joda.time.tz.ZoneInfoProvider",
    "signature": "org.joda.time.tz.ZoneInfoProvider.openResource(String)",
    "snippet": "    private InputStream openResource(String name) throws IOException {\n        InputStream in;\n        if (iFileDir != null) {\n            in = new FileInputStream(new File(iFileDir, name));\n        } else {\n            String path = iResourcePath.concat(name);\n            if (iLoader != null) {\n                in = iLoader.getResourceAsStream(path);\n            } else {\n                in = ClassLoader.getSystemResourceAsStream(path);\n            }\n            if (in == null) {\n                StringBuffer buf = new StringBuffer(40)\n                    .append(\"Resource not found: \\\"\")\n                    .append(path)\n                    .append(\"\\\" ClassLoader: \")\n                    .append(iLoader != null ? iLoader.toString() : \"system\");\n                throw new IOException(buf.toString());\n            }\n        }\n        return in;\n    }",
    "comment": " Opens a resource from file or classpath.  @param name  the name to open @return the input stream @throws IOException if an error occurs ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "ZoneInfoProvider.readZoneInfoMap",
    "class_name": "org.joda.time.tz.ZoneInfoProvider",
    "signature": "org.joda.time.tz.ZoneInfoProvider.readZoneInfoMap(DataInputStream,Map)",
    "snippet": "    private static void readZoneInfoMap(DataInputStream din, Map<String, Object> zimap) throws IOException {\n        // Read the string pool.\n        int size = din.readUnsignedShort();\n        String[] pool = new String[size];\n        for (int i=0; i<size; i++) {\n            pool[i] = din.readUTF().intern();\n        }\n\n        // Read the mappings.\n        size = din.readUnsignedShort();\n        for (int i=0; i<size; i++) {\n            try {\n                zimap.put(pool[din.readUnsignedShort()], pool[din.readUnsignedShort()]);\n            } catch (ArrayIndexOutOfBoundsException e) {\n                throw new IOException(\"Corrupt zone info map\");\n            }\n        }\n    }",
    "comment": " Reads the zone info map from file.  @param din  the input stream @param zimap  gets filled with string id to string id mappings ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  }
]