[
  {
    "name": "AbstractRealMatrix.AbstractRealMatrix",
    "class_name": "org.apache.commons.math.linear.AbstractRealMatrix",
    "signature": "org.apache.commons.math.linear.AbstractRealMatrix.AbstractRealMatrix(int,int)",
    "snippet": "    protected AbstractRealMatrix(final int rowDimension, final int columnDimension)\n        throws IllegalArgumentException {\n        if (rowDimension <= 0 ) {\n            throw MathRuntimeException.createIllegalArgumentException(\n                    \"invalid row dimension {0} (must be positive)\",\n                    rowDimension);\n        }\n        if (columnDimension <= 0) {\n            throw MathRuntimeException.createIllegalArgumentException(\n                    \"invalid column dimension {0} (must be positive)\",\n                    columnDimension);\n        }\n        lu = null;\n    }",
    "comment": " Create a new RealMatrix with the supplied row and column dimensions.  @param rowDimension  the number of rows in the new matrix @param columnDimension  the number of columns in the new matrix @throws IllegalArgumentException if row or column dimension is not positive ",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "AbstractRealMatrix.isSquare",
    "class_name": "org.apache.commons.math.linear.AbstractRealMatrix",
    "signature": "org.apache.commons.math.linear.AbstractRealMatrix.isSquare()",
    "snippet": "    public boolean isSquare() {\n        return (getColumnDimension() == getRowDimension());\n    }",
    "comment": "{@inheritDoc} */",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "AbstractRealMatrix.toString",
    "class_name": "org.apache.commons.math.linear.AbstractRealMatrix",
    "signature": "org.apache.commons.math.linear.AbstractRealMatrix.toString()",
    "snippet": "    @Override\n    public String toString() {\n        final int nRows = getRowDimension();\n        final int nCols = getColumnDimension();\n        final StringBuffer res = new StringBuffer();\n        String fullClassName = getClass().getName();\n        String shortClassName = fullClassName.substring(fullClassName.lastIndexOf('.') + 1);\n        res.append(shortClassName).append(\"{\");\n\n        for (int i = 0; i < nRows; ++i) {\n            if (i > 0) {\n                res.append(\",\");\n            }\n            res.append(\"{\");\n            for (int j = 0; j < nCols; ++j) {\n                if (j > 0) {\n                    res.append(\",\");\n                }\n                res.append(getEntry(i, j));\n            } \n            res.append(\"}\");\n        } \n\n        res.append(\"}\");\n        return res.toString();\n\n    } ",
    "comment": " Get a string representation for this matrix. @return a string representation for this matrix ",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "CholeskyDecompositionImpl.CholeskyDecompositionImpl",
    "class_name": "org.apache.commons.math.linear.CholeskyDecompositionImpl",
    "signature": "org.apache.commons.math.linear.CholeskyDecompositionImpl.CholeskyDecompositionImpl(RealMatrix)",
    "snippet": "    public CholeskyDecompositionImpl(final RealMatrix matrix)\n        throws NonSquareMatrixException,\n               NotSymmetricMatrixException, NotPositiveDefiniteMatrixException {\n        this(matrix, DEFAULT_RELATIVE_SYMMETRY_THRESHOLD,\n             DEFAULT_ABSOLUTE_POSITIVITY_THRESHOLD);\n    }",
    "comment": " Calculates the Cholesky decomposition of the given matrix. <p> Calling this constructor is equivalent to call {@link #CholeskyDecompositionImpl(RealMatrix, double, double)} with the thresholds set to the default values {@link #DEFAULT_RELATIVE_SYMMETRY_THRESHOLD} and {@link #DEFAULT_ABSOLUTE_POSITIVITY_THRESHOLD} </p> @param matrix the matrix to decompose @exception NonSquareMatrixException if matrix is not square @exception NotSymmetricMatrixException if matrix is not symmetric @exception NotPositiveDefiniteMatrixException if the matrix is not strictly positive definite @see #CholeskyDecompositionImpl(RealMatrix, double, double) @see #DEFAULT_RELATIVE_SYMMETRY_THRESHOLD @see #DEFAULT_ABSOLUTE_POSITIVITY_THRESHOLD ",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "CholeskyDecompositionImpl.CholeskyDecompositionImpl",
    "class_name": "org.apache.commons.math.linear.CholeskyDecompositionImpl",
    "signature": "org.apache.commons.math.linear.CholeskyDecompositionImpl.CholeskyDecompositionImpl(RealMatrix,double,double)",
    "snippet": "    public CholeskyDecompositionImpl(final RealMatrix matrix,\n                                     final double relativeSymmetryThreshold,\n                                     final double absolutePositivityThreshold)\n        throws NonSquareMatrixException,\n               NotSymmetricMatrixException, NotPositiveDefiniteMatrixException {\n\n        if (!matrix.isSquare()) {\n            throw new NonSquareMatrixException(matrix.getRowDimension(),\n                                               matrix.getColumnDimension());\n        }\n\n        final int order = matrix.getRowDimension();\n        lTData   = matrix.getData();\n        cachedL  = null;\n        cachedLT = null;\n\n        // check the matrix before transformation\n        for (int i = 0; i < order; ++i) {\n\n            final double[] lI = lTData[i];\n\n            if (lTData[i][i] < absolutePositivityThreshold) {\n                throw new NotPositiveDefiniteMatrixException();\n            }\n            // check off-diagonal elements (and reset them to 0)\n            for (int j = i + 1; j < order; ++j) {\n                final double[] lJ = lTData[j];\n                final double lIJ = lI[j];\n                final double lJI = lJ[i];\n                final double maxDelta =\n                    relativeSymmetryThreshold * Math.max(Math.abs(lIJ), Math.abs(lJI));\n                if (Math.abs(lIJ - lJI) > maxDelta) {\n                    throw new NotSymmetricMatrixException();\n                }\n                lJ[i] = 0;\n           }\n        }\n\n        // transform the matrix\n        for (int i = 0; i < order; ++i) {\n\n            final double[] ltI = lTData[i];\n\n            // check diagonal element\n\n            ltI[i] = Math.sqrt(ltI[i]);\n            final double inverse = 1.0 / ltI[i];\n\n            for (int q = order - 1; q > i; --q) {\n                ltI[q] *= inverse;\n                final double[] ltQ = lTData[q];\n                for (int p = q; p < order; ++p) {\n                    ltQ[p] -= ltI[q] * ltI[p];\n                }\n            }\n\n        }\n\n    }",
    "comment": " Calculates the Cholesky decomposition of the given matrix. @param matrix the matrix to decompose @param relativeSymmetryThreshold threshold above which off-diagonal elements are considered too different and matrix not symmetric @param absolutePositivityThreshold threshold below which diagonal elements are considered null and matrix not positive definite @exception NonSquareMatrixException if matrix is not square @exception NotSymmetricMatrixException if matrix is not symmetric @exception NotPositiveDefiniteMatrixException if the matrix is not strictly positive definite @see #CholeskyDecompositionImpl(RealMatrix) @see #DEFAULT_RELATIVE_SYMMETRY_THRESHOLD @see #DEFAULT_ABSOLUTE_POSITIVITY_THRESHOLD ",
    "is_bug": true,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "CholeskyDecompositionImpl.getL",
    "class_name": "org.apache.commons.math.linear.CholeskyDecompositionImpl",
    "signature": "org.apache.commons.math.linear.CholeskyDecompositionImpl.getL()",
    "snippet": "    public RealMatrix getL() {\n        if (cachedL == null) {\n            cachedL = getLT().transpose();\n        }\n        return cachedL;\n    }",
    "comment": "{@inheritDoc} */",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "CholeskyDecompositionImpl.getLT",
    "class_name": "org.apache.commons.math.linear.CholeskyDecompositionImpl",
    "signature": "org.apache.commons.math.linear.CholeskyDecompositionImpl.getLT()",
    "snippet": "    public RealMatrix getLT() {\n\n        if (cachedLT == null) {\n            cachedLT = MatrixUtils.createRealMatrix(lTData);\n        }\n\n        // return the cached matrix\n        return cachedLT;\n\n    }",
    "comment": "{@inheritDoc} */",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "DenseRealMatrix.DenseRealMatrix",
    "class_name": "org.apache.commons.math.linear.DenseRealMatrix",
    "signature": "org.apache.commons.math.linear.DenseRealMatrix.DenseRealMatrix(double[][])",
    "snippet": "    public DenseRealMatrix(final double[][] rawData)\n        throws IllegalArgumentException {\n        this(rawData.length, rawData[0].length, toBlocksLayout(rawData), false);\n    }",
    "comment": " Create a new dense matrix copying entries from raw layout data. <p>The input array <em>must</em> already be in raw layout.</p> <p>Calling this constructor is equivalent to call: <pre>matrix = new DenseRealMatrix(rawData.length, rawData[0].length, toBlocksLayout(rawData), false);</pre> </p> @param rawData data for new matrix, in raw layout  @exception IllegalArgumentException if <code>blockData</code> shape is inconsistent with block layout @see #DenseRealMatrix(int, int, double[][], boolean) ",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "DenseRealMatrix.DenseRealMatrix",
    "class_name": "org.apache.commons.math.linear.DenseRealMatrix",
    "signature": "org.apache.commons.math.linear.DenseRealMatrix.DenseRealMatrix(int,int)",
    "snippet": "    public DenseRealMatrix(final int rows, final int columns)\n        throws IllegalArgumentException {\n\n        super(rows, columns);\n        this.rows    = rows;\n        this.columns = columns;\n\n        // number of blocks\n        blockRows    = (rows    + BLOCK_SIZE - 1) / BLOCK_SIZE;\n        blockColumns = (columns + BLOCK_SIZE - 1) / BLOCK_SIZE;\n\n        // allocate storage blocks, taking care of smaller ones at right and bottom\n        blocks = createBlocksLayout(rows, columns);\n\n    }",
    "comment": " Create a new matrix with the supplied row and column dimensions.  @param rows  the number of rows in the new matrix @param columns  the number of columns in the new matrix @throws IllegalArgumentException if row or column dimension is not positive ",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "DenseRealMatrix.DenseRealMatrix",
    "class_name": "org.apache.commons.math.linear.DenseRealMatrix",
    "signature": "org.apache.commons.math.linear.DenseRealMatrix.DenseRealMatrix(int,int,double[][],boolean)",
    "snippet": "    public DenseRealMatrix(final int rows, final int columns,\n                           final double[][] blockData, final boolean copyArray)\n        throws IllegalArgumentException {\n\n        super(rows, columns);\n        this.rows    = rows;\n        this.columns = columns;\n\n        // number of blocks\n        blockRows    = (rows    + BLOCK_SIZE - 1) / BLOCK_SIZE;\n        blockColumns = (columns + BLOCK_SIZE - 1) / BLOCK_SIZE;\n\n        if (copyArray) {\n            // allocate storage blocks, taking care of smaller ones at right and bottom\n            blocks = new double[blockRows * blockColumns][];\n        } else {\n            // reference existing array\n            blocks = blockData;\n        }\n\n        int index = 0;\n        for (int iBlock = 0; iBlock < blockRows; ++iBlock) {\n            final int iHeight = blockHeight(iBlock);\n            for (int jBlock = 0; jBlock < blockColumns; ++jBlock, ++index) {\n                if (blockData[index].length != iHeight * blockWidth(jBlock)) {\n                    throw MathRuntimeException.createIllegalArgumentException(\n                            \"wrong array shape (block length = {0}, expected {1})\",\n                            blockData[index].length, iHeight * blockWidth(jBlock));\n                }\n                if (copyArray) {\n                    blocks[index] = blockData[index].clone();\n                }\n            }\n        }\n\n    }",
    "comment": " Create a new dense matrix copying entries from block layout data. <p>The input array <em>must</em> already be in blocks layout.</p> @param rows  the number of rows in the new matrix @param columns  the number of columns in the new matrix @param blockData data for new matrix @param copyArray if true, the input array will be copied, otherwise it will be referenced  @exception IllegalArgumentException if <code>blockData</code> shape is inconsistent with block layout @see #createBlocksLayout(int, int) @see #toBlocksLayout(double[][]) @see #DenseRealMatrix(double[][]) ",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "DenseRealMatrix.blockHeight",
    "class_name": "org.apache.commons.math.linear.DenseRealMatrix",
    "signature": "org.apache.commons.math.linear.DenseRealMatrix.blockHeight(int)",
    "snippet": "    private int blockHeight(final int blockRow) {\n        return (blockRow == blockRows - 1) ? rows - blockRow * BLOCK_SIZE : BLOCK_SIZE;\n    }",
    "comment": " Get the height of a block. @param blockRow row index (in block sense) of the block @return height (number of rows) of the block ",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "DenseRealMatrix.blockWidth",
    "class_name": "org.apache.commons.math.linear.DenseRealMatrix",
    "signature": "org.apache.commons.math.linear.DenseRealMatrix.blockWidth(int)",
    "snippet": "    private int blockWidth(final int blockColumn) {\n        return (blockColumn == blockColumns - 1) ? columns - blockColumn * BLOCK_SIZE : BLOCK_SIZE;\n    }",
    "comment": " Get the width of a block. @param blockColumn column index (in block sense) of the block @return width (number of columns) of the block ",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "DenseRealMatrix.createBlocksLayout",
    "class_name": "org.apache.commons.math.linear.DenseRealMatrix",
    "signature": "org.apache.commons.math.linear.DenseRealMatrix.createBlocksLayout(int,int)",
    "snippet": "    public static double[][] createBlocksLayout(final int rows, final int columns) {\n\n        final int blockRows    = (rows    + BLOCK_SIZE - 1) / BLOCK_SIZE;\n        final int blockColumns = (columns + BLOCK_SIZE - 1) / BLOCK_SIZE;\n\n        final double[][] blocks = new double[blockRows * blockColumns][];\n        for (int iBlock = 0, blockIndex = 0; iBlock < blockRows; ++iBlock) {\n            final int pStart  = iBlock * BLOCK_SIZE;\n            final int pEnd    = Math.min(pStart + BLOCK_SIZE, rows);\n            final int iHeight = pEnd - pStart;\n            for (int jBlock = 0; jBlock < blockColumns; ++jBlock, ++blockIndex) {\n                final int qStart = jBlock * BLOCK_SIZE;\n                final int qEnd   = Math.min(qStart + BLOCK_SIZE, columns);\n                final int jWidth = qEnd - qStart;\n                blocks[blockIndex] = new double[iHeight * jWidth];\n            }\n        }\n\n        return blocks;\n\n    }",
    "comment": " Create a data array in blocks layout. <p> This method can be used to create the array argument of the {@link DenseRealMatrix#DenseRealMatrix(int, int, double[][], boolean)} constructor. </p> @param rows  the number of rows in the new matrix @param columns  the number of columns in the new matrix @return a new data array in blocks layout @see #toBlocksLayout(double[][]) @see #DenseRealMatrix(int, int, double[][], boolean) ",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "DenseRealMatrix.getColumnDimension",
    "class_name": "org.apache.commons.math.linear.DenseRealMatrix",
    "signature": "org.apache.commons.math.linear.DenseRealMatrix.getColumnDimension()",
    "snippet": "    @Override\n    public int getColumnDimension() {\n        return columns;\n    }",
    "comment": "{@inheritDoc} */",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "DenseRealMatrix.getData",
    "class_name": "org.apache.commons.math.linear.DenseRealMatrix",
    "signature": "org.apache.commons.math.linear.DenseRealMatrix.getData()",
    "snippet": "    @Override\n    public double[][] getData() {\n\n        final double[][] data = new double[getRowDimension()][getColumnDimension()];\n        final int lastColumns = columns - (blockColumns - 1) * BLOCK_SIZE;\n\n        for (int iBlock = 0; iBlock < blockRows; ++iBlock) {\n            final int pStart = iBlock * BLOCK_SIZE;\n            final int pEnd   = Math.min(pStart + BLOCK_SIZE, rows);\n            int regularPos   = 0;\n            int lastPos      = 0;\n            for (int p = pStart; p < pEnd; ++p) {\n                final double[] dataP = data[p];\n                int blockIndex = iBlock * blockColumns;\n                int dataPos    = 0;\n                for (int jBlock = 0; jBlock < blockColumns - 1; ++jBlock) {\n                    System.arraycopy(blocks[blockIndex++], regularPos, dataP, dataPos, BLOCK_SIZE);\n                    dataPos += BLOCK_SIZE;\n                }\n                System.arraycopy(blocks[blockIndex], lastPos, dataP, dataPos, lastColumns);\n                regularPos += BLOCK_SIZE;\n                lastPos    += lastColumns;\n            }\n        }\n\n        return data;\n        \n    }",
    "comment": "{@inheritDoc} */",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "DenseRealMatrix.getEntry",
    "class_name": "org.apache.commons.math.linear.DenseRealMatrix",
    "signature": "org.apache.commons.math.linear.DenseRealMatrix.getEntry(int,int)",
    "snippet": "    @Override\n    public double getEntry(final int row, final int column)\n        throws MatrixIndexException {\n        try {\n            final int iBlock = row    / BLOCK_SIZE;\n            final int jBlock = column / BLOCK_SIZE;\n            final int k      = (row    - iBlock * BLOCK_SIZE) * blockWidth(jBlock) +\n                               (column - jBlock * BLOCK_SIZE);\n            return blocks[iBlock * blockColumns + jBlock][k];\n        } catch (ArrayIndexOutOfBoundsException e) {\n            throw new MatrixIndexException(\n                    \"no entry at indices ({0}, {1}) in a {2}x{3} matrix\",\n                    row, column, getRowDimension(), getColumnDimension());\n        }\n    }",
    "comment": "{@inheritDoc} */",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "DenseRealMatrix.getRowDimension",
    "class_name": "org.apache.commons.math.linear.DenseRealMatrix",
    "signature": "org.apache.commons.math.linear.DenseRealMatrix.getRowDimension()",
    "snippet": "    @Override\n    public int getRowDimension() {\n        return rows;\n    }",
    "comment": "{@inheritDoc} */",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "DenseRealMatrix.multiply",
    "class_name": "org.apache.commons.math.linear.DenseRealMatrix",
    "signature": "org.apache.commons.math.linear.DenseRealMatrix.multiply(DenseRealMatrix)",
    "snippet": "    public DenseRealMatrix multiply(DenseRealMatrix m) throws IllegalArgumentException {\n\n        // safety check\n        MatrixUtils.checkMultiplicationCompatible(this, m);\n\n        final DenseRealMatrix out = new DenseRealMatrix(rows, m.columns);\n\n        // perform multiplication block-wise, to ensure good cache behavior\n        int blockIndex = 0;\n        for (int iBlock = 0; iBlock < out.blockRows; ++iBlock) {\n\n            final int pStart = iBlock * BLOCK_SIZE;\n            final int pEnd   = Math.min(pStart + BLOCK_SIZE, rows);\n\n            for (int jBlock = 0; jBlock < out.blockColumns; ++jBlock) {\n                final int jWidth = out.blockWidth(jBlock);\n                final int jWidth2 = jWidth  + jWidth;\n                final int jWidth3 = jWidth2 + jWidth;\n                final int jWidth4 = jWidth3 + jWidth;\n\n                // select current block\n                final double[] outBlock = out.blocks[blockIndex];\n\n                // perform multiplication on current block\n                for (int kBlock = 0; kBlock < blockColumns; ++kBlock) {\n                    final int kWidth = blockWidth(kBlock);\n                    final double[] tBlock = blocks[iBlock * blockColumns + kBlock];\n                    final double[] mBlock = m.blocks[kBlock * m.blockColumns + jBlock];\n                    for (int p = pStart, k = 0; p < pEnd; ++p) {\n                        final int lStart = (p - pStart) * kWidth;\n                        final int lEnd   = lStart + kWidth;\n                        for (int nStart = 0; nStart < jWidth; ++nStart) {\n                            double sum = 0;\n                            int l = lStart;\n                            int n = nStart;\n                            while (l < lEnd - 3) {\n                                sum += tBlock[l] * mBlock[n] +\n                                       tBlock[l + 1] * mBlock[n + jWidth] +\n                                       tBlock[l + 2] * mBlock[n + jWidth2] +\n                                       tBlock[l + 3] * mBlock[n + jWidth3];\n                                l += 4;\n                                n += jWidth4;\n                            }\n                            while (l < lEnd) {\n                                sum += tBlock[l++] * mBlock[n];\n                                n += jWidth;\n                            }\n                            outBlock[k++] += sum;\n                        }\n                    }\n                }\n\n                // go to next block\n                ++blockIndex;\n\n            }\n        }\n\n        return out;\n\n    }",
    "comment": " Returns the result of postmultiplying this by m.  @param m    matrix to postmultiply by @return     this * m @throws     IllegalArgumentException if columnDimension(this) != rowDimension(m) ",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "DenseRealMatrix.multiply",
    "class_name": "org.apache.commons.math.linear.DenseRealMatrix",
    "signature": "org.apache.commons.math.linear.DenseRealMatrix.multiply(RealMatrix)",
    "snippet": "    @Override\n    public DenseRealMatrix multiply(final RealMatrix m)\n        throws IllegalArgumentException {\n        try {\n            return multiply((DenseRealMatrix) m);\n        } catch (ClassCastException cce) {\n\n            // safety check\n            MatrixUtils.checkMultiplicationCompatible(this, m);\n\n            final DenseRealMatrix out = new DenseRealMatrix(rows, m.getColumnDimension());\n\n            // perform multiplication block-wise, to ensure good cache behavior\n            int blockIndex = 0;\n            for (int iBlock = 0; iBlock < out.blockRows; ++iBlock) {\n\n                final int pStart = iBlock * BLOCK_SIZE;\n                final int pEnd   = Math.min(pStart + BLOCK_SIZE, rows);\n\n                for (int jBlock = 0; jBlock < out.blockColumns; ++jBlock) {\n\n                    final int qStart = jBlock * BLOCK_SIZE;\n                    final int qEnd   = Math.min(qStart + BLOCK_SIZE, m.getColumnDimension());\n\n                    // select current block\n                    final double[] outBlock = out.blocks[blockIndex];\n\n                    // perform multiplication on current block\n                    for (int kBlock = 0; kBlock < blockColumns; ++kBlock) {\n                        final int kWidth      = blockWidth(kBlock);\n                        final double[] tBlock = blocks[iBlock * blockColumns + kBlock];\n                        final int rStart      = kBlock * BLOCK_SIZE;\n                        for (int p = pStart, k = 0; p < pEnd; ++p) {\n                            final int lStart = (p - pStart) * kWidth;\n                            final int lEnd   = lStart + kWidth;\n                            for (int q = qStart; q < qEnd; ++q) {\n                                double sum = 0;\n                                for (int l = lStart, r = rStart; l < lEnd; ++l, ++r) {\n                                    sum += tBlock[l] * m.getEntry(r, q);\n                                }\n                                outBlock[k++] += sum;\n                            }\n                        }\n                    }\n\n                    // go to next block\n                    ++blockIndex;\n\n                }\n            }\n\n            return out;\n\n        }\n    }",
    "comment": "{@inheritDoc} */",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "DenseRealMatrix.toBlocksLayout",
    "class_name": "org.apache.commons.math.linear.DenseRealMatrix",
    "signature": "org.apache.commons.math.linear.DenseRealMatrix.toBlocksLayout(double[][])",
    "snippet": "    public static double[][] toBlocksLayout(final double[][] rawData)\n        throws IllegalArgumentException {\n\n        final int rows         = rawData.length;\n        final int columns      = rawData[0].length;\n        final int blockRows    = (rows    + BLOCK_SIZE - 1) / BLOCK_SIZE;\n        final int blockColumns = (columns + BLOCK_SIZE - 1) / BLOCK_SIZE;\n\n        // safety checks\n        for (int i = 0; i < rawData.length; ++i) {\n            final int length = rawData[i].length;\n            if (length != columns) {\n                throw MathRuntimeException.createIllegalArgumentException(\n                        \"some rows have length {0} while others have length {1}\",\n                        columns, length); \n            }\n        }\n\n        // convert array\n        final double[][] blocks = new double[blockRows * blockColumns][];\n        for (int iBlock = 0, blockIndex = 0; iBlock < blockRows; ++iBlock) {\n            final int pStart  = iBlock * BLOCK_SIZE;\n            final int pEnd    = Math.min(pStart + BLOCK_SIZE, rows);\n            final int iHeight = pEnd - pStart;\n            for (int jBlock = 0; jBlock < blockColumns; ++jBlock, ++blockIndex) {\n                final int qStart = jBlock * BLOCK_SIZE;\n                final int qEnd   = Math.min(qStart + BLOCK_SIZE, columns);\n                final int jWidth = qEnd - qStart;\n\n                // allocate new block\n                final double[] block = new double[iHeight * jWidth];\n                blocks[blockIndex] = block;\n\n                // copy data\n                for (int p = pStart, index = 0; p < pEnd; ++p, index += jWidth) {\n                    System.arraycopy(rawData[p], qStart, block, index, jWidth);\n                }\n\n            }\n        }\n\n        return blocks;\n\n    }",
    "comment": " Convert a data array from raw layout to blocks layout. <p> Raw layout is the straightforward layout where element at row i and column j is in array element <code>rawData[i][j]</code>. Blocks layout is the layout used in {@link DenseRealMatrix} instances, where the matrix is split in square blocks (except at right and bottom side where blocks may be rectangular to fit matrix size) and each block is stored in a flattened one-dimensional array. </p> <p> This method creates an array in blocks layout from an input array in raw layout. It can be used to provide the array argument of the {@link DenseRealMatrix#DenseRealMatrix(int, int, double[][], boolean)} constructor. </p> @param rawData data array in raw layout @return a new data array containing the same entries but in blocks layout @exception IllegalArgumentException if <code>rawData</code> is not rectangular (not all rows have the same length) @see #createBlocksLayout(int, int) @see #DenseRealMatrix(int, int, double[][], boolean) ",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "DenseRealMatrix.transpose",
    "class_name": "org.apache.commons.math.linear.DenseRealMatrix",
    "signature": "org.apache.commons.math.linear.DenseRealMatrix.transpose()",
    "snippet": "    @Override\n    public DenseRealMatrix transpose() {\n\n        final int nRows = getRowDimension();\n        final int nCols = getColumnDimension();\n        final DenseRealMatrix out = new DenseRealMatrix(nCols, nRows);\n\n        // perform transpose block-wise, to ensure good cache behavior\n        int blockIndex = 0;\n        for (int iBlock = 0; iBlock < blockColumns; ++iBlock) {\n            for (int jBlock = 0; jBlock < blockRows; ++jBlock) {\n\n                // transpose current block\n                final double[] outBlock = out.blocks[blockIndex];\n                final double[] tBlock   = blocks[jBlock * blockColumns + iBlock];\n                final int      pStart   = iBlock * BLOCK_SIZE;\n                final int      pEnd     = Math.min(pStart + BLOCK_SIZE, columns);\n                final int      qStart   = jBlock * BLOCK_SIZE;\n                final int      qEnd     = Math.min(qStart + BLOCK_SIZE, rows);\n                for (int p = pStart, k = 0; p < pEnd; ++p) {\n                    final int lInc = pEnd - pStart;\n                    for (int q = qStart, l = p - pStart; q < qEnd; ++q, l+= lInc) {\n                        outBlock[k++] = tBlock[l];\n                    }\n                }\n\n                // go to next block\n                ++blockIndex;\n\n            }\n        }\n\n        return out;\n\n    }",
    "comment": "{@inheritDoc} */",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "MatrixUtils.checkMultiplicationCompatible",
    "class_name": "org.apache.commons.math.linear.MatrixUtils",
    "signature": "org.apache.commons.math.linear.MatrixUtils.checkMultiplicationCompatible(AnyMatrix,AnyMatrix)",
    "snippet": "    public static void checkMultiplicationCompatible(final AnyMatrix left, final AnyMatrix right)\n        throws IllegalArgumentException {\n        if (left.getColumnDimension() != right.getRowDimension()) {\n            throw MathRuntimeException.createIllegalArgumentException(\n                    \"{0}x{1} and {2}x{3} matrices are not multiplication compatible\",\n                    left.getRowDimension(), left.getColumnDimension(),\n                    right.getRowDimension(), right.getColumnDimension());\n        }\n    }",
    "comment": " Check if matrices are multiplication compatible @param left left hand side matrix @param right right hand side matrix @exception IllegalArgumentException if matrices are not multiplication compatible ",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  },
  {
    "name": "MatrixUtils.createRealMatrix",
    "class_name": "org.apache.commons.math.linear.MatrixUtils",
    "signature": "org.apache.commons.math.linear.MatrixUtils.createRealMatrix(double[][])",
    "snippet": "    public static RealMatrix createRealMatrix(double[][] data) {\n        return new DenseRealMatrix(data);\n    }",
    "comment": " Returns a {@link RealMatrix} whose entries are the the values in the the input array.  The input array is copied, not referenced.  @param data input array @return  RealMatrix containing the values of the array @throws IllegalArgumentException if <code>data</code> is not rectangular (not all rows have the same length) or empty @throws NullPointerException if <code>data</code> is null @see #createRealMatrix(int, int) ",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 1
  }
]