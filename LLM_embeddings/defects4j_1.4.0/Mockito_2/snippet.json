[
  {
    "name": "Mockito.after",
    "class_name": "org.mockito.Mockito",
    "signature": "org.mockito.Mockito.after(long)",
    "snippet": "    public static VerificationAfterDelay after(long millis) {\n        return new After(millis, VerificationModeFactory.times(1));\n    }",
    "comment": " Allows verifying over a given period. It causes a verify to wait for a specified period of time for a desired interaction rather than failing immediately if has not already happened. May be useful for testing in concurrent conditions. <p> This differs from {@link Mockito#timeout timeout()} in that after() will wait the full period, whereas timeout() will stop early as soon as verification passes, producing different behaviour when used with times(2), for example, which can pass and then later fail. In that case, timeout would pass as soon as times(2) passes, whereas after would run the full time, which point it will fail, as times(2) has failed. <p> It feels this feature should be used rarely - figure out a better way of testing your multi-threaded system <p> Not yet implemented to work with InOrder verification. <pre class=\"code\"><code class=\"java\"> passes after 100ms, if someMethod() has only been called once at that time. verify(mock, after(100)).someMethod(); above is an alias to: verify(mock, after(100).times(1)).someMethod();  passes if someMethod() is called <b>*exactly*</b> 2 times after the given timespan verify(mock, after(100).times(2)).someMethod();  passes if someMethod() has not been called after the given timespan verify(mock, after(100).never()).someMethod();  verifies someMethod() after a given time span using given verification mode useful only if you have your own custom verification modes. verify(mock, new After(100, yourOwnVerificationMode)).someMethod(); </code></pre>  See examples in javadoc for {@link Mockito} class  @param millis - time span in milliseconds  @return verification mode ",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "Mockito.timeout",
    "class_name": "org.mockito.Mockito",
    "signature": "org.mockito.Mockito.timeout(long)",
    "snippet": "    public static VerificationWithTimeout timeout(long millis) {\n        return new Timeout(millis, VerificationModeFactory.times(1));\n    }",
    "comment": " Allows verifying with timeout. It causes a verify to wait for a specified period of time for a desired interaction rather than fails immediately if has not already happened. May be useful for testing in concurrent conditions. <p> This differs from {@link Mockito#after after()} in that after() will wait the full period, unless the final test result is known early (e.g. if a never() fails), whereas timeout() will stop early as soon as verification passes, producing different behaviour when used with times(2), for example, which can pass and then later fail. In that case, timeout would pass as soon as times(2) passes, whereas after would run until times(2) failed, and then fail. <p> It feels this feature should be used rarely - figure out a better way of testing your multi-threaded system <p> Not yet implemented to work with InOrder verification. <pre class=\"code\"><code class=\"java\"> passes when someMethod() is called within given time span verify(mock, timeout(100)).someMethod(); above is an alias to: verify(mock, timeout(100).times(1)).someMethod();  passes as soon as someMethod() has been called 2 times before the given timeout verify(mock, timeout(100).times(2)).someMethod();  equivalent: this also passes as soon as someMethod() has been called 2 times before the given timeout verify(mock, timeout(100).atLeast(2)).someMethod();  verifies someMethod() within given time span using given verification mode useful only if you have your own custom verification modes. verify(mock, new Timeout(100, yourOwnVerificationMode)).someMethod(); </code></pre>  See examples in javadoc for {@link Mockito} class  @param millis - time span in milliseconds  @return verification mode ",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "MockitoAnnotations.initMocks",
    "class_name": "org.mockito.MockitoAnnotations",
    "signature": "org.mockito.MockitoAnnotations.initMocks(Object)",
    "snippet": "    public static void initMocks(Object testClass) {\n        if (testClass == null) {\n            throw new MockitoException(\"testClass cannot be null. For info how to use @Mock annotations see examples in javadoc for MockitoAnnotations class\");\n        }\n\n        AnnotationEngine annotationEngine = new GlobalConfiguration().getAnnotationEngine();\n        Class<?> clazz = testClass.getClass();\n\n        //below can be removed later, when we get read rid of deprecated stuff\n        if (annotationEngine.getClass() != new DefaultMockitoConfiguration().getAnnotationEngine().getClass()) {\n            //this means user has his own annotation engine and we have to respect that.\n            //we will do annotation processing the old way so that we are backwards compatible\n            while (clazz != Object.class) {\n                scanDeprecatedWay(annotationEngine, testClass, clazz);\n                clazz = clazz.getSuperclass();\n            }\n        }\n\n        //anyway act 'the new' way\n        annotationEngine.process(testClass.getClass(), testClass);\n    }",
    "comment": " Initializes objects annotated with Mockito annotations for given testClass: &#064;{@link org.mockito.Mock}, &#064;{@link Spy}, &#064;{@link Captor}, &#064;{@link InjectMocks}  <p> See examples in javadoc for {@link MockitoAnnotations} class. ",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "MockitoAnnotations.scanDeprecatedWay",
    "class_name": "org.mockito.MockitoAnnotations",
    "signature": "org.mockito.MockitoAnnotations.scanDeprecatedWay(AnnotationEngine,Object,Class)",
    "snippet": "    static void scanDeprecatedWay(AnnotationEngine annotationEngine, Object testClass, Class<?> clazz) {\n        Field[] fields = clazz.getDeclaredFields();\n\n        for (Field field : fields) {\n            processAnnotationDeprecatedWay(annotationEngine, testClass, field);\n        }\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "DefaultMockitoConfiguration.getAnnotationEngine",
    "class_name": "org.mockito.configuration.DefaultMockitoConfiguration",
    "signature": "org.mockito.configuration.DefaultMockitoConfiguration.getAnnotationEngine()",
    "snippet": "    public AnnotationEngine getAnnotationEngine() {\n        return new InjectingAnnotationEngine();\n    }",
    "comment": "(non-Javadoc) @see org.mockito.IMockitoConfiguration#getAnnotationEngine() ",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "ClassPathLoader.loadConfiguration",
    "class_name": "org.mockito.internal.configuration.ClassPathLoader",
    "signature": "org.mockito.internal.configuration.ClassPathLoader.loadConfiguration()",
    "snippet": "    @SuppressWarnings({\"unchecked\"})\n    public IMockitoConfiguration loadConfiguration() {\n        //Trying to get config from classpath\n        Class configClass;\n        try {\n            configClass = (Class) Class.forName(MOCKITO_CONFIGURATION_CLASS_NAME);\n        } catch (ClassNotFoundException e) {\n            //that's ok, it means there is no global config, using default one.\n            return null;\n        }\n\n        try {\n            return (IMockitoConfiguration) configClass.newInstance();\n        } catch (ClassCastException e) {\n            throw new MockitoConfigurationException(\"MockitoConfiguration class must implement \" + IMockitoConfiguration.class.getName() + \" interface.\", e);\n        } catch (Exception e) {\n            throw new MockitoConfigurationException(\"Unable to instantiate \" + MOCKITO_CONFIGURATION_CLASS_NAME +\" class. Does it have a safe, no-arg constructor?\", e);\n        }\n    }",
    "comment": " @return configuration loaded from classpath or null ",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "DefaultAnnotationEngine.DefaultAnnotationEngine",
    "class_name": "org.mockito.internal.configuration.DefaultAnnotationEngine",
    "signature": "org.mockito.internal.configuration.DefaultAnnotationEngine.DefaultAnnotationEngine()",
    "snippet": "    public DefaultAnnotationEngine() {\n        registerAnnotationProcessor(Mock.class, new MockAnnotationProcessor());\n        registerAnnotationProcessor(MockitoAnnotations.Mock.class, new MockitoAnnotationsMockAnnotationProcessor());\n        registerAnnotationProcessor(Captor.class, new CaptorAnnotationProcessor());\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "DefaultAnnotationEngine.process",
    "class_name": "org.mockito.internal.configuration.DefaultAnnotationEngine",
    "signature": "org.mockito.internal.configuration.DefaultAnnotationEngine.process(Class,Object)",
    "snippet": "    public void process(Class<?> clazz, Object testInstance) {\n        Field[] fields = clazz.getDeclaredFields();\n        for (Field field : fields) {\n            boolean alreadyAssigned = false;\n            for(Annotation annotation : field.getAnnotations()) {           \n                Object mock = createMockFor(annotation, field);\n                if (mock != null) {\n                    throwIfAlreadyAssigned(field, alreadyAssigned);                    \n                    alreadyAssigned = true;                    \n                    try {\n                        new FieldSetter(testInstance, field).set(mock);\n                    } catch (Exception e) {\n                        throw new MockitoException(\"Problems setting field \" + field.getName() + \" annotated with \"\n                                + annotation, e);\n                    }\n                }        \n            }\n        }\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "DefaultAnnotationEngine.registerAnnotationProcessor",
    "class_name": "org.mockito.internal.configuration.DefaultAnnotationEngine",
    "signature": "org.mockito.internal.configuration.DefaultAnnotationEngine.registerAnnotationProcessor(Class,FieldAnnotationProcessor)",
    "snippet": "    private <A extends Annotation> void registerAnnotationProcessor(Class<A> annotationClass, FieldAnnotationProcessor<A> fieldAnnotationProcessor) {\n        annotationProcessorMap.put(annotationClass, fieldAnnotationProcessor);\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "DefaultInjectionEngine.injectMocksOnFields",
    "class_name": "org.mockito.internal.configuration.DefaultInjectionEngine",
    "signature": "org.mockito.internal.configuration.DefaultInjectionEngine.injectMocksOnFields(Set,Set,Object)",
    "snippet": "    public void injectMocksOnFields(Set<Field> needingInjection, Set<Object> mocks, Object testClassInstance) {\n        MockInjection.onFields(needingInjection, testClassInstance)\n                .withMocks(mocks)\n                .tryConstructorInjection()\n                .tryPropertyOrFieldInjection()\n                .handleSpyAnnotation()\n                .apply();\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "GlobalConfiguration.GlobalConfiguration",
    "class_name": "org.mockito.internal.configuration.GlobalConfiguration",
    "signature": "org.mockito.internal.configuration.GlobalConfiguration.GlobalConfiguration()",
    "snippet": "    public GlobalConfiguration() {\n        //Configuration should be loaded only once but I cannot really test it\n        if (GLOBAL_CONFIGURATION.get() == null) {\n            GLOBAL_CONFIGURATION.set(createConfig());\n        }\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "GlobalConfiguration.createConfig",
    "class_name": "org.mockito.internal.configuration.GlobalConfiguration",
    "signature": "org.mockito.internal.configuration.GlobalConfiguration.createConfig()",
    "snippet": "    private IMockitoConfiguration createConfig() {\n        IMockitoConfiguration defaultConfiguration = new DefaultMockitoConfiguration();\n        IMockitoConfiguration config = new ClassPathLoader().loadConfiguration();\n        if (config != null) {\n            return config;\n        } else {\n            return defaultConfiguration;\n        }\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "GlobalConfiguration.getAnnotationEngine",
    "class_name": "org.mockito.internal.configuration.GlobalConfiguration",
    "signature": "org.mockito.internal.configuration.GlobalConfiguration.getAnnotationEngine()",
    "snippet": "    public AnnotationEngine getAnnotationEngine() {\n        return GLOBAL_CONFIGURATION.get().getAnnotationEngine();\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "GlobalConfiguration.getIt",
    "class_name": "org.mockito.internal.configuration.GlobalConfiguration",
    "signature": "org.mockito.internal.configuration.GlobalConfiguration.getIt()",
    "snippet": "    IMockitoConfiguration getIt() {\n        return GLOBAL_CONFIGURATION.get();\n    }",
    "comment": "back door for testing",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "GlobalConfiguration.validate",
    "class_name": "org.mockito.internal.configuration.GlobalConfiguration",
    "signature": "org.mockito.internal.configuration.GlobalConfiguration.validate()",
    "snippet": "    public static void validate() {\n        new GlobalConfiguration();\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "InjectingAnnotationEngine.injectMocks",
    "class_name": "org.mockito.internal.configuration.InjectingAnnotationEngine",
    "signature": "org.mockito.internal.configuration.InjectingAnnotationEngine.injectMocks(Object)",
    "snippet": "    public void injectMocks(final Object testClassInstance) {\n        Class<?> clazz = testClassInstance.getClass();\n        Set<Field> mockDependentFields = new HashSet<Field>();\n        Set<Object> mocks = newMockSafeHashSet();\n        \n        while (clazz != Object.class) {\n            new InjectMocksScanner(clazz).addTo(mockDependentFields);\n            new MockScanner(testClassInstance, clazz).addPreparedMocks(mocks);\n            clazz = clazz.getSuperclass();\n        }\n        \n        new DefaultInjectionEngine().injectMocksOnFields(mockDependentFields, mocks, testClassInstance);\n    }",
    "comment": " Initializes mock/spies dependencies for objects annotated with &#064;InjectMocks for given testClassInstance. <p> See examples in javadoc for {@link MockitoAnnotations} class.  @param testClassInstance Test class, usually <code>this</code> ",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "InjectingAnnotationEngine.process",
    "class_name": "org.mockito.internal.configuration.InjectingAnnotationEngine",
    "signature": "org.mockito.internal.configuration.InjectingAnnotationEngine.process(Class,Object)",
    "snippet": "    public void process(Class<?> clazz, Object testInstance) {\n        processIndependentAnnotations(testInstance.getClass(), testInstance);\n        processInjectMocks(testInstance.getClass(), testInstance);\n    }",
    "comment": " Process the fields of the test instance and create Mocks, Spies, Captors and inject them on fields annotated &#64;InjectMocks.  <p> This code process the test class and the super classes. <ol> <li>First create Mocks, Spies, Captors.</li> <li>Then try to inject them.</li> </ol>  @param clazz Not used @param testInstance The instance of the test, should not be null.  @see org.mockito.configuration.AnnotationEngine#process(Class, Object) ",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "InjectingAnnotationEngine.processIndependentAnnotations",
    "class_name": "org.mockito.internal.configuration.InjectingAnnotationEngine",
    "signature": "org.mockito.internal.configuration.InjectingAnnotationEngine.processIndependentAnnotations(Class,Object)",
    "snippet": "    private void processIndependentAnnotations(final Class<?> clazz, final Object testInstance) {\n        Class<?> classContext = clazz;\n        while (classContext != Object.class) {\n            //this will create @Mocks, @Captors, etc:\n            delegate.process(classContext, testInstance);\n            //this will create @Spies:\n            spyAnnotationEngine.process(classContext, testInstance);\n\n            classContext = classContext.getSuperclass();\n        }\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "InjectingAnnotationEngine.processInjectMocks",
    "class_name": "org.mockito.internal.configuration.InjectingAnnotationEngine",
    "signature": "org.mockito.internal.configuration.InjectingAnnotationEngine.processInjectMocks(Class,Object)",
    "snippet": "    private void processInjectMocks(final Class<?> clazz, final Object testInstance) {\n        Class<?> classContext = clazz;\n        while (classContext != Object.class) {\n            injectMocks(testInstance);\n            classContext = classContext.getSuperclass();\n        }\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "SpyAnnotationEngine.process",
    "class_name": "org.mockito.internal.configuration.SpyAnnotationEngine",
    "signature": "org.mockito.internal.configuration.SpyAnnotationEngine.process(Class,Object)",
    "snippet": "    @SuppressWarnings(\"deprecation\") // for MockitoAnnotations.Mock\n    public void process(Class<?> context, Object testInstance) {\n        Field[] fields = context.getDeclaredFields();\n        for (Field field : fields) {\n            if (field.isAnnotationPresent(Spy.class) && !field.isAnnotationPresent(InjectMocks.class)) {\n                assertNoIncompatibleAnnotations(Spy.class, field, Mock.class, org.mockito.MockitoAnnotations.Mock.class, Captor.class);\n                field.setAccessible(true);\n                Object instance;\n                try {\n                    instance = field.get(testInstance);\n                    assertNotInterface(instance, field.getType());\n                    if (new MockUtil().isMock(instance)) {\n                        // instance has been spied earlier\n                        // for example happens when MockitoAnnotations.initMocks is called two times.\n                        Mockito.reset(instance);\n                    } else if (instance != null) {\n                        field.set(testInstance, Mockito.mock(instance.getClass(), withSettings()\n                                .spiedInstance(instance)\n                                .defaultAnswer(Mockito.CALLS_REAL_METHODS)\n                                .name(field.getName())));\n                    } else {\n                        field.set(testInstance, newSpyInstance(testInstance, field));\n                    }\n                } catch (Exception e) {\n                    throw new MockitoException(\"Unable to initialize @Spy annotated field '\" + field.getName() + \"'.\\n\" + e.getMessage(), e);\n                }\n            }\n        }\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "ConstructorInjection.ConstructorInjection",
    "class_name": "org.mockito.internal.configuration.injection.ConstructorInjection",
    "signature": "org.mockito.internal.configuration.injection.ConstructorInjection.ConstructorInjection()",
    "snippet": "    public ConstructorInjection() { }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "MockInjection.onFields",
    "class_name": "org.mockito.internal.configuration.injection.MockInjection",
    "signature": "org.mockito.internal.configuration.injection.MockInjection.onFields(Set,Object)",
    "snippet": "    public static OngoingMockInjection onFields(Set<Field> fields, Object ofInstance) {\n        return new OngoingMockInjection(fields, ofInstance);\n    }",
    "comment": " Create a new configuration setup for fields   @param fields Fields needing mock injection @param ofInstance Instance owning the <code>field</code> @return New configuration builder ",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "OngoingMockInjection.apply",
    "class_name": "org.mockito.internal.configuration.injection.MockInjection$OngoingMockInjection",
    "signature": "org.mockito.internal.configuration.injection.MockInjection$OngoingMockInjection.apply()",
    "snippet": "        public void apply() {\n            for (Field field : fields) {\n                injectionStrategies.process(field, fieldOwner, mocks);\n                postInjectionStrategies.process(field, fieldOwner, mocks);\n            }\n        }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "OngoingMockInjection.handleSpyAnnotation",
    "class_name": "org.mockito.internal.configuration.injection.MockInjection$OngoingMockInjection",
    "signature": "org.mockito.internal.configuration.injection.MockInjection$OngoingMockInjection.handleSpyAnnotation()",
    "snippet": "        public OngoingMockInjection handleSpyAnnotation() {\n            postInjectionStrategies.thenTry(new SpyOnInjectedFieldsHandler());\n            return this;\n        }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "OngoingMockInjection.tryConstructorInjection",
    "class_name": "org.mockito.internal.configuration.injection.MockInjection$OngoingMockInjection",
    "signature": "org.mockito.internal.configuration.injection.MockInjection$OngoingMockInjection.tryConstructorInjection()",
    "snippet": "        public OngoingMockInjection tryConstructorInjection() {\n            injectionStrategies.thenTry(new ConstructorInjection());\n            return this;\n        }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "OngoingMockInjection.tryPropertyOrFieldInjection",
    "class_name": "org.mockito.internal.configuration.injection.MockInjection$OngoingMockInjection",
    "signature": "org.mockito.internal.configuration.injection.MockInjection$OngoingMockInjection.tryPropertyOrFieldInjection()",
    "snippet": "        public OngoingMockInjection tryPropertyOrFieldInjection() {\n            injectionStrategies.thenTry(new PropertyAndSetterInjection());\n            return this;\n        }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "OngoingMockInjection.withMocks",
    "class_name": "org.mockito.internal.configuration.injection.MockInjection$OngoingMockInjection",
    "signature": "org.mockito.internal.configuration.injection.MockInjection$OngoingMockInjection.withMocks(Set)",
    "snippet": "        public OngoingMockInjection withMocks(Set<Object> mocks) {\n            this.mocks.addAll(checkNotNull(mocks, \"mocks\"));\n            return this;\n        }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "MockInjectionStrategy.nop",
    "class_name": "org.mockito.internal.configuration.injection.MockInjectionStrategy",
    "signature": "org.mockito.internal.configuration.injection.MockInjectionStrategy.nop()",
    "snippet": "    public static final MockInjectionStrategy nop() {\n        return new MockInjectionStrategy() {\n            protected boolean processInjection(Field field, Object fieldOwner, Set<Object> mockCandidates) {\n                return false;\n            }\n        };\n    }",
    "comment": " NOP Strategy that will always try the next strategy. ",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "MockInjectionStrategy.thenTry",
    "class_name": "org.mockito.internal.configuration.injection.MockInjectionStrategy",
    "signature": "org.mockito.internal.configuration.injection.MockInjectionStrategy.thenTry(MockInjectionStrategy)",
    "snippet": "    public MockInjectionStrategy thenTry(MockInjectionStrategy strategy) {\n        if(nextStrategy != null) {\n            nextStrategy.thenTry(strategy);\n        } else {\n            nextStrategy = strategy;\n        }\n        return strategy;\n    }",
    "comment": " Enqueue next injection strategy.  <p> The implementation should take care of the actual calling if required. </p>  @param strategy Queued strategy. @return The passed strategy instance to allow chaining. ",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "NameBasedCandidateFilter.NameBasedCandidateFilter",
    "class_name": "org.mockito.internal.configuration.injection.filter.NameBasedCandidateFilter",
    "signature": "org.mockito.internal.configuration.injection.filter.NameBasedCandidateFilter.NameBasedCandidateFilter(MockCandidateFilter)",
    "snippet": "    public NameBasedCandidateFilter(MockCandidateFilter next) {\n        this.next = next;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "TypeBasedCandidateFilter.TypeBasedCandidateFilter",
    "class_name": "org.mockito.internal.configuration.injection.filter.TypeBasedCandidateFilter",
    "signature": "org.mockito.internal.configuration.injection.filter.TypeBasedCandidateFilter.TypeBasedCandidateFilter(MockCandidateFilter)",
    "snippet": "    public TypeBasedCandidateFilter(MockCandidateFilter next) {\n        this.next = next;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "InjectMocksScanner.InjectMocksScanner",
    "class_name": "org.mockito.internal.configuration.injection.scanner.InjectMocksScanner",
    "signature": "org.mockito.internal.configuration.injection.scanner.InjectMocksScanner.InjectMocksScanner(Class)",
    "snippet": "    public InjectMocksScanner(Class<?> clazz) {\n        this.clazz = clazz;\n    }",
    "comment": " Create a new InjectMocksScanner for the given clazz on the given instance  @param clazz    Current class in the hierarchy of the test ",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "InjectMocksScanner.addTo",
    "class_name": "org.mockito.internal.configuration.injection.scanner.InjectMocksScanner",
    "signature": "org.mockito.internal.configuration.injection.scanner.InjectMocksScanner.addTo(Set)",
    "snippet": "    public void addTo(Set<Field> mockDependentFields) {\n        mockDependentFields.addAll(scan());\n    }",
    "comment": " Add the fields annotated by @{@link InjectMocks}  @param mockDependentFields Set of fields annotated by  @{@link InjectMocks} ",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "InjectMocksScanner.scan",
    "class_name": "org.mockito.internal.configuration.injection.scanner.InjectMocksScanner",
    "signature": "org.mockito.internal.configuration.injection.scanner.InjectMocksScanner.scan()",
    "snippet": "    private Set<Field> scan() {\n        Set<Field> mockDependentFields = new HashSet<Field>();\n        Field[] fields = clazz.getDeclaredFields();\n        for (Field field : fields) {\n            if (null != field.getAnnotation(InjectMocks.class)) {\n                assertNoAnnotations(field, Mock.class, MockitoAnnotations.Mock.class, Captor.class);\n                mockDependentFields.add(field);\n            }\n        }\n\n        return mockDependentFields;\n    }",
    "comment": " Scan fields annotated by &#064;InjectMocks  @return Fields that depends on Mock ",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "MockScanner.MockScanner",
    "class_name": "org.mockito.internal.configuration.injection.scanner.MockScanner",
    "signature": "org.mockito.internal.configuration.injection.scanner.MockScanner.MockScanner(Object,Class)",
    "snippet": "    public MockScanner(Object instance, Class<?> clazz) {\n        this.instance = instance;\n        this.clazz = clazz;\n    }",
    "comment": " Creates a MockScanner.  @param instance The test instance @param clazz    The class in the type hierarchy of this instance. ",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "MockScanner.addPreparedMocks",
    "class_name": "org.mockito.internal.configuration.injection.scanner.MockScanner",
    "signature": "org.mockito.internal.configuration.injection.scanner.MockScanner.addPreparedMocks(Set)",
    "snippet": "    public void addPreparedMocks(Set<Object> mocks) {\n        mocks.addAll(scan());\n    }",
    "comment": " Add the scanned and prepared mock instance to the given collection.  <p> The preparation of mocks consists only in defining a MockName if not already set. </p>  @param mocks Set of mocks ",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "MockScanner.scan",
    "class_name": "org.mockito.internal.configuration.injection.scanner.MockScanner",
    "signature": "org.mockito.internal.configuration.injection.scanner.MockScanner.scan()",
    "snippet": "    private Set<Object> scan() {\n        Set<Object> mocks = newMockSafeHashSet();\n        for (Field field : clazz.getDeclaredFields()) {\n            // mock or spies only\n            FieldReader fieldReader = new FieldReader(instance, field);\n\n            Object mockInstance = preparedMock(fieldReader.read(), field);\n            if (mockInstance != null) {\n                mocks.add(mockInstance);\n            }\n        }\n        return mocks;\n    }",
    "comment": " Scan and prepare mocks for the given <code>testClassInstance</code> and <code>clazz</code> in the type hierarchy.  @return A prepared set of mock ",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "PluginFinder.PluginFinder",
    "class_name": "org.mockito.internal.configuration.plugins.PluginFinder",
    "signature": "org.mockito.internal.configuration.plugins.PluginFinder.PluginFinder(PluginSwitch)",
    "snippet": "    public PluginFinder(PluginSwitch pluginSwitch) {\n        this.pluginSwitch = pluginSwitch;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "PluginFinder.findPluginClass",
    "class_name": "org.mockito.internal.configuration.plugins.PluginFinder",
    "signature": "org.mockito.internal.configuration.plugins.PluginFinder.findPluginClass(Iterable)",
    "snippet": "    String findPluginClass(Iterable<URL> resources) {\n        for (URL resource : resources) {\n            InputStream s = null;\n            try {\n                s = resource.openStream();\n                String pluginClassName = new PluginFileReader().readPluginClass(s);\n                if (pluginClassName == null) {\n                    //For backwards compatibility\n                    //If the resource does not have plugin class name we're ignoring it\n                    continue;\n                }\n                if (!pluginSwitch.isEnabled(pluginClassName)) {\n                    continue;\n                }\n                return pluginClassName;\n            } catch(Exception e) {\n                throw new MockitoException(\"Problems reading plugin implementation from: \" + resource, e);\n            } finally {\n                IOUtil.closeQuietly(s);\n            }\n        }\n        return null;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "PluginLoader.PluginLoader",
    "class_name": "org.mockito.internal.configuration.plugins.PluginLoader",
    "signature": "org.mockito.internal.configuration.plugins.PluginLoader.PluginLoader(PluginSwitch)",
    "snippet": "    public PluginLoader(PluginSwitch pluginSwitch) {\n        this.pluginSwitch = pluginSwitch;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "PluginLoader.loadImpl",
    "class_name": "org.mockito.internal.configuration.plugins.PluginLoader",
    "signature": "org.mockito.internal.configuration.plugins.PluginLoader.loadImpl(Class)",
    "snippet": "    <T> T loadImpl(Class<T> service) {\n        ClassLoader loader = Thread.currentThread().getContextClassLoader();\n        if (loader == null) {\n            loader = ClassLoader.getSystemClassLoader();\n        }\n        Enumeration<URL> resources;\n        try {\n            resources = loader.getResources(\"mockito-extensions/\" + service.getName());\n        } catch (IOException e) {\n            throw new MockitoException(\"Failed to load \" + service, e);\n        }\n\n        try {\n            String foundPluginClass = new PluginFinder(pluginSwitch).findPluginClass(Iterables.toIterable(resources));\n            if (foundPluginClass != null) {\n                Class<?> pluginClass = loader.loadClass(foundPluginClass);\n                Object plugin = pluginClass.newInstance();\n                return service.cast(plugin);\n            }\n            return null;\n        } catch (Exception e) {\n            throw new MockitoConfigurationException(\n                    \"Failed to load \" + service + \" implementation declared in \" + resources, e);\n        }\n    }",
    "comment": " Equivalent to {@link java.util.ServiceLoader#load} but without requiring Java 6 / Android 2.3 (Gingerbread). ",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "PluginLoader.loadPlugin",
    "class_name": "org.mockito.internal.configuration.plugins.PluginLoader",
    "signature": "org.mockito.internal.configuration.plugins.PluginLoader.loadPlugin(Class,String)",
    "snippet": "    <T> T loadPlugin(Class<T> pluginType, String defaultPluginClassName) {\n        T plugin = loadImpl(pluginType);\n        if (plugin != null) {\n            return plugin;\n        }\n\n        try {\n            // Default implementation. Use our own ClassLoader instead of the context\n            // ClassLoader, as the default implementation is assumed to be part of\n            // Mockito and may not be available via the context ClassLoader.\n            return pluginType.cast(Class.forName(defaultPluginClassName).newInstance());\n        } catch (Exception e) {\n            throw new MockitoException(\"Internal problem occurred, please report it. \" +\n                    \"Mockito is unable to load the default implementation of class that is a part of Mockito distribution. \" +\n                    \"Failed to load \" + pluginType, e);\n        }\n    }",
    "comment": " Scans the classpath for given pluginType. If not found, default class is used. ",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "PluginRegistry.getMockMaker",
    "class_name": "org.mockito.internal.configuration.plugins.PluginRegistry",
    "signature": "org.mockito.internal.configuration.plugins.PluginRegistry.getMockMaker()",
    "snippet": "    MockMaker getMockMaker() {\n        return mockMaker;\n    }",
    "comment": " Returns the implementation of the mock maker available for the current runtime.  <p>Returns {@link org.mockito.internal.creation.cglib.CglibMockMaker} if no {@link org.mockito.plugins.MockMaker} extension exists or is visible in the current classpath.</p> ",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "Plugins.getMockMaker",
    "class_name": "org.mockito.internal.configuration.plugins.Plugins",
    "signature": "org.mockito.internal.configuration.plugins.Plugins.getMockMaker()",
    "snippet": "    public static MockMaker getMockMaker() {\n        return registry.getMockMaker();\n    }",
    "comment": " Returns the implementation of the mock maker available for the current runtime.  <p>Returns {@link org.mockito.internal.creation.cglib.CglibMockMaker} if no {@link org.mockito.plugins.MockMaker} extension exists or is visible in the current classpath.</p> ",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "ArgumentMatcherStorageImpl.reset",
    "class_name": "org.mockito.internal.progress.ArgumentMatcherStorageImpl",
    "signature": "org.mockito.internal.progress.ArgumentMatcherStorageImpl.reset()",
    "snippet": "    public void reset() {\n        matcherStack.clear();\n    }",
    "comment": "(non-Javadoc) @see org.mockito.internal.progress.ArgumentMatcherStorage#reset() ",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "ArgumentMatcherStorageImpl.validateState",
    "class_name": "org.mockito.internal.progress.ArgumentMatcherStorageImpl",
    "signature": "org.mockito.internal.progress.ArgumentMatcherStorageImpl.validateState()",
    "snippet": "    public void validateState() {\n        if (!matcherStack.isEmpty()) {\n            ArrayList lastMatchers = new ArrayList<LocalizedMatcher>(matcherStack);\n            matcherStack.clear();\n            new Reporter().misplacedArgumentMatcher(lastMatchers);\n        }\n    }",
    "comment": "(non-Javadoc) @see org.mockito.internal.progress.ArgumentMatcherStorage#validateState() ",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "MockingProgressImpl.getArgumentMatcherStorage",
    "class_name": "org.mockito.internal.progress.MockingProgressImpl",
    "signature": "org.mockito.internal.progress.MockingProgressImpl.getArgumentMatcherStorage()",
    "snippet": "    public ArgumentMatcherStorage getArgumentMatcherStorage() {\n        return argumentMatcherStorage;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "MockingProgressImpl.reset",
    "class_name": "org.mockito.internal.progress.MockingProgressImpl",
    "signature": "org.mockito.internal.progress.MockingProgressImpl.reset()",
    "snippet": "    public void reset() {\n        stubbingInProgress = null;\n        verificationMode = null;\n        getArgumentMatcherStorage().reset();\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "MockingProgressImpl.resetOngoingStubbing",
    "class_name": "org.mockito.internal.progress.MockingProgressImpl",
    "signature": "org.mockito.internal.progress.MockingProgressImpl.resetOngoingStubbing()",
    "snippet": "    public void resetOngoingStubbing() {\n        iOngoingStubbing = null;\n    }",
    "comment": "(non-Javadoc) @see org.mockito.internal.progress.MockingProgress#resetOngoingStubbing() ",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "MockingProgressImpl.validateMostStuff",
    "class_name": "org.mockito.internal.progress.MockingProgressImpl",
    "signature": "org.mockito.internal.progress.MockingProgressImpl.validateMostStuff()",
    "snippet": "    private void validateMostStuff() {\n        //State is cool when GlobalConfiguration is already loaded\n        //this cannot really be tested functionally because I cannot dynamically mess up org.mockito.configuration.MockitoConfiguration class\n        GlobalConfiguration.validate();\n\n        if (verificationMode != null) {\n            Location location = verificationMode.getLocation();\n            verificationMode = null;\n            reporter.unfinishedVerificationException(location);\n        }\n\n        getArgumentMatcherStorage().validateState();\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "MockingProgressImpl.validateState",
    "class_name": "org.mockito.internal.progress.MockingProgressImpl",
    "signature": "org.mockito.internal.progress.MockingProgressImpl.validateState()",
    "snippet": "    public void validateState() {\n        validateMostStuff();\n        \n        //validate stubbing:\n        if (stubbingInProgress != null) {\n            Location temp = stubbingInProgress;\n            stubbingInProgress = null;\n            reporter.unfinishedStubbing(temp);\n        }\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "ThreadSafeMockingProgress.reset",
    "class_name": "org.mockito.internal.progress.ThreadSafeMockingProgress",
    "signature": "org.mockito.internal.progress.ThreadSafeMockingProgress.reset()",
    "snippet": "    public void reset() {\n        threadSafely().reset();\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "ThreadSafeMockingProgress.resetOngoingStubbing",
    "class_name": "org.mockito.internal.progress.ThreadSafeMockingProgress",
    "signature": "org.mockito.internal.progress.ThreadSafeMockingProgress.resetOngoingStubbing()",
    "snippet": "    public void resetOngoingStubbing() {\n        threadSafely().resetOngoingStubbing();\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "ThreadSafeMockingProgress.threadSafely",
    "class_name": "org.mockito.internal.progress.ThreadSafeMockingProgress",
    "signature": "org.mockito.internal.progress.ThreadSafeMockingProgress.threadSafely()",
    "snippet": "    static MockingProgress threadSafely() {\n        if (mockingProgress.get() == null) {\n            mockingProgress.set(new MockingProgressImpl());\n        }\n        return mockingProgress.get();\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "ThreadSafeMockingProgress.validateState",
    "class_name": "org.mockito.internal.progress.ThreadSafeMockingProgress",
    "signature": "org.mockito.internal.progress.ThreadSafeMockingProgress.validateState()",
    "snippet": "    public void validateState() {\n        threadSafely().validateState();\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "Checks.checkNotNull",
    "class_name": "org.mockito.internal.util.Checks",
    "signature": "org.mockito.internal.util.Checks.checkNotNull(T,String)",
    "snippet": "    public static <T> T checkNotNull(T value, String checkedValue) {\n        if(value == null) {\n            throw new NullPointerException(checkedValue + \" should not be null\");\n        }\n        return value;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "Timer.Timer",
    "class_name": "org.mockito.internal.util.Timer",
    "signature": "org.mockito.internal.util.Timer.Timer(long)",
    "snippet": "    public Timer(long durationMillis) {\n        this.durationMillis = durationMillis;\n    }",
    "comment": "",
    "is_bug": true,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "HashCodeAndEqualsSafeSet.addAll",
    "class_name": "org.mockito.internal.util.collections.HashCodeAndEqualsSafeSet",
    "signature": "org.mockito.internal.util.collections.HashCodeAndEqualsSafeSet.addAll(Collection)",
    "snippet": "    public boolean addAll(Collection<?> mocks) {\n        return backingHashSet.addAll(asWrappedMocks(mocks));\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "HashCodeAndEqualsSafeSet.asWrappedMocks",
    "class_name": "org.mockito.internal.util.collections.HashCodeAndEqualsSafeSet",
    "signature": "org.mockito.internal.util.collections.HashCodeAndEqualsSafeSet.asWrappedMocks(Collection)",
    "snippet": "    private HashSet<HashCodeAndEqualsMockWrapper> asWrappedMocks(Collection<?> mocks) {\n        Checks.checkNotNull(mocks, \"Passed collection should notify() be null\");\n        HashSet<HashCodeAndEqualsMockWrapper> hashSet = new HashSet<HashCodeAndEqualsMockWrapper>();\n        for (Object mock : mocks) {\n            assert ! (mock instanceof HashCodeAndEqualsMockWrapper) : \"WRONG\";\n            hashSet.add(HashCodeAndEqualsMockWrapper.of(mock));\n        }\n        return hashSet;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "HashCodeAndEqualsSafeSet.iterator",
    "class_name": "org.mockito.internal.util.collections.HashCodeAndEqualsSafeSet",
    "signature": "org.mockito.internal.util.collections.HashCodeAndEqualsSafeSet.iterator()",
    "snippet": "    public Iterator<Object> iterator() {\n        return new Iterator<Object>() {\n            private final Iterator<HashCodeAndEqualsMockWrapper> iterator = backingHashSet.iterator();\n\n            public boolean hasNext() {\n                return iterator.hasNext();\n            }\n\n            public Object next() {\n                return iterator.next().get();\n            }\n\n            public void remove() {\n                iterator.remove();\n            }\n        };\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "HashCodeAndEqualsSafeSet.of",
    "class_name": "org.mockito.internal.util.collections.HashCodeAndEqualsSafeSet",
    "signature": "org.mockito.internal.util.collections.HashCodeAndEqualsSafeSet.of(Iterable)",
    "snippet": "    public static HashCodeAndEqualsSafeSet of(Iterable<Object> objects) {\n        HashCodeAndEqualsSafeSet hashCodeAndEqualsSafeSet = new HashCodeAndEqualsSafeSet();\n        if (objects != null) {\n            for (Object mock : objects) {\n                hashCodeAndEqualsSafeSet.add(mock);\n            }\n        }\n        return hashCodeAndEqualsSafeSet;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "HashCodeAndEqualsSafeSet.of",
    "class_name": "org.mockito.internal.util.collections.HashCodeAndEqualsSafeSet",
    "signature": "org.mockito.internal.util.collections.HashCodeAndEqualsSafeSet.of(Object[])",
    "snippet": "    public static HashCodeAndEqualsSafeSet of(Object... mocks) {\n        return of(Arrays.asList(mocks));\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "Iterables.toIterable",
    "class_name": "org.mockito.internal.util.collections.Iterables",
    "signature": "org.mockito.internal.util.collections.Iterables.toIterable(Enumeration)",
    "snippet": "    public static <T> Iterable<T> toIterable(Enumeration<T> in) {\n        List<T> out = new LinkedList<T>();\n        while(in.hasMoreElements()) {\n            out.add(in.nextElement());\n        }\n        return out;\n    }",
    "comment": " Converts enumeration into iterable ",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "Sets.newMockSafeHashSet",
    "class_name": "org.mockito.internal.util.collections.Sets",
    "signature": "org.mockito.internal.util.collections.Sets.newMockSafeHashSet(Object[])",
    "snippet": "    public static Set<Object> newMockSafeHashSet(Object... mocks) {\n        return HashCodeAndEqualsSafeSet.of(mocks);\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "Times.Times",
    "class_name": "org.mockito.internal.verification.Times",
    "signature": "org.mockito.internal.verification.Times.Times(int)",
    "snippet": "    public Times(int wantedNumberOfInvocations) {\n        if (wantedNumberOfInvocations < 0) {\n            throw new MockitoException(\"Negative value is not allowed here\");\n        }\n        this.wantedCount = wantedNumberOfInvocations;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "VerificationModeFactory.times",
    "class_name": "org.mockito.internal.verification.VerificationModeFactory",
    "signature": "org.mockito.internal.verification.VerificationModeFactory.times(int)",
    "snippet": "    public static Times times(int wantedNumberOfInvocations) {\n        return new Times(wantedNumberOfInvocations);\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "VerificationOverTimeImpl.VerificationOverTimeImpl",
    "class_name": "org.mockito.internal.verification.VerificationOverTimeImpl",
    "signature": "org.mockito.internal.verification.VerificationOverTimeImpl.VerificationOverTimeImpl(long,long,VerificationMode,boolean)",
    "snippet": "    public VerificationOverTimeImpl(long pollingPeriodMillis, long durationMillis, VerificationMode delegate, boolean returnOnSuccess) {\n        this(pollingPeriodMillis, durationMillis, delegate, returnOnSuccess, new Timer(durationMillis));\n    }",
    "comment": " Create this verification mode, to be used to verify invocation ongoing data later.  @param pollingPeriodMillis The frequency to poll delegate.verify(), to check whether the delegate has been satisfied @param durationMillis The max time to wait (in millis) for the delegate verification mode to be satisfied @param delegate The verification mode to delegate overall success or failure to @param returnOnSuccess Whether to immediately return successfully once the delegate is satisfied (as in {@link org.mockito.verification.VerificationWithTimeout}, or to only return once the delegate is satisfied and the full duration has passed (as in {@link org.mockito.verification.VerificationAfterDelay}). ",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "VerificationOverTimeImpl.VerificationOverTimeImpl",
    "class_name": "org.mockito.internal.verification.VerificationOverTimeImpl",
    "signature": "org.mockito.internal.verification.VerificationOverTimeImpl.VerificationOverTimeImpl(long,long,VerificationMode,boolean,Timer)",
    "snippet": "    public VerificationOverTimeImpl(long pollingPeriodMillis, long durationMillis, VerificationMode delegate, boolean returnOnSuccess, Timer timer) {\n        this.pollingPeriodMillis = pollingPeriodMillis;\n        this.durationMillis = durationMillis;\n        this.delegate = delegate;\n        this.returnOnSuccess = returnOnSuccess;\n        this.timer = timer;\n    }",
    "comment": " Create this verification mode, to be used to verify invocation ongoing data later.  @param pollingPeriodMillis The frequency to poll delegate.verify(), to check whether the delegate has been satisfied @param durationMillis The max time to wait (in millis) for the delegate verification mode to be satisfied @param delegate The verification mode to delegate overall success or failure to @param returnOnSuccess Whether to immediately return successfully once the delegate is satisfied (as in {@link org.mockito.verification.VerificationWithTimeout}, or to only return once the delegate is satisfied and the full duration has passed (as in {@link org.mockito.verification.VerificationAfterDelay}). @param timer Checker of whether the duration of the verification is still acceptable ",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  }
]