[
  {
    "name": "FunctionUtils.add",
    "class_name": "org.apache.commons.math3.analysis.FunctionUtils",
    "signature": "org.apache.commons.math3.analysis.FunctionUtils.add(UnivariateFunction[])",
    "snippet": "    public static UnivariateFunction add(final UnivariateFunction ... f) {\n        return new UnivariateFunction() {\n            /** {@inheritDoc} */\n            public double value(double x) {\n                double r = f[0].value(x);\n                for (int i = 1; i < f.length; i++) {\n                    r += f[i].value(x);\n                }\n                return r;\n            }\n        };\n    }",
    "comment": " Adds functions.  @param f List of functions. @return a function that computes the sum of the functions. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "Sin.value",
    "class_name": "org.apache.commons.math3.analysis.function.Sin",
    "signature": "org.apache.commons.math3.analysis.function.Sin.value(double)",
    "snippet": "    public double value(double x) {\n        return FastMath.sin(x);\n    }",
    "comment": "{@inheritDoc} */",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "StepFunction.StepFunction",
    "class_name": "org.apache.commons.math3.analysis.function.StepFunction",
    "signature": "org.apache.commons.math3.analysis.function.StepFunction.StepFunction(double[],double[])",
    "snippet": "    public StepFunction(double[] x,\n                        double[] y)\n        throws NullArgumentException,\n               NoDataException,\n               DimensionMismatchException {\n        if (x == null ||\n            y == null) {\n            throw new NullArgumentException();\n        }\n        if (x.length == 0 ||\n            y.length == 0) {\n            throw new NoDataException();\n        }\n        if (y.length != x.length) {\n            throw new DimensionMismatchException(y.length, x.length);\n        }\n        MathArrays.checkOrder(x);\n\n        abscissa = MathArrays.copyOf(x);\n        ordinate = MathArrays.copyOf(y);\n    }",
    "comment": " Builds a step function from a list of arguments and the corresponding values. Specifically, returns the function h(x) defined by <pre><code> h(x) = y[0] for all x < x[1] y[1] for x[1] <= x < x[2] ... y[y.length - 1] for x >= x[x.length - 1] </code></pre> The value of {@code x[0]} is ignored, but it must be strictly less than {@code x[1]}.  @param x Domain values where the function changes value. @param y Values of the function. @throws org.apache.commons.math3.exception.NonMonotonicSequenceException if the {@code x} array is not sorted in strictly increasing order. @throws NullArgumentException if {@code x} or {@code y} are {@code null}. @throws NoDataException if {@code x} or {@code y} are zero-length. @throws DimensionMismatchException if {@code x} and {@code y} do not have the same length. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "StepFunction.value",
    "class_name": "org.apache.commons.math3.analysis.function.StepFunction",
    "signature": "org.apache.commons.math3.analysis.function.StepFunction.value(double)",
    "snippet": "    public double value(double x) {\n        int index = Arrays.binarySearch(abscissa, x);\n        double fx = 0;\n\n        if (index < -1) {\n            // \"x\" is between \"abscissa[-index-2]\" and \"abscissa[-index-1]\".\n            fx = ordinate[-index-2];\n        } else if (index >= 0) {\n            // \"x\" is exactly \"abscissa[index]\".\n            fx = ordinate[index];\n        } else {\n            // Otherwise, \"x\" is smaller than the first value in \"abscissa\"\n            // (hence the returned value should be \"ordinate[0]\").\n            fx = ordinate[0];\n        }\n\n        return fx;\n    }",
    "comment": "{@inheritDoc} */",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "BaseAbstractUnivariateOptimizer.BaseAbstractUnivariateOptimizer",
    "class_name": "org.apache.commons.math3.optimization.univariate.BaseAbstractUnivariateOptimizer",
    "signature": "org.apache.commons.math3.optimization.univariate.BaseAbstractUnivariateOptimizer.BaseAbstractUnivariateOptimizer(ConvergenceChecker)",
    "snippet": "    protected BaseAbstractUnivariateOptimizer(ConvergenceChecker<UnivariatePointValuePair> checker) {\n        this.checker = checker;\n    }",
    "comment": " @param checker Convergence checking procedure. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "BaseAbstractUnivariateOptimizer.computeObjectiveValue",
    "class_name": "org.apache.commons.math3.optimization.univariate.BaseAbstractUnivariateOptimizer",
    "signature": "org.apache.commons.math3.optimization.univariate.BaseAbstractUnivariateOptimizer.computeObjectiveValue(double)",
    "snippet": "    protected double computeObjectiveValue(double point) {\n        try {\n            evaluations.incrementCount();\n        } catch (MaxCountExceededException e) {\n            throw new TooManyEvaluationsException(e.getMax());\n        }\n        return function.value(point);\n    }",
    "comment": " Compute the objective function value.  @param point Point at which the objective function must be evaluated. @return the objective function value at specified point. @throws TooManyEvaluationsException if the maximal number of evaluations is exceeded. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "BaseAbstractUnivariateOptimizer.getConvergenceChecker",
    "class_name": "org.apache.commons.math3.optimization.univariate.BaseAbstractUnivariateOptimizer",
    "signature": "org.apache.commons.math3.optimization.univariate.BaseAbstractUnivariateOptimizer.getConvergenceChecker()",
    "snippet": "    public ConvergenceChecker<UnivariatePointValuePair> getConvergenceChecker() {\n        return checker;\n    }",
    "comment": " {@inheritDoc} ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "BaseAbstractUnivariateOptimizer.getEvaluations",
    "class_name": "org.apache.commons.math3.optimization.univariate.BaseAbstractUnivariateOptimizer",
    "signature": "org.apache.commons.math3.optimization.univariate.BaseAbstractUnivariateOptimizer.getEvaluations()",
    "snippet": "    public int getEvaluations() {\n        return evaluations.getCount();\n    }",
    "comment": "{@inheritDoc} */",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "BaseAbstractUnivariateOptimizer.getGoalType",
    "class_name": "org.apache.commons.math3.optimization.univariate.BaseAbstractUnivariateOptimizer",
    "signature": "org.apache.commons.math3.optimization.univariate.BaseAbstractUnivariateOptimizer.getGoalType()",
    "snippet": "    public GoalType getGoalType() {\n        return goal;\n    }",
    "comment": " @return the optimization type. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "BaseAbstractUnivariateOptimizer.getMax",
    "class_name": "org.apache.commons.math3.optimization.univariate.BaseAbstractUnivariateOptimizer",
    "signature": "org.apache.commons.math3.optimization.univariate.BaseAbstractUnivariateOptimizer.getMax()",
    "snippet": "    public double getMax() {\n        return searchMax;\n    }",
    "comment": " @return the higher end of the search interval. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "BaseAbstractUnivariateOptimizer.getMin",
    "class_name": "org.apache.commons.math3.optimization.univariate.BaseAbstractUnivariateOptimizer",
    "signature": "org.apache.commons.math3.optimization.univariate.BaseAbstractUnivariateOptimizer.getMin()",
    "snippet": "    public double getMin() {\n        return searchMin;\n    }",
    "comment": " @return the lower end of the search interval. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "BaseAbstractUnivariateOptimizer.getStartValue",
    "class_name": "org.apache.commons.math3.optimization.univariate.BaseAbstractUnivariateOptimizer",
    "signature": "org.apache.commons.math3.optimization.univariate.BaseAbstractUnivariateOptimizer.getStartValue()",
    "snippet": "    public double getStartValue() {\n        return searchStart;\n    }",
    "comment": " @return the initial guess. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "BaseAbstractUnivariateOptimizer.optimize",
    "class_name": "org.apache.commons.math3.optimization.univariate.BaseAbstractUnivariateOptimizer",
    "signature": "org.apache.commons.math3.optimization.univariate.BaseAbstractUnivariateOptimizer.optimize(int,UnivariateFunction,GoalType,double,double,double)",
    "snippet": "    public UnivariatePointValuePair optimize(int maxEval, UnivariateFunction f,\n                                                 GoalType goalType,\n                                                 double min, double max,\n                                                 double startValue) {\n        // Checks.\n        if (f == null) {\n            throw new NullArgumentException();\n        }\n        if (goalType == null) {\n            throw new NullArgumentException();\n        }\n\n        // Reset.\n        searchMin = min;\n        searchMax = max;\n        searchStart = startValue;\n        goal = goalType;\n        function = f;\n        evaluations.setMaximalCount(maxEval);\n        evaluations.resetCount();\n\n        // Perform computation.\n        return doOptimize();\n    }",
    "comment": "{@inheritDoc} */",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "BrentOptimizer.BrentOptimizer",
    "class_name": "org.apache.commons.math3.optimization.univariate.BrentOptimizer",
    "signature": "org.apache.commons.math3.optimization.univariate.BrentOptimizer.BrentOptimizer(double,double)",
    "snippet": "    public BrentOptimizer(double rel,\n                          double abs) {\n        this(rel, abs, null);\n    }",
    "comment": " The arguments are used for implementing the original stopping criterion of Brent's algorithm. {@code abs} and {@code rel} define a tolerance {@code tol = rel |x| + abs}. {@code rel} should be no smaller than <em>2 macheps</em> and preferably not much less than <em>sqrt(macheps)</em>, where <em>macheps</em> is the relative machine precision. {@code abs} must be positive.  @param rel Relative threshold. @param abs Absolute threshold. @throws NotStrictlyPositiveException if {@code abs <= 0}. @throws NumberIsTooSmallException if {@code rel < 2 * Math.ulp(1d)}. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "BrentOptimizer.BrentOptimizer",
    "class_name": "org.apache.commons.math3.optimization.univariate.BrentOptimizer",
    "signature": "org.apache.commons.math3.optimization.univariate.BrentOptimizer.BrentOptimizer(double,double,ConvergenceChecker)",
    "snippet": "    public BrentOptimizer(double rel,\n                          double abs,\n                          ConvergenceChecker<UnivariatePointValuePair> checker) {\n        super(checker);\n\n        if (rel < MIN_RELATIVE_TOLERANCE) {\n            throw new NumberIsTooSmallException(rel, MIN_RELATIVE_TOLERANCE, true);\n        }\n        if (abs <= 0) {\n            throw new NotStrictlyPositiveException(abs);\n        }\n\n        relativeThreshold = rel;\n        absoluteThreshold = abs;\n    }",
    "comment": " The arguments are used implement the original stopping criterion of Brent's algorithm. {@code abs} and {@code rel} define a tolerance {@code tol = rel |x| + abs}. {@code rel} should be no smaller than <em>2 macheps</em> and preferably not much less than <em>sqrt(macheps)</em>, where <em>macheps</em> is the relative machine precision. {@code abs} must be positive.  @param rel Relative threshold. @param abs Absolute threshold. @param checker Additional, user-defined, convergence checking procedure. @throws NotStrictlyPositiveException if {@code abs <= 0}. @throws NumberIsTooSmallException if {@code rel < 2 * Math.ulp(1d)}. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "BrentOptimizer.best",
    "class_name": "org.apache.commons.math3.optimization.univariate.BrentOptimizer",
    "signature": "org.apache.commons.math3.optimization.univariate.BrentOptimizer.best(UnivariatePointValuePair,UnivariatePointValuePair,boolean)",
    "snippet": "    private UnivariatePointValuePair best(UnivariatePointValuePair a,\n                                          UnivariatePointValuePair b,\n                                          boolean isMinim) {\n        if (a == null) {\n            return b;\n        }\n        if (b == null) {\n            return a;\n        }\n\n        if (isMinim) {\n            return a.getValue() <= b.getValue() ? a : b;\n        } else {\n            return a.getValue() >= b.getValue() ? a : b;\n        }\n    }",
    "comment": " Selects the best of two points.  @param a Point and value. @param b Point and value. @param isMinim {@code true} if the selected point must be the one with the lowest value. @return the best point, or {@code null} if {@code a} and {@code b} are both {@code null}. When {@code a} and {@code b} have the same function value, {@code a} is returned. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "BrentOptimizer.doOptimize",
    "class_name": "org.apache.commons.math3.optimization.univariate.BrentOptimizer",
    "signature": "org.apache.commons.math3.optimization.univariate.BrentOptimizer.doOptimize()",
    "snippet": "    @Override\n    protected UnivariatePointValuePair doOptimize() {\n        final boolean isMinim = getGoalType() == GoalType.MINIMIZE;\n        final double lo = getMin();\n        final double mid = getStartValue();\n        final double hi = getMax();\n\n        // Optional additional convergence criteria.\n        final ConvergenceChecker<UnivariatePointValuePair> checker\n            = getConvergenceChecker();\n\n        double a;\n        double b;\n        if (lo < hi) {\n            a = lo;\n            b = hi;\n        } else {\n            a = hi;\n            b = lo;\n        }\n\n        double x = mid;\n        double v = x;\n        double w = x;\n        double d = 0;\n        double e = 0;\n        double fx = computeObjectiveValue(x);\n        if (!isMinim) {\n            fx = -fx;\n        }\n        double fv = fx;\n        double fw = fx;\n\n        UnivariatePointValuePair previous = null;\n        UnivariatePointValuePair current\n            = new UnivariatePointValuePair(x, isMinim ? fx : -fx);\n        // Best point encountered so far (which is the initial guess).\n\n        int iter = 0;\n        while (true) {\n            final double m = 0.5 * (a + b);\n            final double tol1 = relativeThreshold * FastMath.abs(x) + absoluteThreshold;\n            final double tol2 = 2 * tol1;\n\n            // Default stopping criterion.\n            final boolean stop = FastMath.abs(x - m) <= tol2 - 0.5 * (b - a);\n            if (!stop) {\n                double p = 0;\n                double q = 0;\n                double r = 0;\n                double u = 0;\n\n                if (FastMath.abs(e) > tol1) { // Fit parabola.\n                    r = (x - w) * (fx - fv);\n                    q = (x - v) * (fx - fw);\n                    p = (x - v) * q - (x - w) * r;\n                    q = 2 * (q - r);\n\n                    if (q > 0) {\n                        p = -p;\n                    } else {\n                        q = -q;\n                    }\n\n                    r = e;\n                    e = d;\n\n                    if (p > q * (a - x) &&\n                        p < q * (b - x) &&\n                        FastMath.abs(p) < FastMath.abs(0.5 * q * r)) {\n                        // Parabolic interpolation step.\n                        d = p / q;\n                        u = x + d;\n\n                        // f must not be evaluated too close to a or b.\n                        if (u - a < tol2 || b - u < tol2) {\n                            if (x <= m) {\n                                d = tol1;\n                            } else {\n                                d = -tol1;\n                            }\n                        }\n                    } else {\n                        // Golden section step.\n                        if (x < m) {\n                            e = b - x;\n                        } else {\n                            e = a - x;\n                        }\n                        d = GOLDEN_SECTION * e;\n                    }\n                } else {\n                    // Golden section step.\n                    if (x < m) {\n                        e = b - x;\n                    } else {\n                        e = a - x;\n                    }\n                    d = GOLDEN_SECTION * e;\n                }\n\n                // Update by at least \"tol1\".\n                if (FastMath.abs(d) < tol1) {\n                    if (d >= 0) {\n                        u = x + tol1;\n                    } else {\n                        u = x - tol1;\n                    }\n                } else {\n                    u = x + d;\n                }\n\n                double fu = computeObjectiveValue(u);\n                if (!isMinim) {\n                    fu = -fu;\n                }\n\n                // User-defined convergence checker.\n                previous = current;\n                current = new UnivariatePointValuePair(u, isMinim ? fu : -fu);\n\n                if (checker != null) {\n                    if (checker.converged(iter, previous, current)) {\n                        return best(current, previous, isMinim);\n                    }\n                }\n\n                // Update a, b, v, w and x.\n                if (fu <= fx) {\n                    if (u < x) {\n                        b = x;\n                    } else {\n                        a = x;\n                    }\n                    v = w;\n                    fv = fw;\n                    w = x;\n                    fw = fx;\n                    x = u;\n                    fx = fu;\n                } else {\n                    if (u < x) {\n                        a = u;\n                    } else {\n                        b = u;\n                    }\n                    if (fu <= fw ||\n                        Precision.equals(w, x)) {\n                        v = w;\n                        fv = fw;\n                        w = u;\n                        fw = fu;\n                    } else if (fu <= fv ||\n                               Precision.equals(v, x) ||\n                               Precision.equals(v, w)) {\n                        v = u;\n                        fv = fu;\n                    }\n                }\n            } else { // Default termination (Brent's criterion).\n                return\n                            best(current,\n                                 previous,\n                            isMinim);\n            }\n            ++iter;\n        }\n    }",
    "comment": "{@inheritDoc} */",
    "is_bug": true,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "UnivariatePointValuePair.UnivariatePointValuePair",
    "class_name": "org.apache.commons.math3.optimization.univariate.UnivariatePointValuePair",
    "signature": "org.apache.commons.math3.optimization.univariate.UnivariatePointValuePair.UnivariatePointValuePair(double,double)",
    "snippet": "    public UnivariatePointValuePair(final double point,\n                                    final double value) {\n        this.point = point;\n        this.value = value;\n    }",
    "comment": " Build a point/objective function value pair.  @param point Point. @param value Value of an objective function at the point ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "UnivariatePointValuePair.getPoint",
    "class_name": "org.apache.commons.math3.optimization.univariate.UnivariatePointValuePair",
    "signature": "org.apache.commons.math3.optimization.univariate.UnivariatePointValuePair.getPoint()",
    "snippet": "    public double getPoint() {\n        return point;\n    }",
    "comment": " Get the point.  @return the point. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "UnivariatePointValuePair.getValue",
    "class_name": "org.apache.commons.math3.optimization.univariate.UnivariatePointValuePair",
    "signature": "org.apache.commons.math3.optimization.univariate.UnivariatePointValuePair.getValue()",
    "snippet": "    public double getValue() {\n        return value;\n    }",
    "comment": " Get the value of the objective function.  @return the stored value of the objective function. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "FastMath.abs",
    "class_name": "org.apache.commons.math3.util.FastMath",
    "signature": "org.apache.commons.math3.util.FastMath.abs(double)",
    "snippet": "    public static double abs(double x) {\n        return (x < 0.0) ? -x : (x == 0.0) ? 0.0 : x; // -0.0 => +0.0\n    }",
    "comment": " Absolute value. @param x number from which absolute value is requested @return abs(x) ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "FastMath.abs",
    "class_name": "org.apache.commons.math3.util.FastMath",
    "signature": "org.apache.commons.math3.util.FastMath.abs(long)",
    "snippet": "    public static long abs(final long x) {\n        return (x < 0l) ? -x : x;\n    }",
    "comment": " Absolute value. @param x number from which absolute value is requested @return abs(x) ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "FastMath.cosQ",
    "class_name": "org.apache.commons.math3.util.FastMath",
    "signature": "org.apache.commons.math3.util.FastMath.cosQ(double,double)",
    "snippet": "    private static double cosQ(double xa, double xb) {\n        final double pi2a = 1.5707963267948966;\n        final double pi2b = 6.123233995736766E-17;\n\n        final double a = pi2a - xa;\n        double b = -(a - pi2a + xa);\n        b += pi2b - xb;\n\n        return sinQ(a, b);\n    }",
    "comment": " Compute cosine in the first quadrant by subtracting input from PI/2 and then calling sinQ.  This is more accurate as the input approaches PI/2. @param xa number from which cosine is requested @param xb extra bits for x (may be 0.0) @return cos(xa + xb) ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "FastMath.min",
    "class_name": "org.apache.commons.math3.util.FastMath",
    "signature": "org.apache.commons.math3.util.FastMath.min(int,int)",
    "snippet": "    public static int min(final int a, final int b) {\n        return (a <= b) ? a : b;\n    }",
    "comment": "Compute the minimum of two values @param a first value @param b second value @return a if a is lesser or equal to b, b otherwise ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "FastMath.polyCosine",
    "class_name": "org.apache.commons.math3.util.FastMath",
    "signature": "org.apache.commons.math3.util.FastMath.polyCosine(double)",
    "snippet": "    private static double polyCosine(double x) {\n        double x2 = x*x;\n\n        double p = 2.479773539153719E-5;\n        p = p * x2 + -0.0013888888689039883;\n        p = p * x2 + 0.041666666666621166;\n        p = p * x2 + -0.49999999999999994;\n        p *= x2;\n\n        return p;\n    }",
    "comment": " Computes cos(x) - 1, where |x| < 1/16. Use a Remez polynomial approximation. @param x a number smaller than 1/16 @return cos(x) - 1 ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "FastMath.polySine",
    "class_name": "org.apache.commons.math3.util.FastMath",
    "signature": "org.apache.commons.math3.util.FastMath.polySine(double)",
    "snippet": "    private static double polySine(final double x)\n    {\n        double x2 = x*x;\n\n        double p = 2.7553817452272217E-6;\n        p = p * x2 + -1.9841269659586505E-4;\n        p = p * x2 + 0.008333333333329196;\n        p = p * x2 + -0.16666666666666666;\n        //p *= x2;\n        //p *= x;\n        p = p * x2 * x;\n\n        return p;\n    }",
    "comment": " Computes sin(x) - x, where |x| < 1/16. Use a Remez polynomial approximation. @param x a number smaller than 1/16 @return sin(x) - x ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "FastMath.sin",
    "class_name": "org.apache.commons.math3.util.FastMath",
    "signature": "org.apache.commons.math3.util.FastMath.sin(double)",
    "snippet": "    public static double sin(double x) {\n        boolean negative = false;\n        int quadrant = 0;\n        double xa;\n        double xb = 0.0;\n\n        /* Take absolute value of the input */\n        xa = x;\n        if (x < 0) {\n            negative = true;\n            xa = -xa;\n        }\n\n        /* Check for zero and negative zero */\n        if (xa == 0.0) {\n            long bits = Double.doubleToLongBits(x);\n            if (bits < 0) {\n                return -0.0;\n            }\n            return 0.0;\n        }\n\n        if (xa != xa || xa == Double.POSITIVE_INFINITY) {\n            return Double.NaN;\n        }\n\n        /* Perform any argument reduction */\n        if (xa > 3294198.0) {\n            // PI * (2**20)\n            // Argument too big for CodyWaite reduction.  Must use\n            // PayneHanek.\n            double reduceResults[] = new double[3];\n            reducePayneHanek(xa, reduceResults);\n            quadrant = ((int) reduceResults[0]) & 3;\n            xa = reduceResults[1];\n            xb = reduceResults[2];\n        } else if (xa > 1.5707963267948966) {\n            final CodyWaite cw = new CodyWaite(xa, xb);\n            quadrant = cw.getK() & 3;\n            xa = cw.getRemA();\n            xb = cw.getRemB();\n        }\n\n        if (negative) {\n            quadrant ^= 2;  // Flip bit 1\n        }\n\n        switch (quadrant) {\n            case 0:\n                return sinQ(xa, xb);\n            case 1:\n                return cosQ(xa, xb);\n            case 2:\n                return -sinQ(xa, xb);\n            case 3:\n                return -cosQ(xa, xb);\n            default:\n                return Double.NaN;\n        }\n    }",
    "comment": " Sine function.  @param x Argument. @return sin(x) ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "FastMath.sinQ",
    "class_name": "org.apache.commons.math3.util.FastMath",
    "signature": "org.apache.commons.math3.util.FastMath.sinQ(double,double)",
    "snippet": "    private static double sinQ(double xa, double xb) {\n        int idx = (int) ((xa * 8.0) + 0.5);\n        final double epsilon = xa - EIGHTHS[idx]; //idx*0.125;\n\n        // Table lookups\n        final double sintA = SINE_TABLE_A[idx];\n        final double sintB = SINE_TABLE_B[idx];\n        final double costA = COSINE_TABLE_A[idx];\n        final double costB = COSINE_TABLE_B[idx];\n\n        // Polynomial eval of sin(epsilon), cos(epsilon)\n        double sinEpsA = epsilon;\n        double sinEpsB = polySine(epsilon);\n        final double cosEpsA = 1.0;\n        final double cosEpsB = polyCosine(epsilon);\n\n        // Split epsilon   xa + xb = x\n        final double temp = sinEpsA * HEX_40000000;\n        double temp2 = (sinEpsA + temp) - temp;\n        sinEpsB +=  sinEpsA - temp2;\n        sinEpsA = temp2;\n\n        /* Compute sin(x) by angle addition formula */\n        double result;\n\n        /* Compute the following sum:\n         *\n         * result = sintA + costA*sinEpsA + sintA*cosEpsB + costA*sinEpsB +\n         *          sintB + costB*sinEpsA + sintB*cosEpsB + costB*sinEpsB;\n         *\n         * Ranges of elements\n         *\n         * xxxtA   0            PI/2\n         * xxxtB   -1.5e-9      1.5e-9\n         * sinEpsA -0.0625      0.0625\n         * sinEpsB -6e-11       6e-11\n         * cosEpsA  1.0\n         * cosEpsB  0           -0.0625\n         *\n         */\n\n        //result = sintA + costA*sinEpsA + sintA*cosEpsB + costA*sinEpsB +\n        //          sintB + costB*sinEpsA + sintB*cosEpsB + costB*sinEpsB;\n\n        //result = sintA + sintA*cosEpsB + sintB + sintB * cosEpsB;\n        //result += costA*sinEpsA + costA*sinEpsB + costB*sinEpsA + costB * sinEpsB;\n        double a = 0;\n        double b = 0;\n\n        double t = sintA;\n        double c = a + t;\n        double d = -(c - a - t);\n        a = c;\n        b = b + d;\n\n        t = costA * sinEpsA;\n        c = a + t;\n        d = -(c - a - t);\n        a = c;\n        b = b + d;\n\n        b = b + sintA * cosEpsB + costA * sinEpsB;\n        /*\n    t = sintA*cosEpsB;\n    c = a + t;\n    d = -(c - a - t);\n    a = c;\n    b = b + d;\n\n    t = costA*sinEpsB;\n    c = a + t;\n    d = -(c - a - t);\n    a = c;\n    b = b + d;\n         */\n\n        b = b + sintB + costB * sinEpsA + sintB * cosEpsB + costB * sinEpsB;\n        /*\n    t = sintB;\n    c = a + t;\n    d = -(c - a - t);\n    a = c;\n    b = b + d;\n\n    t = costB*sinEpsA;\n    c = a + t;\n    d = -(c - a - t);\n    a = c;\n    b = b + d;\n\n    t = sintB*cosEpsB;\n    c = a + t;\n    d = -(c - a - t);\n    a = c;\n    b = b + d;\n\n    t = costB*sinEpsB;\n    c = a + t;\n    d = -(c - a - t);\n    a = c;\n    b = b + d;\n         */\n\n        if (xb != 0.0) {\n            t = ((costA + costB) * (cosEpsA + cosEpsB) -\n                 (sintA + sintB) * (sinEpsA + sinEpsB)) * xb;  // approximate cosine*xb\n            c = a + t;\n            d = -(c - a - t);\n            a = c;\n            b = b + d;\n        }\n\n        result = a + b;\n\n        return result;\n    }",
    "comment": " Compute sine over the first quadrant (0 < x < pi/2). Use combination of table lookup and rational polynomial expansion. @param xa number from which sine is requested @param xb extra bits for x (may be 0.0) @return sin(xa + xb) ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "FastMath.sqrt",
    "class_name": "org.apache.commons.math3.util.FastMath",
    "signature": "org.apache.commons.math3.util.FastMath.sqrt(double)",
    "snippet": "    public static double sqrt(final double a) {\n        return Math.sqrt(a);\n    }",
    "comment": "Compute the square root of a number. <p><b>Note:</b> this implementation currently delegates to {@link Math#sqrt} @param a number on which evaluation is done @return square root of a ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "FastMath.ulp",
    "class_name": "org.apache.commons.math3.util.FastMath",
    "signature": "org.apache.commons.math3.util.FastMath.ulp(double)",
    "snippet": "    public static double ulp(double x) {\n        if (Double.isInfinite(x)) {\n            return Double.POSITIVE_INFINITY;\n        }\n        return abs(x - Double.longBitsToDouble(Double.doubleToLongBits(x) ^ 1));\n    }",
    "comment": " Compute least significant bit (Unit in Last Position) for a number. @param x number from which ulp is requested @return ulp(x) ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "CodyWaite.getK",
    "class_name": "org.apache.commons.math3.util.FastMath$CodyWaite",
    "signature": "org.apache.commons.math3.util.FastMath$CodyWaite.getK()",
    "snippet": "        int getK() {\n            return finalK;\n        }",
    "comment": " @return k ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "CodyWaite.getRemA",
    "class_name": "org.apache.commons.math3.util.FastMath$CodyWaite",
    "signature": "org.apache.commons.math3.util.FastMath$CodyWaite.getRemA()",
    "snippet": "        double getRemA() {\n            return finalRemA;\n        }",
    "comment": " @return remA ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "CodyWaite.getRemB",
    "class_name": "org.apache.commons.math3.util.FastMath$CodyWaite",
    "signature": "org.apache.commons.math3.util.FastMath$CodyWaite.getRemB()",
    "snippet": "        double getRemB() {\n            return finalRemB;\n        }",
    "comment": " @return remB ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "Incrementor.Incrementor",
    "class_name": "org.apache.commons.math3.util.Incrementor",
    "signature": "org.apache.commons.math3.util.Incrementor.Incrementor()",
    "snippet": "    public Incrementor() {\n        this(0);\n    }",
    "comment": " Default constructor. For the new instance to be useful, the maximal count must be set by calling {@link #setMaximalCount(int) setMaximalCount}. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "Incrementor.Incrementor",
    "class_name": "org.apache.commons.math3.util.Incrementor",
    "signature": "org.apache.commons.math3.util.Incrementor.Incrementor(int)",
    "snippet": "    public Incrementor(int max) {\n        this(max,\n             new MaxCountExceededCallback() {\n                 /** {@inheritDoc} */\n                 public void trigger(int max) {\n                     throw new MaxCountExceededException(max);\n                 }\n             });\n    }",
    "comment": " Defines a maximal count.  @param max Maximal count. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "Incrementor.Incrementor",
    "class_name": "org.apache.commons.math3.util.Incrementor",
    "signature": "org.apache.commons.math3.util.Incrementor.Incrementor(int,MaxCountExceededCallback)",
    "snippet": "    public Incrementor(int max,\n                       MaxCountExceededCallback cb) {\n        if (cb == null){\n            throw new NullArgumentException();\n        }\n        maximalCount = max;\n        maxCountCallback = cb;\n    }",
    "comment": " Defines a maximal count and a callback method to be triggered at counter exhaustion.  @param max Maximal count. @param cb Function to be called when the maximal count has been reached. @throws NullArgumentException if {@code cb} is {@code null} ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "Incrementor.getCount",
    "class_name": "org.apache.commons.math3.util.Incrementor",
    "signature": "org.apache.commons.math3.util.Incrementor.getCount()",
    "snippet": "    public int getCount() {\n        return count;\n    }",
    "comment": " Gets the current count.  @return the current count. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "Incrementor.incrementCount",
    "class_name": "org.apache.commons.math3.util.Incrementor",
    "signature": "org.apache.commons.math3.util.Incrementor.incrementCount()",
    "snippet": "    public void incrementCount() {\n        if (++count > maximalCount) {\n            maxCountCallback.trigger(maximalCount);\n        }\n    }",
    "comment": " Adds one to the current iteration count. At counter exhaustion, this method will call the {@link MaxCountExceededCallback#trigger(int) trigger} method of the callback object passed to the {@link #Incrementor(int,MaxCountExceededCallback) constructor}. If not explictly set, a default callback is used that will throw a {@code MaxCountExceededException}.  @throws MaxCountExceededException at counter exhaustion, unless a custom {@link MaxCountExceededCallback callback} has been set at construction. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "Incrementor.resetCount",
    "class_name": "org.apache.commons.math3.util.Incrementor",
    "signature": "org.apache.commons.math3.util.Incrementor.resetCount()",
    "snippet": "    public void resetCount() {\n        count = 0;\n    }",
    "comment": " Resets the counter to 0. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "Incrementor.setMaximalCount",
    "class_name": "org.apache.commons.math3.util.Incrementor",
    "signature": "org.apache.commons.math3.util.Incrementor.setMaximalCount(int)",
    "snippet": "    public void setMaximalCount(int max) {\n        maximalCount = max;\n    }",
    "comment": " Sets the upper limit for the counter. This does not automatically reset the current count to zero (see {@link #resetCount()}).  @param max Upper limit of the counter. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "MathArrays.checkOrder",
    "class_name": "org.apache.commons.math3.util.MathArrays",
    "signature": "org.apache.commons.math3.util.MathArrays.checkOrder(double[])",
    "snippet": "    public static void checkOrder(double[] val) throws NonMonotonicSequenceException {\n        checkOrder(val, OrderDirection.INCREASING, true);\n    }",
    "comment": " Check that the given array is sorted in strictly increasing order.  @param val Values. @throws NonMonotonicSequenceException if the array is not sorted. @since 2.2 ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "MathArrays.checkOrder",
    "class_name": "org.apache.commons.math3.util.MathArrays",
    "signature": "org.apache.commons.math3.util.MathArrays.checkOrder(double[],OrderDirection,boolean)",
    "snippet": "    public static void checkOrder(double[] val, OrderDirection dir,\n                                  boolean strict) throws NonMonotonicSequenceException {\n        checkOrder(val, dir, strict, true);\n    }",
    "comment": " Check that the given array is sorted.  @param val Values. @param dir Ordering direction. @param strict Whether the order should be strict. @throws NonMonotonicSequenceException if the array is not sorted. @since 2.2 ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "MathArrays.checkOrder",
    "class_name": "org.apache.commons.math3.util.MathArrays",
    "signature": "org.apache.commons.math3.util.MathArrays.checkOrder(double[],OrderDirection,boolean,boolean)",
    "snippet": "    public static boolean checkOrder(double[] val, OrderDirection dir,\n                                     boolean strict, boolean abort)\n        throws NonMonotonicSequenceException {\n        double previous = val[0];\n        final int max = val.length;\n\n        int index;\n        ITEM:\n        for (index = 1; index < max; index++) {\n            switch (dir) {\n            case INCREASING:\n                if (strict) {\n                    if (val[index] <= previous) {\n                        break ITEM;\n                    }\n                } else {\n                    if (val[index] < previous) {\n                        break ITEM;\n                    }\n                }\n                break;\n            case DECREASING:\n                if (strict) {\n                    if (val[index] >= previous) {\n                        break ITEM;\n                    }\n                } else {\n                    if (val[index] > previous) {\n                        break ITEM;\n                    }\n                }\n                break;\n            default:\n                // Should never happen.\n                throw new MathInternalError();\n            }\n\n            previous = val[index];\n        }\n\n        if (index == max) {\n            // Loop completed.\n            return true;\n        }\n\n        // Loop early exit means wrong ordering.\n        if (abort) {\n            throw new NonMonotonicSequenceException(val[index], previous, index, dir, strict);\n        } else {\n            return false;\n        }\n    }",
    "comment": " Check that the given array is sorted.  @param val Values. @param dir Ordering direction. @param strict Whether the order should be strict. @param abort Whether to throw an exception if the check fails. @return {@code true} if the array is sorted. @throws NonMonotonicSequenceException if the array is not sorted and {@code abort} is {@code true}. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "MathArrays.copyOf",
    "class_name": "org.apache.commons.math3.util.MathArrays",
    "signature": "org.apache.commons.math3.util.MathArrays.copyOf(double[])",
    "snippet": "     public static double[] copyOf(double[] source) {\n         return copyOf(source, source.length);\n     }",
    "comment": " Creates a copy of the {@code source} array.  @param source Array to be copied. @return the copied array. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "MathArrays.copyOf",
    "class_name": "org.apache.commons.math3.util.MathArrays",
    "signature": "org.apache.commons.math3.util.MathArrays.copyOf(double[],int)",
    "snippet": "    public static double[] copyOf(double[] source, int len) {\n         final double[] output = new double[len];\n         System.arraycopy(source, 0, output, 0, FastMath.min(len, source.length));\n         return output;\n     }",
    "comment": " Creates a copy of the {@code source} array.  @param source Array to be copied. @param len Number of entries to copy. If smaller then the source length, the copy will be truncated, if larger it will padded with zeroes. @return the copied array. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "Precision.equals",
    "class_name": "org.apache.commons.math3.util.Precision",
    "signature": "org.apache.commons.math3.util.Precision.equals(double,double)",
    "snippet": "    public static boolean equals(double x, double y) {\n        return equals(x, y, 1);\n    }",
    "comment": " Returns true iff they are equal as defined by {@link #equals(double,double,int) equals(x, y, 1)}.  @param x first value @param y second value @return {@code true} if the values are equal. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "Precision.equals",
    "class_name": "org.apache.commons.math3.util.Precision",
    "signature": "org.apache.commons.math3.util.Precision.equals(double,double,int)",
    "snippet": "    public static boolean equals(double x, double y, int maxUlps) {\n        long xInt = Double.doubleToLongBits(x);\n        long yInt = Double.doubleToLongBits(y);\n\n        // Make lexicographically ordered as a two's-complement integer.\n        if (xInt < 0) {\n            xInt = SGN_MASK - xInt;\n        }\n        if (yInt < 0) {\n            yInt = SGN_MASK - yInt;\n        }\n\n        final boolean isEqual = FastMath.abs(xInt - yInt) <= maxUlps;\n\n        return isEqual && !Double.isNaN(x) && !Double.isNaN(y);\n    }",
    "comment": " Returns true if both arguments are equal or within the range of allowed error (inclusive). Two float numbers are considered equal if there are {@code (maxUlps - 1)} (or fewer) floating point numbers between them, i.e. two adjacent floating point numbers are considered equal. Adapted from <a href=\"http://www.cygnus-software.com/papers/comparingfloats/comparingfloats.htm\"> Bruce Dawson</a>  @param x first value @param y second value @param maxUlps {@code (maxUlps - 1)} is the number of floating point values between {@code x} and {@code y}. @return {@code true} if there are fewer than {@code maxUlps} floating point values between {@code x} and {@code y}. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  }
]