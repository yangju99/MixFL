[
  {
    "name": "Line.Line",
    "class_name": "org.apache.commons.math3.geometry.euclidean.threed.Line",
    "signature": "org.apache.commons.math3.geometry.euclidean.threed.Line.Line(Vector3D,Vector3D)",
    "snippet": "    public Line(final Vector3D p1, final Vector3D p2) throws MathIllegalArgumentException {\n        reset(p1, p2);\n    }",
    "comment": "Build a line from two points. @param p1 first point belonging to the line (this can be any point) @param p2 second point belonging to the line (this can be any point, different from p1) @exception MathIllegalArgumentException if the points are equal ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "Line.getDirection",
    "class_name": "org.apache.commons.math3.geometry.euclidean.threed.Line",
    "signature": "org.apache.commons.math3.geometry.euclidean.threed.Line.getDirection()",
    "snippet": "    public Vector3D getDirection() {\n        return direction;\n    }",
    "comment": "Get the normalized direction vector. @return normalized direction vector ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "Line.reset",
    "class_name": "org.apache.commons.math3.geometry.euclidean.threed.Line",
    "signature": "org.apache.commons.math3.geometry.euclidean.threed.Line.reset(Vector3D,Vector3D)",
    "snippet": "    public void reset(final Vector3D p1, final Vector3D p2) throws MathIllegalArgumentException {\n        final Vector3D delta = p2.subtract(p1);\n        final double norm2 = delta.getNormSq();\n        if (norm2 == 0.0) {\n            throw new MathIllegalArgumentException(LocalizedFormats.ZERO_NORM);\n        }\n        this.direction = new Vector3D(1.0 / FastMath.sqrt(norm2), delta);\n        zero = new Vector3D(1.0, p1, -p1.dotProduct(delta) / norm2, delta);\n    }",
    "comment": "Reset the instance as if built from two points. @param p1 first point belonging to the line (this can be any point) @param p2 second point belonging to the line (this can be any point, different from p1) @exception MathIllegalArgumentException if the points are equal ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "Line.revert",
    "class_name": "org.apache.commons.math3.geometry.euclidean.threed.Line",
    "signature": "org.apache.commons.math3.geometry.euclidean.threed.Line.revert()",
    "snippet": "    public Line revert() {\n        final Line reverted = new Line(zero, zero.subtract(direction));\n        return reverted;\n    }",
    "comment": "Get a line with reversed direction. @return a new instance, with reversed direction ",
    "is_bug": true,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "Vector3D.Vector3D",
    "class_name": "org.apache.commons.math3.geometry.euclidean.threed.Vector3D",
    "signature": "org.apache.commons.math3.geometry.euclidean.threed.Vector3D.Vector3D(double,Vector3D)",
    "snippet": "    public Vector3D(double a, Vector3D u) {\n        this.x = a * u.x;\n        this.y = a * u.y;\n        this.z = a * u.z;\n    }",
    "comment": "Multiplicative constructor Build a vector from another one and a scale factor. The vector built will be a * u @param a scale factor @param u base (unscaled) vector ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "Vector3D.Vector3D",
    "class_name": "org.apache.commons.math3.geometry.euclidean.threed.Vector3D",
    "signature": "org.apache.commons.math3.geometry.euclidean.threed.Vector3D.Vector3D(double,Vector3D,double,Vector3D)",
    "snippet": "    public Vector3D(double a1, Vector3D u1, double a2, Vector3D u2) {\n        this.x = MathArrays.linearCombination(a1, u1.x, a2, u2.x);\n        this.y = MathArrays.linearCombination(a1, u1.y, a2, u2.y);\n        this.z = MathArrays.linearCombination(a1, u1.z, a2, u2.z);\n    }",
    "comment": "Linear constructor Build a vector from two other ones and corresponding scale factors. The vector built will be a1 * u1 + a2 * u2 @param a1 first scale factor @param u1 first base (unscaled) vector @param a2 second scale factor @param u2 second base (unscaled) vector ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "Vector3D.Vector3D",
    "class_name": "org.apache.commons.math3.geometry.euclidean.threed.Vector3D",
    "signature": "org.apache.commons.math3.geometry.euclidean.threed.Vector3D.Vector3D(double,double,double)",
    "snippet": "    public Vector3D(double x, double y, double z) {\n        this.x = x;\n        this.y = y;\n        this.z = z;\n    }",
    "comment": "Simple constructor. Build a vector from its coordinates @param x abscissa @param y ordinate @param z height @see #getX() @see #getY() @see #getZ() ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "Vector3D.dotProduct",
    "class_name": "org.apache.commons.math3.geometry.euclidean.threed.Vector3D",
    "signature": "org.apache.commons.math3.geometry.euclidean.threed.Vector3D.dotProduct(Vector)",
    "snippet": "    public double dotProduct(final Vector<Euclidean3D> v) {\n        final Vector3D v3 = (Vector3D) v;\n        return MathArrays.linearCombination(x, v3.x, y, v3.y, z, v3.z);\n    }",
    "comment": "{@inheritDoc} <p> The implementation uses specific multiplication and addition algorithms to preserve accuracy and reduce cancellation effects. It should be very accurate even for nearly orthogonal vectors. </p> @see MathArrays#linearCombination(double, double, double, double, double, double) ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "Vector3D.getNormSq",
    "class_name": "org.apache.commons.math3.geometry.euclidean.threed.Vector3D",
    "signature": "org.apache.commons.math3.geometry.euclidean.threed.Vector3D.getNormSq()",
    "snippet": "    public double getNormSq() {\n        // there are no cancellation problems here, so we use the straightforward formula\n        return x * x + y * y + z * z;\n    }",
    "comment": "{@inheritDoc} */",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "Vector3D.negate",
    "class_name": "org.apache.commons.math3.geometry.euclidean.threed.Vector3D",
    "signature": "org.apache.commons.math3.geometry.euclidean.threed.Vector3D.negate()",
    "snippet": "    public Vector3D negate() {\n        return new Vector3D(-x, -y, -z);\n    }",
    "comment": "{@inheritDoc} */",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "Vector3D.subtract",
    "class_name": "org.apache.commons.math3.geometry.euclidean.threed.Vector3D",
    "signature": "org.apache.commons.math3.geometry.euclidean.threed.Vector3D.subtract(Vector)",
    "snippet": "    public Vector3D subtract(final Vector<Euclidean3D> v) {\n        final Vector3D v3 = (Vector3D) v;\n        return new Vector3D(x - v3.x, y - v3.y, z - v3.z);\n    }",
    "comment": "{@inheritDoc} */",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "Vector3D.toArray",
    "class_name": "org.apache.commons.math3.geometry.euclidean.threed.Vector3D",
    "signature": "org.apache.commons.math3.geometry.euclidean.threed.Vector3D.toArray()",
    "snippet": "    public double[] toArray() {\n        return new double[] { x, y, z };\n    }",
    "comment": "Get the vector coordinates as a dimension 3 array. @return vector coordinates @see #Vector3D(double[]) ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "FastMath.sqrt",
    "class_name": "org.apache.commons.math3.util.FastMath",
    "signature": "org.apache.commons.math3.util.FastMath.sqrt(double)",
    "snippet": "    public static double sqrt(final double a) {\n        return Math.sqrt(a);\n    }",
    "comment": "Compute the square root of a number. <p><b>Note:</b> this implementation currently delegates to {@link Math#sqrt} @param a number on which evaluation is done @return square root of a ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "MathArrays.linearCombination",
    "class_name": "org.apache.commons.math3.util.MathArrays",
    "signature": "org.apache.commons.math3.util.MathArrays.linearCombination(double,double,double,double)",
    "snippet": "    public static double linearCombination(final double a1, final double b1,\n                                           final double a2, final double b2) {\n\n        // the code below is split in many additions/subtractions that may\n        // appear redundant. However, they should NOT be simplified, as they\n        // use IEEE754 floating point arithmetic rounding properties.\n        // as an example, the expression \"ca1 - (ca1 - a1)\" is NOT the same as \"a1\"\n        // The variable naming conventions are that xyzHigh contains the most significant\n        // bits of xyz and xyzLow contains its least significant bits. So theoretically\n        // xyz is the sum xyzHigh + xyzLow, but in many cases below, this sum cannot\n        // be represented in only one double precision number so we preserve two numbers\n        // to hold it as long as we can, combining the high and low order bits together\n        // only at the end, after cancellation may have occurred on high order bits\n\n        // split a1 and b1 as two 26 bits numbers\n        final double ca1        = SPLIT_FACTOR * a1;\n        final double a1High     = ca1 - (ca1 - a1);\n        final double a1Low      = a1 - a1High;\n        final double cb1        = SPLIT_FACTOR * b1;\n        final double b1High     = cb1 - (cb1 - b1);\n        final double b1Low      = b1 - b1High;\n\n        // accurate multiplication a1 * b1\n        final double prod1High  = a1 * b1;\n        final double prod1Low   = a1Low * b1Low - (((prod1High - a1High * b1High) - a1Low * b1High) - a1High * b1Low);\n\n        // split a2 and b2 as two 26 bits numbers\n        final double ca2        = SPLIT_FACTOR * a2;\n        final double a2High     = ca2 - (ca2 - a2);\n        final double a2Low      = a2 - a2High;\n        final double cb2        = SPLIT_FACTOR * b2;\n        final double b2High     = cb2 - (cb2 - b2);\n        final double b2Low      = b2 - b2High;\n\n        // accurate multiplication a2 * b2\n        final double prod2High  = a2 * b2;\n        final double prod2Low   = a2Low * b2Low - (((prod2High - a2High * b2High) - a2Low * b2High) - a2High * b2Low);\n\n        // accurate addition a1 * b1 + a2 * b2\n        final double s12High    = prod1High + prod2High;\n        final double s12Prime   = s12High - prod2High;\n        final double s12Low     = (prod2High - (s12High - s12Prime)) + (prod1High - s12Prime);\n\n        // final rounding, s12 may have suffered many cancellations, we try\n        // to recover some bits from the extra words we have saved up to now\n        double result = s12High + (prod1Low + prod2Low + s12Low);\n\n        if (Double.isNaN(result)) {\n            // either we have split infinite numbers or some coefficients were NaNs,\n            // just rely on the naive implementation and let IEEE754 handle this\n            result = a1 * b1 + a2 * b2;\n        }\n\n        return result;\n    }",
    "comment": " Compute a linear combination accurately. <p> This method computes a<sub>1</sub>&times;b<sub>1</sub> + a<sub>2</sub>&times;b<sub>2</sub> to high accuracy. It does so by using specific multiplication and addition algorithms to preserve accuracy and reduce cancellation effects. It is based on the 2005 paper <a href=\"http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.2.1547\"> Accurate Sum and Dot Product</a> by Takeshi Ogita, Siegfried M. Rump, and Shin'ichi Oishi published in SIAM J. Sci. Comput. </p> @param a1 first factor of the first term @param b1 second factor of the first term @param a2 first factor of the second term @param b2 second factor of the second term @return a<sub>1</sub>&times;b<sub>1</sub> + a<sub>2</sub>&times;b<sub>2</sub> @see #linearCombination(double, double, double, double, double, double) @see #linearCombination(double, double, double, double, double, double, double, double) ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "MathArrays.linearCombination",
    "class_name": "org.apache.commons.math3.util.MathArrays",
    "signature": "org.apache.commons.math3.util.MathArrays.linearCombination(double,double,double,double,double,double)",
    "snippet": "    public static double linearCombination(final double a1, final double b1,\n                                           final double a2, final double b2,\n                                           final double a3, final double b3) {\n\n        // the code below is split in many additions/subtractions that may\n        // appear redundant. However, they should NOT be simplified, as they\n        // do use IEEE754 floating point arithmetic rounding properties.\n        // as an example, the expression \"ca1 - (ca1 - a1)\" is NOT the same as \"a1\"\n        // The variables naming conventions are that xyzHigh contains the most significant\n        // bits of xyz and xyzLow contains its least significant bits. So theoretically\n        // xyz is the sum xyzHigh + xyzLow, but in many cases below, this sum cannot\n        // be represented in only one double precision number so we preserve two numbers\n        // to hold it as long as we can, combining the high and low order bits together\n        // only at the end, after cancellation may have occurred on high order bits\n\n        // split a1 and b1 as two 26 bits numbers\n        final double ca1        = SPLIT_FACTOR * a1;\n        final double a1High     = ca1 - (ca1 - a1);\n        final double a1Low      = a1 - a1High;\n        final double cb1        = SPLIT_FACTOR * b1;\n        final double b1High     = cb1 - (cb1 - b1);\n        final double b1Low      = b1 - b1High;\n\n        // accurate multiplication a1 * b1\n        final double prod1High  = a1 * b1;\n        final double prod1Low   = a1Low * b1Low - (((prod1High - a1High * b1High) - a1Low * b1High) - a1High * b1Low);\n\n        // split a2 and b2 as two 26 bits numbers\n        final double ca2        = SPLIT_FACTOR * a2;\n        final double a2High     = ca2 - (ca2 - a2);\n        final double a2Low      = a2 - a2High;\n        final double cb2        = SPLIT_FACTOR * b2;\n        final double b2High     = cb2 - (cb2 - b2);\n        final double b2Low      = b2 - b2High;\n\n        // accurate multiplication a2 * b2\n        final double prod2High  = a2 * b2;\n        final double prod2Low   = a2Low * b2Low - (((prod2High - a2High * b2High) - a2Low * b2High) - a2High * b2Low);\n\n        // split a3 and b3 as two 26 bits numbers\n        final double ca3        = SPLIT_FACTOR * a3;\n        final double a3High     = ca3 - (ca3 - a3);\n        final double a3Low      = a3 - a3High;\n        final double cb3        = SPLIT_FACTOR * b3;\n        final double b3High     = cb3 - (cb3 - b3);\n        final double b3Low      = b3 - b3High;\n\n        // accurate multiplication a3 * b3\n        final double prod3High  = a3 * b3;\n        final double prod3Low   = a3Low * b3Low - (((prod3High - a3High * b3High) - a3Low * b3High) - a3High * b3Low);\n\n        // accurate addition a1 * b1 + a2 * b2\n        final double s12High    = prod1High + prod2High;\n        final double s12Prime   = s12High - prod2High;\n        final double s12Low     = (prod2High - (s12High - s12Prime)) + (prod1High - s12Prime);\n\n        // accurate addition a1 * b1 + a2 * b2 + a3 * b3\n        final double s123High   = s12High + prod3High;\n        final double s123Prime  = s123High - prod3High;\n        final double s123Low    = (prod3High - (s123High - s123Prime)) + (s12High - s123Prime);\n\n        // final rounding, s123 may have suffered many cancellations, we try\n        // to recover some bits from the extra words we have saved up to now\n        double result = s123High + (prod1Low + prod2Low + prod3Low + s12Low + s123Low);\n\n        if (Double.isNaN(result)) {\n            // either we have split infinite numbers or some coefficients were NaNs,\n            // just rely on the naive implementation and let IEEE754 handle this\n            result = a1 * b1 + a2 * b2 + a3 * b3;\n        }\n\n        return result;\n    }",
    "comment": " Compute a linear combination accurately. <p> This method computes a<sub>1</sub>&times;b<sub>1</sub> + a<sub>2</sub>&times;b<sub>2</sub> + a<sub>3</sub>&times;b<sub>3</sub> to high accuracy. It does so by using specific multiplication and addition algorithms to preserve accuracy and reduce cancellation effects. It is based on the 2005 paper <a href=\"http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.2.1547\"> Accurate Sum and Dot Product</a> by Takeshi Ogita, Siegfried M. Rump, and Shin'ichi Oishi published in SIAM J. Sci. Comput. </p> @param a1 first factor of the first term @param b1 second factor of the first term @param a2 first factor of the second term @param b2 second factor of the second term @param a3 first factor of the third term @param b3 second factor of the third term @return a<sub>1</sub>&times;b<sub>1</sub> + a<sub>2</sub>&times;b<sub>2</sub> + a<sub>3</sub>&times;b<sub>3</sub> @see #linearCombination(double, double, double, double) @see #linearCombination(double, double, double, double, double, double, double, double) ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  }
]