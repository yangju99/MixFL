[
  {
    "name": "OpenMapRealVector.OpenMapRealVector",
    "class_name": "org.apache.commons.math3.linear.OpenMapRealVector",
    "signature": "org.apache.commons.math3.linear.OpenMapRealVector.OpenMapRealVector(OpenMapRealVector)",
    "snippet": "    public OpenMapRealVector(OpenMapRealVector v) {\n        virtualSize = v.getDimension();\n        entries = new OpenIntToDoubleHashMap(v.getEntries());\n        epsilon = v.epsilon;\n    }",
    "comment": " Copy constructor.  @param v Instance to copy from. ",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "OpenMapRealVector.OpenMapRealVector",
    "class_name": "org.apache.commons.math3.linear.OpenMapRealVector",
    "signature": "org.apache.commons.math3.linear.OpenMapRealVector.OpenMapRealVector(double[])",
    "snippet": "    public OpenMapRealVector(double[] values) {\n        this(values, DEFAULT_ZERO_TOLERANCE);\n    }",
    "comment": " Create from an array. Only non-zero entries will be stored.  @param values Set of values to create from. ",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "OpenMapRealVector.OpenMapRealVector",
    "class_name": "org.apache.commons.math3.linear.OpenMapRealVector",
    "signature": "org.apache.commons.math3.linear.OpenMapRealVector.OpenMapRealVector(double[],double)",
    "snippet": "    public OpenMapRealVector(double[] values, double epsilon) {\n        virtualSize = values.length;\n        entries = new OpenIntToDoubleHashMap(0.0);\n        this.epsilon = epsilon;\n        for (int key = 0; key < values.length; key++) {\n            double value = values[key];\n            if (!isDefaultValue(value)) {\n                entries.put(key, value);\n            }\n        }\n    }",
    "comment": " Create from an array, specifying zero tolerance. Only non-zero entries will be stored.  @param values Set of values to create from. @param epsilon Tolerance below which a value is considered zero. ",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "OpenMapRealVector.ebeDivide",
    "class_name": "org.apache.commons.math3.linear.OpenMapRealVector",
    "signature": "org.apache.commons.math3.linear.OpenMapRealVector.ebeDivide(RealVector)",
    "snippet": "    @Override\n    public OpenMapRealVector ebeDivide(RealVector v) {\n        checkVectorDimensions(v.getDimension());\n        OpenMapRealVector res = new OpenMapRealVector(this);\n        /*\n         * MATH-803: it is not sufficient to loop through non zero entries of\n         * this only. Indeed, if this[i] = 0d and v[i] = 0d, then\n         * this[i] / v[i] = NaN, and not 0d.\n         */\n        Iterator iter = entries.iterator();\n        while (iter.hasNext()) {\n            iter.advance();\n            res.setEntry(iter.key(), iter.value() / v.getEntry(iter.key()));\n        }\n        return res;\n    }",
    "comment": "{@inheritDoc} */",
    "is_bug": true,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "OpenMapRealVector.ebeMultiply",
    "class_name": "org.apache.commons.math3.linear.OpenMapRealVector",
    "signature": "org.apache.commons.math3.linear.OpenMapRealVector.ebeMultiply(RealVector)",
    "snippet": "    @Override\n    public OpenMapRealVector ebeMultiply(RealVector v) {\n        checkVectorDimensions(v.getDimension());\n        OpenMapRealVector res = new OpenMapRealVector(this);\n        Iterator iter = entries.iterator();\n        while (iter.hasNext()) {\n            iter.advance();\n            res.setEntry(iter.key(), iter.value() * v.getEntry(iter.key()));\n        }\n        /*\n         * MATH-803: the above loop assumes that 0d * x  = 0d for any double x,\n         * which allows to consider only the non-zero entries of this. However,\n         * this fails if this[i] == 0d and (v[i] = NaN or v[i] = Infinity).\n         *\n         * These special cases are handled below.\n         */\n        return res;\n    }",
    "comment": "{@inheritDoc} */",
    "is_bug": true,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "OpenMapRealVector.getDimension",
    "class_name": "org.apache.commons.math3.linear.OpenMapRealVector",
    "signature": "org.apache.commons.math3.linear.OpenMapRealVector.getDimension()",
    "snippet": "    @Override\n    public int getDimension() {\n        return virtualSize;\n    }",
    "comment": "{@inheritDoc} */",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "OpenMapRealVector.getEntries",
    "class_name": "org.apache.commons.math3.linear.OpenMapRealVector",
    "signature": "org.apache.commons.math3.linear.OpenMapRealVector.getEntries()",
    "snippet": "    private OpenIntToDoubleHashMap getEntries() {\n        return entries;\n    }",
    "comment": " Get the entries of this instance.  @return the entries of this instance. ",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "OpenMapRealVector.getEntry",
    "class_name": "org.apache.commons.math3.linear.OpenMapRealVector",
    "signature": "org.apache.commons.math3.linear.OpenMapRealVector.getEntry(int)",
    "snippet": "    @Override\n    public double getEntry(int index) {\n        checkIndex(index);\n        return entries.get(index);\n    }",
    "comment": "{@inheritDoc} */",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "OpenMapRealVector.isDefaultValue",
    "class_name": "org.apache.commons.math3.linear.OpenMapRealVector",
    "signature": "org.apache.commons.math3.linear.OpenMapRealVector.isDefaultValue(double)",
    "snippet": "    protected boolean isDefaultValue(double value) {\n        return FastMath.abs(value) < epsilon;\n    }",
    "comment": " Determine if this value is within epsilon of zero.  @param value Value to test @return {@code true} if this value is within epsilon to zero, {@code false} otherwise. @since 2.1 ",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "OpenMapRealVector.setEntry",
    "class_name": "org.apache.commons.math3.linear.OpenMapRealVector",
    "signature": "org.apache.commons.math3.linear.OpenMapRealVector.setEntry(int,double)",
    "snippet": "    @Override\n    public void setEntry(int index, double value) {\n        checkIndex(index);\n        if (!isDefaultValue(value)) {\n            entries.put(index, value);\n        } else if (entries.containsKey(index)) {\n            entries.remove(index);\n        }\n    }",
    "comment": "{@inheritDoc} */",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "RealVector.checkIndex",
    "class_name": "org.apache.commons.math3.linear.RealVector",
    "signature": "org.apache.commons.math3.linear.RealVector.checkIndex(int)",
    "snippet": "    protected void checkIndex(final int index) {\n        if (index < 0 ||\n            index >= getDimension()) {\n            throw new OutOfRangeException(LocalizedFormats.INDEX,\n                                          index, 0, getDimension() - 1);\n        }\n    }",
    "comment": " Check if an index is valid.  @param index Index to check. @exception OutOfRangeException if {@code index} is not valid. ",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "RealVector.checkVectorDimensions",
    "class_name": "org.apache.commons.math3.linear.RealVector",
    "signature": "org.apache.commons.math3.linear.RealVector.checkVectorDimensions(int)",
    "snippet": "    protected void checkVectorDimensions(int n) {\n        int d = getDimension();\n        if (d != n) {\n            throw new DimensionMismatchException(d, n);\n        }\n    }",
    "comment": " Check if instance dimension is equal to some expected value.  @param n Expected dimension. @throws DimensionMismatchException if the dimension is inconsistent with the vector size. ",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "FastMath.abs",
    "class_name": "org.apache.commons.math3.util.FastMath",
    "signature": "org.apache.commons.math3.util.FastMath.abs(double)",
    "snippet": "    public static double abs(double x) {\n        return (x < 0.0) ? -x : (x == 0.0) ? 0.0 : x; // -0.0 => +0.0\n    }",
    "comment": " Absolute value. @param x number from which absolute value is requested @return abs(x) ",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "FastMath.ceil",
    "class_name": "org.apache.commons.math3.util.FastMath",
    "signature": "org.apache.commons.math3.util.FastMath.ceil(double)",
    "snippet": "    public static double ceil(double x) {\n        double y;\n\n        if (x != x) { // NaN\n            return x;\n        }\n\n        y = floor(x);\n        if (y == x) {\n            return y;\n        }\n\n        y += 1.0;\n\n        if (y == 0) {\n            return x*y;\n        }\n\n        return y;\n    }",
    "comment": "Get the smallest whole number larger than x. @param x number from which ceil is requested @return a double number c such that c is an integer c - 1.0 < x <= c ",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "FastMath.floor",
    "class_name": "org.apache.commons.math3.util.FastMath",
    "signature": "org.apache.commons.math3.util.FastMath.floor(double)",
    "snippet": "    public static double floor(double x) {\n        long y;\n\n        if (x != x) { // NaN\n            return x;\n        }\n\n        if (x >= TWO_POWER_52 || x <= -TWO_POWER_52) {\n            return x;\n        }\n\n        y = (long) x;\n        if (x < 0 && y != x) {\n            y--;\n        }\n\n        if (y == 0) {\n            return x*y;\n        }\n\n        return y;\n    }",
    "comment": "Get the largest whole number smaller than x. @param x number from which floor is requested @return a double number f such that f is an integer f <= x < f + 1.0 ",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "OpenIntToDoubleHashMap.OpenIntToDoubleHashMap",
    "class_name": "org.apache.commons.math3.util.OpenIntToDoubleHashMap",
    "signature": "org.apache.commons.math3.util.OpenIntToDoubleHashMap.OpenIntToDoubleHashMap(OpenIntToDoubleHashMap)",
    "snippet": "    public OpenIntToDoubleHashMap(final OpenIntToDoubleHashMap source) {\n        final int length = source.keys.length;\n        keys = new int[length];\n        System.arraycopy(source.keys, 0, keys, 0, length);\n        values = new double[length];\n        System.arraycopy(source.values, 0, values, 0, length);\n        states = new byte[length];\n        System.arraycopy(source.states, 0, states, 0, length);\n        missingEntries = source.missingEntries;\n        size  = source.size;\n        mask  = source.mask;\n        count = source.count;\n    }",
    "comment": " Copy constructor. @param source map to copy ",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "OpenIntToDoubleHashMap.OpenIntToDoubleHashMap",
    "class_name": "org.apache.commons.math3.util.OpenIntToDoubleHashMap",
    "signature": "org.apache.commons.math3.util.OpenIntToDoubleHashMap.OpenIntToDoubleHashMap(double)",
    "snippet": "    public OpenIntToDoubleHashMap(final double missingEntries) {\n        this(DEFAULT_EXPECTED_SIZE, missingEntries);\n    }",
    "comment": " Build an empty map with default size @param missingEntries value to return when a missing entry is fetched ",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "OpenIntToDoubleHashMap.OpenIntToDoubleHashMap",
    "class_name": "org.apache.commons.math3.util.OpenIntToDoubleHashMap",
    "signature": "org.apache.commons.math3.util.OpenIntToDoubleHashMap.OpenIntToDoubleHashMap(int,double)",
    "snippet": "    public OpenIntToDoubleHashMap(final int expectedSize,\n                                  final double missingEntries) {\n        final int capacity = computeCapacity(expectedSize);\n        keys   = new int[capacity];\n        values = new double[capacity];\n        states = new byte[capacity];\n        this.missingEntries = missingEntries;\n        mask   = capacity - 1;\n    }",
    "comment": " Build an empty map with specified size. @param expectedSize expected number of elements in the map @param missingEntries value to return when a missing entry is fetched ",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "OpenIntToDoubleHashMap.changeIndexSign",
    "class_name": "org.apache.commons.math3.util.OpenIntToDoubleHashMap",
    "signature": "org.apache.commons.math3.util.OpenIntToDoubleHashMap.changeIndexSign(int)",
    "snippet": "    private static int changeIndexSign(final int index) {\n        return -index - 1;\n    }",
    "comment": " Change the index sign @param index initial index @return changed index ",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "OpenIntToDoubleHashMap.computeCapacity",
    "class_name": "org.apache.commons.math3.util.OpenIntToDoubleHashMap",
    "signature": "org.apache.commons.math3.util.OpenIntToDoubleHashMap.computeCapacity(int)",
    "snippet": "    private static int computeCapacity(final int expectedSize) {\n        if (expectedSize == 0) {\n            return 1;\n        }\n        final int capacity   = (int) FastMath.ceil(expectedSize / LOAD_FACTOR);\n        final int powerOfTwo = Integer.highestOneBit(capacity);\n        if (powerOfTwo == capacity) {\n            return capacity;\n        }\n        return nextPowerOfTwo(capacity);\n    }",
    "comment": " Compute the capacity needed for a given size. @param expectedSize expected size of the map @return capacity to use for the specified size ",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "OpenIntToDoubleHashMap.containsKey",
    "class_name": "org.apache.commons.math3.util.OpenIntToDoubleHashMap",
    "signature": "org.apache.commons.math3.util.OpenIntToDoubleHashMap.containsKey(int)",
    "snippet": "    public boolean containsKey(final int key) {\n\n        final int hash  = hashOf(key);\n        int index = hash & mask;\n        if (containsKey(key, index)) {\n            return true;\n        }\n\n        if (states[index] == FREE) {\n            return false;\n        }\n\n        int j = index;\n        for (int perturb = perturb(hash); states[index] != FREE; perturb >>= PERTURB_SHIFT) {\n            j = probe(perturb, j);\n            index = j & mask;\n            if (containsKey(key, index)) {\n                return true;\n            }\n        }\n\n        return false;\n\n    }",
    "comment": " Check if a value is associated with a key. @param key key to check @return true if a value is associated with key ",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "OpenIntToDoubleHashMap.containsKey",
    "class_name": "org.apache.commons.math3.util.OpenIntToDoubleHashMap",
    "signature": "org.apache.commons.math3.util.OpenIntToDoubleHashMap.containsKey(int,int)",
    "snippet": "    private boolean containsKey(final int key, final int index) {\n        return (key != 0 || states[index] == FULL) && keys[index] == key;\n    }",
    "comment": " Check if the tables contain an element associated with specified key at specified index. @param key key to check @param index index to check @return true if an element is associated with key at index ",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "OpenIntToDoubleHashMap.doRemove",
    "class_name": "org.apache.commons.math3.util.OpenIntToDoubleHashMap",
    "signature": "org.apache.commons.math3.util.OpenIntToDoubleHashMap.doRemove(int)",
    "snippet": "    private double doRemove(int index) {\n        keys[index]   = 0;\n        states[index] = REMOVED;\n        final double previous = values[index];\n        values[index] = missingEntries;\n        --size;\n        ++count;\n        return previous;\n    }",
    "comment": " Remove an element at specified index. @param index index of the element to remove @return removed value ",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "OpenIntToDoubleHashMap.findInsertionIndex",
    "class_name": "org.apache.commons.math3.util.OpenIntToDoubleHashMap",
    "signature": "org.apache.commons.math3.util.OpenIntToDoubleHashMap.findInsertionIndex(int)",
    "snippet": "    private int findInsertionIndex(final int key) {\n        return findInsertionIndex(keys, states, key, mask);\n    }",
    "comment": " Find the index at which a key should be inserted @param key key to lookup @return index at which key should be inserted ",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "OpenIntToDoubleHashMap.findInsertionIndex",
    "class_name": "org.apache.commons.math3.util.OpenIntToDoubleHashMap",
    "signature": "org.apache.commons.math3.util.OpenIntToDoubleHashMap.findInsertionIndex(int[],byte[],int,int)",
    "snippet": "    private static int findInsertionIndex(final int[] keys, final byte[] states,\n                                          final int key, final int mask) {\n        final int hash = hashOf(key);\n        int index = hash & mask;\n        if (states[index] == FREE) {\n            return index;\n        } else if (states[index] == FULL && keys[index] == key) {\n            return changeIndexSign(index);\n        }\n\n        int perturb = perturb(hash);\n        int j = index;\n        if (states[index] == FULL) {\n            while (true) {\n                j = probe(perturb, j);\n                index = j & mask;\n                perturb >>= PERTURB_SHIFT;\n\n                if (states[index] != FULL || keys[index] == key) {\n                    break;\n                }\n            }\n        }\n\n        if (states[index] == FREE) {\n            return index;\n        } else if (states[index] == FULL) {\n            // due to the loop exit condition,\n            // if (states[index] == FULL) then keys[index] == key\n            return changeIndexSign(index);\n        }\n\n        final int firstRemoved = index;\n        while (true) {\n            j = probe(perturb, j);\n            index = j & mask;\n\n            if (states[index] == FREE) {\n                return firstRemoved;\n            } else if (states[index] == FULL && keys[index] == key) {\n                return changeIndexSign(index);\n            }\n\n            perturb >>= PERTURB_SHIFT;\n\n        }\n\n    }",
    "comment": " Find the index at which a key should be inserted @param keys keys table @param states states table @param key key to lookup @param mask bit mask for hash values @return index at which key should be inserted ",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "OpenIntToDoubleHashMap.get",
    "class_name": "org.apache.commons.math3.util.OpenIntToDoubleHashMap",
    "signature": "org.apache.commons.math3.util.OpenIntToDoubleHashMap.get(int)",
    "snippet": "    public double get(final int key) {\n\n        final int hash  = hashOf(key);\n        int index = hash & mask;\n        if (containsKey(key, index)) {\n            return values[index];\n        }\n\n        if (states[index] == FREE) {\n            return missingEntries;\n        }\n\n        int j = index;\n        for (int perturb = perturb(hash); states[index] != FREE; perturb >>= PERTURB_SHIFT) {\n            j = probe(perturb, j);\n            index = j & mask;\n            if (containsKey(key, index)) {\n                return values[index];\n            }\n        }\n\n        return missingEntries;\n\n    }",
    "comment": " Get the stored value associated with the given key @param key key associated with the data @return data associated with the key ",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "OpenIntToDoubleHashMap.growTable",
    "class_name": "org.apache.commons.math3.util.OpenIntToDoubleHashMap",
    "signature": "org.apache.commons.math3.util.OpenIntToDoubleHashMap.growTable()",
    "snippet": "    private void growTable() {\n\n        final int oldLength      = states.length;\n        final int[] oldKeys      = keys;\n        final double[] oldValues = values;\n        final byte[] oldStates   = states;\n\n        final int newLength = RESIZE_MULTIPLIER * oldLength;\n        final int[] newKeys = new int[newLength];\n        final double[] newValues = new double[newLength];\n        final byte[] newStates = new byte[newLength];\n        final int newMask = newLength - 1;\n        for (int i = 0; i < oldLength; ++i) {\n            if (oldStates[i] == FULL) {\n                final int key = oldKeys[i];\n                final int index = findInsertionIndex(newKeys, newStates, key, newMask);\n                newKeys[index]   = key;\n                newValues[index] = oldValues[i];\n                newStates[index] = FULL;\n            }\n        }\n\n        mask   = newMask;\n        keys   = newKeys;\n        values = newValues;\n        states = newStates;\n\n    }",
    "comment": " Grow the tables. ",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "OpenIntToDoubleHashMap.hashOf",
    "class_name": "org.apache.commons.math3.util.OpenIntToDoubleHashMap",
    "signature": "org.apache.commons.math3.util.OpenIntToDoubleHashMap.hashOf(int)",
    "snippet": "    private static int hashOf(final int key) {\n        final int h = key ^ ((key >>> 20) ^ (key >>> 12));\n        return h ^ (h >>> 7) ^ (h >>> 4);\n    }",
    "comment": " Compute the hash value of a key @param key key to hash @return hash value of the key ",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "OpenIntToDoubleHashMap.iterator",
    "class_name": "org.apache.commons.math3.util.OpenIntToDoubleHashMap",
    "signature": "org.apache.commons.math3.util.OpenIntToDoubleHashMap.iterator()",
    "snippet": "    public Iterator iterator() {\n        return new Iterator();\n    }",
    "comment": " Get an iterator over map elements. <p>The specialized iterators returned are fail-fast: they throw a <code>ConcurrentModificationException</code> when they detect the map has been modified during iteration.</p> @return iterator over the map elements ",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "OpenIntToDoubleHashMap.perturb",
    "class_name": "org.apache.commons.math3.util.OpenIntToDoubleHashMap",
    "signature": "org.apache.commons.math3.util.OpenIntToDoubleHashMap.perturb(int)",
    "snippet": "    private static int perturb(final int hash) {\n        return hash & 0x7fffffff;\n    }",
    "comment": " Perturb the hash for starting probing. @param hash initial hash @return perturbed hash ",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "OpenIntToDoubleHashMap.probe",
    "class_name": "org.apache.commons.math3.util.OpenIntToDoubleHashMap",
    "signature": "org.apache.commons.math3.util.OpenIntToDoubleHashMap.probe(int,int)",
    "snippet": "    private static int probe(final int perturb, final int j) {\n        return (j << 2) + j + perturb + 1;\n    }",
    "comment": " Compute next probe for collision resolution @param perturb perturbed hash @param j previous probe @return next probe ",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "OpenIntToDoubleHashMap.put",
    "class_name": "org.apache.commons.math3.util.OpenIntToDoubleHashMap",
    "signature": "org.apache.commons.math3.util.OpenIntToDoubleHashMap.put(int,double)",
    "snippet": "    public double put(final int key, final double value) {\n        int index = findInsertionIndex(key);\n        double previous = missingEntries;\n        boolean newMapping = true;\n        if (index < 0) {\n            index = changeIndexSign(index);\n            previous = values[index];\n            newMapping = false;\n        }\n        keys[index]   = key;\n        states[index] = FULL;\n        values[index] = value;\n        if (newMapping) {\n            ++size;\n            if (shouldGrowTable()) {\n                growTable();\n            }\n            ++count;\n        }\n        return previous;\n\n    }",
    "comment": " Put a value associated with a key in the map. @param key key to which value is associated @param value value to put in the map @return previous value associated with the key ",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "OpenIntToDoubleHashMap.remove",
    "class_name": "org.apache.commons.math3.util.OpenIntToDoubleHashMap",
    "signature": "org.apache.commons.math3.util.OpenIntToDoubleHashMap.remove(int)",
    "snippet": "    public double remove(final int key) {\n\n        final int hash  = hashOf(key);\n        int index = hash & mask;\n        if (containsKey(key, index)) {\n            return doRemove(index);\n        }\n\n        if (states[index] == FREE) {\n            return missingEntries;\n        }\n\n        int j = index;\n        for (int perturb = perturb(hash); states[index] != FREE; perturb >>= PERTURB_SHIFT) {\n            j = probe(perturb, j);\n            index = j & mask;\n            if (containsKey(key, index)) {\n                return doRemove(index);\n            }\n        }\n\n        return missingEntries;\n\n    }",
    "comment": " Remove the value associated with a key. @param key key to which the value is associated @return removed value ",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "OpenIntToDoubleHashMap.shouldGrowTable",
    "class_name": "org.apache.commons.math3.util.OpenIntToDoubleHashMap",
    "signature": "org.apache.commons.math3.util.OpenIntToDoubleHashMap.shouldGrowTable()",
    "snippet": "    private boolean shouldGrowTable() {\n        return size > (mask + 1) * LOAD_FACTOR;\n    }",
    "comment": " Check if tables should grow due to increased size. @return true if  tables should grow ",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "Iterator.advance",
    "class_name": "org.apache.commons.math3.util.OpenIntToDoubleHashMap$Iterator",
    "signature": "org.apache.commons.math3.util.OpenIntToDoubleHashMap$Iterator.advance()",
    "snippet": "        public void advance()\n            throws ConcurrentModificationException, NoSuchElementException {\n\n            if (referenceCount != count) {\n                throw new ConcurrentModificationException();\n            }\n\n            // advance on step\n            current = next;\n\n            // prepare next step\n            try {\n                while (states[++next] != FULL) {\n                    // nothing to do\n                }\n            } catch (ArrayIndexOutOfBoundsException e) {\n                next = -2;\n                if (current < 0) {\n                    throw new NoSuchElementException();\n                }\n            }\n\n        }",
    "comment": " Advance iterator one step further. @exception ConcurrentModificationException if the map is modified during iteration @exception NoSuchElementException if there is no element left in the map ",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "Iterator.hasNext",
    "class_name": "org.apache.commons.math3.util.OpenIntToDoubleHashMap$Iterator",
    "signature": "org.apache.commons.math3.util.OpenIntToDoubleHashMap$Iterator.hasNext()",
    "snippet": "        public boolean hasNext() {\n            return next >= 0;\n        }",
    "comment": " Check if there is a next element in the map. @return true if there is a next element ",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "Iterator.key",
    "class_name": "org.apache.commons.math3.util.OpenIntToDoubleHashMap$Iterator",
    "signature": "org.apache.commons.math3.util.OpenIntToDoubleHashMap$Iterator.key()",
    "snippet": "        public int key()\n            throws ConcurrentModificationException, NoSuchElementException {\n            if (referenceCount != count) {\n                throw new ConcurrentModificationException();\n            }\n            if (current < 0) {\n                throw new NoSuchElementException();\n            }\n            return keys[current];\n        }",
    "comment": " Get the key of current entry. @return key of current entry @exception ConcurrentModificationException if the map is modified during iteration @exception NoSuchElementException if there is no element left in the map ",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "Iterator.value",
    "class_name": "org.apache.commons.math3.util.OpenIntToDoubleHashMap$Iterator",
    "signature": "org.apache.commons.math3.util.OpenIntToDoubleHashMap$Iterator.value()",
    "snippet": "        public double value()\n            throws ConcurrentModificationException, NoSuchElementException {\n            if (referenceCount != count) {\n                throw new ConcurrentModificationException();\n            }\n            if (current < 0) {\n                throw new NoSuchElementException();\n            }\n            return values[current];\n        }",
    "comment": " Get the value of current entry. @return value of current entry @exception ConcurrentModificationException if the map is modified during iteration @exception NoSuchElementException if there is no element left in the map ",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  }
]