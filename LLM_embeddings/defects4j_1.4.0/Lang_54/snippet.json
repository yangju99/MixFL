[
  {
    "name": "LocaleUtils.availableLocaleList",
    "class_name": "org.apache.commons.lang.LocaleUtils",
    "signature": "org.apache.commons.lang.LocaleUtils.availableLocaleList()",
    "snippet": "    public static List availableLocaleList() {\n        return cAvailableLocaleList;\n    }",
    "comment": " <p>Obtains an unmodifiable list of installed locales.</p>  <p>This method is a wrapper around {@link Locale#getAvailableLocales()}. It is more efficient, as the JDK method must create a new array each time it is called.</p>  @return the unmodifiable list of available locales ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "LocaleUtils.isAvailableLocale",
    "class_name": "org.apache.commons.lang.LocaleUtils",
    "signature": "org.apache.commons.lang.LocaleUtils.isAvailableLocale(Locale)",
    "snippet": "    public static boolean isAvailableLocale(Locale locale) {\n        return availableLocaleList().contains(locale);\n    }",
    "comment": " <p>Checks if the locale specified is in the list of available locales.</p>  @param locale the Locale object to check if it is available @return true if the locale is a known locale ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "LocaleUtils.toLocale",
    "class_name": "org.apache.commons.lang.LocaleUtils",
    "signature": "org.apache.commons.lang.LocaleUtils.toLocale(String)",
    "snippet": "    public static Locale toLocale(String str) {\n        if (str == null) {\n            return null;\n        }\n        int len = str.length();\n        if (len != 2 && len != 5 && len < 7) {\n            throw new IllegalArgumentException(\"Invalid locale format: \" + str);\n        }\n        char ch0 = str.charAt(0);\n        char ch1 = str.charAt(1);\n        if (ch0 < 'a' || ch0 > 'z' || ch1 < 'a' || ch1 > 'z') {\n            throw new IllegalArgumentException(\"Invalid locale format: \" + str);\n        }\n        if (len == 2) {\n            return new Locale(str, \"\");\n        } else {\n            if (str.charAt(2) != '_') {\n                throw new IllegalArgumentException(\"Invalid locale format: \" + str);\n            }\n            char ch3 = str.charAt(3);\n            char ch4 = str.charAt(4);\n            if (ch3 < 'A' || ch3 > 'Z' || ch4 < 'A' || ch4 > 'Z') {\n                throw new IllegalArgumentException(\"Invalid locale format: \" + str);\n            }\n            if (len == 5) {\n                return new Locale(str.substring(0, 2), str.substring(3, 5));\n            } else {\n                if (str.charAt(5) != '_') {\n                    throw new IllegalArgumentException(\"Invalid locale format: \" + str);\n                }\n                return new Locale(str.substring(0, 2), str.substring(3, 5), str.substring(6));\n            }\n        }\n    }",
    "comment": " <p>Converts a String to a Locale.</p>  <p>This method takes the string format of a locale and creates the locale object from it.</p>  <pre> LocaleUtils.toLocale(\"en\")         = new Locale(\"en\", \"\") LocaleUtils.toLocale(\"en_GB\")      = new Locale(\"en\", \"GB\") LocaleUtils.toLocale(\"en_GB_xxx\")  = new Locale(\"en\", \"GB\", \"xxx\")   (#) </pre>  <p>(#) The behaviour of the JDK variant constructor changed between JDK1.3 and JDK1.4. In JDK1.3, the constructor upper cases the variant, in JDK1.4, it doesn't. Thus, the result from getVariant() may vary depending on your JDK.</p>  <p>This method validates the input strictly. The language code must be lowercase. The country code must be uppercase. The separator must be an underscore. The length must be correct. </p>  @param str  the locale String to convert, null returns null @return a Locale, null if null input @throws IllegalArgumentException if the string is an invalid format ",
    "is_bug": true,
    "failing_test_cases": 1,
    "buggy_methods": 1
  }
]