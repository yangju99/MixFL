[
  {
    "name": "ChartColor.createDefaultPaintArray",
    "class_name": "org.jfree.chart.ChartColor",
    "signature": "org.jfree.chart.ChartColor.createDefaultPaintArray()",
    "snippet": "    public static Paint[] createDefaultPaintArray() {\n\n        return new Paint[] {\n            new Color(0xFF, 0x55, 0x55),\n            new Color(0x55, 0x55, 0xFF),\n            new Color(0x55, 0xFF, 0x55),\n            new Color(0xFF, 0xFF, 0x55),\n            new Color(0xFF, 0x55, 0xFF),\n            new Color(0x55, 0xFF, 0xFF),\n            Color.pink,\n            Color.gray,\n            ChartColor.DARK_RED,\n            ChartColor.DARK_BLUE,\n            ChartColor.DARK_GREEN,\n            ChartColor.DARK_YELLOW,\n            ChartColor.DARK_MAGENTA,\n            ChartColor.DARK_CYAN,\n            Color.darkGray,\n            ChartColor.LIGHT_RED,\n            ChartColor.LIGHT_BLUE,\n            ChartColor.LIGHT_GREEN,\n            ChartColor.LIGHT_YELLOW,\n            ChartColor.LIGHT_MAGENTA,\n            ChartColor.LIGHT_CYAN,\n            Color.lightGray,\n            ChartColor.VERY_DARK_RED,\n            ChartColor.VERY_DARK_BLUE,\n            ChartColor.VERY_DARK_GREEN,\n            ChartColor.VERY_DARK_YELLOW,\n            ChartColor.VERY_DARK_MAGENTA,\n            ChartColor.VERY_DARK_CYAN,\n            ChartColor.VERY_LIGHT_RED,\n            ChartColor.VERY_LIGHT_BLUE,\n            ChartColor.VERY_LIGHT_GREEN,\n            ChartColor.VERY_LIGHT_YELLOW,\n            ChartColor.VERY_LIGHT_MAGENTA,\n            ChartColor.VERY_LIGHT_CYAN\n        };\n    }",
    "comment": " Convenience method to return an array of <code>Paint</code> objects that represent the pre-defined colors in the <code>Color<code> and  <code>ChartColor</code> objects.  @return An array of objects with the <code>Paint</code> interface. ",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "JFreeChart.JFreeChart",
    "class_name": "org.jfree.chart.JFreeChart",
    "signature": "org.jfree.chart.JFreeChart.JFreeChart(Plot)",
    "snippet": "    public JFreeChart(Plot plot) {\n        this(null, null, plot, true);\n    }",
    "comment": " Creates a new chart based on the supplied plot.  The chart will have a legend added automatically, but no title (although you can easily add one later).   <br><br> Note that the  {@link ChartFactory} class contains a range  of static methods that will return ready-made charts, and often this is a more convenient way to create charts than using this constructor.  @param plot  the plot (<code>null</code> not permitted). ",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "JFreeChart.JFreeChart",
    "class_name": "org.jfree.chart.JFreeChart",
    "signature": "org.jfree.chart.JFreeChart.JFreeChart(String,Font,Plot,boolean)",
    "snippet": "    public JFreeChart(String title, Font titleFont, Plot plot, \n                      boolean createLegend) {\n\n        if (plot == null) {\n            throw new NullPointerException(\"Null 'plot' argument.\");\n        }\n\n        // create storage for listeners...\n        this.progressListeners = new EventListenerList();\n        this.changeListeners = new EventListenerList();\n        this.notify = true;  // default is to notify listeners when the \n                             // chart changes\n\n        this.renderingHints = new RenderingHints(\n                RenderingHints.KEY_ANTIALIASING, \n                RenderingHints.VALUE_ANTIALIAS_ON);\n\n        this.borderVisible = false;\n        this.borderStroke = new BasicStroke(1.0f);\n        this.borderPaint = Color.black;\n\n        this.padding = RectangleInsets.ZERO_INSETS;\n        \n        this.plot = plot;\n        plot.addChangeListener(this);\n\n        this.subtitles = new ArrayList();\n\n        // create a legend, if requested...\n        if (createLegend) {\n            LegendTitle legend = new LegendTitle(this.plot);\n            legend.setMargin(new RectangleInsets(1.0, 1.0, 1.0, 1.0));\n            legend.setFrame(new LineBorder());\n            legend.setBackgroundPaint(Color.white);\n            legend.setPosition(RectangleEdge.BOTTOM);\n            this.subtitles.add(legend);\n            legend.addChangeListener(this);\n        }\n\n        // add the chart title, if one has been specified...\n        if (title != null) {\n            if (titleFont == null) {\n                titleFont = DEFAULT_TITLE_FONT;\n            }\n            this.title = new TextTitle(title, titleFont);\n            this.title.addChangeListener(this);\n        }\n\n        this.backgroundPaint = DEFAULT_BACKGROUND_PAINT;\n\n        this.backgroundImage = DEFAULT_BACKGROUND_IMAGE;\n        this.backgroundImageAlignment = DEFAULT_BACKGROUND_IMAGE_ALIGNMENT;\n        this.backgroundImageAlpha = DEFAULT_BACKGROUND_IMAGE_ALPHA;\n\n    }",
    "comment": " Creates a new chart with the given title and plot.  The  <code>createLegend</code> argument specifies whether or not a legend should be added to the chart.   <br><br> Note that the  {@link ChartFactory} class contains a range  of static methods that will return ready-made charts, and often this is a more convenient way to create charts than using this constructor.  @param title  the chart title (<code>null</code> permitted). @param titleFont  the font for displaying the chart title  (<code>null</code> permitted). @param plot  controller of the visual representation of the data  (<code>null</code> not permitted). @param createLegend  a flag indicating whether or not a legend should    be created for the chart. ",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "JFreeChart.createAlignedRectangle2D",
    "class_name": "org.jfree.chart.JFreeChart",
    "signature": "org.jfree.chart.JFreeChart.createAlignedRectangle2D(Size2D,Rectangle2D,HorizontalAlignment,VerticalAlignment)",
    "snippet": "    private Rectangle2D createAlignedRectangle2D(Size2D dimensions, \n            Rectangle2D frame, HorizontalAlignment hAlign, \n            VerticalAlignment vAlign) {\n        double x = Double.NaN;\n        double y = Double.NaN;\n        if (hAlign == HorizontalAlignment.LEFT) {\n            x = frame.getX();   \n        }\n        else if (hAlign == HorizontalAlignment.CENTER) {\n            x = frame.getCenterX() - (dimensions.width / 2.0);   \n        }\n        else if (hAlign == HorizontalAlignment.RIGHT) {\n            x = frame.getMaxX() - dimensions.width;   \n        }\n        if (vAlign == VerticalAlignment.TOP) {\n            y = frame.getY();   \n        }\n        else if (vAlign == VerticalAlignment.CENTER) {\n            y = frame.getCenterY() - (dimensions.height / 2.0);   \n        }\n        else if (vAlign == VerticalAlignment.BOTTOM) {\n            y = frame.getMaxY() - dimensions.height;   \n        }\n        \n        return new Rectangle2D.Double(x, y, dimensions.width, \n                dimensions.height);\n    }",
    "comment": " Creates a rectangle that is aligned to the frame.  @param dimensions @param frame @param hAlign @param vAlign  @return A rectangle. ",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "JFreeChart.createBufferedImage",
    "class_name": "org.jfree.chart.JFreeChart",
    "signature": "org.jfree.chart.JFreeChart.createBufferedImage(int,int,ChartRenderingInfo)",
    "snippet": "    public BufferedImage createBufferedImage(int width, int height, \n                                             ChartRenderingInfo info) {\n        return createBufferedImage(width, height, BufferedImage.TYPE_INT_RGB, \n                info);\n    }",
    "comment": " Creates and returns a buffered image into which the chart has been drawn.  @param width  the width. @param height  the height. @param info  carries back chart state information (<code>null</code>  permitted).  @return A buffered image. ",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "JFreeChart.createBufferedImage",
    "class_name": "org.jfree.chart.JFreeChart",
    "signature": "org.jfree.chart.JFreeChart.createBufferedImage(int,int,int,ChartRenderingInfo)",
    "snippet": "    public BufferedImage createBufferedImage(int width, int height, \n                                             int imageType, \n                                             ChartRenderingInfo info) {\n        BufferedImage image = new BufferedImage(width, height, imageType);\n        Graphics2D g2 = image.createGraphics();\n        draw(g2, new Rectangle2D.Double(0, 0, width, height), null, info);\n        g2.dispose();\n        return image;\n    }",
    "comment": " Creates and returns a buffered image into which the chart has been drawn.  @param width  the width. @param height  the height. @param imageType  the image type. @param info  carries back chart state information (<code>null</code>  permitted).  @return A buffered image. ",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "JFreeChart.draw",
    "class_name": "org.jfree.chart.JFreeChart",
    "signature": "org.jfree.chart.JFreeChart.draw(Graphics2D,Rectangle2D,Point2D,ChartRenderingInfo)",
    "snippet": "    public void draw(Graphics2D g2, \n                     Rectangle2D chartArea, Point2D anchor, \n                     ChartRenderingInfo info) {\n\n        notifyListeners(new ChartProgressEvent(this, this, \n                ChartProgressEvent.DRAWING_STARTED, 0));\n\n        // record the chart area, if info is requested...\n        if (info != null) {\n            info.clear();\n            info.setChartArea(chartArea);\n        }\n\n        // ensure no drawing occurs outside chart area...\n        Shape savedClip = g2.getClip();\n        g2.clip(chartArea);\n\n        g2.addRenderingHints(this.renderingHints);\n\n        // draw the chart background...\n        if (this.backgroundPaint != null) {\n            g2.setPaint(this.backgroundPaint);\n            g2.fill(chartArea);\n        }\n\n        if (this.backgroundImage != null) {\n            Composite originalComposite = g2.getComposite();\n            g2.setComposite(AlphaComposite.getInstance(AlphaComposite.SRC_OVER, \n                    this.backgroundImageAlpha));\n            Rectangle2D dest = new Rectangle2D.Double(0.0, 0.0, \n                    this.backgroundImage.getWidth(null), \n                    this.backgroundImage.getHeight(null));\n            Align.align(dest, chartArea, this.backgroundImageAlignment);\n            g2.drawImage(this.backgroundImage, (int) dest.getX(), \n                    (int) dest.getY(), (int) dest.getWidth(), \n                    (int) dest.getHeight(), null);\n            g2.setComposite(originalComposite);\n        }\n\n        if (isBorderVisible()) {\n            Paint paint = getBorderPaint();\n            Stroke stroke = getBorderStroke();\n            if (paint != null && stroke != null) {\n                Rectangle2D borderArea = new Rectangle2D.Double(\n                        chartArea.getX(), chartArea.getY(), \n                        chartArea.getWidth() - 1.0, chartArea.getHeight() \n                        - 1.0);\n                g2.setPaint(paint);\n                g2.setStroke(stroke);\n                g2.draw(borderArea);\n            }\n        }\n\n        // draw the title and subtitles...\n        Rectangle2D nonTitleArea = new Rectangle2D.Double();\n        nonTitleArea.setRect(chartArea);\n        this.padding.trim(nonTitleArea);\n        \n        EntityCollection entities = null;\n        if (info != null) {\n            entities = info.getEntityCollection();   \n        }\n        if (this.title != null) {\n            EntityCollection e = drawTitle(this.title, g2, nonTitleArea, \n                    (entities != null));\n            if (e != null) {\n                entities.addAll(e);   \n            }\n        }\n\n        Iterator iterator = this.subtitles.iterator();\n        while (iterator.hasNext()) {\n            Title currentTitle = (Title) iterator.next();\n            EntityCollection e = drawTitle(currentTitle, g2, nonTitleArea, \n                    (entities != null));\n            if (e != null) {\n                entities.addAll(e);   \n            }\n        }\n\n        Rectangle2D plotArea = nonTitleArea;\n \n        // draw the plot (axes and data visualisation)\n        PlotRenderingInfo plotInfo = null;\n        if (info != null) {\n            plotInfo = info.getPlotInfo();\n        }\n        this.plot.draw(g2, plotArea, anchor, null, plotInfo);\n\n        g2.setClip(savedClip);\n\n        notifyListeners(new ChartProgressEvent(this, this, \n                ChartProgressEvent.DRAWING_FINISHED, 100));\n    }",
    "comment": " Draws the chart on a Java 2D graphics device (such as the screen or a printer). <P> This method is the focus of the entire JFreeChart library.  @param g2  the graphics device. @param chartArea  the area within which the chart should be drawn. @param anchor  the anchor point (in Java2D space) for the chart  (<code>null</code> permitted). @param info  records info about the drawing (null means collect no info). ",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "JFreeChart.drawTitle",
    "class_name": "org.jfree.chart.JFreeChart",
    "signature": "org.jfree.chart.JFreeChart.drawTitle(Title,Graphics2D,Rectangle2D,boolean)",
    "snippet": "    protected EntityCollection drawTitle(Title t, Graphics2D g2, \n                                         Rectangle2D area, boolean entities) {\n\n        if (t == null) {\n            throw new IllegalArgumentException(\"Null 't' argument.\");   \n        }\n        if (area == null) {\n            throw new IllegalArgumentException(\"Null 'area' argument.\");   \n        }\n        Rectangle2D titleArea = new Rectangle2D.Double();\n        RectangleEdge position = t.getPosition();\n        double ww = area.getWidth();\n        if (ww <= 0.0) {\n            return null;\n        }\n        double hh = area.getHeight();\n        if (hh <= 0.0) {\n            return null;\n        }\n        RectangleConstraint constraint = new RectangleConstraint(ww, \n                new Range(0.0, ww), LengthConstraintType.RANGE, hh, \n                new Range(0.0, hh), LengthConstraintType.RANGE);\n        Object retValue = null;\n        BlockParams p = new BlockParams();\n        p.setGenerateEntities(entities);\n        if (position == RectangleEdge.TOP) {\n            Size2D size = t.arrange(g2, constraint);\n            titleArea = createAlignedRectangle2D(size, area, \n                    t.getHorizontalAlignment(), VerticalAlignment.TOP);\n            retValue = t.draw(g2, titleArea, p);\n            area.setRect(area.getX(), Math.min(area.getY() + size.height, \n                    area.getMaxY()), area.getWidth(), Math.max(area.getHeight()\n                    - size.height, 0));\n        }\n        else if (position == RectangleEdge.BOTTOM) {\n            Size2D size = t.arrange(g2, constraint);\n            titleArea = createAlignedRectangle2D(size, area, \n                    t.getHorizontalAlignment(), VerticalAlignment.BOTTOM);\n            retValue = t.draw(g2, titleArea, p);\n            area.setRect(area.getX(), area.getY(), area.getWidth(), \n                    area.getHeight() - size.height);\n        }\n        else if (position == RectangleEdge.RIGHT) {\n            Size2D size = t.arrange(g2, constraint);\n            titleArea = createAlignedRectangle2D(size, area, \n                    HorizontalAlignment.RIGHT, t.getVerticalAlignment());\n            retValue = t.draw(g2, titleArea, p);\n            area.setRect(area.getX(), area.getY(), area.getWidth() \n                    - size.width, area.getHeight());\n        }\n\n        else if (position == RectangleEdge.LEFT) {\n            Size2D size = t.arrange(g2, constraint);\n            titleArea = createAlignedRectangle2D(size, area, \n                    HorizontalAlignment.LEFT, t.getVerticalAlignment());\n            retValue = t.draw(g2, titleArea, p);\n            area.setRect(area.getX() + size.width, area.getY(), area.getWidth() \n                    - size.width, area.getHeight());\n        }\n        else {\n            throw new RuntimeException(\"Unrecognised title position.\");\n        }\n        EntityCollection result = null;\n        if (retValue instanceof EntityBlockResult) {\n            EntityBlockResult ebr = (EntityBlockResult) retValue;\n            result = ebr.getEntityCollection();\n        }\n        return result;   \n    }",
    "comment": " Draws a title.  The title should be drawn at the top, bottom, left or  right of the specified area, and the area should be updated to reflect  the amount of space used by the title.  @param t  the title (<code>null</code> not permitted). @param g2  the graphics device (<code>null</code> not permitted). @param area  the chart area, excluding any existing titles  (<code>null</code> not permitted). @param entities  a flag that controls whether or not an entity  collection is returned for the title.  @return An entity collection for the title (possibly <code>null</code>). ",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "JFreeChart.isBorderVisible",
    "class_name": "org.jfree.chart.JFreeChart",
    "signature": "org.jfree.chart.JFreeChart.isBorderVisible()",
    "snippet": "    public boolean isBorderVisible() {\n        return this.borderVisible;\n    }",
    "comment": " Returns a flag that controls whether or not a border is drawn around the outside of the chart.  @return A boolean.  @see #setBorderVisible(boolean) ",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "JFreeChart.notifyListeners",
    "class_name": "org.jfree.chart.JFreeChart",
    "signature": "org.jfree.chart.JFreeChart.notifyListeners(ChartProgressEvent)",
    "snippet": "    protected void notifyListeners(ChartProgressEvent event) {\n\n        Object[] listeners = this.progressListeners.getListenerList();\n        for (int i = listeners.length - 2; i >= 0; i -= 2) {\n            if (listeners[i] == ChartProgressListener.class) {\n                ((ChartProgressListener) listeners[i + 1]).chartProgress(event);\n            }\n        }\n\n    }",
    "comment": " Sends a {@link ChartProgressEvent} to all registered listeners.  @param event  information about the event that triggered the  notification. ",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "LegendItem.LegendItem",
    "class_name": "org.jfree.chart.LegendItem",
    "signature": "org.jfree.chart.LegendItem.LegendItem(String,String,String,String,boolean,Shape,boolean,Paint,boolean,Paint,Stroke,boolean,Shape,Stroke,Paint)",
    "snippet": "    public LegendItem(String label, String description,\n                      String toolTipText, String urlText,\n                      boolean shapeVisible, Shape shape,\n                      boolean shapeFilled, Paint fillPaint, \n                      boolean shapeOutlineVisible, Paint outlinePaint,\n                      Stroke outlineStroke,\n                      boolean lineVisible, Shape line,\n                      Stroke lineStroke, Paint linePaint) {\n        \n        if (label == null) {\n            throw new IllegalArgumentException(\"Null 'label' argument.\");   \n        }\n        if (fillPaint == null) {\n            throw new IllegalArgumentException(\"Null 'fillPaint' argument.\");   \n        }\n        if (lineStroke == null) {\n            throw new IllegalArgumentException(\"Null 'lineStroke' argument.\");\n        }\n        if (outlinePaint == null) {\n            throw new IllegalArgumentException(\"Null 'outlinePaint' argument.\");\n        }\n        if (outlineStroke == null) {\n            throw new IllegalArgumentException(\n                    \"Null 'outlineStroke' argument.\");   \n        }\n        this.label = label;\n        this.attributedLabel = null;\n        this.description = description;\n        this.shapeVisible = shapeVisible;\n        this.shape = shape;\n        this.shapeFilled = shapeFilled;\n        this.fillPaint = fillPaint;\n        this.fillPaintTransformer = new StandardGradientPaintTransformer();\n        this.shapeOutlineVisible = shapeOutlineVisible;\n        this.outlinePaint = outlinePaint;\n        this.outlineStroke = outlineStroke;\n        this.lineVisible = lineVisible;\n        this.line = line;\n        this.lineStroke = lineStroke;\n        this.linePaint = linePaint;\n        this.toolTipText = toolTipText;\n        this.urlText = urlText;\n    }",
    "comment": " Creates a new legend item.  @param label  the label (<code>null</code> not permitted). @param description  the description (not currently used,  <code>null</code> permitted). @param toolTipText  the tool tip text (<code>null</code> permitted). @param urlText  the URL text (<code>null</code> permitted). @param shapeVisible  a flag that controls whether or not the shape is  displayed. @param shape  the shape (<code>null</code> permitted). @param shapeFilled  a flag that controls whether or not the shape is  filled. @param fillPaint  the fill paint (<code>null</code> not permitted). @param shapeOutlineVisible  a flag that controls whether or not the  shape is outlined. @param outlinePaint  the outline paint (<code>null</code> not permitted). @param outlineStroke  the outline stroke (<code>null</code> not  permitted). @param lineVisible  a flag that controls whether or not the line is  visible. @param line  the line. @param lineStroke  the stroke (<code>null</code> not permitted). @param linePaint  the line paint (<code>null</code> not permitted). ",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "LegendItem.getDataset",
    "class_name": "org.jfree.chart.LegendItem",
    "signature": "org.jfree.chart.LegendItem.getDataset()",
    "snippet": "    public Dataset getDataset() {\n        return this.dataset;\n    }",
    "comment": " Returns the dataset.  @return The dataset.  @since 1.0.6  @see #setDatasetIndex(int) ",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "LegendItem.getFillPaint",
    "class_name": "org.jfree.chart.LegendItem",
    "signature": "org.jfree.chart.LegendItem.getFillPaint()",
    "snippet": "    public Paint getFillPaint() {\n        return this.fillPaint;\n    }",
    "comment": " Returns the fill paint.  @return The fill paint (never <code>null</code>). ",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "LegendItem.getFillPaintTransformer",
    "class_name": "org.jfree.chart.LegendItem",
    "signature": "org.jfree.chart.LegendItem.getFillPaintTransformer()",
    "snippet": "    public GradientPaintTransformer getFillPaintTransformer() {\n        return this.fillPaintTransformer;\n    }",
    "comment": " Returns the transformer used when the fill paint is an instance of  <code>GradientPaint</code>.  @return The transformer (never <code>null</code>).  @since 1.0.4  @see #setFillPaintTransformer(GradientPaintTransformer) ",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "LegendItem.getLabel",
    "class_name": "org.jfree.chart.LegendItem",
    "signature": "org.jfree.chart.LegendItem.getLabel()",
    "snippet": "    public String getLabel() {\n        return this.label;\n    }",
    "comment": " Returns the label.  @return The label (never <code>null</code>). ",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "LegendItem.getLine",
    "class_name": "org.jfree.chart.LegendItem",
    "signature": "org.jfree.chart.LegendItem.getLine()",
    "snippet": "    public Shape getLine() {\n        return this.line;\n    }",
    "comment": " Returns the line.  @return The line. ",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "LegendItem.getLinePaint",
    "class_name": "org.jfree.chart.LegendItem",
    "signature": "org.jfree.chart.LegendItem.getLinePaint()",
    "snippet": "    public Paint getLinePaint() {\n        return this.linePaint;\n    }",
    "comment": " Returns the paint used for lines.  @return The paint. ",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "LegendItem.getLineStroke",
    "class_name": "org.jfree.chart.LegendItem",
    "signature": "org.jfree.chart.LegendItem.getLineStroke()",
    "snippet": "    public Stroke getLineStroke() {\n        return this.lineStroke;\n    }",
    "comment": " Returns the line stroke for the series.  @return The stroke (never <code>null</code>). ",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "LegendItem.getOutlinePaint",
    "class_name": "org.jfree.chart.LegendItem",
    "signature": "org.jfree.chart.LegendItem.getOutlinePaint()",
    "snippet": "    public Paint getOutlinePaint() {\n        return this.outlinePaint;\n    }",
    "comment": " Returns the outline paint.  @return The outline paint (never <code>null</code>). ",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "LegendItem.getOutlineStroke",
    "class_name": "org.jfree.chart.LegendItem",
    "signature": "org.jfree.chart.LegendItem.getOutlineStroke()",
    "snippet": "    public Stroke getOutlineStroke() {\n        return this.outlineStroke;\n    }",
    "comment": " Returns the outline stroke.  @return The outline stroke (never <code>null</code>). ",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "LegendItem.getSeriesKey",
    "class_name": "org.jfree.chart.LegendItem",
    "signature": "org.jfree.chart.LegendItem.getSeriesKey()",
    "snippet": "    public Comparable getSeriesKey() {\n        return this.seriesKey;\n    }",
    "comment": " Returns the series key.  @return The series key.  @since 1.0.6  @see #setSeriesKey(Comparable) ",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "LegendItem.getShape",
    "class_name": "org.jfree.chart.LegendItem",
    "signature": "org.jfree.chart.LegendItem.getShape()",
    "snippet": "    public Shape getShape() {\n        return this.shape;\n    }",
    "comment": " Returns the shape used to label the series represented by this legend  item.  @return The shape (never <code>null</code>). ",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "LegendItem.getToolTipText",
    "class_name": "org.jfree.chart.LegendItem",
    "signature": "org.jfree.chart.LegendItem.getToolTipText()",
    "snippet": "    public String getToolTipText() {\n        return this.toolTipText;   \n    }",
    "comment": " Returns the tool tip text.  @return The tool tip text (possibly <code>null</code>). ",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "LegendItem.getURLText",
    "class_name": "org.jfree.chart.LegendItem",
    "signature": "org.jfree.chart.LegendItem.getURLText()",
    "snippet": "    public String getURLText() {\n        return this.urlText; \n    }",
    "comment": " Returns the URL text.  @return The URL text (possibly <code>null</code>). ",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "LegendItem.isLineVisible",
    "class_name": "org.jfree.chart.LegendItem",
    "signature": "org.jfree.chart.LegendItem.isLineVisible()",
    "snippet": "    public boolean isLineVisible() {\n        return this.lineVisible;\n    }",
    "comment": " Returns a flag that indicates whether or not the line is visible.  @return A boolean. ",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "LegendItem.isShapeFilled",
    "class_name": "org.jfree.chart.LegendItem",
    "signature": "org.jfree.chart.LegendItem.isShapeFilled()",
    "snippet": "    public boolean isShapeFilled() {\n        return this.shapeFilled;\n    }",
    "comment": " Returns a flag that controls whether or not the shape is filled.  @return A boolean. ",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "LegendItem.isShapeOutlineVisible",
    "class_name": "org.jfree.chart.LegendItem",
    "signature": "org.jfree.chart.LegendItem.isShapeOutlineVisible()",
    "snippet": "    public boolean isShapeOutlineVisible() {\n        return this.shapeOutlineVisible;\n    }",
    "comment": " Returns the flag that controls whether or not the shape outline is visible.  @return A boolean. ",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "LegendItem.isShapeVisible",
    "class_name": "org.jfree.chart.LegendItem",
    "signature": "org.jfree.chart.LegendItem.isShapeVisible()",
    "snippet": "    public boolean isShapeVisible() {\n        return this.shapeVisible;\n    }",
    "comment": " Returns a flag that indicates whether or not the shape is visible.  @return A boolean. ",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "LegendItem.setDataset",
    "class_name": "org.jfree.chart.LegendItem",
    "signature": "org.jfree.chart.LegendItem.setDataset(Dataset)",
    "snippet": "    public void setDataset(Dataset dataset) {\n        this.dataset = dataset;\n    }",
    "comment": " Sets the dataset.  @param dataset  the dataset.  @since 1.0.6 ",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "LegendItem.setDatasetIndex",
    "class_name": "org.jfree.chart.LegendItem",
    "signature": "org.jfree.chart.LegendItem.setDatasetIndex(int)",
    "snippet": "    public void setDatasetIndex(int index) {\n        this.datasetIndex = index;\n    }",
    "comment": " Sets the dataset index for this legend item.  @param index  the index.  @since 1.0.2  @see #getDatasetIndex() ",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "LegendItem.setFillPaintTransformer",
    "class_name": "org.jfree.chart.LegendItem",
    "signature": "org.jfree.chart.LegendItem.setFillPaintTransformer(GradientPaintTransformer)",
    "snippet": "    public void setFillPaintTransformer(GradientPaintTransformer transformer) {\n        if (transformer == null) { \n            throw new IllegalArgumentException(\"Null 'transformer' attribute.\");\n        }\n        this.fillPaintTransformer = transformer;\n    }",
    "comment": " Sets the transformer used when the fill paint is an instance of  <code>GradientPaint</code>.  @param transformer  the transformer (<code>null</code> not permitted).  @since 1.0.4  @see #getFillPaintTransformer() ",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "LegendItem.setSeriesIndex",
    "class_name": "org.jfree.chart.LegendItem",
    "signature": "org.jfree.chart.LegendItem.setSeriesIndex(int)",
    "snippet": "    public void setSeriesIndex(int index) {\n        this.series = index;\n    }",
    "comment": " Sets the series index for this legend item.  @param index  the index.  @since 1.0.2 ",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "LegendItem.setSeriesKey",
    "class_name": "org.jfree.chart.LegendItem",
    "signature": "org.jfree.chart.LegendItem.setSeriesKey(Comparable)",
    "snippet": "    public void setSeriesKey(Comparable key) {\n        this.seriesKey = key;\n    }",
    "comment": " Sets the series key.  @param key  the series key.  @since 1.0.6 ",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "LegendItemCollection.LegendItemCollection",
    "class_name": "org.jfree.chart.LegendItemCollection",
    "signature": "org.jfree.chart.LegendItemCollection.LegendItemCollection()",
    "snippet": "    public LegendItemCollection() {\n        this.items = new java.util.ArrayList();\n    }",
    "comment": " Constructs a new legend item collection, initially empty. ",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "LegendItemCollection.add",
    "class_name": "org.jfree.chart.LegendItemCollection",
    "signature": "org.jfree.chart.LegendItemCollection.add(LegendItem)",
    "snippet": "    public void add(LegendItem item) {\n        this.items.add(item);\n    }",
    "comment": " Adds a legend item to the collection.  @param item  the item to add. ",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "LegendItemCollection.get",
    "class_name": "org.jfree.chart.LegendItemCollection",
    "signature": "org.jfree.chart.LegendItemCollection.get(int)",
    "snippet": "    public LegendItem get(int index) {\n        return (LegendItem) this.items.get(index);\n    }",
    "comment": " Returns a legend item from the collection.  @param index  the legend item index (zero-based).  @return The legend item. ",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "LegendItemCollection.getItemCount",
    "class_name": "org.jfree.chart.LegendItemCollection",
    "signature": "org.jfree.chart.LegendItemCollection.getItemCount()",
    "snippet": "    public int getItemCount() {\n        return this.items.size();\n    }",
    "comment": " Returns the number of legend items in the collection.  @return The item count. ",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "Axis.Axis",
    "class_name": "org.jfree.chart.axis.Axis",
    "signature": "org.jfree.chart.axis.Axis.Axis(String)",
    "snippet": "    protected Axis(String label) {\n\n        this.label = label;\n        this.visible = DEFAULT_AXIS_VISIBLE;\n        this.labelFont = DEFAULT_AXIS_LABEL_FONT;\n        this.labelPaint = DEFAULT_AXIS_LABEL_PAINT;\n        this.labelInsets = DEFAULT_AXIS_LABEL_INSETS;\n        this.labelAngle = 0.0;\n        this.labelToolTip = null;\n        this.labelURL = null;\n        \n        this.axisLineVisible = true;\n        this.axisLinePaint = DEFAULT_AXIS_LINE_PAINT;\n        this.axisLineStroke = DEFAULT_AXIS_LINE_STROKE;\n        \n        this.tickLabelsVisible = DEFAULT_TICK_LABELS_VISIBLE;\n        this.tickLabelFont = DEFAULT_TICK_LABEL_FONT;\n        this.tickLabelPaint = DEFAULT_TICK_LABEL_PAINT;\n        this.tickLabelInsets = DEFAULT_TICK_LABEL_INSETS;\n        \n        this.tickMarksVisible = DEFAULT_TICK_MARKS_VISIBLE;\n        this.tickMarkStroke = DEFAULT_TICK_MARK_STROKE;\n        this.tickMarkPaint = DEFAULT_TICK_MARK_PAINT;\n        this.tickMarkInsideLength = DEFAULT_TICK_MARK_INSIDE_LENGTH;\n        this.tickMarkOutsideLength = DEFAULT_TICK_MARK_OUTSIDE_LENGTH;\n\n        this.plot = null;\n\n        this.listenerList = new EventListenerList();\n\n    }",
    "comment": " Constructs an axis, using default values where necessary.  @param label  the axis label (<code>null</code> permitted). ",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "Axis.addChangeListener",
    "class_name": "org.jfree.chart.axis.Axis",
    "signature": "org.jfree.chart.axis.Axis.addChangeListener(AxisChangeListener)",
    "snippet": "    public void addChangeListener(AxisChangeListener listener) {\n        this.listenerList.add(AxisChangeListener.class, listener);\n    }",
    "comment": " Registers an object for notification of changes to the axis.  @param listener  the object that is being registered.  @see #removeChangeListener(AxisChangeListener) ",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "Axis.drawAxisLine",
    "class_name": "org.jfree.chart.axis.Axis",
    "signature": "org.jfree.chart.axis.Axis.drawAxisLine(Graphics2D,double,Rectangle2D,RectangleEdge)",
    "snippet": "    protected void drawAxisLine(Graphics2D g2, double cursor,\n            Rectangle2D dataArea, RectangleEdge edge) {\n        \n        Line2D axisLine = null;\n        if (edge == RectangleEdge.TOP) {\n            axisLine = new Line2D.Double(dataArea.getX(), cursor, \n                    dataArea.getMaxX(), cursor);  \n        }\n        else if (edge == RectangleEdge.BOTTOM) {\n            axisLine = new Line2D.Double(dataArea.getX(), cursor, \n                    dataArea.getMaxX(), cursor);  \n        }\n        else if (edge == RectangleEdge.LEFT) {\n            axisLine = new Line2D.Double(cursor, dataArea.getY(), cursor, \n                    dataArea.getMaxY());  \n        }\n        else if (edge == RectangleEdge.RIGHT) {\n            axisLine = new Line2D.Double(cursor, dataArea.getY(), cursor, \n                    dataArea.getMaxY());  \n        }\n        g2.setPaint(this.axisLinePaint);\n        g2.setStroke(this.axisLineStroke);\n        g2.draw(axisLine);\n        \n    }",
    "comment": " Draws an axis line at the current cursor position and edge.  @param g2  the graphics device. @param cursor  the cursor position. @param dataArea  the data area. @param edge  the edge. ",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "Axis.drawLabel",
    "class_name": "org.jfree.chart.axis.Axis",
    "signature": "org.jfree.chart.axis.Axis.drawLabel(String,Graphics2D,Rectangle2D,Rectangle2D,RectangleEdge,AxisState,PlotRenderingInfo)",
    "snippet": "    protected AxisState drawLabel(String label, Graphics2D g2, \n            Rectangle2D plotArea, Rectangle2D dataArea, RectangleEdge edge, \n            AxisState state, PlotRenderingInfo plotState) {\n\n        // it is unlikely that 'state' will be null, but check anyway...\n        if (state == null) {\n            throw new IllegalArgumentException(\"Null 'state' argument.\");\n        }\n        \n        if ((label == null) || (label.equals(\"\"))) {\n            return state;\n        }\n\n        Font font = getLabelFont();\n        RectangleInsets insets = getLabelInsets();\n        g2.setFont(font);\n        g2.setPaint(getLabelPaint());\n        FontMetrics fm = g2.getFontMetrics();\n        Rectangle2D labelBounds = TextUtilities.getTextBounds(label, g2, fm);\n        Shape hotspot = null;\n        \n        if (edge == RectangleEdge.TOP) {\n            AffineTransform t = AffineTransform.getRotateInstance(\n                    getLabelAngle(), labelBounds.getCenterX(), \n                    labelBounds.getCenterY());\n            Shape rotatedLabelBounds = t.createTransformedShape(labelBounds);\n            labelBounds = rotatedLabelBounds.getBounds2D();\n            float w = (float) labelBounds.getWidth();\n            float h = (float) labelBounds.getHeight();\n            float labelx = (float) dataArea.getCenterX();\n            float labely = (float) (state.getCursor() - insets.getBottom() \n                    - h / 2.0);\n            TextUtilities.drawRotatedString(label, g2, labelx, labely, \n                    TextAnchor.CENTER, getLabelAngle(), TextAnchor.CENTER);\n            hotspot = new Rectangle2D.Float(labelx - w / 2.0f, \n                    labely - h / 2.0f, w, h);\n            state.cursorUp(insets.getTop() + labelBounds.getHeight() \n                    + insets.getBottom());\n        }\n        else if (edge == RectangleEdge.BOTTOM) {\n            AffineTransform t = AffineTransform.getRotateInstance(\n                    getLabelAngle(), labelBounds.getCenterX(), \n                    labelBounds.getCenterY());\n            Shape rotatedLabelBounds = t.createTransformedShape(labelBounds);\n            labelBounds = rotatedLabelBounds.getBounds2D();\n            float w = (float) labelBounds.getWidth();\n            float h = (float) labelBounds.getHeight();\n            float labelx = (float) dataArea.getCenterX();\n            float labely = (float) (state.getCursor() + insets.getTop() \n                    + h / 2.0);\n            TextUtilities.drawRotatedString(label, g2, labelx, labely, \n                    TextAnchor.CENTER, getLabelAngle(), TextAnchor.CENTER);\n            hotspot = new Rectangle2D.Float(labelx - w / 2.0f, \n                    labely - h / 2.0f, w, h);\n            state.cursorDown(insets.getTop() + labelBounds.getHeight() \n                    + insets.getBottom());\n        }\n        else if (edge == RectangleEdge.LEFT) {\n            AffineTransform t = AffineTransform.getRotateInstance(\n                    getLabelAngle() - Math.PI / 2.0, labelBounds.getCenterX(), \n                    labelBounds.getCenterY());\n            Shape rotatedLabelBounds = t.createTransformedShape(labelBounds);\n            labelBounds = rotatedLabelBounds.getBounds2D();\n            float w = (float) labelBounds.getWidth();\n            float h = (float) labelBounds.getHeight();\n            float labelx = (float) (state.getCursor() - insets.getRight() \n                    - w / 2.0);\n            float labely = (float) dataArea.getCenterY();\n            TextUtilities.drawRotatedString(label, g2, labelx, labely, \n                    TextAnchor.CENTER, getLabelAngle() - Math.PI / 2.0, \n                    TextAnchor.CENTER);\n            hotspot = new Rectangle2D.Float(labelx - w / 2.0f, \n                    labely - h / 2.0f, w, h);\n            state.cursorLeft(insets.getLeft() + labelBounds.getWidth() \n                    + insets.getRight());\n        }\n        else if (edge == RectangleEdge.RIGHT) {\n\n            AffineTransform t = AffineTransform.getRotateInstance(\n                    getLabelAngle() + Math.PI / 2.0, \n                    labelBounds.getCenterX(), labelBounds.getCenterY());\n            Shape rotatedLabelBounds = t.createTransformedShape(labelBounds);\n            labelBounds = rotatedLabelBounds.getBounds2D();\n            float w = (float) labelBounds.getWidth();\n            float h = (float) labelBounds.getHeight();\n            float labelx = (float) (state.getCursor() \n                            + insets.getLeft() + w / 2.0);\n            float labely = (float) (dataArea.getY() + dataArea.getHeight() \n                    / 2.0);\n            TextUtilities.drawRotatedString(label, g2, labelx, labely, \n                    TextAnchor.CENTER, getLabelAngle() + Math.PI / 2.0, \n                    TextAnchor.CENTER);\n            hotspot = new Rectangle2D.Float(labelx - w / 2.0f, \n                    labely - h / 2.0f, w, h);\n            state.cursorRight(insets.getLeft() + labelBounds.getWidth() \n                    + insets.getRight());\n\n        }\n        if (plotState != null && hotspot != null) {\n            ChartRenderingInfo owner = plotState.getOwner();\n            if (owner != null) {\n                EntityCollection entities = owner.getEntityCollection();\n                if (entities != null) {\n                    entities.add(new AxisLabelEntity(this, hotspot, \n                            this.labelToolTip, this.labelURL));\n                }\n            }\n        }\n        return state;\n\n    }",
    "comment": " Draws the axis label.  @param label  the label text. @param g2  the graphics device. @param plotArea  the plot area. @param dataArea  the area inside the axes. @param edge  the location of the axis. @param state  the axis state (<code>null</code> not permitted). @param plotState  the plot state (<code>null</code> permitted).  @return Information about the axis. ",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "Axis.getAxisLinePaint",
    "class_name": "org.jfree.chart.axis.Axis",
    "signature": "org.jfree.chart.axis.Axis.getAxisLinePaint()",
    "snippet": "    public Paint getAxisLinePaint() {\n        return this.axisLinePaint;\n    }",
    "comment": " Returns the paint used to draw the axis line.  @return The paint (never <code>null</code>).  @see #setAxisLinePaint(Paint) ",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "Axis.getAxisLineStroke",
    "class_name": "org.jfree.chart.axis.Axis",
    "signature": "org.jfree.chart.axis.Axis.getAxisLineStroke()",
    "snippet": "    public Stroke getAxisLineStroke() {\n        return this.axisLineStroke;\n    }",
    "comment": " Returns the stroke used to draw the axis line.  @return The stroke (never <code>null</code>).  @see #setAxisLineStroke(Stroke) ",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "Axis.getFixedDimension",
    "class_name": "org.jfree.chart.axis.Axis",
    "signature": "org.jfree.chart.axis.Axis.getFixedDimension()",
    "snippet": "    public double getFixedDimension() {\n        return this.fixedDimension;\n    }",
    "comment": " Returns the fixed dimension for the axis.  @return The fixed dimension.  @see #setFixedDimension(double) ",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "Axis.getLabel",
    "class_name": "org.jfree.chart.axis.Axis",
    "signature": "org.jfree.chart.axis.Axis.getLabel()",
    "snippet": "    public String getLabel() {\n        return this.label;\n    }",
    "comment": " Returns the label for the axis.  @return The label for the axis (<code>null</code> possible).  @see #getLabelFont() @see #getLabelPaint() @see #setLabel(String) ",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "Axis.getLabelAngle",
    "class_name": "org.jfree.chart.axis.Axis",
    "signature": "org.jfree.chart.axis.Axis.getLabelAngle()",
    "snippet": "    public double getLabelAngle() {\n        return this.labelAngle;\n    }",
    "comment": " Returns the angle of the axis label.  @return The angle (in radians).  @see #setLabelAngle(double) ",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "Axis.getLabelEnclosure",
    "class_name": "org.jfree.chart.axis.Axis",
    "signature": "org.jfree.chart.axis.Axis.getLabelEnclosure(Graphics2D,RectangleEdge)",
    "snippet": "    protected Rectangle2D getLabelEnclosure(Graphics2D g2, RectangleEdge edge) {\n\n        Rectangle2D result = new Rectangle2D.Double();\n        String axisLabel = getLabel();\n        if (axisLabel != null && !axisLabel.equals(\"\")) {\n            FontMetrics fm = g2.getFontMetrics(getLabelFont());\n            Rectangle2D bounds = TextUtilities.getTextBounds(axisLabel, g2, fm);\n            RectangleInsets insets = getLabelInsets();\n            bounds = insets.createOutsetRectangle(bounds);\n            double angle = getLabelAngle();\n            if (edge == RectangleEdge.LEFT || edge == RectangleEdge.RIGHT) {\n                angle = angle - Math.PI / 2.0;\n            }\n            double x = bounds.getCenterX();\n            double y = bounds.getCenterY();\n            AffineTransform transformer \n                = AffineTransform.getRotateInstance(angle, x, y);\n            Shape labelBounds = transformer.createTransformedShape(bounds);\n            result = labelBounds.getBounds2D();\n        }\n\n        return result;\n\n    }",
    "comment": " Returns a rectangle that encloses the axis label.  This is typically  used for layout purposes (it gives the maximum dimensions of the label).  @param g2  the graphics device. @param edge  the edge of the plot area along which the axis is measuring.  @return The enclosing rectangle. ",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "Axis.getLabelFont",
    "class_name": "org.jfree.chart.axis.Axis",
    "signature": "org.jfree.chart.axis.Axis.getLabelFont()",
    "snippet": "    public Font getLabelFont() {\n        return this.labelFont;\n    }",
    "comment": " Returns the font for the axis label.  @return The font (never <code>null</code>).  @see #setLabelFont(Font) ",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "Axis.getLabelInsets",
    "class_name": "org.jfree.chart.axis.Axis",
    "signature": "org.jfree.chart.axis.Axis.getLabelInsets()",
    "snippet": "    public RectangleInsets getLabelInsets() {\n        return this.labelInsets;\n    }",
    "comment": " Returns the insets for the label (that is, the amount of blank space that should be left around the label).  @return The label insets (never <code>null</code>).  @see #setLabelInsets(RectangleInsets) ",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "Axis.getLabelPaint",
    "class_name": "org.jfree.chart.axis.Axis",
    "signature": "org.jfree.chart.axis.Axis.getLabelPaint()",
    "snippet": "    public Paint getLabelPaint() {\n        return this.labelPaint;\n    }",
    "comment": " Returns the color/shade used to draw the axis label.  @return The paint (never <code>null</code>).  @see #setLabelPaint(Paint) ",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "Axis.getPlot",
    "class_name": "org.jfree.chart.axis.Axis",
    "signature": "org.jfree.chart.axis.Axis.getPlot()",
    "snippet": "    public Plot getPlot() {\n        return this.plot;\n    }",
    "comment": " Returns the plot that the axis is assigned to.  This method will return  <code>null</code> if the axis is not currently assigned to a plot.  @return The plot that the axis is assigned to (possibly  <code>null</code>).  @see #setPlot(Plot) ",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "Axis.getTickLabelFont",
    "class_name": "org.jfree.chart.axis.Axis",
    "signature": "org.jfree.chart.axis.Axis.getTickLabelFont()",
    "snippet": "    public Font getTickLabelFont() {\n        return this.tickLabelFont;\n    }",
    "comment": " Returns the font used for the tick labels (if showing).  @return The font (never <code>null</code>).  @see #setTickLabelFont(Font) ",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "Axis.getTickLabelInsets",
    "class_name": "org.jfree.chart.axis.Axis",
    "signature": "org.jfree.chart.axis.Axis.getTickLabelInsets()",
    "snippet": "    public RectangleInsets getTickLabelInsets() {\n        return this.tickLabelInsets;\n    }",
    "comment": " Returns the insets for the tick labels.  @return The insets (never <code>null</code>).  @see #setTickLabelInsets(RectangleInsets) ",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "Axis.getTickLabelPaint",
    "class_name": "org.jfree.chart.axis.Axis",
    "signature": "org.jfree.chart.axis.Axis.getTickLabelPaint()",
    "snippet": "    public Paint getTickLabelPaint() {\n        return this.tickLabelPaint;\n    }",
    "comment": " Returns the color/shade used for the tick labels.  @return The paint used for the tick labels.  @see #setTickLabelPaint(Paint) ",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "Axis.getTickMarkInsideLength",
    "class_name": "org.jfree.chart.axis.Axis",
    "signature": "org.jfree.chart.axis.Axis.getTickMarkInsideLength()",
    "snippet": "    public float getTickMarkInsideLength() {\n        return this.tickMarkInsideLength;\n    }",
    "comment": " Returns the inside length of the tick marks.  @return The length.  @see #getTickMarkOutsideLength() @see #setTickMarkInsideLength(float) ",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "Axis.getTickMarkOutsideLength",
    "class_name": "org.jfree.chart.axis.Axis",
    "signature": "org.jfree.chart.axis.Axis.getTickMarkOutsideLength()",
    "snippet": "    public float getTickMarkOutsideLength() {\n        return this.tickMarkOutsideLength;\n    }",
    "comment": " Returns the outside length of the tick marks.  @return The length.  @see #getTickMarkInsideLength() @see #setTickMarkOutsideLength(float) ",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "Axis.getTickMarkPaint",
    "class_name": "org.jfree.chart.axis.Axis",
    "signature": "org.jfree.chart.axis.Axis.getTickMarkPaint()",
    "snippet": "    public Paint getTickMarkPaint() {\n        return this.tickMarkPaint;\n    }",
    "comment": " Returns the paint used to draw tick marks (if they are showing).  @return The paint (never <code>null</code>).  @see #setTickMarkPaint(Paint) ",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "Axis.getTickMarkStroke",
    "class_name": "org.jfree.chart.axis.Axis",
    "signature": "org.jfree.chart.axis.Axis.getTickMarkStroke()",
    "snippet": "    public Stroke getTickMarkStroke() {\n        return this.tickMarkStroke;\n    }",
    "comment": " Returns the stroke used to draw tick marks.  @return The stroke (never <code>null</code>).  @see #setTickMarkStroke(Stroke) ",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "Axis.isAxisLineVisible",
    "class_name": "org.jfree.chart.axis.Axis",
    "signature": "org.jfree.chart.axis.Axis.isAxisLineVisible()",
    "snippet": "    public boolean isAxisLineVisible() {\n        return this.axisLineVisible;\n    }",
    "comment": " A flag that controls whether or not the axis line is drawn.  @return A boolean.  @see #getAxisLinePaint() @see #getAxisLineStroke() @see #setAxisLineVisible(boolean) ",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "Axis.isTickLabelsVisible",
    "class_name": "org.jfree.chart.axis.Axis",
    "signature": "org.jfree.chart.axis.Axis.isTickLabelsVisible()",
    "snippet": "    public boolean isTickLabelsVisible() {\n        return this.tickLabelsVisible;\n    }",
    "comment": " Returns a flag indicating whether or not the tick labels are visible.  @return The flag.  @see #getTickLabelFont() @see #getTickLabelPaint() @see #setTickLabelsVisible(boolean) ",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "Axis.isTickMarksVisible",
    "class_name": "org.jfree.chart.axis.Axis",
    "signature": "org.jfree.chart.axis.Axis.isTickMarksVisible()",
    "snippet": "    public boolean isTickMarksVisible() {\n        return this.tickMarksVisible;\n    }",
    "comment": " Returns the flag that indicates whether or not the tick marks are showing.  @return The flag that indicates whether or not the tick marks are  showing.  @see #setTickMarksVisible(boolean) ",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "Axis.isVisible",
    "class_name": "org.jfree.chart.axis.Axis",
    "signature": "org.jfree.chart.axis.Axis.isVisible()",
    "snippet": "    public boolean isVisible() {\n        return this.visible;\n    }",
    "comment": " Returns <code>true</code> if the axis is visible, and  <code>false</code> otherwise.  @return A boolean.  @see #setVisible(boolean) ",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "Axis.notifyListeners",
    "class_name": "org.jfree.chart.axis.Axis",
    "signature": "org.jfree.chart.axis.Axis.notifyListeners(AxisChangeEvent)",
    "snippet": "    protected void notifyListeners(AxisChangeEvent event) {\n\n        Object[] listeners = this.listenerList.getListenerList();\n        for (int i = listeners.length - 2; i >= 0; i -= 2) {\n            if (listeners[i] == AxisChangeListener.class) {\n                ((AxisChangeListener) listeners[i + 1]).axisChanged(event);\n            }\n        }\n\n    }",
    "comment": " Notifies all registered listeners that the axis has changed. The AxisChangeEvent provides information about the change.  @param event  information about the change to the axis. ",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "Axis.setPlot",
    "class_name": "org.jfree.chart.axis.Axis",
    "signature": "org.jfree.chart.axis.Axis.setPlot(Plot)",
    "snippet": "    public void setPlot(Plot plot) {\n        this.plot = plot;\n        configure();\n    }",
    "comment": " Sets a reference to the plot that the axis is assigned to. <P> This method is used internally, you shouldn't need to call it yourself.  @param plot  the plot.  @see #getPlot() ",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "Axis.setTickMarksVisible",
    "class_name": "org.jfree.chart.axis.Axis",
    "signature": "org.jfree.chart.axis.Axis.setTickMarksVisible(boolean)",
    "snippet": "    public void setTickMarksVisible(boolean flag) {\n        if (flag != this.tickMarksVisible) {\n            this.tickMarksVisible = flag;\n            notifyListeners(new AxisChangeEvent(this));\n        }\n    }",
    "comment": " Sets the flag that indicates whether or not the tick marks are showing and sends an {@link AxisChangeEvent} to all registered listeners.  @param flag  the flag.  @see #isTickMarksVisible() ",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "AxisCollection.AxisCollection",
    "class_name": "org.jfree.chart.axis.AxisCollection",
    "signature": "org.jfree.chart.axis.AxisCollection.AxisCollection()",
    "snippet": "    public AxisCollection() {\n        this.axesAtTop = new java.util.ArrayList();\n        this.axesAtBottom = new java.util.ArrayList();\n        this.axesAtLeft = new java.util.ArrayList();\n        this.axesAtRight = new java.util.ArrayList();\n    }",
    "comment": " Creates a new empty collection. ",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "AxisCollection.add",
    "class_name": "org.jfree.chart.axis.AxisCollection",
    "signature": "org.jfree.chart.axis.AxisCollection.add(Axis,RectangleEdge)",
    "snippet": "    public void add(Axis axis, RectangleEdge edge) {\n        if (axis == null) {\n            throw new IllegalArgumentException(\"Null 'axis' argument.\");   \n        }\n        if (edge == null) {\n            throw new IllegalArgumentException(\"Null 'edge' argument.\");   \n        }\n        if (edge == RectangleEdge.TOP) {\n            this.axesAtTop.add(axis);\n        }\n        else if (edge == RectangleEdge.BOTTOM) {\n            this.axesAtBottom.add(axis);\n        }\n        else if (edge == RectangleEdge.LEFT) {\n            this.axesAtLeft.add(axis);\n        }\n        else if (edge == RectangleEdge.RIGHT) {\n            this.axesAtRight.add(axis);\n        }\n    }",
    "comment": " Adds an axis to the collection.  @param axis  the axis (<code>null</code> not permitted). @param edge  the edge of the plot that the axis should be drawn on  (<code>null</code> not permitted). ",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "AxisCollection.getAxesAtBottom",
    "class_name": "org.jfree.chart.axis.AxisCollection",
    "signature": "org.jfree.chart.axis.AxisCollection.getAxesAtBottom()",
    "snippet": "   public List getAxesAtBottom() {\n        return this.axesAtBottom;\n    }",
    "comment": " Returns a list of the axes (if any) that need to be drawn at the bottom  of the plot area.  @return A list of axes. ",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "AxisCollection.getAxesAtLeft",
    "class_name": "org.jfree.chart.axis.AxisCollection",
    "signature": "org.jfree.chart.axis.AxisCollection.getAxesAtLeft()",
    "snippet": "    public List getAxesAtLeft() {\n        return this.axesAtLeft;\n    }",
    "comment": " Returns a list of the axes (if any) that need to be drawn at the left  of the plot area.  @return A list of axes. ",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "AxisCollection.getAxesAtRight",
    "class_name": "org.jfree.chart.axis.AxisCollection",
    "signature": "org.jfree.chart.axis.AxisCollection.getAxesAtRight()",
    "snippet": "    public List getAxesAtRight() {\n        return this.axesAtRight;    \n    }",
    "comment": " Returns a list of the axes (if any) that need to be drawn at the right  of the plot area.  @return A list of axes. ",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "AxisCollection.getAxesAtTop",
    "class_name": "org.jfree.chart.axis.AxisCollection",
    "signature": "org.jfree.chart.axis.AxisCollection.getAxesAtTop()",
    "snippet": "    public List getAxesAtTop() {\n        return this.axesAtTop;\n    }",
    "comment": " Returns a list of the axes (if any) that need to be drawn at the top of  the plot area.  @return A list of axes. ",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "AxisSpace.AxisSpace",
    "class_name": "org.jfree.chart.axis.AxisSpace",
    "signature": "org.jfree.chart.axis.AxisSpace.AxisSpace()",
    "snippet": "    public AxisSpace() {\n        this.top = 0.0;\n        this.bottom = 0.0;\n        this.left = 0.0;\n        this.right = 0.0;\n    }",
    "comment": " Creates a new axis space record. ",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "AxisSpace.add",
    "class_name": "org.jfree.chart.axis.AxisSpace",
    "signature": "org.jfree.chart.axis.AxisSpace.add(double,RectangleEdge)",
    "snippet": "    public void add(double space, RectangleEdge edge) {\n        if (edge == null) {\n            throw new IllegalArgumentException(\"Null 'edge' argument.\");\n        }\n        if (edge == RectangleEdge.TOP) {     \n            this.top += space;\n        }\n        else if (edge == RectangleEdge.BOTTOM) {\n            this.bottom += space;\n        }\n        else if (edge == RectangleEdge.LEFT) {\n            this.left += space;\n        }\n        else if (edge == RectangleEdge.RIGHT) {\n            this.right += space;\n        }\n        else {\n            throw new IllegalStateException(\"Unrecognised 'edge' argument.\");\n        }\n    }",
    "comment": " Adds space to the top, bottom, left or right edge of the plot area.  @param space  the space (in Java2D units). @param edge  the edge (<code>null</code> not permitted). ",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "AxisSpace.shrink",
    "class_name": "org.jfree.chart.axis.AxisSpace",
    "signature": "org.jfree.chart.axis.AxisSpace.shrink(Rectangle2D,Rectangle2D)",
    "snippet": "    public Rectangle2D shrink(Rectangle2D area, Rectangle2D result) {\n        if (result == null) {\n            result = new Rectangle2D.Double();\n        }\n        result.setRect(\n            area.getX() + this.left, \n            area.getY() + this.top,\n            area.getWidth() - this.left - this.right,\n            area.getHeight() - this.top - this.bottom\n        );\n        return result;\n    }",
    "comment": " Shrinks an area by the space attributes.  @param area  the area to shrink. @param result  an optional carrier for the result.  @return The result. ",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "AxisState.AxisState",
    "class_name": "org.jfree.chart.axis.AxisState",
    "signature": "org.jfree.chart.axis.AxisState.AxisState()",
    "snippet": "    public AxisState() {\n        this(0.0);\n    }",
    "comment": " Creates a new axis state. ",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "AxisState.AxisState",
    "class_name": "org.jfree.chart.axis.AxisState",
    "signature": "org.jfree.chart.axis.AxisState.AxisState(double)",
    "snippet": "    public AxisState(double cursor) {\n        this.cursor = cursor;\n        this.ticks = new java.util.ArrayList();\n    }",
    "comment": " Creates a new axis state.  @param cursor  the cursor. ",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "AxisState.cursorDown",
    "class_name": "org.jfree.chart.axis.AxisState",
    "signature": "org.jfree.chart.axis.AxisState.cursorDown(double)",
    "snippet": "    public void cursorDown(double units) {\n        this.cursor = this.cursor + units;\n    }",
    "comment": " Moves the cursor down by the specified number of Java 2D units.  @param units  the units. ",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "AxisState.cursorLeft",
    "class_name": "org.jfree.chart.axis.AxisState",
    "signature": "org.jfree.chart.axis.AxisState.cursorLeft(double)",
    "snippet": "    public void cursorLeft(double units) {\n        this.cursor = this.cursor - units;\n    }",
    "comment": " Moves the cursor left by the specified number of Java 2D units.  @param units  the units. ",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "AxisState.cursorUp",
    "class_name": "org.jfree.chart.axis.AxisState",
    "signature": "org.jfree.chart.axis.AxisState.cursorUp(double)",
    "snippet": "    public void cursorUp(double units) {\n        this.cursor = this.cursor - units;\n    }",
    "comment": " Moves the cursor up by the specified number of Java 2D units.  @param units  the units. ",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "AxisState.getCursor",
    "class_name": "org.jfree.chart.axis.AxisState",
    "signature": "org.jfree.chart.axis.AxisState.getCursor()",
    "snippet": "    public double getCursor() {\n        return this.cursor;\n    }",
    "comment": " Returns the cursor position.  @return The cursor position. ",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "AxisState.getMax",
    "class_name": "org.jfree.chart.axis.AxisState",
    "signature": "org.jfree.chart.axis.AxisState.getMax()",
    "snippet": "    public double getMax() {\n        return this.max;\n    }",
    "comment": " Returns the maximum width/height.  @return The maximum width/height. ",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "AxisState.getTicks",
    "class_name": "org.jfree.chart.axis.AxisState",
    "signature": "org.jfree.chart.axis.AxisState.getTicks()",
    "snippet": "    public List getTicks() {\n        return this.ticks;\n    }",
    "comment": " Returns the list of ticks.  @return The list of ticks. ",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "AxisState.setMax",
    "class_name": "org.jfree.chart.axis.AxisState",
    "signature": "org.jfree.chart.axis.AxisState.setMax(double)",
    "snippet": "    public void setMax(double max) {\n        this.max = max;\n    }",
    "comment": " Sets the maximum width/height.  @param max the maximum width/height. ",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "AxisState.setTicks",
    "class_name": "org.jfree.chart.axis.AxisState",
    "signature": "org.jfree.chart.axis.AxisState.setTicks(List)",
    "snippet": "    public void setTicks(List ticks) {\n        this.ticks = ticks;\n    }",
    "comment": " Sets the list of ticks.  @param ticks  the ticks. ",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "CategoryAxis.CategoryAxis",
    "class_name": "org.jfree.chart.axis.CategoryAxis",
    "signature": "org.jfree.chart.axis.CategoryAxis.CategoryAxis(String)",
    "snippet": "    public CategoryAxis(String label) {\n\n        super(label);\n\n        this.lowerMargin = DEFAULT_AXIS_MARGIN;\n        this.upperMargin = DEFAULT_AXIS_MARGIN;\n        this.categoryMargin = DEFAULT_CATEGORY_MARGIN;\n        this.maximumCategoryLabelLines = 1;\n        this.maximumCategoryLabelWidthRatio = 0.0f;\n        \n        setTickMarksVisible(false);  // not supported by this axis type yet\n        \n        this.categoryLabelPositionOffset = 4;\n        this.categoryLabelPositions = CategoryLabelPositions.STANDARD;\n        this.tickLabelFontMap = new HashMap();\n        this.tickLabelPaintMap = new HashMap();\n        this.categoryLabelToolTips = new HashMap();\n        \n    }",
    "comment": " Constructs a category axis, using default values where necessary.  @param label  the axis label (<code>null</code> permitted). ",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "CategoryAxis.calculateCategoryGapSize",
    "class_name": "org.jfree.chart.axis.CategoryAxis",
    "signature": "org.jfree.chart.axis.CategoryAxis.calculateCategoryGapSize(int,Rectangle2D,RectangleEdge)",
    "snippet": "    protected double calculateCategoryGapSize(int categoryCount, \n                                              Rectangle2D area,\n                                              RectangleEdge edge) {\n\n        double result = 0.0;\n        double available = 0.0;\n\n        if ((edge == RectangleEdge.TOP) || (edge == RectangleEdge.BOTTOM)) {\n            available = area.getWidth();\n        }\n        else if ((edge == RectangleEdge.LEFT) \n                || (edge == RectangleEdge.RIGHT)) {\n            available = area.getHeight();\n        }\n\n        if (categoryCount > 1) {\n            result = available * getCategoryMargin() / (categoryCount - 1);\n        }\n\n        return result;\n\n    }",
    "comment": " Calculates the size (width or height, depending on the location of the  axis) of a category gap.  @param categoryCount  the number of categories. @param area  the area within which the categories will be drawn. @param edge  the axis location.  @return The category gap width. ",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "CategoryAxis.calculateCategorySize",
    "class_name": "org.jfree.chart.axis.CategoryAxis",
    "signature": "org.jfree.chart.axis.CategoryAxis.calculateCategorySize(int,Rectangle2D,RectangleEdge)",
    "snippet": "    protected double calculateCategorySize(int categoryCount, Rectangle2D area,\n                                           RectangleEdge edge) {\n\n        double result = 0.0;\n        double available = 0.0;\n\n        if ((edge == RectangleEdge.TOP) || (edge == RectangleEdge.BOTTOM)) {\n            available = area.getWidth();\n        }\n        else if ((edge == RectangleEdge.LEFT) \n                || (edge == RectangleEdge.RIGHT)) {\n            available = area.getHeight();\n        }\n        if (categoryCount > 1) {\n            result = available * (1 - getLowerMargin() - getUpperMargin() \n                     - getCategoryMargin());\n            result = result / categoryCount;\n        }\n        else {\n            result = available * (1 - getLowerMargin() - getUpperMargin());\n        }\n        return result;\n\n    }",
    "comment": " Calculates the size (width or height, depending on the location of the  axis) of a category.  @param categoryCount  the number of categories. @param area  the area within which the categories will be drawn. @param edge  the axis location.  @return The category size. ",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "CategoryAxis.calculateTextBlockHeight",
    "class_name": "org.jfree.chart.axis.CategoryAxis",
    "signature": "org.jfree.chart.axis.CategoryAxis.calculateTextBlockHeight(TextBlock,CategoryLabelPosition,Graphics2D)",
    "snippet": "    protected double calculateTextBlockHeight(TextBlock block, \n                                              CategoryLabelPosition position, \n                                              Graphics2D g2) {\n                                                    \n        RectangleInsets insets = getTickLabelInsets();\n        Size2D size = block.calculateDimensions(g2);\n        Rectangle2D box = new Rectangle2D.Double(0.0, 0.0, size.getWidth(), \n                size.getHeight());\n        Shape rotatedBox = ShapeUtilities.rotateShape(box, position.getAngle(),\n                0.0f, 0.0f);\n        double h = rotatedBox.getBounds2D().getHeight() \n                   + insets.getTop() + insets.getBottom();\n        return h;\n        \n    }",
    "comment": " A utility method for determining the height of a text block.  @param block  the text block. @param position  the label position. @param g2  the graphics device.  @return The height. ",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "CategoryAxis.calculateTextBlockWidth",
    "class_name": "org.jfree.chart.axis.CategoryAxis",
    "signature": "org.jfree.chart.axis.CategoryAxis.calculateTextBlockWidth(TextBlock,CategoryLabelPosition,Graphics2D)",
    "snippet": "    protected double calculateTextBlockWidth(TextBlock block, \n                                             CategoryLabelPosition position, \n                                             Graphics2D g2) {\n                                                    \n        RectangleInsets insets = getTickLabelInsets();\n        Size2D size = block.calculateDimensions(g2);\n        Rectangle2D box = new Rectangle2D.Double(0.0, 0.0, size.getWidth(), \n                size.getHeight());\n        Shape rotatedBox = ShapeUtilities.rotateShape(box, position.getAngle(),\n                0.0f, 0.0f);\n        double w = rotatedBox.getBounds2D().getWidth() + insets.getTop() \n                + insets.getBottom();\n        return w;\n        \n    }",
    "comment": " A utility method for determining the width of a text block.  @param block  the text block. @param position  the position. @param g2  the graphics device.  @return The width. ",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "CategoryAxis.configure",
    "class_name": "org.jfree.chart.axis.CategoryAxis",
    "signature": "org.jfree.chart.axis.CategoryAxis.configure()",
    "snippet": "    public void configure() {\n        // nothing required\n    }",
    "comment": " Configures the axis against the current plot. ",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "CategoryAxis.createLabel",
    "class_name": "org.jfree.chart.axis.CategoryAxis",
    "signature": "org.jfree.chart.axis.CategoryAxis.createLabel(Comparable,float,RectangleEdge,Graphics2D)",
    "snippet": "    protected TextBlock createLabel(Comparable category, float width, \n                                    RectangleEdge edge, Graphics2D g2) {\n        TextBlock label = TextUtilities.createTextBlock(category.toString(), \n                getTickLabelFont(category), getTickLabelPaint(category), width,\n                this.maximumCategoryLabelLines, new G2TextMeasurer(g2));  \n        return label; \n    }",
    "comment": " Creates a label.  @param category  the category. @param width  the available width.  @param edge  the edge on which the axis appears. @param g2  the graphics device.  @return A label. ",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "CategoryAxis.draw",
    "class_name": "org.jfree.chart.axis.CategoryAxis",
    "signature": "org.jfree.chart.axis.CategoryAxis.draw(Graphics2D,double,Rectangle2D,Rectangle2D,RectangleEdge,PlotRenderingInfo)",
    "snippet": "    public AxisState draw(Graphics2D g2, \n                          double cursor, \n                          Rectangle2D plotArea, \n                          Rectangle2D dataArea,\n                          RectangleEdge edge,\n                          PlotRenderingInfo plotState) {\n        \n        // if the axis is not visible, don't draw it...\n        if (!isVisible()) {\n            return new AxisState(cursor);\n        }\n        \n        if (isAxisLineVisible()) {\n            drawAxisLine(g2, cursor, dataArea, edge);\n        }\n\n        // draw the category labels and axis label\n        AxisState state = new AxisState(cursor);\n        state = drawCategoryLabels(g2, plotArea, dataArea, edge, state, \n                plotState);\n        state = drawLabel(getLabel(), g2, plotArea, dataArea, edge, state,\n                plotState);\n    \n        return state;\n\n    }",
    "comment": " Draws the axis on a Java 2D graphics device (such as the screen or a  printer).  @param g2  the graphics device (<code>null</code> not permitted). @param cursor  the cursor location. @param plotArea  the area within which the axis should be drawn  (<code>null</code> not permitted). @param dataArea  the area within which the plot is being drawn  (<code>null</code> not permitted). @param edge  the location of the axis (<code>null</code> not permitted). @param plotState  collects information about the plot  (<code>null</code> permitted).  @return The axis state (never <code>null</code>). ",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "CategoryAxis.drawCategoryLabels",
    "class_name": "org.jfree.chart.axis.CategoryAxis",
    "signature": "org.jfree.chart.axis.CategoryAxis.drawCategoryLabels(Graphics2D,Rectangle2D,Rectangle2D,RectangleEdge,AxisState,PlotRenderingInfo)",
    "snippet": "    protected AxisState drawCategoryLabels(Graphics2D g2,\n                                           Rectangle2D plotArea,\n                                           Rectangle2D dataArea,\n                                           RectangleEdge edge,\n                                           AxisState state,\n                                           PlotRenderingInfo plotState) {\n\n        if (state == null) {\n            throw new IllegalArgumentException(\"Null 'state' argument.\");\n        }\n\n        if (isTickLabelsVisible()) {       \n            List ticks = refreshTicks(g2, state, plotArea, edge);       \n            state.setTicks(ticks);        \n          \n            int categoryIndex = 0;\n            Iterator iterator = ticks.iterator();\n            while (iterator.hasNext()) {\n                \n                CategoryTick tick = (CategoryTick) iterator.next();\n                g2.setFont(getTickLabelFont(tick.getCategory()));\n                g2.setPaint(getTickLabelPaint(tick.getCategory()));\n\n                CategoryLabelPosition position \n                        = this.categoryLabelPositions.getLabelPosition(edge);\n                double x0 = 0.0;\n                double x1 = 0.0;\n                double y0 = 0.0;\n                double y1 = 0.0;\n                if (edge == RectangleEdge.TOP) {\n                    x0 = getCategoryStart(categoryIndex, ticks.size(), \n                            dataArea, edge);\n                    x1 = getCategoryEnd(categoryIndex, ticks.size(), dataArea, \n                            edge);\n                    y1 = state.getCursor() - this.categoryLabelPositionOffset;\n                    y0 = y1 - state.getMax();\n                }\n                else if (edge == RectangleEdge.BOTTOM) {\n                    x0 = getCategoryStart(categoryIndex, ticks.size(), \n                            dataArea, edge);\n                    x1 = getCategoryEnd(categoryIndex, ticks.size(), dataArea, \n                            edge); \n                    y0 = state.getCursor() + this.categoryLabelPositionOffset;\n                    y1 = y0 + state.getMax();\n                }\n                else if (edge == RectangleEdge.LEFT) {\n                    y0 = getCategoryStart(categoryIndex, ticks.size(), \n                            dataArea, edge);\n                    y1 = getCategoryEnd(categoryIndex, ticks.size(), dataArea, \n                            edge);\n                    x1 = state.getCursor() - this.categoryLabelPositionOffset;\n                    x0 = x1 - state.getMax();\n                }\n                else if (edge == RectangleEdge.RIGHT) {\n                    y0 = getCategoryStart(categoryIndex, ticks.size(), \n                            dataArea, edge);\n                    y1 = getCategoryEnd(categoryIndex, ticks.size(), dataArea, \n                            edge);\n                    x0 = state.getCursor() + this.categoryLabelPositionOffset;\n                    x1 = x0 - state.getMax();\n                }\n                Rectangle2D area = new Rectangle2D.Double(x0, y0, (x1 - x0), \n                        (y1 - y0));\n                Point2D anchorPoint = RectangleAnchor.coordinates(area, \n                        position.getCategoryAnchor());\n                TextBlock block = tick.getLabel();\n                block.draw(g2, (float) anchorPoint.getX(), \n                        (float) anchorPoint.getY(), position.getLabelAnchor(), \n                        (float) anchorPoint.getX(), (float) anchorPoint.getY(), \n                        position.getAngle());\n                Shape bounds = block.calculateBounds(g2, \n                        (float) anchorPoint.getX(), (float) anchorPoint.getY(), \n                        position.getLabelAnchor(), (float) anchorPoint.getX(), \n                        (float) anchorPoint.getY(), position.getAngle());\n                if (plotState != null && plotState.getOwner() != null) {\n                    EntityCollection entities \n                            = plotState.getOwner().getEntityCollection();\n                    if (entities != null) {\n                        String tooltip = getCategoryLabelToolTip(\n                                tick.getCategory());\n                        entities.add(new CategoryLabelEntity(tick.getCategory(),\n                                bounds, tooltip, null));\n                    }\n                }\n                categoryIndex++;\n            }\n\n            if (edge.equals(RectangleEdge.TOP)) {\n                double h = state.getMax() + this.categoryLabelPositionOffset;\n                state.cursorUp(h);\n            }\n            else if (edge.equals(RectangleEdge.BOTTOM)) {\n                double h = state.getMax() + this.categoryLabelPositionOffset;\n                state.cursorDown(h);\n            }\n            else if (edge == RectangleEdge.LEFT) {\n                double w = state.getMax() + this.categoryLabelPositionOffset;\n                state.cursorLeft(w);\n            }\n            else if (edge == RectangleEdge.RIGHT) {\n                double w = state.getMax() + this.categoryLabelPositionOffset;\n                state.cursorRight(w);\n            }\n        }\n        return state;\n    }",
    "comment": " Draws the category labels and returns the updated axis state.  @param g2  the graphics device (<code>null</code> not permitted). @param plotArea  the plot area (<code>null</code> not permitted). @param dataArea  the area inside the axes (<code>null</code> not  permitted). @param edge  the axis location (<code>null</code> not permitted). @param state  the axis state (<code>null</code> not permitted). @param plotState  collects information about the plot (<code>null</code> permitted).  @return The updated axis state (never <code>null</code>).  @since 1.0.2 ",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "CategoryAxis.getCategoryEnd",
    "class_name": "org.jfree.chart.axis.CategoryAxis",
    "signature": "org.jfree.chart.axis.CategoryAxis.getCategoryEnd(int,int,Rectangle2D,RectangleEdge)",
    "snippet": "    public double getCategoryEnd(int category, int categoryCount, \n                                 Rectangle2D area, RectangleEdge edge) {\n\n        return getCategoryStart(category, categoryCount, area, edge)\n               + calculateCategorySize(categoryCount, area, edge);\n\n    }",
    "comment": " Returns the end coordinate for the specified category.  @param category  the category. @param categoryCount  the number of categories. @param area  the data area. @param edge  the axis location.  @return The coordinate.  @see #getCategoryStart(int, int, Rectangle2D, RectangleEdge) @see #getCategoryMiddle(int, int, Rectangle2D, RectangleEdge) ",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "CategoryAxis.getCategoryMargin",
    "class_name": "org.jfree.chart.axis.CategoryAxis",
    "signature": "org.jfree.chart.axis.CategoryAxis.getCategoryMargin()",
    "snippet": "    public double getCategoryMargin() {\n        return this.categoryMargin;\n    }",
    "comment": " Returns the category margin.  @return The margin.  @see #setCategoryMargin(double) ",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "CategoryAxis.getCategoryStart",
    "class_name": "org.jfree.chart.axis.CategoryAxis",
    "signature": "org.jfree.chart.axis.CategoryAxis.getCategoryStart(int,int,Rectangle2D,RectangleEdge)",
    "snippet": "    public double getCategoryStart(int category, int categoryCount, \n                                   Rectangle2D area,\n                                   RectangleEdge edge) {\n\n        double result = 0.0;\n        if ((edge == RectangleEdge.TOP) || (edge == RectangleEdge.BOTTOM)) {\n            result = area.getX() + area.getWidth() * getLowerMargin();\n        }\n        else if ((edge == RectangleEdge.LEFT) \n                || (edge == RectangleEdge.RIGHT)) {\n            result = area.getMinY() + area.getHeight() * getLowerMargin();\n        }\n\n        double categorySize = calculateCategorySize(categoryCount, area, edge);\n        double categoryGapWidth = calculateCategoryGapSize(categoryCount, area,\n                edge);\n\n        result = result + category * (categorySize + categoryGapWidth);\n        return result;\n        \n    }",
    "comment": " Returns the starting coordinate for the specified category.  @param category  the category. @param categoryCount  the number of categories. @param area  the data area. @param edge  the axis location.  @return The coordinate.  @see #getCategoryMiddle(int, int, Rectangle2D, RectangleEdge) @see #getCategoryEnd(int, int, Rectangle2D, RectangleEdge) ",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "CategoryAxis.getLowerMargin",
    "class_name": "org.jfree.chart.axis.CategoryAxis",
    "signature": "org.jfree.chart.axis.CategoryAxis.getLowerMargin()",
    "snippet": "    public double getLowerMargin() {\n        return this.lowerMargin;\n    }",
    "comment": " Returns the lower margin for the axis.  @return The margin.  @see #getUpperMargin() @see #setLowerMargin(double) ",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "CategoryAxis.getTickLabelFont",
    "class_name": "org.jfree.chart.axis.CategoryAxis",
    "signature": "org.jfree.chart.axis.CategoryAxis.getTickLabelFont(Comparable)",
    "snippet": "    public Font getTickLabelFont(Comparable category) {\n        if (category == null) {\n            throw new IllegalArgumentException(\"Null 'category' argument.\");\n        }\n        Font result = (Font) this.tickLabelFontMap.get(category);\n        // if there is no specific font, use the general one...\n        if (result == null) {\n            result = getTickLabelFont();\n        }\n        return result;\n    }",
    "comment": " Returns the font for the tick label for the given category.  @param category  the category (<code>null</code> not permitted).  @return The font (never <code>null</code>).  @see #setTickLabelFont(Comparable, Font) ",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "CategoryAxis.getTickLabelPaint",
    "class_name": "org.jfree.chart.axis.CategoryAxis",
    "signature": "org.jfree.chart.axis.CategoryAxis.getTickLabelPaint(Comparable)",
    "snippet": "    public Paint getTickLabelPaint(Comparable category) {\n        if (category == null) {\n            throw new IllegalArgumentException(\"Null 'category' argument.\");\n        }\n        Paint result = (Paint) this.tickLabelPaintMap.get(category);\n        // if there is no specific paint, use the general one...\n        if (result == null) {\n            result = getTickLabelPaint();\n        }\n        return result;\n    }",
    "comment": " Returns the paint for the tick label for the given category.  @param category  the category (<code>null</code> not permitted).  @return The paint (never <code>null</code>).  @see #setTickLabelPaint(Paint) ",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "CategoryAxis.getUpperMargin",
    "class_name": "org.jfree.chart.axis.CategoryAxis",
    "signature": "org.jfree.chart.axis.CategoryAxis.getUpperMargin()",
    "snippet": "    public double getUpperMargin() {\n        return this.upperMargin;\n    }",
    "comment": " Returns the upper margin for the axis.  @return The margin.  @see #getLowerMargin() @see #setUpperMargin(double) ",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "CategoryAxis.hashCode",
    "class_name": "org.jfree.chart.axis.CategoryAxis",
    "signature": "org.jfree.chart.axis.CategoryAxis.hashCode()",
    "snippet": "    public int hashCode() {\n        if (getLabel() != null) {\n            return getLabel().hashCode();\n        }\n        else {\n            return 0;\n        }\n    }",
    "comment": " Returns a hash code for this object.  @return A hash code. ",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "CategoryAxis.refreshTicks",
    "class_name": "org.jfree.chart.axis.CategoryAxis",
    "signature": "org.jfree.chart.axis.CategoryAxis.refreshTicks(Graphics2D,AxisState,Rectangle2D,RectangleEdge)",
    "snippet": "    public List refreshTicks(Graphics2D g2, \n                             AxisState state,\n                             Rectangle2D dataArea,\n                             RectangleEdge edge) {\n\n        List ticks = new java.util.ArrayList();\n        \n        // sanity check for data area...\n        if (dataArea.getHeight() <= 0.0 || dataArea.getWidth() < 0.0) {\n            return ticks;\n        }\n\n        CategoryPlot plot = (CategoryPlot) getPlot();\n        List categories = plot.getCategoriesForAxis(this);\n        double max = 0.0;\n                \n        if (categories != null) {\n            CategoryLabelPosition position \n                    = this.categoryLabelPositions.getLabelPosition(edge);\n            float r = this.maximumCategoryLabelWidthRatio;\n            if (r <= 0.0) {\n                r = position.getWidthRatio();   \n            }\n                  \n            float l = 0.0f;\n            if (position.getWidthType() == CategoryLabelWidthType.CATEGORY) {\n                l = (float) calculateCategorySize(categories.size(), dataArea, \n                        edge);  \n            }\n            else {\n                if (RectangleEdge.isLeftOrRight(edge)) {\n                    l = (float) dataArea.getWidth();   \n                }\n                else {\n                    l = (float) dataArea.getHeight();   \n                }\n            }\n            int categoryIndex = 0;\n            Iterator iterator = categories.iterator();\n            while (iterator.hasNext()) {\n                Comparable category = (Comparable) iterator.next();\n                TextBlock label = createLabel(category, l * r, edge, g2);\n                if (edge == RectangleEdge.TOP || edge == RectangleEdge.BOTTOM) {\n                    max = Math.max(max, calculateTextBlockHeight(label, \n                            position, g2));\n                }\n                else if (edge == RectangleEdge.LEFT \n                        || edge == RectangleEdge.RIGHT) {\n                    max = Math.max(max, calculateTextBlockWidth(label, \n                            position, g2));\n                }\n                Tick tick = new CategoryTick(category, label, \n                        position.getLabelAnchor(), position.getRotationAnchor(), \n                        position.getAngle());\n                ticks.add(tick);\n                categoryIndex = categoryIndex + 1;\n            }\n        }\n        state.setMax(max);\n        return ticks;\n        \n    }",
    "comment": " Creates a temporary list of ticks that can be used when drawing the axis.  @param g2  the graphics device (used to get font measurements). @param state  the axis state. @param dataArea  the area inside the axes. @param edge  the location of the axis.  @return A list of ticks. ",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "CategoryAxis.reserveSpace",
    "class_name": "org.jfree.chart.axis.CategoryAxis",
    "signature": "org.jfree.chart.axis.CategoryAxis.reserveSpace(Graphics2D,Plot,Rectangle2D,RectangleEdge,AxisSpace)",
    "snippet": "    public AxisSpace reserveSpace(Graphics2D g2, Plot plot, \n                                  Rectangle2D plotArea, \n                                  RectangleEdge edge, AxisSpace space) {\n\n        // create a new space object if one wasn't supplied...\n        if (space == null) {\n            space = new AxisSpace();\n        }\n        \n        // if the axis is not visible, no additional space is required...\n        if (!isVisible()) {\n            return space;\n        }\n\n        // calculate the max size of the tick labels (if visible)...\n        double tickLabelHeight = 0.0;\n        double tickLabelWidth = 0.0;\n        if (isTickLabelsVisible()) {\n            g2.setFont(getTickLabelFont());\n            AxisState state = new AxisState();\n            // we call refresh ticks just to get the maximum width or height\n            refreshTicks(g2, state, plotArea, edge);\n            if (edge == RectangleEdge.TOP) {\n                tickLabelHeight = state.getMax();\n            }\n            else if (edge == RectangleEdge.BOTTOM) {\n                tickLabelHeight = state.getMax();\n            }\n            else if (edge == RectangleEdge.LEFT) {\n                tickLabelWidth = state.getMax(); \n            }\n            else if (edge == RectangleEdge.RIGHT) {\n                tickLabelWidth = state.getMax(); \n            }\n        }\n        \n        // get the axis label size and update the space object...\n        Rectangle2D labelEnclosure = getLabelEnclosure(g2, edge);\n        double labelHeight = 0.0;\n        double labelWidth = 0.0;\n        if (RectangleEdge.isTopOrBottom(edge)) {\n            labelHeight = labelEnclosure.getHeight();\n            space.add(labelHeight + tickLabelHeight \n                    + this.categoryLabelPositionOffset, edge);\n        }\n        else if (RectangleEdge.isLeftOrRight(edge)) {\n            labelWidth = labelEnclosure.getWidth();\n            space.add(labelWidth + tickLabelWidth \n                    + this.categoryLabelPositionOffset, edge);\n        }\n        return space;\n\n    }",
    "comment": " Estimates the space required for the axis, given a specific drawing area.  @param g2  the graphics device (used to obtain font information). @param plot  the plot that the axis belongs to. @param plotArea  the area within which the axis should be drawn. @param edge  the axis location (top or bottom). @param space  the space already reserved.  @return The space required to draw the axis. ",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "CategoryLabelPosition.CategoryLabelPosition",
    "class_name": "org.jfree.chart.axis.CategoryLabelPosition",
    "signature": "org.jfree.chart.axis.CategoryLabelPosition.CategoryLabelPosition(RectangleAnchor,TextBlockAnchor)",
    "snippet": "    public CategoryLabelPosition(RectangleAnchor categoryAnchor, \n                                 TextBlockAnchor labelAnchor) {\n        // argument checking delegated...\n        this(categoryAnchor, labelAnchor, TextAnchor.CENTER, 0.0, \n                CategoryLabelWidthType.CATEGORY, 0.95f);\n    }",
    "comment": " Creates a new category label position record.  @param categoryAnchor  the category anchor (<code>null</code> not  permitted). @param labelAnchor  the label anchor (<code>null</code> not permitted). ",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "CategoryLabelPosition.CategoryLabelPosition",
    "class_name": "org.jfree.chart.axis.CategoryLabelPosition",
    "signature": "org.jfree.chart.axis.CategoryLabelPosition.CategoryLabelPosition(RectangleAnchor,TextBlockAnchor,CategoryLabelWidthType,float)",
    "snippet": "    public CategoryLabelPosition(RectangleAnchor categoryAnchor, \n                                 TextBlockAnchor labelAnchor,\n                                 CategoryLabelWidthType widthType,\n                                 float widthRatio) {\n        // argument checking delegated...\n        this(categoryAnchor, labelAnchor, TextAnchor.CENTER, 0.0, widthType, \n                widthRatio);\n    }",
    "comment": " Creates a new category label position record.  @param categoryAnchor  the category anchor (<code>null</code> not  permitted). @param labelAnchor  the label anchor (<code>null</code> not permitted). @param widthType  the width type (<code>null</code> not permitted). @param widthRatio  the maximum label width as a percentage (of the  category space or the range space). ",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "CategoryLabelPosition.CategoryLabelPosition",
    "class_name": "org.jfree.chart.axis.CategoryLabelPosition",
    "signature": "org.jfree.chart.axis.CategoryLabelPosition.CategoryLabelPosition(RectangleAnchor,TextBlockAnchor,TextAnchor,double,CategoryLabelWidthType,float)",
    "snippet": "    public CategoryLabelPosition(RectangleAnchor categoryAnchor, \n                                 TextBlockAnchor labelAnchor,\n                                 TextAnchor rotationAnchor,\n                                 double angle,\n                                 CategoryLabelWidthType widthType,\n                                 float widthRatio) {\n        \n        if (categoryAnchor == null) {\n            throw new IllegalArgumentException(\n                    \"Null 'categoryAnchor' argument.\");\n        }\n        if (labelAnchor == null) {\n            throw new IllegalArgumentException(\n                    \"Null 'labelAnchor' argument.\");\n        }\n        if (rotationAnchor == null) {\n            throw new IllegalArgumentException(\n                    \"Null 'rotationAnchor' argument.\");\n        }\n        if (widthType == null) {\n            throw new IllegalArgumentException(\"Null 'widthType' argument.\");   \n        }\n        \n        this.categoryAnchor = categoryAnchor;\n        this.labelAnchor = labelAnchor;\n        this.rotationAnchor = rotationAnchor;\n        this.angle = angle;\n        this.widthType = widthType;\n        this.widthRatio = widthRatio;\n    \n    }",
    "comment": " Creates a new position record.  The item label anchor is a point  relative to the data item (dot, bar or other visual item) on a chart.   The item label is aligned by aligning the text anchor with the item  label anchor.  @param categoryAnchor  the category anchor (<code>null</code> not  permitted). @param labelAnchor  the label anchor (<code>null</code> not permitted). @param rotationAnchor  the rotation anchor (<code>null</code> not  permitted). @param angle  the rotation angle (<code>null</code> not permitted). @param widthType  the width type (<code>null</code> not permitted). @param widthRatio  the maximum label width as a percentage (of the  category space or the range space). ",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "CategoryLabelPosition.getAngle",
    "class_name": "org.jfree.chart.axis.CategoryLabelPosition",
    "signature": "org.jfree.chart.axis.CategoryLabelPosition.getAngle()",
    "snippet": "    public double getAngle() {\n        return this.angle;\n    }",
    "comment": " Returns the angle of rotation for the label.  @return The angle (in radians). ",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "CategoryLabelPosition.getCategoryAnchor",
    "class_name": "org.jfree.chart.axis.CategoryLabelPosition",
    "signature": "org.jfree.chart.axis.CategoryLabelPosition.getCategoryAnchor()",
    "snippet": "    public RectangleAnchor getCategoryAnchor() {\n        return this.categoryAnchor;\n    }",
    "comment": " Returns the item label anchor.  @return The item label anchor (never <code>null</code>). ",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "CategoryLabelPosition.getLabelAnchor",
    "class_name": "org.jfree.chart.axis.CategoryLabelPosition",
    "signature": "org.jfree.chart.axis.CategoryLabelPosition.getLabelAnchor()",
    "snippet": "    public TextBlockAnchor getLabelAnchor() {\n        return this.labelAnchor;\n    }",
    "comment": " Returns the text block anchor.  @return The text block anchor (never <code>null</code>). ",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "CategoryLabelPosition.getRotationAnchor",
    "class_name": "org.jfree.chart.axis.CategoryLabelPosition",
    "signature": "org.jfree.chart.axis.CategoryLabelPosition.getRotationAnchor()",
    "snippet": "    public TextAnchor getRotationAnchor() {\n        return this.rotationAnchor;\n    }",
    "comment": " Returns the rotation anchor point.  @return The rotation anchor point (never <code>null</code>). ",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "CategoryLabelPosition.getWidthRatio",
    "class_name": "org.jfree.chart.axis.CategoryLabelPosition",
    "signature": "org.jfree.chart.axis.CategoryLabelPosition.getWidthRatio()",
    "snippet": "    public float getWidthRatio() {\n        return this.widthRatio;   \n    }",
    "comment": " Returns the ratio used to calculate the maximum category label width.  @return The ratio. ",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "CategoryLabelPosition.getWidthType",
    "class_name": "org.jfree.chart.axis.CategoryLabelPosition",
    "signature": "org.jfree.chart.axis.CategoryLabelPosition.getWidthType()",
    "snippet": "    public CategoryLabelWidthType getWidthType() {\n        return this.widthType;   \n    }",
    "comment": " Returns the width calculation type.  @return The width calculation type (never <code>null</code>). ",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "CategoryLabelPositions.CategoryLabelPositions",
    "class_name": "org.jfree.chart.axis.CategoryLabelPositions",
    "signature": "org.jfree.chart.axis.CategoryLabelPositions.CategoryLabelPositions(CategoryLabelPosition,CategoryLabelPosition,CategoryLabelPosition,CategoryLabelPosition)",
    "snippet": "    public CategoryLabelPositions(CategoryLabelPosition top,\n                                  CategoryLabelPosition bottom,\n                                  CategoryLabelPosition left,\n                                  CategoryLabelPosition right) {\n        \n        if (top == null) {\n            throw new IllegalArgumentException(\"Null 'top' argument.\");\n        }\n        if (bottom == null) {\n            throw new IllegalArgumentException(\"Null 'bottom' argument.\");\n        }\n        if (left == null) {\n            throw new IllegalArgumentException(\"Null 'left' argument.\");\n        }\n        if (right == null) {\n            throw new IllegalArgumentException(\"Null 'right' argument.\");\n        }\n        \n        this.positionForAxisAtTop = top;\n        this.positionForAxisAtBottom = bottom;\n        this.positionForAxisAtLeft = left;\n        this.positionForAxisAtRight = right;\n    \n    }",
    "comment": " Creates a new position specification.  @param top  the label position info used when an axis is at the top  (<code>null</code> not permitted). @param bottom  the label position info used when an axis is at the  bottom (<code>null</code> not permitted). @param left  the label position info used when an axis is at the left  (<code>null</code> not permitted). @param right  the label position info used when an axis is at the right  (<code>null</code> not permitted). ",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "CategoryLabelPositions.createDownRotationLabelPositions",
    "class_name": "org.jfree.chart.axis.CategoryLabelPositions",
    "signature": "org.jfree.chart.axis.CategoryLabelPositions.createDownRotationLabelPositions(double)",
    "snippet": "    public static CategoryLabelPositions createDownRotationLabelPositions(\n            double angle) {\n        return new CategoryLabelPositions(\n            new CategoryLabelPosition(\n                RectangleAnchor.BOTTOM, TextBlockAnchor.BOTTOM_RIGHT, \n                TextAnchor.BOTTOM_RIGHT, angle,\n                CategoryLabelWidthType.RANGE, 0.50f\n            ), // TOP\n            new CategoryLabelPosition(\n                RectangleAnchor.TOP, TextBlockAnchor.TOP_LEFT, \n                TextAnchor.TOP_LEFT, angle,\n                CategoryLabelWidthType.RANGE, 0.50f\n            ), // BOTTOM\n            new CategoryLabelPosition(\n                RectangleAnchor.RIGHT, TextBlockAnchor.TOP_RIGHT, \n                TextAnchor.TOP_RIGHT, angle,\n                CategoryLabelWidthType.RANGE, 0.50f\n            ), // LEFT\n            new CategoryLabelPosition(\n                RectangleAnchor.LEFT, TextBlockAnchor.BOTTOM_LEFT, \n                TextAnchor.BOTTOM_LEFT, angle,\n                CategoryLabelWidthType.RANGE, 0.50f\n            ) // RIGHT\n        );\n    }",
    "comment": " Creates a new instance where the category labels angled downwards by the specified amount.  @param angle  the rotation angle (should be < Math.PI / 2.0).  @return A category label position specification. ",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "CategoryLabelPositions.createUpRotationLabelPositions",
    "class_name": "org.jfree.chart.axis.CategoryLabelPositions",
    "signature": "org.jfree.chart.axis.CategoryLabelPositions.createUpRotationLabelPositions(double)",
    "snippet": "    public static CategoryLabelPositions createUpRotationLabelPositions(\n            double angle) {\n        return new CategoryLabelPositions(\n            new CategoryLabelPosition(\n                RectangleAnchor.BOTTOM, TextBlockAnchor.BOTTOM_LEFT, \n                TextAnchor.BOTTOM_LEFT, -angle,\n                CategoryLabelWidthType.RANGE, 0.50f\n            ), // TOP\n            new CategoryLabelPosition(\n                RectangleAnchor.TOP, TextBlockAnchor.TOP_RIGHT, \n                TextAnchor.TOP_RIGHT, -angle,\n                CategoryLabelWidthType.RANGE, 0.50f\n            ), // BOTTOM\n            new CategoryLabelPosition(\n                RectangleAnchor.RIGHT, TextBlockAnchor.BOTTOM_RIGHT, \n                TextAnchor.BOTTOM_RIGHT, -angle,\n                CategoryLabelWidthType.RANGE, 0.50f\n            ), // LEFT\n            new CategoryLabelPosition(\n                RectangleAnchor.LEFT, TextBlockAnchor.TOP_LEFT, \n                TextAnchor.TOP_LEFT, -angle,\n                CategoryLabelWidthType.RANGE, 0.50f\n            ) // RIGHT\n        );\n    }",
    "comment": " Creates a new instance where the category labels angled upwards by the  specified amount.  @param angle  the rotation angle (should be < Math.PI / 2.0).  @return A category label position specification. ",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "CategoryLabelPositions.getLabelPosition",
    "class_name": "org.jfree.chart.axis.CategoryLabelPositions",
    "signature": "org.jfree.chart.axis.CategoryLabelPositions.getLabelPosition(RectangleEdge)",
    "snippet": "    public CategoryLabelPosition getLabelPosition(RectangleEdge edge) {\n        CategoryLabelPosition result = null;\n        if (edge == RectangleEdge.TOP) {\n            result = this.positionForAxisAtTop;\n        }\n        else if (edge == RectangleEdge.BOTTOM) {\n            result = this.positionForAxisAtBottom;\n        }\n        else if (edge == RectangleEdge.LEFT) {\n            result = this.positionForAxisAtLeft;\n        }\n        else if (edge == RectangleEdge.RIGHT) {\n            result = this.positionForAxisAtRight;\n        }\n        return result;\n    }",
    "comment": " Returns the category label position specification for an axis at the  given location.  @param edge  the axis location.  @return The category label position specification. ",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "CategoryTick.CategoryTick",
    "class_name": "org.jfree.chart.axis.CategoryTick",
    "signature": "org.jfree.chart.axis.CategoryTick.CategoryTick(Comparable,TextBlock,TextBlockAnchor,TextAnchor,double)",
    "snippet": "    public CategoryTick(Comparable category,\n                        TextBlock label,\n                        TextBlockAnchor labelAnchor,\n                        TextAnchor rotationAnchor,\n                        double angle) {\n                            \n        super(\"\", TextAnchor.CENTER, rotationAnchor, angle);\n        this.category = category;\n        this.label = label;\n        this.labelAnchor = labelAnchor;\n        \n    }",
    "comment": " Creates a new tick.  @param category  the category. @param label  the label. @param labelAnchor  the label anchor. @param rotationAnchor  the rotation anchor. @param angle  the rotation angle (in radians). ",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "CategoryTick.getCategory",
    "class_name": "org.jfree.chart.axis.CategoryTick",
    "signature": "org.jfree.chart.axis.CategoryTick.getCategory()",
    "snippet": "    public Comparable getCategory() {\n        return this.category;\n    }",
    "comment": " Returns the category.  @return The category. ",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "CategoryTick.getLabel",
    "class_name": "org.jfree.chart.axis.CategoryTick",
    "signature": "org.jfree.chart.axis.CategoryTick.getLabel()",
    "snippet": "    public TextBlock getLabel() {\n        return this.label;\n    }",
    "comment": " Returns the label.  @return The label. ",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "NumberAxis.NumberAxis",
    "class_name": "org.jfree.chart.axis.NumberAxis",
    "signature": "org.jfree.chart.axis.NumberAxis.NumberAxis(String)",
    "snippet": "    public NumberAxis(String label) {\n        super(label, NumberAxis.createStandardTickUnits());\n        this.rangeType = RangeType.FULL;\n        this.autoRangeIncludesZero = DEFAULT_AUTO_RANGE_INCLUDES_ZERO;\n        this.autoRangeStickyZero = DEFAULT_AUTO_RANGE_STICKY_ZERO;\n        this.tickUnit = DEFAULT_TICK_UNIT;\n        this.numberFormatOverride = null;\n        this.markerBand = null;\n    }",
    "comment": " Constructs a number axis, using default values where necessary.  @param label  the axis label (<code>null</code> permitted). ",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "NumberAxis.autoAdjustRange",
    "class_name": "org.jfree.chart.axis.NumberAxis",
    "signature": "org.jfree.chart.axis.NumberAxis.autoAdjustRange()",
    "snippet": "    protected void autoAdjustRange() {\n\n        Plot plot = getPlot();\n        if (plot == null) {\n            return;  // no plot, no data\n        }\n\n        if (plot instanceof ValueAxisPlot) {\n            ValueAxisPlot vap = (ValueAxisPlot) plot;\n\n            Range r = vap.getDataRange(this);\n            if (r == null) {\n                r = getDefaultAutoRange();\n            }\n            \n            double upper = r.getUpperBound();\n            double lower = r.getLowerBound();\n            if (this.rangeType == RangeType.POSITIVE) {\n                lower = Math.max(0.0, lower);\n                upper = Math.max(0.0, upper);\n            }\n            else if (this.rangeType == RangeType.NEGATIVE) {\n                lower = Math.min(0.0, lower);\n                upper = Math.min(0.0, upper);                   \n            }\n            \n            if (getAutoRangeIncludesZero()) {\n                lower = Math.min(lower, 0.0);\n                upper = Math.max(upper, 0.0);\n            }\n            double range = upper - lower;\n\n            // if fixed auto range, then derive lower bound...\n            double fixedAutoRange = getFixedAutoRange();\n            if (fixedAutoRange > 0.0) {\n                lower = upper - fixedAutoRange;\n            }\n            else {\n                // ensure the autorange is at least <minRange> in size...\n                double minRange = getAutoRangeMinimumSize();\n                if (range < minRange) {\n                    double expand = (minRange - range) / 2;\n                    upper = upper + expand;\n                    lower = lower - expand;\n                    if (lower == upper) { // see bug report 1549218\n                        double adjust = Math.abs(lower) / 10.0;\n                        lower = lower - adjust;\n                        upper = upper + adjust;\n                    }\n                    if (this.rangeType == RangeType.POSITIVE) {\n                        if (lower < 0.0) {\n                            upper = upper - lower;\n                            lower = 0.0;\n                        }\n                    }\n                    else if (this.rangeType == RangeType.NEGATIVE) {\n                        if (upper > 0.0) {\n                            lower = lower - upper;\n                            upper = 0.0;\n                        }\n                    }\n                }\n\n                if (getAutoRangeStickyZero()) {\n                    if (upper <= 0.0) {\n                        upper = Math.min(0.0, upper + getUpperMargin() * range);\n                    }\n                    else {\n                        upper = upper + getUpperMargin() * range;\n                    }\n                    if (lower >= 0.0) {\n                        lower = Math.max(0.0, lower - getLowerMargin() * range);\n                    }\n                    else {\n                        lower = lower - getLowerMargin() * range;\n                    }\n                }\n                else {\n                    upper = upper + getUpperMargin() * range;\n                    lower = lower - getLowerMargin() * range;\n                }\n            }\n\n            setRange(new Range(lower, upper), false, false);\n        }\n\n    }",
    "comment": " Rescales the axis to ensure that all data is visible. ",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "NumberAxis.calculateLowestVisibleTickValue",
    "class_name": "org.jfree.chart.axis.NumberAxis",
    "signature": "org.jfree.chart.axis.NumberAxis.calculateLowestVisibleTickValue()",
    "snippet": "    protected double calculateLowestVisibleTickValue() {\n\n        double unit = getTickUnit().getSize();\n        double index = Math.ceil(getRange().getLowerBound() / unit);\n        return index * unit;\n\n    }",
    "comment": " Calculates the value of the lowest visible tick on the axis.  @return The value of the lowest visible tick on the axis.  @see #calculateHighestVisibleTickValue() ",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "NumberAxis.calculateVisibleTickCount",
    "class_name": "org.jfree.chart.axis.NumberAxis",
    "signature": "org.jfree.chart.axis.NumberAxis.calculateVisibleTickCount()",
    "snippet": "    protected int calculateVisibleTickCount() {\n\n        double unit = getTickUnit().getSize();\n        Range range = getRange();\n        return (int) (Math.floor(range.getUpperBound() / unit)\n                      - Math.ceil(range.getLowerBound() / unit) + 1);\n\n    }",
    "comment": " Calculates the number of visible ticks.  @return The number of visible ticks on the axis. ",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "NumberAxis.configure",
    "class_name": "org.jfree.chart.axis.NumberAxis",
    "signature": "org.jfree.chart.axis.NumberAxis.configure()",
    "snippet": "    public void configure() {\n        if (isAutoRange()) {\n            autoAdjustRange();\n        }\n    }",
    "comment": " Configures the axis to work with the specified plot.  If the axis has auto-scaling, then sets the maximum and minimum values. ",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "NumberAxis.createStandardTickUnits",
    "class_name": "org.jfree.chart.axis.NumberAxis",
    "signature": "org.jfree.chart.axis.NumberAxis.createStandardTickUnits()",
    "snippet": "    public static TickUnitSource createStandardTickUnits() {\n\n        TickUnits units = new TickUnits();\n        DecimalFormat df0 = new DecimalFormat(\"0.00000000\");\n        DecimalFormat df1 = new DecimalFormat(\"0.0000000\");\n        DecimalFormat df2 = new DecimalFormat(\"0.000000\");\n        DecimalFormat df3 = new DecimalFormat(\"0.00000\");\n        DecimalFormat df4 = new DecimalFormat(\"0.0000\");\n        DecimalFormat df5 = new DecimalFormat(\"0.000\");\n        DecimalFormat df6 = new DecimalFormat(\"0.00\");\n        DecimalFormat df7 = new DecimalFormat(\"0.0\");\n        DecimalFormat df8 = new DecimalFormat(\"#,##0\");\n        DecimalFormat df9 = new DecimalFormat(\"#,###,##0\");\n        DecimalFormat df10 = new DecimalFormat(\"#,###,###,##0\");\n        \n        // we can add the units in any order, the TickUnits collection will \n        // sort them...\n        units.add(new NumberTickUnit(0.0000001, df1));\n        units.add(new NumberTickUnit(0.000001, df2));\n        units.add(new NumberTickUnit(0.00001, df3));\n        units.add(new NumberTickUnit(0.0001, df4));\n        units.add(new NumberTickUnit(0.001, df5));\n        units.add(new NumberTickUnit(0.01, df6));\n        units.add(new NumberTickUnit(0.1, df7));\n        units.add(new NumberTickUnit(1, df8));\n        units.add(new NumberTickUnit(10, df8));\n        units.add(new NumberTickUnit(100, df8));\n        units.add(new NumberTickUnit(1000, df8));\n        units.add(new NumberTickUnit(10000, df8));\n        units.add(new NumberTickUnit(100000, df8));\n        units.add(new NumberTickUnit(1000000, df9));\n        units.add(new NumberTickUnit(10000000, df9));\n        units.add(new NumberTickUnit(100000000, df9));\n        units.add(new NumberTickUnit(1000000000, df10));\n        units.add(new NumberTickUnit(10000000000.0, df10));\n        units.add(new NumberTickUnit(100000000000.0, df10));\n        \n        units.add(new NumberTickUnit(0.00000025, df0));\n        units.add(new NumberTickUnit(0.0000025, df1));\n        units.add(new NumberTickUnit(0.000025, df2));\n        units.add(new NumberTickUnit(0.00025, df3));\n        units.add(new NumberTickUnit(0.0025, df4));\n        units.add(new NumberTickUnit(0.025, df5));\n        units.add(new NumberTickUnit(0.25, df6));\n        units.add(new NumberTickUnit(2.5, df7));\n        units.add(new NumberTickUnit(25, df8));\n        units.add(new NumberTickUnit(250, df8));\n        units.add(new NumberTickUnit(2500, df8));\n        units.add(new NumberTickUnit(25000, df8));\n        units.add(new NumberTickUnit(250000, df8));\n        units.add(new NumberTickUnit(2500000, df9));\n        units.add(new NumberTickUnit(25000000, df9));\n        units.add(new NumberTickUnit(250000000, df9));\n        units.add(new NumberTickUnit(2500000000.0, df10));\n        units.add(new NumberTickUnit(25000000000.0, df10));\n        units.add(new NumberTickUnit(250000000000.0, df10));\n\n        units.add(new NumberTickUnit(0.0000005, df1));\n        units.add(new NumberTickUnit(0.000005, df2));\n        units.add(new NumberTickUnit(0.00005, df3));\n        units.add(new NumberTickUnit(0.0005, df4));\n        units.add(new NumberTickUnit(0.005, df5));\n        units.add(new NumberTickUnit(0.05, df6));\n        units.add(new NumberTickUnit(0.5, df7));\n        units.add(new NumberTickUnit(5L, df8));\n        units.add(new NumberTickUnit(50L, df8));\n        units.add(new NumberTickUnit(500L, df8));\n        units.add(new NumberTickUnit(5000L, df8));\n        units.add(new NumberTickUnit(50000L, df8));\n        units.add(new NumberTickUnit(500000L, df8));\n        units.add(new NumberTickUnit(5000000L, df9));\n        units.add(new NumberTickUnit(50000000L, df9));\n        units.add(new NumberTickUnit(500000000L, df9));\n        units.add(new NumberTickUnit(5000000000L, df10));\n        units.add(new NumberTickUnit(50000000000L, df10));\n        units.add(new NumberTickUnit(500000000000L, df10));\n\n        return units;\n\n    }",
    "comment": " Creates the standard tick units. <P> If you don't like these defaults, create your own instance of TickUnits and then pass it to the setStandardTickUnits() method in the NumberAxis class.  @return The standard tick units.  @see #setStandardTickUnits(TickUnitSource) @see #createIntegerTickUnits() ",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "NumberAxis.draw",
    "class_name": "org.jfree.chart.axis.NumberAxis",
    "signature": "org.jfree.chart.axis.NumberAxis.draw(Graphics2D,double,Rectangle2D,Rectangle2D,RectangleEdge,PlotRenderingInfo)",
    "snippet": "    public AxisState draw(Graphics2D g2, \n                          double cursor,\n                          Rectangle2D plotArea, \n                          Rectangle2D dataArea, \n                          RectangleEdge edge,\n                          PlotRenderingInfo plotState) {\n\n        AxisState state = null;\n        // if the axis is not visible, don't draw it...\n        if (!isVisible()) {\n            state = new AxisState(cursor);\n            // even though the axis is not visible, we need ticks for the \n            // gridlines...\n            List ticks = refreshTicks(g2, state, dataArea, edge); \n            state.setTicks(ticks);\n            return state;\n        }\n\n        // draw the tick marks and labels...\n        state = drawTickMarksAndLabels(g2, cursor, plotArea, dataArea, edge,\n                plotState);\n\n//        // draw the marker band (if there is one)...\n//        if (getMarkerBand() != null) {\n//            if (edge == RectangleEdge.BOTTOM) {\n//                cursor = cursor - getMarkerBand().getHeight(g2);\n//            }\n//            getMarkerBand().draw(g2, plotArea, dataArea, 0, cursor);\n//        }\n        \n        // draw the axis label...\n        state = drawLabel(getLabel(), g2, plotArea, dataArea, edge, state,\n                plotState);\n\n        return state;\n        \n    }",
    "comment": " Draws the axis on a Java 2D graphics device (such as the screen or a  printer).  @param g2  the graphics device (<code>null</code> not permitted). @param cursor  the cursor location. @param plotArea  the area within which the axes and data should be drawn (<code>null</code> not permitted). @param dataArea  the area within which the data should be drawn  (<code>null</code> not permitted). @param edge  the location of the axis (<code>null</code> not permitted). @param plotState  collects information about the plot  (<code>null</code> permitted).  @return The axis state (never <code>null</code>). ",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "NumberAxis.estimateMaximumTickLabelHeight",
    "class_name": "org.jfree.chart.axis.NumberAxis",
    "signature": "org.jfree.chart.axis.NumberAxis.estimateMaximumTickLabelHeight(Graphics2D)",
    "snippet": "    protected double estimateMaximumTickLabelHeight(Graphics2D g2) {\n\n        RectangleInsets tickLabelInsets = getTickLabelInsets();\n        double result = tickLabelInsets.getTop() + tickLabelInsets.getBottom();\n        \n        Font tickLabelFont = getTickLabelFont();\n        FontRenderContext frc = g2.getFontRenderContext();\n        result += tickLabelFont.getLineMetrics(\"123\", frc).getHeight();\n        return result;\n        \n    }",
    "comment": " Estimates the maximum tick label height.  @param g2  the graphics device.  @return The maximum height. ",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "NumberAxis.estimateMaximumTickLabelWidth",
    "class_name": "org.jfree.chart.axis.NumberAxis",
    "signature": "org.jfree.chart.axis.NumberAxis.estimateMaximumTickLabelWidth(Graphics2D,TickUnit)",
    "snippet": "    protected double estimateMaximumTickLabelWidth(Graphics2D g2, \n                                                   TickUnit unit) {\n\n        RectangleInsets tickLabelInsets = getTickLabelInsets();\n        double result = tickLabelInsets.getLeft() + tickLabelInsets.getRight();\n\n        if (isVerticalTickLabels()) {\n            // all tick labels have the same width (equal to the height of the \n            // font)...\n            FontRenderContext frc = g2.getFontRenderContext();\n            LineMetrics lm = getTickLabelFont().getLineMetrics(\"0\", frc);\n            result += lm.getHeight();\n        }\n        else {\n            // look at lower and upper bounds...\n            FontMetrics fm = g2.getFontMetrics(getTickLabelFont());\n            Range range = getRange();\n            double lower = range.getLowerBound();\n            double upper = range.getUpperBound();\n            String lowerStr = \"\";\n            String upperStr = \"\";\n            NumberFormat formatter = getNumberFormatOverride();\n            if (formatter != null) {\n                lowerStr = formatter.format(lower);\n                upperStr = formatter.format(upper);\n            }\n            else {\n                lowerStr = unit.valueToString(lower);\n                upperStr = unit.valueToString(upper);                \n            }\n            double w1 = fm.stringWidth(lowerStr);\n            double w2 = fm.stringWidth(upperStr);\n            result += Math.max(w1, w2);\n        }\n\n        return result;\n\n    }",
    "comment": " Estimates the maximum width of the tick labels, assuming the specified  tick unit is used. <P> Rather than computing the string bounds of every tick on the axis, we  just look at two values: the lower bound and the upper bound for the  axis.  These two values will usually be representative.  @param g2  the graphics device. @param unit  the tick unit to use for calculation.  @return The estimated maximum width of the tick labels. ",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "NumberAxis.getAutoRangeIncludesZero",
    "class_name": "org.jfree.chart.axis.NumberAxis",
    "signature": "org.jfree.chart.axis.NumberAxis.getAutoRangeIncludesZero()",
    "snippet": "    public boolean getAutoRangeIncludesZero() {\n        return this.autoRangeIncludesZero;\n    }",
    "comment": " Returns the flag that indicates whether or not the automatic axis range (if indeed it is determined automatically) is forced to include zero.  @return The flag. ",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "NumberAxis.getAutoRangeStickyZero",
    "class_name": "org.jfree.chart.axis.NumberAxis",
    "signature": "org.jfree.chart.axis.NumberAxis.getAutoRangeStickyZero()",
    "snippet": "    public boolean getAutoRangeStickyZero() {\n        return this.autoRangeStickyZero;\n    }",
    "comment": " Returns a flag that affects the auto-range when zero falls outside the data range but inside the margins defined for the axis.  @return The flag.  @see #setAutoRangeStickyZero(boolean) ",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "NumberAxis.getNumberFormatOverride",
    "class_name": "org.jfree.chart.axis.NumberAxis",
    "signature": "org.jfree.chart.axis.NumberAxis.getNumberFormatOverride()",
    "snippet": "    public NumberFormat getNumberFormatOverride() {\n        return this.numberFormatOverride;\n    }",
    "comment": " Returns the number format override.  If this is non-null, then it will  be used to format the numbers on the axis.  @return The number formatter (possibly <code>null</code>).  @see #setNumberFormatOverride(NumberFormat) ",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "NumberAxis.getTickUnit",
    "class_name": "org.jfree.chart.axis.NumberAxis",
    "signature": "org.jfree.chart.axis.NumberAxis.getTickUnit()",
    "snippet": "    public NumberTickUnit getTickUnit() {\n        return this.tickUnit;\n    }",
    "comment": " Returns the tick unit for the axis.   <p> Note: if the <code>autoTickUnitSelection</code> flag is  <code>true</code> the tick unit may be changed while the axis is being  drawn, so in that case the return value from this method may be irrelevant if the method is called before the axis has been drawn.  @return The tick unit for the axis.  @see #setTickUnit(NumberTickUnit) @see ValueAxis#isAutoTickUnitSelection() ",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "NumberAxis.hashCode",
    "class_name": "org.jfree.chart.axis.NumberAxis",
    "signature": "org.jfree.chart.axis.NumberAxis.hashCode()",
    "snippet": "    public int hashCode() {\n        if (getLabel() != null) {\n            return getLabel().hashCode();\n        }\n        else {\n            return 0;\n        }\n    }",
    "comment": " Returns a hash code for this object.  @return A hash code. ",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "NumberAxis.refreshTicks",
    "class_name": "org.jfree.chart.axis.NumberAxis",
    "signature": "org.jfree.chart.axis.NumberAxis.refreshTicks(Graphics2D,AxisState,Rectangle2D,RectangleEdge)",
    "snippet": "    public List refreshTicks(Graphics2D g2, \n                             AxisState state,\n                             Rectangle2D dataArea,\n                             RectangleEdge edge) {\n\n        List result = new java.util.ArrayList();\n        if (RectangleEdge.isTopOrBottom(edge)) {\n            result = refreshTicksHorizontal(g2, dataArea, edge);\n        }\n        else if (RectangleEdge.isLeftOrRight(edge)) {\n            result = refreshTicksVertical(g2, dataArea, edge);\n        }\n        return result;\n\n    }",
    "comment": " Calculates the positions of the tick labels for the axis, storing the  results in the tick label list (ready for drawing).  @param g2  the graphics device. @param state  the axis state. @param dataArea  the area in which the plot should be drawn. @param edge  the location of the axis.  @return A list of ticks.  ",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "NumberAxis.refreshTicksHorizontal",
    "class_name": "org.jfree.chart.axis.NumberAxis",
    "signature": "org.jfree.chart.axis.NumberAxis.refreshTicksHorizontal(Graphics2D,Rectangle2D,RectangleEdge)",
    "snippet": "    protected List refreshTicksHorizontal(Graphics2D g2,\n                                          Rectangle2D dataArea,\n                                          RectangleEdge edge) {\n\n        List result = new java.util.ArrayList();\n\n        Font tickLabelFont = getTickLabelFont();\n        g2.setFont(tickLabelFont);\n        \n        if (isAutoTickUnitSelection()) {\n            selectAutoTickUnit(g2, dataArea, edge);\n        }\n\n        double size = getTickUnit().getSize();\n        int count = calculateVisibleTickCount();\n        double lowestTickValue = calculateLowestVisibleTickValue();\n\n        if (count <= ValueAxis.MAXIMUM_TICK_COUNT) {\n            for (int i = 0; i < count; i++) {\n                double currentTickValue = lowestTickValue + (i * size);\n                String tickLabel;\n                NumberFormat formatter = getNumberFormatOverride();\n                if (formatter != null) {\n                    tickLabel = formatter.format(currentTickValue);\n                }\n                else {\n                    tickLabel = getTickUnit().valueToString(currentTickValue);\n                }\n                TextAnchor anchor = null;\n                TextAnchor rotationAnchor = null;\n                double angle = 0.0;\n                if (isVerticalTickLabels()) {\n                    anchor = TextAnchor.CENTER_RIGHT;\n                    rotationAnchor = TextAnchor.CENTER_RIGHT;\n                    if (edge == RectangleEdge.TOP) {\n                        angle = Math.PI / 2.0;\n                    }\n                    else {\n                        angle = -Math.PI / 2.0;\n                    }\n                }\n                else {\n                    if (edge == RectangleEdge.TOP) {\n                        anchor = TextAnchor.BOTTOM_CENTER;\n                        rotationAnchor = TextAnchor.BOTTOM_CENTER;\n                    }\n                    else {\n                        anchor = TextAnchor.TOP_CENTER;\n                        rotationAnchor = TextAnchor.TOP_CENTER;\n                    }\n                }\n\n                Tick tick = new NumberTick(new Double(currentTickValue), \n                        tickLabel, anchor, rotationAnchor, angle);\n                result.add(tick);\n            }\n        }\n        return result;\n\n    }",
    "comment": " Calculates the positions of the tick labels for the axis, storing the  results in the tick label list (ready for drawing).  @param g2  the graphics device. @param dataArea  the area in which the data should be drawn. @param edge  the location of the axis.  @return A list of ticks. ",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "NumberAxis.refreshTicksVertical",
    "class_name": "org.jfree.chart.axis.NumberAxis",
    "signature": "org.jfree.chart.axis.NumberAxis.refreshTicksVertical(Graphics2D,Rectangle2D,RectangleEdge)",
    "snippet": "    protected List refreshTicksVertical(Graphics2D g2,\n                                        Rectangle2D dataArea,\n                                        RectangleEdge edge) {\n\n        List result = new java.util.ArrayList();\n        result.clear();\n\n        Font tickLabelFont = getTickLabelFont();\n        g2.setFont(tickLabelFont);\n        if (isAutoTickUnitSelection()) {\n            selectAutoTickUnit(g2, dataArea, edge);\n        }\n\n        double size = getTickUnit().getSize();\n        int count = calculateVisibleTickCount();\n        double lowestTickValue = calculateLowestVisibleTickValue();\n\n        if (count <= ValueAxis.MAXIMUM_TICK_COUNT) {\n            for (int i = 0; i < count; i++) {\n                double currentTickValue = lowestTickValue + (i * size);\n                String tickLabel;\n                NumberFormat formatter = getNumberFormatOverride();\n                if (formatter != null) {\n                    tickLabel = formatter.format(currentTickValue);\n                }\n                else {\n                    tickLabel = getTickUnit().valueToString(currentTickValue);\n                }\n\n                TextAnchor anchor = null;\n                TextAnchor rotationAnchor = null;\n                double angle = 0.0;\n                if (isVerticalTickLabels()) {\n                    if (edge == RectangleEdge.LEFT) { \n                        anchor = TextAnchor.BOTTOM_CENTER;\n                        rotationAnchor = TextAnchor.BOTTOM_CENTER;\n                        angle = -Math.PI / 2.0;\n                    }\n                    else {\n                        anchor = TextAnchor.BOTTOM_CENTER;\n                        rotationAnchor = TextAnchor.BOTTOM_CENTER;\n                        angle = Math.PI / 2.0;\n                    }\n                }\n                else {\n                    if (edge == RectangleEdge.LEFT) {\n                        anchor = TextAnchor.CENTER_RIGHT;\n                        rotationAnchor = TextAnchor.CENTER_RIGHT;\n                    }\n                    else {\n                        anchor = TextAnchor.CENTER_LEFT;\n                        rotationAnchor = TextAnchor.CENTER_LEFT;\n                    }\n                }\n\n                Tick tick = new NumberTick(\n                    new Double(currentTickValue), tickLabel, anchor, \n                    rotationAnchor, angle\n                );\n                result.add(tick);\n            }\n        }\n        return result;\n\n    }",
    "comment": " Calculates the positions of the tick labels for the axis, storing the  results in the tick label list (ready for drawing).  @param g2  the graphics device. @param dataArea  the area in which the plot should be drawn. @param edge  the location of the axis.  @return A list of ticks.  ",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "NumberAxis.selectAutoTickUnit",
    "class_name": "org.jfree.chart.axis.NumberAxis",
    "signature": "org.jfree.chart.axis.NumberAxis.selectAutoTickUnit(Graphics2D,Rectangle2D,RectangleEdge)",
    "snippet": "    protected void selectAutoTickUnit(Graphics2D g2,\n                                      Rectangle2D dataArea,\n                                      RectangleEdge edge) {\n\n        if (RectangleEdge.isTopOrBottom(edge)) {\n            selectHorizontalAutoTickUnit(g2, dataArea, edge);\n        }\n        else if (RectangleEdge.isLeftOrRight(edge)) {\n            selectVerticalAutoTickUnit(g2, dataArea, edge);\n        }\n\n    }",
    "comment": " Selects an appropriate tick value for the axis.  The strategy is to display as many ticks as possible (selected from an array of 'standard' tick units) without the labels overlapping.  @param g2  the graphics device. @param dataArea  the area defined by the axes. @param edge  the axis location. ",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "NumberAxis.selectHorizontalAutoTickUnit",
    "class_name": "org.jfree.chart.axis.NumberAxis",
    "signature": "org.jfree.chart.axis.NumberAxis.selectHorizontalAutoTickUnit(Graphics2D,Rectangle2D,RectangleEdge)",
    "snippet": "   protected void selectHorizontalAutoTickUnit(Graphics2D g2,\n                                               Rectangle2D dataArea,\n                                               RectangleEdge edge) {\n\n        double tickLabelWidth = estimateMaximumTickLabelWidth(\n            g2, getTickUnit()\n        );\n\n        // start with the current tick unit...\n        TickUnitSource tickUnits = getStandardTickUnits();\n        TickUnit unit1 = tickUnits.getCeilingTickUnit(getTickUnit());\n        double unit1Width = lengthToJava2D(unit1.getSize(), dataArea, edge);\n\n        // then extrapolate...\n        double guess = (tickLabelWidth / unit1Width) * unit1.getSize();\n\n        NumberTickUnit unit2 \n            = (NumberTickUnit) tickUnits.getCeilingTickUnit(guess);\n        double unit2Width = lengthToJava2D(unit2.getSize(), dataArea, edge);\n\n        tickLabelWidth = estimateMaximumTickLabelWidth(g2, unit2);\n        if (tickLabelWidth > unit2Width) {\n            unit2 = (NumberTickUnit) tickUnits.getLargerTickUnit(unit2);\n        }\n\n        setTickUnit(unit2, false, false);\n\n    }",
    "comment": " Selects an appropriate tick value for the axis.  The strategy is to display as many ticks as possible (selected from an array of 'standard' tick units) without the labels overlapping.  @param g2  the graphics device. @param dataArea  the area defined by the axes. @param edge  the axis location. ",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "NumberAxis.selectVerticalAutoTickUnit",
    "class_name": "org.jfree.chart.axis.NumberAxis",
    "signature": "org.jfree.chart.axis.NumberAxis.selectVerticalAutoTickUnit(Graphics2D,Rectangle2D,RectangleEdge)",
    "snippet": "    protected void selectVerticalAutoTickUnit(Graphics2D g2, \n                                              Rectangle2D dataArea, \n                                              RectangleEdge edge) {\n\n        double tickLabelHeight = estimateMaximumTickLabelHeight(g2);\n\n        // start with the current tick unit...\n        TickUnitSource tickUnits = getStandardTickUnits();\n        TickUnit unit1 = tickUnits.getCeilingTickUnit(getTickUnit());\n        double unitHeight = lengthToJava2D(unit1.getSize(), dataArea, edge);\n\n        // then extrapolate...\n        double guess = (tickLabelHeight / unitHeight) * unit1.getSize();\n        \n        NumberTickUnit unit2 \n            = (NumberTickUnit) tickUnits.getCeilingTickUnit(guess);\n        double unit2Height = lengthToJava2D(unit2.getSize(), dataArea, edge);\n\n        tickLabelHeight = estimateMaximumTickLabelHeight(g2);\n        if (tickLabelHeight > unit2Height) {\n            unit2 = (NumberTickUnit) tickUnits.getLargerTickUnit(unit2);\n        }\n\n        setTickUnit(unit2, false, false);\n\n    }",
    "comment": " Selects an appropriate tick value for the axis.  The strategy is to display as many ticks as possible (selected from an array of 'standard' tick units) without the labels overlapping.  @param g2  the graphics device. @param dataArea  the area in which the plot should be drawn. @param edge  the axis location. ",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "NumberAxis.setTickUnit",
    "class_name": "org.jfree.chart.axis.NumberAxis",
    "signature": "org.jfree.chart.axis.NumberAxis.setTickUnit(NumberTickUnit,boolean,boolean)",
    "snippet": "    public void setTickUnit(NumberTickUnit unit, boolean notify, \n                            boolean turnOffAutoSelect) {\n\n        if (unit == null) {\n            throw new IllegalArgumentException(\"Null 'unit' argument.\");   \n        }\n        this.tickUnit = unit;\n        if (turnOffAutoSelect) {\n            setAutoTickUnitSelection(false, false);\n        }\n        if (notify) {\n            notifyListeners(new AxisChangeEvent(this));\n        }\n\n    }",
    "comment": " Sets the tick unit for the axis and, if requested, sends an  {@link AxisChangeEvent} to all registered listeners.  In addition, an  option is provided to turn off the \"auto-select\" feature for tick units  (you can restore it using the  {@link ValueAxis#setAutoTickUnitSelection(boolean)} method).  @param unit  the new tick unit (<code>null</code> not permitted). @param notify  notify listeners? @param turnOffAutoSelect  turn off the auto-tick selection? ",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "NumberAxis.valueToJava2D",
    "class_name": "org.jfree.chart.axis.NumberAxis",
    "signature": "org.jfree.chart.axis.NumberAxis.valueToJava2D(double,Rectangle2D,RectangleEdge)",
    "snippet": "    public double valueToJava2D(double value, Rectangle2D area, \n                                RectangleEdge edge) {\n        \n        Range range = getRange();\n        double axisMin = range.getLowerBound();\n        double axisMax = range.getUpperBound();\n\n        double min = 0.0;\n        double max = 0.0;\n        if (RectangleEdge.isTopOrBottom(edge)) {\n            min = area.getX();\n            max = area.getMaxX();\n        }\n        else if (RectangleEdge.isLeftOrRight(edge)) {\n            max = area.getMinY();\n            min = area.getMaxY();\n        }\n        if (isInverted()) {\n            return max \n                   - ((value - axisMin) / (axisMax - axisMin)) * (max - min);\n        }\n        else {\n            return min \n                   + ((value - axisMin) / (axisMax - axisMin)) * (max - min);\n        }\n\n    }",
    "comment": " Converts a data value to a coordinate in Java2D space, assuming that the axis runs along one edge of the specified dataArea. <p> Note that it is possible for the coordinate to fall outside the plotArea.  @param value  the data value. @param area  the area for plotting the data. @param edge  the axis location.  @return The Java2D coordinate.  @see #java2DToValue(double, Rectangle2D, RectangleEdge) ",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "NumberTick.NumberTick",
    "class_name": "org.jfree.chart.axis.NumberTick",
    "signature": "org.jfree.chart.axis.NumberTick.NumberTick(Number,String,TextAnchor,TextAnchor,double)",
    "snippet": "    public NumberTick(Number number, String label,\n                      TextAnchor textAnchor, \n                      TextAnchor rotationAnchor, double angle) {\n                        \n        super(number.doubleValue(), label, textAnchor, rotationAnchor, angle);\n        this.number = number;\n            \n    }",
    "comment": " Creates a new tick.  @param number  the number (<code>null</code> not permitted). @param label  the label. @param textAnchor  the part of the label that is aligned with the anchor  point. @param rotationAnchor  defines the rotation point relative to the text. @param angle  the rotation angle (in radians). ",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "NumberTickUnit.NumberTickUnit",
    "class_name": "org.jfree.chart.axis.NumberTickUnit",
    "signature": "org.jfree.chart.axis.NumberTickUnit.NumberTickUnit(double,NumberFormat)",
    "snippet": "    public NumberTickUnit(double size, NumberFormat formatter) {\n        super(size);\n        if (formatter == null) {\n            throw new IllegalArgumentException(\"Null 'formatter' argument.\");\n        }\n        this.formatter = formatter;\n    }",
    "comment": " Creates a new number tick unit.  @param size  the size of the tick unit. @param formatter  a number formatter for the tick unit (<code>null</code> not permitted). ",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "NumberTickUnit.valueToString",
    "class_name": "org.jfree.chart.axis.NumberTickUnit",
    "signature": "org.jfree.chart.axis.NumberTickUnit.valueToString(double)",
    "snippet": "    public String valueToString(double value) {\n        return this.formatter.format(value);\n    }",
    "comment": " Converts a value to a string.  @param value  the value.  @return The formatted string. ",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "Tick.Tick",
    "class_name": "org.jfree.chart.axis.Tick",
    "signature": "org.jfree.chart.axis.Tick.Tick(String,TextAnchor,TextAnchor,double)",
    "snippet": "    public Tick(String text, TextAnchor textAnchor, TextAnchor rotationAnchor, \n                double angle) {\n        if (textAnchor == null) {\n            throw new IllegalArgumentException(\"Null 'textAnchor' argument.\");\n        }\n        if (rotationAnchor == null) {\n            throw new IllegalArgumentException(\n                \"Null 'rotationAnchor' argument.\"\n            );   \n        }\n        this.text = text;\n        this.textAnchor = textAnchor;\n        this.rotationAnchor = rotationAnchor;\n        this.angle = angle;\n    }",
    "comment": " Creates a new tick.  @param text  the formatted version of the tick value. @param textAnchor  the text anchor (<code>null</code> not permitted). @param rotationAnchor  the rotation anchor (<code>null</code> not  permitted). @param angle  the angle.  ",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "Tick.getAngle",
    "class_name": "org.jfree.chart.axis.Tick",
    "signature": "org.jfree.chart.axis.Tick.getAngle()",
    "snippet": "    public double getAngle() {\n        return this.angle;\n    }",
    "comment": " Returns the angle.  @return The angle. ",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "Tick.getRotationAnchor",
    "class_name": "org.jfree.chart.axis.Tick",
    "signature": "org.jfree.chart.axis.Tick.getRotationAnchor()",
    "snippet": "    public TextAnchor getRotationAnchor() {\n        return this.rotationAnchor;\n    }",
    "comment": " Returns the text anchor that defines the point around which the label is rotated.  @return A text anchor (never <code>null</code>). ",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "Tick.getText",
    "class_name": "org.jfree.chart.axis.Tick",
    "signature": "org.jfree.chart.axis.Tick.getText()",
    "snippet": "    public String getText() {\n        return this.text;\n    }",
    "comment": " Returns the text version of the tick value.  @return A string (possibly <code>null</code>; ",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "Tick.getTextAnchor",
    "class_name": "org.jfree.chart.axis.Tick",
    "signature": "org.jfree.chart.axis.Tick.getTextAnchor()",
    "snippet": "    public TextAnchor getTextAnchor() {\n        return this.textAnchor;\n    }",
    "comment": " Returns the text anchor.  @return The text anchor (never <code>null</code>). ",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "TickType.equals",
    "class_name": "org.jfree.chart.axis.TickType",
    "signature": "org.jfree.chart.axis.TickType.equals(Object)",
    "snippet": "    public boolean equals(Object obj) {\n        if (this == obj) {\n            return true;\n        }\n        if (!(obj instanceof TickType)) {\n            return false;\n        }\n\n        TickType that = (TickType) obj;\n        if (!this.name.equals(that.name)) {\n            return false;\n        }\n        return true;\n    }",
    "comment": " Returns <code>true</code> if this object is equal to the specified  object, and <code>false</code> otherwise.  @param obj  the other object.  @return A boolean. ",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "TickUnit.TickUnit",
    "class_name": "org.jfree.chart.axis.TickUnit",
    "signature": "org.jfree.chart.axis.TickUnit.TickUnit(double)",
    "snippet": "    public TickUnit(double size) {\n        this.size = size;\n    }",
    "comment": " Constructs a new tick unit.  @param size  the tick unit size. ",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "TickUnit.compareTo",
    "class_name": "org.jfree.chart.axis.TickUnit",
    "signature": "org.jfree.chart.axis.TickUnit.compareTo(Object)",
    "snippet": "    public int compareTo(Object object) {\n\n        if (object instanceof TickUnit) {\n            TickUnit other = (TickUnit) object;\n            if (this.size > other.getSize()) {\n                return 1;\n            }\n            else if (this.size < other.getSize()) {\n                return -1;\n            }\n            else {\n                return 0;\n            }\n        }\n        else {\n            return -1;\n        }\n\n    }",
    "comment": " Compares this tick unit to an arbitrary object.  @param object  the object to compare against.  @return <code>1</code> if the size of the other object is less than this, <code>0</code> if both have the same size and <code>-1</code> this size is less than the others. ",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "TickUnit.getSize",
    "class_name": "org.jfree.chart.axis.TickUnit",
    "signature": "org.jfree.chart.axis.TickUnit.getSize()",
    "snippet": "    public double getSize() {\n        return this.size;\n    }",
    "comment": " Returns the size of the tick unit.  @return The size of the tick unit. ",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "TickUnits.TickUnits",
    "class_name": "org.jfree.chart.axis.TickUnits",
    "signature": "org.jfree.chart.axis.TickUnits.TickUnits()",
    "snippet": "    public TickUnits() {\n        this.tickUnits = new ArrayList();\n    }",
    "comment": " Constructs a new collection of tick units. ",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "TickUnits.add",
    "class_name": "org.jfree.chart.axis.TickUnits",
    "signature": "org.jfree.chart.axis.TickUnits.add(TickUnit)",
    "snippet": "    public void add(TickUnit unit) {\n        if (unit == null) {\n            throw new NullPointerException(\"Null 'unit' argument.\");\n        }\n        this.tickUnits.add(unit);\n        Collections.sort(this.tickUnits);\n    }",
    "comment": " Adds a tick unit to the collection.  The tick units are maintained in  ascending order.  @param unit  the tick unit to add (<code>null</code> not permitted). ",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "TickUnits.getCeilingTickUnit",
    "class_name": "org.jfree.chart.axis.TickUnits",
    "signature": "org.jfree.chart.axis.TickUnits.getCeilingTickUnit(TickUnit)",
    "snippet": "    public TickUnit getCeilingTickUnit(TickUnit unit) {\n\n        int index = Collections.binarySearch(this.tickUnits, unit);\n        if (index >= 0) {\n            return (TickUnit) this.tickUnits.get(index);\n        }\n        else {\n            index = -(index + 1);\n            return (TickUnit) this.tickUnits.get(Math.min(index, \n                    this.tickUnits.size() - 1));\n        }\n\n    }",
    "comment": " Returns the tick unit in the collection that is greater than or equal to (in size) the specified unit.  @param unit  the unit.  @return A unit from the collection. ",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "TickUnits.getCeilingTickUnit",
    "class_name": "org.jfree.chart.axis.TickUnits",
    "signature": "org.jfree.chart.axis.TickUnits.getCeilingTickUnit(double)",
    "snippet": "    public TickUnit getCeilingTickUnit(double size) {\n        return getCeilingTickUnit(new NumberTickUnit(size, \n                NumberFormat.getInstance()));\n    }",
    "comment": " Returns the tick unit in the collection that is greater than or equal to the specified size.  @param size  the size.  @return A unit from the collection. ",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "TickUnits.getLargerTickUnit",
    "class_name": "org.jfree.chart.axis.TickUnits",
    "signature": "org.jfree.chart.axis.TickUnits.getLargerTickUnit(TickUnit)",
    "snippet": "    public TickUnit getLargerTickUnit(TickUnit unit) {\n\n        int index = Collections.binarySearch(this.tickUnits, unit);\n        if (index >= 0) {\n            index = index + 1;\n        }\n        else {\n            index = -index;\n        }\n\n        return (TickUnit) this.tickUnits.get(Math.min(index, \n                this.tickUnits.size() - 1));\n\n    }",
    "comment": " Returns a tick unit that is larger than the supplied unit.  @param unit   the unit.  @return A tick unit that is larger than the supplied unit. ",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "ValueAxis.ValueAxis",
    "class_name": "org.jfree.chart.axis.ValueAxis",
    "signature": "org.jfree.chart.axis.ValueAxis.ValueAxis(String,TickUnitSource)",
    "snippet": "    protected ValueAxis(String label, TickUnitSource standardTickUnits) {\n\n        super(label);\n\n        this.positiveArrowVisible = false;\n        this.negativeArrowVisible = false;\n\n        this.range = DEFAULT_RANGE;\n        this.autoRange = DEFAULT_AUTO_RANGE;\n        this.defaultAutoRange = DEFAULT_RANGE;\n\n        this.inverted = DEFAULT_INVERTED;\n        this.autoRangeMinimumSize = DEFAULT_AUTO_RANGE_MINIMUM_SIZE;\n\n        this.lowerMargin = DEFAULT_LOWER_MARGIN;\n        this.upperMargin = DEFAULT_UPPER_MARGIN;\n\n        this.fixedAutoRange = 0.0;\n\n        this.autoTickUnitSelection = DEFAULT_AUTO_TICK_UNIT_SELECTION;\n        this.standardTickUnits = standardTickUnits;\n        \n        Polygon p1 = new Polygon();\n        p1.addPoint(0, 0);\n        p1.addPoint(-2, 2);\n        p1.addPoint(2, 2);\n        \n        this.upArrow = p1;\n\n        Polygon p2 = new Polygon();\n        p2.addPoint(0, 0);\n        p2.addPoint(-2, -2);\n        p2.addPoint(2, -2);\n\n        this.downArrow = p2;\n\n        Polygon p3 = new Polygon();\n        p3.addPoint(0, 0);\n        p3.addPoint(-2, -2);\n        p3.addPoint(-2, 2);\n        \n        this.rightArrow = p3;\n\n        Polygon p4 = new Polygon();\n        p4.addPoint(0, 0);\n        p4.addPoint(2, -2);\n        p4.addPoint(2, 2);\n\n        this.leftArrow = p4;\n        \n        this.verticalTickLabels = false;\n        \n    }",
    "comment": " Constructs a value axis.  @param label  the axis label (<code>null</code> permitted). @param standardTickUnits  the source for standard tick units  (<code>null</code> permitted). ",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "ValueAxis.calculateAnchorPoint",
    "class_name": "org.jfree.chart.axis.ValueAxis",
    "signature": "org.jfree.chart.axis.ValueAxis.calculateAnchorPoint(ValueTick,double,Rectangle2D,RectangleEdge)",
    "snippet": "    protected float[] calculateAnchorPoint(ValueTick tick, \n                                           double cursor, \n                                           Rectangle2D dataArea, \n                                           RectangleEdge edge) {\n    \n        RectangleInsets insets = getTickLabelInsets();\n        float[] result = new float[2];\n        if (edge == RectangleEdge.TOP) {\n            result[0] = (float) valueToJava2D(tick.getValue(), dataArea, edge);\n            result[1] = (float) (cursor - insets.getBottom() - 2.0);\n        }\n        else if (edge == RectangleEdge.BOTTOM) {\n            result[0] = (float) valueToJava2D(tick.getValue(), dataArea, edge);\n            result[1] = (float) (cursor + insets.getTop() + 2.0); \n        }\n        else if (edge == RectangleEdge.LEFT) {\n            result[0] = (float) (cursor - insets.getLeft() - 2.0);    \n            result[1] = (float) valueToJava2D(tick.getValue(), dataArea, edge);\n        }\n        else if (edge == RectangleEdge.RIGHT) {\n            result[0] = (float) (cursor + insets.getRight() + 2.0);    \n            result[1] = (float) valueToJava2D(tick.getValue(), dataArea, edge);\n        }\n        return result;\n    }",
    "comment": " Calculates the anchor point for a tick label.  @param tick  the tick. @param cursor  the cursor. @param dataArea  the data area. @param edge  the edge on which the axis is drawn.  @return The x and y coordinates of the anchor point. ",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "ValueAxis.drawAxisLine",
    "class_name": "org.jfree.chart.axis.ValueAxis",
    "signature": "org.jfree.chart.axis.ValueAxis.drawAxisLine(Graphics2D,double,Rectangle2D,RectangleEdge)",
    "snippet": "    protected void drawAxisLine(Graphics2D g2, double cursor,\n                                Rectangle2D dataArea, RectangleEdge edge) {\n        Line2D axisLine = null;\n        if (edge == RectangleEdge.TOP) {\n            axisLine = new Line2D.Double(dataArea.getX(), cursor, \n                    dataArea.getMaxX(), cursor);  \n        }\n        else if (edge == RectangleEdge.BOTTOM) {\n            axisLine = new Line2D.Double(dataArea.getX(), cursor, \n                    dataArea.getMaxX(), cursor);  \n        }\n        else if (edge == RectangleEdge.LEFT) {\n            axisLine = new Line2D.Double(cursor, dataArea.getY(), cursor, \n                    dataArea.getMaxY());  \n        }\n        else if (edge == RectangleEdge.RIGHT) {\n            axisLine = new Line2D.Double(cursor, dataArea.getY(), cursor, \n                    dataArea.getMaxY());  \n        }\n        g2.setPaint(getAxisLinePaint());\n        g2.setStroke(getAxisLineStroke());\n        g2.draw(axisLine);\n        \n        boolean drawUpOrRight = false;  \n        boolean drawDownOrLeft = false;\n        if (this.positiveArrowVisible) {\n            if (this.inverted) {\n                drawDownOrLeft = true;   \n            }\n            else {\n                drawUpOrRight = true;   \n            }\n        }\n        if (this.negativeArrowVisible) {\n            if (this.inverted) {\n                drawUpOrRight = true;   \n            }\n            else {\n                drawDownOrLeft = true;   \n            }\n        }\n        if (drawUpOrRight) {\n            double x = 0.0;\n            double y = 0.0;\n            Shape arrow = null;\n            if (edge == RectangleEdge.TOP || edge == RectangleEdge.BOTTOM) {\n                x = dataArea.getMaxX();\n                y = cursor;\n                arrow = this.rightArrow; \n            }\n            else if (edge == RectangleEdge.LEFT \n                    || edge == RectangleEdge.RIGHT) {\n                x = cursor;\n                y = dataArea.getMinY();\n                arrow = this.upArrow; \n            }\n\n            // draw the arrow...\n            AffineTransform transformer = new AffineTransform();\n            transformer.setToTranslation(x, y);\n            Shape shape = transformer.createTransformedShape(arrow);\n            g2.fill(shape);\n            g2.draw(shape);\n        }\n        \n        if (drawDownOrLeft) {\n            double x = 0.0;\n            double y = 0.0;\n            Shape arrow = null;\n            if (edge == RectangleEdge.TOP || edge == RectangleEdge.BOTTOM) {\n                x = dataArea.getMinX();\n                y = cursor;\n                arrow = this.leftArrow; \n            }\n            else if (edge == RectangleEdge.LEFT \n                    || edge == RectangleEdge.RIGHT) {\n                x = cursor;\n                y = dataArea.getMaxY();\n                arrow = this.downArrow; \n            }\n\n            // draw the arrow...\n            AffineTransform transformer = new AffineTransform();\n            transformer.setToTranslation(x, y);\n            Shape shape = transformer.createTransformedShape(arrow);\n            g2.fill(shape);\n            g2.draw(shape);\n        }\n        \n    }",
    "comment": " Draws an axis line at the current cursor position and edge.  @param g2  the graphics device. @param cursor  the cursor position. @param dataArea  the data area. @param edge  the edge. ",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "ValueAxis.drawTickMarksAndLabels",
    "class_name": "org.jfree.chart.axis.ValueAxis",
    "signature": "org.jfree.chart.axis.ValueAxis.drawTickMarksAndLabels(Graphics2D,double,Rectangle2D,Rectangle2D,RectangleEdge,PlotRenderingInfo)",
    "snippet": "    protected AxisState drawTickMarksAndLabels(Graphics2D g2, double cursor,\n            Rectangle2D plotArea, Rectangle2D dataArea, RectangleEdge edge,\n            PlotRenderingInfo info) {\n                                              \n        AxisState state = new AxisState(cursor);\n\n        if (isAxisLineVisible()) {\n            drawAxisLine(g2, cursor, dataArea, edge);\n        }\n\n        double ol = getTickMarkOutsideLength();\n        double il = getTickMarkInsideLength();\n\n        List ticks = refreshTicks(g2, state, dataArea, edge);\n        state.setTicks(ticks);\n        g2.setFont(getTickLabelFont());\n        Iterator iterator = ticks.iterator();\n        while (iterator.hasNext()) {\n            ValueTick tick = (ValueTick) iterator.next();\n            if (isTickLabelsVisible()) {\n                g2.setPaint(getTickLabelPaint());\n                float[] anchorPoint = calculateAnchorPoint(tick, cursor, \n                        dataArea, edge);\n                TextUtilities.drawRotatedString(tick.getText(), g2, \n                        anchorPoint[0], anchorPoint[1], tick.getTextAnchor(), \n                        tick.getAngle(), tick.getRotationAnchor());\n            }\n\n            if (isTickMarksVisible() && tick.getTickType().equals(TickType.MAJOR)) {\n                float xx = (float) valueToJava2D(tick.getValue(), dataArea, \n                        edge);\n                Line2D mark = null;\n                g2.setStroke(getTickMarkStroke());\n                g2.setPaint(getTickMarkPaint());\n                if (edge == RectangleEdge.LEFT) {\n                    mark = new Line2D.Double(cursor - ol, xx, cursor + il, xx);\n                }\n                else if (edge == RectangleEdge.RIGHT) {\n                    mark = new Line2D.Double(cursor + ol, xx, cursor - il, xx);\n                }\n                else if (edge == RectangleEdge.TOP) {\n                    mark = new Line2D.Double(xx, cursor - ol, xx, cursor + il);\n                }\n                else if (edge == RectangleEdge.BOTTOM) {\n                    mark = new Line2D.Double(xx, cursor + ol, xx, cursor - il);\n                }\n                g2.draw(mark);\n            }\n        }\n        \n        // need to work out the space used by the tick labels...\n        // so we can update the cursor...\n        double used = 0.0;\n        if (isTickLabelsVisible()) {\n            if (edge == RectangleEdge.LEFT) {\n                used += findMaximumTickLabelWidth(ticks, g2, plotArea, \n                        isVerticalTickLabels());  \n                state.cursorLeft(used);      \n            }\n            else if (edge == RectangleEdge.RIGHT) {\n                used = findMaximumTickLabelWidth(ticks, g2, plotArea, \n                        isVerticalTickLabels());\n                state.cursorRight(used);      \n            }\n            else if (edge == RectangleEdge.TOP) {\n                used = findMaximumTickLabelHeight(ticks, g2, plotArea, \n                        isVerticalTickLabels());\n                state.cursorUp(used);\n            }\n            else if (edge == RectangleEdge.BOTTOM) {\n                used = findMaximumTickLabelHeight(ticks, g2, plotArea, \n                        isVerticalTickLabels());\n                state.cursorDown(used);\n            }\n        }\n       \n        return state;\n    }",
    "comment": " Draws the axis line, tick marks and tick mark labels.  @param g2  the graphics device. @param cursor  the cursor. @param plotArea  the plot area. @param dataArea  the data area. @param edge  the edge that the axis is aligned with. @param info  the plot rendering info.  @return The width or height used to draw the axis. ",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "ValueAxis.findMaximumTickLabelHeight",
    "class_name": "org.jfree.chart.axis.ValueAxis",
    "signature": "org.jfree.chart.axis.ValueAxis.findMaximumTickLabelHeight(List,Graphics2D,Rectangle2D,boolean)",
    "snippet": "    protected double findMaximumTickLabelHeight(List ticks,\n                                                Graphics2D g2, \n                                                Rectangle2D drawArea, \n                                                boolean vertical) {\n                                                    \n        RectangleInsets insets = getTickLabelInsets();\n        Font font = getTickLabelFont();\n        double maxHeight = 0.0;\n        if (vertical) {\n            FontMetrics fm = g2.getFontMetrics(font);\n            Iterator iterator = ticks.iterator();\n            while (iterator.hasNext()) {\n                Tick tick = (Tick) iterator.next();\n                Rectangle2D labelBounds = TextUtilities.getTextBounds(\n                        tick.getText(), g2, fm);\n                if (labelBounds.getWidth() + insets.getTop() \n                        + insets.getBottom() > maxHeight) {\n                    maxHeight = labelBounds.getWidth() \n                                + insets.getTop() + insets.getBottom();\n                }\n            }\n        }\n        else {\n            LineMetrics metrics = font.getLineMetrics(\"ABCxyz\", \n                    g2.getFontRenderContext());\n            maxHeight = metrics.getHeight() \n                        + insets.getTop() + insets.getBottom();\n        }\n        return maxHeight;\n        \n    }",
    "comment": " A utility method for determining the height of the tallest tick label.  @param ticks  the ticks. @param g2  the graphics device. @param drawArea  the area within which the plot and axes should be drawn. @param vertical  a flag that indicates whether or not the tick labels  are 'vertical'.  @return The height of the tallest tick label. ",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "ValueAxis.findMaximumTickLabelWidth",
    "class_name": "org.jfree.chart.axis.ValueAxis",
    "signature": "org.jfree.chart.axis.ValueAxis.findMaximumTickLabelWidth(List,Graphics2D,Rectangle2D,boolean)",
    "snippet": "    protected double findMaximumTickLabelWidth(List ticks, \n                                               Graphics2D g2, \n                                               Rectangle2D drawArea, \n                                               boolean vertical) {\n                                                   \n        RectangleInsets insets = getTickLabelInsets();\n        Font font = getTickLabelFont();\n        double maxWidth = 0.0;\n        if (!vertical) {\n            FontMetrics fm = g2.getFontMetrics(font);\n            Iterator iterator = ticks.iterator();\n            while (iterator.hasNext()) {\n                Tick tick = (Tick) iterator.next();\n                Rectangle2D labelBounds = TextUtilities.getTextBounds(\n                        tick.getText(), g2, fm);\n                if (labelBounds.getWidth() + insets.getLeft() \n                        + insets.getRight() > maxWidth) {\n                    maxWidth = labelBounds.getWidth() \n                               + insets.getLeft() + insets.getRight();\n                }\n            }\n        }\n        else {\n            LineMetrics metrics = font.getLineMetrics(\"ABCxyz\", \n                    g2.getFontRenderContext());\n            maxWidth = metrics.getHeight() \n                       + insets.getTop() + insets.getBottom();\n        }\n        return maxWidth;\n        \n    }",
    "comment": " A utility method for determining the width of the widest tick label.  @param ticks  the ticks. @param g2  the graphics device. @param drawArea  the area within which the plot and axes should be drawn. @param vertical  a flag that indicates whether or not the tick labels  are 'vertical'.  @return The width of the tallest tick label. ",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "ValueAxis.getAutoRangeMinimumSize",
    "class_name": "org.jfree.chart.axis.ValueAxis",
    "signature": "org.jfree.chart.axis.ValueAxis.getAutoRangeMinimumSize()",
    "snippet": "    public double getAutoRangeMinimumSize() {\n        return this.autoRangeMinimumSize;\n    }",
    "comment": " Returns the minimum size allowed for the axis range when it is  automatically calculated.  @return The minimum range.  @see #setAutoRangeMinimumSize(double) ",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "ValueAxis.getFixedAutoRange",
    "class_name": "org.jfree.chart.axis.ValueAxis",
    "signature": "org.jfree.chart.axis.ValueAxis.getFixedAutoRange()",
    "snippet": "    public double getFixedAutoRange() {\n        return this.fixedAutoRange;\n    }",
    "comment": " Returns the fixed auto range.  @return The length.  @see #setFixedAutoRange(double) ",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "ValueAxis.getLowerMargin",
    "class_name": "org.jfree.chart.axis.ValueAxis",
    "signature": "org.jfree.chart.axis.ValueAxis.getLowerMargin()",
    "snippet": "    public double getLowerMargin() {\n        return this.lowerMargin;\n    }",
    "comment": " Returns the lower margin for the axis, expressed as a percentage of the  axis range.  This controls the space added to the lower end of the axis  when the axis range is automatically calculated (it is ignored when the  axis range is set explicitly). The default value is 0.05 (five percent).  @return The lower margin.  @see #setLowerMargin(double) ",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "ValueAxis.getRange",
    "class_name": "org.jfree.chart.axis.ValueAxis",
    "signature": "org.jfree.chart.axis.ValueAxis.getRange()",
    "snippet": "    public Range getRange() {\n        return this.range;\n    }",
    "comment": " Returns the range for the axis.  @return The axis range (never <code>null</code>).  @see #setRange(Range) ",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "ValueAxis.getStandardTickUnits",
    "class_name": "org.jfree.chart.axis.ValueAxis",
    "signature": "org.jfree.chart.axis.ValueAxis.getStandardTickUnits()",
    "snippet": "    public TickUnitSource getStandardTickUnits() {\n        return this.standardTickUnits;\n    }",
    "comment": " Returns the source for obtaining standard tick units for the axis.  @return The source (possibly <code>null</code>).  @see #setStandardTickUnits(TickUnitSource) ",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "ValueAxis.getUpperMargin",
    "class_name": "org.jfree.chart.axis.ValueAxis",
    "signature": "org.jfree.chart.axis.ValueAxis.getUpperMargin()",
    "snippet": "    public double getUpperMargin() {\n        return this.upperMargin;\n    }",
    "comment": " Returns the upper margin for the axis, expressed as a percentage of the  axis range.  This controls the space added to the lower end of the axis  when the axis range is automatically calculated (it is ignored when the  axis range is set explicitly). The default value is 0.05 (five percent).  @return The upper margin.  @see #setUpperMargin(double) ",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "ValueAxis.isAutoRange",
    "class_name": "org.jfree.chart.axis.ValueAxis",
    "signature": "org.jfree.chart.axis.ValueAxis.isAutoRange()",
    "snippet": "    public boolean isAutoRange() {\n        return this.autoRange;\n    }",
    "comment": " Returns the flag that controls whether or not the axis range is  automatically adjusted to fit the data values.  @return The flag.  @see #setAutoRange(boolean) ",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "ValueAxis.isAutoTickUnitSelection",
    "class_name": "org.jfree.chart.axis.ValueAxis",
    "signature": "org.jfree.chart.axis.ValueAxis.isAutoTickUnitSelection()",
    "snippet": "    public boolean isAutoTickUnitSelection() {\n        return this.autoTickUnitSelection;\n    }",
    "comment": " Returns a flag indicating whether or not the tick unit is automatically selected from a range of standard tick units.  @return A flag indicating whether or not the tick unit is automatically selected.  @see #setAutoTickUnitSelection(boolean) ",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "ValueAxis.isInverted",
    "class_name": "org.jfree.chart.axis.ValueAxis",
    "signature": "org.jfree.chart.axis.ValueAxis.isInverted()",
    "snippet": "    public boolean isInverted() {\n        return this.inverted;\n    }",
    "comment": " Returns a flag that controls the direction of values on the axis. <P> For a regular axis, values increase from left to right (for a horizontal axis) and bottom to top (for a vertical axis).  When the axis is 'inverted', the values increase in the opposite direction.  @return The flag.  @see #setInverted(boolean) ",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "ValueAxis.isVerticalTickLabels",
    "class_name": "org.jfree.chart.axis.ValueAxis",
    "signature": "org.jfree.chart.axis.ValueAxis.isVerticalTickLabels()",
    "snippet": "    public boolean isVerticalTickLabels() {\n        return this.verticalTickLabels;\n    }",
    "comment": " Returns <code>true</code> if the tick labels should be rotated (to  vertical), and <code>false</code> otherwise.  @return <code>true</code> or <code>false</code>.  @see #setVerticalTickLabels(boolean) ",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "ValueAxis.lengthToJava2D",
    "class_name": "org.jfree.chart.axis.ValueAxis",
    "signature": "org.jfree.chart.axis.ValueAxis.lengthToJava2D(double,Rectangle2D,RectangleEdge)",
    "snippet": "    public double lengthToJava2D(double length, Rectangle2D area, \n                                 RectangleEdge edge) {\n        double zero = valueToJava2D(0.0, area, edge);\n        double l = valueToJava2D(length, area, edge);\n        return Math.abs(l - zero);\n    }",
    "comment": " Converts a length in data coordinates into the corresponding length in  Java2D coordinates.  @param length  the length. @param area  the plot area. @param edge  the edge along which the axis lies.  @return The length in Java2D coordinates. ",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "ValueAxis.reserveSpace",
    "class_name": "org.jfree.chart.axis.ValueAxis",
    "signature": "org.jfree.chart.axis.ValueAxis.reserveSpace(Graphics2D,Plot,Rectangle2D,RectangleEdge,AxisSpace)",
    "snippet": "    public AxisSpace reserveSpace(Graphics2D g2, Plot plot,\n                                  Rectangle2D plotArea, \n                                  RectangleEdge edge, AxisSpace space) {\n\n        // create a new space object if one wasn't supplied...\n        if (space == null) {\n            space = new AxisSpace();\n        }\n        \n        // if the axis is not visible, no additional space is required...\n        if (!isVisible()) {\n            return space;\n        }\n\n        // if the axis has a fixed dimension, return it...\n        double dimension = getFixedDimension();\n        if (dimension > 0.0) {\n            space.ensureAtLeast(dimension, edge);\n        }\n\n        // calculate the max size of the tick labels (if visible)...\n        double tickLabelHeight = 0.0;\n        double tickLabelWidth = 0.0;\n        if (isTickLabelsVisible()) {\n            g2.setFont(getTickLabelFont());\n            List ticks = refreshTicks(g2, new AxisState(), plotArea, edge);\n            if (RectangleEdge.isTopOrBottom(edge)) {\n                tickLabelHeight = findMaximumTickLabelHeight(ticks, g2, \n                        plotArea, isVerticalTickLabels());\n            }\n            else if (RectangleEdge.isLeftOrRight(edge)) {\n                tickLabelWidth = findMaximumTickLabelWidth(ticks, g2, plotArea,\n                        isVerticalTickLabels());\n            }\n        }\n\n        // get the axis label size and update the space object...\n        Rectangle2D labelEnclosure = getLabelEnclosure(g2, edge);\n        double labelHeight = 0.0;\n        double labelWidth = 0.0;\n        if (RectangleEdge.isTopOrBottom(edge)) {\n            labelHeight = labelEnclosure.getHeight();\n            space.add(labelHeight + tickLabelHeight, edge);\n        }\n        else if (RectangleEdge.isLeftOrRight(edge)) {\n            labelWidth = labelEnclosure.getWidth();\n            space.add(labelWidth + tickLabelWidth, edge);\n        }\n\n        return space;\n\n    }",
    "comment": " Returns the space required to draw the axis.  @param g2  the graphics device. @param plot  the plot that the axis belongs to. @param plotArea  the area within which the plot should be drawn. @param edge  the axis location. @param space  the space already reserved (for other axes).  @return The space required to draw the axis (including pre-reserved  space). ",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "ValueAxis.setRange",
    "class_name": "org.jfree.chart.axis.ValueAxis",
    "signature": "org.jfree.chart.axis.ValueAxis.setRange(Range,boolean,boolean)",
    "snippet": "    public void setRange(Range range, boolean turnOffAutoRange, \n                         boolean notify) {\n        if (range == null) {\n            throw new IllegalArgumentException(\"Null 'range' argument.\");\n        }\n        if (turnOffAutoRange) {\n            this.autoRange = false;\n        }\n        this.range = range;\n        if (notify) {\n            notifyListeners(new AxisChangeEvent(this));\n        }\n    }",
    "comment": " Sets the range for the axis, if requested, sends an  {@link AxisChangeEvent} to all registered listeners.  As a side-effect,  the auto-range flag is set to <code>false</code> (optional).  @param range  the range (<code>null</code> not permitted). @param turnOffAutoRange  a flag that controls whether or not the auto  range is turned off.          @param notify  a flag that controls whether or not listeners are  notified.  @see #getRange() ",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "ValueTick.ValueTick",
    "class_name": "org.jfree.chart.axis.ValueTick",
    "signature": "org.jfree.chart.axis.ValueTick.ValueTick(TickType,double,String,TextAnchor,TextAnchor,double)",
    "snippet": "    public ValueTick(TickType tickType, double value, String label, \n                     TextAnchor textAnchor, TextAnchor rotationAnchor, \n                     double angle) {\n                          \n        super(label, textAnchor, rotationAnchor, angle);\n        this.value = value;\n        this.tickType = tickType;   \n    }    ",
    "comment": " Creates a new value tick.  @param tickType  the tick type (major or minor). @param value  the value. @param label  the label. @param textAnchor  the part of the label that is aligned to the anchor  point. @param rotationAnchor  defines the rotation point relative to the label. @param angle  the rotation angle (in radians).  @since 1.0.7 ",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "ValueTick.ValueTick",
    "class_name": "org.jfree.chart.axis.ValueTick",
    "signature": "org.jfree.chart.axis.ValueTick.ValueTick(double,String,TextAnchor,TextAnchor,double)",
    "snippet": "    public ValueTick(double value, String label, \n                     TextAnchor textAnchor, TextAnchor rotationAnchor, \n                     double angle) {\n                          \n        this(TickType.MAJOR, value, label, textAnchor, rotationAnchor, angle);\n        this.value = value;\n        \n    }",
    "comment": " Creates a new value tick.  @param value  the value. @param label  the label. @param textAnchor  the part of the label that is aligned to the anchor  point. @param rotationAnchor  defines the rotation point relative to the label. @param angle  the rotation angle (in radians). ",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "ValueTick.getTickType",
    "class_name": "org.jfree.chart.axis.ValueTick",
    "signature": "org.jfree.chart.axis.ValueTick.getTickType()",
    "snippet": "    public TickType getTickType() {\n        return this.tickType;\n    }",
    "comment": " Returns the tick type (major or minor).  @return The tick type.  @since 1.0.7 ",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "ValueTick.getValue",
    "class_name": "org.jfree.chart.axis.ValueTick",
    "signature": "org.jfree.chart.axis.ValueTick.getValue()",
    "snippet": "    public double getValue() {\n        return this.value;\n    }",
    "comment": " Returns the value.  @return The value. ",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "AbstractBlock.AbstractBlock",
    "class_name": "org.jfree.chart.block.AbstractBlock",
    "signature": "org.jfree.chart.block.AbstractBlock.AbstractBlock()",
    "snippet": "    protected AbstractBlock() {\n        this.id = null;\n        this.width = 0.0;\n        this.height = 0.0;\n        this.bounds = new Rectangle2D.Float();\n        this.margin = RectangleInsets.ZERO_INSETS;\n        this.frame = BlockBorder.NONE; \n        this.padding = RectangleInsets.ZERO_INSETS;\n    }",
    "comment": " Creates a new block. ",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "AbstractBlock.calculateTotalHeight",
    "class_name": "org.jfree.chart.block.AbstractBlock",
    "signature": "org.jfree.chart.block.AbstractBlock.calculateTotalHeight(double)",
    "snippet": "    protected double calculateTotalHeight(double contentHeight) {\n        double result = contentHeight;\n        result = this.padding.extendHeight(result);\n        result = this.frame.getInsets().extendHeight(result);\n        result = this.margin.extendHeight(result);\n        return result;\n    }",
    "comment": " Adds the margin, border and padding to the specified content height.  @param contentHeight  the content height.  @return The adjusted height. ",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "AbstractBlock.calculateTotalWidth",
    "class_name": "org.jfree.chart.block.AbstractBlock",
    "signature": "org.jfree.chart.block.AbstractBlock.calculateTotalWidth(double)",
    "snippet": "    protected double calculateTotalWidth(double contentWidth) {\n        double result = contentWidth;\n        result = this.padding.extendWidth(result);\n        result = this.frame.getInsets().extendWidth(result);\n        result = this.margin.extendWidth(result);\n        return result;\n    }",
    "comment": " Adds the margin, border and padding to the specified content width.  @param contentWidth  the content width.  @return The adjusted width. ",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "AbstractBlock.drawBorder",
    "class_name": "org.jfree.chart.block.AbstractBlock",
    "signature": "org.jfree.chart.block.AbstractBlock.drawBorder(Graphics2D,Rectangle2D)",
    "snippet": "    protected void drawBorder(Graphics2D g2, Rectangle2D area) {\n        this.frame.draw(g2, area);\n    }",
    "comment": " Draws the border around the perimeter of the specified area.  @param g2  the graphics device. @param area  the area. ",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "AbstractBlock.getBounds",
    "class_name": "org.jfree.chart.block.AbstractBlock",
    "signature": "org.jfree.chart.block.AbstractBlock.getBounds()",
    "snippet": "    public Rectangle2D getBounds() {\n        return this.bounds;\n    }",
    "comment": " Returns the current bounds of the block.  @return The bounds.  @see #setBounds(Rectangle2D) ",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "AbstractBlock.getFrame",
    "class_name": "org.jfree.chart.block.AbstractBlock",
    "signature": "org.jfree.chart.block.AbstractBlock.getFrame()",
    "snippet": "    public BlockFrame getFrame() {\n        return this.frame;\n    }",
    "comment": " Returns the current frame (border).  @return The frame.  @since 1.0.5 @see #setFrame(BlockFrame) ",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "AbstractBlock.setBounds",
    "class_name": "org.jfree.chart.block.AbstractBlock",
    "signature": "org.jfree.chart.block.AbstractBlock.setBounds(Rectangle2D)",
    "snippet": "    public void setBounds(Rectangle2D bounds) {\n        if (bounds == null) {\n            throw new IllegalArgumentException(\"Null 'bounds' argument.\");\n        }\n        this.bounds = bounds;\n    }",
    "comment": " Sets the bounds of the block.  @param bounds  the bounds (<code>null</code> not permitted).  @see #getBounds() ",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "AbstractBlock.setFrame",
    "class_name": "org.jfree.chart.block.AbstractBlock",
    "signature": "org.jfree.chart.block.AbstractBlock.setFrame(BlockFrame)",
    "snippet": "    public void setFrame(BlockFrame frame) {\n        if (frame == null) {\n            throw new IllegalArgumentException(\"Null 'frame' argument.\");   \n        }\n        this.frame = frame;\n    }",
    "comment": " Sets the frame (or border).  @param frame  the frame (<code>null</code> not permitted).  @since 1.0.5 @see #getFrame() ",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "AbstractBlock.setMargin",
    "class_name": "org.jfree.chart.block.AbstractBlock",
    "signature": "org.jfree.chart.block.AbstractBlock.setMargin(RectangleInsets)",
    "snippet": "    public void setMargin(RectangleInsets margin) {\n        if (margin == null) {\n            throw new IllegalArgumentException(\"Null 'margin' argument.\");   \n        }\n        this.margin = margin;\n    }",
    "comment": " Sets the margin (use {@link RectangleInsets#ZERO_INSETS} for no  padding).  @param margin  the margin (<code>null</code> not permitted).  @see #getMargin() ",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "AbstractBlock.setPadding",
    "class_name": "org.jfree.chart.block.AbstractBlock",
    "signature": "org.jfree.chart.block.AbstractBlock.setPadding(RectangleInsets)",
    "snippet": "    public void setPadding(RectangleInsets padding) {\n        if (padding == null) {\n            throw new IllegalArgumentException(\"Null 'padding' argument.\");   \n        }\n        this.padding = padding;\n    }",
    "comment": " Sets the padding (use {@link RectangleInsets#ZERO_INSETS} for no  padding).  @param padding  the padding (<code>null</code> not permitted).  @see #getPadding() ",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "AbstractBlock.setPadding",
    "class_name": "org.jfree.chart.block.AbstractBlock",
    "signature": "org.jfree.chart.block.AbstractBlock.setPadding(double,double,double,double)",
    "snippet": "    public void setPadding(double top, double left, double bottom, \n                           double right) {\n        setPadding(new RectangleInsets(top, left, bottom, right));\n    }",
    "comment": " Sets the padding.  @param top  the top padding. @param left  the left padding. @param bottom  the bottom padding. @param right  the right padding. ",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "AbstractBlock.toContentConstraint",
    "class_name": "org.jfree.chart.block.AbstractBlock",
    "signature": "org.jfree.chart.block.AbstractBlock.toContentConstraint(RectangleConstraint)",
    "snippet": "    protected RectangleConstraint toContentConstraint(RectangleConstraint c) {\n        if (c == null) {\n            throw new IllegalArgumentException(\"Null 'c' argument.\");\n        }\n        if (c.equals(RectangleConstraint.NONE)) {\n            return c;\n        }\n        double w = c.getWidth();\n        Range wr = c.getWidthRange();\n        double h = c.getHeight();\n        Range hr = c.getHeightRange();\n        double ww = trimToContentWidth(w);\n        double hh = trimToContentHeight(h);\n        Range wwr = trimToContentWidth(wr);\n        Range hhr = trimToContentHeight(hr);\n        return new RectangleConstraint(\n            ww, wwr, c.getWidthConstraintType(), \n            hh, hhr, c.getHeightConstraintType()\n        );\n    }",
    "comment": " Returns a constraint for the content of this block that will result in the bounds of the block matching the specified constraint.  @param c  the outer constraint (<code>null</code> not permitted).  @return The content constraint. ",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "AbstractBlock.trimBorder",
    "class_name": "org.jfree.chart.block.AbstractBlock",
    "signature": "org.jfree.chart.block.AbstractBlock.trimBorder(Rectangle2D)",
    "snippet": "    protected Rectangle2D trimBorder(Rectangle2D area) {\n        // defer argument checking...\n        this.frame.getInsets().trim(area);\n        return area;\n    }",
    "comment": " Reduces the specified area by the amount of space consumed  by the border.  @param area  the area (<code>null</code> not permitted).  @return The trimmed area. ",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "AbstractBlock.trimMargin",
    "class_name": "org.jfree.chart.block.AbstractBlock",
    "signature": "org.jfree.chart.block.AbstractBlock.trimMargin(Rectangle2D)",
    "snippet": "    protected Rectangle2D trimMargin(Rectangle2D area) {\n        // defer argument checking...\n        this.margin.trim(area);\n        return area;\n    }",
    "comment": " Reduces the specified area by the amount of space consumed  by the margin.  @param area  the area (<code>null</code> not permitted).  @return The trimmed area. ",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "AbstractBlock.trimPadding",
    "class_name": "org.jfree.chart.block.AbstractBlock",
    "signature": "org.jfree.chart.block.AbstractBlock.trimPadding(Rectangle2D)",
    "snippet": "    protected Rectangle2D trimPadding(Rectangle2D area) {\n        // defer argument checking...\n        this.padding.trim(area);\n        return area;\n    }",
    "comment": " Reduces the specified area by the amount of space consumed  by the padding.  @param area  the area (<code>null</code> not permitted).  @return The trimmed area. ",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "AbstractBlock.trimToContentHeight",
    "class_name": "org.jfree.chart.block.AbstractBlock",
    "signature": "org.jfree.chart.block.AbstractBlock.trimToContentHeight(Range)",
    "snippet": "    private Range trimToContentHeight(Range r) {\n        if (r == null) {\n            return null;   \n        }\n        double lowerBound = 0.0;\n        double upperBound = Double.POSITIVE_INFINITY;\n        if (r.getLowerBound() > 0.0) {\n            lowerBound = trimToContentHeight(r.getLowerBound());   \n        }\n        if (r.getUpperBound() < Double.POSITIVE_INFINITY) {\n            upperBound = trimToContentHeight(r.getUpperBound());\n        }\n        return new Range(lowerBound, upperBound);\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "AbstractBlock.trimToContentHeight",
    "class_name": "org.jfree.chart.block.AbstractBlock",
    "signature": "org.jfree.chart.block.AbstractBlock.trimToContentHeight(double)",
    "snippet": "    protected double trimToContentHeight(double fixedHeight) {\n        double result = this.margin.trimHeight(fixedHeight);\n        result = this.frame.getInsets().trimHeight(result);\n        result = this.padding.trimHeight(result);\n        return Math.max(result, 0.0);\n    }",
    "comment": " Calculate the height available for content after subtracting  the margin, border and padding space from the specified fixed  height.  @param fixedHeight  the fixed height.  @return The available space.  @see #trimToContentWidth(double) ",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "AbstractBlock.trimToContentWidth",
    "class_name": "org.jfree.chart.block.AbstractBlock",
    "signature": "org.jfree.chart.block.AbstractBlock.trimToContentWidth(Range)",
    "snippet": "    private Range trimToContentWidth(Range r) {\n        if (r == null) {\n            return null;   \n        }\n        double lowerBound = 0.0;\n        double upperBound = Double.POSITIVE_INFINITY;\n        if (r.getLowerBound() > 0.0) {\n            lowerBound = trimToContentWidth(r.getLowerBound());   \n        }\n        if (r.getUpperBound() < Double.POSITIVE_INFINITY) {\n            upperBound = trimToContentWidth(r.getUpperBound());\n        }\n        return new Range(lowerBound, upperBound);\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "AbstractBlock.trimToContentWidth",
    "class_name": "org.jfree.chart.block.AbstractBlock",
    "signature": "org.jfree.chart.block.AbstractBlock.trimToContentWidth(double)",
    "snippet": "    protected double trimToContentWidth(double fixedWidth) {\n        double result = this.margin.trimWidth(fixedWidth);\n        result = this.frame.getInsets().trimWidth(result);\n        result = this.padding.trimWidth(result);\n        return Math.max(result, 0.0);\n    }",
    "comment": " Calculate the width available for content after subtracting  the margin, border and padding space from the specified fixed  width.  @param fixedWidth  the fixed width.  @return The available space.  @see #trimToContentHeight(double) ",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "BlockBorder.BlockBorder",
    "class_name": "org.jfree.chart.block.BlockBorder",
    "signature": "org.jfree.chart.block.BlockBorder.BlockBorder(RectangleInsets,Paint)",
    "snippet": "    public BlockBorder(RectangleInsets insets, Paint paint) {\n        if (insets == null) {\n            throw new IllegalArgumentException(\"Null 'insets' argument.\");\n        }\n        if (paint == null) {\n            throw new IllegalArgumentException(\"Null 'paint' argument.\");   \n        }\n        this.insets = insets;\n        this.paint = paint;\n    }",
    "comment": " Creates a new border.  @param insets  the border insets (<code>null</code> not permitted). @param paint  the paint (<code>null</code> not permitted). ",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "BlockBorder.draw",
    "class_name": "org.jfree.chart.block.BlockBorder",
    "signature": "org.jfree.chart.block.BlockBorder.draw(Graphics2D,Rectangle2D)",
    "snippet": "    public void draw(Graphics2D g2, Rectangle2D area) {\n        // this default implementation will just fill the available\n        // border space with a single color\n        double t = this.insets.calculateTopInset(area.getHeight());\n        double b = this.insets.calculateBottomInset(area.getHeight());\n        double l = this.insets.calculateLeftInset(area.getWidth());\n        double r = this.insets.calculateRightInset(area.getWidth());\n        double x = area.getX();\n        double y = area.getY();\n        double w = area.getWidth();\n        double h = area.getHeight();\n        g2.setPaint(this.paint);\n        Rectangle2D rect = new Rectangle2D.Double();\n        if (t > 0.0) {\n            rect.setRect(x, y, w, t);\n            g2.fill(rect);\n        }\n        if (b > 0.0) {\n            rect.setRect(x, y + h - b, w, b);\n            g2.fill(rect);\n        }\n        if (l > 0.0) {\n            rect.setRect(x, y, l, h);\n            g2.fill(rect);\n        }\n        if (r > 0.0) {\n            rect.setRect(x + w - r, y, r, h);\n            g2.fill(rect);\n        }\n    }",
    "comment": " Draws the border by filling in the reserved space.  @param g2  the graphics device. @param area  the area. ",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "BlockBorder.getInsets",
    "class_name": "org.jfree.chart.block.BlockBorder",
    "signature": "org.jfree.chart.block.BlockBorder.getInsets()",
    "snippet": "    public RectangleInsets getInsets() {\n        return this.insets;\n    }",
    "comment": " Returns the space reserved for the border.  @return The space (never <code>null</code>). ",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "BlockContainer.BlockContainer",
    "class_name": "org.jfree.chart.block.BlockContainer",
    "signature": "org.jfree.chart.block.BlockContainer.BlockContainer(Arrangement)",
    "snippet": "    public BlockContainer(Arrangement arrangement) {\n        if (arrangement == null) {\n            throw new IllegalArgumentException(\"Null 'arrangement' argument.\");\n        }\n        this.arrangement = arrangement;\n        this.blocks = new ArrayList();\n    }    ",
    "comment": " Creates a new instance with the specified arrangement.  @param arrangement  the arrangement manager (<code>null</code> not  permitted). ",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "BlockContainer.add",
    "class_name": "org.jfree.chart.block.BlockContainer",
    "signature": "org.jfree.chart.block.BlockContainer.add(Block)",
    "snippet": "    public void add(Block block) {\n        add(block, null);\n    }",
    "comment": " Adds a block to the container.  @param block  the block (<code>null</code> permitted). ",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "BlockContainer.add",
    "class_name": "org.jfree.chart.block.BlockContainer",
    "signature": "org.jfree.chart.block.BlockContainer.add(Block,Object)",
    "snippet": "    public void add(Block block, Object key) {\n        this.blocks.add(block);\n        this.arrangement.add(block, key);\n    }",
    "comment": " Adds a block to the container.  @param block  the block (<code>null</code> permitted). @param key  the key (<code>null</code> permitted). ",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "BlockContainer.arrange",
    "class_name": "org.jfree.chart.block.BlockContainer",
    "signature": "org.jfree.chart.block.BlockContainer.arrange(Graphics2D,RectangleConstraint)",
    "snippet": "    public Size2D arrange(Graphics2D g2, RectangleConstraint constraint) {\n        return this.arrangement.arrange(this, g2, constraint);\n    }",
    "comment": " Arranges the contents of the block, within the given constraints, and  returns the block size.  @param g2  the graphics device. @param constraint  the constraint (<code>null</code> not permitted).  @return The block size (in Java2D units, never <code>null</code>). ",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "BlockContainer.clear",
    "class_name": "org.jfree.chart.block.BlockContainer",
    "signature": "org.jfree.chart.block.BlockContainer.clear()",
    "snippet": "    public void clear() {\n        this.blocks.clear();\n        this.arrangement.clear();\n    }",
    "comment": " Clears all the blocks from the container. ",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "BlockContainer.draw",
    "class_name": "org.jfree.chart.block.BlockContainer",
    "signature": "org.jfree.chart.block.BlockContainer.draw(Graphics2D,Rectangle2D,Object)",
    "snippet": "    public Object draw(Graphics2D g2, Rectangle2D area, Object params) {\n        // check if we need to collect chart entities from the container\n        EntityBlockParams ebp = null;\n        StandardEntityCollection sec = null;\n        if (params instanceof EntityBlockParams) {\n            ebp = (EntityBlockParams) params;\n            if (ebp.getGenerateEntities()) {\n                sec = new StandardEntityCollection();   \n            }\n        }\n        Rectangle2D contentArea = (Rectangle2D) area.clone();\n        contentArea = trimMargin(contentArea);\n        drawBorder(g2, contentArea);\n        contentArea = trimBorder(contentArea);\n        contentArea = trimPadding(contentArea);\n        Iterator iterator = this.blocks.iterator();\n        while (iterator.hasNext()) {\n            Block block = (Block) iterator.next();\n            Rectangle2D bounds = block.getBounds();\n            Rectangle2D drawArea = new Rectangle2D.Double(bounds.getX() \n                    + area.getX(), bounds.getY() + area.getY(), \n                    bounds.getWidth(), bounds.getHeight());\n            Object r = block.draw(g2, drawArea, params);\n            if (sec != null) {\n                if (r instanceof EntityBlockResult) {\n                    EntityBlockResult ebr = (EntityBlockResult) r;\n                    EntityCollection ec = ebr.getEntityCollection();\n                    sec.addAll(ec);\n                }\n            }\n        }\n        BlockResult result = null;\n        if (sec != null) {\n            result = new BlockResult();\n            result.setEntityCollection(sec);\n        }\n        return result;\n    }",
    "comment": " Draws the block within the specified area.  @param g2  the graphics device. @param area  the area. @param params  passed on to blocks within the container  (<code>null</code> permitted).  @return An instance of {@link EntityBlockResult}, or <code>null</code>. ",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "BlockContainer.getBlocks",
    "class_name": "org.jfree.chart.block.BlockContainer",
    "signature": "org.jfree.chart.block.BlockContainer.getBlocks()",
    "snippet": "    public List getBlocks() {\n        return Collections.unmodifiableList(this.blocks);\n    }",
    "comment": " Returns an unmodifiable list of the {@link Block} objects managed by  this arrangement.  @return A list of blocks. ",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "BlockContainer.isEmpty",
    "class_name": "org.jfree.chart.block.BlockContainer",
    "signature": "org.jfree.chart.block.BlockContainer.isEmpty()",
    "snippet": "    public boolean isEmpty() {\n        return this.blocks.isEmpty();   \n    }",
    "comment": " Returns <code>true</code> if there are no blocks in the container, and <code>false</code> otherwise.  @return A boolean. ",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "BlockContainer.setArrangement",
    "class_name": "org.jfree.chart.block.BlockContainer",
    "signature": "org.jfree.chart.block.BlockContainer.setArrangement(Arrangement)",
    "snippet": "    public void setArrangement(Arrangement arrangement) {\n        if (arrangement == null) {\n            throw new IllegalArgumentException(\"Null 'arrangement' argument.\");\n        }\n        this.arrangement = arrangement;   \n    }",
    "comment": " Sets the arrangement (layout) manager.  @param arrangement  the arrangement (<code>null</code> not permitted). ",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "BlockParams.BlockParams",
    "class_name": "org.jfree.chart.block.BlockParams",
    "signature": "org.jfree.chart.block.BlockParams.BlockParams()",
    "snippet": "    public BlockParams() {\n        this.translateX = 0.0;\n        this.translateY = 0.0;\n        this.generateEntities = false;    \n    }",
    "comment": " Creates a new instance. ",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "BlockParams.getGenerateEntities",
    "class_name": "org.jfree.chart.block.BlockParams",
    "signature": "org.jfree.chart.block.BlockParams.getGenerateEntities()",
    "snippet": "    public boolean getGenerateEntities() {\n        return this.generateEntities;   \n    }",
    "comment": " Returns the flag that controls whether or not chart entities are  generated.  @return A boolean. ",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "BlockParams.setGenerateEntities",
    "class_name": "org.jfree.chart.block.BlockParams",
    "signature": "org.jfree.chart.block.BlockParams.setGenerateEntities(boolean)",
    "snippet": "    public void setGenerateEntities(boolean generate) {\n        this.generateEntities = generate;   \n    }",
    "comment": " Sets the flag that controls whether or not chart entities are generated.  @param generate  the flag. ",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "BlockResult.BlockResult",
    "class_name": "org.jfree.chart.block.BlockResult",
    "signature": "org.jfree.chart.block.BlockResult.BlockResult()",
    "snippet": "    public BlockResult() {\n        this.entities = null;    \n    }",
    "comment": " Creates a new result instance. ",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "BorderArrangement.BorderArrangement",
    "class_name": "org.jfree.chart.block.BorderArrangement",
    "signature": "org.jfree.chart.block.BorderArrangement.BorderArrangement()",
    "snippet": "    public BorderArrangement() {\n    }",
    "comment": " Creates a new instance. ",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "BorderArrangement.add",
    "class_name": "org.jfree.chart.block.BorderArrangement",
    "signature": "org.jfree.chart.block.BorderArrangement.add(Block,Object)",
    "snippet": "    public void add(Block block, Object key) {\n        \n        if (key == null) {\n            this.centerBlock = block;\n        }\n        else {\n            RectangleEdge edge = (RectangleEdge) key;\n            if (edge == RectangleEdge.TOP) {\n                this.topBlock = block;\n            }\n            else if (edge == RectangleEdge.BOTTOM) {\n                this.bottomBlock = block;\n            }\n            else if (edge == RectangleEdge.LEFT) {\n                this.leftBlock = block;\n            }\n            else if (edge == RectangleEdge.RIGHT) {\n                this.rightBlock = block;\n            }\n        }\n    }",
    "comment": " Adds a block to the arrangement manager at the specified edge.  @param block  the block (<code>null</code> permitted). @param key  the edge (an instance of {@link RectangleEdge}) or  <code>null</code> for the center block. ",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "BorderArrangement.arrange",
    "class_name": "org.jfree.chart.block.BorderArrangement",
    "signature": "org.jfree.chart.block.BorderArrangement.arrange(BlockContainer,Graphics2D,RectangleConstraint)",
    "snippet": "    public Size2D arrange(BlockContainer container, \n                          Graphics2D g2, \n                          RectangleConstraint constraint) {\n        RectangleConstraint contentConstraint \n            = container.toContentConstraint(constraint);\n        Size2D contentSize = null;\n        LengthConstraintType w = contentConstraint.getWidthConstraintType();\n        LengthConstraintType h = contentConstraint.getHeightConstraintType();\n        if (w == LengthConstraintType.NONE) {\n            if (h == LengthConstraintType.NONE) {\n                contentSize = arrangeNN(container, g2);  \n            }\n            else if (h == LengthConstraintType.FIXED) {\n                throw new RuntimeException(\"Not implemented.\");  \n            }\n            else if (h == LengthConstraintType.RANGE) {\n                throw new RuntimeException(\"Not implemented.\");  \n            }\n        }\n        else if (w == LengthConstraintType.FIXED) {\n            if (h == LengthConstraintType.NONE) {\n                contentSize = arrangeFN(container, g2, constraint.getWidth());  \n            }\n            else if (h == LengthConstraintType.FIXED) {\n                contentSize = arrangeFF(container, g2, constraint);  \n            }\n            else if (h == LengthConstraintType.RANGE) {\n                contentSize = arrangeFR(container, g2, constraint);  \n            }\n        }\n        else if (w == LengthConstraintType.RANGE) {\n            if (h == LengthConstraintType.NONE) {\n                throw new RuntimeException(\"Not implemented.\");  \n            }\n            else if (h == LengthConstraintType.FIXED) {\n                throw new RuntimeException(\"Not implemented.\");  \n            }\n            else if (h == LengthConstraintType.RANGE) {\n                contentSize = arrangeRR(\n                    container, constraint.getWidthRange(),\n                    constraint.getHeightRange(), g2\n                );  \n            }\n        }\n        return new Size2D(\n            container.calculateTotalWidth(contentSize.getWidth()),\n            container.calculateTotalHeight(contentSize.getHeight())\n        );\n    }",
    "comment": " Arranges the items in the specified container, subject to the given  constraint.  @param container  the container. @param g2  the graphics device. @param constraint  the constraint.  @return The block size. ",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "BorderArrangement.arrangeNN",
    "class_name": "org.jfree.chart.block.BorderArrangement",
    "signature": "org.jfree.chart.block.BorderArrangement.arrangeNN(BlockContainer,Graphics2D)",
    "snippet": "    protected Size2D arrangeNN(BlockContainer container, Graphics2D g2) {\n        double[] w = new double[5];\n        double[] h = new double[5];\n        if (this.topBlock != null) {\n            Size2D size = this.topBlock.arrange(\n                g2, RectangleConstraint.NONE\n            );\n            w[0] = size.width;\n            h[0] = size.height;\n        }\n        if (this.bottomBlock != null) {\n            Size2D size = this.bottomBlock.arrange(\n                g2, RectangleConstraint.NONE\n            );\n            w[1] = size.width;\n            h[1] = size.height;\n        }\n        if (this.leftBlock != null) {\n            Size2D size = this.leftBlock.arrange(\n                g2, RectangleConstraint.NONE\n            );\n            w[2] = size.width;\n            h[2] = size.height;\n       }\n        if (this.rightBlock != null) {\n            Size2D size = this.rightBlock.arrange(\n                g2, RectangleConstraint.NONE\n            );\n            w[3] = size.width;\n            h[3] = size.height;\n        }\n        \n        h[2] = Math.max(h[2], h[3]);\n        h[3] = h[2];\n        \n        if (this.centerBlock != null) {\n            Size2D size = this.centerBlock.arrange(\n                g2, RectangleConstraint.NONE\n            );\n            w[4] = size.width;\n            h[4] = size.height;\n        }\n        double width = Math.max(w[0], Math.max(w[1], w[2] + w[4] + w[3]));\n        double centerHeight = Math.max(h[2], Math.max(h[3], h[4]));\n        double height = h[0] + h[1] + centerHeight;\n        if (this.topBlock != null) {\n            this.topBlock.setBounds(\n                new Rectangle2D.Double(0.0, 0.0, width, h[0])\n            );\n        }\n        if (this.bottomBlock != null) {\n            this.bottomBlock.setBounds(\n                new Rectangle2D.Double(0.0, height - h[1], width, h[1])\n            );\n        }\n        if (this.leftBlock != null) {\n            this.leftBlock.setBounds(\n                new Rectangle2D.Double(0.0, h[0], w[2], centerHeight)\n            );\n        }\n        if (this.rightBlock != null) {\n            this.rightBlock.setBounds(\n                new Rectangle2D.Double(width - w[3], h[0], w[3], centerHeight)\n            );\n        }\n        \n        if (this.centerBlock != null) {\n            this.centerBlock.setBounds(\n                new Rectangle2D.Double(\n                    w[2], h[0], width - w[2] - w[3], centerHeight\n                )\n            );\n        }\n        return new Size2D(width, height);\n    }",
    "comment": " Performs an arrangement without constraints.  @param container  the container. @param g2  the graphics device.  @return The container size after the arrangement. ",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "CenterArrangement.CenterArrangement",
    "class_name": "org.jfree.chart.block.CenterArrangement",
    "signature": "org.jfree.chart.block.CenterArrangement.CenterArrangement()",
    "snippet": "    public CenterArrangement() {   \n    }",
    "comment": " Creates a new instance. ",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "CenterArrangement.add",
    "class_name": "org.jfree.chart.block.CenterArrangement",
    "signature": "org.jfree.chart.block.CenterArrangement.add(Block,Object)",
    "snippet": "    public void add(Block block, Object key) {\n        // since the flow layout is relatively straightforward, \n        // no information needs to be recorded here\n    }",
    "comment": " Adds a block to be managed by this instance.  This method is usually  called by the {@link BlockContainer}, you shouldn't need to call it  directly.  @param block  the block. @param key  a key that controls the position of the block. ",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "CenterArrangement.arrange",
    "class_name": "org.jfree.chart.block.CenterArrangement",
    "signature": "org.jfree.chart.block.CenterArrangement.arrange(BlockContainer,Graphics2D,RectangleConstraint)",
    "snippet": "    public Size2D arrange(BlockContainer container, Graphics2D g2,\n                          RectangleConstraint constraint) {\n        \n        LengthConstraintType w = constraint.getWidthConstraintType();\n        LengthConstraintType h = constraint.getHeightConstraintType();\n        if (w == LengthConstraintType.NONE) {\n            if (h == LengthConstraintType.NONE) {\n                return arrangeNN(container, g2);  \n            }\n            else if (h == LengthConstraintType.FIXED) {\n                throw new RuntimeException(\"Not implemented.\");  \n            }\n            else if (h == LengthConstraintType.RANGE) {\n                throw new RuntimeException(\"Not implemented.\");  \n            }\n        }\n        else if (w == LengthConstraintType.FIXED) {\n            if (h == LengthConstraintType.NONE) {\n                return arrangeFN(container, g2, constraint);  \n            }\n            else if (h == LengthConstraintType.FIXED) {\n                throw new RuntimeException(\"Not implemented.\");  \n            }\n            else if (h == LengthConstraintType.RANGE) {\n                throw new RuntimeException(\"Not implemented.\");  \n            }\n        }\n        else if (w == LengthConstraintType.RANGE) {\n            if (h == LengthConstraintType.NONE) {\n                return arrangeRN(container, g2, constraint);  \n            }\n            else if (h == LengthConstraintType.FIXED) {\n                return arrangeRF(container, g2, constraint);  \n            }\n            else if (h == LengthConstraintType.RANGE) {\n                return arrangeRR(container, g2, constraint);   \n            }\n        }\n        throw new IllegalArgumentException(\"Unknown LengthConstraintType.\");\n        \n    }",
    "comment": " Calculates and sets the bounds of all the items in the specified  container, subject to the given constraint.  The <code>Graphics2D</code> can be used by some items (particularly items containing text) to  calculate sizing parameters.  @param container  the container whose items are being arranged. @param g2  the graphics device. @param constraint  the size constraint.  @return The size of the container after arrangement of the contents. ",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "CenterArrangement.arrangeNN",
    "class_name": "org.jfree.chart.block.CenterArrangement",
    "signature": "org.jfree.chart.block.CenterArrangement.arrangeNN(BlockContainer,Graphics2D)",
    "snippet": "    protected Size2D arrangeNN(BlockContainer container, Graphics2D g2) {\n        List blocks = container.getBlocks();\n        Block b = (Block) blocks.get(0);\n        Size2D s = b.arrange(g2, RectangleConstraint.NONE);\n        b.setBounds(new Rectangle2D.Double(0.0, 0.0, s.width, s.height));\n        return new Size2D(s.width, s.height);  \n    }",
    "comment": " Arranges the blocks without any constraints.  This puts all blocks into a single row.  @param container  the container. @param g2  the graphics device.  @return The size after the arrangement. ",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "ColumnArrangement.ColumnArrangement",
    "class_name": "org.jfree.chart.block.ColumnArrangement",
    "signature": "org.jfree.chart.block.ColumnArrangement.ColumnArrangement()",
    "snippet": "    public ColumnArrangement() {   \n    }",
    "comment": " Creates a new instance. ",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "FlowArrangement.FlowArrangement",
    "class_name": "org.jfree.chart.block.FlowArrangement",
    "signature": "org.jfree.chart.block.FlowArrangement.FlowArrangement()",
    "snippet": "    public FlowArrangement() {   \n        this(HorizontalAlignment.CENTER, VerticalAlignment.CENTER, 2.0, 2.0);\n    }",
    "comment": " Creates a new instance. ",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "FlowArrangement.FlowArrangement",
    "class_name": "org.jfree.chart.block.FlowArrangement",
    "signature": "org.jfree.chart.block.FlowArrangement.FlowArrangement(HorizontalAlignment,VerticalAlignment,double,double)",
    "snippet": "    public FlowArrangement(HorizontalAlignment hAlign, VerticalAlignment vAlign,\n                           double hGap, double vGap) {   \n        this.horizontalAlignment = hAlign;\n        this.verticalAlignment = vAlign;\n        this.horizontalGap = hGap;\n        this.verticalGap = vGap;\n    }",
    "comment": " Creates a new instance.  @param hAlign  the horizontal alignment (currently ignored). @param vAlign  the vertical alignment (currently ignored). @param hGap  the horizontal gap. @param vGap  the vertical gap. ",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "FlowArrangement.add",
    "class_name": "org.jfree.chart.block.FlowArrangement",
    "signature": "org.jfree.chart.block.FlowArrangement.add(Block,Object)",
    "snippet": "    public void add(Block block, Object key) {\n        // since the flow layout is relatively straightforward, \n        // no information needs to be recorded here\n    }",
    "comment": " Adds a block to be managed by this instance.  This method is usually  called by the {@link BlockContainer}, you shouldn't need to call it  directly.  @param block  the block. @param key  a key that controls the position of the block. ",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "FlowArrangement.arrange",
    "class_name": "org.jfree.chart.block.FlowArrangement",
    "signature": "org.jfree.chart.block.FlowArrangement.arrange(BlockContainer,Graphics2D,RectangleConstraint)",
    "snippet": "    public Size2D arrange(BlockContainer container, Graphics2D g2,\n                          RectangleConstraint constraint) {\n        \n        LengthConstraintType w = constraint.getWidthConstraintType();\n        LengthConstraintType h = constraint.getHeightConstraintType();\n        if (w == LengthConstraintType.NONE) {\n            if (h == LengthConstraintType.NONE) {\n                return arrangeNN(container, g2);  \n            }\n            else if (h == LengthConstraintType.FIXED) {\n                return arrangeNF(container, g2, constraint);  \n            }\n            else if (h == LengthConstraintType.RANGE) {\n                throw new RuntimeException(\"Not implemented.\");  \n            }\n        }\n        else if (w == LengthConstraintType.FIXED) {\n            if (h == LengthConstraintType.NONE) {\n                return arrangeFN(container, g2, constraint);  \n            }\n            else if (h == LengthConstraintType.FIXED) {\n                return arrangeFF(container, g2, constraint);  \n            }\n            else if (h == LengthConstraintType.RANGE) {\n                return arrangeFR(container, g2, constraint);  \n            }\n        }\n        else if (w == LengthConstraintType.RANGE) {\n            if (h == LengthConstraintType.NONE) {\n                return arrangeRN(container, g2, constraint);  \n            }\n            else if (h == LengthConstraintType.FIXED) {\n                return arrangeRF(container, g2, constraint);  \n            }\n            else if (h == LengthConstraintType.RANGE) {\n                return arrangeRR(container, g2, constraint);   \n            }\n        }\n        throw new RuntimeException(\"Unrecognised constraint type.\");\n        \n    }",
    "comment": " Calculates and sets the bounds of all the items in the specified  container, subject to the given constraint.  The <code>Graphics2D</code> can be used by some items (particularly items containing text) to  calculate sizing parameters.  @param container  the container whose items are being arranged. @param constraint  the size constraint. @param g2  the graphics device.  @return The size of the container after arrangement of the contents. ",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "FlowArrangement.arrangeNN",
    "class_name": "org.jfree.chart.block.FlowArrangement",
    "signature": "org.jfree.chart.block.FlowArrangement.arrangeNN(BlockContainer,Graphics2D)",
    "snippet": "    protected Size2D arrangeNN(BlockContainer container, Graphics2D g2) {\n        double x = 0.0;\n        double width = 0.0;\n        double maxHeight = 0.0;\n        List blocks = container.getBlocks();\n        int blockCount = blocks.size();\n        if (blockCount > 0) {\n            Size2D[] sizes = new Size2D[blocks.size()];\n            for (int i = 0; i < blocks.size(); i++) {\n                Block block = (Block) blocks.get(i);\n                sizes[i] = block.arrange(g2, RectangleConstraint.NONE);\n                width = width + sizes[i].getWidth();\n                maxHeight = Math.max(sizes[i].height, maxHeight);\n                block.setBounds(\n                    new Rectangle2D.Double(\n                        x, 0.0, sizes[i].width, sizes[i].height\n                    )\n                );\n                x = x + sizes[i].width + this.horizontalGap;\n            }\n            if (blockCount > 1) {\n                width = width + this.horizontalGap * (blockCount - 1);   \n            }\n            if (this.verticalAlignment != VerticalAlignment.TOP) {\n                for (int i = 0; i < blocks.size(); i++) {\n                    //Block b = (Block) blocks.get(i);\n                    if (this.verticalAlignment == VerticalAlignment.CENTER) {\n                        //TODO: shift block down by half\n                    }\n                    else if (this.verticalAlignment \n                            == VerticalAlignment.BOTTOM) {\n                        //TODO: shift block down to bottom\n                    }\n                }            \n            }\n        }\n        return new Size2D(width, maxHeight);\n    }",
    "comment": " Arranges the blocks without any constraints.  This puts all blocks into a single row.  @param container  the container. @param g2  the graphics device.  @return The size after the arrangement. ",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "FlowArrangement.arrangeRR",
    "class_name": "org.jfree.chart.block.FlowArrangement",
    "signature": "org.jfree.chart.block.FlowArrangement.arrangeRR(BlockContainer,Graphics2D,RectangleConstraint)",
    "snippet": "    protected Size2D arrangeRR(BlockContainer container, Graphics2D g2,\n                               RectangleConstraint constraint) {\n\n        // first arrange without constraints, and see if this fits within\n        // the required ranges...\n        Size2D s1 = arrangeNN(container, g2);\n        if (constraint.getWidthRange().contains(s1.width)) {\n            return s1;  // TODO: we didn't check the height yet\n        }\n        else {\n            RectangleConstraint c = constraint.toFixedWidth(\n                constraint.getWidthRange().getUpperBound()\n            );\n            return arrangeFR(container, g2, c);\n        }\n    }",
    "comment": " Arranges the blocks with the overall width and height to fit within  specified ranges.  @param container  the container. @param constraint  the constraint. @param g2  the graphics device.  @return The size after the arrangement. ",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "FlowArrangement.clear",
    "class_name": "org.jfree.chart.block.FlowArrangement",
    "signature": "org.jfree.chart.block.FlowArrangement.clear()",
    "snippet": "    public void clear() {\n        // no action required.\n    }",
    "comment": " Clears any cached information. ",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "LabelBlock.LabelBlock",
    "class_name": "org.jfree.chart.block.LabelBlock",
    "signature": "org.jfree.chart.block.LabelBlock.LabelBlock(String,Font,Paint)",
    "snippet": "    public LabelBlock(String text, Font font, Paint paint) {        \n        this.text = text;\n        this.paint = paint; \n        this.label = TextUtilities.createTextBlock(text, font, this.paint); \n        this.font = font;\n        this.toolTipText = null;\n        this.urlText = null;\n    }",
    "comment": " Creates a new label block.  @param text  the text for the label (<code>null</code> not permitted). @param font  the font (<code>null</code> not permitted). @param paint the paint (<code>null</code> not permitted). ",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "LabelBlock.arrange",
    "class_name": "org.jfree.chart.block.LabelBlock",
    "signature": "org.jfree.chart.block.LabelBlock.arrange(Graphics2D,RectangleConstraint)",
    "snippet": "    public Size2D arrange(Graphics2D g2, RectangleConstraint constraint) {\n        g2.setFont(this.font);\n        Size2D s = this.label.calculateDimensions(g2);\n        return new Size2D(calculateTotalWidth(s.getWidth()), \n                calculateTotalHeight(s.getHeight()));\n    }",
    "comment": " Arranges the contents of the block, within the given constraints, and  returns the block size.  @param g2  the graphics device. @param constraint  the constraint (<code>null</code> not permitted).  @return The block size (in Java2D units, never <code>null</code>). ",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "LabelBlock.draw",
    "class_name": "org.jfree.chart.block.LabelBlock",
    "signature": "org.jfree.chart.block.LabelBlock.draw(Graphics2D,Rectangle2D,Object)",
    "snippet": "    public Object draw(Graphics2D g2, Rectangle2D area, Object params) {\n        area = trimMargin(area);\n        drawBorder(g2, area);\n        area = trimBorder(area);\n        area = trimPadding(area);\n        \n        // check if we need to collect chart entities from the container\n        EntityBlockParams ebp = null;\n        StandardEntityCollection sec = null;\n        Shape entityArea = null;\n        if (params instanceof EntityBlockParams) {\n            ebp = (EntityBlockParams) params;\n            if (ebp.getGenerateEntities()) {\n                sec = new StandardEntityCollection();\n                entityArea = (Shape) area.clone();\n            }\n        }\n        g2.setPaint(this.paint);\n        g2.setFont(this.font);\n        this.label.draw(g2, (float) area.getX(), (float) area.getY(), \n                TextBlockAnchor.TOP_LEFT);\n        BlockResult result = null;\n        if (ebp != null && sec != null) {\n            if (this.toolTipText != null || this.urlText != null) {\n                ChartEntity entity = new ChartEntity(entityArea, \n                        this.toolTipText, this.urlText);   \n                sec.add(entity);\n                result = new BlockResult();\n                result.setEntityCollection(sec);\n            }\n        }\n        return result;\n    }",
    "comment": " Draws the block within the specified area.  @param g2  the graphics device. @param area  the area. @param params  ignored (<code>null</code> permitted).  @return Always <code>null</code>. ",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "LineBorder.LineBorder",
    "class_name": "org.jfree.chart.block.LineBorder",
    "signature": "org.jfree.chart.block.LineBorder.LineBorder()",
    "snippet": "    public LineBorder() {\n        this(Color.black, new BasicStroke(1.0f), new RectangleInsets(1.0, 1.0, \n                1.0, 1.0));\n    }",
    "comment": " Creates a default border. ",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "LineBorder.LineBorder",
    "class_name": "org.jfree.chart.block.LineBorder",
    "signature": "org.jfree.chart.block.LineBorder.LineBorder(Paint,Stroke,RectangleInsets)",
    "snippet": "    public LineBorder(Paint paint, Stroke stroke, RectangleInsets insets) {\n        if (paint == null) {\n            throw new IllegalArgumentException(\"Null 'paint' argument.\");\n        }\n        if (stroke == null) {\n            throw new IllegalArgumentException(\"Null 'stroke' argument.\");\n        }\n        if (insets == null) {\n            throw new IllegalArgumentException(\"Null 'insets' argument.\");\n        }\n        this.paint = paint;\n        this.stroke = stroke;\n        this.insets = insets;\n    }  ",
    "comment": " Creates a new border with the specified color.  @param paint  the color (<code>null</code> not permitted). @param stroke  the border stroke (<code>null</code> not permitted). @param insets  the insets (<code>null</code> not permitted). ",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "LineBorder.draw",
    "class_name": "org.jfree.chart.block.LineBorder",
    "signature": "org.jfree.chart.block.LineBorder.draw(Graphics2D,Rectangle2D)",
    "snippet": "    public void draw(Graphics2D g2, Rectangle2D area) {\n        double w = area.getWidth();\n        double h = area.getHeight();\n        // if the area has zero height or width, we shouldn't draw anything\n        if (w <= 0.0 || h <= 0.0) {\n            return;\n        }\n        double t = this.insets.calculateTopInset(h);\n        double b = this.insets.calculateBottomInset(h);\n        double l = this.insets.calculateLeftInset(w);\n        double r = this.insets.calculateRightInset(w);\n        double x = area.getX();\n        double y = area.getY();\n        double x0 = x + l / 2.0;\n        double x1 = x + w - r / 2.0;\n        double y0 = y + h - b / 2.0;\n        double y1 = y + t / 2.0;\n        g2.setPaint(getPaint());\n        g2.setStroke(getStroke());\n        Line2D line = new Line2D.Double();\n        if (t > 0.0) {\n            line.setLine(x0, y1, x1, y1);\n            g2.draw(line);\n        }\n        if (b > 0.0) {\n            line.setLine(x0, y0, x1, y0);\n            g2.draw(line);\n        }\n        if (l > 0.0) {\n            line.setLine(x0, y0, x0, y1);\n            g2.draw(line);\n        }\n        if (r > 0.0) {\n            line.setLine(x1, y0, x1, y1);\n            g2.draw(line);\n        }        \n    }    ",
    "comment": " Draws the border by filling in the reserved space (in black).  @param g2  the graphics device. @param area  the area. ",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "LineBorder.getInsets",
    "class_name": "org.jfree.chart.block.LineBorder",
    "signature": "org.jfree.chart.block.LineBorder.getInsets()",
    "snippet": "    public RectangleInsets getInsets() {\n        return this.insets;\n    }",
    "comment": " Returns the insets.  @return The insets (never <code>null</code>). ",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "LineBorder.getPaint",
    "class_name": "org.jfree.chart.block.LineBorder",
    "signature": "org.jfree.chart.block.LineBorder.getPaint()",
    "snippet": "    public Paint getPaint() {\n        return this.paint;\n    }",
    "comment": " Returns the paint.  @return The paint (never <code>null</code>). ",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "LineBorder.getStroke",
    "class_name": "org.jfree.chart.block.LineBorder",
    "signature": "org.jfree.chart.block.LineBorder.getStroke()",
    "snippet": "    public Stroke getStroke() {\n        return this.stroke;\n    }",
    "comment": " Returns the stroke.  @return The stroke (never <code>null</code>). ",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "RectangleConstraint.RectangleConstraint",
    "class_name": "org.jfree.chart.block.RectangleConstraint",
    "signature": "org.jfree.chart.block.RectangleConstraint.RectangleConstraint(double,Range,LengthConstraintType,double,Range,LengthConstraintType)",
    "snippet": "    public RectangleConstraint(double w, Range widthRange, \n                               LengthConstraintType widthConstraintType,\n                               double h, Range heightRange, \n                               LengthConstraintType heightConstraintType) {\n        if (widthConstraintType == null) {\n            throw new IllegalArgumentException(\"Null 'widthType' argument.\");\n        }\n        if (heightConstraintType == null) {\n            throw new IllegalArgumentException(\"Null 'heightType' argument.\"); \n        }\n        this.width = w;\n        this.widthRange = widthRange;\n        this.widthConstraintType = widthConstraintType;\n        this.height = h;\n        this.heightRange = heightRange;\n        this.heightConstraintType = heightConstraintType;\n    }",
    "comment": " Creates a new constraint.  @param w  the fixed or maximum width. @param widthRange  the width range. @param widthConstraintType  the width type. @param h  the fixed or maximum height. @param heightRange  the height range. @param heightConstraintType  the height type. ",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "RectangleConstraint.getHeight",
    "class_name": "org.jfree.chart.block.RectangleConstraint",
    "signature": "org.jfree.chart.block.RectangleConstraint.getHeight()",
    "snippet": "    public double getHeight() {\n        return this.height;\n    }",
    "comment": " Returns the fixed height.  @return The height. ",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "RectangleConstraint.getHeightConstraintType",
    "class_name": "org.jfree.chart.block.RectangleConstraint",
    "signature": "org.jfree.chart.block.RectangleConstraint.getHeightConstraintType()",
    "snippet": "    public LengthConstraintType getHeightConstraintType() {\n        return this.heightConstraintType;\n    }",
    "comment": " Returns the constraint type.  @return The constraint type (never <code>null</code>). ",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "RectangleConstraint.getHeightRange",
    "class_name": "org.jfree.chart.block.RectangleConstraint",
    "signature": "org.jfree.chart.block.RectangleConstraint.getHeightRange()",
    "snippet": "    public Range getHeightRange() {\n        return this.heightRange;   \n    }",
    "comment": " Returns the width range.  @return The range (possibly <code>null</code>). ",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "RectangleConstraint.getWidth",
    "class_name": "org.jfree.chart.block.RectangleConstraint",
    "signature": "org.jfree.chart.block.RectangleConstraint.getWidth()",
    "snippet": "    public double getWidth() {\n        return this.width;\n    }",
    "comment": " Returns the fixed width.  @return The width. ",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "RectangleConstraint.getWidthConstraintType",
    "class_name": "org.jfree.chart.block.RectangleConstraint",
    "signature": "org.jfree.chart.block.RectangleConstraint.getWidthConstraintType()",
    "snippet": "    public LengthConstraintType getWidthConstraintType() {\n        return this.widthConstraintType;\n    }",
    "comment": " Returns the constraint type.  @return The constraint type (never <code>null</code>). ",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "RectangleConstraint.getWidthRange",
    "class_name": "org.jfree.chart.block.RectangleConstraint",
    "signature": "org.jfree.chart.block.RectangleConstraint.getWidthRange()",
    "snippet": "    public Range getWidthRange() {\n        return this.widthRange;   \n    }",
    "comment": " Returns the width range.  @return The range (possibly <code>null</code>). ",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "AxisChangeEvent.AxisChangeEvent",
    "class_name": "org.jfree.chart.event.AxisChangeEvent",
    "signature": "org.jfree.chart.event.AxisChangeEvent.AxisChangeEvent(Axis)",
    "snippet": "    public AxisChangeEvent(Axis axis) {\n        super(axis);\n        this.axis = axis;\n    }",
    "comment": " Creates a new AxisChangeEvent.  @param axis  the axis that generated the event. ",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "ChartChangeEvent.ChartChangeEvent",
    "class_name": "org.jfree.chart.event.ChartChangeEvent",
    "signature": "org.jfree.chart.event.ChartChangeEvent.ChartChangeEvent(Object)",
    "snippet": "    public ChartChangeEvent(Object source) {\n        this(source, null, ChartChangeEventType.GENERAL);\n    }",
    "comment": " Creates a new chart change event.  @param source  the source of the event (could be the chart, a title,  an axis etc.) ",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "ChartChangeEvent.ChartChangeEvent",
    "class_name": "org.jfree.chart.event.ChartChangeEvent",
    "signature": "org.jfree.chart.event.ChartChangeEvent.ChartChangeEvent(Object,JFreeChart,ChartChangeEventType)",
    "snippet": "    public ChartChangeEvent(Object source, JFreeChart chart, \n                            ChartChangeEventType type) {\n        super(source);\n        this.chart = chart;\n        this.type = type;\n    }",
    "comment": " Creates a new chart change event.  @param source  the source of the event (could be the chart, a title, an axis etc.) @param chart  the chart that generated the event. @param type  the type of event. ",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "ChartChangeEvent.setType",
    "class_name": "org.jfree.chart.event.ChartChangeEvent",
    "signature": "org.jfree.chart.event.ChartChangeEvent.setType(ChartChangeEventType)",
    "snippet": "    public void setType(ChartChangeEventType type) {\n        this.type = type;\n    }",
    "comment": " Sets the event type.  @param type  the event type. ",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "ChartProgressEvent.ChartProgressEvent",
    "class_name": "org.jfree.chart.event.ChartProgressEvent",
    "signature": "org.jfree.chart.event.ChartProgressEvent.ChartProgressEvent(Object,JFreeChart,int,int)",
    "snippet": "    public ChartProgressEvent(Object source, JFreeChart chart, int type, \n                              int percent) {\n        super(source);\n        this.chart = chart;\n        this.type = type;\n    }",
    "comment": " Creates a new chart change event.  @param source  the source of the event (could be the chart, a title, an  axis etc.) @param chart  the chart that generated the event. @param type  the type of event. @param percent  the percentage of completion. ",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "PlotChangeEvent.PlotChangeEvent",
    "class_name": "org.jfree.chart.event.PlotChangeEvent",
    "signature": "org.jfree.chart.event.PlotChangeEvent.PlotChangeEvent(Plot)",
    "snippet": "    public PlotChangeEvent(Plot plot) {\n        super(plot);\n        this.plot = plot;\n    }",
    "comment": " Creates a new PlotChangeEvent.  @param plot  the plot that generated the event. ",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "TitleChangeEvent.TitleChangeEvent",
    "class_name": "org.jfree.chart.event.TitleChangeEvent",
    "signature": "org.jfree.chart.event.TitleChangeEvent.TitleChangeEvent(Title)",
    "snippet": "    public TitleChangeEvent(Title title) {\n        super(title);\n        this.title = title;\n    }",
    "comment": " Default constructor.  @param title  the chart title that generated the event. ",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "ItemLabelPosition.ItemLabelPosition",
    "class_name": "org.jfree.chart.labels.ItemLabelPosition",
    "signature": "org.jfree.chart.labels.ItemLabelPosition.ItemLabelPosition(ItemLabelAnchor,TextAnchor)",
    "snippet": "    public ItemLabelPosition(ItemLabelAnchor itemLabelAnchor, \n                             TextAnchor textAnchor) {\n        this(itemLabelAnchor, textAnchor, TextAnchor.CENTER, 0.0);    \n    }",
    "comment": " Creates a new position record (with zero rotation).  @param itemLabelAnchor  the item label anchor (<code>null</code> not  permitted). @param textAnchor  the text anchor (<code>null</code> not permitted). ",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "ItemLabelPosition.ItemLabelPosition",
    "class_name": "org.jfree.chart.labels.ItemLabelPosition",
    "signature": "org.jfree.chart.labels.ItemLabelPosition.ItemLabelPosition(ItemLabelAnchor,TextAnchor,TextAnchor,double)",
    "snippet": "    public ItemLabelPosition(ItemLabelAnchor itemLabelAnchor, \n                             TextAnchor textAnchor,\n                             TextAnchor rotationAnchor,\n                             double angle) {\n              \n        if (itemLabelAnchor == null) {\n            throw new IllegalArgumentException(\n                    \"Null 'itemLabelAnchor' argument.\");\n        }\n        if (textAnchor == null) {\n            throw new IllegalArgumentException(\"Null 'textAnchor' argument.\");\n        }\n        if (rotationAnchor == null) {\n            throw new IllegalArgumentException(\n                    \"Null 'rotationAnchor' argument.\");\n        }\n        \n        this.itemLabelAnchor = itemLabelAnchor;\n        this.textAnchor = textAnchor;\n        this.rotationAnchor = rotationAnchor;\n        this.angle = angle;\n    \n    }",
    "comment": " Creates a new position record.  The item label anchor is a point  relative to the data item (dot, bar or other visual item) on a chart.   The item label is aligned by aligning the text anchor with the  item label anchor.  @param itemLabelAnchor  the item label anchor (<code>null</code> not  permitted). @param textAnchor  the text anchor (<code>null</code> not permitted). @param rotationAnchor  the rotation anchor (<code>null</code> not  permitted). @param angle  the rotation angle (in radians). ",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "StandardCategorySeriesLabelGenerator.StandardCategorySeriesLabelGenerator",
    "class_name": "org.jfree.chart.labels.StandardCategorySeriesLabelGenerator",
    "signature": "org.jfree.chart.labels.StandardCategorySeriesLabelGenerator.StandardCategorySeriesLabelGenerator()",
    "snippet": "    public StandardCategorySeriesLabelGenerator() {\n        this(DEFAULT_LABEL_FORMAT);\n    }",
    "comment": " Creates a default series label generator (uses  {@link #DEFAULT_LABEL_FORMAT}). ",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "StandardCategorySeriesLabelGenerator.StandardCategorySeriesLabelGenerator",
    "class_name": "org.jfree.chart.labels.StandardCategorySeriesLabelGenerator",
    "signature": "org.jfree.chart.labels.StandardCategorySeriesLabelGenerator.StandardCategorySeriesLabelGenerator(String)",
    "snippet": "    public StandardCategorySeriesLabelGenerator(String format) {\n        if (format == null) {\n            throw new IllegalArgumentException(\"Null 'format' argument.\");\n        }\n        this.formatPattern = format;\n    }",
    "comment": " Creates a new series label generator.  @param format  the format pattern (<code>null</code> not permitted). ",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "StandardCategorySeriesLabelGenerator.createItemArray",
    "class_name": "org.jfree.chart.labels.StandardCategorySeriesLabelGenerator",
    "signature": "org.jfree.chart.labels.StandardCategorySeriesLabelGenerator.createItemArray(CategoryDataset,int)",
    "snippet": "    protected Object[] createItemArray(CategoryDataset dataset, int series) {\n        Object[] result = new Object[1];\n        result[0] = dataset.getRowKey(series).toString();\n        return result;\n    }",
    "comment": " Creates the array of items that can be passed to the  {@link MessageFormat} class for creating labels.  @param dataset  the dataset (<code>null</code> not permitted). @param series  the series (zero-based index).  @return The items (never <code>null</code>). ",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "StandardCategorySeriesLabelGenerator.generateLabel",
    "class_name": "org.jfree.chart.labels.StandardCategorySeriesLabelGenerator",
    "signature": "org.jfree.chart.labels.StandardCategorySeriesLabelGenerator.generateLabel(CategoryDataset,int)",
    "snippet": "    public String generateLabel(CategoryDataset dataset, int series) {\n        if (dataset == null) {\n            throw new IllegalArgumentException(\"Null 'dataset' argument.\");\n        }\n        String label = MessageFormat.format(this.formatPattern, \n                createItemArray(dataset, series));\n        return label;\n    }",
    "comment": " Generates a label for the specified series.  @param dataset  the dataset (<code>null</code> not permitted). @param series  the series.  @return A series label. ",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "CategoryPlot.CategoryPlot",
    "class_name": "org.jfree.chart.plot.CategoryPlot",
    "signature": "org.jfree.chart.plot.CategoryPlot.CategoryPlot(CategoryDataset,CategoryAxis,ValueAxis,CategoryItemRenderer)",
    "snippet": "    public CategoryPlot(CategoryDataset dataset,\n                        CategoryAxis domainAxis,\n                        ValueAxis rangeAxis,\n                        CategoryItemRenderer renderer) {\n\n        super();\n\n        this.orientation = PlotOrientation.VERTICAL;\n\n        // allocate storage for dataset, axes and renderers\n        this.domainAxes = new ObjectList();\n        this.domainAxisLocations = new ObjectList();\n        this.rangeAxes = new ObjectList();\n        this.rangeAxisLocations = new ObjectList();\n        \n        this.datasetToDomainAxisMap = new ObjectList();\n        this.datasetToRangeAxisMap = new ObjectList();\n\n        this.renderers = new ObjectList();\n\n        this.datasets = new ObjectList();\n        this.datasets.set(0, dataset);\n        if (dataset != null) {\n            dataset.addChangeListener(this);\n        }\n\n        this.axisOffset = new RectangleInsets(4.0, 4.0, 4.0, 4.0);\n\n        setDomainAxisLocation(AxisLocation.BOTTOM_OR_LEFT, false);\n        setRangeAxisLocation(AxisLocation.TOP_OR_LEFT, false);\n\n        this.renderers.set(0, renderer);\n        if (renderer != null) {\n            renderer.setPlot(this);\n            renderer.addChangeListener(this);\n        }\n\n        this.domainAxes.set(0, domainAxis);\n        this.mapDatasetToDomainAxis(0, 0);\n        if (domainAxis != null) {\n            domainAxis.setPlot(this);\n            domainAxis.addChangeListener(this);\n        }\n        this.drawSharedDomainAxis = false;\n\n        this.rangeAxes.set(0, rangeAxis);\n        this.mapDatasetToRangeAxis(0, 0);\n        if (rangeAxis != null) {\n            rangeAxis.setPlot(this);\n            rangeAxis.addChangeListener(this);\n        }\n        \n        configureDomainAxes();\n        configureRangeAxes();\n\n        this.domainGridlinesVisible = DEFAULT_DOMAIN_GRIDLINES_VISIBLE;\n        this.domainGridlinePosition = CategoryAnchor.MIDDLE;\n        this.domainGridlineStroke = DEFAULT_GRIDLINE_STROKE;\n        this.domainGridlinePaint = DEFAULT_GRIDLINE_PAINT;\n\n        this.rangeGridlinesVisible = DEFAULT_RANGE_GRIDLINES_VISIBLE;\n        this.rangeGridlineStroke = DEFAULT_GRIDLINE_STROKE;\n        this.rangeGridlinePaint = DEFAULT_GRIDLINE_PAINT;\n\n        this.foregroundDomainMarkers = new HashMap();\n        this.backgroundDomainMarkers = new HashMap();\n        this.foregroundRangeMarkers = new HashMap();\n        this.backgroundRangeMarkers = new HashMap();\n\n        Marker baseline = new ValueMarker(0.0, new Color(0.8f, 0.8f, 0.8f, \n                0.5f), new BasicStroke(1.0f), new Color(0.85f, 0.85f, 0.95f, \n                0.5f), new BasicStroke(1.0f), 0.6f);\n        addRangeMarker(baseline, Layer.BACKGROUND);\n\n        this.anchorValue = 0.0;\n\n        this.rangeCrosshairVisible = DEFAULT_CROSSHAIR_VISIBLE;\n        this.rangeCrosshairValue = 0.0;\n        this.rangeCrosshairStroke = DEFAULT_CROSSHAIR_STROKE;\n        this.rangeCrosshairPaint = DEFAULT_CROSSHAIR_PAINT;\n        \n        this.annotations = new java.util.ArrayList();\n\n    }",
    "comment": " Creates a new plot.  @param dataset  the dataset (<code>null</code> permitted). @param domainAxis  the domain axis (<code>null</code> permitted). @param rangeAxis  the range axis (<code>null</code> permitted). @param renderer  the item renderer (<code>null</code> permitted).  ",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "CategoryPlot.addRangeMarker",
    "class_name": "org.jfree.chart.plot.CategoryPlot",
    "signature": "org.jfree.chart.plot.CategoryPlot.addRangeMarker(Marker,Layer)",
    "snippet": "    public void addRangeMarker(Marker marker, Layer layer) {\n        addRangeMarker(0, marker, layer);\n    }",
    "comment": " Adds a marker for display against the range axis and sends a  {@link PlotChangeEvent} to all registered listeners.  Typically a marker  will be drawn by the renderer as a line perpendicular to the range axis,  however this is entirely up to the renderer.  @param marker  the marker (<code>null</code> not permitted). @param layer  the layer (foreground or background) (<code>null</code>  not permitted). ",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "CategoryPlot.addRangeMarker",
    "class_name": "org.jfree.chart.plot.CategoryPlot",
    "signature": "org.jfree.chart.plot.CategoryPlot.addRangeMarker(int,Marker,Layer)",
    "snippet": "    public void addRangeMarker(int index, Marker marker, Layer layer) {\n        Collection markers;\n        if (layer == Layer.FOREGROUND) {\n            markers = (Collection) this.foregroundRangeMarkers.get(\n                    new Integer(index));\n            if (markers == null) {\n                markers = new java.util.ArrayList();\n                this.foregroundRangeMarkers.put(new Integer(index), markers);\n            }\n            markers.add(marker);\n        }\n        else if (layer == Layer.BACKGROUND) {\n            markers = (Collection) this.backgroundRangeMarkers.get(\n                    new Integer(index));\n            if (markers == null) {\n                markers = new java.util.ArrayList();\n                this.backgroundRangeMarkers.put(new Integer(index), markers);\n            }\n            markers.add(marker);            \n        }\n        marker.addChangeListener(this);\n        notifyListeners(new PlotChangeEvent(this));\n    }",
    "comment": " Adds a marker for display by a particular renderer. <P> Typically a marker will be drawn by the renderer as a line perpendicular to a range axis, however this is entirely up to the renderer.  @param index  the renderer index. @param marker  the marker. @param layer  the layer. ",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "CategoryPlot.calculateAxisSpace",
    "class_name": "org.jfree.chart.plot.CategoryPlot",
    "signature": "org.jfree.chart.plot.CategoryPlot.calculateAxisSpace(Graphics2D,Rectangle2D)",
    "snippet": "    protected AxisSpace calculateAxisSpace(Graphics2D g2, \n                                           Rectangle2D plotArea) {\n        AxisSpace space = new AxisSpace();\n        space = calculateRangeAxisSpace(g2, plotArea, space);\n        space = calculateDomainAxisSpace(g2, plotArea, space);\n        return space;\n    }",
    "comment": " Calculates the space required for the axes.  @param g2  the graphics device. @param plotArea  the plot area.  @return The space required for the axes. ",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "CategoryPlot.calculateDomainAxisSpace",
    "class_name": "org.jfree.chart.plot.CategoryPlot",
    "signature": "org.jfree.chart.plot.CategoryPlot.calculateDomainAxisSpace(Graphics2D,Rectangle2D,AxisSpace)",
    "snippet": "    protected AxisSpace calculateDomainAxisSpace(Graphics2D g2, \n                                                 Rectangle2D plotArea, \n                                                 AxisSpace space) {\n                                                     \n        if (space == null) {\n            space = new AxisSpace();\n        }\n        \n        // reserve some space for the domain axis...\n        if (this.fixedDomainAxisSpace != null) {\n            if (this.orientation == PlotOrientation.HORIZONTAL) {\n                space.ensureAtLeast(\n                    this.fixedDomainAxisSpace.getLeft(), RectangleEdge.LEFT);\n                space.ensureAtLeast(this.fixedDomainAxisSpace.getRight(), \n                        RectangleEdge.RIGHT);\n            }\n            else if (this.orientation == PlotOrientation.VERTICAL) {\n                space.ensureAtLeast(this.fixedDomainAxisSpace.getTop(), \n                        RectangleEdge.TOP);\n                space.ensureAtLeast(this.fixedDomainAxisSpace.getBottom(), \n                        RectangleEdge.BOTTOM);\n            }\n        }\n        else {\n            // reserve space for the primary domain axis...\n            RectangleEdge domainEdge = Plot.resolveDomainAxisLocation(\n                    getDomainAxisLocation(), this.orientation);\n            if (this.drawSharedDomainAxis) {\n                space = getDomainAxis().reserveSpace(g2, this, plotArea, \n                        domainEdge, space);\n            }\n            \n            // reserve space for any domain axes...\n            for (int i = 0; i < this.domainAxes.size(); i++) {\n                Axis xAxis = (Axis) this.domainAxes.get(i);\n                if (xAxis != null) {\n                    RectangleEdge edge = getDomainAxisEdge(i);\n                    space = xAxis.reserveSpace(g2, this, plotArea, edge, space);\n                }\n            }\n        }\n\n        return space;\n                                                     \n    }",
    "comment": " Calculates the space required for the domain axis/axes.  @param g2  the graphics device. @param plotArea  the plot area. @param space  a carrier for the result (<code>null</code> permitted).  @return The required space. ",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "CategoryPlot.calculateRangeAxisSpace",
    "class_name": "org.jfree.chart.plot.CategoryPlot",
    "signature": "org.jfree.chart.plot.CategoryPlot.calculateRangeAxisSpace(Graphics2D,Rectangle2D,AxisSpace)",
    "snippet": "    protected AxisSpace calculateRangeAxisSpace(Graphics2D g2, \n                                                Rectangle2D plotArea, \n                                                AxisSpace space) {\n                                                  \n        if (space == null) {\n            space = new AxisSpace(); \n        }\n        \n        // reserve some space for the range axis...\n        if (this.fixedRangeAxisSpace != null) {\n            if (this.orientation == PlotOrientation.HORIZONTAL) {\n                space.ensureAtLeast(this.fixedRangeAxisSpace.getTop(), \n                        RectangleEdge.TOP);\n                space.ensureAtLeast(this.fixedRangeAxisSpace.getBottom(), \n                        RectangleEdge.BOTTOM);\n            }\n            else if (this.orientation == PlotOrientation.VERTICAL) {\n                space.ensureAtLeast(this.fixedRangeAxisSpace.getLeft(), \n                        RectangleEdge.LEFT);\n                space.ensureAtLeast(this.fixedRangeAxisSpace.getRight(), \n                        RectangleEdge.RIGHT);\n            }\n        }\n        else {\n            // reserve space for the range axes (if any)...\n            for (int i = 0; i < this.rangeAxes.size(); i++) {\n                Axis yAxis = (Axis) this.rangeAxes.get(i);\n                if (yAxis != null) {\n                    RectangleEdge edge = getRangeAxisEdge(i);\n                    space = yAxis.reserveSpace(g2, this, plotArea, edge, space);\n                }\n            }\n        }\n        return space;\n                                                    \n    }",
    "comment": " Calculates the space required for the range axis/axes.  @param g2  the graphics device. @param plotArea  the plot area. @param space  a carrier for the result (<code>null</code> permitted).  @return The required space. ",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "CategoryPlot.configureDomainAxes",
    "class_name": "org.jfree.chart.plot.CategoryPlot",
    "signature": "org.jfree.chart.plot.CategoryPlot.configureDomainAxes()",
    "snippet": "    public void configureDomainAxes() {\n        for (int i = 0; i < this.domainAxes.size(); i++) {\n            CategoryAxis axis = (CategoryAxis) this.domainAxes.get(i);\n            if (axis != null) {\n                axis.configure();\n            }\n        }\n    }",
    "comment": " Configures the domain axes. ",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "CategoryPlot.configureRangeAxes",
    "class_name": "org.jfree.chart.plot.CategoryPlot",
    "signature": "org.jfree.chart.plot.CategoryPlot.configureRangeAxes()",
    "snippet": "    public void configureRangeAxes() {\n        for (int i = 0; i < this.rangeAxes.size(); i++) {\n            ValueAxis axis = (ValueAxis) this.rangeAxes.get(i);\n            if (axis != null) {\n                axis.configure();\n            }\n        }\n    }",
    "comment": " Configures the range axes. ",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "CategoryPlot.datasetChanged",
    "class_name": "org.jfree.chart.plot.CategoryPlot",
    "signature": "org.jfree.chart.plot.CategoryPlot.datasetChanged(DatasetChangeEvent)",
    "snippet": "    public void datasetChanged(DatasetChangeEvent event) {\n\n        int count = this.rangeAxes.size();\n        for (int axisIndex = 0; axisIndex < count; axisIndex++) {\n            ValueAxis yAxis = getRangeAxis(axisIndex);\n            if (yAxis != null) {\n                yAxis.configure();\n            }\n        }\n        if (getParent() != null) {\n            getParent().datasetChanged(event);\n        }\n        else {\n            PlotChangeEvent e = new PlotChangeEvent(this);\n            e.setType(ChartChangeEventType.DATASET_UPDATED);\n            notifyListeners(e);\n        }\n\n    }",
    "comment": " Receives notification of a change to the plot's dataset. <P> The range axis bounds will be recalculated if necessary.  @param event  information about the event (not used here). ",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "CategoryPlot.datasetsMappedToDomainAxis",
    "class_name": "org.jfree.chart.plot.CategoryPlot",
    "signature": "org.jfree.chart.plot.CategoryPlot.datasetsMappedToDomainAxis(int)",
    "snippet": "    private List datasetsMappedToDomainAxis(int axisIndex) {\n        List result = new ArrayList();\n        for (int datasetIndex = 0; datasetIndex < this.datasets.size(); \n                datasetIndex++) {\n            Object dataset = this.datasets.get(datasetIndex);\n            if (dataset != null) {\n                Integer m = (Integer) this.datasetToDomainAxisMap.get(\n                        datasetIndex);\n                if (m == null) {  // a dataset with no mapping is assigned to \n                                  // axis 0\n                    if (axisIndex == 0) {\n                        result.add(dataset);\n                    }\n                }\n                else {\n                    if (m.intValue() == axisIndex) {\n                        result.add(dataset);\n                    }\n                }\n            }\n        }\n        return result;\n    }",
    "comment": " Returns a list of the datasets that are mapped to the axis with the specified index.  @param axisIndex  the axis index.  @return The list (possibly empty, but never <code>null</code>).  @since 1.0.3 ",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "CategoryPlot.datasetsMappedToRangeAxis",
    "class_name": "org.jfree.chart.plot.CategoryPlot",
    "signature": "org.jfree.chart.plot.CategoryPlot.datasetsMappedToRangeAxis(int)",
    "snippet": "    private List datasetsMappedToRangeAxis(int index) {\n        List result = new ArrayList();\n        for (int i = 0; i < this.datasets.size(); i++) {\n            Object dataset = this.datasets.get(i);\n            if (dataset != null) {\n                Integer m = (Integer) this.datasetToRangeAxisMap.get(i);\n                if (m == null) {  // a dataset with no mapping is assigned to \n                                  // axis 0\n                    if (index == 0) { \n                        result.add(dataset);\n                    }\n                }\n                else {\n                    if (m.intValue() == index) {\n                        result.add(dataset);\n                    }\n                }\n            }\n        }\n        return result;    \n    }",
    "comment": " A utility method that returns a list of datasets that are mapped to a  given range axis.  @param index  the axis index.  @return A list of datasets. ",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "CategoryPlot.draw",
    "class_name": "org.jfree.chart.plot.CategoryPlot",
    "signature": "org.jfree.chart.plot.CategoryPlot.draw(Graphics2D,Rectangle2D,Point2D,PlotState,PlotRenderingInfo)",
    "snippet": "    public void draw(Graphics2D g2, Rectangle2D area, \n                     Point2D anchor,\n                     PlotState parentState,\n                     PlotRenderingInfo state) {\n\n        // if the plot area is too small, just return...\n        boolean b1 = (area.getWidth() <= MINIMUM_WIDTH_TO_DRAW);\n        boolean b2 = (area.getHeight() <= MINIMUM_HEIGHT_TO_DRAW);\n        if (b1 || b2) {\n            return;\n        }\n\n        // record the plot area...\n        if (state == null) {\n            // if the incoming state is null, no information will be passed\n            // back to the caller - but we create a temporary state to record\n            // the plot area, since that is used later by the axes\n            state = new PlotRenderingInfo(null);\n        }\n        state.setPlotArea(area);\n\n        // adjust the drawing area for the plot insets (if any)...\n        RectangleInsets insets = getInsets();\n        insets.trim(area);\n\n        // calculate the data area...\n        AxisSpace space = calculateAxisSpace(g2, area);\n        Rectangle2D dataArea = space.shrink(area, null);\n        this.axisOffset.trim(dataArea);\n\n        state.setDataArea(dataArea);\n\n        // if there is a renderer, it draws the background, otherwise use the \n        // default background...\n        if (getRenderer() != null) {\n            getRenderer().drawBackground(g2, this, dataArea);\n        }\n        else {\n            drawBackground(g2, dataArea);\n        }\n       \n        Map axisStateMap = drawAxes(g2, area, dataArea, state);\n\n        // don't let anyone draw outside the data area\n        Shape savedClip = g2.getClip();\n        g2.clip(dataArea);\n\n        drawDomainGridlines(g2, dataArea);\n\n        AxisState rangeAxisState = (AxisState) axisStateMap.get(getRangeAxis());\n        if (rangeAxisState == null) {\n            if (parentState != null) {\n                rangeAxisState = (AxisState) parentState.getSharedAxisStates()\n                        .get(getRangeAxis());\n            }\n        }\n        if (rangeAxisState != null) {\n            drawRangeGridlines(g2, dataArea, rangeAxisState.getTicks());\n        }\n        \n        // draw the markers...\n        for (int i = 0; i < this.renderers.size(); i++) {\n            drawDomainMarkers(g2, dataArea, i, Layer.BACKGROUND);\n        }        \n        for (int i = 0; i < this.renderers.size(); i++) {\n            drawRangeMarkers(g2, dataArea, i, Layer.BACKGROUND);\n        }\n\n        // now render data items...\n        boolean foundData = false;\n\n        // set up the alpha-transparency...\n        Composite originalComposite = g2.getComposite();\n        g2.setComposite(AlphaComposite.getInstance(\n                AlphaComposite.SRC_OVER, getForegroundAlpha()));\n\n        DatasetRenderingOrder order = getDatasetRenderingOrder();\n        if (order == DatasetRenderingOrder.FORWARD) {\n\n            // draw background annotations\n            int datasetCount = this.datasets.size();\n            for (int i = 0; i < datasetCount; i++) {\n                CategoryItemRenderer r = getRenderer(i);\n                if (r != null) {\n                    CategoryAxis domainAxis = getDomainAxisForDataset(i);\n                    ValueAxis rangeAxis = getRangeAxisForDataset(i);\n                    r.drawAnnotations(g2, dataArea, domainAxis, rangeAxis,\n                            Layer.BACKGROUND, state);\n                }\n            }\n\n            for (int i = 0; i < datasetCount; i++) {\n                foundData = render(g2, dataArea, i, state) || foundData;\n            }\n\n            // draw foreground annotations\n            for (int i = 0; i < datasetCount; i++) {\n                CategoryItemRenderer r = getRenderer(i);\n                if (r != null) {\n                    CategoryAxis domainAxis = getDomainAxisForDataset(i);\n                    ValueAxis rangeAxis = getRangeAxisForDataset(i);\n                    r.drawAnnotations(g2, dataArea, domainAxis, rangeAxis,\n                            Layer.FOREGROUND, state);\n                }\n            }\n        }\n        else {  // DatasetRenderingOrder.REVERSE\n            \n            // draw background annotations\n            int datasetCount = this.datasets.size();\n            for (int i = datasetCount - 1; i >= 0; i--) {\n                CategoryItemRenderer r = getRenderer(i);\n                if (r != null) {\n                    CategoryAxis domainAxis = getDomainAxisForDataset(i);\n                    ValueAxis rangeAxis = getRangeAxisForDataset(i);\n                    r.drawAnnotations(g2, dataArea, domainAxis, rangeAxis,\n                            Layer.BACKGROUND, state);\n                }\n            }\n            \n            for (int i = this.datasets.size() - 1; i >= 0; i--) {\n                foundData = render(g2, dataArea, i, state) || foundData;   \n            }\n\n            // draw foreground annotations\n            for (int i = datasetCount - 1; i >= 0; i--) {\n                CategoryItemRenderer r = getRenderer(i);\n                if (r != null) {\n                    CategoryAxis domainAxis = getDomainAxisForDataset(i);\n                    ValueAxis rangeAxis = getRangeAxisForDataset(i);\n                    r.drawAnnotations(g2, dataArea, domainAxis, rangeAxis,\n                            Layer.FOREGROUND, state);\n                }\n            }\n        }\n        \n        // draw the foreground markers...\n        for (int i = 0; i < this.renderers.size(); i++) {\n            drawDomainMarkers(g2, dataArea, i, Layer.FOREGROUND);\n        }\n        for (int i = 0; i < this.renderers.size(); i++) {\n            drawRangeMarkers(g2, dataArea, i, Layer.FOREGROUND);\n        }\n\n        // draw the plot's annotations (if any)...\n        drawAnnotations(g2, dataArea, state);\n\n        g2.setClip(savedClip);\n        g2.setComposite(originalComposite);\n\n        if (!foundData) {\n            drawNoDataMessage(g2, dataArea);\n        }\n\n        // draw range crosshair if required...\n        if (isRangeCrosshairVisible()) {\n            // FIXME: this doesn't handle multiple range axes\n            drawRangeCrosshair(g2, dataArea, getOrientation(), \n                    getRangeCrosshairValue(), getRangeAxis(),\n                    getRangeCrosshairStroke(), getRangeCrosshairPaint());\n        }\n\n        // draw an outline around the plot area...\n        if (getRenderer() != null) {\n            getRenderer().drawOutline(g2, this, dataArea);\n        }\n        else {\n            drawOutline(g2, dataArea);\n        }\n\n    }",
    "comment": " Draws the plot on a Java 2D graphics device (such as the screen or a  printer). <P> At your option, you may supply an instance of {@link PlotRenderingInfo}. If you do, it will be populated with information about the drawing, including various plot dimensions and tooltip info.  @param g2  the graphics device. @param area  the area within which the plot (including axes) should  be drawn. @param anchor  the anchor point (<code>null</code> permitted). @param parentState  the state from the parent plot, if there is one. @param state  collects info as the chart is drawn (possibly  <code>null</code>). ",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "CategoryPlot.drawAxes",
    "class_name": "org.jfree.chart.plot.CategoryPlot",
    "signature": "org.jfree.chart.plot.CategoryPlot.drawAxes(Graphics2D,Rectangle2D,Rectangle2D,PlotRenderingInfo)",
    "snippet": "    protected Map drawAxes(Graphics2D g2, \n                           Rectangle2D plotArea, \n                           Rectangle2D dataArea,\n                           PlotRenderingInfo plotState) {\n\n        AxisCollection axisCollection = new AxisCollection();\n\n        // add domain axes to lists...\n        for (int index = 0; index < this.domainAxes.size(); index++) {\n            CategoryAxis xAxis = (CategoryAxis) this.domainAxes.get(index);\n            if (xAxis != null) {\n                axisCollection.add(xAxis, getDomainAxisEdge(index));\n            }\n        }\n\n        // add range axes to lists...\n        for (int index = 0; index < this.rangeAxes.size(); index++) {\n            ValueAxis yAxis = (ValueAxis) this.rangeAxes.get(index);\n            if (yAxis != null) {\n                axisCollection.add(yAxis, getRangeAxisEdge(index));\n            }\n        }\n\n        Map axisStateMap = new HashMap();\n        \n        // draw the top axes\n        double cursor = dataArea.getMinY() - this.axisOffset.calculateTopOutset(\n                dataArea.getHeight());\n        Iterator iterator = axisCollection.getAxesAtTop().iterator();\n        while (iterator.hasNext()) {\n            Axis axis = (Axis) iterator.next();\n            if (axis != null) {\n                AxisState axisState = axis.draw(g2, cursor, plotArea, dataArea, \n                        RectangleEdge.TOP, plotState);\n                cursor = axisState.getCursor();\n                axisStateMap.put(axis, axisState);\n            }\n        }\n\n        // draw the bottom axes\n        cursor = dataArea.getMaxY() \n                 + this.axisOffset.calculateBottomOutset(dataArea.getHeight());\n        iterator = axisCollection.getAxesAtBottom().iterator();\n        while (iterator.hasNext()) {\n            Axis axis = (Axis) iterator.next();\n            if (axis != null) {\n                AxisState axisState = axis.draw(g2, cursor, plotArea, dataArea,\n                        RectangleEdge.BOTTOM, plotState);\n                cursor = axisState.getCursor();\n                axisStateMap.put(axis, axisState);\n            }\n        }\n\n        // draw the left axes\n        cursor = dataArea.getMinX() \n                 - this.axisOffset.calculateLeftOutset(dataArea.getWidth());\n        iterator = axisCollection.getAxesAtLeft().iterator();\n        while (iterator.hasNext()) {\n            Axis axis = (Axis) iterator.next();\n            if (axis != null) {\n                AxisState axisState = axis.draw(g2, cursor, plotArea, dataArea,\n                        RectangleEdge.LEFT, plotState);\n                cursor = axisState.getCursor();\n                axisStateMap.put(axis, axisState);\n            }\n        }\n\n        // draw the right axes\n        cursor = dataArea.getMaxX() \n                 + this.axisOffset.calculateRightOutset(dataArea.getWidth());\n        iterator = axisCollection.getAxesAtRight().iterator();\n        while (iterator.hasNext()) {\n            Axis axis = (Axis) iterator.next();\n            if (axis != null) {\n                AxisState axisState = axis.draw(g2, cursor, plotArea, dataArea, \n                        RectangleEdge.RIGHT, plotState);\n                cursor = axisState.getCursor();\n                axisStateMap.put(axis, axisState);\n            }\n        }\n        \n        return axisStateMap;\n        \n    }",
    "comment": " A utility method for drawing the plot's axes.  @param g2  the graphics device. @param plotArea  the plot area. @param dataArea  the data area. @param plotState  collects information about the plot (<code>null</code> permitted).  @return A map containing the axis states. ",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "CategoryPlot.drawBackground",
    "class_name": "org.jfree.chart.plot.CategoryPlot",
    "signature": "org.jfree.chart.plot.CategoryPlot.drawBackground(Graphics2D,Rectangle2D)",
    "snippet": "    public void drawBackground(Graphics2D g2, Rectangle2D area) {\n        fillBackground(g2, area, this.orientation);\n        drawBackgroundImage(g2, area);\n    }",
    "comment": " Draws the plot background (the background color and/or image). <P> This method will be called during the chart drawing process and is  declared public so that it can be accessed by the renderers used by  certain subclasses.  You shouldn't need to call this method directly.  @param g2  the graphics device. @param area  the area within which the plot should be drawn. ",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "CategoryPlot.drawDomainGridlines",
    "class_name": "org.jfree.chart.plot.CategoryPlot",
    "signature": "org.jfree.chart.plot.CategoryPlot.drawDomainGridlines(Graphics2D,Rectangle2D)",
    "snippet": "    protected void drawDomainGridlines(Graphics2D g2, Rectangle2D dataArea) {\n\n        // draw the domain grid lines, if any...\n        if (isDomainGridlinesVisible()) {\n            CategoryAnchor anchor = getDomainGridlinePosition();\n            RectangleEdge domainAxisEdge = getDomainAxisEdge();\n            Stroke gridStroke = getDomainGridlineStroke();\n            Paint gridPaint = getDomainGridlinePaint();\n            if ((gridStroke != null) && (gridPaint != null)) {\n                // iterate over the categories\n                CategoryDataset data = getDataset();\n                if (data != null) {\n                    CategoryAxis axis = getDomainAxis();\n                    if (axis != null) {\n                        int columnCount = data.getColumnCount();\n                        for (int c = 0; c < columnCount; c++) {\n                            double xx = axis.getCategoryJava2DCoordinate(\n                                    anchor, c, columnCount, dataArea, \n                                    domainAxisEdge);\n                            CategoryItemRenderer renderer1 = getRenderer();\n                            if (renderer1 != null) {\n                                renderer1.drawDomainGridline(g2, this, \n                                        dataArea, xx);\n                            }\n                        }\n                    }\n                }\n            }\n        }\n    }",
    "comment": " Draws the gridlines for the plot.  @param g2  the graphics device. @param dataArea  the area inside the axes.  @see #drawRangeGridlines(Graphics2D, Rectangle2D, List) ",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "CategoryPlot.drawDomainMarkers",
    "class_name": "org.jfree.chart.plot.CategoryPlot",
    "signature": "org.jfree.chart.plot.CategoryPlot.drawDomainMarkers(Graphics2D,Rectangle2D,int,Layer)",
    "snippet": "    protected void drawDomainMarkers(Graphics2D g2, Rectangle2D dataArea, \n                                     int index, Layer layer) {\n                                                 \n        CategoryItemRenderer r = getRenderer(index);\n        if (r == null) {\n            return;\n        }\n        \n        Collection markers = getDomainMarkers(index, layer);\n        CategoryAxis axis = getDomainAxisForDataset(index);\n        if (markers != null && axis != null) {\n            Iterator iterator = markers.iterator();\n            while (iterator.hasNext()) {\n                CategoryMarker marker = (CategoryMarker) iterator.next();\n                r.drawDomainMarker(g2, this, axis, marker, dataArea);\n            }\n        }\n        \n    }",
    "comment": " Draws the domain markers (if any) for an axis and layer.  This method is  typically called from within the draw() method.  @param g2  the graphics device. @param dataArea  the data area. @param index  the renderer index. @param layer  the layer (foreground or background).  @see #drawRangeMarkers(Graphics2D, Rectangle2D, int, Layer) ",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "CategoryPlot.drawRangeGridlines",
    "class_name": "org.jfree.chart.plot.CategoryPlot",
    "signature": "org.jfree.chart.plot.CategoryPlot.drawRangeGridlines(Graphics2D,Rectangle2D,List)",
    "snippet": "    protected void drawRangeGridlines(Graphics2D g2, Rectangle2D dataArea, \n                                      List ticks) {\n        // draw the range grid lines, if any...\n        if (isRangeGridlinesVisible()) {\n            Stroke gridStroke = getRangeGridlineStroke();\n            Paint gridPaint = getRangeGridlinePaint();\n            if ((gridStroke != null) && (gridPaint != null)) {\n                ValueAxis axis = getRangeAxis();\n                if (axis != null) {\n                    Iterator iterator = ticks.iterator();\n                    while (iterator.hasNext()) {\n                        ValueTick tick = (ValueTick) iterator.next();\n                        CategoryItemRenderer renderer1 = getRenderer();\n                        if (renderer1 != null) {\n                            renderer1.drawRangeGridline(g2, this, \n                                    getRangeAxis(), dataArea, tick.getValue());\n                        }\n                    }\n                }\n            }\n        }\n    }",
    "comment": " Draws the gridlines for the plot.  @param g2  the graphics device. @param dataArea  the area inside the axes. @param ticks  the ticks.  @see #drawDomainGridlines(Graphics2D, Rectangle2D) ",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "CategoryPlot.drawRangeMarkers",
    "class_name": "org.jfree.chart.plot.CategoryPlot",
    "signature": "org.jfree.chart.plot.CategoryPlot.drawRangeMarkers(Graphics2D,Rectangle2D,int,Layer)",
    "snippet": "    protected void drawRangeMarkers(Graphics2D g2, Rectangle2D dataArea, \n                                    int index, Layer layer) {\n                                                 \n        CategoryItemRenderer r = getRenderer(index);\n        if (r == null) {\n            return;\n        }\n        \n        Collection markers = getRangeMarkers(index, layer);\n        ValueAxis axis = getRangeAxisForDataset(index);\n        if (markers != null && axis != null) {\n            Iterator iterator = markers.iterator();\n            while (iterator.hasNext()) {\n                Marker marker = (Marker) iterator.next();\n                r.drawRangeMarker(g2, this, axis, marker, dataArea);\n            }\n        }\n        \n    }",
    "comment": " Draws the range markers (if any) for an axis and layer.  This method is  typically called from within the draw() method.  @param g2  the graphics device. @param dataArea  the data area. @param index  the renderer index. @param layer  the layer (foreground or background).  @see #drawDomainMarkers(Graphics2D, Rectangle2D, int, Layer) ",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "CategoryPlot.getCategoriesForAxis",
    "class_name": "org.jfree.chart.plot.CategoryPlot",
    "signature": "org.jfree.chart.plot.CategoryPlot.getCategoriesForAxis(CategoryAxis)",
    "snippet": "    public List getCategoriesForAxis(CategoryAxis axis) {\n        List result = new ArrayList();\n        int axisIndex = this.domainAxes.indexOf(axis);\n        List datasets = datasetsMappedToDomainAxis(axisIndex);\n        Iterator iterator = datasets.iterator();\n        while (iterator.hasNext()) {\n            CategoryDataset dataset = (CategoryDataset) iterator.next();\n            // add the unique categories from this dataset\n            for (int i = 0; i < dataset.getColumnCount(); i++) {\n                Comparable category = dataset.getColumnKey(i);\n                if (!result.contains(category)) {\n                    result.add(category);\n                }\n            }\n        }\n        return result;\n    }",
    "comment": " Returns a list of the categories that should be displayed for the specified axis.  @param axis  the axis (<code>null</code> not permitted)  @return The categories.  @since 1.0.3 ",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "CategoryPlot.getDataRange",
    "class_name": "org.jfree.chart.plot.CategoryPlot",
    "signature": "org.jfree.chart.plot.CategoryPlot.getDataRange(ValueAxis)",
    "snippet": "    public Range getDataRange(ValueAxis axis) {\n\n        Range result = null;\n        List mappedDatasets = new ArrayList();\n        \n        int rangeIndex = this.rangeAxes.indexOf(axis);\n        if (rangeIndex >= 0) {\n            mappedDatasets.addAll(datasetsMappedToRangeAxis(rangeIndex));\n        }\n        else if (axis == getRangeAxis()) {\n            mappedDatasets.addAll(datasetsMappedToRangeAxis(0));\n        }\n\n        // iterate through the datasets that map to the axis and get the union \n        // of the ranges.\n        Iterator iterator = mappedDatasets.iterator();\n        while (iterator.hasNext()) {\n            CategoryDataset d = (CategoryDataset) iterator.next();\n            CategoryItemRenderer r = getRendererForDataset(d);\n            if (r != null) {\n                result = Range.combine(result, r.findRangeBounds(d));\n            }\n        }\n        return result;\n\n    }",
    "comment": " Returns the range of data values that will be plotted against the range  axis.  If the dataset is <code>null</code>, this method returns  <code>null</code>.  @param axis  the axis.  @return The data range. ",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "CategoryPlot.getDataset",
    "class_name": "org.jfree.chart.plot.CategoryPlot",
    "signature": "org.jfree.chart.plot.CategoryPlot.getDataset(int)",
    "snippet": "    public CategoryDataset getDataset(int index) {\n        CategoryDataset result = null;\n        if (this.datasets.size() > index) {\n            result = (CategoryDataset) this.datasets.get(index);\n        }\n        return result;\n    }",
    "comment": " Returns the dataset at the given index.  @param index  the dataset index.  @return The dataset (possibly <code>null</code>).  @see #setDataset(int, CategoryDataset) ",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "CategoryPlot.getDatasetRenderingOrder",
    "class_name": "org.jfree.chart.plot.CategoryPlot",
    "signature": "org.jfree.chart.plot.CategoryPlot.getDatasetRenderingOrder()",
    "snippet": "    public DatasetRenderingOrder getDatasetRenderingOrder() {\n        return this.renderingOrder;\n    }",
    "comment": " Returns the dataset rendering order.  @return The order (never <code>null</code>).  @see #setDatasetRenderingOrder(DatasetRenderingOrder) ",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "CategoryPlot.getDomainAxis",
    "class_name": "org.jfree.chart.plot.CategoryPlot",
    "signature": "org.jfree.chart.plot.CategoryPlot.getDomainAxis()",
    "snippet": "    public CategoryAxis getDomainAxis() {\n        return getDomainAxis(0);\n    }",
    "comment": " Returns the domain axis for the plot.  If the domain axis for this plot is <code>null</code>, then the method will return the parent plot's  domain axis (if there is a parent plot).  @return The domain axis (<code>null</code> permitted).  @see #setDomainAxis(CategoryAxis) ",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "CategoryPlot.getDomainAxis",
    "class_name": "org.jfree.chart.plot.CategoryPlot",
    "signature": "org.jfree.chart.plot.CategoryPlot.getDomainAxis(int)",
    "snippet": "    public CategoryAxis getDomainAxis(int index) {\n        CategoryAxis result = null;\n        if (index < this.domainAxes.size()) {\n            result = (CategoryAxis) this.domainAxes.get(index);\n        }\n        if (result == null) {\n            Plot parent = getParent();\n            if (parent instanceof CategoryPlot) {\n                CategoryPlot cp = (CategoryPlot) parent;\n                result = cp.getDomainAxis(index);\n            }\n        }\n        return result;\n    }",
    "comment": " Returns a domain axis.  @param index  the axis index.  @return The axis (<code>null</code> possible).  @see #setDomainAxis(int, CategoryAxis) ",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "CategoryPlot.getDomainAxisEdge",
    "class_name": "org.jfree.chart.plot.CategoryPlot",
    "signature": "org.jfree.chart.plot.CategoryPlot.getDomainAxisEdge()",
    "snippet": "    public RectangleEdge getDomainAxisEdge() {\n        return getDomainAxisEdge(0);\n    }",
    "comment": " Returns the domain axis edge.  This is derived from the axis location and the plot orientation.  @return The edge (never <code>null</code>). ",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "CategoryPlot.getDomainAxisEdge",
    "class_name": "org.jfree.chart.plot.CategoryPlot",
    "signature": "org.jfree.chart.plot.CategoryPlot.getDomainAxisEdge(int)",
    "snippet": "    public RectangleEdge getDomainAxisEdge(int index) {\n        RectangleEdge result = null;\n        AxisLocation location = getDomainAxisLocation(index);\n        if (location != null) {\n            result = Plot.resolveDomainAxisLocation(location, this.orientation);\n        }\n        else {\n            result = RectangleEdge.opposite(getDomainAxisEdge(0));\n        }\n        return result;\n    }",
    "comment": " Returns the edge for a domain axis.  @param index  the axis index.  @return The edge (never <code>null</code>). ",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "CategoryPlot.getDomainAxisForDataset",
    "class_name": "org.jfree.chart.plot.CategoryPlot",
    "signature": "org.jfree.chart.plot.CategoryPlot.getDomainAxisForDataset(int)",
    "snippet": "    public CategoryAxis getDomainAxisForDataset(int index) {\n        CategoryAxis result = getDomainAxis();\n        Integer axisIndex = (Integer) this.datasetToDomainAxisMap.get(index);\n        if (axisIndex != null) {\n            result = getDomainAxis(axisIndex.intValue());\n        }\n        return result;    \n    }",
    "comment": " Returns the domain axis for a dataset.  You can change the axis for a  dataset using the {@link #mapDatasetToDomainAxis(int, int)} method.  @param index  the dataset index.  @return The domain axis.  @see #mapDatasetToDomainAxis(int, int) ",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "CategoryPlot.getDomainAxisLocation",
    "class_name": "org.jfree.chart.plot.CategoryPlot",
    "signature": "org.jfree.chart.plot.CategoryPlot.getDomainAxisLocation()",
    "snippet": "    public AxisLocation getDomainAxisLocation() {\n        return getDomainAxisLocation(0);\n    }",
    "comment": " Returns the domain axis location for the primary domain axis.  @return The location (never <code>null</code>).  @see #getRangeAxisLocation() ",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "CategoryPlot.getDomainAxisLocation",
    "class_name": "org.jfree.chart.plot.CategoryPlot",
    "signature": "org.jfree.chart.plot.CategoryPlot.getDomainAxisLocation(int)",
    "snippet": "    public AxisLocation getDomainAxisLocation(int index) {\n        AxisLocation result = null;\n        if (index < this.domainAxisLocations.size()) {\n            result = (AxisLocation) this.domainAxisLocations.get(index);\n        }\n        if (result == null) {\n            result = AxisLocation.getOpposite(getDomainAxisLocation(0));\n        }\n        return result;\n    }",
    "comment": " Returns the location for a domain axis.  @param index  the axis index.  @return The location.  @see #setDomainAxisLocation(int, AxisLocation) ",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "CategoryPlot.getDomainMarkers",
    "class_name": "org.jfree.chart.plot.CategoryPlot",
    "signature": "org.jfree.chart.plot.CategoryPlot.getDomainMarkers(int,Layer)",
    "snippet": "    public Collection getDomainMarkers(int index, Layer layer) {\n        Collection result = null;\n        Integer key = new Integer(index);\n        if (layer == Layer.FOREGROUND) {\n            result = (Collection) this.foregroundDomainMarkers.get(key);\n        }    \n        else if (layer == Layer.BACKGROUND) {\n            result = (Collection) this.backgroundDomainMarkers.get(key);\n        }\n        if (result != null) {\n            result = Collections.unmodifiableCollection(result);\n        }\n        return result;\n    }",
    "comment": " Returns a collection of domain markers for a particular renderer and  layer.  @param index  the renderer index. @param layer  the layer.  @return A collection of markers (possibly <code>null</code>). ",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "CategoryPlot.getLegendItems",
    "class_name": "org.jfree.chart.plot.CategoryPlot",
    "signature": "org.jfree.chart.plot.CategoryPlot.getLegendItems()",
    "snippet": "    public LegendItemCollection getLegendItems() {\n        LegendItemCollection result = this.fixedLegendItems;\n        if (result == null) {\n            result = new LegendItemCollection();\n            // get the legend items for the datasets...\n            int count = this.datasets.size();\n            for (int datasetIndex = 0; datasetIndex < count; datasetIndex++) {\n                CategoryDataset dataset = getDataset(datasetIndex);\n                if (dataset != null) {\n                    CategoryItemRenderer renderer = getRenderer(datasetIndex);\n                    if (renderer != null) {\n                        int seriesCount = dataset.getRowCount();\n                        for (int i = 0; i < seriesCount; i++) {\n                            LegendItem item = renderer.getLegendItem(\n                                    datasetIndex, i);\n                            if (item != null) {\n                                result.add(item);\n                            }\n                        }\n                    }\n                }\n            }\n        }\n        return result;\n    }",
    "comment": " Returns the legend items for the plot.  By default, this method creates  a legend item for each series in each of the datasets.  You can change  this behaviour by overriding this method.  @return The legend items. ",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "CategoryPlot.getOrientation",
    "class_name": "org.jfree.chart.plot.CategoryPlot",
    "signature": "org.jfree.chart.plot.CategoryPlot.getOrientation()",
    "snippet": "    public PlotOrientation getOrientation() {\n        return this.orientation;\n    }",
    "comment": " Returns the orientation of the plot.  @return The orientation of the plot (never <code>null</code>).  @see #setOrientation(PlotOrientation) ",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "CategoryPlot.getRangeAxis",
    "class_name": "org.jfree.chart.plot.CategoryPlot",
    "signature": "org.jfree.chart.plot.CategoryPlot.getRangeAxis()",
    "snippet": "    public ValueAxis getRangeAxis() {\n        return getRangeAxis(0);\n    }",
    "comment": " Returns the range axis for the plot.  If the range axis for this plot is null, then the method will return the parent plot's range axis (if there is a parent plot).  @return The range axis (possibly <code>null</code>). ",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "CategoryPlot.getRangeAxis",
    "class_name": "org.jfree.chart.plot.CategoryPlot",
    "signature": "org.jfree.chart.plot.CategoryPlot.getRangeAxis(int)",
    "snippet": "    public ValueAxis getRangeAxis(int index) {\n        ValueAxis result = null;\n        if (index < this.rangeAxes.size()) {\n            result = (ValueAxis) this.rangeAxes.get(index);\n        }\n        if (result == null) {\n            Plot parent = getParent();\n            if (parent instanceof CategoryPlot) {\n                CategoryPlot cp = (CategoryPlot) parent;\n                result = cp.getRangeAxis(index);\n            }\n        }\n        return result;\n    }",
    "comment": " Returns a range axis.  @param index  the axis index.  @return The axis (<code>null</code> possible). ",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "CategoryPlot.getRangeAxisEdge",
    "class_name": "org.jfree.chart.plot.CategoryPlot",
    "signature": "org.jfree.chart.plot.CategoryPlot.getRangeAxisEdge()",
    "snippet": "    public RectangleEdge getRangeAxisEdge() {\n        return getRangeAxisEdge(0);\n    }",
    "comment": " Returns the edge where the primary range axis is located.  @return The edge (never <code>null</code>). ",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "CategoryPlot.getRangeAxisEdge",
    "class_name": "org.jfree.chart.plot.CategoryPlot",
    "signature": "org.jfree.chart.plot.CategoryPlot.getRangeAxisEdge(int)",
    "snippet": "    public RectangleEdge getRangeAxisEdge(int index) {\n        AxisLocation location = getRangeAxisLocation(index);\n        RectangleEdge result = Plot.resolveRangeAxisLocation(location, \n                this.orientation);\n        if (result == null) {\n            result = RectangleEdge.opposite(getRangeAxisEdge(0));\n        }\n        return result;\n    }",
    "comment": " Returns the edge for a range axis.  @param index  the axis index.  @return The edge. ",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "CategoryPlot.getRangeAxisForDataset",
    "class_name": "org.jfree.chart.plot.CategoryPlot",
    "signature": "org.jfree.chart.plot.CategoryPlot.getRangeAxisForDataset(int)",
    "snippet": "    public ValueAxis getRangeAxisForDataset(int index) {\n        ValueAxis result = getRangeAxis();\n        Integer axisIndex = (Integer) this.datasetToRangeAxisMap.get(index);\n        if (axisIndex != null) {\n            result = getRangeAxis(axisIndex.intValue());\n        }\n        return result;    \n    }",
    "comment": " Returns the range axis for a dataset.  You can change the axis for a  dataset using the {@link #mapDatasetToRangeAxis(int, int)} method.  @param index  the dataset index.  @return The range axis.  @see #mapDatasetToRangeAxis(int, int) ",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "CategoryPlot.getRangeAxisLocation",
    "class_name": "org.jfree.chart.plot.CategoryPlot",
    "signature": "org.jfree.chart.plot.CategoryPlot.getRangeAxisLocation(int)",
    "snippet": "    public AxisLocation getRangeAxisLocation(int index) {\n        AxisLocation result = null;\n        if (index < this.rangeAxisLocations.size()) {\n            result = (AxisLocation) this.rangeAxisLocations.get(index);\n        }\n        if (result == null) {\n            result = AxisLocation.getOpposite(getRangeAxisLocation(0));\n        }\n        return result;\n    }",
    "comment": " Returns the location for a range axis.  @param index  the axis index.  @return The location.  @see #setRangeAxisLocation(int, AxisLocation) ",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "CategoryPlot.getRangeGridlinePaint",
    "class_name": "org.jfree.chart.plot.CategoryPlot",
    "signature": "org.jfree.chart.plot.CategoryPlot.getRangeGridlinePaint()",
    "snippet": "    public Paint getRangeGridlinePaint() {\n        return this.rangeGridlinePaint;\n    }",
    "comment": " Returns the paint used to draw the grid-lines against the range axis.  @return The paint (never <code>null</code>).  @see #setRangeGridlinePaint(Paint) ",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "CategoryPlot.getRangeGridlineStroke",
    "class_name": "org.jfree.chart.plot.CategoryPlot",
    "signature": "org.jfree.chart.plot.CategoryPlot.getRangeGridlineStroke()",
    "snippet": "    public Stroke getRangeGridlineStroke() {\n        return this.rangeGridlineStroke;\n    }",
    "comment": " Returns the stroke used to draw the grid-lines against the range axis.  @return The stroke (never <code>null</code>).  @see #setRangeGridlineStroke(Stroke) ",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "CategoryPlot.getRangeMarkers",
    "class_name": "org.jfree.chart.plot.CategoryPlot",
    "signature": "org.jfree.chart.plot.CategoryPlot.getRangeMarkers(int,Layer)",
    "snippet": "    public Collection getRangeMarkers(int index, Layer layer) {\n        Collection result = null;\n        Integer key = new Integer(index);\n        if (layer == Layer.FOREGROUND) {\n            result = (Collection) this.foregroundRangeMarkers.get(key);\n        }    \n        else if (layer == Layer.BACKGROUND) {\n            result = (Collection) this.backgroundRangeMarkers.get(key);\n        }\n        if (result != null) {\n            result = Collections.unmodifiableCollection(result);\n        }\n        return result;\n    }",
    "comment": " Returns a collection of range markers for a particular renderer and  layer.  @param index  the renderer index. @param layer  the layer.  @return A collection of markers (possibly <code>null</code>). ",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "CategoryPlot.getRenderer",
    "class_name": "org.jfree.chart.plot.CategoryPlot",
    "signature": "org.jfree.chart.plot.CategoryPlot.getRenderer()",
    "snippet": "    public CategoryItemRenderer getRenderer() {\n        return getRenderer(0);\n    }",
    "comment": " Returns a reference to the renderer for the plot.  @return The renderer.  @see #setRenderer(CategoryItemRenderer) ",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "CategoryPlot.getRenderer",
    "class_name": "org.jfree.chart.plot.CategoryPlot",
    "signature": "org.jfree.chart.plot.CategoryPlot.getRenderer(int)",
    "snippet": "    public CategoryItemRenderer getRenderer(int index) {\n        CategoryItemRenderer result = null;\n        if (this.renderers.size() > index) {\n            result = (CategoryItemRenderer) this.renderers.get(index);\n        }\n        return result;\n    }",
    "comment": " Returns the renderer at the given index.  @param index  the renderer index.  @return The renderer (possibly <code>null</code>).  @see #setRenderer(int, CategoryItemRenderer) ",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "CategoryPlot.getRendererForDataset",
    "class_name": "org.jfree.chart.plot.CategoryPlot",
    "signature": "org.jfree.chart.plot.CategoryPlot.getRendererForDataset(CategoryDataset)",
    "snippet": "    public CategoryItemRenderer getRendererForDataset(CategoryDataset dataset) {\n        CategoryItemRenderer result = null;\n        for (int i = 0; i < this.datasets.size(); i++) {\n            if (this.datasets.get(i) == dataset) {\n                result = (CategoryItemRenderer) this.renderers.get(i);   \n                break;\n            }\n        }\n        return result;\n    }",
    "comment": " Returns the renderer for the specified dataset.  If the dataset doesn't belong to the plot, this method will return <code>null</code>.  @param dataset  the dataset (<code>null</code> permitted).  @return The renderer (possibly <code>null</code>). ",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "CategoryPlot.isDomainGridlinesVisible",
    "class_name": "org.jfree.chart.plot.CategoryPlot",
    "signature": "org.jfree.chart.plot.CategoryPlot.isDomainGridlinesVisible()",
    "snippet": "    public boolean isDomainGridlinesVisible() {\n        return this.domainGridlinesVisible;\n    }",
    "comment": " Returns the flag that controls whether the domain grid-lines are visible.  @return The <code>true</code> or <code>false</code>.  @see #setDomainGridlinesVisible(boolean) ",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "CategoryPlot.isRangeGridlinesVisible",
    "class_name": "org.jfree.chart.plot.CategoryPlot",
    "signature": "org.jfree.chart.plot.CategoryPlot.isRangeGridlinesVisible()",
    "snippet": "    public boolean isRangeGridlinesVisible() {\n        return this.rangeGridlinesVisible;\n    }",
    "comment": " Returns the flag that controls whether the range grid-lines are visible.  @return The flag.  @see #setRangeGridlinesVisible(boolean) ",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "CategoryPlot.mapDatasetToDomainAxis",
    "class_name": "org.jfree.chart.plot.CategoryPlot",
    "signature": "org.jfree.chart.plot.CategoryPlot.mapDatasetToDomainAxis(int,int)",
    "snippet": "    public void mapDatasetToDomainAxis(int index, int axisIndex) {\n        this.datasetToDomainAxisMap.set(index, new Integer(axisIndex));  \n        // fake a dataset change event to update axes...\n        datasetChanged(new DatasetChangeEvent(this, getDataset(index)));  \n    }",
    "comment": " Maps a dataset to a particular domain axis.  @param index  the dataset index (zero-based). @param axisIndex  the axis index (zero-based).  @see #getDomainAxisForDataset(int) ",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "CategoryPlot.mapDatasetToRangeAxis",
    "class_name": "org.jfree.chart.plot.CategoryPlot",
    "signature": "org.jfree.chart.plot.CategoryPlot.mapDatasetToRangeAxis(int,int)",
    "snippet": "    public void mapDatasetToRangeAxis(int index, int axisIndex) {\n        this.datasetToRangeAxisMap.set(index, new Integer(axisIndex));\n        // fake a dataset change event to update axes...\n        datasetChanged(new DatasetChangeEvent(this, getDataset(index)));  \n    }",
    "comment": " Maps a dataset to a particular range axis.  @param index  the dataset index (zero-based). @param axisIndex  the axis index (zero-based).  @see #getRangeAxisForDataset(int) ",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "CategoryPlot.render",
    "class_name": "org.jfree.chart.plot.CategoryPlot",
    "signature": "org.jfree.chart.plot.CategoryPlot.render(Graphics2D,Rectangle2D,int,PlotRenderingInfo)",
    "snippet": "    public boolean render(Graphics2D g2, Rectangle2D dataArea, int index, \n                          PlotRenderingInfo info) {\n\n        boolean foundData = false;\n        CategoryDataset currentDataset = getDataset(index);\n        CategoryItemRenderer renderer = getRenderer(index);\n        CategoryAxis domainAxis = getDomainAxisForDataset(index);\n        ValueAxis rangeAxis = getRangeAxisForDataset(index);\n        boolean hasData = !DatasetUtilities.isEmptyOrNull(currentDataset);\n        if (hasData && renderer != null) {\n            \n            foundData = true;\n            CategoryItemRendererState state = renderer.initialise(g2, dataArea,\n                    this, index, info);\n            int columnCount = currentDataset.getColumnCount();\n            int rowCount = currentDataset.getRowCount();\n            int passCount = renderer.getPassCount();\n            for (int pass = 0; pass < passCount; pass++) {            \n                if (this.columnRenderingOrder == SortOrder.ASCENDING) {\n                    for (int column = 0; column < columnCount; column++) {\n                        if (this.rowRenderingOrder == SortOrder.ASCENDING) {\n                            for (int row = 0; row < rowCount; row++) {\n                                renderer.drawItem(g2, state, dataArea, this, \n                                        domainAxis, rangeAxis, currentDataset, \n                                        row, column, pass);\n                            }\n                        }\n                        else {\n                            for (int row = rowCount - 1; row >= 0; row--) {\n                                renderer.drawItem(g2, state, dataArea, this, \n                                        domainAxis, rangeAxis, currentDataset, \n                                        row, column, pass);\n                            }                        \n                        }\n                    }\n                }\n                else {\n                    for (int column = columnCount - 1; column >= 0; column--) {\n                        if (this.rowRenderingOrder == SortOrder.ASCENDING) {\n                            for (int row = 0; row < rowCount; row++) {\n                                renderer.drawItem(g2, state, dataArea, this, \n                                        domainAxis, rangeAxis, currentDataset, \n                                        row, column, pass);\n                            }\n                        }\n                        else {\n                            for (int row = rowCount - 1; row >= 0; row--) {\n                                renderer.drawItem(g2, state, dataArea, this, \n                                        domainAxis, rangeAxis, currentDataset, \n                                        row, column, pass);\n                            }                        \n                        }\n                    }\n                }\n            }\n        }\n        return foundData;\n        \n    }",
    "comment": " Draws a representation of a dataset within the dataArea region using the appropriate renderer.  @param g2  the graphics device. @param dataArea  the region in which the data is to be drawn. @param index  the dataset and renderer index. @param info  an optional object for collection dimension information.  @return A boolean that indicates whether or not real data was found. ",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "CategoryPlot.setDomainAxisLocation",
    "class_name": "org.jfree.chart.plot.CategoryPlot",
    "signature": "org.jfree.chart.plot.CategoryPlot.setDomainAxisLocation(AxisLocation,boolean)",
    "snippet": "    public void setDomainAxisLocation(AxisLocation location, boolean notify) {\n        // delegate...\n        setDomainAxisLocation(0, location, notify);\n    }",
    "comment": " Sets the location of the domain axis and, if requested, sends a  {@link PlotChangeEvent} to all registered listeners.  @param location  the axis location (<code>null</code> not permitted). @param notify  a flag that controls whether listeners are notified. ",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "CategoryPlot.setDomainAxisLocation",
    "class_name": "org.jfree.chart.plot.CategoryPlot",
    "signature": "org.jfree.chart.plot.CategoryPlot.setDomainAxisLocation(int,AxisLocation,boolean)",
    "snippet": "    public void setDomainAxisLocation(int index, AxisLocation location, \n            boolean notify) {\n        if (index == 0 && location == null) {\n            throw new IllegalArgumentException(\n                    \"Null 'location' for index 0 not permitted.\");\n        }\n        this.domainAxisLocations.set(index, location);\n        if (notify) {\n            notifyListeners(new PlotChangeEvent(this));\n        }\n    }",
    "comment": " Sets the location for a domain axis and sends a {@link PlotChangeEvent}  to all registered listeners.  @param index  the axis index. @param location  the location. @param notify  notify listeners?  @since 1.0.5  @see #getDomainAxisLocation(int) @see #setRangeAxisLocation(int, AxisLocation, boolean) ",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "CategoryPlot.setOrientation",
    "class_name": "org.jfree.chart.plot.CategoryPlot",
    "signature": "org.jfree.chart.plot.CategoryPlot.setOrientation(PlotOrientation)",
    "snippet": "    public void setOrientation(PlotOrientation orientation) {\n        if (orientation == null) {\n            throw new IllegalArgumentException(\"Null 'orientation' argument.\");\n        }\n        this.orientation = orientation;\n        notifyListeners(new PlotChangeEvent(this));\n    }",
    "comment": " Sets the orientation for the plot and sends a {@link PlotChangeEvent} to all registered listeners.  @param orientation  the orientation (<code>null</code> not permitted).  @see #getOrientation() ",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "CategoryPlot.setRangeAxisLocation",
    "class_name": "org.jfree.chart.plot.CategoryPlot",
    "signature": "org.jfree.chart.plot.CategoryPlot.setRangeAxisLocation(AxisLocation,boolean)",
    "snippet": "    public void setRangeAxisLocation(AxisLocation location, boolean notify) {\n        setRangeAxisLocation(0, location, notify);\n    }",
    "comment": " Sets the location of the range axis and, if requested, sends a  {@link PlotChangeEvent} to all registered listeners.  @param location  the location (<code>null</code> not permitted). @param notify  notify listeners?  @see #setDomainAxisLocation(AxisLocation, boolean) ",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "CategoryPlot.setRangeAxisLocation",
    "class_name": "org.jfree.chart.plot.CategoryPlot",
    "signature": "org.jfree.chart.plot.CategoryPlot.setRangeAxisLocation(int,AxisLocation,boolean)",
    "snippet": "    public void setRangeAxisLocation(int index, AxisLocation location, \n                                     boolean notify) {\n        if (index == 0 && location == null) {\n            throw new IllegalArgumentException(\n                    \"Null 'location' for index 0 not permitted.\");\n        }\n        this.rangeAxisLocations.set(index, location);\n        if (notify) {\n            notifyListeners(new PlotChangeEvent(this));\n        }\n    }",
    "comment": " Sets the location for a range axis and sends a {@link PlotChangeEvent}  to all registered listeners.  @param index  the axis index. @param location  the location. @param notify  notify listeners?  @see #getRangeAxisLocation(int) @see #setDomainAxisLocation(int, AxisLocation, boolean) ",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "DefaultDrawingSupplier.DefaultDrawingSupplier",
    "class_name": "org.jfree.chart.plot.DefaultDrawingSupplier",
    "signature": "org.jfree.chart.plot.DefaultDrawingSupplier.DefaultDrawingSupplier()",
    "snippet": "    public DefaultDrawingSupplier() {\n\n        this(DEFAULT_PAINT_SEQUENCE, DEFAULT_FILL_PAINT_SEQUENCE,\n             DEFAULT_OUTLINE_PAINT_SEQUENCE,\n             DEFAULT_STROKE_SEQUENCE,\n             DEFAULT_OUTLINE_STROKE_SEQUENCE,\n             DEFAULT_SHAPE_SEQUENCE);\n\n    }",
    "comment": " Creates a new supplier, with default sequences for fill paint, outline  paint, stroke and shapes. ",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "DefaultDrawingSupplier.DefaultDrawingSupplier",
    "class_name": "org.jfree.chart.plot.DefaultDrawingSupplier",
    "signature": "org.jfree.chart.plot.DefaultDrawingSupplier.DefaultDrawingSupplier(Paint[],Paint[],Paint[],Stroke[],Stroke[],Shape[])",
    "snippet": "    public DefaultDrawingSupplier(Paint[] paintSequence, \n            Paint[] fillPaintSequence, Paint[] outlinePaintSequence,\n            Stroke[] strokeSequence, Stroke[] outlineStrokeSequence,\n            Shape[] shapeSequence) {\n\n        this.paintSequence = paintSequence;\n        this.fillPaintSequence = fillPaintSequence;\n        this.outlinePaintSequence = outlinePaintSequence;\n        this.strokeSequence = strokeSequence;\n        this.outlineStrokeSequence = outlineStrokeSequence;\n        this.shapeSequence = shapeSequence;\n    }",
    "comment": " Creates a new supplier.  @param paintSequence  the paint sequence. @param fillPaintSequence  the fill paint sequence. @param outlinePaintSequence  the outline paint sequence. @param strokeSequence  the stroke sequence. @param outlineStrokeSequence  the outline stroke sequence. @param shapeSequence  the shape sequence.  @since 1.0.6 ",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "DefaultDrawingSupplier.createStandardSeriesShapes",
    "class_name": "org.jfree.chart.plot.DefaultDrawingSupplier",
    "signature": "org.jfree.chart.plot.DefaultDrawingSupplier.createStandardSeriesShapes()",
    "snippet": "    public static Shape[] createStandardSeriesShapes() {\n\n        Shape[] result = new Shape[10];\n\n        double size = 6.0;\n        double delta = size / 2.0;\n        int[] xpoints = null;\n        int[] ypoints = null;\n\n        // square\n        result[0] = new Rectangle2D.Double(-delta, -delta, size, size);\n        // circle\n        result[1] = new Ellipse2D.Double(-delta, -delta, size, size);\n\n        // up-pointing triangle\n        xpoints = intArray(0.0, delta, -delta);\n        ypoints = intArray(-delta, delta, delta);\n        result[2] = new Polygon(xpoints, ypoints, 3);\n\n        // diamond\n        xpoints = intArray(0.0, delta, 0.0, -delta);\n        ypoints = intArray(-delta, 0.0, delta, 0.0);\n        result[3] = new Polygon(xpoints, ypoints, 4);\n\n        // horizontal rectangle\n        result[4] = new Rectangle2D.Double(-delta, -delta / 2, size, size / 2);\n\n        // down-pointing triangle\n        xpoints = intArray(-delta, +delta, 0.0);\n        ypoints = intArray(-delta, -delta, delta);\n        result[5] = new Polygon(xpoints, ypoints, 3);\n\n        // horizontal ellipse\n        result[6] = new Ellipse2D.Double(-delta, -delta / 2, size, size / 2);\n\n        // right-pointing triangle\n        xpoints = intArray(-delta, delta, -delta);\n        ypoints = intArray(-delta, 0.0, delta);\n        result[7] = new Polygon(xpoints, ypoints, 3);\n\n        // vertical rectangle\n        result[8] = new Rectangle2D.Double(-delta / 2, -delta, size / 2, size);\n\n        // left-pointing triangle\n        xpoints = intArray(-delta, delta, delta);\n        ypoints = intArray(0.0, -delta, +delta);\n        result[9] = new Polygon(xpoints, ypoints, 3);\n\n        return result;\n\n    }",
    "comment": " Creates an array of standard shapes to display for the items in series  on charts.  @return The array of shapes. ",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "DefaultDrawingSupplier.getNextPaint",
    "class_name": "org.jfree.chart.plot.DefaultDrawingSupplier",
    "signature": "org.jfree.chart.plot.DefaultDrawingSupplier.getNextPaint()",
    "snippet": "    public Paint getNextPaint() {\n        Paint result \n            = this.paintSequence[this.paintIndex % this.paintSequence.length];\n        this.paintIndex++;\n        return result;\n    }",
    "comment": " Returns the next paint in the sequence.  @return The paint. ",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "DefaultDrawingSupplier.intArray",
    "class_name": "org.jfree.chart.plot.DefaultDrawingSupplier",
    "signature": "org.jfree.chart.plot.DefaultDrawingSupplier.intArray(double,double,double)",
    "snippet": "    private static int[] intArray(double a, double b, double c) {\n        return new int[] {(int) a, (int) b, (int) c};\n    }",
    "comment": " Helper method to avoid lots of explicit casts in getShape().  Returns an array containing the provided doubles cast to ints.  @param a  x @param b  y @param c  z  @return int[3] with converted params. ",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "DefaultDrawingSupplier.intArray",
    "class_name": "org.jfree.chart.plot.DefaultDrawingSupplier",
    "signature": "org.jfree.chart.plot.DefaultDrawingSupplier.intArray(double,double,double,double)",
    "snippet": "    private static int[] intArray(double a, double b, double c, double d) {\n        return new int[] {(int) a, (int) b, (int) c, (int) d};\n    }",
    "comment": " Helper method to avoid lots of explicit casts in getShape().  Returns an array containing the provided doubles cast to ints.  @param a  x @param b  y @param c  z @param d  t  @return int[4] with converted params. ",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "Marker.Marker",
    "class_name": "org.jfree.chart.plot.Marker",
    "signature": "org.jfree.chart.plot.Marker.Marker(Paint,Stroke,Paint,Stroke,float)",
    "snippet": "    protected Marker(Paint paint, Stroke stroke, \n                     Paint outlinePaint, Stroke outlineStroke, \n                     float alpha) {\n\n        if (paint == null) {\n            throw new IllegalArgumentException(\"Null 'paint' argument.\");\n        }\n        if (stroke == null) {\n            throw new IllegalArgumentException(\"Null 'stroke' argument.\");\n        }\n        if (alpha < 0.0f || alpha > 1.0f)\n            throw new IllegalArgumentException(\n                    \"The 'alpha' value must be in the range 0.0f to 1.0f\");\n        \n        this.paint = paint;\n        this.stroke = stroke;\n        this.outlinePaint = outlinePaint;\n        this.outlineStroke = outlineStroke;\n        this.alpha = alpha;\n        \n        this.labelFont = new Font(\"SansSerif\", Font.PLAIN, 9);\n        this.labelPaint = Color.black;\n        this.labelAnchor = RectangleAnchor.TOP_LEFT;\n        this.labelOffset = new RectangleInsets(3.0, 3.0, 3.0, 3.0);\n        this.labelOffsetType = LengthAdjustmentType.CONTRACT;\n        this.labelTextAnchor = TextAnchor.CENTER;\n        \n        this.listenerList = new EventListenerList();\n    }",
    "comment": " Constructs a new marker.  @param paint  the paint (<code>null</code> not permitted). @param stroke  the stroke (<code>null</code> not permitted). @param outlinePaint  the outline paint (<code>null</code> permitted). @param outlineStroke  the outline stroke (<code>null</code> permitted). @param alpha  the alpha transparency (must be in the range 0.0f to  1.0f).  @throws IllegalArgumentException if <code>paint</code> or  <code>stroke</code> is <code>null</code>, or <code>alpha</code> is  not in the specified range. ",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "Marker.addChangeListener",
    "class_name": "org.jfree.chart.plot.Marker",
    "signature": "org.jfree.chart.plot.Marker.addChangeListener(MarkerChangeListener)",
    "snippet": "    public void addChangeListener(MarkerChangeListener listener) {\n        this.listenerList.add(MarkerChangeListener.class, listener);\n    }",
    "comment": " Registers an object for notification of changes to the marker.  @param listener  the object to be registered.  @since 1.0.3 ",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "Marker.getAlpha",
    "class_name": "org.jfree.chart.plot.Marker",
    "signature": "org.jfree.chart.plot.Marker.getAlpha()",
    "snippet": "    public float getAlpha() {\n        return this.alpha;\n    }",
    "comment": " Returns the alpha transparency.  @return The alpha transparency.  @see #setAlpha(float) ",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "Marker.getLabel",
    "class_name": "org.jfree.chart.plot.Marker",
    "signature": "org.jfree.chart.plot.Marker.getLabel()",
    "snippet": "    public String getLabel() {\n        return this.label;\n    }",
    "comment": " Returns the label (if <code>null</code> no label is displayed).  @return The label (possibly <code>null</code>).  @see #setLabel(String) ",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "Marker.getLabelAnchor",
    "class_name": "org.jfree.chart.plot.Marker",
    "signature": "org.jfree.chart.plot.Marker.getLabelAnchor()",
    "snippet": "    public RectangleAnchor getLabelAnchor() {\n        return this.labelAnchor;\n    }",
    "comment": " Returns the label anchor.  This defines the position of the label  anchor, relative to the bounds of the marker.  @return The label anchor (never <code>null</code>).  @see #setLabelAnchor(RectangleAnchor) ",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "Marker.getPaint",
    "class_name": "org.jfree.chart.plot.Marker",
    "signature": "org.jfree.chart.plot.Marker.getPaint()",
    "snippet": "    public Paint getPaint() {\n        return this.paint;\n    }",
    "comment": " Returns the paint.  @return The paint (never <code>null</code>).  @see #setPaint(Paint) ",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "Marker.getStroke",
    "class_name": "org.jfree.chart.plot.Marker",
    "signature": "org.jfree.chart.plot.Marker.getStroke()",
    "snippet": "    public Stroke getStroke() {\n        return this.stroke;\n    }",
    "comment": " Returns the stroke.  @return The stroke (never <code>null</code>).  @see #setStroke(Stroke) ",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "Plot.Plot",
    "class_name": "org.jfree.chart.plot.Plot",
    "signature": "org.jfree.chart.plot.Plot.Plot()",
    "snippet": "    protected Plot() {\n\n        this.parent = null;\n        this.insets = DEFAULT_INSETS;\n        this.backgroundPaint = DEFAULT_BACKGROUND_PAINT;\n        this.backgroundAlpha = DEFAULT_BACKGROUND_ALPHA;\n        this.backgroundImage = null;\n        this.outlineVisible = true;\n        this.outlineStroke = DEFAULT_OUTLINE_STROKE;\n        this.outlinePaint = DEFAULT_OUTLINE_PAINT;\n        this.foregroundAlpha = DEFAULT_FOREGROUND_ALPHA;\n\n        this.noDataMessage = null;\n        this.noDataMessageFont = new Font(\"SansSerif\", Font.PLAIN, 12);\n        this.noDataMessagePaint = Color.black;\n\n        this.drawingSupplier = new DefaultDrawingSupplier();\n\n        this.listenerList = new EventListenerList();\n\n    }",
    "comment": " Creates a new plot. ",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "Plot.addChangeListener",
    "class_name": "org.jfree.chart.plot.Plot",
    "signature": "org.jfree.chart.plot.Plot.addChangeListener(PlotChangeListener)",
    "snippet": "    public void addChangeListener(PlotChangeListener listener) {\n        this.listenerList.add(PlotChangeListener.class, listener);\n    }",
    "comment": " Registers an object for notification of changes to the plot.  @param listener  the object to be registered.  @see #removeChangeListener(PlotChangeListener) ",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "Plot.drawBackgroundImage",
    "class_name": "org.jfree.chart.plot.Plot",
    "signature": "org.jfree.chart.plot.Plot.drawBackgroundImage(Graphics2D,Rectangle2D)",
    "snippet": "    public void drawBackgroundImage(Graphics2D g2, Rectangle2D area) {\n        if (this.backgroundImage != null) {\n            Composite originalComposite = g2.getComposite();\n            g2.setComposite(AlphaComposite.getInstance(AlphaComposite.SRC_OVER, \n                    this.backgroundImageAlpha));\n            Rectangle2D dest = new Rectangle2D.Double(0.0, 0.0,\n                    this.backgroundImage.getWidth(null), \n                    this.backgroundImage.getHeight(null));\n            Align.align(dest, area, this.backgroundImageAlignment);\n            g2.drawImage(this.backgroundImage, (int) dest.getX(), \n                    (int) dest.getY(), (int) dest.getWidth() + 1, \n                    (int) dest.getHeight() + 1, null);\n            g2.setComposite(originalComposite);\n        }\n    }",
    "comment": " Draws the background image (if there is one) aligned within the  specified area.  @param g2  the graphics device. @param area  the area.  @see #getBackgroundImage() @see #getBackgroundImageAlignment() @see #getBackgroundImageAlpha() ",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "Plot.fillBackground",
    "class_name": "org.jfree.chart.plot.Plot",
    "signature": "org.jfree.chart.plot.Plot.fillBackground(Graphics2D,Rectangle2D,PlotOrientation)",
    "snippet": "    protected void fillBackground(Graphics2D g2, Rectangle2D area, \n            PlotOrientation orientation) {\n        if (orientation == null) {\n            throw new IllegalArgumentException(\"Null 'orientation' argument.\");\n        }\n        if (this.backgroundPaint == null) {\n            return;\n        }\n        Paint p = this.backgroundPaint;\n        if (p instanceof GradientPaint) {\n            GradientPaint gp = (GradientPaint) p;\n            if (orientation == PlotOrientation.VERTICAL) {\n                p = new GradientPaint((float) area.getCenterX(), \n                        (float) area.getMaxY(), gp.getColor1(), \n                        (float) area.getCenterX(), (float) area.getMinY(), \n                        gp.getColor2());\n            }\n            else if (orientation == PlotOrientation.HORIZONTAL) {\n                p = new GradientPaint((float) area.getMinX(), \n                        (float) area.getCenterY(), gp.getColor1(), \n                        (float) area.getMaxX(), (float) area.getCenterY(), \n                        gp.getColor2());\n            }\n        }            \n        Composite originalComposite = g2.getComposite();\n        g2.setComposite(AlphaComposite.getInstance(AlphaComposite.SRC_OVER,\n                this.backgroundAlpha));\n        g2.setPaint(p);\n        g2.fill(area);\n        g2.setComposite(originalComposite);        \n    }",
    "comment": " Fills the specified area with the background paint.  If the background paint is an instance of <code>GradientPaint</code>, the gradient will run in the direction suggested by the plot's orientation.  @param g2  the graphics target. @param area  the plot area. @param orientation  the plot orientation (<code>null</code> not  permitted).  @since 1.0.6 ",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "Plot.getDrawingSupplier",
    "class_name": "org.jfree.chart.plot.Plot",
    "signature": "org.jfree.chart.plot.Plot.getDrawingSupplier()",
    "snippet": "    public DrawingSupplier getDrawingSupplier() {\n        DrawingSupplier result = null;\n        Plot p = getParent();\n        if (p != null) {\n            result = p.getDrawingSupplier();\n        }\n        else {\n            result = this.drawingSupplier;\n        }\n        return result;\n    }",
    "comment": " Returns the drawing supplier for the plot.  @return The drawing supplier (possibly <code>null</code>).  @see #setDrawingSupplier(DrawingSupplier) ",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "Plot.getForegroundAlpha",
    "class_name": "org.jfree.chart.plot.Plot",
    "signature": "org.jfree.chart.plot.Plot.getForegroundAlpha()",
    "snippet": "    public float getForegroundAlpha() {\n        return this.foregroundAlpha;\n    }",
    "comment": " Returns the alpha-transparency for the plot foreground.  @return The alpha-transparency.  @see #setForegroundAlpha(float) ",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "Plot.getInsets",
    "class_name": "org.jfree.chart.plot.Plot",
    "signature": "org.jfree.chart.plot.Plot.getInsets()",
    "snippet": "    public RectangleInsets getInsets() {\n        return this.insets;\n    }",
    "comment": " Returns the insets for the plot area.  @return The insets (never <code>null</code>).  @see #setInsets(RectangleInsets) ",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "Plot.getParent",
    "class_name": "org.jfree.chart.plot.Plot",
    "signature": "org.jfree.chart.plot.Plot.getParent()",
    "snippet": "    public Plot getParent() {\n        return this.parent;\n    }",
    "comment": " Returns the parent plot (or <code>null</code> if this plot is not part  of a combined plot).  @return The parent plot.  @see #setParent(Plot) @see #getRootPlot() ",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "Plot.notifyListeners",
    "class_name": "org.jfree.chart.plot.Plot",
    "signature": "org.jfree.chart.plot.Plot.notifyListeners(PlotChangeEvent)",
    "snippet": "    public void notifyListeners(PlotChangeEvent event) {\n        Object[] listeners = this.listenerList.getListenerList();\n        for (int i = listeners.length - 2; i >= 0; i -= 2) {\n            if (listeners[i] == PlotChangeListener.class) {\n                ((PlotChangeListener) listeners[i + 1]).plotChanged(event);\n            }\n        }\n    }",
    "comment": " Notifies all registered listeners that the plot has been modified.  @param event  information about the change event. ",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "Plot.resolveDomainAxisLocation",
    "class_name": "org.jfree.chart.plot.Plot",
    "signature": "org.jfree.chart.plot.Plot.resolveDomainAxisLocation(AxisLocation,PlotOrientation)",
    "snippet": "    public static RectangleEdge resolveDomainAxisLocation(\n            AxisLocation location, PlotOrientation orientation) {\n        \n        if (location == null) {\n            throw new IllegalArgumentException(\"Null 'location' argument.\");   \n        }\n        if (orientation == null) {\n            throw new IllegalArgumentException(\"Null 'orientation' argument.\");\n        }\n\n        RectangleEdge result = null;\n        \n        if (location == AxisLocation.TOP_OR_RIGHT) {\n            if (orientation == PlotOrientation.HORIZONTAL) {\n                result = RectangleEdge.RIGHT;\n            }\n            else if (orientation == PlotOrientation.VERTICAL) {\n                result = RectangleEdge.TOP;\n            }\n        }\n        else if (location == AxisLocation.TOP_OR_LEFT) {\n            if (orientation == PlotOrientation.HORIZONTAL) {\n                result = RectangleEdge.LEFT;\n            }\n            else if (orientation == PlotOrientation.VERTICAL) {\n                result = RectangleEdge.TOP;\n            }\n        }\n        else if (location == AxisLocation.BOTTOM_OR_RIGHT) {\n            if (orientation == PlotOrientation.HORIZONTAL) {\n                result = RectangleEdge.RIGHT;\n            }\n            else if (orientation == PlotOrientation.VERTICAL) {\n                result = RectangleEdge.BOTTOM;\n            }\n        }\n        else if (location == AxisLocation.BOTTOM_OR_LEFT) {\n            if (orientation == PlotOrientation.HORIZONTAL) {\n                result = RectangleEdge.LEFT;\n            }\n            else if (orientation == PlotOrientation.VERTICAL) {\n                result = RectangleEdge.BOTTOM;\n            }\n        }\n        // the above should cover all the options...\n        if (result == null) {\n            throw new IllegalStateException(\"resolveDomainAxisLocation()\");\n        }\n        return result;\n        \n    }",
    "comment": " Resolves a domain axis location for a given plot orientation.  @param location  the location (<code>null</code> not permitted). @param orientation  the orientation (<code>null</code> not permitted).  @return The edge (never <code>null</code>). ",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "Plot.resolveRangeAxisLocation",
    "class_name": "org.jfree.chart.plot.Plot",
    "signature": "org.jfree.chart.plot.Plot.resolveRangeAxisLocation(AxisLocation,PlotOrientation)",
    "snippet": "    public static RectangleEdge resolveRangeAxisLocation(\n            AxisLocation location, PlotOrientation orientation) {\n\n        if (location == null) {\n            throw new IllegalArgumentException(\"Null 'location' argument.\");   \n        }\n        if (orientation == null) {\n            throw new IllegalArgumentException(\"Null 'orientation' argument.\");\n        }\n\n        RectangleEdge result = null;\n        \n        if (location == AxisLocation.TOP_OR_RIGHT) {\n            if (orientation == PlotOrientation.HORIZONTAL) {\n                result = RectangleEdge.TOP;\n            }\n            else if (orientation == PlotOrientation.VERTICAL) {\n                result = RectangleEdge.RIGHT;\n            }\n        }\n        else if (location == AxisLocation.TOP_OR_LEFT) {\n            if (orientation == PlotOrientation.HORIZONTAL) {\n                result = RectangleEdge.TOP;\n            }\n            else if (orientation == PlotOrientation.VERTICAL) {\n                result = RectangleEdge.LEFT;\n            }\n        }\n        else if (location == AxisLocation.BOTTOM_OR_RIGHT) {\n            if (orientation == PlotOrientation.HORIZONTAL) {\n                result = RectangleEdge.BOTTOM;\n            }\n            else if (orientation == PlotOrientation.VERTICAL) {\n                result = RectangleEdge.RIGHT;\n            }\n        }\n        else if (location == AxisLocation.BOTTOM_OR_LEFT) {\n            if (orientation == PlotOrientation.HORIZONTAL) {\n                result = RectangleEdge.BOTTOM;\n            }\n            else if (orientation == PlotOrientation.VERTICAL) {\n                result = RectangleEdge.LEFT;\n            }\n        }\n\n        // the above should cover all the options...\n        if (result == null) {\n            throw new IllegalStateException(\"resolveRangeAxisLocation()\");\n        }\n        return result;\n        \n    }",
    "comment": " Resolves a range axis location for a given plot orientation.  @param location  the location (<code>null</code> not permitted). @param orientation  the orientation (<code>null</code> not permitted).  @return The edge (never <code>null</code>). ",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "PlotRenderingInfo.PlotRenderingInfo",
    "class_name": "org.jfree.chart.plot.PlotRenderingInfo",
    "signature": "org.jfree.chart.plot.PlotRenderingInfo.PlotRenderingInfo(ChartRenderingInfo)",
    "snippet": "    public PlotRenderingInfo(ChartRenderingInfo owner) {\n        this.owner = owner;        \n        this.dataArea = new Rectangle2D.Double();\n        this.subplotInfo = new java.util.ArrayList();    \n    }",
    "comment": " Creates a new instance.  @param owner  the owner (<code>null</code> permitted). ",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "PlotRenderingInfo.getOwner",
    "class_name": "org.jfree.chart.plot.PlotRenderingInfo",
    "signature": "org.jfree.chart.plot.PlotRenderingInfo.getOwner()",
    "snippet": "    public ChartRenderingInfo getOwner() {\n        return this.owner;\n    }",
    "comment": " Returns the owner (as specified in the constructor).  @return The owner (possibly <code>null</code>). ",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "PlotRenderingInfo.setDataArea",
    "class_name": "org.jfree.chart.plot.PlotRenderingInfo",
    "signature": "org.jfree.chart.plot.PlotRenderingInfo.setDataArea(Rectangle2D)",
    "snippet": "    public void setDataArea(Rectangle2D area) {\n        this.dataArea = area;\n    }",
    "comment": " Sets the data area.  @param area  the data area (in Java2D space, <code>null</code> permitted but discouraged).  @see #getDataArea() ",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "PlotRenderingInfo.setPlotArea",
    "class_name": "org.jfree.chart.plot.PlotRenderingInfo",
    "signature": "org.jfree.chart.plot.PlotRenderingInfo.setPlotArea(Rectangle2D)",
    "snippet": "    public void setPlotArea(Rectangle2D area) {\n        this.plotArea = area;\n    }",
    "comment": " Sets the plot area.  @param area  the plot area (in Java2D space, <code>null</code>  permitted but discouraged)  @see #getPlotArea() ",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "ValueMarker.ValueMarker",
    "class_name": "org.jfree.chart.plot.ValueMarker",
    "signature": "org.jfree.chart.plot.ValueMarker.ValueMarker(double,Paint,Stroke,Paint,Stroke,float)",
    "snippet": "    public ValueMarker(double value, Paint paint, Stroke stroke, \n                       Paint outlinePaint, Stroke outlineStroke, float alpha) {\n        super(paint, stroke, paint, stroke, alpha);\n        this.value = value;\n    }",
    "comment": " Creates a new value marker.  @param value  the value. @param paint  the paint (<code>null</code> not permitted). @param stroke  the stroke (<code>null</code> not permitted). @param outlinePaint  the outline paint (<code>null</code> permitted). @param outlineStroke  the outline stroke (<code>null</code> permitted). @param alpha  the alpha transparency. ",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "ValueMarker.getValue",
    "class_name": "org.jfree.chart.plot.ValueMarker",
    "signature": "org.jfree.chart.plot.ValueMarker.getValue()",
    "snippet": "    public double getValue() {\n        return this.value;\n    }",
    "comment": " Returns the value.  @return The value. ",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "AbstractRenderer.AbstractRenderer",
    "class_name": "org.jfree.chart.renderer.AbstractRenderer",
    "signature": "org.jfree.chart.renderer.AbstractRenderer.AbstractRenderer()",
    "snippet": "    public AbstractRenderer() {\n\n        this.seriesVisibleList = new BooleanList();\n        this.baseSeriesVisible = true;\n\n        this.seriesVisibleInLegendList = new BooleanList();\n        this.baseSeriesVisibleInLegend = true;\n\n        this.paintList = new PaintList();\n        this.basePaint = DEFAULT_PAINT;\n        this.autoPopulateSeriesPaint = true;\n\n        this.fillPaintList = new PaintList();\n        this.baseFillPaint = Color.white;\n        this.autoPopulateSeriesFillPaint = false;\n\n        this.outlinePaintList = new PaintList();\n        this.baseOutlinePaint = DEFAULT_OUTLINE_PAINT;\n        this.autoPopulateSeriesOutlinePaint = false;\n\n        this.strokeList = new StrokeList();\n        this.baseStroke = DEFAULT_STROKE;\n        this.autoPopulateSeriesStroke = false;\n\n        this.outlineStrokeList = new StrokeList();\n        this.baseOutlineStroke = DEFAULT_OUTLINE_STROKE;\n        this.autoPopulateSeriesOutlineStroke = false;\n\n        this.shapeList = new ShapeList();\n        this.baseShape = DEFAULT_SHAPE;\n        this.autoPopulateSeriesShape = true;\n\n        this.itemLabelsVisibleList = new BooleanList();\n        this.baseItemLabelsVisible = false;\n\n        this.itemLabelFontList = new ObjectList();\n        this.baseItemLabelFont = new Font(\"SansSerif\", Font.PLAIN, 10);\n\n        this.itemLabelPaintList = new PaintList();\n        this.baseItemLabelPaint = Color.black;\n\n        this.positiveItemLabelPositionList = new ObjectList();\n        this.basePositiveItemLabelPosition = new ItemLabelPosition(\n                ItemLabelAnchor.OUTSIDE12, TextAnchor.BOTTOM_CENTER);\n        \n        this.negativeItemLabelPositionList = new ObjectList();\n        this.baseNegativeItemLabelPosition = new ItemLabelPosition(\n                ItemLabelAnchor.OUTSIDE6, TextAnchor.TOP_CENTER);\n\n        this.createEntitiesList = new BooleanList();\n        this.baseCreateEntities = true;\n        \n        this.listenerList = new EventListenerList();\n\n    }",
    "comment": " Default constructor. ",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "AbstractRenderer.addChangeListener",
    "class_name": "org.jfree.chart.renderer.AbstractRenderer",
    "signature": "org.jfree.chart.renderer.AbstractRenderer.addChangeListener(RendererChangeListener)",
    "snippet": "    public void addChangeListener(RendererChangeListener listener) {\n        if (listener == null) {\n            throw new IllegalArgumentException(\"Null 'listener' argument.\");   \n        }\n        this.listenerList.add(RendererChangeListener.class, listener);\n    }",
    "comment": " Registers an object to receive notification of changes to the renderer.  @param listener  the listener (<code>null</code> not permitted). ",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "AbstractRenderer.getItemPaint",
    "class_name": "org.jfree.chart.renderer.AbstractRenderer",
    "signature": "org.jfree.chart.renderer.AbstractRenderer.getItemPaint(int,int)",
    "snippet": "    public Paint getItemPaint(int row, int column) {\n        return lookupSeriesPaint(row);\n    }",
    "comment": " Returns the paint used to fill data items as they are drawn. <p> The default implementation passes control to the  <code>getSeriesPaint</code> method. You can override this method if you  require different behaviour.  @param row  the row (or series) index (zero-based). @param column  the column (or category) index (zero-based).  @return The paint (never <code>null</code>). ",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "AbstractRenderer.isSeriesVisible",
    "class_name": "org.jfree.chart.renderer.AbstractRenderer",
    "signature": "org.jfree.chart.renderer.AbstractRenderer.isSeriesVisible(int)",
    "snippet": "    public boolean isSeriesVisible(int series) {\n        boolean result = this.baseSeriesVisible;\n        Boolean b = this.seriesVisibleList.getBoolean(series);\n        if (b != null) {\n            result = b.booleanValue();   \n        }\n        return result;\n    }",
    "comment": " Returns a boolean that indicates whether or not the specified series  should be drawn.  @param series  the series index.  @return A boolean. ",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "AbstractRenderer.isSeriesVisibleInLegend",
    "class_name": "org.jfree.chart.renderer.AbstractRenderer",
    "signature": "org.jfree.chart.renderer.AbstractRenderer.isSeriesVisibleInLegend(int)",
    "snippet": "    public boolean isSeriesVisibleInLegend(int series) {\n        boolean result = this.baseSeriesVisibleInLegend;\n        Boolean b = this.seriesVisibleInLegendList.getBoolean(series);\n        if (b != null) {\n            result = b.booleanValue();   \n        }\n        return result;\n    }",
    "comment": " Returns <code>true</code> if the series should be shown in the legend, and <code>false</code> otherwise.  @param series  the series index.  @return A boolean. ",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "AbstractRenderer.lookupSeriesOutlinePaint",
    "class_name": "org.jfree.chart.renderer.AbstractRenderer",
    "signature": "org.jfree.chart.renderer.AbstractRenderer.lookupSeriesOutlinePaint(int)",
    "snippet": "    public Paint lookupSeriesOutlinePaint(int series) {\n\n        // look up the paint table\n        Paint seriesOutlinePaint = this.outlinePaintList.getPaint(series);\n        if (seriesOutlinePaint == null && this.autoPopulateSeriesOutlinePaint) {\n            DrawingSupplier supplier = getDrawingSupplier();\n            if (supplier != null) {\n                seriesOutlinePaint = supplier.getNextOutlinePaint();\n                this.outlinePaintList.setPaint(series, seriesOutlinePaint);\n            }\n        }\n        if (seriesOutlinePaint == null) {\n            seriesOutlinePaint = this.baseOutlinePaint;\n        }\n        return seriesOutlinePaint;\n\n    }",
    "comment": " Returns the paint used to outline an item drawn by the renderer.  @param series  the series (zero-based index).  @return The paint (never <code>null</code>).  @since 1.0.6 ",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "AbstractRenderer.lookupSeriesOutlineStroke",
    "class_name": "org.jfree.chart.renderer.AbstractRenderer",
    "signature": "org.jfree.chart.renderer.AbstractRenderer.lookupSeriesOutlineStroke(int)",
    "snippet": "    public Stroke lookupSeriesOutlineStroke(int series) {\n\n        // look up the stroke table\n        Stroke result = this.outlineStrokeList.getStroke(series);\n        if (result == null && this.autoPopulateSeriesOutlineStroke) {\n            DrawingSupplier supplier = getDrawingSupplier();\n            if (supplier != null) {\n                result = supplier.getNextOutlineStroke();\n                this.outlineStrokeList.setStroke(series, result);\n            }\n        }\n        if (result == null) {\n            result = this.baseOutlineStroke;\n        }\n        return result;\n\n    }",
    "comment": " Returns the stroke used to outline the items in a series.  @param series  the series (zero-based index).  @return The stroke (never <code>null</code>).  @since 1.0.6 ",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "AbstractRenderer.lookupSeriesPaint",
    "class_name": "org.jfree.chart.renderer.AbstractRenderer",
    "signature": "org.jfree.chart.renderer.AbstractRenderer.lookupSeriesPaint(int)",
    "snippet": "    public Paint lookupSeriesPaint(int series) {\n\n        // look up the paint list\n        Paint seriesPaint = this.paintList.getPaint(series);\n        if (seriesPaint == null && this.autoPopulateSeriesPaint) {\n            DrawingSupplier supplier = getDrawingSupplier();\n            if (supplier != null) {\n                seriesPaint = supplier.getNextPaint();\n                this.paintList.setPaint(series, seriesPaint);\n            }\n        }\n        if (seriesPaint == null) {\n            seriesPaint = this.basePaint;\n        }\n        return seriesPaint;\n\n    }",
    "comment": " Returns the paint used to fill an item drawn by the renderer.  @param series  the series index (zero-based).  @return The paint (never <code>null</code>).  @since 1.0.6 ",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "RendererState.RendererState",
    "class_name": "org.jfree.chart.renderer.RendererState",
    "signature": "org.jfree.chart.renderer.RendererState.RendererState(PlotRenderingInfo)",
    "snippet": "    public RendererState(PlotRenderingInfo info) {\n        this.info = info;\n    }",
    "comment": " Creates a new state object.  @param info  the plot rendering info. ",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "RendererState.getEntityCollection",
    "class_name": "org.jfree.chart.renderer.RendererState",
    "signature": "org.jfree.chart.renderer.RendererState.getEntityCollection()",
    "snippet": "    public EntityCollection getEntityCollection() {\n        EntityCollection result = null;\n        if (this.info != null) {\n            ChartRenderingInfo owner = this.info.getOwner();\n            if (owner != null) {\n                result = owner.getEntityCollection(); \n            }\n        }\n        return result;\n    }",
    "comment": " A convenience method that returns a reference to the entity collection (may be <code>null</code>) being used to record chart entities.  @return The entity collection (possibly <code>null</code>). ",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "AbstractCategoryItemRenderer.AbstractCategoryItemRenderer",
    "class_name": "org.jfree.chart.renderer.category.AbstractCategoryItemRenderer",
    "signature": "org.jfree.chart.renderer.category.AbstractCategoryItemRenderer.AbstractCategoryItemRenderer()",
    "snippet": "    protected AbstractCategoryItemRenderer() {\n        this.itemLabelGeneratorList = new ObjectList();\n        this.toolTipGeneratorList = new ObjectList();\n        this.urlGeneratorList = new ObjectList();\n        this.legendItemLabelGenerator\n                = new StandardCategorySeriesLabelGenerator();\n        this.backgroundAnnotations = new ArrayList();\n        this.foregroundAnnotations = new ArrayList();\n    }",
    "comment": " Creates a new renderer with no tool tip generator and no URL generator. The defaults (no tool tip or URL generators) have been chosen to minimise the processing required to generate a default chart.  If you require tool tips or URLs, then you can easily add the required generators. ",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "AbstractCategoryItemRenderer.createState",
    "class_name": "org.jfree.chart.renderer.category.AbstractCategoryItemRenderer",
    "signature": "org.jfree.chart.renderer.category.AbstractCategoryItemRenderer.createState(PlotRenderingInfo)",
    "snippet": "    protected CategoryItemRendererState createState(PlotRenderingInfo info) {\n        return new CategoryItemRendererState(info);\n    }",
    "comment": " Creates a new state instance---this method is called from the {@link #initialise(Graphics2D, Rectangle2D, CategoryPlot, int, PlotRenderingInfo)} method.  Subclasses can override this method if they need to use a subclass of {@link CategoryItemRendererState}.  @param info  collects plot rendering info (<code>null</code> permitted).  @return The new state instance (never <code>null</code>).  @since 1.0.5 ",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "AbstractCategoryItemRenderer.drawAnnotations",
    "class_name": "org.jfree.chart.renderer.category.AbstractCategoryItemRenderer",
    "signature": "org.jfree.chart.renderer.category.AbstractCategoryItemRenderer.drawAnnotations(Graphics2D,Rectangle2D,CategoryAxis,ValueAxis,Layer,PlotRenderingInfo)",
    "snippet": "    public void drawAnnotations(Graphics2D g2, Rectangle2D dataArea,\n            CategoryAxis domainAxis, ValueAxis rangeAxis, Layer layer,\n            PlotRenderingInfo info) {\n\n        Iterator iterator = null;\n        if (layer.equals(Layer.FOREGROUND)) {\n            iterator = this.foregroundAnnotations.iterator();\n        }\n        else if (layer.equals(Layer.BACKGROUND)) {\n            iterator = this.backgroundAnnotations.iterator();\n        }\n        else {\n            // should not get here\n            throw new RuntimeException(\"Unknown layer.\");\n        }\n        while (iterator.hasNext()) {\n            CategoryAnnotation annotation = (CategoryAnnotation) iterator.next();\n            annotation.draw(g2, this.plot, dataArea, domainAxis, rangeAxis,\n                    0, info);\n        }\n\n    }",
    "comment": " Draws all the annotations for the specified layer.  @param g2  the graphics device. @param dataArea  the data area. @param domainAxis  the domain axis. @param rangeAxis  the range axis. @param layer  the layer. @param info  the plot rendering info.  @since 1.2.0 ",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "AbstractCategoryItemRenderer.drawBackground",
    "class_name": "org.jfree.chart.renderer.category.AbstractCategoryItemRenderer",
    "signature": "org.jfree.chart.renderer.category.AbstractCategoryItemRenderer.drawBackground(Graphics2D,CategoryPlot,Rectangle2D)",
    "snippet": "    public void drawBackground(Graphics2D g2,\n                               CategoryPlot plot,\n                               Rectangle2D dataArea) {\n\n        plot.drawBackground(g2, dataArea);\n\n    }",
    "comment": " Draws a background for the data area.  The default implementation just gets the plot to draw the background, but some renderers will override  this behaviour.  @param g2  the graphics device. @param plot  the plot. @param dataArea  the data area. ",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "AbstractCategoryItemRenderer.drawRangeGridline",
    "class_name": "org.jfree.chart.renderer.category.AbstractCategoryItemRenderer",
    "signature": "org.jfree.chart.renderer.category.AbstractCategoryItemRenderer.drawRangeGridline(Graphics2D,CategoryPlot,ValueAxis,Rectangle2D,double)",
    "snippet": "    public void drawRangeGridline(Graphics2D g2,\n                                  CategoryPlot plot,\n                                  ValueAxis axis,\n                                  Rectangle2D dataArea,\n                                  double value) {\n\n        Range range = axis.getRange();\n        if (!range.contains(value)) {\n            return;\n        }\n\n        PlotOrientation orientation = plot.getOrientation();\n        double v = axis.valueToJava2D(value, dataArea, plot.getRangeAxisEdge());\n        Line2D line = null;\n        if (orientation == PlotOrientation.HORIZONTAL) {\n            line = new Line2D.Double(v, dataArea.getMinY(), v,\n                    dataArea.getMaxY());\n        }\n        else if (orientation == PlotOrientation.VERTICAL) {\n            line = new Line2D.Double(dataArea.getMinX(), v,\n                    dataArea.getMaxX(), v);\n        }\n\n        Paint paint = plot.getRangeGridlinePaint();\n        if (paint == null) {\n            paint = CategoryPlot.DEFAULT_GRIDLINE_PAINT;\n        }\n        g2.setPaint(paint);\n\n        Stroke stroke = plot.getRangeGridlineStroke();\n        if (stroke == null) {\n            stroke = CategoryPlot.DEFAULT_GRIDLINE_STROKE;\n        }\n        g2.setStroke(stroke);\n\n        g2.draw(line);\n\n    }",
    "comment": " Draws a grid line against the range axis.  @param g2  the graphics device. @param plot  the plot. @param axis  the value axis. @param dataArea  the area for plotting data (not yet adjusted for any 3D effect). @param value  the value at which the grid line should be drawn.  @see #drawDomainGridline(Graphics2D, CategoryPlot, Rectangle2D, double)  ",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "AbstractCategoryItemRenderer.drawRangeMarker",
    "class_name": "org.jfree.chart.renderer.category.AbstractCategoryItemRenderer",
    "signature": "org.jfree.chart.renderer.category.AbstractCategoryItemRenderer.drawRangeMarker(Graphics2D,CategoryPlot,ValueAxis,Marker,Rectangle2D)",
    "snippet": "    public void drawRangeMarker(Graphics2D g2,\n                                CategoryPlot plot,\n                                ValueAxis axis,\n                                Marker marker,\n                                Rectangle2D dataArea) {\n\n        if (marker instanceof ValueMarker) {\n            ValueMarker vm = (ValueMarker) marker;\n            double value = vm.getValue();\n            Range range = axis.getRange();\n\n            if (!range.contains(value)) {\n                return;\n            }\n\n            final Composite savedComposite = g2.getComposite();\n            g2.setComposite(AlphaComposite.getInstance(\n                    AlphaComposite.SRC_OVER, marker.getAlpha()));\n\n            PlotOrientation orientation = plot.getOrientation();\n            double v = axis.valueToJava2D(value, dataArea,\n                    plot.getRangeAxisEdge());\n            Line2D line = null;\n            if (orientation == PlotOrientation.HORIZONTAL) {\n                line = new Line2D.Double(v, dataArea.getMinY(), v,\n                        dataArea.getMaxY());\n            }\n            else if (orientation == PlotOrientation.VERTICAL) {\n                line = new Line2D.Double(dataArea.getMinX(), v,\n                        dataArea.getMaxX(), v);\n            }\n\n            g2.setPaint(marker.getPaint());\n            g2.setStroke(marker.getStroke());\n            g2.draw(line);\n\n            String label = marker.getLabel();\n            RectangleAnchor anchor = marker.getLabelAnchor();\n            if (label != null) {\n                Font labelFont = marker.getLabelFont();\n                g2.setFont(labelFont);\n                g2.setPaint(marker.getLabelPaint());\n                Point2D coordinates = calculateRangeMarkerTextAnchorPoint(\n                        g2, orientation, dataArea, line.getBounds2D(),\n                        marker.getLabelOffset(), LengthAdjustmentType.EXPAND,\n                        anchor);\n                TextUtilities.drawAlignedString(label, g2,\n                        (float) coordinates.getX(), (float) coordinates.getY(),\n                        marker.getLabelTextAnchor());\n            }\n            g2.setComposite(savedComposite);\n        }\n        else if (marker instanceof IntervalMarker) {\n            IntervalMarker im = (IntervalMarker) marker;\n            double start = im.getStartValue();\n            double end = im.getEndValue();\n            Range range = axis.getRange();\n            if (!(range.intersects(start, end))) {\n                return;\n            }\n\n            final Composite savedComposite = g2.getComposite();\n            g2.setComposite(AlphaComposite.getInstance(\n                    AlphaComposite.SRC_OVER, marker.getAlpha()));\n\n            double start2d = axis.valueToJava2D(start, dataArea,\n                    plot.getRangeAxisEdge());\n            double end2d = axis.valueToJava2D(end, dataArea,\n                    plot.getRangeAxisEdge());\n            double low = Math.min(start2d, end2d);\n            double high = Math.max(start2d, end2d);\n\n            PlotOrientation orientation = plot.getOrientation();\n            Rectangle2D rect = null;\n            if (orientation == PlotOrientation.HORIZONTAL) {\n                // clip left and right bounds to data area\n                low = Math.max(low, dataArea.getMinX());\n                high = Math.min(high, dataArea.getMaxX());\n                rect = new Rectangle2D.Double(low,\n                        dataArea.getMinY(), high - low,\n                        dataArea.getHeight());\n            }\n            else if (orientation == PlotOrientation.VERTICAL) {\n                // clip top and bottom bounds to data area\n                low = Math.max(low, dataArea.getMinY());\n                high = Math.min(high, dataArea.getMaxY());\n                rect = new Rectangle2D.Double(dataArea.getMinX(),\n                        low, dataArea.getWidth(),\n                        high - low);\n            }\n            Paint p = marker.getPaint();\n            if (p instanceof GradientPaint) {\n                GradientPaint gp = (GradientPaint) p;\n                GradientPaintTransformer t = im.getGradientPaintTransformer();\n                if (t != null) {\n                    gp = t.transform(gp, rect);\n                }\n                g2.setPaint(gp);\n            }\n            else {\n                g2.setPaint(p);\n            }\n            g2.fill(rect);\n\n            // now draw the outlines, if visible...\n            if (im.getOutlinePaint() != null && im.getOutlineStroke() != null) {\n                if (orientation == PlotOrientation.VERTICAL) {\n                    Line2D line = new Line2D.Double();\n                    double x0 = dataArea.getMinX();\n                    double x1 = dataArea.getMaxX();\n                    g2.setPaint(im.getOutlinePaint());\n                    g2.setStroke(im.getOutlineStroke());\n                    if (range.contains(start)) {\n                        line.setLine(x0, start2d, x1, start2d);\n                        g2.draw(line);\n                    }\n                    if (range.contains(end)) {\n                        line.setLine(x0, end2d, x1, end2d);\n                        g2.draw(line);\n                    }\n                }\n                else { // PlotOrientation.HORIZONTAL\n                    Line2D line = new Line2D.Double();\n                    double y0 = dataArea.getMinY();\n                    double y1 = dataArea.getMaxY();\n                    g2.setPaint(im.getOutlinePaint());\n                    g2.setStroke(im.getOutlineStroke());\n                    if (range.contains(start)) {\n                        line.setLine(start2d, y0, start2d, y1);\n                        g2.draw(line);\n                    }\n                    if (range.contains(end)) {\n                        line.setLine(end2d, y0, end2d, y1);\n                        g2.draw(line);\n                    }\n                }\n            }\n\n            String label = marker.getLabel();\n            RectangleAnchor anchor = marker.getLabelAnchor();\n            if (label != null) {\n                Font labelFont = marker.getLabelFont();\n                g2.setFont(labelFont);\n                g2.setPaint(marker.getLabelPaint());\n                Point2D coordinates = calculateRangeMarkerTextAnchorPoint(\n                        g2, orientation, dataArea, rect,\n                        marker.getLabelOffset(), marker.getLabelOffsetType(),\n                        anchor);\n                TextUtilities.drawAlignedString(label, g2,\n                        (float) coordinates.getX(), (float) coordinates.getY(),\n                        marker.getLabelTextAnchor());\n            }\n            g2.setComposite(savedComposite);\n        }\n    }",
    "comment": " Draws a marker for the range axis.  @param g2  the graphics device (not <code>null</code>). @param plot  the plot (not <code>null</code>). @param axis  the range axis (not <code>null</code>). @param marker  the marker to be drawn (not <code>null</code>). @param dataArea  the area inside the axes (not <code>null</code>).  @see #drawDomainMarker(Graphics2D, CategoryPlot, CategoryAxis, CategoryMarker, Rectangle2D) ",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "AbstractCategoryItemRenderer.getColumnCount",
    "class_name": "org.jfree.chart.renderer.category.AbstractCategoryItemRenderer",
    "signature": "org.jfree.chart.renderer.category.AbstractCategoryItemRenderer.getColumnCount()",
    "snippet": "    public int getColumnCount() {\n        return this.columnCount;\n    }",
    "comment": " Returns the number of columns in the dataset.  This value is updated in the {@link AbstractCategoryItemRenderer#initialise} method.  @return The column count. ",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "AbstractCategoryItemRenderer.getDomainAxis",
    "class_name": "org.jfree.chart.renderer.category.AbstractCategoryItemRenderer",
    "signature": "org.jfree.chart.renderer.category.AbstractCategoryItemRenderer.getDomainAxis(CategoryPlot,int)",
    "snippet": "    protected CategoryAxis getDomainAxis(CategoryPlot plot, int index) {\n        CategoryAxis result = plot.getDomainAxis(index);\n        if (result == null) {\n            result = plot.getDomainAxis();\n        }\n        return result;\n    }",
    "comment": " Returns a domain axis for a plot.  @param plot  the plot. @param index  the axis index.  @return A domain axis. ",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "AbstractCategoryItemRenderer.getDrawingSupplier",
    "class_name": "org.jfree.chart.renderer.category.AbstractCategoryItemRenderer",
    "signature": "org.jfree.chart.renderer.category.AbstractCategoryItemRenderer.getDrawingSupplier()",
    "snippet": "    public DrawingSupplier getDrawingSupplier() {\n        DrawingSupplier result = null;\n        CategoryPlot cp = getPlot();\n        if (cp != null) {\n            result = cp.getDrawingSupplier();\n        }\n        return result;\n    }",
    "comment": " Returns the drawing supplier from the plot.  @return The drawing supplier (possibly <code>null</code>). ",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "AbstractCategoryItemRenderer.getItemLabelGenerator",
    "class_name": "org.jfree.chart.renderer.category.AbstractCategoryItemRenderer",
    "signature": "org.jfree.chart.renderer.category.AbstractCategoryItemRenderer.getItemLabelGenerator(int,int)",
    "snippet": "    public CategoryItemLabelGenerator getItemLabelGenerator(int row,\n            int column) {\n        CategoryItemLabelGenerator generator = (CategoryItemLabelGenerator)\n        this.itemLabelGeneratorList.get(row);\n        if (generator == null) {\n            generator = this.baseItemLabelGenerator;\n        }\n        return generator;\n    }",
    "comment": " Returns the item label generator for a data item.  This implementation returns the series item label generator if one is defined, otherwise it returns the default item label generator (which may be  <code>null</code>).  @param row  the row index (zero based). @param column  the column index (zero based).  @return The generator (possibly <code>null</code>). ",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "AbstractCategoryItemRenderer.getLegendItemLabelGenerator",
    "class_name": "org.jfree.chart.renderer.category.AbstractCategoryItemRenderer",
    "signature": "org.jfree.chart.renderer.category.AbstractCategoryItemRenderer.getLegendItemLabelGenerator()",
    "snippet": "    public CategorySeriesLabelGenerator getLegendItemLabelGenerator() {\n        return this.legendItemLabelGenerator;\n    }",
    "comment": " Returns the legend item label generator.  @return The label generator (never <code>null</code>).  @see #setLegendItemLabelGenerator(CategorySeriesLabelGenerator) ",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "AbstractCategoryItemRenderer.getLegendItemToolTipGenerator",
    "class_name": "org.jfree.chart.renderer.category.AbstractCategoryItemRenderer",
    "signature": "org.jfree.chart.renderer.category.AbstractCategoryItemRenderer.getLegendItemToolTipGenerator()",
    "snippet": "    public CategorySeriesLabelGenerator getLegendItemToolTipGenerator() {\n        return this.legendItemToolTipGenerator;\n    }",
    "comment": " Returns the legend item tool tip generator.  @return The tool tip generator (possibly <code>null</code>).  @see #setLegendItemToolTipGenerator(CategorySeriesLabelGenerator) ",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "AbstractCategoryItemRenderer.getLegendItemURLGenerator",
    "class_name": "org.jfree.chart.renderer.category.AbstractCategoryItemRenderer",
    "signature": "org.jfree.chart.renderer.category.AbstractCategoryItemRenderer.getLegendItemURLGenerator()",
    "snippet": "    public CategorySeriesLabelGenerator getLegendItemURLGenerator() {\n        return this.legendItemURLGenerator;\n    }",
    "comment": " Returns the legend item URL generator.  @return The URL generator (possibly <code>null</code>).  @see #setLegendItemURLGenerator(CategorySeriesLabelGenerator) ",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "AbstractCategoryItemRenderer.getPassCount",
    "class_name": "org.jfree.chart.renderer.category.AbstractCategoryItemRenderer",
    "signature": "org.jfree.chart.renderer.category.AbstractCategoryItemRenderer.getPassCount()",
    "snippet": "    public int getPassCount() {\n        return 1;\n    }",
    "comment": " Returns the number of passes through the dataset required by the renderer.  This method returns <code>1</code>, subclasses should override if they need more passes.  @return The pass count. ",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "AbstractCategoryItemRenderer.getPlot",
    "class_name": "org.jfree.chart.renderer.category.AbstractCategoryItemRenderer",
    "signature": "org.jfree.chart.renderer.category.AbstractCategoryItemRenderer.getPlot()",
    "snippet": "    public CategoryPlot getPlot() {\n        return this.plot;\n    }",
    "comment": " Returns the plot that the renderer has been assigned to (where <code>null</code> indicates that the renderer is not currently assigned to a plot).  @return The plot (possibly <code>null</code>).  @see #setPlot(CategoryPlot) ",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "AbstractCategoryItemRenderer.getRowCount",
    "class_name": "org.jfree.chart.renderer.category.AbstractCategoryItemRenderer",
    "signature": "org.jfree.chart.renderer.category.AbstractCategoryItemRenderer.getRowCount()",
    "snippet": "    public int getRowCount() {\n        return this.rowCount;\n    }",
    "comment": " Returns the number of rows in the dataset.  This value is updated in the {@link AbstractCategoryItemRenderer#initialise} method.  @return The row count. ",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "AbstractCategoryItemRenderer.initialise",
    "class_name": "org.jfree.chart.renderer.category.AbstractCategoryItemRenderer",
    "signature": "org.jfree.chart.renderer.category.AbstractCategoryItemRenderer.initialise(Graphics2D,Rectangle2D,CategoryPlot,int,PlotRenderingInfo)",
    "snippet": "    public CategoryItemRendererState initialise(Graphics2D g2,\n                                                Rectangle2D dataArea,\n                                                CategoryPlot plot,\n                                                int rendererIndex,\n                                                PlotRenderingInfo info) {\n\n        setPlot(plot);\n        CategoryDataset data = plot.getDataset(rendererIndex);\n        if (data != null) {\n            this.rowCount = data.getRowCount();\n            this.columnCount = data.getColumnCount();\n        }\n        else {\n            this.rowCount = 0;\n            this.columnCount = 0;\n        }\n        return createState(info);\n\n    }",
    "comment": " Initialises the renderer and returns a state object that will be used for the remainder of the drawing process for a single chart.  The state object allows for the fact that the renderer may be used simultaneously by multiple threads (each thread will work with a separate state object).  @param g2  the graphics device. @param dataArea  the data area. @param plot  the plot. @param rendererIndex  the renderer index. @param info  an object for returning information about the structure of the plot (<code>null</code> permitted).  @return The renderer state. ",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "AbstractCategoryItemRenderer.setPlot",
    "class_name": "org.jfree.chart.renderer.category.AbstractCategoryItemRenderer",
    "signature": "org.jfree.chart.renderer.category.AbstractCategoryItemRenderer.setPlot(CategoryPlot)",
    "snippet": "    public void setPlot(CategoryPlot plot) {\n        if (plot == null) {\n            throw new IllegalArgumentException(\"Null 'plot' argument.\");\n        }\n        this.plot = plot;\n    }",
    "comment": " Sets the plot that the renderer has been assigned to.  This method is usually called by the {@link CategoryPlot}, in normal usage you shouldn't need to call this method directly.  @param plot  the plot (<code>null</code> not permitted).  @see #getPlot() ",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "BarRenderer.BarRenderer",
    "class_name": "org.jfree.chart.renderer.category.BarRenderer",
    "signature": "org.jfree.chart.renderer.category.BarRenderer.BarRenderer()",
    "snippet": "    public BarRenderer() {\n        super();\n        this.base = 0.0;\n        this.includeBaseInRange = true;\n        this.itemMargin = DEFAULT_ITEM_MARGIN;\n        this.drawBarOutline = false;\n        this.maximumBarWidth = 1.0;  \n            // 100 percent, so it will not apply unless changed\n        this.positiveItemLabelPositionFallback = null;\n        this.negativeItemLabelPositionFallback = null;\n        this.gradientPaintTransformer = new StandardGradientPaintTransformer();\n        this.minimumBarLength = 0.0;\n    }",
    "comment": " Creates a new bar renderer with default settings. ",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "BarRenderer.calculateBarWidth",
    "class_name": "org.jfree.chart.renderer.category.BarRenderer",
    "signature": "org.jfree.chart.renderer.category.BarRenderer.calculateBarWidth(CategoryPlot,Rectangle2D,int,CategoryItemRendererState)",
    "snippet": "    protected void calculateBarWidth(CategoryPlot plot, \n                                     Rectangle2D dataArea, \n                                     int rendererIndex,\n                                     CategoryItemRendererState state) {\n                                         \n        CategoryAxis domainAxis = getDomainAxis(plot, rendererIndex);\n        CategoryDataset dataset = plot.getDataset(rendererIndex);\n        if (dataset != null) {\n            int columns = dataset.getColumnCount();\n            int rows = dataset.getRowCount();\n            double space = 0.0;\n            PlotOrientation orientation = plot.getOrientation();\n            if (orientation == PlotOrientation.HORIZONTAL) {\n                space = dataArea.getHeight();\n            }\n            else if (orientation == PlotOrientation.VERTICAL) {\n                space = dataArea.getWidth();\n            }\n            double maxWidth = space * getMaximumBarWidth();\n            double categoryMargin = 0.0;\n            double currentItemMargin = 0.0;\n            if (columns > 1) {\n                categoryMargin = domainAxis.getCategoryMargin();\n            }\n            if (rows > 1) {\n                currentItemMargin = getItemMargin();\n            }\n            double used = space * (1 - domainAxis.getLowerMargin() \n                                     - domainAxis.getUpperMargin()\n                                     - categoryMargin - currentItemMargin);\n            if ((rows * columns) > 0) {\n                state.setBarWidth(Math.min(used / (rows * columns), maxWidth));\n            }\n            else {\n                state.setBarWidth(Math.min(used, maxWidth));\n            }\n        }\n    }",
    "comment": " Calculates the bar width and stores it in the renderer state.  @param plot  the plot. @param dataArea  the data area. @param rendererIndex  the renderer index. @param state  the renderer state. ",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "BarRenderer.findRangeBounds",
    "class_name": "org.jfree.chart.renderer.category.BarRenderer",
    "signature": "org.jfree.chart.renderer.category.BarRenderer.findRangeBounds(CategoryDataset)",
    "snippet": "    public Range findRangeBounds(CategoryDataset dataset) {\n        Range result = DatasetUtilities.findRangeBounds(dataset);\n        if (result != null) {\n            if (this.includeBaseInRange) {\n                result = Range.expandToInclude(result, this.base);\n            }\n        }\n        return result;\n    }",
    "comment": " Returns the range of values the renderer requires to display all the  items from the specified dataset.  This takes into account the range of values in the dataset, plus the flag that determines whether or not the base value for the bars should be included in the range.  @param dataset  the dataset (<code>null</code> permitted).  @return The range (or <code>null</code> if the dataset is  <code>null</code> or empty). ",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "BarRenderer.getLegendItem",
    "class_name": "org.jfree.chart.renderer.category.BarRenderer",
    "signature": "org.jfree.chart.renderer.category.BarRenderer.getLegendItem(int,int)",
    "snippet": "    public LegendItem getLegendItem(int datasetIndex, int series) {\n\n        CategoryPlot cp = getPlot();\n        if (cp == null) {\n            return null;\n        }\n\n        // check that a legend item needs to be displayed...\n        if (!isSeriesVisible(series) || !isSeriesVisibleInLegend(series)) {\n            return null;\n        }\n\n        CategoryDataset dataset = cp.getDataset(datasetIndex);\n        String label = getLegendItemLabelGenerator().generateLabel(dataset, \n                series);\n        String description = label;\n        String toolTipText = null; \n        if (getLegendItemToolTipGenerator() != null) {\n            toolTipText = getLegendItemToolTipGenerator().generateLabel(\n                    dataset, series);   \n        }\n        String urlText = null;\n        if (getLegendItemURLGenerator() != null) {\n            urlText = getLegendItemURLGenerator().generateLabel(dataset, \n                    series);   \n        }\n        Shape shape = new Rectangle2D.Double(-4.0, -4.0, 8.0, 8.0);\n        Paint paint = lookupSeriesPaint(series);\n        Paint outlinePaint = lookupSeriesOutlinePaint(series);\n        Stroke outlineStroke = lookupSeriesOutlineStroke(series);\n\n        LegendItem result = new LegendItem(label, description, toolTipText, \n                urlText, true, shape, true, paint, isDrawBarOutline(), \n                outlinePaint, outlineStroke, false, new Line2D.Float(), \n                new BasicStroke(1.0f), Color.black);\n        result.setDataset(dataset);\n        result.setDatasetIndex(datasetIndex);\n        result.setSeriesKey(dataset.getRowKey(series));\n        result.setSeriesIndex(series);\n        if (this.gradientPaintTransformer != null) {\n            result.setFillPaintTransformer(this.gradientPaintTransformer);\n        }\n        return result;\n    }",
    "comment": " Returns a legend item for a series.  @param datasetIndex  the dataset index (zero-based). @param series  the series index (zero-based).  @return The legend item (possibly <code>null</code>). ",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "BarRenderer.getLowerClip",
    "class_name": "org.jfree.chart.renderer.category.BarRenderer",
    "signature": "org.jfree.chart.renderer.category.BarRenderer.getLowerClip()",
    "snippet": "    public double getLowerClip() {\n        // TODO:  this attribute should be transferred to the renderer state.\n        return this.lowerClip;\n    }",
    "comment": " Returns the lower clip value.  This value is recalculated in the  initialise() method.  @return The value. ",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "BarRenderer.getMaximumBarWidth",
    "class_name": "org.jfree.chart.renderer.category.BarRenderer",
    "signature": "org.jfree.chart.renderer.category.BarRenderer.getMaximumBarWidth()",
    "snippet": "    public double getMaximumBarWidth() {\n        return this.maximumBarWidth;\n    }",
    "comment": " Returns the maximum bar width, as a percentage of the available drawing  space.  @return The maximum bar width.  @see #setMaximumBarWidth(double) ",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "BarRenderer.getUpperClip",
    "class_name": "org.jfree.chart.renderer.category.BarRenderer",
    "signature": "org.jfree.chart.renderer.category.BarRenderer.getUpperClip()",
    "snippet": "    public double getUpperClip() {\n        // TODO:  this attribute should be transferred to the renderer state.\n        return this.upperClip;\n    }",
    "comment": " Returns the upper clip value.  This value is recalculated in the  initialise() method.  @return The value. ",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "BarRenderer.initialise",
    "class_name": "org.jfree.chart.renderer.category.BarRenderer",
    "signature": "org.jfree.chart.renderer.category.BarRenderer.initialise(Graphics2D,Rectangle2D,CategoryPlot,int,PlotRenderingInfo)",
    "snippet": "    public CategoryItemRendererState initialise(Graphics2D g2,\n                                                Rectangle2D dataArea,\n                                                CategoryPlot plot,\n                                                int rendererIndex,\n                                                PlotRenderingInfo info) {\n\n        CategoryItemRendererState state = super.initialise(g2, dataArea, plot, \n                rendererIndex, info);\n\n        // get the clipping values...\n        ValueAxis rangeAxis = plot.getRangeAxisForDataset(rendererIndex);\n        this.lowerClip = rangeAxis.getRange().getLowerBound();\n        this.upperClip = rangeAxis.getRange().getUpperBound();\n\n        // calculate the bar width\n        calculateBarWidth(plot, dataArea, rendererIndex, state);\n\n        return state;\n        \n    }",
    "comment": " Initialises the renderer and returns a state object that will be passed  to subsequent calls to the drawItem method.  This method gets called  once at the start of the process of drawing a chart.  @param g2  the graphics device. @param dataArea  the area in which the data is to be plotted. @param plot  the plot. @param rendererIndex  the renderer index. @param info  collects chart rendering information for return to caller.  @return The renderer state. ",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "BarRenderer.isDrawBarOutline",
    "class_name": "org.jfree.chart.renderer.category.BarRenderer",
    "signature": "org.jfree.chart.renderer.category.BarRenderer.isDrawBarOutline()",
    "snippet": "    public boolean isDrawBarOutline() {\n        return this.drawBarOutline;    \n    }",
    "comment": " Returns a flag that controls whether or not bar outlines are drawn.  @return A boolean.  @see #setDrawBarOutline(boolean) ",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "CategoryItemRendererState.CategoryItemRendererState",
    "class_name": "org.jfree.chart.renderer.category.CategoryItemRendererState",
    "signature": "org.jfree.chart.renderer.category.CategoryItemRendererState.CategoryItemRendererState(PlotRenderingInfo)",
    "snippet": "    public CategoryItemRendererState(PlotRenderingInfo info) {\n        super(info);\n        this.barWidth = 0.0;\n        this.seriesRunningTotal = 0.0;\n    }",
    "comment": " Creates a new object for recording temporary state information for a renderer.  @param info  the plot rendering info (<code>null</code> permitted). ",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "CategoryItemRendererState.getBarWidth",
    "class_name": "org.jfree.chart.renderer.category.CategoryItemRendererState",
    "signature": "org.jfree.chart.renderer.category.CategoryItemRendererState.getBarWidth()",
    "snippet": "    public double getBarWidth() {\n        return this.barWidth;\n    }",
    "comment": " Returns the bar width.  @return The bar width.  @see #setBarWidth(double) ",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "CategoryItemRendererState.setBarWidth",
    "class_name": "org.jfree.chart.renderer.category.CategoryItemRendererState",
    "signature": "org.jfree.chart.renderer.category.CategoryItemRendererState.setBarWidth(double)",
    "snippet": "    public void setBarWidth(double width) {\n        this.barWidth = width;\n    }",
    "comment": " Sets the bar width.  The renderer calculates this value and stores it  here - it is not intended that users can manually set the bar width.  @param width  the width.  @see #getBarWidth() ",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "StatisticalBarRenderer.StatisticalBarRenderer",
    "class_name": "org.jfree.chart.renderer.category.StatisticalBarRenderer",
    "signature": "org.jfree.chart.renderer.category.StatisticalBarRenderer.StatisticalBarRenderer()",
    "snippet": "    public StatisticalBarRenderer() {\n        super();\n        this.errorIndicatorPaint = Color.gray;\n        this.errorIndicatorStroke = new BasicStroke(0.5f);\n    }",
    "comment": " Default constructor. ",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "StatisticalBarRenderer.drawHorizontalItem",
    "class_name": "org.jfree.chart.renderer.category.StatisticalBarRenderer",
    "signature": "org.jfree.chart.renderer.category.StatisticalBarRenderer.drawHorizontalItem(Graphics2D,CategoryItemRendererState,Rectangle2D,CategoryPlot,CategoryAxis,ValueAxis,StatisticalCategoryDataset,int,int)",
    "snippet": "    protected void drawHorizontalItem(Graphics2D g2,\n                                      CategoryItemRendererState state,\n                                      Rectangle2D dataArea,\n                                      CategoryPlot plot,\n                                      CategoryAxis domainAxis,\n                                      ValueAxis rangeAxis,\n                                      StatisticalCategoryDataset dataset,\n                                      int row,\n                                      int column) {\n                                     \n        RectangleEdge xAxisLocation = plot.getDomainAxisEdge();\n        \n        // BAR Y\n        double rectY = domainAxis.getCategoryStart(column, getColumnCount(), \n                dataArea, xAxisLocation);\n\n        int seriesCount = getRowCount();\n        int categoryCount = getColumnCount();\n        if (seriesCount > 1) {\n            double seriesGap = dataArea.getHeight() * getItemMargin()\n                               / (categoryCount * (seriesCount - 1));\n            rectY = rectY + row * (state.getBarWidth() + seriesGap);\n        }\n        else {\n            rectY = rectY + row * state.getBarWidth();\n        }\n\n        // BAR X\n        Number meanValue = dataset.getMeanValue(row, column);\n\n        double value = meanValue.doubleValue();\n        double base = 0.0;\n        double lclip = getLowerClip();\n        double uclip = getUpperClip();\n\n        if (uclip <= 0.0) {  // cases 1, 2, 3 and 4\n            if (value >= uclip) {\n                return; // bar is not visible\n            }\n            base = uclip;\n            if (value <= lclip) {\n                value = lclip;\n            }\n        }\n        else if (lclip <= 0.0) { // cases 5, 6, 7 and 8\n            if (value >= uclip) {\n                value = uclip;\n            }\n            else {\n                if (value <= lclip) {\n                    value = lclip;\n                }\n            }\n        }\n        else { // cases 9, 10, 11 and 12\n            if (value <= lclip) {\n                return; // bar is not visible\n            }\n            base = getLowerClip();\n            if (value >= uclip) {\n               value = uclip;\n            }\n        }\n\n        RectangleEdge yAxisLocation = plot.getRangeAxisEdge();\n        double transY1 = rangeAxis.valueToJava2D(base, dataArea, yAxisLocation);\n        double transY2 = rangeAxis.valueToJava2D(value, dataArea, \n                yAxisLocation);\n        double rectX = Math.min(transY2, transY1);\n\n        double rectHeight = state.getBarWidth();\n        double rectWidth = Math.abs(transY2 - transY1);\n\n        Rectangle2D bar = new Rectangle2D.Double(rectX, rectY, rectWidth, \n                rectHeight);\n        Paint seriesPaint = getItemPaint(row, column);\n        g2.setPaint(seriesPaint);\n        g2.fill(bar);\n        if (isDrawBarOutline() && state.getBarWidth() > 3) {\n            g2.setStroke(getItemStroke(row, column));\n            g2.setPaint(getItemOutlinePaint(row, column));\n            g2.draw(bar);\n        }\n\n        // standard deviation lines\n            double valueDelta = dataset.getStdDevValue(row, column).doubleValue();\n            double highVal = rangeAxis.valueToJava2D(meanValue.doubleValue() \n                    + valueDelta, dataArea, yAxisLocation);\n            double lowVal = rangeAxis.valueToJava2D(meanValue.doubleValue() \n                    - valueDelta, dataArea, yAxisLocation);\n\n            if (this.errorIndicatorStroke != null) {\n                g2.setStroke(this.errorIndicatorStroke);\n            }\n            else {\n                g2.setStroke(getItemOutlineStroke(row, column));\n            }\n            if (this.errorIndicatorPaint != null) {\n                g2.setPaint(this.errorIndicatorPaint);  \n            }\n            else {\n                g2.setPaint(getItemOutlinePaint(row, column));   \n            }\n        \n            Line2D line = null;\n            line = new Line2D.Double(lowVal, rectY + rectHeight / 2.0d, \n                                     highVal, rectY + rectHeight / 2.0d);\n            g2.draw(line);\n            line = new Line2D.Double(highVal, rectY + rectHeight * 0.25, \n                                     highVal, rectY + rectHeight * 0.75);\n            g2.draw(line);\n            line = new Line2D.Double(lowVal, rectY + rectHeight * 0.25, \n                                     lowVal, rectY + rectHeight * 0.75);\n            g2.draw(line);\n        \n        CategoryItemLabelGenerator generator = getItemLabelGenerator(row, \n                column);\n        if (generator != null && isItemLabelVisible(row, column)) {\n            drawItemLabel(g2, dataset, row, column, plot, generator, bar, \n                    (value < 0.0));\n        }        \n\n        // add an item entity, if this information is being collected\n        EntityCollection entities = state.getEntityCollection();\n        if (entities != null) {\n            addItemEntity(entities, dataset, row, column, bar);\n        }\n\n    }",
    "comment": " Draws an item for a plot with a horizontal orientation.  @param g2  the graphics device. @param state  the renderer state. @param dataArea  the data area. @param plot  the plot. @param domainAxis  the domain axis. @param rangeAxis  the range axis. @param dataset  the data. @param row  the row index (zero-based). @param column  the column index (zero-based). ",
    "is_bug": true,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "StatisticalBarRenderer.drawItem",
    "class_name": "org.jfree.chart.renderer.category.StatisticalBarRenderer",
    "signature": "org.jfree.chart.renderer.category.StatisticalBarRenderer.drawItem(Graphics2D,CategoryItemRendererState,Rectangle2D,CategoryPlot,CategoryAxis,ValueAxis,CategoryDataset,int,int,int)",
    "snippet": "    public void drawItem(Graphics2D g2,\n                         CategoryItemRendererState state,\n                         Rectangle2D dataArea,\n                         CategoryPlot plot,\n                         CategoryAxis domainAxis,\n                         ValueAxis rangeAxis,\n                         CategoryDataset data,\n                         int row,\n                         int column,\n                         int pass) {\n\n        // defensive check\n        if (!(data instanceof StatisticalCategoryDataset)) {\n            throw new IllegalArgumentException(\n                \"Requires StatisticalCategoryDataset.\");\n        }\n        StatisticalCategoryDataset statData = (StatisticalCategoryDataset) data;\n\n        PlotOrientation orientation = plot.getOrientation();\n        if (orientation == PlotOrientation.HORIZONTAL) {\n            drawHorizontalItem(g2, state, dataArea, plot, domainAxis, \n                    rangeAxis, statData, row, column);\n        }\n        else if (orientation == PlotOrientation.VERTICAL) {\n            drawVerticalItem(g2, state, dataArea, plot, domainAxis, rangeAxis, \n                    statData, row, column);\n        }\n    }",
    "comment": " Draws the bar with its standard deviation line range for a single  (series, category) data item.  @param g2  the graphics device. @param state  the renderer state. @param dataArea  the data area. @param plot  the plot. @param domainAxis  the domain axis. @param rangeAxis  the range axis. @param data  the data. @param row  the row index (zero-based). @param column  the column index (zero-based). @param pass  the pass index. ",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "StatisticalBarRenderer.drawVerticalItem",
    "class_name": "org.jfree.chart.renderer.category.StatisticalBarRenderer",
    "signature": "org.jfree.chart.renderer.category.StatisticalBarRenderer.drawVerticalItem(Graphics2D,CategoryItemRendererState,Rectangle2D,CategoryPlot,CategoryAxis,ValueAxis,StatisticalCategoryDataset,int,int)",
    "snippet": "    protected void drawVerticalItem(Graphics2D g2,\n                                    CategoryItemRendererState state,\n                                    Rectangle2D dataArea,\n                                    CategoryPlot plot,\n                                    CategoryAxis domainAxis,\n                                    ValueAxis rangeAxis,\n                                    StatisticalCategoryDataset dataset,\n                                    int row,\n                                    int column) {\n                                     \n        RectangleEdge xAxisLocation = plot.getDomainAxisEdge();\n        \n        // BAR X\n        double rectX = domainAxis.getCategoryStart(\n            column, getColumnCount(), dataArea, xAxisLocation\n        );\n\n        int seriesCount = getRowCount();\n        int categoryCount = getColumnCount();\n        if (seriesCount > 1) {\n            double seriesGap = dataArea.getWidth() * getItemMargin()\n                               / (categoryCount * (seriesCount - 1));\n            rectX = rectX + row * (state.getBarWidth() + seriesGap);\n        }\n        else {\n            rectX = rectX + row * state.getBarWidth();\n        }\n\n        // BAR Y\n        Number meanValue = dataset.getMeanValue(row, column);\n\n        double value = meanValue.doubleValue();\n        double base = 0.0;\n        double lclip = getLowerClip();\n        double uclip = getUpperClip();\n\n        if (uclip <= 0.0) {  // cases 1, 2, 3 and 4\n            if (value >= uclip) {\n                return; // bar is not visible\n            }\n            base = uclip;\n            if (value <= lclip) {\n                value = lclip;\n            }\n        }\n        else if (lclip <= 0.0) { // cases 5, 6, 7 and 8\n            if (value >= uclip) {\n                value = uclip;\n            }\n            else {\n                if (value <= lclip) {\n                    value = lclip;\n                }\n            }\n        }\n        else { // cases 9, 10, 11 and 12\n            if (value <= lclip) {\n                return; // bar is not visible\n            }\n            base = getLowerClip();\n            if (value >= uclip) {\n               value = uclip;\n            }\n        }\n\n        RectangleEdge yAxisLocation = plot.getRangeAxisEdge();\n        double transY1 = rangeAxis.valueToJava2D(base, dataArea, yAxisLocation);\n        double transY2 = rangeAxis.valueToJava2D(value, dataArea, \n                yAxisLocation);\n        double rectY = Math.min(transY2, transY1);\n\n        double rectWidth = state.getBarWidth();\n        double rectHeight = Math.abs(transY2 - transY1);\n\n        Rectangle2D bar = new Rectangle2D.Double(rectX, rectY, rectWidth, \n                rectHeight);\n        Paint seriesPaint = getItemPaint(row, column);\n        g2.setPaint(seriesPaint);\n        g2.fill(bar);\n        if (isDrawBarOutline() && state.getBarWidth() > 3) {\n            g2.setStroke(getItemStroke(row, column));\n            g2.setPaint(getItemOutlinePaint(row, column));\n            g2.draw(bar);\n        }\n\n        // standard deviation lines\n            double valueDelta = dataset.getStdDevValue(row, column).doubleValue();\n            double highVal = rangeAxis.valueToJava2D(meanValue.doubleValue() \n                    + valueDelta, dataArea, yAxisLocation);\n            double lowVal = rangeAxis.valueToJava2D(meanValue.doubleValue() \n                    - valueDelta, dataArea, yAxisLocation);\n\n            if (this.errorIndicatorStroke != null) {\n                g2.setStroke(this.errorIndicatorStroke);\n            }\n            else {\n                g2.setStroke(getItemOutlineStroke(row, column));\n            }\n            if (this.errorIndicatorPaint != null) {\n                g2.setPaint(this.errorIndicatorPaint);  \n            }\n            else {\n                g2.setPaint(getItemOutlinePaint(row, column));   \n            }\n            Line2D line = null;\n            line = new Line2D.Double(rectX + rectWidth / 2.0d, lowVal,\n                                     rectX + rectWidth / 2.0d, highVal);\n            g2.draw(line);\n            line = new Line2D.Double(rectX + rectWidth / 2.0d - 5.0d, highVal,\n                                     rectX + rectWidth / 2.0d + 5.0d, highVal);\n            g2.draw(line);\n            line = new Line2D.Double(rectX + rectWidth / 2.0d - 5.0d, lowVal,\n                                     rectX + rectWidth / 2.0d + 5.0d, lowVal);\n            g2.draw(line);\n        \n        CategoryItemLabelGenerator generator = getItemLabelGenerator(row, \n                column);\n        if (generator != null && isItemLabelVisible(row, column)) {\n            drawItemLabel(g2, dataset, row, column, plot, generator, bar, \n                    (value < 0.0));\n        }        \n\n        // add an item entity, if this information is being collected\n        EntityCollection entities = state.getEntityCollection();\n        if (entities != null) {\n            addItemEntity(entities, dataset, row, column, bar);\n        }\n    }",
    "comment": " Draws an item for a plot with a vertical orientation.  @param g2  the graphics device. @param state  the renderer state. @param dataArea  the data area. @param plot  the plot. @param domainAxis  the domain axis. @param rangeAxis  the range axis. @param dataset  the data. @param row  the row index (zero-based). @param column  the column index (zero-based). ",
    "is_bug": true,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "JFreeChartResources.getContents",
    "class_name": "org.jfree.chart.resources.JFreeChartResources",
    "signature": "org.jfree.chart.resources.JFreeChartResources.getContents()",
    "snippet": "    public Object[][] getContents() {\n        return CONTENTS;\n    }",
    "comment": " Returns the array of strings in the resource bundle.  @return The resources. ",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "G2TextMeasurer.G2TextMeasurer",
    "class_name": "org.jfree.chart.text.G2TextMeasurer",
    "signature": "org.jfree.chart.text.G2TextMeasurer.G2TextMeasurer(Graphics2D)",
    "snippet": "    public G2TextMeasurer(Graphics2D g2) {\n        this.g2 = g2;\n    }",
    "comment": " Creates a new text measurer.  @param g2  the graphics device. ",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "G2TextMeasurer.getStringWidth",
    "class_name": "org.jfree.chart.text.G2TextMeasurer",
    "signature": "org.jfree.chart.text.G2TextMeasurer.getStringWidth(String,int,int)",
    "snippet": "    public float getStringWidth(String text, int start, int end) {\n        FontMetrics fm = this.g2.getFontMetrics();\n        Rectangle2D bounds = TextUtilities.getTextBounds(text.substring(start, \n                end), this.g2, fm);\n        float result = (float) bounds.getWidth();\n        return result;\n    }",
    "comment": " Returns the string width.  @param text  the text. @param start  the index of the first character to measure. @param end  the index of the last character to measure.  @return The string width. ",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "TextBlock.TextBlock",
    "class_name": "org.jfree.chart.text.TextBlock",
    "signature": "org.jfree.chart.text.TextBlock.TextBlock()",
    "snippet": "    public TextBlock() {\n        this.lines = new java.util.ArrayList();\n        this.lineAlignment = HorizontalAlignment.CENTER;\n    }",
    "comment": " Creates a new empty text block. ",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "TextBlock.addLine",
    "class_name": "org.jfree.chart.text.TextBlock",
    "signature": "org.jfree.chart.text.TextBlock.addLine(String,Font,Paint)",
    "snippet": "    public void addLine(String text, Font font, Paint paint) {\n        addLine(new TextLine(text, font, paint));\n    }",
    "comment": " Adds a line of text that will be displayed using the specified font.  @param text  the text. @param font  the font. @param paint  the paint. ",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "TextBlock.addLine",
    "class_name": "org.jfree.chart.text.TextBlock",
    "signature": "org.jfree.chart.text.TextBlock.addLine(TextLine)",
    "snippet": "    public void addLine(TextLine line) {\n        this.lines.add(line);    \n    }",
    "comment": " Adds a {@link TextLine} to the block.  @param line  the line. ",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "TextBlock.calculateBounds",
    "class_name": "org.jfree.chart.text.TextBlock",
    "signature": "org.jfree.chart.text.TextBlock.calculateBounds(Graphics2D,float,float,TextBlockAnchor,float,float,double)",
    "snippet": "    public Shape calculateBounds(Graphics2D g2, float anchorX, float anchorY, \n            TextBlockAnchor anchor, float rotateX, float rotateY, \n            double angle) {\n        \n        Size2D d = calculateDimensions(g2);\n        float[] offsets = calculateOffsets(anchor, d.getWidth(), d.getHeight());\n        Rectangle2D bounds = new Rectangle2D.Double(anchorX + offsets[0], \n                anchorY + offsets[1], d.getWidth(), d.getHeight());\n        Shape rotatedBounds = ShapeUtilities.rotateShape(bounds, angle, \n                rotateX, rotateY);\n        return rotatedBounds;   \n        \n    }",
    "comment": " Returns the bounds of the text block.  @param g2  the graphics device (<code>null</code> not permitted). @param anchorX  the x-coordinate for the anchor point. @param anchorY  the y-coordinate for the anchor point. @param anchor  the text block anchor (<code>null</code> not permitted). @param rotateX  the x-coordinate for the rotation point. @param rotateY  the y-coordinate for the rotation point. @param angle  the rotation angle.  @return The bounds. ",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "TextBlock.calculateDimensions",
    "class_name": "org.jfree.chart.text.TextBlock",
    "signature": "org.jfree.chart.text.TextBlock.calculateDimensions(Graphics2D)",
    "snippet": "    public Size2D calculateDimensions(Graphics2D g2) {\n        double width = 0.0;\n        double height = 0.0;\n        Iterator iterator = this.lines.iterator();\n        while (iterator.hasNext()) {\n            TextLine line = (TextLine) iterator.next();\n            Size2D dimension = line.calculateDimensions(g2);\n            width = Math.max(width, dimension.getWidth());\n            height = height + dimension.getHeight();\n        }\n        return new Size2D(width, height);\n    }",
    "comment": " Returns the width and height of the text block.  @param g2  the graphics device.  @return The width and height. ",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "TextBlock.calculateOffsets",
    "class_name": "org.jfree.chart.text.TextBlock",
    "signature": "org.jfree.chart.text.TextBlock.calculateOffsets(TextBlockAnchor,double,double)",
    "snippet": "    private float[] calculateOffsets(TextBlockAnchor anchor, \n                                     double width, double height) {\n        float[] result = new float[2];\n        float xAdj = 0.0f;\n        float yAdj = 0.0f;\n\n        if (anchor == TextBlockAnchor.TOP_CENTER\n                || anchor == TextBlockAnchor.CENTER\n                || anchor == TextBlockAnchor.BOTTOM_CENTER) {\n                    \n            xAdj = (float) -width / 2.0f;\n            \n        }\n        else if (anchor == TextBlockAnchor.TOP_RIGHT\n                || anchor == TextBlockAnchor.CENTER_RIGHT\n                || anchor == TextBlockAnchor.BOTTOM_RIGHT) {\n                    \n            xAdj = (float) -width;\n            \n        }\n\n        if (anchor == TextBlockAnchor.TOP_LEFT\n                || anchor == TextBlockAnchor.TOP_CENTER\n                || anchor == TextBlockAnchor.TOP_RIGHT) {\n                    \n            yAdj = 0.0f;\n            \n        }\n        else if (anchor == TextBlockAnchor.CENTER_LEFT\n                || anchor == TextBlockAnchor.CENTER\n                || anchor == TextBlockAnchor.CENTER_RIGHT) {\n                    \n            yAdj = (float) -height / 2.0f;\n            \n        }\n        else if (anchor == TextBlockAnchor.BOTTOM_LEFT\n                || anchor == TextBlockAnchor.BOTTOM_CENTER\n                || anchor == TextBlockAnchor.BOTTOM_RIGHT) {\n                    \n            yAdj = (float) -height;\n            \n        }\n        result[0] = xAdj;\n        result[1] = yAdj;\n        return result;\n    }   ",
    "comment": " Calculates the x and y offsets required to align the text block with the specified anchor point.  This assumes that the top left of the text  block is at (0.0, 0.0).  @param anchor  the anchor position. @param width  the width of the text block. @param height  the height of the text block.  @return The offsets (float[0] = x offset, float[1] = y offset). ",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "TextBlock.draw",
    "class_name": "org.jfree.chart.text.TextBlock",
    "signature": "org.jfree.chart.text.TextBlock.draw(Graphics2D,float,float,TextBlockAnchor)",
    "snippet": "    public void draw(Graphics2D g2, float x, float y, TextBlockAnchor anchor) {\n        draw(g2, x, y, anchor, 0.0f, 0.0f, 0.0);\n    }",
    "comment": " Draws the text block at a specific location.  @param g2  the graphics device. @param x  the x-coordinate for the anchor point. @param y  the y-coordinate for the anchor point. @param anchor  the anchor point. ",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "TextBlock.draw",
    "class_name": "org.jfree.chart.text.TextBlock",
    "signature": "org.jfree.chart.text.TextBlock.draw(Graphics2D,float,float,TextBlockAnchor,float,float,double)",
    "snippet": "    public void draw(Graphics2D g2, float anchorX, float anchorY, \n                     TextBlockAnchor anchor, float rotateX, float rotateY, \n                     double angle) {\n    \n        Size2D d = calculateDimensions(g2);\n        float[] offsets = calculateOffsets(anchor, d.getWidth(), d.getHeight());\n        Iterator iterator = this.lines.iterator();\n        float yCursor = 0.0f;\n        while (iterator.hasNext()) {\n            TextLine line = (TextLine) iterator.next();\n            Size2D dimension = line.calculateDimensions(g2);\n            float lineOffset = 0.0f;\n            if (this.lineAlignment == HorizontalAlignment.CENTER) {\n                lineOffset = (float) (d.getWidth() - dimension.getWidth()) \n                    / 2.0f;   \n            }\n            else if (this.lineAlignment == HorizontalAlignment.RIGHT) {\n                lineOffset = (float) (d.getWidth() - dimension.getWidth());   \n            }\n            line.draw(g2, anchorX + offsets[0] + lineOffset, anchorY \n                    + offsets[1] + yCursor, TextAnchor.TOP_LEFT, rotateX, \n                    rotateY, angle);\n            yCursor = yCursor + (float) dimension.getHeight();\n        }\n        \n    }",
    "comment": " Draws the text block, aligning it with the specified anchor point and  rotating it about the specified rotation point.  @param g2  the graphics device. @param anchorX  the x-coordinate for the anchor point. @param anchorY  the y-coordinate for the anchor point. @param anchor  the point on the text block that is aligned to the  anchor point. @param rotateX  the x-coordinate for the rotation point. @param rotateY  the x-coordinate for the rotation point. @param angle  the rotation (in radians). ",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "TextFragment.TextFragment",
    "class_name": "org.jfree.chart.text.TextFragment",
    "signature": "org.jfree.chart.text.TextFragment.TextFragment(String,Font,Paint)",
    "snippet": "    public TextFragment(String text, Font font, Paint paint) {\n        this(text, font, paint, 0.0f);\n    }",
    "comment": " Creates a new text fragment.  @param text  the text (<code>null</code> not permitted). @param font  the font (<code>null</code> not permitted). @param paint  the text color (<code>null</code> not permitted). ",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "TextFragment.TextFragment",
    "class_name": "org.jfree.chart.text.TextFragment",
    "signature": "org.jfree.chart.text.TextFragment.TextFragment(String,Font,Paint,float)",
    "snippet": "    public TextFragment(String text, Font font, Paint paint,\n                        float baselineOffset) {\n        if (text == null) {\n            throw new IllegalArgumentException(\"Null 'text' argument.\");  \n        }\n        if (font == null) {\n            throw new IllegalArgumentException(\"Null 'font' argument.\");\n        }\n        if (paint == null) {\n            throw new IllegalArgumentException(\"Null 'paint' argument.\");\n        }\n        this.text = text;\n        this.font = font;\n        this.paint = paint;\n        this.baselineOffset = baselineOffset;\n    }",
    "comment": " Creates a new text fragment.  @param text  the text (<code>null</code> not permitted). @param font  the font (<code>null</code> not permitted). @param paint  the text color (<code>null</code> not permitted). @param baselineOffset  the baseline offset. ",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "TextFragment.calculateBaselineOffset",
    "class_name": "org.jfree.chart.text.TextFragment",
    "signature": "org.jfree.chart.text.TextFragment.calculateBaselineOffset(Graphics2D,TextAnchor)",
    "snippet": "    public float calculateBaselineOffset(Graphics2D g2, TextAnchor anchor) {\n        float result = 0.0f;\n        FontMetrics fm = g2.getFontMetrics(this.font);\n        LineMetrics lm = fm.getLineMetrics(\"ABCxyz\", g2);\n        if (anchor == TextAnchor.TOP_LEFT || anchor == TextAnchor.TOP_CENTER\n                                          || anchor == TextAnchor.TOP_RIGHT) {\n            result = lm.getAscent();\n        }\n        else if (anchor == TextAnchor.BOTTOM_LEFT \n                || anchor == TextAnchor.BOTTOM_CENTER\n                || anchor == TextAnchor.BOTTOM_RIGHT) {\n            result = -lm.getDescent() - lm.getLeading();\n        }\n        return result;                                             \n    }",
    "comment": " Calculates the vertical offset between the baseline and the specified  text anchor.  @param g2  the graphics device. @param anchor  the anchor.  @return the offset. ",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "TextFragment.calculateDimensions",
    "class_name": "org.jfree.chart.text.TextFragment",
    "signature": "org.jfree.chart.text.TextFragment.calculateDimensions(Graphics2D)",
    "snippet": "    public Size2D calculateDimensions(Graphics2D g2) {\n        FontMetrics fm = g2.getFontMetrics(this.font);\n        Rectangle2D bounds = TextUtilities.getTextBounds(this.text, g2, fm);\n        Size2D result = new Size2D(bounds.getWidth(), bounds.getHeight());\n        return result;\n    }",
    "comment": " Calculates the dimensions of the text fragment.  @param g2  the graphics device.  @return The width and height of the text. ",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "TextFragment.draw",
    "class_name": "org.jfree.chart.text.TextFragment",
    "signature": "org.jfree.chart.text.TextFragment.draw(Graphics2D,float,float,TextAnchor,float,float,double)",
    "snippet": "    public void draw(Graphics2D g2, float anchorX, \n                     float anchorY, TextAnchor anchor,\n                     float rotateX, float rotateY, \n                     double angle) {\n    \n        g2.setFont(this.font);\n        g2.setPaint(this.paint);\n        TextUtilities.drawRotatedString(this.text, g2, anchorX, anchorY \n                + this.baselineOffset, anchor, angle, rotateX, rotateY);\n    \n    }",
    "comment": " Draws the text fragment.  @param g2  the graphics device. @param anchorX  the x-coordinate of the anchor point. @param anchorY  the y-coordinate of the anchor point. @param anchor  the location of the text that is aligned to the anchor  point. @param rotateX  the x-coordinate of the rotation point. @param rotateY  the y-coordinate of the rotation point. @param angle  the angle. ",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "TextLine.TextLine",
    "class_name": "org.jfree.chart.text.TextLine",
    "signature": "org.jfree.chart.text.TextLine.TextLine(String,Font,Paint)",
    "snippet": "    public TextLine(String text, Font font, Paint paint) {\n        if (text == null) {\n            throw new IllegalArgumentException(\"Null 'text' argument.\");   \n        }\n        if (font == null) {\n            throw new IllegalArgumentException(\"Null 'font' argument.\");   \n        }\n        if (paint == null) {\n            throw new IllegalArgumentException(\"Null 'paint' argument.\");   \n        }\n        this.fragments = new java.util.ArrayList();\n        TextFragment fragment = new TextFragment(text, font, paint);\n        this.fragments.add(fragment);\n    }",
    "comment": " Creates a new text line.  @param text  the text (<code>null</code> not permitted). @param font  the text font (<code>null</code> not permitted). @param paint  the text color (<code>null</code> not permitted). ",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "TextLine.calculateBaselineOffset",
    "class_name": "org.jfree.chart.text.TextLine",
    "signature": "org.jfree.chart.text.TextLine.calculateBaselineOffset(Graphics2D,TextAnchor)",
    "snippet": "    private float calculateBaselineOffset(Graphics2D g2, \n                                          TextAnchor anchor) {\n        float result = 0.0f;\n        Iterator iterator = this.fragments.iterator();\n        while (iterator.hasNext()) {\n            TextFragment fragment = (TextFragment) iterator.next();\n            result = Math.max(result, \n                    fragment.calculateBaselineOffset(g2, anchor));\n        }\n        return result;\n    }",
    "comment": " Calculate the offsets required to translate from the specified anchor  position to the left baseline position.  @param g2  the graphics device. @param anchor  the anchor position.  @return The offsets. ",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "TextLine.calculateDimensions",
    "class_name": "org.jfree.chart.text.TextLine",
    "signature": "org.jfree.chart.text.TextLine.calculateDimensions(Graphics2D)",
    "snippet": "    public Size2D calculateDimensions(Graphics2D g2) {\n        double width = 0.0;\n        double height = 0.0;\n        Iterator iterator = this.fragments.iterator();\n        while (iterator.hasNext()) {\n            TextFragment fragment = (TextFragment) iterator.next();\n            Size2D dimension = fragment.calculateDimensions(g2);\n            width = width + dimension.getWidth();\n            height = Math.max(height, dimension.getHeight());\n        }\n        return new Size2D(width, height);\n    }",
    "comment": " Calculates the width and height of the text line.  @param g2  the graphics device.  @return The width and height. ",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "TextLine.draw",
    "class_name": "org.jfree.chart.text.TextLine",
    "signature": "org.jfree.chart.text.TextLine.draw(Graphics2D,float,float,TextAnchor,float,float,double)",
    "snippet": "    public void draw(Graphics2D g2, float anchorX, float anchorY, \n                     TextAnchor anchor, float rotateX, float rotateY, \n                     double angle) {\n    \n        float x = anchorX;\n        float yOffset = calculateBaselineOffset(g2, anchor);\n        Iterator iterator = this.fragments.iterator();\n        while (iterator.hasNext()) {\n            TextFragment fragment = (TextFragment) iterator.next();\n            Size2D d = fragment.calculateDimensions(g2);\n            fragment.draw(g2, x, anchorY + yOffset, TextAnchor.BASELINE_LEFT, \n                    rotateX, rotateY, angle);\n            x = x + (float) d.getWidth();\n        }\n    \n    }",
    "comment": " Draws the text line.  @param g2  the graphics device. @param anchorX  the x-coordinate for the anchor point. @param anchorY  the y-coordinate for the anchor point. @param anchor  the point on the text line that is aligned to the anchor  point. @param rotateX  the x-coordinate for the rotation point. @param rotateY  the y-coordinate for the rotation point. @param angle  the rotation angle (in radians). ",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "TextUtilities.createTextBlock",
    "class_name": "org.jfree.chart.text.TextUtilities",
    "signature": "org.jfree.chart.text.TextUtilities.createTextBlock(String,Font,Paint)",
    "snippet": "    public static TextBlock createTextBlock(String text, Font font,\n                                            Paint paint) {\n        if (text == null) {\n            throw new IllegalArgumentException(\"Null 'text' argument.\");\n        }\n        TextBlock result = new TextBlock();\n        String input = text;\n        boolean moreInputToProcess = (text.length() > 0);\n        int start = 0;\n        while (moreInputToProcess) {\n            int index = input.indexOf(\"\\n\");\n            if (index > start) {\n                String line = input.substring(start, index);\n                if (index < input.length() - 1) {\n                    result.addLine(line, font, paint);\n                    input = input.substring(index + 1);\n                }\n                else {\n                    moreInputToProcess = false;\n                }\n            }\n            else if (index == start) {\n                if (index < input.length() - 1) {\n                    input = input.substring(index + 1);\n                }\n                else {\n                    moreInputToProcess = false;\n                }\n            }\n            else {\n                result.addLine(input, font, paint);\n                moreInputToProcess = false;\n            }\n        }\n        return result;\n    }",
    "comment": " Creates a {@link TextBlock} from a <code>String</code>.  Line breaks  are added where the <code>String</code> contains '\\n' characters.  @param text  the text. @param font  the font. @param paint  the paint.  @return A text block. ",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "TextUtilities.createTextBlock",
    "class_name": "org.jfree.chart.text.TextUtilities",
    "signature": "org.jfree.chart.text.TextUtilities.createTextBlock(String,Font,Paint,float,int,TextMeasurer)",
    "snippet": "    public static TextBlock createTextBlock(String text, Font font,\n            Paint paint, float maxWidth, int maxLines, TextMeasurer measurer) {\n        \n        TextBlock result = new TextBlock();\n        BreakIterator iterator = BreakIterator.getLineInstance();\n        iterator.setText(text);\n        int current = 0;\n        int lines = 0;\n        int length = text.length();\n        while (current < length && lines < maxLines) {\n            int next = nextLineBreak(text, current, maxWidth, iterator, \n                    measurer);\n            if (next == BreakIterator.DONE) {\n                result.addLine(text.substring(current), font, paint);\n                return result;\n            }\n            result.addLine(text.substring(current, next), font, paint);\n            lines++;\n            current = next;\n            while (current < text.length()&& text.charAt(current) == '\\n') {\n                current++;\n            }\n        }\n        if (current < length) {\n            TextLine lastLine = result.getLastLine();\n            TextFragment lastFragment = lastLine.getLastTextFragment();\n            String oldStr = lastFragment.getText();\n            String newStr = \"...\";\n            if (oldStr.length() > 3) {\n                newStr = oldStr.substring(0, oldStr.length() - 3) + \"...\";\n            }\n\n            lastLine.removeFragment(lastFragment);\n            TextFragment newFragment = new TextFragment(newStr, \n                    lastFragment.getFont(), lastFragment.getPaint());\n            lastLine.addFragment(newFragment);\n        }\n        return result;\n    }",
    "comment": " Creates a new text block from the given string, breaking the text into lines so that the <code>maxWidth</code> value is respected.  @param text  the text. @param font  the font. @param paint  the paint. @param maxWidth  the maximum width for each line. @param maxLines  the maximum number of lines. @param measurer  the text measurer.  @return A text block. ",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "TextUtilities.deriveRotationAnchorOffsets",
    "class_name": "org.jfree.chart.text.TextUtilities",
    "signature": "org.jfree.chart.text.TextUtilities.deriveRotationAnchorOffsets(Graphics2D,String,TextAnchor)",
    "snippet": "    private static float[] deriveRotationAnchorOffsets(Graphics2D g2,\n            String text, TextAnchor anchor) {\n\n        float[] result = new float[2];\n        FontRenderContext frc = g2.getFontRenderContext();\n        LineMetrics metrics = g2.getFont().getLineMetrics(text, frc);\n        FontMetrics fm = g2.getFontMetrics();\n        Rectangle2D bounds = TextUtilities.getTextBounds(text, g2, fm);\n        float ascent = metrics.getAscent();\n        float halfAscent = ascent / 2.0f;\n        float descent = metrics.getDescent();\n        float leading = metrics.getLeading();\n        float xAdj = 0.0f;\n        float yAdj = 0.0f;\n\n        if (anchor == TextAnchor.TOP_LEFT\n                || anchor == TextAnchor.CENTER_LEFT\n                || anchor == TextAnchor.BOTTOM_LEFT\n                || anchor == TextAnchor.BASELINE_LEFT\n                || anchor == TextAnchor.HALF_ASCENT_LEFT) {\n\n            xAdj = 0.0f;\n\n        }\n        else if (anchor == TextAnchor.TOP_CENTER\n                || anchor == TextAnchor.CENTER\n                || anchor == TextAnchor.BOTTOM_CENTER\n                || anchor == TextAnchor.BASELINE_CENTER\n                || anchor == TextAnchor.HALF_ASCENT_CENTER) {\n\n            xAdj = (float) bounds.getWidth() / 2.0f;\n\n        }\n        else if (anchor == TextAnchor.TOP_RIGHT\n                || anchor == TextAnchor.CENTER_RIGHT\n                || anchor == TextAnchor.BOTTOM_RIGHT\n                || anchor == TextAnchor.BASELINE_RIGHT\n                || anchor == TextAnchor.HALF_ASCENT_RIGHT) {\n\n            xAdj = (float) bounds.getWidth();\n\n        }\n\n        if (anchor == TextAnchor.TOP_LEFT\n                || anchor == TextAnchor.TOP_CENTER\n                || anchor == TextAnchor.TOP_RIGHT) {\n\n            yAdj = descent + leading - (float) bounds.getHeight();\n\n        }\n        else if (anchor == TextAnchor.CENTER_LEFT\n                || anchor == TextAnchor.CENTER\n                || anchor == TextAnchor.CENTER_RIGHT) {\n\n            yAdj = descent + leading - (float) (bounds.getHeight() / 2.0);\n\n        }\n        else if (anchor == TextAnchor.HALF_ASCENT_LEFT\n                || anchor == TextAnchor.HALF_ASCENT_CENTER\n                || anchor == TextAnchor.HALF_ASCENT_RIGHT) {\n\n            yAdj = -halfAscent;\n\n        }\n        else if (anchor == TextAnchor.BASELINE_LEFT\n                || anchor == TextAnchor.BASELINE_CENTER\n                || anchor == TextAnchor.BASELINE_RIGHT) {\n\n            yAdj = 0.0f;\n\n        }\n        else if (anchor == TextAnchor.BOTTOM_LEFT\n                || anchor == TextAnchor.BOTTOM_CENTER\n                || anchor == TextAnchor.BOTTOM_RIGHT) {\n\n            yAdj = metrics.getDescent() + metrics.getLeading();\n\n        }\n        result[0] = xAdj;\n        result[1] = yAdj;\n        return result;\n\n    }",
    "comment": " A utility method that calculates the rotation anchor offsets for a  string.  These offsets are relative to the text starting coordinate  (BASELINE_LEFT).  @param g2  the graphics device. @param text  the text. @param anchor  the anchor point.  @return  The offsets. ",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "TextUtilities.deriveTextBoundsAnchorOffsets",
    "class_name": "org.jfree.chart.text.TextUtilities",
    "signature": "org.jfree.chart.text.TextUtilities.deriveTextBoundsAnchorOffsets(Graphics2D,String,TextAnchor)",
    "snippet": "    private static float[] deriveTextBoundsAnchorOffsets(Graphics2D g2,\n            String text, TextAnchor anchor) {\n\n        float[] result = new float[2];\n        FontRenderContext frc = g2.getFontRenderContext();\n        Font f = g2.getFont();\n        FontMetrics fm = g2.getFontMetrics(f);\n        Rectangle2D bounds = TextUtilities.getTextBounds(text, g2, fm);\n        LineMetrics metrics = f.getLineMetrics(text, frc);\n        float ascent = metrics.getAscent();\n        float halfAscent = ascent / 2.0f;\n        float descent = metrics.getDescent();\n        float leading = metrics.getLeading();\n        float xAdj = 0.0f;\n        float yAdj = 0.0f;\n\n        if (anchor == TextAnchor.TOP_CENTER\n                || anchor == TextAnchor.CENTER\n                || anchor == TextAnchor.BOTTOM_CENTER\n                || anchor == TextAnchor.BASELINE_CENTER\n                || anchor == TextAnchor.HALF_ASCENT_CENTER) {\n\n            xAdj = (float) -bounds.getWidth() / 2.0f;\n\n        }\n        else if (anchor == TextAnchor.TOP_RIGHT\n                || anchor == TextAnchor.CENTER_RIGHT\n                || anchor == TextAnchor.BOTTOM_RIGHT\n                || anchor == TextAnchor.BASELINE_RIGHT\n                || anchor == TextAnchor.HALF_ASCENT_RIGHT) {\n\n            xAdj = (float) -bounds.getWidth();\n\n        }\n\n        if (anchor == TextAnchor.TOP_LEFT\n                || anchor == TextAnchor.TOP_CENTER\n                || anchor == TextAnchor.TOP_RIGHT) {\n\n            yAdj = -descent - leading + (float) bounds.getHeight();\n\n        }\n        else if (anchor == TextAnchor.HALF_ASCENT_LEFT\n                || anchor == TextAnchor.HALF_ASCENT_CENTER\n                || anchor == TextAnchor.HALF_ASCENT_RIGHT) {\n\n            yAdj = halfAscent;\n\n        }\n        else if (anchor == TextAnchor.CENTER_LEFT\n                || anchor == TextAnchor.CENTER\n                || anchor == TextAnchor.CENTER_RIGHT) {\n\n            yAdj = -descent - leading + (float) (bounds.getHeight() / 2.0);\n\n        }\n        else if (anchor == TextAnchor.BASELINE_LEFT\n                || anchor == TextAnchor.BASELINE_CENTER\n                || anchor == TextAnchor.BASELINE_RIGHT) {\n\n            yAdj = 0.0f;\n\n        }\n        else if (anchor == TextAnchor.BOTTOM_LEFT\n                || anchor == TextAnchor.BOTTOM_CENTER\n                || anchor == TextAnchor.BOTTOM_RIGHT) {\n\n            yAdj = -metrics.getDescent() - metrics.getLeading();\n\n        }\n        result[0] = xAdj;\n        result[1] = yAdj;\n        return result;\n\n    }",
    "comment": " A utility method that calculates the anchor offsets for a string.   Normally, the (x, y) coordinate for drawing text is a point on the  baseline at the left of the text string.  If you add these offsets to  (x, y) and draw the string, then the anchor point should coincide with  the (x, y) point.  @param g2  the graphics device (not <code>null</code>). @param text  the text. @param anchor  the anchor point.  @return  The offsets. ",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "TextUtilities.drawRotatedString",
    "class_name": "org.jfree.chart.text.TextUtilities",
    "signature": "org.jfree.chart.text.TextUtilities.drawRotatedString(String,Graphics2D,float,float,TextAnchor,double,TextAnchor)",
    "snippet": "    public static void drawRotatedString(String text, Graphics2D g2,\n            float x, float y, TextAnchor textAnchor,\n            double angle, TextAnchor rotationAnchor) {\n\n        if (text == null || text.equals(\"\")) {\n            return;\n        }\n        float[] textAdj = deriveTextBoundsAnchorOffsets(g2, text, textAnchor);\n        float[] rotateAdj = deriveRotationAnchorOffsets(g2, text, \n                rotationAnchor);\n        drawRotatedString(text, g2, x + textAdj[0], y + textAdj[1],\n                angle, x + textAdj[0] + rotateAdj[0], \n                y + textAdj[1] + rotateAdj[1]);\n\n    }",
    "comment": " Draws a string that is aligned by one anchor point and rotated about  another anchor point.  @param text  the text. @param g2  the graphics device. @param x  the x-coordinate for positioning the text. @param y  the y-coordinate for positioning the text. @param textAnchor  the text anchor. @param angle  the rotation angle (in radians). @param rotationAnchor  the rotation anchor. ",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "TextUtilities.drawRotatedString",
    "class_name": "org.jfree.chart.text.TextUtilities",
    "signature": "org.jfree.chart.text.TextUtilities.drawRotatedString(String,Graphics2D,float,float,TextAnchor,double,float,float)",
    "snippet": "    public static void drawRotatedString(String text, Graphics2D g2, float x, \n            float y, TextAnchor textAnchor, double angle, float rotationX, \n            float rotationY) {\n\n        if (text == null || text.equals(\"\")) {\n            return;\n        }\n        float[] textAdj = deriveTextBoundsAnchorOffsets(g2, text, textAnchor);\n        drawRotatedString(text, g2, x + textAdj[0], y + textAdj[1], angle, \n                rotationX, rotationY);\n    }",
    "comment": " Draws a string that is aligned by one anchor point and rotated about  another anchor point.  @param text  the text. @param g2  the graphics device. @param x  the x-coordinate for positioning the text. @param y  the y-coordinate for positioning the text. @param textAnchor  the text anchor. @param angle  the rotation angle. @param rotationX  the x-coordinate for the rotation anchor point. @param rotationY  the y-coordinate for the rotation anchor point. ",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "TextUtilities.drawRotatedString",
    "class_name": "org.jfree.chart.text.TextUtilities",
    "signature": "org.jfree.chart.text.TextUtilities.drawRotatedString(String,Graphics2D,float,float,double,float,float)",
    "snippet": "    public static void drawRotatedString(String text, Graphics2D g2,\n            float textX, float textY, double angle,\n            float rotateX, float rotateY) {\n\n        if ((text == null) || (text.equals(\"\"))) {\n            return;\n        }\n\n        AffineTransform saved = g2.getTransform();\n\n        // apply the rotation...\n        AffineTransform rotate = AffineTransform.getRotateInstance(\n                angle, rotateX, rotateY);\n        g2.transform(rotate);\n\n        if (useDrawRotatedStringWorkaround) {\n            // workaround for JDC bug ID 4312117 and others...\n            TextLayout tl = new TextLayout(text, g2.getFont(), \n                    g2.getFontRenderContext());\n            tl.draw(g2, textX, textY);\n        }\n        else {\n            // replaces this code...\n            g2.drawString(text, textX, textY);\n        }\n        g2.setTransform(saved);\n\n    }",
    "comment": " A utility method for drawing rotated text. <P> A common rotation is -Math.PI/2 which draws text 'vertically' (with the  top of the characters on the left).  @param text  the text. @param g2  the graphics device. @param textX  the x-coordinate for the text (before rotation). @param textY  the y-coordinate for the text (before rotation). @param angle  the angle of the (clockwise) rotation (in radians). @param rotateX  the point about which the text is rotated. @param rotateY  the point about which the text is rotated. ",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "TextUtilities.getTextBounds",
    "class_name": "org.jfree.chart.text.TextUtilities",
    "signature": "org.jfree.chart.text.TextUtilities.getTextBounds(String,Graphics2D,FontMetrics)",
    "snippet": "    public static Rectangle2D getTextBounds(String text, Graphics2D g2, \n            FontMetrics fm) {\n        \n        final Rectangle2D bounds;\n        if (TextUtilities.useFontMetricsGetStringBounds) {\n            bounds = fm.getStringBounds(text, g2);\n            // getStringBounds() can return incorrect height for some Unicode\n            // characters...see bug parade 6183356, let's replace it with \n            // something correct\n            LineMetrics lm = fm.getFont().getLineMetrics(text,\n                    g2.getFontRenderContext());\n            bounds.setRect(bounds.getX(), bounds.getY(), bounds.getWidth(),\n                    lm.getHeight());\n        }\n        else {\n            double width = fm.stringWidth(text);\n            double height = fm.getHeight();\n            bounds = new Rectangle2D.Double(0.0, -fm.getAscent(), width, \n                    height);\n        }\n        return bounds;\n    }",
    "comment": " Returns the bounds for the specified text.  @param text  the text (<code>null</code> permitted). @param g2  the graphics context (not <code>null</code>). @param fm  the font metrics (not <code>null</code>).  @return The text bounds (<code>null</code> if the <code>text</code>  argument is <code>null</code>). ",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "TextUtilities.nextLineBreak",
    "class_name": "org.jfree.chart.text.TextUtilities",
    "signature": "org.jfree.chart.text.TextUtilities.nextLineBreak(String,int,float,BreakIterator,TextMeasurer)",
    "snippet": "    private static int nextLineBreak(String text, int start,\n            float width, BreakIterator iterator, TextMeasurer measurer) {\n        \n        // this method is (loosely) based on code in JFreeReport's \n        // TextParagraph class\n        int current = start;\n        int end;\n        float x = 0.0f;\n        boolean firstWord = true;\n        int newline = text.indexOf('\\n', start);\n        if (newline < 0) {\n            newline = Integer.MAX_VALUE;\n        }\n        while (((end = iterator.next()) != BreakIterator.DONE)) {\n            if (end > newline) {\n                return newline;\n            }\n            x += measurer.getStringWidth(text, current, end);\n            if (x > width) {\n                if (firstWord) {\n                    while (measurer.getStringWidth(text, start, end) > width) {\n                        end--;\n                        if (end <= start) {\n                            return end;\n                        }\n                    }\n                    return end;\n                }\n                else {\n                    end = iterator.previous();\n                    return end;\n                }\n            }\n            // we found at least one word that fits ...\n            firstWord = false;\n            current = end;\n        }\n        return BreakIterator.DONE;\n    }",
    "comment": " Returns the character index of the next line break.  @param text  the text. @param start  the start index. @param width  the target display width. @param iterator  the word break iterator. @param measurer  the text measurer.  @return The index of the next line break. ",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "LegendGraphic.LegendGraphic",
    "class_name": "org.jfree.chart.title.LegendGraphic",
    "signature": "org.jfree.chart.title.LegendGraphic.LegendGraphic(Shape,Paint)",
    "snippet": "    public LegendGraphic(Shape shape, Paint fillPaint) {\n        if (shape == null) {\n            throw new IllegalArgumentException(\"Null 'shape' argument.\");\n        }\n        if (fillPaint == null) {\n            throw new IllegalArgumentException(\"Null 'fillPaint' argument.\");\n        }\n        this.shapeVisible = true;\n        this.shape = shape;\n        this.shapeAnchor = RectangleAnchor.CENTER;\n        this.shapeLocation = RectangleAnchor.CENTER;\n        this.shapeFilled = true;\n        this.fillPaint = fillPaint;\n        this.fillPaintTransformer = new StandardGradientPaintTransformer();\n        setPadding(2.0, 2.0, 2.0, 2.0);\n    }",
    "comment": " Creates a new legend graphic.  @param shape  the shape (<code>null</code> not permitted). @param fillPaint  the fill paint (<code>null</code> not permitted). ",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "LegendGraphic.arrange",
    "class_name": "org.jfree.chart.title.LegendGraphic",
    "signature": "org.jfree.chart.title.LegendGraphic.arrange(Graphics2D,RectangleConstraint)",
    "snippet": "    public Size2D arrange(Graphics2D g2, RectangleConstraint constraint) {\n        RectangleConstraint contentConstraint = toContentConstraint(constraint);\n        LengthConstraintType w = contentConstraint.getWidthConstraintType();\n        LengthConstraintType h = contentConstraint.getHeightConstraintType();\n        Size2D contentSize = null;\n        if (w == LengthConstraintType.NONE) {\n            if (h == LengthConstraintType.NONE) {\n                contentSize = arrangeNN(g2);\n            }\n            else if (h == LengthConstraintType.RANGE) {\n                throw new RuntimeException(\"Not yet implemented.\");\n            }\n            else if (h == LengthConstraintType.FIXED) {\n                throw new RuntimeException(\"Not yet implemented.\");\n            }\n        }\n        else if (w == LengthConstraintType.RANGE) {\n            if (h == LengthConstraintType.NONE) {\n                throw new RuntimeException(\"Not yet implemented.\");\n            }\n            else if (h == LengthConstraintType.RANGE) {\n                throw new RuntimeException(\"Not yet implemented.\");\n            }\n            else if (h == LengthConstraintType.FIXED) {\n                throw new RuntimeException(\"Not yet implemented.\");\n            }\n        }\n        else if (w == LengthConstraintType.FIXED) {\n            if (h == LengthConstraintType.NONE) {\n                throw new RuntimeException(\"Not yet implemented.\");\n            }\n            else if (h == LengthConstraintType.RANGE) {\n                throw new RuntimeException(\"Not yet implemented.\");\n            }\n            else if (h == LengthConstraintType.FIXED) {   \n                contentSize = new Size2D(\n                    contentConstraint.getWidth(),\n                    contentConstraint.getHeight()\n                );\n            }            \n        }\n        return new Size2D(\n            calculateTotalWidth(contentSize.getWidth()), \n            calculateTotalHeight(contentSize.getHeight())\n        );\n    }",
    "comment": " Arranges the contents of the block, within the given constraints, and  returns the block size.  @param g2  the graphics device. @param constraint  the constraint (<code>null</code> not permitted).  @return The block size (in Java2D units, never <code>null</code>). ",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "LegendGraphic.arrangeNN",
    "class_name": "org.jfree.chart.title.LegendGraphic",
    "signature": "org.jfree.chart.title.LegendGraphic.arrangeNN(Graphics2D)",
    "snippet": "    protected Size2D arrangeNN(Graphics2D g2) {\n        Rectangle2D contentSize = new Rectangle2D.Double();\n        if (this.line != null) {\n            contentSize.setRect(this.line.getBounds2D());\n        }\n        if (this.shape != null) {\n            contentSize = contentSize.createUnion(this.shape.getBounds2D());\n        }\n        return new Size2D(contentSize.getWidth(), contentSize.getHeight());\n    }",
    "comment": " Performs the layout with no constraint, so the content size is  determined by the bounds of the shape and/or line drawn to represent  the series.  @param g2  the graphics device.  @return  The content size. ",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "LegendGraphic.draw",
    "class_name": "org.jfree.chart.title.LegendGraphic",
    "signature": "org.jfree.chart.title.LegendGraphic.draw(Graphics2D,Rectangle2D)",
    "snippet": "    public void draw(Graphics2D g2, Rectangle2D area) {\n        \n        area = trimMargin(area);\n        drawBorder(g2, area);\n        area = trimBorder(area);\n        area = trimPadding(area);\n        \n        if (this.lineVisible) {\n            Point2D location = RectangleAnchor.coordinates(area, \n                    this.shapeLocation);\n            Shape aLine = ShapeUtilities.createTranslatedShape(getLine(), \n                    this.shapeAnchor, location.getX(), location.getY());\n            g2.setPaint(this.linePaint);\n            g2.setStroke(this.lineStroke);\n            g2.draw(aLine);\n        }\n        \n        if (this.shapeVisible) {\n            Point2D location = RectangleAnchor.coordinates(area, \n                    this.shapeLocation);\n            \n            Shape s = ShapeUtilities.createTranslatedShape(this.shape, \n                    this.shapeAnchor, location.getX(), location.getY());\n            if (this.shapeFilled) {\n                Paint p = this.fillPaint;\n                if (p instanceof GradientPaint) {\n                    GradientPaint gp = (GradientPaint) this.fillPaint;\n                    p = this.fillPaintTransformer.transform(gp, s);\n                }\n                g2.setPaint(p);\n                g2.fill(s);\n            }\n            if (this.shapeOutlineVisible) {\n                g2.setPaint(this.outlinePaint);\n                g2.setStroke(this.outlineStroke);\n                g2.draw(s);\n            }\n        }\n        \n    }",
    "comment": " Draws the graphic item within the specified area.  @param g2  the graphics device. @param area  the area. ",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "LegendGraphic.draw",
    "class_name": "org.jfree.chart.title.LegendGraphic",
    "signature": "org.jfree.chart.title.LegendGraphic.draw(Graphics2D,Rectangle2D,Object)",
    "snippet": "    public Object draw(Graphics2D g2, Rectangle2D area, Object params) {\n        draw(g2, area);\n        return null;\n    }",
    "comment": " Draws the block within the specified area.  @param g2  the graphics device. @param area  the area. @param params  ignored (<code>null</code> permitted).  @return Always <code>null</code>. ",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "LegendGraphic.setFillPaintTransformer",
    "class_name": "org.jfree.chart.title.LegendGraphic",
    "signature": "org.jfree.chart.title.LegendGraphic.setFillPaintTransformer(GradientPaintTransformer)",
    "snippet": "    public void setFillPaintTransformer(GradientPaintTransformer transformer) {\n        if (transformer == null) {\n            throw new IllegalArgumentException(\"Null 'transformer' argument.\");\n        }\n        this.fillPaintTransformer = transformer;\n    }",
    "comment": " Sets the transformer used when the fill paint is an instance of  <code>GradientPaint</code>.  @param transformer  the transformer (<code>null</code> not permitted).  @since 1.0.4  @see #getFillPaintTransformer() ",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "LegendGraphic.setLine",
    "class_name": "org.jfree.chart.title.LegendGraphic",
    "signature": "org.jfree.chart.title.LegendGraphic.setLine(Shape)",
    "snippet": "    public void setLine(Shape line) {\n        this.line = line;\n    }",
    "comment": " Sets the line.  A Shape is used here, because then you can use Line2D,  GeneralPath or any other Shape to represent the line.  @param line  the line.  @see #getLine() ",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "LegendGraphic.setLinePaint",
    "class_name": "org.jfree.chart.title.LegendGraphic",
    "signature": "org.jfree.chart.title.LegendGraphic.setLinePaint(Paint)",
    "snippet": "    public void setLinePaint(Paint paint) {\n        this.linePaint = paint;\n    }",
    "comment": " Sets the line paint.  @param paint  the paint.  @see #getLinePaint() ",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "LegendGraphic.setLineStroke",
    "class_name": "org.jfree.chart.title.LegendGraphic",
    "signature": "org.jfree.chart.title.LegendGraphic.setLineStroke(Stroke)",
    "snippet": "    public void setLineStroke(Stroke stroke) {\n        this.lineStroke = stroke;\n    }",
    "comment": " Sets the line stroke.  @param stroke  the stroke.  @see #getLineStroke() ",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "LegendGraphic.setLineVisible",
    "class_name": "org.jfree.chart.title.LegendGraphic",
    "signature": "org.jfree.chart.title.LegendGraphic.setLineVisible(boolean)",
    "snippet": "    public void setLineVisible(boolean visible) {\n        this.lineVisible = visible;\n    }",
    "comment": " Sets the flag that controls whether or not the line is visible.  @param visible  the flag.  @see #isLineVisible() ",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "LegendGraphic.setOutlinePaint",
    "class_name": "org.jfree.chart.title.LegendGraphic",
    "signature": "org.jfree.chart.title.LegendGraphic.setOutlinePaint(Paint)",
    "snippet": "    public void setOutlinePaint(Paint paint) {\n        this.outlinePaint = paint;\n    }",
    "comment": " Sets the outline paint.  @param paint  the paint.  @see #getOutlinePaint() ",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "LegendGraphic.setOutlineStroke",
    "class_name": "org.jfree.chart.title.LegendGraphic",
    "signature": "org.jfree.chart.title.LegendGraphic.setOutlineStroke(Stroke)",
    "snippet": "    public void setOutlineStroke(Stroke stroke) {\n        this.outlineStroke = stroke;\n    }",
    "comment": " Sets the outline stroke.  @param stroke  the stroke.  @see #getOutlineStroke() ",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "LegendGraphic.setShapeAnchor",
    "class_name": "org.jfree.chart.title.LegendGraphic",
    "signature": "org.jfree.chart.title.LegendGraphic.setShapeAnchor(RectangleAnchor)",
    "snippet": "    public void setShapeAnchor(RectangleAnchor anchor) {\n        if (anchor == null) {\n            throw new IllegalArgumentException(\"Null 'anchor' argument.\");\n        }\n        this.shapeAnchor = anchor;    \n    }",
    "comment": " Sets the shape anchor.  This defines a point on the shapes bounding rectangle that will be used to align the shape to a location.  @param anchor  the anchor (<code>null</code> not permitted).  @see #setShapeAnchor(RectangleAnchor) ",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "LegendGraphic.setShapeFilled",
    "class_name": "org.jfree.chart.title.LegendGraphic",
    "signature": "org.jfree.chart.title.LegendGraphic.setShapeFilled(boolean)",
    "snippet": "    public void setShapeFilled(boolean filled) {\n        this.shapeFilled = filled;\n    }",
    "comment": " Sets a flag that controls whether or not the shape is filled.  @param filled  the flag.  @see #isShapeFilled() ",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "LegendGraphic.setShapeLocation",
    "class_name": "org.jfree.chart.title.LegendGraphic",
    "signature": "org.jfree.chart.title.LegendGraphic.setShapeLocation(RectangleAnchor)",
    "snippet": "    public void setShapeLocation(RectangleAnchor location) {\n        if (location == null) {\n            throw new IllegalArgumentException(\"Null 'location' argument.\");\n        }\n        this.shapeLocation = location;\n    }",
    "comment": " Sets the shape location.  This defines a point within the drawing area that will be used to align the shape to.  @param location  the location (<code>null</code> not permitted).  @see #getShapeLocation() ",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "LegendGraphic.setShapeOutlineVisible",
    "class_name": "org.jfree.chart.title.LegendGraphic",
    "signature": "org.jfree.chart.title.LegendGraphic.setShapeOutlineVisible(boolean)",
    "snippet": "    public void setShapeOutlineVisible(boolean visible) {\n        this.shapeOutlineVisible = visible;\n    }",
    "comment": " Sets a flag that controls whether or not the shape outline is visible.  @param visible  the flag.  @see #isShapeOutlineVisible() ",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "LegendGraphic.setShapeVisible",
    "class_name": "org.jfree.chart.title.LegendGraphic",
    "signature": "org.jfree.chart.title.LegendGraphic.setShapeVisible(boolean)",
    "snippet": "    public void setShapeVisible(boolean visible) {\n        this.shapeVisible = visible;\n    }",
    "comment": " Sets a flag that controls whether or not the shape is  visible.  @param visible  the flag.  @see #isShapeVisible() ",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "LegendItemBlockContainer.LegendItemBlockContainer",
    "class_name": "org.jfree.chart.title.LegendItemBlockContainer",
    "signature": "org.jfree.chart.title.LegendItemBlockContainer.LegendItemBlockContainer(Arrangement,Dataset,Comparable)",
    "snippet": "    public LegendItemBlockContainer(Arrangement arrangement, Dataset dataset,\n            Comparable seriesKey) {\n        super(arrangement);\n        this.dataset = dataset;\n        this.seriesKey = seriesKey;\n    }",
    "comment": " Creates a new legend item block.  @param arrangement  the arrangement. @param dataset  the dataset. @param seriesKey  the series key.  @since 1.0.6 ",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "LegendItemBlockContainer.draw",
    "class_name": "org.jfree.chart.title.LegendItemBlockContainer",
    "signature": "org.jfree.chart.title.LegendItemBlockContainer.draw(Graphics2D,Rectangle2D,Object)",
    "snippet": "    public Object draw(Graphics2D g2, Rectangle2D area, Object params) {\n        // draw the block without collecting entities\n        super.draw(g2, area, null);\n        EntityBlockParams ebp = null;\n        BlockResult r = new BlockResult();\n        if (params instanceof EntityBlockParams) {\n            ebp = (EntityBlockParams) params;\n            if (ebp.getGenerateEntities()) {\n                EntityCollection ec = new StandardEntityCollection();\n                LegendItemEntity entity = new LegendItemEntity(\n                        (Shape) area.clone());\n                entity.setSeriesKey(this.seriesKey);\n                entity.setDataset(this.dataset);\n                entity.setToolTipText(getToolTipText());\n                entity.setURLText(getURLText());\n                ec.add(entity);\n                r.setEntityCollection(ec);\n            }\n        }\n        return r;\n    }",
    "comment": " Draws the block within the specified area.  @param g2  the graphics device. @param area  the area. @param params  passed on to blocks within the container  (<code>null</code> permitted).  @return An instance of {@link EntityBlockResult}, or <code>null</code>. ",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "LegendItemBlockContainer.setToolTipText",
    "class_name": "org.jfree.chart.title.LegendItemBlockContainer",
    "signature": "org.jfree.chart.title.LegendItemBlockContainer.setToolTipText(String)",
    "snippet": "    public void setToolTipText(String text) {\n        this.toolTipText = text;   \n    }",
    "comment": " Sets the tool tip text.  @param text  the text (<code>null</code> permitted).  @since 1.0.3 ",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "LegendItemBlockContainer.setURLText",
    "class_name": "org.jfree.chart.title.LegendItemBlockContainer",
    "signature": "org.jfree.chart.title.LegendItemBlockContainer.setURLText(String)",
    "snippet": "    public void setURLText(String text) {\n        this.urlText = text;   \n    }",
    "comment": " Sets the URL text.  @param text  the text (<code>null</code> permitted).  @since 1.0.3 ",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "LegendTitle.LegendTitle",
    "class_name": "org.jfree.chart.title.LegendTitle",
    "signature": "org.jfree.chart.title.LegendTitle.LegendTitle(LegendItemSource)",
    "snippet": "    public LegendTitle(LegendItemSource source) {\n        this(source, new FlowArrangement(), new ColumnArrangement());\n    }",
    "comment": " Constructs a new (empty) legend for the specified source.  @param source  the source. ",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "LegendTitle.LegendTitle",
    "class_name": "org.jfree.chart.title.LegendTitle",
    "signature": "org.jfree.chart.title.LegendTitle.LegendTitle(LegendItemSource,Arrangement,Arrangement)",
    "snippet": "    public LegendTitle(LegendItemSource source, \n                       Arrangement hLayout, Arrangement vLayout) {\n        this.sources = new LegendItemSource[] {source};\n        this.items = new BlockContainer(hLayout);\n        this.hLayout = hLayout;\n        this.vLayout = vLayout;\n        this.backgroundPaint = null;  \n        this.legendItemGraphicEdge = RectangleEdge.LEFT;\n        this.legendItemGraphicAnchor = RectangleAnchor.CENTER;\n        this.legendItemGraphicLocation = RectangleAnchor.CENTER;\n        this.legendItemGraphicPadding = new RectangleInsets(2.0, 2.0, 2.0, 2.0);\n        this.itemFont = DEFAULT_ITEM_FONT;\n        this.itemPaint = DEFAULT_ITEM_PAINT;\n        this.itemLabelPadding = new RectangleInsets(2.0, 2.0, 2.0, 2.0);\n    }",
    "comment": " Creates a new legend title with the specified arrangement.  @param source  the source. @param hLayout  the horizontal item arrangement (<code>null</code> not permitted). @param vLayout  the vertical item arrangement (<code>null</code> not permitted). ",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "LegendTitle.arrange",
    "class_name": "org.jfree.chart.title.LegendTitle",
    "signature": "org.jfree.chart.title.LegendTitle.arrange(Graphics2D,RectangleConstraint)",
    "snippet": "    public Size2D arrange(Graphics2D g2, RectangleConstraint constraint) {\n        Size2D result = new Size2D();\n        fetchLegendItems();\n        if (this.items.isEmpty()) {\n            return result;   \n        }\n        BlockContainer container = this.wrapper;\n        if (container == null) {\n            container = this.items;\n        }\n        RectangleConstraint c = toContentConstraint(constraint);\n        Size2D size = container.arrange(g2, c);\n        result.height = calculateTotalHeight(size.height);\n        result.width = calculateTotalWidth(size.width);\n        return result;\n    }",
    "comment": " Arranges the contents of the block, within the given constraints, and  returns the block size.  @param g2  the graphics device. @param constraint  the constraint (<code>null</code> not permitted).  @return The block size (in Java2D units, never <code>null</code>). ",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "LegendTitle.createLegendItemBlock",
    "class_name": "org.jfree.chart.title.LegendTitle",
    "signature": "org.jfree.chart.title.LegendTitle.createLegendItemBlock(LegendItem)",
    "snippet": "    protected Block createLegendItemBlock(LegendItem item) {\n        BlockContainer result = null;\n        LegendGraphic lg = new LegendGraphic(item.getShape(), \n                item.getFillPaint());\n        lg.setFillPaintTransformer(item.getFillPaintTransformer());\n        lg.setShapeFilled(item.isShapeFilled());\n        lg.setLine(item.getLine());\n        lg.setLineStroke(item.getLineStroke());\n        lg.setLinePaint(item.getLinePaint());\n        lg.setLineVisible(item.isLineVisible());\n        lg.setShapeVisible(item.isShapeVisible());\n        lg.setShapeOutlineVisible(item.isShapeOutlineVisible());\n        lg.setOutlinePaint(item.getOutlinePaint());\n        lg.setOutlineStroke(item.getOutlineStroke());\n        lg.setPadding(this.legendItemGraphicPadding);\n\n        LegendItemBlockContainer legendItem = new LegendItemBlockContainer(\n                new BorderArrangement(), item.getDataset(), \n                item.getSeriesKey());\n        lg.setShapeAnchor(getLegendItemGraphicAnchor());\n        lg.setShapeLocation(getLegendItemGraphicLocation());\n        legendItem.add(lg, this.legendItemGraphicEdge);\n        LabelBlock labelBlock = new LabelBlock(item.getLabel(), this.itemFont, \n                this.itemPaint);\n        labelBlock.setPadding(this.itemLabelPadding);\n        legendItem.add(labelBlock);\n        legendItem.setToolTipText(item.getToolTipText());\n        legendItem.setURLText(item.getURLText());\n        \n        result = new BlockContainer(new CenterArrangement());\n        result.add(legendItem);\n        \n        return result;\n    }",
    "comment": " Creates a legend item block.  @param item  the legend item.  @return The block. ",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "LegendTitle.draw",
    "class_name": "org.jfree.chart.title.LegendTitle",
    "signature": "org.jfree.chart.title.LegendTitle.draw(Graphics2D,Rectangle2D,Object)",
    "snippet": "    public Object draw(Graphics2D g2, Rectangle2D area, Object params) {\n        Rectangle2D target = (Rectangle2D) area.clone();\n        target = trimMargin(target);\n        if (this.backgroundPaint != null) {\n            g2.setPaint(this.backgroundPaint);\n            g2.fill(target);\n        }\n        BlockFrame border = getFrame();\n        border.draw(g2, target);\n        border.getInsets().trim(target);\n        BlockContainer container = this.wrapper;\n        if (container == null) {\n            container = this.items; \n        }\n        target = trimPadding(target);\n        return container.draw(g2, target, params);   \n    }",
    "comment": " Draws the block within the specified area.  @param g2  the graphics device. @param area  the area. @param params  ignored (<code>null</code> permitted).  @return An {@link org.jfree.chart.block.EntityBlockResult} or  <code>null</code>. ",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "LegendTitle.fetchLegendItems",
    "class_name": "org.jfree.chart.title.LegendTitle",
    "signature": "org.jfree.chart.title.LegendTitle.fetchLegendItems()",
    "snippet": "    protected void fetchLegendItems() {\n        this.items.clear();\n        RectangleEdge p = getPosition();\n        if (RectangleEdge.isTopOrBottom(p)) {\n            this.items.setArrangement(this.hLayout);   \n        }\n        else {\n            this.items.setArrangement(this.vLayout);   \n        }\n        for (int s = 0; s < this.sources.length; s++) {\n            LegendItemCollection legendItems = this.sources[s].getLegendItems();\n            if (legendItems != null) {\n                for (int i = 0; i < legendItems.getItemCount(); i++) {\n                    LegendItem item = legendItems.get(i);\n                    Block block = createLegendItemBlock(item);\n                    this.items.add(block);\n                }\n            }\n        }\n    }",
    "comment": " Fetches the latest legend items. ",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "LegendTitle.getLegendItemGraphicAnchor",
    "class_name": "org.jfree.chart.title.LegendTitle",
    "signature": "org.jfree.chart.title.LegendTitle.getLegendItemGraphicAnchor()",
    "snippet": "    public RectangleAnchor getLegendItemGraphicAnchor() {\n        return this.legendItemGraphicAnchor;\n    }",
    "comment": " Returns the legend item graphic anchor.  @return The graphic anchor (never <code>null</code>). ",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "LegendTitle.getLegendItemGraphicLocation",
    "class_name": "org.jfree.chart.title.LegendTitle",
    "signature": "org.jfree.chart.title.LegendTitle.getLegendItemGraphicLocation()",
    "snippet": "    public RectangleAnchor getLegendItemGraphicLocation() {\n        return this.legendItemGraphicLocation;\n    }",
    "comment": " Returns the legend item graphic location.  @return The location (never <code>null</code>). ",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "LegendTitle.setBackgroundPaint",
    "class_name": "org.jfree.chart.title.LegendTitle",
    "signature": "org.jfree.chart.title.LegendTitle.setBackgroundPaint(Paint)",
    "snippet": "    public void setBackgroundPaint(Paint paint) {\n        this.backgroundPaint = paint;   \n        notifyListeners(new TitleChangeEvent(this));\n    }",
    "comment": " Sets the background paint for the legend and sends a  {@link TitleChangeEvent} to all registered listeners.  @param paint  the paint (<code>null</code> permitted). ",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "Title.Title",
    "class_name": "org.jfree.chart.title.Title",
    "signature": "org.jfree.chart.title.Title.Title()",
    "snippet": "    protected Title() {\n        this(Title.DEFAULT_POSITION,\n                Title.DEFAULT_HORIZONTAL_ALIGNMENT,\n                Title.DEFAULT_VERTICAL_ALIGNMENT, Title.DEFAULT_PADDING);\n    }",
    "comment": " Creates a new title, using default attributes where necessary. ",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "Title.Title",
    "class_name": "org.jfree.chart.title.Title",
    "signature": "org.jfree.chart.title.Title.Title(RectangleEdge,HorizontalAlignment,VerticalAlignment,RectangleInsets)",
    "snippet": "    protected Title(RectangleEdge position,\n                    HorizontalAlignment horizontalAlignment, \n                    VerticalAlignment verticalAlignment,\n                    RectangleInsets padding) {\n\n        // check arguments...\n        if (position == null) {\n            throw new IllegalArgumentException(\"Null 'position' argument.\");\n        }\n        if (horizontalAlignment == null) {\n            throw new IllegalArgumentException(\n                    \"Null 'horizontalAlignment' argument.\");\n        }\n\n        if (verticalAlignment == null) {\n            throw new IllegalArgumentException(\n                    \"Null 'verticalAlignment' argument.\");\n        }\n        if (padding == null) {\n            throw new IllegalArgumentException(\"Null 'spacer' argument.\");\n        }\n\n        this.position = position;\n        this.horizontalAlignment = horizontalAlignment;\n        this.verticalAlignment = verticalAlignment;\n        setPadding(padding);\n        this.listenerList = new EventListenerList();\n        this.notify = true;\n\n    }",
    "comment": " Creates a new title.  @param position  the position of the title (<code>null</code> not  permitted). @param horizontalAlignment  the horizontal alignment of the title (LEFT, CENTER or RIGHT, <code>null</code> not  permitted). @param verticalAlignment  the vertical alignment of the title (TOP,  MIDDLE or BOTTOM, <code>null</code> not  permitted). @param padding  the amount of space to leave around the outside of the  title (<code>null</code> not permitted). ",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "Title.addChangeListener",
    "class_name": "org.jfree.chart.title.Title",
    "signature": "org.jfree.chart.title.Title.addChangeListener(TitleChangeListener)",
    "snippet": "    public void addChangeListener(TitleChangeListener listener) {\n        this.listenerList.add(TitleChangeListener.class, listener);\n    }",
    "comment": " Registers an object for notification of changes to the title.  @param listener  the object that is being registered. ",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "Title.getHorizontalAlignment",
    "class_name": "org.jfree.chart.title.Title",
    "signature": "org.jfree.chart.title.Title.getHorizontalAlignment()",
    "snippet": "    public HorizontalAlignment getHorizontalAlignment() {\n        return this.horizontalAlignment;\n    }",
    "comment": " Returns the horizontal alignment of the title.  @return The horizontal alignment (never <code>null</code>). ",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "Title.getPosition",
    "class_name": "org.jfree.chart.title.Title",
    "signature": "org.jfree.chart.title.Title.getPosition()",
    "snippet": "    public RectangleEdge getPosition() {\n        return this.position;\n    }",
    "comment": " Returns the position of the title.  @return The title position (never <code>null</code>). ",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "Title.notifyListeners",
    "class_name": "org.jfree.chart.title.Title",
    "signature": "org.jfree.chart.title.Title.notifyListeners(TitleChangeEvent)",
    "snippet": "    protected void notifyListeners(TitleChangeEvent event) {\n        if (this.notify) {\n            Object[] listeners = this.listenerList.getListenerList();\n            for (int i = listeners.length - 2; i >= 0; i -= 2) {\n                if (listeners[i] == TitleChangeListener.class) {\n                    ((TitleChangeListener) listeners[i + 1]).titleChanged(\n                            event);\n                }\n            }\n        }\n    }",
    "comment": " Notifies all registered listeners that the chart title has changed in  some way.  @param event  an object that contains information about the change to  the title. ",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "Title.setPosition",
    "class_name": "org.jfree.chart.title.Title",
    "signature": "org.jfree.chart.title.Title.setPosition(RectangleEdge)",
    "snippet": "    public void setPosition(RectangleEdge position) {\n        if (position == null) {\n            throw new IllegalArgumentException(\"Null 'position' argument.\");\n        }\n        if (this.position != position) {\n            this.position = position;\n            notifyListeners(new TitleChangeEvent(this));\n        }\n    }",
    "comment": " Sets the position for the title and sends a {@link TitleChangeEvent} to  all registered listeners.  @param position  the position (<code>null</code> not permitted). ",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "BasicProjectInfo.BasicProjectInfo",
    "class_name": "org.jfree.chart.ui.BasicProjectInfo",
    "signature": "org.jfree.chart.ui.BasicProjectInfo.BasicProjectInfo()",
    "snippet": "    public BasicProjectInfo() {\n        this.libraries = new ArrayList();\n        this.optionalLibraries = new ArrayList();\n    }",
    "comment": " Default constructor. ",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "BasicProjectInfo.setCopyright",
    "class_name": "org.jfree.chart.ui.BasicProjectInfo",
    "signature": "org.jfree.chart.ui.BasicProjectInfo.setCopyright(String)",
    "snippet": "    public void setCopyright(String copyright) {\n        this.copyright = copyright;\n    }",
    "comment": " Sets the project copyright statement.  @param copyright  the project copyright statement. ",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "BasicProjectInfo.setInfo",
    "class_name": "org.jfree.chart.ui.BasicProjectInfo",
    "signature": "org.jfree.chart.ui.BasicProjectInfo.setInfo(String)",
    "snippet": "    public void setInfo(String info) {\n        super.setInfo(info);\n    }",
    "comment": " Sets the project info string (for example, this could be the project URL).  @param info  the info string. ",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "BasicProjectInfo.setLicenceName",
    "class_name": "org.jfree.chart.ui.BasicProjectInfo",
    "signature": "org.jfree.chart.ui.BasicProjectInfo.setLicenceName(String)",
    "snippet": "    public void setLicenceName(String licence) {\n        super.setLicenceName(licence);\n    }",
    "comment": " Sets the license name.  @param licence  the license name. ",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "BasicProjectInfo.setName",
    "class_name": "org.jfree.chart.ui.BasicProjectInfo",
    "signature": "org.jfree.chart.ui.BasicProjectInfo.setName(String)",
    "snippet": "    public void setName(String name) {\n        super.setName(name);\n    }",
    "comment": " Sets the project name.  @param name  the project name. ",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "BasicProjectInfo.setVersion",
    "class_name": "org.jfree.chart.ui.BasicProjectInfo",
    "signature": "org.jfree.chart.ui.BasicProjectInfo.setVersion(String)",
    "snippet": "    public void setVersion(String version) {\n        super.setVersion(version);\n    }",
    "comment": " Sets the project version number.  @param version  the version number. ",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "Contributor.Contributor",
    "class_name": "org.jfree.chart.ui.Contributor",
    "signature": "org.jfree.chart.ui.Contributor.Contributor(String,String)",
    "snippet": "    public Contributor(String name, String email) {\n        this.name = name;\n        this.email = email;\n    }",
    "comment": " Creates a new contributor.  @param name  the name. @param email  the e-mail address. ",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "Library.Library",
    "class_name": "org.jfree.chart.ui.Library",
    "signature": "org.jfree.chart.ui.Library.Library()",
    "snippet": "    protected Library() {\n        // nothing required\n    }",
    "comment": " Creates a new library reference. ",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "Library.setInfo",
    "class_name": "org.jfree.chart.ui.Library",
    "signature": "org.jfree.chart.ui.Library.setInfo(String)",
    "snippet": "    protected void setInfo(String info) {\n        this.info = info;\n    }",
    "comment": " Sets the project info.  @param info  the project info. ",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "Library.setLicenceName",
    "class_name": "org.jfree.chart.ui.Library",
    "signature": "org.jfree.chart.ui.Library.setLicenceName(String)",
    "snippet": "    protected void setLicenceName(String licenceName) {\n        this.licenceName = licenceName;\n    }",
    "comment": " Sets the licence name.  @param licenceName  the licence name. ",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "Library.setName",
    "class_name": "org.jfree.chart.ui.Library",
    "signature": "org.jfree.chart.ui.Library.setName(String)",
    "snippet": "    protected void setName(String name) {\n        this.name = name;\n    }",
    "comment": " Sets the project name.  @param name  the project name. ",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "Library.setVersion",
    "class_name": "org.jfree.chart.ui.Library",
    "signature": "org.jfree.chart.ui.Library.setVersion(String)",
    "snippet": "    protected void setVersion(String version) {\n        this.version = version;\n    }",
    "comment": " Sets the version identifier.  @param version  the version identifier. ",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "Licences.getInstance",
    "class_name": "org.jfree.chart.ui.Licences",
    "signature": "org.jfree.chart.ui.Licences.getInstance()",
    "snippet": "    public static Licences getInstance() {\n        if (singleton == null) {\n            singleton = new Licences();\n        }\n        return singleton;\n    }",
    "comment": " Returns a reference to this class.  @return the instance reference. ",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "Licences.getLGPL",
    "class_name": "org.jfree.chart.ui.Licences",
    "signature": "org.jfree.chart.ui.Licences.getLGPL()",
    "snippet": "    public String getLGPL() {\n        return LGPL;\n    }",
    "comment": " Returns the LGPL text in a non static way to prevent the compiler to copy the contents of the field.  @return the LGPL licence text. ",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "ProjectInfo.ProjectInfo",
    "class_name": "org.jfree.chart.ui.ProjectInfo",
    "signature": "org.jfree.chart.ui.ProjectInfo.ProjectInfo()",
    "snippet": "    public ProjectInfo() {\n        // nothing required\n    }",
    "comment": " Constructs an empty project info object. ",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "ProjectInfo.setContributors",
    "class_name": "org.jfree.chart.ui.ProjectInfo",
    "signature": "org.jfree.chart.ui.ProjectInfo.setContributors(List)",
    "snippet": "    public void setContributors(final List contributors) {\n        this.contributors = contributors;\n    }",
    "comment": " Sets the list of contributors.  @param contributors  the list of contributors. ",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "ProjectInfo.setLicenceText",
    "class_name": "org.jfree.chart.ui.ProjectInfo",
    "signature": "org.jfree.chart.ui.ProjectInfo.setLicenceText(String)",
    "snippet": "    public void setLicenceText(final String licenceText) {\n        this.licenceText = licenceText;\n    }",
    "comment": " Sets the project licence text.  @param licenceText  the licence text. ",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "ProjectInfo.setLogo",
    "class_name": "org.jfree.chart.ui.ProjectInfo",
    "signature": "org.jfree.chart.ui.ProjectInfo.setLogo(Image)",
    "snippet": "    public void setLogo(final Image logo) {\n        this.logo = logo;\n    }",
    "comment": " Sets the project logo.  @param logo  the project logo. ",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "AbstractObjectList.AbstractObjectList",
    "class_name": "org.jfree.chart.util.AbstractObjectList",
    "signature": "org.jfree.chart.util.AbstractObjectList.AbstractObjectList()",
    "snippet": "    protected AbstractObjectList() {\n        this(DEFAULT_INITIAL_CAPACITY);\n    }",
    "comment": " Creates a new list with the default initial capacity. ",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "AbstractObjectList.AbstractObjectList",
    "class_name": "org.jfree.chart.util.AbstractObjectList",
    "signature": "org.jfree.chart.util.AbstractObjectList.AbstractObjectList(int)",
    "snippet": "    protected AbstractObjectList(int initialCapacity) {\n        this (initialCapacity, initialCapacity);\n    }",
    "comment": " Creates a new list.  @param initialCapacity  the initial capacity. ",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "AbstractObjectList.AbstractObjectList",
    "class_name": "org.jfree.chart.util.AbstractObjectList",
    "signature": "org.jfree.chart.util.AbstractObjectList.AbstractObjectList(int,int)",
    "snippet": "    protected AbstractObjectList(int initialCapacity, int increment) {\n        this.objects = new Object[initialCapacity];\n        this.increment = increment;\n    }",
    "comment": " Creates a new list.  @param initialCapacity  the initial capacity. @param increment  the increment. ",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "AbstractObjectList.get",
    "class_name": "org.jfree.chart.util.AbstractObjectList",
    "signature": "org.jfree.chart.util.AbstractObjectList.get(int)",
    "snippet": "    protected Object get(int index) {\n        Object result = null;\n        if (index >= 0 && index < this.size) {\n            result = this.objects[index];\n        }\n        return result;\n    }",
    "comment": " Returns the object at the specified index, if there is one, or  <code>null</code>.  @param index  the object index.  @return The object or <code>null</code>. ",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "AbstractObjectList.indexOf",
    "class_name": "org.jfree.chart.util.AbstractObjectList",
    "signature": "org.jfree.chart.util.AbstractObjectList.indexOf(Object)",
    "snippet": "    protected int indexOf(Object object) {\n        for (int index = 0; index < this.size; index++) {\n            if (this.objects[index] == object) {\n                return (index);\n            }\n        }\n        return -1;\n    }",
    "comment": " Returns the index of the specified object, or -1 if the object is not in the list.  @param object  the object.  @return The index or -1. ",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "AbstractObjectList.set",
    "class_name": "org.jfree.chart.util.AbstractObjectList",
    "signature": "org.jfree.chart.util.AbstractObjectList.set(int,Object)",
    "snippet": "    protected void set(int index, Object object) {\n        if (index < 0) {\n            throw new IllegalArgumentException(\"Requires index >= 0.\");\n        }\n        if (index >= this.objects.length) {\n            Object[] enlarged = new Object[index + this.increment];\n            System.arraycopy(this.objects, 0, enlarged, 0, this.objects.length);\n            this.objects = enlarged;\n        }\n        this.objects[index] = object;\n        this.size = Math.max(this.size, index + 1);\n    }",
    "comment": " Sets an object reference (overwriting any existing object).  @param index  the object index. @param object  the object (<code>null</code> permitted). ",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "AbstractObjectList.size",
    "class_name": "org.jfree.chart.util.AbstractObjectList",
    "signature": "org.jfree.chart.util.AbstractObjectList.size()",
    "snippet": "    public int size() {\n        return this.size;\n    }",
    "comment": " Returns the size of the list.  @return The size of the list. ",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "BooleanList.BooleanList",
    "class_name": "org.jfree.chart.util.BooleanList",
    "signature": "org.jfree.chart.util.BooleanList.BooleanList()",
    "snippet": "    public BooleanList() {\n    }",
    "comment": " Creates a new list. ",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "BooleanList.getBoolean",
    "class_name": "org.jfree.chart.util.BooleanList",
    "signature": "org.jfree.chart.util.BooleanList.getBoolean(int)",
    "snippet": "    public Boolean getBoolean(int index) {\n        return (Boolean) get(index);\n    }",
    "comment": " Returns a {@link Boolean} from the list.  @param index the index (zero-based).  @return a {@link Boolean} from the list. ",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "Layer.equals",
    "class_name": "org.jfree.chart.util.Layer",
    "signature": "org.jfree.chart.util.Layer.equals(Object)",
    "snippet": "    public boolean equals(Object obj) {\n\n        if (this == obj) {\n            return true;\n        }\n        if (!(obj instanceof Layer)) {\n            return false;\n        }\n\n        Layer layer = (Layer) obj;\n        if (!this.name.equals(layer.name)) {\n            return false;\n        }\n\n        return true;\n\n    }",
    "comment": " Returns <code>true</code> if this object is equal to the specified  object, and <code>false</code> otherwise.  @param obj  the other object.  @return A boolean. ",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "ObjectList.ObjectList",
    "class_name": "org.jfree.chart.util.ObjectList",
    "signature": "org.jfree.chart.util.ObjectList.ObjectList()",
    "snippet": "    public ObjectList() {\n    }",
    "comment": " Default constructor. ",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "ObjectList.get",
    "class_name": "org.jfree.chart.util.ObjectList",
    "signature": "org.jfree.chart.util.ObjectList.get(int)",
    "snippet": "    public Object get(int index) {         \n        return super.get(index);         \n    }    ",
    "comment": " Returns the object at the specified index, if there is one, or  <code>null</code>.           @param index  the object index.     @return The object or <code>null</code>.           ",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "ObjectList.indexOf",
    "class_name": "org.jfree.chart.util.ObjectList",
    "signature": "org.jfree.chart.util.ObjectList.indexOf(Object)",
    "snippet": "    public int indexOf(Object object) {    \n        return super.indexOf(object);    \n    }    ",
    "comment": " Returns the index of the specified object, or -1 if the object is not  in the list.          @param object  the object.          @return The index or -1.           ",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "ObjectList.set",
    "class_name": "org.jfree.chart.util.ObjectList",
    "signature": "org.jfree.chart.util.ObjectList.set(int,Object)",
    "snippet": "    public void set(int index, Object object) {      \n        super.set(index, object);        \n    }    ",
    "comment": " Sets an object reference (overwriting any existing object).         @param index  the object index.    @param object  the object (<code>null</code> permitted).           ",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "ObjectUtilities.getClassLoader",
    "class_name": "org.jfree.chart.util.ObjectUtilities",
    "signature": "org.jfree.chart.util.ObjectUtilities.getClassLoader(Class)",
    "snippet": "    public synchronized static ClassLoader getClassLoader(final Class c) {\n        if (classLoader != null) {\n            return classLoader;\n        }\n        if (\"ThreadContext\".equals(classLoaderSource)) {\n            final ClassLoader threadLoader\n                = Thread.currentThread().getContextClassLoader();\n            if (threadLoader != null) {\n                return threadLoader;\n            }\n        }\n\n        // Context classloader - do not cache ..\n        final ClassLoader applicationCL = c.getClassLoader();\n        if (applicationCL == null) {\n            return ClassLoader.getSystemClassLoader();\n        }\n        else {\n            return applicationCL;\n        }\n    }",
    "comment": " Returns the classloader, which was responsible for loading the given class.  @param c the classloader, either an application class loader or the boot loader. @return the classloader, never null. @throws SecurityException if the SecurityManager does not allow to grab the context classloader. ",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "ObjectUtilities.isJDK14",
    "class_name": "org.jfree.chart.util.ObjectUtilities",
    "signature": "org.jfree.chart.util.ObjectUtilities.isJDK14()",
    "snippet": "    public static boolean isJDK14() {\n        ClassLoader loader = getClassLoader(ObjectUtilities.class);\n        if (loader != null) {\n            try {\n              loader.loadClass(\"java.util.RandomAccess\");\n              return true;\n            }\n            catch (ClassNotFoundException e) {\n              return false;\n            }\n            catch(Exception e) {\n              // do nothing, but do not crash ...\n            }\n        }\n        // OK, the quick and dirty, but secure way failed. Lets try it\n        // using the standard way.\n        try {\n            String version = System.getProperty(\n                    \"java.vm.specification.version\");\n            // parse the beast...\n            if (version == null) {\n                return false;\n            }\n\n            String[] versions = parseVersions(version);\n            String[] target = new String[]{ \"1\", \"4\" };\n            return (ArrayUtilities.compareVersionArrays(versions, target) >= 0);\n        }\n        catch(Exception e) {\n            return false;\n        }\n    }",
    "comment": " Returns <code>true</code> if we are running on JRE 1.4 or later.  @return A boolean. ",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "PaintList.PaintList",
    "class_name": "org.jfree.chart.util.PaintList",
    "signature": "org.jfree.chart.util.PaintList.PaintList()",
    "snippet": "    public PaintList() {\n        super();\n    }",
    "comment": " Creates a new list. ",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "PaintList.getPaint",
    "class_name": "org.jfree.chart.util.PaintList",
    "signature": "org.jfree.chart.util.PaintList.getPaint(int)",
    "snippet": "    public Paint getPaint(int index) {\n        return (Paint) get(index);\n    }",
    "comment": " Returns a {@link Paint} object from the list.  @param index the index (zero-based).  @return The object. ",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "PaintList.setPaint",
    "class_name": "org.jfree.chart.util.PaintList",
    "signature": "org.jfree.chart.util.PaintList.setPaint(int,Paint)",
    "snippet": "    public void setPaint(int index, Paint paint) {\n        set(index, paint);\n    }",
    "comment": " Sets the {@link Paint} for an item in the list.  The list is expanded  if necessary.  @param index  the index (zero-based). @param paint  the {@link Paint}. ",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "RectangleAnchor.coordinates",
    "class_name": "org.jfree.chart.util.RectangleAnchor",
    "signature": "org.jfree.chart.util.RectangleAnchor.coordinates(Rectangle2D,RectangleAnchor)",
    "snippet": "    public static Point2D coordinates(final Rectangle2D rectangle, \n                                      final RectangleAnchor anchor) {\n        Point2D result = new Point2D.Double();\n        if (anchor == RectangleAnchor.CENTER) {\n            result.setLocation(rectangle.getCenterX(), rectangle.getCenterY());\n        }\n        else if (anchor == RectangleAnchor.TOP) {\n            result.setLocation(rectangle.getCenterX(), rectangle.getMinY());\n        }\n        else if (anchor == RectangleAnchor.BOTTOM) {\n            result.setLocation(rectangle.getCenterX(), rectangle.getMaxY());\n        }\n        else if (anchor == RectangleAnchor.LEFT) {\n            result.setLocation(rectangle.getMinX(), rectangle.getCenterY());\n        }\n        else if (anchor == RectangleAnchor.RIGHT) {\n            result.setLocation(rectangle.getMaxX(), rectangle.getCenterY());\n        }\n        else if (anchor == RectangleAnchor.TOP_LEFT) {\n            result.setLocation(rectangle.getMinX(), rectangle.getMinY());\n        }\n        else if (anchor == RectangleAnchor.TOP_RIGHT) {\n            result.setLocation(rectangle.getMaxX(), rectangle.getMinY());\n        }\n        else if (anchor == RectangleAnchor.BOTTOM_LEFT) {\n            result.setLocation(rectangle.getMinX(), rectangle.getMaxY());\n        }\n        else if (anchor == RectangleAnchor.BOTTOM_RIGHT) {\n            result.setLocation(rectangle.getMaxX(), rectangle.getMaxY());\n        }\n        return result;\n    }",
    "comment": " Returns the (x, y) coordinates of the specified anchor.  @param rectangle  the rectangle. @param anchor  the anchor.  @return The (x, y) coordinates. ",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "RectangleEdge.equals",
    "class_name": "org.jfree.chart.util.RectangleEdge",
    "signature": "org.jfree.chart.util.RectangleEdge.equals(Object)",
    "snippet": "    public boolean equals(Object obj) {\n\n        if (this == obj) {\n            return true;\n        }\n        if (!(obj instanceof RectangleEdge)) {\n            return false;\n        }\n\n        RectangleEdge order = (RectangleEdge) obj;\n        if (!this.name.equals(order.name)) {\n            return false;\n        }\n\n        return true;\n\n    }",
    "comment": " Returns <code>true</code> if this object is equal to the specified  object, and <code>false</code> otherwise.  @param obj  the other object.  @return A boolean. ",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "RectangleEdge.isLeftOrRight",
    "class_name": "org.jfree.chart.util.RectangleEdge",
    "signature": "org.jfree.chart.util.RectangleEdge.isLeftOrRight(RectangleEdge)",
    "snippet": "    public static boolean isLeftOrRight(RectangleEdge edge) {\n        return (edge == RectangleEdge.LEFT || edge == RectangleEdge.RIGHT);    \n    }",
    "comment": " Returns <code>true</code> if the edge is <code>LEFT</code> or  <code>RIGHT</code>, and <code>false</code> otherwise.  @param edge  the edge.  @return A boolean. ",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "RectangleEdge.isTopOrBottom",
    "class_name": "org.jfree.chart.util.RectangleEdge",
    "signature": "org.jfree.chart.util.RectangleEdge.isTopOrBottom(RectangleEdge)",
    "snippet": "    public static boolean isTopOrBottom(RectangleEdge edge) {\n        return (edge == RectangleEdge.TOP || edge == RectangleEdge.BOTTOM);    \n    }",
    "comment": " Returns <code>true</code> if the edge is <code>TOP</code> or  <code>BOTTOM</code>, and <code>false</code> otherwise.  @param edge  the edge.  @return A boolean. ",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "RectangleInsets.RectangleInsets",
    "class_name": "org.jfree.chart.util.RectangleInsets",
    "signature": "org.jfree.chart.util.RectangleInsets.RectangleInsets(UnitType,double,double,double,double)",
    "snippet": "    public RectangleInsets(UnitType unitType, double top, double left, \n                           double bottom, double right) {\n        if (unitType == null) {\n            throw new IllegalArgumentException(\"Null 'unitType' argument.\");\n        }\n        this.unitType = unitType;\n        this.top = top;\n        this.bottom = bottom;\n        this.left = left;\n        this.right = right;\n    }",
    "comment": " Creates a new instance.  @param unitType  absolute or relative units (<code>null</code> not  permitted). @param top  the top insets. @param left  the left insets. @param bottom  the bottom insets. @param right  the right insets. ",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "RectangleInsets.RectangleInsets",
    "class_name": "org.jfree.chart.util.RectangleInsets",
    "signature": "org.jfree.chart.util.RectangleInsets.RectangleInsets(double,double,double,double)",
    "snippet": "    public RectangleInsets(double top, double left, double bottom, \n            double right) {\n        this(UnitType.ABSOLUTE, top, left, bottom, right);   \n    }",
    "comment": " Creates a new instance with the specified insets (as 'absolute' units).  @param top  the top insets. @param left  the left insets. @param bottom  the bottom insets. @param right  the right insets. ",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "RectangleInsets.calculateBottomInset",
    "class_name": "org.jfree.chart.util.RectangleInsets",
    "signature": "org.jfree.chart.util.RectangleInsets.calculateBottomInset(double)",
    "snippet": "    public double calculateBottomInset(double height) {\n        double result = this.bottom;\n        if (this.unitType == UnitType.RELATIVE) {\n            result = (this.bottom * height);\n        }\n        return result;\n    }",
    "comment": " Returns the bottom margin.  @param height  the height of the base rectangle.  @return The bottom margin (in Java2D units). ",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "RectangleInsets.calculateBottomOutset",
    "class_name": "org.jfree.chart.util.RectangleInsets",
    "signature": "org.jfree.chart.util.RectangleInsets.calculateBottomOutset(double)",
    "snippet": "    public double calculateBottomOutset(double height) {\n        double result = this.bottom;\n        if (this.unitType == UnitType.RELATIVE) {\n            result = (height / (1 - this.top - this.bottom)) * this.bottom;\n        }\n        return result;\n    }",
    "comment": " Returns the bottom margin.  @param height  the height of the base rectangle.  @return The bottom margin (in Java2D units). ",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "RectangleInsets.calculateLeftInset",
    "class_name": "org.jfree.chart.util.RectangleInsets",
    "signature": "org.jfree.chart.util.RectangleInsets.calculateLeftInset(double)",
    "snippet": "    public double calculateLeftInset(double width) {\n        double result = this.left;\n        if (this.unitType == UnitType.RELATIVE) {\n            result = (this.left * width);\n        }\n        return result;\n    }",
    "comment": " Returns the left margin.  @param width  the width of the base rectangle.  @return The left margin (in Java2D units). ",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "RectangleInsets.calculateLeftOutset",
    "class_name": "org.jfree.chart.util.RectangleInsets",
    "signature": "org.jfree.chart.util.RectangleInsets.calculateLeftOutset(double)",
    "snippet": "    public double calculateLeftOutset(double width) {\n        double result = this.left;\n        if (this.unitType == UnitType.RELATIVE) {\n            result = (width / (1 - this.left - this.right)) * this.left;\n        }\n        return result;\n    }",
    "comment": " Returns the left margin.  @param width  the width of the base rectangle.  @return The left margin (in Java2D units). ",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "RectangleInsets.calculateRightInset",
    "class_name": "org.jfree.chart.util.RectangleInsets",
    "signature": "org.jfree.chart.util.RectangleInsets.calculateRightInset(double)",
    "snippet": "    public double calculateRightInset(double width) {\n        double result = this.right;\n        if (this.unitType == UnitType.RELATIVE) {\n            result = (this.right * width);\n        }\n        return result;\n    }",
    "comment": " Returns the right margin.  @param width  the width of the base rectangle.  @return The right margin (in Java2D units). ",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "RectangleInsets.calculateRightOutset",
    "class_name": "org.jfree.chart.util.RectangleInsets",
    "signature": "org.jfree.chart.util.RectangleInsets.calculateRightOutset(double)",
    "snippet": "    public double calculateRightOutset(double width) {\n        double result = this.right;\n        if (this.unitType == UnitType.RELATIVE) {\n            result = (width / (1 - this.left - this.right)) * this.right;\n        }\n        return result;\n    }",
    "comment": " Returns the right margin.  @param width  the width of the base rectangle.  @return The right margin (in Java2D units). ",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "RectangleInsets.calculateTopInset",
    "class_name": "org.jfree.chart.util.RectangleInsets",
    "signature": "org.jfree.chart.util.RectangleInsets.calculateTopInset(double)",
    "snippet": "    public double calculateTopInset(double height) {\n        double result = this.top;\n        if (this.unitType == UnitType.RELATIVE) {\n            result = (this.top * height);\n        }\n        return result;\n    }",
    "comment": " Returns the top margin.  @param height  the height of the base rectangle.  @return The top margin (in Java2D units). ",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "RectangleInsets.calculateTopOutset",
    "class_name": "org.jfree.chart.util.RectangleInsets",
    "signature": "org.jfree.chart.util.RectangleInsets.calculateTopOutset(double)",
    "snippet": "    public double calculateTopOutset(double height) {\n        double result = this.top;\n        if (this.unitType == UnitType.RELATIVE) {\n            result = (height / (1 - this.top - this.bottom)) * this.top;\n        }\n        return result;\n    }",
    "comment": " Returns the top margin.  @param height  the height of the base rectangle.  @return The top margin (in Java2D units). ",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "RectangleInsets.createOutsetRectangle",
    "class_name": "org.jfree.chart.util.RectangleInsets",
    "signature": "org.jfree.chart.util.RectangleInsets.createOutsetRectangle(Rectangle2D)",
    "snippet": "    public Rectangle2D createOutsetRectangle(Rectangle2D base) {\n        return createOutsetRectangle(base, true, true);\n    }",
    "comment": " Creates an outset rectangle.  @param base  the base rectangle (<code>null</code> not permitted).  @return An outset rectangle. ",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "RectangleInsets.createOutsetRectangle",
    "class_name": "org.jfree.chart.util.RectangleInsets",
    "signature": "org.jfree.chart.util.RectangleInsets.createOutsetRectangle(Rectangle2D,boolean,boolean)",
    "snippet": "    public Rectangle2D createOutsetRectangle(Rectangle2D base,\n                                             boolean horizontal, \n                                             boolean vertical) {\n        if (base == null) {\n            throw new IllegalArgumentException(\"Null 'base' argument.\");\n        }\n        double topMargin = 0.0;\n        double bottomMargin = 0.0;\n        if (vertical) {\n            topMargin = calculateTopOutset(base.getHeight());\n            bottomMargin = calculateBottomOutset(base.getHeight());\n        }\n        double leftMargin = 0.0;\n        double rightMargin = 0.0;\n        if (horizontal) {\n            leftMargin = calculateLeftOutset(base.getWidth());\n            rightMargin = calculateRightOutset(base.getWidth());\n        }\n        return new Rectangle2D.Double(\n            base.getX() - leftMargin, \n            base.getY() - topMargin,\n            base.getWidth() + leftMargin + rightMargin,\n            base.getHeight() + topMargin + bottomMargin\n        );\n    }",
    "comment": " Creates an outset rectangle.  @param base  the base rectangle (<code>null</code> not permitted). @param horizontal  apply horizontal insets? @param vertical  apply vertical insets?   @return An outset rectangle. ",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "RectangleInsets.extendHeight",
    "class_name": "org.jfree.chart.util.RectangleInsets",
    "signature": "org.jfree.chart.util.RectangleInsets.extendHeight(double)",
    "snippet": "    public double extendHeight(double height) {\n        return height \n               + calculateTopOutset(height) + calculateBottomOutset(height);   \n    }",
    "comment": " Extends the given height to allow for the insets.  @param height  the height.  @return The extended height. ",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "RectangleInsets.extendWidth",
    "class_name": "org.jfree.chart.util.RectangleInsets",
    "signature": "org.jfree.chart.util.RectangleInsets.extendWidth(double)",
    "snippet": "    public double extendWidth(double width) {\n        return width + calculateLeftOutset(width) + calculateRightOutset(width);   \n    }",
    "comment": " Extends the given width to allow for the insets.  @param width  the width.  @return The extended width. ",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "RectangleInsets.getBottom",
    "class_name": "org.jfree.chart.util.RectangleInsets",
    "signature": "org.jfree.chart.util.RectangleInsets.getBottom()",
    "snippet": "    public double getBottom() {\n        return this.bottom;\n    }",
    "comment": " Returns the bottom insets.  @return The bottom insets. ",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "RectangleInsets.getLeft",
    "class_name": "org.jfree.chart.util.RectangleInsets",
    "signature": "org.jfree.chart.util.RectangleInsets.getLeft()",
    "snippet": "    public double getLeft() {\n        return this.left;\n    }",
    "comment": " Returns the left insets.  @return The left insets. ",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "RectangleInsets.getRight",
    "class_name": "org.jfree.chart.util.RectangleInsets",
    "signature": "org.jfree.chart.util.RectangleInsets.getRight()",
    "snippet": "    public double getRight() {\n        return this.right;\n    }",
    "comment": " Returns the right insets.  @return The right insets. ",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "RectangleInsets.getTop",
    "class_name": "org.jfree.chart.util.RectangleInsets",
    "signature": "org.jfree.chart.util.RectangleInsets.getTop()",
    "snippet": "    public double getTop() {\n        return this.top;\n    }",
    "comment": " Returns the top insets.  @return The top insets. ",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "RectangleInsets.trim",
    "class_name": "org.jfree.chart.util.RectangleInsets",
    "signature": "org.jfree.chart.util.RectangleInsets.trim(Rectangle2D)",
    "snippet": "    public void trim(Rectangle2D area) {\n        double w = area.getWidth();\n        double h = area.getHeight();\n        double l = calculateLeftInset(w);\n        double r = calculateRightInset(w);\n        double t = calculateTopInset(h);\n        double b = calculateBottomInset(h);\n        area.setRect(area.getX() + l, area.getY() + t, w - l - r, h - t - b);    \n    }",
    "comment": " Shrinks the given rectangle by the amount of these insets.  @param area  the area (<code>null</code> not permitted). ",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "RectangleInsets.trimHeight",
    "class_name": "org.jfree.chart.util.RectangleInsets",
    "signature": "org.jfree.chart.util.RectangleInsets.trimHeight(double)",
    "snippet": "    public double trimHeight(double height) {\n        return height \n               - calculateTopInset(height) - calculateBottomInset(height);   \n    }",
    "comment": " Trims the given height to allow for the insets.  @param height  the height.  @return The trimmed height. ",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "RectangleInsets.trimWidth",
    "class_name": "org.jfree.chart.util.RectangleInsets",
    "signature": "org.jfree.chart.util.RectangleInsets.trimWidth(double)",
    "snippet": "    public double trimWidth(double width) {\n        return width - calculateLeftInset(width) - calculateRightInset(width);   \n    }",
    "comment": " Trims the given width to allow for the insets.  @param width  the width.  @return The trimmed width. ",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "ShapeList.ShapeList",
    "class_name": "org.jfree.chart.util.ShapeList",
    "signature": "org.jfree.chart.util.ShapeList.ShapeList()",
    "snippet": "    public ShapeList() {\n        super();\n    }",
    "comment": " Creates a new list. ",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "ShapeUtilities.createTranslatedShape",
    "class_name": "org.jfree.chart.util.ShapeUtilities",
    "signature": "org.jfree.chart.util.ShapeUtilities.createTranslatedShape(Shape,RectangleAnchor,double,double)",
    "snippet": "    public static Shape createTranslatedShape(Shape shape, \n                                              RectangleAnchor anchor, \n                                              double locationX,\n                                              double locationY) {\n        if (shape == null) {\n            throw new IllegalArgumentException(\"Null 'shape' argument.\");\n        }        \n        if (anchor == null) {\n            throw new IllegalArgumentException(\"Null 'anchor' argument.\");\n        }\n        Point2D anchorPoint = RectangleAnchor.coordinates(shape.getBounds2D(), \n                anchor);\n        AffineTransform transform = AffineTransform.getTranslateInstance(\n                locationX - anchorPoint.getX(), locationY - anchorPoint.getY());\n        return transform.createTransformedShape(shape);   \n    }",
    "comment": " Translates a shape to a new location such that the anchor point  (relative to the rectangular bounds of the shape) aligns with the  specified (x, y) coordinate in Java2D space.  @param shape  the shape (<code>null</code> not permitted). @param anchor  the anchor (<code>null</code> not permitted). @param locationX  the x-coordinate (in Java2D space). @param locationY  the y-coordinate (in Java2D space).  @return A new and translated shape. ",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "ShapeUtilities.rotateShape",
    "class_name": "org.jfree.chart.util.ShapeUtilities",
    "signature": "org.jfree.chart.util.ShapeUtilities.rotateShape(Shape,double,float,float)",
    "snippet": "    public static Shape rotateShape(Shape base, double angle,\n                                    float x, float y) {\n        if (base == null) {\n            return null;\n        }\n        AffineTransform rotate = AffineTransform.getRotateInstance(angle, x, y);\n        Shape result = rotate.createTransformedShape(base);\n        return result;\n    }",
    "comment": " Rotates a shape about the specified coordinates.  @param base  the shape (<code>null</code> permitted, returns  <code>null</code>). @param angle  the angle (in radians). @param x  the x coordinate for the rotation point (in Java2D space). @param y  the y coordinate for the rotation point (in Java2D space).  @return the rotated shape. ",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "Size2D.Size2D",
    "class_name": "org.jfree.chart.util.Size2D",
    "signature": "org.jfree.chart.util.Size2D.Size2D()",
    "snippet": "    public Size2D() {\n        this(0.0, 0.0);\n    }",
    "comment": " Creates a new instance with zero width and height. ",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "Size2D.Size2D",
    "class_name": "org.jfree.chart.util.Size2D",
    "signature": "org.jfree.chart.util.Size2D.Size2D(double,double)",
    "snippet": "    public Size2D(double width, double height) {\n        this.width = width;\n        this.height = height;\n    }",
    "comment": " Creates a new instance with the specified width and height.  @param width  the width. @param height  the height. ",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "Size2D.getHeight",
    "class_name": "org.jfree.chart.util.Size2D",
    "signature": "org.jfree.chart.util.Size2D.getHeight()",
    "snippet": "    public double getHeight() {\n        return this.height;\n    }",
    "comment": " Returns the height.  @return The height. ",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "Size2D.getWidth",
    "class_name": "org.jfree.chart.util.Size2D",
    "signature": "org.jfree.chart.util.Size2D.getWidth()",
    "snippet": "    public double getWidth() {\n        return this.width;\n    }",
    "comment": " Returns the width.  @return The width. ",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "StandardGradientPaintTransformer.StandardGradientPaintTransformer",
    "class_name": "org.jfree.chart.util.StandardGradientPaintTransformer",
    "signature": "org.jfree.chart.util.StandardGradientPaintTransformer.StandardGradientPaintTransformer()",
    "snippet": "    public StandardGradientPaintTransformer() {\n        this(GradientPaintTransformType.VERTICAL);\n    }",
    "comment": " Creates a new transformer with the type  {@link GradientPaintTransformType#VERTICAL}. ",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "StandardGradientPaintTransformer.StandardGradientPaintTransformer",
    "class_name": "org.jfree.chart.util.StandardGradientPaintTransformer",
    "signature": "org.jfree.chart.util.StandardGradientPaintTransformer.StandardGradientPaintTransformer(GradientPaintTransformType)",
    "snippet": "    public StandardGradientPaintTransformer(GradientPaintTransformType type) {\n        if (type == null) {\n            throw new IllegalArgumentException(\"Null 'type' argument.\");\n        }\n        this.type = type;\n    }",
    "comment": " Creates a new transformer with the specified type.  @param type  the transform type (<code>null</code> not permitted). ",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "StrokeList.StrokeList",
    "class_name": "org.jfree.chart.util.StrokeList",
    "signature": "org.jfree.chart.util.StrokeList.StrokeList()",
    "snippet": "    public StrokeList() {\n        super();\n    }",
    "comment": " Creates a new list. ",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "StrokeList.getStroke",
    "class_name": "org.jfree.chart.util.StrokeList",
    "signature": "org.jfree.chart.util.StrokeList.getStroke(int)",
    "snippet": "    public Stroke getStroke(int index) {\n        return (Stroke) get(index);\n    }",
    "comment": " Returns a {@link Stroke} object from the list.  @param index the index (zero-based).  @return The object. ",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "KeyedObject.KeyedObject",
    "class_name": "org.jfree.data.KeyedObject",
    "signature": "org.jfree.data.KeyedObject.KeyedObject(Comparable,Object)",
    "snippet": "    public KeyedObject(Comparable key, Object object) {\n        this.key = key;\n        this.object = object;\n    }",
    "comment": " Creates a new (key, object) pair.  @param key  the key. @param object  the object (<code>null</code> permitted). ",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "KeyedObject.getKey",
    "class_name": "org.jfree.data.KeyedObject",
    "signature": "org.jfree.data.KeyedObject.getKey()",
    "snippet": "    public Comparable getKey() {\n        return this.key;\n    }",
    "comment": " Returns the key.  @return The key. ",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "KeyedObject.getObject",
    "class_name": "org.jfree.data.KeyedObject",
    "signature": "org.jfree.data.KeyedObject.getObject()",
    "snippet": "    public Object getObject() {\n        return this.object;\n    }",
    "comment": " Returns the object.  @return The object (possibly <code>null</code>). ",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "KeyedObjects.KeyedObjects",
    "class_name": "org.jfree.data.KeyedObjects",
    "signature": "org.jfree.data.KeyedObjects.KeyedObjects()",
    "snippet": "    public KeyedObjects() {\n        this.data = new java.util.ArrayList();\n    }",
    "comment": " Creates a new collection (initially empty). ",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "KeyedObjects.getIndex",
    "class_name": "org.jfree.data.KeyedObjects",
    "signature": "org.jfree.data.KeyedObjects.getIndex(Comparable)",
    "snippet": "    public int getIndex(Comparable key) {\n        int result = -1;\n        int i = 0;\n        Iterator iterator = this.data.iterator();\n        while (iterator.hasNext()) {\n            KeyedObject ko = (KeyedObject) iterator.next();\n            if (ko.getKey().equals(key)) {\n                result = i;\n            }\n            i++;\n        }\n        return result;\n    }",
    "comment": " Returns the index for a given key.  @param key  the key.  @return The index, or <code>-1</code> if the key is unrecognised. ",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "KeyedObjects.getObject",
    "class_name": "org.jfree.data.KeyedObjects",
    "signature": "org.jfree.data.KeyedObjects.getObject(Comparable)",
    "snippet": "    public Object getObject(Comparable key) {\n        return getObject(getIndex(key));\n    }",
    "comment": " Returns the object for a given key. If the key is not recognised, the  method should return <code>null</code>.  @param key  the key.  @return The object (possibly <code>null</code>). ",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "KeyedObjects.getObject",
    "class_name": "org.jfree.data.KeyedObjects",
    "signature": "org.jfree.data.KeyedObjects.getObject(int)",
    "snippet": "    public Object getObject(int item) {\n        Object result = null;\n        if (item >= 0 && item < this.data.size()) {\n            KeyedObject kobj = (KeyedObject) this.data.get(item);\n            if (kobj != null) {\n                result = kobj.getObject();\n            }\n        }\n        return result;\n    }",
    "comment": " Returns an object.  @param item  the item index (zero-based).  @return The object (<code>null</code> if the index is out of range). ",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "KeyedObjects.setObject",
    "class_name": "org.jfree.data.KeyedObjects",
    "signature": "org.jfree.data.KeyedObjects.setObject(Comparable,Object)",
    "snippet": "    public void setObject(Comparable key, Object object) {\n        int keyIndex = getIndex(key);\n        if (keyIndex >= 0) {\n            KeyedObject ko = (KeyedObject) this.data.get(keyIndex);\n            ko.setObject(object);\n        }\n        else {\n            KeyedObject ko = new KeyedObject(key, object);\n            this.data.add(ko);\n        }\n    }",
    "comment": " Replaces an existing object, or adds a new object to the collection. This is the same as the {@link #addObject(Comparable, Object)}  method.  @param key  the key. @param object  the object. ",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "KeyedObjects2D.KeyedObjects2D",
    "class_name": "org.jfree.data.KeyedObjects2D",
    "signature": "org.jfree.data.KeyedObjects2D.KeyedObjects2D()",
    "snippet": "    public KeyedObjects2D() {\n        this.rowKeys = new java.util.ArrayList();\n        this.columnKeys = new java.util.ArrayList();\n        this.rows = new java.util.ArrayList();\n    }",
    "comment": " Creates a new instance (initially empty). ",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "KeyedObjects2D.addObject",
    "class_name": "org.jfree.data.KeyedObjects2D",
    "signature": "org.jfree.data.KeyedObjects2D.addObject(Object,Comparable,Comparable)",
    "snippet": "    public void addObject(Object object, \n                          Comparable rowKey, \n                          Comparable columnKey) {\n        setObject(object, rowKey, columnKey);\n    }",
    "comment": " Adds an object to the table.  Performs the same function as setObject().  @param object  the object. @param rowKey  the row key. @param columnKey  the column key. ",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "KeyedObjects2D.getColumnCount",
    "class_name": "org.jfree.data.KeyedObjects2D",
    "signature": "org.jfree.data.KeyedObjects2D.getColumnCount()",
    "snippet": "    public int getColumnCount() {\n        return this.columnKeys.size();\n    }",
    "comment": " Returns the column count.  @return The column count. ",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "KeyedObjects2D.getColumnKey",
    "class_name": "org.jfree.data.KeyedObjects2D",
    "signature": "org.jfree.data.KeyedObjects2D.getColumnKey(int)",
    "snippet": "    public Comparable getColumnKey(int column) {\n        return (Comparable) this.columnKeys.get(column);\n    }",
    "comment": " Returns the key for a given column.  @param column  the column.  @return The key. ",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "KeyedObjects2D.getObject",
    "class_name": "org.jfree.data.KeyedObjects2D",
    "signature": "org.jfree.data.KeyedObjects2D.getObject(int,int)",
    "snippet": "    public Object getObject(int row, int column) {\n\n        Object result = null;\n        KeyedObjects rowData = (KeyedObjects) this.rows.get(row);\n        if (rowData != null) {\n            Comparable columnKey = (Comparable) this.columnKeys.get(column);\n            if (columnKey != null) {\n                result = rowData.getObject(columnKey);\n            }\n        }\n        return result;\n\n    }",
    "comment": " Returns the object for a given row and column.  @param row  the row index. @param column  the column index.  @return The object. ",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "KeyedObjects2D.getRowCount",
    "class_name": "org.jfree.data.KeyedObjects2D",
    "signature": "org.jfree.data.KeyedObjects2D.getRowCount()",
    "snippet": "    public int getRowCount() {\n        return this.rowKeys.size();\n    }",
    "comment": " Returns the row count.  @return The row count. ",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "KeyedObjects2D.getRowKey",
    "class_name": "org.jfree.data.KeyedObjects2D",
    "signature": "org.jfree.data.KeyedObjects2D.getRowKey(int)",
    "snippet": "    public Comparable getRowKey(int row) {\n        return (Comparable) this.rowKeys.get(row);\n    }",
    "comment": " Returns the key for a given row.  @param row  the row index (zero based).  @return The row index. ",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "KeyedObjects2D.setObject",
    "class_name": "org.jfree.data.KeyedObjects2D",
    "signature": "org.jfree.data.KeyedObjects2D.setObject(Object,Comparable,Comparable)",
    "snippet": "    public void setObject(Object object, \n                          Comparable rowKey, \n                          Comparable columnKey) {\n\n        KeyedObjects row;\n        int rowIndex = this.rowKeys.indexOf(rowKey);\n        if (rowIndex >= 0) {\n            row = (KeyedObjects) this.rows.get(rowIndex);\n        }\n        else {\n            this.rowKeys.add(rowKey);\n            row = new KeyedObjects();\n            this.rows.add(row);\n        }\n        row.setObject(columnKey, object);\n        int columnIndex = this.columnKeys.indexOf(columnKey);\n        if (columnIndex < 0) {\n            this.columnKeys.add(columnKey);\n        }\n\n    }",
    "comment": " Adds or updates an object.  @param object  the object. @param rowKey  the row key. @param columnKey  the column key. ",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "Range.Range",
    "class_name": "org.jfree.data.Range",
    "signature": "org.jfree.data.Range.Range(double,double)",
    "snippet": "    public Range(double lower, double upper) {\n        if (lower > upper) {\n            String msg = \"Range(double, double): require lower (\" + lower \n                + \") <= upper (\" + upper + \").\";\n            throw new IllegalArgumentException(msg);\n        }\n        this.lower = lower;\n        this.upper = upper;\n    }",
    "comment": " Creates a new range.  @param lower  the lower bound (must be <= upper bound). @param upper  the upper bound (must be >= lower bound). ",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "Range.combine",
    "class_name": "org.jfree.data.Range",
    "signature": "org.jfree.data.Range.combine(Range,Range)",
    "snippet": "    public static Range combine(Range range1, Range range2) {\n        if (range1 == null) {\n            return range2;\n        }\n        else {\n            if (range2 == null) {\n                return range1;\n            }\n            else {\n                double l = Math.min(range1.getLowerBound(), \n                        range2.getLowerBound());\n                double u = Math.max(range1.getUpperBound(), \n                        range2.getUpperBound());\n                return new Range(l, u);\n            }\n        }\n    }",
    "comment": " Creates a new range by combining two existing ranges. <P> Note that: <ul> <li>either range can be <code>null</code>, in which case the other  range is returned;</li> <li>if both ranges are <code>null</code> the return value is  <code>null</code>.</li> </ul>  @param range1  the first range (<code>null</code> permitted). @param range2  the second range (<code>null</code> permitted).  @return A new range (possibly <code>null</code>). ",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "Range.contains",
    "class_name": "org.jfree.data.Range",
    "signature": "org.jfree.data.Range.contains(double)",
    "snippet": "    public boolean contains(double value) {\n        return (value >= this.lower && value <= this.upper);\n    }",
    "comment": " Returns <code>true</code> if the range contains the specified value and  <code>false</code> otherwise.  @param value  the value to lookup.  @return <code>true</code> if the range contains the specified value. ",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "Range.expandToInclude",
    "class_name": "org.jfree.data.Range",
    "signature": "org.jfree.data.Range.expandToInclude(Range,double)",
    "snippet": "    public static Range expandToInclude(Range range, double value) {\n        if (range == null) {\n            return new Range(value, value);\n        }\n        if (value < range.getLowerBound()) {\n            return new Range(value, range.getUpperBound());\n        }\n        else if (value > range.getUpperBound()) {\n            return new Range(range.getLowerBound(), value);\n        }\n        else {\n            return range;\n        }\n    }",
    "comment": " Returns a range that includes all the values in the specified  <code>range</code> AND the specified <code>value</code>.  @param range  the range (<code>null</code> permitted). @param value  the value that must be included.  @return A range.  @since 1.0.1 ",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "Range.getLowerBound",
    "class_name": "org.jfree.data.Range",
    "signature": "org.jfree.data.Range.getLowerBound()",
    "snippet": "    public double getLowerBound() {\n        return this.lower;\n    }",
    "comment": " Returns the lower bound for the range.  @return The lower bound. ",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "Range.getUpperBound",
    "class_name": "org.jfree.data.Range",
    "signature": "org.jfree.data.Range.getUpperBound()",
    "snippet": "    public double getUpperBound() {\n        return this.upper;\n    }",
    "comment": " Returns the upper bound for the range.  @return The upper bound. ",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "AbstractDataset.AbstractDataset",
    "class_name": "org.jfree.data.general.AbstractDataset",
    "signature": "org.jfree.data.general.AbstractDataset.AbstractDataset()",
    "snippet": "    protected AbstractDataset() {\n        this.group = new DatasetGroup();\n        this.listenerList = new EventListenerList();\n    }",
    "comment": " Constructs a dataset. By default, the dataset is assigned to its own  group. ",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "AbstractDataset.addChangeListener",
    "class_name": "org.jfree.data.general.AbstractDataset",
    "signature": "org.jfree.data.general.AbstractDataset.addChangeListener(DatasetChangeListener)",
    "snippet": "    public void addChangeListener(DatasetChangeListener listener) {\n        this.listenerList.add(DatasetChangeListener.class, listener);\n    }",
    "comment": " Registers an object to receive notification of changes to the dataset.  @param listener  the object to register.  @see #removeChangeListener(DatasetChangeListener) ",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "AbstractDataset.fireDatasetChanged",
    "class_name": "org.jfree.data.general.AbstractDataset",
    "signature": "org.jfree.data.general.AbstractDataset.fireDatasetChanged()",
    "snippet": "    protected void fireDatasetChanged() {\n        notifyListeners(new DatasetChangeEvent(this, this));\n    }",
    "comment": " Notifies all registered listeners that the dataset has changed.  @see #addChangeListener(DatasetChangeListener) ",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "AbstractDataset.notifyListeners",
    "class_name": "org.jfree.data.general.AbstractDataset",
    "signature": "org.jfree.data.general.AbstractDataset.notifyListeners(DatasetChangeEvent)",
    "snippet": "    protected void notifyListeners(DatasetChangeEvent event) {\n\n        Object[] listeners = this.listenerList.getListenerList();\n        for (int i = listeners.length - 2; i >= 0; i -= 2) {\n            if (listeners[i] == DatasetChangeListener.class) {\n                ((DatasetChangeListener) listeners[i + 1]).datasetChanged(\n                        event);\n            }\n        }\n\n    }",
    "comment": " Notifies all registered listeners that the dataset has changed.  @param event  contains information about the event that triggered the  notification.  @see #addChangeListener(DatasetChangeListener) @see #removeChangeListener(DatasetChangeListener) ",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "DatasetChangeEvent.DatasetChangeEvent",
    "class_name": "org.jfree.data.general.DatasetChangeEvent",
    "signature": "org.jfree.data.general.DatasetChangeEvent.DatasetChangeEvent(Object,Dataset)",
    "snippet": "    public DatasetChangeEvent(Object source, Dataset dataset) {\n        super(source);\n        this.dataset = dataset;\n    }",
    "comment": " Constructs a new event.  The source is either the dataset or the  {@link org.jfree.chart.plot.Plot} class.  The dataset can be  <code>null</code> (in this case the source will be the  {@link org.jfree.chart.plot.Plot} class).  @param source  the source of the event. @param dataset  the dataset that generated the event (<code>null</code> permitted). ",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "DatasetGroup.DatasetGroup",
    "class_name": "org.jfree.data.general.DatasetGroup",
    "signature": "org.jfree.data.general.DatasetGroup.DatasetGroup()",
    "snippet": "    public DatasetGroup() {\n        super();\n        this.id = \"NOID\";\n    }",
    "comment": " Constructs a new group. ",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "DatasetUtilities.findRangeBounds",
    "class_name": "org.jfree.data.general.DatasetUtilities",
    "signature": "org.jfree.data.general.DatasetUtilities.findRangeBounds(CategoryDataset)",
    "snippet": "    public static Range findRangeBounds(CategoryDataset dataset) {\n        return findRangeBounds(dataset, true);\n    }",
    "comment": " Returns the range of values in the range for the dataset.  @param dataset  the dataset (<code>null</code> not permitted).  @return The range (possibly <code>null</code>). ",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "DatasetUtilities.findRangeBounds",
    "class_name": "org.jfree.data.general.DatasetUtilities",
    "signature": "org.jfree.data.general.DatasetUtilities.findRangeBounds(CategoryDataset,boolean)",
    "snippet": "    public static Range findRangeBounds(CategoryDataset dataset, \n                                        boolean includeInterval) {\n        if (dataset == null) {\n            throw new IllegalArgumentException(\"Null 'dataset' argument.\");\n        }\n        Range result = null;\n        if (dataset instanceof RangeInfo) {\n            RangeInfo info = (RangeInfo) dataset;\n            result = info.getRangeBounds(includeInterval);\n        }\n        else {\n            result = iterateCategoryRangeBounds(dataset, includeInterval);\n        }\n        return result;\n    }",
    "comment": " Returns the range of values in the range for the dataset.  @param dataset  the dataset (<code>null</code> not permitted). @param includeInterval  a flag that determines whether or not the y-interval is taken into account.  @return The range (possibly <code>null</code>). ",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "DatasetUtilities.isEmptyOrNull",
    "class_name": "org.jfree.data.general.DatasetUtilities",
    "signature": "org.jfree.data.general.DatasetUtilities.isEmptyOrNull(CategoryDataset)",
    "snippet": "    public static boolean isEmptyOrNull(CategoryDataset dataset) {\n\n        if (dataset == null) {\n            return true;\n        }\n\n        int rowCount = dataset.getRowCount();\n        int columnCount = dataset.getColumnCount();\n        if (rowCount == 0 || columnCount == 0) {\n            return true;\n        }\n\n        for (int r = 0; r < rowCount; r++) {\n            for (int c = 0; c < columnCount; c++) {\n                if (dataset.getValue(r, c) != null) {\n                    return false;\n                }\n\n            }\n        }\n\n        return true;\n\n    }",
    "comment": " Returns <code>true</code> if the dataset is empty (or <code>null</code>), and <code>false</code> otherwise.  @param dataset  the dataset (<code>null</code> permitted).  @return A boolean. ",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "DefaultStatisticalCategoryDataset.DefaultStatisticalCategoryDataset",
    "class_name": "org.jfree.data.statistics.DefaultStatisticalCategoryDataset",
    "signature": "org.jfree.data.statistics.DefaultStatisticalCategoryDataset.DefaultStatisticalCategoryDataset()",
    "snippet": "    public DefaultStatisticalCategoryDataset() {\n        this.data = new KeyedObjects2D();\n        this.minimumRangeValue = Double.NaN;\n        this.maximumRangeValue = Double.NaN;\n        this.minimumRangeValueIncStdDev = Double.NaN;\n        this.maximumRangeValueIncStdDev = Double.NaN;\n    }",
    "comment": " Creates a new dataset. ",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "DefaultStatisticalCategoryDataset.add",
    "class_name": "org.jfree.data.statistics.DefaultStatisticalCategoryDataset",
    "signature": "org.jfree.data.statistics.DefaultStatisticalCategoryDataset.add(Number,Number,Comparable,Comparable)",
    "snippet": "    public void add(Number mean, Number standardDeviation,\n                    Comparable rowKey, Comparable columnKey) {\n        MeanAndStandardDeviation item = new MeanAndStandardDeviation(\n                mean, standardDeviation);\n        this.data.addObject(item, rowKey, columnKey);\n        double m = 0.0;\n        double sd = 0.0;\n        if (mean != null) {\n            m = mean.doubleValue();\n        }\n        if (standardDeviation != null) {\n            sd = standardDeviation.doubleValue();   \n        }\n        \n        if (!Double.isNaN(m)) {\n            if (Double.isNaN(this.maximumRangeValue) \n                    || m > this.maximumRangeValue) {\n                this.maximumRangeValue = m;\n            }\n        }\n        \n        if (!Double.isNaN(m + sd)) {\n            if (Double.isNaN(this.maximumRangeValueIncStdDev) \n                    || (m + sd) > this.maximumRangeValueIncStdDev) {\n                this.maximumRangeValueIncStdDev = m + sd;\n            }\n        }\n\n        if (!Double.isNaN(m)) {\n            if (Double.isNaN(this.minimumRangeValue) \n                    || m < this.minimumRangeValue) {\n                this.minimumRangeValue = m;\n            }\n        }\n\n        if (!Double.isNaN(m - sd)) {\n            if (Double.isNaN(this.minimumRangeValueIncStdDev) \n                    || (m - sd) < this.minimumRangeValueIncStdDev) {\n                this.minimumRangeValueIncStdDev = m - sd;\n            }\n        }\n\n        fireDatasetChanged();\n    }",
    "comment": " Adds a mean and standard deviation to the table.  @param mean  the mean. @param standardDeviation  the standard deviation. @param rowKey  the row key. @param columnKey  the column key. ",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "DefaultStatisticalCategoryDataset.add",
    "class_name": "org.jfree.data.statistics.DefaultStatisticalCategoryDataset",
    "signature": "org.jfree.data.statistics.DefaultStatisticalCategoryDataset.add(double,double,Comparable,Comparable)",
    "snippet": "    public void add(double mean, double standardDeviation,\n                    Comparable rowKey, Comparable columnKey) {\n        add(new Double(mean), new Double(standardDeviation), rowKey, columnKey);\n    }",
    "comment": " Adds a mean and standard deviation to the table.  @param mean  the mean. @param standardDeviation  the standard deviation. @param rowKey  the row key. @param columnKey  the column key. ",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "DefaultStatisticalCategoryDataset.getColumnCount",
    "class_name": "org.jfree.data.statistics.DefaultStatisticalCategoryDataset",
    "signature": "org.jfree.data.statistics.DefaultStatisticalCategoryDataset.getColumnCount()",
    "snippet": "    public int getColumnCount() {\n        return this.data.getColumnCount();\n    }",
    "comment": " Returns the number of columns in the table.  @return The column count. ",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "DefaultStatisticalCategoryDataset.getColumnKey",
    "class_name": "org.jfree.data.statistics.DefaultStatisticalCategoryDataset",
    "signature": "org.jfree.data.statistics.DefaultStatisticalCategoryDataset.getColumnKey(int)",
    "snippet": "    public Comparable getColumnKey(int column) {\n        return this.data.getColumnKey(column);\n    }",
    "comment": " Returns a column key.  @param column  the column index (zero-based).  @return The column key. ",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "DefaultStatisticalCategoryDataset.getMeanValue",
    "class_name": "org.jfree.data.statistics.DefaultStatisticalCategoryDataset",
    "signature": "org.jfree.data.statistics.DefaultStatisticalCategoryDataset.getMeanValue(int,int)",
    "snippet": "    public Number getMeanValue(int row, int column) {\n        Number result = null;\n        MeanAndStandardDeviation masd \n            = (MeanAndStandardDeviation) this.data.getObject(row, column);\n        if (masd != null) {\n            result = masd.getMean();\n        }\n        return result;\n    }",
    "comment": " Returns the mean value for an item.  @param row  the row index (zero-based). @param column  the column index (zero-based).  @return The mean value. ",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "DefaultStatisticalCategoryDataset.getRangeBounds",
    "class_name": "org.jfree.data.statistics.DefaultStatisticalCategoryDataset",
    "signature": "org.jfree.data.statistics.DefaultStatisticalCategoryDataset.getRangeBounds(boolean)",
    "snippet": "    public Range getRangeBounds(boolean includeInterval) {\n        Range result = null;\n        if (includeInterval) {\n            if (!Double.isNaN(this.minimumRangeValueIncStdDev) \n                    && !Double.isNaN(this.maximumRangeValueIncStdDev))\n            result = new Range(this.minimumRangeValueIncStdDev, \n                    this.maximumRangeValueIncStdDev);\n        }\n        else {\n            if (!Double.isNaN(this.minimumRangeValue) \n                    && !Double.isNaN(this.maximumRangeValue))\n            result = new Range(this.minimumRangeValue, this.maximumRangeValue);            \n        }\n        return result;\n    }",
    "comment": " Returns the range of the values in this dataset's range.  @param includeInterval  a flag that determines whether or not the y-interval is taken into account.  @return The range. ",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "DefaultStatisticalCategoryDataset.getRowCount",
    "class_name": "org.jfree.data.statistics.DefaultStatisticalCategoryDataset",
    "signature": "org.jfree.data.statistics.DefaultStatisticalCategoryDataset.getRowCount()",
    "snippet": "    public int getRowCount() {\n        return this.data.getRowCount();\n    }",
    "comment": " Returns the number of rows in the table.  @return The row count. ",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "DefaultStatisticalCategoryDataset.getRowKey",
    "class_name": "org.jfree.data.statistics.DefaultStatisticalCategoryDataset",
    "signature": "org.jfree.data.statistics.DefaultStatisticalCategoryDataset.getRowKey(int)",
    "snippet": "    public Comparable getRowKey(int row) {\n        return this.data.getRowKey(row);\n    }",
    "comment": " Returns a row key.  @param row  the row index (zero-based).  @return The row key. ",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "DefaultStatisticalCategoryDataset.getStdDevValue",
    "class_name": "org.jfree.data.statistics.DefaultStatisticalCategoryDataset",
    "signature": "org.jfree.data.statistics.DefaultStatisticalCategoryDataset.getStdDevValue(int,int)",
    "snippet": "    public Number getStdDevValue(int row, int column) {\n        Number result = null;\n        MeanAndStandardDeviation masd \n            = (MeanAndStandardDeviation) this.data.getObject(row, column);\n        if (masd != null) {\n            result = masd.getStandardDeviation();\n        }\n        return result;\n    }",
    "comment": " Returns the standard deviation value for an item.  @param row  the row index (zero-based). @param column  the column index (zero-based).  @return The standard deviation. ",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "DefaultStatisticalCategoryDataset.getValue",
    "class_name": "org.jfree.data.statistics.DefaultStatisticalCategoryDataset",
    "signature": "org.jfree.data.statistics.DefaultStatisticalCategoryDataset.getValue(int,int)",
    "snippet": "    public Number getValue(int row, int column) {\n        return getMeanValue(row, column);\n    }",
    "comment": " Returns the value for an item (for this dataset, the mean value is returned).  @param row  the row index. @param column  the column index.  @return The value. ",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "MeanAndStandardDeviation.MeanAndStandardDeviation",
    "class_name": "org.jfree.data.statistics.MeanAndStandardDeviation",
    "signature": "org.jfree.data.statistics.MeanAndStandardDeviation.MeanAndStandardDeviation(Number,Number)",
    "snippet": "    public MeanAndStandardDeviation(Number mean, Number standardDeviation) {\n        this.mean = mean;\n        this.standardDeviation = standardDeviation;\n    }",
    "comment": " Creates a new mean and standard deviation record.  @param mean  the mean (<code>null</code> permitted). @param standardDeviation  the standard deviation (<code>null</code> permitted. ",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "MeanAndStandardDeviation.getMean",
    "class_name": "org.jfree.data.statistics.MeanAndStandardDeviation",
    "signature": "org.jfree.data.statistics.MeanAndStandardDeviation.getMean()",
    "snippet": "    public Number getMean() {\n        return this.mean;\n    }",
    "comment": " Returns the mean.  @return The mean. ",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  },
  {
    "name": "MeanAndStandardDeviation.getStandardDeviation",
    "class_name": "org.jfree.data.statistics.MeanAndStandardDeviation",
    "signature": "org.jfree.data.statistics.MeanAndStandardDeviation.getStandardDeviation()",
    "snippet": "    public Number getStandardDeviation() {\n        return this.standardDeviation;\n    }",
    "comment": " Returns the standard deviation.  @return The standard deviation. ",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 2
  }
]