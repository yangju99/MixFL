[
  {
    "name": "Gamma.logGamma",
    "class_name": "org.apache.commons.math.special.Gamma",
    "signature": "org.apache.commons.math.special.Gamma.logGamma(double)",
    "snippet": "    public static double logGamma(double x) {\n        double ret;\n\n        if (Double.isNaN(x) || (x <= 0.0)) {\n            ret = Double.NaN;\n        } else {\n            double g = 607.0 / 128.0;\n            \n            double sum = 0.0;\n            for (int i = lanczos.length - 1; i > 0; --i) {\n                sum = sum + (lanczos[i] / (x + i));\n            }\n            sum = sum + lanczos[0];\n\n            double tmp = x + g + .5;\n            ret = ((x + .5) * Math.log(tmp)) - tmp +\n                HALF_LOG_2_PI + Math.log(sum / x);\n        }\n\n        return ret;\n    }",
    "comment": " Returns the natural logarithm of the gamma function &#915;(x).  The implementation of this method is based on: <ul> <li><a href=\"http://mathworld.wolfram.com/GammaFunction.html\"> Gamma Function</a>, equation (28).</li> <li><a href=\"http://mathworld.wolfram.com/LanczosApproximation.html\"> Lanczos Approximation</a>, equations (1) through (5).</li> <li><a href=\"http://my.fit.edu/~gabdo/gamma.txt\">Paul Godfrey, A note on the computation of the convergent Lanczos complex Gamma approximation </a></li> </ul>  @param x the value. @return log(&#915;(x)) ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 0
  },
  {
    "name": "Gamma.regularizedGammaP",
    "class_name": "org.apache.commons.math.special.Gamma",
    "signature": "org.apache.commons.math.special.Gamma.regularizedGammaP(double,double)",
    "snippet": "    public static double regularizedGammaP(double a, double x)\n        throws MathException\n    {\n        return regularizedGammaP(a, x, DEFAULT_EPSILON, Integer.MAX_VALUE);\n    }",
    "comment": " Returns the regularized gamma function P(a, x).  @param a the a parameter. @param x the value. @return the regularized gamma function P(a, x) @throws MathException if the algorithm fails to converge. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 0
  },
  {
    "name": "Gamma.regularizedGammaP",
    "class_name": "org.apache.commons.math.special.Gamma",
    "signature": "org.apache.commons.math.special.Gamma.regularizedGammaP(double,double,double,int)",
    "snippet": "    public static double regularizedGammaP(double a, \n                                           double x, \n                                           double epsilon, \n                                           int maxIterations) \n        throws MathException\n    {\n        double ret;\n\n        if (Double.isNaN(a) || Double.isNaN(x) || (a <= 0.0) || (x < 0.0)) {\n            ret = Double.NaN;\n        } else if (x == 0.0) {\n            ret = 0.0;\n        } else if (a >= 1.0 && x > a) {\n            // use regularizedGammaQ because it should converge faster in this\n            // case.\n            ret = 1.0 - regularizedGammaQ(a, x, epsilon, maxIterations);\n        } else {\n            // calculate series\n            double n = 0.0; // current element index\n            double an = 1.0 / a; // n-th element in the series\n            double sum = an; // partial sum\n            while (Math.abs(an) > epsilon && n < maxIterations) {\n                // compute next element in the series\n                n = n + 1.0;\n                an = an * (x / (a + n));\n\n                // update partial sum\n                sum = sum + an;\n            }\n            if (n >= maxIterations) {\n                throw new MaxIterationsExceededException(maxIterations);\n            } else {\n                ret = Math.exp(-x + (a * Math.log(x)) - logGamma(a)) * sum;\n            }\n        }\n\n        return ret;\n    }",
    "comment": " Returns the regularized gamma function P(a, x).  The implementation of this method is based on: <ul> <li> <a href=\"http://mathworld.wolfram.com/RegularizedGammaFunction.html\"> Regularized Gamma Function</a>, equation (1).</li> <li> <a href=\"http://mathworld.wolfram.com/IncompleteGammaFunction.html\"> Incomplete Gamma Function</a>, equation (4).</li> <li> <a href=\"http://mathworld.wolfram.com/ConfluentHypergeometricFunctionoftheFirstKind.html\"> Confluent Hypergeometric Function of the First Kind</a>, equation (1). </li> </ul>  @param a the a parameter. @param x the value. @param epsilon When the absolute value of the nth item in the series is less than epsilon the approximation ceases to calculate further elements in the series. @param maxIterations Maximum number of \"iterations\" to complete.  @return the regularized gamma function P(a, x) @throws MathException if the algorithm fails to converge. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 0
  },
  {
    "name": "Gamma.regularizedGammaQ",
    "class_name": "org.apache.commons.math.special.Gamma",
    "signature": "org.apache.commons.math.special.Gamma.regularizedGammaQ(double,double)",
    "snippet": "    public static double regularizedGammaQ(double a, double x)\n        throws MathException\n    {\n        return regularizedGammaQ(a, x, DEFAULT_EPSILON, Integer.MAX_VALUE);\n    }",
    "comment": " Returns the regularized gamma function Q(a, x) = 1 - P(a, x).  @param a the a parameter. @param x the value. @return the regularized gamma function Q(a, x) @throws MathException if the algorithm fails to converge. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 0
  },
  {
    "name": "Gamma.regularizedGammaQ",
    "class_name": "org.apache.commons.math.special.Gamma",
    "signature": "org.apache.commons.math.special.Gamma.regularizedGammaQ(double,double,double,int)",
    "snippet": "    public static double regularizedGammaQ(final double a, \n                                           double x, \n                                           double epsilon, \n                                           int maxIterations) \n        throws MathException\n    {\n        double ret;\n\n        if (Double.isNaN(a) || Double.isNaN(x) || (a <= 0.0) || (x < 0.0)) {\n            ret = Double.NaN;\n        } else if (x == 0.0) {\n            ret = 1.0;\n        } else if (x < a || a < 1.0) {\n            // use regularizedGammaP because it should converge faster in this\n            // case.\n            ret = 1.0 - regularizedGammaP(a, x, epsilon, maxIterations);\n        } else {\n            // create continued fraction\n            ContinuedFraction cf = new ContinuedFraction() {\n\n                private static final long serialVersionUID = 5378525034886164398L;\n\n                protected double getA(int n, double x) {\n                    return ((2.0 * n) + 1.0) - a + x;\n                }\n\n                protected double getB(int n, double x) {\n                    return n * (a - n);\n                }\n            };\n            \n            ret = 1.0 / cf.evaluate(x, epsilon, maxIterations);\n            ret = Math.exp(-x + (a * Math.log(x)) - logGamma(a)) * ret;\n        }\n\n        return ret;\n    }",
    "comment": " Returns the regularized gamma function Q(a, x) = 1 - P(a, x).  The implementation of this method is based on: <ul> <li> <a href=\"http://mathworld.wolfram.com/RegularizedGammaFunction.html\"> Regularized Gamma Function</a>, equation (1).</li> <li> <a href=\"    http://functions.wolfram.com/GammaBetaErf/GammaRegularized/10/0003/\"> Regularized incomplete gamma function: Continued fraction representations  (formula 06.08.10.0003)</a></li> </ul>  @param a the a parameter. @param x the value. @param epsilon When the absolute value of the nth item in the series is less than epsilon the approximation ceases to calculate further elements in the series. @param maxIterations Maximum number of \"iterations\" to complete.  @return the regularized gamma function P(a, x) @throws MathException if the algorithm fails to converge. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 0
  },
  {
    "name": "ContinuedFraction.ContinuedFraction",
    "class_name": "org.apache.commons.math.util.ContinuedFraction",
    "signature": "org.apache.commons.math.util.ContinuedFraction.ContinuedFraction()",
    "snippet": "    protected ContinuedFraction() {\n        super();\n    }",
    "comment": " Default constructor. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 0
  },
  {
    "name": "ContinuedFraction.evaluate",
    "class_name": "org.apache.commons.math.util.ContinuedFraction",
    "signature": "org.apache.commons.math.util.ContinuedFraction.evaluate(double,double,int)",
    "snippet": "    public double evaluate(double x, double epsilon, int maxIterations)\n        throws MathException\n    {\n        double p0 = 1.0;\n        double p1 = getA(0, x);\n        double q0 = 0.0;\n        double q1 = 1.0;\n        double c = p1 / q1;\n        int n = 0;\n        double relativeError = Double.MAX_VALUE;\n        while (n < maxIterations && relativeError > epsilon) {\n            ++n;\n            double a = getA(n, x);\n            double b = getB(n, x);\n            double p2 = a * p1 + b * p0;\n            double q2 = a * q1 + b * q0;\n            if (Double.isInfinite(p2) || Double.isInfinite(q2)) {\n                // need to scale\n                if (a != 0.0) {\n                    p2 = p1 + (b / a * p0);\n                    q2 = q1 + (b / a * q0);\n                } else if (b != 0) {\n                    p2 = (a / b * p1) + p0;\n                    q2 = (a / b * q1) + q0;\n                } else {\n                    // can not scale an convergent is unbounded.\n                    throw new ConvergenceException(\n                        \"Continued fraction convergents diverged to +/- infinity for value {0}\",\n                        new Object[] { new Double(x) });\n                }\n            }\n            double r = p2 / q2;\n            relativeError = Math.abs(r / c - 1.0);\n                \n            // prepare for next iteration\n            c = p2 / q2;\n            p0 = p1;\n            p1 = p2;\n            q0 = q1;\n            q1 = q2;\n        }\n\n        if (n >= maxIterations) {\n            throw new MaxIterationsExceededException(maxIterations,\n                \"Continued fraction convergents failed to converge for value {0}\",\n                new Object[] { new Double(x) });\n        }\n\n        return c;\n    }",
    "comment": " <p> Evaluates the continued fraction at the value x. </p>  <p> The implementation of this method is based on equations 14-17 of: <ul> <li> Eric W. Weisstein. \"Continued Fraction.\" From MathWorld--A Wolfram Web Resource. <a target=\"_blank\" href=\"http://mathworld.wolfram.com/ContinuedFraction.html\"> http://mathworld.wolfram.com/ContinuedFraction.html</a> </li> </ul> The recurrence relationship defined in those equations can result in very large intermediate results which can result in numerical overflow. As a means to combat these overflow conditions, the intermediate results are scaled whenever they threaten to become numerically unstable.  @param x the evaluation point. @param epsilon maximum error allowed. @param maxIterations maximum number of convergents @return the value of the continued fraction evaluated at x.  @throws MathException if the algorithm fails to converge. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 0
  }
]