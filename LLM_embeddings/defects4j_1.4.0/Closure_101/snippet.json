[
  {
    "name": "AbstractCommandLineRunner.AbstractCommandLineRunner",
    "class_name": "com.google.javascript.jscomp.AbstractCommandLineRunner",
    "signature": "com.google.javascript.jscomp.AbstractCommandLineRunner.AbstractCommandLineRunner()",
    "snippet": "  AbstractCommandLineRunner() {\n    this(System.out, System.err);\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "AbstractCommandLineRunner.AbstractCommandLineRunner",
    "class_name": "com.google.javascript.jscomp.AbstractCommandLineRunner",
    "signature": "com.google.javascript.jscomp.AbstractCommandLineRunner.AbstractCommandLineRunner(PrintStream,PrintStream)",
    "snippet": "  AbstractCommandLineRunner(PrintStream out, PrintStream err) {\n    this.config = new CommandLineConfig();\n    this.out = out;\n    this.err = err;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "AbstractCommandLineRunner.createDefineReplacements",
    "class_name": "com.google.javascript.jscomp.AbstractCommandLineRunner",
    "signature": "com.google.javascript.jscomp.AbstractCommandLineRunner.createDefineReplacements(List,CompilerOptions)",
    "snippet": "  @VisibleForTesting\n  static void createDefineReplacements(List<String> definitions,\n      CompilerOptions options) {\n    // Parse the definitions\n    for (String override : definitions) {\n      String[] assignment = override.split(\"=\", 2);\n      String defName = assignment[0];\n\n      if (defName.length() > 0) {\n        if (assignment.length == 1) {\n          options.setDefineToBooleanLiteral(defName, true);\n          continue;\n        } else {\n          String defValue = assignment[1];\n\n          if (defValue.equals(\"true\")) {\n            options.setDefineToBooleanLiteral(defName, true);\n            continue;\n          } else if (defValue.equals(\"false\")) {\n            options.setDefineToBooleanLiteral(defName, false);\n            continue;\n          } else if (defValue.length() > 1 &&\n              defValue.charAt(0) == '\\'' &&\n              defValue.charAt(defValue.length() - 1) == '\\'') {\n            // If the value starts and ends with a single quote,\n            // we assume that it's a string.\n            String maybeStringVal =\n                defValue.substring(1, defValue.length() - 1);\n            if (maybeStringVal.indexOf('\\'') == -1) {\n              options.setDefineToStringLiteral(defName, maybeStringVal);\n              continue;\n            }\n          } else {\n            try {\n              options.setDefineToDoubleLiteral(defName,\n                  Double.parseDouble(defValue));\n              continue;\n            } catch (NumberFormatException e) {\n              // do nothing, it will be caught at the end\n            }\n          }\n        }\n      }\n\n      throw new RuntimeException(\n          \"--define flag syntax invalid: \" + override);\n    }\n  }",
    "comment": " Create a map of constant names to constant values from a textual description of the map.  @param definitions A list of overriding definitions for defines in the form <name>[=<val>], where <val> is a number, boolean, or single-quoted string without single quotes. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "AbstractCommandLineRunner.getCommandLineConfig",
    "class_name": "com.google.javascript.jscomp.AbstractCommandLineRunner",
    "signature": "com.google.javascript.jscomp.AbstractCommandLineRunner.getCommandLineConfig()",
    "snippet": "  protected CommandLineConfig getCommandLineConfig() {\n    return config;\n  }",
    "comment": " Get the command line config, so that it can be initialized. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "AbstractCommandLineRunner.getDiagnosticGroups",
    "class_name": "com.google.javascript.jscomp.AbstractCommandLineRunner",
    "signature": "com.google.javascript.jscomp.AbstractCommandLineRunner.getDiagnosticGroups()",
    "snippet": "  protected DiagnosticGroups getDiagnosticGroups() {\n    return new DiagnosticGroups();\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "AbstractCommandLineRunner.getErrorPrintStream",
    "class_name": "com.google.javascript.jscomp.AbstractCommandLineRunner",
    "signature": "com.google.javascript.jscomp.AbstractCommandLineRunner.getErrorPrintStream()",
    "snippet": "  protected PrintStream getErrorPrintStream() {\n    return err;\n  }",
    "comment": " Returns the PrintStream for writing errors associated with this AbstractCommandLineRunner. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "AbstractCommandLineRunner.getInputCharset",
    "class_name": "com.google.javascript.jscomp.AbstractCommandLineRunner",
    "signature": "com.google.javascript.jscomp.AbstractCommandLineRunner.getInputCharset()",
    "snippet": "  private Charset getInputCharset() throws FlagUsageException {\n    if (!config.charset.isEmpty()) {\n      if (!Charset.isSupported(config.charset)) {\n        throw new FlagUsageException(config.charset +\n            \" is not a valid charset name.\");\n      }\n      return Charset.forName(config.charset);\n    }\n    return Charsets.UTF_8;\n  }",
    "comment": " Query the flag for the charset, and return a Charset object representing the selection.  @return Charset to use when reading inputs @throws FlagUsageException if flag is not a valid Charset name. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "AbstractCommandLineRunner.initOptionsFromFlags",
    "class_name": "com.google.javascript.jscomp.AbstractCommandLineRunner",
    "signature": "com.google.javascript.jscomp.AbstractCommandLineRunner.initOptionsFromFlags(CompilerOptions)",
    "snippet": "  protected void initOptionsFromFlags(CompilerOptions options) {\n\n    DiagnosticGroups diagnosticGroups = getDiagnosticGroups();\n\n    diagnosticGroups.setWarningLevels(\n        options, config.jscompError, CheckLevel.ERROR);\n    diagnosticGroups.setWarningLevels(\n        options, config.jscompWarning, CheckLevel.WARNING);\n    diagnosticGroups.setWarningLevels(\n        options, config.jscompOff, CheckLevel.OFF);\n\n    createDefineReplacements(config.define, options);\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "CommandLineConfig.setCharset",
    "class_name": "com.google.javascript.jscomp.AbstractCommandLineRunner$CommandLineConfig",
    "signature": "com.google.javascript.jscomp.AbstractCommandLineRunner$CommandLineConfig.setCharset(String)",
    "snippet": "    CommandLineConfig setCharset(String charset) {\n      this.charset = charset;\n      return this;\n    }",
    "comment": " Input charset for all files. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "CommandLineConfig.setComputePhaseOrdering",
    "class_name": "com.google.javascript.jscomp.AbstractCommandLineRunner$CommandLineConfig",
    "signature": "com.google.javascript.jscomp.AbstractCommandLineRunner$CommandLineConfig.setComputePhaseOrdering(boolean)",
    "snippet": "    CommandLineConfig setComputePhaseOrdering(boolean computePhaseOrdering) {\n      this.computePhaseOrdering = computePhaseOrdering;\n      return this;\n    }",
    "comment": " Runs the compile job many times, then prints out the best phase ordering from this run ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "CommandLineConfig.setCreateNameMapFiles",
    "class_name": "com.google.javascript.jscomp.AbstractCommandLineRunner$CommandLineConfig",
    "signature": "com.google.javascript.jscomp.AbstractCommandLineRunner$CommandLineConfig.setCreateNameMapFiles(boolean)",
    "snippet": "    CommandLineConfig setCreateNameMapFiles(boolean createNameMapFiles) {\n      this.createNameMapFiles = createNameMapFiles;\n      return this;\n    }",
    "comment": " If true, variable renaming and property renaming map files will be produced as {binary name}_vars_map.out and {binary name}_props_map.out. Note that this flag cannot be used in conjunction with either variable_map_output_file or property_map_output_file ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "CommandLineConfig.setCreateSourceMap",
    "class_name": "com.google.javascript.jscomp.AbstractCommandLineRunner$CommandLineConfig",
    "signature": "com.google.javascript.jscomp.AbstractCommandLineRunner$CommandLineConfig.setCreateSourceMap(String)",
    "snippet": "    CommandLineConfig setCreateSourceMap(String createSourceMap) {\n      this.createSourceMap = createSourceMap;\n      return this;\n    }",
    "comment": " If specified, a source map file mapping the generated source files back to the original source file will be output to the specified path. The %outname% placeholder will expand to the name of the output file that the source map corresponds to. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "CommandLineConfig.setDefine",
    "class_name": "com.google.javascript.jscomp.AbstractCommandLineRunner$CommandLineConfig",
    "signature": "com.google.javascript.jscomp.AbstractCommandLineRunner$CommandLineConfig.setDefine(List)",
    "snippet": "    CommandLineConfig setDefine(List<String> define) {\n      this.define.clear();\n      this.define.addAll(define);\n      return this;\n    }",
    "comment": " Override the value of a variable annotated @define. The format is <name>[=<val>], where <name> is the name of a @define variable and <val> is a boolean, number, or a single-quoted string that contains no single quotes. If [=<val>] is omitted, the variable is marked true ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "CommandLineConfig.setExterns",
    "class_name": "com.google.javascript.jscomp.AbstractCommandLineRunner$CommandLineConfig",
    "signature": "com.google.javascript.jscomp.AbstractCommandLineRunner$CommandLineConfig.setExterns(List)",
    "snippet": "    CommandLineConfig setExterns(List<String> externs) {\n      this.externs.clear();\n      this.externs.addAll(externs);\n      return this;\n    }",
    "comment": " The file containing javascript externs. You may specify multiple. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "CommandLineConfig.setJs",
    "class_name": "com.google.javascript.jscomp.AbstractCommandLineRunner$CommandLineConfig",
    "signature": "com.google.javascript.jscomp.AbstractCommandLineRunner$CommandLineConfig.setJs(List)",
    "snippet": "    CommandLineConfig setJs(List<String> js) {\n      this.js.clear();\n      this.js.addAll(js);\n      return this;\n    }",
    "comment": " The javascript filename. You may specify multiple. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "CommandLineConfig.setJsOutputFile",
    "class_name": "com.google.javascript.jscomp.AbstractCommandLineRunner$CommandLineConfig",
    "signature": "com.google.javascript.jscomp.AbstractCommandLineRunner$CommandLineConfig.setJsOutputFile(String)",
    "snippet": "    CommandLineConfig setJsOutputFile(String jsOutputFile) {\n      this.jsOutputFile = jsOutputFile;\n      return this;\n    }",
    "comment": " Primary output filename. If not specified, output is written to stdout ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "CommandLineConfig.setJscompDevMode",
    "class_name": "com.google.javascript.jscomp.AbstractCommandLineRunner$CommandLineConfig",
    "signature": "com.google.javascript.jscomp.AbstractCommandLineRunner$CommandLineConfig.setJscompDevMode(DevMode)",
    "snippet": "    CommandLineConfig setJscompDevMode(CompilerOptions.DevMode jscompDevMode) {\n      this.jscompDevMode = jscompDevMode;\n      return this;\n    }",
    "comment": "Turns on extra sanity checks */",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "CommandLineConfig.setJscompError",
    "class_name": "com.google.javascript.jscomp.AbstractCommandLineRunner$CommandLineConfig",
    "signature": "com.google.javascript.jscomp.AbstractCommandLineRunner$CommandLineConfig.setJscompError(List)",
    "snippet": "    CommandLineConfig setJscompError(List<String> jscompError) {\n      this.jscompError.clear();\n      this.jscompError.addAll(jscompError);\n      return this;\n    }",
    "comment": " Make the named class of warnings an error. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "CommandLineConfig.setJscompOff",
    "class_name": "com.google.javascript.jscomp.AbstractCommandLineRunner$CommandLineConfig",
    "signature": "com.google.javascript.jscomp.AbstractCommandLineRunner$CommandLineConfig.setJscompOff(List)",
    "snippet": "    CommandLineConfig setJscompOff(List<String> jscompOff) {\n      this.jscompOff.clear();\n      this.jscompOff.addAll(jscompOff);\n      return this;\n    }",
    "comment": " Turn off the named class of warnings. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "CommandLineConfig.setJscompWarning",
    "class_name": "com.google.javascript.jscomp.AbstractCommandLineRunner$CommandLineConfig",
    "signature": "com.google.javascript.jscomp.AbstractCommandLineRunner$CommandLineConfig.setJscompWarning(List)",
    "snippet": "    CommandLineConfig setJscompWarning(List<String> jscompWarning) {\n      this.jscompWarning.clear();\n      this.jscompWarning.addAll(jscompWarning);\n      return this;\n    }",
    "comment": " Make the named class of warnings a normal warning. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "CommandLineConfig.setLoggingLevel",
    "class_name": "com.google.javascript.jscomp.AbstractCommandLineRunner$CommandLineConfig",
    "signature": "com.google.javascript.jscomp.AbstractCommandLineRunner$CommandLineConfig.setLoggingLevel(String)",
    "snippet": "    CommandLineConfig setLoggingLevel(String loggingLevel) {\n      this.loggingLevel = loggingLevel;\n      return this;\n    }",
    "comment": " The logging level (standard java.util.logging.Level values) for Compiler progress. Does not control errors or warnings for the JavaScript code under compilation ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "CommandLineConfig.setModule",
    "class_name": "com.google.javascript.jscomp.AbstractCommandLineRunner$CommandLineConfig",
    "signature": "com.google.javascript.jscomp.AbstractCommandLineRunner$CommandLineConfig.setModule(List)",
    "snippet": "    CommandLineConfig setModule(List<String> module) {\n      this.module.clear();\n      this.module.addAll(module);\n      return this;\n    }",
    "comment": " A javascript module specification. The format is <name>:<num-js-files>[:[<dep>,...][:]]]. Module names must be unique. Each dep is the name of a module that this module depends on. Modules must be listed in dependency order, and js source files must be listed in the corresponding order. Where --module flags occur in relation to --js flags is unimportant ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "CommandLineConfig.setModuleOutputPathPrefix",
    "class_name": "com.google.javascript.jscomp.AbstractCommandLineRunner$CommandLineConfig",
    "signature": "com.google.javascript.jscomp.AbstractCommandLineRunner$CommandLineConfig.setModuleOutputPathPrefix(String)",
    "snippet": "    CommandLineConfig setModuleOutputPathPrefix(String moduleOutputPathPrefix) {\n      this.moduleOutputPathPrefix = moduleOutputPathPrefix;\n      return this;\n    }",
    "comment": " Prefix for filenames of compiled js modules. <module-name>.js will be appended to this prefix. Directories will be created as needed. Use with --module ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "CommandLineConfig.setModuleWrapper",
    "class_name": "com.google.javascript.jscomp.AbstractCommandLineRunner$CommandLineConfig",
    "signature": "com.google.javascript.jscomp.AbstractCommandLineRunner$CommandLineConfig.setModuleWrapper(List)",
    "snippet": "    CommandLineConfig setModuleWrapper(List<String> moduleWrapper) {\n      this.moduleWrapper.clear();\n      this.moduleWrapper.addAll(moduleWrapper);\n      return this;\n    }",
    "comment": " An output wrapper for a javascript module (optional). The format is <name>:<wrapper>. The module name must correspond with a module specified using --module. The wrapper must contain %s as the code placeholder ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "CommandLineConfig.setOutputWrapper",
    "class_name": "com.google.javascript.jscomp.AbstractCommandLineRunner$CommandLineConfig",
    "signature": "com.google.javascript.jscomp.AbstractCommandLineRunner$CommandLineConfig.setOutputWrapper(String)",
    "snippet": "    CommandLineConfig setOutputWrapper(String outputWrapper) {\n      this.outputWrapper = outputWrapper;\n      return this;\n    }",
    "comment": " Interpolate output into this string at the place denoted by the marker token %output%. See --output_wrapper_marker ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "CommandLineConfig.setOutputWrapperMarker",
    "class_name": "com.google.javascript.jscomp.AbstractCommandLineRunner$CommandLineConfig",
    "signature": "com.google.javascript.jscomp.AbstractCommandLineRunner$CommandLineConfig.setOutputWrapperMarker(String)",
    "snippet": "    CommandLineConfig setOutputWrapperMarker(String outputWrapperMarker) {\n      this.outputWrapperMarker = outputWrapperMarker;\n      return this;\n    }",
    "comment": " Use this token as output marker in the value of --output_wrapper ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "CommandLineConfig.setPrintAst",
    "class_name": "com.google.javascript.jscomp.AbstractCommandLineRunner$CommandLineConfig",
    "signature": "com.google.javascript.jscomp.AbstractCommandLineRunner$CommandLineConfig.setPrintAst(boolean)",
    "snippet": "    CommandLineConfig setPrintAst(boolean printAst) {\n      this.printAst = printAst;\n      return this;\n    }",
    "comment": " Prints a dot file describing the internal abstract syntax tree and exits ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "CommandLineConfig.setPrintPassGraph",
    "class_name": "com.google.javascript.jscomp.AbstractCommandLineRunner$CommandLineConfig",
    "signature": "com.google.javascript.jscomp.AbstractCommandLineRunner$CommandLineConfig.setPrintPassGraph(boolean)",
    "snippet": "    CommandLineConfig setPrintPassGraph(boolean printPassGraph) {\n      this.printPassGraph = printPassGraph;\n      return this;\n    }",
    "comment": "Prints a dot file describing the passes that will get run and exits */",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "CommandLineConfig.setPrintTree",
    "class_name": "com.google.javascript.jscomp.AbstractCommandLineRunner$CommandLineConfig",
    "signature": "com.google.javascript.jscomp.AbstractCommandLineRunner$CommandLineConfig.setPrintTree(boolean)",
    "snippet": "    CommandLineConfig setPrintTree(boolean printTree) {\n      this.printTree = printTree;\n      return this;\n    }",
    "comment": "Prints out the parse tree and exits */",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "CommandLineConfig.setPropertyMapInputFile",
    "class_name": "com.google.javascript.jscomp.AbstractCommandLineRunner$CommandLineConfig",
    "signature": "com.google.javascript.jscomp.AbstractCommandLineRunner$CommandLineConfig.setPropertyMapInputFile(String)",
    "snippet": "    CommandLineConfig setPropertyMapInputFile(String propertyMapInputFile) {\n      this.propertyMapInputFile = propertyMapInputFile;\n      return this;\n    }",
    "comment": " File containing the serialized version of the property renaming map produced by a previous compilation ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "CommandLineConfig.setPropertyMapOutputFile",
    "class_name": "com.google.javascript.jscomp.AbstractCommandLineRunner$CommandLineConfig",
    "signature": "com.google.javascript.jscomp.AbstractCommandLineRunner$CommandLineConfig.setPropertyMapOutputFile(String)",
    "snippet": "    CommandLineConfig setPropertyMapOutputFile(String propertyMapOutputFile) {\n      this.propertyMapOutputFile = propertyMapOutputFile;\n      return this;\n    }",
    "comment": " File where the serialized version of the property renaming map produced should be saved ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "CommandLineConfig.setSummaryDetailLevel",
    "class_name": "com.google.javascript.jscomp.AbstractCommandLineRunner$CommandLineConfig",
    "signature": "com.google.javascript.jscomp.AbstractCommandLineRunner$CommandLineConfig.setSummaryDetailLevel(int)",
    "snippet": "    CommandLineConfig setSummaryDetailLevel(int summaryDetailLevel) {\n      this.summaryDetailLevel = summaryDetailLevel;\n      return this;\n    }",
    "comment": " Controls how detailed the compilation summary is. Values: 0 (never print summary), 1 (print summary only if there are errors or warnings), 2 (print summary if type checking is on, see --check_types), 3 (always print summary). The default level is 1 ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "CommandLineConfig.setThirdParty",
    "class_name": "com.google.javascript.jscomp.AbstractCommandLineRunner$CommandLineConfig",
    "signature": "com.google.javascript.jscomp.AbstractCommandLineRunner$CommandLineConfig.setThirdParty(boolean)",
    "snippet": "    CommandLineConfig setThirdParty(boolean thirdParty) {\n      this.thirdParty = thirdParty;\n      return this;\n    }",
    "comment": " Check source validity but do not enforce Closure style rules and conventions ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "CommandLineConfig.setVariableMapInputFile",
    "class_name": "com.google.javascript.jscomp.AbstractCommandLineRunner$CommandLineConfig",
    "signature": "com.google.javascript.jscomp.AbstractCommandLineRunner$CommandLineConfig.setVariableMapInputFile(String)",
    "snippet": "    CommandLineConfig setVariableMapInputFile(String variableMapInputFile) {\n      this.variableMapInputFile = variableMapInputFile;\n      return this;\n    }",
    "comment": " File containing the serialized version of the variable renaming map produced by a previous compilation ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "CommandLineConfig.setVariableMapOutputFile",
    "class_name": "com.google.javascript.jscomp.AbstractCommandLineRunner$CommandLineConfig",
    "signature": "com.google.javascript.jscomp.AbstractCommandLineRunner$CommandLineConfig.setVariableMapOutputFile(String)",
    "snippet": "    CommandLineConfig setVariableMapOutputFile(String variableMapOutputFile) {\n      this.variableMapOutputFile = variableMapOutputFile;\n      return this;\n    }",
    "comment": " File where the serialized version of the variable renaming map produced should be saved ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "AbstractMessageFormatter.AbstractMessageFormatter",
    "class_name": "com.google.javascript.jscomp.AbstractMessageFormatter",
    "signature": "com.google.javascript.jscomp.AbstractMessageFormatter.AbstractMessageFormatter(SourceExcerptProvider)",
    "snippet": "  public AbstractMessageFormatter(SourceExcerptProvider source) {\n    this.source = source;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "AbstractMessageFormatter.setColorize",
    "class_name": "com.google.javascript.jscomp.AbstractMessageFormatter",
    "signature": "com.google.javascript.jscomp.AbstractMessageFormatter.setColorize(boolean)",
    "snippet": "  public void setColorize(boolean colorize) {\n    this.colorize = colorize;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "AnonymousFunctionNamingPolicy.getReservedCharacters",
    "class_name": "com.google.javascript.jscomp.AnonymousFunctionNamingPolicy",
    "signature": "com.google.javascript.jscomp.AnonymousFunctionNamingPolicy.getReservedCharacters()",
    "snippet": "  public char[] getReservedCharacters() {\n    // TODO(user) - for MAPPED, only the first character is reserved which\n    // can be used to further optimize\n    return reservedCharacters;\n  }",
    "comment": " Gets characters that are reserved for use in anonymous function names and can't be used in variable or property names. @return reserved characters or null if no characters are reserved ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "AstChangeProxy.AstChangeProxy",
    "class_name": "com.google.javascript.jscomp.AstChangeProxy",
    "signature": "com.google.javascript.jscomp.AstChangeProxy.AstChangeProxy()",
    "snippet": "  AstChangeProxy() {\n    listeners = Lists.newArrayList();\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "AstChangeProxy.registerListener",
    "class_name": "com.google.javascript.jscomp.AstChangeProxy",
    "signature": "com.google.javascript.jscomp.AstChangeProxy.registerListener(ChangeListener)",
    "snippet": "  final void registerListener(ChangeListener listener) {\n    listeners.add(listener);\n  }",
    "comment": " Registers a change listener. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "BasicErrorManager.generateReport",
    "class_name": "com.google.javascript.jscomp.BasicErrorManager",
    "signature": "com.google.javascript.jscomp.BasicErrorManager.generateReport()",
    "snippet": "  public void generateReport() {\n    for (ErrorWithLevel message : messages) {\n      println(message.level, message.error);\n    }\n    printSummary();\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "BasicErrorManager.getErrorCount",
    "class_name": "com.google.javascript.jscomp.BasicErrorManager",
    "signature": "com.google.javascript.jscomp.BasicErrorManager.getErrorCount()",
    "snippet": "  public int getErrorCount() {\n    return errorCount;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "BasicErrorManager.getErrors",
    "class_name": "com.google.javascript.jscomp.BasicErrorManager",
    "signature": "com.google.javascript.jscomp.BasicErrorManager.getErrors()",
    "snippet": "  public JSError[] getErrors() {\n    return toArray(CheckLevel.ERROR);\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "BasicErrorManager.getWarningCount",
    "class_name": "com.google.javascript.jscomp.BasicErrorManager",
    "signature": "com.google.javascript.jscomp.BasicErrorManager.getWarningCount()",
    "snippet": "  public int getWarningCount() {\n    return warningCount;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "BasicErrorManager.getWarnings",
    "class_name": "com.google.javascript.jscomp.BasicErrorManager",
    "signature": "com.google.javascript.jscomp.BasicErrorManager.getWarnings()",
    "snippet": "  public JSError[] getWarnings() {\n    return toArray(CheckLevel.WARNING);\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "BasicErrorManager.toArray",
    "class_name": "com.google.javascript.jscomp.BasicErrorManager",
    "signature": "com.google.javascript.jscomp.BasicErrorManager.toArray(CheckLevel)",
    "snippet": "  private JSError[] toArray(CheckLevel level) {\n    List<JSError> errors = new ArrayList<JSError>(messages.size());\n    for (ErrorWithLevel p : messages) {\n      if (p.level == level) {\n        errors.add(p.error);\n      }\n    }\n    return errors.toArray(new JSError[errors.size()]);\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "CheckAccidentalSemicolon.CheckAccidentalSemicolon",
    "class_name": "com.google.javascript.jscomp.CheckAccidentalSemicolon",
    "signature": "com.google.javascript.jscomp.CheckAccidentalSemicolon.CheckAccidentalSemicolon(CheckLevel)",
    "snippet": "  CheckAccidentalSemicolon(CheckLevel level) {\n    this.level = level;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "CheckAccidentalSemicolon.visit",
    "class_name": "com.google.javascript.jscomp.CheckAccidentalSemicolon",
    "signature": "com.google.javascript.jscomp.CheckAccidentalSemicolon.visit(NodeTraversal,Node,Node)",
    "snippet": "  public void visit(NodeTraversal t, Node n, Node parent) {\n    Node child;\n    switch (n.getType()) {\n      case Token.IF:\n        child = n.getFirstChild().getNext();  // skip the condition child\n        break;\n\n      case Token.WHILE:\n      case Token.FOR:\n        child = NodeUtil.getLoopCodeBlock(n);\n        break;\n\n      default:\n        return;  // don't check other types\n    }\n\n    // semicolons cause VOID children. Empty blocks are allowed because\n    // that's usually intentional, especially with loops.\n    for (; child != null; child = child.getNext()) {\n      if ((child.getType() == Token.BLOCK) && (!child.hasChildren())) {\n        // Only warn on empty blocks that replaced EMPTY nodes.  BLOCKs with no\n        // children are considered OK.\n        if (child.wasEmptyNode()) {\n          t.getCompiler().report(\n              JSError.make(t, n, level, SUSPICIOUS_SEMICOLON));\n        }\n      }\n    }\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "CheckLevel.isOn",
    "class_name": "com.google.javascript.jscomp.CheckLevel",
    "signature": "com.google.javascript.jscomp.CheckLevel.isOn()",
    "snippet": "  boolean isOn() {\n    return this != OFF;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "CheckSideEffects.CheckSideEffects",
    "class_name": "com.google.javascript.jscomp.CheckSideEffects",
    "signature": "com.google.javascript.jscomp.CheckSideEffects.CheckSideEffects(CheckLevel)",
    "snippet": "  CheckSideEffects(CheckLevel level) {\n    this.level = level;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "CheckSideEffects.visit",
    "class_name": "com.google.javascript.jscomp.CheckSideEffects",
    "signature": "com.google.javascript.jscomp.CheckSideEffects.visit(NodeTraversal,Node,Node)",
    "snippet": "  public void visit(NodeTraversal t, Node n, Node parent) {\n    // VOID nodes appear when there are extra semicolons at the BLOCK level.\n    // I've been unable to think of any cases where this indicates a bug,\n    // and apparently some people like keeping these semicolons around,\n    // so we'll allow it.\n    if (n.getType() == Token.EMPTY ||\n        n.getType() == Token.COMMA) {\n      return;\n    }\n\n    if (parent == null)\n      return;\n\n    int pt = parent.getType();\n    if (pt == Token.COMMA) {\n      Node gramps = parent.getParent();\n      if (gramps.getType() == Token.CALL &&\n          parent == gramps.getFirstChild()) {\n        // Semantically, a direct call to eval is different from an indirect\n        // call to an eval. See Ecma-262 S15.1.2.1. So it's ok for the first\n        // expression to a comma to be a no-op if it's used to indirect\n        // an eval.\n        if (n == parent.getFirstChild() &&\n            parent.getChildCount() == 2 &&\n            n.getNext().getType() == Token.NAME &&\n            \"eval\".equals(n.getNext().getString())) {\n          return;\n        }\n      }\n\n      if (n == parent.getLastChild()) {\n        for (Node an : parent.getAncestors()) {\n          int ancestorType = an.getType();\n          if (ancestorType == Token.COMMA)\n            continue;\n          if (ancestorType != Token.EXPR_RESULT &&\n              ancestorType != Token.BLOCK)\n            return;\n          else\n            break;\n        }\n      }\n    } else if (pt != Token.EXPR_RESULT && pt != Token.BLOCK) {\n      if (pt == Token.FOR && parent.getChildCount() == 4 &&\n          (n == parent.getFirstChild() ||\n           n == parent.getFirstChild().getNext().getNext())) {\n        // Fall through and look for warnings for the 1st and 3rd child\n        // of a for.\n      } else {\n        return;  // it might be ok to not have a side-effect\n      }\n    }\n    if (NodeUtil.isSimpleOperatorType(n.getType()) ||\n        !NodeUtil.mayHaveSideEffects(n)) {\n      if (n.isQualifiedName() && n.getJSDocInfo() != null) {\n        // This no-op statement was there so that JSDoc information could\n        // be attached to the name. This check should not complain about it.\n        return;\n      } else if (NodeUtil.isExpressionNode(n)) {\n        // we already reported the problem when we visited the child.\n        return;\n      }\n\n      String msg = \"This code lacks side-effects. Is there a bug?\";\n      if (n.getType() == Token.STRING) {\n        msg = \"Is there a missing '+' on the previous line?\";\n      }\n\n      t.getCompiler().report(\n          JSError.make(t, n, level, USELESS_CODE_ERROR, msg));\n    }\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "CheckUnreachableCode.CheckUnreachableCode",
    "class_name": "com.google.javascript.jscomp.CheckUnreachableCode",
    "signature": "com.google.javascript.jscomp.CheckUnreachableCode.CheckUnreachableCode(AbstractCompiler,CheckLevel)",
    "snippet": "  CheckUnreachableCode(AbstractCompiler compiler, CheckLevel level) {\n    this.compiler = compiler;\n    this.level = level;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "CheckUnreachableCode.enterScope",
    "class_name": "com.google.javascript.jscomp.CheckUnreachableCode",
    "signature": "com.google.javascript.jscomp.CheckUnreachableCode.enterScope(NodeTraversal)",
    "snippet": "  @Override\n  public void enterScope(NodeTraversal t) {\n    new GraphReachability<Node, ControlFlowGraph.Branch>(\n        t.getControlFlowGraph()).compute(\n            t.getControlFlowGraph().getEntry().getValue());\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "CheckUnreachableCode.exitScope",
    "class_name": "com.google.javascript.jscomp.CheckUnreachableCode",
    "signature": "com.google.javascript.jscomp.CheckUnreachableCode.exitScope(NodeTraversal)",
    "snippet": "  @Override\n  public void exitScope(NodeTraversal t) {\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "CheckUnreachableCode.shouldTraverse",
    "class_name": "com.google.javascript.jscomp.CheckUnreachableCode",
    "signature": "com.google.javascript.jscomp.CheckUnreachableCode.shouldTraverse(NodeTraversal,Node,Node)",
    "snippet": "  @Override\n  public boolean shouldTraverse(NodeTraversal t, Node n, Node parent) {\n    GraphNode<Node, Branch> gNode = t.getControlFlowGraph().getNode(n);\n    if (gNode != null && gNode.getAnnotation() != GraphReachability.REACHABLE) {\n\n      // Only report error when there are some line number informations.\n      // There are synthetic nodes with no line number informations, nodes\n      // introduce by other passes (although not likely since this pass should\n      // be executed early) or some rhino bug.\n      if (n.getLineno() != -1 &&\n          // Allow spurious semi-colons and spurious breaks.\n          n.getType() != Token.EMPTY && n.getType() != Token.BREAK) {\n        compiler.report(JSError.make(t, n, level, UNREACHABLE_CODE));\n        // From now on, we are going to assume the user fixed the error and not\n        // give more warning related to code section reachable from this node.\n        new GraphReachability<Node, ControlFlowGraph.Branch>(\n            t.getControlFlowGraph()).recompute(n);\n\n        // Saves time by not traversing children.\n        return false;\n      }\n    }\n    return true;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "CheckUnreachableCode.visit",
    "class_name": "com.google.javascript.jscomp.CheckUnreachableCode",
    "signature": "com.google.javascript.jscomp.CheckUnreachableCode.visit(NodeTraversal,Node,Node)",
    "snippet": "  @Override\n  public void visit(NodeTraversal t, Node n, Node parent) {\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "ClosureCodingConvention.isOptionalParameter",
    "class_name": "com.google.javascript.jscomp.ClosureCodingConvention",
    "signature": "com.google.javascript.jscomp.ClosureCodingConvention.isOptionalParameter(Node)",
    "snippet": "  @Override\n  public boolean isOptionalParameter(Node parameter) {\n    return false;\n  }",
    "comment": " {@inheritDoc} ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "ClosureCodingConvention.isVarArgsParameter",
    "class_name": "com.google.javascript.jscomp.ClosureCodingConvention",
    "signature": "com.google.javascript.jscomp.ClosureCodingConvention.isVarArgsParameter(Node)",
    "snippet": "  @Override\n  public boolean isVarArgsParameter(Node parameter) {\n    return false;\n  }",
    "comment": " {@inheritDoc} ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "CoalesceVariableNames.CoalesceVariableNames",
    "class_name": "com.google.javascript.jscomp.CoalesceVariableNames",
    "signature": "com.google.javascript.jscomp.CoalesceVariableNames.CoalesceVariableNames(AbstractCompiler,boolean)",
    "snippet": "  CoalesceVariableNames(AbstractCompiler compiler, boolean usePseudoNames) {\n    this.compiler = compiler;\n    colorings = Lists.newLinkedList();\n    this.usePseudoNames = usePseudoNames;\n  }",
    "comment": " @param usePseudoNames For debug purposes, when merging variable foo and bar to foo, rename both variable to foo_bar. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "CoalesceVariableNames.enterScope",
    "class_name": "com.google.javascript.jscomp.CoalesceVariableNames",
    "signature": "com.google.javascript.jscomp.CoalesceVariableNames.enterScope(NodeTraversal)",
    "snippet": "  @Override\n  public void enterScope(NodeTraversal t) {\n    // TODO(user): We CAN do this in the global scope, just need to be\n    // careful when something is exported. Liveness uses bit-vector for live\n    // sets so I don't see compilation time will be a problem for running this\n    // pass in the global scope.\n    Scope scope = t.getScope();\n    if (scope.isGlobal()) {\n      return;\n    }\n    ControlFlowGraph<Node> cfg = t.getControlFlowGraph();\n\n    LiveVariablesAnalysis liveness =\n        new LiveVariablesAnalysis(cfg, scope, compiler);\n    liveness.analyze();\n\n    UndiGraph<Var, Void> interferenceGraph =\n        computeVariableNamesInterferenceGraph(\n            t, cfg, liveness.getEscapedLocals());\n\n    GraphColoring<Var, Void> coloring =\n        new GreedyGraphColoring<Var, Void>(interferenceGraph,\n            coloringTieBreaker);\n\n    coloring.color();\n    colorings.push(coloring);\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "CoalesceVariableNames.exitScope",
    "class_name": "com.google.javascript.jscomp.CoalesceVariableNames",
    "signature": "com.google.javascript.jscomp.CoalesceVariableNames.exitScope(NodeTraversal)",
    "snippet": "  @Override\n  public void exitScope(NodeTraversal t) {\n    if (t.inGlobalScope()) {\n      return;\n    }\n    colorings.pop();\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "CoalesceVariableNames.process",
    "class_name": "com.google.javascript.jscomp.CoalesceVariableNames",
    "signature": "com.google.javascript.jscomp.CoalesceVariableNames.process(Node,Node)",
    "snippet": "  @Override\n  public void process(Node externs, Node root) {\n    NodeTraversal.traverse(compiler, root, this);\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "CoalesceVariableNames.visit",
    "class_name": "com.google.javascript.jscomp.CoalesceVariableNames",
    "signature": "com.google.javascript.jscomp.CoalesceVariableNames.visit(NodeTraversal,Node,Node)",
    "snippet": "  @Override\n  public void visit(NodeTraversal t, Node n, Node parent) {\n    if (colorings.isEmpty() || !NodeUtil.isName(n) ||\n        NodeUtil.isFunction(parent)) {\n      // Don't rename named functions.\n      return;\n    }\n    Var var = t.getScope().getVar(n.getString());\n    GraphNode<Var, ?> vNode = colorings.peek().getGraph().getNode(var);\n    if (vNode == null) {\n      // This is not a local.\n      return;\n    }\n    Var coalescedVar = colorings.peek().getPartitionSuperNode(var);\n    \n    if (!usePseudoNames) {\n      if (vNode.getValue().equals(coalescedVar)) {\n        // The coalesced name is itself, nothing to do.\n        return;\n      }\n\n      // Rename.\n      n.setString(coalescedVar.name);\n      compiler.reportCodeChange();\n\n      if (NodeUtil.isVar(parent)) {\n        removeVarDeclaration(n);\n      }\n    } else {\n      // This code block is slow but since usePseudoName is for debugging,\n      // we should not sacrifice performance for non-debugging compilation to\n      // make this fast.\n      String pseudoName = null;\n      Set<String> allMergedNames = Sets.newTreeSet();\n      for (Iterator<Var> i = t.getScope().getVars(); i.hasNext();) {\n        Var iVar = i.next();\n        \n        // Look for all the variables that can be merged (in the graph by now)\n        // and it is merged with the current coalscedVar.\n        if (colorings.peek().getGraph().getNode(iVar) != null &&\n            coalescedVar.equals(colorings.peek().getPartitionSuperNode(iVar))) {\n          allMergedNames.add(iVar.name);\n        }\n      }\n      \n      // Keep its original name.\n      if (allMergedNames.size() == 1) {\n        return;\n      }\n      \n      pseudoName = Joiner.on(\"_\").join(allMergedNames);\n      \n      while (t.getScope().isDeclared(pseudoName, true)) {\n        pseudoName += \"$\";\n      }\n      \n      n.setString(pseudoName);\n      compiler.reportCodeChange();\n\n      if (!vNode.getValue().equals(coalescedVar) && NodeUtil.isVar(parent)) {\n        removeVarDeclaration(n);\n      }\n    }\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "RecentChange.hasCodeChanged",
    "class_name": "com.google.javascript.jscomp.CodeChangeHandler$RecentChange",
    "signature": "com.google.javascript.jscomp.CodeChangeHandler$RecentChange.hasCodeChanged()",
    "snippet": "    boolean hasCodeChanged() {\n      return hasChanged;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "RecentChange.reportChange",
    "class_name": "com.google.javascript.jscomp.CodeChangeHandler$RecentChange",
    "signature": "com.google.javascript.jscomp.CodeChangeHandler$RecentChange.reportChange()",
    "snippet": "    public void reportChange() {\n      hasChanged = true;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "RecentChange.reset",
    "class_name": "com.google.javascript.jscomp.CodeChangeHandler$RecentChange",
    "signature": "com.google.javascript.jscomp.CodeChangeHandler$RecentChange.reset()",
    "snippet": "    void reset() {\n      hasChanged = false;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "CodeConsumer.add",
    "class_name": "com.google.javascript.jscomp.CodeConsumer",
    "signature": "com.google.javascript.jscomp.CodeConsumer.add(String)",
    "snippet": "  void add(String newcode) {\n    maybeEndStatement();\n\n    if (newcode.length() == 0) {\n      return;\n    }\n\n    char c = newcode.charAt(0);\n    if ((isWordChar(c) || c == '\\\\') &&\n        isWordChar(getLastChar())) {\n      // need space to separate. This is not pretty printing.\n      // For example: \"return foo;\"\n      append(\" \");\n    }\n\n    append(newcode);\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "CodeConsumer.addIdentifier",
    "class_name": "com.google.javascript.jscomp.CodeConsumer",
    "signature": "com.google.javascript.jscomp.CodeConsumer.addIdentifier(String)",
    "snippet": "  void addIdentifier(String identifier) {\n    add(identifier);\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "CodeConsumer.addOp",
    "class_name": "com.google.javascript.jscomp.CodeConsumer",
    "signature": "com.google.javascript.jscomp.CodeConsumer.addOp(String,boolean)",
    "snippet": "  void addOp(String op, boolean binOp) {\n    maybeEndStatement();\n\n    char first = op.charAt(0);\n    char prev = getLastChar();\n\n    if ((first == '+' || first == '-') && prev == first) {\n      // This is not pretty printing. This is to prevent misparsing of\n      // things like \"x + ++y\" or \"x++ + ++y\"\n      append(\" \");\n    } else if (Character.isLetter(first) &&\n               isWordChar(prev)) {\n      // Make sure there is a space after e.g. instanceof , typeof\n      append(\" \");\n    } else if (prev == '-' && first == '>') {\n      // Make sure that we don't emit -->\n      append(\" \");\n    }\n\n    // Allow formating around the operator.\n    appendOp(op, binOp);\n\n    // Line breaking after an operator is always safe. Line breaking before an\n    // operator on the other hand is not. We only line break after a bin op\n    // because it looks strange.\n    if (binOp) {\n      maybeCutLine();\n    }\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "CodeConsumer.appendOp",
    "class_name": "com.google.javascript.jscomp.CodeConsumer",
    "signature": "com.google.javascript.jscomp.CodeConsumer.appendOp(String,boolean)",
    "snippet": "  void appendOp(String op, boolean binOp) {\n    append(op);\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "CodeConsumer.continueProcessing",
    "class_name": "com.google.javascript.jscomp.CodeConsumer",
    "signature": "com.google.javascript.jscomp.CodeConsumer.continueProcessing()",
    "snippet": "  boolean continueProcessing() {\n    return true;\n  }",
    "comment": " Provides a means of interrupting the CodeGenerator. Derived classes should return false to stop further processing. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "CodeConsumer.endLine",
    "class_name": "com.google.javascript.jscomp.CodeConsumer",
    "signature": "com.google.javascript.jscomp.CodeConsumer.endLine()",
    "snippet": "  void endLine() {\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "CodeConsumer.endStatement",
    "class_name": "com.google.javascript.jscomp.CodeConsumer",
    "signature": "com.google.javascript.jscomp.CodeConsumer.endStatement()",
    "snippet": "  void endStatement() {\n    endStatement(false);\n  }",
    "comment": " Indicates the end of a statement and a ';' may need to be added. But we don't add it now, in case we're at the end of a block (in which case we don't have to add the ';'). See maybeEndStatement() ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "CodeConsumer.endStatement",
    "class_name": "com.google.javascript.jscomp.CodeConsumer",
    "signature": "com.google.javascript.jscomp.CodeConsumer.endStatement(boolean)",
    "snippet": "  void endStatement(boolean needSemiColon) {\n    if (needSemiColon) {\n      append(\";\");\n      maybeLineBreak();\n      statementNeedsEnded = false;\n    } else if (statementStarted) {\n      statementNeedsEnded = true;\n    }\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "CodeConsumer.isWordChar",
    "class_name": "com.google.javascript.jscomp.CodeConsumer",
    "signature": "com.google.javascript.jscomp.CodeConsumer.isWordChar(char)",
    "snippet": "  static boolean isWordChar(char ch) {\n    return (ch == '_' ||\n            ch == '$' ||\n            Character.isLetterOrDigit(ch));\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "CodeConsumer.maybeEndStatement",
    "class_name": "com.google.javascript.jscomp.CodeConsumer",
    "signature": "com.google.javascript.jscomp.CodeConsumer.maybeEndStatement()",
    "snippet": "  void maybeEndStatement() {\n    // Add a ';' if we need to.\n    if (statementNeedsEnded) {\n      append(\";\");\n      maybeLineBreak();\n      endLine();\n      statementNeedsEnded = false;\n    }\n    statementStarted = true;\n  }",
    "comment": " This is to be called when we're in a statement. If the prev statement needs to be ended, add a ';'. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "CodeGenerator.CodeGenerator",
    "class_name": "com.google.javascript.jscomp.CodeGenerator",
    "signature": "com.google.javascript.jscomp.CodeGenerator.CodeGenerator(CodeConsumer,Charset,boolean)",
    "snippet": "  CodeGenerator(\n      CodeConsumer consumer, Charset outputCharset, boolean validation) {\n    this.validation = validation;\n    cc = consumer;\n    if (outputCharset == null || outputCharset == Charsets.US_ASCII) {\n      // If we want our default (pretending to be UTF-8, but escaping anything\n      // outside of straight ASCII), then don't use the encoder, but\n      // just special-case the code.  This keeps the normal path through\n      // the code identical to how it's been for years.\n      this.outputCharsetEncoder = null;\n    } else {\n      this.outputCharsetEncoder = outputCharset.newEncoder();\n    }\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "CodeGenerator.add",
    "class_name": "com.google.javascript.jscomp.CodeGenerator",
    "signature": "com.google.javascript.jscomp.CodeGenerator.add(Node)",
    "snippet": "  void add(Node n) {\n    add(n, Context.OTHER);\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "CodeGenerator.add",
    "class_name": "com.google.javascript.jscomp.CodeGenerator",
    "signature": "com.google.javascript.jscomp.CodeGenerator.add(Node,Context)",
    "snippet": "  void add(Node n, Context context) {\n    if (!cc.continueProcessing()) {\n      return;\n    }\n\n    int type = n.getType();\n    String opstr = NodeUtil.opToStr(type);\n    int childCount = n.getChildCount();\n    Node first = n.getFirstChild();\n    Node last = n.getLastChild();\n\n    // Handle all binary operators\n    if (opstr != null && first != last) {\n      Preconditions.checkState(childCount == 2);\n      int p = NodeUtil.precedence(type);\n      addLeftExpr(first, p, context);\n      cc.addOp(opstr, true);\n\n      // For right-hand-side of operations, only pass context if it's\n      // the IN_FOR_INIT_CLAUSE one.\n      Context rhsContext = getContextForNoInOperator(context);\n\n      // Handle associativity.\n      // e.g. if the parse tree is a * (b * c),\n      // we can simply generate a * b * c.\n      if (last.getType() == type &&\n          NodeUtil.isAssociative(type)) {\n        addExpr(last, p, rhsContext);\n      } else if (NodeUtil.isAssignmentOp(n) && NodeUtil.isAssignmentOp(last)) {\n        // Assignments are the only right-associative binary operators\n        addExpr(last, p, rhsContext);\n      } else {\n        addExpr(last, p + 1, rhsContext);\n      }\n      return;\n    }\n\n    cc.startSourceMapping(n);\n\n    switch (type) {\n      case Token.TRY: {\n        Preconditions.checkState(first.getNext().getType() == Token.BLOCK &&\n                first.getNext().getChildCount() <= 1);\n        Preconditions.checkState(childCount >= 2 && childCount <= 3);\n\n        add(\"try\");\n        add(first, Context.PRESERVE_BLOCK);\n\n        // second child contains the catch block, or nothing if there\n        // isn't a catch block\n        Node catchblock = first.getNext().getFirstChild();\n        if (catchblock != null) {\n          add(catchblock);\n        }\n\n        if (childCount == 3) {\n          add(\"finally\");\n          add(last, Context.PRESERVE_BLOCK);\n        }\n        break;\n      }\n\n      case Token.CATCH:\n        Preconditions.checkState(childCount == 3);\n        if (first.getNext().getType() != Token.EMPTY) {\n          throw new Error(\"Catch conditions not suppored because I think\" +\n                          \" that it may be a netscape only feature.\");\n        }\n\n        add(\"catch(\");\n        add(first);\n        add(\")\");\n        add(last, Context.PRESERVE_BLOCK);\n        break;\n\n      case Token.THROW:\n        Preconditions.checkState(childCount == 1);\n        add(\"throw\");\n        add(first);\n\n        // Must have a ';' after a throw statement, otherwise safari can't\n        // parse this.\n        cc.endStatement(true);\n        break;\n\n      case Token.RETURN:\n        add(\"return\");\n        if (childCount == 1) {\n          add(first);\n        } else {\n          Preconditions.checkState(childCount == 0);\n        }\n        cc.endStatement();\n        break;\n\n      case Token.VAR:\n        if (first != null) {\n          add(\"var \");\n          addList(first, false, getContextForNoInOperator(context));\n        }\n        break;\n\n      case Token.NAME:\n        if (first == null || first.getType() == Token.EMPTY) {\n          addIdentifier(n.getString());\n        } else {\n          Preconditions.checkState(childCount == 1);\n          addIdentifier(n.getString());\n          cc.addOp(\"=\", true);\n          if (first.getType() == Token.COMMA) {\n            addExpr(first, NodeUtil.precedence(Token.ASSIGN));\n          } else {\n            // Add expression, consider nearby code at lowest level of\n            // precedence.\n            addExpr(first, 0, getContextForNoInOperator(context));\n          }\n        }\n\n        break;\n\n      case Token.ARRAYLIT:\n        add(\"[\");\n        addList(first, (int[]) n.getProp(Node.SKIP_INDEXES_PROP));\n        add(\"]\");\n        break;\n\n      case Token.LP:\n        add(\"(\");\n        addList(first);\n        add(\")\");\n        break;\n\n      case Token.COMMA:\n        addList(first, false, context);\n        break;\n\n      case Token.NUMBER:\n        Preconditions.checkState(childCount == 0);\n        cc.addNumber(n.getDouble());\n        break;\n\n      case Token.TYPEOF:\n      case Token.VOID:\n      case Token.NOT:\n      case Token.BITNOT:\n      case Token.POS:\n      case Token.NEG: {\n        // All of these unary operators are right-associative\n        Preconditions.checkState(childCount == 1);\n        cc.addOp(NodeUtil.opToStrNoFail(type), false);\n        addExpr(first, NodeUtil.precedence(type));\n        break;\n      }\n\n      case Token.HOOK: {\n        Preconditions.checkState(childCount == 3);\n        int p = NodeUtil.precedence(type);\n        addLeftExpr(first, p + 1, context);\n        cc.addOp(\"?\", true);\n        addExpr(first.getNext(), p);\n        cc.addOp(\":\", true);\n        addExpr(last, p);\n        break;\n      }\n\n      case Token.REGEXP:\n        if (first.getType() != Token.STRING ||\n            last.getType() != Token.STRING) {\n          throw new Error(\"Expected children to be strings\");\n        }\n\n        String regexp = regexpEscape(first.getString(), outputCharsetEncoder);\n\n        // I only use one .add because whitespace matters\n        if (childCount == 2) {\n          add(regexp + last.getString());\n        } else {\n          Preconditions.checkState(childCount == 1);\n          add(regexp);\n        }\n        break;\n\n      case Token.GET_REF:\n        add(first);\n        break;\n\n      case Token.REF_SPECIAL:\n        Preconditions.checkState(childCount == 1);\n        add(first);\n        add(\".\");\n        add((String) n.getProp(Node.NAME_PROP));\n        break;\n\n      case Token.FUNCTION:\n        Preconditions.checkState(childCount == 3);\n        boolean funcNeedsParens = (context == Context.START_OF_EXPR);\n        if (funcNeedsParens) {\n          add(\"(\");\n        }\n\n        add(\"function\");\n        add(first);\n\n        add(first.getNext());\n        add(last, Context.PRESERVE_BLOCK);\n        cc.endFunction(context == Context.STATEMENT);\n\n        if (funcNeedsParens) {\n          add(\")\");\n        }\n        break;\n\n      case Token.SCRIPT:\n      case Token.BLOCK: {\n        boolean stripBlock = n.isSyntheticBlock() ||\n            ((context != Context.PRESERVE_BLOCK) && (n.getChildCount() < 2));\n        if (!stripBlock) {\n          cc.beginBlock();\n        }\n        for (Node c = first; c != null; c = c.getNext()) {\n          add(c, Context.STATEMENT);\n\n          // VAR doesn't include ';' since it gets used in expressions\n          if (c.getType() == Token.VAR) {\n            cc.endStatement();\n          }\n\n          if (c.getType() == Token.FUNCTION) {\n            cc.maybeLineBreak();\n          }\n\n          // Prefer to break lines in between top-level statements\n          // because top level statements are more homogeneous.\n          if (type == Token.SCRIPT) {\n            cc.notePreferredLineBreak();\n          }\n        }\n        if (!stripBlock) {\n          cc.endBlock(context == Context.STATEMENT);\n        }\n        break;\n      }\n\n      case Token.FOR:\n        if (childCount == 4) {\n          add(\"for(\");\n          if (first.getType() == Token.VAR) {\n            add(first, Context.IN_FOR_INIT_CLAUSE);\n          } else {\n            addExpr(first, 0, Context.IN_FOR_INIT_CLAUSE);\n          }\n          add(\";\");\n          add(first.getNext());\n          add(\";\");\n          add(first.getNext().getNext());\n          add(\")\");\n          addNonEmptyExpression(\n              last, getContextForNonEmptyExpression(context), false);\n        } else {\n          Preconditions.checkState(childCount == 3);\n          add(\"for(\");\n          add(first);\n          add(\"in\");\n          add(first.getNext());\n          add(\")\");\n          addNonEmptyExpression(\n              last, getContextForNonEmptyExpression(context), false);\n        }\n        break;\n\n      case Token.DO:\n        Preconditions.checkState(childCount == 2);\n        add(\"do\");\n        addNonEmptyExpression(first, Context.OTHER, false);\n        add(\"while(\");\n        add(last);\n        add(\")\");\n        cc.endStatement();\n        break;\n\n      case Token.WHILE:\n        Preconditions.checkState(childCount == 2);\n        add(\"while(\");\n        add(first);\n        add(\")\");\n        addNonEmptyExpression(\n            last, getContextForNonEmptyExpression(context), false);\n        break;\n\n      case Token.EMPTY:\n        Preconditions.checkState(childCount == 0);\n        break;\n\n      case Token.GETPROP: {\n        Preconditions.checkState(childCount == 2);\n        Preconditions.checkState(last.getType() == Token.STRING);\n        boolean needsParens = (first.getType() == Token.NUMBER);\n        if (needsParens) {\n          add(\"(\");\n        }\n        addLeftExpr(first, NodeUtil.precedence(type), context);\n        if (needsParens) {\n          add(\")\");\n        }\n        add(\".\");\n        addIdentifier(last.getString());\n        break;\n      }\n\n      case Token.GETELEM:\n        Preconditions.checkState(childCount == 2);\n        addLeftExpr(first, NodeUtil.precedence(type), context);\n        add(\"[\");\n        add(first.getNext());\n        add(\"]\");\n        break;\n\n      case Token.WITH:\n        Preconditions.checkState(childCount == 2);\n        add(\"with(\");\n        add(first);\n        add(\")\");\n        addNonEmptyExpression(\n            last, getContextForNonEmptyExpression(context), false);\n        break;\n\n      case Token.INC:\n      case Token.DEC: {\n        Preconditions.checkState(childCount == 1);\n        String o = type == Token.INC ? \"++\" : \"--\";\n        int postProp = n.getIntProp(Node.INCRDECR_PROP, 0);\n        // A non-zero post-prop value indicates a post inc/dec, default of zero\n        // is a pre-inc/dec.\n        if (postProp != 0) {\n          addLeftExpr(first, NodeUtil.precedence(type), context);\n          cc.addOp(o, false);\n        } else {\n          cc.addOp(o, false);\n          add(first);\n        }\n        break;\n      }\n\n      case Token.CALL:\n        // If the left hand side of the call is a direct reference to eval,\n        // then it must have a DIRECT_EVAL annotation. If it does not, then\n        // that means it was originally an indirect call to eval, and that\n        // indirectness must be preserved.\n        if (first.getType() == Token.NAME &&\n            \"eval\".equals(first.getString()) &&\n            !first.getBooleanProp(Node.DIRECT_EVAL)) {\n          add(\"(0,eval)\");\n        } else {\n          addLeftExpr(first, NodeUtil.precedence(type), context);\n        }\n        add(\"(\");\n        addList(first.getNext());\n        add(\")\");\n        break;\n\n      case Token.IF:\n        boolean hasElse = childCount == 3;\n        boolean ambiguousElseClause =\n            context == Context.BEFORE_DANGLING_ELSE && !hasElse;\n        if (ambiguousElseClause) {\n          cc.beginBlock();\n        }\n\n        add(\"if(\");\n        add(first);\n        add(\")\");\n\n        if (hasElse) {\n          addNonEmptyExpression(\n              first.getNext(), Context.BEFORE_DANGLING_ELSE, false);\n          add(\"else\");\n          addNonEmptyExpression(\n              last, getContextForNonEmptyExpression(context), false);\n        } else {\n          addNonEmptyExpression(first.getNext(), Context.OTHER, false);\n          Preconditions.checkState(childCount == 2);\n        }\n\n        if (ambiguousElseClause) {\n          cc.endBlock();\n        }\n        break;\n\n      case Token.NULL:\n      case Token.THIS:\n      case Token.FALSE:\n      case Token.TRUE:\n        Preconditions.checkState(childCount == 0);\n        add(Node.tokenToName(type));\n        break;\n\n      case Token.CONTINUE:\n        Preconditions.checkState(childCount <= 1);\n        add(\"continue\");\n        if (childCount == 1) {\n          add(\" \");\n          add(first);\n        }\n        cc.endStatement();\n        break;\n\n      case Token.DEBUGGER:\n        Preconditions.checkState(childCount == 0);\n        add(\"debugger\");\n        cc.endStatement();\n        break;\n\n      case Token.BREAK:\n        Preconditions.checkState(childCount <= 1);\n        add(\"break\");\n        if (childCount == 1) {\n          add(\" \");\n          add(first);\n        }\n        cc.endStatement();\n        break;\n\n      case Token.EXPR_VOID:\n      case Token.EXPR_RESULT:\n        if (type == Token.EXPR_VOID && validation) {\n          throw new Error(\"Unexpected EXPR_VOID. Should be EXPR_RESULT.\");\n        }\n        Preconditions.checkState(childCount == 1);\n        add(first, Context.START_OF_EXPR);\n        cc.endStatement();\n        break;\n\n      case Token.NEW:\n        add(\"new \");\n        int precedence = NodeUtil.precedence(type);\n\n        // If the first child contains a CALL, then claim higher precedence\n        // to force parens. Otherwise, when parsed, NEW will bind to the\n        // first viable parens\n        if (NodeUtil.containsCall(first)) {\n          precedence = NodeUtil.precedence(first.getType()) + 1;\n        }\n        addExpr(first, precedence);\n\n        // '()' is optional when no arguments are present\n        Node next = first.getNext();\n        if (next != null) {\n          add(\"(\");\n          addList(next);\n          add(\")\");\n        }\n        break;\n\n      case Token.STRING:\n        Preconditions.checkState(childCount == 0);\n        add(jsString(n.getString(), outputCharsetEncoder));\n        break;\n\n      case Token.DELPROP:\n        Preconditions.checkState(childCount == 1);\n        add(\"delete \");\n        add(first);\n        break;\n\n      case Token.OBJECTLIT: {\n        Preconditions.checkState(childCount % 2 == 0);\n        boolean needsParens = (context == Context.START_OF_EXPR);\n        if (needsParens) {\n          add(\"(\");\n        }\n        add(\"{\");\n        for (Node c = first; c != null; c = c.getNext().getNext()) {\n          if (c != first) {\n            cc.listSeparator();\n          }\n\n          // Object literal property names don't have to be quoted if they are\n          // not JavaScript keywords\n          if (c.getType() == Token.STRING &&\n              !TokenStream.isKeyword(c.getString()) &&\n              TokenStream.isJSIdentifier(c.getString()) &&\n              // do not encode literally any non-literal characters that were\n              // unicode escaped.\n              NodeUtil.isLatin(c.getString())) {\n            add(c.getString());\n          } else {\n            addExpr(c, 1);\n          }\n          add(\":\");\n          addExpr(c.getNext(), 1);\n        }\n        add(\"}\");\n        if (needsParens) {\n          add(\")\");\n        }\n        break;\n      }\n\n      case Token.SWITCH:\n        add(\"switch(\");\n        add(first);\n        add(\")\");\n        cc.beginBlock();\n        addAllSiblings(first.getNext());\n        cc.endBlock(context == Context.STATEMENT);\n        break;\n\n      case Token.CASE:\n        Preconditions.checkState(childCount == 2);\n        add(\"case \");\n        add(first);\n        addCaseBody(last);\n        break;\n\n      case Token.DEFAULT:\n        Preconditions.checkState(childCount == 1);\n        add(\"default\");\n        addCaseBody(first);\n        break;\n\n      case Token.LABEL:\n        Preconditions.checkState(childCount == 2);\n        add(first);\n        add(\":\");\n        addNonEmptyExpression(\n            last, getContextForNonEmptyExpression(context), true);\n        break;\n\n      // This node is auto generated in anonymous functions and should just get\n      // ignored for our purposes.\n      case Token.SETNAME:\n        break;\n\n      default:\n        throw new Error(\"Unknown type \" + type + \"\\n\" + n.toStringTree());\n    }\n\n    cc.endSourceMapping(n);\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "CodeGenerator.add",
    "class_name": "com.google.javascript.jscomp.CodeGenerator",
    "signature": "com.google.javascript.jscomp.CodeGenerator.add(String)",
    "snippet": "  void add(String str) {\n    cc.add(str);\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "CodeGenerator.addExpr",
    "class_name": "com.google.javascript.jscomp.CodeGenerator",
    "signature": "com.google.javascript.jscomp.CodeGenerator.addExpr(Node,int,Context)",
    "snippet": "  private void addExpr(Node n, int minPrecedence, Context context) {\n    if ((NodeUtil.precedence(n.getType()) < minPrecedence) ||\n        ((context == Context.IN_FOR_INIT_CLAUSE) &&\n        (n.getType() == Token.IN))){\n      add(\"(\");\n      add(n, clearContextForNoInOperator(context));\n      add(\")\");\n    } else {\n      add(n, context);\n    }\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "CodeGenerator.addIdentifier",
    "class_name": "com.google.javascript.jscomp.CodeGenerator",
    "signature": "com.google.javascript.jscomp.CodeGenerator.addIdentifier(String)",
    "snippet": "  private void addIdentifier(String identifier) {\n    cc.addIdentifier(identifierEscape(identifier));\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "CodeGenerator.addLeftExpr",
    "class_name": "com.google.javascript.jscomp.CodeGenerator",
    "signature": "com.google.javascript.jscomp.CodeGenerator.addLeftExpr(Node,int,Context)",
    "snippet": "  void addLeftExpr(Node n, int minPrecedence, Context context) {\n    addExpr(n, minPrecedence, context);\n  }",
    "comment": " Adds a node at the left-hand side of an expression. Unlike {@link #addExpr(Node,int)}, this preserves information about the context.  The left side of an expression is special because in the JavaScript grammar, certain tokens may be parsed differently when they are at the beginning of a statement. For example, \"{}\" is parsed as a block, but \"{'x': 'y'}\" is parsed as an object literal. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "CodeGenerator.addList",
    "class_name": "com.google.javascript.jscomp.CodeGenerator",
    "signature": "com.google.javascript.jscomp.CodeGenerator.addList(Node)",
    "snippet": "  void addList(Node firstInList) {\n    addList(firstInList, true, Context.OTHER);\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "CodeGenerator.addList",
    "class_name": "com.google.javascript.jscomp.CodeGenerator",
    "signature": "com.google.javascript.jscomp.CodeGenerator.addList(Node,boolean,Context)",
    "snippet": "  void addList(Node firstInList, boolean isArrayOrFunctionArgument,\n               Context lhsContext) {\n    for (Node n = firstInList; n != null; n = n.getNext()) {\n      boolean isFirst = n == firstInList;\n      if (isFirst) {\n        addLeftExpr(n, isArrayOrFunctionArgument ? 1 : 0, lhsContext);\n      } else {\n        cc.listSeparator();\n        addExpr(n, isArrayOrFunctionArgument ? 1 : 0);\n      }\n    }\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "CodeGenerator.getContextForNoInOperator",
    "class_name": "com.google.javascript.jscomp.CodeGenerator",
    "signature": "com.google.javascript.jscomp.CodeGenerator.getContextForNoInOperator(Context)",
    "snippet": "  private  Context getContextForNoInOperator(Context context) {\n    return (context == Context.IN_FOR_INIT_CLAUSE\n        ? Context.IN_FOR_INIT_CLAUSE : Context.OTHER);\n  }",
    "comment": " If we're in a IN_FOR_INIT_CLAUSE, we can't permit in operators in the expression.  Pass on the IN_FOR_INIT_CLAUSE flag through subexpressions. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "CodeGenerator.identifierEscape",
    "class_name": "com.google.javascript.jscomp.CodeGenerator",
    "signature": "com.google.javascript.jscomp.CodeGenerator.identifierEscape(String)",
    "snippet": "  static String identifierEscape(String s) {\n    // First check if escaping is needed at all -- in most cases it isn't.\n    if (NodeUtil.isLatin(s)) {\n      return s;\n    }\n\n    // Now going through the string to escape non-latin characters if needed.\n    StringBuilder sb = new StringBuilder();\n    for (int i = 0; i < s.length(); i++) {\n      char c = s.charAt(i);\n      // Identifiers should always go to Latin1/ ASCII characters because\n      // different browser's rules for valid identifier characters are\n      // crazy.\n      if (c > 0x1F && c < 0x7F) {\n        sb.append(c);\n      } else {\n        appendHexJavaScriptRepresentation(sb, c);\n      }\n    }\n    return sb.toString();\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "CodeGenerator.jsString",
    "class_name": "com.google.javascript.jscomp.CodeGenerator",
    "signature": "com.google.javascript.jscomp.CodeGenerator.jsString(String,CharsetEncoder)",
    "snippet": "  static String jsString(String s, CharsetEncoder outputCharsetEncoder) {\n    int singleq = 0, doubleq = 0;\n\n    // could count the quotes and pick the optimal quote character\n    for (int i = 0; i < s.length(); i++) {\n      switch (s.charAt(i)) {\n        case '\"': doubleq++; break;\n        case '\\'': singleq++; break;\n      }\n    }\n\n    String doublequote, singlequote;\n    char quote;\n    if (singleq < doubleq) {\n      // more double quotes so escape the single quotes\n      quote = '\\'';\n      doublequote = \"\\\"\";\n      singlequote = \"\\\\\\'\";\n    } else {\n      // more single quotes so escape the doubles\n      quote = '\\\"';\n      doublequote = \"\\\\\\\"\";\n      singlequote = \"\\'\";\n    }\n\n    return strEscape(s, quote, doublequote, singlequote, \"\\\\\\\\\",\n        outputCharsetEncoder);\n  }",
    "comment": "Outputs a js string, using the optimal (single/double) quote character */",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "CodeGenerator.strEscape",
    "class_name": "com.google.javascript.jscomp.CodeGenerator",
    "signature": "com.google.javascript.jscomp.CodeGenerator.strEscape(String,char,String,String,String,CharsetEncoder)",
    "snippet": "  static String strEscape(String s, char quote,\n                          String doublequoteEscape,\n                          String singlequoteEscape,\n                          String backslashEscape,\n                          CharsetEncoder outputCharsetEncoder) {\n    StringBuilder sb = new StringBuilder();\n    sb.append(quote);\n    for (int i = 0; i < s.length(); i++) {\n      char c = s.charAt(i);\n      switch (c) {\n        case '\\n': sb.append(\"\\\\n\"); break;\n        case '\\r': sb.append(\"\\\\r\"); break;\n        case '\\t': sb.append(\"\\\\t\"); break;\n        case '\\\\': sb.append(backslashEscape); break;\n        case '\\\"': sb.append(doublequoteEscape); break;\n        case '\\'': sb.append(singlequoteEscape); break;\n        case '>':                       // Break --> into --\\> or ]]> into ]]\\>\n          if (i >= 2 &&\n              ((s.charAt(i - 1) == '-' && s.charAt(i - 2) == '-') ||\n               (s.charAt(i - 1) == ']' && s.charAt(i - 2) == ']'))) {\n            sb.append(\"\\\\>\");\n          } else {\n            sb.append(c);\n          }\n          break;\n        case '<':                       // Break </script into <\\/script\n          final String END_SCRIPT = \"/script\";\n          if (s.regionMatches(true, i + 1, END_SCRIPT, 0,\n              END_SCRIPT.length())) {\n            sb.append(\"<\\\\\");\n          } else {\n            sb.append(c);\n          }\n          break;\n        default:\n          // If we're given an outputCharsetEncoder, then check if the\n          //  character can be represented in this character set.\n          if (outputCharsetEncoder != null) {\n            if (outputCharsetEncoder.canEncode(c)) {\n              sb.append(c);\n            } else {\n              // Unicode-escape the character.\n              appendHexJavaScriptRepresentation(sb, c);\n            }\n          } else {\n            // No charsetEncoder provided - pass straight latin characters\n            // through, and escape the rest.  Doing the explicit character\n            // check is measurably faster than using the CharsetEncoder.\n            if (c > 0x1f && c <= 0x7f) {\n              sb.append(c);\n            } else {\n              // Other characters can be misinterpreted by some js parsers,\n              // or perhaps mangled by proxies along the way,\n              // so we play it safe and unicode escape them.\n              appendHexJavaScriptRepresentation(sb, c);\n            }\n          }\n      }\n    }\n    sb.append(quote);\n    return sb.toString();\n  }",
    "comment": "Helper to escape javascript string as well as regular expression */",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "CodePrinter.toSource",
    "class_name": "com.google.javascript.jscomp.CodePrinter",
    "signature": "com.google.javascript.jscomp.CodePrinter.toSource(Node,Format,boolean,int,SourceMap,Charset,boolean)",
    "snippet": "  private static String toSource(Node root, Format outputFormat,\n                                 boolean lineBreak,  int lineLengthThreshold,\n                                 SourceMap sourceMap,\n                                 Charset outputCharset,\n                                 boolean validation) {\n    boolean createSourceMap = (sourceMap != null);\n    CodeConsumer cp =\n        outputFormat == Format.COMPACT\n        ? new CompactCodePrinter(\n            lineBreak, lineLengthThreshold, createSourceMap)\n        : new PrettyCodePrinter(lineLengthThreshold, createSourceMap);\n    CodeGenerator cg =\n        outputFormat == Format.TYPED\n        ? new TypedCodeGenerator(cp, outputCharset)\n        : new CodeGenerator(cp, outputCharset, validation);\n    cg.add(root);\n\n    String code = ((HasGetCode) cp).getCode();\n\n    if (createSourceMap) {\n      cp.generateSourceMap(sourceMap);\n    }\n\n    return code;\n  }",
    "comment": " Converts a tree to js code ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "Builder.build",
    "class_name": "com.google.javascript.jscomp.CodePrinter$Builder",
    "signature": "com.google.javascript.jscomp.CodePrinter$Builder.build()",
    "snippet": "    String build() {\n      if (root == null) {\n        throw new IllegalStateException(\n            \"Cannot build without root node being specified\");\n      }\n\n      Format outputFormat = outputTypes\n          ? Format.TYPED\n          : prettyPrint\n              ? Format.PRETTY\n              : Format.COMPACT;\n\n      return toSource(root, outputFormat, lineBreak, lineLengthThreshold,\n          sourceMap, outputCharset, validation);\n    }",
    "comment": " Generates the source code and returns it. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "Builder.setLineBreak",
    "class_name": "com.google.javascript.jscomp.CodePrinter$Builder",
    "signature": "com.google.javascript.jscomp.CodePrinter$Builder.setLineBreak(boolean)",
    "snippet": "    Builder setLineBreak(boolean lineBreak) {\n      this.lineBreak = lineBreak;\n      return this;\n    }",
    "comment": " Sets whether line breaking should be done automatically. @param lineBreak If true, line breaking is done automatically. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "Builder.setOutputCharset",
    "class_name": "com.google.javascript.jscomp.CodePrinter$Builder",
    "signature": "com.google.javascript.jscomp.CodePrinter$Builder.setOutputCharset(Charset)",
    "snippet": "    Builder setOutputCharset(Charset outCharset) {\n      this.outputCharset = outCharset;\n      return this;\n    }",
    "comment": " Set the charset to use when determining what characters need to be escaped in the output. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "Builder.setPrettyPrint",
    "class_name": "com.google.javascript.jscomp.CodePrinter$Builder",
    "signature": "com.google.javascript.jscomp.CodePrinter$Builder.setPrettyPrint(boolean)",
    "snippet": "    Builder setPrettyPrint(boolean prettyPrint) {\n      this.prettyPrint = prettyPrint;\n      return this;\n    }",
    "comment": " Sets whether pretty printing should be used. @param prettyPrint If true, pretty printing will be used. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "Builder.setSourceMap",
    "class_name": "com.google.javascript.jscomp.CodePrinter$Builder",
    "signature": "com.google.javascript.jscomp.CodePrinter$Builder.setSourceMap(SourceMap)",
    "snippet": "    Builder setSourceMap(SourceMap sourceMap) {\n      this.sourceMap = sourceMap;\n      return this;\n    }",
    "comment": " Sets the source map to which to write the metadata about the generated source code.  @param sourceMap The source map. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "CompactCodePrinter.append",
    "class_name": "com.google.javascript.jscomp.CodePrinter$CompactCodePrinter",
    "signature": "com.google.javascript.jscomp.CodePrinter$CompactCodePrinter.append(String)",
    "snippet": "    @Override\n    void append(String str) {\n      code.append(str);\n      lineLength += str.length();\n    }",
    "comment": " Appends a string to the code, keeping track of the current line length. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "CompactCodePrinter.getCode",
    "class_name": "com.google.javascript.jscomp.CodePrinter$CompactCodePrinter",
    "signature": "com.google.javascript.jscomp.CodePrinter$CompactCodePrinter.getCode()",
    "snippet": "    public String getCode() {\n      return code.toString();\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "CompactCodePrinter.getLastChar",
    "class_name": "com.google.javascript.jscomp.CodePrinter$CompactCodePrinter",
    "signature": "com.google.javascript.jscomp.CodePrinter$CompactCodePrinter.getLastChar()",
    "snippet": "    @Override\n    char getLastChar() {\n      return (code.length() > 0) ? code.charAt(code.length() - 1) : '\\0';\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "CompactCodePrinter.maybeCutLine",
    "class_name": "com.google.javascript.jscomp.CodePrinter$CompactCodePrinter",
    "signature": "com.google.javascript.jscomp.CodePrinter$CompactCodePrinter.maybeCutLine()",
    "snippet": "    @Override\n    void maybeCutLine() {\n      if (lineLength > lineLengthThreshold) {\n        // Use the preferred position provided it will break the line.\n        if (preferredBreakPosition > lineStartPosition &&\n            preferredBreakPosition < lineStartPosition + lineLength) {\n          int position = preferredBreakPosition;\n          code.insert(position, '\\n');\n          reportLineCut(lineIndex, position - lineStartPosition);\n          lineIndex++;\n          lineLength -= (position - lineStartPosition);\n          lineStartPosition = position + 1;\n        } else {\n          startNewLine();\n        }\n      }\n    }",
    "comment": " This may start a new line if the current line is longer than the line length threshold. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "CompactCodePrinter.maybeLineBreak",
    "class_name": "com.google.javascript.jscomp.CodePrinter$CompactCodePrinter",
    "signature": "com.google.javascript.jscomp.CodePrinter$CompactCodePrinter.maybeLineBreak()",
    "snippet": "    @Override\n    void maybeLineBreak() {\n      if (lineBreak) {\n        if (sawFunction) {\n          startNewLine();\n          sawFunction = false;\n        }\n      }\n\n      // Since we are at a legal line break, can we upgrade the\n      // preferred break position?  We prefer to break after a\n      // semicolon rather than before it.\n      int len = code.length();\n      if (preferredBreakPosition == len - 1) {\n        char ch = code.charAt(len - 1);\n        if (ch == ';') {\n          preferredBreakPosition = len;\n        }\n      }\n      maybeCutLine();\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "CompactCodePrinter.notePreferredLineBreak",
    "class_name": "com.google.javascript.jscomp.CodePrinter$CompactCodePrinter",
    "signature": "com.google.javascript.jscomp.CodePrinter$CompactCodePrinter.notePreferredLineBreak()",
    "snippet": "    @Override\n    void notePreferredLineBreak() {\n      preferredBreakPosition = code.length();\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "MappedCodePrinter.endSourceMapping",
    "class_name": "com.google.javascript.jscomp.CodePrinter$MappedCodePrinter",
    "signature": "com.google.javascript.jscomp.CodePrinter$MappedCodePrinter.endSourceMapping(Node)",
    "snippet": "    @Override\n    void endSourceMapping(Node node) {\n      if (createSrcMap\n          && node.getProp(Node.SOURCEFILE_PROP) != null\n          && node.getLineno() > 0) {\n        int line = getCurrentLineIndex();\n        int index = getCurrentCharIndex();\n\n        // If the index is -1, we are not performing any mapping.\n        if (index >= 0) {\n          Preconditions.checkState(\n              !mappings.empty(), \"Mismatch in start and end of mapping\");\n\n          Mapping mapping = mappings.pop();\n          mapping.end = new Position(line, index);\n        }\n      }\n    }",
    "comment": " Finishes the source mapping for the given node at the current position. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "MappedCodePrinter.startSourceMapping",
    "class_name": "com.google.javascript.jscomp.CodePrinter$MappedCodePrinter",
    "signature": "com.google.javascript.jscomp.CodePrinter$MappedCodePrinter.startSourceMapping(Node)",
    "snippet": "    @Override\n    void startSourceMapping(Node node) {\n      if (createSrcMap\n          && node.getProp(Node.SOURCEFILE_PROP) != null\n          && node.getLineno() > 0) {\n        int line = getCurrentLineIndex();\n        int index = getCurrentCharIndex();\n\n        // If the index is -1, we are not performing any mapping.\n        if (index >= 0) {\n          Mapping mapping = new Mapping();\n          mapping.node = node;\n          mapping.start = new Position(line, index);\n          mappings.push(mapping);\n          allMappings.add(mapping);\n        }\n      }\n    }",
    "comment": " Starts the source mapping for the given node at the current position. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "CollapseVariableDeclarations.CollapseVariableDeclarations",
    "class_name": "com.google.javascript.jscomp.CollapseVariableDeclarations",
    "signature": "com.google.javascript.jscomp.CollapseVariableDeclarations.CollapseVariableDeclarations(AbstractCompiler)",
    "snippet": "  CollapseVariableDeclarations(AbstractCompiler compiler) {\n    this.compiler = compiler;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "CollapseVariableDeclarations.process",
    "class_name": "com.google.javascript.jscomp.CollapseVariableDeclarations",
    "signature": "com.google.javascript.jscomp.CollapseVariableDeclarations.process(Node,Node)",
    "snippet": "  public void process(Node externs, Node root) {\n    collapses.clear();\n    nodesToCollapse.clear();\n\n    NodeTraversal.traverse(compiler, root,\n        new CombinedCompilerPass(compiler,\n            new ExploitAssigns(), new GatherCollapses()));\n    if (!collapses.isEmpty()) {\n      applyCollapses();\n      compiler.reportCodeChange();\n    }\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "ExploitAssigns.collapseAssign",
    "class_name": "com.google.javascript.jscomp.CollapseVariableDeclarations$ExploitAssigns",
    "signature": "com.google.javascript.jscomp.CollapseVariableDeclarations$ExploitAssigns.collapseAssign(NodeTraversal,Node,Node,Node)",
    "snippet": "    private void collapseAssign(NodeTraversal t, Node assign, Node expr,\n        Node exprParent) {\n      Node leftValue = assign.getFirstChild();\n      Node rightValue = leftValue.getNext();\n      if (isCollapsibleValue(leftValue, true) &&\n          collapseAssignEqualTo(expr, exprParent, leftValue)) {\n        t.getCompiler().reportCodeChange();\n      } else if (isCollapsibleValue(rightValue, false) &&\n          collapseAssignEqualTo(expr, exprParent, rightValue)) {\n        t.getCompiler().reportCodeChange();\n      } else if (rightValue.getType() == Token.ASSIGN) {\n        // Recursively deal with nested assigns.\n        collapseAssign(t, rightValue, expr, exprParent);\n      }\n    }",
    "comment": " Try to collapse the given assign into subsequent expressions. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "ExploitAssigns.isCollapsibleValue",
    "class_name": "com.google.javascript.jscomp.CollapseVariableDeclarations$ExploitAssigns",
    "signature": "com.google.javascript.jscomp.CollapseVariableDeclarations$ExploitAssigns.isCollapsibleValue(Node,boolean)",
    "snippet": "    private boolean isCollapsibleValue(Node value, boolean isLValue) {\n      switch (value.getType()) {\n        case Token.GETPROP:\n          // Do not collapse GETPROPs on arbitrary objects, because\n          // they may be implemented  setter functions, and oftentimes\n          // setter functions fail on native objects. This is ok for \"THIS\"\n          // objects, because we assume that they are non-native.\n          return !isLValue || value.getFirstChild().getType() == Token.THIS;\n\n        case Token.NAME:\n        case Token.NUMBER:\n        case Token.TRUE:\n        case Token.FALSE:\n        case Token.NULL:\n        case Token.STRING:\n          return true;\n      }\n\n      return false;\n    }",
    "comment": " Determines whether we know enough about the given value to be able to collapse it into subsequent expressions.  For example, we can collapse booleans and variable names: <code> x = 3; y = x; // y = x = 3; a = true; b = true; // b = a = true; <code> But we won't try to collapse complex expressions.  @param value The value node. @param isLValue Whether it's on the left-hand side of an expr. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "ExploitAssigns.visit",
    "class_name": "com.google.javascript.jscomp.CollapseVariableDeclarations$ExploitAssigns",
    "signature": "com.google.javascript.jscomp.CollapseVariableDeclarations$ExploitAssigns.visit(NodeTraversal,Node,Node)",
    "snippet": "    public void visit(NodeTraversal t, Node expr, Node exprParent) {\n      if (!NodeUtil.isExprAssign(expr)) {\n        return;\n      }\n\n      collapseAssign(t, expr.getFirstChild(), expr, exprParent);\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "GatherCollapses.visit",
    "class_name": "com.google.javascript.jscomp.CollapseVariableDeclarations$GatherCollapses",
    "signature": "com.google.javascript.jscomp.CollapseVariableDeclarations$GatherCollapses.visit(NodeTraversal,Node,Node)",
    "snippet": "    public void visit(NodeTraversal t, Node n, Node parent) {\n      // Only care about var nodes\n      if (n.getType() != Token.VAR) return;\n\n      // If we've already looked at this node, skip it\n      if (nodesToCollapse.contains(n)) return;\n\n      // Adjacent VAR children of an IF node are the if and else parts and can't\n      // be collapsed\n      if (parent.getType() == Token.IF) return;\n\n      Node varNode = n;\n\n      // Find variable declarations that follow this one (if any)\n      n = n.getNext();\n\n      boolean hasNodesToCollapse = false;\n      while (n != null && n.getType() == Token.VAR) {\n        nodesToCollapse.add(n);\n        hasNodesToCollapse = true;\n\n        n = n.getNext();\n      }\n\n      if (hasNodesToCollapse) {\n        nodesToCollapse.add(varNode);\n        collapses.add(new Collapse(varNode, parent));\n      }\n\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "CombinedCompilerPass.CombinedCompilerPass",
    "class_name": "com.google.javascript.jscomp.CombinedCompilerPass",
    "signature": "com.google.javascript.jscomp.CombinedCompilerPass.CombinedCompilerPass(AbstractCompiler,Callback[])",
    "snippet": "  CombinedCompilerPass(\n      AbstractCompiler compiler, Callback... callbacks) {\n    this.compiler = compiler;\n    this.callbacks = new CallbackWrapper[callbacks.length];\n    for (int i = 0; i < callbacks.length; i++) {\n      this.callbacks[i] = new CallbackWrapper(callbacks[i]);\n    }\n  }",
    "comment": " Creates a combined compiler pass. @param compiler the compiler ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "CombinedCompilerPass.enterScope",
    "class_name": "com.google.javascript.jscomp.CombinedCompilerPass",
    "signature": "com.google.javascript.jscomp.CombinedCompilerPass.enterScope(NodeTraversal)",
    "snippet": "  @Override\n  public void enterScope(NodeTraversal t) {\n    for (CallbackWrapper callback : callbacks) {\n      callback.enterScopeIfActive(t);\n    }\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "CombinedCompilerPass.exitScope",
    "class_name": "com.google.javascript.jscomp.CombinedCompilerPass",
    "signature": "com.google.javascript.jscomp.CombinedCompilerPass.exitScope(NodeTraversal)",
    "snippet": "  @Override\n  public void exitScope(NodeTraversal t) {\n    for (CallbackWrapper callback : callbacks) {\n      callback.exitScopeIfActive(t);\n    }\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "CombinedCompilerPass.process",
    "class_name": "com.google.javascript.jscomp.CombinedCompilerPass",
    "signature": "com.google.javascript.jscomp.CombinedCompilerPass.process(Node,Node)",
    "snippet": "  @Override\n  public final void process(Node externs, Node root) {\n    NodeTraversal.traverse(compiler, root, this);\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "CombinedCompilerPass.shouldTraverse",
    "class_name": "com.google.javascript.jscomp.CombinedCompilerPass",
    "signature": "com.google.javascript.jscomp.CombinedCompilerPass.shouldTraverse(NodeTraversal,Node,Node)",
    "snippet": "  @Override\n  public boolean shouldTraverse(NodeTraversal t, Node n, Node parent) {\n    for (CallbackWrapper callback : callbacks) {\n      callback.shouldTraverseIfActive(t, n, parent);\n    }\n    // Note that this method could return false if all callbacks are inactive.\n    // This apparent optimization would make this method more expensive\n    // in the typical case where not all nodes are inactive. It is\n    // very unlikely that many all callbacks would be inactive at the same\n    // time (indeed, there are several checking passes that never return false).\n    return true;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "CombinedCompilerPass.visit",
    "class_name": "com.google.javascript.jscomp.CombinedCompilerPass",
    "signature": "com.google.javascript.jscomp.CombinedCompilerPass.visit(NodeTraversal,Node,Node)",
    "snippet": "  @Override\n  public void visit(NodeTraversal t, Node n, Node parent) {\n    for (CallbackWrapper callback : callbacks) {\n      callback.visitOrMaybeActivate(t, n, parent);\n    }\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "CallbackWrapper.enterScopeIfActive",
    "class_name": "com.google.javascript.jscomp.CombinedCompilerPass$CallbackWrapper",
    "signature": "com.google.javascript.jscomp.CombinedCompilerPass$CallbackWrapper.enterScopeIfActive(NodeTraversal)",
    "snippet": "    void enterScopeIfActive(NodeTraversal t) {\n      if (isActive() && scopedCallback != null) {\n        scopedCallback.enterScope(t);\n      }\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "CallbackWrapper.exitScopeIfActive",
    "class_name": "com.google.javascript.jscomp.CombinedCompilerPass$CallbackWrapper",
    "signature": "com.google.javascript.jscomp.CombinedCompilerPass$CallbackWrapper.exitScopeIfActive(NodeTraversal)",
    "snippet": "    void exitScopeIfActive(NodeTraversal t) {\n      if (isActive() && scopedCallback != null) {\n        scopedCallback.exitScope(t);\n      }\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "CallbackWrapper.isActive",
    "class_name": "com.google.javascript.jscomp.CombinedCompilerPass$CallbackWrapper",
    "signature": "com.google.javascript.jscomp.CombinedCompilerPass$CallbackWrapper.isActive()",
    "snippet": "    boolean isActive() {\n      return waiting == null;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "CallbackWrapper.shouldTraverseIfActive",
    "class_name": "com.google.javascript.jscomp.CombinedCompilerPass$CallbackWrapper",
    "signature": "com.google.javascript.jscomp.CombinedCompilerPass$CallbackWrapper.shouldTraverseIfActive(NodeTraversal,Node,Node)",
    "snippet": "    void shouldTraverseIfActive(NodeTraversal t, Node n, Node parent) {\n      if (isActive() && !callback.shouldTraverse(t, n, parent)) {\n        waiting = n;\n      }\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "CallbackWrapper.visitOrMaybeActivate",
    "class_name": "com.google.javascript.jscomp.CombinedCompilerPass$CallbackWrapper",
    "signature": "com.google.javascript.jscomp.CombinedCompilerPass$CallbackWrapper.visitOrMaybeActivate(NodeTraversal,Node,Node)",
    "snippet": "    void visitOrMaybeActivate(NodeTraversal t, Node n, Node parent) {\n      if (isActive()) {\n        callback.visit(t, n, parent);\n      } else if (waiting == n) {\n        waiting = null;\n      }\n    }",
    "comment": " Visits the node unless the wrapped callback is inactive. Activates the callback if appropriate.  ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "CommandLineRunner.CommandLineRunner",
    "class_name": "com.google.javascript.jscomp.CommandLineRunner",
    "signature": "com.google.javascript.jscomp.CommandLineRunner.CommandLineRunner(String[])",
    "snippet": "  protected CommandLineRunner(String[] args)\n      throws CmdLineException {\n    super();\n    initConfigFromFlags(args, System.err);\n  }",
    "comment": " Create a new command-line runner. You should only need to call the constructor if you're extending this class. Otherwise, the main method should instantiate it. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "CommandLineRunner.createCompiler",
    "class_name": "com.google.javascript.jscomp.CommandLineRunner",
    "signature": "com.google.javascript.jscomp.CommandLineRunner.createCompiler()",
    "snippet": "  @Override\n  protected Compiler createCompiler() {\n    return new Compiler(getErrorPrintStream());\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "CommandLineRunner.createOptions",
    "class_name": "com.google.javascript.jscomp.CommandLineRunner",
    "signature": "com.google.javascript.jscomp.CommandLineRunner.createOptions()",
    "snippet": "  @Override\n  protected CompilerOptions createOptions() {\n    CompilerOptions options = new CompilerOptions();\n    options.setCodingConvention(new ClosureCodingConvention());\n    CompilationLevel level = flags.compilation_level;\n    level.setOptionsForCompilationLevel(options);\n    if (flags.debug) {\n      level.setDebugOptionsForCompilationLevel(options);\n    }\n\n    WarningLevel wLevel = flags.warning_level;\n    wLevel.setOptionsForWarningLevel(options);\n    for (FormattingOption formattingOption : flags.formatting) {\n      formattingOption.applyToOptions(options);\n    }\n    if (flags.process_closure_primitives) {\n      options.closurePass = true;\n    }\n\n    initOptionsFromFlags(options);\n    return options;\n  }",
    "comment": "",
    "is_bug": true,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "CommandLineRunner.initConfigFromFlags",
    "class_name": "com.google.javascript.jscomp.CommandLineRunner",
    "signature": "com.google.javascript.jscomp.CommandLineRunner.initConfigFromFlags(String[],PrintStream)",
    "snippet": "  private void initConfigFromFlags(\n      String[] args, PrintStream err)\n      throws CmdLineException {\n    // Args4j has a different format that the old command-line parser.\n    // So we use some voodoo to get the args into the format that args4j\n    // expects.\n    Pattern argPattern = Pattern.compile(\"(--[a-zA-Z_]+)=(.*)\");\n    Pattern quotesPattern = Pattern.compile(\"^['\\\"](.*)['\\\"]$\");\n    List<String> processedArgs = Lists.newArrayList();\n    for (String arg : args) {\n      Matcher matcher = argPattern.matcher(arg);\n      if (matcher.matches()) {\n        processedArgs.add(matcher.group(1));\n\n        String value = matcher.group(2);\n        Matcher quotesMatcher = quotesPattern.matcher(value);\n        if (quotesMatcher.matches()) {\n          processedArgs.add(quotesMatcher.group(1));\n        } else {\n          processedArgs.add(value);\n        }\n      } else {\n        processedArgs.add(arg);\n      }\n    }\n\n    CmdLineParser parser = new CmdLineParser(flags);\n    try {\n      parser.parseArgument(processedArgs.toArray(new String[] {}));\n    } catch (CmdLineException e) {\n      err.println(e.getMessage());\n      parser.printUsage(err);\n      throw e;\n    }\n    getCommandLineConfig()\n        .setPrintTree(flags.print_tree)\n        .setComputePhaseOrdering(flags.compute_phase_ordering)\n        .setPrintAst(flags.print_ast)\n        .setPrintPassGraph(flags.print_pass_graph)\n        .setJscompDevMode(flags.jscomp_dev_mode)\n        .setLoggingLevel(flags.logging_level)\n        .setExterns(flags.externs)\n        .setJs(flags.js)\n        .setJsOutputFile(flags.js_output_file)\n        .setModule(flags.module)\n        .setVariableMapInputFile(flags.variable_map_input_file)\n        .setPropertyMapInputFile(flags.property_map_input_file)\n        .setVariableMapOutputFile(flags.variable_map_output_file)\n        .setCreateNameMapFiles(flags.create_name_map_files)\n        .setPropertyMapOutputFile(flags.property_map_output_file)\n        .setThirdParty(flags.third_party)\n        .setSummaryDetailLevel(flags.summary_detail_level)\n        .setOutputWrapper(flags.output_wrapper)\n        .setOutputWrapperMarker(flags.output_wrapper_marker)\n        .setModuleWrapper(flags.module_wrapper)\n        .setModuleOutputPathPrefix(flags.module_output_path_prefix)\n        .setCreateSourceMap(flags.create_source_map)\n        .setJscompError(flags.jscomp_error)\n        .setJscompWarning(flags.jscomp_warning)\n        .setJscompOff(flags.jscomp_off)\n        .setDefine(flags.define)\n        .setCharset(flags.charset);\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "BooleanOptionHandler.parseArguments",
    "class_name": "com.google.javascript.jscomp.CommandLineRunner$Flags$BooleanOptionHandler",
    "signature": "com.google.javascript.jscomp.CommandLineRunner$Flags$BooleanOptionHandler.parseArguments(Parameters)",
    "snippet": "      @Override\n      public int parseArguments(Parameters params) throws CmdLineException {\n        String param = params.getParameter(0);\n        if (param == null) {\n          setter.addValue(true);\n          return 0;\n        } else {\n          String lowerParam = param.toLowerCase();\n          if (TRUES.contains(lowerParam)) {\n            setter.addValue(true);\n          } else if (FALSES.contains(lowerParam)) {\n            setter.addValue(false);\n          } else {\n            throw new CmdLineException(owner,\n               \"Illegal boolean value: \" + lowerParam);\n          }\n          return 1;\n        }\n      }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "CompilationLevel.applySafeCompilationOptions",
    "class_name": "com.google.javascript.jscomp.CompilationLevel",
    "signature": "com.google.javascript.jscomp.CompilationLevel.applySafeCompilationOptions(CompilerOptions)",
    "snippet": "  private static void applySafeCompilationOptions(CompilerOptions options) {\n    // Does not call applyBasicCompilationOptions(options) because the call to\n    // skipAllCompilerPasses() cannot be easily undone.\n    options.closurePass = true;\n    options.variableRenaming = VariableRenamingPolicy.LOCAL;\n    options.inlineLocalVariables = true;\n    options.checkGlobalThisLevel = CheckLevel.OFF;\n    options.foldConstants = true;\n    options.removeConstantExpressions = true;\n    options.coalesceVariableNames = true;\n    options.deadAssignmentElimination = true;\n    options.extractPrototypeMemberDeclarations = true;\n    options.collapseVariableDeclarations = true;\n    options.convertToDottedProperties = true;\n    options.labelRenaming = true;\n    options.removeDeadCode = true;\n    options.optimizeArgumentsArray = true;\n    options.removeUnusedVars = true;\n    options.removeUnusedVarsInGlobalScope = false;\n\n    // Allows annotations that are not standard.\n    options.setWarningLevel(DiagnosticGroups.NON_STANDARD_JSDOC,\n        CheckLevel.OFF);\n  }",
    "comment": " Add options that are safe. Safe means options that won't break the JavaScript code even if no symbols are exported and no coding convention is used. @param options The CompilerOptions object to set the options on. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "CompilationLevel.setOptionsForCompilationLevel",
    "class_name": "com.google.javascript.jscomp.CompilationLevel",
    "signature": "com.google.javascript.jscomp.CompilationLevel.setOptionsForCompilationLevel(CompilerOptions)",
    "snippet": "  public void setOptionsForCompilationLevel(CompilerOptions options) {\n    switch (this) {\n      case WHITESPACE_ONLY:\n        applyBasicCompilationOptions(options);\n        break;\n      case SIMPLE_OPTIMIZATIONS:\n        applySafeCompilationOptions(options);\n        break;\n      case ADVANCED_OPTIMIZATIONS:\n        applyFullCompilationOptions(options);\n        break;\n      default:\n        throw new RuntimeException(\"Unknown compilation level.\");\n    }\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "Compiler.Compiler",
    "class_name": "com.google.javascript.jscomp.Compiler",
    "signature": "com.google.javascript.jscomp.Compiler.Compiler(PrintStream)",
    "snippet": "  public Compiler(PrintStream stream) {\n    addChangeHandler(recentChange);\n    this.typeValidator = new TypeValidator(this);\n    outStream = stream;\n  }",
    "comment": " Creates n Compiler that reports errors and warnings to an output stream. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "Compiler.addChangeHandler",
    "class_name": "com.google.javascript.jscomp.Compiler",
    "signature": "com.google.javascript.jscomp.Compiler.addChangeHandler(CodeChangeHandler)",
    "snippet": "  @Override\n  void addChangeHandler(CodeChangeHandler handler) {\n    codeChangeHandlers.add(handler);\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "Compiler.addToDebugLog",
    "class_name": "com.google.javascript.jscomp.Compiler",
    "signature": "com.google.javascript.jscomp.Compiler.addToDebugLog(String)",
    "snippet": "  @Override\n  void addToDebugLog(String str) {\n    debugLog.append(str);\n    debugLog.append('\\n');\n    logger.fine(str);\n  }",
    "comment": "Called from the compiler passes, adds debug info */",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "Compiler.check",
    "class_name": "com.google.javascript.jscomp.Compiler",
    "signature": "com.google.javascript.jscomp.Compiler.check()",
    "snippet": "  public void check() {\n    runCustomPasses(CustomPassExecutionTime.BEFORE_CHECKS);\n\n    PhaseOptimizer phaseOptimizer = new PhaseOptimizer(this, tracker);\n    if (options.devMode == DevMode.EVERY_PASS) {\n      phaseOptimizer.setSanityCheck(sanityCheck);\n    }\n    phaseOptimizer.consume(getPassConfig().getChecks());\n    phaseOptimizer.process(externsRoot, jsRoot);\n    if (hasErrors()) {\n      return;\n    }\n\n    // TODO(nicksantos): clean this up. The flow here is too hard to follow.\n    if (options.nameAnonymousFunctionsOnly) {\n      return;\n    }\n\n    if (options.removeTryCatchFinally) {\n      removeTryCatchFinally();\n    }\n\n    if (!options.stripTypes.isEmpty() ||\n        !options.stripNameSuffixes.isEmpty() ||\n        !options.stripTypePrefixes.isEmpty() ||\n        !options.stripNamePrefixes.isEmpty()) {\n      stripCode(options.stripTypes, options.stripNameSuffixes,\n          options.stripTypePrefixes, options.stripNamePrefixes);\n    }\n\n    runCustomPasses(CustomPassExecutionTime.BEFORE_OPTIMIZATIONS);\n\n    // Ideally, this pass should be the first pass run, however:\n    // 1) VariableReferenceCheck reports unexpected warnings if Normalize\n    // is done first.\n    // 2) ReplaceMessages, stripCode, and potentially custom passes rely on\n    // unmodified local names.\n    normalize();\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "Compiler.checkFirstModule",
    "class_name": "com.google.javascript.jscomp.Compiler",
    "signature": "com.google.javascript.jscomp.Compiler.checkFirstModule(JSModule[])",
    "snippet": "  private void checkFirstModule(JSModule[] modules) {\n    if (modules.length == 0) {\n      report(JSError.make(EMPTY_MODULE_LIST_ERROR));\n    } else if (modules[0].getInputs().isEmpty()) {\n      report(JSError.make(EMPTY_ROOT_MODULE_ERROR,\n          modules[0].getName()));\n    }\n  }",
    "comment": " Verifies that at least one module has been provided and that the first one has at least one source code input. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "Compiler.compile",
    "class_name": "com.google.javascript.jscomp.Compiler",
    "signature": "com.google.javascript.jscomp.Compiler.compile()",
    "snippet": "  private Result compile() {\n    return runInCompilerThread(new Callable<Result>() {\n      public Result call() throws Exception {\n        compileInternal();\n        return getResult();\n      }\n    });\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "Compiler.compile",
    "class_name": "com.google.javascript.jscomp.Compiler",
    "signature": "com.google.javascript.jscomp.Compiler.compile(JSSourceFile[],JSModule[],CompilerOptions)",
    "snippet": "  public Result compile(JSSourceFile[] externs,\n                        JSModule[] modules,\n                        CompilerOptions options) {\n    // The compile method should only be called once.\n    Preconditions.checkState(jsRoot == null);\n\n    try {\n      init(externs, modules, options);\n      if (hasErrors()) {\n        return getResult();\n      }\n      return compile();\n    } finally {\n      Tracer t = newTracer(\"generateReport\");\n      errorManager.generateReport();\n      stopTracer(t, \"generateReport\");\n    }\n  }",
    "comment": " Compiles a list of modules. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "Compiler.compileInternal",
    "class_name": "com.google.javascript.jscomp.Compiler",
    "signature": "com.google.javascript.jscomp.Compiler.compileInternal()",
    "snippet": "  private void compileInternal() {\n    parse();\n    if (hasErrors()) {\n      return;\n    }\n\n    if (!precheck()) {\n      return;\n    }\n\n    if (options.nameAnonymousFunctionsOnly) {\n      // TODO(nicksantos): Move this into an instrument() phase maybe?\n      check();\n      return;\n    }\n\n    if (!options.skipAllPasses) {\n      check();\n      if (hasErrors()) {\n        return;\n      }\n\n      if (options.externExportsPath != null) {\n        externExports();\n      }\n\n      // IDE-mode is defined to stop here, before the heavy rewriting begins.\n      if (!options.ideMode) {\n        optimize();\n      }\n    }\n\n    if (options.recordFunctionInformation) {\n      recordFunctionInformation();\n    }\n\n    if (options.devMode == DevMode.START_AND_END) {\n      runSanityCheck();\n    }\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "Compiler.createMessageFormatter",
    "class_name": "com.google.javascript.jscomp.Compiler",
    "signature": "com.google.javascript.jscomp.Compiler.createMessageFormatter()",
    "snippet": "  private MessageFormatter createMessageFormatter() {\n    boolean colorize = options.shouldColorizeErrorOutput();\n    return options.errorFormat.toFormatter(this, colorize);\n  }",
    "comment": " Creates a message formatter instance corresponding to the value of {@link CompilerOptions}. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "Compiler.createPassConfigInternal",
    "class_name": "com.google.javascript.jscomp.Compiler",
    "signature": "com.google.javascript.jscomp.Compiler.createPassConfigInternal()",
    "snippet": "  PassConfig createPassConfigInternal() {\n    return new DefaultPassConfig(options);\n  }",
    "comment": " Create the passes object. Clients should use setPassConfig instead of overriding this. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "Compiler.endPass",
    "class_name": "com.google.javascript.jscomp.Compiler",
    "signature": "com.google.javascript.jscomp.Compiler.endPass()",
    "snippet": "  void endPass() {\n    Preconditions.checkState(currentTracer != null,\n        \"Tracer should not be null at the end of a pass.\");\n    stopTracer(currentTracer, currentPassName);\n    String passToCheck = currentPassName;\n    currentPassName = null;\n    currentTracer = null;\n\n    maybeSanityCheck();\n  }",
    "comment": " Marks the end of a pass. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "Compiler.fillEmptyModules",
    "class_name": "com.google.javascript.jscomp.Compiler",
    "signature": "com.google.javascript.jscomp.Compiler.fillEmptyModules(JSModule[])",
    "snippet": "  private void fillEmptyModules(JSModule[] modules) {\n    for (int i = 1; i < modules.length; i ++) {\n      JSModule module = modules[i];\n      if (module.getInputs().isEmpty()) {\n        module.add(JSSourceFile.fromCode(\"[\" + module.getName() + \"]\", \"\"));\n      }\n    }\n  }",
    "comment": " Fill any empty modules with a place holder file. It makes any cross module motion easier. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "Compiler.getAllInputsFromModules",
    "class_name": "com.google.javascript.jscomp.Compiler",
    "signature": "com.google.javascript.jscomp.Compiler.getAllInputsFromModules()",
    "snippet": "  private CompilerInput[] getAllInputsFromModules() {\n    List<CompilerInput> inputs = new ArrayList<CompilerInput>();\n    Map<String, JSModule> inputMap = new HashMap<String, JSModule>();\n    for (JSModule module : modules) {\n      for (CompilerInput input : module.getInputs()) {\n        String inputName = input.getName();\n        JSModule firstModule = inputMap.get(inputName);\n        if (firstModule == null) {\n          inputs.add(input);\n          inputMap.put(inputName, module);\n        } else {\n          report(JSError.make(DUPLICATE_INPUT_IN_MODULES,\n              firstModule.getName(), module.getName(), inputName));\n        }\n      }\n    }\n    if (hasErrors()) {\n\n      // There's no reason to bother parsing the code.\n      return new CompilerInput[0];\n    }\n\n    return inputs.toArray(new CompilerInput[inputs.size()]);\n  }",
    "comment": " Builds a single list of all module inputs. Verifies that it contains no duplicates. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "Compiler.getCodingConvention",
    "class_name": "com.google.javascript.jscomp.Compiler",
    "signature": "com.google.javascript.jscomp.Compiler.getCodingConvention()",
    "snippet": "  @Override\n  public CodingConvention getCodingConvention() {\n    CodingConvention convention = options.getCodingConvention();\n    convention = convention != null ? convention : defaultCodingConvention;\n    return convention;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "Compiler.getCssRenamingMap",
    "class_name": "com.google.javascript.jscomp.Compiler",
    "signature": "com.google.javascript.jscomp.Compiler.getCssRenamingMap()",
    "snippet": "  @Override\n  CssRenamingMap getCssRenamingMap() {\n    return options.cssRenamingMap;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "Compiler.getDefaultErrorReporter",
    "class_name": "com.google.javascript.jscomp.Compiler",
    "signature": "com.google.javascript.jscomp.Compiler.getDefaultErrorReporter()",
    "snippet": "  @Override\n  ErrorReporter getDefaultErrorReporter() {\n    return defaultErrorReporter;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "Compiler.getErrorCount",
    "class_name": "com.google.javascript.jscomp.Compiler",
    "signature": "com.google.javascript.jscomp.Compiler.getErrorCount()",
    "snippet": "  public int getErrorCount() {\n    return errorManager.getErrorCount();\n  }",
    "comment": " Gets the number of errors. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "Compiler.getErrors",
    "class_name": "com.google.javascript.jscomp.Compiler",
    "signature": "com.google.javascript.jscomp.Compiler.getErrors()",
    "snippet": "  public JSError[] getErrors() {\n    return errorManager.getErrors();\n  }",
    "comment": " Returns the array of errors (never null). ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "Compiler.getInput",
    "class_name": "com.google.javascript.jscomp.Compiler",
    "signature": "com.google.javascript.jscomp.Compiler.getInput(String)",
    "snippet": "  @Override\n  public CompilerInput getInput(String name) {\n    return inputsByName.get(name);\n  }",
    "comment": "interface, and which ones should always be injected.",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "Compiler.getModuleGraph",
    "class_name": "com.google.javascript.jscomp.Compiler",
    "signature": "com.google.javascript.jscomp.Compiler.getModuleGraph()",
    "snippet": "  @Override\n  JSModuleGraph getModuleGraph() {\n    return moduleGraph;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "Compiler.getParserConfig",
    "class_name": "com.google.javascript.jscomp.Compiler",
    "signature": "com.google.javascript.jscomp.Compiler.getParserConfig()",
    "snippet": "  @Override\n  Config getParserConfig() {\n    if (parserConfig == null) {\n      parserConfig = ParserRunner.createConfig(\n          getTypeRegistry(), isIdeMode());\n    }\n    return parserConfig;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "Compiler.getPassConfig",
    "class_name": "com.google.javascript.jscomp.Compiler",
    "signature": "com.google.javascript.jscomp.Compiler.getPassConfig()",
    "snippet": "  PassConfig getPassConfig() {\n    if (passes == null) {\n      passes = createPassConfigInternal();\n    }\n    return passes;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "Compiler.getResult",
    "class_name": "com.google.javascript.jscomp.Compiler",
    "signature": "com.google.javascript.jscomp.Compiler.getResult()",
    "snippet": "  public Result getResult() {\n    PassConfig.State state = getPassConfig().getIntermediateState();\n    return new Result(getErrors(), getWarnings(), debugLog.toString(),\n        state.variableMap, state.propertyMap,\n        state.anonymousFunctionNameMap, functionInformationMap,\n        sourceMap, externExports, state.cssNames);\n  }",
    "comment": " Returns the result of the compilation. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "Compiler.getRoot",
    "class_name": "com.google.javascript.jscomp.Compiler",
    "signature": "com.google.javascript.jscomp.Compiler.getRoot()",
    "snippet": "  public Node getRoot() {\n    return externAndJsRoot;\n  }",
    "comment": " Returns the root node of the AST, which includes both externs and source. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "Compiler.getTypeRegistry",
    "class_name": "com.google.javascript.jscomp.Compiler",
    "signature": "com.google.javascript.jscomp.Compiler.getTypeRegistry()",
    "snippet": "  @Override\n  public JSTypeRegistry getTypeRegistry() {\n    if (typeRegistry == null) {\n      typeRegistry = new JSTypeRegistry(oldErrorReporter);\n    }\n    return typeRegistry;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "Compiler.getWarnings",
    "class_name": "com.google.javascript.jscomp.Compiler",
    "signature": "com.google.javascript.jscomp.Compiler.getWarnings()",
    "snippet": "  public JSError[] getWarnings() {\n    return errorManager.getWarnings();\n  }",
    "comment": " Returns the array of warnings (never null). ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "Compiler.hasErrors",
    "class_name": "com.google.javascript.jscomp.Compiler",
    "signature": "com.google.javascript.jscomp.Compiler.hasErrors()",
    "snippet": "  public boolean hasErrors() {\n    return hasHaltingErrors();\n  }",
    "comment": " Consults the {@link ErrorManager} to see if we've encountered errors that should halt compilation. <p>  If {@link CompilerOptions#ideMode} is {@code true}, this function always returns {@code false} without consulting the error manager. The error manager will continue to be told about new errors and warnings, but the compiler will complete compilation of all inputs.<p> ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "Compiler.hasHaltingErrors",
    "class_name": "com.google.javascript.jscomp.Compiler",
    "signature": "com.google.javascript.jscomp.Compiler.hasHaltingErrors()",
    "snippet": "  @Override\n  boolean hasHaltingErrors() {\n    return !isIdeMode() && getErrorCount() > 0;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "Compiler.init",
    "class_name": "com.google.javascript.jscomp.Compiler",
    "signature": "com.google.javascript.jscomp.Compiler.init(JSSourceFile[],JSModule[],CompilerOptions)",
    "snippet": "  public void init(JSSourceFile[] externs, JSModule[] modules,\n      CompilerOptions options) {\n    initOptions(options);\n\n    checkFirstModule(modules);\n    fillEmptyModules(modules);\n\n    this.externs = makeCompilerInput(externs, true);\n    this.modules = modules;\n    // Generate the module graph, and report any errors in the module\n    // specification as errors.\n    try {\n      this.moduleGraph = new JSModuleGraph(modules);\n    } catch (JSModuleGraph.ModuleDependenceException e) {\n      // problems with the module format.  Report as an error.  The\n      // message gives all details.\n      report(JSError.make(MODULE_DEPENDENCY_ERROR,\n          e.getModule().getName(), e.getDependentModule().getName()));\n      return;\n    }\n    this.inputs = getAllInputsFromModules();\n    initBasedOnOptions();\n\n    initInputsByNameMap();\n  }",
    "comment": " Initializes the instance state needed for a compile job. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "Compiler.init",
    "class_name": "com.google.javascript.jscomp.Compiler",
    "signature": "com.google.javascript.jscomp.Compiler.init(JSSourceFile[],JSSourceFile[],CompilerOptions)",
    "snippet": "  public void init(JSSourceFile[] externs, JSSourceFile[] inputs,\n      CompilerOptions options) {\n    initOptions(options);\n    \n    this.externs = makeCompilerInput(externs, true);\n    this.modules = null;\n    this.moduleGraph = null;\n    this.inputs = makeCompilerInput(inputs, false);\n    initBasedOnOptions();\n\n    initInputsByNameMap();\n  }",
    "comment": " Initializes the instance state needed for a compile job. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "Compiler.initBasedOnOptions",
    "class_name": "com.google.javascript.jscomp.Compiler",
    "signature": "com.google.javascript.jscomp.Compiler.initBasedOnOptions()",
    "snippet": "  private void initBasedOnOptions() {\n    // Create the source map if necessary.\n    if (options.sourceMapOutputPath != null) {\n      sourceMap = new SourceMap();\n    }\n  }",
    "comment": " Do any initialization that is dependent on the compiler options. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "Compiler.initCompilerOptionsIfTesting",
    "class_name": "com.google.javascript.jscomp.Compiler",
    "signature": "com.google.javascript.jscomp.Compiler.initCompilerOptionsIfTesting()",
    "snippet": "  void initCompilerOptionsIfTesting() {\n    if (options == null) {\n      // initialization for tests that don't initialize the compiler\n      // by the normal mechanisms.\n      initOptions(new CompilerOptions());\n    }\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "Compiler.initInputsByNameMap",
    "class_name": "com.google.javascript.jscomp.Compiler",
    "signature": "com.google.javascript.jscomp.Compiler.initInputsByNameMap()",
    "snippet": "  void initInputsByNameMap() {\n    inputsByName = new HashMap<String, CompilerInput>();\n    for (CompilerInput input : externs) {\n      String name = input.getName();\n      if (!inputsByName.containsKey(name)) {\n        inputsByName.put(name, input);\n      } else {\n        report(JSError.make(DUPLICATE_EXTERN_INPUT, name));\n      }\n    }\n    for (CompilerInput input : inputs) {\n      String name = input.getName();\n      if (!inputsByName.containsKey(name)) {\n        inputsByName.put(name, input);\n      } else {\n        report(JSError.make(DUPLICATE_INPUT, name));\n      }\n    }\n  }",
    "comment": " Creates a map to make looking up an input by name fast. Also checks for duplicate inputs. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "Compiler.initOptions",
    "class_name": "com.google.javascript.jscomp.Compiler",
    "signature": "com.google.javascript.jscomp.Compiler.initOptions(CompilerOptions)",
    "snippet": "  public void initOptions(CompilerOptions options) {\n    this.options = options;\n    if (errorManager == null) {\n      if (outStream == null) {\n        setErrorManager(\n            new LoggerErrorManager(createMessageFormatter(), logger));\n      } else {\n        PrintStreamErrorManager printer =\n            new PrintStreamErrorManager(createMessageFormatter(), outStream);\n        printer.setSummaryDetailLevel(options.summaryDetailLevel);\n        setErrorManager(printer);\n      }\n    }\n  }",
    "comment": " Initialize the compiler options. Only necessary if you're not doing a normal compile() job. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "Compiler.isIdeMode",
    "class_name": "com.google.javascript.jscomp.Compiler",
    "signature": "com.google.javascript.jscomp.Compiler.isIdeMode()",
    "snippet": "  @Override\n  public boolean isIdeMode() {\n    return options.ideMode;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "Compiler.makeCompilerInput",
    "class_name": "com.google.javascript.jscomp.Compiler",
    "signature": "com.google.javascript.jscomp.Compiler.makeCompilerInput(JSSourceFile[],boolean)",
    "snippet": "  private CompilerInput[] makeCompilerInput(\n      JSSourceFile[] files, boolean isExtern) {\n    CompilerInput [] inputs = new CompilerInput[files.length];\n    for (int i = 0; i < files.length; ++i) {\n      inputs[i] = new CompilerInput(files[i], isExtern);\n    }\n    return inputs;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "Compiler.maybeSanityCheck",
    "class_name": "com.google.javascript.jscomp.Compiler",
    "signature": "com.google.javascript.jscomp.Compiler.maybeSanityCheck()",
    "snippet": "  private void maybeSanityCheck() {\n    if (options.devMode == DevMode.EVERY_PASS) {\n      runSanityCheck();\n    }\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "Compiler.newTracer",
    "class_name": "com.google.javascript.jscomp.Compiler",
    "signature": "com.google.javascript.jscomp.Compiler.newTracer(String)",
    "snippet": "  Tracer newTracer(String passName) {\n    String comment = passName\n        + (recentChange.hasCodeChanged() ? \" on recently changed AST\" : \"\");\n    if (options.tracer.isOn()) {\n      tracker.recordPassStart(passName);\n    }\n    return new Tracer(\"Compiler\", comment);\n  }",
    "comment": " Returns a new tracer for the given pass name. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "Compiler.normalize",
    "class_name": "com.google.javascript.jscomp.Compiler",
    "signature": "com.google.javascript.jscomp.Compiler.normalize()",
    "snippet": "  public void normalize() {\n    logger.info(\"Normalizing\");\n    startPass(\"normalize\");\n    process(new Normalize(this, false));\n    setNormalized();\n    endPass();\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "Compiler.optimize",
    "class_name": "com.google.javascript.jscomp.Compiler",
    "signature": "com.google.javascript.jscomp.Compiler.optimize()",
    "snippet": "  public void optimize() {\n    PhaseOptimizer phaseOptimizer = new PhaseOptimizer(this, tracker);\n    if (options.devMode == DevMode.EVERY_PASS) {\n      phaseOptimizer.setSanityCheck(sanityCheck);\n    }\n    phaseOptimizer.consume(getPassConfig().getOptimizations());\n    phaseOptimizer.process(externsRoot, jsRoot);\n    if (hasErrors()) {\n      return;\n    }\n  }",
    "comment": "------------------------------------------------------------------------",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "Compiler.parse",
    "class_name": "com.google.javascript.jscomp.Compiler",
    "signature": "com.google.javascript.jscomp.Compiler.parse()",
    "snippet": "  public void parse() {\n    parseInputs();\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "Compiler.parseInputs",
    "class_name": "com.google.javascript.jscomp.Compiler",
    "signature": "com.google.javascript.jscomp.Compiler.parseInputs()",
    "snippet": "  Node parseInputs() {\n    boolean devMode = options.devMode != DevMode.OFF;\n\n    // If old roots exist (we are parsing a second time), detach each of the\n    // individual file parse trees.\n    if (externsRoot != null) {\n      externsRoot.detachChildren();\n    }\n    if (jsRoot != null) {\n      jsRoot.detachChildren();\n    }\n\n    // Parse main js sources.\n    jsRoot = new Node(Token.BLOCK);\n    jsRoot.setIsSyntheticBlock(true);\n\n    if (options.tracer.isOn()) {\n      tracker = new PerformanceTracker(jsRoot,\n          options.tracer == TracerMode.ALL);\n      addChangeHandler(tracker.getCodeChangeHandler());\n    }\n\n    Tracer tracer = newTracer(\"parseInputs\");\n\n    try {\n      // Parse externs sources.\n      externsRoot = new Node(Token.BLOCK);\n      externsRoot.setIsSyntheticBlock(true);\n      for (CompilerInput input : externs) {\n        Node n = input.getAstRoot(this);\n        if (hasErrors()) {\n          return null;\n        }\n        externsRoot.addChildToBack(n);\n      }\n\n      for (CompilerInput input : inputs) {\n        Node n = input.getAstRoot(this);\n        if (hasErrors()) {\n          return null;\n        }\n\n        // Inputs can have a null AST during initial parse.\n        if (n == null) {\n          continue;\n        }\n\n        if (devMode) {\n          runSanityCheck();\n          if (hasErrors()) {\n            return null;\n          }\n        }\n\n        if (options.sourceMapOutputPath != null ||\n            options.nameReferenceReportPath != null) {\n\n          // Annotate the nodes in the tree with information from the\n          // input file. This information is used to construct the SourceMap.\n          SourceInformationAnnotator sia =\n              new SourceInformationAnnotator(input.getName());\n          NodeTraversal.traverse(this, n, sia);\n        }\n\n        jsRoot.addChildToBack(n);\n      }\n\n      externAndJsRoot = new Node(Token.BLOCK, externsRoot, jsRoot);\n      externAndJsRoot.setIsSyntheticBlock(true);\n\n      return externAndJsRoot;\n    } finally {\n      stopTracer(tracer, \"parseInputs\");\n    }\n  }",
    "comment": " Parses the externs and main inputs.  @return A synthetic root node whose two children are the externs root and the main root ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "Compiler.precheck",
    "class_name": "com.google.javascript.jscomp.Compiler",
    "signature": "com.google.javascript.jscomp.Compiler.precheck()",
    "snippet": "  boolean precheck() {\n    return true;\n  }",
    "comment": " Carry out any special checks or procedures that need to be done before proceeding with rest of the compilation process.  @return true, to continue with compilation ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "Compiler.prepareAst",
    "class_name": "com.google.javascript.jscomp.Compiler",
    "signature": "com.google.javascript.jscomp.Compiler.prepareAst(Node)",
    "snippet": "  @Override\n  void prepareAst(Node root) {\n    Tracer tracer = newTracer(\"prepareAst\");\n    CompilerPass pass = new PrepareAst(this);\n    pass.process(null, root);\n    stopTracer(tracer, \"prepareAst\");\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "Compiler.process",
    "class_name": "com.google.javascript.jscomp.Compiler",
    "signature": "com.google.javascript.jscomp.Compiler.process(CompilerPass)",
    "snippet": "  void process(CompilerPass p) {\n    p.process(externsRoot, jsRoot);\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "Compiler.reportCodeChange",
    "class_name": "com.google.javascript.jscomp.Compiler",
    "signature": "com.google.javascript.jscomp.Compiler.reportCodeChange()",
    "snippet": "  @Override\n  public void reportCodeChange() {\n    for (CodeChangeHandler handler : codeChangeHandlers) {\n      handler.reportChange();\n    }\n  }",
    "comment": " All passes should call reportCodeChange() when they alter the JS tree structure. This is verified by CompilerTestCase. This allows us to optimize to a fixed point. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "Compiler.runCustomPasses",
    "class_name": "com.google.javascript.jscomp.Compiler",
    "signature": "com.google.javascript.jscomp.Compiler.runCustomPasses(CustomPassExecutionTime)",
    "snippet": "  private void runCustomPasses(CustomPassExecutionTime executionTime) {\n    if (options.customPasses != null) {\n      Tracer t = newTracer(\"runCustomPasses\");\n      try {\n        for (CompilerPass p : options.customPasses.get(executionTime)) {\n          process(p);\n        }\n      } finally {\n        stopTracer(t, \"runCustomPasses\");\n      }\n    }\n  }",
    "comment": " Runs custom passes that are designated to run at a particular time. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "Compiler.runInCompilerThread",
    "class_name": "com.google.javascript.jscomp.Compiler",
    "signature": "com.google.javascript.jscomp.Compiler.runInCompilerThread(Callable)",
    "snippet": "  @SuppressWarnings(\"unchecked\")\n  private <T> T runInCompilerThread(final Callable<T> callable) {\n\n    // Under JRE 1.6, the jscompiler overflows the stack when running on some\n    // large or complex js code. Here we start a new thread with a larger\n    // stack in order to let the compiler do its thing, without having to\n    // increase the stack size for *every* thread (which is what -Xss does).\n    // Might want to add thread pool support for clients that compile a lot.\n\n    final boolean dumpTraceReport = options.tracer.isOn();\n    final Object[] result = new Object[1];\n    final Throwable[] exception = new Throwable[1];\n    Runnable runnable = new Runnable() {\n      public void run() {\n        try {\n          if (dumpTraceReport) {\n            Tracer.initCurrentThreadTrace();\n          }\n          result[0] = callable.call();\n        } catch (Throwable e) {\n          exception[0] = e;\n        } finally {\n          if (dumpTraceReport) {\n            Tracer.logAndClearCurrentThreadTrace();\n          }\n        }\n      }\n    };\n\n    if (useThreads) {\n      Thread th = new Thread(null, runnable, \"jscompiler\", COMPILER_STACK_SIZE);\n      th.start();\n      while (true) {\n        try {\n          th.join();\n          break;\n        } catch (InterruptedException ignore) {\n          // ignore\n        }\n      }\n    } else {\n      runnable.run();\n    }\n\n    // Pass on any exception caught by the runnable object.\n    if (exception[0] != null) {\n      throw new RuntimeException(exception[0]);\n    }\n\n    return (T) result[0];\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "Compiler.setErrorManager",
    "class_name": "com.google.javascript.jscomp.Compiler",
    "signature": "com.google.javascript.jscomp.Compiler.setErrorManager(ErrorManager)",
    "snippet": "  public void setErrorManager(ErrorManager errorManager) {\n    Preconditions.checkNotNull(\n        errorManager, \"the error manager cannot be null\");\n    this.errorManager = errorManager;\n  }",
    "comment": " Sets the error manager.  @param errorManager the error manager, it cannot be {@code null} ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "Compiler.setNormalized",
    "class_name": "com.google.javascript.jscomp.Compiler",
    "signature": "com.google.javascript.jscomp.Compiler.setNormalized()",
    "snippet": "  @Override\n  void setNormalized() {\n    normalized = true;\n  }",
    "comment": " Set if the normalization pass has been done. Note: non-private to enable test cases that require the Normalize pass. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "Compiler.setUnnormalized",
    "class_name": "com.google.javascript.jscomp.Compiler",
    "signature": "com.google.javascript.jscomp.Compiler.setUnnormalized()",
    "snippet": "  @Override\n  void setUnnormalized() {\n    normalized = false;\n  }",
    "comment": " Set once unnormalizing passes have been start. Note: non-private to enable test cases that require the Normalize pass. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "Compiler.startPass",
    "class_name": "com.google.javascript.jscomp.Compiler",
    "signature": "com.google.javascript.jscomp.Compiler.startPass(String)",
    "snippet": "  void startPass(String passName) {\n    Preconditions.checkState(currentTracer == null);\n    currentPassName = passName;\n    currentTracer = newTracer(passName);\n  }",
    "comment": " Marks the beginning of a pass. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "Compiler.stopTracer",
    "class_name": "com.google.javascript.jscomp.Compiler",
    "signature": "com.google.javascript.jscomp.Compiler.stopTracer(Tracer,String)",
    "snippet": "  void stopTracer(Tracer t, String passName) {\n    long result = t.stop();\n    if (options.tracer.isOn()) {\n      tracker.recordPassStop(passName, result);\n    }\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "Compiler.toSource",
    "class_name": "com.google.javascript.jscomp.Compiler",
    "signature": "com.google.javascript.jscomp.Compiler.toSource(Node)",
    "snippet": "  @Override\n  String toSource(Node n) {\n    initCompilerOptionsIfTesting();\n    \n    CodePrinter.Builder builder = new CodePrinter.Builder(n);\n    builder.setPrettyPrint(options.prettyPrint);\n    builder.setLineBreak(options.lineBreak);\n    builder.setSourceMap(sourceMap);\n    builder.setOutputCharset(options.outputCharset);\n    return builder.build();\n  }",
    "comment": " Generates JavaScript source code for an AST. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "CompilerInput.CompilerInput",
    "class_name": "com.google.javascript.jscomp.CompilerInput",
    "signature": "com.google.javascript.jscomp.CompilerInput.CompilerInput(JSSourceFile)",
    "snippet": "  public CompilerInput(JSSourceFile file) {\n    this(file, false);\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "CompilerInput.CompilerInput",
    "class_name": "com.google.javascript.jscomp.CompilerInput",
    "signature": "com.google.javascript.jscomp.CompilerInput.CompilerInput(JSSourceFile,boolean)",
    "snippet": "  public CompilerInput(JSSourceFile file, boolean isExtern) {\n    this.ast = new JsAst(file);\n    this.name = file.getName();\n    this.isExtern = isExtern;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "CompilerInput.getAstRoot",
    "class_name": "com.google.javascript.jscomp.CompilerInput",
    "signature": "com.google.javascript.jscomp.CompilerInput.getAstRoot(AbstractCompiler)",
    "snippet": "  @Override\n  public Node getAstRoot(AbstractCompiler compiler) {\n    return ast.getAstRoot(compiler);\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "CompilerInput.getModule",
    "class_name": "com.google.javascript.jscomp.CompilerInput",
    "signature": "com.google.javascript.jscomp.CompilerInput.getModule()",
    "snippet": "  public JSModule getModule() {\n    return module;\n  }",
    "comment": "Returns the module to which the input belongs. */",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "CompilerInput.getName",
    "class_name": "com.google.javascript.jscomp.CompilerInput",
    "signature": "com.google.javascript.jscomp.CompilerInput.getName()",
    "snippet": "  public String getName() {\n    return name;\n  }",
    "comment": "Returns a name for this input. Must be unique across all inputs. */",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "CompilerInput.setModule",
    "class_name": "com.google.javascript.jscomp.CompilerInput",
    "signature": "com.google.javascript.jscomp.CompilerInput.setModule(JSModule)",
    "snippet": "  public void setModule(JSModule module) {\n    // An input may only belong to one module.\n    Preconditions.checkArgument(\n        module == null || this.module == null || this.module == module);\n    this.module = module;\n  }",
    "comment": "Sets the module to which the input belongs. */",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "CompilerOptions.CompilerOptions",
    "class_name": "com.google.javascript.jscomp.CompilerOptions",
    "signature": "com.google.javascript.jscomp.CompilerOptions.CompilerOptions()",
    "snippet": "  public CompilerOptions() {\n    // Checks\n    skipAllPasses = false;\n    nameAnonymousFunctionsOnly = false;\n    devMode = DevMode.OFF;\n    checkSymbols = false;\n    checkShadowVars = CheckLevel.OFF;\n    aggressiveVarCheck = CheckLevel.OFF;\n    checkFunctions = CheckLevel.OFF;\n    checkMethods = CheckLevel.OFF;\n    checkDuplicateMessages = false;\n    allowLegacyJsMessages = false;\n    strictMessageReplacement = false;\n    checkSuspiciousCode = false;\n    checkControlStructures = false;\n    checkUndefinedProperties = CheckLevel.OFF;\n    checkUnusedPropertiesEarly = false;\n    checkTypes = false;\n    tightenTypes = false;\n    inferTypesInGlobalScope = false;\n    checkTypedPropertyCalls = false;\n    reportMissingOverride = CheckLevel.OFF;\n    reportUnknownTypes = CheckLevel.OFF;\n    checkRequires = CheckLevel.OFF;\n    checkProvides = CheckLevel.OFF;\n    checkGlobalNamesLevel = CheckLevel.OFF;\n    brokenClosureRequiresLevel = CheckLevel.ERROR;\n    checkGlobalThisLevel = CheckLevel.WARNING;\n    checkUnreachableCode = CheckLevel.OFF;\n    checkMissingReturn = CheckLevel.OFF;\n    checkMissingGetCssNameLevel = CheckLevel.OFF;\n    checkMissingGetCssNameBlacklist = null;\n    checkEs5Strict = false;\n    checkCaja = false;\n    computeFunctionSideEffects = false;\n    chainCalls = false;\n\n    // Optimizations\n    foldConstants = false;\n    removeConstantExpressions = false;\n    coalesceVariableNames = false;\n    deadAssignmentElimination = false;\n    inlineConstantVars = false;\n    inlineFunctions = false;\n    inlineLocalFunctions = false;\n    crossModuleCodeMotion = false;\n    crossModuleMethodMotion = false;\n    inlineGetters = false;\n    inlineVariables = false;\n    inlineLocalVariables = false;\n    smartNameRemoval = false;\n    removeDeadCode = false;\n    extractPrototypeMemberDeclarations = false;\n    removeUnusedPrototypeProperties = false;\n    removeUnusedPrototypePropertiesInExterns = false;\n    removeUnusedVars = false;\n    removeUnusedVarsInGlobalScope = true;\n    aliasExternals = false;\n    collapseVariableDeclarations = false;\n    collapseAnonymousFunctions = false;\n    aliasableStrings = Collections.emptySet();\n    aliasStringsBlacklist = \"\";\n    aliasAllStrings = false;\n    outputJsStringUsage = false;\n    convertToDottedProperties = false;\n    rewriteFunctionExpressions = false;\n    optimizeParameters = false;\n\n    // Renaming\n    variableRenaming = VariableRenamingPolicy.OFF;\n    propertyRenaming = PropertyRenamingPolicy.OFF;\n    labelRenaming = false;\n    generatePseudoNames = false;\n    renamePrefix = null;\n    aliasKeywords = false;\n    collapseProperties = false;\n    collapsePropertiesOnExternTypes = false;\n    devirtualizePrototypeMethods = false;\n    disambiguateProperties = false;\n    ambiguateProperties = false;\n    anonymousFunctionNaming = AnonymousFunctionNamingPolicy.OFF;\n    exportTestFunctions = false;\n\n    // Alterations\n    runtimeTypeCheck = false;\n    runtimeTypeCheckLogFunction = null;\n    instrumentForCoverage = false;\n    instrumentForCoverageOnly = false;\n    ignoreCajaProperties = false;\n    syntheticBlockStartMarker = null;\n    syntheticBlockEndMarker = null;\n    locale = null;\n    markAsCompiled = false;\n    removeTryCatchFinally = false;\n    closurePass = false;\n    rewriteNewDateGoogNow = true;\n    removeAbstractMethods = true;\n    stripTypes = Collections.emptySet();\n    stripNameSuffixes = Collections.emptySet();\n    stripNamePrefixes = Collections.emptySet();\n    stripTypePrefixes = Collections.emptySet();\n    customPasses = null;\n    markNoSideEffectCalls = false;\n    defineReplacements = Maps.newHashMap();\n    moveFunctionDeclarations = false;\n    instrumentationTemplate = null;\n    appNameStr = \"\";\n    recordFunctionInformation = false;\n    generateExports = false;\n    cssRenamingMap = null;\n    processObjectPropertyString = false;\n    idGenerators = Collections.emptySet();\n\n    // Output\n    printInputDelimiter = false;\n    prettyPrint = false;\n    lineBreak = false;\n    reportPath = null;\n    tracer = TracerMode.OFF;\n    colorizeErrorOutput = false;\n    errorFormat = ErrorFormat.SINGLELINE;\n    warningsGuard = null;\n    debugFunctionSideEffectsPath = null;\n    jsOutputFile = \"\";\n    nameReferenceReportPath = null;\n    nameReferenceGraphPath = null;\n  }",
    "comment": " Initializes compiler options. All options are disabled by default.  Command-line frontends to the compiler should set these properties like a builder. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "CompilerOptions.addWarningsGuard",
    "class_name": "com.google.javascript.jscomp.CompilerOptions",
    "signature": "com.google.javascript.jscomp.CompilerOptions.addWarningsGuard(WarningsGuard)",
    "snippet": "  public void addWarningsGuard(WarningsGuard guard) {\n    if (warningsGuard == null) {\n      warningsGuard = new ComposeWarningsGuard(guard);\n    } else {\n      warningsGuard.addGuard(guard);\n    }\n  }",
    "comment": " Add a guard to the set of warnings guards. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "CompilerOptions.disables",
    "class_name": "com.google.javascript.jscomp.CompilerOptions",
    "signature": "com.google.javascript.jscomp.CompilerOptions.disables(DiagnosticGroup)",
    "snippet": "  boolean disables(DiagnosticGroup type) {\n    return warningsGuard != null && warningsGuard.disables(type);\n  }",
    "comment": " Whether the warnings guard in this Options object disables the given group of warnings. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "CompilerOptions.enables",
    "class_name": "com.google.javascript.jscomp.CompilerOptions",
    "signature": "com.google.javascript.jscomp.CompilerOptions.enables(DiagnosticGroup)",
    "snippet": "  boolean enables(DiagnosticGroup type) {\n    return warningsGuard != null && warningsGuard.enables(type);\n  }",
    "comment": " Whether the warnings guard in this Options object enables the given group of warnings. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "CompilerOptions.getCodingConvention",
    "class_name": "com.google.javascript.jscomp.CompilerOptions",
    "signature": "com.google.javascript.jscomp.CompilerOptions.getCodingConvention()",
    "snippet": "  public CodingConvention getCodingConvention() {\n    return codingConvention;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "CompilerOptions.getDefineReplacements",
    "class_name": "com.google.javascript.jscomp.CompilerOptions",
    "signature": "com.google.javascript.jscomp.CompilerOptions.getDefineReplacements()",
    "snippet": "  public Map<String, Node> getDefineReplacements() {\n    Map<String, Node> map = Maps.newHashMap();\n    for (Map.Entry<String, Object> entry : defineReplacements.entrySet()) {\n      String name = entry.getKey();\n      Object value = entry.getValue();\n      if (value instanceof Boolean) {\n        map.put(name, ((Boolean) value).booleanValue() ?\n            new Node(Token.TRUE) : new Node(Token.FALSE));\n      } else if (value instanceof Integer) {\n        map.put(name, Node.newNumber(((Integer) value).intValue()));\n      } else if (value instanceof Double) {\n        map.put(name, Node.newNumber(((Double) value).doubleValue()));\n      } else {\n        Preconditions.checkState(value instanceof String);\n        map.put(name, Node.newString((String) value));\n      }\n    }\n    return map;\n  }",
    "comment": " Returns the map of define replacements. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "CompilerOptions.getWarningsGuard",
    "class_name": "com.google.javascript.jscomp.CompilerOptions",
    "signature": "com.google.javascript.jscomp.CompilerOptions.getWarningsGuard()",
    "snippet": "  WarningsGuard getWarningsGuard() {\n    return warningsGuard;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "CompilerOptions.setCodingConvention",
    "class_name": "com.google.javascript.jscomp.CompilerOptions",
    "signature": "com.google.javascript.jscomp.CompilerOptions.setCodingConvention(CodingConvention)",
    "snippet": "  public void setCodingConvention(CodingConvention codingConvention) {\n    this.codingConvention = codingConvention;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "CompilerOptions.setSummaryDetailLevel",
    "class_name": "com.google.javascript.jscomp.CompilerOptions",
    "signature": "com.google.javascript.jscomp.CompilerOptions.setSummaryDetailLevel(int)",
    "snippet": "  public void setSummaryDetailLevel(int summaryDetailLevel) {\n    this.summaryDetailLevel = summaryDetailLevel;\n  }",
    "comment": " Controls how detailed the compilation summary is. Values: 0 (never print summary), 1 (print summary only if there are errors or warnings), 2 (print summary if type checking is on, see --check_types), 3 (always print summary). The default level is 1 ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "CompilerOptions.setWarningLevel",
    "class_name": "com.google.javascript.jscomp.CompilerOptions",
    "signature": "com.google.javascript.jscomp.CompilerOptions.setWarningLevel(DiagnosticGroup,CheckLevel)",
    "snippet": "  public void setWarningLevel(DiagnosticGroup type, CheckLevel level) {\n    addWarningsGuard(new DiagnosticGroupWarningsGuard(type, level));\n  }",
    "comment": " Configure the given type of warning to the given level. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "CompilerOptions.shouldColorizeErrorOutput",
    "class_name": "com.google.javascript.jscomp.CompilerOptions",
    "signature": "com.google.javascript.jscomp.CompilerOptions.shouldColorizeErrorOutput()",
    "snippet": "  public boolean shouldColorizeErrorOutput() {\n    return colorizeErrorOutput;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "TracerMode.isOn",
    "class_name": "com.google.javascript.jscomp.CompilerOptions$TracerMode",
    "signature": "com.google.javascript.jscomp.CompilerOptions$TracerMode.isOn()",
    "snippet": "    boolean isOn() {\n      return this != OFF;\n    }",
    "comment": "Collect no timing and size metrics.",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "ComposeWarningsGuard.ComposeWarningsGuard",
    "class_name": "com.google.javascript.jscomp.ComposeWarningsGuard",
    "signature": "com.google.javascript.jscomp.ComposeWarningsGuard.ComposeWarningsGuard(List)",
    "snippet": "  public ComposeWarningsGuard(List<WarningsGuard> guards) {\n    this.guards = Lists.newArrayList();\n    addGuards(guards);\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "ComposeWarningsGuard.ComposeWarningsGuard",
    "class_name": "com.google.javascript.jscomp.ComposeWarningsGuard",
    "signature": "com.google.javascript.jscomp.ComposeWarningsGuard.ComposeWarningsGuard(WarningsGuard[])",
    "snippet": "  public ComposeWarningsGuard(WarningsGuard... guards) {\n    this(Lists.newArrayList(guards));\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "ComposeWarningsGuard.addGuard",
    "class_name": "com.google.javascript.jscomp.ComposeWarningsGuard",
    "signature": "com.google.javascript.jscomp.ComposeWarningsGuard.addGuard(WarningsGuard)",
    "snippet": "  void addGuard(WarningsGuard guard) {\n    if (guard instanceof ComposeWarningsGuard) {\n      addGuards(((ComposeWarningsGuard) guard).guards);\n    } else {\n      int index = Collections.binarySearch(this.guards, guard, guardComparator);\n      if (index < 0) {\n        index = -index - 1;\n      }\n      this.guards.add(index, guard);\n    }\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "ComposeWarningsGuard.addGuards",
    "class_name": "com.google.javascript.jscomp.ComposeWarningsGuard",
    "signature": "com.google.javascript.jscomp.ComposeWarningsGuard.addGuards(Iterable)",
    "snippet": "  private void addGuards(Iterable<WarningsGuard> guards) {\n    for (WarningsGuard guard : guards) {\n      addGuard(guard);\n    }\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "ComposeWarningsGuard.disables",
    "class_name": "com.google.javascript.jscomp.ComposeWarningsGuard",
    "signature": "com.google.javascript.jscomp.ComposeWarningsGuard.disables(DiagnosticGroup)",
    "snippet": "  @Override\n  public boolean disables(DiagnosticGroup group) {\n    nextSingleton:\n    for (DiagnosticType type : group.getTypes()) {\n      DiagnosticGroup singleton = DiagnosticGroup.forType(type);\n\n      for (WarningsGuard guard : guards) {\n        if (guard.disables(singleton)) {\n          continue nextSingleton;\n        } else if (guard.enables(singleton)) {\n          return false;\n        }\n      }\n\n      return false;\n    }\n\n    return true;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "ComposeWarningsGuard.enables",
    "class_name": "com.google.javascript.jscomp.ComposeWarningsGuard",
    "signature": "com.google.javascript.jscomp.ComposeWarningsGuard.enables(DiagnosticGroup)",
    "snippet": "  @Override\n  public boolean enables(DiagnosticGroup group) {\n    for (WarningsGuard guard : guards) {\n      if (guard.enables(group)) {\n        return true;\n      }\n    }\n\n    return false;\n  }",
    "comment": " Determines whether this guard will \"elevate\" the status of any disabled diagnostic type in the group to a warning or an error. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "ControlFlowAnalysis.ControlFlowAnalysis",
    "class_name": "com.google.javascript.jscomp.ControlFlowAnalysis",
    "signature": "com.google.javascript.jscomp.ControlFlowAnalysis.ControlFlowAnalysis(AbstractCompiler,boolean)",
    "snippet": "  ControlFlowAnalysis(AbstractCompiler compiler,\n      boolean shouldTraverseFunctions) {\n    this.compiler = compiler;\n    this.shouldTraverseFunctions = shouldTraverseFunctions;\n  }",
    "comment": " Constructor.  @param compiler Compiler instance. @param shouldTraverseFunctions Whether functions should be traversed (true by default). ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "ControlFlowAnalysis.computeFallThrough",
    "class_name": "com.google.javascript.jscomp.ControlFlowAnalysis",
    "signature": "com.google.javascript.jscomp.ControlFlowAnalysis.computeFallThrough(Node)",
    "snippet": "  private static Node computeFallThrough(Node n) {\n    switch (n.getType()) {\n      case Token.DO:\n        return computeFallThrough(n.getFirstChild());\n      case Token.FOR:\n        if (NodeUtil.isForIn(n)) {\n          return n;\n        }\n        return computeFallThrough(n.getFirstChild());\n      case Token.LABEL:\n        return computeFallThrough(n.getLastChild());\n      default:\n        return n;\n    }\n  }",
    "comment": " Computes the destination node of n when we want to fallthough into the subtree of n. We don't always create a CFG edge into n itself because of DOs and FORs. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "ControlFlowAnalysis.computeFollowNode",
    "class_name": "com.google.javascript.jscomp.ControlFlowAnalysis",
    "signature": "com.google.javascript.jscomp.ControlFlowAnalysis.computeFollowNode(Node)",
    "snippet": "  private Node computeFollowNode(Node node) {\n    return computeFollowNode(node, node);\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "ControlFlowAnalysis.computeFollowNode",
    "class_name": "com.google.javascript.jscomp.ControlFlowAnalysis",
    "signature": "com.google.javascript.jscomp.ControlFlowAnalysis.computeFollowNode(Node,Node)",
    "snippet": "  private Node computeFollowNode(Node fromNode, Node node) {\n    /*\n     * This is the case where:\n     *\n     * 1. Parent is null implies that we are transferring control to the end of\n     * the script.\n     *\n     * 2. Parent is a function implies that we are transferring control back to\n     * the caller of the function.\n     *\n     * 3. If the node is a return statement, we should also transfer control\n     * back to the caller of the function.\n     *\n     * 4. If the node is root then we have reached the end of what we have been\n     * asked to traverse.\n     *\n     * In all cases we should transfer control to a \"symbolic return\" node.\n     * This will make life easier for DFAs.\n     */\n    Node parent = node.getParent();\n    if (parent == null || parent.getType() == Token.FUNCTION || node == root) {\n      return null;\n    }\n\n    // If we are just before a IF/WHILE/DO/FOR:\n    switch (parent.getType()) {\n      // The follow() of any of the path from IF would be what follows IF.\n      case Token.IF:\n        return computeFollowNode(fromNode, parent);\n      case Token.CASE:\n      case Token.DEFAULT:\n        // After the body of a CASE, the control goes to the body of the next\n        // case, without having to go to the case condition.\n        if (parent.getNext() != null) {\n          if (parent.getNext().getType() == Token.CASE) {\n            return parent.getNext().getFirstChild().getNext();\n          } else if (parent.getNext().getType() == Token.DEFAULT) {\n            return parent.getNext().getFirstChild();\n          } else {\n            Preconditions.checkState(false, \"Not reachable\");\n          }\n        } else {\n          return computeFollowNode(fromNode, parent);\n        }\n        break;\n      case Token.FOR:\n        if (NodeUtil.isForIn(parent)) {\n          return parent;\n        } else {\n          return parent.getFirstChild().getNext().getNext();\n        }\n      case Token.WHILE:\n      case Token.DO:\n        return parent;\n      case Token.TRY:\n        // If we are coming out of the TRY block...\n        if (parent.getFirstChild() == node) {\n          if (NodeUtil.hasFinally(parent)) { // and have FINALLY block.\n            return computeFallThrough(parent.getLastChild());\n          } else { // and have no FINALLY.\n            return computeFollowNode(fromNode, parent);\n          }\n        // CATCH block.\n        } else if (NodeUtil.getCatchBlock(parent) == node){\n          if (NodeUtil.hasFinally(parent)) { // and have FINALLY block.\n            return computeFallThrough(node.getNext());\n          } else {\n            return computeFollowNode(fromNode, parent);\n          }\n        // If we are coming out of the FINALLY block...\n        } else if (parent.getLastChild() == node){\n          for (Node finallyNode : finallyMap.get(parent)) {\n            createEdge(fromNode, Branch.UNCOND, finallyNode);\n          }\n          return computeFollowNode(fromNode, parent);\n        }\n    }\n\n    // Now that we are done with the special cases follow should be its\n    // immediate sibling, unless its sibling is a function\n    Node nextSibling = node.getNext();\n\n    // Skip function declarations because control doesn't get pass into it.\n    while (nextSibling != null && nextSibling.getType() == Token.FUNCTION) {\n      nextSibling = nextSibling.getNext();\n    }\n\n    if (nextSibling != null) {\n      return computeFallThrough(nextSibling);\n    } else {\n      // If there are no more siblings, control is transfered up the AST.\n      return computeFollowNode(fromNode, parent);\n    }\n  }",
    "comment": " Computes the follow() node of a given node and its parent. There is a side effect when calling this function. If this function computed an edge that exists a FINALLY, it'll attempt to connect the fromNode to the outer FINALLY according to the finallyMap.  @param fromNode The original source node since {@code node} is changed during recursion. @param node The node that follow() should compute. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "ControlFlowAnalysis.connectToPossibleExceptionHandler",
    "class_name": "com.google.javascript.jscomp.ControlFlowAnalysis",
    "signature": "com.google.javascript.jscomp.ControlFlowAnalysis.connectToPossibleExceptionHandler(Node,Node)",
    "snippet": "  private void connectToPossibleExceptionHandler(Node cfgNode, Node target) {\n    if (mayThrowException(target) && !exceptionHandler.isEmpty()) {\n      Node lastJump = cfgNode;\n      for (Node handler : exceptionHandler) {\n        if (NodeUtil.isFunction(handler)) {\n          return;\n        }\n        Preconditions.checkState(handler.getType() == Token.TRY);\n        Node catchBlock = NodeUtil.getCatchBlock(handler);\n\n        if (!NodeUtil.hasCatchHandler(catchBlock)) { // No catch but a FINALLY.\n          if (lastJump == cfgNode) {\n            createEdge(cfgNode, Branch.ON_EX, handler.getLastChild());\n          } else {\n            finallyMap.put(lastJump, handler.getLastChild());\n          }\n        } else { // Has a catch.\n          if (lastJump == cfgNode) {\n            createEdge(cfgNode, Branch.ON_EX, catchBlock);\n            return;\n          } else {\n            finallyMap.put(lastJump, catchBlock);\n          }\n        }\n        lastJump = handler;\n      }\n    }\n  }",
    "comment": " Connects cfgNode to the proper CATCH block if target subtree might throw an exception. If there are FINALLY blocks reached before a CATCH, it will make the corresponding entry in finallyMap. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "ControlFlowAnalysis.createEdge",
    "class_name": "com.google.javascript.jscomp.ControlFlowAnalysis",
    "signature": "com.google.javascript.jscomp.ControlFlowAnalysis.createEdge(Node,Branch,Node)",
    "snippet": "  private void createEdge(Node fromNode, ControlFlowGraph.Branch branch,\n      Node toNode) {\n    cfg.createNode(fromNode);\n    cfg.createNode(toNode);\n    cfg.connectIfNotFound(fromNode, branch, toNode);\n  }",
    "comment": " Connects the two nodes in the control flow graph.  @param fromNode Source. @param toNode Destination. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "ControlFlowAnalysis.getCfg",
    "class_name": "com.google.javascript.jscomp.ControlFlowAnalysis",
    "signature": "com.google.javascript.jscomp.ControlFlowAnalysis.getCfg()",
    "snippet": "  ControlFlowGraph<Node> getCfg() {\n    return cfg;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "ControlFlowAnalysis.handleExpr",
    "class_name": "com.google.javascript.jscomp.ControlFlowAnalysis",
    "signature": "com.google.javascript.jscomp.ControlFlowAnalysis.handleExpr(Node)",
    "snippet": "  private void handleExpr(Node node) {\n    createEdge(node, Branch.UNCOND, computeFollowNode(node));\n    connectToPossibleExceptionHandler(node, node);\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "ControlFlowAnalysis.handleStmt",
    "class_name": "com.google.javascript.jscomp.ControlFlowAnalysis",
    "signature": "com.google.javascript.jscomp.ControlFlowAnalysis.handleStmt(Node)",
    "snippet": "  private void handleStmt(Node node) {\n    // Simply transfer to the next line.\n    createEdge(node, Branch.UNCOND, computeFollowNode(node));\n    connectToPossibleExceptionHandler(node, node);\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "ControlFlowAnalysis.handleStmtList",
    "class_name": "com.google.javascript.jscomp.ControlFlowAnalysis",
    "signature": "com.google.javascript.jscomp.ControlFlowAnalysis.handleStmtList(Node)",
    "snippet": "  private void handleStmtList(Node node) {\n    Node parent = node.getParent();\n    // Special case, don't add a block of empty CATCH block to the graph.\n    if (node.getType() == Token.BLOCK && parent != null &&\n        parent.getType() == Token.TRY &&\n        NodeUtil.getCatchBlock(parent) == node &&\n        !NodeUtil.hasCatchHandler(node)) {\n      return;\n    }\n\n    // A block transfer control to its first child if it is not empty.\n    Node child = node.getFirstChild();\n\n    // Function declarations are skipped since control doesn't go into that\n    // function (unless it is called)\n    while (child != null && child.getType() == Token.FUNCTION) {\n      child = child.getNext();\n    }\n\n    if (child != null) {\n      createEdge(node, Branch.UNCOND, computeFallThrough(child));\n    } else {\n      createEdge(node, Branch.UNCOND, computeFollowNode(node));\n    }\n\n    // Synthetic blocks\n    if (parent != null) {\n      switch (parent.getType()) {\n        case Token.DEFAULT:\n        case Token.CASE:\n        case Token.TRY:\n          break;\n        default:\n          if (node.getType() == Token.BLOCK && node.isSyntheticBlock()) {\n            Node next = node.getLastChild();\n            if (next != null) {\n              createEdge(node, Branch.SYN_BLOCK, computeFallThrough(next));\n            }\n          }\n          break;\n      }\n    }\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "ControlFlowAnalysis.mayThrowException",
    "class_name": "com.google.javascript.jscomp.ControlFlowAnalysis",
    "signature": "com.google.javascript.jscomp.ControlFlowAnalysis.mayThrowException(Node)",
    "snippet": "  private static boolean mayThrowException(Node n) {\n    switch (n.getType()) {\n      case Token.CALL:\n      case Token.GETPROP:\n      case Token.GETELEM:\n      case Token.THROW:\n      case Token.NEW:\n      case Token.ASSIGN:\n      case Token.INC:\n      case Token.DEC:\n      case Token.INSTANCEOF:\n        return true;\n      case Token.FUNCTION:\n        return false;\n    }\n    for (Node c = n.getFirstChild(); c != null; c = c.getNext()) {\n      if (!ControlFlowGraph.isEnteringNewCfgNode(c) && mayThrowException(c)) {\n        return true;\n      }\n    }\n    return false;\n  }",
    "comment": " Determines if the subtree might throw an exception. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "ControlFlowAnalysis.prioritizeFromEntryNode",
    "class_name": "com.google.javascript.jscomp.ControlFlowAnalysis",
    "signature": "com.google.javascript.jscomp.ControlFlowAnalysis.prioritizeFromEntryNode(DiGraphNode)",
    "snippet": "  private void prioritizeFromEntryNode(DiGraphNode<Node, Branch> entry) {\n    PriorityQueue<DiGraphNode<Node, Branch>> worklist =\n        new PriorityQueue<DiGraphNode<Node, Branch>>(10, priorityComparator);\n    worklist.add(entry);\n\n    while (!worklist.isEmpty()) {\n      DiGraphNode<Node, Branch> current = worklist.remove();\n      if (nodePriorities.containsKey(current)) {\n        continue;\n      }\n\n      nodePriorities.put(current, ++priorityCounter);\n\n      List<DiGraphNode<Node, Branch>> successors =\n          cfg.getDirectedSuccNodes(current);\n      for (DiGraphNode<Node, Branch> candidate : successors) {\n        worklist.add(candidate);\n      }\n    }\n  }",
    "comment": " Given an entry node, find all the nodes reachable from that node and prioritize them. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "ControlFlowAnalysis.process",
    "class_name": "com.google.javascript.jscomp.ControlFlowAnalysis",
    "signature": "com.google.javascript.jscomp.ControlFlowAnalysis.process(Node,Node)",
    "snippet": "  @Override\n  public void process(Node externs, Node root) {\n    this.root = root;\n    astPositionCounter = 0;\n    astPosition = Maps.newHashMap();\n    nodePriorities = Maps.newHashMap();\n    cfg = new AstControlFlowGraph(computeFallThrough(root), nodePriorities);\n    NodeTraversal.traverse(compiler, root, this);\n    astPosition.put(null, ++astPositionCounter); // the implicit return is last.\n\n    // Now, generate the priority of nodes by doing a depth-first\n    // search on the CFG.\n    priorityCounter = 0;\n    DiGraphNode<Node, Branch> entry = cfg.getEntry();\n    prioritizeFromEntryNode(entry);\n\n    if (shouldTraverseFunctions) {\n      // If we're traversing inner functions, we need to rank the\n      // priority of them too.\n      for (DiGraphNode<Node, Branch> candidate : cfg.getDirectedGraphNodes()) {\n        Node value = candidate.getValue();\n        if (value != null && value.getType() == Token.FUNCTION) {\n          Preconditions.checkState(\n              !nodePriorities.containsKey(candidate) || candidate == entry);\n          prioritizeFromEntryNode(candidate);\n        }\n      }\n    }\n\n    // At this point, all reachable nodes have been given a priority, but\n    // unreachable nodes have not been given a priority. Put them last.\n    // Presumably, it doesn't really matter what priority they get, since\n    // this shouldn't happen in real code.\n    for (DiGraphNode<Node, Branch> candidate : cfg.getDirectedGraphNodes()) {\n      if (!nodePriorities.containsKey(candidate)) {\n        nodePriorities.put(candidate, ++priorityCounter);\n      }\n    }\n\n    // Again, the implicit return node is always last.\n    nodePriorities.put(cfg.getImplicitReturn(), ++priorityCounter);\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "ControlFlowAnalysis.shouldTraverse",
    "class_name": "com.google.javascript.jscomp.ControlFlowAnalysis",
    "signature": "com.google.javascript.jscomp.ControlFlowAnalysis.shouldTraverse(NodeTraversal,Node,Node)",
    "snippet": "  @Override\n  public boolean shouldTraverse(\n      NodeTraversal nodeTraversal, Node n, Node parent) {\n    astPosition.put(n, astPositionCounter++);\n\n    switch (n.getType()) {\n      case Token.FUNCTION:\n        if (shouldTraverseFunctions || n == cfg.getEntry().getValue()) {\n          exceptionHandler.push(n);\n          return true;\n        }\n        return false;\n      case Token.TRY:\n        exceptionHandler.push(n);\n        return true;\n    }\n\n    /*\n     * We are going to stop the traversal depending on what the node's parent\n     * is.\n     *\n     * We are only interested in adding edges between nodes that change control\n     * flow. The most obvious ones are loops and IF-ELSE's. A statement\n     * transfers control to its next sibling.\n     *\n     * In case of an expression tree, there is no control flow within the tree\n     * even when there are short circuited operators and conditionals. When we\n     * are doing data flow analysis, we will simply synthesize lattices up the\n     * expression tree by finding the meet at each expression node.\n     *\n     * For example: within a Token.SWITCH, the expression in question does not\n     * change the control flow and need not to be considered.\n     */\n    if (parent != null) {\n      switch (parent.getType()) {\n        case Token.FOR:\n          // Only traverse the body of the for loop.\n          return n == parent.getLastChild();\n\n        // Skip the conditions.\n        case Token.IF:\n        case Token.WHILE:\n        case Token.WITH:\n          return n != parent.getFirstChild();\n        case Token.DO:\n          return n != parent.getFirstChild().getNext();\n        // Only traverse the body of the cases\n        case Token.SWITCH:\n        case Token.CASE:\n        case Token.CATCH:\n        case Token.LABEL:\n          return n != parent.getFirstChild();\n        case Token.FUNCTION:\n          return n == parent.getFirstChild().getNext().getNext();\n        case Token.CONTINUE:\n        case Token.BREAK:\n        case Token.EXPR_RESULT:\n        case Token.VAR:\n        case Token.RETURN:\n        case Token.THROW:\n          return false;\n        case Token.TRY:\n          /* Just before we are about to visit the second child of the TRY node,\n           * we know that we will be visiting either the CATCH or the FINALLY.\n           * In other words, we know that the post order traversal of the TRY\n           * block has been finished, no more exceptions can be caught by the\n           * handler at this TRY block and should be taken out of the stack.\n           */\n          if (n == parent.getFirstChild().getNext()) {\n            Preconditions.checkState(exceptionHandler.peek() == parent);\n            exceptionHandler.pop();\n          }\n      }\n    }\n    return true;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "ControlFlowAnalysis.visit",
    "class_name": "com.google.javascript.jscomp.ControlFlowAnalysis",
    "signature": "com.google.javascript.jscomp.ControlFlowAnalysis.visit(NodeTraversal,Node,Node)",
    "snippet": "  @Override\n  public void visit(NodeTraversal t, Node n, Node parent) {\n    switch (n.getType()) {\n      case Token.IF:\n        handleIf(n);\n        return;\n      case Token.WHILE:\n        handleWhile(n);\n        return;\n      case Token.DO:\n        handleDo(n);\n        return;\n      case Token.FOR:\n        handleFor(n);\n        return;\n      case Token.SWITCH:\n        handleSwitch(n);\n        return;\n      case Token.CASE:\n        handleCase(n);\n        return;\n      case Token.DEFAULT:\n        handleDefault(n);\n        return;\n      case Token.BLOCK:\n      case Token.SCRIPT:\n        handleStmtList(n);\n        return;\n      case Token.FUNCTION:\n        handleFunction(n);\n        return;\n      case Token.EXPR_RESULT:\n        handleExpr(n);\n        return;\n      case Token.THROW:\n        handleThrow(n);\n        return;\n      case Token.TRY:\n        handleTry(n);\n        return;\n      case Token.CATCH:\n        handleCatch(n);\n        return;\n      case Token.BREAK:\n        handleBreak(n);\n        return;\n      case Token.CONTINUE:\n        handleContinue(n);\n        return;\n      case Token.RETURN:\n        handleReturn(n);\n        return;\n      case Token.WITH:\n        handleWith(n);\n        return;\n      case Token.LABEL:\n        return;\n      default:\n        handleStmt(n);\n        return;\n    }\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "ControlFlowGraph.ControlFlowGraph",
    "class_name": "com.google.javascript.jscomp.ControlFlowGraph",
    "signature": "com.google.javascript.jscomp.ControlFlowGraph.ControlFlowGraph(N)",
    "snippet": "  public ControlFlowGraph(N entry) {\n    implicitReturn = createDirectedGraphNode(null);\n    this.entry = createDirectedGraphNode(entry);\n  }",
    "comment": " Constructor. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "ControlFlowGraph.getEntry",
    "class_name": "com.google.javascript.jscomp.ControlFlowGraph",
    "signature": "com.google.javascript.jscomp.ControlFlowGraph.getEntry()",
    "snippet": "  public DiGraphNode<N, ControlFlowGraph.Branch> getEntry() {\n    return entry;\n  }",
    "comment": " Gets the entry point of the control flow graph. In general, this should be the beginning of the global script or beginning of a function.  @return The entry point. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "ControlFlowGraph.getImplicitReturn",
    "class_name": "com.google.javascript.jscomp.ControlFlowGraph",
    "signature": "com.google.javascript.jscomp.ControlFlowGraph.getImplicitReturn()",
    "snippet": "  public DiGraphNode<N, ControlFlowGraph.Branch> getImplicitReturn() {\n    return implicitReturn;\n  }",
    "comment": " Gets the implicit return node.  @return Return node. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "ControlFlowGraph.isEnteringNewCfgNode",
    "class_name": "com.google.javascript.jscomp.ControlFlowGraph",
    "signature": "com.google.javascript.jscomp.ControlFlowGraph.isEnteringNewCfgNode(Node)",
    "snippet": "  public static boolean isEnteringNewCfgNode(Node n) {\n    Node parent = n.getParent();\n    switch (parent.getType()) {\n      case Token.BLOCK:\n      case Token.SCRIPT:\n      case Token.TRY:\n      case Token.FINALLY:\n        return true;\n      case Token.FUNCTION:\n        // A function node represents the start of a function where the name\n        // is bleed into the local scope and parameters has been assigned\n        // to the formal argument names. The node includes the name of the\n        // function and the LP list since we assume the whole set up process\n        // is atomic without change in control flow. The next change of\n        // control is going into the function's body represent by the second\n        // child.\n        return n != parent.getFirstChild().getNext();\n      case Token.WHILE:\n      case Token.DO:\n      case Token.IF:\n        // Theses control structure is represented by its node that holds the\n        // condition. Each of them is a branch node based on its condition.\n        return NodeUtil.getConditionExpression(parent) != n;\n        \n      case Token.FOR:\n        // The FOR(;;) node differs from other control structure in that\n        // it has a initialization and a increment statement. Those\n        // two statements have its corresponding CFG nodes to represent them.\n        // The FOR node represents the condition check for each iteration.\n        // That way the following:\n        // for(var x = 0; x < 10; x++) { } has a graph that is isomorphic to\n        // var x = 0; while(x<10) {  x++; }\n        if (NodeUtil.isForIn(parent)) {\n          return n == parent.getLastChild(); \n        } else {\n          return NodeUtil.getConditionExpression(parent) != n;\n        }\n      case Token.SWITCH:\n      case Token.CASE:\n      case Token.CATCH:\n      case Token.WITH:\n        return n != parent.getFirstChild();\n      default:\n        return false;\n    }\n  }",
    "comment": " @return True if n should be represented by a new CFG node in the control flow graph. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "ControlStructureCheck.ControlStructureCheck",
    "class_name": "com.google.javascript.jscomp.ControlStructureCheck",
    "signature": "com.google.javascript.jscomp.ControlStructureCheck.ControlStructureCheck(AbstractCompiler)",
    "snippet": "  ControlStructureCheck(AbstractCompiler compiler) {\n    this.compiler = compiler;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "ControlStructureCheck.check",
    "class_name": "com.google.javascript.jscomp.ControlStructureCheck",
    "signature": "com.google.javascript.jscomp.ControlStructureCheck.check(Node)",
    "snippet": "  private void check(Node node) {\n    switch (node.getType()) {\n      case Token.WITH:\n        JSDocInfo info = node.getJSDocInfo();\n        boolean allowWith =\n            info != null && info.getSuppressions().contains(\"with\");\n        if (!allowWith) {\n          report(node, USE_OF_WITH);\n        }\n        break;\n\n      case Token.SCRIPT:\n        // Remember the source file name in case we need to report an error.\n        sourceName = (String) node.getProp(Node.SOURCENAME_PROP);\n        break;\n    }\n\n    for (Node bChild = node.getFirstChild(); bChild != null;) {\n      Node next = bChild.getNext();\n      check(bChild);\n      bChild = next;\n    }\n  }",
    "comment": " Reports errors for any invalid use of control structures.  @param node Current node to check. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "ControlStructureCheck.process",
    "class_name": "com.google.javascript.jscomp.ControlStructureCheck",
    "signature": "com.google.javascript.jscomp.ControlStructureCheck.process(Node,Node)",
    "snippet": "  @Override\n  public void process(Node externs, Node root) {\n    check(root);\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "ConvertToDottedProperties.ConvertToDottedProperties",
    "class_name": "com.google.javascript.jscomp.ConvertToDottedProperties",
    "signature": "com.google.javascript.jscomp.ConvertToDottedProperties.ConvertToDottedProperties(AbstractCompiler)",
    "snippet": "  ConvertToDottedProperties(AbstractCompiler compiler) {\n    this.compiler = compiler;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "ConvertToDottedProperties.process",
    "class_name": "com.google.javascript.jscomp.ConvertToDottedProperties",
    "signature": "com.google.javascript.jscomp.ConvertToDottedProperties.process(Node,Node)",
    "snippet": "  public void process(Node externs, Node root) {\n    NodeTraversal.traverse(compiler, root, this);\n  }",
    "comment": "{@inheritDoc} */",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "ConvertToDottedProperties.visit",
    "class_name": "com.google.javascript.jscomp.ConvertToDottedProperties",
    "signature": "com.google.javascript.jscomp.ConvertToDottedProperties.visit(NodeTraversal,Node,Node)",
    "snippet": "  public void visit(NodeTraversal t, Node n, Node parent) {\n    switch (n.getType()) {\n      case Token.GETELEM:\n        Node left = n.getFirstChild();\n        Node right = left.getNext();\n        if (right.getType() == Token.STRING &&\n            NodeUtil.isValidPropertyName(right.getString())) {\n          n.removeChild(left);\n          n.removeChild(right);\n          parent.replaceChild(n, new Node(Token.GETPROP, left, right));\n          compiler.reportCodeChange();\n        }\n        break;\n    }\n  }",
    "comment": "{@inheritDoc} */",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "DeadAssignmentsElimination.DeadAssignmentsElimination",
    "class_name": "com.google.javascript.jscomp.DeadAssignmentsElimination",
    "signature": "com.google.javascript.jscomp.DeadAssignmentsElimination.DeadAssignmentsElimination(AbstractCompiler)",
    "snippet": "  public DeadAssignmentsElimination(AbstractCompiler compiler) {\n    this.compiler = compiler;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "DeadAssignmentsElimination.enterScope",
    "class_name": "com.google.javascript.jscomp.DeadAssignmentsElimination",
    "signature": "com.google.javascript.jscomp.DeadAssignmentsElimination.enterScope(NodeTraversal)",
    "snippet": "  @Override\n  public void enterScope(NodeTraversal t) {\n    Scope scope = t.getScope();\n    // Global scope _SHOULD_ work, however, liveness won't finish without\n    // -Xmx1024 in closure. We might have to look at coding conventions for\n    // exported variables as well.\n    if (scope.isGlobal()) {\n      return;\n    }\n    \n    // We are not going to do any dead assignment elimination in when there is\n    // at least one inner function because in most browsers, when there is a\n    // closure, ALL the variables are saved (escaped).\n    if (!NodeUtil.containsFunctionDeclaration(\n        t.getScopeRoot().getLastChild())) {\n      // Computes liveness information first.\n      ControlFlowGraph<Node> cfg = t.getControlFlowGraph();\n      liveness = new LiveVariablesAnalysis(cfg, scope, compiler);\n      liveness.analyze();\n      tryRemoveDeadAssignments(t, cfg);\n    }\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "DeadAssignmentsElimination.exitScope",
    "class_name": "com.google.javascript.jscomp.DeadAssignmentsElimination",
    "signature": "com.google.javascript.jscomp.DeadAssignmentsElimination.exitScope(NodeTraversal)",
    "snippet": "  @Override\n  public void exitScope(NodeTraversal t) {\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "DeadAssignmentsElimination.process",
    "class_name": "com.google.javascript.jscomp.DeadAssignmentsElimination",
    "signature": "com.google.javascript.jscomp.DeadAssignmentsElimination.process(Node,Node)",
    "snippet": "  @Override\n  public void process(Node externs, Node root) {\n    Preconditions.checkNotNull(externs);\n    Preconditions.checkNotNull(root);\n    NodeTraversal.traverse(compiler, root, this);\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "DeadAssignmentsElimination.visit",
    "class_name": "com.google.javascript.jscomp.DeadAssignmentsElimination",
    "signature": "com.google.javascript.jscomp.DeadAssignmentsElimination.visit(NodeTraversal,Node,Node)",
    "snippet": "  @Override\n  public void visit(NodeTraversal t, Node n, Node parent) {\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "DefaultCodingConvention.isConstant",
    "class_name": "com.google.javascript.jscomp.DefaultCodingConvention",
    "signature": "com.google.javascript.jscomp.DefaultCodingConvention.isConstant(String)",
    "snippet": "  @Override\n  public boolean isConstant(String variableName) {\n    return false;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "DefaultCodingConvention.isExported",
    "class_name": "com.google.javascript.jscomp.DefaultCodingConvention",
    "signature": "com.google.javascript.jscomp.DefaultCodingConvention.isExported(String,boolean)",
    "snippet": "  @Override\n  public boolean isExported(String name, boolean local) {\n    return local && name.startsWith(\"$super\");\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "DefaultPassConfig.DefaultPassConfig",
    "class_name": "com.google.javascript.jscomp.DefaultPassConfig",
    "signature": "com.google.javascript.jscomp.DefaultPassConfig.DefaultPassConfig(CompilerOptions)",
    "snippet": "  public DefaultPassConfig(CompilerOptions options) {\n    super(options);\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "DefaultPassConfig.assertAllLoopablePasses",
    "class_name": "com.google.javascript.jscomp.DefaultPassConfig",
    "signature": "com.google.javascript.jscomp.DefaultPassConfig.assertAllLoopablePasses(List)",
    "snippet": "  private void assertAllLoopablePasses(List<PassFactory> passes) {\n    for (PassFactory pass : passes) {\n      Preconditions.checkState(!pass.isOneTimePass());\n    }\n  }",
    "comment": "Verify that all the passes are multi-run passes. */",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "DefaultPassConfig.assertAllOneTimePasses",
    "class_name": "com.google.javascript.jscomp.DefaultPassConfig",
    "signature": "com.google.javascript.jscomp.DefaultPassConfig.assertAllOneTimePasses(List)",
    "snippet": "  private void assertAllOneTimePasses(List<PassFactory> passes) {\n    for (PassFactory pass : passes) {\n      Preconditions.checkState(pass.isOneTimePass());\n    }\n  }",
    "comment": "Verify that all the passes are one-time passes. */",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "DefaultPassConfig.combineChecks",
    "class_name": "com.google.javascript.jscomp.DefaultPassConfig",
    "signature": "com.google.javascript.jscomp.DefaultPassConfig.combineChecks(AbstractCompiler,List)",
    "snippet": "  private static CompilerPass combineChecks(AbstractCompiler compiler,\n      List<Callback> callbacks) {\n    Preconditions.checkArgument(callbacks.size() > 0);\n    Callback[] array = callbacks.toArray(new Callback[callbacks.size()]);\n    return new CombinedCompilerPass(compiler, array);\n  }",
    "comment": "Executes the given callbacks with a {@link CombinedCompilerPass}. */",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "DefaultPassConfig.createEmptyPass",
    "class_name": "com.google.javascript.jscomp.DefaultPassConfig",
    "signature": "com.google.javascript.jscomp.DefaultPassConfig.createEmptyPass(String)",
    "snippet": "  private static PassFactory createEmptyPass(String name) {\n    return new PassFactory(name, true) {\n      @Override\n      protected CompilerPass createInternal(final AbstractCompiler compiler) {\n        return runInSerial();\n      }\n    };\n  }",
    "comment": " Create a no-op pass that can only run once. Used to break up loops. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "DefaultPassConfig.getAdditionalReplacements",
    "class_name": "com.google.javascript.jscomp.DefaultPassConfig",
    "signature": "com.google.javascript.jscomp.DefaultPassConfig.getAdditionalReplacements(CompilerOptions)",
    "snippet": "  @VisibleForTesting\n  static Map<String, Node> getAdditionalReplacements(\n      CompilerOptions options) {\n    Map<String, Node> additionalReplacements = Maps.newHashMap();\n\n    if (options.markAsCompiled || options.closurePass) {\n      additionalReplacements.put(COMPILED_CONSTANT_NAME, new Node(Token.TRUE));\n    }\n\n    if (options.closurePass && options.locale != null) {\n      additionalReplacements.put(CLOSURE_LOCALE_CONSTANT_NAME,\n          Node.newString(options.locale));\n    }\n\n    return additionalReplacements;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "DefaultPassConfig.getChecks",
    "class_name": "com.google.javascript.jscomp.DefaultPassConfig",
    "signature": "com.google.javascript.jscomp.DefaultPassConfig.getChecks()",
    "snippet": "  @Override\n  protected List<PassFactory> getChecks() {\n    List<PassFactory> checks = Lists.newArrayList();\n\n    if (options.nameAnonymousFunctionsOnly) {\n      if (options.anonymousFunctionNaming ==\n          AnonymousFunctionNamingPolicy.MAPPED) {\n        checks.add(nameMappedAnonymousFunctions);\n      } else if (options.anonymousFunctionNaming ==\n          AnonymousFunctionNamingPolicy.UNMAPPED) {\n        checks.add(nameUnmappedAnonymousFunctions);\n      }\n      return checks;\n    }\n\n    if (options.checkSuspiciousCode) {\n      checks.add(suspiciousCode);\n    }\n\n    if (options.checkControlStructures)  {\n      checks.add(checkControlStructures);\n    }\n\n    if (options.checkRequires.isOn()) {\n      checks.add(checkRequires);\n    }\n\n    if (options.checkProvides.isOn()) {\n      checks.add(checkProvides);\n    }\n\n    // The following passes are more like \"preprocessor\" passes.\n    // It's important that they run before most checking passes.\n    // Perhaps this method should be renamed?\n    if (options.generateExports) {\n      checks.add(generateExports);\n    }\n\n    if (options.exportTestFunctions) {\n      checks.add(exportTestFunctions);\n    }\n\n    if (options.closurePass) {\n      checks.add(closurePrimitives.makeOneTimePass());\n    }\n\n    if (options.closurePass && options.checkMissingGetCssNameLevel.isOn()) {\n      checks.add(closureCheckGetCssName);\n    }\n\n    if (options.closurePass) {\n      checks.add(closureReplaceGetCssName);\n    }\n\n    if (options.syntheticBlockStartMarker != null) {\n      // This pass must run before the first fold constants pass.\n      checks.add(createSyntheticBlocks);\n    }\n\n    // All passes must run the variable check. This synthesizes\n    // variables later so that the compiler doesn't crash. It also\n    // checks the externs file for validity. If you don't want to warn\n    // about missing variable declarations, we shut that specific\n    // error off.\n    WarningsGuard warningsGuard = options.getWarningsGuard();\n    if (!options.checkSymbols &&\n        (warningsGuard == null || !warningsGuard.disables(\n            DiagnosticGroups.CHECK_VARIABLES))) {\n      options.setWarningLevel(DiagnosticGroups.CHECK_VARIABLES,\n          CheckLevel.OFF);\n    }\n\n    checks.add(checkVars);\n\n    if (options.checkShadowVars.isOn()) {\n      checks.add(checkShadowVars);\n    }\n\n    if (options.aggressiveVarCheck.isOn()) {\n      checks.add(checkVariableReferences);\n    }\n\n    // This pass should run before types are assigned.\n    if (options.processObjectPropertyString) {\n      checks.add(objectPropertyStringPreprocess);\n    }\n\n    // DiagnosticGroups override the plain checkTypes option.\n    if (options.enables(DiagnosticGroups.CHECK_TYPES)) {\n      options.checkTypes = true;\n    } else if (options.disables(DiagnosticGroups.CHECK_TYPES)) {\n      options.checkTypes = false;\n    }\n\n    // Type-checking already does more accurate method arity checking, so don't\n    // do legacy method arity checking unless checkTypes is OFF.\n    if (options.checkTypes) {\n      checks.add(resolveTypes.makeOneTimePass());\n      checks.add(inferTypes.makeOneTimePass());\n      checks.add(checkTypes.makeOneTimePass());\n    } else {\n      if (options.checkFunctions.isOn()) {\n        checks.add(checkFunctions);\n      }\n\n      if (options.checkMethods.isOn()) {\n        checks.add(checkMethods);\n      }\n    }\n\n    if (options.checkUnreachableCode.isOn() ||\n        (options.checkTypes && options.checkMissingReturn.isOn())) {\n      checks.add(checkControlFlow);\n    }\n\n    // CheckAccessControls only works if check types is on.\n    if (options.enables(DiagnosticGroups.ACCESS_CONTROLS)\n        && options.checkTypes) {\n      checks.add(checkAccessControls);\n    }\n\n    if (options.checkGlobalNamesLevel.isOn()) {\n      checks.add(checkGlobalNames);\n    }\n\n    if (options.checkUndefinedProperties.isOn() ||\n        options.checkUnusedPropertiesEarly) {\n      checks.add(checkSuspiciousProperties);\n    }\n\n    if (options.checkCaja || options.checkEs5Strict) {\n      checks.add(checkStrictMode);\n    }\n\n    // Defines in code always need to be processed.\n    checks.add(processDefines);\n\n    if (options.instrumentationTemplate != null ||\n        options.recordFunctionInformation) {\n      checks.add(computeFunctionNames);\n    }\n\n    assertAllOneTimePasses(checks);\n    return checks;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "DefaultPassConfig.getCodeRemovingPasses",
    "class_name": "com.google.javascript.jscomp.DefaultPassConfig",
    "signature": "com.google.javascript.jscomp.DefaultPassConfig.getCodeRemovingPasses()",
    "snippet": "  private List<PassFactory> getCodeRemovingPasses() {\n    List<PassFactory> passes = Lists.newArrayList();\n    if (options.inlineVariables || options.inlineLocalVariables) {\n      passes.add(inlineVariables);\n    } else if (options.inlineConstantVars) {\n      passes.add(inlineConstants);\n    }\n\n    if (options.removeConstantExpressions) {\n      passes.add(removeConstantExpressions);\n    }\n\n    if (options.foldConstants) {\n      // These used to be one pass.\n      passes.add(minimizeExitPoints);\n      passes.add(foldConstants);\n    }\n\n    if (options.removeDeadCode) {\n      passes.add(removeUnreachableCode);\n    }\n\n    if (options.removeUnusedPrototypeProperties) {\n      passes.add(removeUnusedPrototypeProperties);\n    }\n\n    assertAllLoopablePasses(passes);\n    return passes;\n  }",
    "comment": "Creates several passes aimed at removing code. */",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "DefaultPassConfig.getIntermediateState",
    "class_name": "com.google.javascript.jscomp.DefaultPassConfig",
    "signature": "com.google.javascript.jscomp.DefaultPassConfig.getIntermediateState()",
    "snippet": "  @Override\n  State getIntermediateState() {\n    return new State(\n        cssNames == null ? null : Maps.newHashMap(cssNames),\n        exportedNames == null ? null :\n            Collections.unmodifiableSet(exportedNames),\n        crossModuleIdGenerator, variableMap, propertyMap,\n        anonymousFunctionNameMap, functionNames);\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "DefaultPassConfig.getMainOptimizationLoop",
    "class_name": "com.google.javascript.jscomp.DefaultPassConfig",
    "signature": "com.google.javascript.jscomp.DefaultPassConfig.getMainOptimizationLoop()",
    "snippet": "  private List<PassFactory> getMainOptimizationLoop() {\n    List<PassFactory> passes = Lists.newArrayList();\n    if (options.inlineGetters) {\n      passes.add(inlineGetters);\n    }\n\n    passes.addAll(getCodeRemovingPasses());\n\n    if (options.inlineFunctions || options.inlineLocalFunctions) {\n      passes.add(inlineFunctions);\n    }\n\n    if (options.removeUnusedVars) {\n      if (options.deadAssignmentElimination) {\n        passes.add(deadAssignmentsElimination);\n      }\n      passes.add(removeUnusedVars);\n    }\n    assertAllLoopablePasses(passes);\n    return passes;\n  }",
    "comment": "Creates the passes for the main optimization loop. */",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "DefaultPassConfig.getOptimizations",
    "class_name": "com.google.javascript.jscomp.DefaultPassConfig",
    "signature": "com.google.javascript.jscomp.DefaultPassConfig.getOptimizations()",
    "snippet": "  @Override\n  protected List<PassFactory> getOptimizations() {\n    List<PassFactory> passes = Lists.newArrayList();\n\n    // TODO(nicksantos): The order of these passes makes no sense, and needs\n    // to be re-arranged.\n\n    if (options.runtimeTypeCheck) {\n      passes.add(runtimeTypeCheck);\n    }\n\n    passes.add(createEmptyPass(\"beforeStandardOptimizations\"));\n\n    if (!options.idGenerators.isEmpty()) {\n      passes.add(replaceIdGenerators);\n    }\n\n    // Optimizes references to the arguments variable.\n    if (options.optimizeArgumentsArray) {\n      passes.add(optimizeArgumentsArray);\n    }\n\n    // Remove all parameters that are constants or unused.\n    if (options.optimizeParameters) {\n      passes.add(removeUselessParameters);\n    }\n\n    // Abstract method removal works best on minimally modified code, and also\n    // only needs to run once.\n    if (options.closurePass && options.removeAbstractMethods) {\n      passes.add(removeAbstractMethods);\n    }\n\n    // Collapsing properties can undo constant inlining, so we do this before\n    // the main optimization loop.\n    if (options.collapseProperties) {\n      passes.add(collapseProperties);\n    }\n\n    // Tighten types based on actual usage.\n    if (options.tightenTypes) {\n      passes.add(tightenTypesBuilder);\n    }\n\n    // Property disambiguation should only run once and needs to be done\n    // soon after type checking, both so that it can make use of type\n    // information and so that other passes can take advantage of the renamed\n    // properties.\n    if (options.disambiguateProperties) {\n      passes.add(disambiguateProperties);\n    }\n\n    if (options.computeFunctionSideEffects) {\n      passes.add(markPureFunctions);\n    } else if (options.markNoSideEffectCalls) {\n      // TODO(user) The properties that this pass adds to CALL and NEW\n      // AST nodes increase the AST's in-memory size.  Given that we are\n      // already running close to our memory limits, we could run into\n      // trouble if we end up using the @nosideeffects annotation a lot\n      // or compute @nosideeffects annotations by looking at function\n      // bodies.  It should be easy to propagate @nosideeffects\n      // annotations as part of passes that depend on this property and\n      // store the result outside the AST (which would allow garbage\n      // collection once the pass is done).\n      passes.add(markNoSideEffectCalls);\n    }\n\n    if (options.chainCalls) {\n      passes.add(chainCalls);\n    }\n\n    // Constant checking must be done after property collapsing because\n    // property collapsing can introduce new constants (e.g. enum values).\n    if (options.inlineConstantVars) {\n      passes.add(checkConsts);\n    }\n\n    // The Caja library adds properties to Object.prototype, which breaks\n    // most for-in loops.  This adds a check to each loop that skips\n    // any property matching /___$/.\n    if (options.ignoreCajaProperties) {\n      passes.add(ignoreCajaProperties);\n    }\n\n    assertAllOneTimePasses(passes);\n\n    if (options.smartNameRemoval || options.reportPath != null) {\n      passes.addAll(getCodeRemovingPasses());\n      passes.add(smartNamePass);\n    }\n\n    // TODO(user): This forces a first crack at crossModuleCodeMotion\n    // before devirtualization. Once certain functions are devirtualized,\n    // it confuses crossModuleCodeMotion ability to recognized that\n    // it is recursive.\n\n    // TODO(user): This is meant for a temporary quick win.\n    // In the future, we might want to improve our analysis in\n    // CrossModuleCodeMotion so we don't need to do this.\n    if (options.crossModuleCodeMotion) {\n      passes.add(crossModuleCodeMotion);\n    }\n\n    // Method devirtualization benefits from property disambiguiation so\n    // it should run after that pass but before passes that do\n    // optimizations based on global names (like cross module code motion\n    // and inline functions).  Smart Name Removal does better if run before\n    // this pass.\n    if (options.devirtualizePrototypeMethods) {\n      passes.add(devirtualizePrototypeMethods);\n    }\n\n    if (options.customPasses != null) {\n      passes.add(getCustomPasses(\n          CustomPassExecutionTime.BEFORE_OPTIMIZATION_LOOP));\n    }\n\n    passes.add(createEmptyPass(\"beforeMainOptimizations\"));\n\n    passes.addAll(getMainOptimizationLoop());\n\n    passes.add(createEmptyPass(\"beforeModuleMotion\"));\n\n    if (options.crossModuleCodeMotion) {\n      passes.add(crossModuleCodeMotion);\n    }\n\n    if (options.crossModuleMethodMotion) {\n      passes.add(crossModuleMethodMotion);\n    }\n\n    passes.add(createEmptyPass(\"afterModuleMotion\"));\n\n    // Some optimizations belong outside the loop because running them more\n    // than once would either have no benefit or be incorrect.\n    if (options.customPasses != null) {\n      passes.add(getCustomPasses(\n          CustomPassExecutionTime.AFTER_OPTIMIZATION_LOOP));\n    }\n\n    if (options.flowSensitiveInlineVariables) {\n      passes.add(flowSensitiveInlineVariables);\n\n      // After inlining some of the variable uses, some variables are unused.\n      // Re-run remove unused vars to clean it up.\n      if (options.removeUnusedVars) {\n        passes.add(removeUnusedVars);\n      }\n    }\n\n    if (options.collapseAnonymousFunctions) {\n      passes.add(collapseAnonymousFunctions);\n    }\n\n    // Move functions before extracting prototype member declarations.\n    if (options.moveFunctionDeclarations) {\n      passes.add(moveFunctionDeclarations);\n    }\n\n    if (options.anonymousFunctionNaming ==\n        AnonymousFunctionNamingPolicy.MAPPED) {\n      passes.add(nameMappedAnonymousFunctions);\n    }\n\n    // The mapped name anonymous function pass makes use of information that\n    // the extract prototype member declarations pass removes so the former\n    // happens before the latter.\n    //\n    // Extracting prototype properties screws up the heuristic renaming\n    // policies, so never run it when those policies are requested.\n    if (options.extractPrototypeMemberDeclarations &&\n        (options.propertyRenaming != PropertyRenamingPolicy.HEURISTIC &&\n         options.propertyRenaming !=\n            PropertyRenamingPolicy.AGGRESSIVE_HEURISTIC)) {\n      passes.add(extractPrototypeMemberDeclarations);\n    }\n\n    if (options.coalesceVariableNames) {\n      passes.add(coalesceVariableNames);\n    }\n\n    if (options.ambiguateProperties &&\n        (options.propertyRenaming == PropertyRenamingPolicy.ALL_UNQUOTED)) {\n      passes.add(ambiguateProperties);\n    }\n\n    if (options.propertyRenaming != PropertyRenamingPolicy.OFF) {\n      passes.add(renameProperties);\n    }\n\n    // Reserve global names added to the \"windows\" object.\n    if (options.reserveRawExports) {\n      passes.add(gatherRawExports);\n    }\n\n    // This comes after property renaming because quoted property names must\n    // not be renamed.\n    if (options.convertToDottedProperties) {\n      passes.add(convertToDottedProperties);\n    }\n\n    // Property renaming must happen before this pass runs since this\n    // pass may convert dotted properties into quoted properties.  It\n    // is beneficial to run before alias strings, alias keywords and\n    // variable renaming.\n    if (options.rewriteFunctionExpressions) {\n      passes.add(rewriteFunctionExpressions);\n    }\n\n    // This comes after converting quoted property accesses to dotted property\n    // accesses in order to avoid aliasing property names.\n    if (!options.aliasableStrings.isEmpty() || options.aliasAllStrings) {\n      passes.add(aliasStrings);\n    }\n\n    if (options.aliasExternals) {\n      passes.add(aliasExternals);\n    }\n\n    if (options.aliasKeywords) {\n      passes.add(aliasKeywords);\n    }\n\n    if (options.collapseVariableDeclarations) {\n      passes.add(collapseVariableDeclarations);\n    }\n\n    passes.add(denormalize);\n\n    if (options.instrumentationTemplate != null) {\n      passes.add(instrumentFunctions);\n    }\n\n    if (options.variableRenaming != VariableRenamingPolicy.ALL) {\n      // If we're leaving some (or all) variables with their old names,\n      // then we need to undo any of the markers we added for distinguishing\n      // local variables (\"$$1\").\n      passes.add(invertContextualRenaming);\n    }\n\n\n    if (options.variableRenaming != VariableRenamingPolicy.OFF) {\n      passes.add(renameVars);\n    }\n\n    // This pass should run after names stop changing.\n    if (options.processObjectPropertyString) {\n      passes.add(objectPropertyStringPostprocess);\n    }\n\n    if (options.labelRenaming) {\n      passes.add(renameLabels);\n    }\n\n    if (options.anonymousFunctionNaming ==\n        AnonymousFunctionNamingPolicy.UNMAPPED) {\n      passes.add(nameUnmappedAnonymousFunctions);\n    }\n\n    // Safety check\n    if (options.checkSymbols) {\n      passes.add(sanityCheckVars);\n    }\n\n    return passes;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "DefaultPassConfig.isInliningForbidden",
    "class_name": "com.google.javascript.jscomp.DefaultPassConfig",
    "signature": "com.google.javascript.jscomp.DefaultPassConfig.isInliningForbidden()",
    "snippet": "  private boolean isInliningForbidden() {\n    return options.propertyRenaming == PropertyRenamingPolicy.HEURISTIC ||\n        options.propertyRenaming ==\n            PropertyRenamingPolicy.AGGRESSIVE_HEURISTIC;\n  }",
    "comment": " All inlining is forbidden in heuristic renaming mode, because inlining will ruin the invariants that it depends on. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "DefaultPassConfig.runInSerial",
    "class_name": "com.google.javascript.jscomp.DefaultPassConfig",
    "signature": "com.google.javascript.jscomp.DefaultPassConfig.runInSerial(Collection)",
    "snippet": "  private static CompilerPass runInSerial(\n      final Collection<CompilerPass> passes) {\n    return new CompilerPass() {\n      @Override public void process(Node externs, Node root) {\n        for (CompilerPass pass : passes) {\n          pass.process(externs, root);\n        }\n      }\n    };\n  }",
    "comment": "Create a compiler pass that runs the given passes in serial. */",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "DefaultPassConfig.runInSerial",
    "class_name": "com.google.javascript.jscomp.DefaultPassConfig",
    "signature": "com.google.javascript.jscomp.DefaultPassConfig.runInSerial(CompilerPass[])",
    "snippet": "  private static CompilerPass runInSerial(final CompilerPass ... passes) {\n    return runInSerial(Lists.newArrayList(passes));\n  }",
    "comment": "Create a compiler pass that runs the given passes in serial. */",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "DefaultPassConfig.runVariableRenaming",
    "class_name": "com.google.javascript.jscomp.DefaultPassConfig",
    "signature": "com.google.javascript.jscomp.DefaultPassConfig.runVariableRenaming(AbstractCompiler,VariableMap,Node,Node)",
    "snippet": "  private VariableMap runVariableRenaming(\n      AbstractCompiler compiler, VariableMap prevVariableMap,\n      Node externs, Node root) {\n    char[] reservedChars =\n        options.anonymousFunctionNaming.getReservedCharacters();\n    boolean preserveAnonymousFunctionNames =\n        options.anonymousFunctionNaming != AnonymousFunctionNamingPolicy.OFF;\n    RenameVars rn = new RenameVars(\n        compiler,\n        options.renamePrefix,\n        options.variableRenaming == VariableRenamingPolicy.LOCAL,\n        preserveAnonymousFunctionNames,\n        options.generatePseudoNames,\n        prevVariableMap,\n        reservedChars,\n        exportedNames);\n    rn.process(externs, root);\n    return rn.getVariableMap();\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "Denormalize.Denormalize",
    "class_name": "com.google.javascript.jscomp.Denormalize",
    "signature": "com.google.javascript.jscomp.Denormalize.Denormalize(AbstractCompiler)",
    "snippet": "  Denormalize(AbstractCompiler compiler) {\n    this.compiler = compiler;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "Denormalize.maybeCollapseIntoForStatements",
    "class_name": "com.google.javascript.jscomp.Denormalize",
    "signature": "com.google.javascript.jscomp.Denormalize.maybeCollapseIntoForStatements(Node,Node)",
    "snippet": "  private void maybeCollapseIntoForStatements(Node n, Node parent) {\n    // Only SCRIPT, BLOCK, and LABELs can have FORs that can be collapsed into.\n    // LABELs are not supported here.\n    if (parent == null || !NodeUtil.isStatementBlock(parent)) {\n      return;\n    }\n\n    // Is the current node something that can be in a for loop initializer?\n    if (!NodeUtil.isExpressionNode(n) && !NodeUtil.isVar(n)) {\n      return;\n    }\n\n    // Is the next statement a valid FOR?\n    Node nextSibling = n.getNext();\n    if (nextSibling != null\n        && nextSibling.getType() == Token.FOR\n        && !NodeUtil.isForIn(nextSibling)\n        && nextSibling.getFirstChild().getType() == Token.EMPTY) {\n\n      // Does the current node contain an in operator?  If so, embedding\n      // the expression in a for loop can cause some Javascript parsers (such\n      // as the Playstation 3's browser based on Access's NetFront\n      // browser) to fail to parse the code.\n      // See bug 1778863 for details.\n      if (NodeUtil.containsType(n, Token.IN)) {\n        return;\n      }\n\n      // Move the current node into the FOR loop initializer.\n      Node forNode = nextSibling;\n      Node oldInitializer = forNode.getFirstChild();\n      parent.removeChild(n);\n\n      Node newInitializer;\n      if (NodeUtil.isVar(n)) {\n        newInitializer = n;\n      } else {\n        // Extract the expression from EXPR_RESULT node.\n        Preconditions.checkState(n.hasOneChild());\n        newInitializer = n.getFirstChild();\n        n.removeChild(newInitializer);\n      }\n\n      forNode.replaceChild(oldInitializer, newInitializer);\n\n      compiler.reportCodeChange();\n    }\n  }",
    "comment": " Collapse VARs and EXPR_RESULT node into FOR loop initializers where possible. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "Denormalize.process",
    "class_name": "com.google.javascript.jscomp.Denormalize",
    "signature": "com.google.javascript.jscomp.Denormalize.process(Node,Node)",
    "snippet": "  @Override\n  public void process(Node externs, Node root) {\n    NodeTraversal.traverse(compiler, root, this);\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "Denormalize.shouldTraverse",
    "class_name": "com.google.javascript.jscomp.Denormalize",
    "signature": "com.google.javascript.jscomp.Denormalize.shouldTraverse(NodeTraversal,Node,Node)",
    "snippet": "  @Override\n  public boolean shouldTraverse(NodeTraversal t, Node n, Node parent) {\n    return true;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "Denormalize.visit",
    "class_name": "com.google.javascript.jscomp.Denormalize",
    "signature": "com.google.javascript.jscomp.Denormalize.visit(NodeTraversal,Node,Node)",
    "snippet": "  @Override\n  public void visit(NodeTraversal t, Node n, Node parent) {\n    maybeCollapseIntoForStatements(n, parent);\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "DiagnosticGroup.DiagnosticGroup",
    "class_name": "com.google.javascript.jscomp.DiagnosticGroup",
    "signature": "com.google.javascript.jscomp.DiagnosticGroup.DiagnosticGroup(DiagnosticGroup[])",
    "snippet": "  public DiagnosticGroup(DiagnosticGroup ...groups) {\n    Set<DiagnosticType> set = Sets.newHashSet();\n\n    for (DiagnosticGroup group : groups) {\n      set.addAll(group.types);\n    }\n\n    this.types = ImmutableSet.copyOf(set);\n  }",
    "comment": " Create a composite group. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "DiagnosticGroup.DiagnosticGroup",
    "class_name": "com.google.javascript.jscomp.DiagnosticGroup",
    "signature": "com.google.javascript.jscomp.DiagnosticGroup.DiagnosticGroup(DiagnosticType[])",
    "snippet": "  public DiagnosticGroup(DiagnosticType ...types) {\n    this.types = ImmutableSet.copyOf(Arrays.asList(types));\n  }",
    "comment": " Create a group that matches all errors of the given types. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "DiagnosticGroup.forType",
    "class_name": "com.google.javascript.jscomp.DiagnosticGroup",
    "signature": "com.google.javascript.jscomp.DiagnosticGroup.forType(DiagnosticType)",
    "snippet": "  static DiagnosticGroup forType(DiagnosticType type) {\n    if (!singletons.containsKey(type)) {\n      singletons.put(type, new DiagnosticGroup(type));\n    }\n    return singletons.get(type);\n  }",
    "comment": "Create a diagnostic group that matches only the given type. */",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "DiagnosticGroup.getTypes",
    "class_name": "com.google.javascript.jscomp.DiagnosticGroup",
    "signature": "com.google.javascript.jscomp.DiagnosticGroup.getTypes()",
    "snippet": "  Collection<DiagnosticType> getTypes() {\n    return types;\n  }",
    "comment": " Returns an iterator over all the types in this group. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "DiagnosticGroup.isSubGroup",
    "class_name": "com.google.javascript.jscomp.DiagnosticGroup",
    "signature": "com.google.javascript.jscomp.DiagnosticGroup.isSubGroup(DiagnosticGroup)",
    "snippet": "  boolean isSubGroup(DiagnosticGroup group) {\n    for (DiagnosticType type : group.types) {\n      if (!matches(type)) {\n        return false;\n      }\n    }\n    return true;\n  }",
    "comment": " Returns whether all of the types in the given group are in this group. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "DiagnosticGroup.matches",
    "class_name": "com.google.javascript.jscomp.DiagnosticGroup",
    "signature": "com.google.javascript.jscomp.DiagnosticGroup.matches(DiagnosticType)",
    "snippet": "  public boolean matches(DiagnosticType type) {\n    return types.contains(type);\n  }",
    "comment": " Returns whether the given type matches a type in this group. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "DiagnosticGroupWarningsGuard.DiagnosticGroupWarningsGuard",
    "class_name": "com.google.javascript.jscomp.DiagnosticGroupWarningsGuard",
    "signature": "com.google.javascript.jscomp.DiagnosticGroupWarningsGuard.DiagnosticGroupWarningsGuard(DiagnosticGroup,CheckLevel)",
    "snippet": "  public DiagnosticGroupWarningsGuard(\n      DiagnosticGroup group, CheckLevel level) {\n    this.group = group;\n    this.level = level;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "DiagnosticGroupWarningsGuard.disables",
    "class_name": "com.google.javascript.jscomp.DiagnosticGroupWarningsGuard",
    "signature": "com.google.javascript.jscomp.DiagnosticGroupWarningsGuard.disables(DiagnosticGroup)",
    "snippet": "  @Override\n  public boolean disables(DiagnosticGroup otherGroup) {\n    return !level.isOn() && group.isSubGroup(otherGroup);\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "DiagnosticGroupWarningsGuard.enables",
    "class_name": "com.google.javascript.jscomp.DiagnosticGroupWarningsGuard",
    "signature": "com.google.javascript.jscomp.DiagnosticGroupWarningsGuard.enables(DiagnosticGroup)",
    "snippet": "  @Override\n  public boolean enables(DiagnosticGroup otherGroup) {\n    if (level.isOn()) {\n      for (DiagnosticType type : otherGroup.getTypes()) {\n        if (group.matches(type)) {\n          return true;\n        }\n      }\n    }\n\n    return false;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "DiagnosticGroups.DiagnosticGroups",
    "class_name": "com.google.javascript.jscomp.DiagnosticGroups",
    "signature": "com.google.javascript.jscomp.DiagnosticGroups.DiagnosticGroups()",
    "snippet": "  DiagnosticGroups() {}",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "DiagnosticGroups.registerGroup",
    "class_name": "com.google.javascript.jscomp.DiagnosticGroups",
    "signature": "com.google.javascript.jscomp.DiagnosticGroups.registerGroup(String,DiagnosticGroup)",
    "snippet": "  static DiagnosticGroup registerGroup(String name,\n      DiagnosticGroup group) {\n    groupsByName.put(name, group);\n    return group;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "DiagnosticGroups.setWarningLevels",
    "class_name": "com.google.javascript.jscomp.DiagnosticGroups",
    "signature": "com.google.javascript.jscomp.DiagnosticGroups.setWarningLevels(CompilerOptions,List,CheckLevel)",
    "snippet": "  void setWarningLevels(CompilerOptions options,\n      List<String> diagnosticGroups, CheckLevel level) {\n    for (String name : diagnosticGroups) {\n      DiagnosticGroup group = forName(name);\n      Preconditions.checkNotNull(group, \"No warning class for name: \" + name);\n      options.setWarningLevel(group, level);\n    }\n  }",
    "comment": " Adds warning levels by name. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "DiagnosticType.disabled",
    "class_name": "com.google.javascript.jscomp.DiagnosticType",
    "signature": "com.google.javascript.jscomp.DiagnosticType.disabled(String,String)",
    "snippet": "  public static DiagnosticType disabled(String name,\n      String descriptionFormat) {\n    return make(name, CheckLevel.OFF, descriptionFormat);\n  }",
    "comment": " Create a DiagnosticType at level CheckLevel.OFF  @param name An identifier @param descriptionFormat A format string @return A new DiagnosticType ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "DiagnosticType.error",
    "class_name": "com.google.javascript.jscomp.DiagnosticType",
    "signature": "com.google.javascript.jscomp.DiagnosticType.error(String,String)",
    "snippet": "  public static DiagnosticType error(String name, String descriptionFormat) {\n    return make(name, CheckLevel.ERROR, descriptionFormat);\n  }",
    "comment": " Create a DiagnosticType at level CheckLevel.ERROR  @param name An identifier @param descriptionFormat A format string @return A new DiagnosticType ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "DiagnosticType.make",
    "class_name": "com.google.javascript.jscomp.DiagnosticType",
    "signature": "com.google.javascript.jscomp.DiagnosticType.make(String,CheckLevel,String)",
    "snippet": "  public static DiagnosticType make(String name, CheckLevel level,\n                                    String descriptionFormat) {\n    return\n        new DiagnosticType(name, level, new MessageFormat(descriptionFormat));\n  }",
    "comment": " Create a DiagnosticType at a given CheckLevel.  @param name An identifier @param level Either CheckLevel.ERROR or CheckLevel.WARNING @param descriptionFormat A format string @return A new DiagnosticType ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "DiagnosticType.warning",
    "class_name": "com.google.javascript.jscomp.DiagnosticType",
    "signature": "com.google.javascript.jscomp.DiagnosticType.warning(String,String)",
    "snippet": "  public static DiagnosticType warning(String name, String descriptionFormat) {\n    return make(name, CheckLevel.WARNING, descriptionFormat);\n  }",
    "comment": " Create a DiagnosticType at level CheckLevel.WARNING  @param name An identifier @param descriptionFormat A format string @return A new DiagnosticType ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "ExtractPrototypeMemberDeclarations.ExtractPrototypeMemberDeclarations",
    "class_name": "com.google.javascript.jscomp.ExtractPrototypeMemberDeclarations",
    "signature": "com.google.javascript.jscomp.ExtractPrototypeMemberDeclarations.ExtractPrototypeMemberDeclarations(AbstractCompiler)",
    "snippet": "  public ExtractPrototypeMemberDeclarations(AbstractCompiler compiler) {\n    this.compiler = compiler;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "ExtractPrototypeMemberDeclarations.process",
    "class_name": "com.google.javascript.jscomp.ExtractPrototypeMemberDeclarations",
    "signature": "com.google.javascript.jscomp.ExtractPrototypeMemberDeclarations.process(Node,Node)",
    "snippet": "  @Override\n  public void process(Node externs, Node root) {\n    GatherExtractionInfo extractionInfo = new GatherExtractionInfo();\n    NodeTraversal.traverse(compiler, root, extractionInfo);\n    if (extractionInfo.shouldExtract()) {\n      doExtraction(extractionInfo);\n      compiler.reportCodeChange();\n    }\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "GatherExtractionInfo.shouldExtract",
    "class_name": "com.google.javascript.jscomp.ExtractPrototypeMemberDeclarations$GatherExtractionInfo",
    "signature": "com.google.javascript.jscomp.ExtractPrototypeMemberDeclarations$GatherExtractionInfo.shouldExtract()",
    "snippet": "    private boolean shouldExtract() {\n      return totalDelta < 0;\n    }",
    "comment": " @return <@code true> if the sum of all the extraction instance gain outweights the overhead of the temp variable declaration. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "GatherExtractionInfo.visit",
    "class_name": "com.google.javascript.jscomp.ExtractPrototypeMemberDeclarations$GatherExtractionInfo",
    "signature": "com.google.javascript.jscomp.ExtractPrototypeMemberDeclarations$GatherExtractionInfo.visit(NodeTraversal,Node,Node)",
    "snippet": "    @Override\n    public void visit(NodeTraversal t, Node n, Node parent) {\n\n      if (n.getType() != Token.SCRIPT && n.getType() != Token.BLOCK) {\n        return;\n      }\n\n      if (prototypeAlias == null) {\n        // Always in global scope\n        prototypeAlias =\n          new VariableNameGenerator(t.getScope()).getNameNewName();\n      }\n\n      for (Node cur = n.getFirstChild(); cur != null; cur = cur.getNext()) {\n        PrototypeMemberDeclaration prototypeMember =\n            PrototypeMemberDeclaration.extractDeclaration(cur);\n        if (prototypeMember == null) {\n          continue;\n        }\n\n        // Found a good site here. The constructor will computes the chain of\n        // declarations that is qualified for extraction.\n        ExtractionInstance instance =\n            new ExtractionInstance(prototypeMember, n);\n        cur = instance.declarations.getLast().node;\n\n        // Only add it to our work list if the extraction at this instance\n        // makes the code smaller.\n        if (instance.isFavorable()) {\n          instances.add(instance);\n          totalDelta += instance.delta;\n        }\n      }\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "PrototypeMemberDeclaration.extractDeclaration",
    "class_name": "com.google.javascript.jscomp.ExtractPrototypeMemberDeclarations$PrototypeMemberDeclaration",
    "signature": "com.google.javascript.jscomp.ExtractPrototypeMemberDeclarations$PrototypeMemberDeclaration.extractDeclaration(Node)",
    "snippet": "    private static PrototypeMemberDeclaration extractDeclaration(Node n) {\n      if (!NodeUtil.isPrototypePropertyDeclaration(n)) {\n        return null;\n      }\n      Node lhs = n.getFirstChild().getFirstChild();\n      return new PrototypeMemberDeclaration(lhs, n);\n    }",
    "comment": " @return A prototype member declaration representation if there is one else it returns {@code null}. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "FoldConstants.FoldConstants",
    "class_name": "com.google.javascript.jscomp.FoldConstants",
    "signature": "com.google.javascript.jscomp.FoldConstants.FoldConstants(AbstractCompiler)",
    "snippet": "  FoldConstants(AbstractCompiler compiler) {\n    this.compiler = compiler;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "FoldConstants.process",
    "class_name": "com.google.javascript.jscomp.FoldConstants",
    "signature": "com.google.javascript.jscomp.FoldConstants.process(Node,Node)",
    "snippet": "  public void process(Node externs, Node jsRoot) {\n    NodeTraversal.traverse(compiler, jsRoot, this);\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "FoldConstants.tryFoldAssign",
    "class_name": "com.google.javascript.jscomp.FoldConstants",
    "signature": "com.google.javascript.jscomp.FoldConstants.tryFoldAssign(NodeTraversal,Node,Node,Node)",
    "snippet": "  private void tryFoldAssign(NodeTraversal t, Node n, Node left, Node right) {\n    Preconditions.checkArgument(n.getType() == Token.ASSIGN);\n\n    // Tries to convert x = x + y -> x += y;\n    if (!right.hasChildren() ||\n        right.getFirstChild().getNext() != right.getLastChild()) {\n      // RHS must have two children.\n      return;\n    }\n\n    if (NodeUtil.mayHaveSideEffects(left)) {\n      return;\n    }\n\n    Node leftChild = right.getFirstChild();\n    if (!compiler.areNodesEqualForInlining(left, leftChild)) {\n      return;\n    }\n\n    int newType = -1;\n    switch (right.getType()) {\n      case Token.ADD:\n        newType = Token.ASSIGN_ADD;\n        break;\n      case Token.BITAND:\n        newType = Token.ASSIGN_BITAND;\n        break;\n      case Token.BITOR:\n        newType = Token.ASSIGN_BITOR;\n        break;\n      case Token.BITXOR:\n        newType = Token.ASSIGN_BITXOR;\n        break;\n      case Token.DIV:\n        newType = Token.ASSIGN_DIV;\n        break;\n      case Token.LSH:\n        newType = Token.ASSIGN_LSH;\n        break;\n      case Token.MOD:\n        newType = Token.ASSIGN_MOD;\n        break;\n      case Token.MUL:\n        newType = Token.ASSIGN_MUL;\n        break;\n      case Token.RSH:\n        newType = Token.ASSIGN_RSH;\n        break;\n      case Token.SUB:\n        newType = Token.ASSIGN_SUB;\n        break;\n      case Token.URSH:\n        newType = Token.ASSIGN_URSH;\n        break;\n      default:\n        return;\n    }\n\n    n.getParent().replaceChild(n, new Node(newType,\n        left.detachFromParent(), right.getLastChild().detachFromParent()));\n    t.getCompiler().reportCodeChange();\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "FoldConstants.tryFoldBlock",
    "class_name": "com.google.javascript.jscomp.FoldConstants",
    "signature": "com.google.javascript.jscomp.FoldConstants.tryFoldBlock(NodeTraversal,Node,Node)",
    "snippet": "  void tryFoldBlock(NodeTraversal t, Node n, Node parent) {\n    // Remove any useless children\n    for (Node c = n.getFirstChild(); c != null; ) {\n      Node next = c.getNext();  // save c.next, since 'c' may be removed\n      if (!NodeUtil.mayHaveSideEffects(c)) {\n        n.removeChild(c);  // lazy kids\n        t.getCompiler().reportCodeChange();\n      }\n      c = next;\n    }\n\n    if (n.isSyntheticBlock() || parent == null) {\n      return;\n    }\n\n    // Try to remove the block.\n    if (NodeUtil.tryMergeBlock(n)) {\n      t.getCompiler().reportCodeChange();\n    }\n  }",
    "comment": " Try removing unneeded block nodes and their useless children ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "FoldConstants.tryFoldGetProp",
    "class_name": "com.google.javascript.jscomp.FoldConstants",
    "signature": "com.google.javascript.jscomp.FoldConstants.tryFoldGetProp(NodeTraversal,Node,Node,Node,Node)",
    "snippet": "  void tryFoldGetProp(NodeTraversal t, Node n, Node left, Node right,\n                      Node parent) {\n    if (right.getType() == Token.STRING &&\n        right.getString().equals(\"length\")) {\n      int knownLength = -1;\n      switch (left.getType()) {\n        case Token.ARRAYLIT:\n          if (NodeUtil.mayHaveSideEffects(left)) {\n            // Nope, can't fold this, without handling the side-effects.\n            return;\n          }\n          knownLength = left.getChildCount();\n          break;\n        case Token.STRING:\n          knownLength = left.getString().length();\n          break;\n        default:\n          // Not a foldable case, forget it.\n          return;\n      }\n\n      Preconditions.checkState(knownLength != -1);\n      Node lengthNode = Node.newNumber(knownLength);\n      parent.replaceChild(n, lengthNode);\n      t.getCompiler().reportCodeChange();\n    }\n  }",
    "comment": " Try to fold array-length. e.g [1, 2, 3].length ==> 3, [x, y].length ==> 2 ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "FoldConstants.tryMinimizeCondition",
    "class_name": "com.google.javascript.jscomp.FoldConstants",
    "signature": "com.google.javascript.jscomp.FoldConstants.tryMinimizeCondition(NodeTraversal,Node,Node)",
    "snippet": "  void tryMinimizeCondition(NodeTraversal t, Node n, Node parent) {\n\n    switch (n.getType()) {\n      case Token.NOT:\n        Node first = n.getFirstChild();\n        switch (first.getType()) {\n          case Token.NOT: {\n              Node newRoot = first.removeFirstChild();\n              parent.replaceChild(n, newRoot);\n              n = newRoot; // continue from here.\n              t.getCompiler().reportCodeChange();\n\n              // The child has moved up, to minimize it recurse.\n              tryMinimizeCondition(t, n, parent);\n              return;\n            }\n          case Token.AND:\n          case Token.OR: {\n              Node leftParent = first.getFirstChild();\n              Node rightParent = first.getLastChild();\n              if (leftParent.getType() != Token.NOT\n                  || rightParent.getType() != Token.NOT) {\n                // No NOTs to elminate.\n                break;\n              }\n              Node left = leftParent.removeFirstChild();\n              Node right = rightParent.removeFirstChild();\n\n              int newOp = (first.getType() == Token.AND) ? Token.OR : Token.AND;\n              Node newRoot = new Node(newOp, left, right);\n              parent.replaceChild(n, newRoot);\n              n = newRoot; // continue from here.\n              t.getCompiler().reportCodeChange();\n\n              // Unlike the NOT case above, we know that AND and OR are\n              // valid root to check minimize so just break out and check\n              // the children.\n            }\n            break;\n        }\n        break;\n\n      case Token.OR:\n      case Token.AND:\n        // check the children.\n        break;\n\n      default:\n        // if(true) --> if(1)\n        if (NodeUtil.isLiteralValue(n)) {\n          boolean result = NodeUtil.getBooleanValue(n);\n          int equivalentResult = result ? 1 : 0;\n          maybeReplaceChildWithNumber(t, n, parent, equivalentResult);\n        }\n        // We can't do anything else currently.\n        return;\n    }\n\n    for (Node c = n.getFirstChild(); c != null; ) {\n      Node next = c.getNext();  // c may be removed.\n      tryMinimizeCondition(t, c, n);\n      c = next;\n    }\n  }",
    "comment": " Try to minimize conditions expressions, as there are additional assumptions that can be made when it is known that the final result is a boolean.  The following transformations are done recursively: !(x||y) --> !x&&!y !(x&&y) --> !x||!y !!x     --> x Thus: !(x&&!y) --> !x||!!y --> !x||y ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "FoldConstants.visit",
    "class_name": "com.google.javascript.jscomp.FoldConstants",
    "signature": "com.google.javascript.jscomp.FoldConstants.visit(NodeTraversal,Node,Node)",
    "snippet": "  public void visit(NodeTraversal t, Node n, Node parent) {\n    int type = n.getType();\n\n    if (type == Token.BLOCK) {\n      tryFoldBlock(t, n, parent);\n      return;\n    }\n\n    Node left = n.getFirstChild();\n    if (left == null) {\n      return;\n    }\n\n    if (type == Token.TYPEOF && NodeUtil.isLiteralValue(left)) {\n      String newValue = null;\n\n      switch (left.getType()) {\n        case Token.STRING:\n          newValue = \"string\";\n          break;\n        case Token.NUMBER:\n          newValue = \"number\";\n          break;\n        case Token.TRUE:\n        case Token.FALSE:\n          newValue = \"boolean\";\n          break;\n        case Token.NULL:\n        case Token.OBJECTLIT:\n        case Token.ARRAYLIT:\n          newValue = \"object\";\n          break;\n        case Token.NAME:\n          // We assume here that programs don't change the value of the\n          // keyword undefined to something other than the value undefined.\n          if (\"undefined\".equals(left.getString())) {\n            newValue = \"undefined\";\n          }\n          break;\n      }\n\n      if (newValue != null) {\n        parent.replaceChild(n, Node.newString(newValue));\n        t.getCompiler().reportCodeChange();\n      }\n\n      return;\n    }\n\n    if (type == Token.NOT ||\n        type == Token.NEG ||\n        type == Token.BITNOT) {\n        Preconditions.checkState(n.hasOneChild());\n\n        if (NodeUtil.isExpressionNode(parent)) {\n          // If the value of the NOT isn't used, then just throw\n          // away the operator\n          parent.replaceChild(n, n.removeFirstChild());\n          t.getCompiler().reportCodeChange();\n          return;\n        }\n\n        // Try to mimize NOT nodes such as !(x==y) into x!=y.\n        if (type == Token.NOT && tryMinimizeNot(t, n, parent)) {\n          return;\n        }\n\n        if (!NodeUtil.isLiteralValue(left)) {\n          return;\n        }\n\n        switch (type) {\n          case Token.NOT:\n            int result = NodeUtil.getBooleanValue(left) ? Token.FALSE :\n                         Token.TRUE;\n            parent.replaceChild(n, new Node(result));\n            t.getCompiler().reportCodeChange();\n            break;\n\n          case Token.NEG:\n            try {\n              if (left.getType() == Token.NAME) {\n                if (left.getString().equals(\"Infinity\")) {\n                  // \"-Infinity\" is valid and a literal, don't modify it.\n                  return;\n                } else if (left.getString().equals(\"NaN\")) {\n                  // \"-NaN\" is \"NaN\".\n                  n.removeChild(left);\n                  parent.replaceChild(n, left);\n                  t.getCompiler().reportCodeChange();\n                  return;\n                }\n              }\n\n              double negNum = -left.getDouble();\n              parent.replaceChild(n, Node.newNumber(negNum));\n              t.getCompiler().reportCodeChange();\n            } catch (UnsupportedOperationException ex) {\n              // left is not a number node, so do not replace, but warn the\n              // user because they can't be doing anything good\n              error(t, NEGATING_A_NON_NUMBER_ERROR, left);\n            }\n            break;\n\n          case Token.BITNOT:\n            try {\n              double val = left.getDouble();\n              if (val >= Integer.MIN_VALUE && val <= Integer.MAX_VALUE) {\n                int intVal = (int) val;\n                if (intVal == val) {\n                  parent.replaceChild(n, Node.newNumber(~intVal));\n                  t.getCompiler().reportCodeChange();\n                } else {\n                  error(t, FRACTIONAL_BITWISE_OPERAND, left);\n                }\n              } else {\n                error(t, BITWISE_OPERAND_OUT_OF_RANGE, left);\n              }\n            } catch (UnsupportedOperationException ex) {\n              // left is not a number node, so do not replace, but warn the\n              // user because they can't be doing anything good\n              error(t, NEGATING_A_NON_NUMBER_ERROR, left);\n            }\n            break;\n        }\n        return;\n    } else if (type == Token.NEW) {\n      if (Token.NAME == left.getType()) {\n        String className = left.getString();\n        if (\"RegExp\".equals(className)) {\n          tryFoldRegularExpressionConstructor(t, n, parent);\n        } else if (left.getNext() == null) {\n          if (\"Array\".equals(className)) {\n            tryFoldLiteralConstructor(\n                t, n, parent, className, Token.ARRAYLIT);\n          } else if (\"Object\".equals(className)) {\n            tryFoldLiteralConstructor(\n                t, n, parent, className, Token.OBJECTLIT);\n          }\n        }\n      }\n    }\n\n    if (type == Token.EXPR_RESULT) {\n      tryMinimizeCondition(t, left, n);\n      return;\n    }\n\n    if (type == Token.RETURN) {\n      tryReduceReturn(t, n);\n      return;\n    }\n\n    Node right = left.getNext();\n    if (right == null) {\n      return;\n    }\n\n    // TODO(johnlenz) Use type information if available to fold\n    // instanceof.\n    if (type == Token.INSTANCEOF\n        && NodeUtil.isLiteralValue(left)\n        && !NodeUtil.mayHaveSideEffects(right)) {\n      if (NodeUtil.isImmutableValue(left)) {\n        // Non-object types are never instances.\n        parent.replaceChild(n, new Node(Token.FALSE));\n        t.getCompiler().reportCodeChange();\n        return;\n      }\n\n      if (right.getType() == Token.NAME\n          && \"Object\".equals(right.getString())) {\n        parent.replaceChild(n, new Node(Token.TRUE));\n        t.getCompiler().reportCodeChange();\n        return;\n      }\n    }\n\n    if (type == Token.IF || type == Token.HOOK) {\n      tryMinimizeCondition(t, n.getFirstChild(), n);\n      boolean changes = tryFoldHookIf(t, n, parent);\n\n      // bad cascades can occur if we run the second round\n      // of IF optimizations immediately\n      if (type == Token.IF && !changes) {\n        tryMinimizeIf(t, n, parent);\n      }\n      return;\n    }\n\n    if (type == Token.DO) {\n      tryMinimizeCondition(t, NodeUtil.getConditionExpression(n), n);\n      tryFoldDo(t, n, parent);\n      return;\n    }\n\n    if (type == Token.WHILE) {\n      tryMinimizeCondition(t, NodeUtil.getConditionExpression(n), n);\n      tryFoldWhile(t, n, parent);\n      return;\n    }\n\n    if (type == Token.FOR) {\n      Node condition = NodeUtil.getConditionExpression(n);\n      if (condition != null) {\n        tryMinimizeCondition(t, condition, n);\n        // The root condition node might have changed, get it again.\n        condition = NodeUtil.getConditionExpression(n);\n        this.tryFoldForCondition(condition, n);\n      }\n\n      tryFoldFor(t, n, parent);\n      return;\n    }\n\n    if (type == Token.AND ||\n        type == Token.OR) {\n      tryFoldAndOr(t, n, left, right, parent);\n      return;\n    }\n\n    if (type == Token.BITOR ||\n        type == Token.BITAND) {\n      tryFoldBitAndOr(t, n, left, right, parent);\n      return;\n    }\n\n    if (type == Token.LSH ||\n        type == Token.RSH ||\n        type == Token.URSH) {\n      tryFoldShift(t, n, left, right, parent);\n      return;\n    }\n\n    if (type == Token.GETPROP) {\n      tryFoldGetProp(t, n, left, right, parent);\n      return;\n    }\n\n    if (type == Token.CALL) {\n      tryFoldStringJoin(t, n, left, right, parent);\n      tryFoldStringIndexOf(t, n, left, right, parent);\n      return;\n    }\n\n    if (type == Token.COMMA) {\n      tryFoldComma(t, n, left, right, parent);\n      return;\n    }\n\n    if (type == Token.ASSIGN) {\n      tryFoldAssign(t, n, left, right);\n    }\n\n    if (!NodeUtil.isLiteralValue(left) ||\n        !NodeUtil.isLiteralValue(right)) {\n\n      if (type == Token.ADD)\n        tryFoldLeftChildAdd(t, n, left, right, parent);\n\n      if (type == Token.LT ||\n          type == Token.GT) {\n        tryFoldComparison(t, n, left, right, parent);\n      }\n\n      return; // The subsequent ops only work if the LHS & RHS are consts\n    }\n\n    if (type == Token.ADD) {\n      tryFoldAdd(t, n, left, right, parent);\n      return;\n    }\n    if (type == Token.SUB ||\n        type == Token.MUL ||\n        type == Token.DIV) {\n      tryFoldArithmetic(t, n, left, right, parent);\n      return;\n    }\n\n    if (type == Token.LT ||\n        type == Token.GT ||\n        type == Token.LE ||\n        type == Token.GE ||\n        type == Token.EQ ||\n        type == Token.NE ||\n        type == Token.SHEQ ||\n        type == Token.SHNE) {\n      tryFoldComparison(t, n, left, right, parent);\n      return;\n    }\n\n    if (type == Token.GETELEM) {\n      tryFoldGetElem(t, n, left, right, parent);\n      return;\n    }\n\n    // other types aren't handled\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "GlobalNamespace.GlobalNamespace",
    "class_name": "com.google.javascript.jscomp.GlobalNamespace",
    "signature": "com.google.javascript.jscomp.GlobalNamespace.GlobalNamespace(AbstractCompiler,Node)",
    "snippet": "  GlobalNamespace(AbstractCompiler compiler, Node root) {\n    this(compiler, null, root);\n  }",
    "comment": " Creates an instance that may emit warnings when building the namespace.  @param compiler The AbstractCompiler, for reporting code changes @param root The root of the rest of the code to build a namespace for. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "GlobalNamespace.GlobalNamespace",
    "class_name": "com.google.javascript.jscomp.GlobalNamespace",
    "signature": "com.google.javascript.jscomp.GlobalNamespace.GlobalNamespace(AbstractCompiler,Node,Node)",
    "snippet": "  GlobalNamespace(AbstractCompiler compiler, Node externsRoot, Node root) {\n    this.compiler = compiler;\n    this.externsRoot = externsRoot;\n    this.root = root;\n  }",
    "comment": " Creates an instance that may emit warnings when building the namespace.  @param compiler The AbstractCompiler, for reporting code changes @param externsRoot The root of the externs to build a namespace for. If this is null, externs and properties defined on extern types will not be included in the global namespace.  If non-null, it allows user-defined function on extern types to be included in the global namespace.  E.g. String.foo. @param root The root of the rest of the code to build a namespace for. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "GlobalNamespace.getNameIndex",
    "class_name": "com.google.javascript.jscomp.GlobalNamespace",
    "signature": "com.google.javascript.jscomp.GlobalNamespace.getNameIndex()",
    "snippet": "  Map<String, Name> getNameIndex() {\n    if (!generated) {\n      process();\n    }\n    return nameMap;\n  }",
    "comment": " Gets an index of all the global names, indexed by full qualified name (as in \"a\", \"a.b.c\", etc.). ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "GlobalNamespace.getTopVarName",
    "class_name": "com.google.javascript.jscomp.GlobalNamespace",
    "signature": "com.google.javascript.jscomp.GlobalNamespace.getTopVarName(String)",
    "snippet": "  private String getTopVarName(String name) {\n    int firstDotIndex = name.indexOf('.');\n    return firstDotIndex == -1 ? name : name.substring(0, firstDotIndex);\n  }",
    "comment": " Gets the top variable name from a possibly namespaced name.  @param name A variable or qualified property name (e.g. \"a\" or \"a.b.c.d\") @return The top variable name (e.g. \"a\") ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "GlobalNamespace.isGlobalNameReference",
    "class_name": "com.google.javascript.jscomp.GlobalNamespace",
    "signature": "com.google.javascript.jscomp.GlobalNamespace.isGlobalNameReference(String,Scope)",
    "snippet": "  private boolean isGlobalNameReference(String name, Scope s) {\n    String topVarName = getTopVarName(name);\n    return isGlobalVarReference(topVarName, s);\n  }",
    "comment": " Determines whether a name reference in a particular scope is a global name reference.  @param name A variable or property name (e.g. \"a\" or \"a.b.c.d\") @param s The scope in which the name is referenced @return Whether the name reference is a global name reference ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "GlobalNamespace.isGlobalScope",
    "class_name": "com.google.javascript.jscomp.GlobalNamespace",
    "signature": "com.google.javascript.jscomp.GlobalNamespace.isGlobalScope(Scope)",
    "snippet": "  private boolean isGlobalScope(Scope s) {\n    return s.getParent() == null;\n  }",
    "comment": " Gets whether a scope is the global scope.  @param s A scope @return Whether the scope is the global scope ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "GlobalNamespace.isGlobalVarReference",
    "class_name": "com.google.javascript.jscomp.GlobalNamespace",
    "signature": "com.google.javascript.jscomp.GlobalNamespace.isGlobalVarReference(String,Scope)",
    "snippet": "  private boolean isGlobalVarReference(String name, Scope s) {\n    Scope.Var v = s.getVar(name);\n    if (v == null && externsScope != null) {\n      v = externsScope.getVar(name);\n    }\n    return v != null && !v.isLocal();\n  }",
    "comment": " Determines whether a variable name reference in a particular scope is a global variable reference.  @param name A variable name (e.g. \"a\") @param s The scope in which the name is referenced @return Whether the name reference is a global variable reference ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "GlobalNamespace.process",
    "class_name": "com.google.javascript.jscomp.GlobalNamespace",
    "signature": "com.google.javascript.jscomp.GlobalNamespace.process()",
    "snippet": "  private void process() {\n    if (externsRoot != null) {\n      inExterns = true;\n      NodeTraversal.traverse(compiler, externsRoot, new BuildGlobalNamespace());\n    }\n    inExterns = false;\n\n    NodeTraversal.traverse(compiler, root, new BuildGlobalNamespace());\n    generated = true;\n  }",
    "comment": " Builds the namespace lazily. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "BuildGlobalNamespace.getOrCreateName",
    "class_name": "com.google.javascript.jscomp.GlobalNamespace$BuildGlobalNamespace",
    "signature": "com.google.javascript.jscomp.GlobalNamespace$BuildGlobalNamespace.getOrCreateName(String)",
    "snippet": "    Name getOrCreateName(String name) {\n      Name node = nameMap.get(name);\n      if (node == null) {\n        int i = name.lastIndexOf('.');\n        if (i >= 0) {\n          String parentName = name.substring(0, i);\n          Name parent = getOrCreateName(parentName);\n          node = parent.addProperty(name.substring(i + 1), inExterns);\n        } else {\n          node = new Name(name, null, inExterns);\n          globalNames.add(node);\n        }\n        nameMap.put(name, node);\n      }\n      return node;\n    }",
    "comment": " Gets a {@link Name} instance for a global name. Creates it if necessary, as well as instances for any of its prefixes that are not yet defined.  @param name A global name (e.g. \"a\", \"a.b.c.d\") @return The {@link Name} instance for {@code name} ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "BuildGlobalNamespace.getValueType",
    "class_name": "com.google.javascript.jscomp.GlobalNamespace$BuildGlobalNamespace",
    "signature": "com.google.javascript.jscomp.GlobalNamespace$BuildGlobalNamespace.getValueType(Node)",
    "snippet": "    Name.Type getValueType(Node n) {\n      switch (n.getType()) {\n        case Token.OBJECTLIT:\n          return Name.Type.OBJECTLIT;\n        case Token.FUNCTION:\n          return Name.Type.FUNCTION;\n        case Token.OR:\n          // Recurse on the second value. If the first value were an object\n          // literal or function, then the OR would be meaningless and the\n          // second value would be dead code. Assume that if the second value\n          // is an object literal or function, then the first value will also\n          // evaluate to one when it doesn't evaluate to false.\n          return getValueType(n.getLastChild());\n        case Token.HOOK:\n          // The same line of reasoning used for the OR case applies here.\n          Node second = n.getFirstChild().getNext();\n          Name.Type t = getValueType(second);\n          if (t != Name.Type.OTHER) return t;\n          Node third = second.getNext();\n          return getValueType(third);\n      }\n      return Name.Type.OTHER;\n    }",
    "comment": " Gets the type of a value or simple expression.  @param n An rvalue in an assignment or variable declaration (not null) @return A {@link Name.Type} ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "BuildGlobalNamespace.handleSetFromGlobal",
    "class_name": "com.google.javascript.jscomp.GlobalNamespace$BuildGlobalNamespace",
    "signature": "com.google.javascript.jscomp.GlobalNamespace$BuildGlobalNamespace.handleSetFromGlobal(NodeTraversal,Node,Node,String,boolean,Type)",
    "snippet": "    void handleSetFromGlobal(NodeTraversal t, Node n, Node parent, String name,\n                             boolean isPropAssign, Name.Type type) {\n      if (maybeHandlePrototypePrefix(t, n, parent, name)) return;\n\n      Name nameObj = getOrCreateName(name);\n      nameObj.type = type;\n\n      Ref set = new Ref(t, n, Ref.Type.SET_FROM_GLOBAL);\n      nameObj.addRef(set);\n\n      if (isNestedAssign(parent)) {\n        // This assignment is both a set and a get that creates an alias.\n        Ref get = new Ref(t, n, Ref.Type.ALIASING_GET);\n        nameObj.addRef(get);\n        Ref.markTwins(set, get);\n      } else if (isConstructorOrEnumDeclaration(n, parent)) {\n        // Names with a @constructor or @enum annotation are always collapsed\n        nameObj.setIsClassOrEnum();\n      }\n    }",
    "comment": " Updates our respresentation of the global namespace to reflect an assignment to a global name in global scope.  @param t The traversal @param n The node currently being visited @param parent {@code n}'s parent @param name The global name (e.g. \"a\" or \"a.b.c.d\") @param isPropAssign Whether this set corresponds to a property assignment of the form <code>a.b.c = ...;</code> @param type The type of the value that the name is being assigned ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "BuildGlobalNamespace.isConstructorOrEnumDeclaration",
    "class_name": "com.google.javascript.jscomp.GlobalNamespace$BuildGlobalNamespace",
    "signature": "com.google.javascript.jscomp.GlobalNamespace$BuildGlobalNamespace.isConstructorOrEnumDeclaration(Node,Node)",
    "snippet": "    private boolean isConstructorOrEnumDeclaration(Node n, Node parent) {\n      JSDocInfo info;\n      int valueNodeType;\n      switch (parent.getType()) {\n        case Token.ASSIGN:\n          info = parent.getJSDocInfo();\n          valueNodeType = n.getNext().getType();\n          break;\n        case Token.VAR:\n          info = n.getJSDocInfo();\n          if (info == null) {\n            info = parent.getJSDocInfo();\n          }\n          Node valueNode = n.getFirstChild();\n          valueNodeType = valueNode != null ? valueNode.getType() : Token.VOID;\n          break;\n        default:\n          return false;\n      }\n      // Heed the annotations only if they're sensibly used.\n      return info != null &&\n             (info.isConstructor() && valueNodeType == Token.FUNCTION ||\n              info.hasEnumParameterType() && valueNodeType == Token.OBJECTLIT);\n    }",
    "comment": " Determines whether a set operation is a constructor or enumeration declaration. The set operation may either be an assignment to a name, a variable declaration, or an object literal key mapping.  @param n The node that represents the name being set @param parent Parent node of {@code n} (an ASSIGN, VAR, or OBJLIT node) @return Whether the set operation is either a constructor or enum declaration ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "BuildGlobalNamespace.isNestedAssign",
    "class_name": "com.google.javascript.jscomp.GlobalNamespace$BuildGlobalNamespace",
    "signature": "com.google.javascript.jscomp.GlobalNamespace$BuildGlobalNamespace.isNestedAssign(Node)",
    "snippet": "    boolean isNestedAssign(Node parent) {\n      return parent.getType() == Token.ASSIGN &&\n             !NodeUtil.isExpressionNode(parent.getParent());\n    }",
    "comment": " Determines whether an assignment is nested (i.e. whether its return value is used).  @param parent The parent of the current traversal node (not null) @return Whether it appears that the return value of the assignment is used ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "BuildGlobalNamespace.maybeHandlePrototypePrefix",
    "class_name": "com.google.javascript.jscomp.GlobalNamespace$BuildGlobalNamespace",
    "signature": "com.google.javascript.jscomp.GlobalNamespace$BuildGlobalNamespace.maybeHandlePrototypePrefix(NodeTraversal,Node,Node,String)",
    "snippet": "    boolean maybeHandlePrototypePrefix(NodeTraversal t, Node n, Node parent,\n        String name) {\n      // We use a string-based approach instead of inspecting the parse tree\n      // to avoid complexities with object literals, possibly nested, beneath\n      // assignments.\n\n      int numLevelsToRemove;\n      String prefix;\n      if (name.endsWith(\".prototype\")) {\n        numLevelsToRemove = 1;\n        prefix = name.substring(0, name.length() - 10);\n      } else {\n        int i = name.indexOf(\".prototype.\");\n        if (i == -1) {\n          return false;\n        }\n        prefix = name.substring(0, i);\n        numLevelsToRemove = 2;\n        i = name.indexOf('.', i + 11);\n        while (i >= 0) {\n          numLevelsToRemove++;\n          i = name.indexOf('.', i + 1);\n        }\n      }\n\n      if (parent != null && NodeUtil.isObjectLitKey(n, parent)) {\n        // Object literal keys have no prefix that's referenced directly per\n        // key, so we're done.\n        return true;\n      }\n\n      for (int i = 0; i < numLevelsToRemove; i++) {\n        parent = n;\n        n = n.getFirstChild();\n      }\n\n      handleGet(t, n, parent, prefix, Ref.Type.PROTOTYPE_GET);\n      return true;\n    }",
    "comment": " Updates our respresentation of the global namespace to reflect a read of a global name's longest prefix before the \"prototype\" property if the name includes the \"prototype\" property. Does nothing otherwise.  @param t The current node traversal @param n The node currently being visited @param parent {@code n}'s parent @param name The global name (e.g. \"a\" or \"a.b.c.d\") @return Whether the name was handled ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "BuildGlobalNamespace.visit",
    "class_name": "com.google.javascript.jscomp.GlobalNamespace$BuildGlobalNamespace",
    "signature": "com.google.javascript.jscomp.GlobalNamespace$BuildGlobalNamespace.visit(NodeTraversal,Node,Node)",
    "snippet": "    public void visit(NodeTraversal t, Node n, Node parent) {\n      if (nodeFilter != null && !nodeFilter.apply(n)) {\n        return;\n      }\n\n      // If we are traversing the externs, then we save a pointer to the scope\n      // generated by them, so that we can do lookups in it later.\n      if (externsRoot != null && n == externsRoot) {\n        externsScope = t.getScope();\n      }\n\n      String name;\n      boolean isSet = false;\n      Name.Type type = Name.Type.OTHER;\n      boolean isPropAssign = false;\n\n      switch (n.getType()) {\n        case Token.STRING:\n          // This may be a key in an object literal declaration.\n          name = null;\n          if (parent != null && parent.getType() == Token.OBJECTLIT) {\n            name = getNameForObjLitKey(n);\n          }\n          if (name == null) return;\n          isSet = true;\n          type = getValueType(n.getNext());\n          break;\n        case Token.NAME:\n          // This may be a variable get or set.\n          if (parent != null) {\n            switch (parent.getType()) {\n              case Token.VAR:\n                isSet = true;\n                Node rvalue = n.getFirstChild();\n                type = rvalue == null ? Name.Type.OTHER : getValueType(rvalue);\n                break;\n              case Token.ASSIGN:\n                if (parent.getFirstChild() == n) {\n                  isSet = true;\n                  type = getValueType(n.getNext());\n                }\n                break;\n              case Token.GETPROP:\n                return;\n              case Token.FUNCTION:\n                Node gramps = parent.getParent();\n                if (gramps == null ||\n                    NodeUtil.isFunctionAnonymous(parent)) return;\n                isSet = true;\n                type = Name.Type.FUNCTION;\n                break;\n            }\n          }\n          name = n.getString();\n          break;\n        case Token.GETPROP:\n          // This may be a namespaced name get or set.\n          if (parent != null) {\n            switch (parent.getType()) {\n              case Token.ASSIGN:\n                if (parent.getFirstChild() == n) {\n                  isSet = true;\n                  type = getValueType(n.getNext());\n                  isPropAssign = true;\n                }\n                break;\n              case Token.GETPROP:\n                return;\n            }\n          }\n          name = n.getQualifiedName();\n          if (name == null) return;\n          break;\n        default:\n          return;\n      }\n\n      // We are only interested in global names.\n      Scope scope = t.getScope();\n      if (!isGlobalNameReference(name, scope)) {\n        return;\n      }\n\n      if (isSet) {\n        if (isGlobalScope(scope)) {\n          handleSetFromGlobal(t, n, parent, name, isPropAssign, type);\n        } else {\n          handleSetFromLocal(t, n, parent, name);\n        }\n      } else {\n        handleGet(t, n, parent, name);\n      }\n    }",
    "comment": "{@inheritDoc} */",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "Name.addProperty",
    "class_name": "com.google.javascript.jscomp.GlobalNamespace$Name",
    "signature": "com.google.javascript.jscomp.GlobalNamespace$Name.addProperty(String,boolean)",
    "snippet": "    Name addProperty(String name, boolean inExterns) {\n      if (props == null) {\n        props = new ArrayList<Name>();\n      }\n      Name node = new Name(name, this, inExterns);\n      props.add(node);\n      return node;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "Name.addRef",
    "class_name": "com.google.javascript.jscomp.GlobalNamespace$Name",
    "signature": "com.google.javascript.jscomp.GlobalNamespace$Name.addRef(Ref)",
    "snippet": "    void addRef(Ref ref) {\n      switch (ref.type) {\n        case SET_FROM_GLOBAL:\n          if (declaration == null) {\n            declaration = ref;\n            docInfo = getDocInfoForDeclaration(ref);\n          } else {\n            addRefInternal(ref);\n          }\n          globalSets++;\n          break;\n        case SET_FROM_LOCAL:\n          addRefInternal(ref);\n          localSets++;\n          break;\n        case PROTOTYPE_GET:\n        case DIRECT_GET:\n          addRefInternal(ref);\n          totalGets++;\n          break;\n        case ALIASING_GET:\n          addRefInternal(ref);\n          aliasingGets++;\n          totalGets++;\n          break;\n        case CALL_GET:\n          addRefInternal(ref);\n          callGets++;\n          totalGets++;\n          break;\n        default:\n          throw new IllegalStateException();\n      }\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "Name.getDocInfoForDeclaration",
    "class_name": "com.google.javascript.jscomp.GlobalNamespace$Name",
    "signature": "com.google.javascript.jscomp.GlobalNamespace$Name.getDocInfoForDeclaration(Ref)",
    "snippet": "    private static JSDocInfo getDocInfoForDeclaration(Ref ref) {\n      if (ref.node != null) {\n        Node refParent = ref.node.getParent();\n        switch (refParent.getType()) {\n          case Token.FUNCTION:\n          case Token.ASSIGN:\n            return refParent.getJSDocInfo();\n          case Token.VAR:\n            return ref.node == refParent.getFirstChild() ?\n                refParent.getJSDocInfo() : ref.node.getJSDocInfo();\n        }\n      }\n\n      return null;\n    }",
    "comment": " Tries to get the doc info for a given declaration ref. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "GoogleCodeRemoval.GoogleCodeRemoval",
    "class_name": "com.google.javascript.jscomp.GoogleCodeRemoval",
    "signature": "com.google.javascript.jscomp.GoogleCodeRemoval.GoogleCodeRemoval(AbstractCompiler)",
    "snippet": "  GoogleCodeRemoval(AbstractCompiler compiler) {\n    this.compiler = compiler;\n  }",
    "comment": " Creates an google code remover.  @param compiler The AbstractCompiler ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "GoogleCodeRemoval.process",
    "class_name": "com.google.javascript.jscomp.GoogleCodeRemoval",
    "signature": "com.google.javascript.jscomp.GoogleCodeRemoval.process(Node,Node)",
    "snippet": "  public void process(Node externs, Node root) {\n    NodeTraversal.traverse(compiler, root, new FindAbstractMethods());\n\n    for (RemovableAssignment assignment : abstractMethodAssignmentNodes) {\n      assignment.remove();\n    }\n  }",
    "comment": " {@inheritDoc} ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "FindAbstractMethods.visit",
    "class_name": "com.google.javascript.jscomp.GoogleCodeRemoval$FindAbstractMethods",
    "signature": "com.google.javascript.jscomp.GoogleCodeRemoval$FindAbstractMethods.visit(NodeTraversal,Node,Node)",
    "snippet": "    public void visit(NodeTraversal t, Node n, Node parent) {\n      if (n.getType() == Token.ASSIGN) {\n        Node nameNode = n.getFirstChild();\n        Node valueNode = n.getLastChild();\n\n        if (nameNode.isQualifiedName() &&\n            valueNode.isQualifiedName() &&\n            ABSTRACT_METHOD_NAME.equals(valueNode.getQualifiedName())) {\n          abstractMethodAssignmentNodes.add(new RemovableAssignment(\n              n.getFirstChild(), n, t));\n        }\n      }\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "GoogleCodingConvention.isConstant",
    "class_name": "com.google.javascript.jscomp.GoogleCodingConvention",
    "signature": "com.google.javascript.jscomp.GoogleCodingConvention.isConstant(String)",
    "snippet": "  @Override\n  public boolean isConstant(String name) {\n    if (name.length() <= 1) {\n      return false;\n    }\n\n    // In compiled code, '$' is often a namespace delimiter. To allow inlining\n    // of namespaced constants, we strip off any namespaces here.\n    int pos = name.lastIndexOf('$');\n    if (pos >= 0) {\n      name = name.substring(pos + 1);\n      if (name.length() == 0) {\n        return false;\n      }\n    }\n\n    if (!Character.isUpperCase(name.charAt(0))) {\n      return false;\n    }\n\n    // hack way of checking that there aren't any lower-case letters\n    return name.toUpperCase().equals(name);\n  }",
    "comment": " {@inheritDoc}  <p>This enforces the Google const name convention, that the first character after the last $ must be an upper-case letter and all subsequent letters must be upper case. The name must be at least 2 characters long.  <p>Examples: <pre> aaa          Not constant - lower-case letters in the name A            Not constant - too short goog$A       Constant - letters after the $ are upper-case. AA17         Constant - digits can appear after the first letter goog$7A      Not constant - first character after the $ must be upper case. $A           Constant - doesn't have to be anything in front of the $ </pre> ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "GoogleCodingConvention.isOptionalParameter",
    "class_name": "com.google.javascript.jscomp.GoogleCodingConvention",
    "signature": "com.google.javascript.jscomp.GoogleCodingConvention.isOptionalParameter(Node)",
    "snippet": "  @Override\n  public boolean isOptionalParameter(Node parameter) {\n    return parameter.getString().startsWith(OPTIONAL_ARG_PREFIX);\n  }",
    "comment": " {@inheritDoc}  <p>In Google code, parameter names beginning with {@code opt_} are treated as optional arguments. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "GoogleCodingConvention.isVarArgsParameter",
    "class_name": "com.google.javascript.jscomp.GoogleCodingConvention",
    "signature": "com.google.javascript.jscomp.GoogleCodingConvention.isVarArgsParameter(Node)",
    "snippet": "  @Override\n  public boolean isVarArgsParameter(Node parameter) {\n    return VAR_ARGS_NAME.equals(parameter.getString());\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "InlineVariables.InlineVariables",
    "class_name": "com.google.javascript.jscomp.InlineVariables",
    "signature": "com.google.javascript.jscomp.InlineVariables.InlineVariables(AbstractCompiler,Mode,boolean)",
    "snippet": "  InlineVariables(\n      AbstractCompiler compiler,\n      Mode mode,\n      boolean inlineAllStrings) {\n    this.compiler = compiler;\n    this.mode = mode;\n    this.inlineAllStrings = inlineAllStrings;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "InlineVariables.getFilterForMode",
    "class_name": "com.google.javascript.jscomp.InlineVariables",
    "signature": "com.google.javascript.jscomp.InlineVariables.getFilterForMode()",
    "snippet": "  private Predicate<Var> getFilterForMode() {\n    switch (mode) {\n      case ALL:\n        return Predicates.<Var>alwaysTrue();\n      case LOCALS_ONLY:\n        return new IdentifyLocals();\n      case CONSTANTS_ONLY:\n        return new IdentifyConstants();\n      default:\n        throw new IllegalStateException();\n    }\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "InlineVariables.process",
    "class_name": "com.google.javascript.jscomp.InlineVariables",
    "signature": "com.google.javascript.jscomp.InlineVariables.process(Node,Node)",
    "snippet": "  @Override\n  public void process(Node externs, Node root) {\n    ReferenceCollectingCallback callback = new ReferenceCollectingCallback(\n        compiler, new InliningBehavior(), getFilterForMode());\n    callback.process(externs, root);\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "IdentifyLocals.apply",
    "class_name": "com.google.javascript.jscomp.InlineVariables$IdentifyLocals",
    "signature": "com.google.javascript.jscomp.InlineVariables$IdentifyLocals.apply(Var)",
    "snippet": "    @Override\n    public boolean apply(Var var) {\n      return var.scope.isLocal();\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "InliningBehavior.afterExitScope",
    "class_name": "com.google.javascript.jscomp.InlineVariables$InliningBehavior",
    "signature": "com.google.javascript.jscomp.InlineVariables$InliningBehavior.afterExitScope(NodeTraversal,Map)",
    "snippet": "    @Override\n    public void afterExitScope(NodeTraversal t,\n        Map<Var, ReferenceCollection> referenceMap) {\n      collectAliasCandidates(t, referenceMap);\n      doInlinesForScope(t, referenceMap);\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "InliningBehavior.collectAliasCandidates",
    "class_name": "com.google.javascript.jscomp.InlineVariables$InliningBehavior",
    "signature": "com.google.javascript.jscomp.InlineVariables$InliningBehavior.collectAliasCandidates(NodeTraversal,Map)",
    "snippet": "    private void collectAliasCandidates(NodeTraversal t,\n        Map<Var, ReferenceCollection> referenceMap) {\n      if (mode != Mode.CONSTANTS_ONLY) {\n        for (Iterator<Var> it = t.getScope().getVars(); it.hasNext();) {\n          Var v = it.next();\n          ReferenceCollection referenceInfo = referenceMap.get(v);\n\n          // NOTE(nicksantos): Don't handle variables that are never used.\n          // The tests are much easier to write if you don't, and there's\n          // another pass that handles unused variables much more elegantly.\n          if (referenceInfo != null && referenceInfo.references.size() >= 2 &&\n              referenceInfo.isWellDefined() &&\n              referenceInfo.isAssignedOnce()) {\n            Reference init = referenceInfo.getInitializingReference();\n            Node value = init.getAssignedValue();\n            if (value != null && value.getType() == Token.NAME) {\n              aliasCandidates.put(value, new AliasCandidate(v, referenceInfo));\n            }\n          }\n        }\n      }\n    }",
    "comment": " If any of the variables are well-defined and alias other variables, mark them as aliasing candidates. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "InliningBehavior.doInlinesForScope",
    "class_name": "com.google.javascript.jscomp.InlineVariables$InliningBehavior",
    "signature": "com.google.javascript.jscomp.InlineVariables$InliningBehavior.doInlinesForScope(NodeTraversal,Map)",
    "snippet": "    private void doInlinesForScope(NodeTraversal t,\n        Map<Var, ReferenceCollection> referenceMap) {\n\n      for (Iterator<Var> it = t.getScope().getVars(); it.hasNext();) {\n        Var v = it.next();\n\n        ReferenceCollection referenceInfo = referenceMap.get(v);\n\n        // referenceInfo will be null if we're in constants-only mode\n        // and the variable is not a constant.\n        if (referenceInfo == null || isVarInlineForbidden(v) ||\n            staleVars.contains(v)) {\n          // Never try to inline exported variables or variables that\n          // were not collected or variables that have already been inlined.\n          continue;\n        } else if (isInlineableDeclaredConstant(v, referenceInfo)) {\n          Reference init = referenceInfo.getInitializingReferenceForConstants();\n          Node value = init.getAssignedValue();\n          inlineDeclaredConstant(v, value, referenceInfo.references);\n          staleVars.add(v);\n        } else if (mode == Mode.CONSTANTS_ONLY) {\n          // If we're in constants-only mode, don't run more aggressive\n          // inlining heuristics. See InlineConstantsTest.\n          continue;\n        } else {\n          inlineNonConstants(v, referenceInfo);\n        }\n      }\n    }",
    "comment": " For all variables in this scope, see if they are only used once. If it looks safe to do so, inline them. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "JSModule.JSModule",
    "class_name": "com.google.javascript.jscomp.JSModule",
    "signature": "com.google.javascript.jscomp.JSModule.JSModule(String)",
    "snippet": "  public JSModule(String name) {\n    this.name = name;\n  }",
    "comment": " Creates an instance.  @param name A unique name for the module ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "JSModule.add",
    "class_name": "com.google.javascript.jscomp.JSModule",
    "signature": "com.google.javascript.jscomp.JSModule.add(CompilerInput)",
    "snippet": "  public void add(CompilerInput input) {\n    inputs.add(input);\n    input.setModule(this);\n  }",
    "comment": "Adds a source code input to this module. */",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "JSModule.add",
    "class_name": "com.google.javascript.jscomp.JSModule",
    "signature": "com.google.javascript.jscomp.JSModule.add(JSSourceFile)",
    "snippet": "  public void add(JSSourceFile file) {\n    add(new CompilerInput(file));\n  }",
    "comment": "Adds a source file input to this module. */",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "JSModule.getDependencies",
    "class_name": "com.google.javascript.jscomp.JSModule",
    "signature": "com.google.javascript.jscomp.JSModule.getDependencies()",
    "snippet": "  public List<JSModule> getDependencies() {\n    return deps;\n  }",
    "comment": " Gets the list of modules that this module depends on.  @return A list that may be empty but not null ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "JSModule.getInputs",
    "class_name": "com.google.javascript.jscomp.JSModule",
    "signature": "com.google.javascript.jscomp.JSModule.getInputs()",
    "snippet": "  public List<CompilerInput> getInputs() {\n    return inputs;\n  }",
    "comment": " Gets this module's list of source code inputs.  @return A list that may be empty but not null ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "JSModuleGraph.JSModuleGraph",
    "class_name": "com.google.javascript.jscomp.JSModuleGraph",
    "signature": "com.google.javascript.jscomp.JSModuleGraph.JSModuleGraph(JSModule[])",
    "snippet": "  public JSModuleGraph(JSModule[] modulesInDepOrder) {\n    moduleDepths = new HashMap<JSModule, Integer>(modulesInDepOrder.length);\n    modulesByDepth = new ArrayList<List<JSModule>>();\n\n    for (JSModule module : modulesInDepOrder) {\n      int depth = 0;\n      for (JSModule dep : module.getDependencies()) {\n        Integer depDepth = moduleDepths.get(dep);\n        if (depDepth == null) {\n          throw new ModuleDependenceException(String.format(\n              \"Modules not in dependency order: %s preceded %s\",\n              module.getName(), dep.getName()),\n              module, dep);\n        }\n        depth = Math.max(depth, depDepth + 1);\n      }\n\n      moduleDepths.put(module, depth);\n      if (depth == modulesByDepth.size()) {\n        modulesByDepth.add(new ArrayList<JSModule>());\n      }\n      modulesByDepth.get(depth).add(module);\n    }\n  }",
    "comment": " Creates a module graph from a list of modules in dependency order. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "JSModuleGraph.getDeepestCommonDependencyInclusive",
    "class_name": "com.google.javascript.jscomp.JSModuleGraph",
    "signature": "com.google.javascript.jscomp.JSModuleGraph.getDeepestCommonDependencyInclusive(JSModule,JSModule)",
    "snippet": "  public JSModule getDeepestCommonDependencyInclusive(\n      JSModule m1, JSModule m2) {\n    if (m2 == m1 || dependsOn(m2, m1)) {\n      return m1;\n    } else if (dependsOn(m1, m2)) {\n      return m2;\n    }\n\n    return getDeepestCommonDependency(m1, m2);\n  }",
    "comment": " Finds the deepest common dependency of two modules, including the modules themselves.  @param m1 A module in this graph @param m2 A module in this graph @return The deepest common dep of {@code m1} and {@code m2}, or null if they have no common dependencies ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "JSSourceFile.fromCode",
    "class_name": "com.google.javascript.jscomp.JSSourceFile",
    "signature": "com.google.javascript.jscomp.JSSourceFile.fromCode(String,String)",
    "snippet": "  public static JSSourceFile fromCode(String fileName, String code) {\n    return new JSSourceFile(SourceFile.fromCode(fileName, code));\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "JSSourceFile.getCode",
    "class_name": "com.google.javascript.jscomp.JSSourceFile",
    "signature": "com.google.javascript.jscomp.JSSourceFile.getCode()",
    "snippet": "  @Override\n  public String getCode() throws IOException {\n    return referenced.getCode();\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "JsAst.JsAst",
    "class_name": "com.google.javascript.jscomp.JsAst",
    "signature": "com.google.javascript.jscomp.JsAst.JsAst(SourceFile)",
    "snippet": "  public JsAst(SourceFile sourceFile) {\n    this.sourceFile = sourceFile;\n    this.fileName = sourceFile.getName();\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "JsAst.createAst",
    "class_name": "com.google.javascript.jscomp.JsAst",
    "signature": "com.google.javascript.jscomp.JsAst.createAst(AbstractCompiler)",
    "snippet": "  private void createAst(AbstractCompiler compiler) {\n    try {\n      parse(compiler, sourceFile.getName(), sourceFile.getCode());\n    } catch (IOException e) {\n      compiler.report(\n          JSError.make(AbstractCompiler.READ_ERROR, sourceFile.getName()));\n    }\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "JsAst.getAstRoot",
    "class_name": "com.google.javascript.jscomp.JsAst",
    "signature": "com.google.javascript.jscomp.JsAst.getAstRoot(AbstractCompiler)",
    "snippet": "  @Override\n  public Node getAstRoot(AbstractCompiler compiler) {\n    if (root == null) {\n      createAst(compiler);\n    }\n    return root;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "JsAst.parse",
    "class_name": "com.google.javascript.jscomp.JsAst",
    "signature": "com.google.javascript.jscomp.JsAst.parse(AbstractCompiler,String,String)",
    "snippet": "  private void parse(AbstractCompiler compiler, String sourceName,\n      String sourceStr) {\n    try {\n      logger_.fine(\"Parsing: \" + sourceName);\n      root = ParserRunner.parse(sourceName, sourceStr,\n          compiler.getParserConfig(),\n          compiler.getDefaultErrorReporter(),\n          logger_);\n    } catch (IOException e) {\n      compiler.report(JSError.make(AbstractCompiler.READ_ERROR, sourceName));\n    }\n\n    if (root == null || compiler.hasHaltingErrors()) {\n      // There was a parse error or IOException, so use a dummy block.\n      root = new Node(Token.BLOCK);\n    } else {\n      compiler.prepareAst(root);\n    }\n\n    // Set the source name so that the compiler passes can track\n    // the source file and module.\n    root.putProp(Node.SOURCENAME_PROP, sourceName);\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "LightweightMessageFormatter.LightweightMessageFormatter",
    "class_name": "com.google.javascript.jscomp.LightweightMessageFormatter",
    "signature": "com.google.javascript.jscomp.LightweightMessageFormatter.LightweightMessageFormatter(SourceExcerptProvider)",
    "snippet": "  public LightweightMessageFormatter(SourceExcerptProvider source) {\n    this(source, LINE);\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "LightweightMessageFormatter.LightweightMessageFormatter",
    "class_name": "com.google.javascript.jscomp.LightweightMessageFormatter",
    "signature": "com.google.javascript.jscomp.LightweightMessageFormatter.LightweightMessageFormatter(SourceExcerptProvider,SourceExcerpt)",
    "snippet": "  public LightweightMessageFormatter(SourceExcerptProvider source,\n      SourceExcerpt excerpt) {\n    super(source);\n    Preconditions.checkNotNull(source);\n    this.excerpt = excerpt;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "MakeDeclaredNamesUnique.MakeDeclaredNamesUnique",
    "class_name": "com.google.javascript.jscomp.MakeDeclaredNamesUnique",
    "signature": "com.google.javascript.jscomp.MakeDeclaredNamesUnique.MakeDeclaredNamesUnique()",
    "snippet": "  MakeDeclaredNamesUnique() {\n    this.rootRenamer = new ContextualRenamer();\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "MakeDeclaredNamesUnique.enterScope",
    "class_name": "com.google.javascript.jscomp.MakeDeclaredNamesUnique",
    "signature": "com.google.javascript.jscomp.MakeDeclaredNamesUnique.enterScope(NodeTraversal)",
    "snippet": "  @Override\n  public void enterScope(NodeTraversal t) {\n    Node declarationRoot = t.getScopeRoot();\n    Renamer renamer;\n    if (nameStack.isEmpty()) {\n      // If the contextual renamer is being used the starting context can not\n      // be a function.\n      Preconditions.checkState(\n          declarationRoot.getType() != Token.FUNCTION ||\n          !(rootRenamer instanceof ContextualRenamer));\n      Preconditions.checkState(t.inGlobalScope());\n      renamer = rootRenamer;\n    } else {\n      renamer = nameStack.peek().forChildScope();\n    }\n\n    if (declarationRoot.getType() == Token.FUNCTION) {\n      // Add the function parameters\n      Node fnParams = declarationRoot.getFirstChild().getNext();\n      for (Node c = fnParams.getFirstChild(); c != null; c = c.getNext()) {\n        String name = c.getString();\n        renamer.addDeclaredName(name);\n      }\n\n      // Add the function body declarations\n      Node functionBody = declarationRoot.getLastChild();\n      findDeclaredNames(functionBody, null, renamer);\n    } else {\n      // Add the block declarations\n      findDeclaredNames(declarationRoot, null, renamer);\n    }\n    nameStack.push(renamer);\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "MakeDeclaredNamesUnique.exitScope",
    "class_name": "com.google.javascript.jscomp.MakeDeclaredNamesUnique",
    "signature": "com.google.javascript.jscomp.MakeDeclaredNamesUnique.exitScope(NodeTraversal)",
    "snippet": "  @Override\n  public void exitScope(NodeTraversal t) {\n    if (!t.inGlobalScope()) {\n      nameStack.pop();\n    }\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "MakeDeclaredNamesUnique.findDeclaredNames",
    "class_name": "com.google.javascript.jscomp.MakeDeclaredNamesUnique",
    "signature": "com.google.javascript.jscomp.MakeDeclaredNamesUnique.findDeclaredNames(Node,Node,Renamer)",
    "snippet": "  private void findDeclaredNames(Node n, Node parent, Renamer renamer) {\n    // Do a shallow traversal, so don't traverse into function declarations,\n    // except for the name of the function itself.\n    if (parent == null\n        || parent.getType() != Token.FUNCTION\n        || n == parent.getFirstChild()) {\n      if (NodeUtil.isVarDeclaration(n)) {\n        renamer.addDeclaredName(n.getString());\n      } else if (NodeUtil.isFunctionDeclaration(n)) {\n        Node nameNode = n.getFirstChild();\n        renamer.addDeclaredName(nameNode.getString());\n      }\n\n      for (Node c = n.getFirstChild(); c != null; c = c.getNext()) {\n        findDeclaredNames(c, n, renamer);\n      }\n    }\n  }",
    "comment": " Traverses the current scope and collects declared names.  Does not decent into functions or add CATCH exceptions. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "MakeDeclaredNamesUnique.getContextualRenameInverter",
    "class_name": "com.google.javascript.jscomp.MakeDeclaredNamesUnique",
    "signature": "com.google.javascript.jscomp.MakeDeclaredNamesUnique.getContextualRenameInverter(AbstractCompiler)",
    "snippet": "  static CompilerPass getContextualRenameInverter(AbstractCompiler compiler) {\n    return new ContextualRenameInverter(compiler);\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "MakeDeclaredNamesUnique.getReplacementName",
    "class_name": "com.google.javascript.jscomp.MakeDeclaredNamesUnique",
    "signature": "com.google.javascript.jscomp.MakeDeclaredNamesUnique.getReplacementName(String)",
    "snippet": "  private String getReplacementName(String oldName) {\n    for (Renamer names : nameStack) {\n      String newName = names.getReplacementName(oldName);\n      if (newName != null) {\n        return newName;\n      }\n    }\n    return null;\n  }",
    "comment": " Walks the stack of name maps and finds the replacement name for the current scope. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "MakeDeclaredNamesUnique.shouldTraverse",
    "class_name": "com.google.javascript.jscomp.MakeDeclaredNamesUnique",
    "signature": "com.google.javascript.jscomp.MakeDeclaredNamesUnique.shouldTraverse(NodeTraversal,Node,Node)",
    "snippet": "  @Override\n  public boolean shouldTraverse(NodeTraversal t, Node n, Node parent) {\n\n    switch (n.getType()) {\n      case Token.FUNCTION:\n        {\n          // Add recursive function name, if needed.\n          // NOTE: \"enterScope\" is called after we need to pick up this name.\n          Renamer renamer = nameStack.peek().forChildScope();\n\n          // If needed, add the function recursive name.\n          String name = n.getFirstChild().getString();\n          if (name != null && !name.isEmpty() && parent != null\n              && !NodeUtil.isFunctionDeclaration(n)) {\n            renamer.addDeclaredName(name);\n          }\n\n          nameStack.push(renamer);\n        }\n        break;\n\n      case Token.CATCH:\n        {\n          Renamer renamer = nameStack.peek().forChildScope();\n\n          String name = n.getFirstChild().getString();\n          renamer.addDeclaredName(name);\n\n          nameStack.push(renamer);\n        }\n        break;\n    }\n\n    return true;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "MakeDeclaredNamesUnique.visit",
    "class_name": "com.google.javascript.jscomp.MakeDeclaredNamesUnique",
    "signature": "com.google.javascript.jscomp.MakeDeclaredNamesUnique.visit(NodeTraversal,Node,Node)",
    "snippet": "  @Override\n  public void visit(NodeTraversal t, Node n, Node parent) {\n    switch (n.getType()) {\n      case Token.NAME:\n        String newName = getReplacementName(n.getString());\n        if (newName != null) {\n          Renamer renamer = nameStack.peek();\n          if (renamer.stripConstIfReplaced()) {\n            // TODO(johnlenz): Do we need to do anything about the javadoc?\n            n.removeProp(Node.IS_CONSTANT_NAME);\n          }\n          n.setString(newName);\n          t.getCompiler().reportCodeChange();\n        }\n        break;\n\n      case Token.FUNCTION:\n        // Remove function recursive name (if any).\n        nameStack.pop();\n        break;\n\n      case Token.CATCH:\n        // Remove catch except name from the stack of names.\n        nameStack.pop();\n        break;\n    }\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "ContextualRenameInverter.enterScope",
    "class_name": "com.google.javascript.jscomp.MakeDeclaredNamesUnique$ContextualRenameInverter",
    "signature": "com.google.javascript.jscomp.MakeDeclaredNamesUnique$ContextualRenameInverter.enterScope(NodeTraversal)",
    "snippet": "    public void enterScope(NodeTraversal t) {\n      if (t.inGlobalScope()) {\n        return;\n      }\n\n      referenceStack.push(referencedNames);\n      referencedNames = Sets.newHashSet();\n    }",
    "comment": " Prepare a set for the new scope. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "ContextualRenameInverter.exitScope",
    "class_name": "com.google.javascript.jscomp.MakeDeclaredNamesUnique$ContextualRenameInverter",
    "signature": "com.google.javascript.jscomp.MakeDeclaredNamesUnique$ContextualRenameInverter.exitScope(NodeTraversal)",
    "snippet": "    public void exitScope(NodeTraversal t) {\n      if (t.inGlobalScope()) {\n        return;\n      }\n\n      for (Iterator<Var> it = t.getScope().getVars(); it.hasNext();) {\n        Var v = it.next();\n        handleScopeVar(v);\n      }\n\n      // Merge any names that were referenced but not declared in the current\n      // scope.\n      Set<String> current = referencedNames;\n      referencedNames = referenceStack.pop();\n      // If there isn't anything left in the stack we will be going into the\n      // global scope: don't try to build a set of referenced names for the\n      // global scope.\n      if (!referenceStack.isEmpty()) {\n        referencedNames.addAll(current);\n      }\n    }",
    "comment": " Rename vars for the current scope, and merge any referenced  names into the parent scope reference set. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "ContextualRenameInverter.process",
    "class_name": "com.google.javascript.jscomp.MakeDeclaredNamesUnique$ContextualRenameInverter",
    "signature": "com.google.javascript.jscomp.MakeDeclaredNamesUnique$ContextualRenameInverter.process(Node,Node)",
    "snippet": "    public void process(Node externs, Node js) {\n      NodeTraversal.traverse(compiler, js, this);\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "ContextualRenameInverter.shouldTraverse",
    "class_name": "com.google.javascript.jscomp.MakeDeclaredNamesUnique$ContextualRenameInverter",
    "signature": "com.google.javascript.jscomp.MakeDeclaredNamesUnique$ContextualRenameInverter.shouldTraverse(NodeTraversal,Node,Node)",
    "snippet": "    @Override\n    public boolean shouldTraverse(NodeTraversal t, Node n, Node parent) {\n      return true;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "ContextualRenameInverter.visit",
    "class_name": "com.google.javascript.jscomp.MakeDeclaredNamesUnique$ContextualRenameInverter",
    "signature": "com.google.javascript.jscomp.MakeDeclaredNamesUnique$ContextualRenameInverter.visit(NodeTraversal,Node,Node)",
    "snippet": "    @Override\n    public void visit(NodeTraversal t, Node node, Node parent) {\n      if (t.inGlobalScope()) {\n        return;\n      }\n\n      if (NodeUtil.isReferenceName(node)) {\n        String name = node.getString();\n        // Add all referenced names to the set so it is possible to check for\n        // conflicts.\n        referencedNames.add(name);\n        // Store only references to candidate names in the node map.\n        if (containsSeparator(name)) {\n          addCandidateNameReference(name, node);\n        }\n      }\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "ContextualRenamer.addDeclaredName",
    "class_name": "com.google.javascript.jscomp.MakeDeclaredNamesUnique$ContextualRenamer",
    "signature": "com.google.javascript.jscomp.MakeDeclaredNamesUnique$ContextualRenamer.addDeclaredName(String)",
    "snippet": "    @Override\n    public void addDeclaredName(String name) {\n      if (!name.equals(ARGUMENTS)) {\n        if (global) {\n          reserveName(name);\n        } else {\n          // It hasn't been declared locally yet, so increment the count.\n          if (!declarations.containsKey(name)) {\n            int id = incrementNameCount(name);\n            String newName = null;\n            if (id != 0) {\n              newName = getUniqueName(name, id);\n            }\n            declarations.put(name, newName);\n          }\n        }\n      }\n    }",
    "comment": " Adds a name to the map of names declared in this scope. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "ContextualRenamer.forChildScope",
    "class_name": "com.google.javascript.jscomp.MakeDeclaredNamesUnique$ContextualRenamer",
    "signature": "com.google.javascript.jscomp.MakeDeclaredNamesUnique$ContextualRenamer.forChildScope()",
    "snippet": "    @Override\n    public Renamer forChildScope() {\n      return new ContextualRenamer(nameUsage);\n    }",
    "comment": " Create a ContextualRenamer ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "ContextualRenamer.getReplacementName",
    "class_name": "com.google.javascript.jscomp.MakeDeclaredNamesUnique$ContextualRenamer",
    "signature": "com.google.javascript.jscomp.MakeDeclaredNamesUnique$ContextualRenamer.getReplacementName(String)",
    "snippet": "    @Override\n    public String getReplacementName(String oldName) {\n      return declarations.get(oldName);\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "ContextualRenamer.incrementNameCount",
    "class_name": "com.google.javascript.jscomp.MakeDeclaredNamesUnique$ContextualRenamer",
    "signature": "com.google.javascript.jscomp.MakeDeclaredNamesUnique$ContextualRenamer.incrementNameCount(String)",
    "snippet": "    private int incrementNameCount(String name) {\n      return nameUsage.add(name, 1);\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "ContextualRenamer.reserveName",
    "class_name": "com.google.javascript.jscomp.MakeDeclaredNamesUnique$ContextualRenamer",
    "signature": "com.google.javascript.jscomp.MakeDeclaredNamesUnique$ContextualRenamer.reserveName(String)",
    "snippet": "    private void reserveName(String name) {\n      nameUsage.setCount(name, 0, 1);\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "MinimizeExitPoints.MinimizeExitPoints",
    "class_name": "com.google.javascript.jscomp.MinimizeExitPoints",
    "signature": "com.google.javascript.jscomp.MinimizeExitPoints.MinimizeExitPoints(AbstractCompiler)",
    "snippet": "  MinimizeExitPoints(AbstractCompiler compiler) {\n    this.compiler = compiler;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "MinimizeExitPoints.process",
    "class_name": "com.google.javascript.jscomp.MinimizeExitPoints",
    "signature": "com.google.javascript.jscomp.MinimizeExitPoints.process(Node,Node)",
    "snippet": "  @Override\n  public void process(Node externs, Node root) {\n    NodeTraversal.traverse(compiler, root, this);\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "MinimizeExitPoints.visit",
    "class_name": "com.google.javascript.jscomp.MinimizeExitPoints",
    "signature": "com.google.javascript.jscomp.MinimizeExitPoints.visit(NodeTraversal,Node,Node)",
    "snippet": "  @Override\n  public void visit(NodeTraversal t, Node n, Node parent) {\n    switch (n.getType()) {\n      case Token.LABEL:\n        tryMinimizeExits(\n            n.getLastChild(), Token.BREAK, n.getFirstChild().getString());\n        break;\n\n      case Token.FOR:\n      case Token.WHILE:\n        tryMinimizeExits(\n            NodeUtil.getLoopCodeBlock(n), Token.CONTINUE, null);\n        break;\n\n      case Token.DO:\n        tryMinimizeExits(\n            NodeUtil.getLoopCodeBlock(n), Token.CONTINUE, null);\n\n        Node cond = NodeUtil.getConditionExpression(n);\n        if (NodeUtil.isLiteralValue(cond) && !NodeUtil.getBooleanValue(cond)) {\n          // Normally, we wouldn't be able to optimize BREAKs inside a loop\n          // but as we know the condition will always false, we can treat them\n          // as we would a CONTINUE.\n          tryMinimizeExits(\n              n.getFirstChild(), Token.BREAK, null);\n        }\n        break;\n\n      case Token.FUNCTION:\n        tryMinimizeExits(\n            n.getLastChild(), Token.RETURN, null);\n        break;\n    }\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "NameGenerator.NameGenerator",
    "class_name": "com.google.javascript.jscomp.NameGenerator",
    "signature": "com.google.javascript.jscomp.NameGenerator.NameGenerator(Set,String,char[])",
    "snippet": "  NameGenerator(Set<String> reservedNames, String prefix,\n      @Nullable char[] reservedCharacters) {\n    this.reservedNames = reservedNames;\n    this.prefix = prefix;\n\n    // build the character arrays to use\n    this.firstChars = reserveCharacters(FIRST_CHAR, reservedCharacters);\n    this.nonFirstChars = reserveCharacters(NONFIRST_CHAR, reservedCharacters);\n\n    checkPrefix(prefix);\n  }",
    "comment": " Creates a NameGenerator.  @param reservedNames set of names that are reserved; generated names will not include these names. This set is referenced rather than copied, so changes to the set will be reflected in how names are generated. @param prefix all generated names begin with this prefix. @param reservedCharacters If specified these characters won't be used in generated names ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "NameGenerator.checkPrefix",
    "class_name": "com.google.javascript.jscomp.NameGenerator",
    "signature": "com.google.javascript.jscomp.NameGenerator.checkPrefix(String)",
    "snippet": "  private void checkPrefix(String prefix) {\n    if (prefix.length() > 0) {\n      // Make sure that prefix starts with a legal character.\n      if (!contains(firstChars, prefix.charAt(0))) {\n        throw new IllegalArgumentException(\"prefix must start with one of: \" +\n                                           Arrays.toString(firstChars));\n      }\n      for (int pos = 1; pos < prefix.length(); ++pos) {\n        if (!contains(nonFirstChars, prefix.charAt(pos))) {\n          throw new IllegalArgumentException(\"prefix has invalid characters, \" +\n                                             \"must be one of: \" +\n                                             Arrays.toString(nonFirstChars));\n        }\n      }\n    }\n  }",
    "comment": "Validates a name prefix. */",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "NameGenerator.generateNextName",
    "class_name": "com.google.javascript.jscomp.NameGenerator",
    "signature": "com.google.javascript.jscomp.NameGenerator.generateNextName()",
    "snippet": "  String generateNextName() {\n    while (true) {\n      String name = prefix;\n      \n      int i = nameCount;\n      \n      if (name.isEmpty()) {\n        int pos = i % firstChars.length;\n        name += firstChars[pos];\n        i /= firstChars.length;\n      }\n\n      while (i > 0) {\n        i--;\n        int pos = i % nonFirstChars.length;\n        name += nonFirstChars[pos];\n        i /= nonFirstChars.length;\n      }\n\n      nameCount++;\n      \n      // Make sure it's not a JS keyword or reserved name.\n      if (TokenStream.isKeyword(name) || reservedNames.contains(name)) {\n        continue;\n      }\n      \n      return name;\n    }\n  }",
    "comment": " Generates the next short name. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "NameGenerator.reserveCharacters",
    "class_name": "com.google.javascript.jscomp.NameGenerator",
    "signature": "com.google.javascript.jscomp.NameGenerator.reserveCharacters(char[],char[])",
    "snippet": "  static char[] reserveCharacters(char[] chars, char[] reservedCharacters) {\n    if (reservedCharacters == null || reservedCharacters.length == 0) {\n      return chars;\n    }    \n    Set<Character> charSet = Sets.newLinkedHashSet(Chars.asList(chars));\n    for (char reservedCharacter : reservedCharacters) {\n      charSet.remove(reservedCharacter);\n    }\n    return Chars.toArray(charSet);\n  }",
    "comment": " Provides the array of available characters based on the specified arrays. @param chars The list of characters that are legal @param reservedCharacters The characters that should not be used @return An array of characters to use. Will return the chars array if reservedCharacters is null or empty, otherwise creates a new array. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "NodeTraversal.NodeTraversal",
    "class_name": "com.google.javascript.jscomp.NodeTraversal",
    "signature": "com.google.javascript.jscomp.NodeTraversal.NodeTraversal(AbstractCompiler,Callback)",
    "snippet": "  public NodeTraversal(AbstractCompiler compiler, Callback cb) {\n    this(compiler, cb, new SyntacticScopeCreator(compiler));\n  }",
    "comment": " Creates a node traversal using the specified callback interface. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "NodeTraversal.NodeTraversal",
    "class_name": "com.google.javascript.jscomp.NodeTraversal",
    "signature": "com.google.javascript.jscomp.NodeTraversal.NodeTraversal(AbstractCompiler,Callback,ScopeCreator)",
    "snippet": "  public NodeTraversal(AbstractCompiler compiler, Callback cb,\n      ScopeCreator scopeCreator) {\n    this.callback = cb;\n    if (cb instanceof ScopedCallback) {\n      this.scopeCallback = (ScopedCallback) cb;\n    }\n    this.compiler = compiler;\n    this.sourceName = \"\";\n    this.scopeCreator = scopeCreator;\n  }",
    "comment": " Creates a node traversal using the specified callback interface and the scope creator. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "NodeTraversal.getControlFlowGraph",
    "class_name": "com.google.javascript.jscomp.NodeTraversal",
    "signature": "com.google.javascript.jscomp.NodeTraversal.getControlFlowGraph()",
    "snippet": "  public ControlFlowGraph<Node> getControlFlowGraph() {\n    if (cfgs.peek() == null) {\n      ControlFlowAnalysis cfa = new ControlFlowAnalysis(compiler, false);\n      cfa.process(null, getScopeRoot());\n      cfgs.pop();\n      cfgs.push(cfa.getCfg());\n    }\n    return cfgs.peek();\n  }",
    "comment": "Gets the control flow graph for the current JS scope. */",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "NodeTraversal.getInput",
    "class_name": "com.google.javascript.jscomp.NodeTraversal",
    "signature": "com.google.javascript.jscomp.NodeTraversal.getInput()",
    "snippet": "  public CompilerInput getInput() {\n    return compiler.getInput(sourceName);\n  }",
    "comment": " Gets the current input source. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "NodeTraversal.getModule",
    "class_name": "com.google.javascript.jscomp.NodeTraversal",
    "signature": "com.google.javascript.jscomp.NodeTraversal.getModule()",
    "snippet": "  public JSModule getModule() {\n    CompilerInput input = getInput();\n    return input == null ? null : input.getModule();\n  }",
    "comment": " Gets the current input module. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "NodeTraversal.getScope",
    "class_name": "com.google.javascript.jscomp.NodeTraversal",
    "signature": "com.google.javascript.jscomp.NodeTraversal.getScope()",
    "snippet": "  public Scope getScope() {\n    Scope scope = scopes.isEmpty() ? null : scopes.peek();\n    if (scopeRoots.isEmpty()) {\n      return scope;\n    }\n\n    Iterator<Node> it = scopeRoots.descendingIterator();\n    while (it.hasNext()) {\n      scope = scopeCreator.createScope(it.next(), scope);\n      scopes.push(scope);\n    }\n    scopeRoots.clear();\n\n    return scope;\n  }",
    "comment": "Gets the current scope. */",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "NodeTraversal.getScopeDepth",
    "class_name": "com.google.javascript.jscomp.NodeTraversal",
    "signature": "com.google.javascript.jscomp.NodeTraversal.getScopeDepth()",
    "snippet": "  int getScopeDepth() {\n    return scopes.size() + scopeRoots.size();\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "NodeTraversal.getScopeRoot",
    "class_name": "com.google.javascript.jscomp.NodeTraversal",
    "signature": "com.google.javascript.jscomp.NodeTraversal.getScopeRoot()",
    "snippet": "  public Node getScopeRoot() {\n    if (scopeRoots.isEmpty()) {\n      return scopes.peek().getRootNode();\n    } else {\n      return scopeRoots.peek();\n    }\n  }",
    "comment": "Returns the current scope's root. */",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "NodeTraversal.getSourceName",
    "class_name": "com.google.javascript.jscomp.NodeTraversal",
    "signature": "com.google.javascript.jscomp.NodeTraversal.getSourceName()",
    "snippet": "  public String getSourceName() {\n    return sourceName;\n  }",
    "comment": " Gets the current input source name.  @return A string that may be empty, but not null ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "NodeTraversal.getSourceName",
    "class_name": "com.google.javascript.jscomp.NodeTraversal",
    "signature": "com.google.javascript.jscomp.NodeTraversal.getSourceName(Node)",
    "snippet": "  private static String getSourceName(Node n) {\n    String name = (String) n.getProp(Node.SOURCENAME_PROP);\n    return name == null ? \"\" : name;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "NodeTraversal.inGlobalScope",
    "class_name": "com.google.javascript.jscomp.NodeTraversal",
    "signature": "com.google.javascript.jscomp.NodeTraversal.inGlobalScope()",
    "snippet": "  boolean inGlobalScope() {\n    return getScopeDepth() <= 1;\n  }",
    "comment": " Determines whether the traversal is currently in the global scope. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "NodeTraversal.popScope",
    "class_name": "com.google.javascript.jscomp.NodeTraversal",
    "signature": "com.google.javascript.jscomp.NodeTraversal.popScope()",
    "snippet": "  private void popScope() {\n    if (scopeCallback != null) {\n      scopeCallback.exitScope(this);\n    }\n    if (scopeRoots.isEmpty()) {\n      scopes.pop();\n    } else {\n      scopeRoots.pop();\n    }\n    cfgs.pop();\n  }",
    "comment": "Pops back to the previous scope (e.g. when leaving a function). */",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "NodeTraversal.pushScope",
    "class_name": "com.google.javascript.jscomp.NodeTraversal",
    "signature": "com.google.javascript.jscomp.NodeTraversal.pushScope(Node)",
    "snippet": "  private void pushScope(Node node) {\n    Preconditions.checkState(curNode != null);\n    scopeRoots.push(node);\n    cfgs.push(null);\n    if (scopeCallback != null) {\n      scopeCallback.enterScope(this);\n    }\n  }",
    "comment": "Creates a new scope (e.g. when entering a function). */",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "NodeTraversal.traverse",
    "class_name": "com.google.javascript.jscomp.NodeTraversal",
    "signature": "com.google.javascript.jscomp.NodeTraversal.traverse(AbstractCompiler,Node,Callback)",
    "snippet": "  public static void traverse(\n      AbstractCompiler compiler, Node root, Callback cb) {\n    NodeTraversal t = new NodeTraversal(compiler, cb);\n    t.traverse(root);\n  }",
    "comment": " Traverses a node recursively. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "NodeTraversal.traverse",
    "class_name": "com.google.javascript.jscomp.NodeTraversal",
    "signature": "com.google.javascript.jscomp.NodeTraversal.traverse(Node)",
    "snippet": "  public void traverse(Node root) {\n    try {\n      sourceName = \"\";\n      curNode = root;\n      pushScope(root);\n      traverseBranch(root, null);\n      popScope();\n    } catch (Exception unexpectedException) {\n      throwUnexpectedException(unexpectedException);\n    }\n  }",
    "comment": " Traverses a parse tree recursively. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "NodeTraversal.traverseBranch",
    "class_name": "com.google.javascript.jscomp.NodeTraversal",
    "signature": "com.google.javascript.jscomp.NodeTraversal.traverseBranch(Node,Node)",
    "snippet": "  @SuppressWarnings(\"fallthrough\")\n  private void traverseBranch(Node n, Node parent) {\n    int type = n.getType();\n    if (type == Token.SCRIPT) {\n      sourceName = getSourceName(n);\n    }\n\n    curNode = n;\n    if (!callback.shouldTraverse(this, n, parent)) return;\n\n    switch (type) {\n      case Token.CATCH:\n        Preconditions.checkState(n.getChildCount() == 3);\n        Preconditions.checkState(n.getFirstChild().getType() == Token.NAME);\n        // the first child is the catch var and the third child\n        // is the code block\n        traverseBranch(n.getFirstChild(), n);\n        traverseBranch(n.getFirstChild().getNext().getNext(), n);\n        break;\n\n      case Token.FUNCTION:\n        traverseFunction(n, parent);\n        break;\n\n      default:\n        for (Node child = n.getFirstChild(); child != null; ) {\n          // child could be replaced, in which case our child node\n          // would no longer point to the true next\n          Node next = child.getNext();\n          traverseBranch(child, n);\n          child = next;\n        }\n        break;\n    }\n\n    curNode = n;\n    callback.visit(this, n, parent);\n  }",
    "comment": " Traverses a branch. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "NodeTraversal.traverseFunction",
    "class_name": "com.google.javascript.jscomp.NodeTraversal",
    "signature": "com.google.javascript.jscomp.NodeTraversal.traverseFunction(Node,Node)",
    "snippet": "  private void traverseFunction(Node n, Node parent) {\n    Preconditions.checkState(n.getChildCount() == 3);\n    Preconditions.checkState(n.getType() == Token.FUNCTION);\n\n    final Node fnName = n.getFirstChild();\n\n    boolean anonymous = parent != null && NodeUtil.isFunctionAnonymous(n);\n\n    if (!anonymous) {\n      // Named functions are parent of the containing scope.\n      traverseBranch(fnName, n);\n    }\n\n    curNode = n;\n    pushScope(n);\n\n    if (anonymous) {\n      // Anonymous function names are parent of the contained scope.\n      traverseBranch(fnName, n);\n    }\n\n    final Node args = fnName.getNext();\n    final Node body = args.getNext();\n\n    // Args\n    traverseBranch(args, n);\n\n    // Body\n    Preconditions.checkState(body.getNext() == null &&\n            body.getType() == Token.BLOCK);\n    traverseBranch(body, n);\n\n    popScope();\n  }",
    "comment": " Traverses a function. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "NodeTraversal.traverseRoots",
    "class_name": "com.google.javascript.jscomp.NodeTraversal",
    "signature": "com.google.javascript.jscomp.NodeTraversal.traverseRoots(AbstractCompiler,List,Callback)",
    "snippet": "  public static void traverseRoots(\n      AbstractCompiler compiler, List<Node> roots, Callback cb) {\n    NodeTraversal t = new NodeTraversal(compiler, cb);\n    t.traverseRoots(roots);\n  }",
    "comment": " Traverses a list of node trees. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "NodeTraversal.traverseRoots",
    "class_name": "com.google.javascript.jscomp.NodeTraversal",
    "signature": "com.google.javascript.jscomp.NodeTraversal.traverseRoots(List)",
    "snippet": "  public void traverseRoots(List<Node> roots) {\n    if (roots.isEmpty()) {\n      return;\n    }\n\n    try {\n      Node scopeRoot = roots.get(0).getParent();\n      Preconditions.checkState(scopeRoot != null);\n\n      sourceName = \"\";\n      curNode = scopeRoot;\n      pushScope(scopeRoot);\n\n      for (Node root : roots) {\n        Preconditions.checkState(root.getParent() == scopeRoot);\n        traverseBranch(root, scopeRoot);\n      }\n\n      popScope();\n    } catch (Exception unexpectedException) {\n      throwUnexpectedException(unexpectedException);\n    }\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "NodeTraversal.traverseRoots",
    "class_name": "com.google.javascript.jscomp.NodeTraversal",
    "signature": "com.google.javascript.jscomp.NodeTraversal.traverseRoots(Node[])",
    "snippet": "  public void traverseRoots(Node ... roots) {\n    traverseRoots(Lists.newArrayList(roots));\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "AbstractPostOrderCallback.shouldTraverse",
    "class_name": "com.google.javascript.jscomp.NodeTraversal$AbstractPostOrderCallback",
    "signature": "com.google.javascript.jscomp.NodeTraversal$AbstractPostOrderCallback.shouldTraverse(NodeTraversal,Node,Node)",
    "snippet": "    public final boolean shouldTraverse(NodeTraversal nodeTraversal, Node n,\n        Node parent) {\n      return true;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "AbstractShallowCallback.shouldTraverse",
    "class_name": "com.google.javascript.jscomp.NodeTraversal$AbstractShallowCallback",
    "signature": "com.google.javascript.jscomp.NodeTraversal$AbstractShallowCallback.shouldTraverse(NodeTraversal,Node,Node)",
    "snippet": "    public final boolean shouldTraverse(NodeTraversal nodeTraversal, Node n,\n        Node parent) {\n      // We do want to traverse the name of a named function, but we don't\n      // want to traverse the arguments or body.\n      return parent == null || parent.getType() != Token.FUNCTION ||\n          n == parent.getFirstChild();\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "NodeUtil.checkForStateChangeHelper",
    "class_name": "com.google.javascript.jscomp.NodeUtil",
    "signature": "com.google.javascript.jscomp.NodeUtil.checkForStateChangeHelper(Node,boolean)",
    "snippet": "  private static boolean checkForStateChangeHelper(\n      Node n, boolean checkForNewObjects) {\n    // Rather than id which ops may have side effects, id the ones\n    // that we know to be safe\n    switch (n.getType()) {\n      // other side-effect free statements and expressions\n      case Token.AND:\n      case Token.BLOCK:\n      case Token.EXPR_RESULT:\n      case Token.HOOK:\n      case Token.IF:\n      case Token.IN:\n      case Token.LP:\n      case Token.NUMBER:\n      case Token.OR:\n      case Token.THIS:\n      case Token.TRUE:\n      case Token.FALSE:\n      case Token.NULL:\n      case Token.STRING:\n      case Token.SWITCH:\n      case Token.TRY:\n      case Token.EMPTY:\n        break;\n\n      // Throws are by definition side effects\n      case Token.THROW:\n        return true;\n\n      case Token.OBJECTLIT:\n      case Token.ARRAYLIT:\n      case Token.REGEXP:\n        if (checkForNewObjects) {\n          return true;\n        }\n        break;\n\n      case Token.VAR:    // empty var statement (no declaration)\n      case Token.NAME:   // variable by itself\n        if (n.getFirstChild() != null)\n          return true;\n\n        break;\n\n      case Token.FUNCTION:\n        // Anonymous functions don't have side-effects, but named ones\n        // change the namespace. Therefore, we check if the function has\n        // a name. Either way, we don't need to check the children, since\n        // they aren't executed at declaration time.\n        //\n        return !isFunctionAnonymous(n);\n\n      case Token.NEW:\n        {\n          if (checkForNewObjects) {\n            return true;\n          }\n\n          // calls to constructors that have no side effects have the\n          // no side effect property set.\n          if (n.isNoSideEffectsCall()) {\n            break;\n          }\n\n          // certain constructors are certified side effect free\n          Node constructor = n.getFirstChild();\n          if (Token.NAME == constructor.getType()) {\n            String className = constructor.getString();\n            if (CONSTRUCTORS_WITHOUT_SIDE_EFFECTS.contains(className)) {\n              // loop below will see if the constructor parameters have\n              // side-effects\n              break;\n            }\n          } else {\n            // the constructor could also be an expression like\n            // new (useArray ? Object : Array)();\n          }\n        }\n        return true;\n\n      case Token.CALL:\n        // calls to functions that have no side effects have the no\n        // side effect property set.\n        if (n.isNoSideEffectsCall()) {\n          // loop below will see if the function parameters have\n          // side-effects\n          break;\n        }\n        return true;\n\n      default:\n        if (isSimpleOperatorType(n.getType()))\n          break;\n\n        if (isAssignmentOp(n)) {\n          // Assignments will have side effects if\n          // a) The RHS has side effects, or\n          // b) The LHS has side effects, or\n          // c) A name on the LHS will exist beyond the life of this statement.\n          if (checkForStateChangeHelper(\n                  n.getFirstChild(), checkForNewObjects) ||\n              checkForStateChangeHelper(\n                  n.getLastChild(), checkForNewObjects)) {\n            return true;\n          }\n\n          Node current = n.getFirstChild();\n          for (;\n               current.getType() == Token.GETPROP ||\n               current.getType() == Token.GETELEM;\n               current = current.getFirstChild()) { }\n\n          return !(isLiteralValue(current) ||\n              current.getType() == Token.FUNCTION);\n        }\n\n        return true;\n    }\n\n    for (Node c = n.getFirstChild(); c != null; c = c.getNext()) {\n      if (checkForStateChangeHelper(c, checkForNewObjects)) {\n        return true;\n      }\n    }\n\n    return false;\n  }",
    "comment": " Returns true if some node in n's subtree changes application state. If {@code checkForNewObjects} is true, we assume that newly created mutable objects (like object literals) change state. Otherwise, we assume that they have no side effects. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "NodeUtil.getInfoForNameNode",
    "class_name": "com.google.javascript.jscomp.NodeUtil",
    "signature": "com.google.javascript.jscomp.NodeUtil.getInfoForNameNode(Node)",
    "snippet": "  static JSDocInfo getInfoForNameNode(Node nameNode) {\n    JSDocInfo info = null;\n    Node parent = null;\n    if (nameNode != null) {\n      info = nameNode.getJSDocInfo();\n      parent = nameNode.getParent();\n    }\n\n    if (info == null && parent != null &&\n        ((parent.getType() == Token.VAR && parent.hasOneChild()) ||\n          parent.getType() == Token.FUNCTION)) {\n      info = parent.getJSDocInfo();\n    }\n    return info;\n  }",
    "comment": " @param nameNode A name node @return The JSDocInfo for the name node ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "NodeUtil.isAssignmentOp",
    "class_name": "com.google.javascript.jscomp.NodeUtil",
    "signature": "com.google.javascript.jscomp.NodeUtil.isAssignmentOp(Node)",
    "snippet": "  static boolean isAssignmentOp(Node n) {\n    switch (n.getType()){\n      case Token.ASSIGN:\n      case Token.ASSIGN_BITOR:\n      case Token.ASSIGN_BITXOR:\n      case Token.ASSIGN_BITAND:\n      case Token.ASSIGN_LSH:\n      case Token.ASSIGN_RSH:\n      case Token.ASSIGN_URSH:\n      case Token.ASSIGN_ADD:\n      case Token.ASSIGN_SUB:\n      case Token.ASSIGN_MUL:\n      case Token.ASSIGN_DIV:\n      case Token.ASSIGN_MOD:\n        return true;\n    }\n    return false;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "NodeUtil.isControlStructure",
    "class_name": "com.google.javascript.jscomp.NodeUtil",
    "signature": "com.google.javascript.jscomp.NodeUtil.isControlStructure(Node)",
    "snippet": "  static boolean isControlStructure(Node n) {\n    switch (n.getType()) {\n      case Token.FOR:\n      case Token.DO:\n      case Token.WHILE:\n      case Token.WITH:\n      case Token.IF:\n      case Token.LABEL:\n      case Token.TRY:\n      case Token.CATCH:\n      case Token.SWITCH:\n      case Token.CASE:\n      case Token.DEFAULT:\n        return true;\n      default:\n        return false;\n    }\n  }",
    "comment": " Determines whether the given node is a FOR, DO, WHILE, WITH, or IF node. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "NodeUtil.isExprAssign",
    "class_name": "com.google.javascript.jscomp.NodeUtil",
    "signature": "com.google.javascript.jscomp.NodeUtil.isExprAssign(Node)",
    "snippet": "  static boolean isExprAssign(Node n) {\n    return n.getType() == Token.EXPR_RESULT\n        && n.getFirstChild().getType() == Token.ASSIGN;\n  }",
    "comment": " Is this node an assignment expression statement?  @param n The node @return True if {@code n} is EXPR_RESULT and {@code n}'s first child is ASSIGN ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "NodeUtil.isExpressionNode",
    "class_name": "com.google.javascript.jscomp.NodeUtil",
    "signature": "com.google.javascript.jscomp.NodeUtil.isExpressionNode(Node)",
    "snippet": "  static boolean isExpressionNode(Node n) {\n    return n.getType() == Token.EXPR_RESULT;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "NodeUtil.isFunction",
    "class_name": "com.google.javascript.jscomp.NodeUtil",
    "signature": "com.google.javascript.jscomp.NodeUtil.isFunction(Node)",
    "snippet": "  static boolean isFunction(Node n) {\n    return n.getType() == Token.FUNCTION;\n  }",
    "comment": " Is this a FUNCTION node? ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "NodeUtil.isFunctionAnonymous",
    "class_name": "com.google.javascript.jscomp.NodeUtil",
    "signature": "com.google.javascript.jscomp.NodeUtil.isFunctionAnonymous(Node)",
    "snippet": "  static boolean isFunctionAnonymous(Node n) {\n    return !isStatement(n);\n  }",
    "comment": " Is a FUNCTION node an anonymous function? An anonymous function is one that has either no name or a name that is not added to the current scope.  <p>Some examples of anonymous functions: <pre> function () {} (function f() {})() [ function f() {} ] var f = function f() {}; for (function f() {};;) {} </pre>  <p>Some examples of functions that are <em>not</em> anonymous: <pre> function f() {} if (x); else function f() {} for (;;) { function f() {} } </pre>  @param n A FUNCTION node @return Whether n is an anonymous function ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "NodeUtil.isFunctionDeclaration",
    "class_name": "com.google.javascript.jscomp.NodeUtil",
    "signature": "com.google.javascript.jscomp.NodeUtil.isFunctionDeclaration(Node)",
    "snippet": "  static boolean isFunctionDeclaration(Node n) {\n    return n.getType() == Token.FUNCTION && !isFunctionAnonymous(n);\n  }",
    "comment": " Is this node a function declaration? A function declaration is a function that has a name that is added to the current scope (i.e. a function that is not anonymous; see {@link #isFunctionAnonymous}). ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "NodeUtil.isHoistedFunctionDeclaration",
    "class_name": "com.google.javascript.jscomp.NodeUtil",
    "signature": "com.google.javascript.jscomp.NodeUtil.isHoistedFunctionDeclaration(Node)",
    "snippet": "  static boolean isHoistedFunctionDeclaration(Node n) {\n    return NodeUtil.isFunctionDeclaration(n)\n        && (n.getParent().getType() == Token.SCRIPT\n            || n.getParent().getParent().getType() == Token.FUNCTION);\n  }",
    "comment": " Is this node a hoisted function declaration? A function declaration in the scope root is hoisted to the top of the scope. See {@link #isFunctionDeclaration}). ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "NodeUtil.isImmutableValue",
    "class_name": "com.google.javascript.jscomp.NodeUtil",
    "signature": "com.google.javascript.jscomp.NodeUtil.isImmutableValue(Node)",
    "snippet": "  static boolean isImmutableValue(Node n) {\n    switch (n.getType()) {\n      case Token.STRING:\n      case Token.NUMBER:\n      case Token.NULL:\n      case Token.TRUE:\n      case Token.FALSE:\n      case Token.VOID:\n        return true;\n      case Token.NEG:\n        return isImmutableValue(n.getFirstChild());\n      case Token.NAME:\n        String name = n.getString();\n        // We assume here that programs don't change the value of the keyword\n        // undefined to something other than the value undefined.\n        return \"undefined\".equals(name)\n            || \"Infinity\".equals(name)\n            || \"NaN\".equals(name);\n    }\n\n    return false;\n  }",
    "comment": " Returns true if this is an immutable value. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "NodeUtil.isLabelName",
    "class_name": "com.google.javascript.jscomp.NodeUtil",
    "signature": "com.google.javascript.jscomp.NodeUtil.isLabelName(Node)",
    "snippet": "  static boolean isLabelName(Node n) {\n    if (n != null && n.getType() == Token.NAME) {\n      Node parent = n.getParent();\n      switch (parent.getType()) {\n        case Token.LABEL:\n        case Token.BREAK:\n        case Token.CONTINUE:\n          if (n == parent.getFirstChild()) {\n            return true;\n          }\n      }\n    }\n    return false;\n  }",
    "comment": "@return Whether the node is a label name. */",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "NodeUtil.isLatin",
    "class_name": "com.google.javascript.jscomp.NodeUtil",
    "signature": "com.google.javascript.jscomp.NodeUtil.isLatin(String)",
    "snippet": "  static boolean isLatin(String s) {\n    char LARGEST_BASIC_LATIN = 0x7f;\n    int len = s.length();\n    for (int index = 0; index < len; index++) {\n      char c = s.charAt(index);\n      if (c > LARGEST_BASIC_LATIN) {\n        return false;\n      }\n    }\n    return true;\n  }",
    "comment": "Test if all characters in the string are in the Basic Latin (aka ASCII) character set - that they have UTF-16 values equal to or below 0x7f. This check can find which identifiers with Unicode characters need to be escaped in order to allow resulting files to be processed by non-Unicode aware UNIX tools and editors.  See http://en.wikipedia.org/wiki/Latin_characters_in_Unicode for more on Basic Latin.  @param s The string to be checked for ASCII-goodness.  @return True if all characters in the string are in Basic Latin set. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "NodeUtil.isLiteralValue",
    "class_name": "com.google.javascript.jscomp.NodeUtil",
    "signature": "com.google.javascript.jscomp.NodeUtil.isLiteralValue(Node)",
    "snippet": "  static boolean isLiteralValue(Node n) {\n    // TODO(nicksantos): Refine this function to catch more literals.\n    switch (n.getType()) {\n      case Token.ARRAYLIT:\n      case Token.OBJECTLIT:\n      case Token.REGEXP:\n        // Return true only if all children are const.\n        for (Node child = n.getFirstChild(); child != null;\n             child = child.getNext()) {\n          if (!isLiteralValue(child)) {\n            return false;\n          }\n        }\n        return true;\n\n      default:\n        return isImmutableValue(n);\n    }\n  }",
    "comment": " Returns true if this is a literal value. We define a literal value as any node that evaluates to the same thing regardless of when or where it is evaluated. So /xyz/ and [3, 5] are literals, but function() { return a; } is not. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "NodeUtil.isPrototypeProperty",
    "class_name": "com.google.javascript.jscomp.NodeUtil",
    "signature": "com.google.javascript.jscomp.NodeUtil.isPrototypeProperty(Node)",
    "snippet": "  static boolean isPrototypeProperty(Node n) {\n    String lhsString = n.getQualifiedName();\n    if (lhsString == null) {\n      return false;\n    }\n    int prototypeIdx = lhsString.indexOf(\".prototype.\");\n    return prototypeIdx != -1;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "NodeUtil.isPrototypePropertyDeclaration",
    "class_name": "com.google.javascript.jscomp.NodeUtil",
    "signature": "com.google.javascript.jscomp.NodeUtil.isPrototypePropertyDeclaration(Node)",
    "snippet": "  static boolean isPrototypePropertyDeclaration(Node n) {\n    if (!NodeUtil.isExprAssign(n)) {\n      return false;\n    }\n    return isPrototypeProperty(n.getFirstChild().getFirstChild());\n  }",
    "comment": " @return {@code true} if the node an assignment to a prototype property of some constructor. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "NodeUtil.isSimpleOperatorType",
    "class_name": "com.google.javascript.jscomp.NodeUtil",
    "signature": "com.google.javascript.jscomp.NodeUtil.isSimpleOperatorType(int)",
    "snippet": "  static boolean isSimpleOperatorType(int type) {\n    switch (type) {\n      case Token.ADD:\n      case Token.BITAND:\n      case Token.BITNOT:\n      case Token.BITOR:\n      case Token.BITXOR:\n      case Token.COMMA:\n      case Token.DIV:\n      case Token.EQ:\n      case Token.GE:\n      case Token.GETELEM:\n      case Token.GETPROP:\n      case Token.GT:\n      case Token.INSTANCEOF:\n      case Token.LE:\n      case Token.LSH:\n      case Token.LT:\n      case Token.MOD:\n      case Token.MUL:\n      case Token.NE:\n      case Token.NOT:\n      case Token.RSH:\n      case Token.SHEQ:\n      case Token.SHNE:\n      case Token.SUB:\n      case Token.TYPEOF:\n      case Token.VOID:\n      case Token.POS:\n      case Token.NEG:\n      case Token.URSH:\n        return true;\n\n      default:\n        return false;\n    }\n  }",
    "comment": " A \"simple\" operator is one whose children are expressions, has no direct side-effects (unlike '+='), and has no conditional aspects (unlike '||'). ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "NodeUtil.isStatement",
    "class_name": "com.google.javascript.jscomp.NodeUtil",
    "signature": "com.google.javascript.jscomp.NodeUtil.isStatement(Node)",
    "snippet": "  static boolean isStatement(Node n) {\n    Node parent = n.getParent();\n    // It is not possible to determine definitely if a node is a statement\n    // or not if it is not part of the AST.  A FUNCTION node, for instance,\n    // is either part of an expression (as a anonymous function) or as\n    // a statement.\n    Preconditions.checkState(parent != null);\n    switch (parent.getType()) {\n      case Token.SCRIPT:\n      case Token.BLOCK:\n      case Token.LABEL:\n        return true;\n      default:\n        return false;\n    }\n  }",
    "comment": " @return Whether the node is used as a statement. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "NodeUtil.isStatementBlock",
    "class_name": "com.google.javascript.jscomp.NodeUtil",
    "signature": "com.google.javascript.jscomp.NodeUtil.isStatementBlock(Node)",
    "snippet": "  static boolean isStatementBlock(Node n) {\n    return n.getType() == Token.SCRIPT || n.getType() == Token.BLOCK;\n  }",
    "comment": " @return Whether the node is of a type that contain other statements. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "NodeUtil.isValidPropertyName",
    "class_name": "com.google.javascript.jscomp.NodeUtil",
    "signature": "com.google.javascript.jscomp.NodeUtil.isValidPropertyName(String)",
    "snippet": "  static boolean isValidPropertyName(String name) {\n    return TokenStream.isJSIdentifier(name) &&\n        !TokenStream.isKeyword(name) &&\n        // no Unicode escaped characters - some browsers are less tolerant\n        // of Unicode characters that might be valid according to the\n        // language spec.\n        // Note that by this point, unicode escapes have been converted\n        // to UTF-16 characters, so we're only searching for character\n        // values, not escapes.\n        NodeUtil.isLatin(name);\n  }",
    "comment": " Determines whether the given name can appear on the right side of the dot operator. Many properties (like reserved words) cannot. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "NodeUtil.isVar",
    "class_name": "com.google.javascript.jscomp.NodeUtil",
    "signature": "com.google.javascript.jscomp.NodeUtil.isVar(Node)",
    "snippet": "  static boolean isVar(Node n) {\n    return n.getType() == Token.VAR;\n  }",
    "comment": " Is this a VAR node? ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "NodeUtil.isVarDeclaration",
    "class_name": "com.google.javascript.jscomp.NodeUtil",
    "signature": "com.google.javascript.jscomp.NodeUtil.isVarDeclaration(Node)",
    "snippet": "  static boolean isVarDeclaration(Node n) {\n    // There is no need to verify that parent != null because a NAME node\n    // always has a parent in a valid parse tree.\n    return n.getType() == Token.NAME && n.getParent().getType() == Token.VAR;\n  }",
    "comment": " Is this node the name of a variable being declared?  @param n The node @return True if {@code n} is NAME and {@code parent} is VAR ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "NodeUtil.mayHaveSideEffects",
    "class_name": "com.google.javascript.jscomp.NodeUtil",
    "signature": "com.google.javascript.jscomp.NodeUtil.mayHaveSideEffects(Node)",
    "snippet": "  static boolean mayHaveSideEffects(Node n) {\n    return checkForStateChangeHelper(n, false);\n  }",
    "comment": " Returns true if the node which may have side effects when executed. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "NodeUtil.newQualifiedNameNode",
    "class_name": "com.google.javascript.jscomp.NodeUtil",
    "signature": "com.google.javascript.jscomp.NodeUtil.newQualifiedNameNode(String,Node,String)",
    "snippet": "  static Node newQualifiedNameNode(String name, Node basisNode,\n      String originalName) {\n    Node node = newQualifiedNameNode(name, -1, -1);\n    setDebugInformation(node, basisNode, originalName);\n    return node;\n  }",
    "comment": " Creates a node representing a qualified name, copying over the source location information from the basis node and assigning the given original name to the node.  @param name A qualified name (e.g. \"foo\" or \"foo.bar.baz\") @param basisNode The node that represents the name as currently found in the AST. @param originalName The original name of the item being represented by the NAME node. Used for debugging information.  @return A NAME or GETPROP node ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "NodeUtil.newQualifiedNameNode",
    "class_name": "com.google.javascript.jscomp.NodeUtil",
    "signature": "com.google.javascript.jscomp.NodeUtil.newQualifiedNameNode(String,int,int)",
    "snippet": "  public static Node newQualifiedNameNode(String name, int lineno, int charno) {\n    int endPos = name.indexOf('.');\n    if (endPos == -1) {\n      return Node.newString(Token.NAME, name, lineno, charno);\n    }\n    Node node = Node.newString(Token.NAME, name.substring(0, endPos),\n                               lineno, charno);\n    int startPos;\n    do {\n      startPos = endPos + 1;\n      endPos = name.indexOf('.', startPos);\n      String part = (endPos == -1\n                     ? name.substring(startPos)\n                     : name.substring(startPos, endPos));\n      node = new Node(Token.GETPROP, node,\n                      Node.newString(Token.STRING, part, lineno, charno),\n                      lineno, charno);\n    } while (endPos != -1);\n\n    return node;\n  }",
    "comment": " Creates a node representing a qualified name.  @param name A qualified name (e.g. \"foo\" or \"foo.bar.baz\") @param lineno The source line offset. @param charno The source character offset from start of the line. @return A NAME or GETPROP node ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "NodeUtil.nodeTypeMayHaveSideEffects",
    "class_name": "com.google.javascript.jscomp.NodeUtil",
    "signature": "com.google.javascript.jscomp.NodeUtil.nodeTypeMayHaveSideEffects(Node)",
    "snippet": "  static boolean nodeTypeMayHaveSideEffects(Node n) {\n    if (NodeUtil.isAssignmentOp(n)) {\n      return true;\n    }\n\n    switch(n.getType()) {\n      case Token.CALL:\n      case Token.DELPROP:\n      case Token.NEW:\n      case Token.DEC:\n      case Token.INC:\n      case Token.THROW:\n        return true;\n      case Token.NAME:\n        // A variable definition.\n        return n.hasChildren();\n      default:\n        return false;\n    }\n  }",
    "comment": " Returns true if the current node's type implies side effects.  This is a non-recursive version of the may have side effects check; used to check wherever the current node's type is one of the reason's why a subtree has side effects. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "NodeUtil.opToStr",
    "class_name": "com.google.javascript.jscomp.NodeUtil",
    "signature": "com.google.javascript.jscomp.NodeUtil.opToStr(int)",
    "snippet": "  static String opToStr(int operator) {\n    switch (operator) {\n      case Token.BITOR: return \"|\";\n      case Token.OR: return \"||\";\n      case Token.BITXOR: return \"^\";\n      case Token.AND: return \"&&\";\n      case Token.BITAND: return \"&\";\n      case Token.SHEQ: return \"===\";\n      case Token.EQ: return \"==\";\n      case Token.NOT: return \"!\";\n      case Token.NE: return \"!=\";\n      case Token.SHNE: return \"!==\";\n      case Token.LSH: return \"<<\";\n      case Token.IN: return \"in\";\n      case Token.LE: return \"<=\";\n      case Token.LT: return \"<\";\n      case Token.URSH: return \">>>\";\n      case Token.RSH: return \">>\";\n      case Token.GE: return \">=\";\n      case Token.GT: return \">\";\n      case Token.MUL: return \"*\";\n      case Token.DIV: return \"/\";\n      case Token.MOD: return \"%\";\n      case Token.BITNOT: return \"~\";\n      case Token.ADD: return \"+\";\n      case Token.SUB: return \"-\";\n      case Token.POS: return \"+\";\n      case Token.NEG: return \"-\";\n      case Token.ASSIGN: return \"=\";\n      case Token.ASSIGN_BITOR: return \"|=\";\n      case Token.ASSIGN_BITXOR: return \"^=\";\n      case Token.ASSIGN_BITAND: return \"&=\";\n      case Token.ASSIGN_LSH: return \"<<=\";\n      case Token.ASSIGN_RSH: return \">>=\";\n      case Token.ASSIGN_URSH: return \">>>=\";\n      case Token.ASSIGN_ADD: return \"+=\";\n      case Token.ASSIGN_SUB: return \"-=\";\n      case Token.ASSIGN_MUL: return \"*=\";\n      case Token.ASSIGN_DIV: return \"/=\";\n      case Token.ASSIGN_MOD: return \"%=\";\n      case Token.VOID: return \"void\";\n      case Token.TYPEOF: return \"typeof\";\n      case Token.INSTANCEOF: return \"instanceof\";\n      default: return null;\n    }\n  }",
    "comment": " Converts an operator's token value (see {@link Token}) to a string representation.  @param operator the operator's token value to convert @return the string representation or {@code null} if the token value is not an operator ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "NodeUtil.precedence",
    "class_name": "com.google.javascript.jscomp.NodeUtil",
    "signature": "com.google.javascript.jscomp.NodeUtil.precedence(int)",
    "snippet": "  static int precedence(int type) {\n    switch (type) {\n      case Token.COMMA:  return 0;\n      case Token.ASSIGN_BITOR:\n      case Token.ASSIGN_BITXOR:\n      case Token.ASSIGN_BITAND:\n      case Token.ASSIGN_LSH:\n      case Token.ASSIGN_RSH:\n      case Token.ASSIGN_URSH:\n      case Token.ASSIGN_ADD:\n      case Token.ASSIGN_SUB:\n      case Token.ASSIGN_MUL:\n      case Token.ASSIGN_DIV:\n      case Token.ASSIGN_MOD:\n      case Token.ASSIGN: return 1;\n      case Token.HOOK:   return 2;  // ?: operator\n      case Token.OR:     return 3;\n      case Token.AND:    return 4;\n      case Token.BITOR:  return 5;\n      case Token.BITXOR: return 6;\n      case Token.BITAND: return 7;\n      case Token.EQ:\n      case Token.NE:\n      case Token.SHEQ:\n      case Token.SHNE:   return 8;\n      case Token.LT:\n      case Token.GT:\n      case Token.LE:\n      case Token.GE:\n      case Token.INSTANCEOF:\n      case Token.IN:     return 9;\n      case Token.LSH:\n      case Token.RSH:\n      case Token.URSH:   return 10;\n      case Token.SUB:\n      case Token.ADD:    return 11;\n      case Token.MUL:\n      case Token.MOD:\n      case Token.DIV:    return 12;\n      case Token.INC:\n      case Token.DEC:\n      case Token.NEW:\n      case Token.DELPROP:\n      case Token.TYPEOF:\n      case Token.VOID:\n      case Token.NOT:\n      case Token.BITNOT:\n      case Token.POS:\n      case Token.NEG:    return 13;\n\n      case Token.ARRAYLIT:\n      case Token.CALL:\n      case Token.EMPTY:\n      case Token.FALSE:\n      case Token.FUNCTION:\n      case Token.GETELEM:\n      case Token.GETPROP:\n      case Token.GET_REF:\n      case Token.IF:\n      case Token.LP:\n      case Token.NAME:\n      case Token.NULL:\n      case Token.NUMBER:\n      case Token.OBJECTLIT:\n      case Token.REGEXP:\n      case Token.RETURN:\n      case Token.STRING:\n      case Token.THIS:\n      case Token.TRUE:\n        return 15;\n\n      default: throw new Error(\"Unknown precedence for \" +\n                               Node.tokenToName(type) +\n                               \" (type \" + type + \")\");\n    }\n  }",
    "comment": " 0 comma , 1 assignment = += -= *= /= %= <<= >>= >>>= &= ^= |= 2 conditional ?: 3 logical-or || 4 logical-and && 5 bitwise-or | 6 bitwise-xor ^ 7 bitwise-and & 8 equality == != 9 relational < <= > >= 10 bitwise shift << >> >>> 11 addition/subtraction + - 12 multiply/divide * / % 13 negation/increment ! ~ - ++ -- 14 call, member () [] . ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "NodeUtil.setDebugInformation",
    "class_name": "com.google.javascript.jscomp.NodeUtil",
    "signature": "com.google.javascript.jscomp.NodeUtil.setDebugInformation(Node,Node,String)",
    "snippet": "  static void setDebugInformation(Node node, Node basisNode,\n                                  String originalName) {\n    node.copyInformationFromForTree(basisNode);\n    node.putProp(Node.ORIGINALNAME_PROP, originalName);\n  }",
    "comment": " Sets the debug information (source file info and orignal name) on the given node.  @param node The node on which to set the debug information. @param basisNode The basis node from which to copy the source file info. @param originalName The original name of the node. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "Normalize.Normalize",
    "class_name": "com.google.javascript.jscomp.Normalize",
    "signature": "com.google.javascript.jscomp.Normalize.Normalize(AbstractCompiler,boolean)",
    "snippet": "  Normalize(AbstractCompiler compiler, boolean assertOnChange) {\n    this.compiler = compiler;\n    this.assertOnChange = assertOnChange;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "Normalize.process",
    "class_name": "com.google.javascript.jscomp.Normalize",
    "signature": "com.google.javascript.jscomp.Normalize.process(Node,Node)",
    "snippet": "  @Override\n  public void process(Node externs, Node root) {\n    NodeTraversal.traverse(compiler, root,\n        new NormalizeStatements(compiler, assertOnChange));\n    if (MAKE_LOCAL_NAMES_UNIQUE) {\n      MakeDeclaredNamesUnique renamer = new MakeDeclaredNamesUnique();\n      NodeTraversal t = new NodeTraversal(compiler, renamer);\n      t.traverseRoots(externs, root);\n    }\n    // It is important that removeDuplicateDeclarations runs after\n    // MakeDeclaredNamesUnique in order for catch block exception names to be\n    // handled properly. Specifically, catch block exception names are\n    // only valid within the catch block, but our currect Scope logic\n    // has no concept of this and includes it in the containing function\n    // (or global scope). MakeDeclaredNamesUnique makes the catch exception\n    // names unique so that removeDuplicateDeclarations() will properly handle\n    // cases where a function scope variable conflict with a exception name:\n    //   function f() {\n    //      try {throw 0;} catch(e) {e; /* catch scope 'e'*/}\n    //      var e = 1; // f scope 'e'\n    //   }\n    // otherwise 'var e = 1' would be rewritten as 'e = 1'.\n    // TODO(johnlenz): Introduce a seperate scope for catch nodes.\n    removeDuplicateDeclarations(root);\n    new PropogateConstantAnnotations(compiler, assertOnChange)\n        .process(externs, root);\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "Normalize.removeDuplicateDeclarations",
    "class_name": "com.google.javascript.jscomp.Normalize",
    "signature": "com.google.javascript.jscomp.Normalize.removeDuplicateDeclarations(Node)",
    "snippet": "  private void removeDuplicateDeclarations(Node root) {\n    Callback tickler = new ScopeTicklingCallback();\n    ScopeCreator scopeCreator =  new SyntacticScopeCreator(\n        compiler, new DuplicateDeclarationHandler());\n    NodeTraversal t = new NodeTraversal(compiler, tickler, scopeCreator);\n    t.traverse(root);\n  }",
    "comment": " Remove duplicate VAR declarations. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "NormalizeStatements.doStatementNormalizations",
    "class_name": "com.google.javascript.jscomp.Normalize$NormalizeStatements",
    "signature": "com.google.javascript.jscomp.Normalize$NormalizeStatements.doStatementNormalizations(NodeTraversal,Node,Node)",
    "snippet": "    private void doStatementNormalizations(\n        NodeTraversal t, Node n, Node parent) {\n      if (n.getType() == Token.LABEL) {\n        normalizeLabels(n);\n      }\n\n      // Only inspect the children of SCRIPTs, BLOCKs and LABELs, as all these\n      // are the only legal place for VARs and FOR statements.\n      if (NodeUtil.isStatementBlock(n) || n.getType() == Token.LABEL) {\n        extractForInitializer(n, null, null);\n      }\n\n      // Only inspect the children of SCRIPTs, BLOCKs, as all these\n      // are the only legal place for VARs.\n      if (NodeUtil.isStatementBlock(n)) {\n        splitVarDeclarations(n);\n      }\n\n      if (n.getType() == Token.FUNCTION) {\n        moveNamedFunctions(n.getLastChild());\n      }\n    }",
    "comment": " Do normalizations that introduce new siblings or parents. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "NormalizeStatements.extractForInitializer",
    "class_name": "com.google.javascript.jscomp.Normalize$NormalizeStatements",
    "signature": "com.google.javascript.jscomp.Normalize$NormalizeStatements.extractForInitializer(Node,Node,Node)",
    "snippet": "    private void extractForInitializer(\n        Node n, Node before, Node beforeParent) {\n\n      for (Node next, c = n.getFirstChild(); c != null; c = next) {\n        next = c.getNext();\n        Node insertBefore = (before == null) ? c : before;\n        Node insertBeforeParent = (before == null) ? n : beforeParent;\n        switch (c.getType()) {\n          case Token.LABEL:\n            extractForInitializer(c, insertBefore, insertBeforeParent);\n            break;\n          case Token.FOR:\n            if (!NodeUtil.isForIn(c)\n                && c.getFirstChild().getType() != Token.EMPTY) {\n              Node init = c.getFirstChild();\n              Node empty = new Node(Token.EMPTY);\n              empty.copyInformationFrom(c);\n              c.replaceChild(init, empty);\n\n              Node newStatement;\n              // Only VAR statements, and expressions are allowed,\n              // but are handled differently.\n              if (init.getType() == Token.VAR) {\n                newStatement = init;\n              } else {\n                newStatement = NodeUtil.newExpr(init);\n              }\n\n              insertBeforeParent.addChildBefore(newStatement, insertBefore);\n              reportCodeChange(\"FOR initializer\");\n            }\n            break;\n        }\n      }\n    }",
    "comment": " Bring the initializers out of FOR loops.  These need to be placed before any associated LABEL nodes. This needs to be done from the top level label first so this is called as a pre-order callback (from shouldTraverse).  @param n The node to inspect. @param before The node to insert the initializer before. @param beforeParent The parent of the node before which the initializer will be inserted. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "NormalizeStatements.shouldTraverse",
    "class_name": "com.google.javascript.jscomp.Normalize$NormalizeStatements",
    "signature": "com.google.javascript.jscomp.Normalize$NormalizeStatements.shouldTraverse(NodeTraversal,Node,Node)",
    "snippet": "    @Override\n    public boolean shouldTraverse(NodeTraversal t, Node n, Node parent) {\n      doStatementNormalizations(t, n, parent);\n\n      return true;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "NormalizeStatements.splitVarDeclarations",
    "class_name": "com.google.javascript.jscomp.Normalize$NormalizeStatements",
    "signature": "com.google.javascript.jscomp.Normalize$NormalizeStatements.splitVarDeclarations(Node)",
    "snippet": "    private void splitVarDeclarations(Node n) {\n      for (Node next, c = n.getFirstChild(); c != null; c = next) {\n        next = c.getNext();\n        if (c.getType() == Token.VAR) {\n          if (assertOnChange && !c.hasChildren()) {\n            throw new IllegalStateException(\"Empty VAR node.\");\n          }\n\n          while (c.getFirstChild() != c.getLastChild()) {\n            Node name = c.getFirstChild();\n            c.removeChild(name);\n            Node newVar = new Node(\n                Token.VAR, name, n.getLineno(), n.getCharno());\n            n.addChildBefore(newVar, c);\n            reportCodeChange(\"VAR with multiple children\");\n          }\n        }\n      }\n    }",
    "comment": " Split a var node such as: var a, b; into individual statements: var a; var b; @param n The whose children we should inspect. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "NormalizeStatements.visit",
    "class_name": "com.google.javascript.jscomp.Normalize$NormalizeStatements",
    "signature": "com.google.javascript.jscomp.Normalize$NormalizeStatements.visit(NodeTraversal,Node,Node)",
    "snippet": "    @Override\n    public void visit(NodeTraversal t, Node n, Node parent) {\n      switch (n.getType()) {\n        case Token.WHILE:\n          if (CONVERT_WHILE_TO_FOR) {\n            Node expr = n.getFirstChild();\n            n.setType(Token.FOR);\n            Node empty = new Node(Token.EMPTY);\n            empty.copyInformationFrom(n);\n            n.addChildBefore(empty, expr);\n            n.addChildAfter(empty.cloneNode(), expr);\n            reportCodeChange(\"WHILE node\");\n          }\n          break;\n\n        case Token.FUNCTION:\n          normalizeFunctionDeclaration(n);\n          break;\n      }\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "PropogateConstantAnnotations.process",
    "class_name": "com.google.javascript.jscomp.Normalize$PropogateConstantAnnotations",
    "signature": "com.google.javascript.jscomp.Normalize$PropogateConstantAnnotations.process(Node,Node)",
    "snippet": "    @Override\n    public void process(Node externs, Node root) {\n      new NodeTraversal(compiler, this).traverseRoots(externs, root);\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "PropogateConstantAnnotations.visit",
    "class_name": "com.google.javascript.jscomp.Normalize$PropogateConstantAnnotations",
    "signature": "com.google.javascript.jscomp.Normalize$PropogateConstantAnnotations.visit(NodeTraversal,Node,Node)",
    "snippet": "    @Override\n    public void visit(NodeTraversal t, Node n, Node parent) {\n      // Note: Constant properties annotations are not propagated.\n      if (n.getType() == Token.NAME) {\n        if (n.getString().isEmpty()) {\n          return;\n        }\n\n        JSDocInfo info = null;\n        // Find the JSDocInfo for a top level variable.\n        Var var = t.getScope().getVar(n.getString());\n        if (var != null) {\n          info = var.getJSDocInfo();\n        }\n\n        if ((info != null && info.isConstant()) &&\n            !n.getBooleanProp(Node.IS_CONSTANT_NAME)) {\n          n.putBooleanProp(Node.IS_CONSTANT_NAME, true);\n          if (assertOnChange) {\n            String name = n.getString();\n            throw new IllegalStateException(\n                \"Unexpected const change.\\n\" +\n                \"  name: \"+ name + \"\\n\" +\n                \"  gramps:\" + n.getParent().getParent().toStringTree());\n          }\n          // Even though the AST has changed (an annotation was added),\n          // the annotations are not compared so don't report the change.\n          // reportCodeChange(\"constant annotation\");\n        }\n      }\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "ScopeTicklingCallback.enterScope",
    "class_name": "com.google.javascript.jscomp.Normalize$ScopeTicklingCallback",
    "signature": "com.google.javascript.jscomp.Normalize$ScopeTicklingCallback.enterScope(NodeTraversal)",
    "snippet": "    @Override\n    public void enterScope(NodeTraversal t) {\n      // Cause the scope to be created, which will cause duplicate\n      // to be found.\n      t.getScope();\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "ScopeTicklingCallback.exitScope",
    "class_name": "com.google.javascript.jscomp.Normalize$ScopeTicklingCallback",
    "signature": "com.google.javascript.jscomp.Normalize$ScopeTicklingCallback.exitScope(NodeTraversal)",
    "snippet": "    @Override\n    public void exitScope(NodeTraversal t) {\n      // Nothing to do.\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "ScopeTicklingCallback.shouldTraverse",
    "class_name": "com.google.javascript.jscomp.Normalize$ScopeTicklingCallback",
    "signature": "com.google.javascript.jscomp.Normalize$ScopeTicklingCallback.shouldTraverse(NodeTraversal,Node,Node)",
    "snippet": "    @Override\n    public boolean shouldTraverse(\n        NodeTraversal nodeTraversal, Node n, Node parent) {\n      return true;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "ScopeTicklingCallback.visit",
    "class_name": "com.google.javascript.jscomp.Normalize$ScopeTicklingCallback",
    "signature": "com.google.javascript.jscomp.Normalize$ScopeTicklingCallback.visit(NodeTraversal,Node,Node)",
    "snippet": "    @Override\n    public void visit(NodeTraversal t, Node n, Node parent) {\n      // Nothing to do.\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "OptimizeArgumentsArray.OptimizeArgumentsArray",
    "class_name": "com.google.javascript.jscomp.OptimizeArgumentsArray",
    "signature": "com.google.javascript.jscomp.OptimizeArgumentsArray.OptimizeArgumentsArray(AbstractCompiler)",
    "snippet": "  OptimizeArgumentsArray(AbstractCompiler compiler) {\n    this(compiler, PARAMETER_PREFIX);\n  }",
    "comment": " Construct this pass and use {@link #PARAMETER_PREFIX} as the prefix for all parameter names that it introduces. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "OptimizeArgumentsArray.OptimizeArgumentsArray",
    "class_name": "com.google.javascript.jscomp.OptimizeArgumentsArray",
    "signature": "com.google.javascript.jscomp.OptimizeArgumentsArray.OptimizeArgumentsArray(AbstractCompiler,String)",
    "snippet": "  OptimizeArgumentsArray(AbstractCompiler compiler, String paramPrefix) {\n    this.compiler = Preconditions.checkNotNull(compiler);\n    this.paramPredix = Preconditions.checkNotNull(paramPrefix);\n  }",
    "comment": " @param paramPrefix the prefix to use for all parameter names that this pass introduces ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "OptimizeArgumentsArray.enterScope",
    "class_name": "com.google.javascript.jscomp.OptimizeArgumentsArray",
    "signature": "com.google.javascript.jscomp.OptimizeArgumentsArray.enterScope(NodeTraversal)",
    "snippet": "  @Override\n  public void enterScope(NodeTraversal traversal) {\n    Preconditions.checkNotNull(traversal);\n\n    // This optimization is valid only within a function so we are going to\n    // skip over the initial entry to the global scope.\n    Node function = traversal.getScopeRoot();\n    if (!NodeUtil.isFunction(function)) {\n      return;\n    }\n\n    // Introduces a new access list and stores the access list of the outer\n    // scope in the stack if necessary.\n    if (currentArgumentsAccess != null) {\n      argumentsAccessStack.push(currentArgumentsAccess);\n    }\n    currentArgumentsAccess = Lists.newLinkedList();\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "OptimizeArgumentsArray.exitScope",
    "class_name": "com.google.javascript.jscomp.OptimizeArgumentsArray",
    "signature": "com.google.javascript.jscomp.OptimizeArgumentsArray.exitScope(NodeTraversal)",
    "snippet": "  @Override\n  public void exitScope(NodeTraversal traversal) {\n    Preconditions.checkNotNull(traversal);\n\n    // This is the case when we are exiting the global scope where we had never\n    // collected argument access list. Since we do not perform this optimization\n    // for the global scope, we will skip this exit point.\n    if (currentArgumentsAccess == null) {\n      return;\n    }\n\n    // Attempt to replace the argument access and if the AST has been change,\n    // report back to the compiler.\n    if (tryReplaceArguments(traversal.getScope())) {\n      traversal.getCompiler().reportCodeChange();\n    }\n\n    // After the attempt to replace the arguments. The currentArgumentsAccess\n    // is stale and as we exit the Scope, no longer holds all the access to the\n    // current scope anymore. We'll pop the access list from the outer scope\n    // and set it as currentArgumentsAcess if the outer scope is not the global\n    // scope.\n    if (!argumentsAccessStack.isEmpty()) {\n      currentArgumentsAccess = argumentsAccessStack.pop();\n    } else {\n      currentArgumentsAccess = null;\n    }\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "OptimizeArgumentsArray.process",
    "class_name": "com.google.javascript.jscomp.OptimizeArgumentsArray",
    "signature": "com.google.javascript.jscomp.OptimizeArgumentsArray.process(Node,Node)",
    "snippet": "  @Override\n  public void process(Node externs, Node root) {\n    NodeTraversal.traverse(compiler, Preconditions.checkNotNull(root), this);\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "OptimizeArgumentsArray.shouldTraverse",
    "class_name": "com.google.javascript.jscomp.OptimizeArgumentsArray",
    "signature": "com.google.javascript.jscomp.OptimizeArgumentsArray.shouldTraverse(NodeTraversal,Node,Node)",
    "snippet": "  @Override\n  public boolean shouldTraverse(\n      NodeTraversal nodeTraversal, Node node, Node parent) {\n    // We will continuously recurse down the AST regardless of the node types.\n    return true;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "OptimizeArgumentsArray.visit",
    "class_name": "com.google.javascript.jscomp.OptimizeArgumentsArray",
    "signature": "com.google.javascript.jscomp.OptimizeArgumentsArray.visit(NodeTraversal,Node,Node)",
    "snippet": "  @Override\n  public void visit(NodeTraversal traversal, Node node, Node parent) {\n    Preconditions.checkNotNull(traversal);\n    Preconditions.checkNotNull(node);\n\n\n    // Searches for all the references to the arguments array.\n\n    // We don't have an arguments list set up for this scope. This implies we\n    // are currently in the global scope so we will not record any arguments\n    // array access.\n    if (currentArgumentsAccess == null) {\n      return;\n    }\n\n    // Otherwise, we are in a function scope and we should record if the current\n    // name is referring to the implicit arguments array.\n    if (NodeUtil.isName(node) && ARGUMENTS.equals(node.getString())) {\n      currentArgumentsAccess.add(node);\n    }\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "Result.notifyCompiler",
    "class_name": "com.google.javascript.jscomp.ParallelCompilerPass$Result",
    "signature": "com.google.javascript.jscomp.ParallelCompilerPass$Result.notifyCompiler(AbstractCompiler)",
    "snippet": "    public void notifyCompiler(AbstractCompiler c) {\n      if (!exceptions.isEmpty()) {\n        throw new RuntimeException(exceptions.get(0));\n      }\n      for (JSError error : errors) {\n        c.report(error);\n      }\n      if (changed) {\n        c.reportCodeChange();\n      }\n    }",
    "comment": " Inform the compiler of all the changes this result object had recorded. It might trigger a {@link Compiler#recentChange}, re-throw all the exceptions that was thrown or report errors/warnings with {@link Compiler#report(JSError)}. This is typically called after all the worker thread has finished executed. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "PassConfig.PassConfig",
    "class_name": "com.google.javascript.jscomp.PassConfig",
    "signature": "com.google.javascript.jscomp.PassConfig.PassConfig(CompilerOptions)",
    "snippet": "  public PassConfig(CompilerOptions options) {\n    this.options = options;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "PassFactory.PassFactory",
    "class_name": "com.google.javascript.jscomp.PassFactory",
    "signature": "com.google.javascript.jscomp.PassFactory.PassFactory(String,boolean)",
    "snippet": "  protected PassFactory(String name, boolean isOneTimePass) {\n    this.name = name;\n    this.isOneTimePass = isOneTimePass;\n  }",
    "comment": " @param name The name of the pass that this factory creates. @param isOneTimePass If true, the pass produced by this factory can only be run once. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "PassFactory.create",
    "class_name": "com.google.javascript.jscomp.PassFactory",
    "signature": "com.google.javascript.jscomp.PassFactory.create(AbstractCompiler)",
    "snippet": "  final CompilerPass create(AbstractCompiler compiler) {\n    Preconditions.checkState(!isCreated || !isOneTimePass,\n        \"One-time passes cannot be run multiple times: \" + name);\n    isCreated = true;\n    return createInternal(compiler);\n  }",
    "comment": " Creates a new compiler pass to be run. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "PassFactory.getName",
    "class_name": "com.google.javascript.jscomp.PassFactory",
    "signature": "com.google.javascript.jscomp.PassFactory.getName()",
    "snippet": "  String getName() {\n    return name;\n  }",
    "comment": " @return The name of this pass. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "PassFactory.isOneTimePass",
    "class_name": "com.google.javascript.jscomp.PassFactory",
    "signature": "com.google.javascript.jscomp.PassFactory.isOneTimePass()",
    "snippet": "  boolean isOneTimePass() {\n    return isOneTimePass;\n  }",
    "comment": " @return Whether the pass produced by this factory can only be run once. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "PassFactory.makeOneTimePass",
    "class_name": "com.google.javascript.jscomp.PassFactory",
    "signature": "com.google.javascript.jscomp.PassFactory.makeOneTimePass()",
    "snippet": "  PassFactory makeOneTimePass() {\n    if (isOneTimePass()) {\n      return this;\n    }\n\n    final PassFactory self = this;\n    return new PassFactory(name, true /* one time pass */) {\n      @Override\n      protected CompilerPass createInternal(AbstractCompiler compiler) {\n        return self.createInternal(compiler);\n      }\n    };\n  }",
    "comment": " Make a new pass factory that only creates one-time passes. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "PhaseOptimizer.PhaseOptimizer",
    "class_name": "com.google.javascript.jscomp.PhaseOptimizer",
    "signature": "com.google.javascript.jscomp.PhaseOptimizer.PhaseOptimizer(AbstractCompiler,PerformanceTracker)",
    "snippet": "  PhaseOptimizer(AbstractCompiler compiler, PerformanceTracker tracker) {\n    this.compiler = compiler;\n    this.tracker = tracker;\n    compiler.addChangeHandler(recentChange);\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "PhaseOptimizer.addOneTimePass",
    "class_name": "com.google.javascript.jscomp.PhaseOptimizer",
    "signature": "com.google.javascript.jscomp.PhaseOptimizer.addOneTimePass(PassFactory)",
    "snippet": "  void addOneTimePass(PassFactory factory) {\n    passes.add(new PassFactoryDelegate(compiler, factory));\n  }",
    "comment": " Add the pass generated by the given factory to the compile sequence. This pass will be run once. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "PhaseOptimizer.consume",
    "class_name": "com.google.javascript.jscomp.PhaseOptimizer",
    "signature": "com.google.javascript.jscomp.PhaseOptimizer.consume(List)",
    "snippet": "  void consume(List<PassFactory> factories) {\n    Loop currentLoop = new LoopInternal();\n    boolean isCurrentLoopPopulated = false;\n    for (PassFactory factory : factories) {\n      if (factory.isOneTimePass()) {\n        if (isCurrentLoopPopulated) {\n          passes.add(currentLoop);\n\n          currentLoop = new LoopInternal();\n          isCurrentLoopPopulated = false;\n        }\n        addOneTimePass(factory);\n      } else {\n        currentLoop.addLoopedPass(factory);\n        isCurrentLoopPopulated = true;\n      }\n    }\n\n    if (isCurrentLoopPopulated) {\n      passes.add(currentLoop);\n    }\n  }",
    "comment": " Add the passes generated by the given factories to the compile sequence.  Automatically pulls multi-run passes into fixed point loops. If there are 2 or more multi-run passes in a row, they will run together in the same fixed point loop. If A and B are in the same fixed point loop, the loop will continue to run both A and B until both are finished making changes.  Other than that, the PhaseOptimizer is free to tweak the order and frequency of multi-run passes in a fixed-point loop. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "PhaseOptimizer.endPass",
    "class_name": "com.google.javascript.jscomp.PhaseOptimizer",
    "signature": "com.google.javascript.jscomp.PhaseOptimizer.endPass(Node,Node)",
    "snippet": "  private void endPass(Node externs, Node root) {\n    Preconditions.checkState(currentTracer != null && currentPassName != null);\n    stopTracer(currentTracer, currentPassName);\n    String passToCheck = currentPassName;\n    currentPassName = null;\n    currentTracer = null;\n\n    try {\n      maybeSanityCheck(externs, root);\n    } catch (Exception e) {\n      // TODO(johnlenz): Remove this once the normalization checks report\n      // errors instead of exceptions.\n      throw new RuntimeException(\"Sanity check failed for \" + passToCheck, e);\n    }\n  }",
    "comment": " Marks the end of a pass. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "PhaseOptimizer.hasHaltingErrors",
    "class_name": "com.google.javascript.jscomp.PhaseOptimizer",
    "signature": "com.google.javascript.jscomp.PhaseOptimizer.hasHaltingErrors()",
    "snippet": "  private boolean hasHaltingErrors() {\n    return compiler.hasHaltingErrors();\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "PhaseOptimizer.maybeSanityCheck",
    "class_name": "com.google.javascript.jscomp.PhaseOptimizer",
    "signature": "com.google.javascript.jscomp.PhaseOptimizer.maybeSanityCheck(Node,Node)",
    "snippet": "  void maybeSanityCheck(Node externs, Node root) {\n    if (sanityCheck != null) {\n      sanityCheck.create(compiler).process(externs, root);\n    }\n  }",
    "comment": " Runs the sanity check if it is available. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "PhaseOptimizer.newTracer",
    "class_name": "com.google.javascript.jscomp.PhaseOptimizer",
    "signature": "com.google.javascript.jscomp.PhaseOptimizer.newTracer(String)",
    "snippet": "  private Tracer newTracer(String passName) {\n    String comment = passName +\n        (recentChange.hasCodeChanged() ? \" on recently changed AST\" : \"\");\n    if (tracker != null) {\n      tracker.recordPassStart(passName);\n    }\n    return new Tracer(\"JSCompiler\", comment);\n  }",
    "comment": " Returns a new tracer for the given pass name. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "PhaseOptimizer.process",
    "class_name": "com.google.javascript.jscomp.PhaseOptimizer",
    "signature": "com.google.javascript.jscomp.PhaseOptimizer.process(Node,Node)",
    "snippet": "  public void process(Node externs, Node root) {\n    for (CompilerPass pass : passes) {\n      pass.process(externs, root);\n      if (hasHaltingErrors()) {\n        return;\n      }\n    }\n  }",
    "comment": " Run all the passes in the optimizer. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "PhaseOptimizer.startPass",
    "class_name": "com.google.javascript.jscomp.PhaseOptimizer",
    "signature": "com.google.javascript.jscomp.PhaseOptimizer.startPass(String)",
    "snippet": "  private void startPass(String passName) {\n    Preconditions.checkState(currentTracer == null && currentPassName == null);\n    currentPassName = passName;\n    currentTracer = newTracer(passName);\n  }",
    "comment": " Marks the beginning of a pass. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "PhaseOptimizer.stopTracer",
    "class_name": "com.google.javascript.jscomp.PhaseOptimizer",
    "signature": "com.google.javascript.jscomp.PhaseOptimizer.stopTracer(Tracer,String)",
    "snippet": "  private void stopTracer(Tracer t, String passName) {\n    long result = t.stop();\n    if (tracker != null) {\n      tracker.recordPassStop(passName, result);\n    }\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "LoopInternal.addLoopedPass",
    "class_name": "com.google.javascript.jscomp.PhaseOptimizer$LoopInternal",
    "signature": "com.google.javascript.jscomp.PhaseOptimizer$LoopInternal.addLoopedPass(PassFactory)",
    "snippet": "    @Override\n    void addLoopedPass(PassFactory factory) {\n      String name = factory.getName();\n      Preconditions.checkArgument(\n          !myNames.contains(name),\n          \"Already a pass with name '\" + name + \"' in this loop\");\n      myNames.add(factory.getName());\n      myPasses.add(new PassFactoryDelegate(compiler, factory));\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "LoopInternal.optimizePasses",
    "class_name": "com.google.javascript.jscomp.PhaseOptimizer$LoopInternal",
    "signature": "com.google.javascript.jscomp.PhaseOptimizer$LoopInternal.optimizePasses()",
    "snippet": "    private void optimizePasses() {\n      // It's important that this ordering is deterministic, so that\n      // multiple compiles with the same input produce exactly the same\n      // results.\n      //\n      // To do this, grab any passes we recognize, and move them to the end\n      // in an \"optimal\" order.\n      List<NamedPass> optimalPasses = Lists.newArrayList();\n      for (String passName : OPTIMAL_ORDER) {\n        for (NamedPass pass : myPasses) {\n          if (pass.name.equals(passName)) {\n            optimalPasses.add(pass);\n            break;\n          }\n        }\n      }\n\n      myPasses.removeAll(optimalPasses);\n      myPasses.addAll(optimalPasses);\n    }",
    "comment": "Re-arrange the passes in an optimal order. */",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "LoopInternal.process",
    "class_name": "com.google.javascript.jscomp.PhaseOptimizer$LoopInternal",
    "signature": "com.google.javascript.jscomp.PhaseOptimizer$LoopInternal.process(Node,Node)",
    "snippet": "    public void process(Node externs, Node root) {\n      Preconditions.checkState(!loopMutex, \"Nested loops are forbidden\");\n      loopMutex = true;\n      if (randomizeLoops) {\n        randomizePasses();\n      } else {\n        optimizePasses();\n      }\n\n      try {\n        // TODO(nicksantos): Use a smarter algorithm that dynamically adjusts\n        // the order that passes are run in.\n        int count = 0;\n        out: do {\n          if (count++ > MAX_LOOPS) {\n            compiler.throwInternalError(OPTIMIZE_LOOP_ERROR, null);\n          }\n\n          recentChange.reset();  // reset before this round of optimizations\n\n          for (CompilerPass pass : myPasses) {\n            pass.process(externs, root);\n            if (hasHaltingErrors()) {\n              break out;\n            }\n          }\n\n        } while (recentChange.hasCodeChanged() && !hasHaltingErrors());\n\n        if (randomizeLoops) {\n          loopsRun.add(getPassOrder());\n        }\n      } finally {\n        loopMutex = false;\n      }\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "NamedPass.process",
    "class_name": "com.google.javascript.jscomp.PhaseOptimizer$NamedPass",
    "signature": "com.google.javascript.jscomp.PhaseOptimizer$NamedPass.process(Node,Node)",
    "snippet": "    public void process(Node externs, Node root) {\n      logger.info(name);\n      startPass(name);\n      processInternal(externs, root);\n      endPass(externs, root);\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "PassFactoryDelegate.processInternal",
    "class_name": "com.google.javascript.jscomp.PhaseOptimizer$PassFactoryDelegate",
    "signature": "com.google.javascript.jscomp.PhaseOptimizer$PassFactoryDelegate.processInternal(Node,Node)",
    "snippet": "    @Override\n    void processInternal(Node externs, Node root) {\n      factory.create(myCompiler).process(externs, root);\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "PrepareAst.PrepareAst",
    "class_name": "com.google.javascript.jscomp.PrepareAst",
    "signature": "com.google.javascript.jscomp.PrepareAst.PrepareAst(AbstractCompiler)",
    "snippet": "  PrepareAst(AbstractCompiler compiler) {\n    this(compiler, false);\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "PrepareAst.PrepareAst",
    "class_name": "com.google.javascript.jscomp.PrepareAst",
    "signature": "com.google.javascript.jscomp.PrepareAst.PrepareAst(AbstractCompiler,boolean)",
    "snippet": "  PrepareAst(AbstractCompiler compiler, boolean forbidChanges) {\n    this.compiler = compiler;\n    this.assertOnChange = forbidChanges;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "PrepareAst.normalizeBlocks",
    "class_name": "com.google.javascript.jscomp.PrepareAst",
    "signature": "com.google.javascript.jscomp.PrepareAst.normalizeBlocks(Node)",
    "snippet": "  private void normalizeBlocks(Node n) {\n    if (NodeUtil.isControlStructure(n)\n        && n.getType() != Token.LABEL\n        && n.getType() != Token.SWITCH) {\n      for (Node c = n.getFirstChild(); c != null; c = c.getNext()) {\n        if (NodeUtil.isControlStructureCodeBlock(n,c) &&\n            c.getType() != Token.BLOCK) {\n          Node newBlock = new Node(Token.BLOCK);\n          newBlock.copyInformationFrom(n);\n          n.replaceChild(c, newBlock);\n          if (c.getType() != Token.EMPTY) {\n            newBlock.addChildrenToFront(c);\n          } else {\n            newBlock.setWasEmptyNode(true);\n          }\n          c = newBlock;\n          reportChange();\n        }\n      }\n    }\n  }",
    "comment": " Add blocks to IF, WHILE, DO, etc. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "PrepareAst.normalizeNodeTypes",
    "class_name": "com.google.javascript.jscomp.PrepareAst",
    "signature": "com.google.javascript.jscomp.PrepareAst.normalizeNodeTypes(Node)",
    "snippet": "  private void normalizeNodeTypes(Node n) {\n    if (n.getType() == Token.EXPR_VOID) {\n      n.setType(Token.EXPR_RESULT);\n      reportChange();\n    }\n\n    // Remove unused properties to minimize differences between ASTs\n    // produced by the two parsers.\n    if (n.getType() == Token.FUNCTION) {\n      Preconditions.checkState(n.getProp(Node.FUNCTION_PROP) == null);\n    }\n\n    normalizeBlocks(n);\n\n    for (Node child = n.getFirstChild();\n         child != null; child = child.getNext()) {\n      // This pass is run during the CompilerTestCase validation, so this\n      // parent pointer check serves as a more general check.\n      Preconditions.checkState(child.getParent() == n);\n\n      normalizeNodeTypes(child);\n    }\n  }",
    "comment": " Covert EXPR_VOID to EXPR_RESULT to simplify the rest of the code. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "PrepareAst.process",
    "class_name": "com.google.javascript.jscomp.PrepareAst",
    "signature": "com.google.javascript.jscomp.PrepareAst.process(Node,Node)",
    "snippet": "  @Override\n  public void process(Node externs, Node root) {\n    normalizeNodeTypes(root);\n    if (externs != null) {\n      NodeTraversal.traverse(\n          compiler, externs, new PrepareAnnotations(compiler));\n    }\n    if (root != null) {\n      NodeTraversal.traverse(\n          compiler, root, new PrepareAnnotations(compiler));\n    }\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "PrepareAnnotations.visit",
    "class_name": "com.google.javascript.jscomp.PrepareAst$PrepareAnnotations",
    "signature": "com.google.javascript.jscomp.PrepareAst$PrepareAnnotations.visit(NodeTraversal,Node,Node)",
    "snippet": "    public void visit(NodeTraversal t, Node n, Node parent) {\n      int nType = n.getType();\n      switch (nType) {\n        case Token.NAME:\n        case Token.STRING:\n          String nString = n.getString();\n          if (nType == Token.NAME &&\n              n.getParent().getType() == Token.CALL &&\n              \"eval\".equals(nString)) {\n            n.putBooleanProp(Node.DIRECT_EVAL, true);\n          }\n          if (convention.isConstant(nString)) {\n            n.putBooleanProp(Node.IS_CONSTANT_NAME, true);\n          }\n          break;\n\n        case Token.FUNCTION:\n          JSDocInfo fnInfo = n.getJSDocInfo();\n          if (fnInfo == null) {\n            // Look for the info on other nodes.\n            if (parent.getType() == Token.ASSIGN) {\n              // on ASSIGNs\n              fnInfo = parent.getJSDocInfo();\n            } else if (parent.getType() == Token.NAME) {\n              // on var NAME = function() { ... };\n              fnInfo = parent.getParent().getJSDocInfo();\n            }\n          }\n\n          // Compute which function parameters are optional and\n          // which are var_args.\n          Node args = n.getFirstChild().getNext();\n          for (Node arg = args.getFirstChild();\n               arg != null;\n               arg = arg.getNext()) {\n            String argName = arg.getString();\n            JSTypeExpression typeExpr = fnInfo == null ?\n                null : fnInfo.getParameterType(argName);\n\n            if (convention.isOptionalParameter(arg) ||\n                typeExpr != null && typeExpr.isOptionalArg()) {\n              arg.putBooleanProp(Node.IS_OPTIONAL_PARAM, true);\n            }\n            if (convention.isVarArgsParameter(arg) ||\n                typeExpr != null && typeExpr.isVarArgs()) {\n              arg.putBooleanProp(Node.IS_VAR_ARGS_PARAM, true);\n            }\n          }\n          break;\n\n        case Token.OBJECTLIT:\n          if (n.getType() == Token.OBJECTLIT) {\n            for (Node key = n.getFirstChild();\n                 key != null; key = key.getNext().getNext()) {\n              Node value = key.getNext();\n              if (key.getJSDocInfo() != null &&\n                  key.getNext().getType() == Token.FUNCTION) {\n                value.setJSDocInfo(key.getJSDocInfo());\n              }\n            }\n          }\n          break;\n      }\n\n      // TODO(johnlenz): Determine if it is possible to simply use the javadoc\n      // everywhere rather than use IS_DISPATCHER.\n      /*\n       * Translate dispatcher info into the property expected node.\n       */\n      if (n.getJSDocInfo() != null && n.getJSDocInfo().isJavaDispatch()) {\n        if (n.getType() == Token.ASSIGN) {\n          Node fnNode = n.getLastChild();\n          Preconditions.checkState(fnNode.getType() == Token.FUNCTION);\n          fnNode.putBooleanProp(Node.IS_DISPATCHER, true);\n        }\n      }\n    }",
    "comment": "  In the AST that Rhino gives us, it needs to make a distinction between jsdoc on the object literal node and jsdoc on the object literal value. For example, <pre> var x = { JSDOC / a: 'b', c: / JSDOC / 'd' }; </pre>  But in few narrow cases (in particular, function literals), it's a lot easier for us if the doc is attached to the value. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "PrintStreamErrorManager.PrintStreamErrorManager",
    "class_name": "com.google.javascript.jscomp.PrintStreamErrorManager",
    "signature": "com.google.javascript.jscomp.PrintStreamErrorManager.PrintStreamErrorManager(MessageFormatter,PrintStream)",
    "snippet": "  public PrintStreamErrorManager(MessageFormatter formatter,\n                                 PrintStream stream) {\n    this.formatter = formatter;\n    this.stream = stream;\n  }",
    "comment": " Creates an error manager. @param formatter the message formatter used to format the messages @param stream the stream on which the errors and warnings should be printed. This class does not close the stream ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "PrintStreamErrorManager.printSummary",
    "class_name": "com.google.javascript.jscomp.PrintStreamErrorManager",
    "signature": "com.google.javascript.jscomp.PrintStreamErrorManager.printSummary()",
    "snippet": "  @Override\n  public void printSummary() {\n    if (summaryDetailLevel >= 3 ||\n        (summaryDetailLevel >= 1 && getErrorCount() + getWarningCount() > 0) ||\n        (summaryDetailLevel >= 2 && getTypedPercent() > 0.0)) {\n      if (getTypedPercent() > 0.0) {\n        stream.format(\"%d error(s), %d warning(s), %.1f%% typed%n\",\n            getErrorCount(), getWarningCount(), getTypedPercent());\n      } else {\n        stream.format(\"%d error(s), %d warning(s)%n\", getErrorCount(),\n            getWarningCount());\n      }\n    }\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "PrintStreamErrorManager.setSummaryDetailLevel",
    "class_name": "com.google.javascript.jscomp.PrintStreamErrorManager",
    "signature": "com.google.javascript.jscomp.PrintStreamErrorManager.setSummaryDetailLevel(int)",
    "snippet": "  public void setSummaryDetailLevel(int summaryDetailLevel) {\n    this.summaryDetailLevel = summaryDetailLevel;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "ProcessClosurePrimitives.ProcessClosurePrimitives",
    "class_name": "com.google.javascript.jscomp.ProcessClosurePrimitives",
    "signature": "com.google.javascript.jscomp.ProcessClosurePrimitives.ProcessClosurePrimitives(AbstractCompiler,CheckLevel,boolean)",
    "snippet": "  ProcessClosurePrimitives(AbstractCompiler compiler,\n                           CheckLevel requiresLevel,\n                           boolean rewriteNewDateGoogNow) {\n    this.compiler = compiler;\n    this.moduleGraph = compiler.getModuleGraph();\n    this.requiresLevel = requiresLevel;\n    this.rewriteNewDateGoogNow = rewriteNewDateGoogNow;\n\n    // goog is special-cased because it is provided in Closure's base library.\n    providedNames.put(GOOG,\n        new ProvidedName(GOOG, null, null, false /* implicit */));\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "ProcessClosurePrimitives.getExportedVariableNames",
    "class_name": "com.google.javascript.jscomp.ProcessClosurePrimitives",
    "signature": "com.google.javascript.jscomp.ProcessClosurePrimitives.getExportedVariableNames()",
    "snippet": "  Set<String> getExportedVariableNames() {\n    return exportedVariables;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "ProcessClosurePrimitives.handleCandidateProvideDefinition",
    "class_name": "com.google.javascript.jscomp.ProcessClosurePrimitives",
    "signature": "com.google.javascript.jscomp.ProcessClosurePrimitives.handleCandidateProvideDefinition(NodeTraversal,Node,Node)",
    "snippet": "  private void handleCandidateProvideDefinition(\n      NodeTraversal t, Node n, Node parent) {\n    if (t.inGlobalScope()) {\n      String name = null;\n      if (n.getType() == Token.NAME && parent.getType() == Token.VAR) {\n        name = n.getString();\n      } else if (n.getType() == Token.ASSIGN &&\n          parent.getType() == Token.EXPR_RESULT) {\n        name = n.getFirstChild().getQualifiedName();\n      }\n\n      if (name != null) {\n        if (parent.getBooleanProp(Node.IS_NAMESPACE)) {\n          processProvideFromPreviousPass(t, name, parent);\n        } else {\n          ProvidedName pn = providedNames.get(name);\n          if (pn != null) {\n            pn.addDefinition(parent, t.getModule());\n          }\n        }\n      }\n    }\n  }",
    "comment": " Handles a candidate definition for a goog.provided name. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "ProcessClosurePrimitives.isNamespacePlaceholder",
    "class_name": "com.google.javascript.jscomp.ProcessClosurePrimitives",
    "signature": "com.google.javascript.jscomp.ProcessClosurePrimitives.isNamespacePlaceholder(Node)",
    "snippet": "  private static boolean isNamespacePlaceholder(Node n) {\n    if (!n.getBooleanProp(Node.IS_NAMESPACE)) {\n      return false;\n    }\n\n    Node value = null;\n    if (n.getType() == Token.EXPR_RESULT) {\n      Node assign = n.getFirstChild();\n      value = assign.getLastChild();\n    } else if (n.getType() == Token.VAR) {\n      Node name = n.getFirstChild();\n      value = name.getFirstChild();\n    }\n\n    return value != null\n      && value.getType() == Token.OBJECTLIT\n      && !value.hasChildren();\n  }",
    "comment": " @return Whether the node is namespace placeholder. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "ProcessClosurePrimitives.process",
    "class_name": "com.google.javascript.jscomp.ProcessClosurePrimitives",
    "signature": "com.google.javascript.jscomp.ProcessClosurePrimitives.process(Node,Node)",
    "snippet": "  public void process(Node externs, Node root) {\n    new NodeTraversal(compiler, this).traverse(root);\n\n    for (ProvidedName pn : providedNames.values()) {\n      pn.replace();\n    }\n\n    if (requiresLevel.isOn()) {\n      for (UnrecognizedRequire r : unrecognizedRequires) {\n        DiagnosticType error;\n        ProvidedName expectedName = providedNames.get(r.namespace);\n        if (expectedName != null && expectedName.firstNode != null) {\n          // The namespace ended up getting provided after it was required.\n          error = LATE_PROVIDE_ERROR;\n        } else {\n          error = MISSING_PROVIDE_ERROR;\n        }\n\n        compiler.report(JSError.make(\n            r.inputName, r.requireNode, requiresLevel, error, r.namespace));\n      }\n    }\n  }",
    "comment": " {@inheritDoc} ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "ProcessClosurePrimitives.processProvideCall",
    "class_name": "com.google.javascript.jscomp.ProcessClosurePrimitives",
    "signature": "com.google.javascript.jscomp.ProcessClosurePrimitives.processProvideCall(NodeTraversal,Node,Node)",
    "snippet": "  private void processProvideCall(NodeTraversal t, Node n, Node parent) {\n    Node left = n.getFirstChild();\n    Node arg = left.getNext();\n    if (verifyProvide(t, left, arg)) {\n      String ns = arg.getString();\n      if (providedNames.containsKey(ns)) {\n        ProvidedName previouslyProvided = providedNames.get(ns);\n        if (!previouslyProvided.isExplicitlyProvided()) {\n          previouslyProvided.addProvide(parent, t.getModule(), true);\n        } else {\n          compiler.report(\n              JSError.make(t, n, DUPLICATE_NAMESPACE_ERROR, ns));\n        }\n      } else {\n        registerAnyProvidedPrefixes(ns, parent, t.getModule());\n        providedNames.put(\n            ns, new ProvidedName(ns, parent, t.getModule(), true));\n      }\n    }\n  }",
    "comment": " Handles a goog.provide call. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "ProcessClosurePrimitives.registerAnyProvidedPrefixes",
    "class_name": "com.google.javascript.jscomp.ProcessClosurePrimitives",
    "signature": "com.google.javascript.jscomp.ProcessClosurePrimitives.registerAnyProvidedPrefixes(String,Node,JSModule)",
    "snippet": "  private void registerAnyProvidedPrefixes(\n      String ns, Node node, JSModule module) {\n    int pos = ns.indexOf('.');\n    while (pos != -1) {\n      String prefixNs = ns.substring(0, pos);\n      pos = ns.indexOf('.', pos + 1);\n      if (providedNames.containsKey(prefixNs)) {\n        providedNames.get(prefixNs).addProvide(\n            node, module, false /* implicit */);\n      } else {\n        providedNames.put(\n            prefixNs,\n            new ProvidedName(prefixNs, node, module, false /* implicit */));\n      }\n    }\n  }",
    "comment": " Registers ProvidedNames for prefix namespaces if they haven't already been defined. The prefix namespaces must be registered in order from shortest to longest.  @param ns The namespace whose prefixes may need to be provided. @param node The EXPR of the provide call. @param module The current module. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "ProcessClosurePrimitives.verifyArgument",
    "class_name": "com.google.javascript.jscomp.ProcessClosurePrimitives",
    "signature": "com.google.javascript.jscomp.ProcessClosurePrimitives.verifyArgument(NodeTraversal,Node,Node)",
    "snippet": "  private boolean verifyArgument(NodeTraversal t, Node methodName, Node arg) {\n    return verifyArgument(t, methodName, arg, Token.STRING);\n  }",
    "comment": " Verifies that a method call has exactly one argument, and that it's a string literal. Reports a compile error if it doesn't.  @return Whether the argument checked out okay ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "ProcessClosurePrimitives.verifyArgument",
    "class_name": "com.google.javascript.jscomp.ProcessClosurePrimitives",
    "signature": "com.google.javascript.jscomp.ProcessClosurePrimitives.verifyArgument(NodeTraversal,Node,Node,int)",
    "snippet": "  private boolean verifyArgument(NodeTraversal t, Node methodName, Node arg,\n      int desiredType) {\n    DiagnosticType diagnostic = null;\n    if (arg == null) {\n      diagnostic = NULL_ARGUMENT_ERROR;\n    } else if (arg.getType() != desiredType) {\n      diagnostic = INVALID_ARGUMENT_ERROR;\n    } else if (arg.getNext() != null) {\n      diagnostic = TOO_MANY_ARGUMENTS_ERROR;\n    }\n    if (diagnostic != null) {\n      compiler.report(\n          JSError.make(t, methodName,\n                       diagnostic, methodName.getQualifiedName()));\n      return false;\n    }\n    return true;\n  }",
    "comment": " Verifies that a method call has exactly one argument, and that it is of the desired type. Reports a compile error if it doesn't.  @return Whether the argument checked out okay ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "ProcessClosurePrimitives.verifyProvide",
    "class_name": "com.google.javascript.jscomp.ProcessClosurePrimitives",
    "signature": "com.google.javascript.jscomp.ProcessClosurePrimitives.verifyProvide(NodeTraversal,Node,Node)",
    "snippet": "  private boolean verifyProvide(NodeTraversal t, Node methodName, Node arg) {\n    if (!verifyArgument(t, methodName, arg)) {\n      return false;\n    }\n\n    for (String part : arg.getString().split(\"\\\\.\")) {\n      if (!NodeUtil.isValidPropertyName(part)) {\n        compiler.report(JSError.make(t, arg, INVALID_PROVIDE_ERROR, part));\n        return false;\n      }\n    }\n    return true;\n  }",
    "comment": " Verifies that a provide method call has exactly one argument, and that it's a string literal and that the contents of the string are valid JS tokens. Reports a compile error if it doesn't.  @return Whether the argument checked out okay ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "ProcessClosurePrimitives.visit",
    "class_name": "com.google.javascript.jscomp.ProcessClosurePrimitives",
    "signature": "com.google.javascript.jscomp.ProcessClosurePrimitives.visit(NodeTraversal,Node,Node)",
    "snippet": "  public void visit(NodeTraversal t, Node n, Node parent) {\n    switch (n.getType()) {\n      case Token.CALL:\n        boolean isExpr = parent.getType() == Token.EXPR_RESULT;\n        Node left = n.getFirstChild();\n        if (left.getType() == Token.GETPROP) {\n          Node name = left.getFirstChild();\n          if (name.getType() == Token.NAME &&\n              GOOG.equals(name.getString())) {\n            // For the sake of simplicity, we report code changes\n            // when we see a provides/requires, and don't worry about\n            // reporting the change when we actually do the replacement.\n            String methodName = name.getNext().getString();\n            if (\"base\".equals(methodName)) {\n              processBaseClassCall(t, n);\n            } else if (!isExpr) {\n              // All other methods must be called in an EXPR.\n              break;\n            } else if (\"require\".equals(methodName)) {\n              processRequireCall(t, n, parent);\n            } else if (\"provide\".equals(methodName)) {\n              processProvideCall(t, n, parent);\n            } else if (\"exportSymbol\".equals(methodName)) {\n              Node arg = left.getNext();\n              if (arg.getType() == Token.STRING) {\n                int dot = arg.getString().indexOf('.');\n                if (dot == -1) {\n                  exportedVariables.add(arg.getString());\n                } else {\n                  exportedVariables.add(arg.getString().substring(0, dot));\n                }\n              }\n            } else if (\"addDependency\".equals(methodName)) {\n              CodingConvention convention = compiler.getCodingConvention();\n              List<String> typeDecls =\n                  convention.identifyTypeDeclarationCall(n);\n              if (typeDecls != null) {\n                for (String typeDecl : typeDecls) {\n                  compiler.getTypeRegistry().forwardDeclareType(typeDecl);\n                }\n              }\n\n              // We can't modify parent, so just create a node that will\n              // get compiled out.\n              parent.replaceChild(n, Node.newNumber(0));\n              compiler.reportCodeChange();\n            } else if (\"setCssNameMapping\".equals(methodName)) {\n              processSetCssNameMapping(t, n, parent);\n            }\n          }\n        }\n        break;\n      case Token.ASSIGN:\n      case Token.NAME:\n        // If this is an assignment to a provided name, remove the provided\n        // object.\n        handleCandidateProvideDefinition(t, n, parent);\n        break;\n      case Token.FUNCTION:\n        // If this is a declaration of a provided named function, this is an\n        // error. Hosited functions will explode if the're provided.\n        if (t.inGlobalScope() &&\n            !NodeUtil.isFunctionAnonymous(n)) {\n          String name = n.getFirstChild().getString();\n          ProvidedName pn = providedNames.get(name);\n          if (pn != null) {\n            compiler.report(JSError.make(t, n, FUNCTION_NAMESPACE_ERROR, name));\n          }\n        }\n        break;\n\n      case Token.NEW:\n        trySimplifyNewDate(t, n, parent);\n        break;\n\n      case Token.GETPROP:\n        if (n.getFirstChild().getType() == Token.NAME &&\n            parent.getType() != Token.CALL &&\n            parent.getType() != Token.ASSIGN &&\n            \"goog.base\".equals(n.getQualifiedName())) {\n          reportBadBaseClassUse(t, n, \"May only be called directly.\");\n        }\n        break;\n    }\n  }",
    "comment": " {@inheritDoc} ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "ProvidedName.addDefinition",
    "class_name": "com.google.javascript.jscomp.ProcessClosurePrimitives$ProvidedName",
    "signature": "com.google.javascript.jscomp.ProcessClosurePrimitives$ProvidedName.addDefinition(Node,JSModule)",
    "snippet": "    void addDefinition(Node node, JSModule module) {\n      Preconditions.checkArgument(NodeUtil.isExpressionNode(node) || // assign\n                                  NodeUtil.isFunction(node) ||\n                                  NodeUtil.isVar(node));\n      Preconditions.checkArgument(explicitNode != node);\n      if ((candidateDefinition == null) || !NodeUtil.isExpressionNode(node)) {\n        candidateDefinition = node;\n        updateMinimumModule(module);\n      }\n    }",
    "comment": " Record function declaration, variable declaration or assignment that refers to the same name as the provide statement.  Give preference to declarations; if no declation exists record a reference to an assignment so it repurposed later. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "ProvidedName.addProvide",
    "class_name": "com.google.javascript.jscomp.ProcessClosurePrimitives$ProvidedName",
    "signature": "com.google.javascript.jscomp.ProcessClosurePrimitives$ProvidedName.addProvide(Node,JSModule,boolean)",
    "snippet": "    void addProvide(Node node, JSModule module, boolean explicit) {\n      if (explicit) {\n        Preconditions.checkState(explicitNode == null);\n        Preconditions.checkArgument(NodeUtil.isExpressionNode(node));\n        explicitNode = node;\n      }\n      updateMinimumModule(module);\n    }",
    "comment": " Add an implicit or explicit provide. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "ProvidedName.createDeclarationNode",
    "class_name": "com.google.javascript.jscomp.ProcessClosurePrimitives$ProvidedName",
    "signature": "com.google.javascript.jscomp.ProcessClosurePrimitives$ProvidedName.createDeclarationNode()",
    "snippet": "    private Node createDeclarationNode() {\n      if (namespace.indexOf('.') == -1) {\n        return makeVarDeclNode(namespace, firstNode);\n      } else {\n        return makeAssignmentExprNode(namespace, firstNode);\n      }\n    }",
    "comment": " Create the declaration node for this name, without inserting it into the AST. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "ProvidedName.makeAssignmentExprNode",
    "class_name": "com.google.javascript.jscomp.ProcessClosurePrimitives$ProvidedName",
    "signature": "com.google.javascript.jscomp.ProcessClosurePrimitives$ProvidedName.makeAssignmentExprNode(String,Node)",
    "snippet": "    private Node makeAssignmentExprNode(String namespace, Node node) {\n      Node decl = new Node(Token.EXPR_RESULT,\n          new Node(Token.ASSIGN,\n            NodeUtil.newQualifiedNameNode(namespace, node, namespace),\n              new Node(Token.OBJECTLIT)));\n      decl.putBooleanProp(Node.IS_NAMESPACE, true);\n      Preconditions.checkState(isNamespacePlaceholder(decl));\n      decl.copyInformationFromForTree(node);\n      return decl;\n    }",
    "comment": " Creates a dotted namespace assignment expression (e.g. <code>foo.bar = {};</code>).  @param namespace A dotted namespace @param node A node from which to copy source info. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "ProvidedName.replace",
    "class_name": "com.google.javascript.jscomp.ProcessClosurePrimitives$ProvidedName",
    "signature": "com.google.javascript.jscomp.ProcessClosurePrimitives$ProvidedName.replace()",
    "snippet": "    void replace() {\n      if (firstNode == null) {\n        // Don't touch the base case ('goog').\n        replacementNode = candidateDefinition;\n        return;\n      }\n\n      // Handle the case where there is a duplicate definition for an explicitly\n      // provided symbol.\n      if (candidateDefinition != null && explicitNode != null) {\n        explicitNode.detachFromParent();\n        compiler.reportCodeChange();\n\n        // Does this need a VAR keyword?\n        replacementNode = candidateDefinition;\n        if (NodeUtil.isExpressionNode(candidateDefinition)) {\n          candidateDefinition.putBooleanProp(Node.IS_NAMESPACE, true);\n          Node assignNode = candidateDefinition.getFirstChild();\n          Node nameNode = assignNode.getFirstChild();\n          if (nameNode.getType() == Token.NAME) {\n            // Need to convert this assign to a var declaration.\n            Node valueNode = nameNode.getNext();\n            assignNode.removeChild(nameNode);\n            assignNode.removeChild(valueNode);\n            nameNode.addChildToFront(valueNode);\n            Node varNode = new Node(Token.VAR, nameNode);\n            varNode.copyInformationFrom(candidateDefinition);\n            candidateDefinition.getParent().replaceChild(\n                candidateDefinition, varNode);\n            nameNode.setJSDocInfo(assignNode.getJSDocInfo());\n            compiler.reportCodeChange();\n            replacementNode = varNode;\n          }\n        }\n      } else {\n        // Handle the case where there's not a duplicate definition.\n        replacementNode = createDeclarationNode();\n        if (firstModule == minimumModule) {\n          firstNode.getParent().addChildBefore(replacementNode, firstNode);\n        } else {\n          // In this case, the name was implicitly provided by two independent\n          // modules. We need to move this code up to a common module.\n          int indexOfDot = namespace.indexOf('.');\n          if (indexOfDot == -1) {\n            // Any old place is fine.\n            compiler.getNodeForCodeInsertion(minimumModule)\n                .addChildToBack(replacementNode);\n          } else {\n            // Add it after the parent namespace.\n            ProvidedName parentName =\n                providedNames.get(namespace.substring(0, indexOfDot));\n            Preconditions.checkNotNull(parentName);\n            Preconditions.checkNotNull(parentName.replacementNode);\n            parentName.replacementNode.getParent().addChildAfter(\n                replacementNode, parentName.replacementNode);\n          }\n        }\n        if (explicitNode != null) {\n          explicitNode.detachFromParent();\n        }\n        compiler.reportCodeChange();\n      }\n    }",
    "comment": " Replace the provide statement.  If we're providing a name with no definition, then create one. If we're providing a name with a duplicate definition, then make sure that definition becomes a declaration. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "ProvidedName.updateMinimumModule",
    "class_name": "com.google.javascript.jscomp.ProcessClosurePrimitives$ProvidedName",
    "signature": "com.google.javascript.jscomp.ProcessClosurePrimitives$ProvidedName.updateMinimumModule(JSModule)",
    "snippet": "    private void updateMinimumModule(JSModule newModule) {\n      if (moduleGraph != null) {\n        if (minimumModule == null) {\n          minimumModule = newModule;\n        } else {\n          minimumModule = moduleGraph.getDeepestCommonDependencyInclusive(\n              minimumModule, newModule);\n        }\n      }\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "ProcessDefines.ProcessDefines",
    "class_name": "com.google.javascript.jscomp.ProcessDefines",
    "signature": "com.google.javascript.jscomp.ProcessDefines.ProcessDefines(AbstractCompiler,Map)",
    "snippet": "  ProcessDefines(AbstractCompiler compiler, Map<String, Node> replacements) {\n    this.compiler = compiler;\n    dominantReplacements = replacements;\n  }",
    "comment": " Create a pass that overrides define constants.  TODO(nicksantos): Write a builder to help JSCompiler induce {@code replacements} from command-line flags  @param replacements A hash table of names of defines to their replacements. All replacements <b>must</b> be literals. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "ProcessDefines.collectDefines",
    "class_name": "com.google.javascript.jscomp.ProcessDefines",
    "signature": "com.google.javascript.jscomp.ProcessDefines.collectDefines(Node,GlobalNamespace)",
    "snippet": "  private Map<String, DefineInfo> collectDefines(Node root,\n      GlobalNamespace namespace) {\n    // Find all the global names with a @define annotation\n    List<Name> allDefines = Lists.newArrayList();\n    for (Name name : namespace.getNameIndex().values()) {\n      if (name.docInfo != null && name.docInfo.isDefine()) {\n        allDefines.add(name);\n      } else if (name.refs != null) {\n        for (Ref ref : name.refs) {\n          Node n = ref.node;\n          Node parent = ref.node.getParent();\n          JSDocInfo info = n.getJSDocInfo();\n          if (info == null &&\n              parent.getType() == Token.VAR && parent.hasOneChild()) {\n            info = parent.getJSDocInfo();\n          }\n\n          if (info != null && info.isDefine()) {\n            allDefines.add(name);\n            break;\n          }\n        }\n      }\n    }\n\n    CollectDefines pass = new CollectDefines(compiler, allDefines);\n    NodeTraversal.traverse(compiler, root, pass);\n    return pass.getAllDefines();\n  }",
    "comment": " Finds all defines, and creates a {@link DefineInfo} data structure for each one. @return A map of {@link DefineInfo} structures, keyed by name. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "ProcessDefines.injectNamespace",
    "class_name": "com.google.javascript.jscomp.ProcessDefines",
    "signature": "com.google.javascript.jscomp.ProcessDefines.injectNamespace(GlobalNamespace)",
    "snippet": "  ProcessDefines injectNamespace(GlobalNamespace namespace) {\n    this.namespace = namespace;\n    return this;\n  }",
    "comment": " Injects a pre-computed global namespace, so that the same namespace can be re-used for multiple check passes. Returns {@code this} for easy chaining. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "ProcessDefines.overrideDefines",
    "class_name": "com.google.javascript.jscomp.ProcessDefines",
    "signature": "com.google.javascript.jscomp.ProcessDefines.overrideDefines(Map)",
    "snippet": "  private void overrideDefines(Map<String, DefineInfo> allDefines) {\n    boolean changed = false;\n    for (Map.Entry<String, DefineInfo> def : allDefines.entrySet()) {\n      String defineName = def.getKey();\n      DefineInfo info = def.getValue();\n      Node inputValue = dominantReplacements.get(defineName);\n      Node finalValue = inputValue != null ?\n          inputValue : info.getLastValue();\n      if (finalValue != info.initialValue) {\n        info.initialValueParent.replaceChild(\n            info.initialValue, finalValue.cloneTree());\n        compiler.addToDebugLog(\"Overriding @define variable \" + defineName);\n        changed = changed ||\n            finalValue.getType() != info.initialValue.getType() ||\n            !finalValue.isEquivalentTo(info.initialValue);\n      }\n    }\n\n    if (changed) {\n      compiler.reportCodeChange();\n    }\n\n    Set<String> unusedReplacements = dominantReplacements.keySet();\n    unusedReplacements.removeAll(allDefines.keySet());\n    unusedReplacements.removeAll(KNOWN_DEFINES);\n    for (String unknownDefine : unusedReplacements) {\n      compiler.report(JSError.make(UNKNOWN_DEFINE_WARNING, unknownDefine));\n    }\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "ProcessDefines.process",
    "class_name": "com.google.javascript.jscomp.ProcessDefines",
    "signature": "com.google.javascript.jscomp.ProcessDefines.process(Node,Node)",
    "snippet": "  public void process(Node externs, Node root) {\n    if (namespace == null) {\n      namespace = new GlobalNamespace(compiler, root);\n    }\n    overrideDefines(collectDefines(root, namespace));\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "CollectDefines.getAllDefines",
    "class_name": "com.google.javascript.jscomp.ProcessDefines$CollectDefines",
    "signature": "com.google.javascript.jscomp.ProcessDefines$CollectDefines.getAllDefines()",
    "snippet": "    Map<String, DefineInfo> getAllDefines() {\n      return allDefines;\n    }",
    "comment": " Get a map of {@link DefineInfo} structures, keyed by the name of the define. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "CollectDefines.shouldTraverse",
    "class_name": "com.google.javascript.jscomp.ProcessDefines$CollectDefines",
    "signature": "com.google.javascript.jscomp.ProcessDefines$CollectDefines.shouldTraverse(NodeTraversal,Node,Node)",
    "snippet": "    public boolean shouldTraverse(NodeTraversal nodeTraversal, Node n,\n        Node parent) {\n      updateAssignAllowedStack(n, true);\n      return true;\n    }",
    "comment": " Keeps track of whether the traversal is in a conditional branch. We traverse all nodes of the parse tree. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "CollectDefines.updateAssignAllowedStack",
    "class_name": "com.google.javascript.jscomp.ProcessDefines$CollectDefines",
    "signature": "com.google.javascript.jscomp.ProcessDefines$CollectDefines.updateAssignAllowedStack(Node,boolean)",
    "snippet": "    private void updateAssignAllowedStack(Node n, boolean entering) {\n      switch (n.getType()) {\n        case Token.CASE:\n        case Token.FOR:\n        case Token.FUNCTION:\n        case Token.HOOK:\n        case Token.IF:\n        case Token.SWITCH:\n        case Token.WHILE:\n          if (entering) {\n            assignAllowed.push(0);\n          } else {\n            assignAllowed.remove();\n          }\n          break;\n      }\n    }",
    "comment": " Determines whether assignment to a define should be allowed in the subtree of the given node, and if not, records that fact.  @param n The node whose subtree we're about to enter or exit. @param entering True if we're entering the subtree, false otherwise. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "CollectDefines.visit",
    "class_name": "com.google.javascript.jscomp.ProcessDefines$CollectDefines",
    "signature": "com.google.javascript.jscomp.ProcessDefines$CollectDefines.visit(NodeTraversal,Node,Node)",
    "snippet": "    public  void visit(NodeTraversal t, Node n, Node parent) {\n      RefInfo refInfo = allRefInfo.get(n);\n      if (refInfo != null) {\n        Ref ref = refInfo.ref;\n        Name name = refInfo.name;\n        String fullName = name.fullName();\n        switch (ref.type) {\n          case SET_FROM_GLOBAL:\n          case SET_FROM_LOCAL:\n            Node valParent = getValueParent(ref);\n            Node val = valParent.getLastChild();\n            if (valParent.getType() == Token.ASSIGN && name.isSimpleName() &&\n                name.declaration == ref) {\n              // For defines, it's an error if a simple name is assigned\n              // before it's declared\n              compiler.report(\n                  JSError.make(t, val, INVALID_DEFINE_INIT_ERROR, fullName));\n            } else if (processDefineAssignment(t, fullName, val, valParent)) {\n              // remove the assignment so that the variable is still declared,\n              // but no longer assigned to a value, e.g.,\n              // DEF_FOO = 5; // becomes \"5;\"\n\n              // We can't remove the ASSIGN/VAR when we're still visiting its\n              // children, so we'll have to come back later to remove it.\n              refInfo.name.removeRef(ref);\n              lvalueToRemoveLater = valParent;\n            }\n            break;\n          default:\n            if (t.inGlobalScope()) {\n              // Treat this as a reference to a define in the global scope.\n              // After this point, the define must not be reassigned,\n              // or it's an error.\n              DefineInfo info = assignableDefines.get(fullName);\n              if (info != null) {\n                setDefineInfoNotAssignable(info, t);\n                assignableDefines.remove(fullName);\n              }\n            }\n            break;\n        }\n      }\n\n      if (!t.inGlobalScope() &&\n          n.getJSDocInfo() != null && n.getJSDocInfo().isDefine()) {\n        // warn about @define annotations in local scopes\n        compiler.report(\n            JSError.make(t, n, NON_GLOBAL_DEFINE_INIT_ERROR, \"\"));\n      }\n\n      if (lvalueToRemoveLater == n) {\n        lvalueToRemoveLater = null;\n        if (n.getType() == Token.ASSIGN) {\n          Node last = n.getLastChild();\n          n.removeChild(last);\n          parent.replaceChild(n, last);\n        } else {\n          Preconditions.checkState(n.getType() == Token.NAME);\n          n.removeChild(n.getFirstChild());\n        }\n        compiler.reportCodeChange();\n      }\n\n      if (n.getType() == Token.CALL) {\n        if (t.inGlobalScope()) {\n          // If there's a function call in the global scope,\n          // we just say it's unsafe and freeze all the defines.\n          //\n          // NOTE(nicksantos): We could be a lot smarter here. For example,\n          // ReplaceOverriddenVars keeps a call graph of all functions and\n          // which functions/variables that they reference, and tries\n          // to statically determine which functions are \"safe\" and which\n          // are not. But this would be overkill, expecially because\n          // the intended use of defines is with config_files, where\n          // all the defines are at the top of the bundle.\n          for (DefineInfo info : assignableDefines.values()) {\n            setDefineInfoNotAssignable(info, t);\n          }\n\n          assignableDefines.clear();\n        }\n      }\n\n      updateAssignAllowedStack(n, false);\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "ReferenceCollectingCallback.ReferenceCollectingCallback",
    "class_name": "com.google.javascript.jscomp.ReferenceCollectingCallback",
    "signature": "com.google.javascript.jscomp.ReferenceCollectingCallback.ReferenceCollectingCallback(AbstractCompiler,Behavior,Predicate)",
    "snippet": "  ReferenceCollectingCallback(AbstractCompiler compiler, Behavior behavior,\n      Predicate<Var> varFilter) {\n    this.compiler = compiler;\n    this.behavior = behavior;\n    this.varFilter = varFilter;\n  }",
    "comment": " Constructor only collects references that match the given variable.  The test for Var equality uses reference equality, so it's necessary to inject a scope when you traverse. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "ReferenceCollectingCallback.enterScope",
    "class_name": "com.google.javascript.jscomp.ReferenceCollectingCallback",
    "signature": "com.google.javascript.jscomp.ReferenceCollectingCallback.enterScope(NodeTraversal)",
    "snippet": "  public void enterScope(NodeTraversal t) {\n    Node n = t.getScope().getRootNode();\n    BasicBlock parent = blockStack.isEmpty() ? null : blockStack.peek();\n    blockStack.push(new BasicBlock(parent, n));\n  }",
    "comment": " Updates block stack and invokes any additional behavior. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "ReferenceCollectingCallback.exitScope",
    "class_name": "com.google.javascript.jscomp.ReferenceCollectingCallback",
    "signature": "com.google.javascript.jscomp.ReferenceCollectingCallback.exitScope(NodeTraversal)",
    "snippet": "  public void exitScope(NodeTraversal t) {\n    blockStack.pop();\n    behavior.afterExitScope(t, referenceMap);\n  }",
    "comment": " Updates block statck and invokes any additional behavior. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "ReferenceCollectingCallback.isBlockBoundary",
    "class_name": "com.google.javascript.jscomp.ReferenceCollectingCallback",
    "signature": "com.google.javascript.jscomp.ReferenceCollectingCallback.isBlockBoundary(Node,Node)",
    "snippet": "  private static boolean isBlockBoundary(Node n, Node parent) {\n    if (parent != null) {\n      switch (parent.getType()) {\n        case Token.DO:\n        case Token.FOR:\n        case Token.TRY:\n        case Token.WHILE:\n        case Token.WITH:\n          // NOTE: TRY has up to 3 child blocks:\n          // TRY\n          //   BLOCK\n          //   BLOCK\n          //     CATCH\n          //   BLOCK\n          // Note that there is an explcit CATCH token but no explicit\n          // FINALLY token. For simplicity, we consider each BLOCK\n          // a separate basic BLOCK.\n          return true;\n        case Token.AND:\n        case Token.HOOK:\n        case Token.IF:\n        case Token.OR:\n          // The first child of a conditional is not a boundary,\n          // but all the rest of the children are.\n          return n != parent.getFirstChild();\n\n      }\n    }\n\n    return n.getType() == Token.CASE;\n  }",
    "comment": " @return true if this node marks the start of a new basic block ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "ReferenceCollectingCallback.process",
    "class_name": "com.google.javascript.jscomp.ReferenceCollectingCallback",
    "signature": "com.google.javascript.jscomp.ReferenceCollectingCallback.process(Node,Node)",
    "snippet": "  public void process(Node externs, Node root) {\n    NodeTraversal.traverse(compiler, root, this);\n  }",
    "comment": " Convenience method for running this pass over a tree with this class as a callback. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "ReferenceCollectingCallback.shouldTraverse",
    "class_name": "com.google.javascript.jscomp.ReferenceCollectingCallback",
    "signature": "com.google.javascript.jscomp.ReferenceCollectingCallback.shouldTraverse(NodeTraversal,Node,Node)",
    "snippet": "  public boolean shouldTraverse(NodeTraversal nodeTraversal, Node n,\n      Node parent) {\n    // If node is a new basic block, put on basic block stack\n    if (isBlockBoundary(n, parent)) {\n      blockStack.push(new BasicBlock(blockStack.peek(), n));\n    }\n    return true;\n  }",
    "comment": " Updates block stack. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "ReferenceCollectingCallback.visit",
    "class_name": "com.google.javascript.jscomp.ReferenceCollectingCallback",
    "signature": "com.google.javascript.jscomp.ReferenceCollectingCallback.visit(NodeTraversal,Node,Node)",
    "snippet": "  public void visit(NodeTraversal t, Node n, Node parent) {\n    if (n.getType() == Token.NAME) {\n      Var v = t.getScope().getVar(n.getString());\n      if (v != null && varFilter.apply(v)) {\n        addReference(t, v,\n            new Reference(n, parent, t, blockStack.peek()));\n      }\n    }\n\n    if (isBlockBoundary(n, parent)) {\n      blockStack.pop();\n    }\n  }",
    "comment": " For each node, update the block stack and reference collection as appropriate. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "RemoveConstantExpressions.RemoveConstantExpressions",
    "class_name": "com.google.javascript.jscomp.RemoveConstantExpressions",
    "signature": "com.google.javascript.jscomp.RemoveConstantExpressions.RemoveConstantExpressions(AbstractCompiler)",
    "snippet": "  RemoveConstantExpressions(AbstractCompiler compiler) {\n    this.compiler = compiler;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "RemoveConstantExpressions.process",
    "class_name": "com.google.javascript.jscomp.RemoveConstantExpressions",
    "signature": "com.google.javascript.jscomp.RemoveConstantExpressions.process(Node,Node)",
    "snippet": "  @Override\n  public void process(Node externs, Node root) {\n    RemoveConstantRValuesCallback cb = new RemoveConstantRValuesCallback();\n    NodeTraversal.traverse(null, root, cb);\n    cb.getResult().notifyCompiler(compiler);\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "RemoveConstantRValuesCallback.getResult",
    "class_name": "com.google.javascript.jscomp.RemoveConstantExpressions$RemoveConstantRValuesCallback",
    "signature": "com.google.javascript.jscomp.RemoveConstantExpressions$RemoveConstantRValuesCallback.getResult()",
    "snippet": "    public Result getResult() {\n      return result;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "RemoveConstantRValuesCallback.trySimplify",
    "class_name": "com.google.javascript.jscomp.RemoveConstantExpressions$RemoveConstantRValuesCallback",
    "signature": "com.google.javascript.jscomp.RemoveConstantExpressions$RemoveConstantRValuesCallback.trySimplify(Node,Node)",
    "snippet": "    private void trySimplify(Node parent, Node node) {\n      if (node.getType() != Token.EXPR_RESULT) {\n        return;\n      }\n\n      Node exprBody = node.getFirstChild();\n      if (!NodeUtil.nodeTypeMayHaveSideEffects(exprBody)) {\n        changeProxy.replaceWith(parent, node, getSideEffectNodes(exprBody));\n      }\n    }",
    "comment": " Attempts to replace the input node with a simpler but functionally equivalent set of nodes. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "RemoveConstantRValuesCallback.visit",
    "class_name": "com.google.javascript.jscomp.RemoveConstantExpressions$RemoveConstantRValuesCallback",
    "signature": "com.google.javascript.jscomp.RemoveConstantExpressions$RemoveConstantRValuesCallback.visit(NodeTraversal,Node,Node)",
    "snippet": "    @Override\n    public void visit(NodeTraversal traversal, Node node, Node parent) {\n      trySimplify(parent, node);\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "RemoveUnusedVars.RemoveUnusedVars",
    "class_name": "com.google.javascript.jscomp.RemoveUnusedVars",
    "signature": "com.google.javascript.jscomp.RemoveUnusedVars.RemoveUnusedVars(AbstractCompiler,boolean,boolean)",
    "snippet": "  RemoveUnusedVars(\n      AbstractCompiler compiler,\n      boolean removeGlobals,\n      boolean preserveAnonymousFunctionNames) {\n    compiler_ = compiler;\n    this.removeGlobals = removeGlobals;\n    this.preserveAnonymousFunctionNames = preserveAnonymousFunctionNames;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "RemoveUnusedVars.markReferencedVar",
    "class_name": "com.google.javascript.jscomp.RemoveUnusedVars",
    "signature": "com.google.javascript.jscomp.RemoveUnusedVars.markReferencedVar(Var)",
    "snippet": "  private void markReferencedVar(Var var) {\n    if (referenced.contains(var)) {\n      // Already marked\n      return;\n    }\n    referenced.add(var);\n\n    Node parent = var.getParentNode();\n    if (parent.getType() == Token.FUNCTION &&\n        var.getInitialValue() != var.scope.getRootNode()) {\n      // Now that the function has been referenced, traverse it.\n      // Unless it's a bleeding function, in which case we're already\n      // traversing it.\n\n      traverseFunction(parent, var.scope);\n    }\n  }",
    "comment": " Marks a var as referenced, recursing into any functions. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "RemoveUnusedVars.process",
    "class_name": "com.google.javascript.jscomp.RemoveUnusedVars",
    "signature": "com.google.javascript.jscomp.RemoveUnusedVars.process(Node,Node)",
    "snippet": "  public void process(Node externs, Node root) {\n    warnedVars_.clear();\n    numRemoved_ = 0;\n    referenced.clear();\n\n    traverseAndRemoveUnusedReferences(root);\n\n    if (numRemoved_ > 0) {\n      compiler_.reportCodeChange();\n    }\n  }",
    "comment": " Traverses the root, removing all unused variables. Multiple traversals may occur to ensure all unused variables are removed. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "RemoveUnusedVars.traverseAndRemoveUnusedReferences",
    "class_name": "com.google.javascript.jscomp.RemoveUnusedVars",
    "signature": "com.google.javascript.jscomp.RemoveUnusedVars.traverseAndRemoveUnusedReferences(Node)",
    "snippet": "  private void traverseAndRemoveUnusedReferences(Node root) {\n    Scope scope = new SyntacticScopeCreator(compiler_).createScope(root, null);\n    traverseNode(root, null, scope);\n\n    if (removeGlobals) {\n      removeUnreferencedVars(scope);\n    }\n  }",
    "comment": " Traverses a node recursively. Call this once per pass. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "RemoveUnusedVars.traverseNode",
    "class_name": "com.google.javascript.jscomp.RemoveUnusedVars",
    "signature": "com.google.javascript.jscomp.RemoveUnusedVars.traverseNode(Node,Node,Scope)",
    "snippet": "  private void traverseNode(Node n, Node parent, Scope scope) {\n    int type = n.getType();\n    switch (type) {\n      // We traverse a function only if the function definition is\n      // immediately being referenced, e.g.\n      // - return function() { ... };\n      // - foo( function() { ... } )\n      // - array[ function() { ... } ];\n      //\n      // Otherwise we traverse into the function only when we encounter\n      // a reference to it (see markReferencedVar())\n      case Token.FUNCTION:\n        // If it's an exported function, or an anonymous function, assume\n        // that it'll be called.\n        if (NodeUtil.isFunctionAnonymous(n) ||\n            compiler_.getCodingConvention().isExported(\n                n.getFirstChild().getString())) {\n          traverseFunction(n, scope);\n        }\n        return;\n\n      case Token.NAME:\n        if (parent.getType() != Token.VAR) {\n          // All non-var declarations are references to other vars\n          Var var = scope.getVar(n.getString());\n          if (var != null) {\n            markReferencedVar(var);\n          }\n        }\n        break;\n    }\n\n    for (Node c = n.getFirstChild(); c != null; c = c.getNext()) {\n      traverseNode(c, n, scope);\n    }\n  }",
    "comment": " Traverses everything in the current scope and marks variables that are referenced. Functions create their own scope, so we don't recurse into them unless they are called. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "RenameLabels.RenameLabels",
    "class_name": "com.google.javascript.jscomp.RenameLabels",
    "signature": "com.google.javascript.jscomp.RenameLabels.RenameLabels(AbstractCompiler)",
    "snippet": "  RenameLabels(AbstractCompiler compiler) {\n    this.compiler = compiler;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "RenameLabels.process",
    "class_name": "com.google.javascript.jscomp.RenameLabels",
    "signature": "com.google.javascript.jscomp.RenameLabels.process(Node,Node)",
    "snippet": "  public void process(Node externs, Node root) {\n    // Do variable reference counting.\n    NodeTraversal.traverse(compiler, root, new ProcessLabels());\n  }",
    "comment": " {@inheritDoc} ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "ProcessLabels.enterScope",
    "class_name": "com.google.javascript.jscomp.RenameLabels$ProcessLabels",
    "signature": "com.google.javascript.jscomp.RenameLabels$ProcessLabels.enterScope(NodeTraversal)",
    "snippet": "    @Override\n    public void enterScope(NodeTraversal nodeTraversal) {\n      // Start a new namespace for label names.\n      namespaceStack.push(new LabelNamespace());\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "ProcessLabels.exitScope",
    "class_name": "com.google.javascript.jscomp.RenameLabels$ProcessLabels",
    "signature": "com.google.javascript.jscomp.RenameLabels$ProcessLabels.exitScope(NodeTraversal)",
    "snippet": "    @Override\n    public void exitScope(NodeTraversal nodeTraversal) {\n      namespaceStack.pop();\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "ProcessLabels.shouldTraverse",
    "class_name": "com.google.javascript.jscomp.RenameLabels$ProcessLabels",
    "signature": "com.google.javascript.jscomp.RenameLabels$ProcessLabels.shouldTraverse(NodeTraversal,Node,Node)",
    "snippet": "    public boolean shouldTraverse(NodeTraversal nodeTraversal, Node node,\n        Node parent) {\n      if (node.getType() == Token.LABEL) {\n        // Determine the new name for this label.\n        LabelNamespace current = namespaceStack.peek();\n        int currentDepth = current.renameMap.size() + 1;\n        String name = node.getFirstChild().getString();\n\n        // Store the context for this label name.\n        LabelInfo li = new LabelInfo(currentDepth);\n        Preconditions.checkState(!current.renameMap.containsKey(name));\n        current.renameMap.put(name, li);\n\n        // Create a new name, if needed, for this depth.\n        if (names.size() < currentDepth) {\n          names.add(nameGenerator.generateNextName());\n        }\n\n        String newName = getNameForId(currentDepth);\n        compiler.addToDebugLog(\"label renamed: \" + name + \" => \" + newName);\n      }\n\n      return true;\n    }",
    "comment": " shouldTraverse is call when descending into the Node tree, so it is used here to build the context for label renames.  {@inheritDoc} ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "ProcessLabels.visit",
    "class_name": "com.google.javascript.jscomp.RenameLabels$ProcessLabels",
    "signature": "com.google.javascript.jscomp.RenameLabels$ProcessLabels.visit(NodeTraversal,Node,Node)",
    "snippet": "    public void visit(NodeTraversal nodeTraversal, Node node, Node parent) {\n      switch (node.getType()) {\n        case Token.LABEL:\n          visitLabel(node, parent);\n          break;\n\n        case Token.BREAK:\n        case Token.CONTINUE:\n          visitBreakOrContinue(node);\n          break;\n      }\n    }",
    "comment": " Delegate the actual processing of the node to visitLabel and visitBreakOrContinue.  {@inheritDoc} ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "RenameVars.RenameVars",
    "class_name": "com.google.javascript.jscomp.RenameVars",
    "signature": "com.google.javascript.jscomp.RenameVars.RenameVars(AbstractCompiler,String,boolean,boolean,boolean,VariableMap,char[],Set)",
    "snippet": "  RenameVars(AbstractCompiler compiler,\n      String prefix,\n      boolean localRenamingOnly,\n      boolean preserveAnonymousFunctionNames,\n      boolean generatePseudoNames,\n      VariableMap prevUsedRenameMap,\n      @Nullable char[] reservedCharacters,\n      @Nullable Set<String> reservedNames) {\n    this.compiler = compiler;\n    this.prefix = prefix == null ? \"\" : prefix;\n    this.localRenamingOnly = localRenamingOnly;\n    this.preserveAnonymousFunctionNames = preserveAnonymousFunctionNames;\n    this.generatePseudoNames = generatePseudoNames;\n    this.prevUsedRenameMap = prevUsedRenameMap;\n    this.reservedCharacters = reservedCharacters;\n    if (reservedNames == null) {\n      this.reservedNames = Sets.newHashSet();\n    } else {\n      this.reservedNames = Sets.newHashSet(reservedNames);\n    }\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "RenameVars.assignNames",
    "class_name": "com.google.javascript.jscomp.RenameVars",
    "signature": "com.google.javascript.jscomp.RenameVars.assignNames(Set)",
    "snippet": "  private void assignNames(Set<Assignment> varsToRename) {\n    NameGenerator globalNameGenerator =\n        new NameGenerator(reservedNames, prefix, reservedCharacters);\n\n    // Local variables never need a prefix.\n    NameGenerator localNameGenerator = prefix.isEmpty() ?\n        globalNameGenerator : new NameGenerator(reservedNames, \"\",\n        reservedCharacters);\n\n    // Generated names and the assignments for non-local vars.\n    List<Assignment> pendingAssignments = new ArrayList<Assignment>();\n    List<String> generatedNamesForAssignments = new ArrayList<String>();\n\n    for (Assignment a : varsToRename) {\n      if (a.newName != null) {\n        continue;\n      }\n\n      if (externNames.contains(a.oldName)) {\n        continue;\n      }\n\n      String newName;\n      if (a.oldName.startsWith(LOCAL_VAR_PREFIX)) {\n        // For local variable, we make the assignment right away.\n        newName = localNameGenerator.generateNextName();\n        finalizeNameAssignment(a, newName);\n      } else {\n        // For non-local variable, delay finalizing the name assignment\n        // until we know how many new names we'll have of length 2, 3, etc.\n        newName = globalNameGenerator.generateNextName();\n        pendingAssignments.add(a);\n        generatedNamesForAssignments.add(newName);\n      }\n      reservedNames.add(newName);\n    }\n\n    // Now that we have a list of generated names, and a list of variable\n    // Assignment objects, we assign the generated names to the vars as\n    // follows:\n    // 1) The most frequent vars get the shorter names.\n    // 2) If N number of vars are going to be assigned names of the same\n    //    length, we assign the N names based on the order at which the vars\n    //    first appear in the source. This makes the output somewhat less\n    //    random, because symbols declared close together are assigned names\n    //    that are quite similar. With this heuristic, the output is more\n    //    compressible.\n    //    For instance, the output may look like:\n    //    var da = \"..\", ea = \"..\";\n    //    function fa() { .. } function ga() { .. }\n\n    int numPendingAssignments = generatedNamesForAssignments.size();\n    for (int i = 0; i < numPendingAssignments;) {\n      SortedSet<Assignment> varsByOrderOfOccurrence =\n          new TreeSet<Assignment>(ORDER_OF_OCCURRENCE_COMPARATOR);\n\n      // Add k number of Assignment to the set, where k is the number of\n      // generated names of the same length.\n      int len = generatedNamesForAssignments.get(i).length();\n      for (int j = i;\n           j < numPendingAssignments &&\n               generatedNamesForAssignments.get(j).length() == len;\n           j++) {\n        varsByOrderOfOccurrence.add(pendingAssignments.get(j));\n      }\n\n      // Now, make the assignments\n      for (Assignment a : varsByOrderOfOccurrence) {\n        finalizeNameAssignment(a, generatedNamesForAssignments.get(i));\n        ++i;\n      }\n    }\n  }",
    "comment": " Determines which new names to substitute for the original names. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "RenameVars.getVariableMap",
    "class_name": "com.google.javascript.jscomp.RenameVars",
    "signature": "com.google.javascript.jscomp.RenameVars.getVariableMap()",
    "snippet": "  VariableMap getVariableMap() {\n    return new VariableMap(renameMap);\n  }",
    "comment": " Gets the variable map. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "RenameVars.okToRenameVar",
    "class_name": "com.google.javascript.jscomp.RenameVars",
    "signature": "com.google.javascript.jscomp.RenameVars.okToRenameVar(String,boolean)",
    "snippet": "  private boolean okToRenameVar(String name, boolean isLocal) {\n    return !compiler.getCodingConvention().isExported(name, isLocal);\n  }",
    "comment": " Determines whether a variable name is okay to rename. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "RenameVars.process",
    "class_name": "com.google.javascript.jscomp.RenameVars",
    "signature": "com.google.javascript.jscomp.RenameVars.process(Node,Node)",
    "snippet": "  public void process(Node externs, Node root) {\n    assignmentLog = new StringBuilder();\n\n    // Do variable reference counting.\n    NodeTraversal.traverse(compiler, externs, new ProcessVars(true));\n    NodeTraversal.traverse(compiler, root, new ProcessVars(false));\n\n    // Make sure that new names don't overlap with extern names.\n    reservedNames.addAll(externNames);\n\n    // Rename vars, sorted by frequency of occurrence to minimize code size.\n    SortedSet<Assignment> varsByFrequency =\n        new TreeSet<Assignment>(FREQUENCY_COMPARATOR);\n    varsByFrequency.addAll(assignments.values());\n\n    // First try to reuse names from an earlier compilation.\n    if (prevUsedRenameMap != null) {\n      reusePreviouslyUsedVariableMap();\n    }\n\n    // Assign names, sorted by descending frequency to minimize code size.\n    assignNames(varsByFrequency);\n\n    boolean changed = false;\n\n    // Rename the globals!\n    for (Node n : globalNameNodes) {\n      String newName = getNewGlobalName(n);\n      // Note: if newName is null, then oldName is an extern.\n      if (newName != null) {\n        n.setString(newName);\n        changed = true;\n      }\n    }\n\n    // Rename the locals!\n    int count = 0;\n    for (Node n : localNameNodes) {\n      String newName = getNewLocalName(n, count);\n      if (newName != null) {\n        n.setString(newName);\n        changed = true;\n      }\n      count++;\n    }\n\n    if (changed) {\n      compiler.reportCodeChange();\n    }\n\n    // Lastly, write the name assignments to the debug log.\n    compiler.addToDebugLog(\"JS var assignments:\\n\" + assignmentLog);\n    assignmentLog = null;\n  }",
    "comment": " {@inheritDoc} ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "ProcessVars.visit",
    "class_name": "com.google.javascript.jscomp.RenameVars$ProcessVars",
    "signature": "com.google.javascript.jscomp.RenameVars$ProcessVars.visit(NodeTraversal,Node,Node)",
    "snippet": "    @Override\n    public void visit(NodeTraversal t, Node n, Node parent) {\n      if (n.getType() != Token.NAME) {\n        return;\n      }\n\n      String name = n.getString();\n\n      // Ignore anonymous functions\n      if (name.length() == 0) {\n        return;\n      }\n\n      // Is this local or Global?\n      Scope.Var var = t.getScope().getVar(name);\n      boolean local = (var != null) && var.isLocal();\n\n      // Are we renaming global variables?\n      if (!local && localRenamingOnly) {\n        reservedNames.add(name);\n        return;\n      }\n\n      // Are we renaming anonymous function names?\n      if (preserveAnonymousFunctionNames\n          && var != null\n          && NodeUtil.isAnonymousFunction(var.getParentNode())) {\n        reservedNames.add(name);\n        return;\n      }\n\n      // Check if we can rename this.\n      if (!okToRenameVar(name, local)) {\n        if (local) {\n          // Blindly de-uniquify for the Prototype library for issue 103.\n          String newName =\n            MakeDeclaredNamesUnique.ContextualRenameInverter.getOrginalName(\n                name);\n          if (!newName.equals(name)) {\n            n.setString(newName);\n          }\n        }\n        return;\n      }\n\n      if (isExternsPass_) {\n        // Keep track of extern globals.\n        if (!local) {\n          externNames.add(name);\n        }\n        return;\n      }\n\n      if (local) {\n        // Local var: assign a new name\n        String tempName = LOCAL_VAR_PREFIX + var.getLocalVarIndex();\n        incCount(tempName, null);\n        localNameNodes.add(n);\n        localTempNames.add(tempName);\n      } else if (var != null) {  // Not an extern\n        // If it's global, increment global count\n        incCount(name, var.input);\n        globalNameNodes.add(n);\n      }\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "ReplaceCssNames.ReplaceCssNames",
    "class_name": "com.google.javascript.jscomp.ReplaceCssNames",
    "signature": "com.google.javascript.jscomp.ReplaceCssNames.ReplaceCssNames(AbstractCompiler,Map)",
    "snippet": "  ReplaceCssNames(AbstractCompiler compiler,\n      @Nullable Map<String, Integer> cssNames) {\n    this.compiler = compiler;\n    this.cssNames = cssNames;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "ReplaceCssNames.getCssRenamingMap",
    "class_name": "com.google.javascript.jscomp.ReplaceCssNames",
    "signature": "com.google.javascript.jscomp.ReplaceCssNames.getCssRenamingMap()",
    "snippet": "  @VisibleForTesting\n  protected CssRenamingMap getCssRenamingMap() {\n    return compiler.getCssRenamingMap();\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "ReplaceCssNames.process",
    "class_name": "com.google.javascript.jscomp.ReplaceCssNames",
    "signature": "com.google.javascript.jscomp.ReplaceCssNames.process(Node,Node)",
    "snippet": "  @Override\n  public void process(Node externs, Node root) {\n    // The CssRenamingMap may not have been available from the compiler when\n    // this ReplaceCssNames pass was constructed, so getCssRenamingMap() should\n    // only be called before this pass is actually run.\n    symbolMap = getCssRenamingMap();\n\n    NodeTraversal.traverse(compiler, root, new Traversal());\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "Traversal.visit",
    "class_name": "com.google.javascript.jscomp.ReplaceCssNames$Traversal",
    "signature": "com.google.javascript.jscomp.ReplaceCssNames$Traversal.visit(NodeTraversal,Node,Node)",
    "snippet": "    @Override\n    public void visit(NodeTraversal t, Node n, Node parent) {\n      if (n.getType() == Token.CALL &&\n          GET_CSS_NAME_FUNCTION.equals(n.getFirstChild().getQualifiedName())) {\n        int count = n.getChildCount();\n        Node first = n.getFirstChild().getNext();\n        switch (count) {\n          case 2:\n            // Replace the function call with the processed argument.\n            if (first.getType() == Token.STRING) {\n              processStringNode(t, first);\n              n.removeChild(first);\n              parent.replaceChild(n, first);\n              compiler.reportCodeChange();\n            } else {\n              compiler.report(JSError.make(t, n, STRING_LITERAL_EXPECTED_ERROR,\n                  Token.name(first.getType())));\n            }\n            break;\n\n          case 3:\n            // Replace function call with concatenation of two args.  It's\n            // assumed the first arg has already been processed.\n\n            Node second = first.getNext();\n\n            if (first.getType() == Token.STRING) {\n              compiler.report(JSError.make(\n                  t, n, UNEXPECTED_STRING_LITERAL_ERROR,\n                  first.getString(), second.getString()));\n\n            } else if (second.getType() == Token.STRING) {\n              processStringNode(t, second);\n              n.removeChild(first);\n              Node replacement = new Node(Token.ADD, first,\n                  Node.newString(\"-\" + second.getString()));\n              parent.replaceChild(n, replacement);\n              compiler.reportCodeChange();\n\n            } else {\n              compiler.report(JSError.make(t, n, STRING_LITERAL_EXPECTED_ERROR,\n                  Token.name(second.getType())));\n            }\n            break;\n\n          default:\n            compiler.report(JSError.make(\n                t, n, INVALID_NUM_ARGUMENTS_ERROR, String.valueOf(count)));\n        }\n      }\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "Result.Result",
    "class_name": "com.google.javascript.jscomp.Result",
    "signature": "com.google.javascript.jscomp.Result.Result(JSError[],JSError[],String,VariableMap,VariableMap,VariableMap,FunctionInformationMap,SourceMap,String,Map)",
    "snippet": "  Result(JSError[] errors, JSError[] warnings, String debugLog,\n         VariableMap variableMap, VariableMap propertyMap,\n         VariableMap namedAnonFunctionMap,\n         FunctionInformationMap functionInformationMap,\n         SourceMap sourceMap,  String externExport,\n         Map<String, Integer> cssNames) {\n    this.success = errors.length == 0;\n    this.errors = errors;\n    this.warnings = warnings;\n    this.debugLog = debugLog;\n    this.variableMap = variableMap;\n    this.propertyMap = propertyMap;\n    this.namedAnonFunctionMap = namedAnonFunctionMap;\n    this.functionInformationMap = functionInformationMap;\n    this.sourceMap = sourceMap;\n    this.externExport = externExport;\n    this.cssNames = cssNames;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "RhinoErrorReporter.forNewRhino",
    "class_name": "com.google.javascript.jscomp.RhinoErrorReporter",
    "signature": "com.google.javascript.jscomp.RhinoErrorReporter.forNewRhino(AbstractCompiler)",
    "snippet": "  public static com.google.javascript.jscomp.mozilla.rhino.ErrorReporter\n      forNewRhino(AbstractCompiler compiler) {\n    return new NewRhinoErrorReporter(compiler);\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "RhinoErrorReporter.forOldRhino",
    "class_name": "com.google.javascript.jscomp.RhinoErrorReporter",
    "signature": "com.google.javascript.jscomp.RhinoErrorReporter.forOldRhino(AbstractCompiler)",
    "snippet": "  public static ErrorReporter forOldRhino(AbstractCompiler compiler) {\n    return new OldRhinoErrorReporter(compiler);\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "RhinoErrorReporter.replacePlaceHolders",
    "class_name": "com.google.javascript.jscomp.RhinoErrorReporter",
    "signature": "com.google.javascript.jscomp.RhinoErrorReporter.replacePlaceHolders(String)",
    "snippet": "  private String replacePlaceHolders(String s) {\n    s = Pattern.quote(s);\n    return s.replaceAll(\"\\\\{\\\\d+\\\\}\", \"\\\\\\\\E.*\\\\\\\\Q\");\n  }",
    "comment": " For each message such as \"Not a good use of {0}\", replace the place holder {0} with a wild card that matches all possible strings. Also put the any non-place-holder in quotes for regex matching later. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "Scope.Scope",
    "class_name": "com.google.javascript.jscomp.Scope",
    "signature": "com.google.javascript.jscomp.Scope.Scope(Node,AbstractCompiler)",
    "snippet": "  Scope(Node rootNode, AbstractCompiler compiler) {\n    this.parent = null;\n    this.rootNode = rootNode;\n    thisType = compiler.getTypeRegistry().getNativeObjectType(GLOBAL_THIS);\n    this.isBottom = false;\n  }",
    "comment": " Creates a global Scope. @param rootNode  Typically the global BLOCK node. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "Scope.Scope",
    "class_name": "com.google.javascript.jscomp.Scope",
    "signature": "com.google.javascript.jscomp.Scope.Scope(Scope,Node)",
    "snippet": "  Scope(Scope parent, Node rootNode) {\n    Preconditions.checkNotNull(parent);\n    Preconditions.checkArgument(rootNode != parent.rootNode);\n\n    this.parent = parent;\n    this.rootNode = rootNode;\n    JSType nodeType = rootNode.getJSType();\n    if (nodeType != null && nodeType instanceof FunctionType) {\n      thisType = ((FunctionType) nodeType).getTypeOfThis();\n    } else {\n      thisType = parent.thisType;\n    }\n    this.isBottom = false;\n  }",
    "comment": " Creates a Scope given the parent Scope and the root node of the scope. @param parent  The parent Scope. Cannot be null. @param rootNode  Typically the FUNCTION node. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "Scope.declare",
    "class_name": "com.google.javascript.jscomp.Scope",
    "signature": "com.google.javascript.jscomp.Scope.declare(String,Node,JSType,CompilerInput)",
    "snippet": "  Var declare(String name, Node nameNode, JSType type, CompilerInput input) {\n    return declare(name, nameNode, type, input, true);\n  }",
    "comment": " Declares a variable whose type is inferred.  @param name name of the variable @param nameNode the NAME node declaring the variable @param type the variable's type @param input the input in which this variable is defined. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "Scope.declare",
    "class_name": "com.google.javascript.jscomp.Scope",
    "signature": "com.google.javascript.jscomp.Scope.declare(String,Node,JSType,CompilerInput,boolean)",
    "snippet": "  Var declare(String name, Node nameNode,\n      JSType type, CompilerInput input, boolean inferred) {\n    Preconditions.checkState(name != null && name.length() > 0);\n\n    // Make sure that it's declared only once\n    Preconditions.checkState(vars.get(name) == null);\n\n    Var var = new Var(inferred);\n    var.name = name;\n    var.nameNode = nameNode;\n    var.type = type;\n    var.scope = this;\n    var.index = vars.size();\n    var.input = input;\n\n    // native variables do not have a name node.\n    // TODO(user): make Var abstract and have NativeVar, NormalVar.\n    JSDocInfo info = NodeUtil.getInfoForNameNode(nameNode);\n\n    var.isDefine = info != null && info.isDefine();\n    var.info = info;\n\n    vars.put(name, var);\n    return var;\n  }",
    "comment": " Declares a variable.  @param name name of the variable @param nameNode the NAME node declaring the variable @param type the variable's type @param input the input in which this variable is defined. @param inferred Whether this variable's type is inferred (as opposed to declared). ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "Scope.getParent",
    "class_name": "com.google.javascript.jscomp.Scope",
    "signature": "com.google.javascript.jscomp.Scope.getParent()",
    "snippet": "  public Scope getParent() {\n    return parent;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "Scope.getRootNode",
    "class_name": "com.google.javascript.jscomp.Scope",
    "signature": "com.google.javascript.jscomp.Scope.getRootNode()",
    "snippet": "  public Node getRootNode() {\n    return rootNode;\n  }",
    "comment": " Gets the container node of the scope. This is typically the FUNCTION node or the global BLOCK/SCRIPT node. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "Scope.getVar",
    "class_name": "com.google.javascript.jscomp.Scope",
    "signature": "com.google.javascript.jscomp.Scope.getVar(String)",
    "snippet": "  public Var getVar(String name) {\n    Var var = vars.get(name);\n    if (var != null) {\n      return var;\n    } else if (parent != null) { // Recurse up the parent Scope\n      return parent.getVar(name);\n    } else {\n      return null;\n    }\n  }",
    "comment": " Returns the variable, may be null ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "Scope.getVars",
    "class_name": "com.google.javascript.jscomp.Scope",
    "signature": "com.google.javascript.jscomp.Scope.getVars()",
    "snippet": "  public Iterator<Var> getVars() {\n    return vars.values().iterator();\n  }",
    "comment": " Return an iterator over all of the variables declared in this scope. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "Scope.isDeclared",
    "class_name": "com.google.javascript.jscomp.Scope",
    "signature": "com.google.javascript.jscomp.Scope.isDeclared(String,boolean)",
    "snippet": "  public boolean isDeclared(String name, boolean recurse) {\n    Scope scope = this;\n    if (scope.vars.containsKey(name))\n      return true;\n\n    if (scope.parent != null && recurse) {\n      return scope.parent.isDeclared(name, recurse);\n    }\n    return false;\n  }",
    "comment": " Returns true if a variable is declared. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "Scope.isGlobal",
    "class_name": "com.google.javascript.jscomp.Scope",
    "signature": "com.google.javascript.jscomp.Scope.isGlobal()",
    "snippet": "  public boolean isGlobal() {\n    return parent == null;\n  }",
    "comment": " Returns whether this is the global scope. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "Scope.isLocal",
    "class_name": "com.google.javascript.jscomp.Scope",
    "signature": "com.google.javascript.jscomp.Scope.isLocal()",
    "snippet": "  public boolean isLocal() {\n    return !isGlobal();\n  }",
    "comment": " Returns whether this is a local scope (i.e. not the global scope). ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "Var.getJSDocInfo",
    "class_name": "com.google.javascript.jscomp.Scope$Var",
    "signature": "com.google.javascript.jscomp.Scope$Var.getJSDocInfo()",
    "snippet": "    public JSDocInfo getJSDocInfo() {\n      return info;\n    }",
    "comment": " Gets the JSDocInfo for the variable. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "Var.getName",
    "class_name": "com.google.javascript.jscomp.Scope$Var",
    "signature": "com.google.javascript.jscomp.Scope$Var.getName()",
    "snippet": "    public String getName() {\n      return name;\n    }",
    "comment": " Gets the name of the variable. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "Var.getParentNode",
    "class_name": "com.google.javascript.jscomp.Scope$Var",
    "signature": "com.google.javascript.jscomp.Scope$Var.getParentNode()",
    "snippet": "    public Node getParentNode() {\n      return nameNode == null ? null : nameNode.getParent();\n    }",
    "comment": " Gets the parent of the name node. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "Var.hashCode",
    "class_name": "com.google.javascript.jscomp.Scope$Var",
    "signature": "com.google.javascript.jscomp.Scope$Var.hashCode()",
    "snippet": "    @Override public int hashCode() {\n      return nameNode.hashCode();\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "Var.isLocal",
    "class_name": "com.google.javascript.jscomp.Scope$Var",
    "signature": "com.google.javascript.jscomp.Scope$Var.isLocal()",
    "snippet": "    public boolean isLocal() {\n      return scope.isLocal();\n    }",
    "comment": " Returns whether this is a local variable. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "SourceFile.SourceFile",
    "class_name": "com.google.javascript.jscomp.SourceFile",
    "signature": "com.google.javascript.jscomp.SourceFile.SourceFile(String)",
    "snippet": "  SourceFile(String fileName) {\n    this.fileName = fileName;\n    // Starting point: offset 0 is at line 1.\n    this.lastOffset = 0;\n    this.lastLine = 1;\n  }",
    "comment": " Construct a new abstract source file.  @param fileName The file name of the source file. It does not necessarily need to correspond to a real path. But it should be unique. Will appear in warning messages emitted by the compiler. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "SourceFile.fromCode",
    "class_name": "com.google.javascript.jscomp.SourceFile",
    "signature": "com.google.javascript.jscomp.SourceFile.fromCode(String,String)",
    "snippet": "  public static SourceFile fromCode(String fileName, String code) {\n    return new Preloaded(fileName, code);\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "SourceFile.getCode",
    "class_name": "com.google.javascript.jscomp.SourceFile",
    "signature": "com.google.javascript.jscomp.SourceFile.getCode()",
    "snippet": "  public String getCode() throws IOException {\n    return code;\n  }",
    "comment": " Gets all the code in this source file. @throws IOException ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "SourceFile.getName",
    "class_name": "com.google.javascript.jscomp.SourceFile",
    "signature": "com.google.javascript.jscomp.SourceFile.getName()",
    "snippet": "  public String getName() {\n    return fileName;\n  }",
    "comment": "Returns a unique name for the source file. */",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "SourceFile.setCode",
    "class_name": "com.google.javascript.jscomp.SourceFile",
    "signature": "com.google.javascript.jscomp.SourceFile.setCode(String)",
    "snippet": "  private void setCode(String sourceCode) {\n    code = sourceCode;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "SourceFile.setOriginalPath",
    "class_name": "com.google.javascript.jscomp.SourceFile",
    "signature": "com.google.javascript.jscomp.SourceFile.setOriginalPath(String)",
    "snippet": "  public void setOriginalPath(String originalPath) {\n    this.originalPath = originalPath;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "SyntacticScopeCreator.SyntacticScopeCreator",
    "class_name": "com.google.javascript.jscomp.SyntacticScopeCreator",
    "signature": "com.google.javascript.jscomp.SyntacticScopeCreator.SyntacticScopeCreator(AbstractCompiler)",
    "snippet": "  SyntacticScopeCreator(AbstractCompiler compiler) {\n    this.compiler = compiler;\n    this.redeclarationHandler = new DefaultRedeclarationHandler();\n  }",
    "comment": " Creates a ScopeCreator. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "SyntacticScopeCreator.SyntacticScopeCreator",
    "class_name": "com.google.javascript.jscomp.SyntacticScopeCreator",
    "signature": "com.google.javascript.jscomp.SyntacticScopeCreator.SyntacticScopeCreator(AbstractCompiler,RedeclarationHandler)",
    "snippet": "  SyntacticScopeCreator(\n      AbstractCompiler compiler, RedeclarationHandler redeclarationHandler) {\n    this.compiler = compiler;\n    this.redeclarationHandler = redeclarationHandler;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "SyntacticScopeCreator.createScope",
    "class_name": "com.google.javascript.jscomp.SyntacticScopeCreator",
    "signature": "com.google.javascript.jscomp.SyntacticScopeCreator.createScope(Node,Scope)",
    "snippet": "  public Scope createScope(Node n, Scope parent) {\n    sourceName = null;\n    if (parent == null) {\n      scope = new Scope(n, compiler);\n    } else {\n      scope = new Scope(parent, n);\n    }\n\n    scanRoot(n, parent);\n\n    sourceName = null;\n    Scope returnedScope = scope;\n    scope = null;\n    return returnedScope;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "SyntacticScopeCreator.declareVar",
    "class_name": "com.google.javascript.jscomp.SyntacticScopeCreator",
    "signature": "com.google.javascript.jscomp.SyntacticScopeCreator.declareVar(String,Node,Node,Node,JSType,Node)",
    "snippet": "  private void declareVar(String name, Node n, Node parent,\n                          Node gramps, JSType declaredType,\n                          Node nodeWithLineNumber) {\n    if (scope.isDeclared(name, false)\n        || (scope.isLocal() && name.equals(ARGUMENTS))) {\n      redeclarationHandler.onRedeclaration(\n          scope, name, n, parent, gramps, nodeWithLineNumber);\n    } else {\n      scope.declare(name, n, declaredType, compiler.getInput(sourceName));\n    }\n  }",
    "comment": " Declares a variable.  @param name The variable name @param n The node corresponding to the variable name (usually a NAME node) @param parent The parent node of {@code n} @param gramps The parent node of {@code parent} @param declaredType The variable's type, according to JSDoc @param nodeWithLineNumber The node to use to access the line number of the variable declaration, if needed ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "SyntacticScopeCreator.scanRoot",
    "class_name": "com.google.javascript.jscomp.SyntacticScopeCreator",
    "signature": "com.google.javascript.jscomp.SyntacticScopeCreator.scanRoot(Node,Scope)",
    "snippet": "  private void scanRoot(Node n, Scope parent) {\n    if (n.getType() == Token.FUNCTION) {\n      sourceName = (String) n.getProp(Node.SOURCENAME_PROP);\n\n      final Node fnNameNode = n.getFirstChild();\n      final Node args = fnNameNode.getNext();\n      final Node body = args.getNext();\n\n      // Bleed the function name into the scope, if it hasn't\n      // been declared in the outer scope.\n      String fnName = fnNameNode.getString();\n      if (!fnName.isEmpty() && NodeUtil.isFunctionAnonymous(n)) {\n        declareVar(fnName, fnNameNode, n, null, null, n);\n      }\n\n      // Args: Declare function variables\n      Preconditions.checkState(args.getType() == Token.LP);\n      for (Node a = args.getFirstChild(); a != null;\n           a = a.getNext()) {\n        Preconditions.checkState(a.getType() == Token.NAME);\n        declareVar(a.getString(), a, args, n, null, n);\n      }\n\n      // Body\n      scanVars(body, n);\n    } else {\n      // It's the global block\n      Preconditions.checkState(scope.getParent() == null);\n      scanVars(n, null);\n    }\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "SyntacticScopeCreator.scanVars",
    "class_name": "com.google.javascript.jscomp.SyntacticScopeCreator",
    "signature": "com.google.javascript.jscomp.SyntacticScopeCreator.scanVars(Node,Node)",
    "snippet": "  private void scanVars(Node n, Node parent) {\n    switch (n.getType()) {\n      case Token.VAR:\n        // Declare all variables. e.g. var x = 1, y, z;\n        for (Node child = n.getFirstChild();\n             child != null;) {\n          Node next = child.getNext();\n          Preconditions.checkState(child.getType() == Token.NAME);\n\n          String name = child.getString();\n          declareVar(name, child, n, parent, null, n);\n          child = next;\n        }\n        return;\n\n      case Token.FUNCTION:\n        if (NodeUtil.isFunctionAnonymous(n)) {\n          return;\n        }\n\n        String fnName = n.getFirstChild().getString();\n        if (fnName.isEmpty()) {\n          // This is invalid, but allow it so the checks can catch it.\n          return;\n        }\n        declareVar(fnName, n.getFirstChild(), n, parent, null, n);\n        return;   // should not examine function's children\n\n      case Token.CATCH:\n        Preconditions.checkState(n.getChildCount() == 3);\n        Preconditions.checkState(n.getFirstChild().getType() == Token.NAME);\n        // the first child is the catch var and the third child\n        // is the code block\n\n        final Node var = n.getFirstChild();\n        final Node block = var.getNext().getNext();\n\n        declareVar(var.getString(), var, n, parent, null, n);\n        scanVars(block, n);\n        return;  // only one child to scan\n\n      case Token.SCRIPT:\n        sourceName = (String) n.getProp(Node.SOURCENAME_PROP);\n        break;\n    }\n\n    // Variables can only occur in statement-level nodes, so\n    // we only need to traverse children in a couple special cases.\n    if (NodeUtil.isControlStructure(n) || NodeUtil.isStatementBlock(n)) {\n      for (Node child = n.getFirstChild();\n           child != null;) {\n        Node next = child.getNext();\n        scanVars(child, n);\n        child = next;\n      }\n    }\n  }",
    "comment": " Scans and gather variables declarations under a Node ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "Tracer.Tracer",
    "class_name": "com.google.javascript.jscomp.Tracer",
    "signature": "com.google.javascript.jscomp.Tracer.Tracer(String,String)",
    "snippet": "  Tracer(@Nullable String type, @Nullable String comment) {\n    this.type = type;\n    this.comment = comment == null ? \"\" : comment;\n    startTimeMs = clock.currentTimeMillis();\n    startThread = Thread.currentThread();\n    if (!extraTracingStatistics.isEmpty()) {\n      int size = extraTracingStatistics.size();\n      extraTracingValues = new long[size];\n      int i = 0;\n      for (TracingStatistic tracingStatistic : extraTracingStatistics) {\n        extraTracingValues[i] = tracingStatistic.start(startThread);\n        i++;\n      }\n    }\n\n    ThreadTrace trace = getThreadTrace();\n\n    // Do nothing if the current thread trace wasn't initialized.\n    if (!trace.isInitialized()) {\n      return;\n    }\n\n    // Check if we are creating too many Tracers.\n    if (trace.events.size() >= MAX_TRACE_SIZE) {\n      logger.log(Level.WARNING,\n                  \"Giant thread trace. Too many Tracers created. \"\n                    + \"Clearing to avoid memory leak.\",\n                  new Throwable(trace.toString()));\n      trace.truncateEvents();\n    }\n\n    // Check if we forgot to close the Tracers.\n    if (trace.outstandingEvents.size() >= MAX_TRACE_SIZE) {\n      logger.log(Level.WARNING,\n                  \"Too many outstanding Tracers. Tracer.stop() is missing \"\n                    + \"or Tracer.stop() is not wrapped in a \"\n                    + \"try/finally block. \"\n                    + \"Clearing to avoid memory leak.\",\n                  new Throwable(trace.toString()));\n      trace.truncateOutstandingEvents();\n    }\n\n    trace.startEvent(this);\n  }",
    "comment": " Create and start a tracer. Both type and comment may be null. See class comment for usage.  @param type The type for totalling @param comment Comment about this tracer ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "Tracer.getThreadTrace",
    "class_name": "com.google.javascript.jscomp.Tracer",
    "signature": "com.google.javascript.jscomp.Tracer.getThreadTrace()",
    "snippet": "  static ThreadTrace getThreadTrace() {\n    ThreadTrace t = traces.get();\n    if (t == null) {\n      t = new ThreadTrace();\n      t.prettyPrint = defaultPrettyPrint;\n      traces.set(t);\n    }\n    return t;\n  }",
    "comment": " Get the ThreadTrace for the current thread, creating one if necessary. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "Tracer.stop",
    "class_name": "com.google.javascript.jscomp.Tracer",
    "signature": "com.google.javascript.jscomp.Tracer.stop()",
    "snippet": "  long stop() {\n    return stop(-1);\n  }",
    "comment": "Stop the trace using the default silence_threshold  @return  The time that this trace actually ran. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "Tracer.stop",
    "class_name": "com.google.javascript.jscomp.Tracer",
    "signature": "com.google.javascript.jscomp.Tracer.stop(int)",
    "snippet": "  long stop(int silence_threshold) {\n    Preconditions.checkState(Thread.currentThread() == startThread);\n\n    ThreadTrace trace = getThreadTrace();\n    // Do nothing if the thread trace was not initialized.\n    if (!trace.isInitialized()) {\n      return 0;\n    }\n\n    stopTimeMs = clock.currentTimeMillis();\n    if (extraTracingValues != null) {\n      // We use extraTracingValues.length rather than extraTracingStatistics.size() because\n      // a new statistic may have been added\n      for (int i = 0; i < extraTracingValues.length; i++) {\n        long value = extraTracingStatistics.get(i).stop(startThread);\n        extraTracingValues[i] = value - extraTracingValues[i];\n      }\n    }\n\n    // Do nothing if the thread trace was not initialized.\n    if (!trace.isInitialized()) {\n      return 0;\n    }\n\n    trace.endEvent(this, silence_threshold);\n    return stopTimeMs - startTimeMs;\n  }",
    "comment": " Stop the trace. This may only be done once and must be done from the same thread that started it. @param silence_threshold Traces for time less than silence_threshold ms will be left out of the trace report. A value of -1 indicates that the current ThreadTrace silence_threshold should be used. @return The time that this trace actually ran ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "ThreadTrace.isInitialized",
    "class_name": "com.google.javascript.jscomp.Tracer$ThreadTrace",
    "signature": "com.google.javascript.jscomp.Tracer$ThreadTrace.isInitialized()",
    "snippet": "    boolean isInitialized() {\n      return isInitialized;\n    }",
    "comment": "Is initialized? */",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "TypeValidator.TypeValidator",
    "class_name": "com.google.javascript.jscomp.TypeValidator",
    "signature": "com.google.javascript.jscomp.TypeValidator.TypeValidator(AbstractCompiler)",
    "snippet": "  TypeValidator(AbstractCompiler compiler) {\n    this.compiler = compiler;\n    this.typeRegistry = compiler.getTypeRegistry();\n    this.allValueTypes = typeRegistry.createUnionType(\n        STRING_TYPE, NUMBER_TYPE, BOOLEAN_TYPE, NULL_TYPE, VOID_TYPE);\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "UnreachableCodeElimination.UnreachableCodeElimination",
    "class_name": "com.google.javascript.jscomp.UnreachableCodeElimination",
    "signature": "com.google.javascript.jscomp.UnreachableCodeElimination.UnreachableCodeElimination(AbstractCompiler,boolean)",
    "snippet": "  UnreachableCodeElimination(AbstractCompiler compiler,\n      boolean removeNoOpStatements) {\n    this.compiler = compiler;\n    this.removeNoOpStatements = removeNoOpStatements;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "UnreachableCodeElimination.enterScope",
    "class_name": "com.google.javascript.jscomp.UnreachableCodeElimination",
    "signature": "com.google.javascript.jscomp.UnreachableCodeElimination.enterScope(NodeTraversal)",
    "snippet": "  @Override\n  public void enterScope(NodeTraversal t) {\n    Scope scope = t.getScope();\n\n    // Computes the control flow graph.\n    ControlFlowAnalysis cfa = new ControlFlowAnalysis(compiler, false);\n    cfa.process(null, scope.getRootNode());\n    cfgStack.push(curCfg);\n    curCfg = cfa.getCfg();\n\n    new GraphReachability<Node, ControlFlowGraph.Branch>(curCfg)\n        .compute(curCfg.getEntry().getValue());\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "UnreachableCodeElimination.exitScope",
    "class_name": "com.google.javascript.jscomp.UnreachableCodeElimination",
    "signature": "com.google.javascript.jscomp.UnreachableCodeElimination.exitScope(NodeTraversal)",
    "snippet": "  @Override\n  public void exitScope(NodeTraversal t) {\n    curCfg = cfgStack.pop();\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "UnreachableCodeElimination.process",
    "class_name": "com.google.javascript.jscomp.UnreachableCodeElimination",
    "signature": "com.google.javascript.jscomp.UnreachableCodeElimination.process(Node,Node)",
    "snippet": "  @Override\n  public void process(Node externs, Node root) {\n    NodeTraversal.traverse(compiler, root, this);\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "UnreachableCodeElimination.visit",
    "class_name": "com.google.javascript.jscomp.UnreachableCodeElimination",
    "signature": "com.google.javascript.jscomp.UnreachableCodeElimination.visit(NodeTraversal,Node,Node)",
    "snippet": "  @Override\n  public void visit(NodeTraversal t, Node n, Node parent) {\n    if (parent == null) {\n      return;\n    }\n    if (n.getType() == Token.FUNCTION || n.getType() == Token.SCRIPT) {\n      return;\n    }\n    // Removes TRYs that had its CATCH removed and/or empty FINALLY.\n    if (n.getType() == Token.TRY) {\n      Node body = n.getFirstChild();\n      Node catchOrFinallyBlock = body.getNext();\n      Node finallyBlock = catchOrFinallyBlock.getNext();\n\n      if (!catchOrFinallyBlock.hasChildren() &&\n          (finallyBlock == null || !finallyBlock.hasChildren())) {\n        n.removeChild(body);\n        parent.replaceChild(n, body);\n        compiler.reportCodeChange();\n        n = body;\n      }\n    }\n    GraphNode<Node, Branch> gNode = curCfg.getNode(n);\n    if (gNode == null) { // Not in CFG.\n      return;\n    }\n    if (gNode.getAnnotation() != GraphReachability.REACHABLE ||\n        (removeNoOpStatements && !NodeUtil.mayHaveSideEffects(n))) {\n      removeDeadExprStatementSafely(n, parent);\n    }\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "VarCheck.VarCheck",
    "class_name": "com.google.javascript.jscomp.VarCheck",
    "signature": "com.google.javascript.jscomp.VarCheck.VarCheck(AbstractCompiler)",
    "snippet": "  VarCheck(AbstractCompiler compiler) {\n    this(compiler, false);\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "VarCheck.VarCheck",
    "class_name": "com.google.javascript.jscomp.VarCheck",
    "signature": "com.google.javascript.jscomp.VarCheck.VarCheck(AbstractCompiler,boolean)",
    "snippet": "  VarCheck(AbstractCompiler compiler, boolean sanityCheck) {\n    this.compiler = compiler;\n    this.sanityCheck = sanityCheck;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "VarCheck.process",
    "class_name": "com.google.javascript.jscomp.VarCheck",
    "signature": "com.google.javascript.jscomp.VarCheck.process(Node,Node)",
    "snippet": "  public void process(Node externs, Node root) {\n    NodeTraversal.traverse(compiler, externs, new NameRefInExternsCheck());\n    NodeTraversal.traverseRoots(\n        compiler, Lists.newArrayList(externs, root), this);\n  }",
    "comment": "{@inheritDoc} */",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "VarCheck.visit",
    "class_name": "com.google.javascript.jscomp.VarCheck",
    "signature": "com.google.javascript.jscomp.VarCheck.visit(NodeTraversal,Node,Node)",
    "snippet": "  public void visit(NodeTraversal t, Node n, Node parent) {\n    if (n.getType() != Token.NAME) {\n      return;\n    }\n\n    if (NodeUtil.isLabelName(n)) {\n      return;\n    }\n\n    String varName = n.getString();\n\n    // Only a function can have an empty name.\n    if (varName.isEmpty()) {\n      Preconditions.checkState(NodeUtil.isFunction(parent));\n\n      // A function declaration with an empty name passes Rhino,\n      // but is supposed to be a syntax error according to the spec.\n      if (!NodeUtil.isAnonymousFunction(parent)) {\n        t.report(n, INVALID_FUNCTION_DECL);\n      }\n      return;\n    }\n\n    // Check that the var has been declared.\n    Scope scope = t.getScope();\n    Scope.Var var = scope.getVar(varName);\n    if (var == null) {\n      if (NodeUtil.isAnonymousFunction(parent)) {\n        // e.g. [ function foo() {} ], it's okay if \"foo\" isn't defined in the\n        // current scope.\n      } else {\n        t.report(n, UNDEFINED_VAR_ERROR, varName);\n\n        if (sanityCheck) {\n          throw new IllegalStateException(\"Unexpected variable \" + varName);\n        } else {\n          // Create a new variable in a synthetic script. This will prevent\n          // subsequent compiler passes from crashing.\n          Node nameNode = Node.newString(Token.NAME, varName);\n          getSynthesizedExternsRoot().addChildToBack(\n              new Node(Token.VAR, nameNode));\n          scope.getGlobalScope().declare(varName, nameNode,\n              null, getSynthesizedExternsInput());\n        }\n      }\n      return;\n    }\n\n    CompilerInput currInput = t.getInput();\n    CompilerInput varInput = var.input;\n    if (currInput == varInput || currInput == null || varInput == null) {\n      // The variable was defined in the same file. This is fine.\n      return;\n    }\n\n    // Check module dependencies.\n    JSModule currModule = currInput.getModule();\n    JSModule varModule = varInput.getModule();\n    JSModuleGraph moduleGraph = compiler.getModuleGraph();\n    if (varModule != currModule && varModule != null && currModule != null) {\n      if (moduleGraph.dependsOn(currModule, varModule)) {\n        // The module dependency was properly declared.\n      } else {\n        if (!sanityCheck && scope.isGlobal()) {\n          if (moduleGraph.dependsOn(varModule, currModule)) {\n            // The variable reference violates a declared module dependency.\n            t.report(n, VIOLATED_MODULE_DEP_ERROR,\n                     currModule.getName(), varModule.getName(), varName);\n          } else {\n            // The variable reference is between two modules that have no\n            // dependency relationship. This should probably be considered an\n            // error, but just issue a warning for now.\n            t.report(n, MISSING_MODULE_DEP_ERROR,\n                     currModule.getName(), varModule.getName(), varName);\n          }\n        } else {\n          t.report(n, STRICT_MODULE_DEP_ERROR,\n                   currModule.getName(), varModule.getName(), varName);\n        }\n      }\n    }\n  }",
    "comment": "{@inheritDoc} */",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "NameRefInExternsCheck.visit",
    "class_name": "com.google.javascript.jscomp.VarCheck$NameRefInExternsCheck",
    "signature": "com.google.javascript.jscomp.VarCheck$NameRefInExternsCheck.visit(NodeTraversal,Node,Node)",
    "snippet": "    public void visit(NodeTraversal t, Node n, Node parent) {\n      if (n.getType() == Token.NAME) {\n        switch (parent.getType()) {\n          case Token.VAR:\n          case Token.FUNCTION:\n          case Token.GETPROP:\n          case Token.LP:\n            // These are okay.\n            break;\n          default:\n            t.report(n, NAME_REFERENCE_IN_EXTERNS_ERROR, n.getString());\n            break;\n        }\n      }\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "VariableMap.VariableMap",
    "class_name": "com.google.javascript.jscomp.VariableMap",
    "signature": "com.google.javascript.jscomp.VariableMap.VariableMap(Map)",
    "snippet": "  VariableMap(Map<String, String> map) {\n    this.map = Collections.unmodifiableMap(map);\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "VariableNameGenerator.VariableNameGenerator",
    "class_name": "com.google.javascript.jscomp.VariableNameGenerator",
    "signature": "com.google.javascript.jscomp.VariableNameGenerator.VariableNameGenerator(Scope)",
    "snippet": "  VariableNameGenerator(Scope scope) {\n    Set<String> usedNames = Sets.newHashSet();\n    for (Iterator<Var> i = scope.getVars(); i.hasNext();) {\n      usedNames.add(i.next().getName());\n    }\n    names = new NameGenerator(usedNames, \"\", null);\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "VariableNameGenerator.getNameNewName",
    "class_name": "com.google.javascript.jscomp.VariableNameGenerator",
    "signature": "com.google.javascript.jscomp.VariableNameGenerator.getNameNewName()",
    "snippet": "  String getNameNewName() {\n    return names.generateNextName();\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "WarningLevel.addDefaultWarnings",
    "class_name": "com.google.javascript.jscomp.WarningLevel",
    "signature": "com.google.javascript.jscomp.WarningLevel.addDefaultWarnings(CompilerOptions)",
    "snippet": "  private static void addDefaultWarnings(CompilerOptions options) {\n    options.checkSuspiciousCode = true;\n    // TODO(user): This is deprecated. We should turn on the\n    // new one once it is default in command line JSCompiler.\n    options.checkUndefinedProperties = CheckLevel.OFF;\n    options.checkUnusedPropertiesEarly = false;\n    options.checkUnreachableCode = CheckLevel.WARNING;\n    options.checkControlStructures = true;\n  }",
    "comment": " Add the default checking pass to the compilation options. @param options The CompilerOptions object to set the options on. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "WarningLevel.setOptionsForWarningLevel",
    "class_name": "com.google.javascript.jscomp.WarningLevel",
    "signature": "com.google.javascript.jscomp.WarningLevel.setOptionsForWarningLevel(CompilerOptions)",
    "snippet": "  public void setOptionsForWarningLevel(CompilerOptions options) {\n    switch (this) {\n      case QUIET:\n        silenceAllWarnings(options);\n        break;\n      case DEFAULT:\n        addDefaultWarnings(options);\n        break;\n      case VERBOSE:\n        addVerboseWarnings(options);\n        break;\n      default:\n        throw new RuntimeException(\"Unknown warning level.\");\n    }\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "WarningsGuard.getPriority",
    "class_name": "com.google.javascript.jscomp.WarningsGuard",
    "signature": "com.google.javascript.jscomp.WarningsGuard.getPriority()",
    "snippet": "  protected int getPriority() {\n    return 50;\n  }",
    "comment": " The priority in which warnings guards are applied. Lower means the guard will be applied sooner. Expressed on a scale of 1 to 100. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "FixedPointGraphTraversal.FixedPointGraphTraversal",
    "class_name": "com.google.javascript.jscomp.graph.FixedPointGraphTraversal",
    "signature": "com.google.javascript.jscomp.graph.FixedPointGraphTraversal.FixedPointGraphTraversal(EdgeCallback)",
    "snippet": "  public FixedPointGraphTraversal(EdgeCallback<N, E> callback) {\n    this.callback = callback;\n  }",
    "comment": " Create a new traversal. @param callback A callback for updating the state of the graph each time an edge is traversed. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "FixedPointGraphTraversal.computeFixedPoint",
    "class_name": "com.google.javascript.jscomp.graph.FixedPointGraphTraversal",
    "signature": "com.google.javascript.jscomp.graph.FixedPointGraphTraversal.computeFixedPoint(DiGraph,N)",
    "snippet": "  public void computeFixedPoint(DiGraph<N, E> graph, N entry) {\n    Set<N> entrySet = Sets.newHashSet();\n    entrySet.add(entry);\n    computeFixedPoint(graph, entrySet);\n  }",
    "comment": " Compute a fixed point for the given graph, entering from the given node. @param graph The graph to traverse. @param entry The node to begin traversing from. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "FixedPointGraphTraversal.computeFixedPoint",
    "class_name": "com.google.javascript.jscomp.graph.FixedPointGraphTraversal",
    "signature": "com.google.javascript.jscomp.graph.FixedPointGraphTraversal.computeFixedPoint(DiGraph,Set)",
    "snippet": "  public void computeFixedPoint(DiGraph<N, E> graph, Set<N> entrySet) {\n    int cycleCount = 0;\n    long nodeCount = graph.getNodes().size();\n\n    // Choose a bail-out heuristically in case the computation\n    // doesn't converge.\n    long maxIterations = Math.max(nodeCount * nodeCount * nodeCount, 100);\n\n    // Use a LinkedHashSet, so that the traversal is deterministic.\n    LinkedHashSet<DiGraphNode<N, E>> workSet =\n        Sets.newLinkedHashSet();\n    for (N n : entrySet) {\n      workSet.add(graph.getDirectedGraphNode(n));\n    }\n    for (; !workSet.isEmpty() && cycleCount < maxIterations; cycleCount++) {\n      // For every out edge in the workSet, traverse that edge. If that\n      // edge updates the state of the graph, then add the destination\n      // node to the resultSet, so that we can update all of its out edges\n      // on the next iteration.\n      DiGraphNode<N, E> source = workSet.iterator().next();\n      N sourceValue = source.getValue();\n\n      workSet.remove(source);\n\n      List<DiGraphEdge<N, E>> outEdges = source.getOutEdges();\n      for (DiGraphEdge<N, E> edge : outEdges) {\n        N destNode = edge.getDestination().getValue();\n        if (callback.traverseEdge(sourceValue, edge.getValue(), destNode)) {\n          workSet.add(edge.getDestination());\n        }\n      }\n    }\n\n    Preconditions.checkState(cycleCount != maxIterations,\n        NON_HALTING_ERROR_MSG);\n  }",
    "comment": " Compute a fixed point for the given graph, entering from the given nodes. @param graph The graph to traverse. @param entrySet The nodes to begin traversing from. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "FixedPointGraphTraversal.newTraversal",
    "class_name": "com.google.javascript.jscomp.graph.FixedPointGraphTraversal",
    "signature": "com.google.javascript.jscomp.graph.FixedPointGraphTraversal.newTraversal(EdgeCallback)",
    "snippet": "  public static <NODE, EDGE> FixedPointGraphTraversal<NODE, EDGE> newTraversal(\n      EdgeCallback<NODE, EDGE> callback) {\n    return new FixedPointGraphTraversal<NODE, EDGE>(callback);\n  }",
    "comment": " Helper method for creating new traversals. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "Graph.clearNodeAnnotations",
    "class_name": "com.google.javascript.jscomp.graph.Graph",
    "signature": "com.google.javascript.jscomp.graph.Graph.clearNodeAnnotations()",
    "snippet": "  public final void clearNodeAnnotations() {\n    for (GraphNode<N, E> n : getNodes()) {\n      n.setAnnotation(null);\n    }\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "Graph.connectIfNotFound",
    "class_name": "com.google.javascript.jscomp.graph.Graph",
    "signature": "com.google.javascript.jscomp.graph.Graph.connectIfNotFound(N,E,N)",
    "snippet": "  public final void connectIfNotFound(N n1, E edge, N n2) {\n    GraphNode<N, E> node1 = getNode(n1);\n    GraphNode<N, E> node2 = getNode(n2);\n    if (node1 == null) {\n      throw new IllegalArgumentException(n1 + \" does not exist in graph\");\n    }\n    if (node2 == null) {\n      throw new IllegalArgumentException(n2 + \" does not exist in graph\");\n    }\n    List<GraphEdge<N, E>> edgeList = getEdges(n1, n2);\n    for (GraphEdge<N, E> e : edgeList) {\n      // Check == first to short circuit nulls.\n      if (e.getValue() == edge || e.getValue().equals(edge)) {\n        return;\n      }\n    }\n    connect(n1, edge, n2);\n  }",
    "comment": " Connects two nodes in the graph with an edge if such edge does not already exists between the nodes.  @param n1 First node. @param edge The edge. @param n2 Second node. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "GraphReachability.GraphReachability",
    "class_name": "com.google.javascript.jscomp.graph.GraphReachability",
    "signature": "com.google.javascript.jscomp.graph.GraphReachability.GraphReachability(DiGraph)",
    "snippet": "  public GraphReachability(DiGraph<N, E> graph) {\n    this.graph = graph;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "GraphReachability.compute",
    "class_name": "com.google.javascript.jscomp.graph.GraphReachability",
    "signature": "com.google.javascript.jscomp.graph.GraphReachability.compute(N)",
    "snippet": "  public void compute(N entry) {\n    graph.clearNodeAnnotations();\n    graph.getNode(entry).setAnnotation(REACHABLE);\n    FixedPointGraphTraversal.newTraversal(this)\n        .computeFixedPoint(graph, entry);\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "GraphReachability.traverseEdge",
    "class_name": "com.google.javascript.jscomp.graph.GraphReachability",
    "signature": "com.google.javascript.jscomp.graph.GraphReachability.traverseEdge(N,E,N)",
    "snippet": "  @Override\n  public boolean traverseEdge(N source, E e, N destination) {\n    if (graph.getNode(source).getAnnotation() == REACHABLE) {\n      GraphNode<N, E> destNode = graph.getNode(destination);\n      if (destNode.getAnnotation() != REACHABLE) {\n        destNode.setAnnotation(REACHABLE);\n        return true;\n      }\n    }\n    return false;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "LinkedDirectedGraph.connect",
    "class_name": "com.google.javascript.jscomp.graph.LinkedDirectedGraph",
    "signature": "com.google.javascript.jscomp.graph.LinkedDirectedGraph.connect(N,E,N)",
    "snippet": "  @Override\n  public GraphEdge<N, E> connect(N srcValue, E edgeValue, N destValue) {\n    DiGraphNode<N, E> node = getDirectedGraphNode(srcValue);\n    if (node == null) {\n      throw new IllegalArgumentException(\n          srcValue + \" does not exist in graph\");\n    }\n    LinkedDirectedGraphNode<N, E> src = (LinkedDirectedGraphNode<N, E>) node;\n    node = getDirectedGraphNode(destValue);\n    if (node == null) {\n      throw new IllegalArgumentException(\n          destValue + \" does not exist in graph\");\n    }\n    LinkedDirectedGraphNode<N, E> dest = (LinkedDirectedGraphNode<N, E>) node;\n    LinkedDirectedGraphEdge<N, E> edge =\n        new LinkedDirectedGraphEdge<N, E>(src, edgeValue, dest);\n    src.getOutEdges().add(edge);\n    dest.getInEdges().add(edge);\n    return edge;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "LinkedDirectedGraph.createDirectedGraphNode",
    "class_name": "com.google.javascript.jscomp.graph.LinkedDirectedGraph",
    "signature": "com.google.javascript.jscomp.graph.LinkedDirectedGraph.createDirectedGraphNode(N)",
    "snippet": "  @Override\n  public DiGraphNode<N, E> createDirectedGraphNode(N nodeValue) {\n    LinkedDirectedGraphNode<N, E> node = nodes.get(nodeValue);\n    if (node == null) {\n      node = new LinkedDirectedGraphNode<N, E>(nodeValue);\n      nodes.put(nodeValue, node);\n    }\n    return node;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "LinkedDirectedGraph.createNode",
    "class_name": "com.google.javascript.jscomp.graph.LinkedDirectedGraph",
    "signature": "com.google.javascript.jscomp.graph.LinkedDirectedGraph.createNode(N)",
    "snippet": "  @Override\n  public GraphNode<N, E> createNode(N value) {\n    return createDirectedGraphNode(value);\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "LinkedDirectedGraph.getDirectedGraphEdges",
    "class_name": "com.google.javascript.jscomp.graph.LinkedDirectedGraph",
    "signature": "com.google.javascript.jscomp.graph.LinkedDirectedGraph.getDirectedGraphEdges(N,N)",
    "snippet": "  @Override\n  public List<DiGraphEdge<N, E>> getDirectedGraphEdges(N n1, N n2) {\n    DiGraphNode<N, E> dNode1 = nodes.get(n1);\n    if (dNode1 == null) {\n      throw new IllegalArgumentException(n1 + \" does not exist in graph\");\n    }\n    DiGraphNode<N, E> dNode2 = nodes.get(n2);\n    if (dNode2 == null) {\n      throw new IllegalArgumentException(n1 + \" does not exist in graph\");\n    }\n    List<DiGraphEdge<N, E>> edges = Lists.newArrayList();\n    for (DiGraphEdge<N, E> outEdge : dNode1.getOutEdges()) {\n      if (outEdge.getDestination() == dNode2) {\n        edges.add(outEdge);\n      }\n    }\n    return edges;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "LinkedDirectedGraph.getDirectedGraphNode",
    "class_name": "com.google.javascript.jscomp.graph.LinkedDirectedGraph",
    "signature": "com.google.javascript.jscomp.graph.LinkedDirectedGraph.getDirectedGraphNode(N)",
    "snippet": "  @Override\n  public DiGraphNode<N, E> getDirectedGraphNode(N nodeValue) {\n    return nodes.get(nodeValue);\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "LinkedDirectedGraph.getDirectedGraphNodes",
    "class_name": "com.google.javascript.jscomp.graph.LinkedDirectedGraph",
    "signature": "com.google.javascript.jscomp.graph.LinkedDirectedGraph.getDirectedGraphNodes()",
    "snippet": "  @Override\n  public List<DiGraphNode<N, E>> getDirectedGraphNodes() {\n    List<DiGraphNode<N, E>> nodeList = Lists.newArrayList();\n    nodeList.addAll(nodes.values());\n    return nodeList;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "LinkedDirectedGraph.getDirectedSuccNodes",
    "class_name": "com.google.javascript.jscomp.graph.LinkedDirectedGraph",
    "signature": "com.google.javascript.jscomp.graph.LinkedDirectedGraph.getDirectedSuccNodes(DiGraphNode)",
    "snippet": "  @Override\n  public List<DiGraphNode<N, E>> getDirectedSuccNodes(\n      DiGraphNode<N, E> dNode) {\n    if (dNode == null) {\n      throw new IllegalArgumentException(dNode + \" is null\");\n    }\n    List<DiGraphNode<N, E>> nodeList = Lists.newArrayList();\n    for (DiGraphEdge<N, E> edge : dNode.getOutEdges()) {\n      nodeList.add(edge.getDestination());\n    }\n    return nodeList;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "LinkedDirectedGraph.getEdges",
    "class_name": "com.google.javascript.jscomp.graph.LinkedDirectedGraph",
    "signature": "com.google.javascript.jscomp.graph.LinkedDirectedGraph.getEdges(N,N)",
    "snippet": "  @Override\n  public List<GraphEdge<N, E>> getEdges(N n1, N n2) {\n    // Since this is a method from a generic graph, edges from both\n    // directions must be added to the returning list.\n    List<DiGraphEdge<N, E>> forwardEdges = getDirectedGraphEdges(n1, n2);\n    List<DiGraphEdge<N, E>> backwardEdges = getDirectedGraphEdges(n2, n1);\n    int totalSize = forwardEdges.size() + backwardEdges.size();\n    List<GraphEdge<N, E>> edges = Lists.newArrayListWithCapacity(totalSize);\n    edges.addAll(forwardEdges);\n    edges.addAll(backwardEdges);\n    return edges;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "LinkedDirectedGraph.getNode",
    "class_name": "com.google.javascript.jscomp.graph.LinkedDirectedGraph",
    "signature": "com.google.javascript.jscomp.graph.LinkedDirectedGraph.getNode(N)",
    "snippet": "  @Override\n  public GraphNode<N, E> getNode(N nodeValue) {\n    return getDirectedGraphNode(nodeValue);\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "LinkedDirectedGraph.getNodes",
    "class_name": "com.google.javascript.jscomp.graph.LinkedDirectedGraph",
    "signature": "com.google.javascript.jscomp.graph.LinkedDirectedGraph.getNodes()",
    "snippet": "  @Override\n  public List<GraphNode<N, E>> getNodes() {\n    List<GraphNode<N, E>> list = Lists.newArrayList();\n    list.addAll(nodes.values());\n    return list;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "LinkedDirectedGraphEdge.getDestination",
    "class_name": "com.google.javascript.jscomp.graph.LinkedDirectedGraph$LinkedDirectedGraphEdge",
    "signature": "com.google.javascript.jscomp.graph.LinkedDirectedGraph$LinkedDirectedGraphEdge.getDestination()",
    "snippet": "    @Override\n    public DiGraphNode<N, E> getDestination() {\n      return destNode;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "LinkedDirectedGraphEdge.getValue",
    "class_name": "com.google.javascript.jscomp.graph.LinkedDirectedGraph$LinkedDirectedGraphEdge",
    "signature": "com.google.javascript.jscomp.graph.LinkedDirectedGraph$LinkedDirectedGraphEdge.getValue()",
    "snippet": "    @Override\n    public E getValue() {\n      return value;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "LinkedDirectedGraphNode.getAnnotation",
    "class_name": "com.google.javascript.jscomp.graph.LinkedDirectedGraph$LinkedDirectedGraphNode",
    "signature": "com.google.javascript.jscomp.graph.LinkedDirectedGraph$LinkedDirectedGraphNode.getAnnotation()",
    "snippet": "    @SuppressWarnings(\"unchecked\")\n    @Override\n    public <A extends Annotation> A getAnnotation() {\n      return (A) annotation;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "LinkedDirectedGraphNode.getInEdges",
    "class_name": "com.google.javascript.jscomp.graph.LinkedDirectedGraph$LinkedDirectedGraphNode",
    "signature": "com.google.javascript.jscomp.graph.LinkedDirectedGraph$LinkedDirectedGraphNode.getInEdges()",
    "snippet": "    @Override\n    public List<DiGraphEdge<N, E>> getInEdges() {\n      return inEdgeList;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "LinkedDirectedGraphNode.getOutEdges",
    "class_name": "com.google.javascript.jscomp.graph.LinkedDirectedGraph$LinkedDirectedGraphNode",
    "signature": "com.google.javascript.jscomp.graph.LinkedDirectedGraph$LinkedDirectedGraphNode.getOutEdges()",
    "snippet": "    @Override\n    public List<DiGraphEdge<N, E>> getOutEdges() {\n      return outEdgeList;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "LinkedDirectedGraphNode.getValue",
    "class_name": "com.google.javascript.jscomp.graph.LinkedDirectedGraph$LinkedDirectedGraphNode",
    "signature": "com.google.javascript.jscomp.graph.LinkedDirectedGraph$LinkedDirectedGraphNode.getValue()",
    "snippet": "    @Override\n    public N getValue() {\n      return value;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "LinkedDirectedGraphNode.setAnnotation",
    "class_name": "com.google.javascript.jscomp.graph.LinkedDirectedGraph$LinkedDirectedGraphNode",
    "signature": "com.google.javascript.jscomp.graph.LinkedDirectedGraph$LinkedDirectedGraphNode.setAnnotation(Annotation)",
    "snippet": "    @Override\n    public void setAnnotation(Annotation data) {\n      annotation = data;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "Config.Config",
    "class_name": "com.google.javascript.jscomp.parsing.Config",
    "signature": "com.google.javascript.jscomp.parsing.Config.Config(JSTypeRegistry,Set,boolean)",
    "snippet": "  Config(JSTypeRegistry registry, Set<String> annotationWhitelist,\n      boolean isIdeMode) {\n    this.registry = registry;\n    this.annotationNames = buildAnnotationNames(annotationWhitelist);\n    this.parseJsDocDocumentation = isIdeMode;\n    this.isIdeMode = isIdeMode;\n  }",
    "comment": " Annotation names. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "Config.buildAnnotationNames",
    "class_name": "com.google.javascript.jscomp.parsing.Config",
    "signature": "com.google.javascript.jscomp.parsing.Config.buildAnnotationNames(Set)",
    "snippet": "  private static Map<String, Annotation> buildAnnotationNames(\n      Set<String> annotationWhitelist) {\n    ImmutableMap.Builder<String, Annotation> annotationBuilder =\n        ImmutableMap.builder();\n    annotationBuilder.putAll(Annotation.recognizedAnnotations);\n    for (String unrecognizedAnnotation : annotationWhitelist) {\n      if (!Annotation.recognizedAnnotations.containsKey(\n              unrecognizedAnnotation)) {\n        annotationBuilder.put(\n            unrecognizedAnnotation, Annotation.NOT_IMPLEMENTED);\n      }\n    }\n    return annotationBuilder.build();\n  }",
    "comment": " Create the annotation names from the user-specified annotation whitelist. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "IRFactory.attachJsDoc",
    "class_name": "com.google.javascript.jscomp.parsing.IRFactory",
    "signature": "com.google.javascript.jscomp.parsing.IRFactory.attachJsDoc(Comment,JSDocInfo)",
    "snippet": "  private void attachJsDoc(Comment comment, JSDocInfo info) {\n    Collection<NodeWithJsDoc> candidates =\n        nodesWithJsDoc.get(comment.getValue());\n    if (candidates.isEmpty()) {\n      return;\n    }\n\n    Iterator<NodeWithJsDoc> candidateIter = candidates.iterator();\n    Node node = candidateIter.next().node;\n    candidateIter.remove();\n    node.setJSDocInfo(info);\n    if (info.hasEnumParameterType()) {\n      if (node.getType() == Token.NAME) {\n        registry.identifyEnumName(node.getString());\n      } else if (node.getType() == Token.VAR &&\n            node.getChildCount() == 1) {\n        registry.identifyEnumName(\n            node.getFirstChild().getString());\n      } else if (node.getType() == Token.ASSIGN) {\n        registry.identifyEnumName(\n            node.getFirstChild().getQualifiedName());\n      }\n    }\n  }",
    "comment": "Attach JSDocInfo to a node, if we can find one. */",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "IRFactory.createJsDocInfoParser",
    "class_name": "com.google.javascript.jscomp.parsing.IRFactory",
    "signature": "com.google.javascript.jscomp.parsing.IRFactory.createJsDocInfoParser(String,int,int,FileLevelJsDocBuilder,JSDocInfo)",
    "snippet": "  private JsDocInfoParser createJsDocInfoParser(\n      String comment, int lineno, int position,\n      Node.FileLevelJsDocBuilder fileLevelJsDocBuilder,\n      JSDocInfo fileOverviewInfo) {\n    // The JsDocInfoParser expects the comment without the initial '/**'.\n    int numOpeningChars = 3;\n    JsDocInfoParser jsdocParser =\n      new JsDocInfoParser(\n          new JsDocTokenStream(comment.substring(numOpeningChars),\n                               lineno,\n                               position2charno(position) + numOpeningChars),\n          sourceName,\n          config,\n          errorReporter);\n    jsdocParser.setFileLevelJsDocBuilder(fileLevelJsDocBuilder);\n    jsdocParser.setFileOverviewJSDocInfo(fileOverviewInfo);\n    jsdocParser.parse();\n    return jsdocParser;\n  }",
    "comment": " Creates a JsDocInfoParser and parses the JsDoc string.  Used both for handling individual JSDoc comments and for handling file-level JSDoc comments (@fileoverview and @license).  @param comment The JsDoc comment to parse. @param lineno The line number of the node this comment is attached to. @param fileLevelJsDocBuilder The builder for file-level JSDocInfo. @param fileOverviewInfo The current @fileoverview JSDocInfo, so that the parser may warn if another @fileoverview is found. May be null. @return A JSDocInfoParser. Will contain either fileoverview jsdoc, or normal jsdoc, or no jsdoc (if the method parses to the wrong level). ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "IRFactory.justTransform",
    "class_name": "com.google.javascript.jscomp.parsing.IRFactory",
    "signature": "com.google.javascript.jscomp.parsing.IRFactory.justTransform(AstNode)",
    "snippet": "  private Node justTransform(AstNode node) {\n    return transformDispatcher.process(node);\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "IRFactory.position2charno",
    "class_name": "com.google.javascript.jscomp.parsing.IRFactory",
    "signature": "com.google.javascript.jscomp.parsing.IRFactory.position2charno(int)",
    "snippet": "  private int position2charno(int position) {\n    int lineIndex = sourceString.lastIndexOf('\\n', position);\n    if (lineIndex == -1) {\n      return position;\n    } else {\n      // Subtract one for initial position being 0.\n      return position - lineIndex - 1;\n    }\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "IRFactory.transform",
    "class_name": "com.google.javascript.jscomp.parsing.IRFactory",
    "signature": "com.google.javascript.jscomp.parsing.IRFactory.transform(AstNode)",
    "snippet": "  private Node transform(AstNode node) {\n    String jsDoc = node.getJsDoc();\n    NodeWithJsDoc nodeWithJsDoc = null;\n    if (jsDoc != null) {\n      nodeWithJsDoc = new NodeWithJsDoc();\n      nodesWithJsDoc.put(jsDoc, nodeWithJsDoc);\n    }\n\n    Node irNode = justTransform(node);\n    if (nodeWithJsDoc != null) {\n      nodeWithJsDoc.node = irNode;\n    }\n\n    // If we have a named function, set the position to that of the name.\n    if (irNode.getType() == Token.FUNCTION &&\n        irNode.getFirstChild().getLineno() != -1) {\n      irNode.setLineno(irNode.getFirstChild().getLineno());\n      irNode.setCharno(irNode.getFirstChild().getCharno());\n    } else {\n      if (irNode.getLineno() == -1) {\n        // If we didn't already set the line, then set it now.  This avoids\n        // cases like ParenthesizedExpression where we just return a previous\n        // node, but don't want the new node to get its parent's line number.\n        int lineno = node.getLineno();\n        irNode.setLineno(lineno);\n        int charno = position2charno(node.getAbsolutePosition());\n        irNode.setCharno(charno);\n      }\n    }\n    return irNode;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "IRFactory.transformTokenType",
    "class_name": "com.google.javascript.jscomp.parsing.IRFactory",
    "signature": "com.google.javascript.jscomp.parsing.IRFactory.transformTokenType(int)",
    "snippet": "  private static int transformTokenType(int token) {\n    switch (token) {\n      case com.google.javascript.jscomp.mozilla.rhino.Token.ERROR:\n        return Token.ERROR;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.EOF:\n        return Token.EOF;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.EOL:\n        return Token.EOL;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.ENTERWITH:\n        return Token.ENTERWITH;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.LEAVEWITH:\n        return Token.LEAVEWITH;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.RETURN:\n        return Token.RETURN;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.GOTO:\n        return Token.GOTO;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.IFEQ:\n        return Token.IFEQ;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.IFNE:\n        return Token.IFNE;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.SETNAME:\n        return Token.SETNAME;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.BITOR:\n        return Token.BITOR;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.BITXOR:\n        return Token.BITXOR;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.BITAND:\n        return Token.BITAND;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.EQ:\n        return Token.EQ;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.NE:\n        return Token.NE;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.LT:\n        return Token.LT;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.LE:\n        return Token.LE;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.GT:\n        return Token.GT;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.GE:\n        return Token.GE;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.LSH:\n        return Token.LSH;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.RSH:\n        return Token.RSH;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.URSH:\n        return Token.URSH;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.ADD:\n        return Token.ADD;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.SUB:\n        return Token.SUB;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.MUL:\n        return Token.MUL;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.DIV:\n        return Token.DIV;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.MOD:\n        return Token.MOD;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.NOT:\n        return Token.NOT;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.BITNOT:\n        return Token.BITNOT;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.POS:\n        return Token.POS;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.NEG:\n        return Token.NEG;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.NEW:\n        return Token.NEW;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.DELPROP:\n        return Token.DELPROP;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.TYPEOF:\n        return Token.TYPEOF;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.GETPROP:\n        return Token.GETPROP;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.SETPROP:\n        return Token.SETPROP;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.GETELEM:\n        return Token.GETELEM;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.SETELEM:\n        return Token.SETELEM;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.CALL:\n        return Token.CALL;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.NAME:\n        return Token.NAME;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.NUMBER:\n        return Token.NUMBER;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.STRING:\n        return Token.STRING;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.NULL:\n        return Token.NULL;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.THIS:\n        return Token.THIS;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.FALSE:\n        return Token.FALSE;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.TRUE:\n        return Token.TRUE;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.SHEQ:\n        return Token.SHEQ;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.SHNE:\n        return Token.SHNE;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.REGEXP:\n        return Token.REGEXP;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.BINDNAME:\n        return Token.BINDNAME;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.THROW:\n        return Token.THROW;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.RETHROW:\n        return Token.RETHROW;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.IN:\n        return Token.IN;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.INSTANCEOF:\n        return Token.INSTANCEOF;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.LOCAL_LOAD:\n        return Token.LOCAL_LOAD;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.GETVAR:\n        return Token.GETVAR;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.SETVAR:\n        return Token.SETVAR;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.CATCH_SCOPE:\n        return Token.CATCH_SCOPE;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.ENUM_INIT_KEYS:\n        return Token.ENUM_INIT_KEYS;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.ENUM_INIT_VALUES:\n        return Token.ENUM_INIT_VALUES;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.ENUM_NEXT:\n        return Token.ENUM_NEXT;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.ENUM_ID:\n        return Token.ENUM_ID;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.THISFN:\n        return Token.THISFN;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.RETURN_RESULT:\n        return Token.RETURN_RESULT;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.ARRAYLIT:\n        return Token.ARRAYLIT;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.OBJECTLIT:\n        return Token.OBJECTLIT;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.GET_REF:\n        return Token.GET_REF;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.SET_REF:\n        return Token.SET_REF;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.DEL_REF:\n        return Token.DEL_REF;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.REF_CALL:\n        return Token.REF_CALL;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.REF_SPECIAL:\n        return Token.REF_SPECIAL;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.DEFAULTNAMESPACE:\n        return Token.DEFAULTNAMESPACE;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.ESCXMLTEXT:\n        return Token.ESCXMLTEXT;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.ESCXMLATTR:\n        return Token.ESCXMLATTR;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.REF_MEMBER:\n        return Token.REF_MEMBER;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.REF_NS_MEMBER:\n        return Token.REF_NS_MEMBER;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.REF_NAME:\n        return Token.REF_NAME;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.REF_NS_NAME:\n        return Token.REF_NS_NAME;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.TRY:\n        return Token.TRY;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.SEMI:\n        return Token.SEMI;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.LB:\n        return Token.LB;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.RB:\n        return Token.RB;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.LC:\n        return Token.LC;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.RC:\n        return Token.RC;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.LP:\n        return Token.LP;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.RP:\n        return Token.RP;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.COMMA:\n        return Token.COMMA;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.ASSIGN:\n        return Token.ASSIGN;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.ASSIGN_BITOR:\n        return Token.ASSIGN_BITOR;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.ASSIGN_BITXOR:\n        return Token.ASSIGN_BITXOR;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.ASSIGN_BITAND:\n        return Token.ASSIGN_BITAND;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.ASSIGN_LSH:\n        return Token.ASSIGN_LSH;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.ASSIGN_RSH:\n        return Token.ASSIGN_RSH;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.ASSIGN_URSH:\n        return Token.ASSIGN_URSH;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.ASSIGN_ADD:\n        return Token.ASSIGN_ADD;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.ASSIGN_SUB:\n        return Token.ASSIGN_SUB;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.ASSIGN_MUL:\n        return Token.ASSIGN_MUL;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.ASSIGN_DIV:\n        return Token.ASSIGN_DIV;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.ASSIGN_MOD:\n        return Token.ASSIGN_MOD;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.HOOK:\n        return Token.HOOK;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.COLON:\n        return Token.COLON;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.OR:\n        return Token.OR;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.AND:\n        return Token.AND;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.INC:\n        return Token.INC;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.DEC:\n        return Token.DEC;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.DOT:\n        return Token.DOT;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.FUNCTION:\n        return Token.FUNCTION;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.EXPORT:\n        return Token.EXPORT;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.IMPORT:\n        return Token.IMPORT;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.IF:\n        return Token.IF;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.ELSE:\n        return Token.ELSE;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.SWITCH:\n        return Token.SWITCH;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.CASE:\n        return Token.CASE;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.DEFAULT:\n        return Token.DEFAULT;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.WHILE:\n        return Token.WHILE;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.DO:\n        return Token.DO;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.FOR:\n        return Token.FOR;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.BREAK:\n        return Token.BREAK;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.CONTINUE:\n        return Token.CONTINUE;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.VAR:\n        return Token.VAR;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.WITH:\n        return Token.WITH;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.CATCH:\n        return Token.CATCH;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.FINALLY:\n        return Token.FINALLY;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.VOID:\n        return Token.VOID;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.RESERVED:\n        return Token.RESERVED;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.EMPTY:\n        return Token.EMPTY;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.BLOCK:\n        return Token.BLOCK;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.LABEL:\n        return Token.LABEL;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.TARGET:\n        return Token.TARGET;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.LOOP:\n        return Token.LOOP;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.EXPR_VOID:\n        return Token.EXPR_VOID;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.EXPR_RESULT:\n        return Token.EXPR_RESULT;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.JSR:\n        return Token.JSR;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.SCRIPT:\n        return Token.SCRIPT;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.TYPEOFNAME:\n        return Token.TYPEOFNAME;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.USE_STACK:\n        return Token.USE_STACK;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.SETPROP_OP:\n        return Token.SETPROP_OP;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.SETELEM_OP:\n        return Token.SETELEM_OP;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.LOCAL_BLOCK:\n        return Token.LOCAL_BLOCK;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.SET_REF_OP:\n        return Token.SET_REF_OP;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.DOTDOT:\n        return Token.DOTDOT;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.COLONCOLON:\n        return Token.COLONCOLON;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.XML:\n        return Token.XML;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.DOTQUERY:\n        return Token.DOTQUERY;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.XMLATTR:\n        return Token.XMLATTR;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.XMLEND:\n        return Token.XMLEND;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.TO_OBJECT:\n        return Token.TO_OBJECT;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.TO_DOUBLE:\n        return Token.TO_DOUBLE;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.GET:\n        return Token.GET;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.SET:\n        return Token.SET;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.CONST:\n        return Token.CONST;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.SETCONST:\n        return Token.SETCONST;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.DEBUGGER:\n        return Token.DEBUGGER;\n    }\n\n    // Token without name\n    throw new IllegalStateException(String.valueOf(token));\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "IRFactory.transformTree",
    "class_name": "com.google.javascript.jscomp.parsing.IRFactory",
    "signature": "com.google.javascript.jscomp.parsing.IRFactory.transformTree(AstRoot,String,Config,ErrorReporter)",
    "snippet": "  public static Node transformTree(AstRoot node,\n                                   String sourceString,\n                                   Config config,\n                                   ErrorReporter errorReporter) {\n    IRFactory irFactory = new IRFactory(sourceString, node.getSourceName(),\n        config, errorReporter);\n    Node irNode = irFactory.transform(node);\n    // @license text gets appended onto the fileLevelJsDocBuilder as found,\n    // and stored straight into the JSDocInfo for the root node.\n    Node.FileLevelJsDocBuilder fileLevelJsDocBuilder =\n        irNode.getJsDocBuilderForNode();\n    // fileOverviewInfo stores the last bit of fileoverview data we saw.\n    // We only permit one, so throwing away extras is fair.\n    // The fileOverviewInfo gets passed into parseJSDocInfo so that\n    // it can detect when multiple @fileoverviews exist in the same file.\n    JSDocInfo fileOverviewInfo = null;\n    if (node.getComments() != null) {\n      for (Comment comment : node.getComments()) {\n        if (comment.getCommentType() == JSDOC) {\n          JsDocInfoParser jsDocParser =\n              irFactory.createJsDocInfoParser(comment.getValue(),\n                  comment.getLineno(), comment.getAbsolutePosition(),\n                  fileLevelJsDocBuilder, fileOverviewInfo);\n          if (jsDocParser.getFileOverviewJSDocInfo() != fileOverviewInfo) {\n            fileOverviewInfo = jsDocParser.getFileOverviewJSDocInfo();\n          } else {\n            JSDocInfo info = jsDocParser.retrieveAndResetParsedJSDocInfo();\n            if (info != null) {\n              irFactory.attachJsDoc(comment, info);\n            }\n          }\n        }\n      }\n\n      // Only after we've seen all @fileoverview entries, attach the\n      // last one to the root node, and copy the found license strings\n      // to that node.\n      if (fileOverviewInfo != null) {\n        if ((irNode.getJSDocInfo() != null) &&\n            (irNode.getJSDocInfo().getLicense() != null)) {\n          fileOverviewInfo.setLicense(irNode.getJSDocInfo().getLicense());\n        }\n        irNode.setJSDocInfo(fileOverviewInfo);\n      }\n    }\n    return irNode;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "TransformDispatcher.isDirective",
    "class_name": "com.google.javascript.jscomp.parsing.IRFactory$TransformDispatcher",
    "signature": "com.google.javascript.jscomp.parsing.IRFactory$TransformDispatcher.isDirective(Node)",
    "snippet": "    private boolean isDirective(Node n) {\n      if (n == null) return false;\n\n      int nType = n.getType();\n      return (nType == Token.EXPR_RESULT || nType == Token.EXPR_VOID) &&\n          n.getFirstChild().getType() == Token.STRING &&\n          ALLOWED_DIRECTIVES.contains(n.getFirstChild().getString());\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "TransformDispatcher.parseDirectives",
    "class_name": "com.google.javascript.jscomp.parsing.IRFactory$TransformDispatcher",
    "signature": "com.google.javascript.jscomp.parsing.IRFactory$TransformDispatcher.parseDirectives(Node)",
    "snippet": "    private void parseDirectives(Node node) {\n      // Remove all the directives, and encode them in the AST.\n      Set<String> directives = null;\n      while (isDirective(node.getFirstChild())) {\n        String directive = node.removeFirstChild().getFirstChild().getString();\n        if (directives == null) {\n          directives = Sets.newHashSet(directive);\n        } else {\n          directives.add(directive);\n        }\n      }\n\n      if (directives != null) {\n        node.setDirectives(directives);\n      }\n    }",
    "comment": " Parse the directives, encode them in the AST, and remove their nodes.  For information on ES5 directives, see section 14.1 of Ecma-262, Edition 5.  It would be nice if Rhino would eventually take care of this for us, but right now their directive-processing is a one-off. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "TransformDispatcher.processAssignment",
    "class_name": "com.google.javascript.jscomp.parsing.IRFactory$TransformDispatcher",
    "signature": "com.google.javascript.jscomp.parsing.IRFactory$TransformDispatcher.processAssignment(Assignment)",
    "snippet": "    @Override\n    Node processAssignment(Assignment assignmentNode) {\n      return processInfixExpression(assignmentNode);\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "TransformDispatcher.processAstRoot",
    "class_name": "com.google.javascript.jscomp.parsing.IRFactory$TransformDispatcher",
    "signature": "com.google.javascript.jscomp.parsing.IRFactory$TransformDispatcher.processAstRoot(AstRoot)",
    "snippet": "    @Override\n    Node processAstRoot(AstRoot rootNode) {\n      Node node = new ScriptOrFnNode(Token.SCRIPT);\n      for (com.google.javascript.jscomp.mozilla.rhino.Node child : rootNode) {\n        node.addChildToBack(transform((AstNode)child));\n      }\n      parseDirectives(node);\n      return node;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "TransformDispatcher.processBlock",
    "class_name": "com.google.javascript.jscomp.parsing.IRFactory$TransformDispatcher",
    "signature": "com.google.javascript.jscomp.parsing.IRFactory$TransformDispatcher.processBlock(Block)",
    "snippet": "    @Override\n    Node processBlock(Block blockNode) {\n      return processGeneric(blockNode);\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "TransformDispatcher.processExpressionStatement",
    "class_name": "com.google.javascript.jscomp.parsing.IRFactory$TransformDispatcher",
    "signature": "com.google.javascript.jscomp.parsing.IRFactory$TransformDispatcher.processExpressionStatement(ExpressionStatement)",
    "snippet": "    @Override\n    Node processExpressionStatement(ExpressionStatement statementNode) {\n      Node node = new Node(transformTokenType(statementNode.getType()));\n      node.addChildToBack(transform(statementNode.getExpression()));\n      return node;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "TransformDispatcher.processFunctionCall",
    "class_name": "com.google.javascript.jscomp.parsing.IRFactory$TransformDispatcher",
    "signature": "com.google.javascript.jscomp.parsing.IRFactory$TransformDispatcher.processFunctionCall(FunctionCall)",
    "snippet": "    @Override\n    Node processFunctionCall(FunctionCall callNode) {\n      Node node = new Node(transformTokenType(callNode.getType()),\n                           transform(callNode.getTarget()));\n      for (AstNode child : callNode.getArguments()) {\n        node.addChildToBack(transform(child));\n      }\n\n      int leftParamPos = callNode.getAbsolutePosition() + callNode.getLp();\n      node.setLineno(callNode.getLineno());\n      node.setCharno(position2charno(leftParamPos));\n      return node;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "TransformDispatcher.processFunctionNode",
    "class_name": "com.google.javascript.jscomp.parsing.IRFactory$TransformDispatcher",
    "signature": "com.google.javascript.jscomp.parsing.IRFactory$TransformDispatcher.processFunctionNode(FunctionNode)",
    "snippet": "   @Override\n  Node processFunctionNode(FunctionNode functionNode) {\n      Name name = functionNode.getFunctionName();\n      Boolean isUnnamedFunction = false;\n      if (name == null) {\n        name = new Name();\n        name.setIdentifier(\"\");\n        isUnnamedFunction = true;\n      }\n      Node node = new com.google.javascript.rhino.FunctionNode(\n          name.getIdentifier());\n      node.putProp(Node.SOURCENAME_PROP, functionNode.getSourceName());\n      Node newName = transform(name);\n      if (isUnnamedFunction) {\n        // Old Rhino tagged the empty name node with the line number of the\n        // declaration.\n        newName.setLineno(functionNode.getLineno());\n        // TODO(user) Mark line number of paren correctly.\n        // Same problem as below - the left paren might not be on the\n        // same line as the function keyword.\n        int lpColumn = functionNode.getAbsolutePosition() +\n            functionNode.getLp();\n        newName.setCharno(position2charno(lpColumn));\n      }\n\n      node.addChildToBack(newName);\n      Node lp = new Node(Token.LP);\n      // The left paren's complicated because it's not represented by an\n      // AstNode, so there's nothing that has the actual line number that it\n      // appeared on.  We know the paren has to appear on the same line as the\n      // function name (or else a semicolon will be inserted.)  If there's no\n      // function name, assume the paren was on the same line as the function.\n      // TODO(user): Mark line number of paren correctly.\n      Name fnName = functionNode.getFunctionName();\n      if (fnName != null) {\n        lp.setLineno(fnName.getLineno());\n      } else {\n        lp.setLineno(functionNode.getLineno());\n      }\n      int lparenCharno = functionNode.getLp() +\n          functionNode.getAbsolutePosition();\n\n      lp.setCharno(position2charno(lparenCharno));\n      for (AstNode param : functionNode.getParams()) {\n        lp.addChildToBack(transform(param));\n      }\n      node.addChildToBack(lp);\n\n      Node bodyNode = transform(functionNode.getBody());\n      parseDirectives(bodyNode);\n      node.addChildToBack(bodyNode);\n     return node;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "TransformDispatcher.processGeneric",
    "class_name": "com.google.javascript.jscomp.parsing.IRFactory$TransformDispatcher",
    "signature": "com.google.javascript.jscomp.parsing.IRFactory$TransformDispatcher.processGeneric(Node)",
    "snippet": "    private Node processGeneric(\n        com.google.javascript.jscomp.mozilla.rhino.Node n) {\n      Node node = new Node(transformTokenType(n.getType()));\n      for (com.google.javascript.jscomp.mozilla.rhino.Node child : n) {\n        node.addChildToBack(transform((AstNode)child));\n      }\n      return node;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "TransformDispatcher.processInfixExpression",
    "class_name": "com.google.javascript.jscomp.parsing.IRFactory$TransformDispatcher",
    "signature": "com.google.javascript.jscomp.parsing.IRFactory$TransformDispatcher.processInfixExpression(InfixExpression)",
    "snippet": "    @Override\n    Node processInfixExpression(InfixExpression exprNode) {\n      Node n =  new Node(\n          transformTokenType(exprNode.getType()),\n          transform(exprNode.getLeft()),\n          transform(exprNode.getRight()));\n      // Set the line number here so we can fine-tune it in ways transform\n      // doesn't do.\n      n.setLineno(exprNode.getLineno());\n      // Position in new ASTNode is to start of expression, but old-fashioned\n      // line numbers from Node reference the operator token.  Add the offset\n      // to the operator to get the correct character number.\n      n.setCharno(position2charno(exprNode.getAbsolutePosition() +\n          exprNode.getOperatorPosition()));\n      return n;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "TransformDispatcher.processName",
    "class_name": "com.google.javascript.jscomp.parsing.IRFactory$TransformDispatcher",
    "signature": "com.google.javascript.jscomp.parsing.IRFactory$TransformDispatcher.processName(Name)",
    "snippet": "    @Override\n    Node processName(Name nameNode) {\n      return Node.newString(Token.NAME, nameNode.getIdentifier());\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "TransformDispatcher.processObjectLiteral",
    "class_name": "com.google.javascript.jscomp.parsing.IRFactory$TransformDispatcher",
    "signature": "com.google.javascript.jscomp.parsing.IRFactory$TransformDispatcher.processObjectLiteral(ObjectLiteral)",
    "snippet": "    @Override\n    Node processObjectLiteral(ObjectLiteral literalNode) {\n      if (literalNode.isDestructuring()) {\n        reportDestructuringAssign(literalNode);\n      }\n\n      Node node = new Node(Token.OBJECTLIT);\n      for (ObjectProperty el : literalNode.getElements()) {\n        node.addChildToBack(transformAsString(el.getLeft()));\n        node.addChildToBack(transform(el.getRight()));\n      }\n      return node;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "TransformDispatcher.processPropertyGet",
    "class_name": "com.google.javascript.jscomp.parsing.IRFactory$TransformDispatcher",
    "signature": "com.google.javascript.jscomp.parsing.IRFactory$TransformDispatcher.processPropertyGet(PropertyGet)",
    "snippet": "    @Override\n    Node processPropertyGet(PropertyGet getNode) {\n      return new Node(\n          Token.GETPROP,\n          transform(getNode.getTarget()),\n          transformAsString(getNode.getProperty()));\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "TransformDispatcher.processStringLiteral",
    "class_name": "com.google.javascript.jscomp.parsing.IRFactory$TransformDispatcher",
    "signature": "com.google.javascript.jscomp.parsing.IRFactory$TransformDispatcher.processStringLiteral(StringLiteral)",
    "snippet": "    @Override\n    Node processStringLiteral(StringLiteral literalNode) {\n      Node n = Node.newString(literalNode.getValue());\n      return n;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "TransformDispatcher.processVariableDeclaration",
    "class_name": "com.google.javascript.jscomp.parsing.IRFactory$TransformDispatcher",
    "signature": "com.google.javascript.jscomp.parsing.IRFactory$TransformDispatcher.processVariableDeclaration(VariableDeclaration)",
    "snippet": "    @Override\n    Node processVariableDeclaration(VariableDeclaration declarationNode) {\n      Node node = new Node(Token.VAR);\n      for (VariableInitializer child : declarationNode.getVariables()) {\n        node.addChildToBack(transform(child));\n      }\n      return node;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "TransformDispatcher.processVariableInitializer",
    "class_name": "com.google.javascript.jscomp.parsing.IRFactory$TransformDispatcher",
    "signature": "com.google.javascript.jscomp.parsing.IRFactory$TransformDispatcher.processVariableInitializer(VariableInitializer)",
    "snippet": "    @Override\n    Node processVariableInitializer(VariableInitializer initializerNode) {\n      Node node = transform(initializerNode.getTarget());\n      if (initializerNode.getInitializer() != null) {\n        node.addChildToBack(transform(initializerNode.getInitializer()));\n        node.setLineno(node.getLineno());\n      }\n      return node;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "TransformDispatcher.transformAsString",
    "class_name": "com.google.javascript.jscomp.parsing.IRFactory$TransformDispatcher",
    "signature": "com.google.javascript.jscomp.parsing.IRFactory$TransformDispatcher.transformAsString(AstNode)",
    "snippet": "    private Node transformAsString(AstNode n) {\n      Node ret = transform(n);\n      if (ret.getType() == Token.STRING) {\n        ret.putBooleanProp(Node.QUOTED_PROP, true);\n      } else if (ret.getType() == Token.NAME) {\n        ret.setType(Token.STRING);\n      }\n      return ret;\n    }",
    "comment": " Transforms the given node and then sets its type to Token.STRING if it was Token.NAME. If its type was already Token.STRING, then quotes it. Used for properties, as the old AST uses String tokens, while the new one uses Name tokens for unquoted strings. For example, in var o = {'a' : 1, b: 2}; the string 'a' is quoted, while the name b is turned into a string, but unquoted. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "JsDocInfoParser.JsDocInfoParser",
    "class_name": "com.google.javascript.jscomp.parsing.JsDocInfoParser",
    "signature": "com.google.javascript.jscomp.parsing.JsDocInfoParser.JsDocInfoParser(JsDocTokenStream,String,Config,ErrorReporter)",
    "snippet": "  JsDocInfoParser(JsDocTokenStream stream,\n                  String sourceName,\n                  Config config,\n                  ErrorReporter errorReporter) {\n    this.stream = stream;\n    this.sourceName = sourceName;\n    this.typeRegistry = config.registry;\n    this.jsdocBuilder = new JSDocInfoBuilder(config.parseJsDocDocumentation);\n    this.annotationNames = config.annotationNames;\n\n    this.errorReporter = errorReporter;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "JsDocInfoParser.createJSTypeExpression",
    "class_name": "com.google.javascript.jscomp.parsing.JsDocInfoParser",
    "signature": "com.google.javascript.jscomp.parsing.JsDocInfoParser.createJSTypeExpression(Node)",
    "snippet": "  private JSTypeExpression createJSTypeExpression(Node n) {\n    return n == null ? null :\n        new JSTypeExpression(n, sourceName, typeRegistry);\n  }",
    "comment": " Constructs a new {@code JSTypeExpression}. @param n A node. May be null. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "JsDocInfoParser.current",
    "class_name": "com.google.javascript.jscomp.parsing.JsDocInfoParser",
    "signature": "com.google.javascript.jscomp.parsing.JsDocInfoParser.current()",
    "snippet": "  private JsDocToken current() {\n    JsDocToken t = unreadToken;\n    unreadToken = NO_UNREAD_TOKEN;\n    return t;\n  }",
    "comment": " Gets the current token, invalidating it in the process. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "JsDocInfoParser.eatTokensUntilEOL",
    "class_name": "com.google.javascript.jscomp.parsing.JsDocInfoParser",
    "signature": "com.google.javascript.jscomp.parsing.JsDocInfoParser.eatTokensUntilEOL()",
    "snippet": "  private JsDocToken eatTokensUntilEOL() {\n    return eatTokensUntilEOL(next());\n  }",
    "comment": " Eats tokens until {@link JsDocToken#EOL} included, and switches back the state to {@link State#SEARCHING_ANNOTATION}. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "JsDocInfoParser.eatTokensUntilEOL",
    "class_name": "com.google.javascript.jscomp.parsing.JsDocInfoParser",
    "signature": "com.google.javascript.jscomp.parsing.JsDocInfoParser.eatTokensUntilEOL(JsDocToken)",
    "snippet": "  private JsDocToken eatTokensUntilEOL(JsDocToken token) {\n    do {\n      if (token == JsDocToken.EOL || token == JsDocToken.EOC ||\n          token == JsDocToken.EOF) {\n        state = State.SEARCHING_ANNOTATION;\n        return token;\n      }\n      token = next();\n    } while (true);\n  }",
    "comment": " Eats tokens until {@link JsDocToken#EOL} included, and switches back the state to {@link State#SEARCHING_ANNOTATION}. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "JsDocInfoParser.extractBlockComment",
    "class_name": "com.google.javascript.jscomp.parsing.JsDocInfoParser",
    "signature": "com.google.javascript.jscomp.parsing.JsDocInfoParser.extractBlockComment(JsDocToken)",
    "snippet": "  private ExtractionInfo extractBlockComment(JsDocToken token) {\n    StringBuilder builder = new StringBuilder();\n\n    boolean ignoreStar = true;\n\n    do {\n      switch (token) {\n        case ANNOTATION:\n        case EOC:\n        case EOF:\n          return new ExtractionInfo(builder.toString().trim(), token);\n\n        case STAR:\n          if (!ignoreStar) {\n            if (builder.length() > 0) {\n              builder.append(' ');\n            }\n\n            builder.append('*');\n          }\n\n          token = next();\n          continue;\n\n        case EOL:\n          ignoreStar = true;\n          builder.append('\\n');\n          token = next();\n          continue;\n\n        default:\n          if (!ignoreStar && builder.length() > 0) {\n            builder.append(' ');\n          }\n\n          ignoreStar = false;\n\n          builder.append(toString(token));\n\n          String line = stream.getRemainingJSDocLine();\n          line = trimEnd(line);\n          builder.append(line);\n          token = next();\n      }\n    } while (true);\n  }",
    "comment": " Extracts the top-level block comment from the JsDoc comment, if any. This method differs from the extractMultilineTextualBlock in that it terminates under different conditions (it doesn't have the same prechecks), it does not first read in the remaining of the current line and its conditions for ignoring the \"*\" (STAR) are different.  @param token The starting token.  @return The extraction information. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "JsDocInfoParser.extractMultilineTextualBlock",
    "class_name": "com.google.javascript.jscomp.parsing.JsDocInfoParser",
    "signature": "com.google.javascript.jscomp.parsing.JsDocInfoParser.extractMultilineTextualBlock(JsDocToken)",
    "snippet": "  private ExtractionInfo extractMultilineTextualBlock(JsDocToken token) {\n    return extractMultilineTextualBlock(token, WhitespaceOption.SINGLE_LINE);\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "JsDocInfoParser.extractMultilineTextualBlock",
    "class_name": "com.google.javascript.jscomp.parsing.JsDocInfoParser",
    "signature": "com.google.javascript.jscomp.parsing.JsDocInfoParser.extractMultilineTextualBlock(JsDocToken,WhitespaceOption)",
    "snippet": "  private ExtractionInfo extractMultilineTextualBlock(JsDocToken token,\n                                                      WhitespaceOption option) {\n\n    if (token == JsDocToken.EOC || token == JsDocToken.EOL ||\n        token == JsDocToken.EOF) {\n      return new ExtractionInfo(\"\", token);\n    }\n\n    stream.update();\n    int startLineno = stream.getLineno();\n    int startCharno = stream.getCharno() + 1;\n\n    // Read the content from the first line.\n    String line = stream.getRemainingJSDocLine();\n\n    if (option != WhitespaceOption.PRESERVE) {\n      line = line.trim();\n    }\n\n    StringBuilder builder = new StringBuilder();\n    builder.append(line);\n\n    state = State.SEARCHING_ANNOTATION;\n    token = next();\n\n    boolean ignoreStar = false;\n\n    do {\n      switch (token) {\n        case ANNOTATION:\n        case EOC:\n        case EOF:\n          String multilineText = builder.toString();\n\n          if (option != WhitespaceOption.PRESERVE) {\n            multilineText = multilineText.trim();\n          }\n\n          int endLineno = stream.getLineno();\n          int endCharno = stream.getCharno();\n\n          if (multilineText.length() > 0) {\n            jsdocBuilder.markText(multilineText, startLineno, startCharno,\n                                  endLineno, endCharno);\n          }\n\n          return new ExtractionInfo(multilineText, token);\n\n        case STAR:\n          if (!ignoreStar) {\n            if (builder.length() > 0) {\n              builder.append(' ');\n            }\n\n            builder.append('*');\n          }\n\n          token = next();\n          continue;\n\n        case EOL:\n          if (option != WhitespaceOption.SINGLE_LINE) {\n            builder.append(\"\\n\");\n          }\n\n          ignoreStar = true;\n          token = next();\n          continue;\n\n        default:\n          ignoreStar = false;\n          state = State.SEARCHING_ANNOTATION;\n\n          if (builder.length() > 0) {\n            builder.append(' ');\n          }\n\n          builder.append(toString(token));\n\n          line = stream.getRemainingJSDocLine();\n\n          if (option != WhitespaceOption.PRESERVE) {\n            line = trimEnd(line);\n          }\n\n          builder.append(line);\n          token = next();\n      }\n    } while (true);\n  }",
    "comment": " Extracts the text found on the current line and all subsequent until either an annotation, end of comment or end of file is reached. Note that if this method detects an end of line as the first token, it will quit immediately (indicating that there is no text where it was expected).  Note that token = info.token; should be called after this method is used to update the token properly in the parser.  @param token The start token. @param option How to handle whitespace.  @return The extraction information. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "JsDocInfoParser.getFileOverviewJSDocInfo",
    "class_name": "com.google.javascript.jscomp.parsing.JsDocInfoParser",
    "signature": "com.google.javascript.jscomp.parsing.JsDocInfoParser.getFileOverviewJSDocInfo()",
    "snippet": "  JSDocInfo getFileOverviewJSDocInfo() {\n    return fileOverviewJSDocInfo;\n  }",
    "comment": " Gets the fileoverview JSDocInfo, if any. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "JsDocInfoParser.hasParsedFileOverviewDocInfo",
    "class_name": "com.google.javascript.jscomp.parsing.JsDocInfoParser",
    "signature": "com.google.javascript.jscomp.parsing.JsDocInfoParser.hasParsedFileOverviewDocInfo()",
    "snippet": "  private boolean hasParsedFileOverviewDocInfo() {\n    return jsdocBuilder.isPopulatedWithFileOverview();\n  }",
    "comment": " Determines whether the parser has been populated with docinfo with a fileoverview tag. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "JsDocInfoParser.match",
    "class_name": "com.google.javascript.jscomp.parsing.JsDocInfoParser",
    "signature": "com.google.javascript.jscomp.parsing.JsDocInfoParser.match(JsDocToken)",
    "snippet": "  private boolean match(JsDocToken token) {\n    unreadToken = next();\n    return unreadToken == token;\n  }",
    "comment": " Tests whether the next symbol of the token stream matches the specific token. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "JsDocInfoParser.newNode",
    "class_name": "com.google.javascript.jscomp.parsing.JsDocInfoParser",
    "signature": "com.google.javascript.jscomp.parsing.JsDocInfoParser.newNode(int)",
    "snippet": "  private Node newNode(int type) {\n    return new Node(type, stream.getLineno(), stream.getCharno());\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "JsDocInfoParser.newStringNode",
    "class_name": "com.google.javascript.jscomp.parsing.JsDocInfoParser",
    "signature": "com.google.javascript.jscomp.parsing.JsDocInfoParser.newStringNode(String)",
    "snippet": "  private Node newStringNode(String s) {\n    return Node.newString(s, stream.getLineno(), stream.getCharno());\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "JsDocInfoParser.next",
    "class_name": "com.google.javascript.jscomp.parsing.JsDocInfoParser",
    "signature": "com.google.javascript.jscomp.parsing.JsDocInfoParser.next()",
    "snippet": "  private JsDocToken next() {\n    if (unreadToken == NO_UNREAD_TOKEN) {\n      return stream.getJsDocToken();\n    } else {\n      return current();\n    }\n  }",
    "comment": " Gets the next token of the token stream or the buffered token if a matching was previously made. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "JsDocInfoParser.parse",
    "class_name": "com.google.javascript.jscomp.parsing.JsDocInfoParser",
    "signature": "com.google.javascript.jscomp.parsing.JsDocInfoParser.parse()",
    "snippet": "  boolean parse() {\n    int lineno;\n    int charno;\n\n    // JSTypes are represented as Rhino AST nodes, and then resolved later.\n    JSTypeExpression type;\n\n    state = State.SEARCHING_ANNOTATION;\n    JsDocToken token = next();\n\n    ExtractionInfo blockInfo = extractBlockComment(token);\n    token = blockInfo.token;\n\n    // If we have a block level comment, record it.\n    if (blockInfo.string.length() > 0) {\n      jsdocBuilder.recordBlockDescription(blockInfo.string);\n    }\n\n    // Parse the actual JsDoc.\n    retry: for (;;) {\n      switch (token) {\n        case ANNOTATION:\n          if (state == State.SEARCHING_ANNOTATION) {\n            state = State.SEARCHING_NEWLINE;\n            lineno = stream.getLineno();\n            charno = stream.getCharno();\n\n            String annotationName = stream.getString();\n            Annotation annotation = annotationNames.get(annotationName);\n            if (annotation == null) {\n              parser.addWarning(\"msg.bad.jsdoc.tag\", annotationName,\n                  stream.getLineno(), stream.getCharno());\n            } else {\n              // Mark the beginning of the annotation.\n              jsdocBuilder.markAnnotation(annotationName, lineno, charno);\n\n              switch (annotation) {\n                case AUTHOR:\n                  ExtractionInfo authorInfo = extractSingleLineBlock();\n                  String author = authorInfo.string;\n\n                  if (author.length() == 0) {\n                    parser.addWarning(\"msg.jsdoc.authormissing\",\n                          stream.getLineno(), stream.getCharno());\n                  } else {\n                    jsdocBuilder.addAuthor(author);\n                  }\n\n                  token = authorInfo.token;\n                  continue retry;\n\n                case CONSTANT:\n                  if (!jsdocBuilder.recordConstancy()) {\n                    parser.addWarning(\"msg.jsdoc.const\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case CONSTRUCTOR:\n                  if (!jsdocBuilder.recordConstructor()) {\n                    if (jsdocBuilder.isInterfaceRecorded()) {\n                      parser.addWarning(\"msg.jsdoc.interface.constructor\",\n                          stream.getLineno(), stream.getCharno());\n                    } else {\n                      parser.addWarning(\"msg.jsdoc.incompat.type\",\n                          stream.getLineno(), stream.getCharno());\n                    }\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case DEPRECATED:\n                  if (!jsdocBuilder.recordDeprecated()) {\n                    parser.addWarning(\"msg.jsdoc.deprecated\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n\n                  // Find the reason/description, if any.\n                  ExtractionInfo reasonInfo =\n                      extractMultilineTextualBlock(token);\n\n                  String reason = reasonInfo.string;\n\n                  if (reason.length() > 0) {\n                    jsdocBuilder.recordDeprecationReason(reason);\n                  }\n\n                  token = reasonInfo.token;\n                  continue retry;\n\n                case INTERFACE:\n                  if (!jsdocBuilder.recordInterface()) {\n                    if (jsdocBuilder.isConstructorRecorded()) {\n                      parser.addWarning(\"msg.jsdoc.interface.constructor\",\n                          stream.getLineno(), stream.getCharno());\n                    } else {\n                      parser.addWarning(\"msg.jsdoc.incompat.type\",\n                          stream.getLineno(), stream.getCharno());\n                    }\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case DESC:\n                  if (jsdocBuilder.isDescriptionRecorded()) {\n                    parser.addWarning(\"msg.jsdoc.desc.extra\",\n                        stream.getLineno(), stream.getCharno());\n                    token = eatTokensUntilEOL();\n                    continue retry;\n                  } else {\n                    ExtractionInfo descriptionInfo =\n                        extractMultilineTextualBlock(token);\n\n                    String description = descriptionInfo.string;\n\n                    jsdocBuilder.recordDescription(description);\n                    token = descriptionInfo.token;\n                    continue retry;\n                  }\n\n                case FILE_OVERVIEW:\n                  ExtractionInfo fileOverviewInfo =\n                      extractMultilineTextualBlock(token,\n                                                   WhitespaceOption.TRIM);\n\n                  String fileOverview = fileOverviewInfo.string;\n\n                  if (!jsdocBuilder.recordFileOverview(fileOverview) ||\n                      fileOverviewJSDocInfo != null) {\n                    parser.addWarning(\"msg.jsdoc.fileoverview.extra\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  token = fileOverviewInfo.token;\n                  continue retry;\n\n                case LICENSE:\n                case PRESERVE:\n                  ExtractionInfo preserveInfo =\n                      extractMultilineTextualBlock(token,\n                                                   WhitespaceOption.PRESERVE);\n\n                  String preserve = preserveInfo.string;\n\n                  if (preserve.length() > 0) {\n                    if (fileLevelJsDocBuilder != null) {\n                      fileLevelJsDocBuilder.append(preserve);\n                    }\n                  }\n\n                  token = preserveInfo.token;\n                  continue retry;\n\n                case ENUM:\n                  token = next();\n                  lineno = stream.getLineno();\n                  charno = stream.getCharno();\n\n                  type = null;\n                  if (token != JsDocToken.EOL && token != JsDocToken.EOC) {\n                    type = createJSTypeExpression(\n                        parseAndRecordTypeNode(token));\n                  }\n\n                  if (type == null) {\n                    type = createJSTypeExpression(newStringNode(\"number\"));\n                  }\n                  if (!jsdocBuilder.recordEnumParameterType(type)) {\n                    parser.addWarning(\"msg.jsdoc.incompat.type\", lineno, charno);\n                  }\n                  token = eatTokensUntilEOL(token);\n                  continue retry;\n\n                case EXPORT:\n                  if (!jsdocBuilder.recordExport()) {\n                    parser.addWarning(\"msg.jsdoc.export\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case EXTERNS:\n                  if (!jsdocBuilder.recordExterns()) {\n                    parser.addWarning(\"msg.jsdoc.externs\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case JAVA_DISPATCH:\n                  if (!jsdocBuilder.recordJavaDispatch()) {\n                    parser.addWarning(\"msg.jsdoc.javadispatch\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case EXTENDS:\n                case IMPLEMENTS:\n                  skipEOLs();\n                  token = next();\n                  lineno = stream.getLineno();\n                  charno = stream.getCharno();\n                  boolean matchingRc = false;\n\n                  if (token == JsDocToken.LC) {\n                    token = next();\n                    matchingRc = true;\n                  }\n\n                  if (token == JsDocToken.STRING) {\n                    Node typeNode = parseAndRecordTypeNameNode(\n                        token, lineno, charno, matchingRc);\n\n                    lineno = stream.getLineno();\n                    charno = stream.getCharno();\n\n                    typeNode = wrapNode(Token.BANG, typeNode);\n                    if (typeNode != null && !matchingRc) {\n                      typeNode.putBooleanProp(Node.BRACELESS_TYPE, true);\n                    }\n                    type = createJSTypeExpression(typeNode);\n\n                    if (annotation == Annotation.EXTENDS) {\n                      if (!jsdocBuilder.recordBaseType(type)) {\n                        parser.addWarning(\n                            \"msg.jsdoc.incompat.type\", lineno, charno);\n                      }\n                    } else {\n                      Preconditions.checkState(\n                          annotation == Annotation.IMPLEMENTS);\n                      if (!jsdocBuilder.recordImplementedInterface(type)) {\n                        parser.addWarning(\"msg.jsdoc.implements.duplicate\",\n                            lineno, charno);\n                      }\n                    }\n                    token = next();\n                    if (matchingRc) {\n                      if (token != JsDocToken.RC) {\n                        parser.addWarning(\"msg.jsdoc.missing.rc\",\n                            stream.getLineno(), stream.getCharno());\n                      }\n                    } else if (token != JsDocToken.EOL &&\n                        token != JsDocToken.EOF && token != JsDocToken.EOC) {\n                      parser.addWarning(\"msg.end.annotation.expected\",\n                          stream.getLineno(), stream.getCharno());\n                    }\n                  } else {\n                    parser.addWarning(\"msg.no.type.name\", lineno, charno);\n                  }\n                  token = eatTokensUntilEOL(token);\n                  continue retry;\n\n                case HIDDEN:\n                  if (!jsdocBuilder.recordHiddenness()) {\n                    parser.addWarning(\"msg.jsdoc.hidden\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case NO_ALIAS:\n                  if (!jsdocBuilder.recordNoAlias()) {\n                    parser.addWarning(\"msg.jsdoc.noalias\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case NO_TYPE_CHECK:\n                  if (!jsdocBuilder.recordNoTypeCheck()) {\n                    parser.addWarning(\"msg.jsdoc.nocheck\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case NOT_IMPLEMENTED:\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case INHERIT_DOC:\n                case OVERRIDE:\n                  if (!jsdocBuilder.recordOverride()) {\n                    parser.addWarning(\"msg.jsdoc.override\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case THROWS:\n                  skipEOLs();\n                  token = next();\n                  lineno = stream.getLineno();\n                  charno = stream.getCharno();\n                  type = null;\n\n                  if (token == JsDocToken.LC) {\n                    type = createJSTypeExpression(\n                        parseAndRecordTypeNode(token));\n\n                    if (type == null) {\n                      // parsing error reported during recursive descent\n                      // recovering parsing\n                      token = eatTokensUntilEOL();\n                      continue retry;\n                    }\n                  }\n\n                  // *Update* the token to that after the type annotation.\n                  token = current();\n\n                  // Save the throw type.\n                  jsdocBuilder.recordThrowType(type);\n\n                  // Find the throw's description (if applicable).\n                  ExtractionInfo descriptionInfo =\n                      extractMultilineTextualBlock(token);\n\n                  String description = descriptionInfo.string;\n\n                  if (description.length() > 0) {\n                    jsdocBuilder.recordThrowDescription(type, description);\n                  }\n\n                  token = descriptionInfo.token;\n                  continue retry;\n\n                case PARAM:\n                  skipEOLs();\n                  token = next();\n                  lineno = stream.getLineno();\n                  charno = stream.getCharno();\n                  type = null;\n\n                  if (token == JsDocToken.LC) {\n                    type = createJSTypeExpression(\n                        parseAndRecordParamTypeNode(token));\n\n                    if (type == null) {\n                      // parsing error reported during recursive descent\n                      // recovering parsing\n                      token = eatTokensUntilEOL();\n                      continue retry;\n                    }\n                    skipEOLs();\n                    token = next();\n                    lineno = stream.getLineno();\n                    charno = stream.getCharno();\n                  }\n\n                  String name = null;\n                  boolean isBracketedParam = JsDocToken.LB == token;\n                  if (isBracketedParam) {\n                    token = next();\n                  }\n\n                  if (JsDocToken.STRING != token) {\n                    parser.addWarning(\"msg.missing.variable.name\",\n                        lineno, charno);\n                  } else {\n                    name = stream.getString();\n\n                    if (isBracketedParam) {\n                      token = next();\n\n                      // Throw out JsDocToolkit's \"default\" parameter annotation.\n                      // It makes no sense under our type system.\n                      if (JsDocToken.EQUALS == token) {\n                        token = next();\n                        if (JsDocToken.STRING == token) {\n                          token = next();\n                        }\n                      }\n\n                      if (JsDocToken.RB != token) {\n                        reportTypeSyntaxWarning(\"msg.jsdoc.missing.rb\");\n                      } else if (type != null) {\n                        // Make the type expression optional, if it isn't\n                        // already.\n                        type = JSTypeExpression.makeOptionalArg(type);\n                      }\n                    }\n\n                    // If the param name has a DOT in it, just throw it out\n                    // quietly. We do not handle the JsDocToolkit method\n                    // for handling properties of params.\n                    if (name.indexOf('.') > -1) {\n                      name = null;\n                    } else if (!jsdocBuilder.recordParameter(name, type)) {\n                      if (jsdocBuilder.hasParameter(name)) {\n                        parser.addWarning(\"msg.dup.variable.name\", name,\n                            lineno, charno);\n                      } else {\n                        parser.addWarning(\"msg.jsdoc.incompat.type\", name,\n                            lineno, charno);\n                      }\n                    }\n                  }\n\n                  if (name == null) {\n                    token = eatTokensUntilEOL(token);\n                    continue retry;\n                  }\n\n                  jsdocBuilder.markName(name, lineno, charno);\n\n                  // Find the parameter's description (if applicable).\n                  ExtractionInfo paramDescriptionInfo =\n                      extractMultilineTextualBlock(token);\n\n                  String paramDescription = paramDescriptionInfo.string;\n\n                  if (paramDescription.length() > 0) {\n                    jsdocBuilder.recordParameterDescription(name,\n                                                            paramDescription);\n                  }\n\n                  token = paramDescriptionInfo.token;\n                  continue retry;\n\n                case PRESERVE_TRY:\n                  if (!jsdocBuilder.recordPreserveTry()) {\n                    parser.addWarning(\"msg.jsdoc.preservertry\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case PRIVATE:\n                  if (!jsdocBuilder.recordVisibility(Visibility.PRIVATE)) {\n                    parser.addWarning(\"msg.jsdoc.visibility.private\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case PROTECTED:\n                  if (!jsdocBuilder.recordVisibility(Visibility.PROTECTED)) {\n                    parser.addWarning(\"msg.jsdoc.visibility.protected\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case PUBLIC:\n                  if (!jsdocBuilder.recordVisibility(Visibility.PUBLIC)) {\n                    parser.addWarning(\"msg.jsdoc.visibility.public\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case NO_SHADOW:\n                  if (!jsdocBuilder.recordNoShadow()) {\n                    parser.addWarning(\"msg.jsdoc.noshadow\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case NO_SIDE_EFFECTS:\n                  if (!jsdocBuilder.recordNoSideEffects()) {\n                    parser.addWarning(\"msg.jsdoc.nosideeffects\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case IMPLICIT_CAST:\n                  if (!jsdocBuilder.recordImplicitCast()) {\n                    parser.addWarning(\"msg.jsdoc.implicitcast\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case SEE:\n                  ExtractionInfo referenceInfo = extractSingleLineBlock();\n                  String reference = referenceInfo.string;\n\n                  if (reference.length() == 0) {\n                    parser.addWarning(\"msg.jsdoc.seemissing\",\n                          stream.getLineno(), stream.getCharno());\n                  } else {\n                    jsdocBuilder.addReference(reference);\n                  }\n\n                  token = referenceInfo.token;\n                  continue retry;\n\n                case SUPPRESS:\n                  token = parseSuppressTag(next());\n                  continue retry;\n\n                case TEMPLATE:\n                  ExtractionInfo templateInfo = extractSingleLineBlock();\n                  String templateTypeName = templateInfo.string;\n\n                  if (templateTypeName.length() == 0) {\n                    parser.addWarning(\"msg.jsdoc.templatemissing\",\n                          stream.getLineno(), stream.getCharno());\n                  } else if (!jsdocBuilder.recordTemplateTypeName(\n                      templateTypeName)) {\n                    parser.addWarning(\"msg.jsdoc.template.at.most.once\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n\n                  token = templateInfo.token;\n                  continue retry;\n\n                case VERSION:\n                  ExtractionInfo versionInfo = extractSingleLineBlock();\n                  String version = versionInfo.string;\n\n                  if (version.length() == 0) {\n                    parser.addWarning(\"msg.jsdoc.versionmissing\",\n                          stream.getLineno(), stream.getCharno());\n                  } else {\n                    if (!jsdocBuilder.recordVersion(version)) {\n                       parser.addWarning(\"msg.jsdoc.extraversion\",\n                          stream.getLineno(), stream.getCharno());\n                    }\n                  }\n\n                  token = versionInfo.token;\n                  continue retry;\n\n                case DEFINE:\n                case RETURN:\n                case THIS:\n                case TYPE:\n                case TYPEDEF:\n                  skipEOLs();\n                  lineno = stream.getLineno();\n                  charno = stream.getCharno();\n\n                  token = next();\n\n                  Node typeNode = parseAndRecordTypeNode(token, lineno, charno);\n\n                  if (annotation == Annotation.THIS) {\n                    typeNode = wrapNode(Token.BANG, typeNode);\n                    if (typeNode != null && token != JsDocToken.LC) {\n                      typeNode.putBooleanProp(Node.BRACELESS_TYPE, true);\n                    }\n                  }\n                  type = createJSTypeExpression(typeNode);\n\n                  if (type == null) {\n                    // error reported during recursive descent\n                    // recovering parsing\n                  } else {\n                    switch (annotation) {\n                      case DEFINE:\n                        if (!isValidDefineType(typeNode)) {\n                          parser.addWarning(\"msg.jsdoc.define.badtype\",\n                              lineno, charno);\n                        } else if (!jsdocBuilder.recordDefineType(type)) {\n                          parser.addWarning(\"msg.jsdoc.define\",\n                              lineno, charno);\n                        }\n                        break;\n\n                      case RETURN:\n                        if (!jsdocBuilder.recordReturnType(type)) {\n                          parser.addWarning(\n                              \"msg.jsdoc.incompat.type\", lineno, charno);\n                          break;\n                        }\n\n                        // *Update* the token to that after the type annotation.\n                        token = current();\n\n                        // Find the return's description (if applicable).\n                        ExtractionInfo returnDescriptionInfo =\n                            extractMultilineTextualBlock(token);\n\n                        String returnDescription = returnDescriptionInfo.string;\n\n                        if (returnDescription.length() > 0) {\n                          jsdocBuilder.recordReturnDescription(\n                              returnDescription);\n                        }\n\n                        token = returnDescriptionInfo.token;\n                        continue retry;\n\n                      case THIS:\n                        if (!jsdocBuilder.recordThisType(type)) {\n                          parser.addWarning(\n                              \"msg.jsdoc.incompat.type\", lineno, charno);\n                        }\n                        break;\n\n                      case TYPE:\n                        if (!jsdocBuilder.recordType(type)) {\n                          parser.addWarning(\n                              \"msg.jsdoc.incompat.type\", lineno, charno);\n                        }\n                        break;\n\n                      case TYPEDEF:\n                        if (!jsdocBuilder.recordTypedef(type)) {\n                          parser.addWarning(\n                              \"msg.jsdoc.incompat.type\", lineno, charno);\n                        }\n                        break;\n                    }\n\n                    token = eatTokensUntilEOL();\n                  }\n                  continue retry;\n              }\n            }\n          }\n          break;\n\n        case EOC:\n          if (hasParsedFileOverviewDocInfo()) {\n            fileOverviewJSDocInfo = retrieveAndResetParsedJSDocInfo();\n          }\n\n          return true;\n\n        case EOF:\n          // discard any accumulated information\n          jsdocBuilder.build(null);\n          parser.addWarning(\"msg.unexpected.eof\",\n              stream.getLineno(), stream.getCharno());\n          return false;\n\n        case EOL:\n          if (state == State.SEARCHING_NEWLINE) {\n            state = State.SEARCHING_ANNOTATION;\n          }\n          token = next();\n          continue retry;\n\n        default:\n          if (token == JsDocToken.STAR && state == State.SEARCHING_ANNOTATION) {\n            token = next();\n            continue retry;\n          } else {\n            state = State.SEARCHING_NEWLINE;\n            token = eatTokensUntilEOL();\n            continue retry;\n          }\n      }\n\n      // next token\n      token = next();\n    }\n  }",
    "comment": " Parses a {@link JSDocInfo} object. This parsing method reads all tokens returned by the {@link JsDocTokenStream#getJsDocToken()} method until the {@link JsDocToken#EOC} is returned.  @return {@code true} if JSDoc information was correctly parsed, {@code false} otherwise ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "JsDocInfoParser.parseAndRecordParamTypeNode",
    "class_name": "com.google.javascript.jscomp.parsing.JsDocInfoParser",
    "signature": "com.google.javascript.jscomp.parsing.JsDocInfoParser.parseAndRecordParamTypeNode(JsDocToken)",
    "snippet": "  private Node parseAndRecordParamTypeNode(JsDocToken token) {\n    Preconditions.checkArgument(token == JsDocToken.LC);\n    int lineno = stream.getLineno();\n    int startCharno = stream.getCharno();\n\n    Node typeNode = parseParamTypeExpressionAnnotation(token);\n    int endCharno = stream.getCharno();\n\n    jsdocBuilder.markTypeNode(typeNode, lineno, startCharno, endCharno,\n        true);\n    return typeNode;\n  }",
    "comment": " Looks for a type expression at the current token and if found, returns it. Note that this method consumes input.  Parameter type expressions are special for two reasons: <ol> <li>They must begin with '{', to distinguish type names from param names. <li>They may end in '=', to denote optionality. </ol>  @param token The current token. @return The type expression found or null if none. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "JsDocInfoParser.parseAndRecordTypeNode",
    "class_name": "com.google.javascript.jscomp.parsing.JsDocInfoParser",
    "signature": "com.google.javascript.jscomp.parsing.JsDocInfoParser.parseAndRecordTypeNode(JsDocToken,int,int)",
    "snippet": "  private Node parseAndRecordTypeNode(JsDocToken token, int lineno,\n      int startCharno) {\n    return parseAndRecordTypeNode(token, lineno, startCharno,\n        token == JsDocToken.LC, false);\n  }",
    "comment": " Looks for a type expression at the current token and if found, returns it. Note that this method consumes input.  @param token The current token. @param lineno The line of the type expression. @param startCharno The starting character position of the type expression. @return The type expression found or null if none. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "JsDocInfoParser.parseAndRecordTypeNode",
    "class_name": "com.google.javascript.jscomp.parsing.JsDocInfoParser",
    "signature": "com.google.javascript.jscomp.parsing.JsDocInfoParser.parseAndRecordTypeNode(JsDocToken,int,int,boolean,boolean)",
    "snippet": "  private Node parseAndRecordTypeNode(JsDocToken token, int lineno,\n                                      int startCharno,\n                                      boolean matchingLC,\n                                      boolean onlyParseSimpleNames) {\n    Node typeNode = null;\n\n    if (onlyParseSimpleNames) {\n      typeNode = parseTypeNameAnnotation(token);\n    } else {\n      typeNode = parseTypeExpressionAnnotation(token);\n    }\n\n    if (typeNode != null && !matchingLC) {\n      typeNode.putBooleanProp(Node.BRACELESS_TYPE, true);\n    }\n\n    int endCharno = stream.getCharno();\n\n    jsdocBuilder.markTypeNode(typeNode, lineno, startCharno, endCharno,\n        matchingLC);\n\n    return typeNode;\n  }",
    "comment": " Looks for a parameter type expression at the current token and if found, returns it. Note that this method consumes input.  @param token The current token. @param lineno The line of the type expression. @param startCharno The starting character position of the type expression. @param matchingLC Whether the type expression starts with a \"{\". @param onlyParseSimpleNames If true, only simple type names are parsed (via a call to parseTypeNameAnnotation instead of parseTypeExpressionAnnotation). @return The type expression found or null if none. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "JsDocInfoParser.parseBasicTypeExpression",
    "class_name": "com.google.javascript.jscomp.parsing.JsDocInfoParser",
    "signature": "com.google.javascript.jscomp.parsing.JsDocInfoParser.parseBasicTypeExpression(JsDocToken)",
    "snippet": "  private Node parseBasicTypeExpression(JsDocToken token) {\n    if (token == JsDocToken.STAR) {\n      return newNode(Token.STAR);\n    } else if (token == JsDocToken.LB) {\n      skipEOLs();\n      return parseArrayType(next());\n    } else if (token == JsDocToken.LC) {\n      skipEOLs();\n      return parseRecordType(next());\n    } else if (token == JsDocToken.LP) {\n      skipEOLs();\n      return parseUnionType(next());\n    } else if (token == JsDocToken.STRING) {\n      String string = stream.getString();\n      if (\"function\".equals(string)) {\n        skipEOLs();\n        return parseFunctionType(next());\n      } else if (\"null\".equals(string) || \"undefined\".equals(string)) {\n        return newStringNode(string);\n      } else {\n        return parseTypeName(token);\n      }\n    }\n\n    return reportGenericTypeSyntaxWarning();\n  }",
    "comment": " BasicTypeExpression := '*' | 'null' | 'undefined' | TypeName | FunctionType | UnionType | RecordType | ArrayType ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "JsDocInfoParser.parseParamTypeExpressionAnnotation",
    "class_name": "com.google.javascript.jscomp.parsing.JsDocInfoParser",
    "signature": "com.google.javascript.jscomp.parsing.JsDocInfoParser.parseParamTypeExpressionAnnotation(JsDocToken)",
    "snippet": "  private Node parseParamTypeExpressionAnnotation(JsDocToken token) {\n    Preconditions.checkArgument(token == JsDocToken.LC);\n\n    skipEOLs();\n\n    boolean restArg = false;\n    token = next();\n    if (token == JsDocToken.ELLIPSIS) {\n      token = next();\n      if (token == JsDocToken.RC) {\n        // EMPTY represents the UNKNOWN type in the Type AST.\n        return wrapNode(Token.ELLIPSIS, new Node(Token.EMPTY));\n      }\n      restArg = true;\n    }\n\n    Node typeNode = parseTopLevelTypeExpression(token);\n    if (typeNode != null) {\n      skipEOLs();\n      if (restArg) {\n        typeNode = wrapNode(Token.ELLIPSIS, typeNode);\n      } else if (match(JsDocToken.EQUALS)) {\n        next();\n        skipEOLs();\n        typeNode = wrapNode(Token.EQUALS, typeNode);\n      }\n\n      if (!match(JsDocToken.RC)) {\n        reportTypeSyntaxWarning(\"msg.jsdoc.missing.rc\");\n      } else {\n        next();\n      }\n    }\n\n    return typeNode;\n  }",
    "comment": " ParamTypeExpressionAnnotation := '{' OptionalParameterType '}' | '{' TopLevelTypeExpression '}' | '{' '...' TopLevelTypeExpression '}'  OptionalParameterType := TopLevelTypeExpression '=' ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "JsDocInfoParser.parseTopLevelTypeExpression",
    "class_name": "com.google.javascript.jscomp.parsing.JsDocInfoParser",
    "signature": "com.google.javascript.jscomp.parsing.JsDocInfoParser.parseTopLevelTypeExpression(JsDocToken)",
    "snippet": "  private Node parseTopLevelTypeExpression(JsDocToken token) {\n    Node typeExpr = parseTypeExpression(token);\n    if (typeExpr != null) {\n      // top-level unions are allowed\n      if (match(JsDocToken.PIPE)) {\n        next();\n        if (match(JsDocToken.PIPE)) {\n          // We support double pipes for backwards-compatibility.\n          next();\n        }\n        skipEOLs();\n        token = next();\n        return parseUnionTypeWithAlternate(token, typeExpr);\n      }\n    }\n    return typeExpr;\n  }",
    "comment": " TopLevelTypeExpression := TypeExpression | TypeUnionList  We made this rule up, for the sake of backwards compatibility. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "JsDocInfoParser.parseTypeExpression",
    "class_name": "com.google.javascript.jscomp.parsing.JsDocInfoParser",
    "signature": "com.google.javascript.jscomp.parsing.JsDocInfoParser.parseTypeExpression(JsDocToken)",
    "snippet": "  private Node parseTypeExpression(JsDocToken token) {\n    if (token == JsDocToken.QMARK) {\n      return wrapNode(Token.QMARK, parseBasicTypeExpression(next()));\n    } else if (token == JsDocToken.BANG) {\n      return wrapNode(Token.BANG, parseBasicTypeExpression(next()));\n    } else {\n      Node basicTypeExpr = parseBasicTypeExpression(token);\n      if (basicTypeExpr != null) {\n        if (match(JsDocToken.QMARK)) {\n          next();\n          return wrapNode(Token.QMARK, basicTypeExpr);\n        } else if (match(JsDocToken.BANG)) {\n          next();\n          return wrapNode(Token.BANG, basicTypeExpr);\n        }\n      }\n\n      return basicTypeExpr;\n    }\n  }",
    "comment": " TypeExpression := BasicTypeExpression | '?' BasicTypeExpression | '!' BasicTypeExpression | BasicTypeExpression '?' | BasicTypeExpression '!' ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "JsDocInfoParser.parseTypeExpressionAnnotation",
    "class_name": "com.google.javascript.jscomp.parsing.JsDocInfoParser",
    "signature": "com.google.javascript.jscomp.parsing.JsDocInfoParser.parseTypeExpressionAnnotation(JsDocToken)",
    "snippet": "  private Node parseTypeExpressionAnnotation(JsDocToken token) {\n    if (token == JsDocToken.LC) {\n      skipEOLs();\n      Node typeNode = parseTopLevelTypeExpression(next());\n      if (typeNode != null) {\n        skipEOLs();\n        if (!match(JsDocToken.RC)) {\n          reportTypeSyntaxWarning(\"msg.jsdoc.missing.rc\");\n        } else {\n          next();\n        }\n      }\n\n      return typeNode;\n    } else {\n      return parseTypeExpression(token);\n    }\n  }",
    "comment": " TypeExpressionAnnotation := TypeExpression | '{' TopLevelTypeExpression '}' ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "JsDocInfoParser.parseTypeName",
    "class_name": "com.google.javascript.jscomp.parsing.JsDocInfoParser",
    "signature": "com.google.javascript.jscomp.parsing.JsDocInfoParser.parseTypeName(JsDocToken)",
    "snippet": "  private Node parseTypeName(JsDocToken token) {\n    if (token != JsDocToken.STRING) {\n      return reportGenericTypeSyntaxWarning();\n    }\n\n    Node typeName = newStringNode(stream.getString());\n    if (match(JsDocToken.LT)) {\n      next();\n      skipEOLs();\n      Node memberType = parseTypeExpressionList(next());\n      if (memberType != null) {\n        typeName.addChildToFront(memberType);\n\n        skipEOLs();\n        if (!match(JsDocToken.GT)) {\n          return reportTypeSyntaxWarning(\"msg.jsdoc.missing.gt\");\n        }\n\n        next();\n      }\n    }\n    return typeName;\n  }",
    "comment": " TypeName := NameExpression | NameExpression TypeApplication TypeApplication := '.<' TypeExpressionList '>' TypeExpressionList := TypeExpression // a white lie ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "JsDocInfoParser.retrieveAndResetParsedJSDocInfo",
    "class_name": "com.google.javascript.jscomp.parsing.JsDocInfoParser",
    "signature": "com.google.javascript.jscomp.parsing.JsDocInfoParser.retrieveAndResetParsedJSDocInfo()",
    "snippet": "  JSDocInfo retrieveAndResetParsedJSDocInfo() {\n    return jsdocBuilder.build(sourceName);\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "JsDocInfoParser.setFileLevelJsDocBuilder",
    "class_name": "com.google.javascript.jscomp.parsing.JsDocInfoParser",
    "signature": "com.google.javascript.jscomp.parsing.JsDocInfoParser.setFileLevelJsDocBuilder(FileLevelJsDocBuilder)",
    "snippet": "  void setFileLevelJsDocBuilder(\n      Node.FileLevelJsDocBuilder fileLevelJsDocBuilder) {\n    this.fileLevelJsDocBuilder = fileLevelJsDocBuilder;\n  }",
    "comment": " Sets the JsDocBuilder for the file-level (root) node of this parse. The parser uses the builder to append any preserve annotations it encounters in jsdoc comments.  @param fileLevelJsDocBuilder ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "JsDocInfoParser.setFileOverviewJSDocInfo",
    "class_name": "com.google.javascript.jscomp.parsing.JsDocInfoParser",
    "signature": "com.google.javascript.jscomp.parsing.JsDocInfoParser.setFileOverviewJSDocInfo(JSDocInfo)",
    "snippet": "  void setFileOverviewJSDocInfo(JSDocInfo fileOverviewJSDocInfo) {\n    this.fileOverviewJSDocInfo = fileOverviewJSDocInfo;\n  }",
    "comment": " Sets the file overview JSDocInfo, in order to warn about multiple uses of the @fileoverview tag in a file. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "JsDocInfoParser.skipEOLs",
    "class_name": "com.google.javascript.jscomp.parsing.JsDocInfoParser",
    "signature": "com.google.javascript.jscomp.parsing.JsDocInfoParser.skipEOLs()",
    "snippet": "  private void skipEOLs() {\n    while (match(JsDocToken.EOL)) {\n      next();\n      if (match(JsDocToken.STAR)) {\n        next();\n      }\n    }\n  }",
    "comment": " Skips all EOLs and all empty lines in the JSDoc. Call this method if you want the JSDoc entry to span multiple lines. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "JsDocInfoParser.wrapNode",
    "class_name": "com.google.javascript.jscomp.parsing.JsDocInfoParser",
    "signature": "com.google.javascript.jscomp.parsing.JsDocInfoParser.wrapNode(int,Node)",
    "snippet": "  private Node wrapNode(int type, Node n) {\n    return n == null ? null :\n        new Node(type, n, stream.getLineno(), stream.getCharno());\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "JsDocTokenStream.JsDocTokenStream",
    "class_name": "com.google.javascript.jscomp.parsing.JsDocTokenStream",
    "signature": "com.google.javascript.jscomp.parsing.JsDocTokenStream.JsDocTokenStream(String,int,int)",
    "snippet": "  JsDocTokenStream(String sourceString, int lineno, int initCharno) {\n    Preconditions.checkNotNull(sourceString);\n    this.lineno = lineno;\n    this.sourceString = sourceString;\n    this.sourceEnd = sourceString.length();\n    this.sourceCursor = this.cursor = 0;\n    this.initLineno = lineno;\n    this.initCharno = initCharno;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "JsDocTokenStream.addToString",
    "class_name": "com.google.javascript.jscomp.parsing.JsDocTokenStream",
    "signature": "com.google.javascript.jscomp.parsing.JsDocTokenStream.addToString(int)",
    "snippet": "  private void addToString(int c) {\n    int N = stringBufferTop;\n    if (N == stringBuffer.length) {\n        char[] tmp = new char[stringBuffer.length * 2];\n        System.arraycopy(stringBuffer, 0, tmp, 0, N);\n        stringBuffer = tmp;\n    }\n    stringBuffer[N] = (char)c;\n    stringBufferTop = N + 1;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "JsDocTokenStream.getChar",
    "class_name": "com.google.javascript.jscomp.parsing.JsDocTokenStream",
    "signature": "com.google.javascript.jscomp.parsing.JsDocTokenStream.getChar()",
    "snippet": "  protected int getChar() {\n    if (ungetCursor != 0) {\n      cursor++;\n      --ungetCursor;\n      if (charno == -1) {\n        charno = getOffset();\n      }\n      return ungetBuffer[ungetCursor];\n    }\n\n    for(;;) {\n      int c;\n      if (sourceCursor == sourceEnd) {\n        hitEOF = true;\n        if (charno == -1) {\n          charno = getOffset();\n        }\n        return EOF_CHAR;\n      }\n      cursor++;\n      c = sourceString.charAt(sourceCursor++);\n\n\n      if (lineEndChar >= 0) {\n        if (lineEndChar == '\\r' && c == '\\n') {\n          lineEndChar = '\\n';\n          continue;\n        }\n        lineEndChar = -1;\n        lineStart = sourceCursor - 1;\n        lineno++;\n      }\n\n      if (c <= 127) {\n        if (c == '\\n' || c == '\\r') {\n          lineEndChar = c;\n          c = '\\n';\n        }\n      } else {\n        if (isJSFormatChar(c)) {\n          continue;\n        }\n        if (ScriptRuntime.isJSLineTerminator(c)) {\n          lineEndChar = c;\n          c = '\\n';\n        }\n      }\n\n      if (charno == -1) {\n        charno = getOffset();\n      }\n\n      return c;\n    }\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "JsDocTokenStream.getCharIgnoreLineEnd",
    "class_name": "com.google.javascript.jscomp.parsing.JsDocTokenStream",
    "signature": "com.google.javascript.jscomp.parsing.JsDocTokenStream.getCharIgnoreLineEnd()",
    "snippet": "  private int getCharIgnoreLineEnd() {\n    if (ungetCursor != 0) {\n      cursor++;\n      --ungetCursor;\n      if (charno == -1) {\n        charno = getOffset();\n      }\n      return ungetBuffer[ungetCursor];\n    }\n\n    for(;;) {\n      int c;\n      if (sourceCursor == sourceEnd) {\n        hitEOF = true;\n        if (charno == -1) {\n          charno = getOffset();\n        }\n        return EOF_CHAR;\n      }\n      cursor++;\n      c = sourceString.charAt(sourceCursor++);\n\n\n      if (c <= 127) {\n        if (c == '\\n' || c == '\\r') {\n          lineEndChar = c;\n          c = '\\n';\n        }\n      } else {\n        if (isJSFormatChar(c)) {\n          continue;\n        }\n        if (ScriptRuntime.isJSLineTerminator(c)) {\n          lineEndChar = c;\n          c = '\\n';\n        }\n      }\n\n      if (charno == -1) {\n        charno = getOffset();\n      }\n\n      return c;\n    }\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "JsDocTokenStream.getCharno",
    "class_name": "com.google.javascript.jscomp.parsing.JsDocTokenStream",
    "signature": "com.google.javascript.jscomp.parsing.JsDocTokenStream.getCharno()",
    "snippet": "  final int getCharno() {\n    return lineno == initLineno? initCharno + charno : charno;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "JsDocTokenStream.getJsDocToken",
    "class_name": "com.google.javascript.jscomp.parsing.JsDocTokenStream",
    "signature": "com.google.javascript.jscomp.parsing.JsDocTokenStream.getJsDocToken()",
    "snippet": "  @SuppressWarnings(\"fallthrough\")\n  final JsDocToken getJsDocToken() {\n    int c;\n    stringBufferTop = 0;\n    for (;;) {\n      // eat white spaces\n      for (;;) {\n        charno = -1;\n        c = getChar();\n        if (c == EOF_CHAR) {\n          return JsDocToken.EOF;\n        } else if (c == '\\n') {\n          return JsDocToken.EOL;\n        } else if (!isJSSpace(c)) {\n          break;\n        }\n      }\n\n      switch (c) {\n        // annotation, e.g. @type or @constructor\n        case '@':\n          do {\n            c = getChar();\n            if (isAlpha(c)) {\n              addToString(c);\n            } else {\n              ungetChar(c);\n              this.string = getStringFromBuffer();\n              stringBufferTop = 0;\n              return JsDocToken.ANNOTATION;\n            }\n          } while (true);\n\n        case '*':\n          if (matchChar('/')) {\n            return JsDocToken.EOC;\n          } else {\n            return JsDocToken.STAR;\n          }\n\n        case ',':\n          return JsDocToken.COMMA;\n\n        case '>':\n          return JsDocToken.GT;\n\n        case '(':\n          return JsDocToken.LP;\n\n        case ')':\n          return JsDocToken.RP;\n\n        case '{':\n          return JsDocToken.LC;\n\n        case '}':\n          return JsDocToken.RC;\n\n        case '[':\n          return JsDocToken.LB;\n\n        case ']':\n          return JsDocToken.RB;\n\n        case '?':\n          return JsDocToken.QMARK;\n\n        case '!':\n          return JsDocToken.BANG;\n\n        case ':':\n          return JsDocToken.COLON;\n\n        case '=':\n          return JsDocToken.EQUALS;\n\n        case '|':\n          matchChar('|');\n          return JsDocToken.PIPE;\n\n        case '.':\n          c = getChar();\n          if (c == '<') {\n            return JsDocToken.LT;\n          } else {\n            if (c == '.') {\n              c = getChar();\n              if (c == '.') {\n                return JsDocToken.ELLIPSIS;\n              } else {\n                addToString('.');\n              }\n            }\n            // we may backtrack across line boundary\n            ungetBuffer[ungetCursor++] = c;\n            c = '.';\n          }\n          // fall through\n\n        default: {\n          // recognize a jsdoc string but discard last . if it is followed by\n          // a non-jsdoc comment char, e.g. Array.<\n          int c1 = c;\n          addToString(c);\n          int c2 = getChar();\n          if (!isJSDocString(c2)) {\n            ungetChar(c2);\n            this.string = getStringFromBuffer();\n            stringBufferTop = 0;\n            return JsDocToken.STRING;\n          } else {\n            do {\n              c1 = c2;\n              c2 = getChar();\n              if (c1 == '.' && c2 == '<') {\n                ungetChar(c2);\n                ungetChar(c1);\n                this.string = getStringFromBuffer();\n                stringBufferTop = 0;\n                return JsDocToken.STRING;\n              } else {\n                if (isJSDocString(c2)) {\n                  addToString(c1);\n                } else {\n                  ungetChar(c2);\n                  addToString(c1);\n                  this.string = getStringFromBuffer();\n                  stringBufferTop = 0;\n                  return JsDocToken.STRING;\n                }\n              }\n            } while (true);\n          }\n        }\n      }\n    }\n  }",
    "comment": " Tokenizes JSDoc comments. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "JsDocTokenStream.getLineno",
    "class_name": "com.google.javascript.jscomp.parsing.JsDocTokenStream",
    "signature": "com.google.javascript.jscomp.parsing.JsDocTokenStream.getLineno()",
    "snippet": "  final int getLineno() { return lineno; }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "JsDocTokenStream.getOffset",
    "class_name": "com.google.javascript.jscomp.parsing.JsDocTokenStream",
    "signature": "com.google.javascript.jscomp.parsing.JsDocTokenStream.getOffset()",
    "snippet": "  final int getOffset() {\n    return sourceCursor - lineStart - ungetCursor - 1;\n  }",
    "comment": " Returns the offset into the current line. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "JsDocTokenStream.getRemainingJSDocLine",
    "class_name": "com.google.javascript.jscomp.parsing.JsDocTokenStream",
    "signature": "com.google.javascript.jscomp.parsing.JsDocTokenStream.getRemainingJSDocLine()",
    "snippet": "  @SuppressWarnings(\"fallthrough\")\n  String getRemainingJSDocLine() {\n    int c;\n    for (;;) {\n      c = getChar();\n      switch (c) {\n        case '*':\n          if (peekChar() != '/') {\n            addToString(c);\n            break;\n          }\n          // fall through\n        case EOF_CHAR:\n        case '\\n':\n          ungetChar(c);\n          this.string = getStringFromBuffer();\n          stringBufferTop = 0;\n          return this.string;\n\n        default:\n          addToString(c);\n          break;\n      }\n    }\n  }",
    "comment": " Gets the remaining JSDoc line without the {@link JsDocToken#EOL}, {@link JsDocToken#EOF} or {@link JsDocToken#EOC}. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "JsDocTokenStream.getString",
    "class_name": "com.google.javascript.jscomp.parsing.JsDocTokenStream",
    "signature": "com.google.javascript.jscomp.parsing.JsDocTokenStream.getString()",
    "snippet": "  final String getString() { return string; }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "JsDocTokenStream.getStringFromBuffer",
    "class_name": "com.google.javascript.jscomp.parsing.JsDocTokenStream",
    "signature": "com.google.javascript.jscomp.parsing.JsDocTokenStream.getStringFromBuffer()",
    "snippet": "  private String getStringFromBuffer() {\n    tokenEnd = cursor;\n    return new String(stringBuffer, 0, stringBufferTop);\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "JsDocTokenStream.isAlpha",
    "class_name": "com.google.javascript.jscomp.parsing.JsDocTokenStream",
    "signature": "com.google.javascript.jscomp.parsing.JsDocTokenStream.isAlpha(int)",
    "snippet": "  private static boolean isAlpha(int c) {\n    // Use 'Z' < 'a'\n    if (c <= 'Z') {\n      return 'A' <= c;\n    } else {\n      return 'a' <= c && c <= 'z';\n    }\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "JsDocTokenStream.isJSDocString",
    "class_name": "com.google.javascript.jscomp.parsing.JsDocTokenStream",
    "signature": "com.google.javascript.jscomp.parsing.JsDocTokenStream.isJSDocString(int)",
    "snippet": "  private boolean isJSDocString(int c) {\n    switch (c) {\n      case '@':\n      case '*':\n      case ',':\n      case '>':\n      case ':':\n      case '(':\n      case ')':\n      case '{':\n      case '}':\n      case '[':\n      case ']':\n      case '?':\n      case '!':\n      case '|':\n      case '=':\n      case EOF_CHAR:\n      case '\\n':\n        return false;\n\n      default:\n        return !isJSSpace(c);\n    }\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "JsDocTokenStream.isJSSpace",
    "class_name": "com.google.javascript.jscomp.parsing.JsDocTokenStream",
    "signature": "com.google.javascript.jscomp.parsing.JsDocTokenStream.isJSSpace(int)",
    "snippet": "  static boolean isJSSpace(int c) {\n    if (c <= 127) {\n      return c == 0x20 || c == 0x9 || c == 0xC || c == 0xB;\n    } else {\n      return c == 0xA0\n          || Character.getType((char)c) == Character.SPACE_SEPARATOR;\n    }\n  }",
    "comment": "As defined in ECMA.  jsscan.c uses C isspace() (which allows \\v, I think.)  note that code in getChar() implicitly accepts '\\r' == \\u000D as well. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "JsDocTokenStream.matchChar",
    "class_name": "com.google.javascript.jscomp.parsing.JsDocTokenStream",
    "signature": "com.google.javascript.jscomp.parsing.JsDocTokenStream.matchChar(int)",
    "snippet": "  private boolean matchChar(int test) {\n    int c = getCharIgnoreLineEnd();\n    if (c == test) {\n      tokenEnd = cursor;\n      return true;\n    } else {\n      ungetCharIgnoreLineEnd(c);\n      return false;\n    }\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "JsDocTokenStream.peekChar",
    "class_name": "com.google.javascript.jscomp.parsing.JsDocTokenStream",
    "signature": "com.google.javascript.jscomp.parsing.JsDocTokenStream.peekChar()",
    "snippet": "  private int peekChar() {\n    int c = getChar();\n    ungetChar(c);\n    return c;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "JsDocTokenStream.ungetChar",
    "class_name": "com.google.javascript.jscomp.parsing.JsDocTokenStream",
    "signature": "com.google.javascript.jscomp.parsing.JsDocTokenStream.ungetChar(int)",
    "snippet": "  private void ungetChar(int c) {\n    // can not unread past across line boundary\n    assert(!(ungetCursor != 0 && ungetBuffer[ungetCursor - 1] == '\\n'));\n    ungetBuffer[ungetCursor++] = c;\n    cursor--;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "JsDocTokenStream.ungetCharIgnoreLineEnd",
    "class_name": "com.google.javascript.jscomp.parsing.JsDocTokenStream",
    "signature": "com.google.javascript.jscomp.parsing.JsDocTokenStream.ungetCharIgnoreLineEnd(int)",
    "snippet": "  private void ungetCharIgnoreLineEnd(int c) {\n    ungetBuffer[ungetCursor++] = c;\n    cursor--;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "JsDocTokenStream.update",
    "class_name": "com.google.javascript.jscomp.parsing.JsDocTokenStream",
    "signature": "com.google.javascript.jscomp.parsing.JsDocTokenStream.update()",
    "snippet": "  void update() {\n    charno = getOffset();\n  }",
    "comment": " Allows the JSDocParser to update the character offset so that getCharno() returns a valid character position. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "ParserRunner.createConfig",
    "class_name": "com.google.javascript.jscomp.parsing.ParserRunner",
    "signature": "com.google.javascript.jscomp.parsing.ParserRunner.createConfig(JSTypeRegistry,boolean)",
    "snippet": "  public static Config createConfig(\n      JSTypeRegistry typeRegistry, boolean isIdeMode) {\n    return new Config(\n        typeRegistry, getAnnotationNames(), isIdeMode);\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "ParserRunner.getAnnotationNames",
    "class_name": "com.google.javascript.jscomp.parsing.ParserRunner",
    "signature": "com.google.javascript.jscomp.parsing.ParserRunner.getAnnotationNames()",
    "snippet": "  static Set<String> getAnnotationNames() {\n    initAnnotationNames();\n    return annotationNames;\n  }",
    "comment": " Gets a list of extra annotations that are OK, even if the parser doesn't have handlers for them built-in. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "ParserRunner.initAnnotationNames",
    "class_name": "com.google.javascript.jscomp.parsing.ParserRunner",
    "signature": "com.google.javascript.jscomp.parsing.ParserRunner.initAnnotationNames()",
    "snippet": "  private static synchronized void initAnnotationNames() {\n    if (annotationNames != null) {\n      return;\n    }\n\n    Set<String> trimmedNames = Sets.newHashSet();\n    ResourceBundle config = ResourceBundle.getBundle(configResource);\n    String[] names = config.getString(\"jsdoc.annotations\").split(\",\");\n    for (String name : names) {\n      trimmedNames.add(name.trim());\n    }\n    annotationNames = ImmutableSet.copyOf(trimmedNames);\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "ParserRunner.parse",
    "class_name": "com.google.javascript.jscomp.parsing.ParserRunner",
    "signature": "com.google.javascript.jscomp.parsing.ParserRunner.parse(String,String,Config,ErrorReporter,Logger)",
    "snippet": "  public static Node parse(String sourceName,\n                           String sourceString,\n                           Config config,\n                           ErrorReporter errorReporter,\n                           Logger logger) throws IOException {\n    Context cx = Context.enter();\n    cx.setErrorReporter(errorReporter);\n    cx.setLanguageVersion(Context.VERSION_1_5);\n    CompilerEnvirons compilerEnv = new CompilerEnvirons();\n    compilerEnv.initFromContext(cx);\n    compilerEnv.setRecordingComments(true);\n    compilerEnv.setRecordingLocalJsDocComments(true);\n    compilerEnv.setWarnTrailingComma(true);\n    if (config.isIdeMode) {\n      compilerEnv.setReservedKeywordAsIdentifier(true);\n      compilerEnv.setAllowMemberExprAsFunctionName(true);\n    }\n\n    Parser p = new Parser(compilerEnv, errorReporter);\n    AstRoot astRoot = null;\n    try {\n      astRoot = p.parse(sourceString, sourceName, 1);\n    } catch (EvaluatorException e) {\n      logger.info(\"Error parsing \" + sourceName + \": \" + e.getMessage());\n    } finally {\n      Context.exit();\n    }\n    Node root = null;\n    if (astRoot != null) {\n      root = IRFactory.transformTree(\n          astRoot, sourceString, config, errorReporter);\n      root.setIsSyntheticBlock(true);\n    }\n    return root;\n  }",
    "comment": " Parses the JavaScript text given by a reader.  @param sourceName The filename. @param sourceString Source code from the file. @param errorReporter An error. @param logger A logger. @return The AST of the given text. @throws IOException ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "TypeSafeDispatcher.process",
    "class_name": "com.google.javascript.jscomp.parsing.TypeSafeDispatcher",
    "signature": "com.google.javascript.jscomp.parsing.TypeSafeDispatcher.process(AstNode)",
    "snippet": "  public T process(AstNode node) {\n    switch (node.getType()) {\n      case Token.ADD:\n      case Token.AND:\n      case Token.BITAND:\n      case Token.BITOR:\n      case Token.BITXOR:\n      case Token.COMMA:\n      case Token.DIV:\n      case Token.EQ:\n      case Token.GE:\n      case Token.GT:\n      case Token.IN:\n      case Token.INSTANCEOF:\n      case Token.LE:\n      case Token.LSH:\n      case Token.LT:\n      case Token.MOD:\n      case Token.MUL:\n      case Token.NE:\n      case Token.OR:\n      case Token.RSH:\n      case Token.SHEQ:\n      case Token.SHNE:\n      case Token.SUB:\n      case Token.URSH:\n        return processInfixExpression((InfixExpression) node);\n      case Token.ARRAYLIT:\n        return processArrayLiteral((ArrayLiteral) node);\n      case Token.ASSIGN:\n      case Token.ASSIGN_ADD:\n      case Token.ASSIGN_BITAND:\n      case Token.ASSIGN_BITOR:\n      case Token.ASSIGN_BITXOR:\n      case Token.ASSIGN_DIV:\n      case Token.ASSIGN_LSH:\n      case Token.ASSIGN_MOD:\n      case Token.ASSIGN_MUL:\n      case Token.ASSIGN_RSH:\n      case Token.ASSIGN_SUB:\n      case Token.ASSIGN_URSH:\n        return processAssignment((Assignment) node);\n      case Token.BITNOT:\n      case Token.DEC:\n      case Token.DELPROP:\n      case Token.INC:\n      case Token.NEG:\n      case Token.NOT:\n      case Token.POS:\n      case Token.TYPEOF:\n      case Token.VOID:\n        return processUnaryExpression((UnaryExpression) node);\n      case Token.BLOCK:\n        if (node instanceof Block) {\n          return processBlock((Block) node);\n        } else  if (node instanceof Scope) {\n          return processScope((Scope) node);\n        } else {\n          throw new IllegalStateException(\"Unexpected node type.  class: \" +\n                                          node.getClass() +\n                                          \" type: \" +\n                                          Token.typeToName(node.getType()));\n        }\n      case Token.BREAK:\n        return processBreakStatement((BreakStatement) node);\n      case Token.CALL:\n        return processFunctionCall((FunctionCall) node);\n      case Token.CASE:\n      case Token.DEFAULT:\n        return processSwitchCase((SwitchCase) node);\n      case Token.CATCH:\n      case Token.FINALLY:\n        return processCatchClause((CatchClause) node);\n      case Token.COLON:\n        return processObjectProperty((ObjectProperty) node);\n      case Token.CONTINUE:\n        return processContinueStatement((ContinueStatement) node);\n      case Token.DO:\n        return processDoLoop((DoLoop) node);\n      case Token.EMPTY:\n        return processEmptyExpression((EmptyExpression) node);\n      case Token.EXPR_RESULT:\n      case Token.EXPR_VOID:\n        if (node instanceof ExpressionStatement) {\n          return processExpressionStatement((ExpressionStatement) node);\n        } else  if (node instanceof LabeledStatement) {\n          return processLabeledStatement((LabeledStatement) node);\n        } else {\n          throw new IllegalStateException(\"Unexpected node type.  class: \" +\n                                          node.getClass() +\n                                          \" type: \" +\n                                          Token.typeToName(node.getType()));\n        }\n      case Token.DEBUGGER:\n      case Token.FALSE:\n      case Token.NULL:\n      case Token.THIS:\n      case Token.TRUE:\n        return processKeywordLiteral((KeywordLiteral) node);\n      case Token.FOR:\n        if (node instanceof ForInLoop) {\n          return processForInLoop((ForInLoop) node);\n        } else  if (node instanceof ForLoop) {\n          return processForLoop((ForLoop) node);\n        } else {\n          throw new IllegalStateException(\"Unexpected node type.  class: \" +\n                                          node.getClass() +\n                                          \" type: \" +\n                                          Token.typeToName(node.getType()));\n        }\n      case Token.FUNCTION:\n        return processFunctionNode((FunctionNode) node);\n      case Token.GETELEM:\n        return processElementGet((ElementGet) node);\n      case Token.GETPROP:\n        return processPropertyGet((PropertyGet) node);\n      case Token.HOOK:\n        return processConditionalExpression((ConditionalExpression) node);\n      case Token.IF:\n        return processIfStatement((IfStatement) node);\n      case Token.LABEL:\n        return processLabel((Label) node);\n      case Token.LP:\n        return processParenthesizedExpression((ParenthesizedExpression) node);\n      case Token.NAME:\n        return processName((Name) node);\n      case Token.NEW:\n        return processNewExpression((NewExpression) node);\n      case Token.NUMBER:\n        return processNumberLiteral((NumberLiteral) node);\n      case Token.OBJECTLIT:\n        return processObjectLiteral((ObjectLiteral) node);\n      case Token.REGEXP:\n        return processRegExpLiteral((RegExpLiteral) node);\n      case Token.RETURN:\n        return processReturnStatement((ReturnStatement) node);\n      case Token.SCRIPT:\n        return processAstRoot((AstRoot) node);\n      case Token.STRING:\n        return processStringLiteral((StringLiteral) node);\n      case Token.SWITCH:\n        return processSwitchStatement((SwitchStatement) node);\n      case Token.THROW:\n        return processThrowStatement((ThrowStatement) node);\n      case Token.TRY:\n        return processTryStatement((TryStatement) node);\n      case Token.VAR:\n        if (node instanceof VariableDeclaration) {\n          return processVariableDeclaration((VariableDeclaration) node);\n        } else  if (node instanceof VariableInitializer) {\n          return processVariableInitializer((VariableInitializer) node);\n        } else {\n          throw new IllegalStateException(\"Unexpected node type.  class: \" +\n                                          node.getClass() +\n                                          \" type: \" +\n                                          Token.typeToName(node.getType()));\n        }\n      case Token.WHILE:\n        return processWhileLoop((WhileLoop) node);\n      case Token.WITH:\n        return processWithStatement((WithStatement) node);\n    }\n    return processIllegalToken(node);\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "Context.getCurrentContext",
    "class_name": "com.google.javascript.rhino.Context",
    "signature": "com.google.javascript.rhino.Context.getCurrentContext()",
    "snippet": "    public static Context getCurrentContext() {\n        return threadContexts.get();\n    }",
    "comment": " Get the current Context.  The current Context is per-thread; this method looks up the Context associated with the current thread. <p>  @return the Context associated with the current thread, or null if no context is associated with the current thread. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "FunctionNode.FunctionNode",
    "class_name": "com.google.javascript.rhino.FunctionNode",
    "signature": "com.google.javascript.rhino.FunctionNode.FunctionNode(String)",
    "snippet": "    public FunctionNode(String name) {\n        super(Token.FUNCTION);\n        functionName = name;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "JSDocInfo.JSDocInfo",
    "class_name": "com.google.javascript.rhino.JSDocInfo",
    "signature": "com.google.javascript.rhino.JSDocInfo.JSDocInfo(boolean)",
    "snippet": "  JSDocInfo(boolean includeDocumentation) {\n    this.includeDocumentation = includeDocumentation;\n  }",
    "comment": " Creates a {@link JSDocInfo} object. This object should be created using a {@link JSDocInfoBuilder}. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "JSDocInfo.addMarker",
    "class_name": "com.google.javascript.rhino.JSDocInfo",
    "signature": "com.google.javascript.rhino.JSDocInfo.addMarker()",
    "snippet": "  Marker addMarker() {\n    if (!lazyInitDocumentation()) {\n      return null;\n    }\n\n    if (documentation.markers == null) {\n      documentation.markers = Lists.newArrayList();\n    }\n\n    Marker marker = new Marker();\n    documentation.markers.add(marker);\n    return marker;\n  }",
    "comment": " Adds a marker to the documentation (if it exists) and returns the marker. Returns null otherwise. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "JSDocInfo.declareParam",
    "class_name": "com.google.javascript.rhino.JSDocInfo",
    "signature": "com.google.javascript.rhino.JSDocInfo.declareParam(JSTypeExpression,String)",
    "snippet": "  boolean declareParam(JSTypeExpression jsType, String parameter) {\n    lazyInitInfo();\n    if (info.parameters == null) {\n      info.parameters = new LinkedHashMap<String, JSTypeExpression>();\n    }\n    if (!info.parameters.containsKey(parameter)) {\n      info.parameters.put(parameter, jsType);\n      return true;\n    } else {\n      return false;\n    }\n  }",
    "comment": " Declares a parameter. Parameters are described using the {@code @param} annotation.  @param jsType the parameter's type, it may be {@code null} when the {@code @param} annotation did not specify a type. @param parameter the parameter's name ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "JSDocInfo.getBaseType",
    "class_name": "com.google.javascript.rhino.JSDocInfo",
    "signature": "com.google.javascript.rhino.JSDocInfo.getBaseType()",
    "snippet": "  public JSTypeExpression getBaseType() {\n    return (info == null) ? null : info.baseType;\n  }",
    "comment": " Gets the base type specified by the {@code @extends} annotation. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "JSDocInfo.getFlag",
    "class_name": "com.google.javascript.rhino.JSDocInfo",
    "signature": "com.google.javascript.rhino.JSDocInfo.getFlag(int)",
    "snippet": "  private boolean getFlag(int mask) {\n    return (bitset & mask) != 0x00;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "JSDocInfo.getParameterCount",
    "class_name": "com.google.javascript.rhino.JSDocInfo",
    "signature": "com.google.javascript.rhino.JSDocInfo.getParameterCount()",
    "snippet": "  public int getParameterCount() {\n    if (info == null || info.parameters == null) {\n      return 0;\n    }\n    return info.parameters.size();\n  }",
    "comment": " Gets the number of parameters defined. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "JSDocInfo.getParameterType",
    "class_name": "com.google.javascript.rhino.JSDocInfo",
    "signature": "com.google.javascript.rhino.JSDocInfo.getParameterType(String)",
    "snippet": "  public JSTypeExpression getParameterType(String parameter) {\n    if (info == null || info.parameters == null) {\n      return null;\n    }\n    return info.parameters.get(parameter);\n  }",
    "comment": " Gets the parameter type. @param parameter the parameter's name @return the parameter's type or {@code null} if this parameter is not defined or has a {@code null} type ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "JSDocInfo.getReturnType",
    "class_name": "com.google.javascript.rhino.JSDocInfo",
    "signature": "com.google.javascript.rhino.JSDocInfo.getReturnType()",
    "snippet": "  public JSTypeExpression getReturnType() {\n    return getType(TYPEFIELD_RETURN);\n  }",
    "comment": " Gets the return type specified by the {@code @return} annotation. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "JSDocInfo.getType",
    "class_name": "com.google.javascript.rhino.JSDocInfo",
    "signature": "com.google.javascript.rhino.JSDocInfo.getType(int)",
    "snippet": "  private JSTypeExpression getType(int typefield) {\n    if ((MASK_TYPEFIELD & bitset) == typefield) {\n      return type;\n    } else {\n      return null;\n    }\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "JSDocInfo.getVisibility",
    "class_name": "com.google.javascript.rhino.JSDocInfo",
    "signature": "com.google.javascript.rhino.JSDocInfo.getVisibility()",
    "snippet": "  public Visibility getVisibility() {\n    return visibility;\n  }",
    "comment": " Gets the visibility specified by {@code @private}, {@code @protected} or {@code @public} annotation. If no visibility is specified, visibility is inherited from the base class. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "JSDocInfo.hasBaseType",
    "class_name": "com.google.javascript.rhino.JSDocInfo",
    "signature": "com.google.javascript.rhino.JSDocInfo.hasBaseType()",
    "snippet": "  public boolean hasBaseType() {\n    return getBaseType() != null;\n  }",
    "comment": " Returns whether this {@link JSDocInfo} contains a type for {@code @extends} annotation. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "JSDocInfo.hasEnumParameterType",
    "class_name": "com.google.javascript.rhino.JSDocInfo",
    "signature": "com.google.javascript.rhino.JSDocInfo.hasEnumParameterType()",
    "snippet": "  public boolean hasEnumParameterType() {\n    return hasType(TYPEFIELD_ENUM);\n  }",
    "comment": " Returns whether an enum parameter type, specified using the {@code @enum} annotation, is present on this JSDoc. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "JSDocInfo.hasFileOverview",
    "class_name": "com.google.javascript.rhino.JSDocInfo",
    "signature": "com.google.javascript.rhino.JSDocInfo.hasFileOverview()",
    "snippet": "  public boolean hasFileOverview() {\n    return getFlag(MASK_FILEOVERVIEW);\n  }",
    "comment": " Returns whether this has a fileoverview flag. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "JSDocInfo.hasReturnType",
    "class_name": "com.google.javascript.rhino.JSDocInfo",
    "signature": "com.google.javascript.rhino.JSDocInfo.hasReturnType()",
    "snippet": "  public boolean hasReturnType() {\n    return hasType(TYPEFIELD_RETURN);\n  }",
    "comment": " Returns whether this {@link JSDocInfo} contains a type for {@code @return} annotation. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "JSDocInfo.hasThisType",
    "class_name": "com.google.javascript.rhino.JSDocInfo",
    "signature": "com.google.javascript.rhino.JSDocInfo.hasThisType()",
    "snippet": "  public boolean hasThisType() {\n    return thisType != null;\n  }",
    "comment": " Returns whether this {@link JSDocInfo} contains a type for {@code @this} annotation. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "JSDocInfo.hasType",
    "class_name": "com.google.javascript.rhino.JSDocInfo",
    "signature": "com.google.javascript.rhino.JSDocInfo.hasType()",
    "snippet": "  public boolean hasType() {\n    return hasType(TYPEFIELD_TYPE);\n  }",
    "comment": " Returns whether a type, specified using the {@code @type} annotation, is present on this JSDoc. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "JSDocInfo.hasType",
    "class_name": "com.google.javascript.rhino.JSDocInfo",
    "signature": "com.google.javascript.rhino.JSDocInfo.hasType(int)",
    "snippet": "  private boolean hasType(int mask) {\n    return (bitset & MASK_TYPEFIELD) == mask;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "JSDocInfo.hasTypedefType",
    "class_name": "com.google.javascript.rhino.JSDocInfo",
    "signature": "com.google.javascript.rhino.JSDocInfo.hasTypedefType()",
    "snippet": "  public boolean hasTypedefType() {\n    return hasType(TYPEFIELD_TYPEDEF);\n  }",
    "comment": " Returns whether a typedef parameter type, specified using the {@code @typedef} annotation, is present on this JSDoc. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "JSDocInfo.isConstant",
    "class_name": "com.google.javascript.rhino.JSDocInfo",
    "signature": "com.google.javascript.rhino.JSDocInfo.isConstant()",
    "snippet": "  public boolean isConstant() {\n    return getFlag(MASK_CONSTANT) || isDefine();\n  }",
    "comment": " Returns whether the {@code @const} annotation is present on this {@link JSDocInfo}. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "JSDocInfo.isConstructor",
    "class_name": "com.google.javascript.rhino.JSDocInfo",
    "signature": "com.google.javascript.rhino.JSDocInfo.isConstructor()",
    "snippet": "  public boolean isConstructor() {\n    return getFlag(MASK_CONSTRUCTOR);\n  }",
    "comment": " Returns whether the {@code @constructor} annotation is present on this {@link JSDocInfo}. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "JSDocInfo.isDefine",
    "class_name": "com.google.javascript.rhino.JSDocInfo",
    "signature": "com.google.javascript.rhino.JSDocInfo.isDefine()",
    "snippet": "  public boolean isDefine() {\n    return getFlag(MASK_DEFINE);\n  }",
    "comment": " Returns whether the {@code @define} annotation is present on this {@link JSDocInfo}. If this annotation is present, then the {@link #getType()} method will retrieve the define type. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "JSDocInfo.isExterns",
    "class_name": "com.google.javascript.rhino.JSDocInfo",
    "signature": "com.google.javascript.rhino.JSDocInfo.isExterns()",
    "snippet": "  public boolean isExterns() {\n    return getFlag(MASK_EXTERNS);\n  }",
    "comment": " Returns whether the {@code @externs} annotation is present on this {@link JSDocInfo}. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "JSDocInfo.isInterface",
    "class_name": "com.google.javascript.rhino.JSDocInfo",
    "signature": "com.google.javascript.rhino.JSDocInfo.isInterface()",
    "snippet": "  public boolean isInterface() {\n    return getFlag(MASK_INTERFACE);\n  }",
    "comment": " Returns whether the {@code @interface} annotation is present on this {@link JSDocInfo}. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "JSDocInfo.isJavaDispatch",
    "class_name": "com.google.javascript.rhino.JSDocInfo",
    "signature": "com.google.javascript.rhino.JSDocInfo.isJavaDispatch()",
    "snippet": "  public boolean isJavaDispatch() {\n    return getFlag(MASK_JAVADISPATCH);\n  }",
    "comment": " Returns whether the {@code @javadispath} annotation is present on this {@link JSDocInfo}. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "JSDocInfo.isNoSideEffects",
    "class_name": "com.google.javascript.rhino.JSDocInfo",
    "signature": "com.google.javascript.rhino.JSDocInfo.isNoSideEffects()",
    "snippet": "  public boolean isNoSideEffects() {\n    return getFlag(MASK_NOSIDEEFFECTS);\n  }",
    "comment": " Returns whether the {@code @nosideeffects} annotation is present on this {@link JSDocInfo}. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "JSDocInfo.lazyInitDocumentation",
    "class_name": "com.google.javascript.rhino.JSDocInfo",
    "signature": "com.google.javascript.rhino.JSDocInfo.lazyInitDocumentation()",
    "snippet": "  private boolean lazyInitDocumentation() {\n    if (!includeDocumentation) {\n      return false;\n    }\n\n    if (documentation == null) {\n      documentation = new LazilyInitializedDocumentation();\n    }\n\n    return true;\n  }",
    "comment": " Lazily initializes the documentation information object, but only if the JSDocInfo was told to keep such information around. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "JSDocInfo.lazyInitInfo",
    "class_name": "com.google.javascript.rhino.JSDocInfo",
    "signature": "com.google.javascript.rhino.JSDocInfo.lazyInitInfo()",
    "snippet": "  private void lazyInitInfo() {\n    if (info == null) {\n      info = new LazilyInitializedInfo();\n    }\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "JSDocInfo.setConstructor",
    "class_name": "com.google.javascript.rhino.JSDocInfo",
    "signature": "com.google.javascript.rhino.JSDocInfo.setConstructor(boolean)",
    "snippet": "  void setConstructor(boolean value) {\n    setFlag(value, MASK_CONSTRUCTOR);\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "JSDocInfo.setFlag",
    "class_name": "com.google.javascript.rhino.JSDocInfo",
    "signature": "com.google.javascript.rhino.JSDocInfo.setFlag(boolean,int)",
    "snippet": "  private void setFlag(boolean value, int mask) {\n    if (value) {\n      bitset |= mask;\n    } else {\n      bitset &= ~mask;\n    }\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "JSDocInfo.setNoSideEffects",
    "class_name": "com.google.javascript.rhino.JSDocInfo",
    "signature": "com.google.javascript.rhino.JSDocInfo.setNoSideEffects(boolean)",
    "snippet": "  void setNoSideEffects(boolean value) {\n    setFlag(value, MASK_NOSIDEEFFECTS);\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "JSDocInfo.setReturnType",
    "class_name": "com.google.javascript.rhino.JSDocInfo",
    "signature": "com.google.javascript.rhino.JSDocInfo.setReturnType(JSTypeExpression)",
    "snippet": "  void setReturnType(JSTypeExpression type) {\n    setType(type, TYPEFIELD_RETURN);\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "JSDocInfo.setSourceName",
    "class_name": "com.google.javascript.rhino.JSDocInfo",
    "signature": "com.google.javascript.rhino.JSDocInfo.setSourceName(String)",
    "snippet": "  void setSourceName(String sourceName) {\n    this.sourceName = sourceName;\n  }",
    "comment": "Sets the name of the source file that contains this JSDoc. */",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "JSDocInfo.setType",
    "class_name": "com.google.javascript.rhino.JSDocInfo",
    "signature": "com.google.javascript.rhino.JSDocInfo.setType(JSTypeExpression)",
    "snippet": "  void setType(JSTypeExpression type) {\n    setType(type, TYPEFIELD_TYPE);\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "JSDocInfo.setType",
    "class_name": "com.google.javascript.rhino.JSDocInfo",
    "signature": "com.google.javascript.rhino.JSDocInfo.setType(JSTypeExpression,int)",
    "snippet": "  private void setType(JSTypeExpression type, int mask) {\n    if ((bitset & MASK_TYPEFIELD) != 0) {\n      throw new IllegalStateException(\n          \"API tried to add two incompatible type tags. \" +\n          \"This should have been blocked and emitted a warning.\");\n    }\n    this.bitset = (bitset & MASK_FLAGS) | mask;\n    this.type = type;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "JSDocInfo.setVisibility",
    "class_name": "com.google.javascript.rhino.JSDocInfo",
    "signature": "com.google.javascript.rhino.JSDocInfo.setVisibility(Visibility)",
    "snippet": "  public void setVisibility(Visibility visibility) {\n    this.visibility = visibility;\n  }",
    "comment": "Visible for testing.",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "JSDocInfoBuilder.JSDocInfoBuilder",
    "class_name": "com.google.javascript.rhino.JSDocInfoBuilder",
    "signature": "com.google.javascript.rhino.JSDocInfoBuilder.JSDocInfoBuilder(boolean)",
    "snippet": "  public JSDocInfoBuilder(boolean parseDocumentation) {\n    this.currentInfo = new JSDocInfo(parseDocumentation);\n    this.parseDocumentation = parseDocumentation;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "JSDocInfoBuilder.build",
    "class_name": "com.google.javascript.rhino.JSDocInfoBuilder",
    "signature": "com.google.javascript.rhino.JSDocInfoBuilder.build(String)",
    "snippet": "  public JSDocInfo build(String sourceName) {\n    if (populated) {\n      JSDocInfo built = currentInfo;\n      built.setSourceName(sourceName);\n      populateDefaults(built);\n      populated = false;\n      currentInfo = new JSDocInfo(this.parseDocumentation);\n      return built;\n    } else {\n      return null;\n    }\n  }",
    "comment": " Builds a {@link JSDocInfo} object based on the populated information and returns it. Once this method is called, the builder can be reused to build another {@link JSDocInfo} object.  @param sourceName The source file containing the JSDoc. @return a {@link JSDocInfo} object populated with the values given to this builder. If no value was populated, this method simply returns {@code null} ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "JSDocInfoBuilder.hasAnySingletonTypeTags",
    "class_name": "com.google.javascript.rhino.JSDocInfoBuilder",
    "signature": "com.google.javascript.rhino.JSDocInfoBuilder.hasAnySingletonTypeTags()",
    "snippet": "  private boolean hasAnySingletonTypeTags() {\n    return currentInfo.hasType() ||\n        currentInfo.hasTypedefType() ||\n        currentInfo.hasEnumParameterType();\n  }",
    "comment": " Whether the current doc info has any of the singleton type tags that may not appear with other type tags, like {@code @type} or {@code @typedef}. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "JSDocInfoBuilder.hasAnyTypeRelatedTags",
    "class_name": "com.google.javascript.rhino.JSDocInfoBuilder",
    "signature": "com.google.javascript.rhino.JSDocInfoBuilder.hasAnyTypeRelatedTags()",
    "snippet": "  private boolean hasAnyTypeRelatedTags() {\n    return currentInfo.isConstructor() ||\n        currentInfo.isInterface() ||\n        currentInfo.getParameterCount() > 0 ||\n        currentInfo.hasReturnType() ||\n        currentInfo.hasBaseType() ||\n        currentInfo.hasThisType() ||\n        hasAnySingletonTypeTags();\n  }",
    "comment": " Whether the current doc info has other type tags, like {@code @param} or {@code @return} or {@code @type} or etc. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "JSDocInfoBuilder.isPopulated",
    "class_name": "com.google.javascript.rhino.JSDocInfoBuilder",
    "signature": "com.google.javascript.rhino.JSDocInfoBuilder.isPopulated()",
    "snippet": "  public boolean isPopulated() {\n    return populated;\n  }",
    "comment": " Returns whether this builder is populated with information that can be used to {@link #build} a {@link JSDocInfo} object. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "JSDocInfoBuilder.isPopulatedWithFileOverview",
    "class_name": "com.google.javascript.rhino.JSDocInfoBuilder",
    "signature": "com.google.javascript.rhino.JSDocInfoBuilder.isPopulatedWithFileOverview()",
    "snippet": "  public boolean isPopulatedWithFileOverview() {\n    return isPopulated() &&\n        (currentInfo.hasFileOverview() || currentInfo.isExterns());\n  }",
    "comment": " Returns whether this builder is populated with information that can be used to {@link #build} a {@link JSDocInfo} object that has a fileoverview tag. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "JSDocInfoBuilder.markAnnotation",
    "class_name": "com.google.javascript.rhino.JSDocInfoBuilder",
    "signature": "com.google.javascript.rhino.JSDocInfoBuilder.markAnnotation(String,int,int)",
    "snippet": "  public void markAnnotation(String annotation, int lineno, int charno) {\n    JSDocInfo.Marker marker = currentInfo.addMarker();\n\n    if (marker != null) {\n      marker.annotation = new JSDocInfo.StringPosition();\n      marker.annotation.setItem(annotation);\n      marker.annotation.setPositionInformation(lineno, charno, lineno,\n                                               charno + annotation.length());\n    }\n\n    currentMarker = marker;\n  }",
    "comment": " Adds a marker to the current JSDocInfo and populates the marker with the annotation information. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "JSDocInfoBuilder.markName",
    "class_name": "com.google.javascript.rhino.JSDocInfoBuilder",
    "signature": "com.google.javascript.rhino.JSDocInfoBuilder.markName(String,int,int)",
    "snippet": "  public void markName(String name, int lineno, int charno) {\n    if (currentMarker != null) {\n      currentMarker.name = new JSDocInfo.StringPosition();\n      currentMarker.name.setItem(name);\n      currentMarker.name.setPositionInformation(lineno, charno,\n                                                lineno, charno + name.length());\n    }\n  }",
    "comment": " Adds a name declaration to the current marker. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "JSDocInfoBuilder.markTypeNode",
    "class_name": "com.google.javascript.rhino.JSDocInfoBuilder",
    "signature": "com.google.javascript.rhino.JSDocInfoBuilder.markTypeNode(Node,int,int,int,boolean)",
    "snippet": "  public void markTypeNode(Node typeNode, int lineno, int startCharno, int endCharno,\n                    boolean hasLC) {\n    if (currentMarker != null) {\n      currentMarker.type = new JSDocInfo.TypePosition();\n      currentMarker.type.setItem(typeNode);\n      currentMarker.type.hasBrackets = hasLC;\n      currentMarker.type.setPositionInformation(lineno, startCharno,\n                                                lineno, endCharno);\n    }\n  }",
    "comment": " Adds a type declaration to the current marker. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "JSDocInfoBuilder.populateDefaults",
    "class_name": "com.google.javascript.rhino.JSDocInfoBuilder",
    "signature": "com.google.javascript.rhino.JSDocInfoBuilder.populateDefaults(JSDocInfo)",
    "snippet": "  private static void populateDefaults(JSDocInfo info) {\n    if (info.getVisibility() == null) {\n      info.setVisibility(Visibility.INHERITED);\n    }\n  }",
    "comment": "Generate defaults when certain parameters are not specified. */",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "JSDocInfoBuilder.recordConstructor",
    "class_name": "com.google.javascript.rhino.JSDocInfoBuilder",
    "signature": "com.google.javascript.rhino.JSDocInfoBuilder.recordConstructor()",
    "snippet": "  public boolean recordConstructor() {\n    if (!hasAnySingletonTypeTags() &&\n        !currentInfo.isConstructor() && !currentInfo.isInterface()) {\n      currentInfo.setConstructor(true);\n      populated = true;\n      return true;\n    } else {\n      return false;\n    }\n  }",
    "comment": " Records that the {@link JSDocInfo} being built should have its {@link JSDocInfo#isConstructor()} flag set to {@code true}.  @return {@code true} if the constructor was recorded and {@code false} if it was already defined or it was incompatible with the existing flags ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "JSDocInfoBuilder.recordNoSideEffects",
    "class_name": "com.google.javascript.rhino.JSDocInfoBuilder",
    "signature": "com.google.javascript.rhino.JSDocInfoBuilder.recordNoSideEffects()",
    "snippet": "  public boolean recordNoSideEffects() {\n    if (!currentInfo.isNoSideEffects()) {\n      currentInfo.setNoSideEffects(true);\n      populated = true;\n      return true;\n    } else {\n      return false;\n    }\n  }",
    "comment": " Records that the {@link JSDocInfo} being built should have its {@link JSDocInfo#isNoSideEffects()} flag set to {@code true}. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "JSDocInfoBuilder.recordParameter",
    "class_name": "com.google.javascript.rhino.JSDocInfoBuilder",
    "signature": "com.google.javascript.rhino.JSDocInfoBuilder.recordParameter(String,JSTypeExpression)",
    "snippet": "  public boolean recordParameter(String parameterName, JSTypeExpression type) {\n    if (!hasAnySingletonTypeTags() &&\n        currentInfo.declareParam(type, parameterName)) {\n      populated = true;\n      return true;\n    } else {\n      return false;\n    }\n  }",
    "comment": " Records a typed parameter.  @return {@code true} if the typed parameter was recorded and {@code false} if a parameter with the same name was already defined ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "JSDocInfoBuilder.recordReturnType",
    "class_name": "com.google.javascript.rhino.JSDocInfoBuilder",
    "signature": "com.google.javascript.rhino.JSDocInfoBuilder.recordReturnType(JSTypeExpression)",
    "snippet": "  public boolean recordReturnType(JSTypeExpression jsType) {\n    if (jsType != null && currentInfo.getReturnType() == null &&\n        !hasAnySingletonTypeTags()) {\n      currentInfo.setReturnType(jsType);\n      populated = true;\n      return true;\n    } else {\n      return false;\n    }\n  }",
    "comment": " Records a return type.  @return {@code true} if the return type was recorded and {@code false} if it is invalid or was already defined ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "JSDocInfoBuilder.recordType",
    "class_name": "com.google.javascript.rhino.JSDocInfoBuilder",
    "signature": "com.google.javascript.rhino.JSDocInfoBuilder.recordType(JSTypeExpression)",
    "snippet": "  public boolean recordType(JSTypeExpression type) {\n    if (type != null && !hasAnyTypeRelatedTags()) {\n      currentInfo.setType(type);\n      populated = true;\n      return true;\n    } else {\n      return false;\n    }\n  }",
    "comment": " Records a type.  @return {@code true} if the type was recorded and {@code false} if it is invalid or was already defined ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "JSTypeExpression.JSTypeExpression",
    "class_name": "com.google.javascript.rhino.JSTypeExpression",
    "signature": "com.google.javascript.rhino.JSTypeExpression.JSTypeExpression(Node,String,JSTypeRegistry)",
    "snippet": "  public JSTypeExpression(Node root, String sourceName,\n      JSTypeRegistry registry) {\n    this.root = root;\n    this.sourceName = sourceName;\n    this.registry = registry;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "JSTypeExpression.isOptionalArg",
    "class_name": "com.google.javascript.rhino.JSTypeExpression",
    "signature": "com.google.javascript.rhino.JSTypeExpression.isOptionalArg()",
    "snippet": "  public boolean isOptionalArg() {\n    return root.getType() == Token.EQUALS;\n  }",
    "comment": " @return Whether this expression denotes an optional {@code @param}. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "JSTypeExpression.isVarArgs",
    "class_name": "com.google.javascript.rhino.JSTypeExpression",
    "signature": "com.google.javascript.rhino.JSTypeExpression.isVarArgs()",
    "snippet": "  public boolean isVarArgs() {\n    return root.getType() == Token.ELLIPSIS;\n  }",
    "comment": " @return Whether this expression denotes a rest args {@code @param}. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "Node.Node",
    "class_name": "com.google.javascript.rhino.Node",
    "signature": "com.google.javascript.rhino.Node.Node(int)",
    "snippet": "    public Node(int nodeType) {\n        type = nodeType;\n        parent = null;\n        sourcePosition = -1;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "Node.Node",
    "class_name": "com.google.javascript.rhino.Node",
    "signature": "com.google.javascript.rhino.Node.Node(int,Node)",
    "snippet": "    public Node(int nodeType, Node child) {\n        Preconditions.checkArgument(child.parent == null,\n            \"new child has existing parent\");\n        Preconditions.checkArgument(child.next == null,\n            \"new child has existing sibling\");\n\n        type = nodeType;\n        parent = null;\n        first = last = child;\n        child.next = null;\n        child.parent = this;\n        sourcePosition = -1;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "Node.Node",
    "class_name": "com.google.javascript.rhino.Node",
    "signature": "com.google.javascript.rhino.Node.Node(int,Node,Node)",
    "snippet": "    public Node(int nodeType, Node left, Node right) {\n        Preconditions.checkArgument(left.parent == null,\n            \"first new child has existing parent\");\n        Preconditions.checkArgument(left.next == null,\n            \"first new child has existing sibling\");\n        Preconditions.checkArgument(right.parent == null,\n            \"second new child has existing parent\");\n        Preconditions.checkArgument(right.next == null,\n            \"second new child has existing sibling\");\n        type = nodeType;\n        parent = null;\n        first = left;\n        last = right;\n        left.next = right;\n        left.parent = this;\n        right.next = null;\n        right.parent = this;\n        sourcePosition = -1;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "Node.Node",
    "class_name": "com.google.javascript.rhino.Node",
    "signature": "com.google.javascript.rhino.Node.Node(int,Node,Node,int,int)",
    "snippet": "    public Node(int nodeType, Node left, Node right, int lineno, int charno) {\n        this(nodeType, left, right);\n        sourcePosition = mergeLineCharNo(lineno, charno);\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "Node.Node",
    "class_name": "com.google.javascript.rhino.Node",
    "signature": "com.google.javascript.rhino.Node.Node(int,Node,int,int)",
    "snippet": "    public Node(int nodeType, Node child, int lineno, int charno) {\n        this(nodeType, child);\n        sourcePosition = mergeLineCharNo(lineno, charno);\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "Node.Node",
    "class_name": "com.google.javascript.rhino.Node",
    "signature": "com.google.javascript.rhino.Node.Node(int,int,int)",
    "snippet": "    public Node(int nodeType, int lineno, int charno) {\n        type = nodeType;\n        parent = null;\n        sourcePosition = mergeLineCharNo(lineno, charno);\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "Node.addChildAfter",
    "class_name": "com.google.javascript.rhino.Node",
    "signature": "com.google.javascript.rhino.Node.addChildAfter(Node,Node)",
    "snippet": "    public void addChildAfter(Node newChild, Node node) {\n        Preconditions.checkArgument(newChild.next == null,\n            \"The new child node has siblings.\");\n        Preconditions.checkArgument(newChild.parent == null,\n            \"The new child node already has a parent.\");\n        newChild.parent = this;\n        newChild.next = node.next;\n        node.next = newChild;\n        if (last == node) {\n            last = newChild;\n        }\n    }",
    "comment": " Add 'child' after 'node'. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "Node.addChildBefore",
    "class_name": "com.google.javascript.rhino.Node",
    "signature": "com.google.javascript.rhino.Node.addChildBefore(Node,Node)",
    "snippet": "    public void addChildBefore(Node newChild, Node node) {\n        Preconditions.checkArgument(node != null,\n            \"The existing child node of the parent should not be null.\");\n        Preconditions.checkArgument(newChild.next == null,\n            \"The new child node has siblings.\");\n        Preconditions.checkArgument(newChild.parent == null,\n            \"The new child node already has a parent.\");\n        if (first == node) {\n            newChild.parent = this;\n            newChild.next = first;\n            first = newChild;\n            return;\n        }\n        Node prev = getChildBefore(node);\n        addChildAfter(newChild, prev);\n    }",
    "comment": " Add 'child' before 'node'. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "Node.addChildToBack",
    "class_name": "com.google.javascript.rhino.Node",
    "signature": "com.google.javascript.rhino.Node.addChildToBack(Node)",
    "snippet": "    public void addChildToBack(Node child) {\n        Preconditions.checkArgument(child.parent == null);\n        Preconditions.checkArgument(child.next == null);\n        child.parent = this;\n        child.next = null;\n        if (last == null) {\n            first = last = child;\n            return;\n        }\n        last.next = child;\n        last = child;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "Node.appendStringTree",
    "class_name": "com.google.javascript.rhino.Node",
    "signature": "com.google.javascript.rhino.Node.appendStringTree(Appendable)",
    "snippet": "    public void appendStringTree(Appendable appendable) throws IOException {\n        toStringTreeHelper(this, 0, appendable);\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "Node.checkTreeEquals",
    "class_name": "com.google.javascript.rhino.Node",
    "signature": "com.google.javascript.rhino.Node.checkTreeEquals(Node)",
    "snippet": "    public String checkTreeEquals(Node node2) {\n        NodeMismatch diff = checkTreeEqualsImpl(node2);\n        if (diff != null) {\n          return \"Node tree inequality:\" +\n              \"\\nTree1:\\n\" + toStringTree() +\n              \"\\n\\nTree2:\\n\" + node2.toStringTree();\n        }\n        return null;\n    }",
    "comment": " Checks if the subtree under this node is the same as another subtree. Returns null if it's equal, or a message describing the differences. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "Node.checkTreeEqualsImpl",
    "class_name": "com.google.javascript.rhino.Node",
    "signature": "com.google.javascript.rhino.Node.checkTreeEqualsImpl(Node)",
    "snippet": "    NodeMismatch checkTreeEqualsImpl(Node node2) {\n        boolean eq = false;\n\n        if (type == node2.getType() &&\n            getChildCount() == node2.getChildCount() &&\n            getClass() == node2.getClass()) {\n\n            eq = this.isEquivalentTo(node2);\n        }\n\n        if (!eq) {\n            return new NodeMismatch(this, node2);\n        }\n\n        NodeMismatch res = null;\n        Node n, n2;\n        for (n = first, n2 = node2.first;\n             res == null && n != null;\n             n = n.next, n2 = n2.next) {\n            res = n.checkTreeEqualsImpl(n2);\n            if (res != null) {\n              return res;\n            }\n        }\n        return res;\n    }",
    "comment": " Compare this node to node2 recursively and return the first pair of nodes that differs doing a preorder depth-first traversal. Package private for testing. Returns null if the nodes are equivalent. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "Node.copyInformationFrom",
    "class_name": "com.google.javascript.rhino.Node",
    "signature": "com.google.javascript.rhino.Node.copyInformationFrom(Node)",
    "snippet": "    public void copyInformationFrom(Node other) {\n        if (getProp(ORIGINALNAME_PROP) == null) {\n            putProp(ORIGINALNAME_PROP, other.getProp(ORIGINALNAME_PROP));\n        }\n\n        if (getProp(SOURCEFILE_PROP) == null) {\n            putProp(SOURCEFILE_PROP, other.getProp(SOURCEFILE_PROP));\n            sourcePosition = other.sourcePosition;\n        }\n    }",
    "comment": " Copies source file and name information from the other node given to the current node. Used for maintaining debug information across node append and remove operations. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "Node.copyInformationFromForTree",
    "class_name": "com.google.javascript.rhino.Node",
    "signature": "com.google.javascript.rhino.Node.copyInformationFromForTree(Node)",
    "snippet": "    public void copyInformationFromForTree(Node other) {\n      copyInformationFrom(other);\n      for (Node child = getFirstChild();\n           child != null; child = child.getNext()) {\n        child.copyInformationFromForTree(other);\n      }\n    }",
    "comment": " Copies source file and name information from the other node to the entire tree rooted at this node. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "Node.detachFromParent",
    "class_name": "com.google.javascript.rhino.Node",
    "signature": "com.google.javascript.rhino.Node.detachFromParent()",
    "snippet": "    public Node detachFromParent() {\n      Preconditions.checkState(parent != null);\n      parent.removeChild(this);\n      return this;\n    }",
    "comment": " Removes this node from its parent.  Equivalent to: node.getParent().removeChild(); ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "Node.ensureProperty",
    "class_name": "com.google.javascript.rhino.Node",
    "signature": "com.google.javascript.rhino.Node.ensureProperty(int)",
    "snippet": "    private PropListItem ensureProperty(int propType)\n    {\n        PropListItem item = lookupProperty(propType);\n        if (item == null) {\n            item = new PropListItem();\n            item.type = propType;\n            item.next = propListHead;\n            propListHead = item;\n        }\n        return item;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "Node.extractCharno",
    "class_name": "com.google.javascript.rhino.Node",
    "signature": "com.google.javascript.rhino.Node.extractCharno(int)",
    "snippet": "    protected static int extractCharno(int lineCharNo) {\n      if (lineCharNo == -1) {\n        return -1;\n      } else {\n        return lineCharNo & COLUMN_MASK;\n      }\n    }",
    "comment": " Extracts the character number and character number from a merged line char number (see {@link #mergeLineCharNo(int, int)}). ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "Node.extractLineno",
    "class_name": "com.google.javascript.rhino.Node",
    "signature": "com.google.javascript.rhino.Node.extractLineno(int)",
    "snippet": "    protected static int extractLineno(int lineCharNo) {\n      if (lineCharNo == -1) {\n        return -1;\n      } else {\n        return lineCharNo >>> COLUMN_BITS;\n      }\n    }",
    "comment": " Extracts the line number and character number from a merged line char number (see {@link #mergeLineCharNo(int, int)}). ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "Node.getBooleanProp",
    "class_name": "com.google.javascript.rhino.Node",
    "signature": "com.google.javascript.rhino.Node.getBooleanProp(int)",
    "snippet": "    public boolean getBooleanProp(int propType) {\n        return getIntProp(propType, 0) != 0;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "Node.getCharno",
    "class_name": "com.google.javascript.rhino.Node",
    "signature": "com.google.javascript.rhino.Node.getCharno()",
    "snippet": "    public int getCharno() {\n        return extractCharno(sourcePosition);\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "Node.getChildBefore",
    "class_name": "com.google.javascript.rhino.Node",
    "signature": "com.google.javascript.rhino.Node.getChildBefore(Node)",
    "snippet": "    public Node getChildBefore(Node child) {\n        if (child == first)\n            return null;\n        Node n = first;\n        while (n.next != child) {\n            n = n.next;\n            if (n == null)\n                throw new RuntimeException(\"node is not a child\");\n        }\n        return n;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "Node.getChildCount",
    "class_name": "com.google.javascript.rhino.Node",
    "signature": "com.google.javascript.rhino.Node.getChildCount()",
    "snippet": "    public int getChildCount() {\n        int c = 0;\n        for (Node n = first; n != null; n = n.next)\n            c++;\n\n        return c;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "Node.getFirstChild",
    "class_name": "com.google.javascript.rhino.Node",
    "signature": "com.google.javascript.rhino.Node.getFirstChild()",
    "snippet": "    public Node getFirstChild() {\n        return first;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "Node.getIntProp",
    "class_name": "com.google.javascript.rhino.Node",
    "signature": "com.google.javascript.rhino.Node.getIntProp(int,int)",
    "snippet": "    public int getIntProp(int propType, int defaultValue)\n    {\n        PropListItem item = lookupProperty(propType);\n        if (item == null) { return defaultValue; }\n        return item.intValue;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "Node.getJSDocInfo",
    "class_name": "com.google.javascript.rhino.Node",
    "signature": "com.google.javascript.rhino.Node.getJSDocInfo()",
    "snippet": "    public JSDocInfo getJSDocInfo()\n    {\n        return (JSDocInfo) getProp(JSDOC_INFO_PROP);\n    }",
    "comment": " Get the {@link JSDocInfo} attached to this node. @return the information or {@code null} if no JSDoc is attached to this node ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "Node.getJSType",
    "class_name": "com.google.javascript.rhino.Node",
    "signature": "com.google.javascript.rhino.Node.getJSType()",
    "snippet": "    public JSType getJSType() {\n        return jsType;\n    }",
    "comment": "Custom annotations",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "Node.getJsDocBuilderForNode",
    "class_name": "com.google.javascript.rhino.Node",
    "signature": "com.google.javascript.rhino.Node.getJsDocBuilderForNode()",
    "snippet": "    public FileLevelJsDocBuilder getJsDocBuilderForNode() {\n      return new FileLevelJsDocBuilder();\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "Node.getLastChild",
    "class_name": "com.google.javascript.rhino.Node",
    "signature": "com.google.javascript.rhino.Node.getLastChild()",
    "snippet": "    public Node getLastChild() {\n        return last;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "Node.getLineno",
    "class_name": "com.google.javascript.rhino.Node",
    "signature": "com.google.javascript.rhino.Node.getLineno()",
    "snippet": "    public int getLineno() {\n        return extractLineno(sourcePosition);\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "Node.getNext",
    "class_name": "com.google.javascript.rhino.Node",
    "signature": "com.google.javascript.rhino.Node.getNext()",
    "snippet": "    public Node getNext() {\n        return next;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "Node.getParent",
    "class_name": "com.google.javascript.rhino.Node",
    "signature": "com.google.javascript.rhino.Node.getParent()",
    "snippet": "    public Node getParent() {\n        return parent;\n    }",
    "comment": "Accessors",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "Node.getProp",
    "class_name": "com.google.javascript.rhino.Node",
    "signature": "com.google.javascript.rhino.Node.getProp(int)",
    "snippet": "    public Object getProp(int propType)\n    {\n        PropListItem item = lookupProperty(propType);\n        if (item == null) { return null; }\n        return item.objectValue;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "Node.getQualifiedName",
    "class_name": "com.google.javascript.rhino.Node",
    "signature": "com.google.javascript.rhino.Node.getQualifiedName()",
    "snippet": "    public String getQualifiedName() {\n        if (type == Token.NAME) {\n            return getString();\n        } else if (type == Token.GETPROP) {\n            String left = getFirstChild().getQualifiedName();\n            if (left == null) {\n              return null;\n            }\n            return left + \".\" + getLastChild().getString();\n        } else if (type == Token.THIS) {\n             return \"this\";\n        } else {\n            return null;\n\n        }\n\n    }",
    "comment": " This function takes a set of GETPROP nodes and produces a string that is each property separated by dots.  If the node ultimately under the left sub-tree is not a simple name, this is not a valid qualified name.  @return a null if this is not a qualified name, or a dot-separated string of the name and properties. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "Node.getSortedPropTypes",
    "class_name": "com.google.javascript.rhino.Node",
    "signature": "com.google.javascript.rhino.Node.getSortedPropTypes()",
    "snippet": "    private int[] getSortedPropTypes() {\n        int count = 0;\n        for (PropListItem x = propListHead; x != null; x = x.next) {\n            count++;\n        }\n\n        int[] keys = new int[count];\n        for (PropListItem x = propListHead; x != null; x = x.next) {\n            count--;\n            keys[count] = x.type;\n        }\n\n        Arrays.sort(keys);\n        return keys;\n    }",
    "comment": "Gets all the property types, in sorted order.",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "Node.getType",
    "class_name": "com.google.javascript.rhino.Node",
    "signature": "com.google.javascript.rhino.Node.getType()",
    "snippet": "    public int getType() {\n        return type;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "Node.hasChildren",
    "class_name": "com.google.javascript.rhino.Node",
    "signature": "com.google.javascript.rhino.Node.hasChildren()",
    "snippet": "    public boolean hasChildren() {\n        return first != null;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "Node.hasOneChild",
    "class_name": "com.google.javascript.rhino.Node",
    "signature": "com.google.javascript.rhino.Node.hasOneChild()",
    "snippet": "    public boolean hasOneChild() {\n      return first != null && first == last;\n    }",
    "comment": " Check for one child more efficiently than by iterating over all the children as is done with Node.getChildCount(). @return Whether the node has exactly one child. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "Node.isEquivalentTo",
    "class_name": "com.google.javascript.rhino.Node",
    "signature": "com.google.javascript.rhino.Node.isEquivalentTo(Node)",
    "snippet": "    public boolean isEquivalentTo(Node node) {\n        if (type == Token.ARRAYLIT) {\n            try {\n                int[] indices1 = (int[])getProp(Node.SKIP_INDEXES_PROP);\n                int[] indices2 = (int[])node.getProp(Node.SKIP_INDEXES_PROP);\n                if (indices1 == null) {\n                    if (indices2 != null)\n                        return false;\n                } else if (indices2 == null) {\n                    return false;\n                } else if (indices1.length != indices2.length) {\n                    return false;\n                } else {\n                    for (int i = 0; i < indices1.length; i++) {\n                        if (indices1[i] != indices2[i])\n                            return false;\n                    }\n                }\n            } catch (Exception e) {\n                return false;\n            }\n        } else if (type == Token.INC ||\n                   type == Token.DEC) {\n            int post1 = this.getIntProp(INCRDECR_PROP, 0);\n            int post2 = node.getIntProp(INCRDECR_PROP, 0);\n            if (post1 != post2)\n                return false;\n        } else if (type == Token.STRING) {\n            int quoted1 = this.getIntProp(QUOTED_PROP, 0);\n            int quoted2 = node.getIntProp(QUOTED_PROP, 0);\n            if (quoted1 != quoted2)\n                return false;\n        }\n        return true;\n    }",
    "comment": "Returns true if this node is equivalent semantically to another */",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "Node.isNoSideEffectsCall",
    "class_name": "com.google.javascript.rhino.Node",
    "signature": "com.google.javascript.rhino.Node.isNoSideEffectsCall()",
    "snippet": "    public boolean isNoSideEffectsCall() {\n        return getBooleanProp(NO_SIDE_EFFECTS_CALL);\n    }",
    "comment": " Returns true if this node is a function or constructor call that has no side effects. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "Node.isQualifiedName",
    "class_name": "com.google.javascript.rhino.Node",
    "signature": "com.google.javascript.rhino.Node.isQualifiedName()",
    "snippet": "    public boolean isQualifiedName() {\n        switch (getType()) {\n            case Token.NAME:\n            case Token.THIS:\n                return true;\n            case Token.GETPROP:\n                return getFirstChild().isQualifiedName();\n            default:\n                return false;\n        }\n    }",
    "comment": " Returns whether a node corresponds to a simple or a qualified name, such as <code>x</code> or <code>a.b.c</code> or <code>this.a</code>. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "Node.isSyntheticBlock",
    "class_name": "com.google.javascript.rhino.Node",
    "signature": "com.google.javascript.rhino.Node.isSyntheticBlock()",
    "snippet": "    public boolean isSyntheticBlock() {\n        return getBooleanProp(SYNTHETIC_BLOCK_PROP);\n    }",
    "comment": " Returns whether this is a synthetic block that should not be considered a real source block. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "Node.lookupProperty",
    "class_name": "com.google.javascript.rhino.Node",
    "signature": "com.google.javascript.rhino.Node.lookupProperty(int)",
    "snippet": "    private PropListItem lookupProperty(int propType)\n    {\n        PropListItem x = propListHead;\n        while (x != null && propType != x.type) {\n            x = x.next;\n        }\n        return x;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "Node.mergeLineCharNo",
    "class_name": "com.google.javascript.rhino.Node",
    "signature": "com.google.javascript.rhino.Node.mergeLineCharNo(int,int)",
    "snippet": "    protected static int mergeLineCharNo(int lineno, int charno) {\n      if (lineno < 0 || charno < 0) {\n        return -1;\n      } else if ((charno & ~COLUMN_MASK) != 0) {\n        return lineno << COLUMN_BITS | COLUMN_MASK;\n      } else {\n        return lineno << COLUMN_BITS | (charno & COLUMN_MASK);\n      }\n    }",
    "comment": " Merges the line number and character number in one integer. The Character number takes the first 12 bits and the line number takes the rest. If the character number is greater than <code>2<sup>12</sup>-1</code> it is adjusted to <code>2<sup>12</sup>-1</code>. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "Node.newString",
    "class_name": "com.google.javascript.rhino.Node",
    "signature": "com.google.javascript.rhino.Node.newString(String)",
    "snippet": "    public static Node newString(String str) {\n        return new StringNode(Token.STRING, str);\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "Node.newString",
    "class_name": "com.google.javascript.rhino.Node",
    "signature": "com.google.javascript.rhino.Node.newString(String,int,int)",
    "snippet": "    public static Node newString(String str, int lineno, int charno) {\n        return new StringNode(Token.STRING, str, lineno, charno);\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "Node.newString",
    "class_name": "com.google.javascript.rhino.Node",
    "signature": "com.google.javascript.rhino.Node.newString(int,String)",
    "snippet": "    public static Node newString(int type, String str) {\n        return new StringNode(type, str);\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "Node.newString",
    "class_name": "com.google.javascript.rhino.Node",
    "signature": "com.google.javascript.rhino.Node.newString(int,String,int,int)",
    "snippet": "    public static Node newString(int type, String str, int lineno, int charno) {\n        return new StringNode(type, str, lineno, charno);\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "Node.propToString",
    "class_name": "com.google.javascript.rhino.Node",
    "signature": "com.google.javascript.rhino.Node.propToString(int)",
    "snippet": "    private static final String propToString(int propType) {\n        switch (propType) {\n            case LOCAL_BLOCK_PROP:   return \"local_block\";\n            case OBJECT_IDS_PROP:    return \"object_ids_prop\";\n            case CATCH_SCOPE_PROP:   return \"catch_scope_prop\";\n            case LABEL_ID_PROP:      return \"label_id_prop\";\n            case TARGET_PROP:        return \"target\";\n            case BREAK_PROP:         return \"break\";\n            case CONTINUE_PROP:      return \"continue\";\n            case ENUM_PROP:          return \"enum\";\n            case FUNCTION_PROP:      return \"function\";\n            case TEMP_PROP:          return \"temp\";\n            case LOCAL_PROP:         return \"local\";\n            case CODEOFFSET_PROP:    return \"codeoffset\";\n            case FIXUPS_PROP:        return \"fixups\";\n            case VARS_PROP:          return \"vars\";\n            case USES_PROP:          return \"uses\";\n            case REGEXP_PROP:        return \"regexp\";\n            case CASES_PROP:         return \"cases\";\n            case DEFAULT_PROP:       return \"default\";\n            case CASEARRAY_PROP:     return \"casearray\";\n            case SOURCENAME_PROP:    return \"sourcename\";\n            case TYPE_PROP:          return \"type\";\n            case SPECIAL_PROP_PROP:  return \"special_prop\";\n            case LABEL_PROP:         return \"label\";\n            case FINALLY_PROP:       return \"finally\";\n            case LOCALCOUNT_PROP:    return \"localcount\";\n\n            case TARGETBLOCK_PROP:   return \"targetblock\";\n            case VARIABLE_PROP:      return \"variable\";\n            case LASTUSE_PROP:       return \"lastuse\";\n            case ISNUMBER_PROP:      return \"isnumber\";\n            case DIRECTCALL_PROP:    return \"directcall\";\n\n            case SPECIALCALL_PROP:   return \"specialcall\";\n            case DEBUGSOURCE_PROP:   return \"debugsource\";\n\n            case JSDOC_INFO_PROP:    return \"jsdoc_info\";\n\n            case SKIP_INDEXES_PROP:  return \"skip_indexes\";\n            case INCRDECR_PROP:      return \"incrdecr\";\n            case MEMBER_TYPE_PROP:   return \"member_type\";\n            case NAME_PROP:          return \"name\";\n            case PARENTHESIZED_PROP: return \"parenthesized\";\n            case QUOTED_PROP:        return \"quoted\";\n\n            case SYNTHETIC_BLOCK_PROP: return \"synthetic\";\n            case SOURCEFILE_PROP: return \"sourcefile\";\n            case EMPTY_BLOCK: return \"empty_block\";\n            case ORIGINALNAME_PROP: return \"originalname\";\n            case NO_SIDE_EFFECTS_CALL: return \"no_side_effects_call\";\n\n            case IS_CONSTANT_NAME:   return \"is_constant_name\";\n            case IS_OPTIONAL_PARAM:  return \"is_optional_param\";\n            case IS_VAR_ARGS_PARAM:  return \"is_var_args_param\";\n            case IS_NAMESPACE:       return \"is_namespace\";\n            case IS_DISPATCHER:      return \"is_dispatcher\";\n            case DIRECTIVES:         return \"directives\";\n            case DIRECT_EVAL:        return \"direct_eval\";\n            default:\n              Kit.codeBug();\n\n\n        }\n        return null;\n    }",
    "comment": "x..y or x..@i",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "Node.putBooleanProp",
    "class_name": "com.google.javascript.rhino.Node",
    "signature": "com.google.javascript.rhino.Node.putBooleanProp(int,boolean)",
    "snippet": "    public void putBooleanProp(int propType, boolean prop) {\n        putIntProp(propType, prop ? 1 : 0);\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "Node.putIntProp",
    "class_name": "com.google.javascript.rhino.Node",
    "signature": "com.google.javascript.rhino.Node.putIntProp(int,int)",
    "snippet": "    public void putIntProp(int propType, int prop)\n    {\n        PropListItem item = ensureProperty(propType);\n        item.intValue = prop;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "Node.putProp",
    "class_name": "com.google.javascript.rhino.Node",
    "signature": "com.google.javascript.rhino.Node.putProp(int,Object)",
    "snippet": "    public void putProp(int propType, Object prop)\n    {\n        if (prop == null) {\n            removeProp(propType);\n        } else {\n            PropListItem item = ensureProperty(propType);\n            item.objectValue = prop;\n        }\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "Node.removeChild",
    "class_name": "com.google.javascript.rhino.Node",
    "signature": "com.google.javascript.rhino.Node.removeChild(Node)",
    "snippet": "    public void removeChild(Node child) {\n        Node prev = getChildBefore(child);\n        if (prev == null)\n            first = first.next;\n        else\n            prev.next = child.next;\n        if (child == last) last = prev;\n        child.next = null;\n        child.parent = null;\n    }",
    "comment": " Detach a child from its parent and siblings. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "Node.removeProp",
    "class_name": "com.google.javascript.rhino.Node",
    "signature": "com.google.javascript.rhino.Node.removeProp(int)",
    "snippet": "    public void removeProp(int propType)\n    {\n        PropListItem x = propListHead;\n        if (x != null) {\n            PropListItem prev = null;\n            while (x.type != propType) {\n                prev = x;\n                x = x.next;\n                if (x == null) { return; }\n            }\n            if (prev == null) {\n                propListHead = x.next;\n            } else {\n                prev.next = x.next;\n            }\n        }\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "Node.setCharno",
    "class_name": "com.google.javascript.rhino.Node",
    "signature": "com.google.javascript.rhino.Node.setCharno(int)",
    "snippet": "    public void setCharno(int charno) {\n        sourcePosition = mergeLineCharNo(getLineno(), charno);\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "Node.setIsSyntheticBlock",
    "class_name": "com.google.javascript.rhino.Node",
    "signature": "com.google.javascript.rhino.Node.setIsSyntheticBlock(boolean)",
    "snippet": "    public void setIsSyntheticBlock(boolean val) {\n        putBooleanProp(SYNTHETIC_BLOCK_PROP, val);\n    }",
    "comment": " Sets whether this is a synthetic block that should not be considered a real source block. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "Node.setJSDocInfo",
    "class_name": "com.google.javascript.rhino.Node",
    "signature": "com.google.javascript.rhino.Node.setJSDocInfo(JSDocInfo)",
    "snippet": "    public void setJSDocInfo(JSDocInfo info)\n    {\n        putProp(JSDOC_INFO_PROP, info);\n    }",
    "comment": " Sets the {@link JSDocInfo} attached to this node. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "Node.setJSType",
    "class_name": "com.google.javascript.rhino.Node",
    "signature": "com.google.javascript.rhino.Node.setJSType(JSType)",
    "snippet": "    public void setJSType(JSType jsType) {\n        this.jsType = jsType;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "Node.setLineno",
    "class_name": "com.google.javascript.rhino.Node",
    "signature": "com.google.javascript.rhino.Node.setLineno(int)",
    "snippet": "    public void setLineno(int lineno) {\n        int charno = getCharno();\n        if (charno == -1) {\n          charno = 0;\n        }\n        sourcePosition = mergeLineCharNo(lineno, charno);\n    }",
    "comment": "Source position management",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "Node.setOptionalArg",
    "class_name": "com.google.javascript.rhino.Node",
    "signature": "com.google.javascript.rhino.Node.setOptionalArg(boolean)",
    "snippet": "    public void setOptionalArg(boolean optionalArg)\n    {\n        putBooleanProp(OPT_ARG_NAME, optionalArg);\n    }",
    "comment": " Sets whether this node is an optional argument node. This method is meaningful only on {@link Token#NAME} nodes used to define a {@link Token#FUNCTION}'s argument list. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "Node.setType",
    "class_name": "com.google.javascript.rhino.Node",
    "signature": "com.google.javascript.rhino.Node.setType(int)",
    "snippet": "    public void setType(int type) {\n        this.type = type;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "Node.setVarArgs",
    "class_name": "com.google.javascript.rhino.Node",
    "signature": "com.google.javascript.rhino.Node.setVarArgs(boolean)",
    "snippet": "    public void setVarArgs(boolean varArgs)\n    {\n        putBooleanProp(VAR_ARGS_NAME, varArgs);\n    }",
    "comment": " Sets whether this node is a variable length argument node. This method is meaningful only on {@link Token#NAME} nodes used to define a {@link Token#FUNCTION}'s argument list. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "Node.toString",
    "class_name": "com.google.javascript.rhino.Node",
    "signature": "com.google.javascript.rhino.Node.toString()",
    "snippet": "    @Override public String toString()\n    {\n       return toString(true, true, true);\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "Node.toString",
    "class_name": "com.google.javascript.rhino.Node",
    "signature": "com.google.javascript.rhino.Node.toString(StringBuilder,boolean,boolean,boolean)",
    "snippet": "    private void toString(\n        StringBuilder sb,\n        boolean printSource,\n        boolean printAnnotations,\n        boolean printType)\n    {\n        if (Token.printTrees) {\n            sb.append(Token.name(type));\n            if (this instanceof StringNode) {\n                sb.append(' ');\n                sb.append(getString());\n            } else if (type == Token.FUNCTION) {\n                sb.append(' ');\n                sb.append(first.getString());\n            } else if (this instanceof ScriptOrFnNode) {\n                ScriptOrFnNode sof = (ScriptOrFnNode)this;\n                if (this instanceof FunctionNode) {\n                    FunctionNode fn = (FunctionNode)this;\n                    sb.append(' ');\n                    sb.append(fn.getFunctionName());\n                }\n                if (printSource) {\n                  sb.append(\" [source name: \");\n                  sb.append(sof.getSourceName());\n                  sb.append(\"] [encoded source length: \");\n                  sb.append(sof.getEncodedSourceEnd()\n                            - sof.getEncodedSourceStart());\n                  sb.append(\"] [base line: \");\n                  sb.append(sof.getBaseLineno());\n                  sb.append(\"] [end line: \");\n                  sb.append(sof.getEndLineno());\n                  sb.append(']');\n                }\n            } else if (type == Token.NUMBER) {\n                sb.append(' ');\n                sb.append(getDouble());\n            }\n            if (printSource) {\n              int lineno = getLineno();\n              if (lineno != -1) {\n                  sb.append(' ');\n                  sb.append(lineno);\n              }\n            }\n\n            if (printAnnotations) {\n              int[] keys = getSortedPropTypes();\n              for (int i = 0; i < keys.length; i++) {\n                  int type = keys[i];\n                  PropListItem x = lookupProperty(type);\n                  sb.append(\" [\");\n                  sb.append(propToString(type));\n                  sb.append(\": \");\n                  String value;\n                  switch (type) {\n                    case TARGETBLOCK_PROP : // can't add this as it recurses\n                      value = \"target block property\";\n                      break;\n                    case LOCAL_BLOCK_PROP :     // can't add this as it is dull\n                      value = \"last local block\";\n                      break;\n                    case ISNUMBER_PROP:\n                      switch (x.intValue) {\n                        case BOTH:\n                          value = \"both\";\n                          break;\n                        case RIGHT:\n                          value = \"right\";\n                          break;\n                        case LEFT:\n                          value = \"left\";\n                          break;\n                        default:\n                          throw Kit.codeBug();\n                      }\n                      break;\n                    case SPECIALCALL_PROP:\n                      switch (x.intValue) {\n                        case SPECIALCALL_EVAL:\n                          value = \"eval\";\n                          break;\n                        case SPECIALCALL_WITH:\n                          value = \"with\";\n                          break;\n                        default:\n                          // NON_SPECIALCALL should not be stored\n                          throw Kit.codeBug();\n                      }\n                      break;\n                    default :\n                      Object obj = x.objectValue;\n                      if (obj != null) {\n                          value = obj.toString();\n                      } else {\n                          value = String.valueOf(x.intValue);\n                      }\n                      break;\n                  }\n                  sb.append(value);\n                  sb.append(']');\n              }\n            }\n\n            if (printType) {\n              if (jsType != null) {\n                  String jsTypeString = jsType.toString();\n                  if (jsTypeString != null) {\n                      sb.append(\" : \");\n                      sb.append(jsTypeString);\n                  }\n              }\n            }\n        }\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "Node.toString",
    "class_name": "com.google.javascript.rhino.Node",
    "signature": "com.google.javascript.rhino.Node.toString(boolean,boolean,boolean)",
    "snippet": "    public String toString(\n        boolean printSource,\n        boolean printAnnotations,\n        boolean printType)\n    {\n        if (Token.printTrees) {\n            StringBuilder sb = new StringBuilder();\n            toString(sb, printSource, printAnnotations, printType);\n            return sb.toString();\n        }\n        return String.valueOf(type);\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "Node.toStringTree",
    "class_name": "com.google.javascript.rhino.Node",
    "signature": "com.google.javascript.rhino.Node.toStringTree()",
    "snippet": "    public String toStringTree() {\n        return toStringTreeImpl();\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "Node.toStringTreeHelper",
    "class_name": "com.google.javascript.rhino.Node",
    "signature": "com.google.javascript.rhino.Node.toStringTreeHelper(Node,int,Appendable)",
    "snippet": "    private static void toStringTreeHelper(Node n, int level, Appendable sb)\n            throws IOException\n    {\n        if (Token.printTrees) {\n            for (int i = 0; i != level; ++i) {\n                sb.append(\"    \");\n            }\n            sb.append(n.toString());\n            sb.append('\\n');\n            for (Node cursor = n.getFirstChild(); cursor != null;\n                 cursor = cursor.getNext())\n            {\n                toStringTreeHelper(cursor, level + 1, sb);\n            }\n        }\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "Node.toStringTreeImpl",
    "class_name": "com.google.javascript.rhino.Node",
    "signature": "com.google.javascript.rhino.Node.toStringTreeImpl()",
    "snippet": "    private String toStringTreeImpl() {\n        try {\n            StringBuffer s = new StringBuffer();\n            appendStringTree(s);\n            return s.toString();\n        } catch (IOException e) {\n            throw new RuntimeException(\"Should not happen\\n\" + e);\n        }\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "StringNode.getString",
    "class_name": "com.google.javascript.rhino.Node$StringNode",
    "signature": "com.google.javascript.rhino.Node$StringNode.getString()",
    "snippet": "        @Override public String getString() {\n            return this.str;\n        }",
    "comment": "returns the string content. @return non null. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "StringNode.isEquivalentTo",
    "class_name": "com.google.javascript.rhino.Node$StringNode",
    "signature": "com.google.javascript.rhino.Node$StringNode.isEquivalentTo(Node)",
    "snippet": "        @Override public boolean isEquivalentTo(Node node) {\n            return (node instanceof StringNode &&\n                    this.str.equals(((StringNode) node).str));\n        }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "ObjArray.ObjArray",
    "class_name": "com.google.javascript.rhino.ObjArray",
    "signature": "com.google.javascript.rhino.ObjArray.ObjArray()",
    "snippet": "    public ObjArray() { }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "ObjToIntMap.ObjToIntMap",
    "class_name": "com.google.javascript.rhino.ObjToIntMap",
    "signature": "com.google.javascript.rhino.ObjToIntMap.ObjToIntMap(int)",
    "snippet": "    public ObjToIntMap(int keyCountHint) {\n        if (keyCountHint < 0) Kit.codeBug();\n        // Table grow when number of stored keys >= 3/4 of max capacity\n        int minimalCapacity = keyCountHint * 4 / 3;\n        int i;\n        for (i = 2; (1 << i) < minimalCapacity; ++i) { }\n        power = i;\n        if (check && power < 2) Kit.codeBug();\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "ScriptOrFnNode.ScriptOrFnNode",
    "class_name": "com.google.javascript.rhino.ScriptOrFnNode",
    "signature": "com.google.javascript.rhino.ScriptOrFnNode.ScriptOrFnNode(int)",
    "snippet": "    public ScriptOrFnNode(int nodeType) {\n        super(nodeType);\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "ScriptOrFnNode.getBaseLineno",
    "class_name": "com.google.javascript.rhino.ScriptOrFnNode",
    "signature": "com.google.javascript.rhino.ScriptOrFnNode.getBaseLineno()",
    "snippet": "    public final int getBaseLineno() { return baseLineno; }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "ScriptOrFnNode.getEncodedSourceEnd",
    "class_name": "com.google.javascript.rhino.ScriptOrFnNode",
    "signature": "com.google.javascript.rhino.ScriptOrFnNode.getEncodedSourceEnd()",
    "snippet": "    public final int getEncodedSourceEnd() { return encodedSourceEnd; }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "ScriptOrFnNode.getEncodedSourceStart",
    "class_name": "com.google.javascript.rhino.ScriptOrFnNode",
    "signature": "com.google.javascript.rhino.ScriptOrFnNode.getEncodedSourceStart()",
    "snippet": "    public final int getEncodedSourceStart() { return encodedSourceStart; }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "ScriptOrFnNode.getEndLineno",
    "class_name": "com.google.javascript.rhino.ScriptOrFnNode",
    "signature": "com.google.javascript.rhino.ScriptOrFnNode.getEndLineno()",
    "snippet": "    public final int getEndLineno() { return endLineno; }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "ScriptOrFnNode.getSourceName",
    "class_name": "com.google.javascript.rhino.ScriptOrFnNode",
    "signature": "com.google.javascript.rhino.ScriptOrFnNode.getSourceName()",
    "snippet": "    public final String getSourceName() { return sourceName; }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "ScriptRuntime.getMessage",
    "class_name": "com.google.javascript.rhino.ScriptRuntime",
    "signature": "com.google.javascript.rhino.ScriptRuntime.getMessage(String,Object[])",
    "snippet": "    public static String getMessage(String messageId, Object[] arguments)\n    {\n        final String defaultResource\n            = \"rhino_ast.java.com.google.javascript.rhino.Messages\";\n\n        Context cx = Context.getCurrentContext();\n        Locale locale = cx != null ? cx.getLocale() : Locale.getDefault();\n\n        // ResourceBundle does cacheing.\n        ResourceBundle rb = ResourceBundle.getBundle(defaultResource, locale);\n\n        String formatString;\n        try {\n            formatString = rb.getString(messageId);\n        } catch (java.util.MissingResourceException mre) {\n            throw new RuntimeException\n                (\"no message resource found for message property \"+ messageId);\n        }\n\n        /*\n         * It's OK to format the string, even if 'arguments' is null;\n         * we need to format it anyway, to make double ''s collapse to\n         * single 's.\n         */\n        // TODO: MessageFormat is not available on pJava\n        MessageFormat formatter = new MessageFormat(formatString);\n        return formatter.format(arguments);\n    }",
    "comment": "OPT there's a noticable delay for the first error!  Maybe it'd make sense to use a ListResourceBundle instead of a properties file to avoid (synchronized) text parsing. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "ScriptRuntime.getMessage0",
    "class_name": "com.google.javascript.rhino.ScriptRuntime",
    "signature": "com.google.javascript.rhino.ScriptRuntime.getMessage0(String)",
    "snippet": "    public static String getMessage0(String messageId)\n    {\n        return getMessage(messageId, null);\n    }",
    "comment": "------------------",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "Token.name",
    "class_name": "com.google.javascript.rhino.Token",
    "signature": "com.google.javascript.rhino.Token.name(int)",
    "snippet": "  public static String name(int token)\n    {\n        if (!printNames) {\n            return String.valueOf(token);\n        }\n        switch (token) {\n          case ERROR:           return \"ERROR\";\n          case EOF:             return \"EOF\";\n          case EOL:             return \"EOL\";\n          case ENTERWITH:       return \"ENTERWITH\";\n          case LEAVEWITH:       return \"LEAVEWITH\";\n          case RETURN:          return \"RETURN\";\n          case GOTO:            return \"GOTO\";\n          case IFEQ:            return \"IFEQ\";\n          case IFNE:            return \"IFNE\";\n          case SETNAME:         return \"SETNAME\";\n          case BITOR:           return \"BITOR\";\n          case BITXOR:          return \"BITXOR\";\n          case BITAND:          return \"BITAND\";\n          case EQ:              return \"EQ\";\n          case NE:              return \"NE\";\n          case LT:              return \"LT\";\n          case LE:              return \"LE\";\n          case GT:              return \"GT\";\n          case GE:              return \"GE\";\n          case LSH:             return \"LSH\";\n          case RSH:             return \"RSH\";\n          case URSH:            return \"URSH\";\n          case ADD:             return \"ADD\";\n          case SUB:             return \"SUB\";\n          case MUL:             return \"MUL\";\n          case DIV:             return \"DIV\";\n          case MOD:             return \"MOD\";\n          case NOT:             return \"NOT\";\n          case BITNOT:          return \"BITNOT\";\n          case POS:             return \"POS\";\n          case NEG:             return \"NEG\";\n          case NEW:             return \"NEW\";\n          case DELPROP:         return \"DELPROP\";\n          case TYPEOF:          return \"TYPEOF\";\n          case GETPROP:         return \"GETPROP\";\n          case SETPROP:         return \"SETPROP\";\n          case GETELEM:         return \"GETELEM\";\n          case SETELEM:         return \"SETELEM\";\n          case CALL:            return \"CALL\";\n          case NAME:            return \"NAME\";\n          case NUMBER:          return \"NUMBER\";\n          case STRING:          return \"STRING\";\n          case NULL:            return \"NULL\";\n          case THIS:            return \"THIS\";\n          case FALSE:           return \"FALSE\";\n          case TRUE:            return \"TRUE\";\n          case SHEQ:            return \"SHEQ\";\n          case SHNE:            return \"SHNE\";\n          case REGEXP:          return \"OBJECT\";\n          case BINDNAME:        return \"BINDNAME\";\n          case THROW:           return \"THROW\";\n          case RETHROW:         return \"RETHROW\";\n          case IN:              return \"IN\";\n          case INSTANCEOF:      return \"INSTANCEOF\";\n          case LOCAL_LOAD:      return \"LOCAL_LOAD\";\n          case GETVAR:          return \"GETVAR\";\n          case SETVAR:          return \"SETVAR\";\n          case CATCH_SCOPE:     return \"CATCH_SCOPE\";\n          case ENUM_INIT_KEYS:  return \"ENUM_INIT_KEYS\";\n          case ENUM_INIT_VALUES:  return \"ENUM_INIT_VALUES\";\n          case ENUM_NEXT:       return \"ENUM_NEXT\";\n          case ENUM_ID:         return \"ENUM_ID\";\n          case THISFN:          return \"THISFN\";\n          case RETURN_RESULT:   return \"RETURN_RESULT\";\n          case ARRAYLIT:        return \"ARRAYLIT\";\n          case OBJECTLIT:       return \"OBJECTLIT\";\n          case GET_REF:         return \"GET_REF\";\n          case SET_REF:         return \"SET_REF\";\n          case DEL_REF:         return \"DEL_REF\";\n          case REF_CALL:        return \"REF_CALL\";\n          case REF_SPECIAL:     return \"REF_SPECIAL\";\n          case DEFAULTNAMESPACE:return \"DEFAULTNAMESPACE\";\n          case ESCXMLTEXT:      return \"ESCXMLTEXT\";\n          case ESCXMLATTR:      return \"ESCXMLATTR\";\n          case REF_MEMBER:      return \"REF_MEMBER\";\n          case REF_NS_MEMBER:   return \"REF_NS_MEMBER\";\n          case REF_NAME:        return \"REF_NAME\";\n          case REF_NS_NAME:     return \"REF_NS_NAME\";\n          case TRY:             return \"TRY\";\n          case SEMI:            return \"SEMI\";\n          case LB:              return \"LB\";\n          case RB:              return \"RB\";\n          case LC:              return \"LC\";\n          case RC:              return \"RC\";\n          case LP:              return \"LP\";\n          case RP:              return \"RP\";\n          case COMMA:           return \"COMMA\";\n          case ASSIGN:          return \"ASSIGN\";\n          case ASSIGN_BITOR:    return \"ASSIGN_BITOR\";\n          case ASSIGN_BITXOR:   return \"ASSIGN_BITXOR\";\n          case ASSIGN_BITAND:   return \"ASSIGN_BITAND\";\n          case ASSIGN_LSH:      return \"ASSIGN_LSH\";\n          case ASSIGN_RSH:      return \"ASSIGN_RSH\";\n          case ASSIGN_URSH:     return \"ASSIGN_URSH\";\n          case ASSIGN_ADD:      return \"ASSIGN_ADD\";\n          case ASSIGN_SUB:      return \"ASSIGN_SUB\";\n          case ASSIGN_MUL:      return \"ASSIGN_MUL\";\n          case ASSIGN_DIV:      return \"ASSIGN_DIV\";\n          case ASSIGN_MOD:      return \"ASSIGN_MOD\";\n          case HOOK:            return \"HOOK\";\n          case COLON:           return \"COLON\";\n          case OR:              return \"OR\";\n          case AND:             return \"AND\";\n          case INC:             return \"INC\";\n          case DEC:             return \"DEC\";\n          case DOT:             return \"DOT\";\n          case FUNCTION:        return \"FUNCTION\";\n          case EXPORT:          return \"EXPORT\";\n          case IMPORT:          return \"IMPORT\";\n          case IF:              return \"IF\";\n          case ELSE:            return \"ELSE\";\n          case SWITCH:          return \"SWITCH\";\n          case CASE:            return \"CASE\";\n          case DEFAULT:         return \"DEFAULT\";\n          case WHILE:           return \"WHILE\";\n          case DO:              return \"DO\";\n          case FOR:             return \"FOR\";\n          case BREAK:           return \"BREAK\";\n          case CONTINUE:        return \"CONTINUE\";\n          case VAR:             return \"VAR\";\n          case WITH:            return \"WITH\";\n          case CATCH:           return \"CATCH\";\n          case FINALLY:         return \"FINALLY\";\n          case RESERVED:        return \"RESERVED\";\n          case EMPTY:           return \"EMPTY\";\n          case BLOCK:           return \"BLOCK\";\n          case LABEL:           return \"LABEL\";\n          case TARGET:          return \"TARGET\";\n          case LOOP:            return \"LOOP\";\n          case EXPR_VOID:       return \"EXPR_VOID\";\n          case EXPR_RESULT:     return \"EXPR_RESULT\";\n          case JSR:             return \"JSR\";\n          case SCRIPT:          return \"SCRIPT\";\n          case TYPEOFNAME:      return \"TYPEOFNAME\";\n          case USE_STACK:       return \"USE_STACK\";\n          case SETPROP_OP:      return \"SETPROP_OP\";\n          case SETELEM_OP:      return \"SETELEM_OP\";\n          case LOCAL_BLOCK:     return \"LOCAL_BLOCK\";\n          case SET_REF_OP:      return \"SET_REF_OP\";\n          case DOTDOT:          return \"DOTDOT\";\n          case COLONCOLON:      return \"COLONCOLON\";\n          case XML:             return \"XML\";\n          case DOTQUERY:        return \"DOTQUERY\";\n          case XMLATTR:         return \"XMLATTR\";\n          case XMLEND:          return \"XMLEND\";\n          case TO_OBJECT:       return \"TO_OBJECT\";\n          case TO_DOUBLE:       return \"TO_DOUBLE\";\n          case GET:             return \"GET\";\n          case SET:             return \"SET\";\n          case CONST:           return \"CONST\";\n          case SETCONST:        return \"SETCONST\";\n          case DEBUGGER:        return \"DEBUGGER\";\n          case ANNOTATION:      return \"ANNOTATION\";\n          case PIPE:            return \"PIPE\";\n          case STAR:            return \"STAR\";\n          case EOC:             return \"EOC\";\n          case QMARK:           return \"QMARK\";\n          case ELLIPSIS:        return \"ELLIPSIS\";\n          case BANG:            return \"BANG\";\n          case VOID:            return \"VOID\"; \n          case EQUALS:          return \"EQUALS\";\n        }\n\n        // Token without name\n        throw new IllegalStateException(String.valueOf(token));\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "TokenStream.isJSIdentifier",
    "class_name": "com.google.javascript.rhino.TokenStream",
    "signature": "com.google.javascript.rhino.TokenStream.isJSIdentifier(String)",
    "snippet": "    public static boolean isJSIdentifier(String s) {\n        int length = s.length();\n\n        if (length == 0 || !Character.isJavaIdentifierStart(s.charAt(0)))\n            return false;\n\n        for (int i=1; i<length; i++) {\n            char c = s.charAt(i);\n            if (!Character.isJavaIdentifierPart(c)) {\n                if (c == '\\\\') {\n                    if (! ((i + 5) < length)\n                        && (s.charAt(i + 1) == 'u')\n                        && 0 <= Kit.xDigitToInt(s.charAt(i + 2), 0)\n                        && 0 <= Kit.xDigitToInt(s.charAt(i + 3), 0)\n                        && 0 <= Kit.xDigitToInt(s.charAt(i + 4), 0)\n                        && 0 <= Kit.xDigitToInt(s.charAt(i + 5), 0)) {\n                        return true;\n                     }\n                }\n\n                return false;\n            }\n        }\n\n        return true;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "TokenStream.isKeyword",
    "class_name": "com.google.javascript.rhino.TokenStream",
    "signature": "com.google.javascript.rhino.TokenStream.isKeyword(String)",
    "snippet": "    public static boolean isKeyword(String s)\n    {\n        return Token.EOF != stringToKeyword(s);\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "TokenStream.stringToKeyword",
    "class_name": "com.google.javascript.rhino.TokenStream",
    "signature": "com.google.javascript.rhino.TokenStream.stringToKeyword(String)",
    "snippet": "    private static int stringToKeyword(String name)\n    {\n// #string_id_map#\n// The following assumes that Token.EOF == 0\n        final int\n            Id_break         = Token.BREAK,\n            Id_case          = Token.CASE,\n            Id_continue      = Token.CONTINUE,\n            Id_default       = Token.DEFAULT,\n            Id_delete        = Token.DELPROP,\n            Id_do            = Token.DO,\n            Id_else          = Token.ELSE,\n            Id_export        = Token.EXPORT,\n            Id_false         = Token.FALSE,\n            Id_for           = Token.FOR,\n            Id_function      = Token.FUNCTION,\n            Id_if            = Token.IF,\n            Id_in            = Token.IN,\n            Id_new           = Token.NEW,\n            Id_null          = Token.NULL,\n            Id_return        = Token.RETURN,\n            Id_switch        = Token.SWITCH,\n            Id_this          = Token.THIS,\n            Id_true          = Token.TRUE,\n            Id_typeof        = Token.TYPEOF,\n            Id_var           = Token.VAR,\n            Id_void          = Token.VOID,\n            Id_while         = Token.WHILE,\n            Id_with          = Token.WITH,\n\n            // the following are #ifdef RESERVE_JAVA_KEYWORDS in jsscan.c\n            Id_abstract      = Token.RESERVED,\n            Id_boolean       = Token.RESERVED,\n            Id_byte          = Token.RESERVED,\n            Id_catch         = Token.CATCH,\n            Id_char          = Token.RESERVED,\n            Id_class         = Token.RESERVED,\n            Id_const         = Token.CONST,\n            Id_debugger      = Token.DEBUGGER,\n            Id_double        = Token.RESERVED,\n            Id_enum          = Token.RESERVED,\n            Id_extends       = Token.RESERVED,\n            Id_final         = Token.RESERVED,\n            Id_finally       = Token.FINALLY,\n            Id_float         = Token.RESERVED,\n            Id_goto          = Token.RESERVED,\n            Id_implements    = Token.RESERVED,\n            Id_import        = Token.IMPORT,\n            Id_instanceof    = Token.INSTANCEOF,\n            Id_int           = Token.RESERVED,\n            Id_interface     = Token.RESERVED,\n            Id_long          = Token.RESERVED,\n            Id_native        = Token.RESERVED,\n            Id_package       = Token.RESERVED,\n            Id_private       = Token.RESERVED,\n            Id_protected     = Token.RESERVED,\n            Id_public        = Token.RESERVED,\n            Id_short         = Token.RESERVED,\n            Id_static        = Token.RESERVED,\n            Id_super         = Token.RESERVED,\n            Id_synchronized  = Token.RESERVED,\n            Id_throw         = Token.THROW,\n            Id_throws        = Token.RESERVED,\n            Id_transient     = Token.RESERVED,\n            Id_try           = Token.TRY,\n            Id_volatile      = Token.RESERVED;\n\n        int id;\n        String s = name;\n// #generated# Last update: 2001-06-01 17:45:01 CEST\n        L0: { id = 0; String X = null; int c;\n            L: switch (s.length()) {\n            case 2: c=s.charAt(1);\n                if (c=='f') { if (s.charAt(0)=='i') {id=Id_if; break L0;} }\n                else if (c=='n') { if (s.charAt(0)=='i') {id=Id_in; break L0;} }\n                else if (c=='o') { if (s.charAt(0)=='d') {id=Id_do; break L0;} }\n                break L;\n            case 3: switch (s.charAt(0)) {\n                case 'f': if (s.charAt(2)=='r' && s.charAt(1)=='o') {id=Id_for; break L0;} break L;\n                case 'i': if (s.charAt(2)=='t' && s.charAt(1)=='n') {id=Id_int; break L0;} break L;\n                case 'n': if (s.charAt(2)=='w' && s.charAt(1)=='e') {id=Id_new; break L0;} break L;\n                case 't': if (s.charAt(2)=='y' && s.charAt(1)=='r') {id=Id_try; break L0;} break L;\n                case 'v': if (s.charAt(2)=='r' && s.charAt(1)=='a') {id=Id_var; break L0;} break L;\n                } break L;\n            case 4: switch (s.charAt(0)) {\n                case 'b': X=\"byte\";id=Id_byte; break L;\n                case 'c': c=s.charAt(3);\n                    if (c=='e') { if (s.charAt(2)=='s' && s.charAt(1)=='a') {\n                            id=Id_case; break L0;} }\n                    else if (c=='r') { if (s.charAt(2)=='a' && s.charAt(1)=='h') {\n                            id=Id_char; break L0;} }\n                    break L;\n                case 'e': c=s.charAt(3);\n                    if (c=='e') { if (s.charAt(2)=='s' && s.charAt(1)=='l') {\n                            id=Id_else; break L0;} }\n                    else if (c=='m') { if (s.charAt(2)=='u' && s.charAt(1)=='n') {\n                            id=Id_enum; break L0;} }\n                    break L;\n                case 'g': X=\"goto\";id=Id_goto; break L;\n                case 'l': X=\"long\";id=Id_long; break L;\n                case 'n': X=\"null\";id=Id_null; break L;\n                case 't': c=s.charAt(3);\n                    if (c=='e') { if (s.charAt(2)=='u' && s.charAt(1)=='r') {\n                            id=Id_true; break L0;} }\n                    else if (c=='s') { if (s.charAt(2)=='i' && s.charAt(1)=='h') {\n                            id=Id_this; break L0;} }\n                    break L;\n                case 'v': X=\"void\";id=Id_void; break L;\n                case 'w': X=\"with\";id=Id_with; break L;\n                } break L;\n            case 5: switch (s.charAt(2)) {\n                case 'a': X=\"class\";id=Id_class; break L;\n                case 'e': X=\"break\";id=Id_break; break L;\n                case 'i': X=\"while\";id=Id_while; break L;\n                case 'l': X=\"false\";id=Id_false; break L;\n                case 'n': c=s.charAt(0);\n                    if (c=='c') { X=\"const\";id=Id_const; }\n                    else if (c=='f') { X=\"final\";id=Id_final; }\n                    break L;\n                case 'o': c=s.charAt(0);\n                    if (c=='f') { X=\"float\";id=Id_float; }\n                    else if (c=='s') { X=\"short\";id=Id_short; }\n                    break L;\n                case 'p': X=\"super\";id=Id_super; break L;\n                case 'r': X=\"throw\";id=Id_throw; break L;\n                case 't': X=\"catch\";id=Id_catch; break L;\n                } break L;\n            case 6: switch (s.charAt(1)) {\n                case 'a': X=\"native\";id=Id_native; break L;\n                case 'e': c=s.charAt(0);\n                    if (c=='d') { X=\"delete\";id=Id_delete; }\n                    else if (c=='r') { X=\"return\";id=Id_return; }\n                    break L;\n                case 'h': X=\"throws\";id=Id_throws; break L;\n                case 'm': X=\"import\";id=Id_import; break L;\n                case 'o': X=\"double\";id=Id_double; break L;\n                case 't': X=\"static\";id=Id_static; break L;\n                case 'u': X=\"public\";id=Id_public; break L;\n                case 'w': X=\"switch\";id=Id_switch; break L;\n                case 'x': X=\"export\";id=Id_export; break L;\n                case 'y': X=\"typeof\";id=Id_typeof; break L;\n                } break L;\n            case 7: switch (s.charAt(1)) {\n                case 'a': X=\"package\";id=Id_package; break L;\n                case 'e': X=\"default\";id=Id_default; break L;\n                case 'i': X=\"finally\";id=Id_finally; break L;\n                case 'o': X=\"boolean\";id=Id_boolean; break L;\n                case 'r': X=\"private\";id=Id_private; break L;\n                case 'x': X=\"extends\";id=Id_extends; break L;\n                } break L;\n            case 8: switch (s.charAt(0)) {\n                case 'a': X=\"abstract\";id=Id_abstract; break L;\n                case 'c': X=\"continue\";id=Id_continue; break L;\n                case 'd': X=\"debugger\";id=Id_debugger; break L;\n                case 'f': X=\"function\";id=Id_function; break L;\n                case 'v': X=\"volatile\";id=Id_volatile; break L;\n                } break L;\n            case 9: c=s.charAt(0);\n                if (c=='i') { X=\"interface\";id=Id_interface; }\n                else if (c=='p') { X=\"protected\";id=Id_protected; }\n                else if (c=='t') { X=\"transient\";id=Id_transient; }\n                break L;\n            case 10: c=s.charAt(1);\n                if (c=='m') { X=\"implements\";id=Id_implements; }\n                else if (c=='n') { X=\"instanceof\";id=Id_instanceof; }\n                break L;\n            case 12: X=\"synchronized\";id=Id_synchronized; break L;\n            }\n            if (X!=null && X!=s && !X.equals(s)) id = 0;\n        }\n// #/generated#\n// #/string_id_map#\n        if (id == 0) { return Token.EOF; }\n        return id & 0xff;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "AllType.AllType",
    "class_name": "com.google.javascript.rhino.jstype.AllType",
    "signature": "com.google.javascript.rhino.jstype.AllType.AllType(JSTypeRegistry)",
    "snippet": "  AllType(JSTypeRegistry registry) {\n    super(registry);\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "AllType.isAllType",
    "class_name": "com.google.javascript.rhino.jstype.AllType",
    "signature": "com.google.javascript.rhino.jstype.AllType.isAllType()",
    "snippet": "  @Override\n  public boolean isAllType() {\n    return true;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "ArrowType.ArrowType",
    "class_name": "com.google.javascript.rhino.jstype.ArrowType",
    "signature": "com.google.javascript.rhino.jstype.ArrowType.ArrowType(JSTypeRegistry,Node,JSType)",
    "snippet": "  ArrowType(JSTypeRegistry registry, Node parameters,\n      JSType returnType) {\n    super(registry);\n    this.parameters = parameters;\n    this.returnType = returnType;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "ArrowType.hashCode",
    "class_name": "com.google.javascript.rhino.jstype.ArrowType",
    "signature": "com.google.javascript.rhino.jstype.ArrowType.hashCode()",
    "snippet": "  @Override\n  public int hashCode() {\n    int hashCode = 0;\n    if (returnType != null) {\n      hashCode += returnType.hashCode();\n    }\n    if (parameters != null) {\n      Node param = parameters.getFirstChild();\n      while (param != null) {\n        JSType paramType = param.getJSType();\n        if (paramType != null) {\n          hashCode += paramType.hashCode();\n        }\n        param = param.getNext();\n      }\n    }\n    return hashCode;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "BooleanType.BooleanType",
    "class_name": "com.google.javascript.rhino.jstype.BooleanType",
    "signature": "com.google.javascript.rhino.jstype.BooleanType.BooleanType(JSTypeRegistry)",
    "snippet": "  BooleanType(JSTypeRegistry registry) {\n    super(registry);\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "BooleanType.toString",
    "class_name": "com.google.javascript.rhino.jstype.BooleanType",
    "signature": "com.google.javascript.rhino.jstype.BooleanType.toString()",
    "snippet": "  @Override\n  public String toString() {\n    return \"boolean\";\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "ErrorFunctionType.ErrorFunctionType",
    "class_name": "com.google.javascript.rhino.jstype.ErrorFunctionType",
    "signature": "com.google.javascript.rhino.jstype.ErrorFunctionType.ErrorFunctionType(JSTypeRegistry,String)",
    "snippet": "  ErrorFunctionType(JSTypeRegistry registry, String name) {\n    super(registry, name, null,\n          registry.createOptionalParameters(\n              registry.getNativeType(ALL_TYPE),\n              registry.getNativeType(ALL_TYPE),\n              registry.getNativeType(ALL_TYPE)),\n          null, null, null, true, true);\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "ErrorFunctionType.getReturnType",
    "class_name": "com.google.javascript.rhino.jstype.ErrorFunctionType",
    "signature": "com.google.javascript.rhino.jstype.ErrorFunctionType.getReturnType()",
    "snippet": "  @Override\n  public JSType getReturnType() {\n    return getInstanceType();\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "FunctionParamBuilder.FunctionParamBuilder",
    "class_name": "com.google.javascript.rhino.jstype.FunctionParamBuilder",
    "signature": "com.google.javascript.rhino.jstype.FunctionParamBuilder.FunctionParamBuilder(JSTypeRegistry)",
    "snippet": "  public FunctionParamBuilder(JSTypeRegistry registry) {\n    this.registry = registry;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "FunctionParamBuilder.addOptionalParams",
    "class_name": "com.google.javascript.rhino.jstype.FunctionParamBuilder",
    "signature": "com.google.javascript.rhino.jstype.FunctionParamBuilder.addOptionalParams(JSType[])",
    "snippet": "  public boolean addOptionalParams(JSType ...types) {\n    if (hasVarArgs()) {\n      return false;\n    }\n\n    for (JSType type : types) {\n      newParameter(registry.createOptionalType(type)).setOptionalArg(true);\n    }\n    return true;\n  }",
    "comment": " Add optional parameters of the given type to the end of the param list. @param types Types for each optional parameter. The builder will make them undefineable. @return False if this is called after var args are added. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "FunctionParamBuilder.addRequiredParams",
    "class_name": "com.google.javascript.rhino.jstype.FunctionParamBuilder",
    "signature": "com.google.javascript.rhino.jstype.FunctionParamBuilder.addRequiredParams(JSType[])",
    "snippet": "  public boolean addRequiredParams(JSType ...types) {\n    if (hasOptionalOrVarArgs()) {\n      return false;\n    }\n\n    for (JSType type : types) {\n      newParameter(type);\n    }\n    return true;\n  }",
    "comment": " Add parameters of the given type to the end of the param list. @return False if this is called after optional params are added. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "FunctionParamBuilder.addVarArgs",
    "class_name": "com.google.javascript.rhino.jstype.FunctionParamBuilder",
    "signature": "com.google.javascript.rhino.jstype.FunctionParamBuilder.addVarArgs(JSType)",
    "snippet": "  public boolean addVarArgs(JSType type) {\n    if (hasVarArgs()) {\n      return false;\n    }\n\n    // There are two types of variable argument functions:\n    // 1) Programmer-defined var args\n    // 2) Native bottom types that can accept any argument.\n    // For the first one, \"undefined\" is a valid value for all arguments.\n    // For the second, we do not want to cast it up to undefined.\n    if (!type.isEmptyType()) {\n      type = registry.createOptionalType(type);\n    }\n    newParameter(type).setVarArgs(true);\n    return true;\n  }",
    "comment": " Add variable arguments to the end of the parameter list. @return False if this is called after var args are added. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "FunctionParamBuilder.build",
    "class_name": "com.google.javascript.rhino.jstype.FunctionParamBuilder",
    "signature": "com.google.javascript.rhino.jstype.FunctionParamBuilder.build()",
    "snippet": "  public Node build() {\n    return root;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "FunctionParamBuilder.hasOptionalOrVarArgs",
    "class_name": "com.google.javascript.rhino.jstype.FunctionParamBuilder",
    "signature": "com.google.javascript.rhino.jstype.FunctionParamBuilder.hasOptionalOrVarArgs()",
    "snippet": "  private boolean hasOptionalOrVarArgs() {\n    Node lastChild = root.getLastChild();\n    return lastChild != null &&\n        (lastChild.isOptionalArg() || lastChild.isVarArgs());\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "FunctionParamBuilder.hasVarArgs",
    "class_name": "com.google.javascript.rhino.jstype.FunctionParamBuilder",
    "signature": "com.google.javascript.rhino.jstype.FunctionParamBuilder.hasVarArgs()",
    "snippet": "  public boolean hasVarArgs() {\n    Node lastChild = root.getLastChild();\n    return lastChild != null && lastChild.isVarArgs();\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "FunctionParamBuilder.newParameter",
    "class_name": "com.google.javascript.rhino.jstype.FunctionParamBuilder",
    "signature": "com.google.javascript.rhino.jstype.FunctionParamBuilder.newParameter(JSType)",
    "snippet": "  private Node newParameter(JSType type) {\n    Node paramNode = Node.newString(Token.NAME, \"\");\n    paramNode.setJSType(type);\n    root.addChildToBack(paramNode);\n    return paramNode;\n  }",
    "comment": "Add a parameter to the list with the given type.",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "FunctionPrototypeType.FunctionPrototypeType",
    "class_name": "com.google.javascript.rhino.jstype.FunctionPrototypeType",
    "signature": "com.google.javascript.rhino.jstype.FunctionPrototypeType.FunctionPrototypeType(JSTypeRegistry,FunctionType,ObjectType)",
    "snippet": "  FunctionPrototypeType(JSTypeRegistry registry, FunctionType ownerFunction,\n      ObjectType implicitPrototype) {\n    this(registry, ownerFunction, implicitPrototype, false);\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "FunctionPrototypeType.FunctionPrototypeType",
    "class_name": "com.google.javascript.rhino.jstype.FunctionPrototypeType",
    "signature": "com.google.javascript.rhino.jstype.FunctionPrototypeType.FunctionPrototypeType(JSTypeRegistry,FunctionType,ObjectType,boolean)",
    "snippet": "  FunctionPrototypeType(JSTypeRegistry registry, FunctionType ownerFunction,\n      ObjectType implicitPrototype, boolean isNative) {\n    super(registry, null /* has no class name */, implicitPrototype,\n        isNative);\n    this.ownerFunction = ownerFunction;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "FunctionType.FunctionType",
    "class_name": "com.google.javascript.rhino.jstype.FunctionType",
    "signature": "com.google.javascript.rhino.jstype.FunctionType.FunctionType(JSTypeRegistry,String,Node,Node,JSType)",
    "snippet": "  @VisibleForTesting\n  public FunctionType(JSTypeRegistry registry, String name, Node source,\n      Node parameters, JSType returnType) {\n    this(registry, name, source, parameters, returnType, null, null, false,\n         false);\n  }",
    "comment": " Creates a function type. @param registry the owner registry for this type @param name the function's name or {@code null} to indicate that the function is anonymous. @param source the node defining this function. Its type ({@link Node#getType()}) must be {@link Token#FUNCTION}. @param parameters the function's parameters or {@code null} to indicate that the parameter types are unknown. @param returnType the function's return type or {@code null} to indicate that the return type is unknown. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "FunctionType.FunctionType",
    "class_name": "com.google.javascript.rhino.jstype.FunctionType",
    "signature": "com.google.javascript.rhino.jstype.FunctionType.FunctionType(JSTypeRegistry,String,Node,Node,JSType,ObjectType,String,boolean,boolean)",
    "snippet": "  FunctionType(JSTypeRegistry registry, String name, Node source,\n      Node parameters, JSType returnType, ObjectType typeOfThis,\n      String templateTypeName,  boolean isConstructor, boolean nativeType) {\n    super(registry, name,\n        registry.getNativeObjectType(JSTypeNative.FUNCTION_INSTANCE_TYPE),\n        nativeType);\n    Preconditions.checkArgument(source == null ||\n        Token.FUNCTION == source.getType());\n    this.source = source;\n    this.kind = isConstructor ? Kind.CONSTRUCTOR : Kind.ORDINARY;\n    if (isConstructor) {\n      this.typeOfThis = typeOfThis != null && typeOfThis.isNoObjectType() ?\n          typeOfThis : new InstanceObjectType(registry, this, nativeType);\n    } else {\n      this.typeOfThis = typeOfThis != null ?\n          typeOfThis :\n          registry.getNativeObjectType(JSTypeNative.UNKNOWN_TYPE);\n    }\n    // The call type should be set up last because we are calling getReturnType,\n    // which may be overloaded and depend on other properties being set.\n    this.call = new ArrowType(registry, parameters,\n        (returnType == null ? getReturnType() : returnType));\n    this.templateTypeName = templateTypeName;\n  }",
    "comment": "Creates an instance for a function that might be a constructor. */",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "FunctionType.addSubType",
    "class_name": "com.google.javascript.rhino.jstype.FunctionType",
    "signature": "com.google.javascript.rhino.jstype.FunctionType.addSubType(FunctionType)",
    "snippet": "  private void addSubType(FunctionType subType) {\n    if (subTypes == null) {\n      subTypes = Lists.newArrayList();\n    }\n    subTypes.add(subType);\n  }",
    "comment": "Adds a type to the list of subtypes for this type. */",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "FunctionType.defineProperty",
    "class_name": "com.google.javascript.rhino.jstype.FunctionType",
    "signature": "com.google.javascript.rhino.jstype.FunctionType.defineProperty(String,JSType,boolean,boolean)",
    "snippet": "  @Override\n  boolean defineProperty(String name, JSType type,\n      boolean inferred, boolean inExterns) {\n    if (\"prototype\".equals(name)) {\n      ObjectType objType = type.toObjectType();\n      if (objType != null) {\n        if (objType.equals(prototype)) {\n          return true;\n        }\n        return setPrototype(\n            new FunctionPrototypeType(\n                registry, this, objType, isNativeObjectType()));\n      } else {\n        return false;\n      }\n    }\n    return super.defineProperty(name, type, inferred, inExterns);\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "FunctionType.getInstanceType",
    "class_name": "com.google.javascript.rhino.jstype.FunctionType",
    "signature": "com.google.javascript.rhino.jstype.FunctionType.getInstanceType()",
    "snippet": "  public ObjectType getInstanceType() {\n    Preconditions.checkState(hasInstanceType());\n    return typeOfThis;\n  }",
    "comment": " Gets the type of instance of this function. @throws IllegalStateException if this function is not a constructor (see {@link #isConstructor()}). ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "FunctionType.getPrototype",
    "class_name": "com.google.javascript.rhino.jstype.FunctionType",
    "signature": "com.google.javascript.rhino.jstype.FunctionType.getPrototype()",
    "snippet": "  public FunctionPrototypeType getPrototype() {\n    // lazy initialization of the prototype field\n    if (prototype == null) {\n      setPrototype(new FunctionPrototypeType(registry, this, null));\n    }\n    return prototype;\n  }",
    "comment": " Gets the {@code prototype} property of this function type. This is equivalent to {@code (ObjectType) getPropertyType(\"prototype\")}. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "FunctionType.getSuperClassConstructor",
    "class_name": "com.google.javascript.rhino.jstype.FunctionType",
    "signature": "com.google.javascript.rhino.jstype.FunctionType.getSuperClassConstructor()",
    "snippet": "  public FunctionType getSuperClassConstructor() {\n    Preconditions.checkArgument(isConstructor() || isInterface());\n    ObjectType maybeSuperInstanceType = getPrototype().getImplicitPrototype();\n    if (maybeSuperInstanceType == null) {\n      return null;\n    }\n    return maybeSuperInstanceType.getConstructor();\n  }",
    "comment": " Given a constructor or an interface type, get its superclass constructor or {@code null} if none exists. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "FunctionType.hasCachedValues",
    "class_name": "com.google.javascript.rhino.jstype.FunctionType",
    "signature": "com.google.javascript.rhino.jstype.FunctionType.hasCachedValues()",
    "snippet": "  @Override\n  public boolean hasCachedValues() {\n    return prototype != null || super.hasCachedValues();\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "FunctionType.hasInstanceType",
    "class_name": "com.google.javascript.rhino.jstype.FunctionType",
    "signature": "com.google.javascript.rhino.jstype.FunctionType.hasInstanceType()",
    "snippet": "  public boolean hasInstanceType() {\n    return isConstructor() || isInterface();\n  }",
    "comment": " Returns whether this function type has an instance type. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "FunctionType.hashCode",
    "class_name": "com.google.javascript.rhino.jstype.FunctionType",
    "signature": "com.google.javascript.rhino.jstype.FunctionType.hashCode()",
    "snippet": "  @Override\n  public int hashCode() {\n    return isInterface() ? getReferenceName().hashCode() : call.hashCode();\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "FunctionType.isConstructor",
    "class_name": "com.google.javascript.rhino.jstype.FunctionType",
    "signature": "com.google.javascript.rhino.jstype.FunctionType.isConstructor()",
    "snippet": "  @Override\n  public boolean isConstructor() {\n    return kind == Kind.CONSTRUCTOR;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "FunctionType.isInterface",
    "class_name": "com.google.javascript.rhino.jstype.FunctionType",
    "signature": "com.google.javascript.rhino.jstype.FunctionType.isInterface()",
    "snippet": "  @Override\n  public boolean isInterface() {\n    return kind == Kind.INTERFACE;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "FunctionType.setInstanceType",
    "class_name": "com.google.javascript.rhino.jstype.FunctionType",
    "signature": "com.google.javascript.rhino.jstype.FunctionType.setInstanceType(ObjectType)",
    "snippet": "  void setInstanceType(ObjectType instanceType) {\n    typeOfThis = instanceType;\n  }",
    "comment": "Sets the instance type. This should only be used for special native types. */",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "FunctionType.setPrototype",
    "class_name": "com.google.javascript.rhino.jstype.FunctionType",
    "signature": "com.google.javascript.rhino.jstype.FunctionType.setPrototype(FunctionPrototypeType)",
    "snippet": "  public boolean setPrototype(FunctionPrototypeType prototype) {\n    if (prototype == null) {\n      return false;\n    }\n    // getInstanceType fails if the function is not a constructor\n    if (isConstructor() && prototype == getInstanceType()) {\n      return false;\n    }\n\n    this.prototype = prototype;\n\n    if (isConstructor() || isInterface()) {\n      FunctionType superClass = getSuperClassConstructor();\n      if (superClass != null) {\n        superClass.addSubType(this);\n      }\n    }\n    return true;\n  }",
    "comment": " Sets the prototype. @param prototype the prototype. If this value is {@code null} it will silently be discarded. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "FunctionType.setPrototypeBasedOn",
    "class_name": "com.google.javascript.rhino.jstype.FunctionType",
    "signature": "com.google.javascript.rhino.jstype.FunctionType.setPrototypeBasedOn(ObjectType)",
    "snippet": "  public void setPrototypeBasedOn(ObjectType baseType) {\n    if (prototype == null) {\n      setPrototype(\n          new FunctionPrototypeType(\n              registry, this, baseType, isNativeObjectType()));\n    } else {\n      prototype.setImplicitPrototype(baseType);\n    }\n  }",
    "comment": " Sets the prototype, creating the prototype object from the given base type. @param baseType The base type. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "InstanceObjectType.InstanceObjectType",
    "class_name": "com.google.javascript.rhino.jstype.InstanceObjectType",
    "signature": "com.google.javascript.rhino.jstype.InstanceObjectType.InstanceObjectType(JSTypeRegistry,FunctionType,boolean)",
    "snippet": "  InstanceObjectType(JSTypeRegistry registry, FunctionType constructor,\n                     boolean isNativeType) {\n    super(registry, null, null, isNativeType);\n    Preconditions.checkNotNull(constructor);\n    this.constructor = constructor;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "InstanceObjectType.equals",
    "class_name": "com.google.javascript.rhino.jstype.InstanceObjectType",
    "signature": "com.google.javascript.rhino.jstype.InstanceObjectType.equals(Object)",
    "snippet": "  @Override\n  public boolean equals(Object that) {\n    if (this == that) {\n      return true;\n    } else if (that instanceof JSType && this.isNominalType()) {\n      ObjectType thatObj = ObjectType.cast((JSType) that);\n      if (thatObj != null && thatObj.isNominalType()) {\n        return getReferenceName().equals(thatObj.getReferenceName());\n      }\n    }\n    return false;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "InstanceObjectType.getConstructor",
    "class_name": "com.google.javascript.rhino.jstype.InstanceObjectType",
    "signature": "com.google.javascript.rhino.jstype.InstanceObjectType.getConstructor()",
    "snippet": "  @Override\n  public FunctionType getConstructor() {\n    return constructor;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "InstanceObjectType.getImplicitPrototype",
    "class_name": "com.google.javascript.rhino.jstype.InstanceObjectType",
    "signature": "com.google.javascript.rhino.jstype.InstanceObjectType.getImplicitPrototype()",
    "snippet": "  @Override\n  public ObjectType getImplicitPrototype() {\n    return getConstructor().getPrototype();\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "InstanceObjectType.getReferenceName",
    "class_name": "com.google.javascript.rhino.jstype.InstanceObjectType",
    "signature": "com.google.javascript.rhino.jstype.InstanceObjectType.getReferenceName()",
    "snippet": "  @Override\n  public String getReferenceName() {\n    return getConstructor().getReferenceName();\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "InstanceObjectType.hasReferenceName",
    "class_name": "com.google.javascript.rhino.jstype.InstanceObjectType",
    "signature": "com.google.javascript.rhino.jstype.InstanceObjectType.hasReferenceName()",
    "snippet": "  @Override\n  public boolean hasReferenceName() {\n    return getConstructor().hasReferenceName();\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "InstanceObjectType.hashCode",
    "class_name": "com.google.javascript.rhino.jstype.InstanceObjectType",
    "signature": "com.google.javascript.rhino.jstype.InstanceObjectType.hashCode()",
    "snippet": "  @Override\n  public int hashCode() {\n    if (hasReferenceName()) {\n      return getReferenceName().hashCode();\n    } else {\n      return super.hashCode();\n    }\n  }",
    "comment": " If this is equal to a NamedType object, its hashCode must be equal to the hashCode of the NamedType object. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "InstanceObjectType.isNominalType",
    "class_name": "com.google.javascript.rhino.jstype.InstanceObjectType",
    "signature": "com.google.javascript.rhino.jstype.InstanceObjectType.isNominalType()",
    "snippet": "  @Override\n  public boolean isNominalType() {\n    return hasReferenceName();\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "InstanceObjectType.toString",
    "class_name": "com.google.javascript.rhino.jstype.InstanceObjectType",
    "signature": "com.google.javascript.rhino.jstype.InstanceObjectType.toString()",
    "snippet": "  @Override\n  public String toString() {\n    return constructor.getReferenceName();\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "JSType.JSType",
    "class_name": "com.google.javascript.rhino.jstype.JSType",
    "signature": "com.google.javascript.rhino.jstype.JSType.JSType(JSTypeRegistry)",
    "snippet": "  JSType(JSTypeRegistry registry) {\n    this.registry = registry;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "JSType.equals",
    "class_name": "com.google.javascript.rhino.jstype.JSType",
    "signature": "com.google.javascript.rhino.jstype.JSType.equals(Object)",
    "snippet": "  @Override public boolean equals(Object jsType) {\n    if (jsType instanceof ProxyObjectType) {\n      return jsType.equals(this);\n    }\n    return this == jsType;\n  }",
    "comment": " This method relies on the fact that for the base {@link JSType}, only one instance of each sub-type will ever be created in a given registry, so there is no need to verify members. If the object pointers are not identical, then the type member must be different. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "JSType.hashCode",
    "class_name": "com.google.javascript.rhino.jstype.JSType",
    "signature": "com.google.javascript.rhino.jstype.JSType.hashCode()",
    "snippet": "  @Override\n  public int hashCode() {\n    return System.identityHashCode(this);\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "JSType.isAllType",
    "class_name": "com.google.javascript.rhino.jstype.JSType",
    "signature": "com.google.javascript.rhino.jstype.JSType.isAllType()",
    "snippet": "  public boolean isAllType() {\n    return false;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "JSType.isEmptyType",
    "class_name": "com.google.javascript.rhino.jstype.JSType",
    "signature": "com.google.javascript.rhino.jstype.JSType.isEmptyType()",
    "snippet": "  public final boolean isEmptyType() {\n    return isNoType() || isNoObjectType();\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "JSType.isNoObjectType",
    "class_name": "com.google.javascript.rhino.jstype.JSType",
    "signature": "com.google.javascript.rhino.jstype.JSType.isNoObjectType()",
    "snippet": "  public boolean isNoObjectType() {\n    return false;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "JSType.isNoType",
    "class_name": "com.google.javascript.rhino.jstype.JSType",
    "signature": "com.google.javascript.rhino.jstype.JSType.isNoType()",
    "snippet": "  public boolean isNoType() {\n    return false;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "JSType.isSubtype",
    "class_name": "com.google.javascript.rhino.jstype.JSType",
    "signature": "com.google.javascript.rhino.jstype.JSType.isSubtype(JSType,JSType)",
    "snippet": "  static boolean isSubtype(JSType thisType, JSType thatType) {\n    // unknown\n    if (thatType.isUnknownType()) {\n      return true;\n    }\n    // equality\n    if (thisType.equals(thatType)) {\n      return true;\n    }\n    // all type\n    if (thatType.isAllType()) {\n      return true;\n    }\n    // unions\n    if (thatType instanceof UnionType) {\n      UnionType union = (UnionType)thatType;\n      for (JSType element : union.alternates) {\n        if (thisType.isSubtype(element)) {\n          return true;\n        }\n      }\n    }\n    // named types\n    if (thatType instanceof NamedType) {\n      return thisType.isSubtype(((NamedType)thatType).referencedType);\n    }\n    return false;\n  }",
    "comment": " A generic implementation meant to be used as a helper for common subtyping cases. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "JSType.isUnknownType",
    "class_name": "com.google.javascript.rhino.jstype.JSType",
    "signature": "com.google.javascript.rhino.jstype.JSType.isUnknownType()",
    "snippet": "  public boolean isUnknownType() {\n    return false;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "JSType.toObjectType",
    "class_name": "com.google.javascript.rhino.jstype.JSType",
    "signature": "com.google.javascript.rhino.jstype.JSType.toObjectType()",
    "snippet": "  public ObjectType toObjectType() {\n    return this instanceof ObjectType ? (ObjectType) this : null;\n  }",
    "comment": " Casts this to an ObjectType, or returns null if this is not an ObjectType.  Does not change the underlying JS type. If you want to simulate JS autoboxing or dereferencing, you should use autoboxesTo() or dereference(). Those methods may change the underlying JS type. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "JSTypeRegistry.JSTypeRegistry",
    "class_name": "com.google.javascript.rhino.jstype.JSTypeRegistry",
    "signature": "com.google.javascript.rhino.jstype.JSTypeRegistry.JSTypeRegistry(ErrorReporter)",
    "snippet": "  public JSTypeRegistry(ErrorReporter reporter) {\n    this.reporter = reporter;\n    nativeTypes = new JSType[JSTypeNative.values().length];\n    namesToTypes = new HashMap<String, JSType>();\n    resetForTypeCheck();\n  }",
    "comment": " Constructs a new type registry populated with the built-in types. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "JSTypeRegistry.createFunctionType",
    "class_name": "com.google.javascript.rhino.jstype.JSTypeRegistry",
    "signature": "com.google.javascript.rhino.jstype.JSTypeRegistry.createFunctionType(JSType,boolean,JSType[])",
    "snippet": "  public FunctionType createFunctionType(JSType returnType,\n      boolean lastVarArgs, JSType... parameterTypes) {\n    if (lastVarArgs) {\n      return createFunctionTypeWithVarArgs(returnType, parameterTypes);\n    } else {\n      return createFunctionType(returnType, parameterTypes);\n    }\n  }",
    "comment": " Creates a function type. @param returnType the function's return type @param lastVarArgs whether the last parameter type should be considered as an extensible var_args parameter @param parameterTypes the parameters' types ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "JSTypeRegistry.createFunctionTypeWithVarArgs",
    "class_name": "com.google.javascript.rhino.jstype.JSTypeRegistry",
    "signature": "com.google.javascript.rhino.jstype.JSTypeRegistry.createFunctionTypeWithVarArgs(JSType,JSType[])",
    "snippet": "  public FunctionType createFunctionTypeWithVarArgs(\n      JSType returnType, JSType... parameterTypes) {\n    return new FunctionType(\n        this, null, null, createParametersWithVarArgs(parameterTypes), returnType);\n  }",
    "comment": " Creates a function type. The last parameter type of the function is considered a variable length argument.  @param returnType the function's return type @param parameterTypes the parameters' types ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "JSTypeRegistry.createObjectType",
    "class_name": "com.google.javascript.rhino.jstype.JSTypeRegistry",
    "signature": "com.google.javascript.rhino.jstype.JSTypeRegistry.createObjectType(String,Node,ObjectType)",
    "snippet": "  public ObjectType createObjectType(String name, Node n,\n      ObjectType implicitPrototype) {\n    return new PrototypeObjectType(this, name, implicitPrototype);\n  }",
    "comment": " Create an object type. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "JSTypeRegistry.createOptionalParameters",
    "class_name": "com.google.javascript.rhino.jstype.JSTypeRegistry",
    "signature": "com.google.javascript.rhino.jstype.JSTypeRegistry.createOptionalParameters(JSType[])",
    "snippet": "  public Node createOptionalParameters(JSType... parameterTypes) {\n    FunctionParamBuilder builder = new FunctionParamBuilder(this);\n    builder.addOptionalParams(parameterTypes);\n    return builder.build();\n  }",
    "comment": " Creates a tree hierarchy representing a typed parameter list in which every parameter is optional. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "JSTypeRegistry.createOptionalType",
    "class_name": "com.google.javascript.rhino.jstype.JSTypeRegistry",
    "signature": "com.google.javascript.rhino.jstype.JSTypeRegistry.createOptionalType(JSType)",
    "snippet": "  public JSType createOptionalType(JSType type) {\n    if (type instanceof UnknownType || type.isAllType()) {\n      return type;\n    } else {\n      return createUnionType(type, getNativeType(JSTypeNative.VOID_TYPE));\n    }\n  }",
    "comment": " Creates a type representing optional values of the given type. @return the union of the type and the void type ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "JSTypeRegistry.createParameters",
    "class_name": "com.google.javascript.rhino.jstype.JSTypeRegistry",
    "signature": "com.google.javascript.rhino.jstype.JSTypeRegistry.createParameters(boolean,JSType[])",
    "snippet": "  private Node createParameters(boolean lastVarArgs, JSType... parameterTypes) {\n    FunctionParamBuilder builder = new FunctionParamBuilder(this);\n    int max = parameterTypes.length - 1;\n    for (int i = 0; i <= max; i++) {\n      if (lastVarArgs && i == max) {\n        builder.addVarArgs(parameterTypes[i]);\n      } else {\n        builder.addRequiredParams(parameterTypes[i]);\n      }\n    }\n    return builder.build();\n  }",
    "comment": " Creates a tree hierarchy representing a typed argument list.  @param lastVarArgs whether the last type should considered as a variable length argument. @param parameterTypes the parameter types. The last element of this array is considered a variable length argument is {@code lastVarArgs} is {@code true}. @return a tree hierarchy representing a typed argument list ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "JSTypeRegistry.createParametersWithVarArgs",
    "class_name": "com.google.javascript.rhino.jstype.JSTypeRegistry",
    "signature": "com.google.javascript.rhino.jstype.JSTypeRegistry.createParametersWithVarArgs(JSType[])",
    "snippet": "  public Node createParametersWithVarArgs(JSType... parameterTypes) {\n    return createParameters(true, parameterTypes);\n  }",
    "comment": " Creates a tree hierarchy representing a typed argument list. The last parameter type is considered a variable length argument.  @param parameterTypes the parameter types. The last element of this array is considered a variable length argument. @return a tree hierarchy representing a typed argument list. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "JSTypeRegistry.createUnionType",
    "class_name": "com.google.javascript.rhino.jstype.JSTypeRegistry",
    "signature": "com.google.javascript.rhino.jstype.JSTypeRegistry.createUnionType(JSTypeNative[])",
    "snippet": "  public JSType createUnionType(JSTypeNative... variants) {\n    UnionTypeBuilder builder = new UnionTypeBuilder(this);\n    for (JSTypeNative typeId : variants) {\n      builder.addAlternate(getNativeType(typeId));\n    }\n    return builder.build();\n  }",
    "comment": " Creates a union type whose variants are the builtin types specified by the arguments. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "JSTypeRegistry.createUnionType",
    "class_name": "com.google.javascript.rhino.jstype.JSTypeRegistry",
    "signature": "com.google.javascript.rhino.jstype.JSTypeRegistry.createUnionType(JSType[])",
    "snippet": "  public JSType createUnionType(JSType... variants) {\n    UnionTypeBuilder builder = new UnionTypeBuilder(this);\n    for (JSType type : variants) {\n      builder.addAlternate(type);\n    }\n    return builder.build();\n  }",
    "comment": " Creates a union type whose variants are the arguments. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "JSTypeRegistry.getNativeObjectType",
    "class_name": "com.google.javascript.rhino.jstype.JSTypeRegistry",
    "signature": "com.google.javascript.rhino.jstype.JSTypeRegistry.getNativeObjectType(JSTypeNative)",
    "snippet": "  public ObjectType getNativeObjectType(JSTypeNative typeId) {\n    return (ObjectType) getNativeType(typeId);\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "JSTypeRegistry.getNativeType",
    "class_name": "com.google.javascript.rhino.jstype.JSTypeRegistry",
    "signature": "com.google.javascript.rhino.jstype.JSTypeRegistry.getNativeType(JSTypeNative)",
    "snippet": "  public JSType getNativeType(JSTypeNative typeId) {\n    return nativeTypes[typeId.ordinal()];\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "JSTypeRegistry.initializeBuiltInTypes",
    "class_name": "com.google.javascript.rhino.jstype.JSTypeRegistry",
    "signature": "com.google.javascript.rhino.jstype.JSTypeRegistry.initializeBuiltInTypes()",
    "snippet": "  private void initializeBuiltInTypes() {\n    // These locals shouldn't be all caps.\n    BooleanType BOOLEAN_TYPE = new BooleanType(this);\n    registerNativeType(JSTypeNative.BOOLEAN_TYPE, BOOLEAN_TYPE);\n\n    NullType NULL_TYPE = new NullType(this);\n    registerNativeType(JSTypeNative.NULL_TYPE, NULL_TYPE);\n\n    NumberType NUMBER_TYPE = new NumberType(this);\n    registerNativeType(JSTypeNative.NUMBER_TYPE, NUMBER_TYPE);\n\n    StringType STRING_TYPE = new StringType(this);\n    registerNativeType(JSTypeNative.STRING_TYPE, STRING_TYPE);\n\n    UnknownType UNKNOWN_TYPE = new UnknownType(this, false);\n    registerNativeType(JSTypeNative.UNKNOWN_TYPE, UNKNOWN_TYPE);\n    registerNativeType(\n        JSTypeNative.CHECKED_UNKNOWN_TYPE, new UnknownType(this, true));\n\n    VoidType VOID_TYPE = new VoidType(this);\n    registerNativeType(JSTypeNative.VOID_TYPE, VOID_TYPE);\n\n    AllType ALL_TYPE = new AllType(this);\n    registerNativeType(JSTypeNative.ALL_TYPE, ALL_TYPE);\n\n    // Top Level Prototype (the One)\n    // The initializations of TOP_LEVEL_PROTOTYPE and OBJECT_FUNCTION_TYPE\n    // use each other's results, so at least one of them will get null\n    // instead of an actual type; however, this seems to be benign.\n    ObjectType TOP_LEVEL_PROTOTYPE =\n        new FunctionPrototypeType(this, null, null, true);\n    registerNativeType(JSTypeNative.TOP_LEVEL_PROTOTYPE, TOP_LEVEL_PROTOTYPE);\n\n    // Object\n    FunctionType OBJECT_FUNCTION_TYPE =\n        new FunctionType(this, \"Object\", null,\n            createOptionalParameters(ALL_TYPE), UNKNOWN_TYPE,\n            null, null, true, true);\n    OBJECT_FUNCTION_TYPE.defineDeclaredProperty(\n        \"prototype\", TOP_LEVEL_PROTOTYPE, true);\n    registerNativeType(JSTypeNative.OBJECT_FUNCTION_TYPE, OBJECT_FUNCTION_TYPE);\n\n    ObjectType OBJECT_PROTOTYPE = OBJECT_FUNCTION_TYPE.getPrototype();\n    registerNativeType(JSTypeNative.OBJECT_PROTOTYPE, OBJECT_PROTOTYPE);\n\n    ObjectType OBJECT_TYPE = OBJECT_FUNCTION_TYPE.getInstanceType();\n    registerNativeType(JSTypeNative.OBJECT_TYPE, OBJECT_TYPE);\n\n    // Function\n    FunctionType FUNCTION_FUNCTION_TYPE =\n        new FunctionType(this, \"Function\", null,\n            createParametersWithVarArgs(ALL_TYPE), UNKNOWN_TYPE,\n            null, null, true, true);\n    FUNCTION_FUNCTION_TYPE.setPrototypeBasedOn(OBJECT_TYPE);\n    registerNativeType(\n        JSTypeNative.FUNCTION_FUNCTION_TYPE, FUNCTION_FUNCTION_TYPE);\n\n    ObjectType FUNCTION_PROTOTYPE = FUNCTION_FUNCTION_TYPE.getPrototype();\n    registerNativeType(JSTypeNative.FUNCTION_PROTOTYPE, FUNCTION_PROTOTYPE);\n\n    NoType NO_TYPE = new NoType(this);\n    registerNativeType(JSTypeNative.NO_TYPE, NO_TYPE);\n\n    NoObjectType NO_OBJECT_TYPE = new NoObjectType(this);\n    registerNativeType(JSTypeNative.NO_OBJECT_TYPE, NO_OBJECT_TYPE);\n\n    // Array\n    FunctionType ARRAY_FUNCTION_TYPE =\n      new FunctionType(this, \"Array\", null,\n          createParametersWithVarArgs(ALL_TYPE), null, null, null, true, true) {\n        private static final long serialVersionUID = 1L;\n\n        @Override\n        public JSType getReturnType() {\n          return getInstanceType();\n        }\n      };\n    ObjectType arrayPrototype = ARRAY_FUNCTION_TYPE.getPrototype();\n    registerNativeType(JSTypeNative.ARRAY_FUNCTION_TYPE, ARRAY_FUNCTION_TYPE);\n\n    ObjectType ARRAY_TYPE = ARRAY_FUNCTION_TYPE.getInstanceType();\n    registerNativeType(JSTypeNative.ARRAY_TYPE, ARRAY_TYPE);\n\n    // Boolean\n    FunctionType BOOLEAN_OBJECT_FUNCTION_TYPE =\n        new FunctionType(this, \"Boolean\", null,\n            createParameters(false, ALL_TYPE), BOOLEAN_TYPE, null, null, true,\n            true);\n    ObjectType booleanPrototype = BOOLEAN_OBJECT_FUNCTION_TYPE.getPrototype();\n    registerNativeType(\n        JSTypeNative.BOOLEAN_OBJECT_FUNCTION_TYPE, BOOLEAN_OBJECT_FUNCTION_TYPE);\n\n    ObjectType BOOLEAN_OBJECT_TYPE =\n        BOOLEAN_OBJECT_FUNCTION_TYPE.getInstanceType();\n    registerNativeType(JSTypeNative.BOOLEAN_OBJECT_TYPE, BOOLEAN_OBJECT_TYPE);\n\n    // Date\n    FunctionType DATE_FUNCTION_TYPE =\n      new FunctionType(this, \"Date\", null,\n          createOptionalParameters(UNKNOWN_TYPE, UNKNOWN_TYPE, UNKNOWN_TYPE,\n              UNKNOWN_TYPE, UNKNOWN_TYPE, UNKNOWN_TYPE, UNKNOWN_TYPE),\n          STRING_TYPE, null, null, true, true);\n    ObjectType datePrototype = DATE_FUNCTION_TYPE.getPrototype();\n    registerNativeType(JSTypeNative.DATE_FUNCTION_TYPE, DATE_FUNCTION_TYPE);\n\n    ObjectType DATE_TYPE = DATE_FUNCTION_TYPE.getInstanceType();\n    registerNativeType(JSTypeNative.DATE_TYPE, DATE_TYPE);\n\n    // Error\n    FunctionType ERROR_FUNCTION_TYPE = new ErrorFunctionType(this, \"Error\");\n    registerNativeType(JSTypeNative.ERROR_FUNCTION_TYPE, ERROR_FUNCTION_TYPE);\n\n    ObjectType ERROR_TYPE = ERROR_FUNCTION_TYPE.getInstanceType();\n    registerNativeType(JSTypeNative.ERROR_TYPE, ERROR_TYPE);\n\n    // EvalError\n    FunctionType EVAL_ERROR_FUNCTION_TYPE =\n        new ErrorFunctionType(this, \"EvalError\");\n    EVAL_ERROR_FUNCTION_TYPE.setPrototypeBasedOn(ERROR_TYPE);\n    registerNativeType(\n        JSTypeNative.EVAL_ERROR_FUNCTION_TYPE, EVAL_ERROR_FUNCTION_TYPE);\n\n    ObjectType EVAL_ERROR_TYPE = EVAL_ERROR_FUNCTION_TYPE.getInstanceType();\n    registerNativeType(JSTypeNative.EVAL_ERROR_TYPE, EVAL_ERROR_TYPE);\n\n    // RangeError\n    FunctionType RANGE_ERROR_FUNCTION_TYPE =\n        new ErrorFunctionType(this, \"RangeError\");\n    RANGE_ERROR_FUNCTION_TYPE.setPrototypeBasedOn(ERROR_TYPE);\n    registerNativeType(\n        JSTypeNative.RANGE_ERROR_FUNCTION_TYPE, RANGE_ERROR_FUNCTION_TYPE);\n\n    ObjectType RANGE_ERROR_TYPE = RANGE_ERROR_FUNCTION_TYPE.getInstanceType();\n    registerNativeType(JSTypeNative.RANGE_ERROR_TYPE, RANGE_ERROR_TYPE);\n\n    // ReferenceError\n    FunctionType REFERENCE_ERROR_FUNCTION_TYPE =\n        new ErrorFunctionType(this, \"ReferenceError\");\n    REFERENCE_ERROR_FUNCTION_TYPE.setPrototypeBasedOn(ERROR_TYPE);\n    registerNativeType(\n        JSTypeNative.REFERENCE_ERROR_FUNCTION_TYPE, REFERENCE_ERROR_FUNCTION_TYPE);\n\n    ObjectType REFERENCE_ERROR_TYPE =\n        REFERENCE_ERROR_FUNCTION_TYPE.getInstanceType();\n    registerNativeType(JSTypeNative.REFERENCE_ERROR_TYPE, REFERENCE_ERROR_TYPE);\n\n    // SyntaxError\n    FunctionType SYNTAX_ERROR_FUNCTION_TYPE =\n        new ErrorFunctionType(this, \"SyntaxError\");\n    SYNTAX_ERROR_FUNCTION_TYPE.setPrototypeBasedOn(ERROR_TYPE);\n    registerNativeType(\n        JSTypeNative.SYNTAX_ERROR_FUNCTION_TYPE, SYNTAX_ERROR_FUNCTION_TYPE);\n\n    ObjectType SYNTAX_ERROR_TYPE = SYNTAX_ERROR_FUNCTION_TYPE.getInstanceType();\n    registerNativeType(JSTypeNative.SYNTAX_ERROR_TYPE, SYNTAX_ERROR_TYPE);\n\n    // TypeError\n    FunctionType TYPE_ERROR_FUNCTION_TYPE =\n        new ErrorFunctionType(this, \"TypeError\");\n    TYPE_ERROR_FUNCTION_TYPE.setPrototypeBasedOn(ERROR_TYPE);\n    registerNativeType(\n        JSTypeNative.TYPE_ERROR_FUNCTION_TYPE, TYPE_ERROR_FUNCTION_TYPE);\n\n    ObjectType TYPE_ERROR_TYPE = TYPE_ERROR_FUNCTION_TYPE.getInstanceType();\n    registerNativeType(JSTypeNative.TYPE_ERROR_TYPE, TYPE_ERROR_TYPE);\n\n    // URIError\n    FunctionType URI_ERROR_FUNCTION_TYPE =\n        new ErrorFunctionType(this, \"URIError\");\n    URI_ERROR_FUNCTION_TYPE.setPrototypeBasedOn(ERROR_TYPE);\n    registerNativeType(\n        JSTypeNative.URI_ERROR_FUNCTION_TYPE, URI_ERROR_FUNCTION_TYPE);\n\n    ObjectType URI_ERROR_TYPE = URI_ERROR_FUNCTION_TYPE.getInstanceType();\n    registerNativeType(JSTypeNative.URI_ERROR_TYPE, URI_ERROR_TYPE);\n\n    // Number\n    FunctionType NUMBER_OBJECT_FUNCTION_TYPE =\n        new FunctionType(this, \"Number\", null, createParameters(false, ALL_TYPE),\n            NUMBER_TYPE, null, null, true, true);\n    ObjectType numberPrototype = NUMBER_OBJECT_FUNCTION_TYPE.getPrototype();\n    registerNativeType(\n        JSTypeNative.NUMBER_OBJECT_FUNCTION_TYPE, NUMBER_OBJECT_FUNCTION_TYPE);\n\n    ObjectType NUMBER_OBJECT_TYPE =\n        NUMBER_OBJECT_FUNCTION_TYPE.getInstanceType();\n    registerNativeType(JSTypeNative.NUMBER_OBJECT_TYPE, NUMBER_OBJECT_TYPE);\n\n    // RegExp\n    FunctionType REGEXP_FUNCTION_TYPE =\n      new FunctionType(this, \"RegExp\", null,\n          createOptionalParameters(ALL_TYPE, ALL_TYPE),\n          null, null, null, true, true) {\n        private static final long serialVersionUID = 1L;\n\n        @Override\n        public JSType getReturnType() {\n          return getInstanceType();\n        }\n      };\n    ObjectType regexpPrototype = REGEXP_FUNCTION_TYPE.getPrototype();\n    registerNativeType(JSTypeNative.REGEXP_FUNCTION_TYPE, REGEXP_FUNCTION_TYPE);\n\n    ObjectType REGEXP_TYPE = REGEXP_FUNCTION_TYPE.getInstanceType();\n    registerNativeType(JSTypeNative.REGEXP_TYPE, REGEXP_TYPE);\n\n    // String\n    FunctionType STRING_OBJECT_FUNCTION_TYPE =\n        new FunctionType(this, \"String\", null, createParameters(false, ALL_TYPE),\n        STRING_TYPE, null, null, true, true);\n    ObjectType stringPrototype = STRING_OBJECT_FUNCTION_TYPE.getPrototype();\n    registerNativeType(\n        JSTypeNative.STRING_OBJECT_FUNCTION_TYPE, STRING_OBJECT_FUNCTION_TYPE);\n\n    ObjectType STRING_OBJECT_TYPE =\n        STRING_OBJECT_FUNCTION_TYPE.getInstanceType();\n    registerNativeType(\n        JSTypeNative.STRING_OBJECT_TYPE, STRING_OBJECT_TYPE);\n\n    // (Object,string,number)\n    JSType OBJECT_NUMBER_STRING =\n        createUnionType(OBJECT_TYPE, NUMBER_TYPE, STRING_TYPE);\n    registerNativeType(JSTypeNative.OBJECT_NUMBER_STRING, OBJECT_NUMBER_STRING);\n\n    // (Object,string,number,boolean)\n    JSType OBJECT_NUMBER_STRING_BOOLEAN =\n        createUnionType(OBJECT_TYPE, NUMBER_TYPE, STRING_TYPE, BOOLEAN_TYPE);\n    registerNativeType(JSTypeNative.OBJECT_NUMBER_STRING_BOOLEAN,\n        OBJECT_NUMBER_STRING_BOOLEAN);\n\n    // (string,number,boolean)\n    JSType NUMBER_STRING_BOOLEAN =\n        createUnionType(NUMBER_TYPE, STRING_TYPE, BOOLEAN_TYPE);\n    registerNativeType(JSTypeNative.NUMBER_STRING_BOOLEAN,\n        NUMBER_STRING_BOOLEAN);\n\n    // (string,number)\n    JSType NUMBER_STRING = createUnionType(NUMBER_TYPE, STRING_TYPE);\n    registerNativeType(JSTypeNative.NUMBER_STRING, NUMBER_STRING);\n\n    // Native object properties are filled in by externs...\n\n    // (String, string)\n    JSType STRING_VALUE_OR_OBJECT_TYPE =\n        createUnionType(STRING_OBJECT_TYPE, STRING_TYPE);\n    registerNativeType(\n        JSTypeNative.STRING_VALUE_OR_OBJECT_TYPE, STRING_VALUE_OR_OBJECT_TYPE);\n\n    // (Number, number)\n    JSType NUMBER_VALUE_OR_OBJECT_TYPE =\n        createUnionType(NUMBER_OBJECT_TYPE, NUMBER_TYPE);\n    registerNativeType(\n        JSTypeNative.NUMBER_VALUE_OR_OBJECT_TYPE, NUMBER_VALUE_OR_OBJECT_TYPE);\n\n    // unknown function type, i.e. (?...) -> ?\n    FunctionType U2U_FUNCTION_TYPE =\n        createFunctionType(UNKNOWN_TYPE, true, UNKNOWN_TYPE);\n    registerNativeType(JSTypeNative.U2U_FUNCTION_TYPE, U2U_FUNCTION_TYPE);\n\n    // unknown constructor type, i.e. (?...) -> ? with the NoObject type\n    // as instance type\n    FunctionType U2U_CONSTRUCTOR_TYPE =\n        // This is equivalent to\n        // createConstructorType(UNKNOWN_TYPE, true, UNKNOWN_TYPE), but,\n        // in addition, overrides getInstanceType() to return the NoObject type\n        // instead of a new anonymous object.\n        new FunctionType(this, \"Function\", null,\n          createParametersWithVarArgs(\n              UNKNOWN_TYPE), UNKNOWN_TYPE, NO_OBJECT_TYPE, null, true, true) {\n          private static final long serialVersionUID = 1L;\n\n          @Override public FunctionType getConstructor() {\n            return registry.getNativeFunctionType(\n                JSTypeNative.FUNCTION_FUNCTION_TYPE);\n          }\n        };\n\n    // The U2U_CONSTRUCTOR is weird, because it's the supertype of its\n    // own constructor.\n    registerNativeType(JSTypeNative.U2U_CONSTRUCTOR_TYPE, U2U_CONSTRUCTOR_TYPE);\n    registerNativeType(\n        JSTypeNative.FUNCTION_INSTANCE_TYPE, U2U_CONSTRUCTOR_TYPE);\n\n    FUNCTION_FUNCTION_TYPE.setInstanceType(U2U_CONSTRUCTOR_TYPE);\n    U2U_CONSTRUCTOR_TYPE.setImplicitPrototype(FUNCTION_PROTOTYPE);\n\n    // least function type, i.e. (All...) -> NoType\n    FunctionType LEAST_FUNCTION_TYPE =\n        createFunctionType(NO_TYPE, true, ALL_TYPE);\n    registerNativeType(JSTypeNative.LEAST_FUNCTION_TYPE, LEAST_FUNCTION_TYPE);\n\n    // the 'this' object in the global scope\n    ObjectType GLOBAL_THIS = createObjectType(\"global this\", null,\n        UNKNOWN_TYPE /* to be resolved later */);\n    registerNativeType(JSTypeNative.GLOBAL_THIS, GLOBAL_THIS);\n\n    // greatest function type, i.e. (NoType...) -> All\n    FunctionType GREATEST_FUNCTION_TYPE =\n      createFunctionType(ALL_TYPE, true, NO_TYPE);\n    registerNativeType(JSTypeNative.GREATEST_FUNCTION_TYPE,\n        GREATEST_FUNCTION_TYPE);\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "JSTypeRegistry.initializeRegistry",
    "class_name": "com.google.javascript.rhino.jstype.JSTypeRegistry",
    "signature": "com.google.javascript.rhino.jstype.JSTypeRegistry.initializeRegistry()",
    "snippet": "  private void initializeRegistry() {\n    register(getNativeType(JSTypeNative.ARRAY_TYPE));\n    register(getNativeType(JSTypeNative.BOOLEAN_OBJECT_TYPE));\n    register(getNativeType(JSTypeNative.BOOLEAN_TYPE));\n    register(getNativeType(JSTypeNative.DATE_TYPE));\n    register(getNativeType(JSTypeNative.NULL_TYPE));\n    register(getNativeType(JSTypeNative.NULL_TYPE), \"Null\");\n    register(getNativeType(JSTypeNative.NUMBER_OBJECT_TYPE));\n    register(getNativeType(JSTypeNative.NUMBER_TYPE));\n    register(getNativeType(JSTypeNative.OBJECT_TYPE));\n    register(getNativeType(JSTypeNative.ERROR_TYPE));\n    register(getNativeType(JSTypeNative.URI_ERROR_TYPE));\n    register(getNativeType(JSTypeNative.EVAL_ERROR_TYPE));\n    register(getNativeType(JSTypeNative.TYPE_ERROR_TYPE));\n    register(getNativeType(JSTypeNative.RANGE_ERROR_TYPE));\n    register(getNativeType(JSTypeNative.REFERENCE_ERROR_TYPE));\n    register(getNativeType(JSTypeNative.SYNTAX_ERROR_TYPE));\n    register(getNativeType(JSTypeNative.REGEXP_TYPE));\n    register(getNativeType(JSTypeNative.STRING_OBJECT_TYPE));\n    register(getNativeType(JSTypeNative.STRING_TYPE));\n    register(getNativeType(JSTypeNative.VOID_TYPE));\n    register(getNativeType(JSTypeNative.VOID_TYPE), \"Undefined\");\n    register(getNativeType(JSTypeNative.VOID_TYPE), \"void\");\n    register(getNativeType(JSTypeNative.FUNCTION_INSTANCE_TYPE), \"Function\");\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "JSTypeRegistry.register",
    "class_name": "com.google.javascript.rhino.jstype.JSTypeRegistry",
    "signature": "com.google.javascript.rhino.jstype.JSTypeRegistry.register(JSType)",
    "snippet": "  private void register(JSType type) {\n    register(type, type.toString());\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "JSTypeRegistry.register",
    "class_name": "com.google.javascript.rhino.jstype.JSTypeRegistry",
    "signature": "com.google.javascript.rhino.jstype.JSTypeRegistry.register(JSType,String)",
    "snippet": "  private void register(JSType type, String name) {\n    namesToTypes.put(name, type);\n\n    // Add all the namespaces in which this name lives.\n    while (name.indexOf('.') > 0) {\n      name = name.substring(0, name.lastIndexOf('.'));\n      namespaces.add(name);\n    }\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "JSTypeRegistry.registerNativeType",
    "class_name": "com.google.javascript.rhino.jstype.JSTypeRegistry",
    "signature": "com.google.javascript.rhino.jstype.JSTypeRegistry.registerNativeType(JSTypeNative,JSType)",
    "snippet": "  private void registerNativeType(JSTypeNative typeId, JSType type) {\n    nativeTypes[typeId.ordinal()] = type;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "JSTypeRegistry.registerPropertyOnType",
    "class_name": "com.google.javascript.rhino.jstype.JSTypeRegistry",
    "signature": "com.google.javascript.rhino.jstype.JSTypeRegistry.registerPropertyOnType(String,ObjectType)",
    "snippet": "  public void registerPropertyOnType(String propertyName, ObjectType owner) {\n    Set<ObjectType> typeSet = typesIndexedByProperty.get(propertyName);\n    if (typeSet == null) {\n      typesIndexedByProperty.put(propertyName, typeSet = Sets.newHashSet());\n    }\n    greatestSubtypeByProperty.remove(propertyName);\n    typeSet.add(owner);\n  }",
    "comment": " Tells the type system that {@code owner} may have a property named {@code propertyName}. This allows the registry to keep track of what types a property is defined upon.  This is NOT the same as saying that {@code owner} must have a property named type. ObjectType#hasProperty attempts to minimize false positives (\"if we're not sure, then don't type check this property\"). The type registry, on the other hand, should attempt to minimize false negatives (\"if this property is assigned anywhere in the program, it must show up in the type registry\"). ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "JSTypeRegistry.resetForTypeCheck",
    "class_name": "com.google.javascript.rhino.jstype.JSTypeRegistry",
    "signature": "com.google.javascript.rhino.jstype.JSTypeRegistry.resetForTypeCheck()",
    "snippet": "  public void resetForTypeCheck() {\n    typesIndexedByProperty.clear();\n    initializeBuiltInTypes();\n    namesToTypes.clear();\n    namespaces.clear();\n    initializeRegistry();\n  }",
    "comment": " Reset to run the TypeCheck pass. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "NoObjectType.NoObjectType",
    "class_name": "com.google.javascript.rhino.jstype.NoObjectType",
    "signature": "com.google.javascript.rhino.jstype.NoObjectType.NoObjectType(JSTypeRegistry)",
    "snippet": "  NoObjectType(JSTypeRegistry registry) {\n    super(registry, null, null, null, null, null, null, true, true);\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "NoObjectType.getReturnType",
    "class_name": "com.google.javascript.rhino.jstype.NoObjectType",
    "signature": "com.google.javascript.rhino.jstype.NoObjectType.getReturnType()",
    "snippet": "  @Override\n  public JSType getReturnType() {\n    return this;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "NoObjectType.isNoObjectType",
    "class_name": "com.google.javascript.rhino.jstype.NoObjectType",
    "signature": "com.google.javascript.rhino.jstype.NoObjectType.isNoObjectType()",
    "snippet": "  @Override\n  public boolean isNoObjectType() {\n    return true;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "NoType.NoType",
    "class_name": "com.google.javascript.rhino.jstype.NoType",
    "signature": "com.google.javascript.rhino.jstype.NoType.NoType(JSTypeRegistry)",
    "snippet": "  NoType(JSTypeRegistry registry) {\n    super(registry);\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "NoType.isNoType",
    "class_name": "com.google.javascript.rhino.jstype.NoType",
    "signature": "com.google.javascript.rhino.jstype.NoType.isNoType()",
    "snippet": "  @Override\n  public boolean isNoType() {\n    return true;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "NullType.NullType",
    "class_name": "com.google.javascript.rhino.jstype.NullType",
    "signature": "com.google.javascript.rhino.jstype.NullType.NullType(JSTypeRegistry)",
    "snippet": "  NullType(JSTypeRegistry registry) {\n    super(registry);\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "NullType.toString",
    "class_name": "com.google.javascript.rhino.jstype.NullType",
    "signature": "com.google.javascript.rhino.jstype.NullType.toString()",
    "snippet": "  @Override\n  public String toString() {\n    return \"null\";\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "NumberType.NumberType",
    "class_name": "com.google.javascript.rhino.jstype.NumberType",
    "signature": "com.google.javascript.rhino.jstype.NumberType.NumberType(JSTypeRegistry)",
    "snippet": "  NumberType(JSTypeRegistry registry) {\n    super(registry);\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "NumberType.toString",
    "class_name": "com.google.javascript.rhino.jstype.NumberType",
    "signature": "com.google.javascript.rhino.jstype.NumberType.toString()",
    "snippet": "  @Override\n  public String toString() {\n    return \"number\";\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "ObjectType.ObjectType",
    "class_name": "com.google.javascript.rhino.jstype.ObjectType",
    "signature": "com.google.javascript.rhino.jstype.ObjectType.ObjectType(JSTypeRegistry)",
    "snippet": "  ObjectType(JSTypeRegistry registry) {\n    super(registry);\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "ObjectType.cast",
    "class_name": "com.google.javascript.rhino.jstype.ObjectType",
    "signature": "com.google.javascript.rhino.jstype.ObjectType.cast(JSType)",
    "snippet": "  public static ObjectType cast(JSType type) {\n    return type == null ? null : type.toObjectType();\n  }",
    "comment": " A null-safe version of JSType#toObjectType. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "ObjectType.defineDeclaredProperty",
    "class_name": "com.google.javascript.rhino.jstype.ObjectType",
    "signature": "com.google.javascript.rhino.jstype.ObjectType.defineDeclaredProperty(String,JSType,boolean)",
    "snippet": "  public final boolean defineDeclaredProperty(String propertyName,\n      JSType type, boolean inExterns) {\n    // All property definitions go through this method\n    // or defineInferredProperty.\n    registry.registerPropertyOnType(propertyName, this);\n\n    return defineProperty(propertyName, type, false, inExterns);\n  }",
    "comment": " Defines a property whose type is synthesized (i.e. not inferred). @param propertyName the property's name @param type the type @param inExterns {@code true} if this property was defined in an externs file. TightenTypes assumes that any function passed to an externs property could be called, so setting this incorrectly could result in live code being removed. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "ObjectType.hasCachedValues",
    "class_name": "com.google.javascript.rhino.jstype.ObjectType",
    "signature": "com.google.javascript.rhino.jstype.ObjectType.hasCachedValues()",
    "snippet": "  public boolean hasCachedValues() {\n    return !unknown;\n  }",
    "comment": " Returns true if any cached valeus have been set for this type.  If true, then the prototype chain should not be changed, as it might invalidate the cached values. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "ObjectType.isImplicitPrototype",
    "class_name": "com.google.javascript.rhino.jstype.ObjectType",
    "signature": "com.google.javascript.rhino.jstype.ObjectType.isImplicitPrototype(ObjectType)",
    "snippet": "  final boolean isImplicitPrototype(ObjectType prototype) {\n    for (ObjectType current = this;\n         current != null;\n         current = current.getImplicitPrototype()) {\n      if (current.equals(prototype)) {\n        return true;\n      }\n    }\n    return false;\n  }",
    "comment": " Checks that the prototype is an implicit prototype of this object. Since each object has an implicit prototype, an implicit prototype's implicit prototype is also this implicit prototype's.  @param prototype any prototype based object  @return {@code true} if {@code prototype} is {@code equal} to any object in this object's implicit prototype chain. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "ObjectType.isUnknownType",
    "class_name": "com.google.javascript.rhino.jstype.ObjectType",
    "signature": "com.google.javascript.rhino.jstype.ObjectType.isUnknownType()",
    "snippet": "  @Override\n  public boolean isUnknownType() {\n    // If the object is unknown now, check the supertype again,\n    // because it might have been resolved since the last check.\n    if (unknown) {\n      ObjectType implicitProto = getImplicitPrototype();\n      if (implicitProto == null ||\n          implicitProto.isNativeObjectType()) {\n        unknown = false;\n      } else {\n        unknown = implicitProto.isUnknownType();\n      }\n    }\n    return unknown;\n  }",
    "comment": " We treat this as the unknown type if any of its implicit prototype properties is unknown. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "PrototypeObjectType.PrototypeObjectType",
    "class_name": "com.google.javascript.rhino.jstype.PrototypeObjectType",
    "signature": "com.google.javascript.rhino.jstype.PrototypeObjectType.PrototypeObjectType(JSTypeRegistry,String,ObjectType)",
    "snippet": "  PrototypeObjectType(JSTypeRegistry registry, String className,\n      ObjectType implicitPrototype) {\n    this(registry, className, implicitPrototype, false);\n  }",
    "comment": " Creates an object type.  @param className the name of the class.  May be {@code null} to denote an anonymous class.  @param implicitPrototype the implicit prototype (a.k.a. {@code [[Prototype]]}) as defined by ECMA-262. If the implicit prototype is {@code null} the implicit prototype will be set to the {@link JSTypeNative#OBJECT_TYPE}. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "PrototypeObjectType.PrototypeObjectType",
    "class_name": "com.google.javascript.rhino.jstype.PrototypeObjectType",
    "signature": "com.google.javascript.rhino.jstype.PrototypeObjectType.PrototypeObjectType(JSTypeRegistry,String,ObjectType,boolean)",
    "snippet": "  PrototypeObjectType(JSTypeRegistry registry, String className,\n      ObjectType implicitPrototype, boolean nativeType) {\n    super(registry);\n    this.properties = Maps.newHashMap();\n    this.className = className;\n    this.nativeType = nativeType;\n    if (nativeType) {\n      this.implicitPrototype = implicitPrototype;\n    } else if (implicitPrototype == null) {\n      this.implicitPrototype =\n          registry.getNativeObjectType(JSTypeNative.OBJECT_TYPE);\n    } else {\n      this.implicitPrototype = implicitPrototype;\n    }\n  }",
    "comment": " Creates an object type, allowing specification of the implicit prototype when creating native objects. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "PrototypeObjectType.getConstructor",
    "class_name": "com.google.javascript.rhino.jstype.PrototypeObjectType",
    "signature": "com.google.javascript.rhino.jstype.PrototypeObjectType.getConstructor()",
    "snippet": "  @Override\n  public FunctionType getConstructor() {\n    return null;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "PrototypeObjectType.getImplicitPrototype",
    "class_name": "com.google.javascript.rhino.jstype.PrototypeObjectType",
    "signature": "com.google.javascript.rhino.jstype.PrototypeObjectType.getImplicitPrototype()",
    "snippet": "  @Override\n  public ObjectType getImplicitPrototype() {\n    return implicitPrototype;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "PrototypeObjectType.getReferenceName",
    "class_name": "com.google.javascript.rhino.jstype.PrototypeObjectType",
    "signature": "com.google.javascript.rhino.jstype.PrototypeObjectType.getReferenceName()",
    "snippet": "  @Override\n  public String getReferenceName() {\n    if (className != null) {\n      return className;\n    } else {\n      return \"{...}\";\n    }\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "PrototypeObjectType.hasCachedValues",
    "class_name": "com.google.javascript.rhino.jstype.PrototypeObjectType",
    "signature": "com.google.javascript.rhino.jstype.PrototypeObjectType.hasCachedValues()",
    "snippet": "  @Override\n  public boolean hasCachedValues() {\n    return super.hasCachedValues();\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "PrototypeObjectType.hasReferenceName",
    "class_name": "com.google.javascript.rhino.jstype.PrototypeObjectType",
    "signature": "com.google.javascript.rhino.jstype.PrototypeObjectType.hasReferenceName()",
    "snippet": "  @Override\n  public boolean hasReferenceName() {\n    return className != null;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "PrototypeObjectType.implicitPrototypeChainIsUnknown",
    "class_name": "com.google.javascript.rhino.jstype.PrototypeObjectType",
    "signature": "com.google.javascript.rhino.jstype.PrototypeObjectType.implicitPrototypeChainIsUnknown()",
    "snippet": "  private boolean implicitPrototypeChainIsUnknown() {\n    ObjectType p = getImplicitPrototype();\n    while (p != null) {\n      if (p.isUnknownType()) {\n        return true;\n      }\n      p = p.getImplicitPrototype();\n    }\n    return false;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "PrototypeObjectType.isNativeObjectType",
    "class_name": "com.google.javascript.rhino.jstype.PrototypeObjectType",
    "signature": "com.google.javascript.rhino.jstype.PrototypeObjectType.isNativeObjectType()",
    "snippet": "  @Override\n  public boolean isNativeObjectType() {\n    return nativeType;\n  }",
    "comment": "Whether this is a built-in object. */",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "PrototypeObjectType.isSubtype",
    "class_name": "com.google.javascript.rhino.jstype.PrototypeObjectType",
    "signature": "com.google.javascript.rhino.jstype.PrototypeObjectType.isSubtype(JSType)",
    "snippet": "  @Override\n  public boolean isSubtype(JSType that) {\n    if (JSType.isSubtype(this, that)) {\n      return true;\n    }\n\n    // Union types\n    if (that instanceof UnionType) {\n      // The static {@code JSType.isSubtype} check already decomposed\n      // union types, so we don't need to check those again.\n      return false;\n    }\n\n    // record types\n    if (that instanceof RecordType) {\n      return RecordType.isSubtype(this, (RecordType) that);\n    }\n\n    // Interfaces\n    // Find all the interfaces implemented by this class and compare each one\n    // to the interface instance.\n    ObjectType thatObj = that.toObjectType();\n    ObjectType thatCtor = thatObj == null ? null : thatObj.getConstructor();\n    if (thatCtor != null && thatCtor.isInterface()) {\n      Iterable<ObjectType> thisInterfaces = getCtorImplementedInterfaces();\n      for (ObjectType thisInterface : thisInterfaces) {\n        if (thisInterface.isSubtype(that)) {\n          return true;\n        }\n      }\n    }\n\n    // other prototype based objects\n    if (that != null) {\n      if (isUnknownType() || implicitPrototypeChainIsUnknown()) {\n        // If unsure, say 'yes', to avoid spurious warnings.\n        // TODO(user): resolve the prototype chain completely in all cases,\n        // to avoid guessing.\n        return true;\n      }\n      return this.isImplicitPrototype(thatObj);\n    }\n\n    return false;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "PrototypeObjectType.setImplicitPrototype",
    "class_name": "com.google.javascript.rhino.jstype.PrototypeObjectType",
    "signature": "com.google.javascript.rhino.jstype.PrototypeObjectType.setImplicitPrototype(ObjectType)",
    "snippet": "  void setImplicitPrototype(ObjectType implicitPrototype) {\n    checkState(!hasCachedValues());\n    this.implicitPrototype = implicitPrototype;\n  }",
    "comment": " This should only be reset on the FunctionPrototypeType, only to fix an incorrectly established prototype chain due to the user having a mismatch in super class declaration, and only before properties on that type are processed. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "StringType.StringType",
    "class_name": "com.google.javascript.rhino.jstype.StringType",
    "signature": "com.google.javascript.rhino.jstype.StringType.StringType(JSTypeRegistry)",
    "snippet": "  StringType(JSTypeRegistry registry) {\n    super(registry);\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "StringType.toString",
    "class_name": "com.google.javascript.rhino.jstype.StringType",
    "signature": "com.google.javascript.rhino.jstype.StringType.toString()",
    "snippet": "  @Override\n  public String toString() {\n    return \"string\";\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "UnionType.UnionType",
    "class_name": "com.google.javascript.rhino.jstype.UnionType",
    "signature": "com.google.javascript.rhino.jstype.UnionType.UnionType(JSTypeRegistry,Set)",
    "snippet": "  UnionType(JSTypeRegistry registry, Set<JSType> alternates) {\n    super(registry);\n    this.alternates = alternates;\n    this.hashcode = this.alternates.hashCode();\n  }",
    "comment": " Creates a union type.  @param alternates the alternates of the union ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "UnionTypeBuilder.UnionTypeBuilder",
    "class_name": "com.google.javascript.rhino.jstype.UnionTypeBuilder",
    "signature": "com.google.javascript.rhino.jstype.UnionTypeBuilder.UnionTypeBuilder(JSTypeRegistry)",
    "snippet": "  UnionTypeBuilder(JSTypeRegistry registry) {\n    this.registry = registry;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "UnionTypeBuilder.addAlternate",
    "class_name": "com.google.javascript.rhino.jstype.UnionTypeBuilder",
    "signature": "com.google.javascript.rhino.jstype.UnionTypeBuilder.addAlternate(JSType)",
    "snippet": "  UnionTypeBuilder addAlternate(JSType alternate) {\n    // build() returns the bottom type by default, so we can\n    // just bail out early here.\n    if (alternate.isNoType()) {\n      return this;\n    }\n\n    isAllType = isAllType || alternate.isAllType();\n\n    boolean isAlternateUnknown = alternate instanceof UnknownType;\n    isNativeUnknownType = isNativeUnknownType || isAlternateUnknown;\n    if (isAlternateUnknown) {\n      areAllUnknownsChecked = areAllUnknownsChecked &&\n          alternate.isCheckedUnknownType();\n    }\n    if (!isAllType && !isNativeUnknownType) {\n      if (alternate instanceof UnionType) {\n        UnionType union = (UnionType) alternate;\n        for (JSType unionAlt : union.getAlternates()) {\n          addAlternate(unionAlt);\n        }\n      } else {\n        if (!alternate.isUnknownType()) {\n          Iterator<JSType> it = alternates.iterator();\n          while (it.hasNext()) {\n            JSType current = it.next();\n            if (!current.isUnknownType()) {\n              if (alternate.isSubtype(current)) {\n                // Alternate is unnecessary.\n                return this;\n              } else if (current.isSubtype(alternate)) {\n                // Alternate makes current obsolete\n                it.remove();\n              }\n            }\n          }\n        }\n        alternates.add(alternate);\n        result = null; // invalidate the memoized result\n      }\n    } else {\n      result = null;\n    }\n    return this;\n  }",
    "comment": " Adds an alternate to the union type under construction. Returns this for easy chaining. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "UnionTypeBuilder.build",
    "class_name": "com.google.javascript.rhino.jstype.UnionTypeBuilder",
    "signature": "com.google.javascript.rhino.jstype.UnionTypeBuilder.build()",
    "snippet": "  JSType build() {\n    if (result == null) {\n      if (isAllType) {\n        result = registry.getNativeType(ALL_TYPE);\n      } else if (isNativeUnknownType) {\n        if (areAllUnknownsChecked) {\n          result = registry.getNativeType(CHECKED_UNKNOWN_TYPE);\n        } else {\n          result = registry.getNativeType(UNKNOWN_TYPE);\n        }\n      } else {\n        Set<JSType> alternateSet = Sets.newUnmodifiableHashSet(alternates);\n        int size = alternateSet.size();\n        if (size > MAX_UNION_SIZE) {\n          result = registry.getNativeType(UNKNOWN_TYPE);\n        } else {\n          if (size > 1) {\n            result = new UnionType(registry, alternateSet);\n          } else if (size == 1) {\n            result = alternates.iterator().next();\n          } else {\n            result = registry.getNativeType(NO_TYPE);\n          }\n        }\n      }\n    }\n    return result;\n  }",
    "comment": " Creates a union. @return A UnionType if it has two or more alternates, the only alternate if it has one and otherwise {@code NO_TYPE}. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "UnknownType.UnknownType",
    "class_name": "com.google.javascript.rhino.jstype.UnknownType",
    "signature": "com.google.javascript.rhino.jstype.UnknownType.UnknownType(JSTypeRegistry,boolean)",
    "snippet": "  UnknownType(JSTypeRegistry registry, boolean isChecked) {\n    super(registry);\n    this.isChecked = isChecked;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "ValueType.ValueType",
    "class_name": "com.google.javascript.rhino.jstype.ValueType",
    "signature": "com.google.javascript.rhino.jstype.ValueType.ValueType(JSTypeRegistry)",
    "snippet": "  ValueType(JSTypeRegistry registry) {\n    super(registry);\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "ValueType.isSubtype",
    "class_name": "com.google.javascript.rhino.jstype.ValueType",
    "signature": "com.google.javascript.rhino.jstype.ValueType.isSubtype(JSType)",
    "snippet": "  @Override\n  public boolean isSubtype(JSType that) {\n    return JSType.isSubtype(this, that);\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "VoidType.VoidType",
    "class_name": "com.google.javascript.rhino.jstype.VoidType",
    "signature": "com.google.javascript.rhino.jstype.VoidType.VoidType(JSTypeRegistry)",
    "snippet": "  VoidType(JSTypeRegistry registry) {\n    super(registry);\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "VoidType.toString",
    "class_name": "com.google.javascript.rhino.jstype.VoidType",
    "signature": "com.google.javascript.rhino.jstype.VoidType.toString()",
    "snippet": "  @Override\n  public String toString() {\n    return \"undefined\";\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  }
]