[
  {
    "name": "StringUtils.defaultString",
    "class_name": "org.apache.commons.lang.StringUtils",
    "signature": "org.apache.commons.lang.StringUtils.defaultString(String)",
    "snippet": "    public static String defaultString(String str) {\n        return str == null ? EMPTY : str;\n    }",
    "comment": " <p>Returns either the passed in String, or if the String is <code>null</code>, an empty String (\"\").</p>  <pre> StringUtils.defaultString(null)  = \"\" StringUtils.defaultString(\"\")    = \"\" StringUtils.defaultString(\"bat\") = \"bat\" </pre>  @see ObjectUtils#toString(Object) @see String#valueOf(Object) @param str  the String to check, may be null @return the passed in String, or the empty String if it was <code>null</code> ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "StringUtils.indexOf",
    "class_name": "org.apache.commons.lang.StringUtils",
    "signature": "org.apache.commons.lang.StringUtils.indexOf(String,String,int)",
    "snippet": "    public static int indexOf(String str, String searchStr, int startPos) {\n        if (str == null || searchStr == null) {\n            return -1;\n        }\n        // JDK1.2/JDK1.3 have a bug, when startPos > str.length for \"\", hence\n        if (searchStr.length() == 0 && startPos >= str.length()) {\n            return str.length();\n        }\n        return str.indexOf(searchStr, startPos);\n    }",
    "comment": " <p>Finds the first index within a String, handling <code>null</code>. This method uses {@link String#indexOf(String, int)}.</p>  <p>A <code>null</code> String will return <code>-1</code>. A negative start position is treated as zero. An empty (\"\") search String always matches. A start position greater than the string length only matches an empty search String.</p>  <pre> StringUtils.indexOf(null, *, *)          = -1 StringUtils.indexOf(*, null, *)          = -1 StringUtils.indexOf(\"\", \"\", 0)           = 0 StringUtils.indexOf(\"aabaabaa\", \"a\", 0)  = 0 StringUtils.indexOf(\"aabaabaa\", \"b\", 0)  = 2 StringUtils.indexOf(\"aabaabaa\", \"ab\", 0) = 1 StringUtils.indexOf(\"aabaabaa\", \"b\", 3)  = 5 StringUtils.indexOf(\"aabaabaa\", \"b\", 9)  = -1 StringUtils.indexOf(\"aabaabaa\", \"b\", -1) = 2 StringUtils.indexOf(\"aabaabaa\", \"\", 2)   = 2 StringUtils.indexOf(\"abc\", \"\", 9)        = 3 </pre>  @param str  the String to check, may be null @param searchStr  the String to find, may be null @param startPos  the start position, negative treated as zero @return the first index of the search String, -1 if no match or <code>null</code> string input @since 2.0 ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "WordUtils.abbreviate",
    "class_name": "org.apache.commons.lang.WordUtils",
    "signature": "org.apache.commons.lang.WordUtils.abbreviate(String,int,int,String)",
    "snippet": "    public static String abbreviate(String str, int lower, int upper, String appendToEnd) {\n        // initial parameter checks\n        if (str == null) {\n            return null;\n        }\n        if (str.length() == 0) {\n            return StringUtils.EMPTY;\n        }\n\n        // if the lower value is greater than the length of the string,\n        // set to the length of the string\n        // if the upper value is -1 (i.e. no limit) or is greater\n        // than the length of the string, set to the length of the string\n        if (upper == -1 || upper > str.length()) {\n            upper = str.length();\n        }\n        // if upper is less than lower, raise it to lower\n        if (upper < lower) {\n            upper = lower;\n        }\n\n        StringBuffer result = new StringBuffer();\n        int index = StringUtils.indexOf(str, \" \", lower);\n        if (index == -1) {\n            result.append(str.substring(0, upper));\n            // only if abbreviation has occured do we append the appendToEnd value\n            if (upper != str.length()) {\n                result.append(StringUtils.defaultString(appendToEnd));\n            }\n        } else if (index > upper) {\n            result.append(str.substring(0, upper));\n            result.append(StringUtils.defaultString(appendToEnd));\n        } else {\n            result.append(str.substring(0, index));\n            result.append(StringUtils.defaultString(appendToEnd));\n        }\n        return result.toString();\n    }",
    "comment": " Abbreviates a string nicely.  This method searches for the first space after the lower limit and abbreviates the String there. It will also append any String passed as a parameter to the end of the String. The upper limit can be specified to forcibly abbreviate a String.  @param str         the string to be abbreviated. If null is passed, null is returned. If the empty String is passed, the empty string is returned. @param lower       the lower limit. @param upper       the upper limit; specify -1 if no limit is desired. If the upper limit is lower than the lower limit, it will be adjusted to be the same as the lower limit. @param appendToEnd String to be appended to the end of the abbreviated string. This is appended ONLY if the string was indeed abbreviated. The append does not count towards the lower or upper limits. @return the abbreviated String. @since 2.4 ",
    "is_bug": true,
    "failing_test_cases": 1,
    "buggy_methods": 1
  }
]