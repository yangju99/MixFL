[
  {
    "name": "AbstractRealMatrix.AbstractRealMatrix",
    "class_name": "org.apache.commons.math.linear.AbstractRealMatrix",
    "signature": "org.apache.commons.math.linear.AbstractRealMatrix.AbstractRealMatrix()",
    "snippet": "    protected AbstractRealMatrix() {}",
    "comment": " Creates a matrix with no data ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "AbstractRealMatrix.AbstractRealMatrix",
    "class_name": "org.apache.commons.math.linear.AbstractRealMatrix",
    "signature": "org.apache.commons.math.linear.AbstractRealMatrix.AbstractRealMatrix(int,int)",
    "snippet": "    protected AbstractRealMatrix(final int rowDimension, final int columnDimension) {\n        if (rowDimension < 1) {\n            throw new NotStrictlyPositiveException(rowDimension);\n        }\n        if (columnDimension < 1) {\n            throw new NotStrictlyPositiveException(columnDimension);\n        }\n    }",
    "comment": " Create a new RealMatrix with the supplied row and column dimensions.  @param rowDimension  the number of rows in the new matrix @param columnDimension  the number of columns in the new matrix @throws NotStrictlyPositiveException if row or column dimension is not positive ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "AbstractRealMatrix.getRow",
    "class_name": "org.apache.commons.math.linear.AbstractRealMatrix",
    "signature": "org.apache.commons.math.linear.AbstractRealMatrix.getRow(int)",
    "snippet": "    public double[] getRow(final int row) {\n        MatrixUtils.checkRowIndex(this, row);\n        final int nCols = getColumnDimension();\n        final double[] out = new double[nCols];\n        for (int i = 0; i < nCols; ++i) {\n            out[i] = getEntry(row, i);\n        }\n\n        return out;\n    }",
    "comment": "{@inheritDoc} */",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "AbstractRealMatrix.getRowVector",
    "class_name": "org.apache.commons.math.linear.AbstractRealMatrix",
    "signature": "org.apache.commons.math.linear.AbstractRealMatrix.getRowVector(int)",
    "snippet": "    public RealVector getRowVector(final int row) {\n        return new ArrayRealVector(getRow(row), false);\n    }",
    "comment": "{@inheritDoc} */",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "AbstractRealMatrix.setRowVector",
    "class_name": "org.apache.commons.math.linear.AbstractRealMatrix",
    "signature": "org.apache.commons.math.linear.AbstractRealMatrix.setRowVector(int,RealVector)",
    "snippet": "    public void setRowVector(final int row, final RealVector vector) {\n        MatrixUtils.checkRowIndex(this, row);\n        final int nCols = getColumnDimension();\n        if (vector.getDimension() != nCols) {\n            throw new MatrixDimensionMismatchException(1, vector.getDimension(),\n                                                       1, nCols);\n        }\n        for (int i = 0; i < nCols; ++i) {\n            setEntry(row, i, vector.getEntry(i));\n        }\n    }",
    "comment": "{@inheritDoc} */",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "Array2DRowRealMatrix.Array2DRowRealMatrix",
    "class_name": "org.apache.commons.math.linear.Array2DRowRealMatrix",
    "signature": "org.apache.commons.math.linear.Array2DRowRealMatrix.Array2DRowRealMatrix(double[][])",
    "snippet": "    public Array2DRowRealMatrix(final double[][] d)\n        throws DimensionMismatchException, NoDataException, NullArgumentException {\n        copyIn(d);\n    }",
    "comment": " Create a new {@code RealMatrix} using the input array as the underlying data array. <p>The input array is copied, not referenced. This constructor has the same effect as calling {@link #Array2DRowRealMatrix(double[][], boolean)} with the second argument set to {@code true}.</p>  @param d Data for the new matrix. @throws DimensionMismatchException if {@code d} is not rectangular. @throws NoDataException if {@code d} row or colum dimension is zero. @throws NullArgumentException if {@code d} is {@code null}. @see #Array2DRowRealMatrix(double[][], boolean) ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "Array2DRowRealMatrix.Array2DRowRealMatrix",
    "class_name": "org.apache.commons.math.linear.Array2DRowRealMatrix",
    "signature": "org.apache.commons.math.linear.Array2DRowRealMatrix.Array2DRowRealMatrix(int,int)",
    "snippet": "    public Array2DRowRealMatrix(final int rowDimension, final int columnDimension) {\n        super(rowDimension, columnDimension);\n        data = new double[rowDimension][columnDimension];\n    }",
    "comment": " Create a new RealMatrix with the supplied row and column dimensions.  @param rowDimension Number of rows in the new matrix. @param columnDimension Number of columns in the new matrix. @throws org.apache.commons.math.exception.NotStrictlyPositiveException if the row or column dimension is not positive. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "Array2DRowRealMatrix.copyIn",
    "class_name": "org.apache.commons.math.linear.Array2DRowRealMatrix",
    "signature": "org.apache.commons.math.linear.Array2DRowRealMatrix.copyIn(double[][])",
    "snippet": "    private void copyIn(final double[][] in)\n        throws DimensionMismatchException, NoDataException, NullArgumentException {\n        setSubMatrix(in, 0, 0);\n    }",
    "comment": " Replace data with a fresh copy of the input array.  @param in Data to copy. @throws NoDataException if the input array is empty. @throws DimensionMismatchException if the input array is not rectangular. @throws NullArgumentException if the input array is {@code null}. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "Array2DRowRealMatrix.getColumnDimension",
    "class_name": "org.apache.commons.math.linear.Array2DRowRealMatrix",
    "signature": "org.apache.commons.math.linear.Array2DRowRealMatrix.getColumnDimension()",
    "snippet": "    @Override\n    public int getColumnDimension() {\n        return ((data == null) || (data[0] == null)) ? 0 : data[0].length;\n    }",
    "comment": "{@inheritDoc} */",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "Array2DRowRealMatrix.getDataRef",
    "class_name": "org.apache.commons.math.linear.Array2DRowRealMatrix",
    "signature": "org.apache.commons.math.linear.Array2DRowRealMatrix.getDataRef()",
    "snippet": "    public double[][] getDataRef() {\n        return data;\n    }",
    "comment": " Get a reference to the underlying data array.  @return 2-dimensional array of entries. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "Array2DRowRealMatrix.getEntry",
    "class_name": "org.apache.commons.math.linear.Array2DRowRealMatrix",
    "signature": "org.apache.commons.math.linear.Array2DRowRealMatrix.getEntry(int,int)",
    "snippet": "    @Override\n    public double getEntry(final int row, final int column) {\n        MatrixUtils.checkMatrixIndex(this, row, column);\n        return data[row][column];\n    }",
    "comment": "{@inheritDoc} */",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "Array2DRowRealMatrix.getRowDimension",
    "class_name": "org.apache.commons.math.linear.Array2DRowRealMatrix",
    "signature": "org.apache.commons.math.linear.Array2DRowRealMatrix.getRowDimension()",
    "snippet": "    @Override\n        public int getRowDimension() {\n        return (data == null) ? 0 : data.length;\n    }",
    "comment": "{@inheritDoc} */",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "Array2DRowRealMatrix.setEntry",
    "class_name": "org.apache.commons.math.linear.Array2DRowRealMatrix",
    "signature": "org.apache.commons.math.linear.Array2DRowRealMatrix.setEntry(int,int,double)",
    "snippet": "    @Override\n    public void setEntry(final int row, final int column, final double value) {\n        MatrixUtils.checkMatrixIndex(this, row, column);\n        data[row][column] = value;\n    }",
    "comment": "{@inheritDoc} */",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "Array2DRowRealMatrix.setSubMatrix",
    "class_name": "org.apache.commons.math.linear.Array2DRowRealMatrix",
    "signature": "org.apache.commons.math.linear.Array2DRowRealMatrix.setSubMatrix(double[][],int,int)",
    "snippet": "    @Override\n    public void setSubMatrix(final double[][] subMatrix,\n                             final int row, final int column) {\n        if (data == null) {\n            if (row > 0) {\n                throw new MathIllegalStateException(LocalizedFormats.FIRST_ROWS_NOT_INITIALIZED_YET, row);\n            }\n            if (column > 0) {\n                throw new MathIllegalStateException(LocalizedFormats.FIRST_COLUMNS_NOT_INITIALIZED_YET, column);\n            }\n            MathUtils.checkNotNull(subMatrix);\n            final int nRows = subMatrix.length;\n            if (nRows == 0) {\n                throw new NoDataException(LocalizedFormats.AT_LEAST_ONE_ROW);\n            }\n\n            final int nCols = subMatrix[0].length;\n            if (nCols == 0) {\n                throw new NoDataException(LocalizedFormats.AT_LEAST_ONE_COLUMN);\n            }\n            data = new double[subMatrix.length][nCols];\n            for (int i = 0; i < data.length; ++i) {\n                if (subMatrix[i].length != nCols) {\n                    throw new DimensionMismatchException(subMatrix[i].length, nCols);\n                }\n                System.arraycopy(subMatrix[i], 0, data[i + row], column, nCols);\n            }\n        } else {\n            super.setSubMatrix(subMatrix, row, column);\n        }\n\n    }",
    "comment": "{@inheritDoc} */",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "ArrayRealVector.ArrayRealVector",
    "class_name": "org.apache.commons.math.linear.ArrayRealVector",
    "signature": "org.apache.commons.math.linear.ArrayRealVector.ArrayRealVector(ArrayRealVector,boolean)",
    "snippet": "    public ArrayRealVector(ArrayRealVector v, boolean deep) {\n        data = deep ? v.data.clone() : v.data;\n    }",
    "comment": " Construct a vector from another vector.  @param v Vector to copy. @param deep If {@code true} perform a deep copy, otherwise perform a shallow copy. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "ArrayRealVector.ArrayRealVector",
    "class_name": "org.apache.commons.math.linear.ArrayRealVector",
    "signature": "org.apache.commons.math.linear.ArrayRealVector.ArrayRealVector(double[])",
    "snippet": "    public ArrayRealVector(double[] d) {\n        data = d.clone();\n    }",
    "comment": " Construct a vector from an array, copying the input array.  @param d Array. @throws NullArgumentException if {@code d} is {@code null}. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "ArrayRealVector.ArrayRealVector",
    "class_name": "org.apache.commons.math.linear.ArrayRealVector",
    "signature": "org.apache.commons.math.linear.ArrayRealVector.ArrayRealVector(double[],boolean)",
    "snippet": "    public ArrayRealVector(double[] d, boolean copyArray) {\n        if (d == null) {\n            throw new NullArgumentException();\n        }\n        data = copyArray ? d.clone() :  d;\n    }",
    "comment": " Create a new ArrayRealVector using the input array as the underlying data array. If an array is built specially in order to be embedded in a ArrayRealVector and not used directly, the {@code copyArray} may be set to {@code false}. This will prevent the copying and improve performance as no new array will be built and no data will be copied.  @param d Data for the new vector. @param copyArray if {@code true}, the input array will be copied, otherwise it will be referenced. @throws NullArgumentException if {@code d} is {@code null}. @see #ArrayRealVector(double[]) ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "ArrayRealVector.ArrayRealVector",
    "class_name": "org.apache.commons.math.linear.ArrayRealVector",
    "signature": "org.apache.commons.math.linear.ArrayRealVector.ArrayRealVector(int)",
    "snippet": "    public ArrayRealVector(int size) {\n        data = new double[size];\n    }",
    "comment": " Construct a vector of zeroes.  @param size Size of the vector. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "ArrayRealVector.checkVectorDimensions",
    "class_name": "org.apache.commons.math.linear.ArrayRealVector",
    "signature": "org.apache.commons.math.linear.ArrayRealVector.checkVectorDimensions(int)",
    "snippet": "    @Override\n    protected void checkVectorDimensions(int n) {\n        if (data.length != n) {\n            throw new DimensionMismatchException(data.length, n);\n        }\n    }",
    "comment": " Check if instance dimension is equal to some expected value.  @param n Expected dimension. @throws DimensionMismatchException if the dimension is inconsistent with vector size. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "ArrayRealVector.copy",
    "class_name": "org.apache.commons.math.linear.ArrayRealVector",
    "signature": "org.apache.commons.math.linear.ArrayRealVector.copy()",
    "snippet": "    @Override\n    public ArrayRealVector copy() {\n        return new ArrayRealVector(this, true);\n    }",
    "comment": "{@inheritDoc} */",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "ArrayRealVector.dotProduct",
    "class_name": "org.apache.commons.math.linear.ArrayRealVector",
    "signature": "org.apache.commons.math.linear.ArrayRealVector.dotProduct(RealVector)",
    "snippet": "    @Override\n    public double dotProduct(RealVector v) {\n        if (v instanceof ArrayRealVector) {\n            final double[] vData = ((ArrayRealVector) v).data;\n            checkVectorDimensions(vData.length);\n            double dot = 0;\n            for (int i = 0; i < data.length; i++) {\n                dot += data[i] * vData[i];\n            }\n            return dot;\n        } else {\n            checkVectorDimensions(v);\n            double dot = 0;\n            Iterator<Entry> it = v.sparseIterator();\n            Entry e;\n            while(it.hasNext() && (e = it.next()) != null) {\n                dot += data[e.getIndex()] * e.getValue();\n            }\n            return dot;\n        }\n    }",
    "comment": "{@inheritDoc} */",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "ArrayRealVector.getDimension",
    "class_name": "org.apache.commons.math.linear.ArrayRealVector",
    "signature": "org.apache.commons.math.linear.ArrayRealVector.getDimension()",
    "snippet": "    @Override\n    public int getDimension() {\n        return data.length;\n    }",
    "comment": "{@inheritDoc} */",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "ArrayRealVector.getEntry",
    "class_name": "org.apache.commons.math.linear.ArrayRealVector",
    "signature": "org.apache.commons.math.linear.ArrayRealVector.getEntry(int)",
    "snippet": "    @Override\n    public double getEntry(int index) {\n        return data[index];\n    }",
    "comment": "{@inheritDoc} */",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "ArrayRealVector.mapMultiplyToSelf",
    "class_name": "org.apache.commons.math.linear.ArrayRealVector",
    "signature": "org.apache.commons.math.linear.ArrayRealVector.mapMultiplyToSelf(double)",
    "snippet": "    @Override\n    public RealVector mapMultiplyToSelf(double d) {\n        for (int i = 0; i < data.length; i++) {\n            data[i] = data[i] * d;\n        }\n        return this;\n    }",
    "comment": "{@inheritDoc} */",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "ArrayRealVector.subtract",
    "class_name": "org.apache.commons.math.linear.ArrayRealVector",
    "signature": "org.apache.commons.math.linear.ArrayRealVector.subtract(RealVector)",
    "snippet": "    @Override\n    public ArrayRealVector subtract(RealVector v) {\n        if (v instanceof ArrayRealVector) {\n            final double[] vData = ((ArrayRealVector) v).data;\n            final int dim = vData.length;\n            checkVectorDimensions(dim);\n            ArrayRealVector result = new ArrayRealVector(dim);\n            double[] resultData = result.data;\n            for (int i = 0; i < dim; i++) {\n                resultData[i] = data[i] - vData[i];\n            }\n            return result;\n        } else {\n            checkVectorDimensions(v);\n            double[] out = data.clone();\n            Iterator<Entry> it = v.sparseIterator();\n            Entry e;\n            while(it.hasNext() && (e = it.next()) != null) {\n                out[e.getIndex()] -= e.getValue();\n            }\n            return new ArrayRealVector(out, false);\n        }\n    }",
    "comment": "{@inheritDoc} */",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "ArrayRealVector.toArray",
    "class_name": "org.apache.commons.math.linear.ArrayRealVector",
    "signature": "org.apache.commons.math.linear.ArrayRealVector.toArray()",
    "snippet": "    @Override\n    public double[] toArray(){\n        return data.clone();\n    }",
    "comment": "{@inheritDoc} */",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "MatrixUtils.checkColumnIndex",
    "class_name": "org.apache.commons.math.linear.MatrixUtils",
    "signature": "org.apache.commons.math.linear.MatrixUtils.checkColumnIndex(AnyMatrix,int)",
    "snippet": "    public static void checkColumnIndex(final AnyMatrix m, final int column) {\n        if (column < 0 || column >= m.getColumnDimension()) {\n            throw new OutOfRangeException(LocalizedFormats.COLUMN_INDEX,\n                                           column, 0, m.getColumnDimension() - 1);\n        }\n    }",
    "comment": " Check if a column index is valid.  @param m Matrix. @param column Column index to check. @throws OutOfRangeException if {@code column} is not a valid index. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "MatrixUtils.checkMatrixIndex",
    "class_name": "org.apache.commons.math.linear.MatrixUtils",
    "signature": "org.apache.commons.math.linear.MatrixUtils.checkMatrixIndex(AnyMatrix,int,int)",
    "snippet": "    public static void checkMatrixIndex(final AnyMatrix m,\n                                        final int row, final int column) {\n        checkRowIndex(m, row);\n        checkColumnIndex(m, column);\n    }",
    "comment": " Check if matrix indices are valid.  @param m Matrix. @param row Row index to check. @param column Column index to check. @throws OutOfRangeException if {@code row} or {@code column} is not a valid index. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "MatrixUtils.checkRowIndex",
    "class_name": "org.apache.commons.math.linear.MatrixUtils",
    "signature": "org.apache.commons.math.linear.MatrixUtils.checkRowIndex(AnyMatrix,int)",
    "snippet": "    public static void checkRowIndex(final AnyMatrix m, final int row) {\n        if (row < 0 ||\n            row >= m.getRowDimension()) {\n            throw new OutOfRangeException(LocalizedFormats.ROW_INDEX,\n                                          row, 0, m.getRowDimension() - 1);\n        }\n    }",
    "comment": " Check if a row index is valid.  @param m Matrix. @param row Row index to check. @throws OutOfRangeException if {@code row} is not a valid index. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "RealVector.mapMultiply",
    "class_name": "org.apache.commons.math.linear.RealVector",
    "signature": "org.apache.commons.math.linear.RealVector.mapMultiply(double)",
    "snippet": "    public RealVector mapMultiply(double d) {\n        return copy().mapMultiplyToSelf(d);\n    }",
    "comment": " Multiply each entry by the argument. Returns a new vector. Does not change instance data.  @param d Multiplication factor. @return {@code this} * {@code d}. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "RealVectorFormat.RealVectorFormat",
    "class_name": "org.apache.commons.math.linear.RealVectorFormat",
    "signature": "org.apache.commons.math.linear.RealVectorFormat.RealVectorFormat(NumberFormat)",
    "snippet": "    public RealVectorFormat(final NumberFormat format) {\n        this(DEFAULT_PREFIX, DEFAULT_SUFFIX, DEFAULT_SEPARATOR, format);\n    }",
    "comment": " Create an instance with a custom number format for components. @param format the custom format for components. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "RealVectorFormat.RealVectorFormat",
    "class_name": "org.apache.commons.math.linear.RealVectorFormat",
    "signature": "org.apache.commons.math.linear.RealVectorFormat.RealVectorFormat(String,String,String,NumberFormat)",
    "snippet": "    public RealVectorFormat(final String prefix, final String suffix,\n                            final String separator, final NumberFormat format) {\n        this.prefix      = prefix;\n        this.suffix      = suffix;\n        this.separator   = separator;\n        trimmedPrefix    = prefix.trim();\n        trimmedSuffix    = suffix.trim();\n        trimmedSeparator = separator.trim();\n        this.format      = format;\n    }",
    "comment": " Create an instance with custom prefix, suffix, separator and format for components. @param prefix prefix to use instead of the default \"{\" @param suffix suffix to use instead of the default \"}\" @param separator separator to use instead of the default \"; \" @param format the custom format for components. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "RealVectorFormat.getInstance",
    "class_name": "org.apache.commons.math.linear.RealVectorFormat",
    "signature": "org.apache.commons.math.linear.RealVectorFormat.getInstance()",
    "snippet": "    public static RealVectorFormat getInstance() {\n        return getInstance(Locale.getDefault());\n    }",
    "comment": " Returns the default real vector format for the current locale. @return the default real vector format. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "RealVectorFormat.getInstance",
    "class_name": "org.apache.commons.math.linear.RealVectorFormat",
    "signature": "org.apache.commons.math.linear.RealVectorFormat.getInstance(Locale)",
    "snippet": "    public static RealVectorFormat getInstance(final Locale locale) {\n        return new RealVectorFormat(CompositeFormat.getDefaultNumberFormat(locale));\n    }",
    "comment": " Returns the default real vector format for the given locale. @param locale the specific locale used by the format. @return the real vector format specific to the given locale. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "RealPointValuePair.RealPointValuePair",
    "class_name": "org.apache.commons.math.optimization.RealPointValuePair",
    "signature": "org.apache.commons.math.optimization.RealPointValuePair.RealPointValuePair(double[],double)",
    "snippet": "    public RealPointValuePair(final double[] point, final double value) {\n        this.point = (point == null) ? null : point.clone();\n        this.value = value;\n    }",
    "comment": "Build a point/objective function value pair. @param point point coordinates (the built instance will store a copy of the array, not the array passed as argument) @param value value of an objective function at the point ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "RealPointValuePair.getPoint",
    "class_name": "org.apache.commons.math.optimization.RealPointValuePair",
    "signature": "org.apache.commons.math.optimization.RealPointValuePair.getPoint()",
    "snippet": "    public double[] getPoint() {\n        return (point == null) ? null : point.clone();\n    }",
    "comment": "Get the point. @return a copy of the stored point ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "AbstractLinearOptimizer.AbstractLinearOptimizer",
    "class_name": "org.apache.commons.math.optimization.linear.AbstractLinearOptimizer",
    "signature": "org.apache.commons.math.optimization.linear.AbstractLinearOptimizer.AbstractLinearOptimizer()",
    "snippet": "    protected AbstractLinearOptimizer() {\n        setMaxIterations(DEFAULT_MAX_ITERATIONS);\n    }",
    "comment": "Simple constructor with default settings. <p>The maximal number of evaluation is set to its default value.</p> ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "AbstractLinearOptimizer.incrementIterationsCounter",
    "class_name": "org.apache.commons.math.optimization.linear.AbstractLinearOptimizer",
    "signature": "org.apache.commons.math.optimization.linear.AbstractLinearOptimizer.incrementIterationsCounter()",
    "snippet": "    protected void incrementIterationsCounter()\n        throws MaxCountExceededException {\n        if (++iterations > maxIterations) {\n            throw new MaxCountExceededException(maxIterations);\n        }\n    }",
    "comment": "Increment the iterations counter by 1. @exception MaxCountExceededException if the maximal number of iterations is exceeded ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "AbstractLinearOptimizer.optimize",
    "class_name": "org.apache.commons.math.optimization.linear.AbstractLinearOptimizer",
    "signature": "org.apache.commons.math.optimization.linear.AbstractLinearOptimizer.optimize(LinearObjectiveFunction,Collection,GoalType,boolean)",
    "snippet": "    public RealPointValuePair optimize(final LinearObjectiveFunction f,\n                                       final Collection<LinearConstraint> constraints,\n                                       final GoalType goalType, final boolean restrictToNonNegative)\n         throws MathIllegalStateException {\n\n        // store linear problem characteristics\n        this.function          = f;\n        this.linearConstraints = constraints;\n        this.goal              = goalType;\n        this.nonNegative       = restrictToNonNegative;\n\n        iterations  = 0;\n\n        // solve the problem\n        return doOptimize();\n\n    }",
    "comment": "{@inheritDoc} */",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "AbstractLinearOptimizer.setMaxIterations",
    "class_name": "org.apache.commons.math.optimization.linear.AbstractLinearOptimizer",
    "signature": "org.apache.commons.math.optimization.linear.AbstractLinearOptimizer.setMaxIterations(int)",
    "snippet": "    public void setMaxIterations(int maxIterations) {\n        this.maxIterations = maxIterations;\n    }",
    "comment": "{@inheritDoc} */",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "LinearConstraint.LinearConstraint",
    "class_name": "org.apache.commons.math.optimization.linear.LinearConstraint",
    "signature": "org.apache.commons.math.optimization.linear.LinearConstraint.LinearConstraint(RealVector,Relationship,double)",
    "snippet": "    public LinearConstraint(final RealVector coefficients, final Relationship relationship,\n                            final double value) {\n        this.coefficients = coefficients;\n        this.relationship = relationship;\n        this.value        = value;\n    }",
    "comment": " Build a constraint involving a single linear equation. <p> A linear constraint with a single linear equation has one of the forms: <ul> <li>c<sub>1</sub>x<sub>1</sub> + ... c<sub>n</sub>x<sub>n</sub> = v</li> <li>c<sub>1</sub>x<sub>1</sub> + ... c<sub>n</sub>x<sub>n</sub> &lt;= v</li> <li>c<sub>1</sub>x<sub>1</sub> + ... c<sub>n</sub>x<sub>n</sub> >= v</li> </ul> </p> @param coefficients The coefficients of the constraint (left hand side) @param relationship The type of (in)equality used in the constraint @param value The value of the constraint (right hand side) ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "LinearConstraint.LinearConstraint",
    "class_name": "org.apache.commons.math.optimization.linear.LinearConstraint",
    "signature": "org.apache.commons.math.optimization.linear.LinearConstraint.LinearConstraint(double[],Relationship,double)",
    "snippet": "    public LinearConstraint(final double[] coefficients, final Relationship relationship,\n                            final double value) {\n        this(new ArrayRealVector(coefficients), relationship, value);\n    }",
    "comment": " Build a constraint involving a single linear equation. <p> A linear constraint with a single linear equation has one of the forms: <ul> <li>c<sub>1</sub>x<sub>1</sub> + ... c<sub>n</sub>x<sub>n</sub> = v</li> <li>c<sub>1</sub>x<sub>1</sub> + ... c<sub>n</sub>x<sub>n</sub> &lt;= v</li> <li>c<sub>1</sub>x<sub>1</sub> + ... c<sub>n</sub>x<sub>n</sub> >= v</li> </ul> </p> @param coefficients The coefficients of the constraint (left hand side) @param relationship The type of (in)equality used in the constraint @param value The value of the constraint (right hand side) ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "LinearConstraint.getCoefficients",
    "class_name": "org.apache.commons.math.optimization.linear.LinearConstraint",
    "signature": "org.apache.commons.math.optimization.linear.LinearConstraint.getCoefficients()",
    "snippet": "    public RealVector getCoefficients() {\n        return coefficients;\n    }",
    "comment": " Get the coefficients of the constraint (left hand side). @return coefficients of the constraint (left hand side) ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "LinearConstraint.getRelationship",
    "class_name": "org.apache.commons.math.optimization.linear.LinearConstraint",
    "signature": "org.apache.commons.math.optimization.linear.LinearConstraint.getRelationship()",
    "snippet": "    public Relationship getRelationship() {\n        return relationship;\n    }",
    "comment": " Get the relationship between left and right hand sides. @return relationship between left and right hand sides ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "LinearConstraint.getValue",
    "class_name": "org.apache.commons.math.optimization.linear.LinearConstraint",
    "signature": "org.apache.commons.math.optimization.linear.LinearConstraint.getValue()",
    "snippet": "    public double getValue() {\n        return value;\n    }",
    "comment": " Get the value of the constraint (right hand side). @return value of the constraint (right hand side) ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "LinearObjectiveFunction.LinearObjectiveFunction",
    "class_name": "org.apache.commons.math.optimization.linear.LinearObjectiveFunction",
    "signature": "org.apache.commons.math.optimization.linear.LinearObjectiveFunction.LinearObjectiveFunction(RealVector,double)",
    "snippet": "    public LinearObjectiveFunction(RealVector coefficients, double constantTerm) {\n        this.coefficients = coefficients;\n        this.constantTerm = constantTerm;\n    }",
    "comment": " @param coefficients The coefficients for the linear equation being optimized @param constantTerm The constant term of the linear equation ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "LinearObjectiveFunction.LinearObjectiveFunction",
    "class_name": "org.apache.commons.math.optimization.linear.LinearObjectiveFunction",
    "signature": "org.apache.commons.math.optimization.linear.LinearObjectiveFunction.LinearObjectiveFunction(double[],double)",
    "snippet": "    public LinearObjectiveFunction(double[] coefficients, double constantTerm) {\n        this(new ArrayRealVector(coefficients), constantTerm);\n    }",
    "comment": " @param coefficients The coefficients for the linear equation being optimized @param constantTerm The constant term of the linear equation ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "LinearObjectiveFunction.getCoefficients",
    "class_name": "org.apache.commons.math.optimization.linear.LinearObjectiveFunction",
    "signature": "org.apache.commons.math.optimization.linear.LinearObjectiveFunction.getCoefficients()",
    "snippet": "    public RealVector getCoefficients() {\n        return coefficients;\n    }",
    "comment": " Get the coefficients of the linear equation being optimized. @return coefficients of the linear equation being optimized ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "LinearObjectiveFunction.getConstantTerm",
    "class_name": "org.apache.commons.math.optimization.linear.LinearObjectiveFunction",
    "signature": "org.apache.commons.math.optimization.linear.LinearObjectiveFunction.getConstantTerm()",
    "snippet": "    public double getConstantTerm() {\n        return constantTerm;\n    }",
    "comment": " Get the constant of the linear equation being optimized. @return constant of the linear equation being optimized ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "LinearObjectiveFunction.getValue",
    "class_name": "org.apache.commons.math.optimization.linear.LinearObjectiveFunction",
    "signature": "org.apache.commons.math.optimization.linear.LinearObjectiveFunction.getValue(double[])",
    "snippet": "    public double getValue(final double[] point) {\n        return coefficients.dotProduct(new ArrayRealVector(point, false)) + constantTerm;\n    }",
    "comment": " Compute the value of the linear equation at the current point @param point point at which linear equation must be evaluated @return value of the linear equation at the current point ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "SimplexSolver.SimplexSolver",
    "class_name": "org.apache.commons.math.optimization.linear.SimplexSolver",
    "signature": "org.apache.commons.math.optimization.linear.SimplexSolver.SimplexSolver()",
    "snippet": "    public SimplexSolver() {\n        this(DEFAULT_EPSILON, DEFAULT_ULPS);\n    }",
    "comment": " Build a simplex solver with default settings. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "SimplexSolver.SimplexSolver",
    "class_name": "org.apache.commons.math.optimization.linear.SimplexSolver",
    "signature": "org.apache.commons.math.optimization.linear.SimplexSolver.SimplexSolver(double,int)",
    "snippet": "    public SimplexSolver(final double epsilon, final int maxUlps) {\n        this.epsilon = epsilon;\n        this.maxUlps = maxUlps;\n    }",
    "comment": " Build a simplex solver with a specified accepted amount of error @param epsilon the amount of error to accept for algorithm convergence @param maxUlps amount of error to accept in floating point comparisons ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "SimplexSolver.doIteration",
    "class_name": "org.apache.commons.math.optimization.linear.SimplexSolver",
    "signature": "org.apache.commons.math.optimization.linear.SimplexSolver.doIteration(SimplexTableau)",
    "snippet": "    protected void doIteration(final SimplexTableau tableau)\n        throws MaxCountExceededException, UnboundedSolutionException {\n\n        incrementIterationsCounter();\n\n        Integer pivotCol = getPivotColumn(tableau);\n        Integer pivotRow = getPivotRow(tableau, pivotCol);\n        if (pivotRow == null) {\n            throw new UnboundedSolutionException();\n        }\n\n        // set the pivot element to 1\n        double pivotVal = tableau.getEntry(pivotRow, pivotCol);\n        tableau.divideRow(pivotRow, pivotVal);\n\n        // set the rest of the pivot column to 0\n        for (int i = 0; i < tableau.getHeight(); i++) {\n            if (i != pivotRow) {\n                double multiplier = tableau.getEntry(i, pivotCol);\n                tableau.subtractRow(i, pivotRow, multiplier);\n            }\n        }\n    }",
    "comment": " Runs one iteration of the Simplex method on the given model. @param tableau simple tableau for the problem @throws MaxCountExceededException if the maximal iteration count has been exceeded @throws UnboundedSolutionException if the model is found not to have a bounded solution ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "SimplexSolver.doOptimize",
    "class_name": "org.apache.commons.math.optimization.linear.SimplexSolver",
    "signature": "org.apache.commons.math.optimization.linear.SimplexSolver.doOptimize()",
    "snippet": "    @Override\n    public RealPointValuePair doOptimize()\n        throws MaxCountExceededException, UnboundedSolutionException, NoFeasibleSolutionException {\n        final SimplexTableau tableau =\n            new SimplexTableau(function, linearConstraints, goal, nonNegative,\n                               epsilon, maxUlps);\n\n        solvePhase1(tableau);\n        tableau.dropPhase1Objective();\n\n        while (!tableau.isOptimal()) {\n            doIteration(tableau);\n        }\n        return tableau.getSolution();\n    }",
    "comment": "{@inheritDoc} */",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "SimplexSolver.getPivotColumn",
    "class_name": "org.apache.commons.math.optimization.linear.SimplexSolver",
    "signature": "org.apache.commons.math.optimization.linear.SimplexSolver.getPivotColumn(SimplexTableau)",
    "snippet": "    private Integer getPivotColumn(SimplexTableau tableau) {\n        double minValue = 0;\n        Integer minPos = null;\n        for (int i = tableau.getNumObjectiveFunctions(); i < tableau.getWidth() - 1; i++) {\n            final double entry = tableau.getEntry(0, i);\n            if (Precision.compareTo(entry, minValue, maxUlps) < 0) {\n                minValue = entry;\n                minPos = i;\n            }\n        }\n        return minPos;\n    }",
    "comment": " Returns the column with the most negative coefficient in the objective function row. @param tableau simple tableau for the problem @return column with the most negative coefficient ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "SimplexSolver.getPivotRow",
    "class_name": "org.apache.commons.math.optimization.linear.SimplexSolver",
    "signature": "org.apache.commons.math.optimization.linear.SimplexSolver.getPivotRow(SimplexTableau,int)",
    "snippet": "    private Integer getPivotRow(SimplexTableau tableau, final int col) {\n        // create a list of all the rows that tie for the lowest score in the minimum ratio test\n        List<Integer> minRatioPositions = new ArrayList<Integer>();\n        double minRatio = Double.MAX_VALUE;\n        for (int i = tableau.getNumObjectiveFunctions(); i < tableau.getHeight(); i++) {\n            final double rhs = tableau.getEntry(i, tableau.getWidth() - 1);\n            final double entry = tableau.getEntry(i, col);\n\n            if (Precision.compareTo(entry, 0d, maxUlps) > 0) {\n                final double ratio = rhs / entry;\n                final int cmp = Precision.compareTo(ratio, minRatio, maxUlps);\n                if (cmp == 0) {\n                    minRatioPositions.add(i);\n                } else if (cmp < 0) {\n                    minRatio = ratio;\n                    minRatioPositions = new ArrayList<Integer>();\n                    minRatioPositions.add(i);\n                }\n            }\n        }\n\n        if (minRatioPositions.size() == 0) {\n          return null;\n        } else if (minRatioPositions.size() > 1) {\n          // there's a degeneracy as indicated by a tie in the minimum ratio test\n          // check if there's an artificial variable that can be forced out of the basis\n          for (Integer row : minRatioPositions) {\n            for (int i = 0; i < tableau.getNumArtificialVariables(); i++) {\n              int column = i + tableau.getArtificialVariableOffset();\n              final double entry = tableau.getEntry(row, column);\n              if (Precision.equals(entry, 1d, maxUlps) &&\n                  row.equals(tableau.getBasicRow(column))) {\n                return row;\n              }\n            }\n          }\n        }\n        return minRatioPositions.get(0);\n    }",
    "comment": " Returns the row with the minimum ratio as given by the minimum ratio test (MRT). @param tableau simple tableau for the problem @param col the column to test the ratio of.  See {@link #getPivotColumn(SimplexTableau)} @return row with the minimum ratio ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "SimplexSolver.solvePhase1",
    "class_name": "org.apache.commons.math.optimization.linear.SimplexSolver",
    "signature": "org.apache.commons.math.optimization.linear.SimplexSolver.solvePhase1(SimplexTableau)",
    "snippet": "    protected void solvePhase1(final SimplexTableau tableau)\n        throws MaxCountExceededException, UnboundedSolutionException, NoFeasibleSolutionException {\n\n        // make sure we're in Phase 1\n        if (tableau.getNumArtificialVariables() == 0) {\n            return;\n        }\n\n        while (!tableau.isOptimal()) {\n            doIteration(tableau);\n        }\n\n        // if W is not zero then we have no feasible solution\n        if (!Precision.equals(tableau.getEntry(0, tableau.getRhsOffset()), 0d, epsilon)) {\n            throw new NoFeasibleSolutionException();\n        }\n    }",
    "comment": " Solves Phase 1 of the Simplex method. @param tableau simple tableau for the problem @throws MaxCountExceededException if the maximal iteration count has been exceeded @throws UnboundedSolutionException if the model is found not to have a bounded solution @throws NoFeasibleSolutionException if there is no feasible solution ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "SimplexTableau.SimplexTableau",
    "class_name": "org.apache.commons.math.optimization.linear.SimplexTableau",
    "signature": "org.apache.commons.math.optimization.linear.SimplexTableau.SimplexTableau(LinearObjectiveFunction,Collection,GoalType,boolean,double,int)",
    "snippet": "    SimplexTableau(final LinearObjectiveFunction f,\n                   final Collection<LinearConstraint> constraints,\n                   final GoalType goalType, final boolean restrictToNonNegative,\n                   final double epsilon,\n                   final int maxUlps) {\n        this.f                      = f;\n        this.constraints            = normalizeConstraints(constraints);\n        this.restrictToNonNegative  = restrictToNonNegative;\n        this.epsilon                = epsilon;\n        this.maxUlps                = maxUlps;\n        this.numDecisionVariables   = f.getCoefficients().getDimension() +\n                                      (restrictToNonNegative ? 0 : 1);\n        this.numSlackVariables      = getConstraintTypeCounts(Relationship.LEQ) +\n                                      getConstraintTypeCounts(Relationship.GEQ);\n        this.numArtificialVariables = getConstraintTypeCounts(Relationship.EQ) +\n                                      getConstraintTypeCounts(Relationship.GEQ);\n        this.tableau = createTableau(goalType == GoalType.MAXIMIZE);\n        initializeColumnLabels();\n    }",
    "comment": " Build a tableau for a linear problem. @param f linear objective function @param constraints linear constraints @param goalType type of optimization goal: either {@link GoalType#MAXIMIZE} or {@link GoalType#MINIMIZE} @param restrictToNonNegative whether to restrict the variables to non-negative values @param epsilon amount of error to accept when checking for optimality @param maxUlps amount of error to accept in floating point comparisons ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "SimplexTableau.copyArray",
    "class_name": "org.apache.commons.math.optimization.linear.SimplexTableau",
    "signature": "org.apache.commons.math.optimization.linear.SimplexTableau.copyArray(double[],double[])",
    "snippet": "    private void copyArray(final double[] src, final double[] dest) {\n        System.arraycopy(src, 0, dest, getNumObjectiveFunctions(), src.length);\n    }",
    "comment": " @param src the source array @param dest the destination array ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "SimplexTableau.createTableau",
    "class_name": "org.apache.commons.math.optimization.linear.SimplexTableau",
    "signature": "org.apache.commons.math.optimization.linear.SimplexTableau.createTableau(boolean)",
    "snippet": "    protected RealMatrix createTableau(final boolean maximize) {\n\n        // create a matrix of the correct size\n        int width = numDecisionVariables + numSlackVariables +\n        numArtificialVariables + getNumObjectiveFunctions() + 1; // + 1 is for RHS\n        int height = constraints.size() + getNumObjectiveFunctions();\n        Array2DRowRealMatrix matrix = new Array2DRowRealMatrix(height, width);\n\n        // initialize the objective function rows\n        if (getNumObjectiveFunctions() == 2) {\n            matrix.setEntry(0, 0, -1);\n        }\n        int zIndex = (getNumObjectiveFunctions() == 1) ? 0 : 1;\n        matrix.setEntry(zIndex, zIndex, maximize ? 1 : -1);\n        RealVector objectiveCoefficients =\n            maximize ? f.getCoefficients().mapMultiply(-1) : f.getCoefficients();\n        copyArray(objectiveCoefficients.toArray(), matrix.getDataRef()[zIndex]);\n        matrix.setEntry(zIndex, width - 1,\n            maximize ? f.getConstantTerm() : -1 * f.getConstantTerm());\n\n        if (!restrictToNonNegative) {\n            matrix.setEntry(zIndex, getSlackVariableOffset() - 1,\n                getInvertedCoefficientSum(objectiveCoefficients));\n        }\n\n        // initialize the constraint rows\n        int slackVar = 0;\n        int artificialVar = 0;\n        for (int i = 0; i < constraints.size(); i++) {\n            LinearConstraint constraint = constraints.get(i);\n            int row = getNumObjectiveFunctions() + i;\n\n            // decision variable coefficients\n            copyArray(constraint.getCoefficients().toArray(), matrix.getDataRef()[row]);\n\n            // x-\n            if (!restrictToNonNegative) {\n                matrix.setEntry(row, getSlackVariableOffset() - 1,\n                    getInvertedCoefficientSum(constraint.getCoefficients()));\n            }\n\n            // RHS\n            matrix.setEntry(row, width - 1, constraint.getValue());\n\n            // slack variables\n            if (constraint.getRelationship() == Relationship.LEQ) {\n                matrix.setEntry(row, getSlackVariableOffset() + slackVar++, 1);  // slack\n            } else if (constraint.getRelationship() == Relationship.GEQ) {\n                matrix.setEntry(row, getSlackVariableOffset() + slackVar++, -1); // excess\n            }\n\n            // artificial variables\n            if ((constraint.getRelationship() == Relationship.EQ) ||\n                    (constraint.getRelationship() == Relationship.GEQ)) {\n                matrix.setEntry(0, getArtificialVariableOffset() + artificialVar, 1);\n                matrix.setEntry(row, getArtificialVariableOffset() + artificialVar++, 1);\n                matrix.setRowVector(0, matrix.getRowVector(0).subtract(matrix.getRowVector(row)));\n            }\n        }\n\n        return matrix;\n    }",
    "comment": " Create the tableau by itself. @param maximize if true, goal is to maximize the objective function @return created tableau ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "SimplexTableau.divideRow",
    "class_name": "org.apache.commons.math.optimization.linear.SimplexTableau",
    "signature": "org.apache.commons.math.optimization.linear.SimplexTableau.divideRow(int,double)",
    "snippet": "    protected void divideRow(final int dividendRow, final double divisor) {\n        for (int j = 0; j < getWidth(); j++) {\n            tableau.setEntry(dividendRow, j, tableau.getEntry(dividendRow, j) / divisor);\n        }\n    }",
    "comment": " Subtracts a multiple of one row from another. <p> After application of this operation, the following will hold: minuendRow = minuendRow - multiple * subtrahendRow </p> @param dividendRow index of the row @param divisor value of the divisor ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "SimplexTableau.dropPhase1Objective",
    "class_name": "org.apache.commons.math.optimization.linear.SimplexTableau",
    "signature": "org.apache.commons.math.optimization.linear.SimplexTableau.dropPhase1Objective()",
    "snippet": "    protected void dropPhase1Objective() {\n        if (getNumObjectiveFunctions() == 1) {\n            return;\n        }\n\n        List<Integer> columnsToDrop = new ArrayList<Integer>();\n        columnsToDrop.add(0);\n\n        // positive cost non-artificial variables\n        for (int i = getNumObjectiveFunctions(); i < getArtificialVariableOffset(); i++) {\n            final double entry = tableau.getEntry(0, i);\n            if (Precision.compareTo(entry, 0d, maxUlps) > 0) {\n                columnsToDrop.add(i);\n            }\n        }\n\n        // non-basic artificial variables\n        for (int i = 0; i < getNumArtificialVariables(); i++) {\n          int col = i + getArtificialVariableOffset();\n          if (getBasicRow(col) == null) {\n            columnsToDrop.add(col);\n          }\n        }\n\n        double[][] matrix = new double[getHeight() - 1][getWidth() - columnsToDrop.size()];\n        for (int i = 1; i < getHeight(); i++) {\n          int col = 0;\n          for (int j = 0; j < getWidth(); j++) {\n            if (!columnsToDrop.contains(j)) {\n              matrix[i - 1][col++] = tableau.getEntry(i, j);\n            }\n          }\n        }\n\n        for (int i = columnsToDrop.size() - 1; i >= 0; i--) {\n          columnLabels.remove((int) columnsToDrop.get(i));\n        }\n\n        this.tableau = new Array2DRowRealMatrix(matrix);\n        this.numArtificialVariables = 0;\n    }",
    "comment": " Removes the phase 1 objective function, positive cost non-artificial variables, and the non-basic artificial variables from this tableau. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "SimplexTableau.getArtificialVariableOffset",
    "class_name": "org.apache.commons.math.optimization.linear.SimplexTableau",
    "signature": "org.apache.commons.math.optimization.linear.SimplexTableau.getArtificialVariableOffset()",
    "snippet": "    protected final int getArtificialVariableOffset() {\n        return getNumObjectiveFunctions() + numDecisionVariables + numSlackVariables;\n    }",
    "comment": " Get the offset of the first artificial variable. @return offset of the first artificial variable ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "SimplexTableau.getBasicRow",
    "class_name": "org.apache.commons.math.optimization.linear.SimplexTableau",
    "signature": "org.apache.commons.math.optimization.linear.SimplexTableau.getBasicRow(int)",
    "snippet": "    protected Integer getBasicRow(final int col) {\n        Integer row = null;\n        for (int i = 0; i < getHeight(); i++) {\n            final double entry = getEntry(i, col);\n            if (Precision.equals(entry, 1d, maxUlps) && (row == null)) {\n                row = i;\n            } else if (!Precision.equals(entry, 0d, maxUlps)) {\n                return null;\n            }\n        }\n        return row;\n    }",
    "comment": " Checks whether the given column is basic. @param col index of the column to check @return the row that the variable is basic in.  null if the column is not basic ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "SimplexTableau.getConstraintTypeCounts",
    "class_name": "org.apache.commons.math.optimization.linear.SimplexTableau",
    "signature": "org.apache.commons.math.optimization.linear.SimplexTableau.getConstraintTypeCounts(Relationship)",
    "snippet": "    private int getConstraintTypeCounts(final Relationship relationship) {\n        int count = 0;\n        for (final LinearConstraint constraint : constraints) {\n            if (constraint.getRelationship() == relationship) {\n                ++count;\n            }\n        }\n        return count;\n    }",
    "comment": " Get a count of constraints corresponding to a specified relationship. @param relationship relationship to count @return number of constraint with the specified relationship ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "SimplexTableau.getEntry",
    "class_name": "org.apache.commons.math.optimization.linear.SimplexTableau",
    "signature": "org.apache.commons.math.optimization.linear.SimplexTableau.getEntry(int,int)",
    "snippet": "    protected final double getEntry(final int row, final int column) {\n        return tableau.getEntry(row, column);\n    }",
    "comment": "Get an entry of the tableau. @param row row index @param column column index @return entry at (row, column) ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "SimplexTableau.getHeight",
    "class_name": "org.apache.commons.math.optimization.linear.SimplexTableau",
    "signature": "org.apache.commons.math.optimization.linear.SimplexTableau.getHeight()",
    "snippet": "    protected final int getHeight() {\n        return tableau.getRowDimension();\n    }",
    "comment": " Get the height of the tableau. @return height of the tableau ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "SimplexTableau.getNumArtificialVariables",
    "class_name": "org.apache.commons.math.optimization.linear.SimplexTableau",
    "signature": "org.apache.commons.math.optimization.linear.SimplexTableau.getNumArtificialVariables()",
    "snippet": "    protected final int getNumArtificialVariables() {\n        return numArtificialVariables;\n    }",
    "comment": " Get the number of artificial variables. @return number of artificial variables ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "SimplexTableau.getNumObjectiveFunctions",
    "class_name": "org.apache.commons.math.optimization.linear.SimplexTableau",
    "signature": "org.apache.commons.math.optimization.linear.SimplexTableau.getNumObjectiveFunctions()",
    "snippet": "    protected final int getNumObjectiveFunctions() {\n        return this.numArtificialVariables > 0 ? 2 : 1;\n    }",
    "comment": " Get the number of objective functions in this tableau. @return 2 for Phase 1.  1 for Phase 2. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "SimplexTableau.getNumSlackVariables",
    "class_name": "org.apache.commons.math.optimization.linear.SimplexTableau",
    "signature": "org.apache.commons.math.optimization.linear.SimplexTableau.getNumSlackVariables()",
    "snippet": "    protected final int getNumSlackVariables() {\n        return numSlackVariables;\n    }",
    "comment": " Get the number of slack variables. @return number of slack variables ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "SimplexTableau.getOriginalNumDecisionVariables",
    "class_name": "org.apache.commons.math.optimization.linear.SimplexTableau",
    "signature": "org.apache.commons.math.optimization.linear.SimplexTableau.getOriginalNumDecisionVariables()",
    "snippet": "    protected final int getOriginalNumDecisionVariables() {\n        return f.getCoefficients().getDimension();\n    }",
    "comment": " Get the original number of decision variables. @return original number of decision variables @see #getNumDecisionVariables() ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "SimplexTableau.getRhsOffset",
    "class_name": "org.apache.commons.math.optimization.linear.SimplexTableau",
    "signature": "org.apache.commons.math.optimization.linear.SimplexTableau.getRhsOffset()",
    "snippet": "    protected final int getRhsOffset() {\n        return getWidth() - 1;\n    }",
    "comment": " Get the offset of the right hand side. @return offset of the right hand side ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "SimplexTableau.getSolution",
    "class_name": "org.apache.commons.math.optimization.linear.SimplexTableau",
    "signature": "org.apache.commons.math.optimization.linear.SimplexTableau.getSolution()",
    "snippet": "    protected RealPointValuePair getSolution() {\n      int negativeVarColumn = columnLabels.indexOf(NEGATIVE_VAR_COLUMN_LABEL);\n      Integer negativeVarBasicRow = negativeVarColumn > 0 ? getBasicRow(negativeVarColumn) : null;\n      double mostNegative = negativeVarBasicRow == null ? 0 : getEntry(negativeVarBasicRow, getRhsOffset());\n\n      Set<Integer> basicRows = new HashSet<Integer>();\n      double[] coefficients = new double[getOriginalNumDecisionVariables()];\n      for (int i = 0; i < coefficients.length; i++) {\n          int colIndex = columnLabels.indexOf(\"x\" + i);\n          if (colIndex < 0) {\n            coefficients[i] = 0;\n            continue;\n          }\n          Integer basicRow = getBasicRow(colIndex);\n              // if the basic row is found to be the objective function row\n              // set the coefficient to 0 -> this case handles unconstrained \n              // variables that are still part of the objective function\n          if (basicRows.contains(basicRow)) {\n              // if multiple variables can take a given value\n              // then we choose the first and set the rest equal to 0\n              coefficients[i] = 0 - (restrictToNonNegative ? 0 : mostNegative);\n          } else {\n              basicRows.add(basicRow);\n              coefficients[i] =\n                  (basicRow == null ? 0 : getEntry(basicRow, getRhsOffset())) -\n                  (restrictToNonNegative ? 0 : mostNegative);\n          }\n      }\n      return new RealPointValuePair(coefficients, f.getValue(coefficients));\n    }",
    "comment": " Get the current solution.  @return current solution ",
    "is_bug": true,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "SimplexTableau.getWidth",
    "class_name": "org.apache.commons.math.optimization.linear.SimplexTableau",
    "signature": "org.apache.commons.math.optimization.linear.SimplexTableau.getWidth()",
    "snippet": "    protected final int getWidth() {\n        return tableau.getColumnDimension();\n    }",
    "comment": " Get the width of the tableau. @return width of the tableau ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "SimplexTableau.initializeColumnLabels",
    "class_name": "org.apache.commons.math.optimization.linear.SimplexTableau",
    "signature": "org.apache.commons.math.optimization.linear.SimplexTableau.initializeColumnLabels()",
    "snippet": "    protected void initializeColumnLabels() {\n      if (getNumObjectiveFunctions() == 2) {\n        columnLabels.add(\"W\");\n      }\n      columnLabels.add(\"Z\");\n      for (int i = 0; i < getOriginalNumDecisionVariables(); i++) {\n        columnLabels.add(\"x\" + i);\n      }\n      if (!restrictToNonNegative) {\n        columnLabels.add(NEGATIVE_VAR_COLUMN_LABEL);\n      }\n      for (int i = 0; i < getNumSlackVariables(); i++) {\n        columnLabels.add(\"s\" + i);\n      }\n      for (int i = 0; i < getNumArtificialVariables(); i++) {\n        columnLabels.add(\"a\" + i);\n      }\n      columnLabels.add(\"RHS\");\n    }",
    "comment": " Initialize the labels for the columns. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "SimplexTableau.isOptimal",
    "class_name": "org.apache.commons.math.optimization.linear.SimplexTableau",
    "signature": "org.apache.commons.math.optimization.linear.SimplexTableau.isOptimal()",
    "snippet": "    boolean isOptimal() {\n        for (int i = getNumObjectiveFunctions(); i < getWidth() - 1; i++) {\n            final double entry = tableau.getEntry(0, i);\n            if (Precision.compareTo(entry, 0d, epsilon) < 0) {\n                return false;\n            }\n        }\n        return true;\n    }",
    "comment": " Returns whether the problem is at an optimal state. @return whether the model has been solved ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "SimplexTableau.normalize",
    "class_name": "org.apache.commons.math.optimization.linear.SimplexTableau",
    "signature": "org.apache.commons.math.optimization.linear.SimplexTableau.normalize(LinearConstraint)",
    "snippet": "    private LinearConstraint normalize(final LinearConstraint constraint) {\n        if (constraint.getValue() < 0) {\n            return new LinearConstraint(constraint.getCoefficients().mapMultiply(-1),\n                                        constraint.getRelationship().oppositeRelationship(),\n                                        -1 * constraint.getValue());\n        }\n        return new LinearConstraint(constraint.getCoefficients(),\n                                    constraint.getRelationship(), constraint.getValue());\n    }",
    "comment": " Get a new equation equivalent to this one with a positive right hand side. @param constraint reference constraint @return new equation ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "SimplexTableau.normalizeConstraints",
    "class_name": "org.apache.commons.math.optimization.linear.SimplexTableau",
    "signature": "org.apache.commons.math.optimization.linear.SimplexTableau.normalizeConstraints(Collection)",
    "snippet": "    public List<LinearConstraint> normalizeConstraints(Collection<LinearConstraint> originalConstraints) {\n        List<LinearConstraint> normalized = new ArrayList<LinearConstraint>();\n        for (LinearConstraint constraint : originalConstraints) {\n            normalized.add(normalize(constraint));\n        }\n        return normalized;\n    }",
    "comment": " Get new versions of the constraints which have positive right hand sides. @param originalConstraints original (not normalized) constraints @return new versions of the constraints ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "SimplexTableau.subtractRow",
    "class_name": "org.apache.commons.math.optimization.linear.SimplexTableau",
    "signature": "org.apache.commons.math.optimization.linear.SimplexTableau.subtractRow(int,int,double)",
    "snippet": "    protected void subtractRow(final int minuendRow, final int subtrahendRow,\n                               final double multiple) {\n        tableau.setRowVector(minuendRow, tableau.getRowVector(minuendRow)\n            .subtract(tableau.getRowVector(subtrahendRow).mapMultiply(multiple)));\n    }",
    "comment": " Subtracts a multiple of one row from another. <p> After application of this operation, the following will hold: minuendRow = minuendRow - multiple * subtrahendRow </p> @param minuendRow row index @param subtrahendRow row index @param multiple multiplication factor ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "CompositeFormat.getDefaultNumberFormat",
    "class_name": "org.apache.commons.math.util.CompositeFormat",
    "signature": "org.apache.commons.math.util.CompositeFormat.getDefaultNumberFormat(Locale)",
    "snippet": "    public static NumberFormat getDefaultNumberFormat(final Locale locale) {\n        final NumberFormat nf = NumberFormat.getInstance(locale);\n        nf.setMaximumFractionDigits(2);\n        return nf;\n    }",
    "comment": " Create a default number format.  The default number format is based on {@link NumberFormat#getInstance(java.util.Locale)} with the only customizing that the maximum number of fraction digits is set to 2. @param locale the specific locale used by the format. @return the default number format specific to the given locale. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "FastMath.abs",
    "class_name": "org.apache.commons.math.util.FastMath",
    "signature": "org.apache.commons.math.util.FastMath.abs(double)",
    "snippet": "    public static double abs(double x) {\n        return (x < 0.0) ? -x : (x == 0.0) ? 0.0 : x; // -0.0 => +0.0\n    }",
    "comment": " Absolute value. @param x number from which absolute value is requested @return abs(x) ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "FastMath.abs",
    "class_name": "org.apache.commons.math.util.FastMath",
    "signature": "org.apache.commons.math.util.FastMath.abs(long)",
    "snippet": "    public static long abs(final long x) {\n        return (x < 0l) ? -x : x;\n    }",
    "comment": " Absolute value. @param x number from which absolute value is requested @return abs(x) ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "MathUtils.checkNotNull",
    "class_name": "org.apache.commons.math.util.MathUtils",
    "signature": "org.apache.commons.math.util.MathUtils.checkNotNull(Object)",
    "snippet": "    public static void checkNotNull(Object o)\n        throws NullArgumentException {\n        if (o == null) {\n            throw new NullArgumentException();\n        }\n    }",
    "comment": " Checks that an object is not null.  @param o Object to be checked. @throws NullArgumentException if {@code o} is {@code null}. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "Precision.compareTo",
    "class_name": "org.apache.commons.math.util.Precision",
    "signature": "org.apache.commons.math.util.Precision.compareTo(double,double,double)",
    "snippet": "    public static int compareTo(double x, double y, double eps) {\n        if (equals(x, y, eps)) {\n            return 0;\n        } else if (x < y) {\n            return -1;\n        }\n        return 1;\n    }",
    "comment": " Compares two numbers given some amount of allowed error.  @param x the first number @param y the second number @param eps the amount of error to allow when checking for equality @return <ul><li>0 if  {@link #equals(double, double, double) equals(x, y, eps)}</li> <li>&lt; 0 if !{@link #equals(double, double, double) equals(x, y, eps)} &amp;&amp; x &lt; y</li> <li>> 0 if !{@link #equals(double, double, double) equals(x, y, eps)} &amp;&amp; x > y</li></ul> ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "Precision.compareTo",
    "class_name": "org.apache.commons.math.util.Precision",
    "signature": "org.apache.commons.math.util.Precision.compareTo(double,double,int)",
    "snippet": "    public static int compareTo(final double x, final double y, final int maxUlps) {\n        if (equals(x, y, maxUlps)) {\n            return 0;\n        } else if (x < y) {\n            return -1;\n        }\n        return 1;\n    }",
    "comment": " Compares two numbers given some amount of allowed error. Two float numbers are considered equal if there are {@code (maxUlps - 1)} (or fewer) floating point numbers between them, i.e. two adjacent floating point numbers are considered equal. Adapted from <a href=\"http://www.cygnus-software.com/papers/comparingfloats/comparingfloats.htm\"> Bruce Dawson</a>  @param x first value @param y second value @param maxUlps {@code (maxUlps - 1)} is the number of floating point values between {@code x} and {@code y}. @return <ul><li>0 if  {@link #equals(double, double, int) equals(x, y, maxUlps)}</li> <li>&lt; 0 if !{@link #equals(double, double, int) equals(x, y, maxUlps)} &amp;&amp; x &lt; y</li> <li>> 0 if !{@link #equals(double, double, int) equals(x, y, maxUlps)} &amp;&amp; x > y</li></ul> ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "Precision.equals",
    "class_name": "org.apache.commons.math.util.Precision",
    "signature": "org.apache.commons.math.util.Precision.equals(double,double,double)",
    "snippet": "    public static boolean equals(double x, double y, double eps) {\n        return equals(x, y, 1) || FastMath.abs(y - x) <= eps;\n    }",
    "comment": " Returns {@code true} if there is no double value strictly between the arguments or the difference between them is within the range of allowed error (inclusive).  @param x First value. @param y Second value. @param eps Amount of allowed absolute error. @return {@code true} if the values are two adjacent floating point numbers or they are within range of each other. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "Precision.equals",
    "class_name": "org.apache.commons.math.util.Precision",
    "signature": "org.apache.commons.math.util.Precision.equals(double,double,int)",
    "snippet": "    public static boolean equals(double x, double y, int maxUlps) {\n        long xInt = Double.doubleToLongBits(x);\n        long yInt = Double.doubleToLongBits(y);\n\n        // Make lexicographically ordered as a two's-complement integer.\n        if (xInt < 0) {\n            xInt = SGN_MASK - xInt;\n        }\n        if (yInt < 0) {\n            yInt = SGN_MASK - yInt;\n        }\n\n        final boolean isEqual = FastMath.abs(xInt - yInt) <= maxUlps;\n\n        return isEqual && !Double.isNaN(x) && !Double.isNaN(y);\n    }",
    "comment": " Returns true if both arguments are equal or within the range of allowed error (inclusive). Two float numbers are considered equal if there are {@code (maxUlps - 1)} (or fewer) floating point numbers between them, i.e. two adjacent floating point numbers are considered equal. Adapted from <a href=\"http://www.cygnus-software.com/papers/comparingfloats/comparingfloats.htm\"> Bruce Dawson</a>  @param x first value @param y second value @param maxUlps {@code (maxUlps - 1)} is the number of floating point values between {@code x} and {@code y}. @return {@code true} if there are fewer than {@code maxUlps} floating point values between {@code x} and {@code y}. ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  }
]