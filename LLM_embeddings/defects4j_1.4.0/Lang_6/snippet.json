[
  {
    "name": "ArrayUtils.clone",
    "class_name": "org.apache.commons.lang3.ArrayUtils",
    "signature": "org.apache.commons.lang3.ArrayUtils.clone(T[])",
    "snippet": "    public static <T> T[] clone(T[] array) {\n        if (array == null) {\n            return null;\n        }\n        return array.clone();\n    }",
    "comment": " <p>Shallow clones an array returning a typecast result and handling {@code null}.</p>  <p>The objects in the array are not cloned, thus there is no special handling for multi-dimensional arrays.</p>  <p>This method returns {@code null} for a {@code null} input array.</p>  @param <T> the component type of the array @param array  the array to shallow clone, may be {@code null} @return the cloned array, {@code null} if {@code null} input ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "StringEscapeUtils.escapeCsv",
    "class_name": "org.apache.commons.lang3.StringEscapeUtils",
    "signature": "org.apache.commons.lang3.StringEscapeUtils.escapeCsv(String)",
    "snippet": "    public static final String escapeCsv(String input) {\n        return ESCAPE_CSV.translate(input);\n    }",
    "comment": " <p>Returns a {@code String} value for a CSV column enclosed in double quotes, if required.</p>  <p>If the value contains a comma, newline or double quote, then the String value is returned enclosed in double quotes.</p> </p>  <p>Any double quote characters in the value are escaped with another double quote.</p>  <p>If the value does not contain a comma, newline or double quote, then the String value is returned unchanged.</p> </p>  see <a href=\"http://en.wikipedia.org/wiki/Comma-separated_values\">Wikipedia</a> and <a href=\"http://tools.ietf.org/html/rfc4180\">RFC 4180</a>.  @param input the input CSV column String, may be null @return the input String, enclosed in double quotes if the value contains a comma, newline or double quote, {@code null} if null string input @since 2.4 ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "CsvEscaper.translate",
    "class_name": "org.apache.commons.lang3.StringEscapeUtils$CsvEscaper",
    "signature": "org.apache.commons.lang3.StringEscapeUtils$CsvEscaper.translate(CharSequence,int,Writer)",
    "snippet": "        @Override\n        public int translate(CharSequence input, int index, Writer out) throws IOException {\n\n            if(index != 0) {\n                throw new IllegalStateException(\"CsvEscaper should never reach the [1] index\");\n            }\n\n            if (StringUtils.containsNone(input.toString(), CSV_SEARCH_CHARS)) {\n                out.write(input.toString());\n            } else {\n                out.write(CSV_QUOTE);\n                out.write(StringUtils.replace(input.toString(), CSV_QUOTE_STR, CSV_QUOTE_STR + CSV_QUOTE_STR));\n                out.write(CSV_QUOTE);\n            }\n            return input.length();\n        }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "StringUtils.containsNone",
    "class_name": "org.apache.commons.lang3.StringUtils",
    "signature": "org.apache.commons.lang3.StringUtils.containsNone(CharSequence,char[])",
    "snippet": "    public static boolean containsNone(CharSequence cs, char... searchChars) {\n        if (cs == null || searchChars == null) {\n            return true;\n        }\n        int csLen = cs.length();\n        int csLast = csLen - 1;\n        int searchLen = searchChars.length;\n        int searchLast = searchLen - 1;\n        for (int i = 0; i < csLen; i++) {\n            char ch = cs.charAt(i);\n            for (int j = 0; j < searchLen; j++) {\n                if (searchChars[j] == ch) {\n                    if (Character.isHighSurrogate(ch)) {\n                        if (j == searchLast) {\n                            // missing low surrogate, fine, like String.indexOf(String)\n                            return false;\n                        }\n                        if (i < csLast && searchChars[j + 1] == cs.charAt(i + 1)) {\n                            return false;\n                        }\n                    } else {\n                        // ch is in the Basic Multilingual Plane\n                        return false;\n                    }\n                }\n            }\n        }\n        return true;\n    }",
    "comment": " <p>Checks that the CharSequence does not contain certain characters.</p>  <p>A {@code null} CharSequence will return {@code true}. A {@code null} invalid character array will return {@code true}. An empty CharSequence (length()=0) always returns true.</p>  <pre> StringUtils.containsNone(null, *)       = true StringUtils.containsNone(*, null)       = true StringUtils.containsNone(\"\", *)         = true StringUtils.containsNone(\"ab\", '')      = true StringUtils.containsNone(\"abab\", 'xyz') = true StringUtils.containsNone(\"ab1\", 'xyz')  = true StringUtils.containsNone(\"abz\", 'xyz')  = false </pre>  @param cs  the CharSequence to check, may be null @param searchChars  an array of invalid chars, may be null @return true if it contains none of the invalid chars, or is null @since 2.0 @since 3.0 Changed signature from containsNone(String, char[]) to containsNone(CharSequence, char...) ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "AggregateTranslator.AggregateTranslator",
    "class_name": "org.apache.commons.lang3.text.translate.AggregateTranslator",
    "signature": "org.apache.commons.lang3.text.translate.AggregateTranslator.AggregateTranslator(CharSequenceTranslator[])",
    "snippet": "    public AggregateTranslator(CharSequenceTranslator... translators) {\n        this.translators = ArrayUtils.clone(translators);\n    }",
    "comment": " Specify the translators to be used at creation time.   @param translators CharSequenceTranslator array to aggregate ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "CharSequenceTranslator.translate",
    "class_name": "org.apache.commons.lang3.text.translate.CharSequenceTranslator",
    "signature": "org.apache.commons.lang3.text.translate.CharSequenceTranslator.translate(CharSequence)",
    "snippet": "    public final String translate(CharSequence input) {\n        if (input == null) {\n            return null;\n        }\n        try {\n            StringWriter writer = new StringWriter(input.length() * 2);\n            translate(input, writer);\n            return writer.toString();\n        } catch (IOException ioe) {\n            // this should never ever happen while writing to a StringWriter\n            throw new RuntimeException(ioe);\n        }\n    }",
    "comment": " Helper for non-Writer usage.  @param input CharSequence to be translated @return String output of translation ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "CharSequenceTranslator.translate",
    "class_name": "org.apache.commons.lang3.text.translate.CharSequenceTranslator",
    "signature": "org.apache.commons.lang3.text.translate.CharSequenceTranslator.translate(CharSequence,Writer)",
    "snippet": "    public final void translate(CharSequence input, Writer out) throws IOException {\n        if (out == null) {\n            throw new IllegalArgumentException(\"The Writer must not be null\");\n        }\n        if (input == null) {\n            return;\n        }\n        int pos = 0;\n        int len = input.length();\n        while (pos < len) {\n            int consumed = translate(input, pos, out);\n            if (consumed == 0) {\n                char[] c = Character.toChars(Character.codePointAt(input, pos));\n                out.write(c);\n                pos+= c.length;\n                continue;\n            }\n//          // contract with translators is that they have to understand codepoints \n//          // and they just took care of a surrogate pair\n            for (int pt = 0; pt < consumed; pt++) {\n                pos += Character.charCount(Character.codePointAt(input, pos));\n            }\n        }\n    }",
    "comment": " Translate an input onto a Writer. This is intentionally final as its algorithm is  tightly coupled with the abstract method of this class.   @param input CharSequence that is being translated @param out Writer to translate the text to @throws IOException if and only if the Writer produces an IOException ",
    "is_bug": true,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "CharSequenceTranslator.with",
    "class_name": "org.apache.commons.lang3.text.translate.CharSequenceTranslator",
    "signature": "org.apache.commons.lang3.text.translate.CharSequenceTranslator.with(CharSequenceTranslator[])",
    "snippet": "    public final CharSequenceTranslator with(CharSequenceTranslator... translators) {\n        CharSequenceTranslator[] newArray = new CharSequenceTranslator[translators.length + 1];\n        newArray[0] = this;\n        System.arraycopy(translators, 0, newArray, 1, translators.length);\n        return new AggregateTranslator(newArray);\n    }",
    "comment": " Helper method to create a merger of this translator with another set of  translators. Useful in customizing the standard functionality.  @param translators CharSequenceTranslator array of translators to merge with this one @return CharSequenceTranslator merging this translator with the others ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "EntityArrays.APOS_ESCAPE",
    "class_name": "org.apache.commons.lang3.text.translate.EntityArrays",
    "signature": "org.apache.commons.lang3.text.translate.EntityArrays.APOS_ESCAPE()",
    "snippet": "    public static String[][] APOS_ESCAPE() { return APOS_ESCAPE.clone(); }",
    "comment": " Mapping to escape the apostrophe character to its XML character entity. @return the mapping table ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "EntityArrays.APOS_UNESCAPE",
    "class_name": "org.apache.commons.lang3.text.translate.EntityArrays",
    "signature": "org.apache.commons.lang3.text.translate.EntityArrays.APOS_UNESCAPE()",
    "snippet": "    public static String[][] APOS_UNESCAPE() { return APOS_UNESCAPE.clone(); }",
    "comment": " Reverse of {@link #APOS_ESCAPE()} for unescaping purposes. @return the mapping table ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "EntityArrays.BASIC_ESCAPE",
    "class_name": "org.apache.commons.lang3.text.translate.EntityArrays",
    "signature": "org.apache.commons.lang3.text.translate.EntityArrays.BASIC_ESCAPE()",
    "snippet": "    public static String[][] BASIC_ESCAPE() { return BASIC_ESCAPE.clone(); }",
    "comment": " Mapping to escape the basic XML and HTML character entities.  Namely: {@code \" & < >} @return the mapping table ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "EntityArrays.BASIC_UNESCAPE",
    "class_name": "org.apache.commons.lang3.text.translate.EntityArrays",
    "signature": "org.apache.commons.lang3.text.translate.EntityArrays.BASIC_UNESCAPE()",
    "snippet": "    public static String[][] BASIC_UNESCAPE() { return BASIC_UNESCAPE.clone(); }",
    "comment": " Reverse of {@link #BASIC_ESCAPE()} for unescaping purposes. @return the mapping table ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "EntityArrays.HTML40_EXTENDED_ESCAPE",
    "class_name": "org.apache.commons.lang3.text.translate.EntityArrays",
    "signature": "org.apache.commons.lang3.text.translate.EntityArrays.HTML40_EXTENDED_ESCAPE()",
    "snippet": "    public static String[][] HTML40_EXTENDED_ESCAPE() { return HTML40_EXTENDED_ESCAPE.clone(); }",
    "comment": " Mapping to escape additional <a href=\"http://www.w3.org/TR/REC-html40/sgml/entities.html\">character entity references</a>. Note that this must be used with {@link #ISO8859_1_ESCAPE()} to get the full list of HTML 4.0 character entities. @return the mapping table ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "EntityArrays.HTML40_EXTENDED_UNESCAPE",
    "class_name": "org.apache.commons.lang3.text.translate.EntityArrays",
    "signature": "org.apache.commons.lang3.text.translate.EntityArrays.HTML40_EXTENDED_UNESCAPE()",
    "snippet": "    public static String[][] HTML40_EXTENDED_UNESCAPE() { return HTML40_EXTENDED_UNESCAPE.clone(); }",
    "comment": " Reverse of {@link #HTML40_EXTENDED_ESCAPE()} for unescaping purposes. @return the mapping table ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "EntityArrays.ISO8859_1_ESCAPE",
    "class_name": "org.apache.commons.lang3.text.translate.EntityArrays",
    "signature": "org.apache.commons.lang3.text.translate.EntityArrays.ISO8859_1_ESCAPE()",
    "snippet": "    public static String[][] ISO8859_1_ESCAPE() { return ISO8859_1_ESCAPE.clone(); }",
    "comment": " Mapping to escape <a href=\"https://secure.wikimedia.org/wikipedia/en/wiki/ISO/IEC_8859-1\">ISO-8859-1</a> characters to their named HTML 3.x equivalents. @return the mapping table ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "EntityArrays.ISO8859_1_UNESCAPE",
    "class_name": "org.apache.commons.lang3.text.translate.EntityArrays",
    "signature": "org.apache.commons.lang3.text.translate.EntityArrays.ISO8859_1_UNESCAPE()",
    "snippet": "    public static String[][] ISO8859_1_UNESCAPE() { return ISO8859_1_UNESCAPE.clone(); }",
    "comment": " Reverse of {@link #ISO8859_1_ESCAPE()} for unescaping purposes. @return the mapping table ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "EntityArrays.JAVA_CTRL_CHARS_ESCAPE",
    "class_name": "org.apache.commons.lang3.text.translate.EntityArrays",
    "signature": "org.apache.commons.lang3.text.translate.EntityArrays.JAVA_CTRL_CHARS_ESCAPE()",
    "snippet": "    public static String[][] JAVA_CTRL_CHARS_ESCAPE() { return JAVA_CTRL_CHARS_ESCAPE.clone(); }",
    "comment": " Mapping to escape the Java control characters.  Namely: {@code \\b \\n \\t \\f \\r} @return the mapping table ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "EntityArrays.JAVA_CTRL_CHARS_UNESCAPE",
    "class_name": "org.apache.commons.lang3.text.translate.EntityArrays",
    "signature": "org.apache.commons.lang3.text.translate.EntityArrays.JAVA_CTRL_CHARS_UNESCAPE()",
    "snippet": "    public static String[][] JAVA_CTRL_CHARS_UNESCAPE() { return JAVA_CTRL_CHARS_UNESCAPE.clone(); }",
    "comment": " Reverse of {@link #JAVA_CTRL_CHARS_ESCAPE()} for unescaping purposes. @return the mapping table ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "EntityArrays.invert",
    "class_name": "org.apache.commons.lang3.text.translate.EntityArrays",
    "signature": "org.apache.commons.lang3.text.translate.EntityArrays.invert(String[][])",
    "snippet": "    public static String[][] invert(String[][] array) {\n        String[][] newarray = new String[array.length][2];\n        for(int i = 0; i<array.length; i++) {\n            newarray[i][0] = array[i][1];\n            newarray[i][1] = array[i][0];\n        }\n        return newarray;\n    }",
    "comment": " Used to invert an escape array into an unescape array @param array String[][] to be inverted @return String[][] inverted array ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "LookupTranslator.LookupTranslator",
    "class_name": "org.apache.commons.lang3.text.translate.LookupTranslator",
    "signature": "org.apache.commons.lang3.text.translate.LookupTranslator.LookupTranslator(CharSequence[][])",
    "snippet": "    public LookupTranslator(CharSequence[]... lookup) {\n        lookupMap = new HashMap<CharSequence, CharSequence>();\n        int _shortest = Integer.MAX_VALUE;\n        int _longest = 0;\n        if (lookup != null) {\n            for (CharSequence[] seq : lookup) {\n                this.lookupMap.put(seq[0], seq[1]);\n                int sz = seq[0].length();\n                if (sz < _shortest) {\n                    _shortest = sz;\n                }\n                if (sz > _longest) {\n                    _longest = sz;\n                }\n            }\n        }\n        shortest = _shortest;\n        longest = _longest;\n    }",
    "comment": " Define the lookup table to be used in translation  @param lookup CharSequence[][] table of size [*][2] ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "NumericEntityUnescaper.NumericEntityUnescaper",
    "class_name": "org.apache.commons.lang3.text.translate.NumericEntityUnescaper",
    "signature": "org.apache.commons.lang3.text.translate.NumericEntityUnescaper.NumericEntityUnescaper(OPTION[])",
    "snippet": "    public NumericEntityUnescaper(OPTION... options) {\n        if(options.length > 0) {\n            this.options = EnumSet.copyOf(Arrays.asList(options));\n        } else {\n            this.options = EnumSet.copyOf(Arrays.asList(new OPTION[] { OPTION.semiColonRequired }));\n        }\n    }",
    "comment": " Create a UnicodeUnescaper.  The constructor takes a list of options, only one type of which is currently  available (whether to allow, error or ignore the semi-colon on the end of a  numeric entity to being missing).  For example, to support numeric entities without a ';': new NumericEntityUnescaper(NumericEntityUnescaper.OPTION.semiColonOptional) and to throw an IllegalArgumentException when they're missing: new NumericEntityUnescaper(NumericEntityUnescaper.OPTION.errorIfNoSemiColon)  Note that the default behaviour is to ignore them.   @param options to apply to this unescaper ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  },
  {
    "name": "UnicodeEscaper.outsideOf",
    "class_name": "org.apache.commons.lang3.text.translate.UnicodeEscaper",
    "signature": "org.apache.commons.lang3.text.translate.UnicodeEscaper.outsideOf(int,int)",
    "snippet": "    public static UnicodeEscaper outsideOf(int codepointLow, int codepointHigh) {\n        return new UnicodeEscaper(codepointLow, codepointHigh, false);\n    }",
    "comment": " <p>Constructs a <code>UnicodeEscaper</code> outside of the specified values (exclusive). </p>  @param codepointLow below which to escape @param codepointHigh above which to escape @return the newly created {@code UnicodeEscaper} instance ",
    "is_bug": false,
    "failing_test_cases": 1,
    "buggy_methods": 1
  }
]