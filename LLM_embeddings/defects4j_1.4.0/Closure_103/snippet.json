[
  {
    "name": "AbstractMessageFormatter.AbstractMessageFormatter",
    "class_name": "com.google.javascript.jscomp.AbstractMessageFormatter",
    "signature": "com.google.javascript.jscomp.AbstractMessageFormatter.AbstractMessageFormatter(SourceExcerptProvider)",
    "snippet": "  public AbstractMessageFormatter(SourceExcerptProvider source) {\n    this.source = source;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "AbstractMessageFormatter.setColorize",
    "class_name": "com.google.javascript.jscomp.AbstractMessageFormatter",
    "signature": "com.google.javascript.jscomp.AbstractMessageFormatter.setColorize(boolean)",
    "snippet": "  public void setColorize(boolean colorize) {\n    this.colorize = colorize;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "BasicErrorManager.getErrorCount",
    "class_name": "com.google.javascript.jscomp.BasicErrorManager",
    "signature": "com.google.javascript.jscomp.BasicErrorManager.getErrorCount()",
    "snippet": "  public int getErrorCount() {\n    return errorCount;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "BasicErrorManager.getErrors",
    "class_name": "com.google.javascript.jscomp.BasicErrorManager",
    "signature": "com.google.javascript.jscomp.BasicErrorManager.getErrors()",
    "snippet": "  public JSError[] getErrors() {\n    return toArray(CheckLevel.ERROR);\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "BasicErrorManager.getWarningCount",
    "class_name": "com.google.javascript.jscomp.BasicErrorManager",
    "signature": "com.google.javascript.jscomp.BasicErrorManager.getWarningCount()",
    "snippet": "  public int getWarningCount() {\n    return warningCount;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "BasicErrorManager.getWarnings",
    "class_name": "com.google.javascript.jscomp.BasicErrorManager",
    "signature": "com.google.javascript.jscomp.BasicErrorManager.getWarnings()",
    "snippet": "  public JSError[] getWarnings() {\n    return toArray(CheckLevel.WARNING);\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "BasicErrorManager.report",
    "class_name": "com.google.javascript.jscomp.BasicErrorManager",
    "signature": "com.google.javascript.jscomp.BasicErrorManager.report(CheckLevel,JSError)",
    "snippet": "  public void report(CheckLevel level, JSError error) {\n    if (messages.add(new ErrorWithLevel(error, level))) {\n      if (level == CheckLevel.ERROR) {\n        errorCount++;\n      } else if (level == CheckLevel.WARNING) {\n        warningCount++;\n      }\n    }\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "BasicErrorManager.toArray",
    "class_name": "com.google.javascript.jscomp.BasicErrorManager",
    "signature": "com.google.javascript.jscomp.BasicErrorManager.toArray(CheckLevel)",
    "snippet": "  private JSError[] toArray(CheckLevel level) {\n    List<JSError> errors = new ArrayList<JSError>(messages.size());\n    for (ErrorWithLevel p : messages) {\n      if (p.level == level) {\n        errors.add(p.error);\n      }\n    }\n    return errors.toArray(new JSError[errors.size()]);\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "LeveledJSErrorComparator.compare",
    "class_name": "com.google.javascript.jscomp.BasicErrorManager$LeveledJSErrorComparator",
    "signature": "com.google.javascript.jscomp.BasicErrorManager$LeveledJSErrorComparator.compare(ErrorWithLevel,ErrorWithLevel)",
    "snippet": "    public int compare(ErrorWithLevel p1, ErrorWithLevel p2) {\n      // null is the smallest value\n      if (p2 == null) {\n        if (p1 == null) {\n          return 0;\n        } else {\n          return P1_GT_P2;\n        }\n      }\n\n      // check level\n      if (p1.level != p2.level) {\n        return p2.level.compareTo(p1.level);\n      }\n\n      // sourceName comparison\n      String source1 = p1.error.sourceName;\n      String source2 = p2.error.sourceName;\n      if (source1 != null && source2 != null) {\n        int sourceCompare = source1.compareTo(source2);\n        if (sourceCompare != 0) {\n          return sourceCompare;\n        }\n      } else if (source1 == null && source2 != null) {\n        return P1_LT_P2;\n      } else if (source1 != null && source2 == null) {\n        return P1_GT_P2;\n      }\n      // lineno comparison\n      int lineno1 = p1.error.lineNumber;\n      int lineno2 = p2.error.lineNumber;\n      if (lineno1 != lineno2) {\n        return lineno1 - lineno2;\n      } else if (lineno1 < 0 && 0 <= lineno2) {\n        return P1_LT_P2;\n      } else if (0 <= lineno1 && lineno2 < 0) {\n        return P1_GT_P2;\n      }\n      // charno comparison\n      int charno1 = p1.error.getCharno();\n      int charno2 = p2.error.getCharno();\n      if (charno1 != charno2) {\n        return charno1 - charno2;\n      } else if (charno1 < 0 && 0 <= charno2) {\n        return P1_LT_P2;\n      } else if (0 <= charno1 && charno2 < 0) {\n        return P1_GT_P2;\n      }\n      // description\n      return p1.error.description.compareTo(p2.error.description);\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "ChainableReverseAbstractInterpreter.ChainableReverseAbstractInterpreter",
    "class_name": "com.google.javascript.jscomp.ChainableReverseAbstractInterpreter",
    "signature": "com.google.javascript.jscomp.ChainableReverseAbstractInterpreter.ChainableReverseAbstractInterpreter(CodingConvention,JSTypeRegistry)",
    "snippet": "  ChainableReverseAbstractInterpreter(CodingConvention convention,\n      JSTypeRegistry typeRegistry) {\n    Preconditions.checkNotNull(convention);\n    this.convention = convention;\n    this.typeRegistry = typeRegistry;\n    firstLink = this;\n    nextLink = null;\n  }",
    "comment": " Constructs an interpreter, which is the only link in a chain. Interpreters can be appended using {@link #append}. ",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "CheckLevel.isOn",
    "class_name": "com.google.javascript.jscomp.CheckLevel",
    "signature": "com.google.javascript.jscomp.CheckLevel.isOn()",
    "snippet": "  boolean isOn() {\n    return this != OFF;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "CheckUnreachableCode.CheckUnreachableCode",
    "class_name": "com.google.javascript.jscomp.CheckUnreachableCode",
    "signature": "com.google.javascript.jscomp.CheckUnreachableCode.CheckUnreachableCode(AbstractCompiler,CheckLevel)",
    "snippet": "  CheckUnreachableCode(AbstractCompiler compiler, CheckLevel level) {\n    this.compiler = compiler;\n    this.level = level;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "CheckUnreachableCode.enterScope",
    "class_name": "com.google.javascript.jscomp.CheckUnreachableCode",
    "signature": "com.google.javascript.jscomp.CheckUnreachableCode.enterScope(NodeTraversal)",
    "snippet": "  @Override\n  public void enterScope(NodeTraversal t) {\n    new GraphReachability<Node, ControlFlowGraph.Branch>(\n        t.getControlFlowGraph()).compute(\n            t.getControlFlowGraph().getEntry().getValue());\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "CheckUnreachableCode.exitScope",
    "class_name": "com.google.javascript.jscomp.CheckUnreachableCode",
    "signature": "com.google.javascript.jscomp.CheckUnreachableCode.exitScope(NodeTraversal)",
    "snippet": "  @Override\n  public void exitScope(NodeTraversal t) {\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "CheckUnreachableCode.shouldTraverse",
    "class_name": "com.google.javascript.jscomp.CheckUnreachableCode",
    "signature": "com.google.javascript.jscomp.CheckUnreachableCode.shouldTraverse(NodeTraversal,Node,Node)",
    "snippet": "  @Override\n  public boolean shouldTraverse(NodeTraversal t, Node n, Node parent) {\n    GraphNode<Node, Branch> gNode = t.getControlFlowGraph().getNode(n);\n    if (gNode != null && gNode.getAnnotation() != GraphReachability.REACHABLE) {\n\n      // Only report error when there are some line number informations.\n      // There are synthetic nodes with no line number informations, nodes\n      // introduce by other passes (although not likely since this pass should\n      // be executed early) or some rhino bug.\n      if (n.getLineno() != -1 &&\n          // Allow spurious semi-colons and spurious breaks.\n          n.getType() != Token.EMPTY && n.getType() != Token.BREAK) {\n        compiler.report(JSError.make(t, n, level, UNREACHABLE_CODE));\n        // From now on, we are going to assume the user fixed the error and not\n        // give more warning related to code section reachable from this node.\n        new GraphReachability<Node, ControlFlowGraph.Branch>(\n            t.getControlFlowGraph()).recompute(n);\n\n        // Saves time by not traversing children.\n        return false;\n      }\n    }\n    return true;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "CheckUnreachableCode.visit",
    "class_name": "com.google.javascript.jscomp.CheckUnreachableCode",
    "signature": "com.google.javascript.jscomp.CheckUnreachableCode.visit(NodeTraversal,Node,Node)",
    "snippet": "  @Override\n  public void visit(NodeTraversal t, Node n, Node parent) {\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "RecentChange.hasCodeChanged",
    "class_name": "com.google.javascript.jscomp.CodeChangeHandler$RecentChange",
    "signature": "com.google.javascript.jscomp.CodeChangeHandler$RecentChange.hasCodeChanged()",
    "snippet": "    boolean hasCodeChanged() {\n      return hasChanged;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "RecentChange.reset",
    "class_name": "com.google.javascript.jscomp.CodeChangeHandler$RecentChange",
    "signature": "com.google.javascript.jscomp.CodeChangeHandler$RecentChange.reset()",
    "snippet": "    void reset() {\n      hasChanged = false;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "CodeConsumer.add",
    "class_name": "com.google.javascript.jscomp.CodeConsumer",
    "signature": "com.google.javascript.jscomp.CodeConsumer.add(String)",
    "snippet": "  void add(String newcode) {\n    maybeEndStatement();\n\n    if (newcode.length() == 0) {\n      return;\n    }\n\n    char c = newcode.charAt(0);\n    if ((isWordChar(c) || c == '\\\\') &&\n        isWordChar(getLastChar())) {\n      // need space to separate. This is not pretty printing.\n      // For example: \"return foo;\"\n      append(\" \");\n    }\n\n    append(newcode);\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "CodeConsumer.addIdentifier",
    "class_name": "com.google.javascript.jscomp.CodeConsumer",
    "signature": "com.google.javascript.jscomp.CodeConsumer.addIdentifier(String)",
    "snippet": "  void addIdentifier(String identifier) {\n    add(identifier);\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "CodeConsumer.addOp",
    "class_name": "com.google.javascript.jscomp.CodeConsumer",
    "signature": "com.google.javascript.jscomp.CodeConsumer.addOp(String,boolean)",
    "snippet": "  void addOp(String op, boolean binOp) {\n    maybeEndStatement();\n\n    char first = op.charAt(0);\n    char prev = getLastChar();\n\n    if ((first == '+' || first == '-') && prev == first) {\n      // This is not pretty printing. This is to prevent misparsing of\n      // things like \"x + ++y\" or \"x++ + ++y\"\n      append(\" \");\n    } else if (Character.isLetter(first) &&\n               isWordChar(prev)) {\n      // Make sure there is a space after e.g. instanceof , typeof\n      append(\" \");\n    } else if (prev == '-' && first == '>') {\n      // Make sure that we don't emit -->\n      append(\" \");\n    }\n\n    // Allow formating around the operator.\n    appendOp(op, binOp);\n\n    // Line breaking after an operator is always safe. Line breaking before an\n    // operator on the other hand is not. We only line break after a bin op\n    // because it looks strange.\n    if (binOp) {\n      maybeCutLine();\n    }\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "CodeConsumer.appendBlockEnd",
    "class_name": "com.google.javascript.jscomp.CodeConsumer",
    "signature": "com.google.javascript.jscomp.CodeConsumer.appendBlockEnd()",
    "snippet": "  void appendBlockEnd() {\n    append(\"}\");\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "CodeConsumer.appendBlockStart",
    "class_name": "com.google.javascript.jscomp.CodeConsumer",
    "signature": "com.google.javascript.jscomp.CodeConsumer.appendBlockStart()",
    "snippet": "  void appendBlockStart() {\n    append(\"{\");\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "CodeConsumer.appendOp",
    "class_name": "com.google.javascript.jscomp.CodeConsumer",
    "signature": "com.google.javascript.jscomp.CodeConsumer.appendOp(String,boolean)",
    "snippet": "  void appendOp(String op, boolean binOp) {\n    append(op);\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "CodeConsumer.beginBlock",
    "class_name": "com.google.javascript.jscomp.CodeConsumer",
    "signature": "com.google.javascript.jscomp.CodeConsumer.beginBlock()",
    "snippet": "  void beginBlock() {\n    if (statementNeedsEnded) {\n      append(\";\");\n      maybeLineBreak();\n    }\n    appendBlockStart();\n\n    endLine();\n    statementNeedsEnded = false;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "CodeConsumer.continueProcessing",
    "class_name": "com.google.javascript.jscomp.CodeConsumer",
    "signature": "com.google.javascript.jscomp.CodeConsumer.continueProcessing()",
    "snippet": "  boolean continueProcessing() {\n    return true;\n  }",
    "comment": " Provides a means of interrupting the CodeGenerator. Derived classes should return false to stop further processing. ",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "CodeConsumer.endBlock",
    "class_name": "com.google.javascript.jscomp.CodeConsumer",
    "signature": "com.google.javascript.jscomp.CodeConsumer.endBlock(boolean)",
    "snippet": "  void endBlock(boolean statementContext) {\n    appendBlockEnd();\n    if (statementContext) {\n      endLine();\n    }\n    statementNeedsEnded = false;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "CodeConsumer.endFunction",
    "class_name": "com.google.javascript.jscomp.CodeConsumer",
    "signature": "com.google.javascript.jscomp.CodeConsumer.endFunction(boolean)",
    "snippet": "  void endFunction(boolean statementContext) {\n    sawFunction = true;\n    if (statementContext) {\n      endLine();\n    }\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "CodeConsumer.endLine",
    "class_name": "com.google.javascript.jscomp.CodeConsumer",
    "signature": "com.google.javascript.jscomp.CodeConsumer.endLine()",
    "snippet": "  void endLine() {\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "CodeConsumer.endStatement",
    "class_name": "com.google.javascript.jscomp.CodeConsumer",
    "signature": "com.google.javascript.jscomp.CodeConsumer.endStatement()",
    "snippet": "  void endStatement() {\n    endStatement(false);\n  }",
    "comment": " Indicates the end of a statement and a ';' may need to be added. But we don't add it now, in case we're at the end of a block (in which case we don't have to add the ';'). See maybeEndStatement() ",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "CodeConsumer.endStatement",
    "class_name": "com.google.javascript.jscomp.CodeConsumer",
    "signature": "com.google.javascript.jscomp.CodeConsumer.endStatement(boolean)",
    "snippet": "  void endStatement(boolean needSemiColon) {\n    if (needSemiColon) {\n      append(\";\");\n      maybeLineBreak();\n      statementNeedsEnded = false;\n    } else if (statementStarted) {\n      statementNeedsEnded = true;\n    }\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "CodeConsumer.isWordChar",
    "class_name": "com.google.javascript.jscomp.CodeConsumer",
    "signature": "com.google.javascript.jscomp.CodeConsumer.isWordChar(char)",
    "snippet": "  static boolean isWordChar(char ch) {\n    return (ch == '_' ||\n            ch == '$' ||\n            Character.isLetterOrDigit(ch));\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "CodeConsumer.maybeEndStatement",
    "class_name": "com.google.javascript.jscomp.CodeConsumer",
    "signature": "com.google.javascript.jscomp.CodeConsumer.maybeEndStatement()",
    "snippet": "  void maybeEndStatement() {\n    // Add a ';' if we need to.\n    if (statementNeedsEnded) {\n      append(\";\");\n      maybeLineBreak();\n      endLine();\n      statementNeedsEnded = false;\n    }\n    statementStarted = true;\n  }",
    "comment": " This is to be called when we're in a statement. If the prev statement needs to be ended, add a ';'. ",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "CodeGenerator.CodeGenerator",
    "class_name": "com.google.javascript.jscomp.CodeGenerator",
    "signature": "com.google.javascript.jscomp.CodeGenerator.CodeGenerator(CodeConsumer,Charset,boolean)",
    "snippet": "  CodeGenerator(\n      CodeConsumer consumer, Charset outputCharset, boolean validation) {\n    this.validation = validation;\n    cc = consumer;\n    if (outputCharset == null || outputCharset == Charsets.US_ASCII) {\n      // If we want our default (pretending to be UTF-8, but escaping anything\n      // outside of straight ASCII), then don't use the encoder, but\n      // just special-case the code.  This keeps the normal path through\n      // the code identical to how it's been for years.\n      this.outputCharsetEncoder = null;\n    } else {\n      this.outputCharsetEncoder = outputCharset.newEncoder();\n    }\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "CodeGenerator.add",
    "class_name": "com.google.javascript.jscomp.CodeGenerator",
    "signature": "com.google.javascript.jscomp.CodeGenerator.add(Node)",
    "snippet": "  void add(Node n) {\n    add(n, Context.OTHER);\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "CodeGenerator.add",
    "class_name": "com.google.javascript.jscomp.CodeGenerator",
    "signature": "com.google.javascript.jscomp.CodeGenerator.add(Node,Context)",
    "snippet": "  void add(Node n, Context context) {\n    if (!cc.continueProcessing()) {\n      return;\n    }\n\n    int type = n.getType();\n    String opstr = NodeUtil.opToStr(type);\n    int childCount = n.getChildCount();\n    Node first = n.getFirstChild();\n    Node last = n.getLastChild();\n\n    // Handle all binary operators\n    if (opstr != null && first != last) {\n      Preconditions.checkState(childCount == 2);\n      int p = NodeUtil.precedence(type);\n      addLeftExpr(first, p, context);\n      cc.addOp(opstr, true);\n\n      // For right-hand-side of operations, only pass context if it's\n      // the IN_FOR_INIT_CLAUSE one.\n      Context rhsContext = getContextForNoInOperator(context);\n\n      // Handle associativity.\n      // e.g. if the parse tree is a * (b * c),\n      // we can simply generate a * b * c.\n      if (last.getType() == type &&\n          NodeUtil.isAssociative(type)) {\n        addExpr(last, p, rhsContext);\n      } else if (NodeUtil.isAssignmentOp(n) && NodeUtil.isAssignmentOp(last)) {\n        // Assignments are the only right-associative binary operators\n        addExpr(last, p, rhsContext);\n      } else {\n        addExpr(last, p + 1, rhsContext);\n      }\n      return;\n    }\n\n    cc.startSourceMapping(n);\n\n    switch (type) {\n      case Token.TRY: {\n        Preconditions.checkState(first.getNext().getType() == Token.BLOCK &&\n                first.getNext().getChildCount() <= 1);\n        Preconditions.checkState(childCount >= 2 && childCount <= 3);\n\n        add(\"try\");\n        add(first, Context.PRESERVE_BLOCK);\n\n        // second child contains the catch block, or nothing if there\n        // isn't a catch block\n        Node catchblock = first.getNext().getFirstChild();\n        if (catchblock != null) {\n          add(catchblock);\n        }\n\n        if (childCount == 3) {\n          add(\"finally\");\n          add(last, Context.PRESERVE_BLOCK);\n        }\n        break;\n      }\n\n      case Token.CATCH:\n        Preconditions.checkState(childCount == 3);\n        if (first.getNext().getType() != Token.EMPTY) {\n          throw new Error(\"Catch conditions not suppored because I think\" +\n                          \" that it may be a netscape only feature.\");\n        }\n\n        add(\"catch(\");\n        add(first);\n        add(\")\");\n        add(last, Context.PRESERVE_BLOCK);\n        break;\n\n      case Token.THROW:\n        Preconditions.checkState(childCount == 1);\n        add(\"throw\");\n        add(first);\n\n        // Must have a ';' after a throw statement, otherwise safari can't\n        // parse this.\n        cc.endStatement(true);\n        break;\n\n      case Token.RETURN:\n        add(\"return\");\n        if (childCount == 1) {\n          add(first);\n        } else {\n          Preconditions.checkState(childCount == 0);\n        }\n        cc.endStatement();\n        break;\n\n      case Token.VAR:\n        if (first != null) {\n          add(\"var \");\n          addList(first, false, getContextForNoInOperator(context));\n        }\n        break;\n\n      case Token.NAME:\n        if (first == null || first.getType() == Token.EMPTY) {\n          addIdentifier(n.getString());\n        } else {\n          Preconditions.checkState(childCount == 1);\n          addIdentifier(n.getString());\n          cc.addOp(\"=\", true);\n          if (first.getType() == Token.COMMA) {\n            addExpr(first, NodeUtil.precedence(Token.ASSIGN));\n          } else {\n            // Add expression, consider nearby code at lowest level of\n            // precedence.\n            addExpr(first, 0, getContextForNoInOperator(context));\n          }\n        }\n\n        break;\n\n      case Token.ARRAYLIT:\n        add(\"[\");\n        addList(first, (int[]) n.getProp(Node.SKIP_INDEXES_PROP));\n        add(\"]\");\n        break;\n\n      case Token.LP:\n        add(\"(\");\n        addList(first);\n        add(\")\");\n        break;\n\n      case Token.COMMA:\n        addList(first, false, context);\n        break;\n\n      case Token.NUMBER:\n        Preconditions.checkState(childCount == 0);\n        cc.addNumber(n.getDouble());\n        break;\n\n      case Token.TYPEOF:\n      case Token.VOID:\n      case Token.NOT:\n      case Token.BITNOT:\n      case Token.POS:\n      case Token.NEG: {\n        // All of these unary operators are right-associative\n        Preconditions.checkState(childCount == 1);\n        cc.addOp(NodeUtil.opToStrNoFail(type), false);\n        addExpr(first, NodeUtil.precedence(type));\n        break;\n      }\n\n      case Token.HOOK: {\n        Preconditions.checkState(childCount == 3);\n        int p = NodeUtil.precedence(type);\n        addLeftExpr(first, p + 1, context);\n        cc.addOp(\"?\", true);\n        addExpr(first.getNext(), p);\n        cc.addOp(\":\", true);\n        addExpr(last, p);\n        break;\n      }\n\n      case Token.REGEXP:\n        if (first.getType() != Token.STRING ||\n            last.getType() != Token.STRING) {\n          throw new Error(\"Expected children to be strings\");\n        }\n\n        String regexp = regexpEscape(first.getString(), outputCharsetEncoder);\n\n        // I only use one .add because whitespace matters\n        if (childCount == 2) {\n          add(regexp + last.getString());\n        } else {\n          Preconditions.checkState(childCount == 1);\n          add(regexp);\n        }\n        break;\n\n      case Token.GET_REF:\n        add(first);\n        break;\n\n      case Token.REF_SPECIAL:\n        Preconditions.checkState(childCount == 1);\n        add(first);\n        add(\".\");\n        add((String) n.getProp(Node.NAME_PROP));\n        break;\n\n      case Token.FUNCTION:\n        Preconditions.checkState(childCount == 3);\n        boolean funcNeedsParens = (context == Context.START_OF_EXPR);\n        if (funcNeedsParens) {\n          add(\"(\");\n        }\n\n        add(\"function\");\n        add(first);\n\n        add(first.getNext());\n        add(last, Context.PRESERVE_BLOCK);\n        cc.endFunction(context == Context.STATEMENT);\n\n        if (funcNeedsParens) {\n          add(\")\");\n        }\n        break;\n\n      case Token.SCRIPT:\n      case Token.BLOCK: {\n        boolean stripBlock = n.isSyntheticBlock() ||\n            ((context != Context.PRESERVE_BLOCK) && (n.getChildCount() < 2));\n        if (!stripBlock) {\n          cc.beginBlock();\n        }\n        for (Node c = first; c != null; c = c.getNext()) {\n          add(c, Context.STATEMENT);\n\n          // VAR doesn't include ';' since it gets used in expressions\n          if (c.getType() == Token.VAR) {\n            cc.endStatement();\n          }\n\n          if (c.getType() == Token.FUNCTION) {\n            cc.maybeLineBreak();\n          }\n\n          // Prefer to break lines in between top-level statements\n          // because top level statements are more homogeneous.\n          if (type == Token.SCRIPT) {\n            cc.notePreferredLineBreak();\n          }\n        }\n        if (!stripBlock) {\n          cc.endBlock(context == Context.STATEMENT);\n        }\n        break;\n      }\n\n      case Token.FOR:\n        if (childCount == 4) {\n          add(\"for(\");\n          if (first.getType() == Token.VAR) {\n            add(first, Context.IN_FOR_INIT_CLAUSE);\n          } else {\n            addExpr(first, 0, Context.IN_FOR_INIT_CLAUSE);\n          }\n          add(\";\");\n          add(first.getNext());\n          add(\";\");\n          add(first.getNext().getNext());\n          add(\")\");\n          addNonEmptyExpression(\n              last, getContextForNonEmptyExpression(context), false);\n        } else {\n          Preconditions.checkState(childCount == 3);\n          add(\"for(\");\n          add(first);\n          add(\"in\");\n          add(first.getNext());\n          add(\")\");\n          addNonEmptyExpression(\n              last, getContextForNonEmptyExpression(context), false);\n        }\n        break;\n\n      case Token.DO:\n        Preconditions.checkState(childCount == 2);\n        add(\"do\");\n        addNonEmptyExpression(first, Context.OTHER, false);\n        add(\"while(\");\n        add(last);\n        add(\")\");\n        cc.endStatement();\n        break;\n\n      case Token.WHILE:\n        Preconditions.checkState(childCount == 2);\n        add(\"while(\");\n        add(first);\n        add(\")\");\n        addNonEmptyExpression(\n            last, getContextForNonEmptyExpression(context), false);\n        break;\n\n      case Token.EMPTY:\n        Preconditions.checkState(childCount == 0);\n        break;\n\n      case Token.GETPROP: {\n        Preconditions.checkState(childCount == 2);\n        Preconditions.checkState(last.getType() == Token.STRING);\n        boolean needsParens = (first.getType() == Token.NUMBER);\n        if (needsParens) {\n          add(\"(\");\n        }\n        addLeftExpr(first, NodeUtil.precedence(type), context);\n        if (needsParens) {\n          add(\")\");\n        }\n        add(\".\");\n        addIdentifier(last.getString());\n        break;\n      }\n\n      case Token.GETELEM:\n        Preconditions.checkState(childCount == 2);\n        addLeftExpr(first, NodeUtil.precedence(type), context);\n        add(\"[\");\n        add(first.getNext());\n        add(\"]\");\n        break;\n\n      case Token.WITH:\n        Preconditions.checkState(childCount == 2);\n        add(\"with(\");\n        add(first);\n        add(\")\");\n        addNonEmptyExpression(\n            last, getContextForNonEmptyExpression(context), false);\n        break;\n\n      case Token.INC:\n      case Token.DEC: {\n        Preconditions.checkState(childCount == 1);\n        String o = type == Token.INC ? \"++\" : \"--\";\n        int postProp = n.getIntProp(Node.INCRDECR_PROP, 0);\n        // A non-zero post-prop value indicates a post inc/dec, default of zero\n        // is a pre-inc/dec.\n        if (postProp != 0) {\n          addLeftExpr(first, NodeUtil.precedence(type), context);\n          cc.addOp(o, false);\n        } else {\n          cc.addOp(o, false);\n          add(first);\n        }\n        break;\n      }\n\n      case Token.CALL:\n        // If the left hand side of the call is a direct reference to eval,\n        // then it must have a DIRECT_EVAL annotation. If it does not, then\n        // that means it was originally an indirect call to eval, and that\n        // indirectness must be preserved.\n        if (first.getType() == Token.NAME &&\n            \"eval\".equals(first.getString()) &&\n            !first.getBooleanProp(Node.DIRECT_EVAL)) {\n          add(\"(0,eval)\");\n        } else {\n          addLeftExpr(first, NodeUtil.precedence(type), context);\n        }\n        add(\"(\");\n        addList(first.getNext());\n        add(\")\");\n        break;\n\n      case Token.IF:\n        boolean hasElse = childCount == 3;\n        boolean ambiguousElseClause =\n            context == Context.BEFORE_DANGLING_ELSE && !hasElse;\n        if (ambiguousElseClause) {\n          cc.beginBlock();\n        }\n\n        add(\"if(\");\n        add(first);\n        add(\")\");\n\n        if (hasElse) {\n          addNonEmptyExpression(\n              first.getNext(), Context.BEFORE_DANGLING_ELSE, false);\n          add(\"else\");\n          addNonEmptyExpression(\n              last, getContextForNonEmptyExpression(context), false);\n        } else {\n          addNonEmptyExpression(first.getNext(), Context.OTHER, false);\n          Preconditions.checkState(childCount == 2);\n        }\n\n        if (ambiguousElseClause) {\n          cc.endBlock();\n        }\n        break;\n\n      case Token.NULL:\n      case Token.THIS:\n      case Token.FALSE:\n      case Token.TRUE:\n        Preconditions.checkState(childCount == 0);\n        add(Node.tokenToName(type));\n        break;\n\n      case Token.CONTINUE:\n        Preconditions.checkState(childCount <= 1);\n        add(\"continue\");\n        if (childCount == 1) {\n          add(\" \");\n          add(first);\n        }\n        cc.endStatement();\n        break;\n\n      case Token.DEBUGGER:\n        Preconditions.checkState(childCount == 0);\n        add(\"debugger\");\n        cc.endStatement();\n        break;\n\n      case Token.BREAK:\n        Preconditions.checkState(childCount <= 1);\n        add(\"break\");\n        if (childCount == 1) {\n          add(\" \");\n          add(first);\n        }\n        cc.endStatement();\n        break;\n\n      case Token.EXPR_VOID:\n      case Token.EXPR_RESULT:\n        if (type == Token.EXPR_VOID && validation) {\n          throw new Error(\"Unexpected EXPR_VOID. Should be EXPR_RESULT.\");\n        }\n        Preconditions.checkState(childCount == 1);\n        add(first, Context.START_OF_EXPR);\n        cc.endStatement();\n        break;\n\n      case Token.NEW:\n        add(\"new \");\n        int precedence = NodeUtil.precedence(type);\n\n        // If the first child contains a CALL, then claim higher precedence\n        // to force parens. Otherwise, when parsed, NEW will bind to the\n        // first viable parens\n        if (NodeUtil.containsCall(first)) {\n          precedence = NodeUtil.precedence(first.getType()) + 1;\n        }\n        addExpr(first, precedence);\n\n        // '()' is optional when no arguments are present\n        Node next = first.getNext();\n        if (next != null) {\n          add(\"(\");\n          addList(next);\n          add(\")\");\n        }\n        break;\n\n      case Token.STRING:\n        Preconditions.checkState(childCount == 0);\n        add(jsString(n.getString(), outputCharsetEncoder));\n        break;\n\n      case Token.DELPROP:\n        Preconditions.checkState(childCount == 1);\n        add(\"delete \");\n        add(first);\n        break;\n\n      case Token.OBJECTLIT: {\n        Preconditions.checkState(childCount % 2 == 0);\n        boolean needsParens = (context == Context.START_OF_EXPR);\n        if (needsParens) {\n          add(\"(\");\n        }\n        add(\"{\");\n        for (Node c = first; c != null; c = c.getNext().getNext()) {\n          if (c != first) {\n            cc.listSeparator();\n          }\n\n          // Object literal property names don't have to be quoted if they are\n          // not JavaScript keywords\n          if (c.getType() == Token.STRING &&\n              !TokenStream.isKeyword(c.getString()) &&\n              TokenStream.isJSIdentifier(c.getString()) &&\n              // do not encode literally any non-literal characters that were\n              // unicode escaped.\n              NodeUtil.isLatin(c.getString())) {\n            add(c.getString());\n          } else {\n            addExpr(c, 1);\n          }\n          add(\":\");\n          addExpr(c.getNext(), 1);\n        }\n        add(\"}\");\n        if (needsParens) {\n          add(\")\");\n        }\n        break;\n      }\n\n      case Token.SWITCH:\n        add(\"switch(\");\n        add(first);\n        add(\")\");\n        cc.beginBlock();\n        addAllSiblings(first.getNext());\n        cc.endBlock(context == Context.STATEMENT);\n        break;\n\n      case Token.CASE:\n        Preconditions.checkState(childCount == 2);\n        add(\"case \");\n        add(first);\n        addCaseBody(last);\n        break;\n\n      case Token.DEFAULT:\n        Preconditions.checkState(childCount == 1);\n        add(\"default\");\n        addCaseBody(first);\n        break;\n\n      case Token.LABEL:\n        Preconditions.checkState(childCount == 2);\n        add(first);\n        add(\":\");\n        addNonEmptyExpression(\n            last, getContextForNonEmptyExpression(context), true);\n        break;\n\n      // This node is auto generated in anonymous functions and should just get\n      // ignored for our purposes.\n      case Token.SETNAME:\n        break;\n\n      default:\n        throw new Error(\"Unknown type \" + type + \"\\n\" + n.toStringTree());\n    }\n\n    cc.endSourceMapping(n);\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "CodeGenerator.add",
    "class_name": "com.google.javascript.jscomp.CodeGenerator",
    "signature": "com.google.javascript.jscomp.CodeGenerator.add(String)",
    "snippet": "  void add(String str) {\n    cc.add(str);\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "CodeGenerator.addExpr",
    "class_name": "com.google.javascript.jscomp.CodeGenerator",
    "signature": "com.google.javascript.jscomp.CodeGenerator.addExpr(Node,int,Context)",
    "snippet": "  private void addExpr(Node n, int minPrecedence, Context context) {\n    if ((NodeUtil.precedence(n.getType()) < minPrecedence) ||\n        ((context == Context.IN_FOR_INIT_CLAUSE) &&\n        (n.getType() == Token.IN))){\n      add(\"(\");\n      add(n, clearContextForNoInOperator(context));\n      add(\")\");\n    } else {\n      add(n, context);\n    }\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "CodeGenerator.addIdentifier",
    "class_name": "com.google.javascript.jscomp.CodeGenerator",
    "signature": "com.google.javascript.jscomp.CodeGenerator.addIdentifier(String)",
    "snippet": "  private void addIdentifier(String identifier) {\n    cc.addIdentifier(identifierEscape(identifier));\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "CodeGenerator.addLeftExpr",
    "class_name": "com.google.javascript.jscomp.CodeGenerator",
    "signature": "com.google.javascript.jscomp.CodeGenerator.addLeftExpr(Node,int,Context)",
    "snippet": "  void addLeftExpr(Node n, int minPrecedence, Context context) {\n    addExpr(n, minPrecedence, context);\n  }",
    "comment": " Adds a node at the left-hand side of an expression. Unlike {@link #addExpr(Node,int)}, this preserves information about the context.  The left side of an expression is special because in the JavaScript grammar, certain tokens may be parsed differently when they are at the beginning of a statement. For example, \"{}\" is parsed as a block, but \"{'x': 'y'}\" is parsed as an object literal. ",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "CodeGenerator.addList",
    "class_name": "com.google.javascript.jscomp.CodeGenerator",
    "signature": "com.google.javascript.jscomp.CodeGenerator.addList(Node)",
    "snippet": "  void addList(Node firstInList) {\n    addList(firstInList, true, Context.OTHER);\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "CodeGenerator.addList",
    "class_name": "com.google.javascript.jscomp.CodeGenerator",
    "signature": "com.google.javascript.jscomp.CodeGenerator.addList(Node,boolean,Context)",
    "snippet": "  void addList(Node firstInList, boolean isArrayOrFunctionArgument,\n               Context lhsContext) {\n    for (Node n = firstInList; n != null; n = n.getNext()) {\n      boolean isFirst = n == firstInList;\n      if (isFirst) {\n        addLeftExpr(n, isArrayOrFunctionArgument ? 1 : 0, lhsContext);\n      } else {\n        cc.listSeparator();\n        addExpr(n, isArrayOrFunctionArgument ? 1 : 0);\n      }\n    }\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "CodeGenerator.getContextForNoInOperator",
    "class_name": "com.google.javascript.jscomp.CodeGenerator",
    "signature": "com.google.javascript.jscomp.CodeGenerator.getContextForNoInOperator(Context)",
    "snippet": "  private  Context getContextForNoInOperator(Context context) {\n    return (context == Context.IN_FOR_INIT_CLAUSE\n        ? Context.IN_FOR_INIT_CLAUSE : Context.OTHER);\n  }",
    "comment": " If we're in a IN_FOR_INIT_CLAUSE, we can't permit in operators in the expression.  Pass on the IN_FOR_INIT_CLAUSE flag through subexpressions. ",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "CodeGenerator.identifierEscape",
    "class_name": "com.google.javascript.jscomp.CodeGenerator",
    "signature": "com.google.javascript.jscomp.CodeGenerator.identifierEscape(String)",
    "snippet": "  static String identifierEscape(String s) {\n    // First check if escaping is needed at all -- in most cases it isn't.\n    if (NodeUtil.isLatin(s)) {\n      return s;\n    }\n\n    // Now going through the string to escape non-latin characters if needed.\n    StringBuilder sb = new StringBuilder();\n    for (int i = 0; i < s.length(); i++) {\n      char c = s.charAt(i);\n      // Identifiers should always go to Latin1/ ASCII characters because\n      // different browser's rules for valid identifier characters are\n      // crazy.\n      if (c > 0x1F && c < 0x7F) {\n        sb.append(c);\n      } else {\n        appendHexJavaScriptRepresentation(sb, c);\n      }\n    }\n    return sb.toString();\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "CodePrinter.toSource",
    "class_name": "com.google.javascript.jscomp.CodePrinter",
    "signature": "com.google.javascript.jscomp.CodePrinter.toSource(Node,Format,boolean,int,SourceMap,Charset,boolean)",
    "snippet": "  private static String toSource(Node root, Format outputFormat,\n                                 boolean lineBreak,  int lineLengthThreshold,\n                                 SourceMap sourceMap,\n                                 Charset outputCharset,\n                                 boolean validation) {\n    boolean createSourceMap = (sourceMap != null);\n    CodeConsumer cp =\n        outputFormat == Format.COMPACT\n        ? new CompactCodePrinter(\n            lineBreak, lineLengthThreshold, createSourceMap)\n        : new PrettyCodePrinter(lineLengthThreshold, createSourceMap);\n    CodeGenerator cg =\n        outputFormat == Format.TYPED\n        ? new TypedCodeGenerator(cp, outputCharset)\n        : new CodeGenerator(cp, outputCharset, validation);\n    cg.add(root);\n\n    String code = ((HasGetCode) cp).getCode();\n\n    if (createSourceMap) {\n      cp.generateSourceMap(sourceMap);\n    }\n\n    return code;\n  }",
    "comment": " Converts a tree to js code ",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "Builder.build",
    "class_name": "com.google.javascript.jscomp.CodePrinter$Builder",
    "signature": "com.google.javascript.jscomp.CodePrinter$Builder.build()",
    "snippet": "    String build() {\n      if (root == null) {\n        throw new IllegalStateException(\n            \"Cannot build without root node being specified\");\n      }\n\n      Format outputFormat = outputTypes\n          ? Format.TYPED\n          : prettyPrint\n              ? Format.PRETTY\n              : Format.COMPACT;\n\n      return toSource(root, outputFormat, lineBreak, lineLengthThreshold,\n          sourceMap, outputCharset, validation);\n    }",
    "comment": " Generates the source code and returns it. ",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "Builder.setLineBreak",
    "class_name": "com.google.javascript.jscomp.CodePrinter$Builder",
    "signature": "com.google.javascript.jscomp.CodePrinter$Builder.setLineBreak(boolean)",
    "snippet": "    Builder setLineBreak(boolean lineBreak) {\n      this.lineBreak = lineBreak;\n      return this;\n    }",
    "comment": " Sets whether line breaking should be done automatically. @param lineBreak If true, line breaking is done automatically. ",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "Builder.setOutputCharset",
    "class_name": "com.google.javascript.jscomp.CodePrinter$Builder",
    "signature": "com.google.javascript.jscomp.CodePrinter$Builder.setOutputCharset(Charset)",
    "snippet": "    Builder setOutputCharset(Charset outCharset) {\n      this.outputCharset = outCharset;\n      return this;\n    }",
    "comment": " Set the charset to use when determining what characters need to be escaped in the output. ",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "Builder.setPrettyPrint",
    "class_name": "com.google.javascript.jscomp.CodePrinter$Builder",
    "signature": "com.google.javascript.jscomp.CodePrinter$Builder.setPrettyPrint(boolean)",
    "snippet": "    Builder setPrettyPrint(boolean prettyPrint) {\n      this.prettyPrint = prettyPrint;\n      return this;\n    }",
    "comment": " Sets whether pretty printing should be used. @param prettyPrint If true, pretty printing will be used. ",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "Builder.setSourceMap",
    "class_name": "com.google.javascript.jscomp.CodePrinter$Builder",
    "signature": "com.google.javascript.jscomp.CodePrinter$Builder.setSourceMap(SourceMap)",
    "snippet": "    Builder setSourceMap(SourceMap sourceMap) {\n      this.sourceMap = sourceMap;\n      return this;\n    }",
    "comment": " Sets the source map to which to write the metadata about the generated source code.  @param sourceMap The source map. ",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "CompactCodePrinter.append",
    "class_name": "com.google.javascript.jscomp.CodePrinter$CompactCodePrinter",
    "signature": "com.google.javascript.jscomp.CodePrinter$CompactCodePrinter.append(String)",
    "snippet": "    @Override\n    void append(String str) {\n      code.append(str);\n      lineLength += str.length();\n    }",
    "comment": " Appends a string to the code, keeping track of the current line length. ",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "CompactCodePrinter.getCode",
    "class_name": "com.google.javascript.jscomp.CodePrinter$CompactCodePrinter",
    "signature": "com.google.javascript.jscomp.CodePrinter$CompactCodePrinter.getCode()",
    "snippet": "    public String getCode() {\n      return code.toString();\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "CompactCodePrinter.getLastChar",
    "class_name": "com.google.javascript.jscomp.CodePrinter$CompactCodePrinter",
    "signature": "com.google.javascript.jscomp.CodePrinter$CompactCodePrinter.getLastChar()",
    "snippet": "    @Override\n    char getLastChar() {\n      return (code.length() > 0) ? code.charAt(code.length() - 1) : '\\0';\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "CompactCodePrinter.maybeCutLine",
    "class_name": "com.google.javascript.jscomp.CodePrinter$CompactCodePrinter",
    "signature": "com.google.javascript.jscomp.CodePrinter$CompactCodePrinter.maybeCutLine()",
    "snippet": "    @Override\n    void maybeCutLine() {\n      if (lineLength > lineLengthThreshold) {\n        // Use the preferred position provided it will break the line.\n        if (preferredBreakPosition > lineStartPosition &&\n            preferredBreakPosition < lineStartPosition + lineLength) {\n          int position = preferredBreakPosition;\n          code.insert(position, '\\n');\n          reportLineCut(lineIndex, position - lineStartPosition);\n          lineIndex++;\n          lineLength -= (position - lineStartPosition);\n          lineStartPosition = position + 1;\n        } else {\n          startNewLine();\n        }\n      }\n    }",
    "comment": " This may start a new line if the current line is longer than the line length threshold. ",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "CompactCodePrinter.maybeLineBreak",
    "class_name": "com.google.javascript.jscomp.CodePrinter$CompactCodePrinter",
    "signature": "com.google.javascript.jscomp.CodePrinter$CompactCodePrinter.maybeLineBreak()",
    "snippet": "    @Override\n    void maybeLineBreak() {\n      if (lineBreak) {\n        if (sawFunction) {\n          startNewLine();\n          sawFunction = false;\n        }\n      }\n\n      // Since we are at a legal line break, can we upgrade the\n      // preferred break position?  We prefer to break after a\n      // semicolon rather than before it.\n      int len = code.length();\n      if (preferredBreakPosition == len - 1) {\n        char ch = code.charAt(len - 1);\n        if (ch == ';') {\n          preferredBreakPosition = len;\n        }\n      }\n      maybeCutLine();\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "CompactCodePrinter.notePreferredLineBreak",
    "class_name": "com.google.javascript.jscomp.CodePrinter$CompactCodePrinter",
    "signature": "com.google.javascript.jscomp.CodePrinter$CompactCodePrinter.notePreferredLineBreak()",
    "snippet": "    @Override\n    void notePreferredLineBreak() {\n      preferredBreakPosition = code.length();\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "MappedCodePrinter.endSourceMapping",
    "class_name": "com.google.javascript.jscomp.CodePrinter$MappedCodePrinter",
    "signature": "com.google.javascript.jscomp.CodePrinter$MappedCodePrinter.endSourceMapping(Node)",
    "snippet": "    @Override\n    void endSourceMapping(Node node) {\n      if (createSrcMap\n          && node.getProp(Node.SOURCEFILE_PROP) != null\n          && node.getLineno() > 0) {\n        int line = getCurrentLineIndex();\n        int index = getCurrentCharIndex();\n\n        // If the index is -1, we are not performing any mapping.\n        if (index >= 0) {\n          Preconditions.checkState(\n              !mappings.empty(), \"Mismatch in start and end of mapping\");\n\n          Mapping mapping = mappings.pop();\n          mapping.end = new Position(line, index);\n        }\n      }\n    }",
    "comment": " Finishes the source mapping for the given node at the current position. ",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "MappedCodePrinter.startSourceMapping",
    "class_name": "com.google.javascript.jscomp.CodePrinter$MappedCodePrinter",
    "signature": "com.google.javascript.jscomp.CodePrinter$MappedCodePrinter.startSourceMapping(Node)",
    "snippet": "    @Override\n    void startSourceMapping(Node node) {\n      if (createSrcMap\n          && node.getProp(Node.SOURCEFILE_PROP) != null\n          && node.getLineno() > 0) {\n        int line = getCurrentLineIndex();\n        int index = getCurrentCharIndex();\n\n        // If the index is -1, we are not performing any mapping.\n        if (index >= 0) {\n          Mapping mapping = new Mapping();\n          mapping.node = node;\n          mapping.start = new Position(line, index);\n          mappings.push(mapping);\n          allMappings.add(mapping);\n        }\n      }\n    }",
    "comment": " Starts the source mapping for the given node at the current position. ",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "CodingConventionAnnotator.CodingConventionAnnotator",
    "class_name": "com.google.javascript.jscomp.CodingConventionAnnotator",
    "signature": "com.google.javascript.jscomp.CodingConventionAnnotator.CodingConventionAnnotator(AbstractCompiler)",
    "snippet": "  public CodingConventionAnnotator(AbstractCompiler compiler) {\n    this.compiler = compiler;\n    this.convention = compiler.getCodingConvention();\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "CodingConventionAnnotator.process",
    "class_name": "com.google.javascript.jscomp.CodingConventionAnnotator",
    "signature": "com.google.javascript.jscomp.CodingConventionAnnotator.process(Node,Node)",
    "snippet": "  @Override\n  public void process(Node externs, Node root) {\n    if (externs != null) {\n      NodeTraversal.traverse(compiler, externs, this);\n    }\n    if (root != null) {\n      NodeTraversal.traverse(compiler, root, this);\n    }\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "CodingConventionAnnotator.visit",
    "class_name": "com.google.javascript.jscomp.CodingConventionAnnotator",
    "signature": "com.google.javascript.jscomp.CodingConventionAnnotator.visit(NodeTraversal,Node,Node)",
    "snippet": "  @Override\n  public void visit(NodeTraversal t, Node n, Node parent) {\n    int nType = n.getType();\n    switch (nType) {\n      case Token.NAME:\n      case Token.STRING:\n        String nString = n.getString();\n        if (nType == Token.NAME &&\n            n.getParent().getType() == Token.CALL &&\n            \"eval\".equals(nString)) {\n          n.putBooleanProp(Node.DIRECT_EVAL, true);\n        }\n        if (convention.isConstant(nString)) {\n          n.putBooleanProp(Node.IS_CONSTANT_NAME, true);\n        }\n        break;\n\n      case Token.FUNCTION:\n        JSDocInfo fnInfo = n.getJSDocInfo();\n        if (fnInfo == null) {\n          // Look for the info on other nodes.\n          if (parent.getType() == Token.ASSIGN) {\n            // on ASSIGNs\n            fnInfo = parent.getJSDocInfo();\n          } else if (parent.getType() == Token.NAME) {\n            // on var NAME = function() { ... };\n            fnInfo = parent.getParent().getJSDocInfo();\n          }\n        }\n\n        // Compute which function parameters are optional and\n        // which are var_args.\n        Node args = n.getFirstChild().getNext();\n        for (Node arg = args.getFirstChild();\n             arg != null;\n             arg = arg.getNext()) {\n          String argName = arg.getString();\n          JSTypeExpression typeExpr = fnInfo == null ?\n              null : fnInfo.getParameterType(argName);\n\n          if (convention.isOptionalParameter(arg) ||\n              typeExpr != null && typeExpr.isOptionalArg()) {\n            arg.putBooleanProp(Node.IS_OPTIONAL_PARAM, true);\n          }\n          if (convention.isVarArgsParameter(arg) ||\n              typeExpr != null && typeExpr.isVarArgs()) {\n            arg.putBooleanProp(Node.IS_VAR_ARGS_PARAM, true);\n          }\n        }\n        break;\n    }\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "CombinedCompilerPass.CombinedCompilerPass",
    "class_name": "com.google.javascript.jscomp.CombinedCompilerPass",
    "signature": "com.google.javascript.jscomp.CombinedCompilerPass.CombinedCompilerPass(AbstractCompiler,Callback[])",
    "snippet": "  CombinedCompilerPass(\n      AbstractCompiler compiler, Callback... callbacks) {\n    this.compiler = compiler;\n    this.callbacks = new CallbackWrapper[callbacks.length];\n    for (int i = 0; i < callbacks.length; i++) {\n      this.callbacks[i] = new CallbackWrapper(callbacks[i]);\n    }\n  }",
    "comment": " Creates a combined compiler pass. @param compiler the compiler ",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "CombinedCompilerPass.enterScope",
    "class_name": "com.google.javascript.jscomp.CombinedCompilerPass",
    "signature": "com.google.javascript.jscomp.CombinedCompilerPass.enterScope(NodeTraversal)",
    "snippet": "  @Override\n  public void enterScope(NodeTraversal t) {\n    for (CallbackWrapper callback : callbacks) {\n      callback.enterScopeIfActive(t);\n    }\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "CombinedCompilerPass.exitScope",
    "class_name": "com.google.javascript.jscomp.CombinedCompilerPass",
    "signature": "com.google.javascript.jscomp.CombinedCompilerPass.exitScope(NodeTraversal)",
    "snippet": "  @Override\n  public void exitScope(NodeTraversal t) {\n    for (CallbackWrapper callback : callbacks) {\n      callback.exitScopeIfActive(t);\n    }\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "CombinedCompilerPass.process",
    "class_name": "com.google.javascript.jscomp.CombinedCompilerPass",
    "signature": "com.google.javascript.jscomp.CombinedCompilerPass.process(Node,Node)",
    "snippet": "  @Override\n  public final void process(Node externs, Node root) {\n    NodeTraversal.traverse(compiler, root, this);\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "CombinedCompilerPass.shouldTraverse",
    "class_name": "com.google.javascript.jscomp.CombinedCompilerPass",
    "signature": "com.google.javascript.jscomp.CombinedCompilerPass.shouldTraverse(NodeTraversal,Node,Node)",
    "snippet": "  @Override\n  public boolean shouldTraverse(NodeTraversal t, Node n, Node parent) {\n    for (CallbackWrapper callback : callbacks) {\n      callback.shouldTraverseIfActive(t, n, parent);\n    }\n    // Note that this method could return false if all callbacks are inactive.\n    // This apparent optimization would make this method more expensive\n    // in the typical case where not all nodes are inactive. It is\n    // very unlikely that many all callbacks would be inactive at the same\n    // time (indeed, there are several checking passes that never return false).\n    return true;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "CombinedCompilerPass.visit",
    "class_name": "com.google.javascript.jscomp.CombinedCompilerPass",
    "signature": "com.google.javascript.jscomp.CombinedCompilerPass.visit(NodeTraversal,Node,Node)",
    "snippet": "  @Override\n  public void visit(NodeTraversal t, Node n, Node parent) {\n    for (CallbackWrapper callback : callbacks) {\n      callback.visitOrMaybeActivate(t, n, parent);\n    }\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "CallbackWrapper.enterScopeIfActive",
    "class_name": "com.google.javascript.jscomp.CombinedCompilerPass$CallbackWrapper",
    "signature": "com.google.javascript.jscomp.CombinedCompilerPass$CallbackWrapper.enterScopeIfActive(NodeTraversal)",
    "snippet": "    void enterScopeIfActive(NodeTraversal t) {\n      if (isActive() && scopedCallback != null) {\n        scopedCallback.enterScope(t);\n      }\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "CallbackWrapper.exitScopeIfActive",
    "class_name": "com.google.javascript.jscomp.CombinedCompilerPass$CallbackWrapper",
    "signature": "com.google.javascript.jscomp.CombinedCompilerPass$CallbackWrapper.exitScopeIfActive(NodeTraversal)",
    "snippet": "    void exitScopeIfActive(NodeTraversal t) {\n      if (isActive() && scopedCallback != null) {\n        scopedCallback.exitScope(t);\n      }\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "CallbackWrapper.isActive",
    "class_name": "com.google.javascript.jscomp.CombinedCompilerPass$CallbackWrapper",
    "signature": "com.google.javascript.jscomp.CombinedCompilerPass$CallbackWrapper.isActive()",
    "snippet": "    boolean isActive() {\n      return waiting == null;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "CallbackWrapper.shouldTraverseIfActive",
    "class_name": "com.google.javascript.jscomp.CombinedCompilerPass$CallbackWrapper",
    "signature": "com.google.javascript.jscomp.CombinedCompilerPass$CallbackWrapper.shouldTraverseIfActive(NodeTraversal,Node,Node)",
    "snippet": "    void shouldTraverseIfActive(NodeTraversal t, Node n, Node parent) {\n      if (isActive() && !callback.shouldTraverse(t, n, parent)) {\n        waiting = n;\n      }\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "CallbackWrapper.visitOrMaybeActivate",
    "class_name": "com.google.javascript.jscomp.CombinedCompilerPass$CallbackWrapper",
    "signature": "com.google.javascript.jscomp.CombinedCompilerPass$CallbackWrapper.visitOrMaybeActivate(NodeTraversal,Node,Node)",
    "snippet": "    void visitOrMaybeActivate(NodeTraversal t, Node n, Node parent) {\n      if (isActive()) {\n        callback.visit(t, n, parent);\n      } else if (waiting == n) {\n        waiting = null;\n      }\n    }",
    "comment": " Visits the node unless the wrapped callback is inactive. Activates the callback if appropriate.  ",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "Compiler.Compiler",
    "class_name": "com.google.javascript.jscomp.Compiler",
    "signature": "com.google.javascript.jscomp.Compiler.Compiler()",
    "snippet": "  public Compiler() {\n    addChangeHandler(recentChange);\n    this.typeValidator = new TypeValidator(this);\n    setErrorManager(new LoggerErrorManager(createMessageFormatter(), logger_));\n  }",
    "comment": " Creates a Compiler that reports errors and warnings to its logger. ",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "Compiler.addChangeHandler",
    "class_name": "com.google.javascript.jscomp.Compiler",
    "signature": "com.google.javascript.jscomp.Compiler.addChangeHandler(CodeChangeHandler)",
    "snippet": "  @Override\n  void addChangeHandler(CodeChangeHandler handler) {\n    codeChangeHandlers.add(handler);\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "Compiler.annotateCodingConvention",
    "class_name": "com.google.javascript.jscomp.Compiler",
    "signature": "com.google.javascript.jscomp.Compiler.annotateCodingConvention(Node)",
    "snippet": "  @Override\n  void annotateCodingConvention(Node root) {\n    Tracer tracer = newTracer(\"annotateCodingConvention\");\n    CompilerPass pass = new CodingConventionAnnotator(this);\n    pass.process(null, root);\n    stopTracer(tracer, \"annotateCodingConvention\");\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "Compiler.createDefaultOptions",
    "class_name": "com.google.javascript.jscomp.Compiler",
    "signature": "com.google.javascript.jscomp.Compiler.createDefaultOptions()",
    "snippet": "  CompilerOptions createDefaultOptions() {\n    return new CompilerOptions();\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "Compiler.createMessageFormatter",
    "class_name": "com.google.javascript.jscomp.Compiler",
    "signature": "com.google.javascript.jscomp.Compiler.createMessageFormatter()",
    "snippet": "  private MessageFormatter createMessageFormatter() {\n    boolean colorize = options_.shouldColorizeErrorOutput();\n    return options_.errorFormat.toFormatter(this, colorize);\n  }",
    "comment": " Creates a message formatter instance corresponding to the value of {@link CompilerOptions}. ",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "Compiler.getCodingConvention",
    "class_name": "com.google.javascript.jscomp.Compiler",
    "signature": "com.google.javascript.jscomp.Compiler.getCodingConvention()",
    "snippet": "  @Override\n  public CodingConvention getCodingConvention() {\n    CodingConvention convention = options_.getCodingConvention();\n    convention = convention != null ? convention : defaultCodingConvention;\n    return convention;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "Compiler.getDefaultErrorReporter",
    "class_name": "com.google.javascript.jscomp.Compiler",
    "signature": "com.google.javascript.jscomp.Compiler.getDefaultErrorReporter()",
    "snippet": "  @Override\n  ErrorReporter getDefaultErrorReporter() {\n    return defaultErrorReporter;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "Compiler.getErrorCount",
    "class_name": "com.google.javascript.jscomp.Compiler",
    "signature": "com.google.javascript.jscomp.Compiler.getErrorCount()",
    "snippet": "  public int getErrorCount() {\n    return errorManager.getErrorCount();\n  }",
    "comment": " Gets the number of errors. ",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "Compiler.getErrors",
    "class_name": "com.google.javascript.jscomp.Compiler",
    "signature": "com.google.javascript.jscomp.Compiler.getErrors()",
    "snippet": "  public JSError[] getErrors() {\n    return errorManager.getErrors();\n  }",
    "comment": " Returns the array of errors (never null). ",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "Compiler.getParserConfig",
    "class_name": "com.google.javascript.jscomp.Compiler",
    "signature": "com.google.javascript.jscomp.Compiler.getParserConfig()",
    "snippet": "  @Override\n  Config getParserConfig() {\n    if (parserConfig == null) {\n      parserConfig = ParserRunner.createConfig(\n          getTypeRegistry(), isIdeMode());\n    }\n    return parserConfig;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "Compiler.getTypeRegistry",
    "class_name": "com.google.javascript.jscomp.Compiler",
    "signature": "com.google.javascript.jscomp.Compiler.getTypeRegistry()",
    "snippet": "  @Override\n  public JSTypeRegistry getTypeRegistry() {\n    if (typeRegistry == null) {\n      typeRegistry = new JSTypeRegistry(oldErrorReporter);\n    }\n    return typeRegistry;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "Compiler.getWarnings",
    "class_name": "com.google.javascript.jscomp.Compiler",
    "signature": "com.google.javascript.jscomp.Compiler.getWarnings()",
    "snippet": "  public JSError[] getWarnings() {\n    return errorManager.getWarnings();\n  }",
    "comment": " Returns the array of warnings (never null). ",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "Compiler.hasErrors",
    "class_name": "com.google.javascript.jscomp.Compiler",
    "signature": "com.google.javascript.jscomp.Compiler.hasErrors()",
    "snippet": "  public boolean hasErrors() {\n    return hasHaltingErrors();\n  }",
    "comment": " Consults the {@link ErrorManager} to see if we've encountered errors that should halt compilation. <p>  If {@link CompilerOptions#ideMode} is {@code true}, this function always returns {@code false} without consulting the error manager. The error manager will continue to be told about new errors and warnings, but the compiler will complete compilation of all inputs.<p> ",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "Compiler.hasHaltingErrors",
    "class_name": "com.google.javascript.jscomp.Compiler",
    "signature": "com.google.javascript.jscomp.Compiler.hasHaltingErrors()",
    "snippet": "  @Override\n  boolean hasHaltingErrors() {\n    return !isIdeMode() && getErrorCount() > 0;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "Compiler.init",
    "class_name": "com.google.javascript.jscomp.Compiler",
    "signature": "com.google.javascript.jscomp.Compiler.init(JSSourceFile[],JSSourceFile[],CompilerOptions)",
    "snippet": "  public void init(JSSourceFile[] externs, JSSourceFile[] inputs,\n      CompilerOptions options) {\n    externs_ = makeCompilerInput(externs, true);\n    modules_ = null;\n    moduleGraph_ = null;\n    inputs_ = makeCompilerInput(inputs, false);\n    options_ = options;\n    initBasedOnOptions();\n\n    initInputsByNameMap();\n  }",
    "comment": " Initializes the instance state needed for a compile job. ",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "Compiler.initBasedOnOptions",
    "class_name": "com.google.javascript.jscomp.Compiler",
    "signature": "com.google.javascript.jscomp.Compiler.initBasedOnOptions()",
    "snippet": "  private void initBasedOnOptions() {\n    // Create the source map if necessary.\n    if (options_.sourceMapOutputPath != null) {\n      sourceMap_ = new SourceMap();\n    }\n  }",
    "comment": " Do any initialization that is dependent on the compiler options. ",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "Compiler.initInputsByNameMap",
    "class_name": "com.google.javascript.jscomp.Compiler",
    "signature": "com.google.javascript.jscomp.Compiler.initInputsByNameMap()",
    "snippet": "  void initInputsByNameMap() {\n    inputsByName_ = new HashMap<String, CompilerInput>();\n    for (CompilerInput input : externs_) {\n      String name = input.getName();\n      if (!inputsByName_.containsKey(name)) {\n        inputsByName_.put(name, input);\n      } else {\n        report(JSError.make(DUPLICATE_EXTERN_INPUT, name));\n      }\n    }\n    for (CompilerInput input : inputs_) {\n      String name = input.getName();\n      if (!inputsByName_.containsKey(name)) {\n        inputsByName_.put(name, input);\n      } else {\n        report(JSError.make(DUPLICATE_INPUT, name));\n      }\n    }\n  }",
    "comment": " Creates a map to make looking up an input by name fast. Also checks for duplicate inputs. ",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "Compiler.isIdeMode",
    "class_name": "com.google.javascript.jscomp.Compiler",
    "signature": "com.google.javascript.jscomp.Compiler.isIdeMode()",
    "snippet": "  @Override\n  public boolean isIdeMode() {\n    return options_.ideMode;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "Compiler.makeCompilerInput",
    "class_name": "com.google.javascript.jscomp.Compiler",
    "signature": "com.google.javascript.jscomp.Compiler.makeCompilerInput(JSSourceFile[],boolean)",
    "snippet": "  private CompilerInput[] makeCompilerInput(\n      JSSourceFile[] files, boolean isExtern) {\n    CompilerInput [] inputs = new CompilerInput[files.length];\n    for (int i = 0; i < files.length; ++i) {\n      inputs[i] = new CompilerInput(files[i], isExtern);\n    }\n    return inputs;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "Compiler.newTracer",
    "class_name": "com.google.javascript.jscomp.Compiler",
    "signature": "com.google.javascript.jscomp.Compiler.newTracer(String)",
    "snippet": "  Tracer newTracer(String passName) {\n    String comment = passName\n        + (recentChange.hasCodeChanged() ? \" on recently changed AST\" : \"\");\n    if (options_.tracer.isOn()) {\n      tracker.recordPassStart(passName);\n    }\n    return new Tracer(\"Compiler\", comment);\n  }",
    "comment": " Returns a new tracer for the given pass name. ",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "Compiler.normalizeNodeTypes",
    "class_name": "com.google.javascript.jscomp.Compiler",
    "signature": "com.google.javascript.jscomp.Compiler.normalizeNodeTypes(Node)",
    "snippet": "  @Override\n  void normalizeNodeTypes(Node root) {\n    Tracer tracer = newTracer(\"normalizeNodeTypes\");\n\n    // TODO(johnlenz): Merge the NodeTypeNormalizer into the AST creator\n    // it doesn't need to be done separately.\n    CompilerPass pass = new NodeTypeNormalizer();\n    pass.process(null, root);\n\n    stopTracer(tracer, \"normalizeNodeTypes\");\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "Compiler.parseInputs",
    "class_name": "com.google.javascript.jscomp.Compiler",
    "signature": "com.google.javascript.jscomp.Compiler.parseInputs()",
    "snippet": "  Node parseInputs() {\n    boolean devMode = options_.devMode != DevMode.OFF;\n\n    // If old roots exist (we are parsing a second time), detach each of the\n    // individual file parse trees.\n    if (externsRoot != null) {\n      externsRoot.detachChildren();\n    }\n    if (jsRoot != null) {\n      jsRoot.detachChildren();\n    }\n\n    // Parse main js sources.\n    jsRoot = new Node(Token.BLOCK);\n    jsRoot.setIsSyntheticBlock(true);\n\n    if (options_.tracer.isOn()) {\n      tracker = new PerformanceTracker(jsRoot,\n          options_.tracer == TracerMode.ALL);\n      addChangeHandler(tracker.getCodeChangeHandler());\n    }\n\n    Tracer tracer = newTracer(\"parseInputs\");\n\n    try {\n      // Parse externs sources.\n      externsRoot = new Node(Token.BLOCK);\n      externsRoot.setIsSyntheticBlock(true);\n      for (CompilerInput input : externs_) {\n        Node n = input.getAstRoot(this);\n        if (hasErrors()) {\n          return null;\n        }\n        externsRoot.addChildToBack(n);\n      }\n\n      for (CompilerInput input : inputs_) {\n        Node n = input.getAstRoot(this);\n        if (hasErrors()) {\n          return null;\n        }\n\n        // Inputs can have a null AST during initial parse.\n        if (n == null) {\n          continue;\n        }\n\n        if (devMode) {\n          runSanityCheck();\n          if (hasErrors()) {\n            return null;\n          }\n        }\n\n        if (options_.sourceMapOutputPath != null ||\n            options_.nameReferenceReportPath != null) {\n\n          // Annotate the nodes in the tree with information from the\n          // input file. This information is used to construct the SourceMap.\n          SourceInformationAnnotator sia =\n              new SourceInformationAnnotator(input.getName());\n          NodeTraversal.traverse(this, n, sia);\n        }\n\n        jsRoot.addChildToBack(n);\n      }\n\n      externAndJsRoot = new Node(Token.BLOCK, externsRoot, jsRoot);\n      externAndJsRoot.setIsSyntheticBlock(true);\n\n      return externAndJsRoot;\n    } finally {\n      stopTracer(tracer, \"parseInputs\");\n    }\n  }",
    "comment": " Parses the externs and main inputs.  @return A synthetic root node whose two children are the externs root and the main root ",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "Compiler.report",
    "class_name": "com.google.javascript.jscomp.Compiler",
    "signature": "com.google.javascript.jscomp.Compiler.report(JSError)",
    "snippet": "  @Override\n  void report(JSError error) {\n    CheckLevel level = error.level;\n    WarningsGuard guard = options_.getWarningsGuard();\n    if (guard != null) {\n      CheckLevel newLevel = guard.level(error);\n      if (newLevel != null) {\n        level = newLevel;\n      }\n    }\n\n    if (level.isOn()) {\n      errorManager.report(level, error);\n    }\n  }",
    "comment": "------------------------------------------------------------------------",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "Compiler.setErrorManager",
    "class_name": "com.google.javascript.jscomp.Compiler",
    "signature": "com.google.javascript.jscomp.Compiler.setErrorManager(ErrorManager)",
    "snippet": "  public void setErrorManager(ErrorManager errorManager) {\n    Preconditions.checkNotNull(\n        errorManager, \"the error manager cannot be null\");\n    this.errorManager = errorManager;\n  }",
    "comment": " Sets the error manager.  @param errorManager the error manager, it cannot be {@code null} ",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "Compiler.stopTracer",
    "class_name": "com.google.javascript.jscomp.Compiler",
    "signature": "com.google.javascript.jscomp.Compiler.stopTracer(Tracer,String)",
    "snippet": "  void stopTracer(Tracer t, String passName) {\n    long result = t.stop();\n    if (options_.tracer.isOn()) {\n      tracker.recordPassStop(passName, result);\n    }\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "CompilerInput.CompilerInput",
    "class_name": "com.google.javascript.jscomp.CompilerInput",
    "signature": "com.google.javascript.jscomp.CompilerInput.CompilerInput(JSSourceFile,boolean)",
    "snippet": "  public CompilerInput(JSSourceFile file, boolean isExtern) {\n    this.ast = new JsAst(file);\n    this.name = file.getName();\n    this.isExtern = isExtern;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "CompilerInput.getAstRoot",
    "class_name": "com.google.javascript.jscomp.CompilerInput",
    "signature": "com.google.javascript.jscomp.CompilerInput.getAstRoot(AbstractCompiler)",
    "snippet": "  @Override\n  public Node getAstRoot(AbstractCompiler compiler) {\n    return ast.getAstRoot(compiler);\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "CompilerInput.getName",
    "class_name": "com.google.javascript.jscomp.CompilerInput",
    "signature": "com.google.javascript.jscomp.CompilerInput.getName()",
    "snippet": "  public String getName() {\n    return name;\n  }",
    "comment": "Returns a name for this input. Must be unique across all inputs. */",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "CompilerOptions.CompilerOptions",
    "class_name": "com.google.javascript.jscomp.CompilerOptions",
    "signature": "com.google.javascript.jscomp.CompilerOptions.CompilerOptions()",
    "snippet": "  public CompilerOptions() {\n    // Checks\n    skipAllPasses = false;\n    nameAnonymousFunctionsOnly = false;\n    devMode = DevMode.OFF;\n    checkSymbols = false;\n    checkShadowVars = CheckLevel.OFF;\n    aggressiveVarCheck = CheckLevel.OFF;\n    checkFunctions = CheckLevel.OFF;\n    checkMethods = CheckLevel.OFF;\n    checkDuplicateMessages = false;\n    allowLegacyJsMessages = false;\n    strictMessageReplacement = false;\n    checkSuspiciousCode = false;\n    checkControlStructures = false;\n    checkUndefinedProperties = CheckLevel.OFF;\n    checkUnusedPropertiesEarly = false;\n    checkTypes = false;\n    tightenTypes = false;\n    inferTypesInGlobalScope = false;\n    checkTypedPropertyCalls = false;\n    reportMissingOverride = CheckLevel.OFF;\n    reportUnknownTypes = CheckLevel.OFF;\n    checkRequires = CheckLevel.OFF;\n    checkProvides = CheckLevel.OFF;\n    checkGlobalNamesLevel = CheckLevel.OFF;\n    brokenClosureRequiresLevel = CheckLevel.ERROR;\n    checkGlobalThisLevel = CheckLevel.WARNING;\n    checkUnreachableCode = CheckLevel.OFF;\n    checkMissingReturn = CheckLevel.OFF;\n    checkMissingGetCssNameLevel = CheckLevel.OFF;\n    checkMissingGetCssNameBlacklist = null;\n    checkEs5Strict = false;\n    checkCaja = false;\n    computeFunctionSideEffects = false;\n    chainCalls = false;\n\n    // Optimizations\n    foldConstants = false;\n    removeConstantExpressions = false;\n    coalesceVariableNames = false;\n    deadAssignmentElimination = false;\n    inlineConstantVars = false;\n    inlineFunctions = false;\n    inlineLocalFunctions = false;\n    crossModuleCodeMotion = false;\n    crossModuleMethodMotion = false;\n    inlineGetters = false;\n    inlineVariables = false;\n    inlineLocalVariables = false;\n    smartNameRemoval = false;\n    removeDeadCode = false;\n    extractPrototypeMemberDeclarations = false;\n    removeUnusedPrototypeProperties = false;\n    removeUnusedPrototypePropertiesInExterns = false;\n    removeUnusedVars = false;\n    removeUnusedVarsInGlobalScope = true;\n    aliasExternals = false;\n    collapseVariableDeclarations = false;\n    collapseAnonymousFunctions = false;\n    aliasableStrings = Collections.emptySet();\n    aliasStringsBlacklist = \"\";\n    aliasAllStrings = false;\n    outputJsStringUsage = false;\n    convertToDottedProperties = false;\n    rewriteFunctionExpressions = false;\n    optimizeParameters = false;\n\n    // Renaming\n    variableRenaming = VariableRenamingPolicy.OFF;\n    propertyRenaming = PropertyRenamingPolicy.OFF;\n    labelRenaming = false;\n    generatePseudoNames = false;\n    renamePrefix = null;\n    aliasKeywords = false;\n    collapseProperties = false;\n    collapsePropertiesOnExternTypes = false;\n    devirtualizePrototypeMethods = false;\n    disambiguateProperties = false;\n    ambiguateProperties = false;\n    anonymousFunctionNaming = AnonymousFunctionNamingPolicy.OFF;\n    exportTestFunctions = false;\n\n    // Alterations\n    runtimeTypeCheck = false;\n    runtimeTypeCheckLogFunction = null;\n    instrumentForCoverage = false;\n    instrumentForCoverageOnly = false;\n    ignoreCajaProperties = false;\n    syntheticBlockStartMarker = null;\n    syntheticBlockEndMarker = null;\n    locale = null;\n    markAsCompiled = false;\n    removeTryCatchFinally = false;\n    closurePass = false;\n    rewriteNewDateGoogNow = true;\n    removeAbstractMethods = true;\n    stripTypes = Collections.emptySet();\n    stripNameSuffixes = Collections.emptySet();\n    stripNamePrefixes = Collections.emptySet();\n    stripTypePrefixes = Collections.emptySet();\n    customPasses = null;\n    markNoSideEffectCalls = false;\n    defineReplacements = Maps.newHashMap();\n    moveFunctionDeclarations = false;\n    instrumentationTemplate = null;\n    appNameStr = \"\";\n    recordFunctionInformation = false;\n    generateExports = false;\n    cssRenamingMap = null;\n    processObjectPropertyString = false;\n    idGenerators = Collections.emptySet();\n\n    // Output\n    printInputDelimiter = false;\n    prettyPrint = false;\n    lineBreak = false;\n    reportPath = null;\n    tracer = TracerMode.OFF;\n    colorizeErrorOutput = false;\n    errorFormat = ErrorFormat.SINGLELINE;\n    warningsGuard = null;\n    debugFunctionSideEffectsPath = null;\n    jsOutputFile = \"\";\n    nameReferenceReportPath = null;\n    nameReferenceGraphPath = null;\n  }",
    "comment": " Initializes compiler options. All options are disabled by default.  Command-line frontends to the compiler should set these properties like a builder. ",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "CompilerOptions.addWarningsGuard",
    "class_name": "com.google.javascript.jscomp.CompilerOptions",
    "signature": "com.google.javascript.jscomp.CompilerOptions.addWarningsGuard(WarningsGuard)",
    "snippet": "  public void addWarningsGuard(WarningsGuard guard) {\n    if (warningsGuard == null) {\n      warningsGuard = new ComposeWarningsGuard(guard);\n    } else {\n      warningsGuard.addGuard(guard);\n    }\n  }",
    "comment": " Add a guard to the set of warnings guards. ",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "CompilerOptions.getCodingConvention",
    "class_name": "com.google.javascript.jscomp.CompilerOptions",
    "signature": "com.google.javascript.jscomp.CompilerOptions.getCodingConvention()",
    "snippet": "  public CodingConvention getCodingConvention() {\n    return codingConvention;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "CompilerOptions.getWarningsGuard",
    "class_name": "com.google.javascript.jscomp.CompilerOptions",
    "signature": "com.google.javascript.jscomp.CompilerOptions.getWarningsGuard()",
    "snippet": "  WarningsGuard getWarningsGuard() {\n    return warningsGuard;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "CompilerOptions.setCodingConvention",
    "class_name": "com.google.javascript.jscomp.CompilerOptions",
    "signature": "com.google.javascript.jscomp.CompilerOptions.setCodingConvention(CodingConvention)",
    "snippet": "  public void setCodingConvention(CodingConvention codingConvention) {\n    this.codingConvention = codingConvention;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "CompilerOptions.setWarningLevel",
    "class_name": "com.google.javascript.jscomp.CompilerOptions",
    "signature": "com.google.javascript.jscomp.CompilerOptions.setWarningLevel(DiagnosticGroup,CheckLevel)",
    "snippet": "  public void setWarningLevel(DiagnosticGroup type, CheckLevel level) {\n    addWarningsGuard(new DiagnosticGroupWarningsGuard(type, level));\n  }",
    "comment": " Configure the given type of warning to the given level. ",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "CompilerOptions.shouldColorizeErrorOutput",
    "class_name": "com.google.javascript.jscomp.CompilerOptions",
    "signature": "com.google.javascript.jscomp.CompilerOptions.shouldColorizeErrorOutput()",
    "snippet": "  public boolean shouldColorizeErrorOutput() {\n    return colorizeErrorOutput;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "TracerMode.isOn",
    "class_name": "com.google.javascript.jscomp.CompilerOptions$TracerMode",
    "signature": "com.google.javascript.jscomp.CompilerOptions$TracerMode.isOn()",
    "snippet": "    boolean isOn() {\n      return this != OFF;\n    }",
    "comment": "Collect no timing and size metrics.",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "ComposeWarningsGuard.ComposeWarningsGuard",
    "class_name": "com.google.javascript.jscomp.ComposeWarningsGuard",
    "signature": "com.google.javascript.jscomp.ComposeWarningsGuard.ComposeWarningsGuard(List)",
    "snippet": "  public ComposeWarningsGuard(List<WarningsGuard> guards) {\n    this.guards = Lists.newArrayList();\n    addGuards(guards);\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "ComposeWarningsGuard.ComposeWarningsGuard",
    "class_name": "com.google.javascript.jscomp.ComposeWarningsGuard",
    "signature": "com.google.javascript.jscomp.ComposeWarningsGuard.ComposeWarningsGuard(WarningsGuard[])",
    "snippet": "  public ComposeWarningsGuard(WarningsGuard... guards) {\n    this(Lists.newArrayList(guards));\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "ComposeWarningsGuard.addGuard",
    "class_name": "com.google.javascript.jscomp.ComposeWarningsGuard",
    "signature": "com.google.javascript.jscomp.ComposeWarningsGuard.addGuard(WarningsGuard)",
    "snippet": "  void addGuard(WarningsGuard guard) {\n    if (guard instanceof ComposeWarningsGuard) {\n      addGuards(((ComposeWarningsGuard) guard).guards);\n    } else {\n      int index = Collections.binarySearch(this.guards, guard, guardComparator);\n      if (index < 0) {\n        index = -index - 1;\n      }\n      this.guards.add(index, guard);\n    }\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "ComposeWarningsGuard.addGuards",
    "class_name": "com.google.javascript.jscomp.ComposeWarningsGuard",
    "signature": "com.google.javascript.jscomp.ComposeWarningsGuard.addGuards(Iterable)",
    "snippet": "  private void addGuards(Iterable<WarningsGuard> guards) {\n    for (WarningsGuard guard : guards) {\n      addGuard(guard);\n    }\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "ComposeWarningsGuard.level",
    "class_name": "com.google.javascript.jscomp.ComposeWarningsGuard",
    "signature": "com.google.javascript.jscomp.ComposeWarningsGuard.level(JSError)",
    "snippet": "  @Override\n  public CheckLevel level(JSError error) {\n    for (WarningsGuard guard : guards) {\n      CheckLevel newLevel = guard.level(error);\n      if (newLevel != null) {\n        return newLevel;\n      }\n    }\n    return null;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "ControlFlowAnalysis.ControlFlowAnalysis",
    "class_name": "com.google.javascript.jscomp.ControlFlowAnalysis",
    "signature": "com.google.javascript.jscomp.ControlFlowAnalysis.ControlFlowAnalysis(AbstractCompiler,boolean)",
    "snippet": "  ControlFlowAnalysis(AbstractCompiler compiler,\n      boolean shouldTraverseFunctions) {\n    this.compiler = compiler;\n    this.shouldTraverseFunctions = shouldTraverseFunctions;\n  }",
    "comment": " Constructor.  @param compiler Compiler instance. @param shouldTraverseFunctions Whether functions should be traversed (true by default). ",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "ControlFlowAnalysis.computeFallThrough",
    "class_name": "com.google.javascript.jscomp.ControlFlowAnalysis",
    "signature": "com.google.javascript.jscomp.ControlFlowAnalysis.computeFallThrough(Node)",
    "snippet": "  private static Node computeFallThrough(Node n) {\n    switch (n.getType()) {\n      case Token.DO:\n        return computeFallThrough(n.getFirstChild());\n      case Token.FOR:\n        if (NodeUtil.isForIn(n)) {\n          return n;\n        }\n        return computeFallThrough(n.getFirstChild());\n      case Token.LABEL:\n        return computeFallThrough(n.getLastChild());\n      default:\n        return n;\n    }\n  }",
    "comment": " Computes the destination node of n when we want to fallthough into the subtree of n. We don't always create a CFG edge into n itself because of DOs and FORs. ",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "ControlFlowAnalysis.computeFollowNode",
    "class_name": "com.google.javascript.jscomp.ControlFlowAnalysis",
    "signature": "com.google.javascript.jscomp.ControlFlowAnalysis.computeFollowNode(Node)",
    "snippet": "  private Node computeFollowNode(Node node) {\n    return computeFollowNode(node, node);\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "ControlFlowAnalysis.computeFollowNode",
    "class_name": "com.google.javascript.jscomp.ControlFlowAnalysis",
    "signature": "com.google.javascript.jscomp.ControlFlowAnalysis.computeFollowNode(Node,Node)",
    "snippet": "  private Node computeFollowNode(Node fromNode, Node node) {\n    /*\n     * This is the case where:\n     *\n     * 1. Parent is null implies that we are transferring control to the end of\n     * the script.\n     *\n     * 2. Parent is a function implies that we are transferring control back to\n     * the caller of the function.\n     *\n     * 3. If the node is a return statement, we should also transfer control\n     * back to the caller of the function.\n     *\n     * 4. If the node is root then we have reached the end of what we have been\n     * asked to traverse.\n     *\n     * In all cases we should transfer control to a \"symbolic return\" node.\n     * This will make life easier for DFAs.\n     */\n    Node parent = node.getParent();\n    if (parent == null || parent.getType() == Token.FUNCTION || node == root) {\n      return null;\n    }\n\n    // If we are just before a IF/WHILE/DO/FOR:\n    switch (parent.getType()) {\n      // The follow() of any of the path from IF would be what follows IF.\n      case Token.IF:\n        return computeFollowNode(fromNode, parent);\n      case Token.CASE:\n      case Token.DEFAULT:\n        // After the body of a CASE, the control goes to the body of the next\n        // case, without having to go to the case condition.\n        if (parent.getNext() != null) {\n          if (parent.getNext().getType() == Token.CASE) {\n            return parent.getNext().getFirstChild().getNext();\n          } else if (parent.getNext().getType() == Token.DEFAULT) {\n            return parent.getNext().getFirstChild();\n          } else {\n            Preconditions.checkState(false, \"Not reachable\");\n          }\n        } else {\n          return computeFollowNode(fromNode, parent);\n        }\n        break;\n      case Token.FOR:\n        if (NodeUtil.isForIn(parent)) {\n          return parent;\n        } else {\n          return parent.getFirstChild().getNext().getNext();\n        }\n      case Token.WHILE:\n      case Token.DO:\n        return parent;\n      case Token.TRY:\n        // If we are coming out of the TRY block...\n        if (parent.getFirstChild() == node) {\n          if (NodeUtil.hasFinally(parent)) { // and have FINALLY block.\n            return computeFallThrough(parent.getLastChild());\n          } else { // and have no FINALLY.\n            return computeFollowNode(fromNode, parent);\n          }\n        // CATCH block.\n        } else if (NodeUtil.getCatchBlock(parent) == node){\n          if (NodeUtil.hasFinally(parent)) { // and have FINALLY block.\n            return computeFallThrough(node.getNext());\n          } else {\n            return computeFollowNode(fromNode, parent);\n          }\n        // If we are coming out of the FINALLY block...\n        } else if (parent.getLastChild() == node){\n          for (Node finallyNode : finallyMap.get(parent)) {\n            createEdge(fromNode, Branch.UNCOND, finallyNode);\n          }\n          return computeFollowNode(fromNode, parent);\n        }\n    }\n\n    // Now that we are done with the special cases follow should be its\n    // immediate sibling, unless its sibling is a function\n    Node nextSibling = node.getNext();\n\n    // Skip function declarations because control doesn't get pass into it.\n    while (nextSibling != null && nextSibling.getType() == Token.FUNCTION) {\n      nextSibling = nextSibling.getNext();\n    }\n\n    if (nextSibling != null) {\n      return computeFallThrough(nextSibling);\n    } else {\n      // If there are no more siblings, control is transfered up the AST.\n      return computeFollowNode(fromNode, parent);\n    }\n  }",
    "comment": " Computes the follow() node of a given node and its parent. There is a side effect when calling this function. If this function computed an edge that exists a FINALLY, it'll attempt to connect the fromNode to the outer FINALLY according to the finallyMap.  @param fromNode The original source node since {@code node} is changed during recursion. @param node The node that follow() should compute. ",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "ControlFlowAnalysis.connectToPossibleExceptionHandler",
    "class_name": "com.google.javascript.jscomp.ControlFlowAnalysis",
    "signature": "com.google.javascript.jscomp.ControlFlowAnalysis.connectToPossibleExceptionHandler(Node,Node)",
    "snippet": "  private void connectToPossibleExceptionHandler(Node cfgNode, Node target) {\n    if (mayThrowException(target) && !exceptionHandler.isEmpty()) {\n      Node lastJump = cfgNode;\n      for (Node handler : exceptionHandler) {\n        if (NodeUtil.isFunction(handler)) {\n          return;\n        }\n        Preconditions.checkState(handler.getType() == Token.TRY);\n        Node catchBlock = NodeUtil.getCatchBlock(handler);\n\n        if (!NodeUtil.hasCatchHandler(catchBlock)) { // No catch but a FINALLY.\n          if (lastJump == cfgNode) {\n            createEdge(cfgNode, Branch.ON_EX, handler.getLastChild());\n          } else {\n            finallyMap.put(lastJump, handler.getLastChild());\n          }\n        } else { // Has a catch.\n          if (lastJump == cfgNode) {\n            createEdge(cfgNode, Branch.ON_EX, catchBlock);\n            return;\n          } else {\n            finallyMap.put(lastJump, catchBlock);\n          }\n        }\n        lastJump = handler;\n      }\n    }\n  }",
    "comment": " Connects cfgNode to the proper CATCH block if target subtree might throw an exception. If there are FINALLY blocks reached before a CATCH, it will make the corresponding entry in finallyMap. ",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "ControlFlowAnalysis.createEdge",
    "class_name": "com.google.javascript.jscomp.ControlFlowAnalysis",
    "signature": "com.google.javascript.jscomp.ControlFlowAnalysis.createEdge(Node,Branch,Node)",
    "snippet": "  private void createEdge(Node fromNode, ControlFlowGraph.Branch branch,\n      Node toNode) {\n    cfg.createNode(fromNode);\n    cfg.createNode(toNode);\n    cfg.connectIfNotFound(fromNode, branch, toNode);\n  }",
    "comment": " Connects the two nodes in the control flow graph.  @param fromNode Source. @param toNode Destination. ",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "ControlFlowAnalysis.getCfg",
    "class_name": "com.google.javascript.jscomp.ControlFlowAnalysis",
    "signature": "com.google.javascript.jscomp.ControlFlowAnalysis.getCfg()",
    "snippet": "  ControlFlowGraph<Node> getCfg() {\n    return cfg;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "ControlFlowAnalysis.handleCatch",
    "class_name": "com.google.javascript.jscomp.ControlFlowAnalysis",
    "signature": "com.google.javascript.jscomp.ControlFlowAnalysis.handleCatch(Node)",
    "snippet": "  private void handleCatch(Node node) {\n    createEdge(node, Branch.UNCOND, node.getLastChild());\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "ControlFlowAnalysis.handleFunction",
    "class_name": "com.google.javascript.jscomp.ControlFlowAnalysis",
    "signature": "com.google.javascript.jscomp.ControlFlowAnalysis.handleFunction(Node)",
    "snippet": "  private void handleFunction(Node node) {\n    // A block transfer control to its first child if it is not empty.\n    Preconditions.checkState(node.getChildCount() >= 3);\n    createEdge(node, Branch.UNCOND,\n        computeFallThrough(node.getFirstChild().getNext().getNext()));\n    Preconditions.checkState(exceptionHandler.peek() == node);\n    exceptionHandler.pop();\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "ControlFlowAnalysis.handleIf",
    "class_name": "com.google.javascript.jscomp.ControlFlowAnalysis",
    "signature": "com.google.javascript.jscomp.ControlFlowAnalysis.handleIf(Node)",
    "snippet": "  private void handleIf(Node node) {\n    Node thenBlock = node.getFirstChild().getNext();\n    Node elseBlock = thenBlock.getNext();\n    createEdge(node, Branch.ON_TRUE, computeFallThrough(thenBlock));\n\n    if (elseBlock == null) {\n      createEdge(node, Branch.ON_FALSE,\n          computeFollowNode(node)); // not taken branch\n    } else {\n      createEdge(node, Branch.ON_FALSE, computeFallThrough(elseBlock));\n    }\n    connectToPossibleExceptionHandler(\n        node, NodeUtil.getConditionExpression(node));\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "ControlFlowAnalysis.handleReturn",
    "class_name": "com.google.javascript.jscomp.ControlFlowAnalysis",
    "signature": "com.google.javascript.jscomp.ControlFlowAnalysis.handleReturn(Node)",
    "snippet": "  private void handleReturn(Node node) {\n    Node lastJump = null;\n    for (Iterator<Node> iter = exceptionHandler.iterator(); iter.hasNext();) {\n      Node curHandler = iter.next();\n      if (NodeUtil.isFunction(curHandler)) {\n        break;\n      }\n      if (NodeUtil.hasFinally(curHandler)) {\n        if (lastJump == null) {\n          createEdge(node, Branch.UNCOND, curHandler.getLastChild());\n        } else {\n          finallyMap.put(lastJump,\n              computeFallThrough(curHandler.getLastChild()));\n        }\n        lastJump = curHandler;\n      }\n    }\n\n    if (node.hasChildren()) {\n      connectToPossibleExceptionHandler(node, node.getFirstChild());\n    }\n\n    if (lastJump == null) {\n      createEdge(node, Branch.UNCOND, null);\n    } else {\n      finallyMap.put(lastJump, null);\n    }\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "ControlFlowAnalysis.handleStmtList",
    "class_name": "com.google.javascript.jscomp.ControlFlowAnalysis",
    "signature": "com.google.javascript.jscomp.ControlFlowAnalysis.handleStmtList(Node)",
    "snippet": "  private void handleStmtList(Node node) {\n    Node parent = node.getParent();\n    // Special case, don't add a block of empty CATCH block to the graph.\n    if (node.getType() == Token.BLOCK && parent != null &&\n        parent.getType() == Token.TRY &&\n        NodeUtil.getCatchBlock(parent) == node &&\n        !NodeUtil.hasCatchHandler(node)) {\n      return;\n    }\n\n    // A block transfer control to its first child if it is not empty.\n    Node child = node.getFirstChild();\n\n    // Function declarations are skipped since control doesn't go into that\n    // function (unless it is called)\n    while (child != null && child.getType() == Token.FUNCTION) {\n      child = child.getNext();\n    }\n\n    if (child != null) {\n      createEdge(node, Branch.UNCOND, computeFallThrough(child));\n    } else {\n      createEdge(node, Branch.UNCOND, computeFollowNode(node));\n    }\n\n    // Synthetic blocks\n    if (parent != null) {\n      switch (parent.getType()) {\n        case Token.DEFAULT:\n        case Token.CASE:\n        case Token.TRY:\n          break;\n        default:\n          if (node.getType() == Token.BLOCK && node.isSyntheticBlock()) {\n            Node next = node.getLastChild();\n            if (next != null) {\n              createEdge(node, Branch.SYN_BLOCK, computeFallThrough(next));\n            }\n          }\n          break;\n      }\n    }\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "ControlFlowAnalysis.handleTry",
    "class_name": "com.google.javascript.jscomp.ControlFlowAnalysis",
    "signature": "com.google.javascript.jscomp.ControlFlowAnalysis.handleTry(Node)",
    "snippet": "  private void handleTry(Node node) {\n    createEdge(node, Branch.UNCOND, node.getFirstChild());\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "ControlFlowAnalysis.mayThrowException",
    "class_name": "com.google.javascript.jscomp.ControlFlowAnalysis",
    "signature": "com.google.javascript.jscomp.ControlFlowAnalysis.mayThrowException(Node)",
    "snippet": "  private static boolean mayThrowException(Node n) {\n    switch (n.getType()) {\n      case Token.CALL:\n      case Token.GETPROP:\n      case Token.GETELEM:\n      case Token.THROW:\n      case Token.NEW:\n      case Token.ASSIGN:\n      case Token.INC:\n      case Token.DEC:\n        return true;\n      case Token.FUNCTION:\n        return false;\n    }\n    for (Node c = n.getFirstChild(); c != null; c = c.getNext()) {\n      if (!ControlFlowGraph.isEnteringNewCfgNode(c) && mayThrowException(c)) {\n        return true;\n      }\n    }\n    return false;\n  }",
    "comment": " Determines if the subtree might throw an exception. ",
    "is_bug": true,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "ControlFlowAnalysis.prioritizeFromEntryNode",
    "class_name": "com.google.javascript.jscomp.ControlFlowAnalysis",
    "signature": "com.google.javascript.jscomp.ControlFlowAnalysis.prioritizeFromEntryNode(DiGraphNode)",
    "snippet": "  private void prioritizeFromEntryNode(DiGraphNode<Node, Branch> entry) {\n    PriorityQueue<DiGraphNode<Node, Branch>> worklist =\n        new PriorityQueue<DiGraphNode<Node, Branch>>(10, priorityComparator);\n    worklist.add(entry);\n\n    while (!worklist.isEmpty()) {\n      DiGraphNode<Node, Branch> current = worklist.remove();\n      if (nodePriorities.containsKey(current)) {\n        continue;\n      }\n\n      nodePriorities.put(current, ++priorityCounter);\n\n      List<DiGraphNode<Node, Branch>> successors =\n          cfg.getDirectedSuccNodes(current);\n      for (DiGraphNode<Node, Branch> candidate : successors) {\n        worklist.add(candidate);\n      }\n    }\n  }",
    "comment": " Given an entry node, find all the nodes reachable from that node and prioritize them. ",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "ControlFlowAnalysis.process",
    "class_name": "com.google.javascript.jscomp.ControlFlowAnalysis",
    "signature": "com.google.javascript.jscomp.ControlFlowAnalysis.process(Node,Node)",
    "snippet": "  @Override\n  public void process(Node externs, Node root) {\n    this.root = root;\n    astPositionCounter = 0;\n    astPosition = Maps.newHashMap();\n    nodePriorities = Maps.newHashMap();\n    cfg = new AstControlFlowGraph(computeFallThrough(root), nodePriorities);\n    NodeTraversal.traverse(compiler, root, this);\n    astPosition.put(null, ++astPositionCounter); // the implicit return is last.\n\n    // Now, generate the priority of nodes by doing a depth-first\n    // search on the CFG.\n    priorityCounter = 0;\n    DiGraphNode<Node, Branch> entry = cfg.getEntry();\n    prioritizeFromEntryNode(entry);\n\n    if (shouldTraverseFunctions) {\n      // If we're traversing inner functions, we need to rank the\n      // priority of them too.\n      for (DiGraphNode<Node, Branch> candidate : cfg.getDirectedGraphNodes()) {\n        Node value = candidate.getValue();\n        if (value != null && value.getType() == Token.FUNCTION) {\n          Preconditions.checkState(\n              !nodePriorities.containsKey(candidate) || candidate == entry);\n          prioritizeFromEntryNode(candidate);\n        }\n      }\n    }\n\n    // At this point, all reachable nodes have been given a priority, but\n    // unreachable nodes have not been given a priority. Put them last.\n    // Presumably, it doesn't really matter what priority they get, since\n    // this shouldn't happen in real code.\n    for (DiGraphNode<Node, Branch> candidate : cfg.getDirectedGraphNodes()) {\n      if (!nodePriorities.containsKey(candidate)) {\n        nodePriorities.put(candidate, ++priorityCounter);\n      }\n    }\n\n    // Again, the implicit return node is always last.\n    nodePriorities.put(cfg.getImplicitReturn(), ++priorityCounter);\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "ControlFlowAnalysis.shouldTraverse",
    "class_name": "com.google.javascript.jscomp.ControlFlowAnalysis",
    "signature": "com.google.javascript.jscomp.ControlFlowAnalysis.shouldTraverse(NodeTraversal,Node,Node)",
    "snippet": "  @Override\n  public boolean shouldTraverse(\n      NodeTraversal nodeTraversal, Node n, Node parent) {\n    astPosition.put(n, astPositionCounter++);\n\n    switch (n.getType()) {\n      case Token.FUNCTION:\n        if (shouldTraverseFunctions || n == cfg.getEntry().getValue()) {\n          exceptionHandler.push(n);\n          return true;\n        }\n        return false;\n      case Token.TRY:\n        exceptionHandler.push(n);\n        return true;\n    }\n\n    /*\n     * We are going to stop the traversal depending on what the node's parent\n     * is.\n     *\n     * We are only interested in adding edges between nodes that change control\n     * flow. The most obvious ones are loops and IF-ELSE's. A statement\n     * transfers control to its next sibling.\n     *\n     * In case of an expression tree, there is no control flow within the tree\n     * even when there are short circuited operators and conditionals. When we\n     * are doing data flow analysis, we will simply synthesize lattices up the\n     * expression tree by finding the meet at each expression node.\n     *\n     * For example: within a Token.SWITCH, the expression in question does not\n     * change the control flow and need not to be considered.\n     */\n    if (parent != null) {\n      switch (parent.getType()) {\n        case Token.FOR:\n          // Only traverse the body of the for loop.\n          return n == parent.getLastChild();\n\n        // Skip the conditions.\n        case Token.IF:\n        case Token.WHILE:\n        case Token.WITH:\n          return n != parent.getFirstChild();\n        case Token.DO:\n          return n != parent.getFirstChild().getNext();\n        // Only traverse the body of the cases\n        case Token.SWITCH:\n        case Token.CASE:\n        case Token.CATCH:\n        case Token.LABEL:\n          return n != parent.getFirstChild();\n        case Token.FUNCTION:\n          return n == parent.getFirstChild().getNext().getNext();\n        case Token.CONTINUE:\n        case Token.BREAK:\n        case Token.EXPR_RESULT:\n        case Token.VAR:\n        case Token.RETURN:\n        case Token.THROW:\n          return false;\n        case Token.TRY:\n          /* Just before we are about to visit the second child of the TRY node,\n           * we know that we will be visiting either the CATCH or the FINALLY.\n           * In other words, we know that the post order traversal of the TRY\n           * block has been finished, no more exceptions can be caught by the\n           * handler at this TRY block and should be taken out of the stack.\n           */\n          if (n == parent.getFirstChild().getNext()) {\n            Preconditions.checkState(exceptionHandler.peek() == parent);\n            exceptionHandler.pop();\n          }\n      }\n    }\n    return true;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "ControlFlowAnalysis.visit",
    "class_name": "com.google.javascript.jscomp.ControlFlowAnalysis",
    "signature": "com.google.javascript.jscomp.ControlFlowAnalysis.visit(NodeTraversal,Node,Node)",
    "snippet": "  @Override\n  public void visit(NodeTraversal t, Node n, Node parent) {\n    switch (n.getType()) {\n      case Token.IF:\n        handleIf(n);\n        return;\n      case Token.WHILE:\n        handleWhile(n);\n        return;\n      case Token.DO:\n        handleDo(n);\n        return;\n      case Token.FOR:\n        handleFor(n);\n        return;\n      case Token.SWITCH:\n        handleSwitch(n);\n        return;\n      case Token.CASE:\n        handleCase(n);\n        return;\n      case Token.DEFAULT:\n        handleDefault(n);\n        return;\n      case Token.BLOCK:\n      case Token.SCRIPT:\n        handleStmtList(n);\n        return;\n      case Token.FUNCTION:\n        handleFunction(n);\n        return;\n      case Token.EXPR_RESULT:\n        handleExpr(n);\n        return;\n      case Token.THROW:\n        handleThrow(n);\n        return;\n      case Token.TRY:\n        handleTry(n);\n        return;\n      case Token.CATCH:\n        handleCatch(n);\n        return;\n      case Token.BREAK:\n        handleBreak(n);\n        return;\n      case Token.CONTINUE:\n        handleContinue(n);\n        return;\n      case Token.RETURN:\n        handleReturn(n);\n        return;\n      case Token.WITH:\n        handleWith(n);\n        return;\n      case Token.LABEL:\n        return;\n      default:\n        handleStmt(n);\n        return;\n    }\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "ControlFlowGraph.ControlFlowGraph",
    "class_name": "com.google.javascript.jscomp.ControlFlowGraph",
    "signature": "com.google.javascript.jscomp.ControlFlowGraph.ControlFlowGraph(N)",
    "snippet": "  public ControlFlowGraph(N entry) {\n    implicitReturn = createDirectedGraphNode(null);\n    this.entry = createDirectedGraphNode(entry);\n  }",
    "comment": " Constructor. ",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "ControlFlowGraph.getEntry",
    "class_name": "com.google.javascript.jscomp.ControlFlowGraph",
    "signature": "com.google.javascript.jscomp.ControlFlowGraph.getEntry()",
    "snippet": "  public DiGraphNode<N, ControlFlowGraph.Branch> getEntry() {\n    return entry;\n  }",
    "comment": " Gets the entry point of the control flow graph. In general, this should be the beginning of the global script or beginning of a function.  @return The entry point. ",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "ControlFlowGraph.getImplicitReturn",
    "class_name": "com.google.javascript.jscomp.ControlFlowGraph",
    "signature": "com.google.javascript.jscomp.ControlFlowGraph.getImplicitReturn()",
    "snippet": "  public DiGraphNode<N, ControlFlowGraph.Branch> getImplicitReturn() {\n    return implicitReturn;\n  }",
    "comment": " Gets the implicit return node.  @return Return node. ",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "ControlFlowGraph.isEnteringNewCfgNode",
    "class_name": "com.google.javascript.jscomp.ControlFlowGraph",
    "signature": "com.google.javascript.jscomp.ControlFlowGraph.isEnteringNewCfgNode(Node)",
    "snippet": "  public static boolean isEnteringNewCfgNode(Node n) {\n    Node parent = n.getParent();\n    switch (parent.getType()) {\n      case Token.BLOCK:\n      case Token.SCRIPT:\n      case Token.TRY:\n      case Token.FINALLY:\n        return true;\n      case Token.FUNCTION:\n        // A function node represents the start of a function where the name\n        // is bleed into the local scope and parameters has been assigned\n        // to the formal argument names. The node includes the name of the\n        // function and the LP list since we assume the whole set up process\n        // is atomic without change in control flow. The next change of\n        // control is going into the function's body represent by the second\n        // child.\n        return n != parent.getFirstChild().getNext();\n      case Token.WHILE:\n      case Token.DO:\n      case Token.IF:\n        // Theses control structure is represented by its node that holds the\n        // condition. Each of them is a branch node based on its condition.\n        return NodeUtil.getConditionExpression(parent) != n;\n        \n      case Token.FOR:\n        // The FOR(;;) node differs from other control structure in that\n        // it has a initialization and a increment statement. Those\n        // two statements have its corresponding CFG nodes to represent them.\n        // The FOR node represents the condition check for each iteration.\n        // That way the following:\n        // for(var x = 0; x < 10; x++) { } has a graph that is isomorphic to\n        // var x = 0; while(x<10) {  x++; }\n        if (NodeUtil.isForIn(parent)) {\n          return n == parent.getLastChild(); \n        } else {\n          return NodeUtil.getConditionExpression(parent) != n;\n        }\n      case Token.SWITCH:\n      case Token.CASE:\n      case Token.CATCH:\n      case Token.WITH:\n        return n != parent.getFirstChild();\n      default:\n        return false;\n    }\n  }",
    "comment": " @return True if n should be represented by a new CFG node in the control flow graph. ",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "CreateSyntheticBlocks.CreateSyntheticBlocks",
    "class_name": "com.google.javascript.jscomp.CreateSyntheticBlocks",
    "signature": "com.google.javascript.jscomp.CreateSyntheticBlocks.CreateSyntheticBlocks(AbstractCompiler,String,String)",
    "snippet": "  public CreateSyntheticBlocks(AbstractCompiler compiler,\n      String startMarkerName, String endMarkerName) {\n    this.compiler = compiler;\n    this.startMarkerName = startMarkerName;\n    this.endMarkerName = endMarkerName;\n    startMarkerStack = new ArrayDeque<StartMarker>();\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "CreateSyntheticBlocks.process",
    "class_name": "com.google.javascript.jscomp.CreateSyntheticBlocks",
    "signature": "com.google.javascript.jscomp.CreateSyntheticBlocks.process(Node,Node)",
    "snippet": "  @Override\n  public void process(Node externs, Node root) {\n    NodeTraversal.traverse(compiler, root, new Callback());\n\n    for (StartMarker startMarker : startMarkerStack) {\n      compiler.report(JSError.make(startMarker.sourceName, startMarker.node,\n          UNMATCHED_START_MARKER, startMarkerName));\n    }\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "Callback.visit",
    "class_name": "com.google.javascript.jscomp.CreateSyntheticBlocks$Callback",
    "signature": "com.google.javascript.jscomp.CreateSyntheticBlocks$Callback.visit(NodeTraversal,Node,Node)",
    "snippet": "    @Override\n    public void visit(NodeTraversal t, Node n, Node parent) {\n      if (n.getType() != Token.NAME || parent.getType() != Token.CALL) {\n        return;\n      }\n\n      if (startMarkerName.equals(n.getString())) {\n        // Record information needed for insertion of a synthetic block or\n        // warning about an unmatched start marker.\n        Node ancestorBlockChild = n;\n        Node ancestorBlock = null;\n        for (Node ancestor : n.getAncestors()) {\n          int type = ancestor.getType();\n          if (type == Token.SCRIPT || type == Token.BLOCK) {\n            ancestorBlock = ancestor;\n            break;\n          }\n          ancestorBlockChild = ancestor;\n        }\n\n        startMarkerStack.push(new StartMarker(t.getSourceName(), n,\n            ancestorBlockChild, ancestorBlock));\n      }\n\n      if (!endMarkerName.equals(n.getString())) {\n        return;\n      }\n\n      if (startMarkerStack.isEmpty()) {\n        compiler.report(JSError.make(t, n, UNMATCHED_END_MARKER,\n            startMarkerName, endMarkerName));\n        return;\n      }\n\n      StartMarker startMarker = startMarkerStack.pop();\n\n      Node endMarkerAncestorBlockChild = n;\n      for (Node ancestor : n.getAncestors()) {\n        int type = ancestor.getType();\n        if (type == Token.SCRIPT || type == Token.BLOCK) {\n          if (ancestor != startMarker.ancestorBlock) {\n            // The end marker isn't in the same block as the start marker.\n            compiler.report(JSError.make(t, n, UNMATCHED_END_MARKER,\n                startMarkerName, endMarkerName));\n            return;\n          }\n          break;\n        }\n        endMarkerAncestorBlockChild = ancestor;\n      }\n\n      Node block = new Node(Token.BLOCK);\n      block.setIsSyntheticBlock(true);\n      startMarker.ancestorBlock.addChildAfter(block,\n          startMarker.ancestorBlockChild);\n      Node removedNode = null;\n      do {\n        // Move the nodes into the synthetic block.\n        removedNode = startMarker.ancestorBlock.removeChildAfter(block);\n        block.addChildToBack(removedNode);\n      } while (removedNode != endMarkerAncestorBlockChild);\n\n      compiler.reportCodeChange();\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "DataFlowAnalysis.DataFlowAnalysis",
    "class_name": "com.google.javascript.jscomp.DataFlowAnalysis",
    "signature": "com.google.javascript.jscomp.DataFlowAnalysis.DataFlowAnalysis(ControlFlowGraph,JoinOp)",
    "snippet": "  DataFlowAnalysis(ControlFlowGraph<N> targetCfg, JoinOp<L> joinOp) {\n    this.cfg = targetCfg;\n    this.joinOp = joinOp;\n    Comparator<DiGraphNode<N, Branch>> nodeComparator =\n      cfg.getOptionalNodeComparator(isForward());\n    if (nodeComparator != null) {\n      this.orderedWorkSet = Sets.newTreeSet(nodeComparator);\n    } else {\n      this.orderedWorkSet = Sets.newLinkedHashSet();\n    }\n  }",
    "comment": " Constructs a data flow analysis.  <p>Typical usage <pre> DataFlowAnalysis dfa = ... dfa.analyze(); </pre>  {@link #analyze()} annotates the result to the control flow graph by means of {@link DiGraphNode#setAnnotation} without any modification of the graph itself. Additional calls to {@link #analyze()} recomputes the analysis which can be useful if the control flow graph has been modified.  @param targetCfg The control flow graph object that this object performs on. Modification of the graph requires a separate call to {@link #analyze()}.  @see #analyze() ",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "DataFlowAnalysis.analyze",
    "class_name": "com.google.javascript.jscomp.DataFlowAnalysis",
    "signature": "com.google.javascript.jscomp.DataFlowAnalysis.analyze()",
    "snippet": "  final void analyze() {\n    analyze(MAX_STEPS);\n  }",
    "comment": " Finds a fixed-point solution using at most {@link #MAX_STEPS} iterations.  @see #analyze(int) ",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "DataFlowAnalysis.analyze",
    "class_name": "com.google.javascript.jscomp.DataFlowAnalysis",
    "signature": "com.google.javascript.jscomp.DataFlowAnalysis.analyze(int)",
    "snippet": "  final void analyze(int maxSteps) {\n    initialize();\n    int step = 0;\n    while (!orderedWorkSet.isEmpty()) {\n      if (step > maxSteps) {\n        throw new MaxIterationsExceededException(\n          \"Analysis did not terminate after \" + maxSteps + \" iterations\");\n      }\n      DiGraphNode<N, Branch> curNode = orderedWorkSet.iterator().next();\n      orderedWorkSet.remove(curNode);\n      joinInputs(curNode);\n      if (flow(curNode)) {\n        // If there is a change in the current node, we want to grab the list\n        // of nodes that this node affects.\n        List<DiGraphNode<N, Branch>> nextNodes = isForward() ?\n            cfg.getDirectedSuccNodes(curNode) :\n            cfg.getDirectedPredNodes(curNode);\n        for (DiGraphNode<N, Branch> nextNode : nextNodes) {\n          if (nextNode != cfg.getImplicitReturn()) {\n            orderedWorkSet.add(nextNode);\n          }\n        }\n      }\n      step++;\n    }\n    if (isForward()) {\n      joinInputs(getCfg().getImplicitReturn());\n    }\n  }",
    "comment": " Finds a fixed-point solution. The function has the side effect of replacing the existing node annotations with the computed solutions using {@link com.google.javascript.jscomp.graph.GraphNode#setAnnotation(Annotation)}.  <p>Initially, each node's input and output flow state contains the value given by {@link #createInitialEstimateLattice()} (with the exception of the entry node of the graph which takes on the {@link #createEntryLattice()} value. Each node will use the output state of its predecessor and compute a output state according to the instruction. At that time, any nodes that depends on the node's newly modified output value will need to recompute their output state again. Each step will perform a computation at one node until no extra computation will modify any existing output state anymore.  @param maxSteps Max number of iterations before the method stops and throw a {@link MaxIterationsExceededException}. This will prevent the analysis from going into a infinite loop. ",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "DataFlowAnalysis.getCfg",
    "class_name": "com.google.javascript.jscomp.DataFlowAnalysis",
    "signature": "com.google.javascript.jscomp.DataFlowAnalysis.getCfg()",
    "snippet": "  final ControlFlowGraph<N> getCfg() {\n    return cfg;\n  }",
    "comment": " Returns the control flow graph that this analysis was performed on. Modifications can be done on this graph, however, the only time that the annotations are correct is after {@link #analyze()} is called and before the graph has been modified. ",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "BinaryJoinOp.apply",
    "class_name": "com.google.javascript.jscomp.DataFlowAnalysis$BinaryJoinOp",
    "signature": "com.google.javascript.jscomp.DataFlowAnalysis$BinaryJoinOp.apply(L,L)",
    "snippet": "    abstract L apply(L latticeA, L latticeB);",
    "comment": " Creates a new lattice that will be the join of two input lattices.  @return The join of {@code latticeA} and {@code latticeB}. ",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "BinaryJoinOp.apply",
    "class_name": "com.google.javascript.jscomp.DataFlowAnalysis$BinaryJoinOp",
    "signature": "com.google.javascript.jscomp.DataFlowAnalysis$BinaryJoinOp.apply(List)",
    "snippet": "    @Override\n    public final L apply(List<L> values) {\n      Preconditions.checkArgument(!values.isEmpty());\n      int size = values.size();\n      if (size == 1) {\n        return values.get(0);\n      } else if (size == 2) {\n        return apply(values.get(0), values.get(1));\n      } else {\n        int mid = computeMidPoint(size);\n        return apply(\n            apply(values.subList(0, mid)),\n            apply(values.subList(mid, size)));\n      }\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "BranchedFlowState.setIn",
    "class_name": "com.google.javascript.jscomp.DataFlowAnalysis$BranchedFlowState",
    "signature": "com.google.javascript.jscomp.DataFlowAnalysis$BranchedFlowState.setIn(L)",
    "snippet": "    void setIn(L in) {\n      Preconditions.checkNotNull(in);\n      this.in = in;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "BranchedForwardDataFlowAnalysis.flow",
    "class_name": "com.google.javascript.jscomp.DataFlowAnalysis$BranchedForwardDataFlowAnalysis",
    "signature": "com.google.javascript.jscomp.DataFlowAnalysis$BranchedForwardDataFlowAnalysis.flow(DiGraphNode)",
    "snippet": "    @Override\n    protected final boolean flow(DiGraphNode<N, Branch> node) {\n      BranchedFlowState<L> state = node.getAnnotation();\n      List<L> outBefore = state.out;\n      state.out = branchedFlowThrough(node.getValue(), state.in);\n      Preconditions.checkState(outBefore.size() == state.out.size());\n      for (int i = 0; i < outBefore.size(); i++) {\n        if (!outBefore.get(i).equals(state.out.get(i))) {\n          return true;\n        }\n      }\n      return false;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "BranchedForwardDataFlowAnalysis.initialize",
    "class_name": "com.google.javascript.jscomp.DataFlowAnalysis$BranchedForwardDataFlowAnalysis",
    "signature": "com.google.javascript.jscomp.DataFlowAnalysis$BranchedForwardDataFlowAnalysis.initialize()",
    "snippet": "    @Override\n    protected void initialize() {\n      orderedWorkSet.clear();\n      for (DiGraphNode<N, Branch> node : getCfg().getDirectedGraphNodes()) {\n        List<DiGraphEdge<N, Branch>> edgeList =\n          getCfg().getOutEdges(node.getValue());\n        int outEdgeCount = edgeList.size();\n        List<L> outLattices = Lists.newArrayList();\n        for (int i = 0; i < outEdgeCount; i++) {\n          outLattices.add(createInitialEstimateLattice());\n        }\n        node.setAnnotation(new BranchedFlowState<L>(\n            createInitialEstimateLattice(), outLattices));\n        if (node != getCfg().getImplicitReturn()) {\n          orderedWorkSet.add(node);\n        }\n      }\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "BranchedForwardDataFlowAnalysis.isForward",
    "class_name": "com.google.javascript.jscomp.DataFlowAnalysis$BranchedForwardDataFlowAnalysis",
    "signature": "com.google.javascript.jscomp.DataFlowAnalysis$BranchedForwardDataFlowAnalysis.isForward()",
    "snippet": "    @Override\n    final boolean isForward() {\n      return true;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "BranchedForwardDataFlowAnalysis.joinInputs",
    "class_name": "com.google.javascript.jscomp.DataFlowAnalysis$BranchedForwardDataFlowAnalysis",
    "signature": "com.google.javascript.jscomp.DataFlowAnalysis$BranchedForwardDataFlowAnalysis.joinInputs(DiGraphNode)",
    "snippet": "    @Override\n    protected void joinInputs(DiGraphNode<N, Branch> node) {\n      BranchedFlowState<L> state = node.getAnnotation();\n      List<DiGraphNode<N, Branch>> predNodes =\n          getCfg().getDirectedPredNodes(node);\n      List<L> values = new ArrayList<L>(predNodes.size());\n\n      for (DiGraphNode<N, Branch> predNode : predNodes) {\n        BranchedFlowState<L> predNodeState = predNode.getAnnotation();\n\n        L in = predNodeState.out.get(\n            getCfg().getDirectedSuccNodes(predNode).indexOf(node));\n\n        values.add(in);\n      }\n      if (getCfg().getEntry() == node) {\n        state.setIn(createEntryLattice());\n      } else if (!values.isEmpty()) {\n        state.setIn(joinOp.apply(values));\n      }\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "DiagnosticGroup.DiagnosticGroup",
    "class_name": "com.google.javascript.jscomp.DiagnosticGroup",
    "signature": "com.google.javascript.jscomp.DiagnosticGroup.DiagnosticGroup(DiagnosticGroup[])",
    "snippet": "  public DiagnosticGroup(DiagnosticGroup ...groups) {\n    Set<DiagnosticType> set = Sets.newHashSet();\n\n    for (DiagnosticGroup group : groups) {\n      set.addAll(group.types);\n    }\n\n    this.types = ImmutableSet.copyOf(set);\n  }",
    "comment": " Create a composite group. ",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "DiagnosticGroup.DiagnosticGroup",
    "class_name": "com.google.javascript.jscomp.DiagnosticGroup",
    "signature": "com.google.javascript.jscomp.DiagnosticGroup.DiagnosticGroup(DiagnosticType[])",
    "snippet": "  public DiagnosticGroup(DiagnosticType ...types) {\n    this.types = ImmutableSet.copyOf(Arrays.asList(types));\n  }",
    "comment": " Create a group that matches all errors of the given types. ",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "DiagnosticGroup.matches",
    "class_name": "com.google.javascript.jscomp.DiagnosticGroup",
    "signature": "com.google.javascript.jscomp.DiagnosticGroup.matches(DiagnosticType)",
    "snippet": "  public boolean matches(DiagnosticType type) {\n    return types.contains(type);\n  }",
    "comment": " Returns whether the given type matches a type in this group. ",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "DiagnosticGroup.matches",
    "class_name": "com.google.javascript.jscomp.DiagnosticGroup",
    "signature": "com.google.javascript.jscomp.DiagnosticGroup.matches(JSError)",
    "snippet": "  public boolean matches(JSError error) {\n    return matches(error.getType());\n  }",
    "comment": " Returns whether the given error's type matches a type in this group. ",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "DiagnosticGroupWarningsGuard.DiagnosticGroupWarningsGuard",
    "class_name": "com.google.javascript.jscomp.DiagnosticGroupWarningsGuard",
    "signature": "com.google.javascript.jscomp.DiagnosticGroupWarningsGuard.DiagnosticGroupWarningsGuard(DiagnosticGroup,CheckLevel)",
    "snippet": "  public DiagnosticGroupWarningsGuard(\n      DiagnosticGroup group, CheckLevel level) {\n    this.group = group;\n    this.level = level;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "DiagnosticGroupWarningsGuard.level",
    "class_name": "com.google.javascript.jscomp.DiagnosticGroupWarningsGuard",
    "signature": "com.google.javascript.jscomp.DiagnosticGroupWarningsGuard.level(JSError)",
    "snippet": "  @Override\n  public CheckLevel level(JSError error) {\n    return group.matches(error) ? level : null;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "DiagnosticGroups.registerGroup",
    "class_name": "com.google.javascript.jscomp.DiagnosticGroups",
    "signature": "com.google.javascript.jscomp.DiagnosticGroups.registerGroup(String,DiagnosticGroup)",
    "snippet": "  static DiagnosticGroup registerGroup(String name,\n      DiagnosticGroup group) {\n    groupsByName.put(name, group);\n    return group;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "DiagnosticType.disabled",
    "class_name": "com.google.javascript.jscomp.DiagnosticType",
    "signature": "com.google.javascript.jscomp.DiagnosticType.disabled(String,String)",
    "snippet": "  public static DiagnosticType disabled(String name,\n      String descriptionFormat) {\n    return make(name, CheckLevel.OFF, descriptionFormat);\n  }",
    "comment": " Create a DiagnosticType at level CheckLevel.OFF  @param name An identifier @param descriptionFormat A format string @return A new DiagnosticType ",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "DiagnosticType.error",
    "class_name": "com.google.javascript.jscomp.DiagnosticType",
    "signature": "com.google.javascript.jscomp.DiagnosticType.error(String,String)",
    "snippet": "  public static DiagnosticType error(String name, String descriptionFormat) {\n    return make(name, CheckLevel.ERROR, descriptionFormat);\n  }",
    "comment": " Create a DiagnosticType at level CheckLevel.ERROR  @param name An identifier @param descriptionFormat A format string @return A new DiagnosticType ",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "DiagnosticType.make",
    "class_name": "com.google.javascript.jscomp.DiagnosticType",
    "signature": "com.google.javascript.jscomp.DiagnosticType.make(String,CheckLevel,String)",
    "snippet": "  public static DiagnosticType make(String name, CheckLevel level,\n                                    String descriptionFormat) {\n    return\n        new DiagnosticType(name, level, new MessageFormat(descriptionFormat));\n  }",
    "comment": " Create a DiagnosticType at a given CheckLevel.  @param name An identifier @param level Either CheckLevel.ERROR or CheckLevel.WARNING @param descriptionFormat A format string @return A new DiagnosticType ",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "DiagnosticType.warning",
    "class_name": "com.google.javascript.jscomp.DiagnosticType",
    "signature": "com.google.javascript.jscomp.DiagnosticType.warning(String,String)",
    "snippet": "  public static DiagnosticType warning(String name, String descriptionFormat) {\n    return make(name, CheckLevel.WARNING, descriptionFormat);\n  }",
    "comment": " Create a DiagnosticType at level CheckLevel.WARNING  @param name An identifier @param descriptionFormat A format string @return A new DiagnosticType ",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "DisambiguateProperties.forJSTypeSystem",
    "class_name": "com.google.javascript.jscomp.DisambiguateProperties",
    "signature": "com.google.javascript.jscomp.DisambiguateProperties.forJSTypeSystem(AbstractCompiler)",
    "snippet": "  static DisambiguateProperties<JSType> forJSTypeSystem(\n      AbstractCompiler compiler) {\n    return new DisambiguateProperties<JSType>(\n        compiler, new JSTypeSystem(compiler));\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "DisambiguateProperties.getProperty",
    "class_name": "com.google.javascript.jscomp.DisambiguateProperties",
    "signature": "com.google.javascript.jscomp.DisambiguateProperties.getProperty(String)",
    "snippet": "  protected Property getProperty(String name) {\n    if (!properties.containsKey(name)) {\n      properties.put(name, new Property(name));\n    }\n    return properties.get(name);\n  }",
    "comment": "Returns the property for the given name, creating it if necessary. */",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "DisambiguateProperties.process",
    "class_name": "com.google.javascript.jscomp.DisambiguateProperties",
    "signature": "com.google.javascript.jscomp.DisambiguateProperties.process(Node,Node)",
    "snippet": "  public void process(Node externs, Node root) {\n    for (TypeMismatch mis : compiler.getTypeValidator().getMismatches()) {\n      addInvalidatingType(mis.typeA);\n      addInvalidatingType(mis.typeB);\n    }\n\n    StaticScope<T> scope = typeSystem.getRootScope();\n    NodeTraversal.traverse(compiler, externs, new FindExternProperties());\n    NodeTraversal.traverse(compiler, root, new FindRenameableProperties());\n    renameProperties();\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "DisambiguateProperties.renameProperties",
    "class_name": "com.google.javascript.jscomp.DisambiguateProperties",
    "signature": "com.google.javascript.jscomp.DisambiguateProperties.renameProperties()",
    "snippet": "  void renameProperties() {\n    int propsRenamed = 0, propsSkipped = 0, instancesRenamed = 0,\n        instancesSkipped = 0, singleTypeProps = 0;\n\n    for (Property prop : properties.values()) {\n      if (prop.shouldRename()) {\n        Map<T, String> propNames = buildPropNames(prop.getTypes(), prop.name);\n\n        ++propsRenamed;\n        prop.expandTypesToSkip();\n        UnionFind<T> types = prop.getTypes();\n        for (Node node : prop.renameNodes) {\n          T rootType = prop.rootTypes.get(node);\n          if (prop.shouldRename(rootType)) {\n            String newName = propNames.get(rootType);\n            node.setString(newName);\n            compiler.reportCodeChange();\n            ++instancesRenamed;\n          } else {\n            ++instancesSkipped;\n          }\n        }\n      } else {\n        if (prop.skipRenaming) {\n          ++propsSkipped;\n        } else {\n          ++singleTypeProps;\n        }\n      }\n    }\n    logger.info(\"Renamed \" + instancesRenamed + \" instances of \"\n                + propsRenamed + \" properties.\");\n    logger.info(\"Skipped renaming \" + instancesSkipped + \" invalidated \"\n                + \"properties, \" + propsSkipped + \" instances of properties \"\n                + \"that were skipped for specific types and \" + singleTypeProps\n                + \" properties that were referenced from only one type.\");\n  }",
    "comment": "Renames all properties with references on more than one type. */",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "AbstractScopingCallback.enterScope",
    "class_name": "com.google.javascript.jscomp.DisambiguateProperties$AbstractScopingCallback",
    "signature": "com.google.javascript.jscomp.DisambiguateProperties$AbstractScopingCallback.enterScope(NodeTraversal)",
    "snippet": "    public void enterScope(NodeTraversal t) {\n      if (t.inGlobalScope()) {\n        scopes.push(typeSystem.getRootScope());\n      } else {\n        scopes.push(typeSystem.getFunctionScope(t.getScopeRoot()));\n      }\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "AbstractScopingCallback.exitScope",
    "class_name": "com.google.javascript.jscomp.DisambiguateProperties$AbstractScopingCallback",
    "signature": "com.google.javascript.jscomp.DisambiguateProperties$AbstractScopingCallback.exitScope(NodeTraversal)",
    "snippet": "    public void exitScope(NodeTraversal t) {\n      scopes.pop();\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "AbstractScopingCallback.getScope",
    "class_name": "com.google.javascript.jscomp.DisambiguateProperties$AbstractScopingCallback",
    "signature": "com.google.javascript.jscomp.DisambiguateProperties$AbstractScopingCallback.getScope()",
    "snippet": "    protected StaticScope<T> getScope() {\n      return scopes.peek();\n    }",
    "comment": "Returns the current scope at this point in the file. */",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "AbstractScopingCallback.shouldTraverse",
    "class_name": "com.google.javascript.jscomp.DisambiguateProperties$AbstractScopingCallback",
    "signature": "com.google.javascript.jscomp.DisambiguateProperties$AbstractScopingCallback.shouldTraverse(NodeTraversal,Node,Node)",
    "snippet": "    public boolean shouldTraverse(NodeTraversal t, Node n, Node parent) {\n      return true;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "FindExternProperties.visit",
    "class_name": "com.google.javascript.jscomp.DisambiguateProperties$FindExternProperties",
    "signature": "com.google.javascript.jscomp.DisambiguateProperties$FindExternProperties.visit(NodeTraversal,Node,Node)",
    "snippet": "    @Override public void visit(NodeTraversal t, Node n, Node parent) {\n      if (n.getType() == Token.GETPROP) {\n        String field = n.getLastChild().getString();\n        T type = typeSystem.getType(getScope(), n.getFirstChild(), field);\n        Property prop = getProperty(field);\n        if (typeSystem.isInvalidatingType(type)) {\n          prop.invalidate();\n        } else {\n          prop.addTypeToSkip(type);\n\n          // If this is a prototype property, then we want to skip assignments\n          // to the instance type as well.  These assignments are not usually\n          // seen in the extern code itself, so we must handle them here.\n          if ((type = typeSystem.getInstanceFromPrototype(type)) != null) {\n            prop.getTypes().add(type);\n            prop.typesToSkip.add(type);\n          }\n        }\n      }\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "FindRenameableProperties.handleGetProp",
    "class_name": "com.google.javascript.jscomp.DisambiguateProperties$FindRenameableProperties",
    "signature": "com.google.javascript.jscomp.DisambiguateProperties$FindRenameableProperties.handleGetProp(NodeTraversal,Node)",
    "snippet": "    private void handleGetProp(NodeTraversal t, Node n) {\n      String name = n.getLastChild().getString();\n      T type = typeSystem.getType(getScope(), n.getFirstChild(), name);\n\n      Property prop = getProperty(name);\n      if (!prop.scheduleRenaming(n.getLastChild(),\n                                 processProperty(t, prop, type, null))) {\n        if (showInvalidationWarnings) {\n          compiler.report(JSError.make(\n              t.getSourceName(), n, INVALIDATION, name,\n              (type == null ? \"null\" : type.toString()), n.toString()));\n        }\n      }\n    }",
    "comment": " Processes a GETPROP node. ",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "FindRenameableProperties.processProperty",
    "class_name": "com.google.javascript.jscomp.DisambiguateProperties$FindRenameableProperties",
    "signature": "com.google.javascript.jscomp.DisambiguateProperties$FindRenameableProperties.processProperty(NodeTraversal,Property,T,T)",
    "snippet": "    private T processProperty(\n        NodeTraversal t, Property prop, T type, T relatedType) {\n      type = typeSystem.restrictByNotNullOrUndefined(type);\n      if (prop.skipRenaming || typeSystem.isInvalidatingType(type)) {\n        return null;\n      }\n\n      Iterable<T> alternatives = typeSystem.getTypeAlternatives(type);\n      if (alternatives != null) {\n        T firstType = null;\n        for (T subType : alternatives) {\n          T lastType = processProperty(t, prop, subType, firstType);\n          if (lastType != null) {\n            firstType = firstType == null ? lastType : firstType;\n          }\n        }\n        return firstType;\n      } else {\n        T topType = typeSystem.getTypeWithProperty(prop.name, type);\n        if (typeSystem.isInvalidatingType(topType)) {\n          return null;\n        }\n        prop.addType(type, topType, relatedType);\n        return topType;\n      }\n    }",
    "comment": " Processes a property, adding it to the list of properties to rename. @return a representative type for the property reference, which will be the highest type on the prototype chain of the provided type.  In the case of a union type, it will be the highest type on the prototype chain of one of the members of the union. ",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "FindRenameableProperties.visit",
    "class_name": "com.google.javascript.jscomp.DisambiguateProperties$FindRenameableProperties",
    "signature": "com.google.javascript.jscomp.DisambiguateProperties$FindRenameableProperties.visit(NodeTraversal,Node,Node)",
    "snippet": "    @Override\n    public void visit(NodeTraversal t, Node n, Node parent) {\n      if (n.getType() == Token.GETPROP) {\n        handleGetProp(t, n);\n      } else if (n.getType() == Token.OBJECTLIT) {\n        handleObjectLit(t, n);\n      }\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "JSTypeSystem.getFunctionScope",
    "class_name": "com.google.javascript.jscomp.DisambiguateProperties$JSTypeSystem",
    "signature": "com.google.javascript.jscomp.DisambiguateProperties$JSTypeSystem.getFunctionScope(Node)",
    "snippet": "    @Override public StaticScope<JSType> getFunctionScope(Node node) {\n      return null;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "JSTypeSystem.getInstanceFromPrototype",
    "class_name": "com.google.javascript.jscomp.DisambiguateProperties$JSTypeSystem",
    "signature": "com.google.javascript.jscomp.DisambiguateProperties$JSTypeSystem.getInstanceFromPrototype(JSType)",
    "snippet": "    @Override public JSType getInstanceFromPrototype(JSType type) {\n      if (type.isFunctionPrototypeType()) {\n        FunctionPrototypeType prototype = (FunctionPrototypeType) type;\n        FunctionType owner = prototype.getOwnerFunction();\n        if (owner.isConstructor() || owner.isInterface()) {\n          return ((FunctionPrototypeType) type).getOwnerFunction()\n              .getInstanceType();\n        }\n      }\n      return null;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "JSTypeSystem.getRootScope",
    "class_name": "com.google.javascript.jscomp.DisambiguateProperties$JSTypeSystem",
    "signature": "com.google.javascript.jscomp.DisambiguateProperties$JSTypeSystem.getRootScope()",
    "snippet": "    @Override public StaticScope<JSType> getRootScope() { return null; }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "JSTypeSystem.getType",
    "class_name": "com.google.javascript.jscomp.DisambiguateProperties$JSTypeSystem",
    "signature": "com.google.javascript.jscomp.DisambiguateProperties$JSTypeSystem.getType(StaticScope,Node,String)",
    "snippet": "    @Override public JSType getType(\n        StaticScope<JSType> scope, Node node, String prop) {\n      if (node.getJSType() == null) {\n        return registry.getNativeType(JSTypeNative.UNKNOWN_TYPE);\n      }\n      return node.getJSType();\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "JSTypeSystem.getTypeAlternatives",
    "class_name": "com.google.javascript.jscomp.DisambiguateProperties$JSTypeSystem",
    "signature": "com.google.javascript.jscomp.DisambiguateProperties$JSTypeSystem.getTypeAlternatives(JSType)",
    "snippet": "    @Override public Iterable<JSType> getTypeAlternatives(JSType type) {\n      if (type.isUnionType()) {\n        return ((UnionType) type).getAlternates();\n      } else {\n        ObjectType objType = type.toObjectType();\n        if (objType != null &&\n            objType.getConstructor() != null &&\n            objType.getConstructor().isInterface()) {\n          List<JSType> list = Lists.newArrayList();\n          for (FunctionType impl\n                   : registry.getDirectImplementors(objType)) {\n            list.add(impl.getInstanceType());\n          }\n          return list;\n        } else {\n          return null;\n        }\n      }\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "JSTypeSystem.getTypeWithProperty",
    "class_name": "com.google.javascript.jscomp.DisambiguateProperties$JSTypeSystem",
    "signature": "com.google.javascript.jscomp.DisambiguateProperties$JSTypeSystem.getTypeWithProperty(String,JSType)",
    "snippet": "    @Override public ObjectType getTypeWithProperty(String field, JSType type) {\n      if (!(type instanceof ObjectType)) {\n        if (type.autoboxesTo() != null) {\n          type = type.autoboxesTo();\n        } else {\n          return null;\n        }\n      }\n\n      // Ignore the prototype itself at all times.\n      if (\"prototype\".equals(field)) {\n        return null;\n      }\n\n      // We look up the prototype chain to find the highest place (if any) that\n      // this appears.  This will make references to overriden properties look\n      // like references to the initial property, so they are renamed alike.\n      ObjectType foundType = null;\n      ObjectType objType = ObjectType.cast(type);\n      while (objType != null && objType.getImplicitPrototype() != objType) {\n        if (objType.hasOwnProperty(field)) {\n          foundType = objType;\n        }\n        objType = objType.getImplicitPrototype();\n      }\n      // If the property does not exist on the referenced type but the original\n      // type is an object type, see if any subtype has the property.\n        // getGreatestSubtypeWithProperty does not guarantee that the property\n        // is defined on the returned type, it just indicates that it might be,\n        // so we have to double check.\n      return foundType;\n    }",
    "comment": "",
    "is_bug": true,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "JSTypeSystem.getTypesToSkipForType",
    "class_name": "com.google.javascript.jscomp.DisambiguateProperties$JSTypeSystem",
    "signature": "com.google.javascript.jscomp.DisambiguateProperties$JSTypeSystem.getTypesToSkipForType(JSType)",
    "snippet": "    @Override public ImmutableSet<JSType> getTypesToSkipForType(JSType type) {\n      type = type.restrictByNotNullOrUndefined();\n      if (type instanceof UnionType) {\n        Set<JSType> types = Sets.newHashSet(type);\n        for (JSType alt : ((UnionType) type).getAlternates()) {\n          types.addAll(getTypesToSkipForTypeNonUnion(type));\n        }\n        return ImmutableSet.copyOf(types);\n      }\n      return ImmutableSet.copyOf(getTypesToSkipForTypeNonUnion(type));\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "JSTypeSystem.getTypesToSkipForTypeNonUnion",
    "class_name": "com.google.javascript.jscomp.DisambiguateProperties$JSTypeSystem",
    "signature": "com.google.javascript.jscomp.DisambiguateProperties$JSTypeSystem.getTypesToSkipForTypeNonUnion(JSType)",
    "snippet": "    private Set<JSType> getTypesToSkipForTypeNonUnion(JSType type) {\n      Set<JSType> types = Sets.newHashSet();\n      JSType skipType = type;\n      while (skipType != null) {\n        types.add(skipType);\n\n        ObjectType objSkipType = skipType.toObjectType();\n        if (objSkipType != null) {\n          skipType = objSkipType.getImplicitPrototype();\n        } else {\n          break;\n        }\n      }\n      return types;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "JSTypeSystem.isInvalidatingType",
    "class_name": "com.google.javascript.jscomp.DisambiguateProperties$JSTypeSystem",
    "signature": "com.google.javascript.jscomp.DisambiguateProperties$JSTypeSystem.isInvalidatingType(JSType)",
    "snippet": "    @Override public boolean isInvalidatingType(JSType type) {\n      if (type == null || invalidatingTypes.contains(type) ||\n          (type.isNamedType() && type.isUnknownType())) {\n        return true;\n      }\n\n      ObjectType objType = ObjectType.cast(type);\n      return objType != null && !objType.hasReferenceName();\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "JSTypeSystem.isTypeToSkip",
    "class_name": "com.google.javascript.jscomp.DisambiguateProperties$JSTypeSystem",
    "signature": "com.google.javascript.jscomp.DisambiguateProperties$JSTypeSystem.isTypeToSkip(JSType)",
    "snippet": "    @Override public boolean isTypeToSkip(JSType type) {\n      return type.isEnumType() || (type.autoboxesTo() != null);\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "JSTypeSystem.recordInterfaces",
    "class_name": "com.google.javascript.jscomp.DisambiguateProperties$JSTypeSystem",
    "signature": "com.google.javascript.jscomp.DisambiguateProperties$JSTypeSystem.recordInterfaces(JSType,JSType,Property)",
    "snippet": "    @Override\n    public void recordInterfaces(JSType type, JSType relatedType,\n                                 DisambiguateProperties<JSType>.Property p) {\n      ObjectType objType = ObjectType.cast(type);\n      if (objType != null) {\n        FunctionType constructor;\n        if (objType instanceof FunctionType) {\n          constructor = (FunctionType) objType;\n        } else if (objType instanceof FunctionPrototypeType) {\n          constructor = ((FunctionPrototypeType) objType).getOwnerFunction();\n        } else {\n          constructor = objType.getConstructor();\n        }\n        while (constructor != null) {\n          for (ObjectType itype : constructor.getImplementedInterfaces()) {\n            JSType top = getTypeWithProperty(p.name, itype);\n            if (top != null) {\n              p.addType(itype, top, relatedType);\n            } else {\n              recordInterfaces(itype, relatedType, p);\n            }\n\n            // If this interface invalidated this property, return now.\n            if (p.skipRenaming) return;\n          }\n          if (constructor.isInterface() || constructor.isConstructor()) {\n            constructor = constructor.getSuperClassConstructor();\n          } else {\n            constructor = null;\n          }\n        }\n      }\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "JSTypeSystem.restrictByNotNullOrUndefined",
    "class_name": "com.google.javascript.jscomp.DisambiguateProperties$JSTypeSystem",
    "signature": "com.google.javascript.jscomp.DisambiguateProperties$JSTypeSystem.restrictByNotNullOrUndefined(JSType)",
    "snippet": "    @Override public JSType restrictByNotNullOrUndefined(JSType type) {\n      return type.restrictByNotNullOrUndefined();\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "Property.addType",
    "class_name": "com.google.javascript.jscomp.DisambiguateProperties$Property",
    "signature": "com.google.javascript.jscomp.DisambiguateProperties$Property.addType(T,T,T)",
    "snippet": "    boolean addType(T type, T top, T relatedType) {\n      checkState(!skipRenaming, \"Attempt to record skipped property: %s\", name);\n      if (typeSystem.isInvalidatingType(top)) {\n        invalidate();\n        return false;\n      } else {\n        if (typeSystem.isTypeToSkip(top)) {\n          addTypeToSkip(top);\n        }\n\n        if (relatedType == null) {\n          getTypes().add(top);\n        } else {\n          getTypes().union(top, relatedType);\n        }\n        typeSystem.recordInterfaces(type, top, this);\n        return true;\n      }\n    }",
    "comment": " Record that this property is referenced from this type. @return true if the type was recorded for this property, else false, which would happen if the type was invalidating. ",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "Property.addTypeToSkip",
    "class_name": "com.google.javascript.jscomp.DisambiguateProperties$Property",
    "signature": "com.google.javascript.jscomp.DisambiguateProperties$Property.addTypeToSkip(T)",
    "snippet": "    void addTypeToSkip(T type) {\n      for (T skipType : typeSystem.getTypesToSkipForType(type)) {\n        typesToSkip.add(skipType);\n        getTypes().union(skipType, type);\n      }\n    }",
    "comment": "Records the given type as one to skip for this property. */",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "Property.getTypes",
    "class_name": "com.google.javascript.jscomp.DisambiguateProperties$Property",
    "signature": "com.google.javascript.jscomp.DisambiguateProperties$Property.getTypes()",
    "snippet": "    UnionFind<T> getTypes() {\n      if (types == null) {\n        types = new StandardUnionFind<T>();\n      }\n      return types;\n    }",
    "comment": "Returns the types on which this field is referenced. */",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "Property.invalidate",
    "class_name": "com.google.javascript.jscomp.DisambiguateProperties$Property",
    "signature": "com.google.javascript.jscomp.DisambiguateProperties$Property.invalidate()",
    "snippet": "    boolean invalidate() {\n      boolean changed = !skipRenaming;\n      skipRenaming = true;\n      types = null;\n      return changed;\n    }",
    "comment": " Invalidates a field from renaming.  Used for field references on an object with unknown type. ",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "Property.scheduleRenaming",
    "class_name": "com.google.javascript.jscomp.DisambiguateProperties$Property",
    "signature": "com.google.javascript.jscomp.DisambiguateProperties$Property.scheduleRenaming(Node,T)",
    "snippet": "    boolean scheduleRenaming(Node node, T type) {\n      if (!skipRenaming) {\n        if (typeSystem.isInvalidatingType(type)) {\n          invalidate();\n          return false;\n        }\n        renameNodes.add(node);\n        rootTypes.put(node, type);\n      }\n      return true;\n    }",
    "comment": " Schedule the node to potentially be renamed. @param node the node to rename @param type the highest type in the prototype chain for which the property is defined @return True if type was accepted without invalidation or if the property was already invalidated.  False if this property was invalidated this time. ",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "Property.shouldRename",
    "class_name": "com.google.javascript.jscomp.DisambiguateProperties$Property",
    "signature": "com.google.javascript.jscomp.DisambiguateProperties$Property.shouldRename()",
    "snippet": "    boolean shouldRename() {\n      return !skipRenaming && types != null\n          && types.allEquivalenceClasses().size() > 1;\n    }",
    "comment": "Returns true if any instance of this property should be renamed. */",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "FunctionTypeBuilder.FunctionTypeBuilder",
    "class_name": "com.google.javascript.jscomp.FunctionTypeBuilder",
    "signature": "com.google.javascript.jscomp.FunctionTypeBuilder.FunctionTypeBuilder(String,AbstractCompiler,Node,String,Scope)",
    "snippet": "  FunctionTypeBuilder(String fnName, AbstractCompiler compiler,\n      Node errorRoot, String sourceName, Scope scope) {\n    Preconditions.checkNotNull(errorRoot);\n\n    this.fnName = fnName == null ? \"\" : fnName;\n    this.codingConvention = compiler.getCodingConvention();\n    this.typeRegistry = compiler.getTypeRegistry();\n    this.errorRoot = errorRoot;\n    this.sourceName = sourceName;\n    this.compiler = compiler;\n    this.scope = scope;\n  }",
    "comment": " @param fnName The function name. @param compiler The compiler. @param errorRoot The node to associate with any warning generated by this builder. @param sourceName A source name for associating any warnings that we have to emit. @param scope The syntactic scope. ",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "FunctionTypeBuilder.addParameter",
    "class_name": "com.google.javascript.jscomp.FunctionTypeBuilder",
    "signature": "com.google.javascript.jscomp.FunctionTypeBuilder.addParameter(FunctionParamBuilder,JSType,boolean,boolean,boolean)",
    "snippet": "  private boolean addParameter(FunctionParamBuilder builder,\n      JSType paramType, boolean warnedAboutArgList,\n      boolean isOptional, boolean isVarArgs) {\n    boolean emittedWarning = false;\n    if (isOptional) {\n      // Remembering that an optional parameter has been encountered\n      // so that if a non optional param is encountered later, an\n      // error can be reported.\n      if (!builder.addOptionalParams(paramType) && !warnedAboutArgList) {\n        reportWarning(VAR_ARGS_MUST_BE_LAST);\n        emittedWarning = true;\n      }\n    } else if (isVarArgs) {\n      if (!builder.addVarArgs(paramType) && !warnedAboutArgList) {\n        reportWarning(VAR_ARGS_MUST_BE_LAST);\n        emittedWarning = true;\n      }\n    } else {\n      if (!builder.addRequiredParams(paramType) && !warnedAboutArgList) {\n        // An optional parameter was seen and this argument is not an optional\n        // or var arg so it is an error.\n        if (builder.hasVarArgs()) {\n          reportWarning(VAR_ARGS_MUST_BE_LAST);\n        } else {\n          reportWarning(OPTIONAL_ARG_AT_END);\n        }\n        emittedWarning = true;\n      }\n    }\n    return emittedWarning;\n  }",
    "comment": " Add a parameter to the param list. @param builder A builder. @param paramType The parameter type. @param warnedAboutArgList Whether we've already warned about arg ordering issues (like if optional args appeared before required ones). @param isOptional Is this an optional parameter? @param isVarArgs Is this a var args parameter? @return Whether a warning was emitted. ",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "FunctionTypeBuilder.buildAndRegister",
    "class_name": "com.google.javascript.jscomp.FunctionTypeBuilder",
    "signature": "com.google.javascript.jscomp.FunctionTypeBuilder.buildAndRegister()",
    "snippet": "  FunctionType buildAndRegister() {\n    if (returnType == null || parametersNode == null) {\n      throw new IllegalStateException(\n          \"All Function types must have params and a return type\");\n    }\n\n    FunctionType fnType;\n    if (isConstructor) {\n      fnType = getOrCreateConstructor();\n    } else if (isInterface) {\n      fnType = typeRegistry.createInterfaceType(fnName, sourceNode);\n      if (scope.isGlobal() && !fnName.isEmpty()) {\n        typeRegistry.declareType(fnName, fnType.getInstanceType());\n      }\n      maybeSetBaseType(fnType);\n    } else {\n      fnType = new FunctionType(typeRegistry, fnName, sourceNode,\n          parametersNode, returnType, thisType, templateTypeName);\n      maybeSetBaseType(fnType);\n    }\n\n    if (implementedInterfaces != null) {\n      fnType.setImplementedInterfaces(implementedInterfaces);\n    }\n\n    typeRegistry.clearTemplateTypeName();\n\n    return fnType;\n  }",
    "comment": " Builds the function type, and puts it in the registry. ",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "FunctionTypeBuilder.getOrCreateConstructor",
    "class_name": "com.google.javascript.jscomp.FunctionTypeBuilder",
    "signature": "com.google.javascript.jscomp.FunctionTypeBuilder.getOrCreateConstructor()",
    "snippet": "  private FunctionType getOrCreateConstructor() {\n    FunctionType fnType = typeRegistry.createConstructorType(\n        fnName, sourceNode, parametersNode, returnType);\n    JSType existingType = typeRegistry.getType(fnName);\n\n    if (existingType != null) {\n      boolean isInstanceObject = existingType instanceof InstanceObjectType;\n      if (isInstanceObject || fnName.equals(\"Function\")) {\n        FunctionType existingFn =\n            isInstanceObject ?\n            ((InstanceObjectType) existingType).getConstructor() :\n            typeRegistry.getNativeFunctionType(FUNCTION_FUNCTION_TYPE);\n\n        if (existingFn.getSource() == null) {\n          existingFn.setSource(sourceNode);\n        }\n\n        if (!existingFn.hasEqualCallType(fnType)) {\n          reportWarning(TYPE_REDEFINITION, fnName,\n              fnType.toString(), existingFn.toString());\n        }\n\n        return existingFn;\n      } else {\n        // We fall through and return the created type, even though it will fail\n        // to register. We have no choice as we have to return a function. We\n        // issue an error elsewhere though, so the user should fix it.\n      }\n    }\n\n    maybeSetBaseType(fnType);\n\n    if (scope.isGlobal() && !fnName.isEmpty()) {\n      typeRegistry.declareType(fnName, fnType.getInstanceType());\n    }\n    return fnType;\n  }",
    "comment": " Returns a constructor function either by returning it from the registry if it exists or creating and registering a new type. If there is already a type, then warn if the existing type is different than the one we are creating, though still return the existing function if possible.  The primary purpose of this is that registering a constructor will fail for all built-in types that are initialized in {@link JSTypeRegistry}.  We a) want to make sure that the type information specified in the externs file matches what is in the registry and b) annotate the externs with the {@link JSType} from the registry so that there are not two separate JSType objects for one type. ",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "FunctionTypeBuilder.inferInheritance",
    "class_name": "com.google.javascript.jscomp.FunctionTypeBuilder",
    "signature": "com.google.javascript.jscomp.FunctionTypeBuilder.inferInheritance(JSDocInfo)",
    "snippet": "  FunctionTypeBuilder inferInheritance(@Nullable JSDocInfo info) {\n    if (info != null) {\n      isConstructor = info.isConstructor();\n      isInterface = info.isInterface();\n\n      // base type\n      if (info.hasBaseType()) {\n        if (isConstructor || isInterface) {\n          baseType = ObjectType.cast(info.getBaseType().evaluate(scope));\n          if (baseType == null) {\n            reportWarning(EXTENDS_NON_OBJECT, fnName, baseType.toString());\n          }\n        } else {\n          reportWarning(EXTENDS_WITHOUT_TYPEDEF, fnName);\n        }\n      }\n\n      // implemented interfaces\n      if (isConstructor || isInterface) {\n        implementedInterfaces = Lists.newArrayList();\n        for (JSTypeExpression t : info.getImplementedInterfaces()) {\n          ObjectType interType = ObjectType.cast(t.evaluate(scope));\n          if (interType != null) {\n            implementedInterfaces.add(interType);\n          } else {\n            reportError(BAD_IMPLEMENTED_TYPE, fnName);\n          }\n        }\n        if (baseType != null) {\n          JSType maybeFunctionType = baseType.getConstructor();\n          if (maybeFunctionType instanceof FunctionType) {\n            FunctionType functionType = baseType.getConstructor();\n            Iterables.addAll(\n                implementedInterfaces,\n                functionType.getImplementedInterfaces());\n          }\n        }\n      } else if (info.getImplementedInterfaceCount() > 0) {\n        reportWarning(IMPLEMENTS_WITHOUT_CONSTRUCTOR, fnName);\n      }\n    }\n\n    return this;\n  }",
    "comment": " Infer the role of the function (whether it's a constructor or interface) and what it inherits from in JSDocInfo. ",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "FunctionTypeBuilder.inferParameterTypes",
    "class_name": "com.google.javascript.jscomp.FunctionTypeBuilder",
    "signature": "com.google.javascript.jscomp.FunctionTypeBuilder.inferParameterTypes(Node,JSDocInfo)",
    "snippet": "  FunctionTypeBuilder inferParameterTypes(@Nullable Node argsParent,\n      @Nullable JSDocInfo info) {\n    if (argsParent == null) {\n      if (info == null) {\n        return this;\n      } else {\n        return inferParameterTypes(info);\n      }\n    }\n\n    // arguments\n    FunctionParamBuilder builder = new FunctionParamBuilder(typeRegistry);\n    boolean warnedAboutArgList = false;\n    Set<String> allJsDocParams = (info == null) ?\n        Sets.<String>newHashSet() :\n        Sets.newHashSet(info.getParameterNames());\n    boolean foundTemplateType = false;\n    for (Node arg : argsParent.children()) {\n      String argumentName = arg.getString();\n      allJsDocParams.remove(argumentName);\n\n      // type from JSDocInfo\n      JSType parameterType =\n          info != null && info.hasParameterType(argumentName) ?\n          info.getParameterType(argumentName).evaluate(scope) :\n          typeRegistry.getNativeType(UNKNOWN_TYPE);\n      if (templateTypeName != null &&\n          parameterType.restrictByNotNullOrUndefined().isTemplateType()) {\n        if (foundTemplateType) {\n          reportError(TEMPLATE_TYPE_DUPLICATED, fnName);\n        }\n        foundTemplateType = true;\n      }\n      warnedAboutArgList |= addParameter(\n          builder, parameterType, warnedAboutArgList,\n          isOptionalParameter(arg, info),\n          isVarArgsParameter(arg, info));\n    }\n\n    if (templateTypeName != null && !foundTemplateType) {\n      reportError(TEMPLATE_TYPE_EXPECTED, fnName);\n    }\n\n    for (String inexistentName : allJsDocParams) {\n      reportWarning(INEXISTANT_PARAM, inexistentName, fnName);\n    }\n\n    parametersNode = builder.build();\n    return this;\n  }",
    "comment": " Infer the parameter types from the list of argument names and the doc info. ",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "FunctionTypeBuilder.inferReturnType",
    "class_name": "com.google.javascript.jscomp.FunctionTypeBuilder",
    "signature": "com.google.javascript.jscomp.FunctionTypeBuilder.inferReturnType(JSDocInfo)",
    "snippet": "  FunctionTypeBuilder inferReturnType(@Nullable JSDocInfo info) {\n    returnType = info != null && info.hasReturnType() ?\n        info.getReturnType().evaluate(scope) :\n        typeRegistry.getNativeType(UNKNOWN_TYPE);\n    if (templateTypeName != null &&\n        returnType.restrictByNotNullOrUndefined().isTemplateType()) {\n      reportError(TEMPLATE_TYPE_EXPECTED, fnName);\n    }\n    return this;\n  }",
    "comment": " Infer the return type from JSDocInfo. ",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "FunctionTypeBuilder.inferTemplateTypeName",
    "class_name": "com.google.javascript.jscomp.FunctionTypeBuilder",
    "signature": "com.google.javascript.jscomp.FunctionTypeBuilder.inferTemplateTypeName(JSDocInfo)",
    "snippet": "  FunctionTypeBuilder inferTemplateTypeName(@Nullable JSDocInfo info) {\n    if (info != null) {\n      templateTypeName = info.getTemplateTypeName();\n      typeRegistry.setTemplateTypeName(templateTypeName);\n    }\n    return this;\n  }",
    "comment": " Infer the template type from the doc info. ",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "FunctionTypeBuilder.inferThisType",
    "class_name": "com.google.javascript.jscomp.FunctionTypeBuilder",
    "signature": "com.google.javascript.jscomp.FunctionTypeBuilder.inferThisType(JSDocInfo,Node)",
    "snippet": "  FunctionTypeBuilder inferThisType(JSDocInfo info,\n      @Nullable Node owner) {\n    ObjectType maybeThisType = null;\n    if (info != null && info.hasThisType()) {\n      maybeThisType = ObjectType.cast(info.getThisType().evaluate(scope));\n    }\n    if (maybeThisType != null) {\n      // TODO(user): Doing an instanceof check here is too\n      // restrictive as (Date,Error) is, for instance, an object type\n      // even though its implementation is a UnionType. Would need to\n      // create interfaces JSType, ObjectType, FunctionType etc and have\n      // separate implementation instead of the class hierarchy, so that\n      // union types can also be object types, etc.\n      thisType = maybeThisType;\n    } else if (owner != null &&\n               (info == null || !info.hasType())) {\n      // If the function is of the form:\n      // x.prototype.y = function() {}\n      // then we can assume \"x\" is the @this type. On the other hand,\n      // if it's of the form:\n      // /** @type {Function} */ x.prototype.y;\n      // then we should not give it a @this type.\n      String ownerTypeName = owner.getQualifiedName();\n      ObjectType ownerType = ObjectType.cast(\n          typeRegistry.getType(\n              scope, ownerTypeName, sourceName,\n              owner.getLineno(), owner.getCharno()));\n      if (ownerType != null) {\n        thisType = ownerType;\n      }\n    }\n\n    return this;\n  }",
    "comment": " Infers the type of {@code this}. @param info The JSDocInfo for this function. @param owner The node for the object whose prototype \"owns\" this function. For example, {@code A} in the expression {@code A.prototype.foo}. May be null to indicate that this is not a prototype property. ",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "FunctionTypeBuilder.isFunctionTypeDeclaration",
    "class_name": "com.google.javascript.jscomp.FunctionTypeBuilder",
    "signature": "com.google.javascript.jscomp.FunctionTypeBuilder.isFunctionTypeDeclaration(JSDocInfo)",
    "snippet": "  static boolean isFunctionTypeDeclaration(JSDocInfo info) {\n    return info.getParameterCount() > 0 ||\n        info.hasReturnType() ||\n        info.hasThisType() ||\n        info.isConstructor() ||\n        info.isInterface();\n  }",
    "comment": " Determines whether the given jsdoc info declares a function type. ",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "FunctionTypeBuilder.isOptionalParameter",
    "class_name": "com.google.javascript.jscomp.FunctionTypeBuilder",
    "signature": "com.google.javascript.jscomp.FunctionTypeBuilder.isOptionalParameter(Node,JSDocInfo)",
    "snippet": "  private boolean isOptionalParameter(\n      Node param, @Nullable JSDocInfo info) {\n    if (codingConvention.isOptionalParameter(param)) {\n      return true;\n    }\n\n    String paramName = param.getString();\n    return info != null && info.hasParameterType(paramName) &&\n        info.getParameterType(paramName).isOptionalArg();\n  }",
    "comment": " @return Whether the given param is an optional param. ",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "FunctionTypeBuilder.isVarArgsParameter",
    "class_name": "com.google.javascript.jscomp.FunctionTypeBuilder",
    "signature": "com.google.javascript.jscomp.FunctionTypeBuilder.isVarArgsParameter(Node,JSDocInfo)",
    "snippet": "  private boolean isVarArgsParameter(\n      Node param, @Nullable JSDocInfo info) {\n    if (codingConvention.isVarArgsParameter(param)) {\n      return true;\n    }\n\n    String paramName = param.getString();\n    return info != null && info.hasParameterType(paramName) &&\n        info.getParameterType(paramName).isVarArgs();\n  }",
    "comment": " Determine whether this is a var args parameter. @return Whether the given param is a var args param. ",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "FunctionTypeBuilder.maybeSetBaseType",
    "class_name": "com.google.javascript.jscomp.FunctionTypeBuilder",
    "signature": "com.google.javascript.jscomp.FunctionTypeBuilder.maybeSetBaseType(FunctionType)",
    "snippet": "  private void maybeSetBaseType(FunctionType fnType) {\n    if (baseType != null) {\n      fnType.setPrototypeBasedOn(baseType);\n    }\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "FunctionTypeBuilder.setSourceNode",
    "class_name": "com.google.javascript.jscomp.FunctionTypeBuilder",
    "signature": "com.google.javascript.jscomp.FunctionTypeBuilder.setSourceNode(Node)",
    "snippet": "  FunctionTypeBuilder setSourceNode(@Nullable Node sourceNode) {\n    this.sourceNode = sourceNode;\n    return this;\n  }",
    "comment": " Sets the FUNCTION node of this function. ",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "GoogleCodingConvention.isConstant",
    "class_name": "com.google.javascript.jscomp.GoogleCodingConvention",
    "signature": "com.google.javascript.jscomp.GoogleCodingConvention.isConstant(String)",
    "snippet": "  @Override\n  public boolean isConstant(String name) {\n    if (name.length() <= 1) {\n      return false;\n    }\n\n    // In compiled code, '$' is often a namespace delimiter. To allow inlining\n    // of namespaced constants, we strip off any namespaces here.\n    int pos = name.lastIndexOf('$');\n    if (pos >= 0) {\n      name = name.substring(pos + 1);\n      if (name.length() == 0) {\n        return false;\n      }\n    }\n\n    if (!Character.isUpperCase(name.charAt(0))) {\n      return false;\n    }\n\n    // hack way of checking that there aren't any lower-case letters\n    return name.toUpperCase().equals(name);\n  }",
    "comment": " {@inheritDoc}  <p>This enforces the Google const name convention, that the first character after the last $ must be an upper-case letter and all subsequent letters must be upper case. The name must be at least 2 characters long.  <p>Examples: <pre> aaa          Not constant - lower-case letters in the name A            Not constant - too short goog$A       Constant - letters after the $ are upper-case. AA17         Constant - digits can appear after the first letter goog$7A      Not constant - first character after the $ must be upper case. $A           Constant - doesn't have to be anything in front of the $ </pre> ",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "InferJSDocInfo.InferJSDocInfo",
    "class_name": "com.google.javascript.jscomp.InferJSDocInfo",
    "signature": "com.google.javascript.jscomp.InferJSDocInfo.InferJSDocInfo(AbstractCompiler)",
    "snippet": "  InferJSDocInfo(AbstractCompiler compiler) {\n    this.compiler = compiler;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "InferJSDocInfo.attachJSDocInfoToNominalTypeOrShape",
    "class_name": "com.google.javascript.jscomp.InferJSDocInfo",
    "signature": "com.google.javascript.jscomp.InferJSDocInfo.attachJSDocInfoToNominalTypeOrShape(ObjectType,JSDocInfo,String)",
    "snippet": "  private void attachJSDocInfoToNominalTypeOrShape(\n      ObjectType objType, JSDocInfo docInfo, @Nullable String qName) {\n    if (objType.isConstructor() ||\n        objType.isEnumType() ||\n        objType.isInterface()) {\n      // Named types.\n      if (objType.hasReferenceName() &&\n          objType.getReferenceName().equals(qName)) {\n        objType.setJSDocInfo(docInfo);\n\n        if (objType.isConstructor() || objType.isInterface()) {\n          ((FunctionType) objType).getInstanceType().setJSDocInfo(\n              docInfo);\n        } else if (objType instanceof EnumType) {\n          ((EnumType) objType).getElementsType().setJSDocInfo(docInfo);\n        }\n      }\n    } else if (!objType.isNativeObjectType() &&\n        objType.isFunctionType()) {\n      // Structural functions.\n      objType.setJSDocInfo(docInfo);\n    }\n  }",
    "comment": " Handle cases #1 and #3 in the class doc. ",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "InferJSDocInfo.dereferenceToObject",
    "class_name": "com.google.javascript.jscomp.InferJSDocInfo",
    "signature": "com.google.javascript.jscomp.InferJSDocInfo.dereferenceToObject(JSType)",
    "snippet": "  private ObjectType dereferenceToObject(JSType type) {\n    return ObjectType.cast(type == null ? null : type.dereference());\n  }",
    "comment": " Dereferences the given type to an object, or returns null. ",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "InferJSDocInfo.process",
    "class_name": "com.google.javascript.jscomp.InferJSDocInfo",
    "signature": "com.google.javascript.jscomp.InferJSDocInfo.process(Node,Node)",
    "snippet": "  public void process(Node externs, Node root) {\n    if (externs != null) {\n      inExterns = true;\n      NodeTraversal.traverse(compiler, externs, this);\n    }\n    if (root != null) {\n      inExterns = false;\n      NodeTraversal.traverse(compiler, root, this);\n    }\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "InferJSDocInfo.visit",
    "class_name": "com.google.javascript.jscomp.InferJSDocInfo",
    "signature": "com.google.javascript.jscomp.InferJSDocInfo.visit(NodeTraversal,Node,Node)",
    "snippet": "  public void visit(NodeTraversal t, Node n, Node parent) {\n    JSDocInfo docInfo;\n\n    switch (n.getType()) {\n      // Infer JSDocInfo on types of all type declarations on variables.\n      case Token.NAME:\n        if (parent == null) {\n          return;\n        }\n\n        // Only allow JSDoc on VARs, function declarations, and assigns.\n        if (parent.getType() != Token.VAR &&\n            !NodeUtil.isFunctionDeclaration(parent) &&\n            !(parent.getType() == Token.ASSIGN &&\n              n == parent.getFirstChild())) {\n          return;\n        }\n\n        // There are four places the doc info could live.\n        // 1) A FUNCTION node.\n        // /** ... */ function f() { ... }\n        // 2) An ASSIGN parent.\n        // /** ... */ x = function () { ... }\n        // 3) A NAME parent.\n        // var x, /** ... */ y = function() { ... }\n        // 4) A VAR gramps.\n        // /** ... */ var x = function() { ... }\n        docInfo = n.getJSDocInfo();\n        if (docInfo == null &&\n            !(parent.getType() == Token.VAR &&\n                !parent.hasOneChild())) {\n          docInfo = parent.getJSDocInfo();\n        }\n\n        // Try to find the type of the NAME.\n        JSType varType = n.getJSType();\n        if (varType == null && parent.getType() == Token.FUNCTION) {\n          varType = parent.getJSType();\n        }\n\n        // If we have no type to attach JSDocInfo to, then there's nothing\n        // we can do.\n        if (varType == null || docInfo == null) {\n          return;\n        }\n\n        // Dereference the type. If the result is not an object, or already\n        // has docs attached, then do nothing.\n        ObjectType objType = dereferenceToObject(varType);\n        if (objType == null || objType.getJSDocInfo() != null) {\n          return;\n        }\n\n        attachJSDocInfoToNominalTypeOrShape(objType, docInfo, n.getString());\n        break;\n\n      case Token.GETPROP:\n        // Infer JSDocInfo on properties.\n        // There are two ways to write doc comments on a property.\n        //\n        // 1)\n        // /** @deprecated */\n        // obj.prop = ...\n        //\n        // 2)\n        // /** @deprecated */\n        // obj.prop;\n        if (NodeUtil.isExpressionNode(parent) ||\n            (parent.getType() == Token.ASSIGN &&\n             parent.getFirstChild() == n)) {\n          docInfo = n.getJSDocInfo();\n          if (docInfo == null) {\n            docInfo = parent.getJSDocInfo();\n          }\n          if (docInfo != null) {\n            ObjectType lhsType =\n                dereferenceToObject(n.getFirstChild().getJSType());\n            if (lhsType != null) {\n              // Put the JSDoc in the property slot, if there is one.\n              String propName = n.getLastChild().getString();\n              if (lhsType.hasOwnProperty(propName)) {\n                lhsType.setPropertyJSDocInfo(propName, docInfo, inExterns);\n              }\n\n              // Put the JSDoc in any constructors or function shapes as well.\n              ObjectType propType =\n                  dereferenceToObject(lhsType.getPropertyType(propName));\n              if (propType != null) {\n                attachJSDocInfoToNominalTypeOrShape(\n                    propType, docInfo, n.getQualifiedName());\n              }\n            }\n          }\n        }\n        break;\n    }\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "JSError.getCharno",
    "class_name": "com.google.javascript.jscomp.JSError",
    "signature": "com.google.javascript.jscomp.JSError.getCharno()",
    "snippet": "  public int getCharno() {\n    return charno;\n  }",
    "comment": " Get the character number. ",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "JSError.getType",
    "class_name": "com.google.javascript.jscomp.JSError",
    "signature": "com.google.javascript.jscomp.JSError.getType()",
    "snippet": "  public DiagnosticType getType() {\n    return type;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "JSError.make",
    "class_name": "com.google.javascript.jscomp.JSError",
    "signature": "com.google.javascript.jscomp.JSError.make(NodeTraversal,Node,CheckLevel,DiagnosticType,String[])",
    "snippet": "  public static JSError make(NodeTraversal t, Node n,\n      CheckLevel level, DiagnosticType type, String... arguments) {\n    return new JSError(t.getSourceName(), n.getLineno(), n.getCharno(), type,\n        level, arguments);\n  }",
    "comment": " Creates a JSError during NodeTraversal.  @param t Determines source file name containing current script @param n Determines the line and char position within the source file name @param type The DiagnosticType @param arguments Arguments to be incorporated into the message ",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "JSError.toString",
    "class_name": "com.google.javascript.jscomp.JSError",
    "signature": "com.google.javascript.jscomp.JSError.toString()",
    "snippet": "  @Override\n  public String toString() {\n    // TODO(user): remove custom toString.\n    return type.key + \". \" + description + \" at \" +\n      (sourceName != null && sourceName.length() > 0 ?\n       sourceName : \"(unknown source)\") + \" line \" +\n      (lineNumber != -1 ? String.valueOf(lineNumber) : \"(unknown line)\");\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "JSSourceFile.fromCode",
    "class_name": "com.google.javascript.jscomp.JSSourceFile",
    "signature": "com.google.javascript.jscomp.JSSourceFile.fromCode(String,String)",
    "snippet": "  public static JSSourceFile fromCode(String fileName, String code) {\n    return new JSSourceFile(SourceFile.fromCode(fileName, code));\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "JSSourceFile.getCode",
    "class_name": "com.google.javascript.jscomp.JSSourceFile",
    "signature": "com.google.javascript.jscomp.JSSourceFile.getCode()",
    "snippet": "  @Override\n  public String getCode() throws IOException {\n    return referenced.getCode();\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "JsAst.JsAst",
    "class_name": "com.google.javascript.jscomp.JsAst",
    "signature": "com.google.javascript.jscomp.JsAst.JsAst(SourceFile)",
    "snippet": "  public JsAst(SourceFile sourceFile) {\n    this.sourceFile = sourceFile;\n    this.fileName = sourceFile.getName();\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "JsAst.createAst",
    "class_name": "com.google.javascript.jscomp.JsAst",
    "signature": "com.google.javascript.jscomp.JsAst.createAst(AbstractCompiler)",
    "snippet": "  private void createAst(AbstractCompiler compiler) {\n    try {\n      parse(compiler, sourceFile.getName(), sourceFile.getCode());\n    } catch (IOException e) {\n      compiler.report(\n          JSError.make(AbstractCompiler.READ_ERROR, sourceFile.getName()));\n    }\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "JsAst.getAstRoot",
    "class_name": "com.google.javascript.jscomp.JsAst",
    "signature": "com.google.javascript.jscomp.JsAst.getAstRoot(AbstractCompiler)",
    "snippet": "  @Override\n  public Node getAstRoot(AbstractCompiler compiler) {\n    if (root == null) {\n      createAst(compiler);\n    }\n    return root;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "JsAst.parse",
    "class_name": "com.google.javascript.jscomp.JsAst",
    "signature": "com.google.javascript.jscomp.JsAst.parse(AbstractCompiler,String,String)",
    "snippet": "  private void parse(AbstractCompiler compiler, String sourceName,\n      String sourceStr) {\n    try {\n      logger_.fine(\"Parsing: \" + sourceName);\n      root = ParserRunner.parse(sourceName, sourceStr,\n          compiler.getParserConfig(),\n          compiler.getDefaultErrorReporter(),\n          logger_);\n    } catch (IOException e) {\n      compiler.report(JSError.make(AbstractCompiler.READ_ERROR, sourceName));\n    }\n\n    if (root == null || compiler.hasHaltingErrors()) {\n      // There was a parse error or IOException, so use a dummy block.\n      root = new Node(Token.BLOCK);\n    } else {\n      compiler.normalizeNodeTypes(root);\n      compiler.annotateCodingConvention(root);\n    }\n\n    // Set the source name so that the compiler passes can track\n    // the source file and module.\n    root.putProp(Node.SOURCENAME_PROP, sourceName);\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "LightweightMessageFormatter.LightweightMessageFormatter",
    "class_name": "com.google.javascript.jscomp.LightweightMessageFormatter",
    "signature": "com.google.javascript.jscomp.LightweightMessageFormatter.LightweightMessageFormatter(SourceExcerptProvider)",
    "snippet": "  public LightweightMessageFormatter(SourceExcerptProvider source) {\n    this(source, LINE);\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "LightweightMessageFormatter.LightweightMessageFormatter",
    "class_name": "com.google.javascript.jscomp.LightweightMessageFormatter",
    "signature": "com.google.javascript.jscomp.LightweightMessageFormatter.LightweightMessageFormatter(SourceExcerptProvider,SourceExcerpt)",
    "snippet": "  public LightweightMessageFormatter(SourceExcerptProvider source,\n      SourceExcerpt excerpt) {\n    super(source);\n    this.excerpt = excerpt;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "LinkedFlowScope.LinkedFlowScope",
    "class_name": "com.google.javascript.jscomp.LinkedFlowScope",
    "signature": "com.google.javascript.jscomp.LinkedFlowScope.LinkedFlowScope(FlatFlowScopeCache)",
    "snippet": "  LinkedFlowScope(FlatFlowScopeCache cache) {\n    this(cache, null);\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "LinkedFlowScope.LinkedFlowScope",
    "class_name": "com.google.javascript.jscomp.LinkedFlowScope",
    "signature": "com.google.javascript.jscomp.LinkedFlowScope.LinkedFlowScope(LinkedFlowScope)",
    "snippet": "  LinkedFlowScope(LinkedFlowScope directParent) {\n    this(directParent.cache, directParent);\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "LinkedFlowScope.createChildFlowScope",
    "class_name": "com.google.javascript.jscomp.LinkedFlowScope",
    "signature": "com.google.javascript.jscomp.LinkedFlowScope.createChildFlowScope()",
    "snippet": "  @Override\n  public FlowScope createChildFlowScope() {\n    frozen = true;\n\n    if (depth > MAX_DEPTH) {\n      if (flattened == null) {\n        flattened = new FlatFlowScopeCache(this);\n      }\n      return new LinkedFlowScope(flattened);\n    }\n\n    return new LinkedFlowScope(this);\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "LinkedFlowScope.createEntryLattice",
    "class_name": "com.google.javascript.jscomp.LinkedFlowScope",
    "signature": "com.google.javascript.jscomp.LinkedFlowScope.createEntryLattice(Scope)",
    "snippet": "  public static LinkedFlowScope createEntryLattice(Scope scope) {\n    return new LinkedFlowScope(new FlatFlowScopeCache(scope));\n  }",
    "comment": " Creates an entry lattice for the flow. ",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "LinkedFlowScope.equals",
    "class_name": "com.google.javascript.jscomp.LinkedFlowScope",
    "signature": "com.google.javascript.jscomp.LinkedFlowScope.equals(Object)",
    "snippet": "  @Override\n  public boolean equals(Object other) {\n    if (other instanceof LinkedFlowScope) {\n      LinkedFlowScope that = (LinkedFlowScope) other;\n      if (this.optimize() == that.optimize()) {\n        return true;\n      }\n\n      // If two flow scopes are in the same function, then they could have\n      // two possible function scopes: the real one and the BOTTOM scope.\n      // If they have different function scopes, we *should* iterate thru all\n      // the variables in each scope and compare. However, 99.9% of the time,\n      // they're not equal. And the other .1% of the time, we can pretend\n      // they're equal--this just means that data flow analysis will have\n      // to propagate the entry lattice a little bit further than it\n      // really needs to. Everything will still come out ok.\n      if (this.getFunctionScope() != that.getFunctionScope()) {\n        return false;\n      }\n\n      if (cache == that.cache) {\n        // If the two flow scopes have the same cache, then we can check\n        // equality a lot faster: by just looking at the \"dirty\" elements\n        // in the cache, and comparing them in both scopes.\n        for (String name : cache.dirtySymbols) {\n          if (diffSlots(getSlot(name), that.getSlot(name))) {\n            return false;\n          }\n        }\n\n        return true;\n      }\n\n      Map<String, StaticSlot<JSType>> myFlowSlots = allFlowSlots();\n      Map<String, StaticSlot<JSType>> otherFlowSlots = that.allFlowSlots();\n\n      for (StaticSlot<JSType> slot : myFlowSlots.values()) {\n        if (diffSlots(slot, otherFlowSlots.get(slot.getName()))) {\n          return false;\n        }\n        otherFlowSlots.remove(slot.getName());\n      }\n      for (StaticSlot<JSType> slot : otherFlowSlots.values()) {\n        if (diffSlots(slot, myFlowSlots.get(slot.getName()))) {\n          return false;\n        }\n      }\n      return true;\n    }\n    return false;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "LinkedFlowScope.getFunctionScope",
    "class_name": "com.google.javascript.jscomp.LinkedFlowScope",
    "signature": "com.google.javascript.jscomp.LinkedFlowScope.getFunctionScope()",
    "snippet": "  private Scope getFunctionScope() {\n    return cache.functionScope;\n  }",
    "comment": "Gets the function scope for this flow scope. */",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "LinkedFlowScope.getSlot",
    "class_name": "com.google.javascript.jscomp.LinkedFlowScope",
    "signature": "com.google.javascript.jscomp.LinkedFlowScope.getSlot(String)",
    "snippet": "  public StaticSlot<JSType> getSlot(String name) {\n    if (cache.dirtySymbols.contains(name)) {\n      for (LinkedFlowSlot slot = lastSlot;\n           slot != null; slot = slot.parent) {\n        if (slot.getName().equals(name)) {\n          return slot;\n        }\n      }\n    }\n    return cache.getSlot(name);\n  }",
    "comment": " Get the slot for the given symbol. ",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "LinkedFlowScope.inferSlotType",
    "class_name": "com.google.javascript.jscomp.LinkedFlowScope",
    "signature": "com.google.javascript.jscomp.LinkedFlowScope.inferSlotType(String,JSType)",
    "snippet": "  @Override\n  public void inferSlotType(String symbol, JSType type) {\n    Preconditions.checkState(!frozen);\n    lastSlot = new LinkedFlowSlot(symbol, type, lastSlot);\n    depth++;\n    cache.dirtySymbols.add(symbol);\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "LinkedFlowScope.optimize",
    "class_name": "com.google.javascript.jscomp.LinkedFlowScope",
    "signature": "com.google.javascript.jscomp.LinkedFlowScope.optimize()",
    "snippet": "  @Override\n  public LinkedFlowScope optimize() {\n    LinkedFlowScope current;\n    for (current = this;\n         current.parent != null &&\n             current.lastSlot == current.parent.lastSlot;\n         current = current.parent) {}\n    return current;\n  }",
    "comment": "a findUniqueRefinedSlot on it.",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "FlatFlowScopeCache.getSlot",
    "class_name": "com.google.javascript.jscomp.LinkedFlowScope$FlatFlowScopeCache",
    "signature": "com.google.javascript.jscomp.LinkedFlowScope$FlatFlowScopeCache.getSlot(String)",
    "snippet": "    public StaticSlot<JSType> getSlot(String name) {\n      if (symbols.containsKey(name)) {\n        return symbols.get(name);\n      } else {\n        return functionScope.getSlot(name);\n      }\n    }",
    "comment": " Get the slot for the given symbol. ",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "FlowScopeJoinOp.apply",
    "class_name": "com.google.javascript.jscomp.LinkedFlowScope$FlowScopeJoinOp",
    "signature": "com.google.javascript.jscomp.LinkedFlowScope$FlowScopeJoinOp.apply(FlowScope,FlowScope)",
    "snippet": "    @SuppressWarnings(\"unchecked\")\n    @Override\n    public FlowScope apply(FlowScope a, FlowScope b) {\n      // To join the two scopes, we have to\n      LinkedFlowScope linkedA = (LinkedFlowScope) a;\n      LinkedFlowScope linkedB = (LinkedFlowScope) b;\n      linkedA.frozen = true;\n      linkedB.frozen = true;\n      if (linkedA.optimize() == linkedB.optimize()) {\n        return linkedA.createChildFlowScope();\n      }\n      return new LinkedFlowScope(new FlatFlowScopeCache(linkedA, linkedB));\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "LoggerErrorManager.LoggerErrorManager",
    "class_name": "com.google.javascript.jscomp.LoggerErrorManager",
    "signature": "com.google.javascript.jscomp.LoggerErrorManager.LoggerErrorManager(MessageFormatter,Logger)",
    "snippet": "  public LoggerErrorManager(MessageFormatter formatter, Logger logger) {\n    this.formatter = formatter;\n    this.logger = logger;\n  }",
    "comment": " Creates an instance. ",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "MemoizedScopeCreator.MemoizedScopeCreator",
    "class_name": "com.google.javascript.jscomp.MemoizedScopeCreator",
    "signature": "com.google.javascript.jscomp.MemoizedScopeCreator.MemoizedScopeCreator(ScopeCreator)",
    "snippet": "  MemoizedScopeCreator(ScopeCreator delegate) {\n    this.delegate = delegate;\n  }",
    "comment": " @param delegate The real source of Scope objects. ",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "MemoizedScopeCreator.createScope",
    "class_name": "com.google.javascript.jscomp.MemoizedScopeCreator",
    "signature": "com.google.javascript.jscomp.MemoizedScopeCreator.createScope(Node,Scope)",
    "snippet": "  @Override\n  public Scope createScope(Node n, Scope parent) {\n    Scope scope = scopes.get(n);\n    if (scope == null) {\n      scope = delegate.createScope(n, parent);\n      scopes.put(n, scope);\n    } else {\n      Preconditions.checkState(parent == scope.getParent());\n    }\n    return scope;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "NodeTraversal.NodeTraversal",
    "class_name": "com.google.javascript.jscomp.NodeTraversal",
    "signature": "com.google.javascript.jscomp.NodeTraversal.NodeTraversal(AbstractCompiler,Callback)",
    "snippet": "  public NodeTraversal(AbstractCompiler compiler, Callback cb) {\n    this(compiler, cb, new SyntacticScopeCreator(compiler));\n  }",
    "comment": " Creates a node traversal using the specified callback interface. ",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "NodeTraversal.NodeTraversal",
    "class_name": "com.google.javascript.jscomp.NodeTraversal",
    "signature": "com.google.javascript.jscomp.NodeTraversal.NodeTraversal(AbstractCompiler,Callback,ScopeCreator)",
    "snippet": "  public NodeTraversal(AbstractCompiler compiler, Callback cb,\n      ScopeCreator scopeCreator) {\n    this.callback = cb;\n    if (cb instanceof ScopedCallback) {\n      this.scopeCallback = (ScopedCallback) cb;\n    }\n    this.compiler = compiler;\n    this.sourceName = \"\";\n    this.scopeCreator = scopeCreator;\n  }",
    "comment": " Creates a node traversal using the specified callback interface and the scope creator. ",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "NodeTraversal.getControlFlowGraph",
    "class_name": "com.google.javascript.jscomp.NodeTraversal",
    "signature": "com.google.javascript.jscomp.NodeTraversal.getControlFlowGraph()",
    "snippet": "  public ControlFlowGraph<Node> getControlFlowGraph() {\n    if (cfgs.peek() == null) {\n      ControlFlowAnalysis cfa = new ControlFlowAnalysis(compiler, false);\n      cfa.process(null, getScopeRoot());\n      cfgs.pop();\n      cfgs.push(cfa.getCfg());\n    }\n    return cfgs.peek();\n  }",
    "comment": "Gets the control flow graph for the current JS scope. */",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "NodeTraversal.getScopeRoot",
    "class_name": "com.google.javascript.jscomp.NodeTraversal",
    "signature": "com.google.javascript.jscomp.NodeTraversal.getScopeRoot()",
    "snippet": "  public Node getScopeRoot() {\n    if (scopeRoots.isEmpty()) {\n      return scopes.peek().getRootNode();\n    } else {\n      return scopeRoots.peek();\n    }\n  }",
    "comment": "Returns the current scope's root. */",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "NodeTraversal.getSourceName",
    "class_name": "com.google.javascript.jscomp.NodeTraversal",
    "signature": "com.google.javascript.jscomp.NodeTraversal.getSourceName()",
    "snippet": "  public String getSourceName() {\n    return sourceName;\n  }",
    "comment": " Gets the current input source name.  @return A string that may be empty, but not null ",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "NodeTraversal.getSourceName",
    "class_name": "com.google.javascript.jscomp.NodeTraversal",
    "signature": "com.google.javascript.jscomp.NodeTraversal.getSourceName(Node)",
    "snippet": "  private static String getSourceName(Node n) {\n    String name = (String) n.getProp(Node.SOURCENAME_PROP);\n    return name == null ? \"\" : name;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "NodeTraversal.popScope",
    "class_name": "com.google.javascript.jscomp.NodeTraversal",
    "signature": "com.google.javascript.jscomp.NodeTraversal.popScope()",
    "snippet": "  private void popScope() {\n    if (scopeCallback != null) {\n      scopeCallback.exitScope(this);\n    }\n    if (scopeRoots.isEmpty()) {\n      scopes.pop();\n    } else {\n      scopeRoots.pop();\n    }\n    cfgs.pop();\n  }",
    "comment": "Pops back to the previous scope (e.g. when leaving a function). */",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "NodeTraversal.pushScope",
    "class_name": "com.google.javascript.jscomp.NodeTraversal",
    "signature": "com.google.javascript.jscomp.NodeTraversal.pushScope(Node)",
    "snippet": "  private void pushScope(Node node) {\n    Preconditions.checkState(curNode != null);\n    scopeRoots.push(node);\n    cfgs.push(null);\n    if (scopeCallback != null) {\n      scopeCallback.enterScope(this);\n    }\n  }",
    "comment": "Creates a new scope (e.g. when entering a function). */",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "NodeTraversal.traverse",
    "class_name": "com.google.javascript.jscomp.NodeTraversal",
    "signature": "com.google.javascript.jscomp.NodeTraversal.traverse(AbstractCompiler,Node,Callback)",
    "snippet": "  public static void traverse(\n      AbstractCompiler compiler, Node root, Callback cb) {\n    NodeTraversal t = new NodeTraversal(compiler, cb);\n    t.traverse(root);\n  }",
    "comment": " Traverses a node recursively. ",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "NodeTraversal.traverse",
    "class_name": "com.google.javascript.jscomp.NodeTraversal",
    "signature": "com.google.javascript.jscomp.NodeTraversal.traverse(Node)",
    "snippet": "  public void traverse(Node root) {\n    try {\n      sourceName = \"\";\n      curNode = root;\n      pushScope(root);\n      traverseBranch(root, null);\n      popScope();\n    } catch (Exception unexpectedException) {\n      throwUnexpectedException(unexpectedException);\n    }\n  }",
    "comment": " Traverses a parse tree recursively. ",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "NodeTraversal.traverseBranch",
    "class_name": "com.google.javascript.jscomp.NodeTraversal",
    "signature": "com.google.javascript.jscomp.NodeTraversal.traverseBranch(Node,Node)",
    "snippet": "  @SuppressWarnings(\"fallthrough\")\n  private void traverseBranch(Node n, Node parent) {\n    int type = n.getType();\n    if (type == Token.SCRIPT) {\n      sourceName = getSourceName(n);\n    }\n\n    curNode = n;\n    if (!callback.shouldTraverse(this, n, parent)) return;\n\n    switch (type) {\n      case Token.CATCH:\n        Preconditions.checkState(n.getChildCount() == 3);\n        Preconditions.checkState(n.getFirstChild().getType() == Token.NAME);\n        // the first child is the catch var and the third child\n        // is the code block\n        traverseBranch(n.getFirstChild(), n);\n        traverseBranch(n.getFirstChild().getNext().getNext(), n);\n        break;\n\n      case Token.FUNCTION:\n        traverseFunction(n, parent);\n        break;\n\n      default:\n        for (Node child = n.getFirstChild(); child != null; ) {\n          // child could be replaced, in which case our child node\n          // would no longer point to the true next\n          Node next = child.getNext();\n          traverseBranch(child, n);\n          child = next;\n        }\n        break;\n    }\n\n    curNode = n;\n    callback.visit(this, n, parent);\n  }",
    "comment": " Traverses a branch. ",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "NodeTraversal.traverseFunction",
    "class_name": "com.google.javascript.jscomp.NodeTraversal",
    "signature": "com.google.javascript.jscomp.NodeTraversal.traverseFunction(Node,Node)",
    "snippet": "  private void traverseFunction(Node n, Node parent) {\n    Preconditions.checkState(n.getChildCount() == 3);\n    Preconditions.checkState(n.getType() == Token.FUNCTION);\n\n    final Node fnName = n.getFirstChild();\n\n    boolean anonymous = parent != null && NodeUtil.isFunctionAnonymous(n);\n\n    if (!anonymous) {\n      // Named functions are parent of the containing scope.\n      traverseBranch(fnName, n);\n    }\n\n    curNode = n;\n    pushScope(n);\n\n    if (anonymous) {\n      // Anonymous function names are parent of the contained scope.\n      traverseBranch(fnName, n);\n    }\n\n    final Node args = fnName.getNext();\n    final Node body = args.getNext();\n\n    // Args\n    traverseBranch(args, n);\n\n    // Body\n    Preconditions.checkState(body.getNext() == null &&\n            body.getType() == Token.BLOCK);\n    traverseBranch(body, n);\n\n    popScope();\n  }",
    "comment": " Traverses a function. ",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "AbstractPostOrderCallback.shouldTraverse",
    "class_name": "com.google.javascript.jscomp.NodeTraversal$AbstractPostOrderCallback",
    "signature": "com.google.javascript.jscomp.NodeTraversal$AbstractPostOrderCallback.shouldTraverse(NodeTraversal,Node,Node)",
    "snippet": "    public final boolean shouldTraverse(NodeTraversal nodeTraversal, Node n,\n        Node parent) {\n      return true;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "NodeTypeNormalizer.NodeTypeNormalizer",
    "class_name": "com.google.javascript.jscomp.NodeTypeNormalizer",
    "signature": "com.google.javascript.jscomp.NodeTypeNormalizer.NodeTypeNormalizer()",
    "snippet": "  NodeTypeNormalizer() {\n    this(false);\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "NodeTypeNormalizer.NodeTypeNormalizer",
    "class_name": "com.google.javascript.jscomp.NodeTypeNormalizer",
    "signature": "com.google.javascript.jscomp.NodeTypeNormalizer.NodeTypeNormalizer(boolean)",
    "snippet": "  NodeTypeNormalizer(boolean forbidChanges) {\n    this.assertOnChange = forbidChanges;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "NodeTypeNormalizer.normalizeBlocks",
    "class_name": "com.google.javascript.jscomp.NodeTypeNormalizer",
    "signature": "com.google.javascript.jscomp.NodeTypeNormalizer.normalizeBlocks(Node)",
    "snippet": "  private void normalizeBlocks(Node n) {\n    if (NodeUtil.isControlStructure(n)\n        && n.getType() != Token.LABEL\n        && n.getType() != Token.SWITCH) {\n      for (Node c = n.getFirstChild(); c != null; c = c.getNext()) {\n        if (NodeUtil.isControlStructureCodeBlock(n,c) &&\n            c.getType() != Token.BLOCK) {\n          Node newBlock = new Node(Token.BLOCK);\n          n.replaceChild(c, newBlock);\n          if (c.getType() != Token.EMPTY) {\n            newBlock.addChildrenToFront(c);\n          } else {\n            newBlock.setWasEmptyNode(true);\n          }\n          c = newBlock;\n          reportChange();\n        }\n      }\n    }\n  }",
    "comment": " Add blocks to IF, WHILE, DO, etc. ",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "NodeTypeNormalizer.normalizeJsDocAnnotations",
    "class_name": "com.google.javascript.jscomp.NodeTypeNormalizer",
    "signature": "com.google.javascript.jscomp.NodeTypeNormalizer.normalizeJsDocAnnotations(Node)",
    "snippet": "  private void normalizeJsDocAnnotations(Node n) {\n    if (n.getType() == Token.OBJECTLIT) {\n      for (Node key = n.getFirstChild();\n           key != null; key = key.getNext().getNext()) {\n        Node value = key.getNext();\n        if (key.getJSDocInfo() != null &&\n            key.getNext().getType() == Token.FUNCTION) {\n          value.setJSDocInfo(key.getJSDocInfo());\n        }\n      }\n    }\n\n    // TODO(johnlenz): Determine if it is possible to simply use the javadoc\n    // everywhere rather than use IS_DISPATCHER.\n    /*\n     * Translate dispatcher info into the property expected node.\n     */\n    if (n.getJSDocInfo() != null && n.getJSDocInfo().isJavaDispatch()) {\n      if (n.getType() == Token.ASSIGN) {\n        Node fnNode = n.getLastChild();\n        Preconditions.checkState(fnNode.getType() == Token.FUNCTION);\n        fnNode.putBooleanProp(Node.IS_DISPATCHER, true);\n      }\n    }\n\n    for (Node child = n.getFirstChild();\n         child != null; child = child.getNext()) {\n      normalizeJsDocAnnotations(child);\n    }\n  }",
    "comment": " Normalize where JSDoc annotations appear on the AST.  In the AST that Rhino gives us, it needs to make a distinction between jsdoc on the object literal node and jsdoc on the object literal value. For example, <pre> var x = { JSDOC / a: 'b', c: / JSDOC / 'd' }; </pre>  But in few narrow cases (in particular, function literals), it's a lot easier for us if the doc is attached to the value. ",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "NodeTypeNormalizer.normalizeNodeTypes",
    "class_name": "com.google.javascript.jscomp.NodeTypeNormalizer",
    "signature": "com.google.javascript.jscomp.NodeTypeNormalizer.normalizeNodeTypes(Node)",
    "snippet": "  private void normalizeNodeTypes(Node n) {\n    if (n.getType() == Token.EXPR_VOID) {\n      n.setType(Token.EXPR_RESULT);\n      reportChange();\n    }\n\n    // Remove unused properties to minimize differences between ASTs\n    // produced by the two parsers.\n    if (n.getType() == Token.FUNCTION) {\n      Preconditions.checkState(n.getProp(Node.FUNCTION_PROP) == null);\n    }\n\n    normalizeBlocks(n);\n\n    for (Node child = n.getFirstChild();\n         child != null; child = child.getNext()) {\n      // This pass is run during the CompilerTestCase validation, so this\n      // parent pointer check serves as a more general check.\n      Preconditions.checkState(child.getParent() == n);\n\n      normalizeNodeTypes(child);\n    }\n  }",
    "comment": " Covert EXPR_VOID to EXPR_RESULT to simplify the rest of the code. ",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "NodeTypeNormalizer.process",
    "class_name": "com.google.javascript.jscomp.NodeTypeNormalizer",
    "signature": "com.google.javascript.jscomp.NodeTypeNormalizer.process(Node,Node)",
    "snippet": "  @Override\n  public void process(Node externs, Node root) {\n    normalizeNodeTypes(root);\n    normalizeJsDocAnnotations(root);\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "NodeTypeNormalizer.reportChange",
    "class_name": "com.google.javascript.jscomp.NodeTypeNormalizer",
    "signature": "com.google.javascript.jscomp.NodeTypeNormalizer.reportChange()",
    "snippet": "  private void reportChange() {\n    if (assertOnChange) {\n      Preconditions.checkState(false, \"normalizeNodeType constraints violated\");\n    }\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "NodeUtil.getCatchBlock",
    "class_name": "com.google.javascript.jscomp.NodeUtil",
    "signature": "com.google.javascript.jscomp.NodeUtil.getCatchBlock(Node)",
    "snippet": "  static Node getCatchBlock(Node n) {\n    Preconditions.checkArgument(n.getType() == Token.TRY);\n    return n.getFirstChild().getNext();\n  }",
    "comment": " @return The BLOCK node containing the CATCH node (if any) of a TRY. ",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "NodeUtil.getConditionExpression",
    "class_name": "com.google.javascript.jscomp.NodeUtil",
    "signature": "com.google.javascript.jscomp.NodeUtil.getConditionExpression(Node)",
    "snippet": "  static Node getConditionExpression(Node n) {\n    switch (n.getType()) {\n      case Token.IF:\n      case Token.WHILE:\n        return n.getFirstChild();\n      case Token.DO:\n        return n.getLastChild();\n      case Token.FOR:\n        switch (n.getChildCount()) {\n          case 3:\n            return null;\n          case 4:\n            return n.getFirstChild().getNext();\n        }\n        throw new IllegalArgumentException(\"malformed 'for' statement \" + n);\n      case Token.CASE:\n        return null;\n    }\n    throw new IllegalArgumentException(n + \" does not have a condition.\");\n  }",
    "comment": " Gets the condition of an ON_TRUE / ON_FALSE CFG edge. @param n a node with an outgoing conditional CFG edge @return the condition node or null if the condition is not obviously a node ",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "NodeUtil.hasCatchHandler",
    "class_name": "com.google.javascript.jscomp.NodeUtil",
    "signature": "com.google.javascript.jscomp.NodeUtil.hasCatchHandler(Node)",
    "snippet": "  static boolean hasCatchHandler(Node n) {\n    Preconditions.checkArgument(n.getType() == Token.BLOCK);\n    return n.hasChildren() && n.getFirstChild().getType() == Token.CATCH;\n  }",
    "comment": " @return Whether BLOCK (from a TRY node) contains a CATCH. @see NodeUtil#getCatchBlock ",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "NodeUtil.hasFinally",
    "class_name": "com.google.javascript.jscomp.NodeUtil",
    "signature": "com.google.javascript.jscomp.NodeUtil.hasFinally(Node)",
    "snippet": "  static boolean hasFinally(Node n) {\n    Preconditions.checkArgument(n.getType() == Token.TRY);\n    return n.getChildCount() == 3;\n  }",
    "comment": " @return Whether a TRY node has a finally block. ",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "NodeUtil.isControlStructure",
    "class_name": "com.google.javascript.jscomp.NodeUtil",
    "signature": "com.google.javascript.jscomp.NodeUtil.isControlStructure(Node)",
    "snippet": "  static boolean isControlStructure(Node n) {\n    switch (n.getType()) {\n      case Token.FOR:\n      case Token.DO:\n      case Token.WHILE:\n      case Token.WITH:\n      case Token.IF:\n      case Token.LABEL:\n      case Token.TRY:\n      case Token.CATCH:\n      case Token.SWITCH:\n      case Token.CASE:\n      case Token.DEFAULT:\n        return true;\n      default:\n        return false;\n    }\n  }",
    "comment": " Determines whether the given node is a FOR, DO, WHILE, WITH, or IF node. ",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "NodeUtil.isControlStructureCodeBlock",
    "class_name": "com.google.javascript.jscomp.NodeUtil",
    "signature": "com.google.javascript.jscomp.NodeUtil.isControlStructureCodeBlock(Node,Node)",
    "snippet": "  static boolean isControlStructureCodeBlock(Node parent, Node n) {\n    switch (parent.getType()) {\n      case Token.FOR:\n      case Token.WHILE:\n      case Token.LABEL:\n      case Token.WITH:\n        return parent.getLastChild() == n;\n      case Token.DO:\n        return parent.getFirstChild() == n;\n      case Token.IF:\n        return parent.getFirstChild() != n;\n      case Token.TRY:\n        return parent.getFirstChild() == n || parent.getLastChild() == n;\n      case Token.CATCH:\n        return parent.getLastChild() == n;\n      case Token.SWITCH:\n      case Token.CASE:\n        return parent.getFirstChild() != n;\n      case Token.DEFAULT:\n        return true;\n      default:\n        Preconditions.checkState(isControlStructure(parent));\n        return false;\n    }\n  }",
    "comment": " Determines whether the given node is code node for FOR, DO, WHILE, WITH, or IF node. ",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "NodeUtil.isFunction",
    "class_name": "com.google.javascript.jscomp.NodeUtil",
    "signature": "com.google.javascript.jscomp.NodeUtil.isFunction(Node)",
    "snippet": "  static boolean isFunction(Node n) {\n    return n.getType() == Token.FUNCTION;\n  }",
    "comment": " Is this a FUNCTION node? ",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "NodeUtil.isFunctionAnonymous",
    "class_name": "com.google.javascript.jscomp.NodeUtil",
    "signature": "com.google.javascript.jscomp.NodeUtil.isFunctionAnonymous(Node)",
    "snippet": "  static boolean isFunctionAnonymous(Node n) {\n    return !isStatement(n);\n  }",
    "comment": " Is a FUNCTION node an anonymous function? An anonymous function is one that has either no name or a name that is not added to the current scope.  <p>Some examples of anonymous functions: <pre> function () {} (function f() {})() [ function f() {} ] var f = function f() {}; for (function f() {};;) {} </pre>  <p>Some examples of functions that are <em>not</em> anonymous: <pre> function f() {} if (x); else function f() {} for (;;) { function f() {} } </pre>  @param n A FUNCTION node @return Whether n is an anonymous function ",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "NodeUtil.isStatement",
    "class_name": "com.google.javascript.jscomp.NodeUtil",
    "signature": "com.google.javascript.jscomp.NodeUtil.isStatement(Node)",
    "snippet": "  static boolean isStatement(Node n) {\n    Node parent = n.getParent();\n    // It is not possible to determine definitely if a node is a statement\n    // or not if it is not part of the AST.  A FUNCTION node, for instance,\n    // is either part of an expression (as a anonymous function) or as\n    // a statement.\n    Preconditions.checkState(parent != null);\n    switch (parent.getType()) {\n      case Token.SCRIPT:\n      case Token.BLOCK:\n      case Token.LABEL:\n        return true;\n      default:\n        return false;\n    }\n  }",
    "comment": " @return Whether the node is used as a statement. ",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "PassFactory.PassFactory",
    "class_name": "com.google.javascript.jscomp.PassFactory",
    "signature": "com.google.javascript.jscomp.PassFactory.PassFactory(String,boolean)",
    "snippet": "  protected PassFactory(String name, boolean isOneTimePass) {\n    this.name = name;\n    this.isOneTimePass = isOneTimePass;\n  }",
    "comment": " @param name The name of the pass that this factory creates. @param isOneTimePass If true, the pass produced by this factory can only be run once. ",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "PotentialCheckManager.flush",
    "class_name": "com.google.javascript.jscomp.PotentialCheckManager",
    "signature": "com.google.javascript.jscomp.PotentialCheckManager.flush()",
    "snippet": "  void flush() {\n    for (PotentialCheck check : checks) {\n      check.evaluate();\n    }\n    checks.clear();\n  }",
    "comment": " Evaluates all pending potential checks. Each check is either reported or permanently discarded. ",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "RhinoErrorReporter.forNewRhino",
    "class_name": "com.google.javascript.jscomp.RhinoErrorReporter",
    "signature": "com.google.javascript.jscomp.RhinoErrorReporter.forNewRhino(AbstractCompiler)",
    "snippet": "  public static com.google.javascript.jscomp.mozilla.rhino.ErrorReporter\n      forNewRhino(AbstractCompiler compiler) {\n    return new NewRhinoErrorReporter(compiler);\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "RhinoErrorReporter.forOldRhino",
    "class_name": "com.google.javascript.jscomp.RhinoErrorReporter",
    "signature": "com.google.javascript.jscomp.RhinoErrorReporter.forOldRhino(AbstractCompiler)",
    "snippet": "  public static ErrorReporter forOldRhino(AbstractCompiler compiler) {\n    return new OldRhinoErrorReporter(compiler);\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "RhinoErrorReporter.replacePlaceHolders",
    "class_name": "com.google.javascript.jscomp.RhinoErrorReporter",
    "signature": "com.google.javascript.jscomp.RhinoErrorReporter.replacePlaceHolders(String)",
    "snippet": "  private String replacePlaceHolders(String s) {\n    s = Pattern.quote(s);\n    return s.replaceAll(\"\\\\{\\\\d+\\\\}\", \"\\\\\\\\E.*\\\\\\\\Q\");\n  }",
    "comment": " For each message such as \"Not a good use of {0}\", replace the place holder {0} with a wild card that matches all possible strings. Also put the any non-place-holder in quotes for regex matching later. ",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "Scope.Scope",
    "class_name": "com.google.javascript.jscomp.Scope",
    "signature": "com.google.javascript.jscomp.Scope.Scope(Node,AbstractCompiler)",
    "snippet": "  Scope(Node rootNode, AbstractCompiler compiler) {\n    this.parent = null;\n    this.rootNode = rootNode;\n    thisType = compiler.getTypeRegistry().getNativeObjectType(GLOBAL_THIS);\n    this.isBottom = false;\n  }",
    "comment": " Creates a global Scope. @param rootNode  Typically the global BLOCK node. ",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "Scope.Scope",
    "class_name": "com.google.javascript.jscomp.Scope",
    "signature": "com.google.javascript.jscomp.Scope.Scope(Node,ObjectType)",
    "snippet": "  Scope(Node rootNode, ObjectType thisType) {\n    this.parent = null;\n    this.rootNode = rootNode;\n    this.thisType = thisType;\n    this.isBottom = true;\n  }",
    "comment": " Creates a empty Scope (bottom of the lattice). @param rootNode Typically a FUNCTION node or the global BLOCK node. @param thisType the type of {@code this} in this scope ",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "Scope.Scope",
    "class_name": "com.google.javascript.jscomp.Scope",
    "signature": "com.google.javascript.jscomp.Scope.Scope(Scope,Node)",
    "snippet": "  Scope(Scope parent, Node rootNode) {\n    Preconditions.checkNotNull(parent);\n    Preconditions.checkArgument(rootNode != parent.rootNode);\n\n    this.parent = parent;\n    this.rootNode = rootNode;\n    JSType nodeType = rootNode.getJSType();\n    if (nodeType != null && nodeType instanceof FunctionType) {\n      thisType = ((FunctionType) nodeType).getTypeOfThis();\n    } else {\n      thisType = parent.thisType;\n    }\n    this.isBottom = false;\n  }",
    "comment": " Creates a Scope given the parent Scope and the root node of the scope. @param parent  The parent Scope. Cannot be null. @param rootNode  Typically the FUNCTION node. ",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "Scope.declare",
    "class_name": "com.google.javascript.jscomp.Scope",
    "signature": "com.google.javascript.jscomp.Scope.declare(String,Node,JSType,CompilerInput,boolean)",
    "snippet": "  Var declare(String name, Node nameNode,\n      JSType type, CompilerInput input, boolean inferred) {\n    Preconditions.checkState(name != null && name.length() > 0);\n\n    // Make sure that it's declared only once\n    Preconditions.checkState(vars.get(name) == null);\n\n    Var var = new Var(inferred);\n    var.name = name;\n    var.nameNode = nameNode;\n    var.type = type;\n    var.scope = this;\n    var.index = vars.size();\n    var.input = input;\n\n    // native variables do not have a name node.\n    // TODO(user): make Var abstract and have NativeVar, NormalVar.\n    JSDocInfo info = NodeUtil.getInfoForNameNode(nameNode);\n\n    var.isDefine = info != null && info.isDefine();\n    var.info = info;\n\n    vars.put(name, var);\n    return var;\n  }",
    "comment": " Declares a variable.  @param name name of the variable @param nameNode the NAME node declaring the variable @param type the variable's type @param input the input in which this variable is defined. @param inferred Whether this variable's type is inferred (as opposed to declared). ",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "Scope.getParent",
    "class_name": "com.google.javascript.jscomp.Scope",
    "signature": "com.google.javascript.jscomp.Scope.getParent()",
    "snippet": "  public Scope getParent() {\n    return parent;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "Scope.getParentScope",
    "class_name": "com.google.javascript.jscomp.Scope",
    "signature": "com.google.javascript.jscomp.Scope.getParentScope()",
    "snippet": "  @Override\n  public StaticScope<JSType> getParentScope() {\n    return parent;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "Scope.getRootNode",
    "class_name": "com.google.javascript.jscomp.Scope",
    "signature": "com.google.javascript.jscomp.Scope.getRootNode()",
    "snippet": "  public Node getRootNode() {\n    return rootNode;\n  }",
    "comment": " Gets the container node of the scope. This is typically the FUNCTION node or the global BLOCK/SCRIPT node. ",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "Scope.getSlot",
    "class_name": "com.google.javascript.jscomp.Scope",
    "signature": "com.google.javascript.jscomp.Scope.getSlot(String)",
    "snippet": "  public StaticSlot<JSType> getSlot(String name) {\n    return getVar(name);\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "Scope.getTypeOfThis",
    "class_name": "com.google.javascript.jscomp.Scope",
    "signature": "com.google.javascript.jscomp.Scope.getTypeOfThis()",
    "snippet": "  public ObjectType getTypeOfThis() {\n    return thisType;\n  }",
    "comment": " Gets the type of {@code this} in the current scope. ",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "Scope.getVar",
    "class_name": "com.google.javascript.jscomp.Scope",
    "signature": "com.google.javascript.jscomp.Scope.getVar(String)",
    "snippet": "  public Var getVar(String name) {\n    Var var = vars.get(name);\n    if (var != null) {\n      return var;\n    } else if (parent != null) { // Recurse up the parent Scope\n      return parent.getVar(name);\n    } else {\n      return null;\n    }\n  }",
    "comment": " Returns the variable, may be null ",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "Scope.getVars",
    "class_name": "com.google.javascript.jscomp.Scope",
    "signature": "com.google.javascript.jscomp.Scope.getVars()",
    "snippet": "  public Iterator<Var> getVars() {\n    return vars.values().iterator();\n  }",
    "comment": " Return an iterator over all of the variables declared in this scope. ",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "Scope.isDeclared",
    "class_name": "com.google.javascript.jscomp.Scope",
    "signature": "com.google.javascript.jscomp.Scope.isDeclared(String,boolean)",
    "snippet": "  public boolean isDeclared(String name, boolean recurse) {\n    Scope scope = this;\n    if (scope.vars.containsKey(name))\n      return true;\n\n    if (scope.parent != null && recurse) {\n      return scope.parent.isDeclared(name, recurse);\n    }\n    return false;\n  }",
    "comment": " Returns true if a variable is declared. ",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "Scope.isGlobal",
    "class_name": "com.google.javascript.jscomp.Scope",
    "signature": "com.google.javascript.jscomp.Scope.isGlobal()",
    "snippet": "  public boolean isGlobal() {\n    return parent == null;\n  }",
    "comment": " Returns whether this is the global scope. ",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "Scope.isLocal",
    "class_name": "com.google.javascript.jscomp.Scope",
    "signature": "com.google.javascript.jscomp.Scope.isLocal()",
    "snippet": "  public boolean isLocal() {\n    return !isGlobal();\n  }",
    "comment": " Returns whether this is a local scope (i.e. not the global scope). ",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "Var.getInitialValue",
    "class_name": "com.google.javascript.jscomp.Scope$Var",
    "signature": "com.google.javascript.jscomp.Scope$Var.getInitialValue()",
    "snippet": "    public Node getInitialValue() {\n      Node parent = getParentNode();\n      return parent.getType() == Token.FUNCTION ?\n          parent : nameNode.getFirstChild();\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "Var.getName",
    "class_name": "com.google.javascript.jscomp.Scope$Var",
    "signature": "com.google.javascript.jscomp.Scope$Var.getName()",
    "snippet": "    public String getName() {\n      return name;\n    }",
    "comment": " Gets the name of the variable. ",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "Var.getNameNode",
    "class_name": "com.google.javascript.jscomp.Scope$Var",
    "signature": "com.google.javascript.jscomp.Scope$Var.getNameNode()",
    "snippet": "    public Node getNameNode() {\n      return nameNode;\n    }",
    "comment": " Returns the name node that produced this variable. ",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "Var.getParentNode",
    "class_name": "com.google.javascript.jscomp.Scope$Var",
    "signature": "com.google.javascript.jscomp.Scope$Var.getParentNode()",
    "snippet": "    public Node getParentNode() {\n      return nameNode == null ? null : nameNode.getParent();\n    }",
    "comment": " Gets the parent of the name node. ",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "Var.getScope",
    "class_name": "com.google.javascript.jscomp.Scope$Var",
    "signature": "com.google.javascript.jscomp.Scope$Var.getScope()",
    "snippet": "    Scope getScope() {\n      return scope;\n    }",
    "comment": " Gets the scope where this variable is declared. ",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "Var.getType",
    "class_name": "com.google.javascript.jscomp.Scope$Var",
    "signature": "com.google.javascript.jscomp.Scope$Var.getType()",
    "snippet": "    public JSType getType() {\n      return type;\n    }",
    "comment": " Gets this variable's type. To know whether this type has been inferred, see {@code #isInferred()}. ",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "Var.isExtern",
    "class_name": "com.google.javascript.jscomp.Scope$Var",
    "signature": "com.google.javascript.jscomp.Scope$Var.isExtern()",
    "snippet": "    boolean isExtern() {\n      return input == null || input.isExtern();\n    }",
    "comment": " Returns whether this is defined in an extern file. ",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "Var.isLocal",
    "class_name": "com.google.javascript.jscomp.Scope$Var",
    "signature": "com.google.javascript.jscomp.Scope$Var.isLocal()",
    "snippet": "    public boolean isLocal() {\n      return scope.isLocal();\n    }",
    "comment": " Returns whether this is a local variable. ",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "Var.isTypeInferred",
    "class_name": "com.google.javascript.jscomp.Scope$Var",
    "signature": "com.google.javascript.jscomp.Scope$Var.isTypeInferred()",
    "snippet": "    public boolean isTypeInferred() {\n      return typeInferred;\n    }",
    "comment": " Returns whether this variable's type is inferred. To get the variable's type, see {@link #getType()}. ",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "Var.setType",
    "class_name": "com.google.javascript.jscomp.Scope$Var",
    "signature": "com.google.javascript.jscomp.Scope$Var.setType(JSType)",
    "snippet": "    void setType(JSType type) {\n      Preconditions.checkState(isTypeInferred());\n      this.type = type;\n    }",
    "comment": " Sets this variable's type. @throws IllegalStateException if the variable's type is not inferred ",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "SemanticReverseAbstractInterpreter.SemanticReverseAbstractInterpreter",
    "class_name": "com.google.javascript.jscomp.SemanticReverseAbstractInterpreter",
    "signature": "com.google.javascript.jscomp.SemanticReverseAbstractInterpreter.SemanticReverseAbstractInterpreter(CodingConvention,JSTypeRegistry)",
    "snippet": "  SemanticReverseAbstractInterpreter(CodingConvention convention,\n      JSTypeRegistry typeRegistry) {\n    super(convention, typeRegistry);\n  }",
    "comment": " Creates a semantic reverse abstract interpreter. ",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "SourceFile.SourceFile",
    "class_name": "com.google.javascript.jscomp.SourceFile",
    "signature": "com.google.javascript.jscomp.SourceFile.SourceFile(String)",
    "snippet": "  SourceFile(String fileName) {\n    this.fileName = fileName;\n    // Starting point: offset 0 is at line 1.\n    this.lastOffset = 0;\n    this.lastLine = 1;\n  }",
    "comment": " Construct a new abstract source file.  @param fileName The file name of the source file. It does not necessarily need to correspond to a real path. But it should be unique. Will appear in warning messages emitted by the compiler. ",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "SourceFile.fromCode",
    "class_name": "com.google.javascript.jscomp.SourceFile",
    "signature": "com.google.javascript.jscomp.SourceFile.fromCode(String,String)",
    "snippet": "  public static SourceFile fromCode(String fileName, String code) {\n    return new Preloaded(fileName, code);\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "SourceFile.getCode",
    "class_name": "com.google.javascript.jscomp.SourceFile",
    "signature": "com.google.javascript.jscomp.SourceFile.getCode()",
    "snippet": "  public String getCode() throws IOException {\n    return code;\n  }",
    "comment": " Gets all the code in this source file.  @throws IOException  ",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "SourceFile.getName",
    "class_name": "com.google.javascript.jscomp.SourceFile",
    "signature": "com.google.javascript.jscomp.SourceFile.getName()",
    "snippet": "  public String getName() {\n    return fileName;\n  }",
    "comment": "Returns a unique name for the source file. */",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "SourceFile.setCode",
    "class_name": "com.google.javascript.jscomp.SourceFile",
    "signature": "com.google.javascript.jscomp.SourceFile.setCode(String)",
    "snippet": "  private void setCode(String sourceCode) {\n    code = sourceCode;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "SymbolTable.SymbolTable",
    "class_name": "com.google.javascript.jscomp.SymbolTable",
    "signature": "com.google.javascript.jscomp.SymbolTable.SymbolTable(AbstractCompiler)",
    "snippet": "  SymbolTable(AbstractCompiler compiler) {\n    this.compiler = compiler;\n    compiler.addChangeHandler(this);\n\n    scopeCreator = new SyntacticScopeCreator(compiler);\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "SymbolTable.acquire",
    "class_name": "com.google.javascript.jscomp.SymbolTable",
    "signature": "com.google.javascript.jscomp.SymbolTable.acquire()",
    "snippet": "  synchronized void acquire() {\n    Preconditions.checkState(!locked, \"SymbolTable already acquired\");\n    locked = true;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "SymbolTable.release",
    "class_name": "com.google.javascript.jscomp.SymbolTable",
    "signature": "com.google.javascript.jscomp.SymbolTable.release()",
    "snippet": "  synchronized void release() {\n    Preconditions.checkState(locked, \"SymbolTable already released\");\n    locked = false;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "SymbolTable.verify",
    "class_name": "com.google.javascript.jscomp.SymbolTable",
    "signature": "com.google.javascript.jscomp.SymbolTable.verify(Node,Node)",
    "snippet": "  void verify(Node expectedRoot, Node actualRoot) {\n    VerifyingCallback callback = new VerifyingCallback(\n        expectedRoot, actualRoot);\n    callback.verify();\n  }",
    "comment": " Check that this symbol table has been kept up to date. Compiler warnings will be emitted if anything is wrong. @param expectedRoot The root of the expected AST. @param actualRoot The root of the actual AST used with this symbol table. ",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "VerifyingCallback.verify",
    "class_name": "com.google.javascript.jscomp.SymbolTable$VerifyingCallback",
    "signature": "com.google.javascript.jscomp.SymbolTable$VerifyingCallback.verify()",
    "snippet": "    private void verify() {\n      if (cache == null) {\n        // The symbol table was never used, so no need to check anything.\n        return;\n      }\n\n      if (!cache.scopes.isEmpty()) {\n        verifyScopes();\n      }\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "SyntacticScopeCreator.SyntacticScopeCreator",
    "class_name": "com.google.javascript.jscomp.SyntacticScopeCreator",
    "signature": "com.google.javascript.jscomp.SyntacticScopeCreator.SyntacticScopeCreator(AbstractCompiler)",
    "snippet": "  SyntacticScopeCreator(AbstractCompiler compiler) {\n    this.compiler = compiler;\n    this.redeclarationHandler = new DefaultRedeclarationHandler();\n  }",
    "comment": " Creates a ScopeCreator. ",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "Tracer.Tracer",
    "class_name": "com.google.javascript.jscomp.Tracer",
    "signature": "com.google.javascript.jscomp.Tracer.Tracer(String,String)",
    "snippet": "  Tracer(@Nullable String type, @Nullable String comment) {\n    this.type = type;\n    this.comment = comment == null ? \"\" : comment;\n    startTimeMs = clock.currentTimeMillis();\n    startThread = Thread.currentThread();\n    if (!extraTracingStatistics.isEmpty()) {\n      int size = extraTracingStatistics.size();\n      extraTracingValues = new long[size];\n      int i = 0;\n      for (TracingStatistic tracingStatistic : extraTracingStatistics) {\n        extraTracingValues[i] = tracingStatistic.start(startThread);\n        i++;\n      }\n    }\n\n    ThreadTrace trace = getThreadTrace();\n\n    // Do nothing if the current thread trace wasn't initialized.\n    if (!trace.isInitialized()) {\n      return;\n    }\n\n    // Check if we are creating too many Tracers.\n    if (trace.events.size() >= MAX_TRACE_SIZE) {\n      logger.log(Level.WARNING,\n                  \"Giant thread trace. Too many Tracers created. \"\n                    + \"Clearing to avoid memory leak.\",\n                  new Throwable(trace.toString()));\n      trace.truncateEvents();\n    }\n\n    // Check if we forgot to close the Tracers.\n    if (trace.outstandingEvents.size() >= MAX_TRACE_SIZE) {\n      logger.log(Level.WARNING,\n                  \"Too many outstanding Tracers. Tracer.stop() is missing \"\n                    + \"or Tracer.stop() is not wrapped in a \"\n                    + \"try/finally block. \"\n                    + \"Clearing to avoid memory leak.\",\n                  new Throwable(trace.toString()));\n      trace.truncateOutstandingEvents();\n    }\n\n    trace.startEvent(this);\n  }",
    "comment": " Create and start a tracer. Both type and comment may be null. See class comment for usage.  @param type The type for totalling @param comment Comment about this tracer ",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "Tracer.getThreadTrace",
    "class_name": "com.google.javascript.jscomp.Tracer",
    "signature": "com.google.javascript.jscomp.Tracer.getThreadTrace()",
    "snippet": "  static ThreadTrace getThreadTrace() {\n    ThreadTrace t = traces.get();\n    if (t == null) {\n      t = new ThreadTrace();\n      t.prettyPrint = defaultPrettyPrint;\n      traces.set(t);\n    }\n    return t;\n  }",
    "comment": " Get the ThreadTrace for the current thread, creating one if necessary. ",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "Tracer.stop",
    "class_name": "com.google.javascript.jscomp.Tracer",
    "signature": "com.google.javascript.jscomp.Tracer.stop()",
    "snippet": "  long stop() {\n    return stop(-1);\n  }",
    "comment": "Stop the trace using the default silence_threshold  @return  The time that this trace actually ran. ",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "Tracer.stop",
    "class_name": "com.google.javascript.jscomp.Tracer",
    "signature": "com.google.javascript.jscomp.Tracer.stop(int)",
    "snippet": "  long stop(int silence_threshold) {\n    Preconditions.checkState(Thread.currentThread() == startThread);\n\n    ThreadTrace trace = getThreadTrace();\n    // Do nothing if the thread trace was not initialized.\n    if (!trace.isInitialized()) {\n      return 0;\n    }\n\n    stopTimeMs = clock.currentTimeMillis();\n    if (extraTracingValues != null) {\n      // We use extraTracingValues.length rather than extraTracingStatistics.size() because\n      // a new statistic may have been added\n      for (int i = 0; i < extraTracingValues.length; i++) {\n        long value = extraTracingStatistics.get(i).stop(startThread);\n        extraTracingValues[i] = value - extraTracingValues[i];\n      }\n    }\n\n    // Do nothing if the thread trace was not initialized.\n    if (!trace.isInitialized()) {\n      return 0;\n    }\n\n    trace.endEvent(this, silence_threshold);\n    return stopTimeMs - startTimeMs;\n  }",
    "comment": " Stop the trace. This may only be done once and must be done from the same thread that started it. @param silence_threshold Traces for time less than silence_threshold ms will be left out of the trace report. A value of -1 indicates that the current ThreadTrace silence_threshold should be used. @return The time that this trace actually ran ",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "ThreadTrace.isInitialized",
    "class_name": "com.google.javascript.jscomp.Tracer$ThreadTrace",
    "signature": "com.google.javascript.jscomp.Tracer$ThreadTrace.isInitialized()",
    "snippet": "    boolean isInitialized() {\n      return isInitialized;\n    }",
    "comment": "Is initialized? */",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "TypeCheck.TypeCheck",
    "class_name": "com.google.javascript.jscomp.TypeCheck",
    "signature": "com.google.javascript.jscomp.TypeCheck.TypeCheck(AbstractCompiler,ReverseAbstractInterpreter,JSTypeRegistry)",
    "snippet": "  TypeCheck(AbstractCompiler compiler,\n      ReverseAbstractInterpreter reverseInterpreter,\n      JSTypeRegistry typeRegistry) {\n    this(compiler, reverseInterpreter, typeRegistry, null, null,\n         CheckLevel.WARNING, CheckLevel.OFF);\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "TypeCheck.TypeCheck",
    "class_name": "com.google.javascript.jscomp.TypeCheck",
    "signature": "com.google.javascript.jscomp.TypeCheck.TypeCheck(AbstractCompiler,ReverseAbstractInterpreter,JSTypeRegistry,Scope,ScopeCreator,CheckLevel,CheckLevel)",
    "snippet": "  public TypeCheck(AbstractCompiler compiler,\n      ReverseAbstractInterpreter reverseInterpreter,\n      JSTypeRegistry typeRegistry,\n      Scope topScope,\n      ScopeCreator scopeCreator,\n      CheckLevel reportMissingOverride,\n      CheckLevel reportUnknownTypes) {\n    this.compiler = compiler;\n    this.validator = compiler.getTypeValidator();\n    this.reverseInterpreter = reverseInterpreter;\n    this.typeRegistry = typeRegistry;\n    this.topScope = topScope;\n    this.scopeCreator = scopeCreator;\n    this.reportMissingOverride = reportMissingOverride;\n    this.reportUnknownTypes = reportUnknownTypes;\n    this.inferJSDocInfo = new InferJSDocInfo(compiler);\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "TypeCheck.check",
    "class_name": "com.google.javascript.jscomp.TypeCheck",
    "signature": "com.google.javascript.jscomp.TypeCheck.check(Node,boolean)",
    "snippet": "  public void check(Node node, boolean externs) {\n    Preconditions.checkNotNull(node);\n\n    NodeTraversal t = new NodeTraversal(compiler, this, scopeCreator);\n    inExterns = externs;\n    t.traverseWithScope(node, topScope);\n    if (externs) {\n      inferJSDocInfo.process(node, null);\n    } else {\n      inferJSDocInfo.process(null, node);\n    }\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "TypeCheck.checkPropertyAccess",
    "class_name": "com.google.javascript.jscomp.TypeCheck",
    "signature": "com.google.javascript.jscomp.TypeCheck.checkPropertyAccess(JSType,String,NodeTraversal,Node)",
    "snippet": "  private void checkPropertyAccess(JSType childType, String propName,\n      NodeTraversal t, Node n) {\n    ObjectType objectType = childType.dereference();\n    if (objectType != null) {\n      JSType propType = getJSType(n);\n      if ((!objectType.hasProperty(propName) ||\n           objectType.equals(typeRegistry.getNativeType(UNKNOWN_TYPE))) &&\n          propType.equals(typeRegistry.getNativeType(UNKNOWN_TYPE))) {\n        if (objectType instanceof EnumType) {\n          t.report(n, INEXISTENT_ENUM_ELEMENT, propName);\n        } else if (!objectType.isEmptyType() &&\n            reportMissingProperties && !isPropertyTest(n)) {\n          if (!typeRegistry.canPropertyBeDefined(objectType, propName)) {\n            t.report(n, INEXISTENT_PROPERTY, propName,\n                validator.getReadableJSTypeName(n.getFirstChild(), true));\n          }\n        }\n      }\n    } else {\n      // TODO(nicksantos): might want to flag the access on a non object when\n      // it's impossible to get a property from this type.\n    }\n  }",
    "comment": " Make sure that the access of this property is ok. ",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "TypeCheck.doPercentTypedAccounting",
    "class_name": "com.google.javascript.jscomp.TypeCheck",
    "signature": "com.google.javascript.jscomp.TypeCheck.doPercentTypedAccounting(NodeTraversal,Node)",
    "snippet": "  private void doPercentTypedAccounting(NodeTraversal t, Node n) {\n    JSType type = n.getJSType();\n    if (type == null) {\n      nullCount++;\n    } else if (type.isUnknownType()) {\n      if (reportUnknownTypes.isOn()) {\n        String unresolvedReference = getUnresolvedReference(type);\n        if (unresolvedReference != null) {\n          compiler.report(JSError.make(t, n, reportUnknownTypes,\n                                       UNRESOLVED_TYPE, unresolvedReference));\n        } else {\n          compiler.report(JSError.make(t, n, reportUnknownTypes,\n                                       UNKNOWN_EXPR_TYPE));\n        }\n      }\n      unknownCount++;\n    } else {\n      typedCount++;\n    }\n  }",
    "comment": " Counts the given node in the typed statistics. @param n a node that should be typed ",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "TypeCheck.ensureTyped",
    "class_name": "com.google.javascript.jscomp.TypeCheck",
    "signature": "com.google.javascript.jscomp.TypeCheck.ensureTyped(NodeTraversal,Node)",
    "snippet": "  private void ensureTyped(NodeTraversal t, Node n) {\n    ensureTyped(t, n, getNativeType(UNKNOWN_TYPE));\n  }",
    "comment": " Ensure that the given node has a type. If it does not have one, attach the UNKNOWN_TYPE. ",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "TypeCheck.ensureTyped",
    "class_name": "com.google.javascript.jscomp.TypeCheck",
    "signature": "com.google.javascript.jscomp.TypeCheck.ensureTyped(NodeTraversal,Node,JSType)",
    "snippet": "  private void ensureTyped(NodeTraversal t, Node n, JSType type) {\n    // Make sure FUNCTION nodes always get function type.\n    Preconditions.checkState(n.getType() != Token.FUNCTION ||\n            type instanceof FunctionType ||\n            type.isUnknownType());\n    JSDocInfo info = n.getJSDocInfo();\n    if (info != null) {\n      if (info.hasType()) {\n        JSType infoType = info.getType().evaluate(t.getScope());\n        validator.expectCanCast(t, n, infoType, type);\n        type = infoType;\n      }\n\n      if (info.isImplicitCast() && !inExterns) {\n        String propName = n.getType() == Token.GETPROP ?\n            n.getLastChild().getString() : \"(missing)\";\n        compiler.report(\n            JSError.make(t, n, ILLEGAL_IMPLICIT_CAST, propName));\n      }\n    }\n\n    if (n.getJSType() == null) {\n      n.setJSType(type);\n    }\n  }",
    "comment": " Enforces type casts, and ensures the node is typed.  A cast in the way that we use it in JSDoc annotations never alters the generated code and therefore never can induce any runtime operation. What this means is that a 'cast' is really just a compile time constraint on the underlying value. In the future, we may add support for run-time casts for compiled tests.  To ensure some shred of sanity, we enforce the notion that the type you are casting to may only meaningfully be a narrower type than the underlying declared type. We also invalidate optimizations on bad type casts.  @param t The traversal object needed to report errors. @param n The node getting a type assigned to it. @param type The type to be assigned. ",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "TypeCheck.ensureTyped",
    "class_name": "com.google.javascript.jscomp.TypeCheck",
    "signature": "com.google.javascript.jscomp.TypeCheck.ensureTyped(NodeTraversal,Node,JSTypeNative)",
    "snippet": "  private void ensureTyped(NodeTraversal t, Node n, JSTypeNative type) {\n    ensureTyped(t, n, getNativeType(type));\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "TypeCheck.getJSType",
    "class_name": "com.google.javascript.jscomp.TypeCheck",
    "signature": "com.google.javascript.jscomp.TypeCheck.getJSType(Node)",
    "snippet": "  private JSType getJSType(Node n) {\n    JSType jsType = n.getJSType();\n    if (jsType == null) {\n      // TODO(nicksantos): This branch indicates a compiler bug, not worthy of\n      // halting the compilation but we should log this and analyze to track\n      // down why it happens. This is not critical and will be resolved over\n      // time as the type checker is extended.\n      return getNativeType(UNKNOWN_TYPE);\n    } else {\n      return jsType;\n    }\n  }",
    "comment": " This method gets the JSType from the Node argument and verifies that it is present. ",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "TypeCheck.getNativeType",
    "class_name": "com.google.javascript.jscomp.TypeCheck",
    "signature": "com.google.javascript.jscomp.TypeCheck.getNativeType(JSTypeNative)",
    "snippet": "  private JSType getNativeType(JSTypeNative typeId) {\n    return typeRegistry.getNativeType(typeId);\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "TypeCheck.isPropertyTest",
    "class_name": "com.google.javascript.jscomp.TypeCheck",
    "signature": "com.google.javascript.jscomp.TypeCheck.isPropertyTest(Node)",
    "snippet": "  private boolean isPropertyTest(Node getProp) {\n    Node parent = getProp.getParent();\n    switch (parent.getType()) {\n      case Token.CALL:\n        return parent.getFirstChild() != getProp &&\n            compiler.getCodingConvention().isPropertyTestFunction(parent);\n\n      case Token.IF:\n      case Token.WHILE:\n      case Token.DO:\n      case Token.FOR:\n        return NodeUtil.getConditionExpression(parent) == getProp;\n\n      case Token.INSTANCEOF:\n      case Token.TYPEOF:\n        return true;\n\n      case Token.AND:\n      case Token.HOOK:\n        return parent.getFirstChild() == getProp;\n    }\n    return false;\n  }",
    "comment": " Determines whether this node is testing for the existence of a property. If true, we will not emit warnings about a missing property.  @param getProp The GETPROP being tested. ",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "TypeCheck.process",
    "class_name": "com.google.javascript.jscomp.TypeCheck",
    "signature": "com.google.javascript.jscomp.TypeCheck.process(Node,Node)",
    "snippet": "  public void process(Node externsRoot, Node jsRoot) {\n    Preconditions.checkNotNull(scopeCreator);\n    Preconditions.checkNotNull(topScope);\n\n    Node externsAndJs = jsRoot.getParent();\n    Preconditions.checkState(externsAndJs != null);\n    Preconditions.checkState(\n        externsRoot == null || externsAndJs.hasChild(externsRoot));\n\n    if (externsRoot != null) {\n      check(externsRoot, true);\n    }\n    check(jsRoot, false);\n\n    potentialChecks.flush();\n  }",
    "comment": " Main entry point for this phase of processing. This follows the pattern for JSCompiler phases.  @param externsRoot The root of the externs parse tree. @param jsRoot The root of the input parse tree to be checked. ",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "TypeCheck.processForTesting",
    "class_name": "com.google.javascript.jscomp.TypeCheck",
    "signature": "com.google.javascript.jscomp.TypeCheck.processForTesting(Node,Node)",
    "snippet": "  public Scope processForTesting(Node externsRoot, Node jsRoot) {\n    Preconditions.checkState(scopeCreator == null);\n    Preconditions.checkState(topScope == null);\n\n    Preconditions.checkState(jsRoot.getParent() != null);\n    Node externsAndJsRoot = jsRoot.getParent();\n\n    scopeCreator = new MemoizedScopeCreator(new TypedScopeCreator(compiler));\n    topScope = scopeCreator.createScope(externsAndJsRoot, null);\n\n    TypeInferencePass inference = new TypeInferencePass(compiler,\n        reverseInterpreter, topScope, scopeCreator);\n\n    inference.process(externsRoot, jsRoot);\n    process(externsRoot, jsRoot);\n\n    return topScope;\n  }",
    "comment": "Main entry point of this phase for testing code. */",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "TypeCheck.shouldTraverse",
    "class_name": "com.google.javascript.jscomp.TypeCheck",
    "signature": "com.google.javascript.jscomp.TypeCheck.shouldTraverse(NodeTraversal,Node,Node)",
    "snippet": "  public boolean shouldTraverse(\n      NodeTraversal t, Node n, Node parent) {\n    JSDocInfo info;\n    switch (n.getType()) {\n      case Token.SCRIPT:\n      case Token.VAR:\n        // @notypecheck\n        info = n.getJSDocInfo();\n        if (info != null && info.isNoTypeCheck()) {\n          return false;\n        }\n        break;\n\n      case Token.FUNCTION:\n        // @notypecheck\n        info = n.getJSDocInfo();\n        info = (info == null) ? parent.getJSDocInfo() : info;\n        if (info != null && info.isNoTypeCheck()) {\n          return false;\n        }\n\n        // normal type checking\n        final TypeCheck outerThis = this;\n        final Scope outerScope = t.getScope();\n        final FunctionType functionType = (FunctionType) n.getJSType();\n        final String functionPrivateName = n.getFirstChild().getString();\n        if (functionPrivateName != null && functionPrivateName.length() > 0 &&\n            outerScope.isDeclared(functionPrivateName, false) &&\n            // Ideally, we would want to check whether the type in the scope\n            // differs from the type being defined, but then the extern\n            // redeclarations of built-in types generates spurious warnings.\n            !(outerScope.getVar(\n                functionPrivateName).getType() instanceof FunctionType)) {\n          t.report(n, FUNCTION_MASKS_VARIABLE, functionPrivateName);\n        }\n\n        // TODO(user): Only traverse the function's body. The function's\n        // name and arguments are traversed by the scope creator, and ideally\n        // should not be traversed by the type checker.\n        break;\n    }\n    return true;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "TypeCheck.visit",
    "class_name": "com.google.javascript.jscomp.TypeCheck",
    "signature": "com.google.javascript.jscomp.TypeCheck.visit(NodeTraversal,Node,Node)",
    "snippet": "  public void visit(NodeTraversal t, Node n, Node parent) {\n    JSType childType;\n    JSType leftType, rightType;\n    Node left, right;\n    // To be explicitly set to false if the node is not typeable.\n    boolean typeable = true;\n\n    switch (n.getType()) {\n      case Token.NAME:\n        typeable = visitName(t, n, parent);\n        break;\n\n      case Token.LP:\n        // If this is under a FUNCTION node, it is a parameter list and can be\n        // ignored here.\n        if (parent.getType() != Token.FUNCTION) {\n          ensureTyped(t, n, getJSType(n.getFirstChild()));\n        } else {\n          typeable = false;\n        }\n        break;\n\n      case Token.COMMA:\n        ensureTyped(t, n, getJSType(n.getLastChild()));\n        break;\n\n      case Token.TRUE:\n      case Token.FALSE:\n        ensureTyped(t, n, BOOLEAN_TYPE);\n        break;\n\n      case Token.THIS:\n        ensureTyped(t, n, t.getScope().getTypeOfThis());\n        break;\n\n      case Token.REF_SPECIAL:\n        ensureTyped(t, n);\n        break;\n\n      case Token.GET_REF:\n        ensureTyped(t, n, getJSType(n.getFirstChild()));\n        break;\n\n      case Token.NULL:\n        ensureTyped(t, n, NULL_TYPE);\n        break;\n\n      case Token.NUMBER:\n        if (n.getParent().getType() != Token.OBJECTLIT) {\n          ensureTyped(t, n, NUMBER_TYPE);\n        } else {\n          typeable = false;\n        }\n        break;\n\n      case Token.ARRAYLIT:\n        ensureTyped(t, n, ARRAY_TYPE);\n        break;\n\n      case Token.STRING:\n        if (n.getParent().getType() != Token.OBJECTLIT) {\n          ensureTyped(t, n, STRING_TYPE);\n        } else {\n          typeable = false;\n        }\n        break;\n\n      case Token.REGEXP:\n        ensureTyped(t, n, REGEXP_TYPE);\n        break;\n\n      case Token.GETPROP:\n        visitGetProp(t, n, parent);\n        typeable = !(parent.getType() == Token.ASSIGN &&\n                     parent.getFirstChild() == n);\n        break;\n\n      case Token.GETELEM:\n        visitGetElem(t, n);\n        // The type of GETELEM is always unknown, so no point counting that.\n        // If that unknown leaks elsewhere (say by an assignment to another\n        // variable), then it will be counted.\n        typeable = false;\n        break;\n\n      case Token.VAR:\n        visitVar(t, n);\n        typeable = false;\n        break;\n\n      case Token.NEW:\n        visitNew(t, n);\n        typeable = true;\n        break;\n\n      case Token.CALL:\n        visitCall(t, n);\n        typeable = !NodeUtil.isExpressionNode(parent);\n        break;\n\n      case Token.RETURN:\n        visitReturn(t, n);\n        typeable = false;\n        break;\n\n      case Token.DEC:\n      case Token.INC:\n        left = n.getFirstChild();\n        validator.expectNumber(\n            t, left, getJSType(left), \"increment/decrement\");\n        ensureTyped(t, n, NUMBER_TYPE);\n        break;\n\n      case Token.NOT:\n        ensureTyped(t, n, BOOLEAN_TYPE);\n        break;\n\n      case Token.VOID:\n        ensureTyped(t, n, VOID_TYPE);\n        break;\n\n      case Token.TYPEOF:\n        ensureTyped(t, n, STRING_TYPE);\n        break;\n\n      case Token.BITNOT:\n        childType = getJSType(n.getFirstChild());\n        if (!childType.matchesInt32Context()) {\n          t.report(n, BIT_OPERATION, NodeUtil.opToStr(n.getType()),\n              childType.toString());\n        }\n        ensureTyped(t, n, NUMBER_TYPE);\n        break;\n\n      case Token.POS:\n      case Token.NEG:\n        left = n.getFirstChild();\n        validator.expectNumber(t, left, getJSType(left), \"sign operator\");\n        ensureTyped(t, n, NUMBER_TYPE);\n        break;\n\n      case Token.EQ:\n      case Token.NE: {\n        leftType = getJSType(n.getFirstChild());\n        rightType = getJSType(n.getLastChild());\n\n        JSType leftTypeRestricted = leftType.restrictByNotNullOrUndefined();\n        JSType rightTypeRestricted = rightType.restrictByNotNullOrUndefined();\n        TernaryValue result =\n            leftTypeRestricted.testForEquality(rightTypeRestricted);\n        if (result != TernaryValue.UNKNOWN) {\n          if (n.getType() == Token.NE) {\n            result = result.not();\n          }\n          t.report(n, DETERMINISTIC_TEST, leftType.toString(),\n              rightType.toString(), result.toString());\n        }\n        ensureTyped(t, n, BOOLEAN_TYPE);\n        break;\n      }\n\n      case Token.SHEQ:\n      case Token.SHNE: {\n        leftType = getJSType(n.getFirstChild());\n        rightType = getJSType(n.getLastChild());\n\n        JSType leftTypeRestricted = leftType.restrictByNotNullOrUndefined();\n        JSType rightTypeRestricted = rightType.restrictByNotNullOrUndefined();\n        if (!leftTypeRestricted.canTestForShallowEqualityWith(\n                rightTypeRestricted)) {\n          t.report(n, DETERMINISTIC_TEST_NO_RESULT, leftType.toString(),\n              rightType.toString());\n        }\n        ensureTyped(t, n, BOOLEAN_TYPE);\n        break;\n      }\n\n      case Token.LT:\n      case Token.LE:\n      case Token.GT:\n      case Token.GE:\n        leftType = getJSType(n.getFirstChild());\n        rightType = getJSType(n.getLastChild());\n        if (rightType.isNumber()) {\n          validator.expectNumber(\n              t, n, leftType, \"left side of numeric comparison\");\n        } else if (leftType.isNumber()) {\n          validator.expectNumber(\n              t, n, rightType, \"right side of numeric comparison\");\n        } else if (leftType.matchesNumberContext() &&\n                   rightType.matchesNumberContext()) {\n          // OK.\n        } else {\n          // Whether the comparison is numeric will be determined at runtime\n          // each time the expression is evaluated. Regardless, both operands\n          // should match a string context.\n          String message = \"left side of comparison\";\n          validator.expectString(t, n, leftType, message);\n          validator.expectNotVoid(\n              t, n, leftType, message, getNativeType(STRING_TYPE));\n          message = \"right side of comparison\";\n          validator.expectString(t, n, rightType, message);\n          validator.expectNotVoid(\n              t, n, rightType, message, getNativeType(STRING_TYPE));\n        }\n        ensureTyped(t, n, BOOLEAN_TYPE);\n        break;\n\n      case Token.IN:\n        left = n.getFirstChild();\n        right = n.getLastChild();\n        leftType = getJSType(left);\n        rightType = getJSType(right);\n        validator.expectObject(t, n, rightType, \"'in' requires an object\");\n        validator.expectString(t, left, leftType, \"left side of 'in'\");\n        ensureTyped(t, n, BOOLEAN_TYPE);\n        break;\n\n      case Token.INSTANCEOF:\n        left = n.getFirstChild();\n        right = n.getLastChild();\n        leftType = getJSType(left);\n        rightType = getJSType(right).restrictByNotNullOrUndefined();\n\n        validator.expectAnyObject(\n            t, left, leftType, \"deterministic instanceof yields false\");\n        validator.expectActualObject(\n            t, right, rightType, \"instanceof requires an object\");\n        ensureTyped(t, n, BOOLEAN_TYPE);\n        break;\n\n      case Token.ASSIGN:\n        visitAssign(t, n);\n        typeable = false;\n        break;\n\n      case Token.ASSIGN_LSH:\n      case Token.ASSIGN_RSH:\n      case Token.ASSIGN_URSH:\n      case Token.ASSIGN_DIV:\n      case Token.ASSIGN_MOD:\n      case Token.ASSIGN_BITOR:\n      case Token.ASSIGN_BITXOR:\n      case Token.ASSIGN_BITAND:\n      case Token.ASSIGN_SUB:\n      case Token.ASSIGN_ADD:\n      case Token.ASSIGN_MUL:\n      case Token.LSH:\n      case Token.RSH:\n      case Token.URSH:\n      case Token.DIV:\n      case Token.MOD:\n      case Token.BITOR:\n      case Token.BITXOR:\n      case Token.BITAND:\n      case Token.SUB:\n      case Token.ADD:\n      case Token.MUL:\n        visitBinaryOperator(n.getType(), t, n);\n        break;\n\n      case Token.DELPROP:\n        if (!isReference(n.getFirstChild())) {\n          t.report(n, BAD_DELETE);\n        }\n        ensureTyped(t, n, BOOLEAN_TYPE);\n        break;\n\n      case Token.CASE:\n        JSType switchType = getJSType(parent.getFirstChild());\n        JSType caseType = getJSType(n.getFirstChild());\n        validator.expectSwitchMatchesCase(t, n, switchType, caseType);\n        typeable = false;\n        break;\n\n      case Token.WITH: {\n        Node child = n.getFirstChild();\n        childType = getJSType(child);\n        validator.expectObject(\n            t, child, childType, \"with requires an object\");\n        typeable = false;\n        break;\n      }\n\n      case Token.FUNCTION:\n        visitFunction(t, n);\n        break;\n\n      // These nodes have no interesting type behavior.\n      case Token.LABEL:\n      case Token.SWITCH:\n      case Token.BREAK:\n      case Token.CATCH:\n      case Token.TRY:\n      case Token.SCRIPT:\n      case Token.EXPR_RESULT:\n      case Token.BLOCK:\n      case Token.EMPTY:\n      case Token.DEFAULT:\n      case Token.CONTINUE:\n      case Token.DEBUGGER:\n      case Token.THROW:\n        typeable = false;\n        break;\n\n      // These nodes require data flow analysis.\n      case Token.DO:\n      case Token.FOR:\n      case Token.IF:\n      case Token.WHILE:\n        typeable = false;\n        break;\n\n      // These nodes are typed during the type inference.\n      case Token.AND:\n      case Token.HOOK:\n      case Token.OBJECTLIT:\n      case Token.OR:\n        if (n.getJSType() != null) { // If we didn't run type inference.\n          ensureTyped(t, n);\n        } else {\n          // If this is an enum, then give that type to the objectlit as well.\n          if ((n.getType() == Token.OBJECTLIT)\n              && (parent.getJSType() instanceof EnumType)) {\n            ensureTyped(t, n, parent.getJSType());\n          } else {\n            ensureTyped(t, n);\n          }\n        }\n        break;\n\n      default:\n        t.report(n, UNEXPECTED_TOKEN, Token.name(n.getType()));\n        ensureTyped(t, n);\n        break;\n    }\n\n    // Don't count externs since the user's code may not even use that part.\n    typeable = typeable && !inExterns;\n\n    if (typeable) {\n      doPercentTypedAccounting(t, n);\n    }\n  }",
    "comment": " This is the meat of the type checking.  It is basically one big switch, with each case representing one type of parse tree node.  The individual cases are usually pretty straightforward.  @param t The node traversal object that supplies context, such as the scope chain to use in name lookups as well as error reporting. @param n The node being visited. @param parent The parent of the node n. ",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "TypeCheck.visitFunction",
    "class_name": "com.google.javascript.jscomp.TypeCheck",
    "signature": "com.google.javascript.jscomp.TypeCheck.visitFunction(NodeTraversal,Node)",
    "snippet": "  private void visitFunction(NodeTraversal t, Node n) {\n    JSDocInfo info = n.getJSDocInfo();\n\n    FunctionType functionType = (FunctionType) n.getJSType();\n    String functionPrivateName = n.getFirstChild().getString();\n    if (functionType.isInterface() || functionType.isConstructor()) {\n      FunctionType baseConstructor = functionType.\n          getPrototype().getImplicitPrototype().getConstructor();\n      if (baseConstructor != null &&\n          baseConstructor != getNativeType(OBJECT_FUNCTION_TYPE) &&\n          (baseConstructor.isConstructor() && functionType.isInterface() ||\n           baseConstructor.isInterface() && functionType.isConstructor())) {\n        compiler.report(\n            JSError.make(t, n, CONFLICTING_EXTENDED_TYPE, functionPrivateName));\n      }\n\n      for (JSType baseInterface : functionType.getImplementedInterfaces()) {\n        boolean badImplementedType = false;\n        ObjectType baseInterfaceObj = ObjectType.cast(baseInterface);\n        if (baseInterfaceObj != null) {\n          FunctionType interfaceConstructor =\n              baseInterfaceObj.getConstructor();\n          if (interfaceConstructor != null &&\n              !interfaceConstructor.isInterface()) {\n            badImplementedType = true;\n          }\n        } else {\n          badImplementedType = true;\n        }\n        if (badImplementedType) {\n          t.report(n, BAD_IMPLEMENTED_TYPE, functionPrivateName);\n        }\n      }\n      if (functionType.isConstructor()) {\n        validator.expectAllInterfacePropertiesImplemented(functionType);\n      }\n    }\n  }",
    "comment": " Visits a {@link Token#FUNCTION} node.  @param t The node traversal object that supplies context, such as the scope chain to use in name lookups as well as error reporting. @param n The node being visited. ",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "TypeCheck.visitGetProp",
    "class_name": "com.google.javascript.jscomp.TypeCheck",
    "signature": "com.google.javascript.jscomp.TypeCheck.visitGetProp(NodeTraversal,Node,Node)",
    "snippet": "  private void visitGetProp(NodeTraversal t, Node n, Node parent) {\n    // GETPROP nodes have an assigned type on their node by the scope creator\n    // if this is an enum declaration. The only namespaced enum declarations\n    // that we allow are of the form object.name = ...;\n    if (n.getJSType() != null && parent.getType() == Token.ASSIGN) {\n      return;\n    }\n\n    // obj.prop or obj.method()\n    // Lots of types can appear on the left, a call to a void function can\n    // never be on the left. getPropertyType will decide what is acceptable\n    // and what isn't.\n    Node property = n.getLastChild();\n    Node objNode = n.getFirstChild();\n    JSType childType = getJSType(objNode);\n\n    // TODO(user): remove in favor of flagging every property access on\n    // non-object.\n    if (!validator.expectNotVoid(t, n, childType,\n            \"undefined has no properties\", getNativeType(OBJECT_TYPE))) {\n      ensureTyped(t, n);\n      return;\n    }\n\n    checkPropertyAccess(childType, property.getString(), t, n);\n    ensureTyped(t, n);\n  }",
    "comment": " Visits a GETPROP node.  @param t The node traversal object that supplies context, such as the scope chain to use in name lookups as well as error reporting. @param n The node being visited. @param parent The parent of <code>n</code> ",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "TypeCheck.visitName",
    "class_name": "com.google.javascript.jscomp.TypeCheck",
    "signature": "com.google.javascript.jscomp.TypeCheck.visitName(NodeTraversal,Node,Node)",
    "snippet": "  boolean visitName(NodeTraversal t, Node n, Node parent) {\n    // At this stage, we need to determine whether this is a leaf\n    // node in an expression (which therefore needs to have a type\n    // assigned for it) versus some other decorative node that we\n    // can safely ignore.  Function names, arguments (children of LP nodes) and\n    // variable declarations are ignored.\n    // TODO(user): remove this short-circuiting in favor of a\n    // pre order traversal of the FUNCTION, CATCH, LP and VAR nodes.\n    int parentNodeType = parent.getType();\n    if (parentNodeType == Token.FUNCTION ||\n        parentNodeType == Token.CATCH ||\n        parentNodeType == Token.LP ||\n        parentNodeType == Token.VAR) {\n      return false;\n    }\n\n    JSType type = n.getJSType();\n    if (type == null) {\n      type = getNativeType(UNKNOWN_TYPE);\n      Var var = t.getScope().getVar(n.getString());\n      if (var != null) {\n        JSType varType = var.getType();\n        if (varType != null) {\n          type = varType;\n        }\n      }\n    }\n    ensureTyped(t, n, type);\n    return true;\n  }",
    "comment": " Visits a NAME node.  @param t The node traversal object that supplies context, such as the scope chain to use in name lookups as well as error reporting. @param n The node being visited. @param parent The parent of the node n. @return whether the node is typeable or not ",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "TypeCheck.visitVar",
    "class_name": "com.google.javascript.jscomp.TypeCheck",
    "signature": "com.google.javascript.jscomp.TypeCheck.visitVar(NodeTraversal,Node)",
    "snippet": "  private void visitVar(NodeTraversal t, Node n) {\n    // TODO(nicksantos): Fix this so that the doc info always shows up\n    // on the NAME node. We probably want to wait for the parser\n    // merge to fix this.\n    JSDocInfo varInfo = n.hasOneChild() ? n.getJSDocInfo() : null;\n    for (Node name : n.children()) {\n      Node value = name.getFirstChild();\n      // A null var would indicate a bug in the scope creation logic.\n      Var var = t.getScope().getVar(name.getString());\n\n      if (value != null) {\n        JSType valueType = getJSType(value);\n        JSType nameType = var.getType();\n        nameType = (nameType == null) ? getNativeType(UNKNOWN_TYPE) : nameType;\n\n        JSDocInfo info = name.getJSDocInfo();\n        if (info == null) {\n          info = varInfo;\n        }\n        if (info != null && info.hasEnumParameterType()) {\n          // var.getType() can never be null, this would indicate a bug in the\n          // scope creation logic.\n          checkEnumInitializer(\n              t, value,  info.getEnumParameterType().evaluate(t.getScope()));\n        } else if (var.isTypeInferred()) {\n          ensureTyped(t, name, valueType);\n        } else {\n          validator.expectCanAssignTo(\n              t, value, valueType, nameType, \"initializing variable\");\n        }\n      }\n    }\n  }",
    "comment": " Visits a VAR node.  @param t The node traversal object that supplies context, such as the scope chain to use in name lookups as well as error reporting. @param n The node being visited. ",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "TypeInference.TypeInference",
    "class_name": "com.google.javascript.jscomp.TypeInference",
    "signature": "com.google.javascript.jscomp.TypeInference.TypeInference(AbstractCompiler,ControlFlowGraph,ReverseAbstractInterpreter,Scope,Collection)",
    "snippet": "  TypeInference(AbstractCompiler compiler, ControlFlowGraph<Node> cfg,\n                ReverseAbstractInterpreter reverseInterpreter,\n                Scope functionScope, Collection<Var> unflowableVars) {\n    super(cfg, new LinkedFlowScope.FlowScopeJoinOp());\n    this.compiler = compiler;\n    this.registry = compiler.getTypeRegistry();\n    this.reverseInterpreter = reverseInterpreter;\n    this.syntacticScope = functionScope;\n    this.functionScope = LinkedFlowScope.createEntryLattice(functionScope);\n\n    for (Var unflowableVar : unflowableVars) {\n      String name = unflowableVar.getName();\n      if (functionScope.getVar(name) == unflowableVar) {\n        this.unflowableVarNames.add(name);\n      }\n    }\n\n    Iterator<Var> varIt = functionScope.getVars();\n    while (varIt.hasNext()) {\n      Var var = varIt.next();\n      if (this.unflowableVarNames.contains(var.getName())) {\n        continue;\n      }\n\n      // For each local variable declared with the VAR keyword, the entry\n      // type is VOID.\n      if (var.getParentNode() != null &&\n          var.getType() == null && // no declared type\n          var.getParentNode().getType() == Token.VAR &&\n          !var.isExtern()) {\n        this.functionScope.inferSlotType(\n            var.getName(), getNativeType(VOID_TYPE));\n      }\n    }\n\n    this.bottomScope = LinkedFlowScope.createEntryLattice(\n        new Scope(functionScope.getRootNode(), functionScope.getTypeOfThis()));\n  }",
    "comment": "TODO(nicksantos): Create a builder for this class.",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "TypeInference.branchedFlowThrough",
    "class_name": "com.google.javascript.jscomp.TypeInference",
    "signature": "com.google.javascript.jscomp.TypeInference.branchedFlowThrough(Node,FlowScope)",
    "snippet": "  @Override\n  @SuppressWarnings(\"fallthrough\")\n  List<FlowScope> branchedFlowThrough(Node source, FlowScope input) {\n    // NOTE(nicksantos): Right now, we just treat ON_EX edges like UNCOND\n    // edges. If we wanted to be perfect, we'd actually JOIN all the out\n    // lattices of this flow with the in lattice, and then make that the out\n    // lattice for the ON_EX edge. But it's probably to expensive to be\n    // worthwhile.\n    FlowScope output = flowThrough(source, input);\n    Node condition = null;\n    FlowScope conditionFlowScope = null;\n    BooleanOutcomePair conditionOutcomes = null;\n\n    List<DiGraphEdge<Node, Branch>> branchEdges = getCfg().getOutEdges(source);\n    List<FlowScope> result = Lists.newArrayListWithCapacity(branchEdges.size());\n    for (DiGraphEdge<Node, Branch> branchEdge : branchEdges) {\n      Branch branch = branchEdge.getValue();\n      FlowScope newScope = output;\n\n      switch (branch) {\n        case ON_TRUE:\n          if (NodeUtil.isForIn(source)) {\n            // item is assigned a property name, so its type should be string.\n            Node item = source.getFirstChild();\n            if (item.getType() == Token.VAR) {\n              item = item.getFirstChild();\n            }\n            if (item.getType() == Token.NAME) {\n              FlowScope informed = output.createChildFlowScope();\n              redeclare(informed, item.getString(),\n                  getNativeType(STRING_TYPE));\n              newScope = informed;\n            }\n            break;\n          }\n\n          // FALL THROUGH\n\n        case ON_FALSE:\n          if (condition == null) {\n            condition = NodeUtil.getConditionExpression(source);\n            if (condition == null && source.getType() == Token.CASE) {\n              condition = source;\n\n              // conditionFlowScope is cached from previous iterations\n              // of the loop.\n              if (conditionFlowScope == null) {\n                conditionFlowScope = traverse(\n                    condition.getFirstChild(), output.createChildFlowScope());\n              }\n            }\n          }\n\n          if (condition != null) {\n            if (condition.getType() == Token.AND ||\n                condition.getType() == Token.OR) {\n              // When handling the short-circuiting binary operators,\n              // the outcome scope on true can be different than the outcome\n              // scope on false.\n              //\n              // TODO(nicksantos): The \"right\" way to do this is to\n              // carry the known outcome all the way through the\n              // recursive traversal, so that we can construct a\n              // different flow scope based on the outcome. However,\n              // this would require a bunch of code and a bunch of\n              // extra computation for an edge case. This seems to be\n              // a \"good enough\" approximation.\n\n              // conditionOutcomes is cached from previous iterations\n              // of the loop.\n              if (conditionOutcomes == null) {\n                conditionOutcomes = condition.getType() == Token.AND ?\n                    traverseAnd(condition, output.createChildFlowScope()) :\n                    traverseOr(condition, output.createChildFlowScope());\n              }\n              newScope =\n                  reverseInterpreter.getPreciserScopeKnowingConditionOutcome(\n                      condition,\n                      conditionOutcomes.getOutcomeFlowScope(\n                          condition.getType(), branch == Branch.ON_TRUE),\n                      branch == Branch.ON_TRUE);\n            } else {\n              // conditionFlowScope is cached from previous iterations\n              // of the loop.\n              if (conditionFlowScope == null) {\n                conditionFlowScope =\n                    traverse(condition, output.createChildFlowScope());\n              }\n              newScope =\n                  reverseInterpreter.getPreciserScopeKnowingConditionOutcome(\n                      condition, conditionFlowScope, branch == Branch.ON_TRUE);\n            }\n          }\n          break;\n      }\n\n      result.add(newScope.optimize());\n    }\n    return result;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "TypeInference.createEntryLattice",
    "class_name": "com.google.javascript.jscomp.TypeInference",
    "signature": "com.google.javascript.jscomp.TypeInference.createEntryLattice()",
    "snippet": "  @Override\n  FlowScope createEntryLattice() {\n    return functionScope;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "TypeInference.createInitialEstimateLattice",
    "class_name": "com.google.javascript.jscomp.TypeInference",
    "signature": "com.google.javascript.jscomp.TypeInference.createInitialEstimateLattice()",
    "snippet": "  @Override\n  FlowScope createInitialEstimateLattice() {\n    return bottomScope;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "TypeInference.dereferencePointer",
    "class_name": "com.google.javascript.jscomp.TypeInference",
    "signature": "com.google.javascript.jscomp.TypeInference.dereferencePointer(Node,FlowScope)",
    "snippet": "  private FlowScope dereferencePointer(Node n, FlowScope scope) {\n    if (n.getType() == Token.NAME) {\n      JSType type = getJSType(n);\n      JSType narrowed = type.restrictByNotNullOrUndefined();\n      if (type != narrowed) {\n        scope = scope.createChildFlowScope();\n        redeclare(scope, n.getString(), narrowed);\n      }\n    }\n    return scope;\n  }",
    "comment": " If we access a property of a symbol, then that symbol is not null or undefined. ",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "TypeInference.ensurePropertyDeclared",
    "class_name": "com.google.javascript.jscomp.TypeInference",
    "signature": "com.google.javascript.jscomp.TypeInference.ensurePropertyDeclared(Node)",
    "snippet": "  private void ensurePropertyDeclared(Node getprop) {\n    ObjectType ownerType = ObjectType.cast(\n        getJSType(getprop.getFirstChild()).restrictByNotNullOrUndefined());\n    if (ownerType != null) {\n      ensurePropertyDeclaredHelper(getprop, ownerType);\n    }\n  }",
    "comment": " Defines a declared property if it has not been defined yet.  This handles the case where a property is declared on an object where the object type is inferred, and so the object type will not be known in {@code TypedScopeCreator}. ",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "TypeInference.ensurePropertyDeclaredHelper",
    "class_name": "com.google.javascript.jscomp.TypeInference",
    "signature": "com.google.javascript.jscomp.TypeInference.ensurePropertyDeclaredHelper(Node,ObjectType)",
    "snippet": "  private boolean ensurePropertyDeclaredHelper(\n      Node getprop, ObjectType objectType) {\n    String propName = getprop.getLastChild().getString();\n    String qName = getprop.getQualifiedName();\n    if (qName != null) {\n      Var var = syntacticScope.getVar(qName);\n      if (var != null && !var.isTypeInferred()) {\n        // Handle normal declarations that could not be addressed earlier.\n        if (propName.equals(\"prototype\") ||\n        // Handle prototype declarations that could not be addressed earlier.\n            (!objectType.hasOwnProperty(propName) &&\n             (!objectType.isInstanceType() ||\n                 (var.isExtern() && !objectType.isNativeObjectType())))) {\n          return objectType.defineDeclaredProperty(\n              propName, var.getType(), var.isExtern());\n        }\n      }\n    }\n    return false;\n  }",
    "comment": " Declares a property on its owner, if necessary. @return True if a property was declared. ",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "TypeInference.flowThrough",
    "class_name": "com.google.javascript.jscomp.TypeInference",
    "signature": "com.google.javascript.jscomp.TypeInference.flowThrough(Node,FlowScope)",
    "snippet": "  @Override\n  FlowScope flowThrough(Node n, FlowScope input) {\n    // If we have not walked a path from <entry> to <n>, then we don't\n    // want to infer anything about this scope.\n    if (input == bottomScope) {\n      return input;\n    }\n\n    FlowScope output = input.createChildFlowScope();\n    output = traverse(n, output);\n    return output;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "TypeInference.getAssignedOuterLocalVars",
    "class_name": "com.google.javascript.jscomp.TypeInference",
    "signature": "com.google.javascript.jscomp.TypeInference.getAssignedOuterLocalVars()",
    "snippet": "  Multimap<Scope, Var> getAssignedOuterLocalVars() {\n    return assignedOuterLocalVars;\n  }",
    "comment": " @return Local variables assigned in this scope, but which are declared in a scope outside of it. Hashed by the scope they're declared in. ",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "TypeInference.getJSType",
    "class_name": "com.google.javascript.jscomp.TypeInference",
    "signature": "com.google.javascript.jscomp.TypeInference.getJSType(Node)",
    "snippet": "  private JSType getJSType(Node n) {\n    JSType jsType = n.getJSType();\n    if (jsType == null) {\n      // TODO(nicksantos): This branch indicates a compiler bug, not worthy of\n      // halting the compilation but we should log this and analyze to track\n      // down why it happens. This is not critical and will be resolved over\n      // time as the type checker is extended.\n      return getNativeType(UNKNOWN_TYPE);\n    } else {\n      return jsType;\n    }\n  }",
    "comment": " This method gets the JSType from the Node argument and verifies that it is present. ",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "TypeInference.getNativeType",
    "class_name": "com.google.javascript.jscomp.TypeInference",
    "signature": "com.google.javascript.jscomp.TypeInference.getNativeType(JSTypeNative)",
    "snippet": "  private JSType getNativeType(JSTypeNative typeId) {\n    return registry.getNativeType(typeId);\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "TypeInference.getPropertyType",
    "class_name": "com.google.javascript.jscomp.TypeInference",
    "signature": "com.google.javascript.jscomp.TypeInference.getPropertyType(JSType,String,Node,FlowScope)",
    "snippet": "  private JSType getPropertyType(JSType objType, String propName,\n      Node n, FlowScope scope) {\n    // Scopes sometimes contain inferred type info about qualified names.\n    String qualifiedName = n.getQualifiedName();\n    StaticSlot<JSType> var = scope.getSlot(qualifiedName);\n    if (var != null) {\n      JSType varType = var.getType();\n      if (varType != null) {\n        if (varType.equals(getNativeType(UNKNOWN_TYPE)) &&\n            var != syntacticScope.getSlot(qualifiedName)) {\n          // If the type of this qualified name has been checked in this scope,\n          // then use CHECKED_UNKNOWN_TYPE instead to indicate that.\n          return getNativeType(CHECKED_UNKNOWN_TYPE);\n        } else {\n          return varType;\n        }\n      }\n    }\n\n    JSType propertyType = null;\n    if (objType != null) {\n      propertyType = objType.findPropertyType(propName);\n    }\n\n    if ((propertyType == null || propertyType.isUnknownType()) &&\n        qualifiedName != null) {\n      // If we find this node in the registry, then we can infer its type.\n      ObjectType regType = ObjectType.cast(registry.getType(qualifiedName));\n      if (regType != null) {\n        propertyType = regType.getConstructor();\n      }\n    }\n\n    return propertyType;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "TypeInference.redeclare",
    "class_name": "com.google.javascript.jscomp.TypeInference",
    "signature": "com.google.javascript.jscomp.TypeInference.redeclare(FlowScope,String,JSType)",
    "snippet": "  private void redeclare(FlowScope scope, String varName, JSType varType) {\n    if (varType == null) {\n      varType = getNativeType(JSTypeNative.UNKNOWN_TYPE);\n    }\n    if (unflowableVarNames.contains(varName)) {\n      return;\n    }\n    scope.inferSlotType(varName, varType);\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "TypeInference.traverse",
    "class_name": "com.google.javascript.jscomp.TypeInference",
    "signature": "com.google.javascript.jscomp.TypeInference.traverse(Node,FlowScope)",
    "snippet": "  private FlowScope traverse(Node n, FlowScope scope) {\n    switch (n.getType()) {\n      case Token.ASSIGN:\n        scope = traverseAssign(n, scope);\n        break;\n\n      case Token.NAME:\n        scope = traverseName(n, scope);\n        break;\n\n      case Token.GETPROP:\n        scope = traverseGetProp(n, scope);\n        break;\n\n      case Token.AND:\n        scope = traverseAnd(n, scope).getJoinedFlowScope()\n            .createChildFlowScope();\n        break;\n\n      case Token.OR:\n        scope = traverseOr(n, scope).getJoinedFlowScope()\n            .createChildFlowScope();\n        break;\n\n      case Token.HOOK:\n        scope = traverseHook(n, scope);\n        break;\n\n      case Token.OBJECTLIT:\n        scope = traverseObjectLiteral(n, scope);\n        break;\n\n      case Token.CALL:\n        scope = traverseCall(n, scope);\n        break;\n\n      case Token.NEW:\n        scope = traverseNew(n, scope);\n        break;\n\n      case Token.ASSIGN_ADD:\n      case Token.ADD:\n        scope = traverseAdd(n, scope);\n        break;\n\n      case Token.POS:\n      case Token.NEG:\n        scope = traverse(n.getFirstChild(), scope);  // Find types.\n        n.setJSType(getNativeType(NUMBER_TYPE));\n        break;\n\n      case Token.NULL:\n        n.setJSType(getNativeType(NULL_TYPE));\n        break;\n\n      case Token.VOID:\n        n.setJSType(getNativeType(VOID_TYPE));\n        break;\n\n      case Token.ARRAYLIT:\n        scope = traverseArrayLiteral(n, scope);\n        break;\n\n      case Token.REF_SPECIAL:\n        n.setJSType(getNativeType(UNKNOWN_TYPE));\n        break;\n\n      case Token.REGEXP:\n        n.setJSType(getNativeType(REGEXP_TYPE));\n        break;\n\n      case Token.THIS:\n        n.setJSType(scope.getTypeOfThis());\n        break;\n\n      case Token.ASSIGN_LSH:\n      case Token.ASSIGN_RSH:\n      case Token.LSH:\n      case Token.RSH:\n      case Token.ASSIGN_URSH:\n      case Token.URSH:\n      case Token.ASSIGN_DIV:\n      case Token.ASSIGN_MOD:\n      case Token.ASSIGN_BITAND:\n      case Token.ASSIGN_BITXOR:\n      case Token.ASSIGN_BITOR:\n      case Token.ASSIGN_MUL:\n      case Token.ASSIGN_SUB:\n      case Token.DIV:\n      case Token.MOD:\n      case Token.BITAND:\n      case Token.BITXOR:\n      case Token.BITOR:\n      case Token.MUL:\n      case Token.SUB:\n      case Token.DEC:\n      case Token.INC:\n      case Token.BITNOT:\n      case Token.NUMBER:\n        scope = traverseChildren(n, scope);\n        n.setJSType(getNativeType(NUMBER_TYPE));\n        break;\n\n      case Token.LP:\n      case Token.GET_REF:\n        scope = traverse(n.getFirstChild(), scope);\n        n.setJSType(getJSType(n.getFirstChild()));\n        break;\n\n      case Token.COMMA:\n        scope = traverseChildren(n, scope);\n        n.setJSType(getJSType(n.getLastChild()));\n        break;\n\n      case Token.STRING:\n      case Token.TYPEOF:\n        scope = traverseChildren(n, scope);\n        n.setJSType(getNativeType(STRING_TYPE));\n        break;\n\n      case Token.LT:\n      case Token.LE:\n      case Token.GT:\n      case Token.GE:\n      case Token.NOT:\n      case Token.EQ:\n      case Token.NE:\n      case Token.SHEQ:\n      case Token.SHNE:\n      case Token.INSTANCEOF:\n      case Token.IN:\n      case Token.TRUE:\n      case Token.FALSE:\n        scope = traverseChildren(n, scope);\n        n.setJSType(getNativeType(BOOLEAN_TYPE));\n        break;\n\n      case Token.GETELEM:\n        scope = traverseGetElem(n, scope);\n        break;\n\n      case Token.EXPR_RESULT:\n        scope = traverseChildren(n, scope);\n        if (n.getFirstChild().getType() == Token.GETPROP) {\n          ensurePropertyDeclared(n.getFirstChild());\n        }\n        break;\n\n      case Token.SWITCH:\n        scope = traverse(n.getFirstChild(), scope);\n        break;\n\n      case Token.VAR:\n      case Token.RETURN:\n      case Token.THROW:\n        scope = traverseChildren(n, scope);\n        break;\n\n      case Token.CATCH:\n        scope = traverseCatch(n, scope);\n        break;\n    }\n    if (n.getType() != Token.FUNCTION) {\n      JSDocInfo info = n.getJSDocInfo();\n      if (info != null && info.hasType()) {\n        JSType castType = info.getType().evaluate(syntacticScope);\n\n        // A stubbed type cast on a qualified name should take\n        // effect for all subsequent accesses of that name,\n        // so treat it the same as an assign to that name.\n        if (n.isQualifiedName() &&\n            n.getParent().getType() == Token.EXPR_RESULT) {\n          updateScopeForTypeChange(scope, n, n.getJSType(), castType);\n        }\n\n        n.setJSType(castType);\n      }\n    }\n\n    return scope;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "TypeInference.traverseChildren",
    "class_name": "com.google.javascript.jscomp.TypeInference",
    "signature": "com.google.javascript.jscomp.TypeInference.traverseChildren(Node,FlowScope)",
    "snippet": "  private FlowScope traverseChildren(Node n, FlowScope scope) {\n    for (Node el = n.getFirstChild(); el != null; el = el.getNext()) {\n      scope = traverse(el, scope);\n    }\n    return scope;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "TypeInference.traverseGetProp",
    "class_name": "com.google.javascript.jscomp.TypeInference",
    "signature": "com.google.javascript.jscomp.TypeInference.traverseGetProp(Node,FlowScope)",
    "snippet": "  private FlowScope traverseGetProp(Node n, FlowScope scope) {\n    Node objNode = n.getFirstChild();\n    Node property = n.getLastChild();\n    scope = traverseChildren(n, scope);\n    n.setJSType(\n        getPropertyType(\n            objNode.getJSType(), property.getString(), n, scope));\n    return dereferencePointer(n.getFirstChild(), scope);\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "TypeInference.traverseName",
    "class_name": "com.google.javascript.jscomp.TypeInference",
    "signature": "com.google.javascript.jscomp.TypeInference.traverseName(Node,FlowScope)",
    "snippet": "  private FlowScope traverseName(Node n, FlowScope scope) {\n    String varName = n.getString();\n    Node value = n.getFirstChild();\n    JSType type = n.getJSType();\n    if (value != null) {\n      scope = traverse(value, scope);\n      updateScopeForTypeChange(scope, n, n.getJSType() /* could be null */,\n         getJSType(value));\n      return scope;\n    } else {\n      StaticSlot<JSType> var = scope.getSlot(varName);\n      if (var != null &&\n          !(var.isTypeInferred() && unflowableVarNames.contains(varName))) {\n        type = var.getType();\n        if (type == null) {\n          type = getNativeType(UNKNOWN_TYPE);\n        }\n      }\n    }\n    n.setJSType(type);\n    return scope;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "TypeInference.updateScopeForTypeChange",
    "class_name": "com.google.javascript.jscomp.TypeInference",
    "signature": "com.google.javascript.jscomp.TypeInference.updateScopeForTypeChange(FlowScope,Node,JSType,JSType)",
    "snippet": "  private void updateScopeForTypeChange(\n      FlowScope scope, Node left, JSType leftType, JSType resultType) {\n    Preconditions.checkNotNull(resultType);\n    switch (left.getType()) {\n      case Token.NAME:\n        String varName = left.getString();\n        Var var = syntacticScope.getVar(varName);\n        if (var != null && var.isLocal() && var.getScope() != syntacticScope) {\n          assignedOuterLocalVars.put(var.getScope(), var);\n        }\n\n        // When looking at VAR initializers for declared VARs, we trust\n        // the declared type over the type it's being initialized to.\n        // This has two purposes:\n        // 1) We avoid re-declaring declared variables so that built-in\n        //    types defined in externs are not redeclared.\n        // 2) When there's a lexical closure like\n        //    /** @type {?string} */ var x = null;\n        //    function f() { x = 'xyz'; }\n        //    the inference will ignore the lexical closure,\n        //    which is just wrong. This bug needs to be fixed eventually.\n        boolean isVarDeclaration = left.hasChildren();\n        if (!isVarDeclaration || var == null || var.isTypeInferred()) {\n          redeclare(scope, varName, resultType);\n        }\n        left.setJSType(isVarDeclaration || leftType == null ?\n            resultType : null);\n\n        if (var != null && var.isTypeInferred()) {\n          JSType oldType = var.getType();\n          var.setType(oldType == null ?\n              resultType : oldType.getLeastSupertype(resultType));\n        }\n        break;\n      case Token.GETPROP:\n        String qualifiedName = left.getQualifiedName();\n        if (qualifiedName != null) {\n          scope.inferQualifiedSlot(qualifiedName,\n              leftType == null ? getNativeType(UNKNOWN_TYPE) : leftType,\n              resultType);\n        }\n\n        left.setJSType(resultType);\n        ensurePropertyDefined(left, resultType);\n        break;\n    }\n  }",
    "comment": " Updates the scope according to the result of a type change, like an assignment or a type cast. ",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "TypeInferencePass.TypeInferencePass",
    "class_name": "com.google.javascript.jscomp.TypeInferencePass",
    "signature": "com.google.javascript.jscomp.TypeInferencePass.TypeInferencePass(AbstractCompiler,ReverseAbstractInterpreter,Scope,ScopeCreator)",
    "snippet": "  TypeInferencePass(AbstractCompiler compiler,\n      ReverseAbstractInterpreter reverseInterpreter,\n      Scope topScope, ScopeCreator scopeCreator) {\n    this.compiler = compiler;\n    this.reverseInterpreter = reverseInterpreter;\n    this.topScope = topScope;\n    this.scopeCreator = scopeCreator;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "TypeInferencePass.computeCfg",
    "class_name": "com.google.javascript.jscomp.TypeInferencePass",
    "signature": "com.google.javascript.jscomp.TypeInferencePass.computeCfg(Node)",
    "snippet": "  private ControlFlowGraph<Node> computeCfg(Node n) {\n    ControlFlowAnalysis cfa = new ControlFlowAnalysis(compiler, false);\n    cfa.process(null, n);\n    return cfa.getCfg();\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "TypeInferencePass.getUnflowableVars",
    "class_name": "com.google.javascript.jscomp.TypeInferencePass",
    "signature": "com.google.javascript.jscomp.TypeInferencePass.getUnflowableVars(Scope)",
    "snippet": "  private Collection<Var> getUnflowableVars(Scope scope) {\n    List<Var> vars = Lists.newArrayList();\n    for (Scope current = scope;\n         current.isLocal(); current = current.getParent()) {\n      vars.addAll(escapedLocalVars.get(current));\n    }\n    return vars;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "TypeInferencePass.inferTypes",
    "class_name": "com.google.javascript.jscomp.TypeInferencePass",
    "signature": "com.google.javascript.jscomp.TypeInferencePass.inferTypes(Node)",
    "snippet": "  void inferTypes(Node node) {\n    NodeTraversal inferTypes = new NodeTraversal(\n        compiler, new TypeInferringCallback(), scopeCreator);\n    inferTypes.traverseWithScope(node, topScope);\n  }",
    "comment": "Entry point for type inference when running over part of the tree. */",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "TypeInferencePass.inferTypes",
    "class_name": "com.google.javascript.jscomp.TypeInferencePass",
    "signature": "com.google.javascript.jscomp.TypeInferencePass.inferTypes(NodeTraversal,Node,Scope)",
    "snippet": "  void inferTypes(NodeTraversal t, Node n, Scope scope) {\n    TypeInference typeInference =\n        new TypeInference(\n            compiler, computeCfg(n), reverseInterpreter, scope,\n            getUnflowableVars(scope));\n    try {\n      typeInference.analyze();\n      escapedLocalVars.putAll(typeInference.getAssignedOuterLocalVars());\n\n      // Resolve any new type names found during the inference.\n      compiler.getTypeRegistry().resolveTypesInScope(scope);\n\n    } catch (DataFlowAnalysis.MaxIterationsExceededException e) {\n      compiler.report(JSError.make(t, n, DATAFLOW_ERROR));\n    }\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "TypeInferencePass.process",
    "class_name": "com.google.javascript.jscomp.TypeInferencePass",
    "signature": "com.google.javascript.jscomp.TypeInferencePass.process(Node,Node)",
    "snippet": "  public void process(Node externsRoot, Node jsRoot) {\n    Node externsAndJs = jsRoot.getParent();\n    Preconditions.checkState(externsAndJs != null);\n    Preconditions.checkState(\n        externsRoot == null || externsAndJs.hasChild(externsRoot));\n\n    inferTypes(externsAndJs);\n  }",
    "comment": " Main entry point for type inference when running over the whole tree.  @param externsRoot The root of the externs parse tree. @param jsRoot The root of the input parse tree to be checked. ",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "TypeInferringCallback.enterScope",
    "class_name": "com.google.javascript.jscomp.TypeInferencePass$TypeInferringCallback",
    "signature": "com.google.javascript.jscomp.TypeInferencePass$TypeInferringCallback.enterScope(NodeTraversal)",
    "snippet": "    public void enterScope(NodeTraversal t) {\n      Scope scope = t.getScope();\n      Node node = t.getCurrentNode();\n      if (scope.isGlobal()) {\n        inferTypes(t, node, scope);\n      }\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "TypeInferringCallback.exitScope",
    "class_name": "com.google.javascript.jscomp.TypeInferencePass$TypeInferringCallback",
    "signature": "com.google.javascript.jscomp.TypeInferencePass$TypeInferringCallback.exitScope(NodeTraversal)",
    "snippet": "    public void exitScope(NodeTraversal t) {\n      Scope scope = t.getScope();\n      Node node = t.getCurrentNode();\n      if (scope.isLocal()) {\n        inferTypes(t, node, scope);\n      }\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "TypeInferringCallback.shouldTraverse",
    "class_name": "com.google.javascript.jscomp.TypeInferencePass$TypeInferringCallback",
    "signature": "com.google.javascript.jscomp.TypeInferencePass$TypeInferringCallback.shouldTraverse(NodeTraversal,Node,Node)",
    "snippet": "    public boolean shouldTraverse(NodeTraversal t, Node n, Node parent) {\n      return true;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "TypeInferringCallback.visit",
    "class_name": "com.google.javascript.jscomp.TypeInferencePass$TypeInferringCallback",
    "signature": "com.google.javascript.jscomp.TypeInferencePass$TypeInferringCallback.visit(NodeTraversal,Node,Node)",
    "snippet": "    public void visit(NodeTraversal t, Node n, Node parent) {\n      // Do nothing\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "TypeValidator.TypeValidator",
    "class_name": "com.google.javascript.jscomp.TypeValidator",
    "signature": "com.google.javascript.jscomp.TypeValidator.TypeValidator(AbstractCompiler)",
    "snippet": "  TypeValidator(AbstractCompiler compiler) {\n    this.compiler = compiler;\n    this.typeRegistry = compiler.getTypeRegistry();\n    this.allValueTypes = typeRegistry.createUnionType(\n        STRING_TYPE, NUMBER_TYPE, BOOLEAN_TYPE, NULL_TYPE, VOID_TYPE);\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "TypedScopeCreator.TypedScopeCreator",
    "class_name": "com.google.javascript.jscomp.TypedScopeCreator",
    "signature": "com.google.javascript.jscomp.TypedScopeCreator.TypedScopeCreator(AbstractCompiler)",
    "snippet": "  TypedScopeCreator(AbstractCompiler compiler) {\n    this(compiler, compiler.getCodingConvention());\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "TypedScopeCreator.TypedScopeCreator",
    "class_name": "com.google.javascript.jscomp.TypedScopeCreator",
    "signature": "com.google.javascript.jscomp.TypedScopeCreator.TypedScopeCreator(AbstractCompiler,CodingConvention)",
    "snippet": "  TypedScopeCreator(AbstractCompiler compiler,\n      CodingConvention codingConvention) {\n    this.compiler = compiler;\n    this.validator = compiler.getTypeValidator();\n    this.codingConvention = codingConvention;\n    this.typeRegistry = compiler.getTypeRegistry();\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "TypedScopeCreator.createInitialScope",
    "class_name": "com.google.javascript.jscomp.TypedScopeCreator",
    "signature": "com.google.javascript.jscomp.TypedScopeCreator.createInitialScope(Node)",
    "snippet": "  @VisibleForTesting\n  Scope createInitialScope(Node root) {\n    Scope s = new Scope(root, compiler);\n    declareNativeFunctionType(s, ARRAY_FUNCTION_TYPE);\n    declareNativeFunctionType(s, BOOLEAN_OBJECT_FUNCTION_TYPE);\n    declareNativeFunctionType(s, DATE_FUNCTION_TYPE);\n    declareNativeFunctionType(s, ERROR_FUNCTION_TYPE);\n    declareNativeFunctionType(s, EVAL_ERROR_FUNCTION_TYPE);\n    declareNativeFunctionType(s, FUNCTION_FUNCTION_TYPE);\n    declareNativeFunctionType(s, NUMBER_OBJECT_FUNCTION_TYPE);\n    declareNativeFunctionType(s, OBJECT_FUNCTION_TYPE);\n    declareNativeFunctionType(s, RANGE_ERROR_FUNCTION_TYPE);\n    declareNativeFunctionType(s, REFERENCE_ERROR_FUNCTION_TYPE);\n    declareNativeFunctionType(s, REGEXP_FUNCTION_TYPE);\n    declareNativeFunctionType(s, STRING_OBJECT_FUNCTION_TYPE);\n    declareNativeFunctionType(s, SYNTAX_ERROR_FUNCTION_TYPE);\n    declareNativeFunctionType(s, TYPE_ERROR_FUNCTION_TYPE);\n    declareNativeFunctionType(s, URI_ERROR_FUNCTION_TYPE);\n    declareNativeValueType(s, \"undefined\", VOID_TYPE);\n\n    // The typedef construct needs the any type, so that it can be assigned\n    // to anything. This is kind of a hack, and an artifact of the typedef\n    // syntax we've chosen.\n    declareNativeValueType(s, \"goog.typedef\", NO_TYPE);\n\n    // ActiveXObject is unqiuely special, because it can be used to construct\n    // any type (the type that it creates is related to the arguments you\n    // pass to it).\n    declareNativeValueType(s, \"ActiveXObject\", NO_OBJECT_TYPE);\n\n    return s;\n  }",
    "comment": " Create the outermost scope. This scope contains native binding such as {@code Object}, {@code Date}, etc. ",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "TypedScopeCreator.createScope",
    "class_name": "com.google.javascript.jscomp.TypedScopeCreator",
    "signature": "com.google.javascript.jscomp.TypedScopeCreator.createScope(Node,Scope)",
    "snippet": "  public Scope createScope(Node root, Scope parent) {\n    // Constructing the global scope is very different than constructing\n    // inner scopes, because only global scopes can contain named classes that\n    // show up in the type registry.\n    Scope newScope = null;\n    if (parent == null) {\n      // Find all the classes in the global scope.\n      newScope = createInitialScope(root);\n\n      GlobalScopeBuilder scopeBuilder = new GlobalScopeBuilder(newScope);\n      NodeTraversal.traverse(compiler, root, scopeBuilder);\n      scopeBuilder.resolveStubDeclarations();\n\n      // Gather the properties in each function that we found in the\n      // global scope, if that function has a @this type that we can\n      // build properties on.\n      for (Node functionNode : scopeBuilder.nonExternFunctions) {\n        JSType type = functionNode.getJSType();\n        if (type != null && type instanceof FunctionType) {\n          FunctionType fnType = (FunctionType) type;\n          ObjectType fnThisType = fnType.getTypeOfThis();\n          if (!fnThisType.isUnknownType()) {\n            NodeTraversal.traverse(compiler, functionNode.getLastChild(),\n                scopeBuilder.new CollectProperties(fnThisType));\n          }\n        }\n      }\n\n      codingConvention.defineDelegateProxyProperties(\n          typeRegistry, newScope, delegateProxyMap);\n    } else {\n      newScope = new Scope(parent, root);\n      (new LocalScopeBuilder(newScope)).build();\n    }\n    typeRegistry.resolveTypesInScope(newScope);\n    return newScope;\n  }",
    "comment": " Creates a scope with all types declared. Declares newly discovered types and type properties in the type registry. ",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "TypedScopeCreator.declareNativeFunctionType",
    "class_name": "com.google.javascript.jscomp.TypedScopeCreator",
    "signature": "com.google.javascript.jscomp.TypedScopeCreator.declareNativeFunctionType(Scope,JSTypeNative)",
    "snippet": "  private void declareNativeFunctionType(Scope scope, JSTypeNative tId) {\n    FunctionType t = typeRegistry.getNativeFunctionType(tId);\n    declareNativeType(scope, t.getInstanceType().getReferenceName(), t);\n    declareNativeType(\n        scope, t.getPrototype().getReferenceName(), t.getPrototype());\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "TypedScopeCreator.declareNativeType",
    "class_name": "com.google.javascript.jscomp.TypedScopeCreator",
    "signature": "com.google.javascript.jscomp.TypedScopeCreator.declareNativeType(Scope,String,JSType)",
    "snippet": "  private void declareNativeType(Scope scope, String name, JSType t) {\n    scope.declare(name, null, t, null, false);\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "TypedScopeCreator.declareNativeValueType",
    "class_name": "com.google.javascript.jscomp.TypedScopeCreator",
    "signature": "com.google.javascript.jscomp.TypedScopeCreator.declareNativeValueType(Scope,String,JSTypeNative)",
    "snippet": "  private void declareNativeValueType(Scope scope, String name,\n      JSTypeNative tId) {\n    declareNativeType(scope, name, typeRegistry.getNativeType(tId));\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "AbstractScopeBuilder.define",
    "class_name": "com.google.javascript.jscomp.TypedScopeCreator$AbstractScopeBuilder",
    "signature": "com.google.javascript.jscomp.TypedScopeCreator$AbstractScopeBuilder.define(Node,Node)",
    "snippet": "    void define(Node n, Node parent) {\n      Preconditions.checkState(sourceName != null);\n\n      JSDocInfo info = n.getJSDocInfo();\n      switch (n.getType()) {\n        case Token.CATCH:\n          Node catchName = n.getFirstChild();\n          defineSlot(catchName, n, null);\n          break;\n\n        case Token.VAR:\n          if (n.getChildCount() > 1) {\n            if (info != null) {\n              // multiple children\n              compiler.report(JSError.make(sourceName, n, MULTIPLE_VAR_DEF));\n            }\n            for (Node name : n.children()) {\n              defineName(name, n, parent, name.getJSDocInfo());\n            }\n          } else {\n            Node name = n.getFirstChild();\n            defineName(name, n, parent,\n                (info != null) ? info : name.getJSDocInfo());\n          }\n          break;\n\n        case Token.FUNCTION:\n          int parentType = parent.getType();\n          Preconditions.checkState(\n              (scope.isLocal() || parentType != Token.ASSIGN) &&\n              parentType != Token.NAME,\n              \"function defined as standalone function when it is being \" +\n              \"assigned\");\n          String functionName = n.getFirstChild().getString();\n          FunctionType functionType = getFunctionType(functionName, n, info,\n              null);\n          if (NodeUtil.isFunctionDeclaration(n)) {\n            defineSlot(n.getFirstChild(), n, functionType);\n          }\n          break;\n\n        case Token.ASSIGN:\n          // TODO(nicksantos): We should support direct assignment to a\n          // prototype, as in:\n          // Foo.prototype = {\n          //   a: function() { ... },\n          //   b: function() { ... }\n          // };\n          // Right now (6/23/08), we understand most of this syntax, but we\n          // don't tie the \"a\" and \"b\" methods to the context of Foo.\n\n          Node rvalue = n.getLastChild();\n          Node lvalue = n.getFirstChild();\n          info = (info != null) ? info : rvalue.getJSDocInfo();\n          if (rvalue.getType() == Token.FUNCTION ||\n              info != null && info.isConstructor()) {\n            getFunctionType(lvalue.getQualifiedName(), rvalue, info,\n                lvalue);\n          } else if (info != null && info.hasEnumParameterType()) {\n            lvalue.setJSType(\n                getEnumType(lvalue.getQualifiedName(), n, rvalue,\n                    info.getEnumParameterType().evaluate(scope)));\n          }\n          break;\n\n        default:\n          throw new IllegalStateException(Integer.toString(n.getType()));\n      }\n    }",
    "comment": " Defines variable(s) or modifies types based on the content of the node {@code n}. A variable definition creates variables in the current scope, a function definition creates a binding, and an assignment updates the type of the namespaces on which the definition is made (e.g. {@code goog.FOO = 6}). @param n a {@link Token#VAR}, {@link Token#FUNCTION} or {@link Token#ASSIGN} node @param parent {@code n}'s parent ",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "AbstractScopeBuilder.defineName",
    "class_name": "com.google.javascript.jscomp.TypedScopeCreator$AbstractScopeBuilder",
    "signature": "com.google.javascript.jscomp.TypedScopeCreator$AbstractScopeBuilder.defineName(Node,Node,Node,JSDocInfo)",
    "snippet": "    private void defineName(Node name, Node var, Node parent, JSDocInfo info) {\n      Node value = name.getFirstChild();\n\n      if (value != null && value.getType() == Token.FUNCTION) {\n        // function\n        String functionName = name.getString();\n        FunctionType functionType =\n            getFunctionType(functionName, value, info, null);\n        defineSlot(name, var, functionType);\n      } else {\n        // variable's type\n        JSType type = null;\n        if (info == null) {\n          // the variable's type will be inferred\n          CompilerInput input = compiler.getInput(sourceName);\n          Preconditions.checkNotNull(input, sourceName);\n          type = input.isExtern() ?\n              typeRegistry.getNativeType(UNKNOWN_TYPE) : null;\n        } else if (info.hasEnumParameterType()) {\n          type = getEnumType(name.getString(), var, value,\n              info.getEnumParameterType().evaluate(scope));\n        } else if (info.isConstructor()) {\n          type = getFunctionType(name.getString(), value, info, name);\n        } else {\n          type = getDeclaredTypeInAnnotation(sourceName, name, info);\n        }\n\n        defineSlot(name, var, type);\n      }\n    }",
    "comment": " Defines a variable based on the {@link Token#NAME} node passed. @param name The {@link Token#NAME} node. @param var The parent of the {@code name} node, which must be a {@link Token#VAR} node. @param parent {@code var}'s parent. @param info the {@link JSDocInfo} information relating to this {@code name} node. ",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "AbstractScopeBuilder.defineSlot",
    "class_name": "com.google.javascript.jscomp.TypedScopeCreator$AbstractScopeBuilder",
    "signature": "com.google.javascript.jscomp.TypedScopeCreator$AbstractScopeBuilder.defineSlot(Node,Node,JSType)",
    "snippet": "    private void defineSlot(Node name, Node parent, JSType type) {\n      defineSlot(name, parent, type, type == null);\n    }",
    "comment": " Defines a typed variable. The defining node will be annotated with the variable's type or {@code null} if its type is inferred. @param name the defining node. It must be a {@link Token#NAME}. @param parent the {@code name}'s parent. @param type the variable's type. It may be {@code null}, in which case the variable's type will be inferred. ",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "AbstractScopeBuilder.defineSlot",
    "class_name": "com.google.javascript.jscomp.TypedScopeCreator$AbstractScopeBuilder",
    "signature": "com.google.javascript.jscomp.TypedScopeCreator$AbstractScopeBuilder.defineSlot(Node,Node,JSType,boolean)",
    "snippet": "    void defineSlot(Node n, Node parent, JSType type, boolean inferred) {\n      Preconditions.checkArgument(inferred || type != null);\n\n      // Only allow declarations of NAMEs and qualfied names.\n      boolean shouldDeclareOnGlobalThis = false;\n      if (n.getType() == Token.NAME) {\n        Preconditions.checkArgument(\n            parent.getType() == Token.FUNCTION ||\n            parent.getType() == Token.VAR ||\n            parent.getType() == Token.LP ||\n            parent.getType() == Token.CATCH);\n        shouldDeclareOnGlobalThis = scope.isGlobal() &&\n            (parent.getType() == Token.VAR ||\n             parent.getType() == Token.FUNCTION);\n      } else {\n        Preconditions.checkArgument(\n            n.getType() == Token.GETPROP &&\n            (parent.getType() == Token.ASSIGN ||\n             parent.getType() == Token.EXPR_RESULT));\n      }\n      String variableName = n.getQualifiedName();\n      Preconditions.checkArgument(!variableName.isEmpty());\n\n      // declared in closest scope?\n      if (scope.isDeclared(variableName, false)) {\n        Var oldVar = scope.getVar(variableName);\n        validator.expectUndeclaredVariable(\n            sourceName, n, parent, oldVar, variableName, type);\n      } else {\n        if (!inferred) {\n          n.setJSType(type);\n        }\n        CompilerInput input = compiler.getInput(sourceName);\n        scope.declare(variableName, n, type, input, inferred);\n\n        if (shouldDeclareOnGlobalThis) {\n          ObjectType globalThis =\n              typeRegistry.getNativeObjectType(JSTypeNative.GLOBAL_THIS);\n          boolean isExtern = input.isExtern();\n          if (inferred) {\n            globalThis.defineInferredProperty(variableName,\n                type == null ?\n                    typeRegistry.getNativeType(JSTypeNative.NO_TYPE) :\n                    type,\n                isExtern);\n          } else {\n            globalThis.defineDeclaredProperty(variableName, type, isExtern);\n          }\n        }\n\n        // If we're in the global scope, also declare var.prototype\n        // in the scope chain.\n        if (scope.isGlobal() && type instanceof FunctionType) {\n          FunctionType fnType = (FunctionType) type;\n          if (fnType.isConstructor() || fnType.isInterface()) {\n            FunctionType superClassCtor = fnType.getSuperClassConstructor();\n            scope.declare(variableName + \".prototype\", n,\n                fnType.getPrototype(), compiler.getInput(sourceName),\n                /* declared iff there's an explicit supertype */\n                superClassCtor == null ||\n                superClassCtor.getInstanceType().equals(\n                    typeRegistry.getNativeType(OBJECT_TYPE)));\n          }\n        }\n      }\n    }",
    "comment": " Defines a typed variable. The defining node will be annotated with the variable's type of {@link JSTypeNative#UNKNOWN_TYPE} if its type is inferred.  Slots may be any variable or any qualified name in the global scope.  @param n the defining NAME or GETPROP node. @param parent the {@code n}'s parent. @param type the variable's type. It may be {@code null} if {@code inferred} is {@code true}. ",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "AbstractScopeBuilder.getDeclaredTypeInAnnotation",
    "class_name": "com.google.javascript.jscomp.TypedScopeCreator$AbstractScopeBuilder",
    "signature": "com.google.javascript.jscomp.TypedScopeCreator$AbstractScopeBuilder.getDeclaredTypeInAnnotation(NodeTraversal,Node,JSDocInfo)",
    "snippet": "    JSType getDeclaredTypeInAnnotation(\n        NodeTraversal t, Node node, JSDocInfo info) {\n      return getDeclaredTypeInAnnotation(t.getSourceName(), node, info);\n    }",
    "comment": " Returns the type specified in a JSDoc annotation near a GETPROP or NAME.  Extracts type information from either the {@code @type} tag or from the {@code @return} and {@code @param} tags. ",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "AbstractScopeBuilder.getDeclaredTypeInAnnotation",
    "class_name": "com.google.javascript.jscomp.TypedScopeCreator$AbstractScopeBuilder",
    "signature": "com.google.javascript.jscomp.TypedScopeCreator$AbstractScopeBuilder.getDeclaredTypeInAnnotation(String,Node,JSDocInfo)",
    "snippet": "    JSType getDeclaredTypeInAnnotation(String sourceName,\n        Node node, JSDocInfo info) {\n      JSType jsType = null;\n      Node objNode = node.getType() == Token.GETPROP ?\n          node.getFirstChild() : null;\n      if (info != null) {\n        if (info.hasType()) {\n          jsType = info.getType().evaluate(scope);\n        } else if (FunctionTypeBuilder.isFunctionTypeDeclaration(info)) {\n          String fnName = node.getQualifiedName();\n\n          // constructors are often handled separately.\n          if (info.isConstructor() && typeRegistry.getType(fnName) != null) {\n            return null;\n          }\n\n          FunctionTypeBuilder builder =\n              new FunctionTypeBuilder(\n                  fnName, compiler, node, sourceName, scope)\n              .inferTemplateTypeName(info)\n              .inferReturnType(info)\n              .inferParameterTypes(info)\n              .inferInheritance(info);\n\n          // Infer the context type.\n          boolean searchedForThisType = false;\n          if (objNode != null) {\n            if (objNode.getType() == Token.GETPROP &&\n                objNode.getLastChild().getString().equals(\"prototype\")) {\n              builder.inferThisType(info, objNode.getFirstChild());\n              searchedForThisType = true;\n            } else if (objNode.getType() == Token.THIS) {\n              builder.inferThisType(info, objNode.getJSType());\n              searchedForThisType = true;\n            }\n          }\n\n          if (!searchedForThisType) {\n            builder.inferThisType(info, (Node) null);\n          }\n\n          jsType = builder.buildAndRegister();\n        }\n      }\n      return jsType;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "AbstractScopeBuilder.getFunctionType",
    "class_name": "com.google.javascript.jscomp.TypedScopeCreator$AbstractScopeBuilder",
    "signature": "com.google.javascript.jscomp.TypedScopeCreator$AbstractScopeBuilder.getFunctionType(String,Node,JSDocInfo,Node)",
    "snippet": "    private FunctionType getFunctionType(String name,\n        Node rValue, JSDocInfo info, @Nullable Node lvalueNode) {\n      FunctionType functionType = null;\n\n      // Handle function aliases.\n      if (rValue != null && rValue.isQualifiedName()) {\n        Var var = scope.getVar(rValue.getQualifiedName());\n        if (var != null && var.getType() instanceof FunctionType) {\n          functionType = (FunctionType) var.getType();\n          if (functionType != null && functionType.isConstructor()) {\n            typeRegistry.declareType(name, functionType.getInstanceType());\n          }\n        }\n        return functionType;\n      }\n\n      Node owner = null;\n      if (lvalueNode != null) {\n        owner = getPrototypePropertyOwner(lvalueNode);\n      }\n\n      Node errorRoot = rValue == null ? lvalueNode : rValue;\n      boolean isFnLiteral =\n          rValue != null && rValue.getType() == Token.FUNCTION;\n      Node fnRoot = isFnLiteral ? rValue : null;\n      Node parametersNode = isFnLiteral ?\n          rValue.getFirstChild().getNext() : null;\n\n      if (functionType == null && info != null && info.hasType()) {\n        JSType type = info.getType().evaluate(scope);\n\n        // Known to be not null since we have the FUNCTION token there.\n        type = type.restrictByNotNullOrUndefined();\n        if (type.isFunctionType()) {\n          functionType = (FunctionType) type;\n          functionType.setJSDocInfo(info);\n        }\n      }\n\n      if (functionType == null) {\n        if (info == null ||\n            !FunctionTypeBuilder.isFunctionTypeDeclaration(info)) {\n          // We don't really have any type information in the annotation.\n          // Before we give up on this function, look at the object we're\n          // assigning it to. For example, if the function looks like this:\n          // SubFoo.prototype.bar = function() { ... };\n          // We can use type information on Foo.prototype.bar and apply it\n          // to this function.\n          if (lvalueNode != null && lvalueNode.getType() == Token.GETPROP &&\n              lvalueNode.isQualifiedName()) {\n            Var var = scope.getVar(\n                lvalueNode.getFirstChild().getQualifiedName());\n            if (var != null) {\n              ObjectType ownerType = ObjectType.cast(var.getType());\n              FunctionType propType = null;\n              if (ownerType != null) {\n                propType = findOverriddenFunction(\n                    ownerType, lvalueNode.getLastChild().getString());\n              }\n\n              if (propType != null) {\n                functionType =\n                    new FunctionTypeBuilder(\n                        name, compiler, errorRoot, sourceName, scope)\n                    .setSourceNode(fnRoot)\n                    .inferFromOverriddenFunction(propType, parametersNode)\n                    .inferThisType(info, owner)\n                    .buildAndRegister();\n              }\n            }\n          }\n        }\n      } // end if (functionType == null)\n\n      if (functionType == null) {\n        functionType =\n            new FunctionTypeBuilder(name, compiler, errorRoot, sourceName,\n                scope)\n            .setSourceNode(fnRoot)\n            .inferTemplateTypeName(info)\n            .inferReturnType(info)\n            .inferInheritance(info)\n            .inferThisType(info, owner)\n            .inferParameterTypes(parametersNode, info)\n            .buildAndRegister();\n      }\n\n      // assigning the function type to the function node\n      if (rValue != null) {\n        rValue.setJSType(functionType);\n      }\n\n      // all done\n      return functionType;\n    }",
    "comment": " Gets the function type from the function node and its attached {@link JSDocInfo}. @param name the function's name @param rValue the function node. It must be a {@link Token#FUNCTION}. @param info the {@link JSDocInfo} attached to the function definition @param lvalueNode The node where this function is being assigned. For example, {@code A.prototype.foo = ...} would be used to determine that this function is a method of A.prototype. May be null to indicate that this is not being assigned to a qualified name. ",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "AbstractScopeBuilder.shouldTraverse",
    "class_name": "com.google.javascript.jscomp.TypedScopeCreator$AbstractScopeBuilder",
    "signature": "com.google.javascript.jscomp.TypedScopeCreator$AbstractScopeBuilder.shouldTraverse(NodeTraversal,Node,Node)",
    "snippet": "    @Override\n    public final boolean shouldTraverse(NodeTraversal nodeTraversal, Node n,\n        Node parent) {\n      if (n.getType() == Token.FUNCTION ||\n          n.getType() == Token.SCRIPT) {\n        sourceName = (String) n.getProp(Node.SOURCENAME_PROP);\n      }\n\n      // We do want to traverse the name of a named function, but we don't\n      // want to traverse the arguments or body.\n      return parent == null || parent.getType() != Token.FUNCTION ||\n          n == parent.getFirstChild() || parent == scope.getRootNode();\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "GlobalScopeBuilder.checkForTypedef",
    "class_name": "com.google.javascript.jscomp.TypedScopeCreator$GlobalScopeBuilder",
    "signature": "com.google.javascript.jscomp.TypedScopeCreator$GlobalScopeBuilder.checkForTypedef(NodeTraversal,Node,JSDocInfo)",
    "snippet": "    private void checkForTypedef(\n        NodeTraversal t, Node candidate, JSDocInfo info) {\n      if (info == null || !info.hasTypedefType()) {\n        return;\n      }\n\n      String typedef = candidate.getQualifiedName();\n      if (typedef == null) {\n        return;\n      }\n\n      // TODO(nicksantos|user): This is a terrible, terrible hack\n      // to bail out on recusive typedefs. We'll eventually need\n      // to handle these properly.\n      typeRegistry.forwardDeclareType(typedef);\n\n      JSType realType = info.getTypedefType().evaluate(scope);\n      if (realType == null) {\n        compiler.report(\n            JSError.make(\n                t.getSourceName(), candidate, MALFORMED_TYPEDEF, typedef));\n      }\n\n      typeRegistry.declareType(typedef, realType);\n      if (candidate.getType() == Token.GETPROP) {\n        defineSlot(candidate, candidate.getParent(),\n            typeRegistry.getNativeType(NO_TYPE), false);\n      }\n    }",
    "comment": " Handle typedefs. @param t The current traversal. @param candidate A qualified name node. @param info JSDoc comments. ",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "GlobalScopeBuilder.getDeclaredGetPropType",
    "class_name": "com.google.javascript.jscomp.TypedScopeCreator$GlobalScopeBuilder",
    "signature": "com.google.javascript.jscomp.TypedScopeCreator$GlobalScopeBuilder.getDeclaredGetPropType(NodeTraversal,JSDocInfo,Node,Node)",
    "snippet": "    private JSType getDeclaredGetPropType(NodeTraversal t, JSDocInfo info,\n        Node n, Node rhsValue) {\n      if (info != null && info.hasType()) {\n        return getDeclaredTypeInAnnotation(t, n, info);\n      } else if (info != null && info.hasEnumParameterType()) {\n        return n.getJSType();\n      } else if (rhsValue != null &&\n          rhsValue.getType() == Token.FUNCTION) {\n        return rhsValue.getJSType();\n      } else {\n        return getDeclaredTypeInAnnotation(t, n, info);\n      }\n    }",
    "comment": " Look for a type declaration on a GETPROP node.  @param info The doc info for this property. @param n A top-level GETPROP node (it should not be contained inside another GETPROP). @param rhsValue The node that {@code n} is being initialized to, or {@code null} if this is a stub declaration. ",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "GlobalScopeBuilder.getObjectSlot",
    "class_name": "com.google.javascript.jscomp.TypedScopeCreator$GlobalScopeBuilder",
    "signature": "com.google.javascript.jscomp.TypedScopeCreator$GlobalScopeBuilder.getObjectSlot(String)",
    "snippet": "    private ObjectType getObjectSlot(String slotName) {\n      Var ownerVar = scope.getVar(slotName);\n      if (ownerVar != null) {\n        JSType ownerVarType = ownerVar.getType();\n        return ObjectType.cast(ownerVarType == null ?\n            null : ownerVarType.restrictByNotNullOrUndefined());\n      }\n      return null;\n    }",
    "comment": " Find the ObjectType associated with the given slot. @param slotName The name of the slot to find the type in. @return An object type, or null if this slot does not contain an object. ",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "GlobalScopeBuilder.maybeDeclareQualifiedName",
    "class_name": "com.google.javascript.jscomp.TypedScopeCreator$GlobalScopeBuilder",
    "signature": "com.google.javascript.jscomp.TypedScopeCreator$GlobalScopeBuilder.maybeDeclareQualifiedName(NodeTraversal,JSDocInfo,Node,Node,Node)",
    "snippet": "    private void maybeDeclareQualifiedName(NodeTraversal t, JSDocInfo info,\n        Node n, Node parent, Node rhsValue) {\n      Node ownerNode = n.getFirstChild();\n      String ownerName = ownerNode.getQualifiedName();\n      String qName = n.getQualifiedName();\n      String propName = n.getLastChild().getString();\n      Preconditions.checkArgument(qName != null && ownerName != null);\n\n      // Function prototypes are special.\n      // It's a common JS idiom to do:\n      // F.prototype = { ... };\n      // So if F does not have an explicitly declared super type,\n      // allow F.prototype to be redefined arbitrarily.\n      if (\"prototype\".equals(propName)) {\n        Var qVar = scope.getVar(qName);\n        if (qVar != null) {\n          if (!qVar.isTypeInferred()) {\n            // Just ignore assigns to declared prototypes.\n            return;\n          }\n          scope.undeclare(qVar);\n        }\n      }\n\n      // Precedence of type information on GETPROPs:\n      // 1) @type annotation / @enum annotation\n      // 2) ASSIGN to FUNCTION literal\n      // 3) @param/@return annotation (with no function literal)\n      // 4) ASSIGN to anything else\n      //\n      // 1 and 3 are declarations, 4 is inferred, and 2 is a declaration iff\n      // the function has not been declared before.\n      //\n      // FUNCTION literals are special because TypedScopeCreator is very smart\n      // about getting as much type information as possible for them.\n\n      // Determining type for #1 + #2 + #3\n      JSType valueType = getDeclaredGetPropType(t, info, n, rhsValue);\n      if (valueType == null && rhsValue != null) {\n        // Determining type for #4\n        valueType = rhsValue.getJSType();\n      }\n\n      if (valueType == null) {\n        if (parent.getType() == Token.EXPR_RESULT) {\n          stubDeclarations.add(new StubDeclaration(\n              n, t.getInput().isExtern(), ownerName));\n        } else if (rhsValue != null &&\n                   rhsValue.getType() == Token.TRUE) {\n          // We declare these for delegate proxy method properties.\n          ObjectType ownerType = getObjectSlot(ownerName);\n          if (ownerType instanceof FunctionType) {\n            JSType ownerTypeOfThis = ((FunctionType) ownerType).getTypeOfThis();\n            String delegateName = codingConvention.getDelegateSuperclassName();\n            JSType delegateType = delegateName == null ?\n                null : typeRegistry.getType(delegateName);\n            if (delegateType != null &&\n                ownerTypeOfThis.isSubtype(delegateType)) {\n              defineSlot(n, parent, typeRegistry.getNativeType(BOOLEAN_TYPE),\n                         true);\n            }\n          }\n        }\n\n        return;\n      }\n\n      boolean inferred = true;\n      if (info != null) {\n        // Determining declaration for #1 + #3\n        inferred = !(info.hasType() || info.hasEnumParameterType() ||\n            FunctionTypeBuilder.isFunctionTypeDeclaration(info));\n      }\n\n      if (inferred) {\n        // Determining declaration for #2\n        inferred = !(rhsValue != null &&\n            rhsValue.getType() == Token.FUNCTION &&\n            !scope.isDeclared(qName, false));\n      }\n\n      if (!inferred) {\n        ObjectType ownerType = getObjectSlot(ownerName);\n        if (ownerType != null) {\n          // Only declare this as an official property if it has not been\n          // declared yet.\n          boolean isExtern = t.getInput().isExtern();\n          if ((!ownerType.hasOwnProperty(propName) ||\n               ownerType.isPropertyTypeInferred(propName)) &&\n              ((isExtern && !ownerType.isNativeObjectType()) ||\n               !ownerType.isInstanceType())) {\n            // If the property is undeclared or inferred, declare it now.\n            ownerType.defineDeclaredProperty(propName, valueType, isExtern);\n          }\n        }\n\n        // If the property is already declared, the error will be\n        // caught when we try to declare it in the current scope.\n        defineSlot(n, parent, valueType, inferred);\n      }\n    }",
    "comment": " Declare the symbol for a qualified name in the global scope.  @param info The doc info for this property. @param n A top-level GETPROP node (it should not be contained inside another GETPROP). @param parent The parent of {@code n}. @param rhsValue The node that {@code n} is being initialized to, or {@code null} if this is a stub declaration. ",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "GlobalScopeBuilder.resolveStubDeclarations",
    "class_name": "com.google.javascript.jscomp.TypedScopeCreator$GlobalScopeBuilder",
    "signature": "com.google.javascript.jscomp.TypedScopeCreator$GlobalScopeBuilder.resolveStubDeclarations()",
    "snippet": "    private void resolveStubDeclarations() {\n      for (StubDeclaration stub : stubDeclarations) {\n        Node n = stub.node;\n        Node parent = n.getParent();\n        String qName = n.getQualifiedName();\n        String propName = n.getLastChild().getString();\n        String ownerName = stub.ownerName;\n        boolean isExtern = stub.isExtern;\n\n        if (scope.isDeclared(qName, false)) {\n          continue;\n        }\n\n        // If we see a stub property, make sure to register this property\n        // in the type registry.\n        ObjectType ownerType = getObjectSlot(ownerName);\n        ObjectType unknownType = typeRegistry.getNativeObjectType(UNKNOWN_TYPE);\n        defineSlot(n, parent, unknownType, true);\n\n        if (ownerType != null &&\n            (isExtern || ownerType.isFunctionPrototypeType())) {\n          // If this is a stub for a prototype, just declare it\n          // as an unknown type. These are seen often in externs.\n          ownerType.defineInferredProperty(\n              propName, unknownType, isExtern);\n        } else {\n          typeRegistry.registerPropertyOnType(\n              propName, ownerType == null ? unknownType : ownerType);\n        }\n      }\n    }",
    "comment": " Resolve any stub delcarations to unknown types if we could not find types for them during traversal. ",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "GlobalScopeBuilder.visit",
    "class_name": "com.google.javascript.jscomp.TypedScopeCreator$GlobalScopeBuilder",
    "signature": "com.google.javascript.jscomp.TypedScopeCreator$GlobalScopeBuilder.visit(NodeTraversal,Node,Node)",
    "snippet": "    @Override public void visit(NodeTraversal t, Node n, Node parent) {\n      switch (n.getType()) {\n        case Token.CALL:\n          SubclassRelationship relationship =\n              codingConvention.getClassesDefinedByCall(n);\n          if (relationship != null) {\n            ObjectType superClass = ObjectType.cast(\n                typeRegistry.getType(relationship.superclassName));\n            ObjectType subClass = ObjectType.cast(\n                typeRegistry.getType(relationship.subclassName));\n            if (superClass != null && subClass != null) {\n              FunctionType superCtor = superClass.getConstructor();\n              FunctionType subCtor = subClass.getConstructor();\n\n              if (relationship.type == SubclassType.INHERITS) {\n                validator.expectSuperType(t, n, superClass, subClass);\n              }\n\n              if (superCtor != null && subCtor != null) {\n                codingConvention.applySubclassRelationship(\n                    superCtor, subCtor, relationship.type);\n              }\n            }\n          }\n\n          String singletonGetterClassName =\n              codingConvention.getSingletonGetterClassName(n);\n          if (singletonGetterClassName != null) {\n            ObjectType objectType = ObjectType.cast(\n                typeRegistry.getType(singletonGetterClassName));\n            if (objectType != null) {\n              FunctionType functionType = objectType.getConstructor();\n\n              if (functionType != null) {\n                FunctionType getterType = new FunctionType(\n                    typeRegistry, null, null,\n                    new FunctionParamBuilder(typeRegistry).build(),\n                    objectType, null);\n                codingConvention.applySingletonGetter(functionType, getterType,\n                                                      objectType);\n              }\n            }\n          }\n\n          DelegateRelationship delegateRelationship =\n              codingConvention.getDelegateRelationship(n);\n          if (delegateRelationship != null) {\n            ObjectType delegatorObject = ObjectType.cast(\n                typeRegistry.getType(delegateRelationship.delegator));\n            ObjectType delegateBaseObject = ObjectType.cast(\n                typeRegistry.getType(delegateRelationship.delegateBase));\n            ObjectType delegateSuperObject = ObjectType.cast(\n                typeRegistry.getType(\n                    codingConvention.getDelegateSuperclassName()));\n            if (delegatorObject != null &&\n                delegateBaseObject != null &&\n                delegateSuperObject != null) {\n              FunctionType delegatorCtor = delegatorObject.getConstructor();\n              FunctionType delegateBaseCtor =\n                  delegateBaseObject.getConstructor();\n              FunctionType delegateSuperCtor =\n                  delegateSuperObject.getConstructor();\n\n              if (delegatorCtor != null && delegateBaseCtor != null &&\n                  delegateSuperCtor != null) {\n                FunctionParamBuilder functionParamBuilder =\n                    new FunctionParamBuilder(typeRegistry);\n                functionParamBuilder.addRequiredParams(\n                    typeRegistry.getNativeType(U2U_CONSTRUCTOR_TYPE));\n                FunctionType findDelegate = new FunctionType(\n                    typeRegistry, null, null, functionParamBuilder.build(),\n                    typeRegistry.createNullableType(delegateBaseObject), null);\n\n                FunctionType delegateProxy =\n                    typeRegistry.createConstructorType(\n                        delegateBaseObject.getReferenceName(), null, null,\n                        null);\n                delegateProxy.setPrototypeBasedOn(delegateBaseCtor);\n\n                codingConvention.applyDelegateRelationship(\n                    delegateSuperObject, delegateBaseObject, delegatorObject,\n                    delegateProxy, findDelegate);\n                delegateProxyMap.put(\n                    delegateProxy.getPrototype(),\n                    delegateBaseCtor.getPrototype());\n              }\n            }\n          }\n\n          ObjectLiteralCast objectLiteralCast =\n              codingConvention.getObjectLiteralCast(t, n);\n          if (objectLiteralCast != null) {\n            ObjectType type = ObjectType.cast(\n                typeRegistry.getType(objectLiteralCast.typeName));\n            if (type != null && type.getConstructor() != null) {\n              objectLiteralCast.objectNode.setJSType(type);\n            } else {\n              compiler.report(JSError.make(t.getSourceName(), n,\n                                           CONSTRUCTOR_EXPECTED));\n            }\n          }\n          break;\n\n        case Token.FUNCTION:\n          if (!t.getInput().isExtern()) {\n            nonExternFunctions.add(n);\n          }\n\n          // VARs and ASSIGNs are handled separately.\n          if (parent.getType() == Token.ASSIGN ||\n              parent.getType() == Token.NAME) {\n            return;\n          }\n          define(n, parent);\n          break;\n\n        case Token.ASSIGN:\n          // Handle constructor and enum definitions.\n          define(n, parent);\n\n          // Handle typedefs.\n          checkForOldStyleTypedef(t, n);\n\n          // Handle initialization of properties.\n          Node firstChild = n.getFirstChild();\n          if (firstChild.getType() == Token.GETPROP &&\n              firstChild.isQualifiedName()) {\n            maybeDeclareQualifiedName(t, n.getJSDocInfo(),\n                firstChild, n, firstChild.getNext());\n          }\n          break;\n\n        case Token.CATCH:\n          define(n, parent);\n          break;\n\n        case Token.VAR:\n          define(n, parent);\n\n          // Handle typedefs.\n          if (n.hasOneChild()) {\n            checkForOldStyleTypedef(t, n);\n            checkForTypedef(t, n.getFirstChild(), n.getJSDocInfo());\n          }\n          break;\n\n        case Token.GETPROP:\n          // Handle stubbed properties.\n          if (parent.getType() == Token.EXPR_RESULT &&\n              n.isQualifiedName()) {\n            checkForTypedef(t, n, n.getJSDocInfo());\n            maybeDeclareQualifiedName(t, n.getJSDocInfo(), n, parent, null);\n          }\n          break;\n      }\n    }",
    "comment": " Visit a node in the global scope, and add anything it declares to the global symbol table.  @param t The current traversal. @param n The node being visited. @param parent The parent of n ",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "CollectProperties.visit",
    "class_name": "com.google.javascript.jscomp.TypedScopeCreator$GlobalScopeBuilder$CollectProperties",
    "signature": "com.google.javascript.jscomp.TypedScopeCreator$GlobalScopeBuilder$CollectProperties.visit(NodeTraversal,Node,Node)",
    "snippet": "      public void visit(NodeTraversal t, Node n, Node parent) {\n        if (parent != null && parent.getType() == Token.EXPR_RESULT) {\n          switch (n.getType()) {\n            case Token.ASSIGN:\n              maybeCollectMember(t, n.getFirstChild(), n);\n              break;\n            case Token.GETPROP:\n              maybeCollectMember(t, n, n);\n              break;\n          }\n        }\n      }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "LocalScopeBuilder.build",
    "class_name": "com.google.javascript.jscomp.TypedScopeCreator$LocalScopeBuilder",
    "signature": "com.google.javascript.jscomp.TypedScopeCreator$LocalScopeBuilder.build()",
    "snippet": "    void build() {\n      NodeTraversal.traverse(compiler, scope.getRootNode(), this);\n    }",
    "comment": " Traverse the scope root and build it. ",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "LocalScopeBuilder.declareArguments",
    "class_name": "com.google.javascript.jscomp.TypedScopeCreator$LocalScopeBuilder",
    "signature": "com.google.javascript.jscomp.TypedScopeCreator$LocalScopeBuilder.declareArguments(Node)",
    "snippet": "    private void declareArguments(Node functionNode) {\n      Node astParameters = functionNode.getFirstChild().getNext();\n      Node body = astParameters.getNext();\n      FunctionType functionType = (FunctionType) functionNode.getJSType();\n      if (functionType != null) {\n        Node jsDocParameters = functionType.getParametersNode();\n        if (jsDocParameters != null) {\n          Node jsDocParameter = jsDocParameters.getFirstChild();\n          for (Node astParameter : astParameters.children()) {\n            if (jsDocParameter != null) {\n              defineSlot(astParameter, functionNode,\n                  jsDocParameter.getJSType(), true);\n              jsDocParameter = jsDocParameter.getNext();\n            } else {\n              defineSlot(astParameter, functionNode, null, true);\n            }\n          }\n        }\n      }\n    } // end declareArguments",
    "comment": " Declares all of a function's arguments. ",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "LocalScopeBuilder.handleFunctionInputs",
    "class_name": "com.google.javascript.jscomp.TypedScopeCreator$LocalScopeBuilder",
    "signature": "com.google.javascript.jscomp.TypedScopeCreator$LocalScopeBuilder.handleFunctionInputs(Node)",
    "snippet": "    private void handleFunctionInputs(Node fnNode) {\n      // Handle bleeding functions.\n      Node fnNameNode = fnNode.getFirstChild();\n      String fnName = fnNameNode.getString();\n      if (!fnName.isEmpty()) {\n        Scope.Var fnVar = scope.getVar(fnName);\n        if (fnVar == null ||\n            // Make sure we're not touching a native function. Native\n            // functions aren't bleeding, but may not have a declaration\n            // node.\n            (fnVar.getNameNode() != null &&\n                // Make sure that the function is actually bleeding by checking\n                // if has already been declared.\n                fnVar.getInitialValue() != fnNode)) {\n          defineSlot(fnNameNode, fnNode, fnNode.getJSType(), false);\n        }\n      }\n\n      declareArguments(fnNode);\n    }",
    "comment": "Handle bleeding functions and function parameters. */",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "LocalScopeBuilder.visit",
    "class_name": "com.google.javascript.jscomp.TypedScopeCreator$LocalScopeBuilder",
    "signature": "com.google.javascript.jscomp.TypedScopeCreator$LocalScopeBuilder.visit(NodeTraversal,Node,Node)",
    "snippet": "    @Override public void visit(NodeTraversal t, Node n, Node parent) {\n      if (n == scope.getRootNode()) return;\n\n      if (n.getType() == Token.LP && parent == scope.getRootNode()) {\n        handleFunctionInputs(parent);\n        return;\n      }\n\n      switch (n.getType()) {\n        case Token.FUNCTION:\n          // VARs and ASSIGNs are handled separately.\n          if (parent.getType() == Token.NAME) {\n            return;\n          }\n          define(n, parent);\n          break;\n\n        case Token.CATCH:\n        case Token.VAR:\n          define(n, parent);\n          break;\n      }\n    }",
    "comment": " Visit a node in a local scope, and add any local variables or catch parameters into the local symbol table.  @param t The node traversal. @param n The node being visited. @param parent The parent of n ",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "FixedPointGraphTraversal.FixedPointGraphTraversal",
    "class_name": "com.google.javascript.jscomp.graph.FixedPointGraphTraversal",
    "signature": "com.google.javascript.jscomp.graph.FixedPointGraphTraversal.FixedPointGraphTraversal(EdgeCallback)",
    "snippet": "  public FixedPointGraphTraversal(EdgeCallback<N, E> callback) {\n    this.callback = callback;\n  }",
    "comment": " Create a new traversal. @param callback A callback for updating the state of the graph each time an edge is traversed. ",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "FixedPointGraphTraversal.computeFixedPoint",
    "class_name": "com.google.javascript.jscomp.graph.FixedPointGraphTraversal",
    "signature": "com.google.javascript.jscomp.graph.FixedPointGraphTraversal.computeFixedPoint(DiGraph,N)",
    "snippet": "  public void computeFixedPoint(DiGraph<N, E> graph, N entry) {\n    Set<N> entrySet = Sets.newHashSet();\n    entrySet.add(entry);\n    computeFixedPoint(graph, entrySet);\n  }",
    "comment": " Compute a fixed point for the given graph, entering from the given node. @param graph The graph to traverse. @param entry The node to begin traversing from. ",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "FixedPointGraphTraversal.computeFixedPoint",
    "class_name": "com.google.javascript.jscomp.graph.FixedPointGraphTraversal",
    "signature": "com.google.javascript.jscomp.graph.FixedPointGraphTraversal.computeFixedPoint(DiGraph,Set)",
    "snippet": "  public void computeFixedPoint(DiGraph<N, E> graph, Set<N> entrySet) {\n    int cycleCount = 0;\n    long nodeCount = graph.getNodes().size();\n\n    // Choose a bail-out heuristically in case the computation\n    // doesn't converge.\n    long maxIterations = Math.max(nodeCount * nodeCount * nodeCount, 100);\n\n    // Use a LinkedHashSet, so that the traversal is deterministic.\n    LinkedHashSet<DiGraphNode<N, E>> workSet =\n        Sets.newLinkedHashSet();\n    for (N n : entrySet) {\n      workSet.add(graph.getDirectedGraphNode(n));\n    }\n    for (; !workSet.isEmpty() && cycleCount < maxIterations; cycleCount++) {\n      // For every out edge in the workSet, traverse that edge. If that\n      // edge updates the state of the graph, then add the destination\n      // node to the resultSet, so that we can update all of its out edges\n      // on the next iteration.\n      DiGraphNode<N, E> source = workSet.iterator().next();\n      N sourceValue = source.getValue();\n\n      workSet.remove(source);\n\n      List<DiGraphEdge<N, E>> outEdges = source.getOutEdges();\n      for (DiGraphEdge<N, E> edge : outEdges) {\n        N destNode = edge.getDestination().getValue();\n        if (callback.traverseEdge(sourceValue, edge.getValue(), destNode)) {\n          workSet.add(edge.getDestination());\n        }\n      }\n    }\n\n    Preconditions.checkState(cycleCount != maxIterations,\n        NON_HALTING_ERROR_MSG);\n  }",
    "comment": " Compute a fixed point for the given graph, entering from the given nodes. @param graph The graph to traverse. @param entrySet The nodes to begin traversing from. ",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "FixedPointGraphTraversal.newTraversal",
    "class_name": "com.google.javascript.jscomp.graph.FixedPointGraphTraversal",
    "signature": "com.google.javascript.jscomp.graph.FixedPointGraphTraversal.newTraversal(EdgeCallback)",
    "snippet": "  public static <NODE, EDGE> FixedPointGraphTraversal<NODE, EDGE> newTraversal(\n      EdgeCallback<NODE, EDGE> callback) {\n    return new FixedPointGraphTraversal<NODE, EDGE>(callback);\n  }",
    "comment": " Helper method for creating new traversals. ",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "Graph.clearNodeAnnotations",
    "class_name": "com.google.javascript.jscomp.graph.Graph",
    "signature": "com.google.javascript.jscomp.graph.Graph.clearNodeAnnotations()",
    "snippet": "  public final void clearNodeAnnotations() {\n    for (GraphNode<N, E> n : getNodes()) {\n      n.setAnnotation(null);\n    }\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "Graph.connectIfNotFound",
    "class_name": "com.google.javascript.jscomp.graph.Graph",
    "signature": "com.google.javascript.jscomp.graph.Graph.connectIfNotFound(N,E,N)",
    "snippet": "  public final void connectIfNotFound(N n1, E edge, N n2) {\n    GraphNode<N, E> node1 = getNode(n1);\n    GraphNode<N, E> node2 = getNode(n2);\n    if (node1 == null) {\n      throw new IllegalArgumentException(n1 + \" does not exist in graph\");\n    }\n    if (node2 == null) {\n      throw new IllegalArgumentException(n2 + \" does not exist in graph\");\n    }\n    List<GraphEdge<N, E>> edgeList = getEdges(n1, n2);\n    for (GraphEdge<N, E> e : edgeList) {\n      // Check == first to short circuit nulls.\n      if (e.getValue() == edge || e.getValue().equals(edge)) {\n        return;\n      }\n    }\n    connect(n1, edge, n2);\n  }",
    "comment": " Connects two nodes in the graph with an edge if such edge does not already exists between the nodes.  @param n1 First node. @param edge The edge. @param n2 Second node. ",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "GraphReachability.GraphReachability",
    "class_name": "com.google.javascript.jscomp.graph.GraphReachability",
    "signature": "com.google.javascript.jscomp.graph.GraphReachability.GraphReachability(DiGraph)",
    "snippet": "  public GraphReachability(DiGraph<N, E> graph) {\n    this.graph = graph;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "GraphReachability.compute",
    "class_name": "com.google.javascript.jscomp.graph.GraphReachability",
    "signature": "com.google.javascript.jscomp.graph.GraphReachability.compute(N)",
    "snippet": "  public void compute(N entry) {\n    graph.clearNodeAnnotations();\n    graph.getNode(entry).setAnnotation(REACHABLE);\n    FixedPointGraphTraversal.newTraversal(this)\n        .computeFixedPoint(graph, entry);\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "GraphReachability.recompute",
    "class_name": "com.google.javascript.jscomp.graph.GraphReachability",
    "signature": "com.google.javascript.jscomp.graph.GraphReachability.recompute(N)",
    "snippet": "  public void recompute(N reachableNode) {\n    GraphNode<N, E> newReachable = graph.getNode(reachableNode);\n    Preconditions.checkState(newReachable.getAnnotation() != REACHABLE);\n    newReachable.setAnnotation(REACHABLE);\n    FixedPointGraphTraversal.newTraversal(this)\n        .computeFixedPoint(graph, reachableNode);\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "GraphReachability.traverseEdge",
    "class_name": "com.google.javascript.jscomp.graph.GraphReachability",
    "signature": "com.google.javascript.jscomp.graph.GraphReachability.traverseEdge(N,E,N)",
    "snippet": "  @Override\n  public boolean traverseEdge(N source, E e, N destination) {\n    if (graph.getNode(source).getAnnotation() == REACHABLE) {\n      GraphNode<N, E> destNode = graph.getNode(destination);\n      if (destNode.getAnnotation() != REACHABLE) {\n        destNode.setAnnotation(REACHABLE);\n        return true;\n      }\n    }\n    return false;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "LinkedDirectedGraph.connect",
    "class_name": "com.google.javascript.jscomp.graph.LinkedDirectedGraph",
    "signature": "com.google.javascript.jscomp.graph.LinkedDirectedGraph.connect(N,E,N)",
    "snippet": "  @Override\n  public GraphEdge<N, E> connect(N srcValue, E edgeValue, N destValue) {\n    DiGraphNode<N, E> node = getDirectedGraphNode(srcValue);\n    if (node == null) {\n      throw new IllegalArgumentException(\n          srcValue + \" does not exist in graph\");\n    }\n    LinkedDirectedGraphNode<N, E> src = (LinkedDirectedGraphNode<N, E>) node;\n    node = getDirectedGraphNode(destValue);\n    if (node == null) {\n      throw new IllegalArgumentException(\n          destValue + \" does not exist in graph\");\n    }\n    LinkedDirectedGraphNode<N, E> dest = (LinkedDirectedGraphNode<N, E>) node;\n    LinkedDirectedGraphEdge<N, E> edge =\n        new LinkedDirectedGraphEdge<N, E>(src, edgeValue, dest);\n    src.getOutEdges().add(edge);\n    dest.getInEdges().add(edge);\n    return edge;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "LinkedDirectedGraph.createDirectedGraphNode",
    "class_name": "com.google.javascript.jscomp.graph.LinkedDirectedGraph",
    "signature": "com.google.javascript.jscomp.graph.LinkedDirectedGraph.createDirectedGraphNode(N)",
    "snippet": "  @Override\n  public DiGraphNode<N, E> createDirectedGraphNode(N nodeValue) {\n    LinkedDirectedGraphNode<N, E> node = nodes.get(nodeValue);\n    if (node == null) {\n      node = new LinkedDirectedGraphNode<N, E>(nodeValue);\n      nodes.put(nodeValue, node);\n    }\n    return node;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "LinkedDirectedGraph.createNode",
    "class_name": "com.google.javascript.jscomp.graph.LinkedDirectedGraph",
    "signature": "com.google.javascript.jscomp.graph.LinkedDirectedGraph.createNode(N)",
    "snippet": "  @Override\n  public GraphNode<N, E> createNode(N value) {\n    return createDirectedGraphNode(value);\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "LinkedDirectedGraph.getDirectedGraphEdges",
    "class_name": "com.google.javascript.jscomp.graph.LinkedDirectedGraph",
    "signature": "com.google.javascript.jscomp.graph.LinkedDirectedGraph.getDirectedGraphEdges(N,N)",
    "snippet": "  @Override\n  public List<DiGraphEdge<N, E>> getDirectedGraphEdges(N n1, N n2) {\n    DiGraphNode<N, E> dNode1 = nodes.get(n1);\n    if (dNode1 == null) {\n      throw new IllegalArgumentException(n1 + \" does not exist in graph\");\n    }\n    DiGraphNode<N, E> dNode2 = nodes.get(n2);\n    if (dNode2 == null) {\n      throw new IllegalArgumentException(n1 + \" does not exist in graph\");\n    }\n    List<DiGraphEdge<N, E>> edges = Lists.newArrayList();\n    for (DiGraphEdge<N, E> outEdge : dNode1.getOutEdges()) {\n      if (outEdge.getDestination() == dNode2) {\n        edges.add(outEdge);\n      }\n    }\n    return edges;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "LinkedDirectedGraph.getDirectedGraphNode",
    "class_name": "com.google.javascript.jscomp.graph.LinkedDirectedGraph",
    "signature": "com.google.javascript.jscomp.graph.LinkedDirectedGraph.getDirectedGraphNode(N)",
    "snippet": "  @Override\n  public DiGraphNode<N, E> getDirectedGraphNode(N nodeValue) {\n    return nodes.get(nodeValue);\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "LinkedDirectedGraph.getDirectedGraphNodes",
    "class_name": "com.google.javascript.jscomp.graph.LinkedDirectedGraph",
    "signature": "com.google.javascript.jscomp.graph.LinkedDirectedGraph.getDirectedGraphNodes()",
    "snippet": "  @Override\n  public List<DiGraphNode<N, E>> getDirectedGraphNodes() {\n    List<DiGraphNode<N, E>> nodeList = Lists.newArrayList();\n    nodeList.addAll(nodes.values());\n    return nodeList;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "LinkedDirectedGraph.getDirectedSuccNodes",
    "class_name": "com.google.javascript.jscomp.graph.LinkedDirectedGraph",
    "signature": "com.google.javascript.jscomp.graph.LinkedDirectedGraph.getDirectedSuccNodes(DiGraphNode)",
    "snippet": "  @Override\n  public List<DiGraphNode<N, E>> getDirectedSuccNodes(\n      DiGraphNode<N, E> dNode) {\n    if (dNode == null) {\n      throw new IllegalArgumentException(dNode + \" is null\");\n    }\n    List<DiGraphNode<N, E>> nodeList = Lists.newArrayList();\n    for (DiGraphEdge<N, E> edge : dNode.getOutEdges()) {\n      nodeList.add(edge.getDestination());\n    }\n    return nodeList;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "LinkedDirectedGraph.getEdges",
    "class_name": "com.google.javascript.jscomp.graph.LinkedDirectedGraph",
    "signature": "com.google.javascript.jscomp.graph.LinkedDirectedGraph.getEdges(N,N)",
    "snippet": "  @Override\n  public List<GraphEdge<N, E>> getEdges(N n1, N n2) {\n    // Since this is a method from a generic graph, edges from both\n    // directions must be added to the returning list.\n    List<DiGraphEdge<N, E>> forwardEdges = getDirectedGraphEdges(n1, n2);\n    List<DiGraphEdge<N, E>> backwardEdges = getDirectedGraphEdges(n2, n1);\n    int totalSize = forwardEdges.size() + backwardEdges.size();\n    List<GraphEdge<N, E>> edges = Lists.newArrayListWithCapacity(totalSize);\n    edges.addAll(forwardEdges);\n    edges.addAll(backwardEdges);\n    return edges;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "LinkedDirectedGraph.getNode",
    "class_name": "com.google.javascript.jscomp.graph.LinkedDirectedGraph",
    "signature": "com.google.javascript.jscomp.graph.LinkedDirectedGraph.getNode(N)",
    "snippet": "  @Override\n  public GraphNode<N, E> getNode(N nodeValue) {\n    return getDirectedGraphNode(nodeValue);\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "LinkedDirectedGraph.getNodes",
    "class_name": "com.google.javascript.jscomp.graph.LinkedDirectedGraph",
    "signature": "com.google.javascript.jscomp.graph.LinkedDirectedGraph.getNodes()",
    "snippet": "  @Override\n  public List<GraphNode<N, E>> getNodes() {\n    List<GraphNode<N, E>> list = Lists.newArrayList();\n    list.addAll(nodes.values());\n    return list;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "LinkedDirectedGraphEdge.getDestination",
    "class_name": "com.google.javascript.jscomp.graph.LinkedDirectedGraph$LinkedDirectedGraphEdge",
    "signature": "com.google.javascript.jscomp.graph.LinkedDirectedGraph$LinkedDirectedGraphEdge.getDestination()",
    "snippet": "    @Override\n    public DiGraphNode<N, E> getDestination() {\n      return destNode;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "LinkedDirectedGraphEdge.getValue",
    "class_name": "com.google.javascript.jscomp.graph.LinkedDirectedGraph$LinkedDirectedGraphEdge",
    "signature": "com.google.javascript.jscomp.graph.LinkedDirectedGraph$LinkedDirectedGraphEdge.getValue()",
    "snippet": "    @Override\n    public E getValue() {\n      return value;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "LinkedDirectedGraphNode.getAnnotation",
    "class_name": "com.google.javascript.jscomp.graph.LinkedDirectedGraph$LinkedDirectedGraphNode",
    "signature": "com.google.javascript.jscomp.graph.LinkedDirectedGraph$LinkedDirectedGraphNode.getAnnotation()",
    "snippet": "    @SuppressWarnings(\"unchecked\")\n    @Override\n    public <A extends Annotation> A getAnnotation() {\n      return (A) annotation;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "LinkedDirectedGraphNode.getInEdges",
    "class_name": "com.google.javascript.jscomp.graph.LinkedDirectedGraph$LinkedDirectedGraphNode",
    "signature": "com.google.javascript.jscomp.graph.LinkedDirectedGraph$LinkedDirectedGraphNode.getInEdges()",
    "snippet": "    @Override\n    public List<DiGraphEdge<N, E>> getInEdges() {\n      return inEdgeList;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "LinkedDirectedGraphNode.getOutEdges",
    "class_name": "com.google.javascript.jscomp.graph.LinkedDirectedGraph$LinkedDirectedGraphNode",
    "signature": "com.google.javascript.jscomp.graph.LinkedDirectedGraph$LinkedDirectedGraphNode.getOutEdges()",
    "snippet": "    @Override\n    public List<DiGraphEdge<N, E>> getOutEdges() {\n      return outEdgeList;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "LinkedDirectedGraphNode.getValue",
    "class_name": "com.google.javascript.jscomp.graph.LinkedDirectedGraph$LinkedDirectedGraphNode",
    "signature": "com.google.javascript.jscomp.graph.LinkedDirectedGraph$LinkedDirectedGraphNode.getValue()",
    "snippet": "    @Override\n    public N getValue() {\n      return value;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "LinkedDirectedGraphNode.setAnnotation",
    "class_name": "com.google.javascript.jscomp.graph.LinkedDirectedGraph$LinkedDirectedGraphNode",
    "signature": "com.google.javascript.jscomp.graph.LinkedDirectedGraph$LinkedDirectedGraphNode.setAnnotation(Annotation)",
    "snippet": "    @Override\n    public void setAnnotation(Annotation data) {\n      annotation = data;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "StandardUnionFind.StandardUnionFind",
    "class_name": "com.google.javascript.jscomp.graph.StandardUnionFind",
    "signature": "com.google.javascript.jscomp.graph.StandardUnionFind.StandardUnionFind()",
    "snippet": "  public StandardUnionFind() {\n  }",
    "comment": "Creates an empty UnionFind structure. */",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "StandardUnionFind.add",
    "class_name": "com.google.javascript.jscomp.graph.StandardUnionFind",
    "signature": "com.google.javascript.jscomp.graph.StandardUnionFind.add(E)",
    "snippet": "  public void add(E e) {\n    union(e, e);\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "StandardUnionFind.findRoot",
    "class_name": "com.google.javascript.jscomp.graph.StandardUnionFind",
    "signature": "com.google.javascript.jscomp.graph.StandardUnionFind.findRoot(Node)",
    "snippet": "  private Node<E> findRoot(Node<E> node) {\n    if (node.parent != node) {\n      node.parent = findRoot(node.parent);\n    }\n    return node.parent;\n  }",
    "comment": " Given a {@link Node}, walk the parent field as far as possible, until reaching the root, which is the {@link Node} for the current representative of this equivalence class. To achieve low runtime complexity, also compress the path, by making each node a direct child of the root. ",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "StandardUnionFind.findRootOrCreateNode",
    "class_name": "com.google.javascript.jscomp.graph.StandardUnionFind",
    "signature": "com.google.javascript.jscomp.graph.StandardUnionFind.findRootOrCreateNode(E)",
    "snippet": "  private Node<E> findRootOrCreateNode(E e) {\n    Node<E> node = elmap.get(e);\n    if (node != null) {\n      return findRoot(node);\n    }\n    node = new Node<E>(e);\n    elmap.put(e, node);\n    return node;\n  }",
    "comment": " If e is already in a non-trivial equivalence class, that is, a class with more than two elements, then return the {@link Node} corresponding to the representative element. Otherwise, if e sits in an equivalence class by itself, then create a {@link Node}, put it into elmap and return it. ",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "StandardUnionFind.union",
    "class_name": "com.google.javascript.jscomp.graph.StandardUnionFind",
    "signature": "com.google.javascript.jscomp.graph.StandardUnionFind.union(E,E)",
    "snippet": "  public E union(E a, E b) {\n    Node<E> nodeA = findRootOrCreateNode(a);\n    Node<E> nodeB = findRootOrCreateNode(b);\n\n    if (nodeA == nodeB) {\n      return nodeA.element;\n    }\n    if (nodeA.rank > nodeB.rank) {\n      nodeB.parent = nodeA;\n      nodeA.size += nodeB.size;\n      return nodeA.element;\n    }\n    nodeA.parent = nodeB;\n    if (nodeA.rank == nodeB.rank) {\n      nodeB.rank++;\n    }\n    nodeB.size += nodeA.size;\n    return nodeB.element;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "Config.Config",
    "class_name": "com.google.javascript.jscomp.parsing.Config",
    "signature": "com.google.javascript.jscomp.parsing.Config.Config(JSTypeRegistry,Set,boolean)",
    "snippet": "  Config(JSTypeRegistry registry, Set<String> annotationWhitelist,\n      boolean isIdeMode) {\n    this.registry = registry;\n    this.annotationNames = buildAnnotationNames(annotationWhitelist);\n    this.parseJsDocDocumentation = isIdeMode;\n    this.isIdeMode = isIdeMode;\n  }",
    "comment": " Annotation names. ",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "Config.buildAnnotationNames",
    "class_name": "com.google.javascript.jscomp.parsing.Config",
    "signature": "com.google.javascript.jscomp.parsing.Config.buildAnnotationNames(Set)",
    "snippet": "  private static Map<String, Annotation> buildAnnotationNames(\n      Set<String> annotationWhitelist) {\n    ImmutableMap.Builder<String, Annotation> annotationBuilder =\n        ImmutableMap.builder();\n    annotationBuilder.putAll(Annotation.recognizedAnnotations);\n    for (String unrecognizedAnnotation : annotationWhitelist) {\n      if (!Annotation.recognizedAnnotations.containsKey(\n              unrecognizedAnnotation)) {\n        annotationBuilder.put(\n            unrecognizedAnnotation, Annotation.NOT_IMPLEMENTED);\n      }\n    }\n    return annotationBuilder.build();\n  }",
    "comment": " Create the annotation names from the user-specified annotation whitelist. ",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "IRFactory.justTransform",
    "class_name": "com.google.javascript.jscomp.parsing.IRFactory",
    "signature": "com.google.javascript.jscomp.parsing.IRFactory.justTransform(AstNode)",
    "snippet": "  private Node justTransform(AstNode node) {\n    return transformDispatcher.process(node);\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "IRFactory.position2charno",
    "class_name": "com.google.javascript.jscomp.parsing.IRFactory",
    "signature": "com.google.javascript.jscomp.parsing.IRFactory.position2charno(int)",
    "snippet": "  private int position2charno(int position) {\n    int lineIndex = sourceString.lastIndexOf('\\n', position);\n    if (lineIndex == -1) {\n      return position;\n    } else {\n      // Subtract one for initial position being 0.\n      return position - lineIndex - 1;\n    }\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "IRFactory.transform",
    "class_name": "com.google.javascript.jscomp.parsing.IRFactory",
    "signature": "com.google.javascript.jscomp.parsing.IRFactory.transform(AstNode)",
    "snippet": "  private Node transform(AstNode node) {\n    String jsDoc = node.getJsDoc();\n    NodeWithJsDoc nodeWithJsDoc = null;\n    if (jsDoc != null) {\n      nodeWithJsDoc = new NodeWithJsDoc();\n      nodesWithJsDoc.put(jsDoc, nodeWithJsDoc);\n    }\n\n    Node irNode = justTransform(node);\n    if (nodeWithJsDoc != null) {\n      nodeWithJsDoc.node = irNode;\n    }\n\n    // If we have a named function, set the position to that of the name.\n    if (irNode.getType() == Token.FUNCTION &&\n        irNode.getFirstChild().getLineno() != -1) {\n      irNode.setLineno(irNode.getFirstChild().getLineno());\n      irNode.setCharno(irNode.getFirstChild().getCharno());\n    } else {\n      if (irNode.getLineno() == -1) {\n        // If we didn't already set the line, then set it now.  This avoids\n        // cases like ParenthesizedExpression where we just return a previous\n        // node, but don't want the new node to get its parent's line number.\n        int lineno = node.getLineno();\n        irNode.setLineno(lineno);\n        int charno = position2charno(node.getAbsolutePosition());\n        irNode.setCharno(charno);\n      }\n    }\n    return irNode;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "IRFactory.transformTokenType",
    "class_name": "com.google.javascript.jscomp.parsing.IRFactory",
    "signature": "com.google.javascript.jscomp.parsing.IRFactory.transformTokenType(int)",
    "snippet": "  private static int transformTokenType(int token) {\n    switch (token) {\n      case com.google.javascript.jscomp.mozilla.rhino.Token.ERROR:\n        return Token.ERROR;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.EOF:\n        return Token.EOF;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.EOL:\n        return Token.EOL;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.ENTERWITH:\n        return Token.ENTERWITH;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.LEAVEWITH:\n        return Token.LEAVEWITH;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.RETURN:\n        return Token.RETURN;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.GOTO:\n        return Token.GOTO;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.IFEQ:\n        return Token.IFEQ;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.IFNE:\n        return Token.IFNE;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.SETNAME:\n        return Token.SETNAME;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.BITOR:\n        return Token.BITOR;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.BITXOR:\n        return Token.BITXOR;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.BITAND:\n        return Token.BITAND;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.EQ:\n        return Token.EQ;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.NE:\n        return Token.NE;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.LT:\n        return Token.LT;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.LE:\n        return Token.LE;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.GT:\n        return Token.GT;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.GE:\n        return Token.GE;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.LSH:\n        return Token.LSH;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.RSH:\n        return Token.RSH;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.URSH:\n        return Token.URSH;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.ADD:\n        return Token.ADD;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.SUB:\n        return Token.SUB;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.MUL:\n        return Token.MUL;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.DIV:\n        return Token.DIV;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.MOD:\n        return Token.MOD;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.NOT:\n        return Token.NOT;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.BITNOT:\n        return Token.BITNOT;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.POS:\n        return Token.POS;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.NEG:\n        return Token.NEG;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.NEW:\n        return Token.NEW;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.DELPROP:\n        return Token.DELPROP;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.TYPEOF:\n        return Token.TYPEOF;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.GETPROP:\n        return Token.GETPROP;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.SETPROP:\n        return Token.SETPROP;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.GETELEM:\n        return Token.GETELEM;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.SETELEM:\n        return Token.SETELEM;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.CALL:\n        return Token.CALL;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.NAME:\n        return Token.NAME;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.NUMBER:\n        return Token.NUMBER;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.STRING:\n        return Token.STRING;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.NULL:\n        return Token.NULL;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.THIS:\n        return Token.THIS;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.FALSE:\n        return Token.FALSE;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.TRUE:\n        return Token.TRUE;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.SHEQ:\n        return Token.SHEQ;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.SHNE:\n        return Token.SHNE;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.REGEXP:\n        return Token.REGEXP;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.BINDNAME:\n        return Token.BINDNAME;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.THROW:\n        return Token.THROW;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.RETHROW:\n        return Token.RETHROW;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.IN:\n        return Token.IN;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.INSTANCEOF:\n        return Token.INSTANCEOF;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.LOCAL_LOAD:\n        return Token.LOCAL_LOAD;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.GETVAR:\n        return Token.GETVAR;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.SETVAR:\n        return Token.SETVAR;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.CATCH_SCOPE:\n        return Token.CATCH_SCOPE;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.ENUM_INIT_KEYS:\n        return Token.ENUM_INIT_KEYS;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.ENUM_INIT_VALUES:\n        return Token.ENUM_INIT_VALUES;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.ENUM_NEXT:\n        return Token.ENUM_NEXT;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.ENUM_ID:\n        return Token.ENUM_ID;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.THISFN:\n        return Token.THISFN;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.RETURN_RESULT:\n        return Token.RETURN_RESULT;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.ARRAYLIT:\n        return Token.ARRAYLIT;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.OBJECTLIT:\n        return Token.OBJECTLIT;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.GET_REF:\n        return Token.GET_REF;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.SET_REF:\n        return Token.SET_REF;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.DEL_REF:\n        return Token.DEL_REF;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.REF_CALL:\n        return Token.REF_CALL;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.REF_SPECIAL:\n        return Token.REF_SPECIAL;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.DEFAULTNAMESPACE:\n        return Token.DEFAULTNAMESPACE;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.ESCXMLTEXT:\n        return Token.ESCXMLTEXT;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.ESCXMLATTR:\n        return Token.ESCXMLATTR;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.REF_MEMBER:\n        return Token.REF_MEMBER;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.REF_NS_MEMBER:\n        return Token.REF_NS_MEMBER;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.REF_NAME:\n        return Token.REF_NAME;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.REF_NS_NAME:\n        return Token.REF_NS_NAME;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.TRY:\n        return Token.TRY;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.SEMI:\n        return Token.SEMI;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.LB:\n        return Token.LB;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.RB:\n        return Token.RB;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.LC:\n        return Token.LC;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.RC:\n        return Token.RC;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.LP:\n        return Token.LP;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.RP:\n        return Token.RP;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.COMMA:\n        return Token.COMMA;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.ASSIGN:\n        return Token.ASSIGN;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.ASSIGN_BITOR:\n        return Token.ASSIGN_BITOR;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.ASSIGN_BITXOR:\n        return Token.ASSIGN_BITXOR;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.ASSIGN_BITAND:\n        return Token.ASSIGN_BITAND;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.ASSIGN_LSH:\n        return Token.ASSIGN_LSH;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.ASSIGN_RSH:\n        return Token.ASSIGN_RSH;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.ASSIGN_URSH:\n        return Token.ASSIGN_URSH;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.ASSIGN_ADD:\n        return Token.ASSIGN_ADD;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.ASSIGN_SUB:\n        return Token.ASSIGN_SUB;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.ASSIGN_MUL:\n        return Token.ASSIGN_MUL;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.ASSIGN_DIV:\n        return Token.ASSIGN_DIV;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.ASSIGN_MOD:\n        return Token.ASSIGN_MOD;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.HOOK:\n        return Token.HOOK;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.COLON:\n        return Token.COLON;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.OR:\n        return Token.OR;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.AND:\n        return Token.AND;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.INC:\n        return Token.INC;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.DEC:\n        return Token.DEC;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.DOT:\n        return Token.DOT;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.FUNCTION:\n        return Token.FUNCTION;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.EXPORT:\n        return Token.EXPORT;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.IMPORT:\n        return Token.IMPORT;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.IF:\n        return Token.IF;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.ELSE:\n        return Token.ELSE;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.SWITCH:\n        return Token.SWITCH;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.CASE:\n        return Token.CASE;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.DEFAULT:\n        return Token.DEFAULT;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.WHILE:\n        return Token.WHILE;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.DO:\n        return Token.DO;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.FOR:\n        return Token.FOR;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.BREAK:\n        return Token.BREAK;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.CONTINUE:\n        return Token.CONTINUE;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.VAR:\n        return Token.VAR;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.WITH:\n        return Token.WITH;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.CATCH:\n        return Token.CATCH;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.FINALLY:\n        return Token.FINALLY;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.VOID:\n        return Token.VOID;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.RESERVED:\n        return Token.RESERVED;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.EMPTY:\n        return Token.EMPTY;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.BLOCK:\n        return Token.BLOCK;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.LABEL:\n        return Token.LABEL;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.TARGET:\n        return Token.TARGET;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.LOOP:\n        return Token.LOOP;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.EXPR_VOID:\n        return Token.EXPR_VOID;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.EXPR_RESULT:\n        return Token.EXPR_RESULT;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.JSR:\n        return Token.JSR;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.SCRIPT:\n        return Token.SCRIPT;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.TYPEOFNAME:\n        return Token.TYPEOFNAME;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.USE_STACK:\n        return Token.USE_STACK;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.SETPROP_OP:\n        return Token.SETPROP_OP;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.SETELEM_OP:\n        return Token.SETELEM_OP;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.LOCAL_BLOCK:\n        return Token.LOCAL_BLOCK;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.SET_REF_OP:\n        return Token.SET_REF_OP;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.DOTDOT:\n        return Token.DOTDOT;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.COLONCOLON:\n        return Token.COLONCOLON;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.XML:\n        return Token.XML;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.DOTQUERY:\n        return Token.DOTQUERY;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.XMLATTR:\n        return Token.XMLATTR;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.XMLEND:\n        return Token.XMLEND;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.TO_OBJECT:\n        return Token.TO_OBJECT;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.TO_DOUBLE:\n        return Token.TO_DOUBLE;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.GET:\n        return Token.GET;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.SET:\n        return Token.SET;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.CONST:\n        return Token.CONST;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.SETCONST:\n        return Token.SETCONST;\n      case com.google.javascript.jscomp.mozilla.rhino.Token.DEBUGGER:\n        return Token.DEBUGGER;\n    }\n\n    // Token without name\n    throw new IllegalStateException(String.valueOf(token));\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "IRFactory.transformTree",
    "class_name": "com.google.javascript.jscomp.parsing.IRFactory",
    "signature": "com.google.javascript.jscomp.parsing.IRFactory.transformTree(AstRoot,String,Config,ErrorReporter)",
    "snippet": "  public static Node transformTree(AstRoot node,\n                                   String sourceString,\n                                   Config config,\n                                   ErrorReporter errorReporter) {\n    IRFactory irFactory = new IRFactory(sourceString, node.getSourceName(),\n        config, errorReporter);\n    Node irNode = irFactory.transform(node);\n    // @license text gets appended onto the fileLevelJsDocBuilder as found,\n    // and stored straight into the JSDocInfo for the root node.\n    Node.FileLevelJsDocBuilder fileLevelJsDocBuilder =\n        irNode.getJsDocBuilderForNode();\n    // fileOverviewInfo stores the last bit of fileoverview data we saw.\n    // We only permit one, so throwing away extras is fair.\n    // The fileOverviewInfo gets passed into parseJSDocInfo so that\n    // it can detect when multiple @fileoverviews exist in the same file.\n    JSDocInfo fileOverviewInfo = null;\n    if (node.getComments() != null) {\n      for (Comment comment : node.getComments()) {\n        if (comment.getCommentType() == JSDOC) {\n          JsDocInfoParser jsDocParser =\n              irFactory.createJsDocInfoParser(comment.getValue(),\n                  comment.getLineno(), comment.getAbsolutePosition(),\n                  fileLevelJsDocBuilder, fileOverviewInfo);\n          if (jsDocParser.getFileOverviewJSDocInfo() != fileOverviewInfo) {\n            fileOverviewInfo = jsDocParser.getFileOverviewJSDocInfo();\n          } else {\n            JSDocInfo info = jsDocParser.retrieveAndResetParsedJSDocInfo();\n            if (info != null) {\n              irFactory.attachJsDoc(comment, info);\n            }\n          }\n        }\n      }\n\n      // Only after we've seen all @fileoverview entries, attach the\n      // last one to the root node, and copy the found license strings\n      // to that node.\n      if (fileOverviewInfo != null) {\n        if ((irNode.getJSDocInfo() != null) &&\n            (irNode.getJSDocInfo().getLicense() != null)) {\n          fileOverviewInfo.setLicense(irNode.getJSDocInfo().getLicense());\n        }\n        irNode.setJSDocInfo(fileOverviewInfo);\n      }\n    }\n    return irNode;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "TransformDispatcher.isDirective",
    "class_name": "com.google.javascript.jscomp.parsing.IRFactory$TransformDispatcher",
    "signature": "com.google.javascript.jscomp.parsing.IRFactory$TransformDispatcher.isDirective(Node)",
    "snippet": "    private boolean isDirective(Node n) {\n      if (n == null) return false;\n\n      int nType = n.getType();\n      return (nType == Token.EXPR_RESULT || nType == Token.EXPR_VOID) &&\n          n.getFirstChild().getType() == Token.STRING &&\n          ALLOWED_DIRECTIVES.contains(n.getFirstChild().getString());\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "TransformDispatcher.parseDirectives",
    "class_name": "com.google.javascript.jscomp.parsing.IRFactory$TransformDispatcher",
    "signature": "com.google.javascript.jscomp.parsing.IRFactory$TransformDispatcher.parseDirectives(Node)",
    "snippet": "    private void parseDirectives(Node node) {\n      // Remove all the directives, and encode them in the AST.\n      Set<String> directives = null;\n      while (isDirective(node.getFirstChild())) {\n        String directive = node.removeFirstChild().getFirstChild().getString();\n        if (directives == null) {\n          directives = Sets.newHashSet(directive);\n        } else {\n          directives.add(directive);\n        }\n      }\n\n      if (directives != null) {\n        node.setDirectives(directives);\n      }\n    }",
    "comment": " Parse the directives, encode them in the AST, and remove their nodes.  For information on ES5 directives, see section 14.1 of Ecma-262, Edition 5.  It would be nice if Rhino would eventually take care of this for us, but right now their directive-processing is a one-off. ",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "TransformDispatcher.processAstRoot",
    "class_name": "com.google.javascript.jscomp.parsing.IRFactory$TransformDispatcher",
    "signature": "com.google.javascript.jscomp.parsing.IRFactory$TransformDispatcher.processAstRoot(AstRoot)",
    "snippet": "    @Override\n    Node processAstRoot(AstRoot rootNode) {\n      Node node = new ScriptOrFnNode(Token.SCRIPT);\n      for (com.google.javascript.jscomp.mozilla.rhino.Node child : rootNode) {\n        node.addChildToBack(transform((AstNode)child));\n      }\n      parseDirectives(node);\n      return node;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "TransformDispatcher.processBlock",
    "class_name": "com.google.javascript.jscomp.parsing.IRFactory$TransformDispatcher",
    "signature": "com.google.javascript.jscomp.parsing.IRFactory$TransformDispatcher.processBlock(Block)",
    "snippet": "    @Override\n    Node processBlock(Block blockNode) {\n      return processGeneric(blockNode);\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "TransformDispatcher.processCatchClause",
    "class_name": "com.google.javascript.jscomp.parsing.IRFactory$TransformDispatcher",
    "signature": "com.google.javascript.jscomp.parsing.IRFactory$TransformDispatcher.processCatchClause(CatchClause)",
    "snippet": "    @Override\n    Node processCatchClause(CatchClause clauseNode) {\n      AstNode catchVar = clauseNode.getVarName();\n      Node node = new Node(Token.CATCH, transform(catchVar));\n      if (clauseNode.getCatchCondition() != null) {\n        node.addChildToBack(transform(clauseNode.getCatchCondition()));\n      } else {\n        Node catchCondition = new Node(Token.EMPTY);\n        // Old Rhino used the position of the catchVar as the position\n        // for the (nonexistent) error being caught.\n        catchCondition.setLineno(catchVar.getLineno());\n        int clauseAbsolutePosition =\n            position2charno(catchVar.getAbsolutePosition());\n        catchCondition.setCharno(clauseAbsolutePosition);\n        node.addChildToBack(catchCondition);\n      }\n      node.addChildToBack(transform(clauseNode.getBody()));\n      return node;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "TransformDispatcher.processFunctionNode",
    "class_name": "com.google.javascript.jscomp.parsing.IRFactory$TransformDispatcher",
    "signature": "com.google.javascript.jscomp.parsing.IRFactory$TransformDispatcher.processFunctionNode(FunctionNode)",
    "snippet": "   @Override\n  Node processFunctionNode(FunctionNode functionNode) {\n      Name name = functionNode.getFunctionName();\n      Boolean isUnnamedFunction = false;\n      if (name == null) {\n        name = new Name();\n        name.setIdentifier(\"\");\n        isUnnamedFunction = true;\n      }\n      Node node = new com.google.javascript.rhino.FunctionNode(\n          name.getIdentifier());\n      node.putProp(Node.SOURCENAME_PROP, functionNode.getSourceName());\n      Node newName = transform(name);\n      if (isUnnamedFunction) {\n        // Old Rhino tagged the empty name node with the line number of the\n        // declaration.\n        newName.setLineno(functionNode.getLineno());\n        // TODO(user) Mark line number of paren correctly.\n        // Same problem as below - the left paren might not be on the\n        // same line as the function keyword.\n        int lpColumn = functionNode.getAbsolutePosition() +\n            functionNode.getLp();\n        newName.setCharno(position2charno(lpColumn));\n      }\n\n      node.addChildToBack(newName);\n      Node lp = new Node(Token.LP);\n      // The left paren's complicated because it's not represented by an\n      // AstNode, so there's nothing that has the actual line number that it\n      // appeared on.  We know the paren has to appear on the same line as the\n      // function name (or else a semicolon will be inserted.)  If there's no\n      // function name, assume the paren was on the same line as the function.\n      // TODO(user): Mark line number of paren correctly.\n      Name fnName = functionNode.getFunctionName();\n      if (fnName != null) {\n        lp.setLineno(fnName.getLineno());\n      } else {\n        lp.setLineno(functionNode.getLineno());\n      }\n      int lparenCharno = functionNode.getLp() +\n          functionNode.getAbsolutePosition();\n\n      lp.setCharno(position2charno(lparenCharno));\n      for (AstNode param : functionNode.getParams()) {\n        lp.addChildToBack(transform(param));\n      }\n      node.addChildToBack(lp);\n\n      Node bodyNode = transform(functionNode.getBody());\n      parseDirectives(bodyNode);\n      node.addChildToBack(bodyNode);\n     return node;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "TransformDispatcher.processGeneric",
    "class_name": "com.google.javascript.jscomp.parsing.IRFactory$TransformDispatcher",
    "signature": "com.google.javascript.jscomp.parsing.IRFactory$TransformDispatcher.processGeneric(Node)",
    "snippet": "    private Node processGeneric(\n        com.google.javascript.jscomp.mozilla.rhino.Node n) {\n      Node node = new Node(transformTokenType(n.getType()));\n      for (com.google.javascript.jscomp.mozilla.rhino.Node child : n) {\n        node.addChildToBack(transform((AstNode)child));\n      }\n      return node;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "TransformDispatcher.processIfStatement",
    "class_name": "com.google.javascript.jscomp.parsing.IRFactory$TransformDispatcher",
    "signature": "com.google.javascript.jscomp.parsing.IRFactory$TransformDispatcher.processIfStatement(IfStatement)",
    "snippet": "    @Override\n    Node processIfStatement(IfStatement statementNode) {\n      Node node = new Node(Token.IF);\n      node.addChildToBack(transform(statementNode.getCondition()));\n      node.addChildToBack(transform(statementNode.getThenPart()));\n      if (statementNode.getElsePart() != null) {\n        node.addChildToBack(transform(statementNode.getElsePart()));\n      }\n      return node;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "TransformDispatcher.processInfixExpression",
    "class_name": "com.google.javascript.jscomp.parsing.IRFactory$TransformDispatcher",
    "signature": "com.google.javascript.jscomp.parsing.IRFactory$TransformDispatcher.processInfixExpression(InfixExpression)",
    "snippet": "    @Override\n    Node processInfixExpression(InfixExpression exprNode) {\n      Node n =  new Node(\n          transformTokenType(exprNode.getType()),\n          transform(exprNode.getLeft()),\n          transform(exprNode.getRight()));\n      // Set the line number here so we can fine-tune it in ways transform\n      // doesn't do.\n      n.setLineno(exprNode.getLineno());\n      // Position in new ASTNode is to start of expression, but old-fashioned\n      // line numbers from Node reference the operator token.  Add the offset\n      // to the operator to get the correct character number.\n      n.setCharno(position2charno(exprNode.getAbsolutePosition() +\n          exprNode.getOperatorPosition()));\n      return n;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "TransformDispatcher.processKeywordLiteral",
    "class_name": "com.google.javascript.jscomp.parsing.IRFactory$TransformDispatcher",
    "signature": "com.google.javascript.jscomp.parsing.IRFactory$TransformDispatcher.processKeywordLiteral(KeywordLiteral)",
    "snippet": "    @Override\n    Node processKeywordLiteral(KeywordLiteral literalNode) {\n      return new Node(transformTokenType(literalNode.getType()));\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "TransformDispatcher.processName",
    "class_name": "com.google.javascript.jscomp.parsing.IRFactory$TransformDispatcher",
    "signature": "com.google.javascript.jscomp.parsing.IRFactory$TransformDispatcher.processName(Name)",
    "snippet": "    @Override\n    Node processName(Name nameNode) {\n      return Node.newString(Token.NAME, nameNode.getIdentifier());\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "TransformDispatcher.processReturnStatement",
    "class_name": "com.google.javascript.jscomp.parsing.IRFactory$TransformDispatcher",
    "signature": "com.google.javascript.jscomp.parsing.IRFactory$TransformDispatcher.processReturnStatement(ReturnStatement)",
    "snippet": "    @Override\n    Node processReturnStatement(ReturnStatement statementNode) {\n      Node node = new Node(Token.RETURN);\n      if (statementNode.getReturnValue() != null) {\n        node.addChildToBack(transform(statementNode.getReturnValue()));\n      }\n      return node;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "TransformDispatcher.processScope",
    "class_name": "com.google.javascript.jscomp.parsing.IRFactory$TransformDispatcher",
    "signature": "com.google.javascript.jscomp.parsing.IRFactory$TransformDispatcher.processScope(Scope)",
    "snippet": "    @Override\n    Node processScope(Scope scopeNode) {\n      return processGeneric(scopeNode);\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "TransformDispatcher.processTryStatement",
    "class_name": "com.google.javascript.jscomp.parsing.IRFactory$TransformDispatcher",
    "signature": "com.google.javascript.jscomp.parsing.IRFactory$TransformDispatcher.processTryStatement(TryStatement)",
    "snippet": "    @Override\n    Node processTryStatement(TryStatement statementNode) {\n      Node node = new Node(Token.TRY, transform(statementNode.getTryBlock()));\n      Node block = new Node(Token.BLOCK);\n      boolean lineSet = false;\n\n      for (CatchClause cc : statementNode.getCatchClauses()) {\n        // Mark the enclosing block at the same line as the first catch\n        // clause.\n        if (lineSet == false) {\n            block.setLineno(cc.getLineno());\n            lineSet = true;\n        }\n        block.addChildToBack(transform(cc));\n      }\n      node.addChildToBack(block);\n\n      AstNode finallyBlock = statementNode.getFinallyBlock();\n      if (finallyBlock != null) {\n        node.addChildToBack(transform(finallyBlock));\n      }\n\n      // If we didn't set the line on the catch clause, then\n      // we've got an empty catch clause.  Set its line to be the same\n      // as the finally block (to match Old Rhino's behavior.)\n      if ((lineSet == false) && (finallyBlock != null)) {\n        block.setLineno(finallyBlock.getLineno());\n      }\n\n      return node;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "JsDocInfoParser.JsDocInfoParser",
    "class_name": "com.google.javascript.jscomp.parsing.JsDocInfoParser",
    "signature": "com.google.javascript.jscomp.parsing.JsDocInfoParser.JsDocInfoParser(JsDocTokenStream,String,Config,ErrorReporter)",
    "snippet": "  JsDocInfoParser(JsDocTokenStream stream,\n                  String sourceName,\n                  Config config,\n                  ErrorReporter errorReporter) {\n    this.stream = stream;\n    this.sourceName = sourceName;\n    this.typeRegistry = config.registry;\n    this.jsdocBuilder = new JSDocInfoBuilder(config.parseJsDocDocumentation);\n    this.annotationNames = config.annotationNames;\n\n    this.errorReporter = errorReporter;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "JsDocInfoParser.createJSTypeExpression",
    "class_name": "com.google.javascript.jscomp.parsing.JsDocInfoParser",
    "signature": "com.google.javascript.jscomp.parsing.JsDocInfoParser.createJSTypeExpression(Node)",
    "snippet": "  private JSTypeExpression createJSTypeExpression(Node n) {\n    return n == null ? null :\n        new JSTypeExpression(n, sourceName, typeRegistry);\n  }",
    "comment": " Constructs a new {@code JSTypeExpression}. @param n A node. May be null. ",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "JsDocInfoParser.current",
    "class_name": "com.google.javascript.jscomp.parsing.JsDocInfoParser",
    "signature": "com.google.javascript.jscomp.parsing.JsDocInfoParser.current()",
    "snippet": "  private JsDocToken current() {\n    JsDocToken t = unreadToken;\n    unreadToken = NO_UNREAD_TOKEN;\n    return t;\n  }",
    "comment": " Gets the current token, invalidating it in the process. ",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "JsDocInfoParser.eatTokensUntilEOL",
    "class_name": "com.google.javascript.jscomp.parsing.JsDocInfoParser",
    "signature": "com.google.javascript.jscomp.parsing.JsDocInfoParser.eatTokensUntilEOL()",
    "snippet": "  private JsDocToken eatTokensUntilEOL() {\n    return eatTokensUntilEOL(next());\n  }",
    "comment": " Eats tokens until {@link JsDocToken#EOL} included, and switches back the state to {@link State#SEARCHING_ANNOTATION}. ",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "JsDocInfoParser.eatTokensUntilEOL",
    "class_name": "com.google.javascript.jscomp.parsing.JsDocInfoParser",
    "signature": "com.google.javascript.jscomp.parsing.JsDocInfoParser.eatTokensUntilEOL(JsDocToken)",
    "snippet": "  private JsDocToken eatTokensUntilEOL(JsDocToken token) {\n    do {\n      if (token == JsDocToken.EOL || token == JsDocToken.EOC ||\n          token == JsDocToken.EOF) {\n        state = State.SEARCHING_ANNOTATION;\n        return token;\n      }\n      token = next();\n    } while (true);\n  }",
    "comment": " Eats tokens until {@link JsDocToken#EOL} included, and switches back the state to {@link State#SEARCHING_ANNOTATION}. ",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "JsDocInfoParser.extractBlockComment",
    "class_name": "com.google.javascript.jscomp.parsing.JsDocInfoParser",
    "signature": "com.google.javascript.jscomp.parsing.JsDocInfoParser.extractBlockComment(JsDocToken)",
    "snippet": "  private ExtractionInfo extractBlockComment(JsDocToken token) {\n    StringBuilder builder = new StringBuilder();\n\n    boolean ignoreStar = true;\n\n    do {\n      switch (token) {\n        case ANNOTATION:\n        case EOC:\n        case EOF:\n          return new ExtractionInfo(builder.toString().trim(), token);\n\n        case STAR:\n          if (!ignoreStar) {\n            if (builder.length() > 0) {\n              builder.append(' ');\n            }\n\n            builder.append('*');\n          }\n\n          token = next();\n          continue;\n\n        case EOL:\n          ignoreStar = true;\n          builder.append('\\n');\n          token = next();\n          continue;\n\n        default:\n          if (!ignoreStar && builder.length() > 0) {\n            builder.append(' ');\n          }\n\n          ignoreStar = false;\n\n          builder.append(toString(token));\n\n          String line = stream.getRemainingJSDocLine();\n          line = trimEnd(line);\n          builder.append(line);\n          token = next();\n      }\n    } while (true);\n  }",
    "comment": " Extracts the top-level block comment from the JsDoc comment, if any. This method differs from the extractMultilineTextualBlock in that it terminates under different conditions (it doesn't have the same prechecks), it does not first read in the remaining of the current line and its conditions for ignoring the \"*\" (STAR) are different.  @param token The starting token.  @return The extraction information. ",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "JsDocInfoParser.extractMultilineTextualBlock",
    "class_name": "com.google.javascript.jscomp.parsing.JsDocInfoParser",
    "signature": "com.google.javascript.jscomp.parsing.JsDocInfoParser.extractMultilineTextualBlock(JsDocToken)",
    "snippet": "  private ExtractionInfo extractMultilineTextualBlock(JsDocToken token) {\n    return extractMultilineTextualBlock(token, WhitespaceOption.SINGLE_LINE);\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "JsDocInfoParser.extractMultilineTextualBlock",
    "class_name": "com.google.javascript.jscomp.parsing.JsDocInfoParser",
    "signature": "com.google.javascript.jscomp.parsing.JsDocInfoParser.extractMultilineTextualBlock(JsDocToken,WhitespaceOption)",
    "snippet": "  private ExtractionInfo extractMultilineTextualBlock(JsDocToken token,\n                                                      WhitespaceOption option) {\n\n    if (token == JsDocToken.EOC || token == JsDocToken.EOL ||\n        token == JsDocToken.EOF) {\n      return new ExtractionInfo(\"\", token);\n    }\n\n    stream.update();\n    int startLineno = stream.getLineno();\n    int startCharno = stream.getCharno() + 1;\n\n    // Read the content from the first line.\n    String line = stream.getRemainingJSDocLine();\n\n    if (option != WhitespaceOption.PRESERVE) {\n      line = line.trim();\n    }\n\n    StringBuilder builder = new StringBuilder();\n    builder.append(line);\n\n    state = State.SEARCHING_ANNOTATION;\n    token = next();\n\n    boolean ignoreStar = false;\n\n    do {\n      switch (token) {\n        case ANNOTATION:\n        case EOC:\n        case EOF:\n          String multilineText = builder.toString();\n\n          if (option != WhitespaceOption.PRESERVE) {\n            multilineText = multilineText.trim();\n          }\n\n          int endLineno = stream.getLineno();\n          int endCharno = stream.getCharno();\n\n          if (multilineText.length() > 0) {\n            jsdocBuilder.markText(multilineText, startLineno, startCharno,\n                                  endLineno, endCharno);\n          }\n\n          return new ExtractionInfo(multilineText, token);\n\n        case STAR:\n          if (!ignoreStar) {\n            if (builder.length() > 0) {\n              builder.append(' ');\n            }\n\n            builder.append('*');\n          }\n\n          token = next();\n          continue;\n\n        case EOL:\n          if (option != WhitespaceOption.SINGLE_LINE) {\n            builder.append(\"\\n\");\n          }\n\n          ignoreStar = true;\n          token = next();\n          continue;\n\n        default:\n          ignoreStar = false;\n          state = State.SEARCHING_ANNOTATION;\n\n          if (builder.length() > 0) {\n            builder.append(' ');\n          }\n\n          builder.append(toString(token));\n\n          line = stream.getRemainingJSDocLine();\n\n          if (option != WhitespaceOption.PRESERVE) {\n            line = trimEnd(line);\n          }\n\n          builder.append(line);\n          token = next();\n      }\n    } while (true);\n  }",
    "comment": " Extracts the text found on the current line and all subsequent until either an annotation, end of comment or end of file is reached. Note that if this method detects an end of line as the first token, it will quit immediately (indicating that there is no text where it was expected).  Note that token = info.token; should be called after this method is used to update the token properly in the parser.  @param token The start token. @param option How to handle whitespace.  @return The extraction information. ",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "JsDocInfoParser.getFileOverviewJSDocInfo",
    "class_name": "com.google.javascript.jscomp.parsing.JsDocInfoParser",
    "signature": "com.google.javascript.jscomp.parsing.JsDocInfoParser.getFileOverviewJSDocInfo()",
    "snippet": "  JSDocInfo getFileOverviewJSDocInfo() {\n    return fileOverviewJSDocInfo;\n  }",
    "comment": " Gets the fileoverview JSDocInfo, if any. ",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "JsDocInfoParser.hasParsedFileOverviewDocInfo",
    "class_name": "com.google.javascript.jscomp.parsing.JsDocInfoParser",
    "signature": "com.google.javascript.jscomp.parsing.JsDocInfoParser.hasParsedFileOverviewDocInfo()",
    "snippet": "  private boolean hasParsedFileOverviewDocInfo() {\n    return jsdocBuilder.isPopulatedWithFileOverview();\n  }",
    "comment": " Determines whether the parser has been populated with docinfo with a fileoverview tag. ",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "JsDocInfoParser.match",
    "class_name": "com.google.javascript.jscomp.parsing.JsDocInfoParser",
    "signature": "com.google.javascript.jscomp.parsing.JsDocInfoParser.match(JsDocToken)",
    "snippet": "  private boolean match(JsDocToken token) {\n    unreadToken = next();\n    return unreadToken == token;\n  }",
    "comment": " Tests whether the next symbol of the token stream matches the specific token. ",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "JsDocInfoParser.newStringNode",
    "class_name": "com.google.javascript.jscomp.parsing.JsDocInfoParser",
    "signature": "com.google.javascript.jscomp.parsing.JsDocInfoParser.newStringNode(String)",
    "snippet": "  private Node newStringNode(String s) {\n    return Node.newString(s, stream.getLineno(), stream.getCharno());\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "JsDocInfoParser.next",
    "class_name": "com.google.javascript.jscomp.parsing.JsDocInfoParser",
    "signature": "com.google.javascript.jscomp.parsing.JsDocInfoParser.next()",
    "snippet": "  private JsDocToken next() {\n    if (unreadToken == NO_UNREAD_TOKEN) {\n      return stream.getJsDocToken();\n    } else {\n      return current();\n    }\n  }",
    "comment": " Gets the next token of the token stream or the buffered token if a matching was previously made. ",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "JsDocInfoParser.parse",
    "class_name": "com.google.javascript.jscomp.parsing.JsDocInfoParser",
    "signature": "com.google.javascript.jscomp.parsing.JsDocInfoParser.parse()",
    "snippet": "  boolean parse() {\n    int lineno;\n    int charno;\n\n    // JSTypes are represented as Rhino AST nodes, and then resolved later.\n    JSTypeExpression type;\n\n    state = State.SEARCHING_ANNOTATION;\n    JsDocToken token = next();\n\n    ExtractionInfo blockInfo = extractBlockComment(token);\n    token = blockInfo.token;\n\n    // If we have a block level comment, record it.\n    if (blockInfo.string.length() > 0) {\n      jsdocBuilder.recordBlockDescription(blockInfo.string);\n    }\n\n    // Parse the actual JsDoc.\n    retry: for (;;) {\n      switch (token) {\n        case ANNOTATION:\n          if (state == State.SEARCHING_ANNOTATION) {\n            state = State.SEARCHING_NEWLINE;\n            lineno = stream.getLineno();\n            charno = stream.getCharno();\n\n            String annotationName = stream.getString();\n            Annotation annotation = annotationNames.get(annotationName);\n            if (annotation == null) {\n              parser.addWarning(\"msg.bad.jsdoc.tag\", annotationName,\n                  stream.getLineno(), stream.getCharno());\n            } else {\n              // Mark the beginning of the annotation.\n              jsdocBuilder.markAnnotation(annotationName, lineno, charno);\n\n              switch (annotation) {\n                case AUTHOR:\n                  ExtractionInfo authorInfo = extractSingleLineBlock();\n                  String author = authorInfo.string;\n\n                  if (author.length() == 0) {\n                    parser.addWarning(\"msg.jsdoc.authormissing\",\n                          stream.getLineno(), stream.getCharno());\n                  } else {\n                    jsdocBuilder.addAuthor(author);\n                  }\n\n                  token = authorInfo.token;\n                  continue retry;\n\n                case CONSTANT:\n                  if (!jsdocBuilder.recordConstancy()) {\n                    parser.addWarning(\"msg.jsdoc.const\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case CONSTRUCTOR:\n                  if (!jsdocBuilder.recordConstructor()) {\n                    if (jsdocBuilder.isInterfaceRecorded()) {\n                      parser.addWarning(\"msg.jsdoc.interface.constructor\",\n                          stream.getLineno(), stream.getCharno());\n                    } else {\n                      parser.addWarning(\"msg.jsdoc.incompat.type\",\n                          stream.getLineno(), stream.getCharno());\n                    }\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case DEPRECATED:\n                  if (!jsdocBuilder.recordDeprecated()) {\n                    parser.addWarning(\"msg.jsdoc.deprecated\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n\n                  // Find the reason/description, if any.\n                  ExtractionInfo reasonInfo =\n                      extractMultilineTextualBlock(token);\n\n                  String reason = reasonInfo.string;\n\n                  if (reason.length() > 0) {\n                    jsdocBuilder.recordDeprecationReason(reason);\n                  }\n\n                  token = reasonInfo.token;\n                  continue retry;\n\n                case INTERFACE:\n                  if (!jsdocBuilder.recordInterface()) {\n                    if (jsdocBuilder.isConstructorRecorded()) {\n                      parser.addWarning(\"msg.jsdoc.interface.constructor\",\n                          stream.getLineno(), stream.getCharno());\n                    } else {\n                      parser.addWarning(\"msg.jsdoc.incompat.type\",\n                          stream.getLineno(), stream.getCharno());\n                    }\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case DESC:\n                  if (jsdocBuilder.isDescriptionRecorded()) {\n                    parser.addWarning(\"msg.jsdoc.desc.extra\",\n                        stream.getLineno(), stream.getCharno());\n                    token = eatTokensUntilEOL();\n                    continue retry;\n                  } else {\n                    ExtractionInfo descriptionInfo =\n                        extractMultilineTextualBlock(token);\n\n                    String description = descriptionInfo.string;\n\n                    jsdocBuilder.recordDescription(description);\n                    token = descriptionInfo.token;\n                    continue retry;\n                  }\n\n                case FILE_OVERVIEW:\n                  ExtractionInfo fileOverviewInfo =\n                      extractMultilineTextualBlock(token,\n                                                   WhitespaceOption.TRIM);\n\n                  String fileOverview = fileOverviewInfo.string;\n\n                  if (!jsdocBuilder.recordFileOverview(fileOverview) ||\n                      fileOverviewJSDocInfo != null) {\n                    parser.addWarning(\"msg.jsdoc.fileoverview.extra\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  token = fileOverviewInfo.token;\n                  continue retry;\n\n                case LICENSE:\n                case PRESERVE:\n                  ExtractionInfo preserveInfo =\n                      extractMultilineTextualBlock(token,\n                                                   WhitespaceOption.PRESERVE);\n\n                  String preserve = preserveInfo.string;\n\n                  if (preserve.length() > 0) {\n                    if (fileLevelJsDocBuilder != null) {\n                      fileLevelJsDocBuilder.append(preserve);\n                    }\n                  }\n\n                  token = preserveInfo.token;\n                  continue retry;\n\n                case ENUM:\n                  token = next();\n                  lineno = stream.getLineno();\n                  charno = stream.getCharno();\n\n                  type = null;\n                  if (token != JsDocToken.EOL && token != JsDocToken.EOC) {\n                    type = createJSTypeExpression(\n                        parseAndRecordTypeNode(token));\n                  }\n\n                  if (type == null) {\n                    type = createJSTypeExpression(newStringNode(\"number\"));\n                  }\n                  if (!jsdocBuilder.recordEnumParameterType(type)) {\n                    parser.addWarning(\"msg.jsdoc.incompat.type\", lineno, charno);\n                  }\n                  token = eatTokensUntilEOL(token);\n                  continue retry;\n\n                case EXPORT:\n                  if (!jsdocBuilder.recordExport()) {\n                    parser.addWarning(\"msg.jsdoc.export\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case EXTERNS:\n                  if (!jsdocBuilder.recordExterns()) {\n                    parser.addWarning(\"msg.jsdoc.externs\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case JAVA_DISPATCH:\n                  if (!jsdocBuilder.recordJavaDispatch()) {\n                    parser.addWarning(\"msg.jsdoc.javadispatch\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case EXTENDS:\n                case IMPLEMENTS:\n                  skipEOLs();\n                  token = next();\n                  lineno = stream.getLineno();\n                  charno = stream.getCharno();\n                  boolean matchingRc = false;\n\n                  if (token == JsDocToken.LC) {\n                    token = next();\n                    matchingRc = true;\n                  }\n\n                  if (token == JsDocToken.STRING) {\n                    Node typeNode = parseAndRecordTypeNameNode(\n                        token, lineno, charno, matchingRc);\n\n                    lineno = stream.getLineno();\n                    charno = stream.getCharno();\n\n                    typeNode = wrapNode(Token.BANG, typeNode);\n                    if (typeNode != null && !matchingRc) {\n                      typeNode.putBooleanProp(Node.BRACELESS_TYPE, true);\n                    }\n                    type = createJSTypeExpression(typeNode);\n\n                    if (annotation == Annotation.EXTENDS) {\n                      if (!jsdocBuilder.recordBaseType(type)) {\n                        parser.addWarning(\n                            \"msg.jsdoc.incompat.type\", lineno, charno);\n                      }\n                    } else {\n                      Preconditions.checkState(\n                          annotation == Annotation.IMPLEMENTS);\n                      if (!jsdocBuilder.recordImplementedInterface(type)) {\n                        parser.addWarning(\"msg.jsdoc.implements.duplicate\",\n                            lineno, charno);\n                      }\n                    }\n                    token = next();\n                    if (matchingRc) {\n                      if (token != JsDocToken.RC) {\n                        parser.addWarning(\"msg.jsdoc.missing.rc\",\n                            stream.getLineno(), stream.getCharno());\n                      }\n                    } else if (token != JsDocToken.EOL &&\n                        token != JsDocToken.EOF && token != JsDocToken.EOC) {\n                      parser.addWarning(\"msg.end.annotation.expected\",\n                          stream.getLineno(), stream.getCharno());\n                    }\n                  } else {\n                    parser.addWarning(\"msg.no.type.name\", lineno, charno);\n                  }\n                  token = eatTokensUntilEOL(token);\n                  continue retry;\n\n                case HIDDEN:\n                  if (!jsdocBuilder.recordHiddenness()) {\n                    parser.addWarning(\"msg.jsdoc.hidden\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case NO_ALIAS:\n                  if (!jsdocBuilder.recordNoAlias()) {\n                    parser.addWarning(\"msg.jsdoc.noalias\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case NO_TYPE_CHECK:\n                  if (!jsdocBuilder.recordNoTypeCheck()) {\n                    parser.addWarning(\"msg.jsdoc.nocheck\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case NOT_IMPLEMENTED:\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case INHERIT_DOC:\n                case OVERRIDE:\n                  if (!jsdocBuilder.recordOverride()) {\n                    parser.addWarning(\"msg.jsdoc.override\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case THROWS:\n                  skipEOLs();\n                  token = next();\n                  lineno = stream.getLineno();\n                  charno = stream.getCharno();\n                  type = null;\n\n                  if (token == JsDocToken.LC) {\n                    type = createJSTypeExpression(\n                        parseAndRecordTypeNode(token));\n\n                    if (type == null) {\n                      // parsing error reported during recursive descent\n                      // recovering parsing\n                      token = eatTokensUntilEOL();\n                      continue retry;\n                    }\n                  }\n\n                  // *Update* the token to that after the type annotation.\n                  token = current();\n\n                  // Save the throw type.\n                  jsdocBuilder.recordThrowType(type);\n\n                  // Find the throw's description (if applicable).\n                  ExtractionInfo descriptionInfo =\n                      extractMultilineTextualBlock(token);\n\n                  String description = descriptionInfo.string;\n\n                  if (description.length() > 0) {\n                    jsdocBuilder.recordThrowDescription(type, description);\n                  }\n\n                  token = descriptionInfo.token;\n                  continue retry;\n\n                case PARAM:\n                  skipEOLs();\n                  token = next();\n                  lineno = stream.getLineno();\n                  charno = stream.getCharno();\n                  type = null;\n\n                  if (token == JsDocToken.LC) {\n                    type = createJSTypeExpression(\n                        parseAndRecordParamTypeNode(token));\n\n                    if (type == null) {\n                      // parsing error reported during recursive descent\n                      // recovering parsing\n                      token = eatTokensUntilEOL();\n                      continue retry;\n                    }\n                    skipEOLs();\n                    token = next();\n                    lineno = stream.getLineno();\n                    charno = stream.getCharno();\n                  }\n\n                  String name = null;\n                  boolean isBracketedParam = JsDocToken.LB == token;\n                  if (isBracketedParam) {\n                    token = next();\n                  }\n\n                  if (JsDocToken.STRING != token) {\n                    parser.addWarning(\"msg.missing.variable.name\",\n                        lineno, charno);\n                  } else {\n                    name = stream.getString();\n\n                    if (isBracketedParam) {\n                      token = next();\n\n                      // Throw out JsDocToolkit's \"default\" parameter annotation.\n                      // It makes no sense under our type system.\n                      if (JsDocToken.EQUALS == token) {\n                        token = next();\n                        if (JsDocToken.STRING == token) {\n                          token = next();\n                        }\n                      }\n\n                      if (JsDocToken.RB != token) {\n                        reportTypeSyntaxWarning(\"msg.jsdoc.missing.rb\");\n                      } else if (type != null) {\n                        // Make the type expression optional, if it isn't\n                        // already.\n                        type = JSTypeExpression.makeOptionalArg(type);\n                      }\n                    }\n\n                    // If the param name has a DOT in it, just throw it out\n                    // quietly. We do not handle the JsDocToolkit method\n                    // for handling properties of params.\n                    if (name.indexOf('.') > -1) {\n                      name = null;\n                    } else if (!jsdocBuilder.recordParameter(name, type)) {\n                      if (jsdocBuilder.hasParameter(name)) {\n                        parser.addWarning(\"msg.dup.variable.name\", name,\n                            lineno, charno);\n                      } else {\n                        parser.addWarning(\"msg.jsdoc.incompat.type\", name,\n                            lineno, charno);\n                      }\n                    }\n                  }\n\n                  if (name == null) {\n                    token = eatTokensUntilEOL(token);\n                    continue retry;\n                  }\n\n                  jsdocBuilder.markName(name, lineno, charno);\n\n                  // Find the parameter's description (if applicable).\n                  ExtractionInfo paramDescriptionInfo =\n                      extractMultilineTextualBlock(token);\n\n                  String paramDescription = paramDescriptionInfo.string;\n\n                  if (paramDescription.length() > 0) {\n                    jsdocBuilder.recordParameterDescription(name,\n                                                            paramDescription);\n                  }\n\n                  token = paramDescriptionInfo.token;\n                  continue retry;\n\n                case PRESERVE_TRY:\n                  if (!jsdocBuilder.recordPreserveTry()) {\n                    parser.addWarning(\"msg.jsdoc.preservertry\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case PRIVATE:\n                  if (!jsdocBuilder.recordVisibility(Visibility.PRIVATE)) {\n                    parser.addWarning(\"msg.jsdoc.visibility.private\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case PROTECTED:\n                  if (!jsdocBuilder.recordVisibility(Visibility.PROTECTED)) {\n                    parser.addWarning(\"msg.jsdoc.visibility.protected\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case PUBLIC:\n                  if (!jsdocBuilder.recordVisibility(Visibility.PUBLIC)) {\n                    parser.addWarning(\"msg.jsdoc.visibility.public\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case NO_SHADOW:\n                  if (!jsdocBuilder.recordNoShadow()) {\n                    parser.addWarning(\"msg.jsdoc.noshadow\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case NO_SIDE_EFFECTS:\n                  if (!jsdocBuilder.recordNoSideEffects()) {\n                    parser.addWarning(\"msg.jsdoc.nosideeffects\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case IMPLICIT_CAST:\n                  if (!jsdocBuilder.recordImplicitCast()) {\n                    parser.addWarning(\"msg.jsdoc.implicitcast\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n                  token = eatTokensUntilEOL();\n                  continue retry;\n\n                case SEE:\n                  ExtractionInfo referenceInfo = extractSingleLineBlock();\n                  String reference = referenceInfo.string;\n\n                  if (reference.length() == 0) {\n                    parser.addWarning(\"msg.jsdoc.seemissing\",\n                          stream.getLineno(), stream.getCharno());\n                  } else {\n                    jsdocBuilder.addReference(reference);\n                  }\n\n                  token = referenceInfo.token;\n                  continue retry;\n\n                case SUPPRESS:\n                  token = parseSuppressTag(next());\n                  continue retry;\n\n                case TEMPLATE:\n                  ExtractionInfo templateInfo = extractSingleLineBlock();\n                  String templateTypeName = templateInfo.string;\n\n                  if (templateTypeName.length() == 0) {\n                    parser.addWarning(\"msg.jsdoc.templatemissing\",\n                          stream.getLineno(), stream.getCharno());\n                  } else if (!jsdocBuilder.recordTemplateTypeName(\n                      templateTypeName)) {\n                    parser.addWarning(\"msg.jsdoc.template.at.most.once\",\n                        stream.getLineno(), stream.getCharno());\n                  }\n\n                  token = templateInfo.token;\n                  continue retry;\n\n                case VERSION:\n                  ExtractionInfo versionInfo = extractSingleLineBlock();\n                  String version = versionInfo.string;\n\n                  if (version.length() == 0) {\n                    parser.addWarning(\"msg.jsdoc.versionmissing\",\n                          stream.getLineno(), stream.getCharno());\n                  } else {\n                    if (!jsdocBuilder.recordVersion(version)) {\n                       parser.addWarning(\"msg.jsdoc.extraversion\",\n                          stream.getLineno(), stream.getCharno());\n                    }\n                  }\n\n                  token = versionInfo.token;\n                  continue retry;\n\n                case DEFINE:\n                case RETURN:\n                case THIS:\n                case TYPE:\n                case TYPEDEF:\n                  skipEOLs();\n                  lineno = stream.getLineno();\n                  charno = stream.getCharno();\n\n                  token = next();\n\n                  Node typeNode = parseAndRecordTypeNode(token, lineno, charno);\n\n                  if (annotation == Annotation.THIS) {\n                    typeNode = wrapNode(Token.BANG, typeNode);\n                    if (typeNode != null && token != JsDocToken.LC) {\n                      typeNode.putBooleanProp(Node.BRACELESS_TYPE, true);\n                    }\n                  }\n                  type = createJSTypeExpression(typeNode);\n\n                  if (type == null) {\n                    // error reported during recursive descent\n                    // recovering parsing\n                  } else {\n                    switch (annotation) {\n                      case DEFINE:\n                        if (!isValidDefineType(typeNode)) {\n                          parser.addWarning(\"msg.jsdoc.define.badtype\",\n                              lineno, charno);\n                        } else if (!jsdocBuilder.recordDefineType(type)) {\n                          parser.addWarning(\"msg.jsdoc.define\",\n                              lineno, charno);\n                        }\n                        break;\n\n                      case RETURN:\n                        if (!jsdocBuilder.recordReturnType(type)) {\n                          parser.addWarning(\n                              \"msg.jsdoc.incompat.type\", lineno, charno);\n                          break;\n                        }\n\n                        // *Update* the token to that after the type annotation.\n                        token = current();\n\n                        // Find the return's description (if applicable).\n                        ExtractionInfo returnDescriptionInfo =\n                            extractMultilineTextualBlock(token);\n\n                        String returnDescription = returnDescriptionInfo.string;\n\n                        if (returnDescription.length() > 0) {\n                          jsdocBuilder.recordReturnDescription(\n                              returnDescription);\n                        }\n\n                        token = returnDescriptionInfo.token;\n                        continue retry;\n\n                      case THIS:\n                        if (!jsdocBuilder.recordThisType(type)) {\n                          parser.addWarning(\n                              \"msg.jsdoc.incompat.type\", lineno, charno);\n                        }\n                        break;\n\n                      case TYPE:\n                        if (!jsdocBuilder.recordType(type)) {\n                          parser.addWarning(\n                              \"msg.jsdoc.incompat.type\", lineno, charno);\n                        }\n                        break;\n\n                      case TYPEDEF:\n                        if (!jsdocBuilder.recordTypedef(type)) {\n                          parser.addWarning(\n                              \"msg.jsdoc.incompat.type\", lineno, charno);\n                        }\n                        break;\n                    }\n\n                    token = eatTokensUntilEOL();\n                  }\n                  continue retry;\n              }\n            }\n          }\n          break;\n\n        case EOC:\n          if (hasParsedFileOverviewDocInfo()) {\n            fileOverviewJSDocInfo = retrieveAndResetParsedJSDocInfo();\n          }\n\n          return true;\n\n        case EOF:\n          // discard any accumulated information\n          jsdocBuilder.build(null);\n          parser.addWarning(\"msg.unexpected.eof\",\n              stream.getLineno(), stream.getCharno());\n          return false;\n\n        case EOL:\n          if (state == State.SEARCHING_NEWLINE) {\n            state = State.SEARCHING_ANNOTATION;\n          }\n          token = next();\n          continue retry;\n\n        default:\n          if (token == JsDocToken.STAR && state == State.SEARCHING_ANNOTATION) {\n            token = next();\n            continue retry;\n          } else {\n            state = State.SEARCHING_NEWLINE;\n            token = eatTokensUntilEOL();\n            continue retry;\n          }\n      }\n\n      // next token\n      token = next();\n    }\n  }",
    "comment": " Parses a {@link JSDocInfo} object. This parsing method reads all tokens returned by the {@link JsDocTokenStream#getJsDocToken()} method until the {@link JsDocToken#EOC} is returned.  @return {@code true} if JSDoc information was correctly parsed, {@code false} otherwise ",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "JsDocInfoParser.parseAndRecordParamTypeNode",
    "class_name": "com.google.javascript.jscomp.parsing.JsDocInfoParser",
    "signature": "com.google.javascript.jscomp.parsing.JsDocInfoParser.parseAndRecordParamTypeNode(JsDocToken)",
    "snippet": "  private Node parseAndRecordParamTypeNode(JsDocToken token) {\n    Preconditions.checkArgument(token == JsDocToken.LC);\n    int lineno = stream.getLineno();\n    int startCharno = stream.getCharno();\n\n    Node typeNode = parseParamTypeExpressionAnnotation(token);\n    int endCharno = stream.getCharno();\n\n    jsdocBuilder.markTypeNode(typeNode, lineno, startCharno, endCharno,\n        true);\n    return typeNode;\n  }",
    "comment": " Looks for a type expression at the current token and if found, returns it. Note that this method consumes input.  Parameter type expressions are special for two reasons: <ol> <li>They must begin with '{', to distinguish type names from param names. <li>They may end in '=', to denote optionality. </ol>  @param token The current token. @return The type expression found or null if none. ",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "JsDocInfoParser.parseAndRecordTypeNameNode",
    "class_name": "com.google.javascript.jscomp.parsing.JsDocInfoParser",
    "signature": "com.google.javascript.jscomp.parsing.JsDocInfoParser.parseAndRecordTypeNameNode(JsDocToken,int,int,boolean)",
    "snippet": "  private Node parseAndRecordTypeNameNode(JsDocToken token, int lineno,\n                                          int startCharno, boolean matchingLC) {\n    return parseAndRecordTypeNode(token, lineno, startCharno, matchingLC, true);\n  }",
    "comment": " Looks for a type expression at the current token and if found, returns it. Note that this method consumes input.  @param token The current token. @param lineno The line of the type expression. @param startCharno The starting character position of the type expression. @param matchingLC Whether the type expression starts with a \"{\". @return The type expression found or null if none. ",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "JsDocInfoParser.parseAndRecordTypeNode",
    "class_name": "com.google.javascript.jscomp.parsing.JsDocInfoParser",
    "signature": "com.google.javascript.jscomp.parsing.JsDocInfoParser.parseAndRecordTypeNode(JsDocToken,int,int,boolean,boolean)",
    "snippet": "  private Node parseAndRecordTypeNode(JsDocToken token, int lineno,\n                                      int startCharno,\n                                      boolean matchingLC,\n                                      boolean onlyParseSimpleNames) {\n    Node typeNode = null;\n\n    if (onlyParseSimpleNames) {\n      typeNode = parseTypeNameAnnotation(token);\n    } else {\n      typeNode = parseTypeExpressionAnnotation(token);\n    }\n\n    if (typeNode != null && !matchingLC) {\n      typeNode.putBooleanProp(Node.BRACELESS_TYPE, true);\n    }\n\n    int endCharno = stream.getCharno();\n\n    jsdocBuilder.markTypeNode(typeNode, lineno, startCharno, endCharno,\n        matchingLC);\n\n    return typeNode;\n  }",
    "comment": " Looks for a parameter type expression at the current token and if found, returns it. Note that this method consumes input.  @param token The current token. @param lineno The line of the type expression. @param startCharno The starting character position of the type expression. @param matchingLC Whether the type expression starts with a \"{\". @param onlyParseSimpleNames If true, only simple type names are parsed (via a call to parseTypeNameAnnotation instead of parseTypeExpressionAnnotation). @return The type expression found or null if none. ",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "JsDocInfoParser.parseBasicTypeExpression",
    "class_name": "com.google.javascript.jscomp.parsing.JsDocInfoParser",
    "signature": "com.google.javascript.jscomp.parsing.JsDocInfoParser.parseBasicTypeExpression(JsDocToken)",
    "snippet": "  private Node parseBasicTypeExpression(JsDocToken token) {\n    if (token == JsDocToken.STAR) {\n      return newNode(Token.STAR);\n    } else if (token == JsDocToken.LB) {\n      skipEOLs();\n      return parseArrayType(next());\n    } else if (token == JsDocToken.LC) {\n      skipEOLs();\n      return parseRecordType(next());\n    } else if (token == JsDocToken.LP) {\n      skipEOLs();\n      return parseUnionType(next());\n    } else if (token == JsDocToken.STRING) {\n      String string = stream.getString();\n      if (\"function\".equals(string)) {\n        skipEOLs();\n        return parseFunctionType(next());\n      } else if (\"null\".equals(string) || \"undefined\".equals(string)) {\n        return newStringNode(string);\n      } else {\n        return parseTypeName(token);\n      }\n    }\n\n    return reportGenericTypeSyntaxWarning();\n  }",
    "comment": " BasicTypeExpression := '*' | 'null' | 'undefined' | TypeName | FunctionType | UnionType | RecordType | ArrayType ",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "JsDocInfoParser.parseParamTypeExpressionAnnotation",
    "class_name": "com.google.javascript.jscomp.parsing.JsDocInfoParser",
    "signature": "com.google.javascript.jscomp.parsing.JsDocInfoParser.parseParamTypeExpressionAnnotation(JsDocToken)",
    "snippet": "  private Node parseParamTypeExpressionAnnotation(JsDocToken token) {\n    Preconditions.checkArgument(token == JsDocToken.LC);\n\n    skipEOLs();\n\n    boolean restArg = false;\n    token = next();\n    if (token == JsDocToken.ELLIPSIS) {\n      token = next();\n      if (token == JsDocToken.RC) {\n        // EMPTY represents the UNKNOWN type in the Type AST.\n        return wrapNode(Token.ELLIPSIS, new Node(Token.EMPTY));\n      }\n      restArg = true;\n    }\n\n    Node typeNode = parseTopLevelTypeExpression(token);\n    if (typeNode != null) {\n      skipEOLs();\n      if (restArg) {\n        typeNode = wrapNode(Token.ELLIPSIS, typeNode);\n      } else if (match(JsDocToken.EQUALS)) {\n        next();\n        skipEOLs();\n        typeNode = wrapNode(Token.EQUALS, typeNode);\n      }\n\n      if (!match(JsDocToken.RC)) {\n        reportTypeSyntaxWarning(\"msg.jsdoc.missing.rc\");\n      } else {\n        next();\n      }\n    }\n\n    return typeNode;\n  }",
    "comment": " ParamTypeExpressionAnnotation := '{' OptionalParameterType '}' | '{' TopLevelTypeExpression '}' | '{' '...' TopLevelTypeExpression '}'  OptionalParameterType := TopLevelTypeExpression '=' ",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "JsDocInfoParser.parseTopLevelTypeExpression",
    "class_name": "com.google.javascript.jscomp.parsing.JsDocInfoParser",
    "signature": "com.google.javascript.jscomp.parsing.JsDocInfoParser.parseTopLevelTypeExpression(JsDocToken)",
    "snippet": "  private Node parseTopLevelTypeExpression(JsDocToken token) {\n    Node typeExpr = parseTypeExpression(token);\n    if (typeExpr != null) {\n      // top-level unions are allowed\n      if (match(JsDocToken.PIPE)) {\n        next();\n        if (match(JsDocToken.PIPE)) {\n          // We support double pipes for backwards-compatibility.\n          next();\n        }\n        skipEOLs();\n        token = next();\n        return parseUnionTypeWithAlternate(token, typeExpr);\n      }\n    }\n    return typeExpr;\n  }",
    "comment": " TopLevelTypeExpression := TypeExpression | TypeUnionList  We made this rule up, for the sake of backwards compatibility. ",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "JsDocInfoParser.parseTypeExpression",
    "class_name": "com.google.javascript.jscomp.parsing.JsDocInfoParser",
    "signature": "com.google.javascript.jscomp.parsing.JsDocInfoParser.parseTypeExpression(JsDocToken)",
    "snippet": "  private Node parseTypeExpression(JsDocToken token) {\n    if (token == JsDocToken.QMARK) {\n      return wrapNode(Token.QMARK, parseBasicTypeExpression(next()));\n    } else if (token == JsDocToken.BANG) {\n      return wrapNode(Token.BANG, parseBasicTypeExpression(next()));\n    } else {\n      Node basicTypeExpr = parseBasicTypeExpression(token);\n      if (basicTypeExpr != null) {\n        if (match(JsDocToken.QMARK)) {\n          next();\n          return wrapNode(Token.QMARK, basicTypeExpr);\n        } else if (match(JsDocToken.BANG)) {\n          next();\n          return wrapNode(Token.BANG, basicTypeExpr);\n        }\n      }\n\n      return basicTypeExpr;\n    }\n  }",
    "comment": " TypeExpression := BasicTypeExpression | '?' BasicTypeExpression | '!' BasicTypeExpression | BasicTypeExpression '?' | BasicTypeExpression '!' ",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "JsDocInfoParser.parseTypeName",
    "class_name": "com.google.javascript.jscomp.parsing.JsDocInfoParser",
    "signature": "com.google.javascript.jscomp.parsing.JsDocInfoParser.parseTypeName(JsDocToken)",
    "snippet": "  private Node parseTypeName(JsDocToken token) {\n    if (token != JsDocToken.STRING) {\n      return reportGenericTypeSyntaxWarning();\n    }\n\n    Node typeName = newStringNode(stream.getString());\n    if (match(JsDocToken.LT)) {\n      next();\n      skipEOLs();\n      Node memberType = parseTypeExpressionList(next());\n      if (memberType != null) {\n        typeName.addChildToFront(memberType);\n\n        skipEOLs();\n        if (!match(JsDocToken.GT)) {\n          return reportTypeSyntaxWarning(\"msg.jsdoc.missing.gt\");\n        }\n\n        next();\n      }\n    }\n    return typeName;\n  }",
    "comment": " TypeName := NameExpression | NameExpression TypeApplication TypeApplication := '.<' TypeExpressionList '>' TypeExpressionList := TypeExpression // a white lie ",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "JsDocInfoParser.parseTypeNameAnnotation",
    "class_name": "com.google.javascript.jscomp.parsing.JsDocInfoParser",
    "signature": "com.google.javascript.jscomp.parsing.JsDocInfoParser.parseTypeNameAnnotation(JsDocToken)",
    "snippet": "  private Node parseTypeNameAnnotation(JsDocToken token) {\n    if (token == JsDocToken.LC) {\n      skipEOLs();\n      Node typeNode = parseTypeName(next());\n      if (typeNode != null) {\n        skipEOLs();\n        if (!match(JsDocToken.RC)) {\n          reportTypeSyntaxWarning(\"msg.jsdoc.missing.rc\");\n        } else {\n          next();\n        }\n      }\n\n      return typeNode;\n    } else {\n      return parseTypeName(token);\n    }\n  }",
    "comment": " TypeNameAnnotation := TypeName | '{' TypeName '}' ",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "JsDocInfoParser.retrieveAndResetParsedJSDocInfo",
    "class_name": "com.google.javascript.jscomp.parsing.JsDocInfoParser",
    "signature": "com.google.javascript.jscomp.parsing.JsDocInfoParser.retrieveAndResetParsedJSDocInfo()",
    "snippet": "  JSDocInfo retrieveAndResetParsedJSDocInfo() {\n    return jsdocBuilder.build(sourceName);\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "JsDocInfoParser.setFileLevelJsDocBuilder",
    "class_name": "com.google.javascript.jscomp.parsing.JsDocInfoParser",
    "signature": "com.google.javascript.jscomp.parsing.JsDocInfoParser.setFileLevelJsDocBuilder(FileLevelJsDocBuilder)",
    "snippet": "  void setFileLevelJsDocBuilder(\n      Node.FileLevelJsDocBuilder fileLevelJsDocBuilder) {\n    this.fileLevelJsDocBuilder = fileLevelJsDocBuilder;\n  }",
    "comment": " Sets the JsDocBuilder for the file-level (root) node of this parse. The parser uses the builder to append any preserve annotations it encounters in jsdoc comments.  @param fileLevelJsDocBuilder ",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "JsDocInfoParser.setFileOverviewJSDocInfo",
    "class_name": "com.google.javascript.jscomp.parsing.JsDocInfoParser",
    "signature": "com.google.javascript.jscomp.parsing.JsDocInfoParser.setFileOverviewJSDocInfo(JSDocInfo)",
    "snippet": "  void setFileOverviewJSDocInfo(JSDocInfo fileOverviewJSDocInfo) {\n    this.fileOverviewJSDocInfo = fileOverviewJSDocInfo;\n  }",
    "comment": " Sets the file overview JSDocInfo, in order to warn about multiple uses of the @fileoverview tag in a file. ",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "JsDocInfoParser.skipEOLs",
    "class_name": "com.google.javascript.jscomp.parsing.JsDocInfoParser",
    "signature": "com.google.javascript.jscomp.parsing.JsDocInfoParser.skipEOLs()",
    "snippet": "  private void skipEOLs() {\n    while (match(JsDocToken.EOL)) {\n      next();\n      if (match(JsDocToken.STAR)) {\n        next();\n      }\n    }\n  }",
    "comment": " Skips all EOLs and all empty lines in the JSDoc. Call this method if you want the JSDoc entry to span multiple lines. ",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "JsDocInfoParser.wrapNode",
    "class_name": "com.google.javascript.jscomp.parsing.JsDocInfoParser",
    "signature": "com.google.javascript.jscomp.parsing.JsDocInfoParser.wrapNode(int,Node)",
    "snippet": "  private Node wrapNode(int type, Node n) {\n    return n == null ? null :\n        new Node(type, n, stream.getLineno(), stream.getCharno());\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "JsDocTokenStream.JsDocTokenStream",
    "class_name": "com.google.javascript.jscomp.parsing.JsDocTokenStream",
    "signature": "com.google.javascript.jscomp.parsing.JsDocTokenStream.JsDocTokenStream(String,int,int)",
    "snippet": "  JsDocTokenStream(String sourceString, int lineno, int initCharno) {\n    Preconditions.checkNotNull(sourceString);\n    this.lineno = lineno;\n    this.sourceString = sourceString;\n    this.sourceEnd = sourceString.length();\n    this.sourceCursor = this.cursor = 0;\n    this.initLineno = lineno;\n    this.initCharno = initCharno;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "JsDocTokenStream.addToString",
    "class_name": "com.google.javascript.jscomp.parsing.JsDocTokenStream",
    "signature": "com.google.javascript.jscomp.parsing.JsDocTokenStream.addToString(int)",
    "snippet": "  private void addToString(int c) {\n    int N = stringBufferTop;\n    if (N == stringBuffer.length) {\n        char[] tmp = new char[stringBuffer.length * 2];\n        System.arraycopy(stringBuffer, 0, tmp, 0, N);\n        stringBuffer = tmp;\n    }\n    stringBuffer[N] = (char)c;\n    stringBufferTop = N + 1;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "JsDocTokenStream.getChar",
    "class_name": "com.google.javascript.jscomp.parsing.JsDocTokenStream",
    "signature": "com.google.javascript.jscomp.parsing.JsDocTokenStream.getChar()",
    "snippet": "  protected int getChar() {\n    if (ungetCursor != 0) {\n      cursor++;\n      --ungetCursor;\n      if (charno == -1) {\n        charno = getOffset();\n      }\n      return ungetBuffer[ungetCursor];\n    }\n\n    for(;;) {\n      int c;\n      if (sourceCursor == sourceEnd) {\n        hitEOF = true;\n        if (charno == -1) {\n          charno = getOffset();\n        }\n        return EOF_CHAR;\n      }\n      cursor++;\n      c = sourceString.charAt(sourceCursor++);\n\n\n      if (lineEndChar >= 0) {\n        if (lineEndChar == '\\r' && c == '\\n') {\n          lineEndChar = '\\n';\n          continue;\n        }\n        lineEndChar = -1;\n        lineStart = sourceCursor - 1;\n        lineno++;\n      }\n\n      if (c <= 127) {\n        if (c == '\\n' || c == '\\r') {\n          lineEndChar = c;\n          c = '\\n';\n        }\n      } else {\n        if (isJSFormatChar(c)) {\n          continue;\n        }\n        if (ScriptRuntime.isJSLineTerminator(c)) {\n          lineEndChar = c;\n          c = '\\n';\n        }\n      }\n\n      if (charno == -1) {\n        charno = getOffset();\n      }\n\n      return c;\n    }\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "JsDocTokenStream.getCharIgnoreLineEnd",
    "class_name": "com.google.javascript.jscomp.parsing.JsDocTokenStream",
    "signature": "com.google.javascript.jscomp.parsing.JsDocTokenStream.getCharIgnoreLineEnd()",
    "snippet": "  private int getCharIgnoreLineEnd() {\n    if (ungetCursor != 0) {\n      cursor++;\n      --ungetCursor;\n      if (charno == -1) {\n        charno = getOffset();\n      }\n      return ungetBuffer[ungetCursor];\n    }\n\n    for(;;) {\n      int c;\n      if (sourceCursor == sourceEnd) {\n        hitEOF = true;\n        if (charno == -1) {\n          charno = getOffset();\n        }\n        return EOF_CHAR;\n      }\n      cursor++;\n      c = sourceString.charAt(sourceCursor++);\n\n\n      if (c <= 127) {\n        if (c == '\\n' || c == '\\r') {\n          lineEndChar = c;\n          c = '\\n';\n        }\n      } else {\n        if (isJSFormatChar(c)) {\n          continue;\n        }\n        if (ScriptRuntime.isJSLineTerminator(c)) {\n          lineEndChar = c;\n          c = '\\n';\n        }\n      }\n\n      if (charno == -1) {\n        charno = getOffset();\n      }\n\n      return c;\n    }\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "JsDocTokenStream.getCharno",
    "class_name": "com.google.javascript.jscomp.parsing.JsDocTokenStream",
    "signature": "com.google.javascript.jscomp.parsing.JsDocTokenStream.getCharno()",
    "snippet": "  final int getCharno() {\n    return lineno == initLineno? initCharno + charno : charno;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "JsDocTokenStream.getJsDocToken",
    "class_name": "com.google.javascript.jscomp.parsing.JsDocTokenStream",
    "signature": "com.google.javascript.jscomp.parsing.JsDocTokenStream.getJsDocToken()",
    "snippet": "  @SuppressWarnings(\"fallthrough\")\n  final JsDocToken getJsDocToken() {\n    int c;\n    stringBufferTop = 0;\n    for (;;) {\n      // eat white spaces\n      for (;;) {\n        charno = -1;\n        c = getChar();\n        if (c == EOF_CHAR) {\n          return JsDocToken.EOF;\n        } else if (c == '\\n') {\n          return JsDocToken.EOL;\n        } else if (!isJSSpace(c)) {\n          break;\n        }\n      }\n\n      switch (c) {\n        // annotation, e.g. @type or @constructor\n        case '@':\n          do {\n            c = getChar();\n            if (isAlpha(c)) {\n              addToString(c);\n            } else {\n              ungetChar(c);\n              this.string = getStringFromBuffer();\n              stringBufferTop = 0;\n              return JsDocToken.ANNOTATION;\n            }\n          } while (true);\n\n        case '*':\n          if (matchChar('/')) {\n            return JsDocToken.EOC;\n          } else {\n            return JsDocToken.STAR;\n          }\n\n        case ',':\n          return JsDocToken.COMMA;\n\n        case '>':\n          return JsDocToken.GT;\n\n        case '(':\n          return JsDocToken.LP;\n\n        case ')':\n          return JsDocToken.RP;\n\n        case '{':\n          return JsDocToken.LC;\n\n        case '}':\n          return JsDocToken.RC;\n\n        case '[':\n          return JsDocToken.LB;\n\n        case ']':\n          return JsDocToken.RB;\n\n        case '?':\n          return JsDocToken.QMARK;\n\n        case '!':\n          return JsDocToken.BANG;\n\n        case ':':\n          return JsDocToken.COLON;\n\n        case '=':\n          return JsDocToken.EQUALS;\n\n        case '|':\n          matchChar('|');\n          return JsDocToken.PIPE;\n\n        case '.':\n          c = getChar();\n          if (c == '<') {\n            return JsDocToken.LT;\n          } else {\n            if (c == '.') {\n              c = getChar();\n              if (c == '.') {\n                return JsDocToken.ELLIPSIS;\n              } else {\n                addToString('.');\n              }\n            }\n            // we may backtrack across line boundary\n            ungetBuffer[ungetCursor++] = c;\n            c = '.';\n          }\n          // fall through\n\n        default: {\n          // recognize a jsdoc string but discard last . if it is followed by\n          // a non-jsdoc comment char, e.g. Array.<\n          int c1 = c;\n          addToString(c);\n          int c2 = getChar();\n          if (!isJSDocString(c2)) {\n            ungetChar(c2);\n            this.string = getStringFromBuffer();\n            stringBufferTop = 0;\n            return JsDocToken.STRING;\n          } else {\n            do {\n              c1 = c2;\n              c2 = getChar();\n              if (c1 == '.' && c2 == '<') {\n                ungetChar(c2);\n                ungetChar(c1);\n                this.string = getStringFromBuffer();\n                stringBufferTop = 0;\n                return JsDocToken.STRING;\n              } else {\n                if (isJSDocString(c2)) {\n                  addToString(c1);\n                } else {\n                  ungetChar(c2);\n                  addToString(c1);\n                  this.string = getStringFromBuffer();\n                  stringBufferTop = 0;\n                  return JsDocToken.STRING;\n                }\n              }\n            } while (true);\n          }\n        }\n      }\n    }\n  }",
    "comment": " Tokenizes JSDoc comments. ",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "JsDocTokenStream.getLineno",
    "class_name": "com.google.javascript.jscomp.parsing.JsDocTokenStream",
    "signature": "com.google.javascript.jscomp.parsing.JsDocTokenStream.getLineno()",
    "snippet": "  final int getLineno() { return lineno; }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "JsDocTokenStream.getOffset",
    "class_name": "com.google.javascript.jscomp.parsing.JsDocTokenStream",
    "signature": "com.google.javascript.jscomp.parsing.JsDocTokenStream.getOffset()",
    "snippet": "  final int getOffset() {\n    return sourceCursor - lineStart - ungetCursor - 1;\n  }",
    "comment": " Returns the offset into the current line. ",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "JsDocTokenStream.getRemainingJSDocLine",
    "class_name": "com.google.javascript.jscomp.parsing.JsDocTokenStream",
    "signature": "com.google.javascript.jscomp.parsing.JsDocTokenStream.getRemainingJSDocLine()",
    "snippet": "  @SuppressWarnings(\"fallthrough\")\n  String getRemainingJSDocLine() {\n    int c;\n    for (;;) {\n      c = getChar();\n      switch (c) {\n        case '*':\n          if (peekChar() != '/') {\n            addToString(c);\n            break;\n          }\n          // fall through\n        case EOF_CHAR:\n        case '\\n':\n          ungetChar(c);\n          this.string = getStringFromBuffer();\n          stringBufferTop = 0;\n          return this.string;\n\n        default:\n          addToString(c);\n          break;\n      }\n    }\n  }",
    "comment": " Gets the remaining JSDoc line without the {@link JsDocToken#EOL}, {@link JsDocToken#EOF} or {@link JsDocToken#EOC}. ",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "JsDocTokenStream.getString",
    "class_name": "com.google.javascript.jscomp.parsing.JsDocTokenStream",
    "signature": "com.google.javascript.jscomp.parsing.JsDocTokenStream.getString()",
    "snippet": "  final String getString() { return string; }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "JsDocTokenStream.getStringFromBuffer",
    "class_name": "com.google.javascript.jscomp.parsing.JsDocTokenStream",
    "signature": "com.google.javascript.jscomp.parsing.JsDocTokenStream.getStringFromBuffer()",
    "snippet": "  private String getStringFromBuffer() {\n    tokenEnd = cursor;\n    return new String(stringBuffer, 0, stringBufferTop);\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "JsDocTokenStream.isAlpha",
    "class_name": "com.google.javascript.jscomp.parsing.JsDocTokenStream",
    "signature": "com.google.javascript.jscomp.parsing.JsDocTokenStream.isAlpha(int)",
    "snippet": "  private static boolean isAlpha(int c) {\n    // Use 'Z' < 'a'\n    if (c <= 'Z') {\n      return 'A' <= c;\n    } else {\n      return 'a' <= c && c <= 'z';\n    }\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "JsDocTokenStream.isJSDocString",
    "class_name": "com.google.javascript.jscomp.parsing.JsDocTokenStream",
    "signature": "com.google.javascript.jscomp.parsing.JsDocTokenStream.isJSDocString(int)",
    "snippet": "  private boolean isJSDocString(int c) {\n    switch (c) {\n      case '@':\n      case '*':\n      case ',':\n      case '>':\n      case ':':\n      case '(':\n      case ')':\n      case '{':\n      case '}':\n      case '[':\n      case ']':\n      case '?':\n      case '!':\n      case '|':\n      case '=':\n      case EOF_CHAR:\n      case '\\n':\n        return false;\n\n      default:\n        return !isJSSpace(c);\n    }\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "JsDocTokenStream.isJSSpace",
    "class_name": "com.google.javascript.jscomp.parsing.JsDocTokenStream",
    "signature": "com.google.javascript.jscomp.parsing.JsDocTokenStream.isJSSpace(int)",
    "snippet": "  static boolean isJSSpace(int c) {\n    if (c <= 127) {\n      return c == 0x20 || c == 0x9 || c == 0xC || c == 0xB;\n    } else {\n      return c == 0xA0\n          || Character.getType((char)c) == Character.SPACE_SEPARATOR;\n    }\n  }",
    "comment": "As defined in ECMA.  jsscan.c uses C isspace() (which allows \\v, I think.)  note that code in getChar() implicitly accepts '\\r' == \\u000D as well. ",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "JsDocTokenStream.matchChar",
    "class_name": "com.google.javascript.jscomp.parsing.JsDocTokenStream",
    "signature": "com.google.javascript.jscomp.parsing.JsDocTokenStream.matchChar(int)",
    "snippet": "  private boolean matchChar(int test) {\n    int c = getCharIgnoreLineEnd();\n    if (c == test) {\n      tokenEnd = cursor;\n      return true;\n    } else {\n      ungetCharIgnoreLineEnd(c);\n      return false;\n    }\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "JsDocTokenStream.peekChar",
    "class_name": "com.google.javascript.jscomp.parsing.JsDocTokenStream",
    "signature": "com.google.javascript.jscomp.parsing.JsDocTokenStream.peekChar()",
    "snippet": "  private int peekChar() {\n    int c = getChar();\n    ungetChar(c);\n    return c;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "JsDocTokenStream.ungetChar",
    "class_name": "com.google.javascript.jscomp.parsing.JsDocTokenStream",
    "signature": "com.google.javascript.jscomp.parsing.JsDocTokenStream.ungetChar(int)",
    "snippet": "  private void ungetChar(int c) {\n    // can not unread past across line boundary\n    assert(!(ungetCursor != 0 && ungetBuffer[ungetCursor - 1] == '\\n'));\n    ungetBuffer[ungetCursor++] = c;\n    cursor--;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "JsDocTokenStream.update",
    "class_name": "com.google.javascript.jscomp.parsing.JsDocTokenStream",
    "signature": "com.google.javascript.jscomp.parsing.JsDocTokenStream.update()",
    "snippet": "  void update() {\n    charno = getOffset();\n  }",
    "comment": " Allows the JSDocParser to update the character offset so that getCharno() returns a valid character position. ",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "ParserRunner.createConfig",
    "class_name": "com.google.javascript.jscomp.parsing.ParserRunner",
    "signature": "com.google.javascript.jscomp.parsing.ParserRunner.createConfig(JSTypeRegistry,boolean)",
    "snippet": "  public static Config createConfig(\n      JSTypeRegistry typeRegistry, boolean isIdeMode) {\n    return new Config(\n        typeRegistry, getAnnotationNames(), isIdeMode);\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "ParserRunner.getAnnotationNames",
    "class_name": "com.google.javascript.jscomp.parsing.ParserRunner",
    "signature": "com.google.javascript.jscomp.parsing.ParserRunner.getAnnotationNames()",
    "snippet": "  static Set<String> getAnnotationNames() {\n    initAnnotationNames();\n    return annotationNames;\n  }",
    "comment": " Gets a list of extra annotations that are OK, even if the parser doesn't have handlers for them built-in. ",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "ParserRunner.initAnnotationNames",
    "class_name": "com.google.javascript.jscomp.parsing.ParserRunner",
    "signature": "com.google.javascript.jscomp.parsing.ParserRunner.initAnnotationNames()",
    "snippet": "  private static synchronized void initAnnotationNames() {\n    if (annotationNames != null) {\n      return;\n    }\n\n    Set<String> trimmedNames = Sets.newHashSet();\n    ResourceBundle config = ResourceBundle.getBundle(configResource);\n    String[] names = config.getString(\"jsdoc.annotations\").split(\",\");\n    for (String name : names) {\n      trimmedNames.add(name.trim());\n    }\n    annotationNames = ImmutableSet.copyOf(trimmedNames);\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "ParserRunner.parse",
    "class_name": "com.google.javascript.jscomp.parsing.ParserRunner",
    "signature": "com.google.javascript.jscomp.parsing.ParserRunner.parse(String,String,Config,ErrorReporter,Logger)",
    "snippet": "  public static Node parse(String sourceName,\n                           String sourceString,\n                           Config config,\n                           ErrorReporter errorReporter,\n                           Logger logger) throws IOException {\n    Context cx = Context.enter();\n    cx.setErrorReporter(errorReporter);\n    cx.setLanguageVersion(Context.VERSION_1_5);\n    CompilerEnvirons compilerEnv = new CompilerEnvirons();\n    compilerEnv.initFromContext(cx);\n    compilerEnv.setRecordingComments(true);\n    compilerEnv.setRecordingLocalJsDocComments(true);\n    compilerEnv.setWarnTrailingComma(true);\n    if (config.isIdeMode) {\n      compilerEnv.setReservedKeywordAsIdentifier(true);\n      compilerEnv.setAllowMemberExprAsFunctionName(true);\n    }\n\n    Parser p = new Parser(compilerEnv, errorReporter);\n    AstRoot astRoot = null;\n    try {\n      astRoot = p.parse(sourceString, sourceName, 1);\n    } catch (EvaluatorException e) {\n      logger.info(\"Error parsing \" + sourceName + \": \" + e.getMessage());\n    } finally {\n      Context.exit();\n    }\n    Node root = null;\n    if (astRoot != null) {\n      root = IRFactory.transformTree(\n          astRoot, sourceString, config, errorReporter);\n      root.setIsSyntheticBlock(true);\n    }\n    return root;\n  }",
    "comment": " Parses the JavaScript text given by a reader.  @param sourceName The filename. @param sourceString Source code from the file. @param isIdeMode Whether in IDE mode, which affects the environment. @param typeRegistry The type registry. @param errorReporter An error. @param logger A logger. @return The AST of the given text. @throws IOException ",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "TypeSafeDispatcher.process",
    "class_name": "com.google.javascript.jscomp.parsing.TypeSafeDispatcher",
    "signature": "com.google.javascript.jscomp.parsing.TypeSafeDispatcher.process(AstNode)",
    "snippet": "  public T process(AstNode node) {\n    switch (node.getType()) {\n      case Token.ADD:\n      case Token.AND:\n      case Token.BITAND:\n      case Token.BITOR:\n      case Token.BITXOR:\n      case Token.COMMA:\n      case Token.DIV:\n      case Token.EQ:\n      case Token.GE:\n      case Token.GT:\n      case Token.IN:\n      case Token.INSTANCEOF:\n      case Token.LE:\n      case Token.LSH:\n      case Token.LT:\n      case Token.MOD:\n      case Token.MUL:\n      case Token.NE:\n      case Token.OR:\n      case Token.RSH:\n      case Token.SHEQ:\n      case Token.SHNE:\n      case Token.SUB:\n      case Token.URSH:\n        return processInfixExpression((InfixExpression) node);\n      case Token.ARRAYLIT:\n        return processArrayLiteral((ArrayLiteral) node);\n      case Token.ASSIGN:\n      case Token.ASSIGN_ADD:\n      case Token.ASSIGN_BITAND:\n      case Token.ASSIGN_BITOR:\n      case Token.ASSIGN_BITXOR:\n      case Token.ASSIGN_DIV:\n      case Token.ASSIGN_LSH:\n      case Token.ASSIGN_MOD:\n      case Token.ASSIGN_MUL:\n      case Token.ASSIGN_RSH:\n      case Token.ASSIGN_SUB:\n      case Token.ASSIGN_URSH:\n        return processAssignment((Assignment) node);\n      case Token.BITNOT:\n      case Token.DEC:\n      case Token.DELPROP:\n      case Token.INC:\n      case Token.NEG:\n      case Token.NOT:\n      case Token.POS:\n      case Token.TYPEOF:\n      case Token.VOID:\n        return processUnaryExpression((UnaryExpression) node);\n      case Token.BLOCK:\n        if (node instanceof Block) {\n          return processBlock((Block) node);\n        } else  if (node instanceof Scope) {\n          return processScope((Scope) node);\n        } else {\n          throw new IllegalStateException(\"Unexpected node type.  class: \" +\n                                          node.getClass() +\n                                          \" type: \" +\n                                          Token.typeToName(node.getType()));\n        }\n      case Token.BREAK:\n        return processBreakStatement((BreakStatement) node);\n      case Token.CALL:\n        return processFunctionCall((FunctionCall) node);\n      case Token.CASE:\n      case Token.DEFAULT:\n        return processSwitchCase((SwitchCase) node);\n      case Token.CATCH:\n      case Token.FINALLY:\n        return processCatchClause((CatchClause) node);\n      case Token.COLON:\n        return processObjectProperty((ObjectProperty) node);\n      case Token.CONTINUE:\n        return processContinueStatement((ContinueStatement) node);\n      case Token.DO:\n        return processDoLoop((DoLoop) node);\n      case Token.EMPTY:\n        return processEmptyExpression((EmptyExpression) node);\n      case Token.EXPR_RESULT:\n      case Token.EXPR_VOID:\n        if (node instanceof ExpressionStatement) {\n          return processExpressionStatement((ExpressionStatement) node);\n        } else  if (node instanceof LabeledStatement) {\n          return processLabeledStatement((LabeledStatement) node);\n        } else {\n          throw new IllegalStateException(\"Unexpected node type.  class: \" +\n                                          node.getClass() +\n                                          \" type: \" +\n                                          Token.typeToName(node.getType()));\n        }\n      case Token.DEBUGGER:\n      case Token.FALSE:\n      case Token.NULL:\n      case Token.THIS:\n      case Token.TRUE:\n        return processKeywordLiteral((KeywordLiteral) node);\n      case Token.FOR:\n        if (node instanceof ForInLoop) {\n          return processForInLoop((ForInLoop) node);\n        } else  if (node instanceof ForLoop) {\n          return processForLoop((ForLoop) node);\n        } else {\n          throw new IllegalStateException(\"Unexpected node type.  class: \" +\n                                          node.getClass() +\n                                          \" type: \" +\n                                          Token.typeToName(node.getType()));\n        }\n      case Token.FUNCTION:\n        return processFunctionNode((FunctionNode) node);\n      case Token.GETELEM:\n        return processElementGet((ElementGet) node);\n      case Token.GETPROP:\n        return processPropertyGet((PropertyGet) node);\n      case Token.HOOK:\n        return processConditionalExpression((ConditionalExpression) node);\n      case Token.IF:\n        return processIfStatement((IfStatement) node);\n      case Token.LABEL:\n        return processLabel((Label) node);\n      case Token.LP:\n        return processParenthesizedExpression((ParenthesizedExpression) node);\n      case Token.NAME:\n        return processName((Name) node);\n      case Token.NEW:\n        return processNewExpression((NewExpression) node);\n      case Token.NUMBER:\n        return processNumberLiteral((NumberLiteral) node);\n      case Token.OBJECTLIT:\n        return processObjectLiteral((ObjectLiteral) node);\n      case Token.REGEXP:\n        return processRegExpLiteral((RegExpLiteral) node);\n      case Token.RETURN:\n        return processReturnStatement((ReturnStatement) node);\n      case Token.SCRIPT:\n        return processAstRoot((AstRoot) node);\n      case Token.STRING:\n        return processStringLiteral((StringLiteral) node);\n      case Token.SWITCH:\n        return processSwitchStatement((SwitchStatement) node);\n      case Token.THROW:\n        return processThrowStatement((ThrowStatement) node);\n      case Token.TRY:\n        return processTryStatement((TryStatement) node);\n      case Token.VAR:\n        if (node instanceof VariableDeclaration) {\n          return processVariableDeclaration((VariableDeclaration) node);\n        } else  if (node instanceof VariableInitializer) {\n          return processVariableInitializer((VariableInitializer) node);\n        } else {\n          throw new IllegalStateException(\"Unexpected node type.  class: \" +\n                                          node.getClass() +\n                                          \" type: \" +\n                                          Token.typeToName(node.getType()));\n        }\n      case Token.WHILE:\n        return processWhileLoop((WhileLoop) node);\n      case Token.WITH:\n        return processWithStatement((WithStatement) node);\n    }\n    return processIllegalToken(node);\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "Context.getCurrentContext",
    "class_name": "com.google.javascript.rhino.Context",
    "signature": "com.google.javascript.rhino.Context.getCurrentContext()",
    "snippet": "    public static Context getCurrentContext() {\n        return threadContexts.get();\n    }",
    "comment": " Get the current Context.  The current Context is per-thread; this method looks up the Context associated with the current thread. <p>  @return the Context associated with the current thread, or null if no context is associated with the current thread. ",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "FunctionNode.FunctionNode",
    "class_name": "com.google.javascript.rhino.FunctionNode",
    "signature": "com.google.javascript.rhino.FunctionNode.FunctionNode(String)",
    "snippet": "    public FunctionNode(String name) {\n        super(Token.FUNCTION);\n        functionName = name;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "JSDocInfo.JSDocInfo",
    "class_name": "com.google.javascript.rhino.JSDocInfo",
    "signature": "com.google.javascript.rhino.JSDocInfo.JSDocInfo(boolean)",
    "snippet": "  JSDocInfo(boolean includeDocumentation) {\n    this.includeDocumentation = includeDocumentation;\n  }",
    "comment": " Creates a {@link JSDocInfo} object. This object should be created using a {@link JSDocInfoBuilder}. ",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "JSDocInfo.addMarker",
    "class_name": "com.google.javascript.rhino.JSDocInfo",
    "signature": "com.google.javascript.rhino.JSDocInfo.addMarker()",
    "snippet": "  Marker addMarker() {\n    if (!lazyInitDocumentation()) {\n      return null;\n    }\n\n    if (documentation.markers == null) {\n      documentation.markers = Lists.newArrayList();\n    }\n\n    Marker marker = new Marker();\n    documentation.markers.add(marker);\n    return marker;\n  }",
    "comment": " Adds a marker to the documentation (if it exists) and returns the marker. Returns null otherwise. ",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "JSDocInfo.declareParam",
    "class_name": "com.google.javascript.rhino.JSDocInfo",
    "signature": "com.google.javascript.rhino.JSDocInfo.declareParam(JSTypeExpression,String)",
    "snippet": "  boolean declareParam(JSTypeExpression jsType, String parameter) {\n    lazyInitInfo();\n    if (info.parameters == null) {\n      info.parameters = new LinkedHashMap<String, JSTypeExpression>();\n    }\n    if (!info.parameters.containsKey(parameter)) {\n      info.parameters.put(parameter, jsType);\n      return true;\n    } else {\n      return false;\n    }\n  }",
    "comment": " Declares a parameter. Parameters are described using the {@code @param} annotation.  @param jsType the parameter's type, it may be {@code null} when the {@code @param} annotation did not specify a type. @param parameter the parameter's name ",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "JSDocInfo.getBaseType",
    "class_name": "com.google.javascript.rhino.JSDocInfo",
    "signature": "com.google.javascript.rhino.JSDocInfo.getBaseType()",
    "snippet": "  public JSTypeExpression getBaseType() {\n    return (info == null) ? null : info.baseType;\n  }",
    "comment": " Gets the base type specified by the {@code @extends} annotation. ",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "JSDocInfo.getFlag",
    "class_name": "com.google.javascript.rhino.JSDocInfo",
    "signature": "com.google.javascript.rhino.JSDocInfo.getFlag(int)",
    "snippet": "  private boolean getFlag(int mask) {\n    return (bitset & mask) != 0x00;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "JSDocInfo.getImplementedInterfaceCount",
    "class_name": "com.google.javascript.rhino.JSDocInfo",
    "signature": "com.google.javascript.rhino.JSDocInfo.getImplementedInterfaceCount()",
    "snippet": "  public int getImplementedInterfaceCount() {\n    if (info == null || info.implementedInterfaces == null) {\n      return 0;\n    }\n    return info.implementedInterfaces.size();\n  }",
    "comment": " Gets the number of interfaces specified by the {@code @implements} annotation. ",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "JSDocInfo.getImplementedInterfaces",
    "class_name": "com.google.javascript.rhino.JSDocInfo",
    "signature": "com.google.javascript.rhino.JSDocInfo.getImplementedInterfaces()",
    "snippet": "  public List<JSTypeExpression> getImplementedInterfaces() {\n    if (info == null || info.implementedInterfaces == null) {\n      return ImmutableList.of();\n    }\n    return Collections.unmodifiableList(info.implementedInterfaces);\n  }",
    "comment": " Returns the types specified by the {@code @implements} annotation.  @return An immutable list of JSTypeExpression objects that can be resolved to types. ",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "JSDocInfo.getParameterCount",
    "class_name": "com.google.javascript.rhino.JSDocInfo",
    "signature": "com.google.javascript.rhino.JSDocInfo.getParameterCount()",
    "snippet": "  public int getParameterCount() {\n    if (info == null || info.parameters == null) {\n      return 0;\n    }\n    return info.parameters.size();\n  }",
    "comment": " Gets the number of parameters defined. ",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "JSDocInfo.getParameterNames",
    "class_name": "com.google.javascript.rhino.JSDocInfo",
    "signature": "com.google.javascript.rhino.JSDocInfo.getParameterNames()",
    "snippet": "  public Set<String> getParameterNames() {\n    if (info == null || info.parameters == null) {\n      return ImmutableSet.of();\n    }\n    return ImmutableSet.copyOf(info.parameters.keySet());\n  }",
    "comment": " Returns the set of names of the defined parameters. The iteration order of the returned set is not the order in which parameters are defined.  @return the set of names of the defined parameters. The returned set is immutable. ",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "JSDocInfo.getParameterType",
    "class_name": "com.google.javascript.rhino.JSDocInfo",
    "signature": "com.google.javascript.rhino.JSDocInfo.getParameterType(String)",
    "snippet": "  public JSTypeExpression getParameterType(String parameter) {\n    if (info == null || info.parameters == null) {\n      return null;\n    }\n    return info.parameters.get(parameter);\n  }",
    "comment": " Gets the parameter type. @param parameter the parameter's name @return the parameter's type or {@code null} if this parameter is not defined or has a {@code null} type ",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "JSDocInfo.getTemplateTypeName",
    "class_name": "com.google.javascript.rhino.JSDocInfo",
    "signature": "com.google.javascript.rhino.JSDocInfo.getTemplateTypeName()",
    "snippet": "  public String getTemplateTypeName() {\n    if (info == null) {\n      return null;\n    }\n    return info.templateTypeName;\n  }",
    "comment": "Gets the template type name. */",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "JSDocInfo.getVisibility",
    "class_name": "com.google.javascript.rhino.JSDocInfo",
    "signature": "com.google.javascript.rhino.JSDocInfo.getVisibility()",
    "snippet": "  public Visibility getVisibility() {\n    return visibility;\n  }",
    "comment": " Gets the visibility specified by {@code @private}, {@code @protected} or {@code @public} annotation. If no visibility is specified, visibility is inherited from the base class. ",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "JSDocInfo.hasBaseType",
    "class_name": "com.google.javascript.rhino.JSDocInfo",
    "signature": "com.google.javascript.rhino.JSDocInfo.hasBaseType()",
    "snippet": "  public boolean hasBaseType() {\n    return getBaseType() != null;\n  }",
    "comment": " Returns whether this {@link JSDocInfo} contains a type for {@code @extends} annotation. ",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "JSDocInfo.hasEnumParameterType",
    "class_name": "com.google.javascript.rhino.JSDocInfo",
    "signature": "com.google.javascript.rhino.JSDocInfo.hasEnumParameterType()",
    "snippet": "  public boolean hasEnumParameterType() {\n    return hasType(TYPEFIELD_ENUM);\n  }",
    "comment": " Returns whether an enum parameter type, specified using the {@code @enum} annotation, is present on this JSDoc. ",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "JSDocInfo.hasFileOverview",
    "class_name": "com.google.javascript.rhino.JSDocInfo",
    "signature": "com.google.javascript.rhino.JSDocInfo.hasFileOverview()",
    "snippet": "  public boolean hasFileOverview() {\n    return getFlag(MASK_FILEOVERVIEW);\n  }",
    "comment": " Returns whether this has a fileoverview flag. ",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "JSDocInfo.hasParameterType",
    "class_name": "com.google.javascript.rhino.JSDocInfo",
    "signature": "com.google.javascript.rhino.JSDocInfo.hasParameterType(String)",
    "snippet": "  public boolean hasParameterType(String parameter) {\n    return getParameterType(parameter) != null;\n  }",
    "comment": " Returns whether the parameter has an attached type.  @return {@code true} if the parameter has an attached type, {@code false} if the parameter has no attached type or does not exist. ",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "JSDocInfo.hasReturnType",
    "class_name": "com.google.javascript.rhino.JSDocInfo",
    "signature": "com.google.javascript.rhino.JSDocInfo.hasReturnType()",
    "snippet": "  public boolean hasReturnType() {\n    return hasType(TYPEFIELD_RETURN);\n  }",
    "comment": " Returns whether this {@link JSDocInfo} contains a type for {@code @return} annotation. ",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "JSDocInfo.hasThisType",
    "class_name": "com.google.javascript.rhino.JSDocInfo",
    "signature": "com.google.javascript.rhino.JSDocInfo.hasThisType()",
    "snippet": "  public boolean hasThisType() {\n    return thisType != null;\n  }",
    "comment": " Returns whether this {@link JSDocInfo} contains a type for {@code @this} annotation. ",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "JSDocInfo.hasType",
    "class_name": "com.google.javascript.rhino.JSDocInfo",
    "signature": "com.google.javascript.rhino.JSDocInfo.hasType()",
    "snippet": "  public boolean hasType() {\n    return hasType(TYPEFIELD_TYPE);\n  }",
    "comment": " Returns whether a type, specified using the {@code @type} annotation, is present on this JSDoc. ",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "JSDocInfo.hasType",
    "class_name": "com.google.javascript.rhino.JSDocInfo",
    "signature": "com.google.javascript.rhino.JSDocInfo.hasType(int)",
    "snippet": "  private boolean hasType(int mask) {\n    return (bitset & MASK_TYPEFIELD) == mask;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "JSDocInfo.hasTypedefType",
    "class_name": "com.google.javascript.rhino.JSDocInfo",
    "signature": "com.google.javascript.rhino.JSDocInfo.hasTypedefType()",
    "snippet": "  public boolean hasTypedefType() {\n    return hasType(TYPEFIELD_TYPEDEF);\n  }",
    "comment": " Returns whether a typedef parameter type, specified using the {@code @typedef} annotation, is present on this JSDoc. ",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "JSDocInfo.isConstructor",
    "class_name": "com.google.javascript.rhino.JSDocInfo",
    "signature": "com.google.javascript.rhino.JSDocInfo.isConstructor()",
    "snippet": "  public boolean isConstructor() {\n    return getFlag(MASK_CONSTRUCTOR);\n  }",
    "comment": " Returns whether the {@code @constructor} annotation is present on this {@link JSDocInfo}. ",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "JSDocInfo.isDefine",
    "class_name": "com.google.javascript.rhino.JSDocInfo",
    "signature": "com.google.javascript.rhino.JSDocInfo.isDefine()",
    "snippet": "  public boolean isDefine() {\n    return getFlag(MASK_DEFINE);\n  }",
    "comment": " Returns whether the {@code @define} annotation is present on this {@link JSDocInfo}. If this annotation is present, then the {@link #getType()} method will retrieve the define type. ",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "JSDocInfo.isExterns",
    "class_name": "com.google.javascript.rhino.JSDocInfo",
    "signature": "com.google.javascript.rhino.JSDocInfo.isExterns()",
    "snippet": "  public boolean isExterns() {\n    return getFlag(MASK_EXTERNS);\n  }",
    "comment": " Returns whether the {@code @externs} annotation is present on this {@link JSDocInfo}. ",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "JSDocInfo.isInterface",
    "class_name": "com.google.javascript.rhino.JSDocInfo",
    "signature": "com.google.javascript.rhino.JSDocInfo.isInterface()",
    "snippet": "  public boolean isInterface() {\n    return getFlag(MASK_INTERFACE);\n  }",
    "comment": " Returns whether the {@code @interface} annotation is present on this {@link JSDocInfo}. ",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "JSDocInfo.isJavaDispatch",
    "class_name": "com.google.javascript.rhino.JSDocInfo",
    "signature": "com.google.javascript.rhino.JSDocInfo.isJavaDispatch()",
    "snippet": "  public boolean isJavaDispatch() {\n    return getFlag(MASK_JAVADISPATCH);\n  }",
    "comment": " Returns whether the {@code @javadispath} annotation is present on this {@link JSDocInfo}. ",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "JSDocInfo.isNoTypeCheck",
    "class_name": "com.google.javascript.rhino.JSDocInfo",
    "signature": "com.google.javascript.rhino.JSDocInfo.isNoTypeCheck()",
    "snippet": "  public boolean isNoTypeCheck() {\n    return getFlag(MASK_NOCHECK);\n  }",
    "comment": " Returns whether the {@code @nocheck} annotation is present on this {@link JSDocInfo}. ",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "JSDocInfo.lazyInitDocumentation",
    "class_name": "com.google.javascript.rhino.JSDocInfo",
    "signature": "com.google.javascript.rhino.JSDocInfo.lazyInitDocumentation()",
    "snippet": "  private boolean lazyInitDocumentation() {\n    if (!includeDocumentation) {\n      return false;\n    }\n\n    if (documentation == null) {\n      documentation = new LazilyInitializedDocumentation();\n    }\n\n    return true;\n  }",
    "comment": " Lazily initializes the documentation information object, but only if the JSDocInfo was told to keep such information around. ",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "JSDocInfo.lazyInitInfo",
    "class_name": "com.google.javascript.rhino.JSDocInfo",
    "signature": "com.google.javascript.rhino.JSDocInfo.lazyInitInfo()",
    "snippet": "  private void lazyInitInfo() {\n    if (info == null) {\n      info = new LazilyInitializedInfo();\n    }\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "JSDocInfo.setBaseType",
    "class_name": "com.google.javascript.rhino.JSDocInfo",
    "signature": "com.google.javascript.rhino.JSDocInfo.setBaseType(JSTypeExpression)",
    "snippet": "  void setBaseType(JSTypeExpression type) {\n    lazyInitInfo();\n    info.baseType = type;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "JSDocInfo.setConstructor",
    "class_name": "com.google.javascript.rhino.JSDocInfo",
    "signature": "com.google.javascript.rhino.JSDocInfo.setConstructor(boolean)",
    "snippet": "  void setConstructor(boolean value) {\n    setFlag(value, MASK_CONSTRUCTOR);\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "JSDocInfo.setFlag",
    "class_name": "com.google.javascript.rhino.JSDocInfo",
    "signature": "com.google.javascript.rhino.JSDocInfo.setFlag(boolean,int)",
    "snippet": "  private void setFlag(boolean value, int mask) {\n    if (value) {\n      bitset |= mask;\n    } else {\n      bitset &= ~mask;\n    }\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "JSDocInfo.setSourceName",
    "class_name": "com.google.javascript.rhino.JSDocInfo",
    "signature": "com.google.javascript.rhino.JSDocInfo.setSourceName(String)",
    "snippet": "  void setSourceName(String sourceName) {\n    this.sourceName = sourceName;\n  }",
    "comment": "Sets the name of the source file that contains this JSDoc. */",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "JSDocInfo.setVisibility",
    "class_name": "com.google.javascript.rhino.JSDocInfo",
    "signature": "com.google.javascript.rhino.JSDocInfo.setVisibility(Visibility)",
    "snippet": "  public void setVisibility(Visibility visibility) {\n    this.visibility = visibility;\n  }",
    "comment": "Visible for testing.",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "JSDocInfo.toString",
    "class_name": "com.google.javascript.rhino.JSDocInfo",
    "signature": "com.google.javascript.rhino.JSDocInfo.toString()",
    "snippet": "  @Override\n  public String toString() {\n    return \"JSDocInfo\";\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "JSDocInfoBuilder.JSDocInfoBuilder",
    "class_name": "com.google.javascript.rhino.JSDocInfoBuilder",
    "signature": "com.google.javascript.rhino.JSDocInfoBuilder.JSDocInfoBuilder(boolean)",
    "snippet": "  public JSDocInfoBuilder(boolean parseDocumentation) {\n    this.currentInfo = new JSDocInfo(parseDocumentation);\n    this.parseDocumentation = parseDocumentation;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "JSDocInfoBuilder.build",
    "class_name": "com.google.javascript.rhino.JSDocInfoBuilder",
    "signature": "com.google.javascript.rhino.JSDocInfoBuilder.build(String)",
    "snippet": "  public JSDocInfo build(String sourceName) {\n    if (populated) {\n      JSDocInfo built = currentInfo;\n      built.setSourceName(sourceName);\n      populateDefaults(built);\n      populated = false;\n      currentInfo = new JSDocInfo(this.parseDocumentation);\n      return built;\n    } else {\n      return null;\n    }\n  }",
    "comment": " Builds a {@link JSDocInfo} object based on the populated information and returns it. Once this method is called, the builder can be reused to build another {@link JSDocInfo} object.  @param sourceName The source file containing the JSDoc. @return a {@link JSDocInfo} object populated with the values given to this builder. If no value was populated, this method simply returns {@code null} ",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "JSDocInfoBuilder.hasAnySingletonTypeTags",
    "class_name": "com.google.javascript.rhino.JSDocInfoBuilder",
    "signature": "com.google.javascript.rhino.JSDocInfoBuilder.hasAnySingletonTypeTags()",
    "snippet": "  private boolean hasAnySingletonTypeTags() {\n    return currentInfo.hasType() ||\n        currentInfo.hasTypedefType() ||\n        currentInfo.hasEnumParameterType();\n  }",
    "comment": " Whether the current doc info has any of the singleton type tags that may not appear with other type tags, like {@code @type} or {@code @typedef}. ",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "JSDocInfoBuilder.isPopulated",
    "class_name": "com.google.javascript.rhino.JSDocInfoBuilder",
    "signature": "com.google.javascript.rhino.JSDocInfoBuilder.isPopulated()",
    "snippet": "  public boolean isPopulated() {\n    return populated;\n  }",
    "comment": " Returns whether this builder is populated with information that can be used to {@link #build} a {@link JSDocInfo} object. ",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "JSDocInfoBuilder.isPopulatedWithFileOverview",
    "class_name": "com.google.javascript.rhino.JSDocInfoBuilder",
    "signature": "com.google.javascript.rhino.JSDocInfoBuilder.isPopulatedWithFileOverview()",
    "snippet": "  public boolean isPopulatedWithFileOverview() {\n    return isPopulated() &&\n        (currentInfo.hasFileOverview() || currentInfo.isExterns());\n  }",
    "comment": " Returns whether this builder is populated with information that can be used to {@link #build} a {@link JSDocInfo} object that has a fileoverview tag. ",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "JSDocInfoBuilder.markAnnotation",
    "class_name": "com.google.javascript.rhino.JSDocInfoBuilder",
    "signature": "com.google.javascript.rhino.JSDocInfoBuilder.markAnnotation(String,int,int)",
    "snippet": "  public void markAnnotation(String annotation, int lineno, int charno) {\n    JSDocInfo.Marker marker = currentInfo.addMarker();\n\n    if (marker != null) {\n      marker.annotation = new JSDocInfo.StringPosition();\n      marker.annotation.setItem(annotation);\n      marker.annotation.setPositionInformation(lineno, charno, lineno,\n                                               charno + annotation.length());\n    }\n\n    currentMarker = marker;\n  }",
    "comment": " Adds a marker to the current JSDocInfo and populates the marker with the annotation information. ",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "JSDocInfoBuilder.markName",
    "class_name": "com.google.javascript.rhino.JSDocInfoBuilder",
    "signature": "com.google.javascript.rhino.JSDocInfoBuilder.markName(String,int,int)",
    "snippet": "  public void markName(String name, int lineno, int charno) {\n    if (currentMarker != null) {\n      currentMarker.name = new JSDocInfo.StringPosition();\n      currentMarker.name.setItem(name);\n      currentMarker.name.setPositionInformation(lineno, charno,\n                                                lineno, charno + name.length());\n    }\n  }",
    "comment": " Adds a name declaration to the current marker. ",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "JSDocInfoBuilder.markTypeNode",
    "class_name": "com.google.javascript.rhino.JSDocInfoBuilder",
    "signature": "com.google.javascript.rhino.JSDocInfoBuilder.markTypeNode(Node,int,int,int,boolean)",
    "snippet": "  public void markTypeNode(Node typeNode, int lineno, int startCharno, int endCharno,\n                    boolean hasLC) {\n    if (currentMarker != null) {\n      currentMarker.type = new JSDocInfo.TypePosition();\n      currentMarker.type.setItem(typeNode);\n      currentMarker.type.hasBrackets = hasLC;\n      currentMarker.type.setPositionInformation(lineno, startCharno,\n                                                lineno, endCharno);\n    }\n  }",
    "comment": " Adds a type declaration to the current marker. ",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "JSDocInfoBuilder.populateDefaults",
    "class_name": "com.google.javascript.rhino.JSDocInfoBuilder",
    "signature": "com.google.javascript.rhino.JSDocInfoBuilder.populateDefaults(JSDocInfo)",
    "snippet": "  private static void populateDefaults(JSDocInfo info) {\n    if (info.getVisibility() == null) {\n      info.setVisibility(Visibility.INHERITED);\n    }\n  }",
    "comment": "Generate defaults when certain parameters are not specified. */",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "JSDocInfoBuilder.recordBaseType",
    "class_name": "com.google.javascript.rhino.JSDocInfoBuilder",
    "signature": "com.google.javascript.rhino.JSDocInfoBuilder.recordBaseType(JSTypeExpression)",
    "snippet": "  public boolean recordBaseType(JSTypeExpression jsType) {\n    if (jsType != null && !hasAnySingletonTypeTags() &&\n        !currentInfo.hasBaseType()) {\n      currentInfo.setBaseType(jsType);\n      populated = true;\n      return true;\n    } else {\n      return false;\n    }\n  }",
    "comment": " Records a base type.  @return {@code true} if the base type was recorded and {@code false} if it was already defined ",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "JSDocInfoBuilder.recordConstructor",
    "class_name": "com.google.javascript.rhino.JSDocInfoBuilder",
    "signature": "com.google.javascript.rhino.JSDocInfoBuilder.recordConstructor()",
    "snippet": "  public boolean recordConstructor() {\n    if (!hasAnySingletonTypeTags() &&\n        !currentInfo.isConstructor() && !currentInfo.isInterface()) {\n      currentInfo.setConstructor(true);\n      populated = true;\n      return true;\n    } else {\n      return false;\n    }\n  }",
    "comment": " Records that the {@link JSDocInfo} being built should have its {@link JSDocInfo#isConstructor()} flag set to {@code true}.  @return {@code true} if the constructor was recorded and {@code false} if it was already defined or it was incompatible with the existing flags ",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "JSDocInfoBuilder.recordParameter",
    "class_name": "com.google.javascript.rhino.JSDocInfoBuilder",
    "signature": "com.google.javascript.rhino.JSDocInfoBuilder.recordParameter(String,JSTypeExpression)",
    "snippet": "  public boolean recordParameter(String parameterName, JSTypeExpression type) {\n    if (!hasAnySingletonTypeTags() &&\n        currentInfo.declareParam(type, parameterName)) {\n      populated = true;\n      return true;\n    } else {\n      return false;\n    }\n  }",
    "comment": " Records a typed parameter.  @return {@code true} if the typed parameter was recorded and {@code false} if a parameter with the same name was already defined ",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "JSTypeExpression.JSTypeExpression",
    "class_name": "com.google.javascript.rhino.JSTypeExpression",
    "signature": "com.google.javascript.rhino.JSTypeExpression.JSTypeExpression(Node,String,JSTypeRegistry)",
    "snippet": "  public JSTypeExpression(Node root, String sourceName,\n      JSTypeRegistry registry) {\n    this.root = root;\n    this.sourceName = sourceName;\n    this.registry = registry;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "JSTypeExpression.evaluate",
    "class_name": "com.google.javascript.rhino.JSTypeExpression",
    "signature": "com.google.javascript.rhino.JSTypeExpression.evaluate(StaticScope)",
    "snippet": "  public JSType evaluate(StaticScope<JSType> scope) {\n    JSType type = registry.createFromTypeNodes(root, sourceName, scope);\n    if (root.getBooleanProp(Node.BRACELESS_TYPE)) {\n      type.forgiveUnknownNames();\n    }\n    return type;\n  }",
    "comment": " Evaluates the type expression into a {@code JSType} object. ",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "JSTypeExpression.isOptionalArg",
    "class_name": "com.google.javascript.rhino.JSTypeExpression",
    "signature": "com.google.javascript.rhino.JSTypeExpression.isOptionalArg()",
    "snippet": "  public boolean isOptionalArg() {\n    return root.getType() == Token.EQUALS;\n  }",
    "comment": " @return Whether this expression denotes an optional {@code @param}. ",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "JSTypeExpression.isVarArgs",
    "class_name": "com.google.javascript.rhino.JSTypeExpression",
    "signature": "com.google.javascript.rhino.JSTypeExpression.isVarArgs()",
    "snippet": "  public boolean isVarArgs() {\n    return root.getType() == Token.ELLIPSIS;\n  }",
    "comment": " @return Whether this expression denotes a rest args {@code @param}. ",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "Node.Node",
    "class_name": "com.google.javascript.rhino.Node",
    "signature": "com.google.javascript.rhino.Node.Node(int)",
    "snippet": "    public Node(int nodeType) {\n        type = nodeType;\n        parent = null;\n        sourcePosition = -1;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "Node.Node",
    "class_name": "com.google.javascript.rhino.Node",
    "signature": "com.google.javascript.rhino.Node.Node(int,Node)",
    "snippet": "    public Node(int nodeType, Node child) {\n        Preconditions.checkArgument(child.parent == null,\n            \"new child has existing parent\");\n        Preconditions.checkArgument(child.next == null,\n            \"new child has existing sibling\");\n\n        type = nodeType;\n        parent = null;\n        first = last = child;\n        child.next = null;\n        child.parent = this;\n        sourcePosition = -1;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "Node.Node",
    "class_name": "com.google.javascript.rhino.Node",
    "signature": "com.google.javascript.rhino.Node.Node(int,Node,Node)",
    "snippet": "    public Node(int nodeType, Node left, Node right) {\n        Preconditions.checkArgument(left.parent == null,\n            \"first new child has existing parent\");\n        Preconditions.checkArgument(left.next == null,\n            \"first new child has existing sibling\");\n        Preconditions.checkArgument(right.parent == null,\n            \"second new child has existing parent\");\n        Preconditions.checkArgument(right.next == null,\n            \"second new child has existing sibling\");\n        type = nodeType;\n        parent = null;\n        first = left;\n        last = right;\n        left.next = right;\n        left.parent = this;\n        right.next = null;\n        right.parent = this;\n        sourcePosition = -1;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "Node.addChildToBack",
    "class_name": "com.google.javascript.rhino.Node",
    "signature": "com.google.javascript.rhino.Node.addChildToBack(Node)",
    "snippet": "    public void addChildToBack(Node child) {\n        Preconditions.checkArgument(child.parent == null);\n        Preconditions.checkArgument(child.next == null);\n        child.parent = this;\n        child.next = null;\n        if (last == null) {\n            first = last = child;\n            return;\n        }\n        last.next = child;\n        last = child;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "Node.addChildrenToFront",
    "class_name": "com.google.javascript.rhino.Node",
    "signature": "com.google.javascript.rhino.Node.addChildrenToFront(Node)",
    "snippet": "    public void addChildrenToFront(Node children) {\n        for (Node child = children; child != null; child = child.next) {\n          Preconditions.checkArgument(child.parent == null);\n          child.parent = this;\n        }\n        Node lastSib = children.getLastSibling();\n        lastSib.next = first;\n        first = children;\n        if (last == null) {\n            last = lastSib;\n        }\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "Node.cloneNode",
    "class_name": "com.google.javascript.rhino.Node",
    "signature": "com.google.javascript.rhino.Node.cloneNode()",
    "snippet": "    public Node cloneNode() {\n        Node result;\n        try {\n            result = (Node) super.clone();\n            result.next = null;\n            result.first = null;\n            result.last = null;\n            result.parent = null;\n        }\n        catch (CloneNotSupportedException e) {\n            throw new RuntimeException(e.getMessage());\n        }\n        return result;\n    }",
    "comment": " @return A detached clone of the Node, specifically excluding its children. ",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "Node.cloneTree",
    "class_name": "com.google.javascript.rhino.Node",
    "signature": "com.google.javascript.rhino.Node.cloneTree()",
    "snippet": "    public Node cloneTree() {\n        Node result = cloneNode();\n        for (Node n2 = getFirstChild(); n2 != null; n2 = n2.getNext()) {\n            Node n2clone = n2.cloneTree();\n            n2clone.parent = result;\n            if (result.last != null) {\n                result.last.next = n2clone;\n            }\n            if (result.first == null) {\n                result.first = n2clone;\n            }\n            result.last = n2clone;\n        }\n        return result;\n    }",
    "comment": " @return A detached clone of the Node and all its children. ",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "Node.copyInformationFrom",
    "class_name": "com.google.javascript.rhino.Node",
    "signature": "com.google.javascript.rhino.Node.copyInformationFrom(Node)",
    "snippet": "    public void copyInformationFrom(Node other) {\n        if (getProp(ORIGINALNAME_PROP) == null) {\n            putProp(ORIGINALNAME_PROP, other.getProp(ORIGINALNAME_PROP));\n        }\n\n        if (getProp(SOURCEFILE_PROP) == null) {\n            putProp(SOURCEFILE_PROP, other.getProp(SOURCEFILE_PROP));\n            sourcePosition = other.sourcePosition;\n        }\n    }",
    "comment": " Copies source file and name information from the other node given to the current node. Used for maintaining debug information across node append and remove operations. ",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "Node.ensureProperty",
    "class_name": "com.google.javascript.rhino.Node",
    "signature": "com.google.javascript.rhino.Node.ensureProperty(int)",
    "snippet": "    private PropListItem ensureProperty(int propType)\n    {\n        PropListItem item = lookupProperty(propType);\n        if (item == null) {\n            item = new PropListItem();\n            item.type = propType;\n            item.next = propListHead;\n            propListHead = item;\n        }\n        return item;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "Node.extractCharno",
    "class_name": "com.google.javascript.rhino.Node",
    "signature": "com.google.javascript.rhino.Node.extractCharno(int)",
    "snippet": "    protected static int extractCharno(int lineCharNo) {\n      if (lineCharNo == -1) {\n        return -1;\n      } else {\n        return lineCharNo & COLUMN_MASK;\n      }\n    }",
    "comment": " Extracts the character number and character number from a merged line char number (see {@link #mergeLineCharNo(int, int)}). ",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "Node.extractLineno",
    "class_name": "com.google.javascript.rhino.Node",
    "signature": "com.google.javascript.rhino.Node.extractLineno(int)",
    "snippet": "    protected static int extractLineno(int lineCharNo) {\n      if (lineCharNo == -1) {\n        return -1;\n      } else {\n        return lineCharNo >>> COLUMN_BITS;\n      }\n    }",
    "comment": " Extracts the line number and character number from a merged line char number (see {@link #mergeLineCharNo(int, int)}). ",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "Node.getBooleanProp",
    "class_name": "com.google.javascript.rhino.Node",
    "signature": "com.google.javascript.rhino.Node.getBooleanProp(int)",
    "snippet": "    public boolean getBooleanProp(int propType) {\n        return getIntProp(propType, 0) != 0;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "Node.getCharno",
    "class_name": "com.google.javascript.rhino.Node",
    "signature": "com.google.javascript.rhino.Node.getCharno()",
    "snippet": "    public int getCharno() {\n        return extractCharno(sourcePosition);\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "Node.getChildBefore",
    "class_name": "com.google.javascript.rhino.Node",
    "signature": "com.google.javascript.rhino.Node.getChildBefore(Node)",
    "snippet": "    public Node getChildBefore(Node child) {\n        if (child == first)\n            return null;\n        Node n = first;\n        while (n.next != child) {\n            n = n.next;\n            if (n == null)\n                throw new RuntimeException(\"node is not a child\");\n        }\n        return n;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "Node.getChildCount",
    "class_name": "com.google.javascript.rhino.Node",
    "signature": "com.google.javascript.rhino.Node.getChildCount()",
    "snippet": "    public int getChildCount() {\n        int c = 0;\n        for (Node n = first; n != null; n = n.next)\n            c++;\n\n        return c;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "Node.getFirstChild",
    "class_name": "com.google.javascript.rhino.Node",
    "signature": "com.google.javascript.rhino.Node.getFirstChild()",
    "snippet": "    public Node getFirstChild() {\n        return first;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "Node.getIntProp",
    "class_name": "com.google.javascript.rhino.Node",
    "signature": "com.google.javascript.rhino.Node.getIntProp(int,int)",
    "snippet": "    public int getIntProp(int propType, int defaultValue)\n    {\n        PropListItem item = lookupProperty(propType);\n        if (item == null) { return defaultValue; }\n        return item.intValue;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "Node.getJSDocInfo",
    "class_name": "com.google.javascript.rhino.Node",
    "signature": "com.google.javascript.rhino.Node.getJSDocInfo()",
    "snippet": "    public JSDocInfo getJSDocInfo()\n    {\n        return (JSDocInfo) getProp(JSDOC_INFO_PROP);\n    }",
    "comment": " Get the {@link JSDocInfo} attached to this node. @return the information or {@code null} if no JSDoc is attached to this node ",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "Node.getJSType",
    "class_name": "com.google.javascript.rhino.Node",
    "signature": "com.google.javascript.rhino.Node.getJSType()",
    "snippet": "    public JSType getJSType() {\n        return jsType;\n    }",
    "comment": "Custom annotations",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "Node.getJsDocBuilderForNode",
    "class_name": "com.google.javascript.rhino.Node",
    "signature": "com.google.javascript.rhino.Node.getJsDocBuilderForNode()",
    "snippet": "    public FileLevelJsDocBuilder getJsDocBuilderForNode() {\n      return new FileLevelJsDocBuilder();\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "Node.getLastChild",
    "class_name": "com.google.javascript.rhino.Node",
    "signature": "com.google.javascript.rhino.Node.getLastChild()",
    "snippet": "    public Node getLastChild() {\n        return last;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "Node.getLastSibling",
    "class_name": "com.google.javascript.rhino.Node",
    "signature": "com.google.javascript.rhino.Node.getLastSibling()",
    "snippet": "    public Node getLastSibling() {\n        Node n = this;\n        while (n.next != null) {\n            n = n.next;\n        }\n        return n;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "Node.getLineno",
    "class_name": "com.google.javascript.rhino.Node",
    "signature": "com.google.javascript.rhino.Node.getLineno()",
    "snippet": "    public int getLineno() {\n        return extractLineno(sourcePosition);\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "Node.getNext",
    "class_name": "com.google.javascript.rhino.Node",
    "signature": "com.google.javascript.rhino.Node.getNext()",
    "snippet": "    public Node getNext() {\n        return next;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "Node.getParent",
    "class_name": "com.google.javascript.rhino.Node",
    "signature": "com.google.javascript.rhino.Node.getParent()",
    "snippet": "    public Node getParent() {\n        return parent;\n    }",
    "comment": "Accessors",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "Node.getProp",
    "class_name": "com.google.javascript.rhino.Node",
    "signature": "com.google.javascript.rhino.Node.getProp(int)",
    "snippet": "    public Object getProp(int propType)\n    {\n        PropListItem item = lookupProperty(propType);\n        if (item == null) { return null; }\n        return item.objectValue;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "Node.getType",
    "class_name": "com.google.javascript.rhino.Node",
    "signature": "com.google.javascript.rhino.Node.getType()",
    "snippet": "    public int getType() {\n        return type;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "Node.hasChildren",
    "class_name": "com.google.javascript.rhino.Node",
    "signature": "com.google.javascript.rhino.Node.hasChildren()",
    "snippet": "    public boolean hasChildren() {\n        return first != null;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "Node.isSyntheticBlock",
    "class_name": "com.google.javascript.rhino.Node",
    "signature": "com.google.javascript.rhino.Node.isSyntheticBlock()",
    "snippet": "    public boolean isSyntheticBlock() {\n        return getBooleanProp(SYNTHETIC_BLOCK_PROP);\n    }",
    "comment": " Returns whether this is a synthetic block that should not be considered a real source block. ",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "Node.lookupProperty",
    "class_name": "com.google.javascript.rhino.Node",
    "signature": "com.google.javascript.rhino.Node.lookupProperty(int)",
    "snippet": "    private PropListItem lookupProperty(int propType)\n    {\n        PropListItem x = propListHead;\n        while (x != null && propType != x.type) {\n            x = x.next;\n        }\n        return x;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "Node.mergeLineCharNo",
    "class_name": "com.google.javascript.rhino.Node",
    "signature": "com.google.javascript.rhino.Node.mergeLineCharNo(int,int)",
    "snippet": "    protected static int mergeLineCharNo(int lineno, int charno) {\n      if (lineno < 0 || charno < 0) {\n        return -1;\n      } else if ((charno & ~COLUMN_MASK) != 0) {\n        return lineno << COLUMN_BITS | COLUMN_MASK;\n      } else {\n        return lineno << COLUMN_BITS | (charno & COLUMN_MASK);\n      }\n    }",
    "comment": " Merges the line number and character number in one integer. The Character number takes the first 12 bits and the line number takes the rest. If the character number is greater than <code>2<sup>12</sup>-1</code> it is adjusted to <code>2<sup>12</sup>-1</code>. ",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "Node.newString",
    "class_name": "com.google.javascript.rhino.Node",
    "signature": "com.google.javascript.rhino.Node.newString(int,String)",
    "snippet": "    public static Node newString(int type, String str) {\n        return new StringNode(type, str);\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "Node.putBooleanProp",
    "class_name": "com.google.javascript.rhino.Node",
    "signature": "com.google.javascript.rhino.Node.putBooleanProp(int,boolean)",
    "snippet": "    public void putBooleanProp(int propType, boolean prop) {\n        putIntProp(propType, prop ? 1 : 0);\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "Node.putIntProp",
    "class_name": "com.google.javascript.rhino.Node",
    "signature": "com.google.javascript.rhino.Node.putIntProp(int,int)",
    "snippet": "    public void putIntProp(int propType, int prop)\n    {\n        PropListItem item = ensureProperty(propType);\n        item.intValue = prop;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "Node.putProp",
    "class_name": "com.google.javascript.rhino.Node",
    "signature": "com.google.javascript.rhino.Node.putProp(int,Object)",
    "snippet": "    public void putProp(int propType, Object prop)\n    {\n        if (prop == null) {\n            removeProp(propType);\n        } else {\n            PropListItem item = ensureProperty(propType);\n            item.objectValue = prop;\n        }\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "Node.removeProp",
    "class_name": "com.google.javascript.rhino.Node",
    "signature": "com.google.javascript.rhino.Node.removeProp(int)",
    "snippet": "    public void removeProp(int propType)\n    {\n        PropListItem x = propListHead;\n        if (x != null) {\n            PropListItem prev = null;\n            while (x.type != propType) {\n                prev = x;\n                x = x.next;\n                if (x == null) { return; }\n            }\n            if (prev == null) {\n                propListHead = x.next;\n            } else {\n                prev.next = x.next;\n            }\n        }\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "Node.replaceChild",
    "class_name": "com.google.javascript.rhino.Node",
    "signature": "com.google.javascript.rhino.Node.replaceChild(Node,Node)",
    "snippet": "    public void replaceChild(Node child, Node newChild) {\n        Preconditions.checkArgument(newChild.next == null,\n            \"The new child node has siblings.\");\n        Preconditions.checkArgument(newChild.parent == null,\n            \"The new child node already has a parent.\");\n\n        // Copy over important information.\n        newChild.copyInformationFrom(child);\n\n        newChild.next = child.next;\n        newChild.parent = this;\n        if (child == first) {\n            first = newChild;\n        } else {\n            Node prev = getChildBefore(child);\n            prev.next = newChild;\n        }\n        if (child == last)\n            last = newChild;\n        child.next = null;\n        child.parent = null;\n    }",
    "comment": " Detaches child from Node and replaces it with newChild. ",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "Node.setCharno",
    "class_name": "com.google.javascript.rhino.Node",
    "signature": "com.google.javascript.rhino.Node.setCharno(int)",
    "snippet": "    public void setCharno(int charno) {\n        sourcePosition = mergeLineCharNo(getLineno(), charno);\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "Node.setIsSyntheticBlock",
    "class_name": "com.google.javascript.rhino.Node",
    "signature": "com.google.javascript.rhino.Node.setIsSyntheticBlock(boolean)",
    "snippet": "    public void setIsSyntheticBlock(boolean val) {\n        putBooleanProp(SYNTHETIC_BLOCK_PROP, val);\n    }",
    "comment": " Sets whether this is a synthetic block that should not be considered a real source block. ",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "Node.setJSType",
    "class_name": "com.google.javascript.rhino.Node",
    "signature": "com.google.javascript.rhino.Node.setJSType(JSType)",
    "snippet": "    public void setJSType(JSType jsType) {\n        this.jsType = jsType;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "Node.setLineno",
    "class_name": "com.google.javascript.rhino.Node",
    "signature": "com.google.javascript.rhino.Node.setLineno(int)",
    "snippet": "    public void setLineno(int lineno) {\n        int charno = getCharno();\n        if (charno == -1) {\n          charno = 0;\n        }\n        sourcePosition = mergeLineCharNo(lineno, charno);\n    }",
    "comment": "Source position management",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "Node.setOptionalArg",
    "class_name": "com.google.javascript.rhino.Node",
    "signature": "com.google.javascript.rhino.Node.setOptionalArg(boolean)",
    "snippet": "    public void setOptionalArg(boolean optionalArg)\n    {\n        putBooleanProp(OPT_ARG_NAME, optionalArg);\n    }",
    "comment": " Sets whether this node is an optional argument node. This method is meaningful only on {@link Token#NAME} nodes used to define a {@link Token#FUNCTION}'s argument list. ",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "Node.setVarArgs",
    "class_name": "com.google.javascript.rhino.Node",
    "signature": "com.google.javascript.rhino.Node.setVarArgs(boolean)",
    "snippet": "    public void setVarArgs(boolean varArgs)\n    {\n        putBooleanProp(VAR_ARGS_NAME, varArgs);\n    }",
    "comment": " Sets whether this node is a variable length argument node. This method is meaningful only on {@link Token#NAME} nodes used to define a {@link Token#FUNCTION}'s argument list. ",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "StringNode.getString",
    "class_name": "com.google.javascript.rhino.Node$StringNode",
    "signature": "com.google.javascript.rhino.Node$StringNode.getString()",
    "snippet": "        @Override public String getString() {\n            return this.str;\n        }",
    "comment": "returns the string content. @return non null. ",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "ObjArray.ObjArray",
    "class_name": "com.google.javascript.rhino.ObjArray",
    "signature": "com.google.javascript.rhino.ObjArray.ObjArray()",
    "snippet": "    public ObjArray() { }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "ObjToIntMap.ObjToIntMap",
    "class_name": "com.google.javascript.rhino.ObjToIntMap",
    "signature": "com.google.javascript.rhino.ObjToIntMap.ObjToIntMap(int)",
    "snippet": "    public ObjToIntMap(int keyCountHint) {\n        if (keyCountHint < 0) Kit.codeBug();\n        // Table grow when number of stored keys >= 3/4 of max capacity\n        int minimalCapacity = keyCountHint * 4 / 3;\n        int i;\n        for (i = 2; (1 << i) < minimalCapacity; ++i) { }\n        power = i;\n        if (check && power < 2) Kit.codeBug();\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "ScriptOrFnNode.ScriptOrFnNode",
    "class_name": "com.google.javascript.rhino.ScriptOrFnNode",
    "signature": "com.google.javascript.rhino.ScriptOrFnNode.ScriptOrFnNode(int)",
    "snippet": "    public ScriptOrFnNode(int nodeType) {\n        super(nodeType);\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "ScriptRuntime.getMessage",
    "class_name": "com.google.javascript.rhino.ScriptRuntime",
    "signature": "com.google.javascript.rhino.ScriptRuntime.getMessage(String,Object[])",
    "snippet": "    public static String getMessage(String messageId, Object[] arguments)\n    {\n        final String defaultResource\n            = \"rhino_ast.java.com.google.javascript.rhino.Messages\";\n\n        Context cx = Context.getCurrentContext();\n        Locale locale = cx != null ? cx.getLocale() : Locale.getDefault();\n\n        // ResourceBundle does cacheing.\n        ResourceBundle rb = ResourceBundle.getBundle(defaultResource, locale);\n\n        String formatString;\n        try {\n            formatString = rb.getString(messageId);\n        } catch (java.util.MissingResourceException mre) {\n            throw new RuntimeException\n                (\"no message resource found for message property \"+ messageId);\n        }\n\n        /*\n         * It's OK to format the string, even if 'arguments' is null;\n         * we need to format it anyway, to make double ''s collapse to\n         * single 's.\n         */\n        // TODO: MessageFormat is not available on pJava\n        MessageFormat formatter = new MessageFormat(formatString);\n        return formatter.format(arguments);\n    }",
    "comment": "OPT there's a noticable delay for the first error!  Maybe it'd make sense to use a ListResourceBundle instead of a properties file to avoid (synchronized) text parsing. ",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "ScriptRuntime.getMessage0",
    "class_name": "com.google.javascript.rhino.ScriptRuntime",
    "signature": "com.google.javascript.rhino.ScriptRuntime.getMessage0(String)",
    "snippet": "    public static String getMessage0(String messageId)\n    {\n        return getMessage(messageId, null);\n    }",
    "comment": "------------------",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "Token.name",
    "class_name": "com.google.javascript.rhino.Token",
    "signature": "com.google.javascript.rhino.Token.name(int)",
    "snippet": "  public static String name(int token)\n    {\n        if (!printNames) {\n            return String.valueOf(token);\n        }\n        switch (token) {\n          case ERROR:           return \"ERROR\";\n          case EOF:             return \"EOF\";\n          case EOL:             return \"EOL\";\n          case ENTERWITH:       return \"ENTERWITH\";\n          case LEAVEWITH:       return \"LEAVEWITH\";\n          case RETURN:          return \"RETURN\";\n          case GOTO:            return \"GOTO\";\n          case IFEQ:            return \"IFEQ\";\n          case IFNE:            return \"IFNE\";\n          case SETNAME:         return \"SETNAME\";\n          case BITOR:           return \"BITOR\";\n          case BITXOR:          return \"BITXOR\";\n          case BITAND:          return \"BITAND\";\n          case EQ:              return \"EQ\";\n          case NE:              return \"NE\";\n          case LT:              return \"LT\";\n          case LE:              return \"LE\";\n          case GT:              return \"GT\";\n          case GE:              return \"GE\";\n          case LSH:             return \"LSH\";\n          case RSH:             return \"RSH\";\n          case URSH:            return \"URSH\";\n          case ADD:             return \"ADD\";\n          case SUB:             return \"SUB\";\n          case MUL:             return \"MUL\";\n          case DIV:             return \"DIV\";\n          case MOD:             return \"MOD\";\n          case NOT:             return \"NOT\";\n          case BITNOT:          return \"BITNOT\";\n          case POS:             return \"POS\";\n          case NEG:             return \"NEG\";\n          case NEW:             return \"NEW\";\n          case DELPROP:         return \"DELPROP\";\n          case TYPEOF:          return \"TYPEOF\";\n          case GETPROP:         return \"GETPROP\";\n          case SETPROP:         return \"SETPROP\";\n          case GETELEM:         return \"GETELEM\";\n          case SETELEM:         return \"SETELEM\";\n          case CALL:            return \"CALL\";\n          case NAME:            return \"NAME\";\n          case NUMBER:          return \"NUMBER\";\n          case STRING:          return \"STRING\";\n          case NULL:            return \"NULL\";\n          case THIS:            return \"THIS\";\n          case FALSE:           return \"FALSE\";\n          case TRUE:            return \"TRUE\";\n          case SHEQ:            return \"SHEQ\";\n          case SHNE:            return \"SHNE\";\n          case REGEXP:          return \"OBJECT\";\n          case BINDNAME:        return \"BINDNAME\";\n          case THROW:           return \"THROW\";\n          case RETHROW:         return \"RETHROW\";\n          case IN:              return \"IN\";\n          case INSTANCEOF:      return \"INSTANCEOF\";\n          case LOCAL_LOAD:      return \"LOCAL_LOAD\";\n          case GETVAR:          return \"GETVAR\";\n          case SETVAR:          return \"SETVAR\";\n          case CATCH_SCOPE:     return \"CATCH_SCOPE\";\n          case ENUM_INIT_KEYS:  return \"ENUM_INIT_KEYS\";\n          case ENUM_INIT_VALUES:  return \"ENUM_INIT_VALUES\";\n          case ENUM_NEXT:       return \"ENUM_NEXT\";\n          case ENUM_ID:         return \"ENUM_ID\";\n          case THISFN:          return \"THISFN\";\n          case RETURN_RESULT:   return \"RETURN_RESULT\";\n          case ARRAYLIT:        return \"ARRAYLIT\";\n          case OBJECTLIT:       return \"OBJECTLIT\";\n          case GET_REF:         return \"GET_REF\";\n          case SET_REF:         return \"SET_REF\";\n          case DEL_REF:         return \"DEL_REF\";\n          case REF_CALL:        return \"REF_CALL\";\n          case REF_SPECIAL:     return \"REF_SPECIAL\";\n          case DEFAULTNAMESPACE:return \"DEFAULTNAMESPACE\";\n          case ESCXMLTEXT:      return \"ESCXMLTEXT\";\n          case ESCXMLATTR:      return \"ESCXMLATTR\";\n          case REF_MEMBER:      return \"REF_MEMBER\";\n          case REF_NS_MEMBER:   return \"REF_NS_MEMBER\";\n          case REF_NAME:        return \"REF_NAME\";\n          case REF_NS_NAME:     return \"REF_NS_NAME\";\n          case TRY:             return \"TRY\";\n          case SEMI:            return \"SEMI\";\n          case LB:              return \"LB\";\n          case RB:              return \"RB\";\n          case LC:              return \"LC\";\n          case RC:              return \"RC\";\n          case LP:              return \"LP\";\n          case RP:              return \"RP\";\n          case COMMA:           return \"COMMA\";\n          case ASSIGN:          return \"ASSIGN\";\n          case ASSIGN_BITOR:    return \"ASSIGN_BITOR\";\n          case ASSIGN_BITXOR:   return \"ASSIGN_BITXOR\";\n          case ASSIGN_BITAND:   return \"ASSIGN_BITAND\";\n          case ASSIGN_LSH:      return \"ASSIGN_LSH\";\n          case ASSIGN_RSH:      return \"ASSIGN_RSH\";\n          case ASSIGN_URSH:     return \"ASSIGN_URSH\";\n          case ASSIGN_ADD:      return \"ASSIGN_ADD\";\n          case ASSIGN_SUB:      return \"ASSIGN_SUB\";\n          case ASSIGN_MUL:      return \"ASSIGN_MUL\";\n          case ASSIGN_DIV:      return \"ASSIGN_DIV\";\n          case ASSIGN_MOD:      return \"ASSIGN_MOD\";\n          case HOOK:            return \"HOOK\";\n          case COLON:           return \"COLON\";\n          case OR:              return \"OR\";\n          case AND:             return \"AND\";\n          case INC:             return \"INC\";\n          case DEC:             return \"DEC\";\n          case DOT:             return \"DOT\";\n          case FUNCTION:        return \"FUNCTION\";\n          case EXPORT:          return \"EXPORT\";\n          case IMPORT:          return \"IMPORT\";\n          case IF:              return \"IF\";\n          case ELSE:            return \"ELSE\";\n          case SWITCH:          return \"SWITCH\";\n          case CASE:            return \"CASE\";\n          case DEFAULT:         return \"DEFAULT\";\n          case WHILE:           return \"WHILE\";\n          case DO:              return \"DO\";\n          case FOR:             return \"FOR\";\n          case BREAK:           return \"BREAK\";\n          case CONTINUE:        return \"CONTINUE\";\n          case VAR:             return \"VAR\";\n          case WITH:            return \"WITH\";\n          case CATCH:           return \"CATCH\";\n          case FINALLY:         return \"FINALLY\";\n          case RESERVED:        return \"RESERVED\";\n          case EMPTY:           return \"EMPTY\";\n          case BLOCK:           return \"BLOCK\";\n          case LABEL:           return \"LABEL\";\n          case TARGET:          return \"TARGET\";\n          case LOOP:            return \"LOOP\";\n          case EXPR_VOID:       return \"EXPR_VOID\";\n          case EXPR_RESULT:     return \"EXPR_RESULT\";\n          case JSR:             return \"JSR\";\n          case SCRIPT:          return \"SCRIPT\";\n          case TYPEOFNAME:      return \"TYPEOFNAME\";\n          case USE_STACK:       return \"USE_STACK\";\n          case SETPROP_OP:      return \"SETPROP_OP\";\n          case SETELEM_OP:      return \"SETELEM_OP\";\n          case LOCAL_BLOCK:     return \"LOCAL_BLOCK\";\n          case SET_REF_OP:      return \"SET_REF_OP\";\n          case DOTDOT:          return \"DOTDOT\";\n          case COLONCOLON:      return \"COLONCOLON\";\n          case XML:             return \"XML\";\n          case DOTQUERY:        return \"DOTQUERY\";\n          case XMLATTR:         return \"XMLATTR\";\n          case XMLEND:          return \"XMLEND\";\n          case TO_OBJECT:       return \"TO_OBJECT\";\n          case TO_DOUBLE:       return \"TO_DOUBLE\";\n          case GET:             return \"GET\";\n          case SET:             return \"SET\";\n          case CONST:           return \"CONST\";\n          case SETCONST:        return \"SETCONST\";\n          case DEBUGGER:        return \"DEBUGGER\";\n          case ANNOTATION:      return \"ANNOTATION\";\n          case PIPE:            return \"PIPE\";\n          case STAR:            return \"STAR\";\n          case EOC:             return \"EOC\";\n          case QMARK:           return \"QMARK\";\n          case ELLIPSIS:        return \"ELLIPSIS\";\n          case BANG:            return \"BANG\";\n          case VOID:            return \"VOID\"; \n          case EQUALS:          return \"EQUALS\";\n        }\n\n        // Token without name\n        throw new IllegalStateException(String.valueOf(token));\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "AllType.AllType",
    "class_name": "com.google.javascript.rhino.jstype.AllType",
    "signature": "com.google.javascript.rhino.jstype.AllType.AllType(JSTypeRegistry)",
    "snippet": "  AllType(JSTypeRegistry registry) {\n    super(registry);\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "AllType.isAllType",
    "class_name": "com.google.javascript.rhino.jstype.AllType",
    "signature": "com.google.javascript.rhino.jstype.AllType.isAllType()",
    "snippet": "  @Override\n  public boolean isAllType() {\n    return true;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "ArrowType.ArrowType",
    "class_name": "com.google.javascript.rhino.jstype.ArrowType",
    "signature": "com.google.javascript.rhino.jstype.ArrowType.ArrowType(JSTypeRegistry,Node,JSType)",
    "snippet": "  ArrowType(JSTypeRegistry registry, Node parameters,\n      JSType returnType) {\n    super(registry);\n    this.parameters = parameters;\n    this.returnType = returnType;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "ArrowType.hashCode",
    "class_name": "com.google.javascript.rhino.jstype.ArrowType",
    "signature": "com.google.javascript.rhino.jstype.ArrowType.hashCode()",
    "snippet": "  @Override\n  public int hashCode() {\n    int hashCode = 0;\n    if (returnType != null) {\n      hashCode += returnType.hashCode();\n    }\n    if (parameters != null) {\n      Node param = parameters.getFirstChild();\n      while (param != null) {\n        JSType paramType = param.getJSType();\n        if (paramType != null) {\n          hashCode += paramType.hashCode();\n        }\n        param = param.getNext();\n      }\n    }\n    return hashCode;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "BooleanType.BooleanType",
    "class_name": "com.google.javascript.rhino.jstype.BooleanType",
    "signature": "com.google.javascript.rhino.jstype.BooleanType.BooleanType(JSTypeRegistry)",
    "snippet": "  BooleanType(JSTypeRegistry registry) {\n    super(registry);\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "BooleanType.toString",
    "class_name": "com.google.javascript.rhino.jstype.BooleanType",
    "signature": "com.google.javascript.rhino.jstype.BooleanType.toString()",
    "snippet": "  @Override\n  public String toString() {\n    return \"boolean\";\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "ErrorFunctionType.ErrorFunctionType",
    "class_name": "com.google.javascript.rhino.jstype.ErrorFunctionType",
    "signature": "com.google.javascript.rhino.jstype.ErrorFunctionType.ErrorFunctionType(JSTypeRegistry,String)",
    "snippet": "  ErrorFunctionType(JSTypeRegistry registry, String name) {\n    super(registry, name, null,\n          registry.createOptionalParameters(\n              registry.getNativeType(ALL_TYPE),\n              registry.getNativeType(ALL_TYPE),\n              registry.getNativeType(ALL_TYPE)),\n          null, null, null, true, true);\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "ErrorFunctionType.getReturnType",
    "class_name": "com.google.javascript.rhino.jstype.ErrorFunctionType",
    "signature": "com.google.javascript.rhino.jstype.ErrorFunctionType.getReturnType()",
    "snippet": "  @Override\n  public JSType getReturnType() {\n    return getInstanceType();\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "FunctionParamBuilder.FunctionParamBuilder",
    "class_name": "com.google.javascript.rhino.jstype.FunctionParamBuilder",
    "signature": "com.google.javascript.rhino.jstype.FunctionParamBuilder.FunctionParamBuilder(JSTypeRegistry)",
    "snippet": "  public FunctionParamBuilder(JSTypeRegistry registry) {\n    this.registry = registry;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "FunctionParamBuilder.addOptionalParams",
    "class_name": "com.google.javascript.rhino.jstype.FunctionParamBuilder",
    "signature": "com.google.javascript.rhino.jstype.FunctionParamBuilder.addOptionalParams(JSType[])",
    "snippet": "  public boolean addOptionalParams(JSType ...types) {\n    if (hasVarArgs()) {\n      return false;\n    }\n\n    for (JSType type : types) {\n      newParameter(registry.createOptionalType(type)).setOptionalArg(true);\n    }\n    return true;\n  }",
    "comment": " Add optional parameters of the given type to the end of the param list. @param types Types for each optional parameter. The builder will make them undefineable. @return False if this is called after var args are added. ",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "FunctionParamBuilder.addRequiredParams",
    "class_name": "com.google.javascript.rhino.jstype.FunctionParamBuilder",
    "signature": "com.google.javascript.rhino.jstype.FunctionParamBuilder.addRequiredParams(JSType[])",
    "snippet": "  public boolean addRequiredParams(JSType ...types) {\n    if (hasOptionalOrVarArgs()) {\n      return false;\n    }\n\n    for (JSType type : types) {\n      newParameter(type);\n    }\n    return true;\n  }",
    "comment": " Add parameters of the given type to the end of the param list. @return False if this is called after optional params are added. ",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "FunctionParamBuilder.addVarArgs",
    "class_name": "com.google.javascript.rhino.jstype.FunctionParamBuilder",
    "signature": "com.google.javascript.rhino.jstype.FunctionParamBuilder.addVarArgs(JSType)",
    "snippet": "  public boolean addVarArgs(JSType type) {\n    if (hasVarArgs()) {\n      return false;\n    }\n\n    // There are two types of variable argument functions:\n    // 1) Programmer-defined var args\n    // 2) Native bottom types that can accept any argument.\n    // For the first one, \"undefined\" is a valid value for all arguments.\n    // For the second, we do not want to cast it up to undefined.\n    if (!type.isEmptyType()) {\n      type = registry.createOptionalType(type);\n    }\n    newParameter(type).setVarArgs(true);\n    return true;\n  }",
    "comment": " Add variable arguments to the end of the parameter list. @return False if this is called after var args are added. ",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "FunctionParamBuilder.build",
    "class_name": "com.google.javascript.rhino.jstype.FunctionParamBuilder",
    "signature": "com.google.javascript.rhino.jstype.FunctionParamBuilder.build()",
    "snippet": "  public Node build() {\n    return root;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "FunctionParamBuilder.hasOptionalOrVarArgs",
    "class_name": "com.google.javascript.rhino.jstype.FunctionParamBuilder",
    "signature": "com.google.javascript.rhino.jstype.FunctionParamBuilder.hasOptionalOrVarArgs()",
    "snippet": "  private boolean hasOptionalOrVarArgs() {\n    Node lastChild = root.getLastChild();\n    return lastChild != null &&\n        (lastChild.isOptionalArg() || lastChild.isVarArgs());\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "FunctionParamBuilder.hasVarArgs",
    "class_name": "com.google.javascript.rhino.jstype.FunctionParamBuilder",
    "signature": "com.google.javascript.rhino.jstype.FunctionParamBuilder.hasVarArgs()",
    "snippet": "  public boolean hasVarArgs() {\n    Node lastChild = root.getLastChild();\n    return lastChild != null && lastChild.isVarArgs();\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "FunctionParamBuilder.newParameter",
    "class_name": "com.google.javascript.rhino.jstype.FunctionParamBuilder",
    "signature": "com.google.javascript.rhino.jstype.FunctionParamBuilder.newParameter(JSType)",
    "snippet": "  private Node newParameter(JSType type) {\n    Node paramNode = Node.newString(Token.NAME, \"\");\n    paramNode.setJSType(type);\n    root.addChildToBack(paramNode);\n    return paramNode;\n  }",
    "comment": "Add a parameter to the list with the given type.",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "FunctionPrototypeType.FunctionPrototypeType",
    "class_name": "com.google.javascript.rhino.jstype.FunctionPrototypeType",
    "signature": "com.google.javascript.rhino.jstype.FunctionPrototypeType.FunctionPrototypeType(JSTypeRegistry,FunctionType,ObjectType)",
    "snippet": "  FunctionPrototypeType(JSTypeRegistry registry, FunctionType ownerFunction,\n      ObjectType implicitPrototype) {\n    this(registry, ownerFunction, implicitPrototype, false);\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "FunctionPrototypeType.FunctionPrototypeType",
    "class_name": "com.google.javascript.rhino.jstype.FunctionPrototypeType",
    "signature": "com.google.javascript.rhino.jstype.FunctionPrototypeType.FunctionPrototypeType(JSTypeRegistry,FunctionType,ObjectType,boolean)",
    "snippet": "  FunctionPrototypeType(JSTypeRegistry registry, FunctionType ownerFunction,\n      ObjectType implicitPrototype, boolean isNative) {\n    super(registry, null /* has no class name */, implicitPrototype,\n        isNative);\n    this.ownerFunction = ownerFunction;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "FunctionType.FunctionType",
    "class_name": "com.google.javascript.rhino.jstype.FunctionType",
    "signature": "com.google.javascript.rhino.jstype.FunctionType.FunctionType(JSTypeRegistry,String,Node,Node,JSType)",
    "snippet": "  @VisibleForTesting\n  public FunctionType(JSTypeRegistry registry, String name, Node source,\n      Node parameters, JSType returnType) {\n    this(registry, name, source, parameters, returnType, null, null, false,\n         false);\n  }",
    "comment": " Creates a function type. @param registry the owner registry for this type @param name the function's name or {@code null} to indicate that the function is anonymous. @param source the node defining this function. Its type ({@link Node#getType()}) must be {@link Token#FUNCTION}. @param parameters the function's parameters or {@code null} to indicate that the parameter types are unknown. @param returnType the function's return type or {@code null} to indicate that the return type is unknown. ",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "FunctionType.FunctionType",
    "class_name": "com.google.javascript.rhino.jstype.FunctionType",
    "signature": "com.google.javascript.rhino.jstype.FunctionType.FunctionType(JSTypeRegistry,String,Node,Node,JSType,ObjectType,String,boolean,boolean)",
    "snippet": "  FunctionType(JSTypeRegistry registry, String name, Node source,\n      Node parameters, JSType returnType, ObjectType typeOfThis,\n      String templateTypeName,  boolean isConstructor, boolean nativeType) {\n    super(registry, name,\n        registry.getNativeObjectType(JSTypeNative.FUNCTION_INSTANCE_TYPE),\n        nativeType);\n    Preconditions.checkArgument(source == null ||\n        Token.FUNCTION == source.getType());\n    this.source = source;\n    this.kind = isConstructor ? Kind.CONSTRUCTOR : Kind.ORDINARY;\n    if (isConstructor) {\n      this.typeOfThis = typeOfThis != null && typeOfThis.isNoObjectType() ?\n          typeOfThis : new InstanceObjectType(registry, this, nativeType);\n    } else {\n      this.typeOfThis = typeOfThis != null ?\n          typeOfThis :\n          registry.getNativeObjectType(JSTypeNative.UNKNOWN_TYPE);\n    }\n    // The call type should be set up last because we are calling getReturnType,\n    // which may be overloaded and depend on other properties being set.\n    this.call = new ArrowType(registry, parameters,\n        (returnType == null ? getReturnType() : returnType));\n    this.templateTypeName = templateTypeName;\n  }",
    "comment": "Creates an instance for a function that might be a constructor. */",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "FunctionType.addSubType",
    "class_name": "com.google.javascript.rhino.jstype.FunctionType",
    "signature": "com.google.javascript.rhino.jstype.FunctionType.addSubType(FunctionType)",
    "snippet": "  private void addSubType(FunctionType subType) {\n    if (subTypes == null) {\n      subTypes = Lists.newArrayList();\n    }\n    subTypes.add(subType);\n  }",
    "comment": "Adds a type to the list of subtypes for this type. */",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "FunctionType.defineProperty",
    "class_name": "com.google.javascript.rhino.jstype.FunctionType",
    "signature": "com.google.javascript.rhino.jstype.FunctionType.defineProperty(String,JSType,boolean,boolean)",
    "snippet": "  @Override\n  boolean defineProperty(String name, JSType type,\n      boolean inferred, boolean inExterns) {\n    if (\"prototype\".equals(name)) {\n      ObjectType objType = type.toObjectType();\n      if (objType != null) {\n        if (objType.equals(prototype)) {\n          return true;\n        }\n        return setPrototype(\n            new FunctionPrototypeType(\n                registry, this, objType, isNativeObjectType()));\n      } else {\n        return false;\n      }\n    }\n    return super.defineProperty(name, type, inferred, inExterns);\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "FunctionType.getInstanceType",
    "class_name": "com.google.javascript.rhino.jstype.FunctionType",
    "signature": "com.google.javascript.rhino.jstype.FunctionType.getInstanceType()",
    "snippet": "  public ObjectType getInstanceType() {\n    Preconditions.checkState(hasInstanceType());\n    return typeOfThis;\n  }",
    "comment": " Gets the type of instance of this function. @throws IllegalStateException if this function is not a constructor (see {@link #isConstructor()}). ",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "FunctionType.getPrototype",
    "class_name": "com.google.javascript.rhino.jstype.FunctionType",
    "signature": "com.google.javascript.rhino.jstype.FunctionType.getPrototype()",
    "snippet": "  public FunctionPrototypeType getPrototype() {\n    // lazy initialization of the prototype field\n    if (prototype == null) {\n      setPrototype(new FunctionPrototypeType(registry, this, null));\n    }\n    return prototype;\n  }",
    "comment": " Gets the {@code prototype} property of this function type. This is equivalent to {@code (ObjectType) getPropertyType(\"prototype\")}. ",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "FunctionType.getSuperClassConstructor",
    "class_name": "com.google.javascript.rhino.jstype.FunctionType",
    "signature": "com.google.javascript.rhino.jstype.FunctionType.getSuperClassConstructor()",
    "snippet": "  public FunctionType getSuperClassConstructor() {\n    Preconditions.checkArgument(isConstructor() || isInterface());\n    ObjectType maybeSuperInstanceType = getPrototype().getImplicitPrototype();\n    if (maybeSuperInstanceType == null) {\n      return null;\n    }\n    return maybeSuperInstanceType.getConstructor();\n  }",
    "comment": " Given a constructor or an interface type, get its superclass constructor or {@code null} if none exists. ",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "FunctionType.hasCachedValues",
    "class_name": "com.google.javascript.rhino.jstype.FunctionType",
    "signature": "com.google.javascript.rhino.jstype.FunctionType.hasCachedValues()",
    "snippet": "  @Override\n  public boolean hasCachedValues() {\n    return prototype != null || super.hasCachedValues();\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "FunctionType.hasInstanceType",
    "class_name": "com.google.javascript.rhino.jstype.FunctionType",
    "signature": "com.google.javascript.rhino.jstype.FunctionType.hasInstanceType()",
    "snippet": "  public boolean hasInstanceType() {\n    return isConstructor() || isInterface();\n  }",
    "comment": " Returns whether this function type has an instance type. ",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "FunctionType.hashCode",
    "class_name": "com.google.javascript.rhino.jstype.FunctionType",
    "signature": "com.google.javascript.rhino.jstype.FunctionType.hashCode()",
    "snippet": "  @Override\n  public int hashCode() {\n    return isInterface() ? getReferenceName().hashCode() : call.hashCode();\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "FunctionType.isConstructor",
    "class_name": "com.google.javascript.rhino.jstype.FunctionType",
    "signature": "com.google.javascript.rhino.jstype.FunctionType.isConstructor()",
    "snippet": "  @Override\n  public boolean isConstructor() {\n    return kind == Kind.CONSTRUCTOR;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "FunctionType.isInterface",
    "class_name": "com.google.javascript.rhino.jstype.FunctionType",
    "signature": "com.google.javascript.rhino.jstype.FunctionType.isInterface()",
    "snippet": "  @Override\n  public boolean isInterface() {\n    return kind == Kind.INTERFACE;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "FunctionType.setInstanceType",
    "class_name": "com.google.javascript.rhino.jstype.FunctionType",
    "signature": "com.google.javascript.rhino.jstype.FunctionType.setInstanceType(ObjectType)",
    "snippet": "  void setInstanceType(ObjectType instanceType) {\n    typeOfThis = instanceType;\n  }",
    "comment": "Sets the instance type. This should only be used for special native types. */",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "FunctionType.setPrototype",
    "class_name": "com.google.javascript.rhino.jstype.FunctionType",
    "signature": "com.google.javascript.rhino.jstype.FunctionType.setPrototype(FunctionPrototypeType)",
    "snippet": "  public boolean setPrototype(FunctionPrototypeType prototype) {\n    if (prototype == null) {\n      return false;\n    }\n    // getInstanceType fails if the function is not a constructor\n    if (isConstructor() && prototype == getInstanceType()) {\n      return false;\n    }\n\n    this.prototype = prototype;\n\n    if (isConstructor() || isInterface()) {\n      FunctionType superClass = getSuperClassConstructor();\n      if (superClass != null) {\n        superClass.addSubType(this);\n      }\n    }\n    return true;\n  }",
    "comment": " Sets the prototype. @param prototype the prototype. If this value is {@code null} it will silently be discarded. ",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "FunctionType.setPrototypeBasedOn",
    "class_name": "com.google.javascript.rhino.jstype.FunctionType",
    "signature": "com.google.javascript.rhino.jstype.FunctionType.setPrototypeBasedOn(ObjectType)",
    "snippet": "  public void setPrototypeBasedOn(ObjectType baseType) {\n    if (prototype == null) {\n      setPrototype(\n          new FunctionPrototypeType(\n              registry, this, baseType, isNativeObjectType()));\n    } else {\n      prototype.setImplicitPrototype(baseType);\n    }\n  }",
    "comment": " Sets the prototype, creating the prototype object from the given base type. @param baseType The base type. ",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "InstanceObjectType.InstanceObjectType",
    "class_name": "com.google.javascript.rhino.jstype.InstanceObjectType",
    "signature": "com.google.javascript.rhino.jstype.InstanceObjectType.InstanceObjectType(JSTypeRegistry,FunctionType,boolean)",
    "snippet": "  InstanceObjectType(JSTypeRegistry registry, FunctionType constructor,\n                     boolean isNativeType) {\n    super(registry, null, null, isNativeType);\n    Preconditions.checkNotNull(constructor);\n    this.constructor = constructor;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "InstanceObjectType.defineProperty",
    "class_name": "com.google.javascript.rhino.jstype.InstanceObjectType",
    "signature": "com.google.javascript.rhino.jstype.InstanceObjectType.defineProperty(String,JSType,boolean,boolean)",
    "snippet": "  @Override\n  boolean defineProperty(String name, JSType type, boolean inferred,\n      boolean inExterns) {\n    ObjectType proto = getImplicitPrototype();\n    if (proto != null && proto.hasOwnDeclaredProperty(name)) {\n      return false;\n    }\n    return super.defineProperty(name, type, inferred, inExterns);\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "InstanceObjectType.equals",
    "class_name": "com.google.javascript.rhino.jstype.InstanceObjectType",
    "signature": "com.google.javascript.rhino.jstype.InstanceObjectType.equals(Object)",
    "snippet": "  @Override\n  public boolean equals(Object that) {\n    if (this == that) {\n      return true;\n    } else if (that instanceof JSType && this.isNominalType()) {\n      ObjectType thatObj = ObjectType.cast((JSType) that);\n      if (thatObj != null && thatObj.isNominalType()) {\n        return getReferenceName().equals(thatObj.getReferenceName());\n      }\n    }\n    return false;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "InstanceObjectType.getConstructor",
    "class_name": "com.google.javascript.rhino.jstype.InstanceObjectType",
    "signature": "com.google.javascript.rhino.jstype.InstanceObjectType.getConstructor()",
    "snippet": "  @Override\n  public FunctionType getConstructor() {\n    return constructor;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "InstanceObjectType.getImplicitPrototype",
    "class_name": "com.google.javascript.rhino.jstype.InstanceObjectType",
    "signature": "com.google.javascript.rhino.jstype.InstanceObjectType.getImplicitPrototype()",
    "snippet": "  @Override\n  public ObjectType getImplicitPrototype() {\n    return getConstructor().getPrototype();\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "InstanceObjectType.getReferenceName",
    "class_name": "com.google.javascript.rhino.jstype.InstanceObjectType",
    "signature": "com.google.javascript.rhino.jstype.InstanceObjectType.getReferenceName()",
    "snippet": "  @Override\n  public String getReferenceName() {\n    return getConstructor().getReferenceName();\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "InstanceObjectType.hasReferenceName",
    "class_name": "com.google.javascript.rhino.jstype.InstanceObjectType",
    "signature": "com.google.javascript.rhino.jstype.InstanceObjectType.hasReferenceName()",
    "snippet": "  @Override\n  public boolean hasReferenceName() {\n    return getConstructor().hasReferenceName();\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "InstanceObjectType.hashCode",
    "class_name": "com.google.javascript.rhino.jstype.InstanceObjectType",
    "signature": "com.google.javascript.rhino.jstype.InstanceObjectType.hashCode()",
    "snippet": "  @Override\n  public int hashCode() {\n    if (hasReferenceName()) {\n      return getReferenceName().hashCode();\n    } else {\n      return super.hashCode();\n    }\n  }",
    "comment": " If this is equal to a NamedType object, its hashCode must be equal to the hashCode of the NamedType object. ",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "InstanceObjectType.isNominalType",
    "class_name": "com.google.javascript.rhino.jstype.InstanceObjectType",
    "signature": "com.google.javascript.rhino.jstype.InstanceObjectType.isNominalType()",
    "snippet": "  @Override\n  public boolean isNominalType() {\n    return hasReferenceName();\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "InstanceObjectType.toString",
    "class_name": "com.google.javascript.rhino.jstype.InstanceObjectType",
    "signature": "com.google.javascript.rhino.jstype.InstanceObjectType.toString()",
    "snippet": "  @Override\n  public String toString() {\n    return constructor.getReferenceName();\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "JSType.JSType",
    "class_name": "com.google.javascript.rhino.jstype.JSType",
    "signature": "com.google.javascript.rhino.jstype.JSType.JSType(JSTypeRegistry)",
    "snippet": "  JSType(JSTypeRegistry registry) {\n    this.registry = registry;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "JSType.equals",
    "class_name": "com.google.javascript.rhino.jstype.JSType",
    "signature": "com.google.javascript.rhino.jstype.JSType.equals(Object)",
    "snippet": "  @Override public boolean equals(Object jsType) {\n    if (jsType instanceof ProxyObjectType) {\n      return jsType.equals(this);\n    }\n    return this == jsType;\n  }",
    "comment": " This method relies on the fact that for the base {@link JSType}, only one instance of each sub-type will ever be created in a given registry, so there is no need to verify members. If the object pointers are not identical, then the type member must be different. ",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "JSType.hashCode",
    "class_name": "com.google.javascript.rhino.jstype.JSType",
    "signature": "com.google.javascript.rhino.jstype.JSType.hashCode()",
    "snippet": "  @Override\n  public int hashCode() {\n    return System.identityHashCode(this);\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "JSType.isAllType",
    "class_name": "com.google.javascript.rhino.jstype.JSType",
    "signature": "com.google.javascript.rhino.jstype.JSType.isAllType()",
    "snippet": "  public boolean isAllType() {\n    return false;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "JSType.isEmptyType",
    "class_name": "com.google.javascript.rhino.jstype.JSType",
    "signature": "com.google.javascript.rhino.jstype.JSType.isEmptyType()",
    "snippet": "  public final boolean isEmptyType() {\n    return isNoType() || isNoObjectType();\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "JSType.isNoObjectType",
    "class_name": "com.google.javascript.rhino.jstype.JSType",
    "signature": "com.google.javascript.rhino.jstype.JSType.isNoObjectType()",
    "snippet": "  public boolean isNoObjectType() {\n    return false;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "JSType.isNoType",
    "class_name": "com.google.javascript.rhino.jstype.JSType",
    "signature": "com.google.javascript.rhino.jstype.JSType.isNoType()",
    "snippet": "  public boolean isNoType() {\n    return false;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "JSType.isSubtype",
    "class_name": "com.google.javascript.rhino.jstype.JSType",
    "signature": "com.google.javascript.rhino.jstype.JSType.isSubtype(JSType,JSType)",
    "snippet": "  static boolean isSubtype(JSType thisType, JSType thatType) {\n    // unknown\n    if (thatType.isUnknownType()) {\n      return true;\n    }\n    // equality\n    if (thisType.equals(thatType)) {\n      return true;\n    }\n    // all type\n    if (thatType.isAllType()) {\n      return true;\n    }\n    // unions\n    if (thatType instanceof UnionType) {\n      UnionType union = (UnionType)thatType;\n      for (JSType element : union.alternates) {\n        if (thisType.isSubtype(element)) {\n          return true;\n        }\n      }\n    }\n    // named types\n    if (thatType instanceof NamedType) {\n      return thisType.isSubtype(((NamedType)thatType).referencedType);\n    }\n    return false;\n  }",
    "comment": " A generic implementation meant to be used as a helper for common subtyping cases. ",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "JSType.isUnknownType",
    "class_name": "com.google.javascript.rhino.jstype.JSType",
    "signature": "com.google.javascript.rhino.jstype.JSType.isUnknownType()",
    "snippet": "  public boolean isUnknownType() {\n    return false;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "JSType.toObjectType",
    "class_name": "com.google.javascript.rhino.jstype.JSType",
    "signature": "com.google.javascript.rhino.jstype.JSType.toObjectType()",
    "snippet": "  public ObjectType toObjectType() {\n    return this instanceof ObjectType ? (ObjectType) this : null;\n  }",
    "comment": " Casts this to an ObjectType, or returns null if this is not an ObjectType.  Does not change the underlying JS type. If you want to simulate JS autoboxing or dereferencing, you should use autoboxesTo() or dereference(). Those methods may change the underlying JS type. ",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "JSTypeRegistry.JSTypeRegistry",
    "class_name": "com.google.javascript.rhino.jstype.JSTypeRegistry",
    "signature": "com.google.javascript.rhino.jstype.JSTypeRegistry.JSTypeRegistry(ErrorReporter)",
    "snippet": "  public JSTypeRegistry(ErrorReporter reporter) {\n    this.reporter = reporter;\n    nativeTypes = new JSType[JSTypeNative.values().length];\n    namesToTypes = new HashMap<String, JSType>();\n    resetForTypeCheck();\n  }",
    "comment": " Constructs a new type registry populated with the built-in types. ",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "JSTypeRegistry.createFunctionType",
    "class_name": "com.google.javascript.rhino.jstype.JSTypeRegistry",
    "signature": "com.google.javascript.rhino.jstype.JSTypeRegistry.createFunctionType(JSType,boolean,JSType[])",
    "snippet": "  public FunctionType createFunctionType(JSType returnType,\n      boolean lastVarArgs, JSType... parameterTypes) {\n    if (lastVarArgs) {\n      return createFunctionTypeWithVarArgs(returnType, parameterTypes);\n    } else {\n      return createFunctionType(returnType, parameterTypes);\n    }\n  }",
    "comment": " Creates a function type. @param returnType the function's return type @param lastVarArgs whether the last parameter type should be considered as an extensible var_args parameter @param parameterTypes the parameters' types ",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "JSTypeRegistry.createFunctionTypeWithVarArgs",
    "class_name": "com.google.javascript.rhino.jstype.JSTypeRegistry",
    "signature": "com.google.javascript.rhino.jstype.JSTypeRegistry.createFunctionTypeWithVarArgs(JSType,JSType[])",
    "snippet": "  public FunctionType createFunctionTypeWithVarArgs(\n      JSType returnType, JSType... parameterTypes) {\n    return new FunctionType(\n        this, null, null, createParametersWithVarArgs(parameterTypes), returnType);\n  }",
    "comment": " Creates a function type. The last parameter type of the function is considered a variable length argument.  @param returnType the function's return type @param parameterTypes the parameters' types ",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "JSTypeRegistry.createNullableType",
    "class_name": "com.google.javascript.rhino.jstype.JSTypeRegistry",
    "signature": "com.google.javascript.rhino.jstype.JSTypeRegistry.createNullableType(JSType)",
    "snippet": "  public JSType createNullableType(JSType type) {\n    return createUnionType(type, getNativeType(JSTypeNative.NULL_TYPE));\n  }",
    "comment": " Creates a type representing nullable values of the given type. @return the union of the type and the Null type ",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "JSTypeRegistry.createObjectType",
    "class_name": "com.google.javascript.rhino.jstype.JSTypeRegistry",
    "signature": "com.google.javascript.rhino.jstype.JSTypeRegistry.createObjectType(String,Node,ObjectType)",
    "snippet": "  public ObjectType createObjectType(String name, Node n,\n      ObjectType implicitPrototype) {\n    return new PrototypeObjectType(this, name, implicitPrototype);\n  }",
    "comment": " Create an object type. ",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "JSTypeRegistry.createOptionalParameters",
    "class_name": "com.google.javascript.rhino.jstype.JSTypeRegistry",
    "signature": "com.google.javascript.rhino.jstype.JSTypeRegistry.createOptionalParameters(JSType[])",
    "snippet": "  public Node createOptionalParameters(JSType... parameterTypes) {\n    FunctionParamBuilder builder = new FunctionParamBuilder(this);\n    builder.addOptionalParams(parameterTypes);\n    return builder.build();\n  }",
    "comment": " Creates a tree hierarchy representing a typed parameter list in which every parameter is optional. ",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "JSTypeRegistry.createOptionalType",
    "class_name": "com.google.javascript.rhino.jstype.JSTypeRegistry",
    "signature": "com.google.javascript.rhino.jstype.JSTypeRegistry.createOptionalType(JSType)",
    "snippet": "  public JSType createOptionalType(JSType type) {\n    if (type instanceof UnknownType || type.isAllType()) {\n      return type;\n    } else {\n      return createUnionType(type, getNativeType(JSTypeNative.VOID_TYPE));\n    }\n  }",
    "comment": " Creates a type representing optional values of the given type. @return the union of the type and the void type ",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "JSTypeRegistry.createParameters",
    "class_name": "com.google.javascript.rhino.jstype.JSTypeRegistry",
    "signature": "com.google.javascript.rhino.jstype.JSTypeRegistry.createParameters(boolean,JSType[])",
    "snippet": "  private Node createParameters(boolean lastVarArgs, JSType... parameterTypes) {\n    FunctionParamBuilder builder = new FunctionParamBuilder(this);\n    int max = parameterTypes.length - 1;\n    for (int i = 0; i <= max; i++) {\n      if (lastVarArgs && i == max) {\n        builder.addVarArgs(parameterTypes[i]);\n      } else {\n        builder.addRequiredParams(parameterTypes[i]);\n      }\n    }\n    return builder.build();\n  }",
    "comment": " Creates a tree hierarchy representing a typed argument list.  @param lastVarArgs whether the last type should considered as a variable length argument. @param parameterTypes the parameter types. The last element of this array is considered a variable length argument is {@code lastVarArgs} is {@code true}. @return a tree hierarchy representing a typed argument list ",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "JSTypeRegistry.createParametersWithVarArgs",
    "class_name": "com.google.javascript.rhino.jstype.JSTypeRegistry",
    "signature": "com.google.javascript.rhino.jstype.JSTypeRegistry.createParametersWithVarArgs(JSType[])",
    "snippet": "  public Node createParametersWithVarArgs(JSType... parameterTypes) {\n    return createParameters(true, parameterTypes);\n  }",
    "comment": " Creates a tree hierarchy representing a typed argument list. The last parameter type is considered a variable length argument.  @param parameterTypes the parameter types. The last element of this array is considered a variable length argument. @return a tree hierarchy representing a typed argument list. ",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "JSTypeRegistry.createUnionType",
    "class_name": "com.google.javascript.rhino.jstype.JSTypeRegistry",
    "signature": "com.google.javascript.rhino.jstype.JSTypeRegistry.createUnionType(JSTypeNative[])",
    "snippet": "  public JSType createUnionType(JSTypeNative... variants) {\n    UnionTypeBuilder builder = new UnionTypeBuilder(this);\n    for (JSTypeNative typeId : variants) {\n      builder.addAlternate(getNativeType(typeId));\n    }\n    return builder.build();\n  }",
    "comment": " Creates a union type whose variants are the builtin types specified by the arguments. ",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "JSTypeRegistry.createUnionType",
    "class_name": "com.google.javascript.rhino.jstype.JSTypeRegistry",
    "signature": "com.google.javascript.rhino.jstype.JSTypeRegistry.createUnionType(JSType[])",
    "snippet": "  public JSType createUnionType(JSType... variants) {\n    UnionTypeBuilder builder = new UnionTypeBuilder(this);\n    for (JSType type : variants) {\n      builder.addAlternate(type);\n    }\n    return builder.build();\n  }",
    "comment": " Creates a union type whose variants are the arguments. ",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "JSTypeRegistry.getNativeFunctionType",
    "class_name": "com.google.javascript.rhino.jstype.JSTypeRegistry",
    "signature": "com.google.javascript.rhino.jstype.JSTypeRegistry.getNativeFunctionType(JSTypeNative)",
    "snippet": "  public FunctionType getNativeFunctionType(JSTypeNative typeId) {\n    return (FunctionType) getNativeType(typeId);\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "JSTypeRegistry.getNativeObjectType",
    "class_name": "com.google.javascript.rhino.jstype.JSTypeRegistry",
    "signature": "com.google.javascript.rhino.jstype.JSTypeRegistry.getNativeObjectType(JSTypeNative)",
    "snippet": "  public ObjectType getNativeObjectType(JSTypeNative typeId) {\n    return (ObjectType) getNativeType(typeId);\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "JSTypeRegistry.getNativeType",
    "class_name": "com.google.javascript.rhino.jstype.JSTypeRegistry",
    "signature": "com.google.javascript.rhino.jstype.JSTypeRegistry.getNativeType(JSTypeNative)",
    "snippet": "  public JSType getNativeType(JSTypeNative typeId) {\n    return nativeTypes[typeId.ordinal()];\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "JSTypeRegistry.initializeBuiltInTypes",
    "class_name": "com.google.javascript.rhino.jstype.JSTypeRegistry",
    "signature": "com.google.javascript.rhino.jstype.JSTypeRegistry.initializeBuiltInTypes()",
    "snippet": "  private void initializeBuiltInTypes() {\n    // These locals shouldn't be all caps.\n    BooleanType BOOLEAN_TYPE = new BooleanType(this);\n    registerNativeType(JSTypeNative.BOOLEAN_TYPE, BOOLEAN_TYPE);\n\n    NullType NULL_TYPE = new NullType(this);\n    registerNativeType(JSTypeNative.NULL_TYPE, NULL_TYPE);\n\n    NumberType NUMBER_TYPE = new NumberType(this);\n    registerNativeType(JSTypeNative.NUMBER_TYPE, NUMBER_TYPE);\n\n    StringType STRING_TYPE = new StringType(this);\n    registerNativeType(JSTypeNative.STRING_TYPE, STRING_TYPE);\n\n    UnknownType UNKNOWN_TYPE = new UnknownType(this, false);\n    registerNativeType(JSTypeNative.UNKNOWN_TYPE, UNKNOWN_TYPE);\n    registerNativeType(\n        JSTypeNative.CHECKED_UNKNOWN_TYPE, new UnknownType(this, true));\n\n    VoidType VOID_TYPE = new VoidType(this);\n    registerNativeType(JSTypeNative.VOID_TYPE, VOID_TYPE);\n\n    AllType ALL_TYPE = new AllType(this);\n    registerNativeType(JSTypeNative.ALL_TYPE, ALL_TYPE);\n\n    // Top Level Prototype (the One)\n    // The initializations of TOP_LEVEL_PROTOTYPE and OBJECT_FUNCTION_TYPE\n    // use each other's results, so at least one of them will get null\n    // instead of an actual type; however, this seems to be benign.\n    ObjectType TOP_LEVEL_PROTOTYPE =\n        new FunctionPrototypeType(this, null, null, true);\n    registerNativeType(JSTypeNative.TOP_LEVEL_PROTOTYPE, TOP_LEVEL_PROTOTYPE);\n\n    // Object\n    FunctionType OBJECT_FUNCTION_TYPE =\n        new FunctionType(this, \"Object\", null,\n            createOptionalParameters(ALL_TYPE), UNKNOWN_TYPE,\n            null, null, true, true);\n    OBJECT_FUNCTION_TYPE.defineDeclaredProperty(\n        \"prototype\", TOP_LEVEL_PROTOTYPE, true);\n    registerNativeType(JSTypeNative.OBJECT_FUNCTION_TYPE, OBJECT_FUNCTION_TYPE);\n\n    ObjectType OBJECT_PROTOTYPE = OBJECT_FUNCTION_TYPE.getPrototype();\n    registerNativeType(JSTypeNative.OBJECT_PROTOTYPE, OBJECT_PROTOTYPE);\n\n    ObjectType OBJECT_TYPE = OBJECT_FUNCTION_TYPE.getInstanceType();\n    registerNativeType(JSTypeNative.OBJECT_TYPE, OBJECT_TYPE);\n\n    // Function\n    FunctionType FUNCTION_FUNCTION_TYPE =\n        new FunctionType(this, \"Function\", null,\n            createParametersWithVarArgs(ALL_TYPE), UNKNOWN_TYPE,\n            null, null, true, true);\n    FUNCTION_FUNCTION_TYPE.setPrototypeBasedOn(OBJECT_TYPE);\n    registerNativeType(\n        JSTypeNative.FUNCTION_FUNCTION_TYPE, FUNCTION_FUNCTION_TYPE);\n\n    ObjectType FUNCTION_PROTOTYPE = FUNCTION_FUNCTION_TYPE.getPrototype();\n    registerNativeType(JSTypeNative.FUNCTION_PROTOTYPE, FUNCTION_PROTOTYPE);\n\n    NoType NO_TYPE = new NoType(this);\n    registerNativeType(JSTypeNative.NO_TYPE, NO_TYPE);\n\n    NoObjectType NO_OBJECT_TYPE = new NoObjectType(this);\n    registerNativeType(JSTypeNative.NO_OBJECT_TYPE, NO_OBJECT_TYPE);\n\n    // Array\n    FunctionType ARRAY_FUNCTION_TYPE =\n      new FunctionType(this, \"Array\", null,\n          createParametersWithVarArgs(ALL_TYPE), null, null, null, true, true) {\n        private static final long serialVersionUID = 1L;\n\n        @Override\n        public JSType getReturnType() {\n          return getInstanceType();\n        }\n      };\n    ObjectType arrayPrototype = ARRAY_FUNCTION_TYPE.getPrototype();\n    registerNativeType(JSTypeNative.ARRAY_FUNCTION_TYPE, ARRAY_FUNCTION_TYPE);\n\n    ObjectType ARRAY_TYPE = ARRAY_FUNCTION_TYPE.getInstanceType();\n    registerNativeType(JSTypeNative.ARRAY_TYPE, ARRAY_TYPE);\n\n    // Boolean\n    FunctionType BOOLEAN_OBJECT_FUNCTION_TYPE =\n        new FunctionType(this, \"Boolean\", null,\n            createParameters(false, ALL_TYPE), BOOLEAN_TYPE, null, null, true,\n            true);\n    ObjectType booleanPrototype = BOOLEAN_OBJECT_FUNCTION_TYPE.getPrototype();\n    registerNativeType(\n        JSTypeNative.BOOLEAN_OBJECT_FUNCTION_TYPE, BOOLEAN_OBJECT_FUNCTION_TYPE);\n\n    ObjectType BOOLEAN_OBJECT_TYPE =\n        BOOLEAN_OBJECT_FUNCTION_TYPE.getInstanceType();\n    registerNativeType(JSTypeNative.BOOLEAN_OBJECT_TYPE, BOOLEAN_OBJECT_TYPE);\n\n    // Date\n    FunctionType DATE_FUNCTION_TYPE =\n      new FunctionType(this, \"Date\", null,\n          createOptionalParameters(UNKNOWN_TYPE, UNKNOWN_TYPE, UNKNOWN_TYPE,\n              UNKNOWN_TYPE, UNKNOWN_TYPE, UNKNOWN_TYPE, UNKNOWN_TYPE),\n          STRING_TYPE, null, null, true, true);\n    ObjectType datePrototype = DATE_FUNCTION_TYPE.getPrototype();\n    registerNativeType(JSTypeNative.DATE_FUNCTION_TYPE, DATE_FUNCTION_TYPE);\n\n    ObjectType DATE_TYPE = DATE_FUNCTION_TYPE.getInstanceType();\n    registerNativeType(JSTypeNative.DATE_TYPE, DATE_TYPE);\n\n    // Error\n    FunctionType ERROR_FUNCTION_TYPE = new ErrorFunctionType(this, \"Error\");\n    registerNativeType(JSTypeNative.ERROR_FUNCTION_TYPE, ERROR_FUNCTION_TYPE);\n\n    ObjectType ERROR_TYPE = ERROR_FUNCTION_TYPE.getInstanceType();\n    registerNativeType(JSTypeNative.ERROR_TYPE, ERROR_TYPE);\n\n    // EvalError\n    FunctionType EVAL_ERROR_FUNCTION_TYPE =\n        new ErrorFunctionType(this, \"EvalError\");\n    EVAL_ERROR_FUNCTION_TYPE.setPrototypeBasedOn(ERROR_TYPE);\n    registerNativeType(\n        JSTypeNative.EVAL_ERROR_FUNCTION_TYPE, EVAL_ERROR_FUNCTION_TYPE);\n\n    ObjectType EVAL_ERROR_TYPE = EVAL_ERROR_FUNCTION_TYPE.getInstanceType();\n    registerNativeType(JSTypeNative.EVAL_ERROR_TYPE, EVAL_ERROR_TYPE);\n\n    // RangeError\n    FunctionType RANGE_ERROR_FUNCTION_TYPE =\n        new ErrorFunctionType(this, \"RangeError\");\n    RANGE_ERROR_FUNCTION_TYPE.setPrototypeBasedOn(ERROR_TYPE);\n    registerNativeType(\n        JSTypeNative.RANGE_ERROR_FUNCTION_TYPE, RANGE_ERROR_FUNCTION_TYPE);\n\n    ObjectType RANGE_ERROR_TYPE = RANGE_ERROR_FUNCTION_TYPE.getInstanceType();\n    registerNativeType(JSTypeNative.RANGE_ERROR_TYPE, RANGE_ERROR_TYPE);\n\n    // ReferenceError\n    FunctionType REFERENCE_ERROR_FUNCTION_TYPE =\n        new ErrorFunctionType(this, \"ReferenceError\");\n    REFERENCE_ERROR_FUNCTION_TYPE.setPrototypeBasedOn(ERROR_TYPE);\n    registerNativeType(\n        JSTypeNative.REFERENCE_ERROR_FUNCTION_TYPE, REFERENCE_ERROR_FUNCTION_TYPE);\n\n    ObjectType REFERENCE_ERROR_TYPE =\n        REFERENCE_ERROR_FUNCTION_TYPE.getInstanceType();\n    registerNativeType(JSTypeNative.REFERENCE_ERROR_TYPE, REFERENCE_ERROR_TYPE);\n\n    // SyntaxError\n    FunctionType SYNTAX_ERROR_FUNCTION_TYPE =\n        new ErrorFunctionType(this, \"SyntaxError\");\n    SYNTAX_ERROR_FUNCTION_TYPE.setPrototypeBasedOn(ERROR_TYPE);\n    registerNativeType(\n        JSTypeNative.SYNTAX_ERROR_FUNCTION_TYPE, SYNTAX_ERROR_FUNCTION_TYPE);\n\n    ObjectType SYNTAX_ERROR_TYPE = SYNTAX_ERROR_FUNCTION_TYPE.getInstanceType();\n    registerNativeType(JSTypeNative.SYNTAX_ERROR_TYPE, SYNTAX_ERROR_TYPE);\n\n    // TypeError\n    FunctionType TYPE_ERROR_FUNCTION_TYPE =\n        new ErrorFunctionType(this, \"TypeError\");\n    TYPE_ERROR_FUNCTION_TYPE.setPrototypeBasedOn(ERROR_TYPE);\n    registerNativeType(\n        JSTypeNative.TYPE_ERROR_FUNCTION_TYPE, TYPE_ERROR_FUNCTION_TYPE);\n\n    ObjectType TYPE_ERROR_TYPE = TYPE_ERROR_FUNCTION_TYPE.getInstanceType();\n    registerNativeType(JSTypeNative.TYPE_ERROR_TYPE, TYPE_ERROR_TYPE);\n\n    // URIError\n    FunctionType URI_ERROR_FUNCTION_TYPE =\n        new ErrorFunctionType(this, \"URIError\");\n    URI_ERROR_FUNCTION_TYPE.setPrototypeBasedOn(ERROR_TYPE);\n    registerNativeType(\n        JSTypeNative.URI_ERROR_FUNCTION_TYPE, URI_ERROR_FUNCTION_TYPE);\n\n    ObjectType URI_ERROR_TYPE = URI_ERROR_FUNCTION_TYPE.getInstanceType();\n    registerNativeType(JSTypeNative.URI_ERROR_TYPE, URI_ERROR_TYPE);\n\n    // Number\n    FunctionType NUMBER_OBJECT_FUNCTION_TYPE =\n        new FunctionType(this, \"Number\", null, createParameters(false, ALL_TYPE),\n            NUMBER_TYPE, null, null, true, true);\n    ObjectType numberPrototype = NUMBER_OBJECT_FUNCTION_TYPE.getPrototype();\n    registerNativeType(\n        JSTypeNative.NUMBER_OBJECT_FUNCTION_TYPE, NUMBER_OBJECT_FUNCTION_TYPE);\n\n    ObjectType NUMBER_OBJECT_TYPE =\n        NUMBER_OBJECT_FUNCTION_TYPE.getInstanceType();\n    registerNativeType(JSTypeNative.NUMBER_OBJECT_TYPE, NUMBER_OBJECT_TYPE);\n\n    // RegExp\n    FunctionType REGEXP_FUNCTION_TYPE =\n      new FunctionType(this, \"RegExp\", null,\n          createOptionalParameters(ALL_TYPE, ALL_TYPE),\n          null, null, null, true, true) {\n        private static final long serialVersionUID = 1L;\n\n        @Override\n        public JSType getReturnType() {\n          return getInstanceType();\n        }\n      };\n    ObjectType regexpPrototype = REGEXP_FUNCTION_TYPE.getPrototype();\n    registerNativeType(JSTypeNative.REGEXP_FUNCTION_TYPE, REGEXP_FUNCTION_TYPE);\n\n    ObjectType REGEXP_TYPE = REGEXP_FUNCTION_TYPE.getInstanceType();\n    registerNativeType(JSTypeNative.REGEXP_TYPE, REGEXP_TYPE);\n\n    // String\n    FunctionType STRING_OBJECT_FUNCTION_TYPE =\n        new FunctionType(this, \"String\", null, createParameters(false, ALL_TYPE),\n        STRING_TYPE, null, null, true, true);\n    ObjectType stringPrototype = STRING_OBJECT_FUNCTION_TYPE.getPrototype();\n    registerNativeType(\n        JSTypeNative.STRING_OBJECT_FUNCTION_TYPE, STRING_OBJECT_FUNCTION_TYPE);\n\n    ObjectType STRING_OBJECT_TYPE =\n        STRING_OBJECT_FUNCTION_TYPE.getInstanceType();\n    registerNativeType(\n        JSTypeNative.STRING_OBJECT_TYPE, STRING_OBJECT_TYPE);\n\n    // (Object,string,number)\n    JSType OBJECT_NUMBER_STRING =\n        createUnionType(OBJECT_TYPE, NUMBER_TYPE, STRING_TYPE);\n    registerNativeType(JSTypeNative.OBJECT_NUMBER_STRING, OBJECT_NUMBER_STRING);\n\n    // (Object,string,number,boolean)\n    JSType OBJECT_NUMBER_STRING_BOOLEAN =\n        createUnionType(OBJECT_TYPE, NUMBER_TYPE, STRING_TYPE, BOOLEAN_TYPE);\n    registerNativeType(JSTypeNative.OBJECT_NUMBER_STRING_BOOLEAN,\n        OBJECT_NUMBER_STRING_BOOLEAN);\n\n    // (string,number,boolean)\n    JSType NUMBER_STRING_BOOLEAN =\n        createUnionType(NUMBER_TYPE, STRING_TYPE, BOOLEAN_TYPE);\n    registerNativeType(JSTypeNative.NUMBER_STRING_BOOLEAN,\n        NUMBER_STRING_BOOLEAN);\n\n    // (string,number)\n    JSType NUMBER_STRING = createUnionType(NUMBER_TYPE, STRING_TYPE);\n    registerNativeType(JSTypeNative.NUMBER_STRING, NUMBER_STRING);\n\n    // Native object properties are filled in by externs...\n\n    // (String, string)\n    JSType STRING_VALUE_OR_OBJECT_TYPE =\n        createUnionType(STRING_OBJECT_TYPE, STRING_TYPE);\n    registerNativeType(\n        JSTypeNative.STRING_VALUE_OR_OBJECT_TYPE, STRING_VALUE_OR_OBJECT_TYPE);\n\n    // (Number, number)\n    JSType NUMBER_VALUE_OR_OBJECT_TYPE =\n        createUnionType(NUMBER_OBJECT_TYPE, NUMBER_TYPE);\n    registerNativeType(\n        JSTypeNative.NUMBER_VALUE_OR_OBJECT_TYPE, NUMBER_VALUE_OR_OBJECT_TYPE);\n\n    // unknown function type, i.e. (?...) -> ?\n    FunctionType U2U_FUNCTION_TYPE =\n        createFunctionType(UNKNOWN_TYPE, true, UNKNOWN_TYPE);\n    registerNativeType(JSTypeNative.U2U_FUNCTION_TYPE, U2U_FUNCTION_TYPE);\n\n    // unknown constructor type, i.e. (?...) -> ? with the NoObject type\n    // as instance type\n    FunctionType U2U_CONSTRUCTOR_TYPE =\n        // This is equivalent to\n        // createConstructorType(UNKNOWN_TYPE, true, UNKNOWN_TYPE), but,\n        // in addition, overrides getInstanceType() to return the NoObject type\n        // instead of a new anonymous object.\n        new FunctionType(this, \"Function\", null,\n          createParametersWithVarArgs(\n              UNKNOWN_TYPE), UNKNOWN_TYPE, NO_OBJECT_TYPE, null, true, true) {\n          private static final long serialVersionUID = 1L;\n\n          @Override public FunctionType getConstructor() {\n            return registry.getNativeFunctionType(\n                JSTypeNative.FUNCTION_FUNCTION_TYPE);\n          }\n        };\n\n    // The U2U_CONSTRUCTOR is weird, because it's the supertype of its\n    // own constructor.\n    registerNativeType(JSTypeNative.U2U_CONSTRUCTOR_TYPE, U2U_CONSTRUCTOR_TYPE);\n    registerNativeType(\n        JSTypeNative.FUNCTION_INSTANCE_TYPE, U2U_CONSTRUCTOR_TYPE);\n\n    FUNCTION_FUNCTION_TYPE.setInstanceType(U2U_CONSTRUCTOR_TYPE);\n    U2U_CONSTRUCTOR_TYPE.setImplicitPrototype(FUNCTION_PROTOTYPE);\n\n    // least function type, i.e. (All...) -> NoType\n    FunctionType LEAST_FUNCTION_TYPE =\n        createFunctionType(NO_TYPE, true, ALL_TYPE);\n    registerNativeType(JSTypeNative.LEAST_FUNCTION_TYPE, LEAST_FUNCTION_TYPE);\n\n    // the 'this' object in the global scope\n    ObjectType GLOBAL_THIS = createObjectType(\"global this\", null,\n        UNKNOWN_TYPE /* to be resolved later */);\n    registerNativeType(JSTypeNative.GLOBAL_THIS, GLOBAL_THIS);\n\n    // greatest function type, i.e. (NoType...) -> All\n    FunctionType GREATEST_FUNCTION_TYPE =\n      createFunctionType(ALL_TYPE, true, NO_TYPE);\n    registerNativeType(JSTypeNative.GREATEST_FUNCTION_TYPE,\n        GREATEST_FUNCTION_TYPE);\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "JSTypeRegistry.initializeRegistry",
    "class_name": "com.google.javascript.rhino.jstype.JSTypeRegistry",
    "signature": "com.google.javascript.rhino.jstype.JSTypeRegistry.initializeRegistry()",
    "snippet": "  private void initializeRegistry() {\n    register(getNativeType(JSTypeNative.ARRAY_TYPE));\n    register(getNativeType(JSTypeNative.BOOLEAN_OBJECT_TYPE));\n    register(getNativeType(JSTypeNative.BOOLEAN_TYPE));\n    register(getNativeType(JSTypeNative.DATE_TYPE));\n    register(getNativeType(JSTypeNative.NULL_TYPE));\n    register(getNativeType(JSTypeNative.NULL_TYPE), \"Null\");\n    register(getNativeType(JSTypeNative.NUMBER_OBJECT_TYPE));\n    register(getNativeType(JSTypeNative.NUMBER_TYPE));\n    register(getNativeType(JSTypeNative.OBJECT_TYPE));\n    register(getNativeType(JSTypeNative.ERROR_TYPE));\n    register(getNativeType(JSTypeNative.URI_ERROR_TYPE));\n    register(getNativeType(JSTypeNative.EVAL_ERROR_TYPE));\n    register(getNativeType(JSTypeNative.TYPE_ERROR_TYPE));\n    register(getNativeType(JSTypeNative.RANGE_ERROR_TYPE));\n    register(getNativeType(JSTypeNative.REFERENCE_ERROR_TYPE));\n    register(getNativeType(JSTypeNative.SYNTAX_ERROR_TYPE));\n    register(getNativeType(JSTypeNative.REGEXP_TYPE));\n    register(getNativeType(JSTypeNative.STRING_OBJECT_TYPE));\n    register(getNativeType(JSTypeNative.STRING_TYPE));\n    register(getNativeType(JSTypeNative.VOID_TYPE));\n    register(getNativeType(JSTypeNative.VOID_TYPE), \"Undefined\");\n    register(getNativeType(JSTypeNative.VOID_TYPE), \"void\");\n    register(getNativeType(JSTypeNative.FUNCTION_INSTANCE_TYPE), \"Function\");\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "JSTypeRegistry.register",
    "class_name": "com.google.javascript.rhino.jstype.JSTypeRegistry",
    "signature": "com.google.javascript.rhino.jstype.JSTypeRegistry.register(JSType)",
    "snippet": "  private void register(JSType type) {\n    register(type, type.toString());\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "JSTypeRegistry.register",
    "class_name": "com.google.javascript.rhino.jstype.JSTypeRegistry",
    "signature": "com.google.javascript.rhino.jstype.JSTypeRegistry.register(JSType,String)",
    "snippet": "  private void register(JSType type, String name) {\n    namesToTypes.put(name, type);\n\n    // Add all the namespaces in which this name lives.\n    while (name.indexOf('.') > 0) {\n      name = name.substring(0, name.lastIndexOf('.'));\n      namespaces.add(name);\n    }\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "JSTypeRegistry.registerNativeType",
    "class_name": "com.google.javascript.rhino.jstype.JSTypeRegistry",
    "signature": "com.google.javascript.rhino.jstype.JSTypeRegistry.registerNativeType(JSTypeNative,JSType)",
    "snippet": "  private void registerNativeType(JSTypeNative typeId, JSType type) {\n    nativeTypes[typeId.ordinal()] = type;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "JSTypeRegistry.registerPropertyOnType",
    "class_name": "com.google.javascript.rhino.jstype.JSTypeRegistry",
    "signature": "com.google.javascript.rhino.jstype.JSTypeRegistry.registerPropertyOnType(String,ObjectType)",
    "snippet": "  public void registerPropertyOnType(String propertyName, ObjectType owner) {\n    Set<ObjectType> typeSet = typesIndexedByProperty.get(propertyName);\n    if (typeSet == null) {\n      typesIndexedByProperty.put(propertyName, typeSet = Sets.newHashSet());\n    }\n    greatestSubtypeByProperty.remove(propertyName);\n    typeSet.add(owner);\n  }",
    "comment": " Tells the type system that {@code owner} may have a property named {@code propertyName}. This allows the registry to keep track of what types a property is defined upon.  This is NOT the same as saying that {@code owner} must have a property named type. ObjectType#hasProperty attempts to minimize false positives (\"if we're not sure, then don't type check this property\"). The type registry, on the other hand, should attempt to minimize false negatives (\"if this property is assigned anywhere in the program, it must show up in the type registry\"). ",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "JSTypeRegistry.resetForTypeCheck",
    "class_name": "com.google.javascript.rhino.jstype.JSTypeRegistry",
    "signature": "com.google.javascript.rhino.jstype.JSTypeRegistry.resetForTypeCheck()",
    "snippet": "  public void resetForTypeCheck() {\n    typesIndexedByProperty.clear();\n    initializeBuiltInTypes();\n    namesToTypes.clear();\n    namespaces.clear();\n    initializeRegistry();\n  }",
    "comment": " Reset to run the TypeCheck pass. ",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "NoObjectType.NoObjectType",
    "class_name": "com.google.javascript.rhino.jstype.NoObjectType",
    "signature": "com.google.javascript.rhino.jstype.NoObjectType.NoObjectType(JSTypeRegistry)",
    "snippet": "  NoObjectType(JSTypeRegistry registry) {\n    super(registry, null, null, null, null, null, null, true, true);\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "NoObjectType.getReturnType",
    "class_name": "com.google.javascript.rhino.jstype.NoObjectType",
    "signature": "com.google.javascript.rhino.jstype.NoObjectType.getReturnType()",
    "snippet": "  @Override\n  public JSType getReturnType() {\n    return this;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "NoObjectType.isNoObjectType",
    "class_name": "com.google.javascript.rhino.jstype.NoObjectType",
    "signature": "com.google.javascript.rhino.jstype.NoObjectType.isNoObjectType()",
    "snippet": "  @Override\n  public boolean isNoObjectType() {\n    return true;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "NoType.NoType",
    "class_name": "com.google.javascript.rhino.jstype.NoType",
    "signature": "com.google.javascript.rhino.jstype.NoType.NoType(JSTypeRegistry)",
    "snippet": "  NoType(JSTypeRegistry registry) {\n    super(registry);\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "NoType.isNoType",
    "class_name": "com.google.javascript.rhino.jstype.NoType",
    "signature": "com.google.javascript.rhino.jstype.NoType.isNoType()",
    "snippet": "  @Override\n  public boolean isNoType() {\n    return true;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "NullType.NullType",
    "class_name": "com.google.javascript.rhino.jstype.NullType",
    "signature": "com.google.javascript.rhino.jstype.NullType.NullType(JSTypeRegistry)",
    "snippet": "  NullType(JSTypeRegistry registry) {\n    super(registry);\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "NullType.toString",
    "class_name": "com.google.javascript.rhino.jstype.NullType",
    "signature": "com.google.javascript.rhino.jstype.NullType.toString()",
    "snippet": "  @Override\n  public String toString() {\n    return \"null\";\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "NumberType.NumberType",
    "class_name": "com.google.javascript.rhino.jstype.NumberType",
    "signature": "com.google.javascript.rhino.jstype.NumberType.NumberType(JSTypeRegistry)",
    "snippet": "  NumberType(JSTypeRegistry registry) {\n    super(registry);\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "NumberType.toString",
    "class_name": "com.google.javascript.rhino.jstype.NumberType",
    "signature": "com.google.javascript.rhino.jstype.NumberType.toString()",
    "snippet": "  @Override\n  public String toString() {\n    return \"number\";\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "ObjectType.ObjectType",
    "class_name": "com.google.javascript.rhino.jstype.ObjectType",
    "signature": "com.google.javascript.rhino.jstype.ObjectType.ObjectType(JSTypeRegistry)",
    "snippet": "  ObjectType(JSTypeRegistry registry) {\n    super(registry);\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "ObjectType.cast",
    "class_name": "com.google.javascript.rhino.jstype.ObjectType",
    "signature": "com.google.javascript.rhino.jstype.ObjectType.cast(JSType)",
    "snippet": "  public static ObjectType cast(JSType type) {\n    return type == null ? null : type.toObjectType();\n  }",
    "comment": " A null-safe version of JSType#toObjectType. ",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "ObjectType.defineDeclaredProperty",
    "class_name": "com.google.javascript.rhino.jstype.ObjectType",
    "signature": "com.google.javascript.rhino.jstype.ObjectType.defineDeclaredProperty(String,JSType,boolean)",
    "snippet": "  public final boolean defineDeclaredProperty(String propertyName,\n      JSType type, boolean inExterns) {\n    // All property definitions go through this method\n    // or defineInferredProperty.\n    registry.registerPropertyOnType(propertyName, this);\n\n    return defineProperty(propertyName, type, false, inExterns);\n  }",
    "comment": " Defines a property whose type is synthesized (i.e. not inferred). @param propertyName the property's name @param type the type @param inExterns {@code true} if this property was defined in an externs file. TightenTypes assumes that any function passed to an externs property could be called, so setting this incorrectly could result in live code being removed. ",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "ObjectType.hasCachedValues",
    "class_name": "com.google.javascript.rhino.jstype.ObjectType",
    "signature": "com.google.javascript.rhino.jstype.ObjectType.hasCachedValues()",
    "snippet": "  public boolean hasCachedValues() {\n    return !unknown;\n  }",
    "comment": " Returns true if any cached valeus have been set for this type.  If true, then the prototype chain should not be changed, as it might invalidate the cached values. ",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "ObjectType.hasOwnDeclaredProperty",
    "class_name": "com.google.javascript.rhino.jstype.ObjectType",
    "signature": "com.google.javascript.rhino.jstype.ObjectType.hasOwnDeclaredProperty(String)",
    "snippet": "  boolean hasOwnDeclaredProperty(String name) {\n    return hasOwnProperty(name) && isPropertyTypeDeclared(name);\n  }",
    "comment": " Whether the given property is declared on this object. ",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "ObjectType.isImplicitPrototype",
    "class_name": "com.google.javascript.rhino.jstype.ObjectType",
    "signature": "com.google.javascript.rhino.jstype.ObjectType.isImplicitPrototype(ObjectType)",
    "snippet": "  final boolean isImplicitPrototype(ObjectType prototype) {\n    for (ObjectType current = this;\n         current != null;\n         current = current.getImplicitPrototype()) {\n      if (current.equals(prototype)) {\n        return true;\n      }\n    }\n    return false;\n  }",
    "comment": " Checks that the prototype is an implicit prototype of this object. Since each object has an implicit prototype, an implicit prototype's implicit prototype is also this implicit prototype's.  @param prototype any prototype based object  @return {@code true} if {@code prototype} is {@code equal} to any object in this object's implicit prototype chain. ",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "ObjectType.isUnknownType",
    "class_name": "com.google.javascript.rhino.jstype.ObjectType",
    "signature": "com.google.javascript.rhino.jstype.ObjectType.isUnknownType()",
    "snippet": "  @Override\n  public boolean isUnknownType() {\n    // If the object is unknown now, check the supertype again,\n    // because it might have been resolved since the last check.\n    if (unknown) {\n      ObjectType implicitProto = getImplicitPrototype();\n      if (implicitProto == null ||\n          implicitProto.isNativeObjectType()) {\n        unknown = false;\n      } else {\n        unknown = implicitProto.isUnknownType();\n      }\n    }\n    return unknown;\n  }",
    "comment": " We treat this as the unknown type if any of its implicit prototype properties is unknown. ",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "PrototypeObjectType.PrototypeObjectType",
    "class_name": "com.google.javascript.rhino.jstype.PrototypeObjectType",
    "signature": "com.google.javascript.rhino.jstype.PrototypeObjectType.PrototypeObjectType(JSTypeRegistry,String,ObjectType)",
    "snippet": "  PrototypeObjectType(JSTypeRegistry registry, String className,\n      ObjectType implicitPrototype) {\n    this(registry, className, implicitPrototype, false);\n  }",
    "comment": " Creates an object type.  @param className the name of the class.  May be {@code null} to denote an anonymous class.  @param implicitPrototype the implicit prototype (a.k.a. {@code [[Prototype]]}) as defined by ECMA-262. If the implicit prototype is {@code null} the implicit prototype will be set to the {@link JSTypeNative#OBJECT_TYPE}. ",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "PrototypeObjectType.PrototypeObjectType",
    "class_name": "com.google.javascript.rhino.jstype.PrototypeObjectType",
    "signature": "com.google.javascript.rhino.jstype.PrototypeObjectType.PrototypeObjectType(JSTypeRegistry,String,ObjectType,boolean)",
    "snippet": "  PrototypeObjectType(JSTypeRegistry registry, String className,\n      ObjectType implicitPrototype, boolean nativeType) {\n    super(registry);\n    this.properties = Maps.newHashMap();\n    this.className = className;\n    this.nativeType = nativeType;\n    if (nativeType) {\n      this.implicitPrototype = implicitPrototype;\n    } else if (implicitPrototype == null) {\n      this.implicitPrototype =\n          registry.getNativeObjectType(JSTypeNative.OBJECT_TYPE);\n    } else {\n      this.implicitPrototype = implicitPrototype;\n    }\n  }",
    "comment": " Creates an object type, allowing specification of the implicit prototype when creating native objects. ",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "PrototypeObjectType.defineProperty",
    "class_name": "com.google.javascript.rhino.jstype.PrototypeObjectType",
    "signature": "com.google.javascript.rhino.jstype.PrototypeObjectType.defineProperty(String,JSType,boolean,boolean)",
    "snippet": "  @Override\n  boolean defineProperty(String name, JSType type, boolean inferred,\n      boolean inExterns) {\n    if (hasOwnDeclaredProperty(name)) {\n      return false;\n    }\n    properties.put(name, new Property(type, inferred, inExterns));\n    return true;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "PrototypeObjectType.getConstructor",
    "class_name": "com.google.javascript.rhino.jstype.PrototypeObjectType",
    "signature": "com.google.javascript.rhino.jstype.PrototypeObjectType.getConstructor()",
    "snippet": "  @Override\n  public FunctionType getConstructor() {\n    return null;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "PrototypeObjectType.getImplicitPrototype",
    "class_name": "com.google.javascript.rhino.jstype.PrototypeObjectType",
    "signature": "com.google.javascript.rhino.jstype.PrototypeObjectType.getImplicitPrototype()",
    "snippet": "  @Override\n  public ObjectType getImplicitPrototype() {\n    return implicitPrototype;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "PrototypeObjectType.getReferenceName",
    "class_name": "com.google.javascript.rhino.jstype.PrototypeObjectType",
    "signature": "com.google.javascript.rhino.jstype.PrototypeObjectType.getReferenceName()",
    "snippet": "  @Override\n  public String getReferenceName() {\n    if (className != null) {\n      return className;\n    } else {\n      return \"{...}\";\n    }\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "PrototypeObjectType.hasCachedValues",
    "class_name": "com.google.javascript.rhino.jstype.PrototypeObjectType",
    "signature": "com.google.javascript.rhino.jstype.PrototypeObjectType.hasCachedValues()",
    "snippet": "  @Override\n  public boolean hasCachedValues() {\n    return super.hasCachedValues();\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "PrototypeObjectType.hasOwnProperty",
    "class_name": "com.google.javascript.rhino.jstype.PrototypeObjectType",
    "signature": "com.google.javascript.rhino.jstype.PrototypeObjectType.hasOwnProperty(String)",
    "snippet": "  @Override\n  public boolean hasOwnProperty(String propertyName) {\n    return properties.get(propertyName) != null;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "PrototypeObjectType.hasReferenceName",
    "class_name": "com.google.javascript.rhino.jstype.PrototypeObjectType",
    "signature": "com.google.javascript.rhino.jstype.PrototypeObjectType.hasReferenceName()",
    "snippet": "  @Override\n  public boolean hasReferenceName() {\n    return className != null;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "PrototypeObjectType.implicitPrototypeChainIsUnknown",
    "class_name": "com.google.javascript.rhino.jstype.PrototypeObjectType",
    "signature": "com.google.javascript.rhino.jstype.PrototypeObjectType.implicitPrototypeChainIsUnknown()",
    "snippet": "  private boolean implicitPrototypeChainIsUnknown() {\n    ObjectType p = getImplicitPrototype();\n    while (p != null) {\n      if (p.isUnknownType()) {\n        return true;\n      }\n      p = p.getImplicitPrototype();\n    }\n    return false;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "PrototypeObjectType.isNativeObjectType",
    "class_name": "com.google.javascript.rhino.jstype.PrototypeObjectType",
    "signature": "com.google.javascript.rhino.jstype.PrototypeObjectType.isNativeObjectType()",
    "snippet": "  @Override\n  public boolean isNativeObjectType() {\n    return nativeType;\n  }",
    "comment": "Whether this is a built-in object. */",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "PrototypeObjectType.isSubtype",
    "class_name": "com.google.javascript.rhino.jstype.PrototypeObjectType",
    "signature": "com.google.javascript.rhino.jstype.PrototypeObjectType.isSubtype(JSType)",
    "snippet": "  @Override\n  public boolean isSubtype(JSType that) {\n    if (JSType.isSubtype(this, that)) {\n      return true;\n    }\n\n    // Union types\n    if (that instanceof UnionType) {\n      // The static {@code JSType.isSubtype} check already decomposed\n      // union types, so we don't need to check those again.\n      return false;\n    }\n\n    // record types\n    if (that instanceof RecordType) {\n      return RecordType.isSubtype(this, (RecordType) that);\n    }\n\n    // Interfaces\n    // Find all the interfaces implemented by this class and compare each one\n    // to the interface instance.\n    ObjectType thatObj = that.toObjectType();\n    ObjectType thatCtor = thatObj == null ? null : thatObj.getConstructor();\n    if (thatCtor != null && thatCtor.isInterface()) {\n      Iterable<ObjectType> thisInterfaces = getCtorImplementedInterfaces();\n      for (ObjectType thisInterface : thisInterfaces) {\n        if (thisInterface.isSubtype(that)) {\n          return true;\n        }\n      }\n    }\n\n    // other prototype based objects\n    if (that != null) {\n      if (isUnknownType() || implicitPrototypeChainIsUnknown()) {\n        // If unsure, say 'yes', to avoid spurious warnings.\n        // TODO(user): resolve the prototype chain completely in all cases,\n        // to avoid guessing.\n        return true;\n      }\n      return this.isImplicitPrototype(thatObj);\n    }\n\n    return false;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "PrototypeObjectType.setImplicitPrototype",
    "class_name": "com.google.javascript.rhino.jstype.PrototypeObjectType",
    "signature": "com.google.javascript.rhino.jstype.PrototypeObjectType.setImplicitPrototype(ObjectType)",
    "snippet": "  void setImplicitPrototype(ObjectType implicitPrototype) {\n    checkState(!hasCachedValues());\n    this.implicitPrototype = implicitPrototype;\n  }",
    "comment": " This should only be reset on the FunctionPrototypeType, only to fix an incorrectly established prototype chain due to the user having a mismatch in super class declaration, and only before properties on that type are processed. ",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "ProxyObjectType.ProxyObjectType",
    "class_name": "com.google.javascript.rhino.jstype.ProxyObjectType",
    "signature": "com.google.javascript.rhino.jstype.ProxyObjectType.ProxyObjectType(JSTypeRegistry,ObjectType)",
    "snippet": "  ProxyObjectType(JSTypeRegistry registry, ObjectType referencedType) {\n    super(registry);\n    this.referencedType = referencedType;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "SimpleSlot.SimpleSlot",
    "class_name": "com.google.javascript.rhino.jstype.SimpleSlot",
    "signature": "com.google.javascript.rhino.jstype.SimpleSlot.SimpleSlot(String,JSType,boolean)",
    "snippet": "  public SimpleSlot(String name, JSType type, boolean inferred) {\n    this.name = name;\n    this.type = type;\n    this.inferred = inferred;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "StringType.StringType",
    "class_name": "com.google.javascript.rhino.jstype.StringType",
    "signature": "com.google.javascript.rhino.jstype.StringType.StringType(JSTypeRegistry)",
    "snippet": "  StringType(JSTypeRegistry registry) {\n    super(registry);\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "StringType.toString",
    "class_name": "com.google.javascript.rhino.jstype.StringType",
    "signature": "com.google.javascript.rhino.jstype.StringType.toString()",
    "snippet": "  @Override\n  public String toString() {\n    return \"string\";\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "TemplateType.TemplateType",
    "class_name": "com.google.javascript.rhino.jstype.TemplateType",
    "signature": "com.google.javascript.rhino.jstype.TemplateType.TemplateType(JSTypeRegistry,String)",
    "snippet": "  TemplateType(JSTypeRegistry registry, String name) {\n    super(registry, registry.getNativeObjectType(JSTypeNative.UNKNOWN_TYPE));\n    this.name = name;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "UnionType.UnionType",
    "class_name": "com.google.javascript.rhino.jstype.UnionType",
    "signature": "com.google.javascript.rhino.jstype.UnionType.UnionType(JSTypeRegistry,Set)",
    "snippet": "  UnionType(JSTypeRegistry registry, Set<JSType> alternates) {\n    super(registry);\n    this.alternates = alternates;\n  }",
    "comment": " Creates a union type.  @param alternates the alternates of the union ",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "UnionTypeBuilder.UnionTypeBuilder",
    "class_name": "com.google.javascript.rhino.jstype.UnionTypeBuilder",
    "signature": "com.google.javascript.rhino.jstype.UnionTypeBuilder.UnionTypeBuilder(JSTypeRegistry)",
    "snippet": "  UnionTypeBuilder(JSTypeRegistry registry) {\n    this.registry = registry;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "UnionTypeBuilder.addAlternate",
    "class_name": "com.google.javascript.rhino.jstype.UnionTypeBuilder",
    "signature": "com.google.javascript.rhino.jstype.UnionTypeBuilder.addAlternate(JSType)",
    "snippet": "  UnionTypeBuilder addAlternate(JSType alternate) {\n    // build() returns the bottom type by default, so we can\n    // just bail out early here.\n    if (alternate.isNoType()) {\n      return this;\n    }\n\n    isAllType = isAllType || alternate.isAllType();\n\n    boolean isAlternateUnknown = alternate instanceof UnknownType;\n    isNativeUnknownType = isNativeUnknownType || isAlternateUnknown;\n    if (isAlternateUnknown) {\n      areAllUnknownsChecked = areAllUnknownsChecked &&\n          alternate.isCheckedUnknownType();\n    }\n    if (!isAllType && !isNativeUnknownType) {\n      if (alternate instanceof UnionType) {\n        UnionType union = (UnionType) alternate;\n        for (JSType unionAlt : union.getAlternates()) {\n          addAlternate(unionAlt);\n        }\n      } else {\n        if (!alternate.isUnknownType()) {\n          Iterator<JSType> it = alternates.iterator();\n          while (it.hasNext()) {\n            JSType current = it.next();\n            if (!current.isUnknownType()) {\n              if (alternate.isSubtype(current)) {\n                // Alternate is unnecessary.\n                return this;\n              } else if (current.isSubtype(alternate)) {\n                // Alternate makes current obsolete\n                it.remove();\n              }\n            }\n          }\n        }\n        alternates.add(alternate);\n        result = null; // invalidate the memoized result\n      }\n    } else {\n      result = null;\n    }\n    return this;\n  }",
    "comment": " Adds an alternate to the union type under construction. Returns this for easy chaining. ",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "UnionTypeBuilder.build",
    "class_name": "com.google.javascript.rhino.jstype.UnionTypeBuilder",
    "signature": "com.google.javascript.rhino.jstype.UnionTypeBuilder.build()",
    "snippet": "  JSType build() {\n    if (result == null) {\n      if (isAllType) {\n        result = registry.getNativeType(ALL_TYPE);\n      } else if (isNativeUnknownType) {\n        if (areAllUnknownsChecked) {\n          result = registry.getNativeType(CHECKED_UNKNOWN_TYPE);\n        } else {\n          result = registry.getNativeType(UNKNOWN_TYPE);\n        }\n      } else {\n        Set<JSType> alternateSet = Sets.newUnmodifiableHashSet(alternates);\n        int size = alternateSet.size();\n        if (size > MAX_UNION_SIZE) {\n          result = registry.getNativeType(UNKNOWN_TYPE);\n        } else {\n          if (size > 1) {\n            result = new UnionType(registry, alternateSet);\n          } else if (size == 1) {\n            result = alternates.iterator().next();\n          } else {\n            result = registry.getNativeType(NO_TYPE);\n          }\n        }\n      }\n    }\n    return result;\n  }",
    "comment": " Creates a union. @return A UnionType if it has two or more alternates, the only alternate if it has one and otherwise {@code NO_TYPE}. ",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "UnknownType.UnknownType",
    "class_name": "com.google.javascript.rhino.jstype.UnknownType",
    "signature": "com.google.javascript.rhino.jstype.UnknownType.UnknownType(JSTypeRegistry,boolean)",
    "snippet": "  UnknownType(JSTypeRegistry registry, boolean isChecked) {\n    super(registry);\n    this.isChecked = isChecked;\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "ValueType.ValueType",
    "class_name": "com.google.javascript.rhino.jstype.ValueType",
    "signature": "com.google.javascript.rhino.jstype.ValueType.ValueType(JSTypeRegistry)",
    "snippet": "  ValueType(JSTypeRegistry registry) {\n    super(registry);\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "ValueType.isSubtype",
    "class_name": "com.google.javascript.rhino.jstype.ValueType",
    "signature": "com.google.javascript.rhino.jstype.ValueType.isSubtype(JSType)",
    "snippet": "  @Override\n  public boolean isSubtype(JSType that) {\n    return JSType.isSubtype(this, that);\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "VoidType.VoidType",
    "class_name": "com.google.javascript.rhino.jstype.VoidType",
    "signature": "com.google.javascript.rhino.jstype.VoidType.VoidType(JSTypeRegistry)",
    "snippet": "  VoidType(JSTypeRegistry registry) {\n    super(registry);\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "VoidType.toString",
    "class_name": "com.google.javascript.rhino.jstype.VoidType",
    "signature": "com.google.javascript.rhino.jstype.VoidType.toString()",
    "snippet": "  @Override\n  public String toString() {\n    return \"undefined\";\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "BaseJSTypeTestCase.addMethod",
    "class_name": "com.google.javascript.rhino.testing.BaseJSTypeTestCase",
    "signature": "com.google.javascript.rhino.testing.BaseJSTypeTestCase.addMethod(JSTypeRegistry,ObjectType,String,JSType)",
    "snippet": "  private static void addMethod(\n      JSTypeRegistry registry, ObjectType receivingType, String methodName,\n      JSType returnType) {\n    receivingType.defineDeclaredProperty(methodName,\n        new FunctionType(registry, null, null, null, returnType), true);\n  }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  },
  {
    "name": "BaseJSTypeTestCase.addNativeProperties",
    "class_name": "com.google.javascript.rhino.testing.BaseJSTypeTestCase",
    "signature": "com.google.javascript.rhino.testing.BaseJSTypeTestCase.addNativeProperties(JSTypeRegistry)",
    "snippet": "  public static void addNativeProperties(JSTypeRegistry registry) {\n    JSType booleanType = registry.getNativeType(JSTypeNative.BOOLEAN_TYPE);\n    JSType numberType = registry.getNativeType(JSTypeNative.NUMBER_TYPE);\n    JSType stringType = registry.getNativeType(JSTypeNative.STRING_TYPE);\n    JSType unknownType = registry.getNativeType(JSTypeNative.UNKNOWN_TYPE);\n\n    ObjectType objectType =\n        registry.getNativeObjectType(JSTypeNative.OBJECT_TYPE);\n    ObjectType arrayType =\n        registry.getNativeObjectType(JSTypeNative.ARRAY_TYPE);\n    ObjectType dateType =\n        registry.getNativeObjectType(JSTypeNative.DATE_TYPE);\n    ObjectType regexpType =\n        registry.getNativeObjectType(JSTypeNative.REGEXP_TYPE);\n    ObjectType booleanObjectType =\n        registry.getNativeObjectType(JSTypeNative.BOOLEAN_OBJECT_TYPE);\n    ObjectType numberObjectType =\n        registry.getNativeObjectType(JSTypeNative.NUMBER_OBJECT_TYPE);\n    ObjectType stringObjectType =\n        registry.getNativeObjectType(JSTypeNative.STRING_OBJECT_TYPE);\n\n    ObjectType objectPrototype = registry\n        .getNativeFunctionType(JSTypeNative.OBJECT_FUNCTION_TYPE)\n        .getPrototype();\n    addMethod(registry, objectPrototype, \"constructor\", objectType);\n    addMethod(registry, objectPrototype, \"toString\", stringType);\n    addMethod(registry, objectPrototype, \"toLocaleString\", stringType);\n    addMethod(registry, objectPrototype, \"valueOf\", unknownType);\n    addMethod(registry, objectPrototype, \"hasOwnProperty\", booleanType);\n    addMethod(registry, objectPrototype, \"isPrototypeOf\", booleanType);\n    addMethod(registry, objectPrototype, \"propertyIsEnumerable\", booleanType);\n\n    ObjectType arrayPrototype = registry\n        .getNativeFunctionType(JSTypeNative.ARRAY_FUNCTION_TYPE)\n        .getPrototype();\n    addMethod(registry, arrayPrototype, \"constructor\", arrayType);\n    addMethod(registry, arrayPrototype, \"toString\", stringType);\n    addMethod(registry, arrayPrototype, \"toLocaleString\", stringType);\n    addMethod(registry, arrayPrototype, \"concat\", arrayType);\n    addMethod(registry, arrayPrototype, \"join\", stringType);\n    addMethod(registry, arrayPrototype, \"pop\", unknownType);\n    addMethod(registry, arrayPrototype, \"push\", numberType);\n    addMethod(registry, arrayPrototype, \"reverse\", arrayType);\n    addMethod(registry, arrayPrototype, \"shift\", unknownType);\n    addMethod(registry, arrayPrototype, \"slice\", arrayType);\n    addMethod(registry, arrayPrototype, \"sort\", arrayType);\n    addMethod(registry, arrayPrototype, \"splice\", arrayType);\n    addMethod(registry, arrayPrototype, \"unshift\", numberType);\n    arrayType.defineDeclaredProperty(\"length\", numberType, true);\n\n    ObjectType booleanPrototype = registry\n        .getNativeFunctionType(JSTypeNative.BOOLEAN_OBJECT_FUNCTION_TYPE)\n        .getPrototype();\n    addMethod(registry, booleanPrototype, \"constructor\", booleanObjectType);\n    addMethod(registry, booleanPrototype, \"toString\", stringType);\n    addMethod(registry, booleanPrototype, \"valueOf\", booleanType);\n\n    ObjectType datePrototype = registry\n        .getNativeFunctionType(JSTypeNative.DATE_FUNCTION_TYPE)\n        .getPrototype();\n    addMethod(registry, datePrototype, \"constructor\", dateType);\n    addMethod(registry, datePrototype, \"toString\", stringType);\n    addMethod(registry, datePrototype, \"toDateString\", stringType);\n    addMethod(registry, datePrototype, \"toTimeString\", stringType);\n    addMethod(registry, datePrototype, \"toLocaleString\", stringType);\n    addMethod(registry, datePrototype, \"toLocaleDateString\", stringType);\n    addMethod(registry, datePrototype, \"toLocaleTimeString\", stringType);\n    addMethod(registry, datePrototype, \"valueOf\", numberType);\n    addMethod(registry, datePrototype, \"getTime\", numberType);\n    addMethod(registry, datePrototype, \"getFullYear\", numberType);\n    addMethod(registry, datePrototype, \"getUTCFullYear\", numberType);\n    addMethod(registry, datePrototype, \"getMonth\", numberType);\n    addMethod(registry, datePrototype, \"getUTCMonth\", numberType);\n    addMethod(registry, datePrototype, \"getDate\", numberType);\n    addMethod(registry, datePrototype, \"getUTCDate\", numberType);\n    addMethod(registry, datePrototype, \"getDay\", numberType);\n    addMethod(registry, datePrototype, \"getUTCDay\", numberType);\n    addMethod(registry, datePrototype, \"getHours\", numberType);\n    addMethod(registry, datePrototype, \"getUTCHours\", numberType);\n    addMethod(registry, datePrototype, \"getMinutes\", numberType);\n    addMethod(registry, datePrototype, \"getUTCMinutes\", numberType);\n    addMethod(registry, datePrototype, \"getSeconds\", numberType);\n    addMethod(registry, datePrototype, \"getUTCSeconds\", numberType);\n    addMethod(registry, datePrototype, \"getMilliseconds\", numberType);\n    addMethod(registry, datePrototype, \"getUTCMilliseconds\", numberType);\n    addMethod(registry, datePrototype, \"getTimezoneOffset\", numberType);\n    addMethod(registry, datePrototype, \"setTime\", numberType);\n    addMethod(registry, datePrototype, \"setMilliseconds\", numberType);\n    addMethod(registry, datePrototype, \"setUTCMilliseconds\", numberType);\n    addMethod(registry, datePrototype, \"setSeconds\", numberType);\n    addMethod(registry, datePrototype, \"setUTCSeconds\", numberType);\n    addMethod(registry, datePrototype, \"setMinutes\", numberType);\n    addMethod(registry, datePrototype, \"setUTCMinutes\", numberType);\n    addMethod(registry, datePrototype, \"setHours\", numberType);\n    addMethod(registry, datePrototype, \"setUTCHours\", numberType);\n    addMethod(registry, datePrototype, \"setDate\", numberType);\n    addMethod(registry, datePrototype, \"setUTCDate\", numberType);\n    addMethod(registry, datePrototype, \"setMonth\", numberType);\n    addMethod(registry, datePrototype, \"setUTCMonth\", numberType);\n    addMethod(registry, datePrototype, \"setFullYear\", numberType);\n    addMethod(registry, datePrototype, \"setUTCFullYear\", numberType);\n    addMethod(registry, datePrototype, \"toUTCString\", stringType);\n    addMethod(registry, datePrototype, \"toGMTString\", stringType);\n\n    ObjectType numberPrototype = registry\n        .getNativeFunctionType(JSTypeNative.NUMBER_OBJECT_FUNCTION_TYPE)\n        .getPrototype();\n    addMethod(registry, numberPrototype, \"constructor\", numberObjectType);\n    addMethod(registry, numberPrototype, \"toString\", stringType);\n    addMethod(registry, numberPrototype, \"toLocaleString\", stringType);\n    addMethod(registry, numberPrototype, \"valueOf\", numberType);\n    addMethod(registry, numberPrototype, \"toFixed\", stringType);\n    addMethod(registry, numberPrototype, \"toExponential\", stringType);\n    addMethod(registry, numberPrototype, \"toPrecision\", stringType);\n\n    ObjectType regexpPrototype = registry\n        .getNativeFunctionType(JSTypeNative.REGEXP_FUNCTION_TYPE)\n        .getPrototype();\n    addMethod(registry, regexpPrototype, \"constructor\", regexpType);\n    addMethod(registry, regexpPrototype, \"exec\",\n        registry.createNullableType(arrayType));\n    addMethod(registry, regexpPrototype, \"test\", booleanType);\n    addMethod(registry, regexpPrototype, \"toString\", stringType);\n    regexpType.defineDeclaredProperty(\"source\", stringType, true);\n    regexpType.defineDeclaredProperty(\"global\", booleanType, true);\n    regexpType.defineDeclaredProperty(\"ignoreCase\", booleanType, true);\n    regexpType.defineDeclaredProperty(\"multiline\", booleanType, true);\n    regexpType.defineDeclaredProperty(\"lastIndex\", numberType, true);\n\n    ObjectType stringPrototype = registry\n        .getNativeFunctionType(JSTypeNative.STRING_OBJECT_FUNCTION_TYPE)\n        .getPrototype();\n    addMethod(registry, stringPrototype, \"constructor\", stringObjectType);\n    addMethod(registry, stringPrototype, \"toString\", stringType);\n    addMethod(registry, stringPrototype, \"valueOf\", stringType);\n    addMethod(registry, stringPrototype, \"charAt\", stringType);\n    addMethod(registry, stringPrototype, \"charCodeAt\", numberType);\n    addMethod(registry, stringPrototype, \"concat\", stringType);\n    addMethod(registry, stringPrototype, \"indexOf\", numberType);\n    addMethod(registry, stringPrototype, \"lastIndexOf\", numberType);\n    addMethod(registry, stringPrototype, \"localeCompare\", numberType);\n    addMethod(registry, stringPrototype, \"match\",\n        registry.createNullableType(arrayType));\n    addMethod(registry, stringPrototype, \"replace\", stringType);\n    addMethod(registry, stringPrototype, \"search\", numberType);\n    addMethod(registry, stringPrototype, \"slice\", stringType);\n    addMethod(registry, stringPrototype, \"split\", arrayType);\n    addMethod(registry, stringPrototype, \"substring\", stringType);\n    addMethod(registry, stringPrototype, \"toLowerCase\", stringType);\n    addMethod(registry, stringPrototype, \"toLocaleLowerCase\", stringType);\n    addMethod(registry, stringPrototype, \"toUpperCase\", stringType);\n    addMethod(registry, stringPrototype, \"toLocaleUpperCase\", stringType);\n    stringObjectType.defineDeclaredProperty(\"length\", numberType, true);\n  }",
    "comment": "Adds a basic set of properties to the native types. */",
    "is_bug": false,
    "failing_test_cases": 3,
    "buggy_methods": 2
  }
]