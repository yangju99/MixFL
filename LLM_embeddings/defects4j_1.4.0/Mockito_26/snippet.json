[
  {
    "name": "Answers.get",
    "class_name": "org.mockito.Answers",
    "signature": "org.mockito.Answers.get()",
    "snippet": "    public Answer<Object> get() {\n        return implementation;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 0
  },
  {
    "name": "Mockito.mock",
    "class_name": "org.mockito.Mockito",
    "signature": "org.mockito.Mockito.mock(Class)",
    "snippet": "    public static <T> T mock(Class<T> classToMock) {\n        return mock(classToMock, withSettings().defaultAnswer(RETURNS_DEFAULTS));\n    }",
    "comment": " Creates mock object of given class or interface. <p> See examples in javadoc for {@link Mockito} class  @param classToMock class or interface to mock @return mock object ",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 0
  },
  {
    "name": "Mockito.mock",
    "class_name": "org.mockito.Mockito",
    "signature": "org.mockito.Mockito.mock(Class,MockSettings)",
    "snippet": "    public static <T> T mock(Class<T> classToMock, MockSettings mockSettings) {\n        return MOCKITO_CORE.mock(classToMock, mockSettings);\n    }",
    "comment": " Creates a mock with some non-standard settings. <p> The number of configuration points for a mock grows  so we need a fluent way to introduce new configuration without adding more and more overloaded Mockito.mock() methods.  Hence {@link MockSettings}. <pre class=\"code\"><code class=\"java\"> Listener mock = mock(Listener.class, withSettings() .name(\"firstListner\").defaultBehavior(RETURNS_SMART_NULLS)); );   </code></pre> <b>Use it carefully and occasionally</b>. What might be reason your test needs non-standard mocks?  Is the code under test so complicated that it requires non-standard mocks?  Wouldn't you prefer to refactor the code under test so it is testable in a simple way? <p> See also {@link Mockito#withSettings()} <p> See examples in javadoc for {@link Mockito} class  @param classToMock class or interface to mock @param mockSettings additional mock settings @return mock object ",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 0
  },
  {
    "name": "Mockito.withSettings",
    "class_name": "org.mockito.Mockito",
    "signature": "org.mockito.Mockito.withSettings()",
    "snippet": "    public static MockSettings withSettings() {\n        return new MockSettingsImpl().defaultAnswer(RETURNS_DEFAULTS);\n    }",
    "comment": " Allows mock creation with additional mock settings.  <p> Don't use it too often.  Consider writing simple tests that use simple mocks.  Repeat after me: simple tests push simple, KISSy, readable & maintainable code. If you cannot write a test in a simple way - refactor the code under test. <p> Examples of mock settings: <pre class=\"code\"><code class=\"java\"> Creates mock with different default answer & name Foo mock = mock(Foo.class, withSettings() .defaultAnswer(RETURNS_SMART_NULLS) .name(\"cool mockie\"));  Creates mock with different default answer, descriptive name and extra interfaces Foo mock = mock(Foo.class, withSettings() .defaultAnswer(RETURNS_SMART_NULLS) .name(\"cool mockie\") .extraInterfaces(Bar.class));     </code></pre> {@link MockSettings} has been introduced for two reasons.  Firstly, to make it easy to add another mock settings when the demand comes. Secondly, to enable combining different mock settings without introducing zillions of overloaded mock() methods. <p> See javadoc for {@link MockSettings} to learn about possible mock settings. <p>  @return mock settings instance with defaults. ",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 0
  },
  {
    "name": "MockitoAnnotations.initMocks",
    "class_name": "org.mockito.MockitoAnnotations",
    "signature": "org.mockito.MockitoAnnotations.initMocks(Object)",
    "snippet": "    public static void initMocks(Object testClass) {\n        if (testClass == null) {\n            throw new MockitoException(\"testClass cannot be null. For info how to use @Mock annotations see examples in javadoc for MockitoAnnotations class\");\n        }\n\n        AnnotationEngine annotationEngine = new GlobalConfiguration().getAnnotationEngine();\n        Class<?> clazz = testClass.getClass();\n\n        //below can be removed later, when we get read rid of deprecated stuff\n        if (annotationEngine.getClass() != new DefaultMockitoConfiguration().getAnnotationEngine().getClass()) {\n            //this means user has his own annotation engine and we have to respect that.\n            //we will do annotation processing the old way so that we are backwards compatible\n            while (clazz != Object.class) {\n                scanDeprecatedWay(annotationEngine, testClass, clazz);\n                clazz = clazz.getSuperclass();\n            }\n        }\n\n        //anyway act 'the new' way\n        annotationEngine.process(testClass.getClass(), testClass);\n    }",
    "comment": " Initializes objects annotated with Mockito annotations for given testClass: &#064;{@link org.mockito.Mock}, &#064;{@link Spy}, &#064;{@link Captor}, &#064;{@link InjectMocks}  <p> See examples in javadoc for {@link MockitoAnnotations} class. ",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 0
  },
  {
    "name": "MockitoAnnotations.processAnnotationDeprecatedWay",
    "class_name": "org.mockito.MockitoAnnotations",
    "signature": "org.mockito.MockitoAnnotations.processAnnotationDeprecatedWay(AnnotationEngine,Object,Field)",
    "snippet": "    @SuppressWarnings(\"deprecation\")\n    static void processAnnotationDeprecatedWay(AnnotationEngine annotationEngine, Object testClass, Field field) {\n        boolean alreadyAssigned = false;\n        for(Annotation annotation : field.getAnnotations()) {\n            Object mock = annotationEngine.createMockFor(annotation, field);\n            if (mock != null) {\n                throwIfAlreadyAssigned(field, alreadyAssigned);\n                alreadyAssigned = true;                \n                try {\n                    new FieldSetter(testClass, field).set(mock);\n                } catch (Exception e) {\n                    throw new MockitoException(\"Problems setting field \" + field.getName() + \" annotated with \"\n                            + annotation, e);\n                }\n            }\n        }\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 0
  },
  {
    "name": "MockitoAnnotations.scanDeprecatedWay",
    "class_name": "org.mockito.MockitoAnnotations",
    "signature": "org.mockito.MockitoAnnotations.scanDeprecatedWay(AnnotationEngine,Object,Class)",
    "snippet": "    static void scanDeprecatedWay(AnnotationEngine annotationEngine, Object testClass, Class<?> clazz) {\n        Field[] fields = clazz.getDeclaredFields();\n\n        for (Field field : fields) {\n            processAnnotationDeprecatedWay(annotationEngine, testClass, field);\n        }\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 0
  },
  {
    "name": "DefaultMockitoConfiguration.getAnnotationEngine",
    "class_name": "org.mockito.configuration.DefaultMockitoConfiguration",
    "signature": "org.mockito.configuration.DefaultMockitoConfiguration.getAnnotationEngine()",
    "snippet": "    public AnnotationEngine getAnnotationEngine() {\n        return new InjectingAnnotationEngine();\n    }",
    "comment": "(non-Javadoc) @see org.mockito.IMockitoConfiguration#getAnnotationEngine() ",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 0
  },
  {
    "name": "MockitoCore.mock",
    "class_name": "org.mockito.internal.MockitoCore",
    "signature": "org.mockito.internal.MockitoCore.mock(Class,MockSettings)",
    "snippet": "    public <T> T mock(Class<T> typeToMock, MockSettings settings) {\n        if (!MockSettingsImpl.class.isInstance(settings)) {\n            throw new IllegalArgumentException(\n                    \"Unexpected implementation of '\" + settings.getClass().getCanonicalName() + \"'\\n\"\n                    + \"At the moment, you cannot provide your own implementations that class.\");\n        }\n        MockSettingsImpl impl = MockSettingsImpl.class.cast(settings);\n        MockCreationSettings<T> creationSettings = impl.confirm(typeToMock);\n        T mock = mockUtil.createMock(creationSettings);\n        mockingProgress.mockingStarted(mock, typeToMock);\n        return mock;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 0
  },
  {
    "name": "ClassPathLoader.findPlatformMockMaker",
    "class_name": "org.mockito.internal.configuration.ClassPathLoader",
    "signature": "org.mockito.internal.configuration.ClassPathLoader.findPlatformMockMaker()",
    "snippet": "    static MockMaker findPlatformMockMaker() {\n        for (MockMaker mockMaker : loadImplementations(MockMaker.class)) {\n            return mockMaker; // return the first one service loader finds (if any)\n        }\n        return new CglibMockMaker(); // default implementation\n    }",
    "comment": " Scans the classpath to find a mock maker plugin if one is available, allowing mockito to run on alternative platforms like Android. ",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 0
  },
  {
    "name": "ClassPathLoader.getMockMaker",
    "class_name": "org.mockito.internal.configuration.ClassPathLoader",
    "signature": "org.mockito.internal.configuration.ClassPathLoader.getMockMaker()",
    "snippet": "    public static MockMaker getMockMaker() {\n        return mockMaker;\n    }",
    "comment": " Returns the implementation of the mock maker available for the current runtime.  <p>Returns {@link CglibMockMaker} if no {@link MockMaker} extension exists or is visible in the current classpath.</p> ",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 0
  },
  {
    "name": "ClassPathLoader.loadConfiguration",
    "class_name": "org.mockito.internal.configuration.ClassPathLoader",
    "signature": "org.mockito.internal.configuration.ClassPathLoader.loadConfiguration()",
    "snippet": "    @SuppressWarnings({\"unchecked\"})\n    public IMockitoConfiguration loadConfiguration() {\n        //Trying to get config from classpath\n        Class configClass;\n        try {\n            configClass = (Class) Class.forName(MOCKITO_CONFIGURATION_CLASS_NAME);\n        } catch (ClassNotFoundException e) {\n            //that's ok, it means there is no global config, using default one.\n            return null;\n        }\n\n        try {\n            return (IMockitoConfiguration) configClass.newInstance();\n        } catch (ClassCastException e) {\n            throw new MockitoConfigurationException(\"MockitoConfiguration class must implement \" + IMockitoConfiguration.class.getName() + \" interface.\", e);\n        } catch (Exception e) {\n            throw new MockitoConfigurationException(\"Unable to instantiate \" + MOCKITO_CONFIGURATION_CLASS_NAME +\" class. Does it have a safe, no-arg constructor?\", e);\n        }\n    }",
    "comment": " @return configuration loaded from classpath or null ",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 0
  },
  {
    "name": "ClassPathLoader.loadImplementations",
    "class_name": "org.mockito.internal.configuration.ClassPathLoader",
    "signature": "org.mockito.internal.configuration.ClassPathLoader.loadImplementations(Class)",
    "snippet": "    static <T> List<T> loadImplementations(Class<T> service) {\n        ClassLoader loader = Thread.currentThread().getContextClassLoader();\n        if (loader == null) {\n            loader = ClassLoader.getSystemClassLoader();\n        }\n\n        Enumeration<URL> resources;\n        try {\n            resources = loader.getResources(\"mockito-extensions/\" + service.getName());\n        } catch (IOException e) {\n            throw new MockitoException(\"Failed to load \" + service, e);\n        }\n\n        List<T> result = new ArrayList<T>();\n        for (URL resource : Collections.list(resources)) {\n            InputStream in = null;\n            try {\n                in = resource.openStream();\n                for (String line : readerToLines(new InputStreamReader(in, \"UTF-8\"))) {\n                    String name = stripCommentAndWhitespace(line);\n                    if (name.length() != 0) {\n                        result.add(service.cast(loader.loadClass(name).newInstance()));\n                    }\n                }\n            } catch (Exception e) {\n                throw new MockitoConfigurationException(\n                        \"Failed to load \" + service + \" using \" + resource, e);\n            } finally {\n                closeQuietly(in);\n            }\n        }\n        return result;\n    }",
    "comment": " Equivalent to {@link java.util.ServiceLoader#load} but without requiring Java 6 / Android 2.3 (Gingerbread). ",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 0
  },
  {
    "name": "DefaultAnnotationEngine.DefaultAnnotationEngine",
    "class_name": "org.mockito.internal.configuration.DefaultAnnotationEngine",
    "signature": "org.mockito.internal.configuration.DefaultAnnotationEngine.DefaultAnnotationEngine()",
    "snippet": "    public DefaultAnnotationEngine() {\n        registerAnnotationProcessor(Mock.class, new MockAnnotationProcessor());\n        registerAnnotationProcessor(MockitoAnnotations.Mock.class, new MockitoAnnotationsMockAnnotationProcessor());\n        registerAnnotationProcessor(Captor.class, new CaptorAnnotationProcessor());\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 0
  },
  {
    "name": "DefaultAnnotationEngine.process",
    "class_name": "org.mockito.internal.configuration.DefaultAnnotationEngine",
    "signature": "org.mockito.internal.configuration.DefaultAnnotationEngine.process(Class,Object)",
    "snippet": "    public void process(Class<?> clazz, Object testInstance) {\n        Field[] fields = clazz.getDeclaredFields();\n        for (Field field : fields) {\n            boolean alreadyAssigned = false;\n            for(Annotation annotation : field.getAnnotations()) {           \n                Object mock = createMockFor(annotation, field);\n                if (mock != null) {\n                    throwIfAlreadyAssigned(field, alreadyAssigned);                    \n                    alreadyAssigned = true;                    \n                    try {\n                        new FieldSetter(testInstance, field).set(mock);\n                    } catch (Exception e) {\n                        throw new MockitoException(\"Problems setting field \" + field.getName() + \" annotated with \"\n                                + annotation, e);\n                    }\n                }        \n            }\n        }\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 0
  },
  {
    "name": "DefaultAnnotationEngine.registerAnnotationProcessor",
    "class_name": "org.mockito.internal.configuration.DefaultAnnotationEngine",
    "signature": "org.mockito.internal.configuration.DefaultAnnotationEngine.registerAnnotationProcessor(Class,FieldAnnotationProcessor)",
    "snippet": "    private <A extends Annotation> void registerAnnotationProcessor(Class<A> annotationClass, FieldAnnotationProcessor<A> fieldAnnotationProcessor) {\n        annotationProcessorMap.put(annotationClass, fieldAnnotationProcessor);\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 0
  },
  {
    "name": "DefaultInjectionEngine.injectMocksOnFields",
    "class_name": "org.mockito.internal.configuration.DefaultInjectionEngine",
    "signature": "org.mockito.internal.configuration.DefaultInjectionEngine.injectMocksOnFields(Set,Set,Object)",
    "snippet": "    public void injectMocksOnFields(Set<Field> needingInjection, Set<Object> mocks, Object testClassInstance) {\n        MockInjection.onFields(needingInjection, testClassInstance)\n                .withMocks(mocks)\n                .tryConstructorInjection()\n                .tryPropertyOrFieldInjection()\n                .handleSpyAnnotation()\n                .apply();\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 0
  },
  {
    "name": "GlobalConfiguration.GlobalConfiguration",
    "class_name": "org.mockito.internal.configuration.GlobalConfiguration",
    "signature": "org.mockito.internal.configuration.GlobalConfiguration.GlobalConfiguration()",
    "snippet": "    public GlobalConfiguration() {\n        //Configuration should be loaded only once but I cannot really test it\n        if (globalConfiguration.get() == null) {\n            globalConfiguration.set(createConfig());\n        }\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 0
  },
  {
    "name": "GlobalConfiguration.createConfig",
    "class_name": "org.mockito.internal.configuration.GlobalConfiguration",
    "signature": "org.mockito.internal.configuration.GlobalConfiguration.createConfig()",
    "snippet": "    private IMockitoConfiguration createConfig() {\n        IMockitoConfiguration defaultConfiguration = new DefaultMockitoConfiguration();\n        IMockitoConfiguration config = new ClassPathLoader().loadConfiguration();\n        if (config != null) {\n            return config;\n        } else {\n            return defaultConfiguration;\n        }\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 0
  },
  {
    "name": "GlobalConfiguration.getAnnotationEngine",
    "class_name": "org.mockito.internal.configuration.GlobalConfiguration",
    "signature": "org.mockito.internal.configuration.GlobalConfiguration.getAnnotationEngine()",
    "snippet": "    public AnnotationEngine getAnnotationEngine() {\n        return globalConfiguration.get().getAnnotationEngine();\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 0
  },
  {
    "name": "GlobalConfiguration.getIt",
    "class_name": "org.mockito.internal.configuration.GlobalConfiguration",
    "signature": "org.mockito.internal.configuration.GlobalConfiguration.getIt()",
    "snippet": "    IMockitoConfiguration getIt() {\n        return globalConfiguration.get();\n    }",
    "comment": "back door for testing",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 0
  },
  {
    "name": "GlobalConfiguration.validate",
    "class_name": "org.mockito.internal.configuration.GlobalConfiguration",
    "signature": "org.mockito.internal.configuration.GlobalConfiguration.validate()",
    "snippet": "    public static void validate() {\n        new GlobalConfiguration();\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 0
  },
  {
    "name": "InjectingAnnotationEngine.injectMocks",
    "class_name": "org.mockito.internal.configuration.InjectingAnnotationEngine",
    "signature": "org.mockito.internal.configuration.InjectingAnnotationEngine.injectMocks(Object)",
    "snippet": "    public void injectMocks(final Object testClassInstance) {\n        Class<?> clazz = testClassInstance.getClass();\n        Set<Field> mockDependentFields = new HashSet<Field>();\n        Set<Object> mocks = newMockSafeHashSet();\n        \n        while (clazz != Object.class) {\n            new InjectMocksScanner(clazz).addTo(mockDependentFields);\n            new MockScanner(testClassInstance, clazz).addPreparedMocks(mocks);\n            clazz = clazz.getSuperclass();\n        }\n        \n        new DefaultInjectionEngine().injectMocksOnFields(mockDependentFields, mocks, testClassInstance);\n    }",
    "comment": " Initializes mock/spies dependencies for objects annotated with &#064;InjectMocks for given testClassInstance. <p> See examples in javadoc for {@link MockitoAnnotations} class.  @param testClassInstance Test class, usually <code>this</code> ",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 0
  },
  {
    "name": "InjectingAnnotationEngine.process",
    "class_name": "org.mockito.internal.configuration.InjectingAnnotationEngine",
    "signature": "org.mockito.internal.configuration.InjectingAnnotationEngine.process(Class,Object)",
    "snippet": "    public void process(Class<?> clazz, Object testInstance) {\n        processIndependentAnnotations(testInstance.getClass(), testInstance);\n        processInjectMocks(testInstance.getClass(), testInstance);\n    }",
    "comment": " Process the fields of the test instance and create Mocks, Spies, Captors and inject them on fields annotated &#64;InjectMocks.  <p> This code process the test class and the super classes. <ol> <li>First create Mocks, Spies, Captors.</li> <li>Then try to inject them.</li> </ol>  @param clazz Not used @param testInstance The instance of the test, should not be null.  @see org.mockito.configuration.AnnotationEngine#process(Class, Object) ",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 0
  },
  {
    "name": "InjectingAnnotationEngine.processIndependentAnnotations",
    "class_name": "org.mockito.internal.configuration.InjectingAnnotationEngine",
    "signature": "org.mockito.internal.configuration.InjectingAnnotationEngine.processIndependentAnnotations(Class,Object)",
    "snippet": "    private void processIndependentAnnotations(final Class<?> clazz, final Object testInstance) {\n        Class<?> classContext = clazz;\n        while (classContext != Object.class) {\n            //this will create @Mocks, @Captors, etc:\n            delegate.process(classContext, testInstance);\n            //this will create @Spies:\n            spyAnnotationEngine.process(classContext, testInstance);\n\n            classContext = classContext.getSuperclass();\n        }\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 0
  },
  {
    "name": "InjectingAnnotationEngine.processInjectMocks",
    "class_name": "org.mockito.internal.configuration.InjectingAnnotationEngine",
    "signature": "org.mockito.internal.configuration.InjectingAnnotationEngine.processInjectMocks(Class,Object)",
    "snippet": "    private void processInjectMocks(final Class<?> clazz, final Object testInstance) {\n        Class<?> classContext = clazz;\n        while (classContext != Object.class) {\n            injectMocks(testInstance);\n            classContext = classContext.getSuperclass();\n        }\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 0
  },
  {
    "name": "SpyAnnotationEngine.process",
    "class_name": "org.mockito.internal.configuration.SpyAnnotationEngine",
    "signature": "org.mockito.internal.configuration.SpyAnnotationEngine.process(Class,Object)",
    "snippet": "    @SuppressWarnings(\"deprecation\") // for MockitoAnnotations.Mock\n    public void process(Class<?> context, Object testInstance) {\n        Field[] fields = context.getDeclaredFields();\n        for (Field field : fields) {\n            if (field.isAnnotationPresent(Spy.class) && !field.isAnnotationPresent(InjectMocks.class)) {\n                assertNoIncompatibleAnnotations(Spy.class, field, Mock.class, org.mockito.MockitoAnnotations.Mock.class, Captor.class);\n                Object instance = null;\n                try {\n                    FieldInitializationReport report = new FieldInitializer(testInstance, field).initialize();\n                    instance = report.fieldInstance();\n                } catch (MockitoException e) {\n                    new Reporter().cannotInitializeForSpyAnnotation(field.getName(), e);\n                }\n                try {\n                    if (new MockUtil().isMock(instance)) {\n                        // instance has been spied earlier\n                        // for example happens when MockitoAnnotations.initMocks is called two times.\n                        Mockito.reset(instance);\n                    } else {\n                        field.setAccessible(true);\n                        field.set(testInstance, Mockito.mock(instance.getClass(), withSettings()\n                                .spiedInstance(instance)\n                                .defaultAnswer(Mockito.CALLS_REAL_METHODS)\n                                .name(field.getName())));\n                    }\n                } catch (IllegalAccessException e) {\n                    throw new MockitoException(\"Problems initiating spied field \" + field.getName(), e);\n                }\n            }\n        }\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 0
  },
  {
    "name": "ConstructorInjection.ConstructorInjection",
    "class_name": "org.mockito.internal.configuration.injection.ConstructorInjection",
    "signature": "org.mockito.internal.configuration.injection.ConstructorInjection.ConstructorInjection()",
    "snippet": "    public ConstructorInjection() { }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 0
  },
  {
    "name": "MockInjection.onFields",
    "class_name": "org.mockito.internal.configuration.injection.MockInjection",
    "signature": "org.mockito.internal.configuration.injection.MockInjection.onFields(Set,Object)",
    "snippet": "    public static OngoingMockInjection onFields(Set<Field> fields, Object ofInstance) {\n        return new OngoingMockInjection(fields, ofInstance);\n    }",
    "comment": " Create a new configuration setup for fields   @param fields Fields needing mock injection @param ofInstance Instance owning the <code>field</code> @return New configuration builder ",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 0
  },
  {
    "name": "OngoingMockInjection.apply",
    "class_name": "org.mockito.internal.configuration.injection.MockInjection$OngoingMockInjection",
    "signature": "org.mockito.internal.configuration.injection.MockInjection$OngoingMockInjection.apply()",
    "snippet": "        public void apply() {\n            for (Field field : fields) {\n                injectionStrategies.process(field, fieldOwner, mocks);\n                postInjectionStrategies.process(field, fieldOwner, mocks);\n            }\n        }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 0
  },
  {
    "name": "OngoingMockInjection.handleSpyAnnotation",
    "class_name": "org.mockito.internal.configuration.injection.MockInjection$OngoingMockInjection",
    "signature": "org.mockito.internal.configuration.injection.MockInjection$OngoingMockInjection.handleSpyAnnotation()",
    "snippet": "        public OngoingMockInjection handleSpyAnnotation() {\n            postInjectionStrategies.thenTry(new SpyOnInjectedFieldsHandler());\n            return this;\n        }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 0
  },
  {
    "name": "OngoingMockInjection.tryConstructorInjection",
    "class_name": "org.mockito.internal.configuration.injection.MockInjection$OngoingMockInjection",
    "signature": "org.mockito.internal.configuration.injection.MockInjection$OngoingMockInjection.tryConstructorInjection()",
    "snippet": "        public OngoingMockInjection tryConstructorInjection() {\n            injectionStrategies.thenTry(new ConstructorInjection());\n            return this;\n        }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 0
  },
  {
    "name": "OngoingMockInjection.tryPropertyOrFieldInjection",
    "class_name": "org.mockito.internal.configuration.injection.MockInjection$OngoingMockInjection",
    "signature": "org.mockito.internal.configuration.injection.MockInjection$OngoingMockInjection.tryPropertyOrFieldInjection()",
    "snippet": "        public OngoingMockInjection tryPropertyOrFieldInjection() {\n            injectionStrategies.thenTry(new PropertyAndSetterInjection());\n            return this;\n        }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 0
  },
  {
    "name": "OngoingMockInjection.withMocks",
    "class_name": "org.mockito.internal.configuration.injection.MockInjection$OngoingMockInjection",
    "signature": "org.mockito.internal.configuration.injection.MockInjection$OngoingMockInjection.withMocks(Set)",
    "snippet": "        public OngoingMockInjection withMocks(Set<Object> mocks) {\n            this.mocks.addAll(checkNotNull(mocks, \"mocks\"));\n            return this;\n        }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 0
  },
  {
    "name": "MockInjectionStrategy.nop",
    "class_name": "org.mockito.internal.configuration.injection.MockInjectionStrategy",
    "signature": "org.mockito.internal.configuration.injection.MockInjectionStrategy.nop()",
    "snippet": "    public static final MockInjectionStrategy nop() {\n        return new MockInjectionStrategy() {\n            protected boolean processInjection(Field field, Object fieldOwner, Set<Object> mockCandidates) {\n                return false;\n            }\n        };\n    }",
    "comment": " NOP Strategy that will always try the next strategy. ",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 0
  },
  {
    "name": "MockInjectionStrategy.thenTry",
    "class_name": "org.mockito.internal.configuration.injection.MockInjectionStrategy",
    "signature": "org.mockito.internal.configuration.injection.MockInjectionStrategy.thenTry(MockInjectionStrategy)",
    "snippet": "    public MockInjectionStrategy thenTry(MockInjectionStrategy strategy) {\n        if(nextStrategy != null) {\n            nextStrategy.thenTry(strategy);\n        } else {\n            nextStrategy = strategy;\n        }\n        return strategy;\n    }",
    "comment": " Enqueue next injection strategy.  <p> The implementation should take care of the actual calling if required. </p>  @param strategy Queued strategy. @return The passed strategy instance to allow chaining. ",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 0
  },
  {
    "name": "NameBasedCandidateFilter.NameBasedCandidateFilter",
    "class_name": "org.mockito.internal.configuration.injection.filter.NameBasedCandidateFilter",
    "signature": "org.mockito.internal.configuration.injection.filter.NameBasedCandidateFilter.NameBasedCandidateFilter(MockCandidateFilter)",
    "snippet": "    public NameBasedCandidateFilter(MockCandidateFilter next) {\n        this.next = next;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 0
  },
  {
    "name": "TypeBasedCandidateFilter.TypeBasedCandidateFilter",
    "class_name": "org.mockito.internal.configuration.injection.filter.TypeBasedCandidateFilter",
    "signature": "org.mockito.internal.configuration.injection.filter.TypeBasedCandidateFilter.TypeBasedCandidateFilter(MockCandidateFilter)",
    "snippet": "    public TypeBasedCandidateFilter(MockCandidateFilter next) {\n        this.next = next;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 0
  },
  {
    "name": "InjectMocksScanner.InjectMocksScanner",
    "class_name": "org.mockito.internal.configuration.injection.scanner.InjectMocksScanner",
    "signature": "org.mockito.internal.configuration.injection.scanner.InjectMocksScanner.InjectMocksScanner(Class)",
    "snippet": "    public InjectMocksScanner(Class<?> clazz) {\n        this.clazz = clazz;\n    }",
    "comment": " Create a new InjectMocksScanner for the given clazz on the given instance  @param clazz    Current class in the hierarchy of the test ",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 0
  },
  {
    "name": "InjectMocksScanner.addTo",
    "class_name": "org.mockito.internal.configuration.injection.scanner.InjectMocksScanner",
    "signature": "org.mockito.internal.configuration.injection.scanner.InjectMocksScanner.addTo(Set)",
    "snippet": "    public void addTo(Set<Field> mockDependentFields) {\n        mockDependentFields.addAll(scan());\n    }",
    "comment": " Add the fields annotated by @{@link InjectMocks}  @param mockDependentFields Set of fields annotated by  @{@link InjectMocks} ",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 0
  },
  {
    "name": "InjectMocksScanner.scan",
    "class_name": "org.mockito.internal.configuration.injection.scanner.InjectMocksScanner",
    "signature": "org.mockito.internal.configuration.injection.scanner.InjectMocksScanner.scan()",
    "snippet": "    private Set<Field> scan() {\n        Set<Field> mockDependentFields = new HashSet<Field>();\n        Field[] fields = clazz.getDeclaredFields();\n        for (Field field : fields) {\n            if (null != field.getAnnotation(InjectMocks.class)) {\n                assertNoAnnotations(field, Mock.class, MockitoAnnotations.Mock.class, Captor.class);\n                mockDependentFields.add(field);\n            }\n        }\n\n        return mockDependentFields;\n    }",
    "comment": " Scan fields annotated by &#064;InjectMocks  @return Fields that depends on Mock ",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 0
  },
  {
    "name": "MockScanner.MockScanner",
    "class_name": "org.mockito.internal.configuration.injection.scanner.MockScanner",
    "signature": "org.mockito.internal.configuration.injection.scanner.MockScanner.MockScanner(Object,Class)",
    "snippet": "    public MockScanner(Object instance, Class<?> clazz) {\n        this.instance = instance;\n        this.clazz = clazz;\n    }",
    "comment": " Creates a MockScanner.  @param instance The test instance @param clazz    The class in the type hierarchy of this instance. ",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 0
  },
  {
    "name": "MockScanner.addPreparedMocks",
    "class_name": "org.mockito.internal.configuration.injection.scanner.MockScanner",
    "signature": "org.mockito.internal.configuration.injection.scanner.MockScanner.addPreparedMocks(Set)",
    "snippet": "    public void addPreparedMocks(Set<Object> mocks) {\n        mocks.addAll(scan());\n    }",
    "comment": " Add the scanned and prepared mock instance to the given collection.  <p> The preparation of mocks consists only in defining a MockName if not already set. </p>  @param mocks Set of mocks ",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 0
  },
  {
    "name": "MockScanner.isAnnotatedByMockOrSpy",
    "class_name": "org.mockito.internal.configuration.injection.scanner.MockScanner",
    "signature": "org.mockito.internal.configuration.injection.scanner.MockScanner.isAnnotatedByMockOrSpy(Field)",
    "snippet": "    private boolean isAnnotatedByMockOrSpy(Field field) {\n        return null != field.getAnnotation(Spy.class)\n                || null != field.getAnnotation(Mock.class)\n                || null != field.getAnnotation(MockitoAnnotations.Mock.class);\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 0
  },
  {
    "name": "MockScanner.isMockOrSpy",
    "class_name": "org.mockito.internal.configuration.injection.scanner.MockScanner",
    "signature": "org.mockito.internal.configuration.injection.scanner.MockScanner.isMockOrSpy(Object)",
    "snippet": "    private boolean isMockOrSpy(Object instance) {\n        return mockUtil.isMock(instance)\n                || mockUtil.isSpy(instance);\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 0
  },
  {
    "name": "MockScanner.preparedMock",
    "class_name": "org.mockito.internal.configuration.injection.scanner.MockScanner",
    "signature": "org.mockito.internal.configuration.injection.scanner.MockScanner.preparedMock(Object,Field)",
    "snippet": "    private Object preparedMock(Object instance, Field field) {\n        if (isAnnotatedByMockOrSpy(field)) {\n            return instance;\n        } else if (isMockOrSpy(instance)) {\n            mockUtil.maybeRedefineMockName(instance, field.getName());\n            return instance;\n        }\n        return null;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 0
  },
  {
    "name": "MockScanner.scan",
    "class_name": "org.mockito.internal.configuration.injection.scanner.MockScanner",
    "signature": "org.mockito.internal.configuration.injection.scanner.MockScanner.scan()",
    "snippet": "    private Set<Object> scan() {\n        Set<Object> mocks = newMockSafeHashSet();\n        for (Field field : clazz.getDeclaredFields()) {\n            // mock or spies only\n            FieldReader fieldReader = new FieldReader(instance, field);\n\n            Object mockInstance = preparedMock(fieldReader.read(), field);\n            if (mockInstance != null) {\n                mocks.add(mockInstance);\n            }\n        }\n        return mocks;\n    }",
    "comment": " Scan and prepare mocks for the given <code>testClassInstance</code> and <code>clazz</code> in the type hierarchy.  @return A prepared set of mock ",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 0
  },
  {
    "name": "CglibMockMaker.getHandler",
    "class_name": "org.mockito.internal.creation.CglibMockMaker",
    "signature": "org.mockito.internal.creation.CglibMockMaker.getHandler(Object)",
    "snippet": "    public MockHandler getHandler(Object mock) {\n        if (!(mock instanceof Factory)) {\n            return null;\n        }\n        Factory factory = (Factory) mock;\n        Callback callback = factory.getCallback(0);\n        if (!(callback instanceof MethodInterceptorFilter)) {\n            return null;\n        }\n        return ((MethodInterceptorFilter) callback).getHandler();\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 0
  },
  {
    "name": "DelegatingMethod.DelegatingMethod",
    "class_name": "org.mockito.internal.creation.DelegatingMethod",
    "signature": "org.mockito.internal.creation.DelegatingMethod.DelegatingMethod(Method)",
    "snippet": "    public DelegatingMethod(Method method) {\n        assert method != null : \"Method cannot be null\";\n        this.method = method;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 0
  },
  {
    "name": "DelegatingMethod.getReturnType",
    "class_name": "org.mockito.internal.creation.DelegatingMethod",
    "signature": "org.mockito.internal.creation.DelegatingMethod.getReturnType()",
    "snippet": "    public Class<?> getReturnType() {\n        return method.getReturnType();\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 0
  },
  {
    "name": "MethodInterceptorFilter.MethodInterceptorFilter",
    "class_name": "org.mockito.internal.creation.MethodInterceptorFilter",
    "signature": "org.mockito.internal.creation.MethodInterceptorFilter.MethodInterceptorFilter(InternalMockHandler,MockCreationSettings)",
    "snippet": "    public MethodInterceptorFilter(InternalMockHandler handler, MockCreationSettings mockSettings) {\n        this.handler = handler;\n        this.mockSettings = mockSettings;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 0
  },
  {
    "name": "MockSettingsImpl.confirm",
    "class_name": "org.mockito.internal.creation.MockSettingsImpl",
    "signature": "org.mockito.internal.creation.MockSettingsImpl.confirm(Class)",
    "snippet": "    public MockCreationSettings<T> confirm(Class<T> typeToMock) {\n        return validatedSettings(typeToMock, this);\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 0
  },
  {
    "name": "MockSettingsImpl.defaultAnswer",
    "class_name": "org.mockito.internal.creation.MockSettingsImpl",
    "signature": "org.mockito.internal.creation.MockSettingsImpl.defaultAnswer(Answer)",
    "snippet": "    public MockSettings defaultAnswer(Answer defaultAnswer) {\n        this.defaultAnswer = defaultAnswer;\n        return this;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 0
  },
  {
    "name": "MockSettingsImpl.getExtraInterfaces",
    "class_name": "org.mockito.internal.creation.MockSettingsImpl",
    "signature": "org.mockito.internal.creation.MockSettingsImpl.getExtraInterfaces()",
    "snippet": "    public Set<Class> getExtraInterfaces() {\n        return extraInterfaces;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 0
  },
  {
    "name": "MockSettingsImpl.getSpiedInstance",
    "class_name": "org.mockito.internal.creation.MockSettingsImpl",
    "signature": "org.mockito.internal.creation.MockSettingsImpl.getSpiedInstance()",
    "snippet": "    public Object getSpiedInstance() {\n        return spiedInstance;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 0
  },
  {
    "name": "MockSettingsImpl.isSerializable",
    "class_name": "org.mockito.internal.creation.MockSettingsImpl",
    "signature": "org.mockito.internal.creation.MockSettingsImpl.isSerializable()",
    "snippet": "    public boolean isSerializable() {\n        return serializable;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 0
  },
  {
    "name": "MockSettingsImpl.prepareExtraInterfaces",
    "class_name": "org.mockito.internal.creation.MockSettingsImpl",
    "signature": "org.mockito.internal.creation.MockSettingsImpl.prepareExtraInterfaces(CreationSettings)",
    "snippet": "    private static Set<Class> prepareExtraInterfaces(CreationSettings settings) {\n        Set<Class> interfaces = new HashSet<Class>(settings.getExtraInterfaces());\n        if(settings.isSerializable()) {\n            interfaces.add(Serializable.class);\n        }\n        if (settings.getSpiedInstance() != null) {\n            interfaces.add(MockitoSpy.class);\n        }\n        return interfaces;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 0
  },
  {
    "name": "MockSettingsImpl.validatedSettings",
    "class_name": "org.mockito.internal.creation.MockSettingsImpl",
    "signature": "org.mockito.internal.creation.MockSettingsImpl.validatedSettings(Class,CreationSettings)",
    "snippet": "    private static <T> CreationSettings<T> validatedSettings(Class<T> typeToMock, CreationSettings<T> source) {\n        MockCreationValidator validator = new MockCreationValidator();\n\n        validator.validateType(typeToMock);\n        validator.validateExtraInterfaces(typeToMock, source.getExtraInterfaces());\n        validator.validateMockedType(typeToMock, source.getSpiedInstance());\n\n        //TODO SF - add this validation and also add missing coverage\n//        validator.validateDelegatedInstance(classToMock, settings.getDelegatedInstance());\n\n        CreationSettings<T> settings = new CreationSettings<T>(source);\n        settings.setMockName(new MockNameImpl(source.getName(), typeToMock));\n        settings.setTypeToMock(typeToMock);\n        settings.setExtraInterfaces(prepareExtraInterfaces(source));\n        return settings;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 0
  },
  {
    "name": "MockitoNamingPolicy.getTag",
    "class_name": "org.mockito.internal.creation.cglib.MockitoNamingPolicy",
    "signature": "org.mockito.internal.creation.cglib.MockitoNamingPolicy.getTag()",
    "snippet": "    @Override\n    protected String getTag() {\n        return \"ByMockitoWithCGLIB\";\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 0
  },
  {
    "name": "ClassImposterizer.canImposterise",
    "class_name": "org.mockito.internal.creation.jmock.ClassImposterizer",
    "signature": "org.mockito.internal.creation.jmock.ClassImposterizer.canImposterise(Class)",
    "snippet": "    public boolean canImposterise(Class<?> type) {\n        return !type.isPrimitive() && !Modifier.isFinal(type.getModifiers());\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 0
  },
  {
    "name": "ClassImposterizer.createProxy",
    "class_name": "org.mockito.internal.creation.jmock.ClassImposterizer",
    "signature": "org.mockito.internal.creation.jmock.ClassImposterizer.createProxy(Class,MethodInterceptor)",
    "snippet": "    private Object createProxy(Class<?> proxyClass, final MethodInterceptor interceptor) {\n        Factory proxy = (Factory) objenesis.newInstance(proxyClass);\n        proxy.setCallbacks(new Callback[] {interceptor, SerializableNoOp.SERIALIZABLE_INSTANCE });\n        return proxy;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 0
  },
  {
    "name": "ClassImposterizer.imposterise",
    "class_name": "org.mockito.internal.creation.jmock.ClassImposterizer",
    "signature": "org.mockito.internal.creation.jmock.ClassImposterizer.imposterise(MethodInterceptor,Class,Collection)",
    "snippet": "    public <T> T imposterise(final MethodInterceptor interceptor, Class<T> mockedType, Collection<Class> ancillaryTypes) {\n        return imposterise(interceptor, mockedType, ancillaryTypes.toArray(new Class[ancillaryTypes.size()]));\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 0
  },
  {
    "name": "ClassImposterizer.setConstructorsAccessible",
    "class_name": "org.mockito.internal.creation.jmock.ClassImposterizer",
    "signature": "org.mockito.internal.creation.jmock.ClassImposterizer.setConstructorsAccessible(Class,boolean)",
    "snippet": "    private void setConstructorsAccessible(Class<?> mockedType, boolean accessible) {\n        for (Constructor<?> constructor : mockedType.getDeclaredConstructors()) {\n            constructor.setAccessible(accessible);\n        }\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 0
  },
  {
    "name": "SearchingClassLoader.addIfNewElement",
    "class_name": "org.mockito.internal.creation.jmock.SearchingClassLoader",
    "signature": "org.mockito.internal.creation.jmock.SearchingClassLoader.addIfNewElement(List,ClassLoader)",
    "snippet": "    private static void addIfNewElement(List<ClassLoader> loaders, ClassLoader c) {\n        if (c != null && !loaders.contains(c)) {\n            loaders.add(c);\n        }\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 0
  },
  {
    "name": "SearchingClassLoader.combine",
    "class_name": "org.mockito.internal.creation.jmock.SearchingClassLoader",
    "signature": "org.mockito.internal.creation.jmock.SearchingClassLoader.combine(List)",
    "snippet": "    private static ClassLoader combine(List<ClassLoader> parentLoaders) {\n        ClassLoader loader = parentLoaders.get(parentLoaders.size()-1);\n        \n        for (int i = parentLoaders.size()-2; i >= 0; i--) {\n            loader = new SearchingClassLoader(parentLoaders.get(i), loader);\n        }\n        \n        return loader;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 0
  },
  {
    "name": "CreationSettings.CreationSettings",
    "class_name": "org.mockito.internal.creation.settings.CreationSettings",
    "signature": "org.mockito.internal.creation.settings.CreationSettings.CreationSettings()",
    "snippet": "    public CreationSettings() {}",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 0
  },
  {
    "name": "CreationSettings.CreationSettings",
    "class_name": "org.mockito.internal.creation.settings.CreationSettings",
    "signature": "org.mockito.internal.creation.settings.CreationSettings.CreationSettings(CreationSettings)",
    "snippet": "    public CreationSettings(CreationSettings copy) {\n        this.typeToMock = copy.typeToMock;\n        this.extraInterfaces = copy.extraInterfaces;\n        this.name = copy.name;\n        this.spiedInstance = copy.spiedInstance;\n        this.defaultAnswer = copy.defaultAnswer;\n        this.mockName = copy.mockName;\n        this.serializable = copy.serializable;\n        this.invocationListeners = copy.invocationListeners;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 0
  },
  {
    "name": "CreationSettings.getExtraInterfaces",
    "class_name": "org.mockito.internal.creation.settings.CreationSettings",
    "signature": "org.mockito.internal.creation.settings.CreationSettings.getExtraInterfaces()",
    "snippet": "    public Set<Class> getExtraInterfaces() {\n        return extraInterfaces;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 0
  },
  {
    "name": "CreationSettings.getInvocationListeners",
    "class_name": "org.mockito.internal.creation.settings.CreationSettings",
    "signature": "org.mockito.internal.creation.settings.CreationSettings.getInvocationListeners()",
    "snippet": "    public List<InvocationListener> getInvocationListeners() {\n        return invocationListeners;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 0
  },
  {
    "name": "CreationSettings.getName",
    "class_name": "org.mockito.internal.creation.settings.CreationSettings",
    "signature": "org.mockito.internal.creation.settings.CreationSettings.getName()",
    "snippet": "    public String getName() {\n        return name;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 0
  },
  {
    "name": "CreationSettings.getSpiedInstance",
    "class_name": "org.mockito.internal.creation.settings.CreationSettings",
    "signature": "org.mockito.internal.creation.settings.CreationSettings.getSpiedInstance()",
    "snippet": "    public Object getSpiedInstance() {\n        return spiedInstance;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 0
  },
  {
    "name": "CreationSettings.getTypeToMock",
    "class_name": "org.mockito.internal.creation.settings.CreationSettings",
    "signature": "org.mockito.internal.creation.settings.CreationSettings.getTypeToMock()",
    "snippet": "    public Class<T> getTypeToMock() {\n        return typeToMock;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 0
  },
  {
    "name": "CreationSettings.setExtraInterfaces",
    "class_name": "org.mockito.internal.creation.settings.CreationSettings",
    "signature": "org.mockito.internal.creation.settings.CreationSettings.setExtraInterfaces(Set)",
    "snippet": "    public CreationSettings<T> setExtraInterfaces(Set<Class> extraInterfaces) {\n        this.extraInterfaces = extraInterfaces;\n        return this;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 0
  },
  {
    "name": "CreationSettings.setMockName",
    "class_name": "org.mockito.internal.creation.settings.CreationSettings",
    "signature": "org.mockito.internal.creation.settings.CreationSettings.setMockName(MockName)",
    "snippet": "    public CreationSettings<T> setMockName(MockName mockName) {\n        this.mockName = mockName;\n        return this;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 0
  },
  {
    "name": "CreationSettings.setTypeToMock",
    "class_name": "org.mockito.internal.creation.settings.CreationSettings",
    "signature": "org.mockito.internal.creation.settings.CreationSettings.setTypeToMock(Class)",
    "snippet": "    public CreationSettings<T> setTypeToMock(Class<T> typeToMock) {\n        this.typeToMock = typeToMock;\n        return this;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 0
  },
  {
    "name": "LocationImpl.LocationImpl",
    "class_name": "org.mockito.internal.debugging.LocationImpl",
    "signature": "org.mockito.internal.debugging.LocationImpl.LocationImpl()",
    "snippet": "    public LocationImpl() {\n        this(new StackTraceFilter());\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 0
  },
  {
    "name": "LocationImpl.LocationImpl",
    "class_name": "org.mockito.internal.debugging.LocationImpl",
    "signature": "org.mockito.internal.debugging.LocationImpl.LocationImpl(StackTraceFilter)",
    "snippet": "    public LocationImpl(StackTraceFilter stackTraceFilter) {\n        this.stackTraceFilter = stackTraceFilter;\n        stackTraceHolder = new Throwable();\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 0
  },
  {
    "name": "InvocationNotifierHandler.InvocationNotifierHandler",
    "class_name": "org.mockito.internal.handler.InvocationNotifierHandler",
    "signature": "org.mockito.internal.handler.InvocationNotifierHandler.InvocationNotifierHandler(InternalMockHandler,MockCreationSettings)",
    "snippet": "    public InvocationNotifierHandler(InternalMockHandler<T> mockHandler, MockCreationSettings settings) {\n        this.mockHandler = mockHandler;\n        this.invocationListeners = settings.getInvocationListeners();\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 0
  },
  {
    "name": "MockHandlerFactory.create",
    "class_name": "org.mockito.internal.handler.MockHandlerFactory",
    "signature": "org.mockito.internal.handler.MockHandlerFactory.create(MockCreationSettings)",
    "snippet": "    public InternalMockHandler create(MockCreationSettings settings) {\n        InternalMockHandler handler = new MockHandlerImpl(settings);\n        InternalMockHandler nullResultGuardian = new NullResultGuardian(handler);\n        InternalMockHandler notifier = new InvocationNotifierHandler(nullResultGuardian, settings);\n\n        return notifier;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 0
  },
  {
    "name": "MockHandlerImpl.MockHandlerImpl",
    "class_name": "org.mockito.internal.handler.MockHandlerImpl",
    "signature": "org.mockito.internal.handler.MockHandlerImpl.MockHandlerImpl(MockCreationSettings)",
    "snippet": "    public MockHandlerImpl(MockCreationSettings mockSettings) {\n        this.mockSettings = mockSettings;\n        this.mockingProgress = new ThreadSafeMockingProgress();\n        this.matchersBinder = new MatchersBinder();\n        this.invocationContainerImpl = new InvocationContainerImpl(mockingProgress);\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 0
  },
  {
    "name": "NullResultGuardian.NullResultGuardian",
    "class_name": "org.mockito.internal.handler.NullResultGuardian",
    "signature": "org.mockito.internal.handler.NullResultGuardian.NullResultGuardian(InternalMockHandler)",
    "snippet": "    public NullResultGuardian(InternalMockHandler delegate) {\n        this.delegate = delegate;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 0
  },
  {
    "name": "ArgumentsProcessor.expandVarArgs",
    "class_name": "org.mockito.internal.invocation.ArgumentsProcessor",
    "signature": "org.mockito.internal.invocation.ArgumentsProcessor.expandVarArgs(boolean,Object[])",
    "snippet": "    public static Object[] expandVarArgs(final boolean isVarArgs, final Object[] args) {\n        if (!isVarArgs || new ArrayUtils().isEmpty(args) || args[args.length - 1] != null && !args[args.length - 1].getClass().isArray()) {\n            return args == null ? new Object[0] : args;\n        }\n\n        final int nonVarArgsCount = args.length - 1;\n        Object[] varArgs;\n        if (args[nonVarArgsCount] == null) {\n            // in case someone deliberately passed null varArg array\n            varArgs = new Object[] { null };\n        } else {\n            varArgs = ArrayEquals.createObjectArray(args[nonVarArgsCount]);\n        }\n        final int varArgsCount = varArgs.length;\n        Object[] newArgs = new Object[nonVarArgsCount + varArgsCount];\n        System.arraycopy(args, 0, newArgs, 0, nonVarArgsCount);\n        System.arraycopy(varArgs, 0, newArgs, nonVarArgsCount, varArgsCount);\n        return newArgs;\n    }",
    "comment": "varArgs (1, a, b);",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 0
  },
  {
    "name": "InvocationImpl.InvocationImpl",
    "class_name": "org.mockito.internal.invocation.InvocationImpl",
    "signature": "org.mockito.internal.invocation.InvocationImpl.InvocationImpl(Object,MockitoMethod,Object[],int,RealMethod)",
    "snippet": "    public InvocationImpl(Object mock, MockitoMethod mockitoMethod, Object[] args, int sequenceNumber, RealMethod realMethod) {\n        this.method = mockitoMethod;\n        this.mock = mock;\n        this.realMethod = realMethod;\n        this.arguments = ArgumentsProcessor.expandVarArgs(mockitoMethod.isVarArgs(), args);\n        this.rawArguments = args;\n        this.sequenceNumber = sequenceNumber;\n        this.location = new LocationImpl();\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 0
  },
  {
    "name": "InvocationImpl.getMethod",
    "class_name": "org.mockito.internal.invocation.InvocationImpl",
    "signature": "org.mockito.internal.invocation.InvocationImpl.getMethod()",
    "snippet": "    public Method getMethod() {\n        return method.getJavaMethod();\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 0
  },
  {
    "name": "SerializableMethod.SerializableMethod",
    "class_name": "org.mockito.internal.invocation.SerializableMethod",
    "signature": "org.mockito.internal.invocation.SerializableMethod.SerializableMethod(Method)",
    "snippet": "    public SerializableMethod(Method method) {\n        declaringClass = method.getDeclaringClass();\n        methodName = method.getName();\n        parameterTypes = method.getParameterTypes();\n        returnType = method.getReturnType();\n        exceptionTypes = method.getExceptionTypes();\n        isVarArgs = method.isVarArgs();\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 0
  },
  {
    "name": "SerializableMethod.getJavaMethod",
    "class_name": "org.mockito.internal.invocation.SerializableMethod",
    "signature": "org.mockito.internal.invocation.SerializableMethod.getJavaMethod()",
    "snippet": "    public Method getJavaMethod() {\n        try {\n            return declaringClass.getDeclaredMethod(methodName, parameterTypes);\n        } catch (SecurityException e) {\n            String message = String.format(\n                    \"The method %1$s.%2$s is probably private or protected and cannot be mocked.\\n\" +\n                            \"Please report this as a defect with an example of how to reproduce it.\", declaringClass, methodName);\n            throw new MockitoException(message, e);\n        } catch (NoSuchMethodException e) {\n            String message = String.format(\n                    \"The method %1$s.%2$s does not exists and you should not get to this point.\\n\" +\n                            \"Please report this as a defect with an example of how to reproduce it.\", declaringClass, methodName);\n            throw new MockitoException(message, e);\n        }\n    }    ",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 0
  },
  {
    "name": "SerializableMethod.isVarArgs",
    "class_name": "org.mockito.internal.invocation.SerializableMethod",
    "signature": "org.mockito.internal.invocation.SerializableMethod.isVarArgs()",
    "snippet": "    public boolean isVarArgs() {\n        return isVarArgs;\n    }  ",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 0
  },
  {
    "name": "ArgumentMatcherStorageImpl.validateState",
    "class_name": "org.mockito.internal.progress.ArgumentMatcherStorageImpl",
    "signature": "org.mockito.internal.progress.ArgumentMatcherStorageImpl.validateState()",
    "snippet": "    public void validateState() {\n        if (!matcherStack.isEmpty()) {\n            ArrayList lastMatchers = new ArrayList<LocalizedMatcher>(matcherStack);\n            matcherStack.clear();\n            new Reporter().misplacedArgumentMatcher(lastMatchers);\n        }\n    }",
    "comment": "(non-Javadoc) @see org.mockito.internal.progress.ArgumentMatcherStorage#validateState() ",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 0
  },
  {
    "name": "HandyReturnValues.returnFor",
    "class_name": "org.mockito.internal.progress.HandyReturnValues",
    "signature": "org.mockito.internal.progress.HandyReturnValues.returnFor(Class)",
    "snippet": "    public <T> T returnFor(Class<T> clazz) {\n        if (isPrimitiveWrapper(clazz)) {\n            return primitiveWrapperOf(clazz);\n        } \n        return primitiveValueOrNullFor(clazz);\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 0
  },
  {
    "name": "MockingProgressImpl.getArgumentMatcherStorage",
    "class_name": "org.mockito.internal.progress.MockingProgressImpl",
    "signature": "org.mockito.internal.progress.MockingProgressImpl.getArgumentMatcherStorage()",
    "snippet": "    public ArgumentMatcherStorage getArgumentMatcherStorage() {\n        return argumentMatcherStorage;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 0
  },
  {
    "name": "MockingProgressImpl.validateMostStuff",
    "class_name": "org.mockito.internal.progress.MockingProgressImpl",
    "signature": "org.mockito.internal.progress.MockingProgressImpl.validateMostStuff()",
    "snippet": "    private void validateMostStuff() {\n        //State is cool when GlobalConfiguration is already loaded\n        //this cannot really be tested functionally because I cannot dynamically mess up org.mockito.configuration.MockitoConfiguration class\n        GlobalConfiguration.validate();\n\n        if (verificationMode != null) {\n            Location location = verificationMode.getLocation();\n            verificationMode = null;\n            reporter.unfinishedVerificationException(location);\n        }\n\n        getArgumentMatcherStorage().validateState();\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 0
  },
  {
    "name": "MockingProgressImpl.validateState",
    "class_name": "org.mockito.internal.progress.MockingProgressImpl",
    "signature": "org.mockito.internal.progress.MockingProgressImpl.validateState()",
    "snippet": "    public void validateState() {\n        validateMostStuff();\n        \n        //validate stubbing:\n        if (stubbingInProgress != null) {\n            Location temp = stubbingInProgress;\n            stubbingInProgress = null;\n            reporter.unfinishedStubbing(temp);\n        }\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 0
  },
  {
    "name": "ThreadSafeMockingProgress.threadSafely",
    "class_name": "org.mockito.internal.progress.ThreadSafeMockingProgress",
    "signature": "org.mockito.internal.progress.ThreadSafeMockingProgress.threadSafely()",
    "snippet": "    static MockingProgress threadSafely() {\n        if (mockingProgress.get() == null) {\n            mockingProgress.set(new MockingProgressImpl());\n        }\n        return mockingProgress.get();\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 0
  },
  {
    "name": "ThreadSafeMockingProgress.validateState",
    "class_name": "org.mockito.internal.progress.ThreadSafeMockingProgress",
    "signature": "org.mockito.internal.progress.ThreadSafeMockingProgress.validateState()",
    "snippet": "    public void validateState() {\n        threadSafely().validateState();\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 0
  },
  {
    "name": "InvocationContainerImpl.InvocationContainerImpl",
    "class_name": "org.mockito.internal.stubbing.InvocationContainerImpl",
    "signature": "org.mockito.internal.stubbing.InvocationContainerImpl.InvocationContainerImpl(MockingProgress)",
    "snippet": "    public InvocationContainerImpl(MockingProgress mockingProgress) {\n        this.mockingProgress = mockingProgress;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 0
  },
  {
    "name": "ReturnsEmptyValues.returnValueFor",
    "class_name": "org.mockito.internal.stubbing.defaultanswers.ReturnsEmptyValues",
    "signature": "org.mockito.internal.stubbing.defaultanswers.ReturnsEmptyValues.returnValueFor(Class)",
    "snippet": "    Object returnValueFor(Class<?> type) {\n        if (type.isPrimitive()) {\n            return Primitives.primitiveValueOrNullFor(type);\n        } else if (Primitives.isPrimitiveWrapper(type)) {\n            return Primitives.primitiveWrapperOf(type);\n        //new instances are used instead of Collections.emptyList(), etc.\n        //to avoid UnsupportedOperationException if code under test modifies returned collection\n        } else if (type == Collection.class) {\n            return new LinkedList<Object>();\n        } else if (type == Set.class) {\n            return new HashSet<Object>();\n        } else if (type == HashSet.class) {\n            return new HashSet<Object>();\n        } else if (type == SortedSet.class) {\n            return new TreeSet<Object>();\n        } else if (type == TreeSet.class) {\n            return new TreeSet<Object>();\n        } else if (type == LinkedHashSet.class) {\n            return new LinkedHashSet<Object>();\n        } else if (type == List.class) {\n            return new LinkedList<Object>();\n        } else if (type == LinkedList.class) {\n            return new LinkedList<Object>();\n        } else if (type == ArrayList.class) {\n            return new ArrayList<Object>();\n        } else if (type == Map.class) {\n            return new HashMap<Object, Object>();\n        } else if (type == HashMap.class) {\n            return new HashMap<Object, Object>();\n        } else if (type == SortedMap.class) {\n            return new TreeMap<Object, Object>();\n        } else if (type == TreeMap.class) {\n            return new TreeMap<Object, Object>();\n        } else if (type == LinkedHashMap.class) {\n            return new LinkedHashMap<Object, Object>();\n        }       \n        //Let's not care about the rest of collections.\n        return null;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 0
  },
  {
    "name": "ReturnsMocks.answer",
    "class_name": "org.mockito.internal.stubbing.defaultanswers.ReturnsMocks",
    "signature": "org.mockito.internal.stubbing.defaultanswers.ReturnsMocks.answer(InvocationOnMock)",
    "snippet": "    public Object answer(InvocationOnMock invocation) throws Throwable {\n        Object ret = delegate.answer(invocation);\n        if (ret != null) {\n            return ret;\n        }\n            \n        return returnValueFor(invocation.getMethod().getReturnType());\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 0
  },
  {
    "name": "ReturnsMoreEmptyValues.answer",
    "class_name": "org.mockito.internal.stubbing.defaultanswers.ReturnsMoreEmptyValues",
    "signature": "org.mockito.internal.stubbing.defaultanswers.ReturnsMoreEmptyValues.answer(InvocationOnMock)",
    "snippet": "    public Object answer(InvocationOnMock invocation) throws Throwable {\n        Object ret = delegate.answer(invocation);\n        if (ret != null) {\n            return ret;\n        }\n\n        Class<?> returnType = invocation.getMethod().getReturnType();\n        return returnValueFor(returnType);\n    }",
    "comment": "(non-Javadoc) @see org.mockito.stubbing.Answer#answer(org.mockito.invocation.InvocationOnMock) ",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 0
  },
  {
    "name": "Checks.checkNotNull",
    "class_name": "org.mockito.internal.util.Checks",
    "signature": "org.mockito.internal.util.Checks.checkNotNull(T,String)",
    "snippet": "    public static <T> T checkNotNull(T value, String checkedValue) {\n        if(value == null) {\n            throw new NullPointerException(checkedValue + \" should not be null\");\n        }\n        return value;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 0
  },
  {
    "name": "MockCreationValidator.isTypeMockable",
    "class_name": "org.mockito.internal.util.MockCreationValidator",
    "signature": "org.mockito.internal.util.MockCreationValidator.isTypeMockable(Class)",
    "snippet": "    public boolean isTypeMockable(Class<?> clz) {\n        return ClassImposterizer.INSTANCE.canImposterise(clz);\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 0
  },
  {
    "name": "MockCreationValidator.validateExtraInterfaces",
    "class_name": "org.mockito.internal.util.MockCreationValidator",
    "signature": "org.mockito.internal.util.MockCreationValidator.validateExtraInterfaces(Class,Collection)",
    "snippet": "    public void validateExtraInterfaces(Class classToMock, Collection<Class> extraInterfaces) {\n        if (extraInterfaces == null) {\n            return;\n        }\n\n        for (Class i : extraInterfaces) {\n            if (classToMock == i) {\n                new Reporter().extraInterfacesCannotContainMockedType(classToMock);\n            }\n        }\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 0
  },
  {
    "name": "MockCreationValidator.validateMockedType",
    "class_name": "org.mockito.internal.util.MockCreationValidator",
    "signature": "org.mockito.internal.util.MockCreationValidator.validateMockedType(Class,Object)",
    "snippet": "    public void validateMockedType(Class classToMock, Object spiedInstance) {\n        if (classToMock == null || spiedInstance == null) {\n            return;\n        }\n        if (!classToMock.equals(spiedInstance.getClass())) {\n            new Reporter().mockedTypeIsInconsistentWithSpiedInstanceType(classToMock, spiedInstance);\n        }\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 0
  },
  {
    "name": "MockCreationValidator.validateType",
    "class_name": "org.mockito.internal.util.MockCreationValidator",
    "signature": "org.mockito.internal.util.MockCreationValidator.validateType(Class)",
    "snippet": "    public void validateType(Class classToMock) {\n        if (!isTypeMockable(classToMock)) {\n            new Reporter().cannotMockFinalClass(classToMock);\n        }\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 0
  },
  {
    "name": "MockNameImpl.MockNameImpl",
    "class_name": "org.mockito.internal.util.MockNameImpl",
    "signature": "org.mockito.internal.util.MockNameImpl.MockNameImpl(String,Class)",
    "snippet": "    @SuppressWarnings(\"unchecked\")\n    public MockNameImpl(String mockName, Class classToMock) {\n        if (mockName == null) {\n            this.mockName = toInstanceName(classToMock);\n            this.defaultName = true;\n        } else {\n            this.mockName = mockName;\n        }\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 0
  },
  {
    "name": "MockNameImpl.toInstanceName",
    "class_name": "org.mockito.internal.util.MockNameImpl",
    "signature": "org.mockito.internal.util.MockNameImpl.toInstanceName(Class)",
    "snippet": "    private static String toInstanceName(Class<?> clazz) {\n        String className = clazz.getSimpleName();\n        if (className.length() == 0) {\n            //it's an anonymous class, let's get name from the parent\n            className = clazz.getSuperclass().getSimpleName();\n        }\n        //lower case first letter\n        return className.substring(0, 1).toLowerCase() + className.substring(1);\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 0
  },
  {
    "name": "MockUtil.isMock",
    "class_name": "org.mockito.internal.util.MockUtil",
    "signature": "org.mockito.internal.util.MockUtil.isMock(Object)",
    "snippet": "    public boolean isMock(Object mock) {\n        return mock != null && isMockitoMock(mock);\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 0
  },
  {
    "name": "MockUtil.isMockitoMock",
    "class_name": "org.mockito.internal.util.MockUtil",
    "signature": "org.mockito.internal.util.MockUtil.isMockitoMock(T)",
    "snippet": "    private <T> boolean isMockitoMock(T mock) {\n        return mockMaker.getHandler(mock) != null;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 0
  },
  {
    "name": "MockUtil.isSpy",
    "class_name": "org.mockito.internal.util.MockUtil",
    "signature": "org.mockito.internal.util.MockUtil.isSpy(Object)",
    "snippet": "    public boolean isSpy(Object mock) {\n        return mock instanceof MockitoSpy && isMock(mock);\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 0
  },
  {
    "name": "Primitives.isPrimitiveWrapper",
    "class_name": "org.mockito.internal.util.Primitives",
    "signature": "org.mockito.internal.util.Primitives.isPrimitiveWrapper(Class)",
    "snippet": "    public static boolean isPrimitiveWrapper(Class<?> type) {\n        return wrapperReturnValues.containsKey(type);\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 0
  },
  {
    "name": "Primitives.primitiveValueOrNullFor",
    "class_name": "org.mockito.internal.util.Primitives",
    "signature": "org.mockito.internal.util.Primitives.primitiveValueOrNullFor(Class)",
    "snippet": "    public static <T> T primitiveValueOrNullFor(Class<T> primitiveType) {\n        return (T) primitiveValues.get(primitiveType);\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 0
  },
  {
    "name": "HashCodeAndEqualsSafeSet.addAll",
    "class_name": "org.mockito.internal.util.collections.HashCodeAndEqualsSafeSet",
    "signature": "org.mockito.internal.util.collections.HashCodeAndEqualsSafeSet.addAll(Collection)",
    "snippet": "    public boolean addAll(Collection<?> mocks) {\n        return backingHashSet.addAll(asWrappedMocks(mocks));\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 0
  },
  {
    "name": "HashCodeAndEqualsSafeSet.asWrappedMocks",
    "class_name": "org.mockito.internal.util.collections.HashCodeAndEqualsSafeSet",
    "signature": "org.mockito.internal.util.collections.HashCodeAndEqualsSafeSet.asWrappedMocks(Collection)",
    "snippet": "    private HashSet<HashCodeAndEqualsMockWrapper> asWrappedMocks(Collection<?> mocks) {\n        Checks.checkNotNull(mocks, \"Passed collection should notify() be null\");\n        HashSet<HashCodeAndEqualsMockWrapper> hashSet = new HashSet<HashCodeAndEqualsMockWrapper>();\n        for (Object mock : mocks) {\n            assert ! (mock instanceof HashCodeAndEqualsMockWrapper) : \"WRONG\";\n            hashSet.add(HashCodeAndEqualsMockWrapper.of(mock));\n        }\n        return hashSet;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 0
  },
  {
    "name": "HashCodeAndEqualsSafeSet.iterator",
    "class_name": "org.mockito.internal.util.collections.HashCodeAndEqualsSafeSet",
    "signature": "org.mockito.internal.util.collections.HashCodeAndEqualsSafeSet.iterator()",
    "snippet": "    public Iterator<Object> iterator() {\n        return new Iterator<Object>() {\n            private Iterator<HashCodeAndEqualsMockWrapper> iterator = backingHashSet.iterator();\n\n            public boolean hasNext() {\n                return iterator.hasNext();\n            }\n\n            public Object next() {\n                return iterator.next().get();\n            }\n\n            public void remove() {\n                iterator.remove();\n            }\n        };\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 0
  },
  {
    "name": "HashCodeAndEqualsSafeSet.of",
    "class_name": "org.mockito.internal.util.collections.HashCodeAndEqualsSafeSet",
    "signature": "org.mockito.internal.util.collections.HashCodeAndEqualsSafeSet.of(Iterable)",
    "snippet": "    public static HashCodeAndEqualsSafeSet of(Iterable<Object> objects) {\n        HashCodeAndEqualsSafeSet hashCodeAndEqualsSafeSet = new HashCodeAndEqualsSafeSet();\n        if (objects != null) {\n            for (Object mock : objects) {\n                hashCodeAndEqualsSafeSet.add(mock);\n            }\n        }\n        return hashCodeAndEqualsSafeSet;\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 0
  },
  {
    "name": "HashCodeAndEqualsSafeSet.of",
    "class_name": "org.mockito.internal.util.collections.HashCodeAndEqualsSafeSet",
    "signature": "org.mockito.internal.util.collections.HashCodeAndEqualsSafeSet.of(Object[])",
    "snippet": "    public static HashCodeAndEqualsSafeSet of(Object... mocks) {\n        return of(Arrays.asList(mocks));\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 0
  },
  {
    "name": "Sets.newMockSafeHashSet",
    "class_name": "org.mockito.internal.util.collections.Sets",
    "signature": "org.mockito.internal.util.collections.Sets.newMockSafeHashSet(Object[])",
    "snippet": "    public static Set<Object> newMockSafeHashSet(Object... mocks) {\n        return HashCodeAndEqualsSafeSet.of(mocks);\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 0
  },
  {
    "name": "AccessibilityChanger.enableAccess",
    "class_name": "org.mockito.internal.util.reflection.AccessibilityChanger",
    "signature": "org.mockito.internal.util.reflection.AccessibilityChanger.enableAccess(AccessibleObject)",
    "snippet": "    public void enableAccess(AccessibleObject accessibleObject) {\n        wasAccessible = accessibleObject.isAccessible();\n        accessibleObject.setAccessible(true);\n    }",
    "comment": " changes the accessibleObject accessibility and returns true if accessibility was changed ",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 0
  },
  {
    "name": "FieldReader.FieldReader",
    "class_name": "org.mockito.internal.util.reflection.FieldReader",
    "signature": "org.mockito.internal.util.reflection.FieldReader.FieldReader(Object,Field)",
    "snippet": "    public FieldReader(Object target, Field field) {\n        this.target = target;\n        this.field = field;\n        changer.enableAccess(field);\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 0
  },
  {
    "name": "FieldReader.read",
    "class_name": "org.mockito.internal.util.reflection.FieldReader",
    "signature": "org.mockito.internal.util.reflection.FieldReader.read()",
    "snippet": "    public Object read() {\n        try {\n            return field.get(target);\n        } catch (Exception e) {\n            throw new MockitoException(\"Cannot read state from field: \" + field + \", on instance: \" + target);\n        }\n    }",
    "comment": "",
    "is_bug": false,
    "failing_test_cases": 4,
    "buggy_methods": 0
  }
]