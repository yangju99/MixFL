[
  {
    "name": "AbstractRealDistribution.AbstractRealDistribution",
    "class_name": "org.apache.commons.math3.distribution.AbstractRealDistribution",
    "signature": "org.apache.commons.math3.distribution.AbstractRealDistribution.AbstractRealDistribution(RandomGenerator)",
    "snippet": "    protected AbstractRealDistribution(RandomGenerator rng) {\n        random = rng;\n    }",
    "comment": " @param rng Random number generator. ",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 2
  },
  {
    "name": "FDistribution.FDistribution",
    "class_name": "org.apache.commons.math3.distribution.FDistribution",
    "signature": "org.apache.commons.math3.distribution.FDistribution.FDistribution(RandomGenerator,double,double,double)",
    "snippet": "    public FDistribution(RandomGenerator rng,\n                         double numeratorDegreesOfFreedom,\n                         double denominatorDegreesOfFreedom,\n                         double inverseCumAccuracy)\n        throws NotStrictlyPositiveException {\n        super(rng);\n\n        if (numeratorDegreesOfFreedom <= 0) {\n            throw new NotStrictlyPositiveException(LocalizedFormats.DEGREES_OF_FREEDOM,\n                                                   numeratorDegreesOfFreedom);\n        }\n        if (denominatorDegreesOfFreedom <= 0) {\n            throw new NotStrictlyPositiveException(LocalizedFormats.DEGREES_OF_FREEDOM,\n                                                   denominatorDegreesOfFreedom);\n        }\n        this.numeratorDegreesOfFreedom = numeratorDegreesOfFreedom;\n        this.denominatorDegreesOfFreedom = denominatorDegreesOfFreedom;\n        solverAbsoluteAccuracy = inverseCumAccuracy;\n    }",
    "comment": " Creates an F distribution.  @param rng Random number generator. @param numeratorDegreesOfFreedom Numerator degrees of freedom. @param denominatorDegreesOfFreedom Denominator degrees of freedom. @param inverseCumAccuracy the maximum absolute error in inverse cumulative probability estimates. @throws NotStrictlyPositiveException if {@code numeratorDegreesOfFreedom <= 0} or {@code denominatorDegreesOfFreedom <= 0}. @since 3.1 ",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 2
  },
  {
    "name": "FDistribution.FDistribution",
    "class_name": "org.apache.commons.math3.distribution.FDistribution",
    "signature": "org.apache.commons.math3.distribution.FDistribution.FDistribution(double,double)",
    "snippet": "    public FDistribution(double numeratorDegreesOfFreedom,\n                         double denominatorDegreesOfFreedom)\n        throws NotStrictlyPositiveException {\n        this(numeratorDegreesOfFreedom, denominatorDegreesOfFreedom,\n             DEFAULT_INVERSE_ABSOLUTE_ACCURACY);\n    }",
    "comment": " Creates an F distribution using the given degrees of freedom.  @param numeratorDegreesOfFreedom Numerator degrees of freedom. @param denominatorDegreesOfFreedom Denominator degrees of freedom. @throws NotStrictlyPositiveException if {@code numeratorDegreesOfFreedom <= 0} or {@code denominatorDegreesOfFreedom <= 0}. ",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 2
  },
  {
    "name": "FDistribution.FDistribution",
    "class_name": "org.apache.commons.math3.distribution.FDistribution",
    "signature": "org.apache.commons.math3.distribution.FDistribution.FDistribution(double,double,double)",
    "snippet": "    public FDistribution(double numeratorDegreesOfFreedom,\n                         double denominatorDegreesOfFreedom,\n                         double inverseCumAccuracy)\n        throws NotStrictlyPositiveException {\n        this(new Well19937c(), numeratorDegreesOfFreedom,\n             denominatorDegreesOfFreedom, inverseCumAccuracy);\n    }",
    "comment": " Creates an F distribution using the given degrees of freedom and inverse cumulative probability accuracy.  @param numeratorDegreesOfFreedom Numerator degrees of freedom. @param denominatorDegreesOfFreedom Denominator degrees of freedom. @param inverseCumAccuracy the maximum absolute error in inverse cumulative probability estimates. @throws NotStrictlyPositiveException if {@code numeratorDegreesOfFreedom <= 0} or {@code denominatorDegreesOfFreedom <= 0}. @since 2.1 ",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 2
  },
  {
    "name": "FDistribution.density",
    "class_name": "org.apache.commons.math3.distribution.FDistribution",
    "signature": "org.apache.commons.math3.distribution.FDistribution.density(double)",
    "snippet": "    public double density(double x) {\n        final double nhalf = numeratorDegreesOfFreedom / 2;\n        final double mhalf = denominatorDegreesOfFreedom / 2;\n        final double logx = FastMath.log(x);\n        final double logn = FastMath.log(numeratorDegreesOfFreedom);\n        final double logm = FastMath.log(denominatorDegreesOfFreedom);\n        final double lognxm = FastMath.log(numeratorDegreesOfFreedom * x +\n                                           denominatorDegreesOfFreedom);\n        return FastMath.exp(nhalf * logn + nhalf * logx - logx +\n                            mhalf * logm - nhalf * lognxm - mhalf * lognxm -\n                            Beta.logBeta(nhalf, mhalf));\n    }",
    "comment": " {@inheritDoc}  @since 2.1 ",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 2
  },
  {
    "name": "FDistribution.getSupportLowerBound",
    "class_name": "org.apache.commons.math3.distribution.FDistribution",
    "signature": "org.apache.commons.math3.distribution.FDistribution.getSupportLowerBound()",
    "snippet": "    public double getSupportLowerBound() {\n        return 0;\n    }",
    "comment": " {@inheritDoc}  The lower bound of the support is always 0 no matter the parameters.  @return lower bound of the support (always 0) ",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 2
  },
  {
    "name": "FDistribution.isSupportLowerBoundInclusive",
    "class_name": "org.apache.commons.math3.distribution.FDistribution",
    "signature": "org.apache.commons.math3.distribution.FDistribution.isSupportLowerBoundInclusive()",
    "snippet": "    public boolean isSupportLowerBoundInclusive() {\n        return true;\n    }",
    "comment": "{@inheritDoc} */",
    "is_bug": true,
    "failing_test_cases": 2,
    "buggy_methods": 2
  },
  {
    "name": "UniformRealDistribution.UniformRealDistribution",
    "class_name": "org.apache.commons.math3.distribution.UniformRealDistribution",
    "signature": "org.apache.commons.math3.distribution.UniformRealDistribution.UniformRealDistribution(RandomGenerator,double,double,double)",
    "snippet": "    public UniformRealDistribution(RandomGenerator rng,\n                                   double lower,\n                                   double upper,\n                                   double inverseCumAccuracy)\n        throws NumberIsTooLargeException {\n        super(rng);\n        if (lower >= upper) {\n            throw new NumberIsTooLargeException(\n                            LocalizedFormats.LOWER_BOUND_NOT_BELOW_UPPER_BOUND,\n                            lower, upper, false);\n        }\n\n        this.lower = lower;\n        this.upper = upper;\n        solverAbsoluteAccuracy = inverseCumAccuracy;\n    }",
    "comment": " Creates a uniform distribution.  @param rng Random number generator. @param lower Lower bound of this distribution (inclusive). @param upper Upper bound of this distribution (exclusive). @param inverseCumAccuracy Inverse cumulative probability accuracy. @throws NumberIsTooLargeException if {@code lower >= upper}. @since 3.1 ",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 2
  },
  {
    "name": "UniformRealDistribution.UniformRealDistribution",
    "class_name": "org.apache.commons.math3.distribution.UniformRealDistribution",
    "signature": "org.apache.commons.math3.distribution.UniformRealDistribution.UniformRealDistribution(double,double)",
    "snippet": "    public UniformRealDistribution(double lower, double upper)\n        throws NumberIsTooLargeException {\n        this(lower, upper, DEFAULT_INVERSE_ABSOLUTE_ACCURACY);\n    }",
    "comment": " Create a uniform real distribution using the given lower and upper bounds.  @param lower Lower bound of this distribution (inclusive). @param upper Upper bound of this distribution (exclusive). @throws NumberIsTooLargeException if {@code lower >= upper}. ",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 2
  },
  {
    "name": "UniformRealDistribution.UniformRealDistribution",
    "class_name": "org.apache.commons.math3.distribution.UniformRealDistribution",
    "signature": "org.apache.commons.math3.distribution.UniformRealDistribution.UniformRealDistribution(double,double,double)",
    "snippet": "    public UniformRealDistribution(double lower, double upper, double inverseCumAccuracy)\n        throws NumberIsTooLargeException {\n        this(new  Well19937c(), lower, upper, inverseCumAccuracy);\n    }",
    "comment": " Create a uniform distribution.  @param lower Lower bound of this distribution (inclusive). @param upper Upper bound of this distribution (exclusive). @param inverseCumAccuracy Inverse cumulative probability accuracy. @throws NumberIsTooLargeException if {@code lower >= upper}. ",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 2
  },
  {
    "name": "UniformRealDistribution.density",
    "class_name": "org.apache.commons.math3.distribution.UniformRealDistribution",
    "signature": "org.apache.commons.math3.distribution.UniformRealDistribution.density(double)",
    "snippet": "    public double density(double x) {\n        if (x < lower || x > upper) {\n            return 0.0;\n        }\n        return 1 / (upper - lower);\n    }",
    "comment": "{@inheritDoc} */",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 2
  },
  {
    "name": "UniformRealDistribution.getSupportUpperBound",
    "class_name": "org.apache.commons.math3.distribution.UniformRealDistribution",
    "signature": "org.apache.commons.math3.distribution.UniformRealDistribution.getSupportUpperBound()",
    "snippet": "    public double getSupportUpperBound() {\n        return upper;\n    }",
    "comment": " {@inheritDoc}  The upper bound of the support is equal to the upper bound parameter of the distribution.  @return upper bound of the support ",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 2
  },
  {
    "name": "UniformRealDistribution.isSupportUpperBoundInclusive",
    "class_name": "org.apache.commons.math3.distribution.UniformRealDistribution",
    "signature": "org.apache.commons.math3.distribution.UniformRealDistribution.isSupportUpperBoundInclusive()",
    "snippet": "    public boolean isSupportUpperBoundInclusive() {\n        return false;\n    }",
    "comment": "{@inheritDoc} */",
    "is_bug": true,
    "failing_test_cases": 2,
    "buggy_methods": 2
  },
  {
    "name": "AbstractWell.AbstractWell",
    "class_name": "org.apache.commons.math3.random.AbstractWell",
    "signature": "org.apache.commons.math3.random.AbstractWell.AbstractWell(int,int,int,int)",
    "snippet": "    protected AbstractWell(final int k, final int m1, final int m2, final int m3) {\n        this(k, m1, m2, m3, null);\n    }",
    "comment": "Creates a new random number generator. <p>The instance is initialized using the current time plus the system identity hash code of this instance as the seed.</p> @param k number of bits in the pool (not necessarily a multiple of 32) @param m1 first parameter of the algorithm @param m2 second parameter of the algorithm @param m3 third parameter of the algorithm ",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 2
  },
  {
    "name": "AbstractWell.AbstractWell",
    "class_name": "org.apache.commons.math3.random.AbstractWell",
    "signature": "org.apache.commons.math3.random.AbstractWell.AbstractWell(int,int,int,int,int[])",
    "snippet": "    protected AbstractWell(final int k, final int m1, final int m2, final int m3, final int[] seed) {\n\n        // the bits pool contains k bits, k = r w - p where r is the number\n        // of w bits blocks, w is the block size (always 32 in the original paper)\n        // and p is the number of unused bits in the last block\n        final int w = 32;\n        final int r = (k + w - 1) / w;\n        this.v      = new int[r];\n        this.index  = 0;\n\n        // precompute indirection index tables. These tables are used for optimizing access\n        // they allow saving computations like \"(j + r - 2) % r\" with costly modulo operations\n        iRm1 = new int[r];\n        iRm2 = new int[r];\n        i1   = new int[r];\n        i2   = new int[r];\n        i3   = new int[r];\n        for (int j = 0; j < r; ++j) {\n            iRm1[j] = (j + r - 1) % r;\n            iRm2[j] = (j + r - 2) % r;\n            i1[j]   = (j + m1)    % r;\n            i2[j]   = (j + m2)    % r;\n            i3[j]   = (j + m3)    % r;\n        }\n\n        // initialize the pool content\n        setSeed(seed);\n\n    }",
    "comment": "Creates a new random number generator using an int array seed. @param k number of bits in the pool (not necessarily a multiple of 32) @param m1 first parameter of the algorithm @param m2 second parameter of the algorithm @param m3 third parameter of the algorithm @param seed the initial seed (32 bits integers array), if null the seed of the generator will be related to the current time ",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 2
  },
  {
    "name": "AbstractWell.setSeed",
    "class_name": "org.apache.commons.math3.random.AbstractWell",
    "signature": "org.apache.commons.math3.random.AbstractWell.setSeed(int[])",
    "snippet": "    @Override\n    public void setSeed(final int[] seed) {\n        if (seed == null) {\n            setSeed(System.currentTimeMillis() + System.identityHashCode(this));\n            return;\n        }\n\n        System.arraycopy(seed, 0, v, 0, Math.min(seed.length, v.length));\n\n        if (seed.length < v.length) {\n            for (int i = seed.length; i < v.length; ++i) {\n                final long l = v[i - seed.length];\n                v[i] = (int) ((1812433253l * (l ^ (l >> 30)) + i) & 0xffffffffL);\n            }\n        }\n\n        index = 0;\n        clear();  // Clear normal deviate cache\n    }",
    "comment": "Reinitialize the generator as if just built with the given int array seed. <p>The state of the generator is exactly the same as a new generator built with the same seed.</p> @param seed the initial seed (32 bits integers array). If null the seed of the generator will be the system time plus the system identity hash code of the instance. ",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 2
  },
  {
    "name": "AbstractWell.setSeed",
    "class_name": "org.apache.commons.math3.random.AbstractWell",
    "signature": "org.apache.commons.math3.random.AbstractWell.setSeed(long)",
    "snippet": "    @Override\n    public void setSeed(final long seed) {\n        setSeed(new int[] { (int) (seed >>> 32), (int) (seed & 0xffffffffl) });\n    }",
    "comment": "Reinitialize the generator as if just built with the given long seed. <p>The state of the generator is exactly the same as a new generator built with the same seed.</p> @param seed the initial seed (64 bits integer) ",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 2
  },
  {
    "name": "BitsStreamGenerator.BitsStreamGenerator",
    "class_name": "org.apache.commons.math3.random.BitsStreamGenerator",
    "signature": "org.apache.commons.math3.random.BitsStreamGenerator.BitsStreamGenerator()",
    "snippet": "    public BitsStreamGenerator() {\n        nextGaussian = Double.NaN;\n    }",
    "comment": "Creates a new random number generator. ",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 2
  },
  {
    "name": "BitsStreamGenerator.clear",
    "class_name": "org.apache.commons.math3.random.BitsStreamGenerator",
    "signature": "org.apache.commons.math3.random.BitsStreamGenerator.clear()",
    "snippet": "    public void clear() {\n        nextGaussian = Double.NaN;\n    }",
    "comment": " Clears the cache used by the default implementation of {@link #nextGaussian}. ",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 2
  },
  {
    "name": "RandomDataGenerator.RandomDataGenerator",
    "class_name": "org.apache.commons.math3.random.RandomDataGenerator",
    "signature": "org.apache.commons.math3.random.RandomDataGenerator.RandomDataGenerator()",
    "snippet": "    public RandomDataGenerator() {\n    }",
    "comment": " Construct a RandomDataGenerator, using a default random generator as the source of randomness.  <p>The default generator is a {@link Well19937c} seeded with {@code System.currentTimeMillis() + System.identityHashCode(this))}. The generator is initialized and seeded on first use.</p> ",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 2
  },
  {
    "name": "RandomDataImpl.RandomDataImpl",
    "class_name": "org.apache.commons.math3.random.RandomDataImpl",
    "signature": "org.apache.commons.math3.random.RandomDataImpl.RandomDataImpl()",
    "snippet": "    public RandomDataImpl() {\n        delegate = new RandomDataGenerator();\n    }",
    "comment": " Construct a RandomDataImpl, using a default random generator as the source of randomness.  <p>The default generator is a {@link Well19937c} seeded with {@code System.currentTimeMillis() + System.identityHashCode(this))}. The generator is initialized and seeded on first use.</p> ",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 2
  },
  {
    "name": "Well19937c.Well19937c",
    "class_name": "org.apache.commons.math3.random.Well19937c",
    "signature": "org.apache.commons.math3.random.Well19937c.Well19937c()",
    "snippet": "    public Well19937c() {\n        super(K, M1, M2, M3);\n    }",
    "comment": "Creates a new random number generator. <p>The instance is initialized using the current time as the seed.</p> ",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 2
  },
  {
    "name": "Beta.logBeta",
    "class_name": "org.apache.commons.math3.special.Beta",
    "signature": "org.apache.commons.math3.special.Beta.logBeta(double,double)",
    "snippet": "    public static double logBeta(double a, double b) {\n        return logBeta(a, b, DEFAULT_EPSILON, Integer.MAX_VALUE);\n    }",
    "comment": " Returns the natural logarithm of the beta function B(a, b).  @param a Parameter {@code a}. @param b Parameter {@code b}. @return log(B(a, b)). ",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 2
  },
  {
    "name": "Beta.logBeta",
    "class_name": "org.apache.commons.math3.special.Beta",
    "signature": "org.apache.commons.math3.special.Beta.logBeta(double,double,double,int)",
    "snippet": "    public static double logBeta(double a, double b,\n                                 double epsilon,\n                                 int maxIterations) {\n        double ret;\n\n        if (Double.isNaN(a) ||\n            Double.isNaN(b) ||\n            a <= 0.0 ||\n            b <= 0.0) {\n            ret = Double.NaN;\n        } else {\n            ret = Gamma.logGamma(a) + Gamma.logGamma(b) -\n                Gamma.logGamma(a + b);\n        }\n\n        return ret;\n    }",
    "comment": " Returns the natural logarithm of the beta function B(a, b).  The implementation of this method is based on: <ul> <li><a href=\"http://mathworld.wolfram.com/BetaFunction.html\"> Beta Function</a>, equation (1).</li> </ul>  @param a Parameter {@code a}. @param b Parameter {@code b}. @param epsilon When the absolute value of the nth item in the series is less than epsilon the approximation ceases to calculate further elements in the series. @param maxIterations Maximum number of \"iterations\" to complete. @return log(B(a, b)). ",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 2
  },
  {
    "name": "Gamma.invGamma1pm1",
    "class_name": "org.apache.commons.math3.special.Gamma",
    "signature": "org.apache.commons.math3.special.Gamma.invGamma1pm1(double)",
    "snippet": "    public static double invGamma1pm1(final double x) {\n\n        if (x < -0.5) {\n            throw new NumberIsTooSmallException(x, -0.5, true);\n        }\n        if (x > 1.5) {\n            throw new NumberIsTooLargeException(x, 1.5, true);\n        }\n\n        final double ret;\n        final double t = x <= 0.5 ? x : (x - 0.5) - 0.5;\n        if (t < 0.0) {\n            final double a = INV_GAMMA1P_M1_A0 + t * INV_GAMMA1P_M1_A1;\n            double b = INV_GAMMA1P_M1_B8;\n            b = INV_GAMMA1P_M1_B7 + t * b;\n            b = INV_GAMMA1P_M1_B6 + t * b;\n            b = INV_GAMMA1P_M1_B5 + t * b;\n            b = INV_GAMMA1P_M1_B4 + t * b;\n            b = INV_GAMMA1P_M1_B3 + t * b;\n            b = INV_GAMMA1P_M1_B2 + t * b;\n            b = INV_GAMMA1P_M1_B1 + t * b;\n            b = 1.0 + t * b;\n\n            double c = INV_GAMMA1P_M1_C13 + t * (a / b);\n            c = INV_GAMMA1P_M1_C12 + t * c;\n            c = INV_GAMMA1P_M1_C11 + t * c;\n            c = INV_GAMMA1P_M1_C10 + t * c;\n            c = INV_GAMMA1P_M1_C9 + t * c;\n            c = INV_GAMMA1P_M1_C8 + t * c;\n            c = INV_GAMMA1P_M1_C7 + t * c;\n            c = INV_GAMMA1P_M1_C6 + t * c;\n            c = INV_GAMMA1P_M1_C5 + t * c;\n            c = INV_GAMMA1P_M1_C4 + t * c;\n            c = INV_GAMMA1P_M1_C3 + t * c;\n            c = INV_GAMMA1P_M1_C2 + t * c;\n            c = INV_GAMMA1P_M1_C1 + t * c;\n            c = INV_GAMMA1P_M1_C + t * c;\n            if (x > 0.5) {\n                ret = t * c / x;\n            } else {\n                ret = x * ((c + 0.5) + 0.5);\n            }\n        } else {\n            double p = INV_GAMMA1P_M1_P6;\n            p = INV_GAMMA1P_M1_P5 + t * p;\n            p = INV_GAMMA1P_M1_P4 + t * p;\n            p = INV_GAMMA1P_M1_P3 + t * p;\n            p = INV_GAMMA1P_M1_P2 + t * p;\n            p = INV_GAMMA1P_M1_P1 + t * p;\n            p = INV_GAMMA1P_M1_P0 + t * p;\n\n            double q = INV_GAMMA1P_M1_Q4;\n            q = INV_GAMMA1P_M1_Q3 + t * q;\n            q = INV_GAMMA1P_M1_Q2 + t * q;\n            q = INV_GAMMA1P_M1_Q1 + t * q;\n            q = 1.0 + t * q;\n\n            double c = INV_GAMMA1P_M1_C13 + (p / q) * t;\n            c = INV_GAMMA1P_M1_C12 + t * c;\n            c = INV_GAMMA1P_M1_C11 + t * c;\n            c = INV_GAMMA1P_M1_C10 + t * c;\n            c = INV_GAMMA1P_M1_C9 + t * c;\n            c = INV_GAMMA1P_M1_C8 + t * c;\n            c = INV_GAMMA1P_M1_C7 + t * c;\n            c = INV_GAMMA1P_M1_C6 + t * c;\n            c = INV_GAMMA1P_M1_C5 + t * c;\n            c = INV_GAMMA1P_M1_C4 + t * c;\n            c = INV_GAMMA1P_M1_C3 + t * c;\n            c = INV_GAMMA1P_M1_C2 + t * c;\n            c = INV_GAMMA1P_M1_C1 + t * c;\n            c = INV_GAMMA1P_M1_C0 + t * c;\n\n            if (x > 0.5) {\n                ret = (t / x) * ((c - 0.5) - 0.5);\n            } else {\n                ret = x * c;\n            }\n        }\n\n        return ret;\n    }",
    "comment": " Returns the value of 1 / &Gamma;(1 + x) - 1 for -0&#46;5 &le; x &le; 1&#46;5. This implementation is based on the double precision implementation in the <em>NSWC Library of Mathematics Subroutines</em>, {@code DGAM1}.  @param x Argument. @return The value of {@code 1.0 / Gamma(1.0 + x) - 1.0}. @throws NumberIsTooSmallException if {@code x < -0.5} @throws NumberIsTooLargeException if {@code x > 1.5} ",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 2
  },
  {
    "name": "Gamma.logGamma",
    "class_name": "org.apache.commons.math3.special.Gamma",
    "signature": "org.apache.commons.math3.special.Gamma.logGamma(double)",
    "snippet": "    public static double logGamma(double x) {\n        double ret;\n\n        if (Double.isNaN(x) || (x <= 0.0)) {\n            ret = Double.NaN;\n        } else if (x < 0.5) {\n            return logGamma1p(x) - FastMath.log(x);\n        } else if (x <= 2.5) {\n            return logGamma1p((x - 0.5) - 0.5);\n        } else if (x <= 8.0) {\n            final int n = (int) FastMath.floor(x - 1.5);\n            double prod = 1.0;\n            for (int i = 1; i <= n; i++) {\n                prod *= x - i;\n            }\n            return logGamma1p(x - (n + 1)) + FastMath.log(prod);\n        } else {\n            double sum = lanczos(x);\n            double tmp = x + LANCZOS_G + .5;\n            ret = ((x + .5) * FastMath.log(tmp)) - tmp +\n                HALF_LOG_2_PI + FastMath.log(sum / x);\n        }\n\n        return ret;\n    }",
    "comment": " <p> Returns the value of log&nbsp;&Gamma;(x) for x&nbsp;&gt;&nbsp;0. </p> <p> For x &le; 8, the implementation is based on the double precision implementation in the <em>NSWC Library of Mathematics Subroutines</em>, {@code DGAMLN}. For x &gt; 8, the implementation is based on </p> <ul> <li><a href=\"http://mathworld.wolfram.com/GammaFunction.html\">Gamma Function</a>, equation (28).</li> <li><a href=\"http://mathworld.wolfram.com/LanczosApproximation.html\"> Lanczos Approximation</a>, equations (1) through (5).</li> <li><a href=\"http://my.fit.edu/~gabdo/gamma.txt\">Paul Godfrey, A note on the computation of the convergent Lanczos complex Gamma approximation</a></li> </ul>  @param x Argument. @return the value of {@code log(Gamma(x))}, {@code Double.NaN} if {@code x <= 0.0}. ",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 2
  },
  {
    "name": "Gamma.logGamma1p",
    "class_name": "org.apache.commons.math3.special.Gamma",
    "signature": "org.apache.commons.math3.special.Gamma.logGamma1p(double)",
    "snippet": "    public static double logGamma1p(final double x)\n        throws NumberIsTooSmallException, NumberIsTooLargeException {\n\n        if (x < -0.5) {\n            throw new NumberIsTooSmallException(x, -0.5, true);\n        }\n        if (x > 1.5) {\n            throw new NumberIsTooLargeException(x, 1.5, true);\n        }\n\n        return -FastMath.log1p(invGamma1pm1(x));\n    }",
    "comment": " Returns the value of log &Gamma;(1 + x) for -0&#46;5 &le; x &le; 1&#46;5. This implementation is based on the double precision implementation in the <em>NSWC Library of Mathematics Subroutines</em>, {@code DGMLN1}.  @param x Argument. @return The value of {@code log(Gamma(1 + x))}. @throws NumberIsTooSmallException if {@code x < -0.5}. @throws NumberIsTooLargeException if {@code x > 1.5}. ",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 2
  },
  {
    "name": "FastMath.exp",
    "class_name": "org.apache.commons.math3.util.FastMath",
    "signature": "org.apache.commons.math3.util.FastMath.exp(double)",
    "snippet": "    public static double exp(double x) {\n        return exp(x, 0.0, null);\n    }",
    "comment": " Exponential function.  Computes exp(x), function result is nearly rounded.   It will be correctly rounded to the theoretical value for 99.9% of input values, otherwise it will have a 1 UPL error.  Method: Lookup intVal = exp(int(x)) Lookup fracVal = exp(int(x-int(x) / 1024.0) * 1024.0 ); Compute z as the exponential of the remaining bits by a polynomial minus one exp(x) = intVal * fracVal * (1 + z)  Accuracy: Calculation is done with 63 bits of precision, so result should be correctly rounded for 99.9% of input values, with less than 1 ULP error otherwise.  @param x   a double @return double e<sup>x</sup> ",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 2
  },
  {
    "name": "FastMath.exp",
    "class_name": "org.apache.commons.math3.util.FastMath",
    "signature": "org.apache.commons.math3.util.FastMath.exp(double,double,double[])",
    "snippet": "    private static double exp(double x, double extra, double[] hiPrec) {\n        double intPartA;\n        double intPartB;\n        int intVal;\n\n        /* Lookup exp(floor(x)).\n         * intPartA will have the upper 22 bits, intPartB will have the lower\n         * 52 bits.\n         */\n        if (x < 0.0) {\n            intVal = (int) -x;\n\n            if (intVal > 746) {\n                if (hiPrec != null) {\n                    hiPrec[0] = 0.0;\n                    hiPrec[1] = 0.0;\n                }\n                return 0.0;\n            }\n\n            if (intVal > 709) {\n                /* This will produce a subnormal output */\n                final double result = exp(x+40.19140625, extra, hiPrec) / 285040095144011776.0;\n                if (hiPrec != null) {\n                    hiPrec[0] /= 285040095144011776.0;\n                    hiPrec[1] /= 285040095144011776.0;\n                }\n                return result;\n            }\n\n            if (intVal == 709) {\n                /* exp(1.494140625) is nearly a machine number... */\n                final double result = exp(x+1.494140625, extra, hiPrec) / 4.455505956692756620;\n                if (hiPrec != null) {\n                    hiPrec[0] /= 4.455505956692756620;\n                    hiPrec[1] /= 4.455505956692756620;\n                }\n                return result;\n            }\n\n            intVal++;\n\n            intPartA = ExpIntTable.EXP_INT_TABLE_A[EXP_INT_TABLE_MAX_INDEX-intVal];\n            intPartB = ExpIntTable.EXP_INT_TABLE_B[EXP_INT_TABLE_MAX_INDEX-intVal];\n\n            intVal = -intVal;\n        } else {\n            intVal = (int) x;\n\n            if (intVal > 709) {\n                if (hiPrec != null) {\n                    hiPrec[0] = Double.POSITIVE_INFINITY;\n                    hiPrec[1] = 0.0;\n                }\n                return Double.POSITIVE_INFINITY;\n            }\n\n            intPartA = ExpIntTable.EXP_INT_TABLE_A[EXP_INT_TABLE_MAX_INDEX+intVal];\n            intPartB = ExpIntTable.EXP_INT_TABLE_B[EXP_INT_TABLE_MAX_INDEX+intVal];\n        }\n\n        /* Get the fractional part of x, find the greatest multiple of 2^-10 less than\n         * x and look up the exp function of it.\n         * fracPartA will have the upper 22 bits, fracPartB the lower 52 bits.\n         */\n        final int intFrac = (int) ((x - intVal) * 1024.0);\n        final double fracPartA = ExpFracTable.EXP_FRAC_TABLE_A[intFrac];\n        final double fracPartB = ExpFracTable.EXP_FRAC_TABLE_B[intFrac];\n\n        /* epsilon is the difference in x from the nearest multiple of 2^-10.  It\n         * has a value in the range 0 <= epsilon < 2^-10.\n         * Do the subtraction from x as the last step to avoid possible loss of percison.\n         */\n        final double epsilon = x - (intVal + intFrac / 1024.0);\n\n        /* Compute z = exp(epsilon) - 1.0 via a minimax polynomial.  z has\n       full double precision (52 bits).  Since z < 2^-10, we will have\n       62 bits of precision when combined with the contant 1.  This will be\n       used in the last addition below to get proper rounding. */\n\n        /* Remez generated polynomial.  Converges on the interval [0, 2^-10], error\n       is less than 0.5 ULP */\n        double z = 0.04168701738764507;\n        z = z * epsilon + 0.1666666505023083;\n        z = z * epsilon + 0.5000000000042687;\n        z = z * epsilon + 1.0;\n        z = z * epsilon + -3.940510424527919E-20;\n\n        /* Compute (intPartA+intPartB) * (fracPartA+fracPartB) by binomial\n       expansion.\n       tempA is exact since intPartA and intPartB only have 22 bits each.\n       tempB will have 52 bits of precision.\n         */\n        double tempA = intPartA * fracPartA;\n        double tempB = intPartA * fracPartB + intPartB * fracPartA + intPartB * fracPartB;\n\n        /* Compute the result.  (1+z)(tempA+tempB).  Order of operations is\n       important.  For accuracy add by increasing size.  tempA is exact and\n       much larger than the others.  If there are extra bits specified from the\n       pow() function, use them. */\n        final double tempC = tempB + tempA;\n        final double result;\n        if (extra != 0.0) {\n            result = tempC*extra*z + tempC*extra + tempC*z + tempB + tempA;\n        } else {\n            result = tempC*z + tempB + tempA;\n        }\n\n        if (hiPrec != null) {\n            // If requesting high precision\n            hiPrec[0] = tempA;\n            hiPrec[1] = tempC*extra*z + tempC*extra + tempC*z + tempB;\n        }\n\n        return result;\n    }",
    "comment": " Internal helper method for exponential function. @param x original argument of the exponential function @param extra extra bits of precision on input (To Be Confirmed) @param hiPrec extra bits of precision on output (To Be Confirmed) @return exp(x) ",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 2
  },
  {
    "name": "FastMath.floor",
    "class_name": "org.apache.commons.math3.util.FastMath",
    "signature": "org.apache.commons.math3.util.FastMath.floor(double)",
    "snippet": "    public static double floor(double x) {\n        long y;\n\n        if (x != x) { // NaN\n            return x;\n        }\n\n        if (x >= TWO_POWER_52 || x <= -TWO_POWER_52) {\n            return x;\n        }\n\n        y = (long) x;\n        if (x < 0 && y != x) {\n            y--;\n        }\n\n        if (y == 0) {\n            return x*y;\n        }\n\n        return y;\n    }",
    "comment": "Get the largest whole number smaller than x. @param x number from which floor is requested @return a double number f such that f is an integer f <= x < f + 1.0 ",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 2
  },
  {
    "name": "FastMath.log",
    "class_name": "org.apache.commons.math3.util.FastMath",
    "signature": "org.apache.commons.math3.util.FastMath.log(double)",
    "snippet": "    public static double log(final double x) {\n        return log(x, null);\n    }",
    "comment": " Natural logarithm.  @param x   a double @return log(x) ",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 2
  },
  {
    "name": "FastMath.log",
    "class_name": "org.apache.commons.math3.util.FastMath",
    "signature": "org.apache.commons.math3.util.FastMath.log(double,double[])",
    "snippet": "    private static double log(final double x, final double[] hiPrec) {\n        if (x==0) { // Handle special case of +0/-0\n            return Double.NEGATIVE_INFINITY;\n        }\n        long bits = Double.doubleToLongBits(x);\n\n        /* Handle special cases of negative input, and NaN */\n        if ((bits & 0x8000000000000000L) != 0 || x != x) {\n            if (x != 0.0) {\n                if (hiPrec != null) {\n                    hiPrec[0] = Double.NaN;\n                }\n\n                return Double.NaN;\n            }\n        }\n\n        /* Handle special cases of Positive infinity. */\n        if (x == Double.POSITIVE_INFINITY) {\n            if (hiPrec != null) {\n                hiPrec[0] = Double.POSITIVE_INFINITY;\n            }\n\n            return Double.POSITIVE_INFINITY;\n        }\n\n        /* Extract the exponent */\n        int exp = (int)(bits >> 52)-1023;\n\n        if ((bits & 0x7ff0000000000000L) == 0) {\n            // Subnormal!\n            if (x == 0) {\n                // Zero\n                if (hiPrec != null) {\n                    hiPrec[0] = Double.NEGATIVE_INFINITY;\n                }\n\n                return Double.NEGATIVE_INFINITY;\n            }\n\n            /* Normalize the subnormal number. */\n            bits <<= 1;\n            while ( (bits & 0x0010000000000000L) == 0) {\n                --exp;\n                bits <<= 1;\n            }\n        }\n\n\n        if (exp == -1 || exp == 0) {\n            if (x < 1.01 && x > 0.99 && hiPrec == null) {\n                /* The normal method doesn't work well in the range [0.99, 1.01], so call do a straight\n           polynomial expansion in higer precision. */\n\n               /* Compute x - 1.0 and split it */\n                double xa = x - 1.0;\n                double xb = xa - x + 1.0;\n                double tmp = xa * HEX_40000000;\n                double aa = xa + tmp - tmp;\n                double ab = xa - aa;\n                xa = aa;\n                xb = ab;\n\n                final double[] lnCoef_last = LN_QUICK_COEF[LN_QUICK_COEF.length - 1];\n                double ya = lnCoef_last[0];\n                double yb = lnCoef_last[1];\n\n                for (int i = LN_QUICK_COEF.length - 2; i >= 0; i--) {\n                    /* Multiply a = y * x */\n                    aa = ya * xa;\n                    ab = ya * xb + yb * xa + yb * xb;\n                    /* split, so now y = a */\n                    tmp = aa * HEX_40000000;\n                    ya = aa + tmp - tmp;\n                    yb = aa - ya + ab;\n\n                    /* Add  a = y + lnQuickCoef */\n                    final double[] lnCoef_i = LN_QUICK_COEF[i];\n                    aa = ya + lnCoef_i[0];\n                    ab = yb + lnCoef_i[1];\n                    /* Split y = a */\n                    tmp = aa * HEX_40000000;\n                    ya = aa + tmp - tmp;\n                    yb = aa - ya + ab;\n                }\n\n                /* Multiply a = y * x */\n                aa = ya * xa;\n                ab = ya * xb + yb * xa + yb * xb;\n                /* split, so now y = a */\n                tmp = aa * HEX_40000000;\n                ya = aa + tmp - tmp;\n                yb = aa - ya + ab;\n\n                return ya + yb;\n            }\n        }\n\n        // lnm is a log of a number in the range of 1.0 - 2.0, so 0 <= lnm < ln(2)\n        final double[] lnm = lnMant.LN_MANT[(int)((bits & 0x000ffc0000000000L) >> 42)];\n\n        /*\n    double epsilon = x / Double.longBitsToDouble(bits & 0xfffffc0000000000L);\n\n    epsilon -= 1.0;\n         */\n\n        // y is the most significant 10 bits of the mantissa\n        //double y = Double.longBitsToDouble(bits & 0xfffffc0000000000L);\n        //double epsilon = (x - y) / y;\n        final double epsilon = (bits & 0x3ffffffffffL) / (TWO_POWER_52 + (bits & 0x000ffc0000000000L));\n\n        double lnza = 0.0;\n        double lnzb = 0.0;\n\n        if (hiPrec != null) {\n            /* split epsilon -> x */\n            double tmp = epsilon * HEX_40000000;\n            double aa = epsilon + tmp - tmp;\n            double ab = epsilon - aa;\n            double xa = aa;\n            double xb = ab;\n\n            /* Need a more accurate epsilon, so adjust the division. */\n            final double numer = bits & 0x3ffffffffffL;\n            final double denom = TWO_POWER_52 + (bits & 0x000ffc0000000000L);\n            aa = numer - xa*denom - xb * denom;\n            xb += aa / denom;\n\n            /* Remez polynomial evaluation */\n            final double[] lnCoef_last = LN_HI_PREC_COEF[LN_HI_PREC_COEF.length-1];\n            double ya = lnCoef_last[0];\n            double yb = lnCoef_last[1];\n\n            for (int i = LN_HI_PREC_COEF.length - 2; i >= 0; i--) {\n                /* Multiply a = y * x */\n                aa = ya * xa;\n                ab = ya * xb + yb * xa + yb * xb;\n                /* split, so now y = a */\n                tmp = aa * HEX_40000000;\n                ya = aa + tmp - tmp;\n                yb = aa - ya + ab;\n\n                /* Add  a = y + lnHiPrecCoef */\n                final double[] lnCoef_i = LN_HI_PREC_COEF[i];\n                aa = ya + lnCoef_i[0];\n                ab = yb + lnCoef_i[1];\n                /* Split y = a */\n                tmp = aa * HEX_40000000;\n                ya = aa + tmp - tmp;\n                yb = aa - ya + ab;\n            }\n\n            /* Multiply a = y * x */\n            aa = ya * xa;\n            ab = ya * xb + yb * xa + yb * xb;\n\n            /* split, so now lnz = a */\n            /*\n      tmp = aa * 1073741824.0;\n      lnza = aa + tmp - tmp;\n      lnzb = aa - lnza + ab;\n             */\n            lnza = aa + ab;\n            lnzb = -(lnza - aa - ab);\n        } else {\n            /* High precision not required.  Eval Remez polynomial\n         using standard double precision */\n            lnza = -0.16624882440418567;\n            lnza = lnza * epsilon + 0.19999954120254515;\n            lnza = lnza * epsilon + -0.2499999997677497;\n            lnza = lnza * epsilon + 0.3333333333332802;\n            lnza = lnza * epsilon + -0.5;\n            lnza = lnza * epsilon + 1.0;\n            lnza = lnza * epsilon;\n        }\n\n        /* Relative sizes:\n         * lnzb     [0, 2.33E-10]\n         * lnm[1]   [0, 1.17E-7]\n         * ln2B*exp [0, 1.12E-4]\n         * lnza      [0, 9.7E-4]\n         * lnm[0]   [0, 0.692]\n         * ln2A*exp [0, 709]\n         */\n\n        /* Compute the following sum:\n         * lnzb + lnm[1] + ln2B*exp + lnza + lnm[0] + ln2A*exp;\n         */\n\n        //return lnzb + lnm[1] + ln2B*exp + lnza + lnm[0] + ln2A*exp;\n        double a = LN_2_A*exp;\n        double b = 0.0;\n        double c = a+lnm[0];\n        double d = -(c-a-lnm[0]);\n        a = c;\n        b = b + d;\n\n        c = a + lnza;\n        d = -(c - a - lnza);\n        a = c;\n        b = b + d;\n\n        c = a + LN_2_B*exp;\n        d = -(c - a - LN_2_B*exp);\n        a = c;\n        b = b + d;\n\n        c = a + lnm[1];\n        d = -(c - a - lnm[1]);\n        a = c;\n        b = b + d;\n\n        c = a + lnzb;\n        d = -(c - a - lnzb);\n        a = c;\n        b = b + d;\n\n        if (hiPrec != null) {\n            hiPrec[0] = a;\n            hiPrec[1] = b;\n        }\n\n        return a + b;\n    }",
    "comment": " Internal helper method for natural logarithm function. @param x original argument of the natural logarithm function @param hiPrec extra bits of precision on output (To Be Confirmed) @return log(x) ",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 2
  },
  {
    "name": "FastMath.log1p",
    "class_name": "org.apache.commons.math3.util.FastMath",
    "signature": "org.apache.commons.math3.util.FastMath.log1p(double)",
    "snippet": "    public static double log1p(final double x) {\n        if (x == -1) {\n            return Double.NEGATIVE_INFINITY;\n        }\n\n        if (x == Double.POSITIVE_INFINITY) {\n            return Double.POSITIVE_INFINITY;\n        }\n\n        if (x > 1e-6 ||\n            x < -1e-6) {\n            final double xpa = 1 + x;\n            final double xpb = -(xpa - 1 - x);\n\n            final double[] hiPrec = new double[2];\n            final double lores = log(xpa, hiPrec);\n            if (Double.isInfinite(lores)) { // Don't allow this to be converted to NaN\n                return lores;\n            }\n\n            // Do a taylor series expansion around xpa:\n            //   f(x+y) = f(x) + f'(x) y + f''(x)/2 y^2\n            final double fx1 = xpb / xpa;\n            final double epsilon = 0.5 * fx1 + 1;\n            return epsilon * fx1 + hiPrec[1] + hiPrec[0];\n        } else {\n            // Value is small |x| < 1e6, do a Taylor series centered on 1.\n            final double y = (x * F_1_3 - F_1_2) * x + 1;\n            return y * x;\n        }\n    }",
    "comment": " Computes log(1 + x).  @param x Number. @return {@code log(1 + x)}. ",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 2
  },
  {
    "name": "FastMathLiteralArrays.loadExpFracA",
    "class_name": "org.apache.commons.math3.util.FastMathLiteralArrays",
    "signature": "org.apache.commons.math3.util.FastMathLiteralArrays.loadExpFracA()",
    "snippet": "    static double[] loadExpFracA() {\n        return EXP_FRAC_A.clone();\n    }",
    "comment": " Load \"EXP_FRAC_A\".  @return a clone of the data array. ",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 2
  },
  {
    "name": "FastMathLiteralArrays.loadExpFracB",
    "class_name": "org.apache.commons.math3.util.FastMathLiteralArrays",
    "signature": "org.apache.commons.math3.util.FastMathLiteralArrays.loadExpFracB()",
    "snippet": "    static double[] loadExpFracB() {\n        return EXP_FRAC_B.clone();\n    }",
    "comment": " Load \"EXP_FRAC_B\".  @return a clone of the data array. ",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 2
  },
  {
    "name": "FastMathLiteralArrays.loadExpIntA",
    "class_name": "org.apache.commons.math3.util.FastMathLiteralArrays",
    "signature": "org.apache.commons.math3.util.FastMathLiteralArrays.loadExpIntA()",
    "snippet": "    static double[] loadExpIntA() {\n        return EXP_INT_A.clone();\n    }",
    "comment": " Load \"EXP_INT_A\".  @return a clone of the data array. ",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 2
  },
  {
    "name": "FastMathLiteralArrays.loadExpIntB",
    "class_name": "org.apache.commons.math3.util.FastMathLiteralArrays",
    "signature": "org.apache.commons.math3.util.FastMathLiteralArrays.loadExpIntB()",
    "snippet": "    static double[] loadExpIntB() {\n        return EXP_INT_B.clone();\n    }",
    "comment": " Load \"EXP_INT_B\".  @return a clone of the data array. ",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 2
  },
  {
    "name": "FastMathLiteralArrays.loadLnMant",
    "class_name": "org.apache.commons.math3.util.FastMathLiteralArrays",
    "signature": "org.apache.commons.math3.util.FastMathLiteralArrays.loadLnMant()",
    "snippet": "    static double[][] loadLnMant() {\n        return LN_MANT.clone();\n    }",
    "comment": " Load \"LN_MANT\".  @return a clone of the data array. ",
    "is_bug": false,
    "failing_test_cases": 2,
    "buggy_methods": 2
  }
]